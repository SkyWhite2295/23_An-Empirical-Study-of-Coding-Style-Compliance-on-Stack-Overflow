12270246,12269438,1,"<p>If my understanding from comments is correct - you want something like that:</p>

<pre><code>U* create_T() { return new U; }
if (T t = create_T())
{
  // do something with t
}
</code></pre>

<p>The problem here, already mentioned in comments: this syntax <code>T t = u</code> is just calling copy constructor. If u is of type <code>T</code> it is equivalent to: <code>T t(u)</code>. If <code>u</code>, like in your example, is of another type convertible to <code>T</code> (<code>here by T::T(U*)</code>) then it is actually this: <code>T t(T(u))</code>. So here you have the copy contructor for which compiler complains. </p>

<p>There is no solution, because this is not valid <code>if</code> syntax:</p>

<pre><code>if (T i(create_T())) {}
</code></pre>

<p>However I would not write all of these without good advise ;)</p>

<p>You can forget about problems with copy constructor with this syntax:</p>

<pre><code>if (U* u = create_T()) {
   T t(u);
   ....
} 
</code></pre>

<p>BTW, <code>std::auto_ptr</code> has the same problem as your <code>T</code> type. Just add explicit to your <code>T(U*)</code> constructor and you will see similarity to <code>auto_ptr</code>:</p>

<pre><code>class U {};

class T : boost::noncopyable {
public:
    explicit T(U *p) : p_(p) {
    }

    ~T() {
        delete p_;
    }

private:
    U *p_;
};

int main() {
    T x = new U; // allowed
    T y(new U);  // allowed
    std::auto_ptr&lt;U&gt; a = new U;
    std::auto_ptr&lt;U&gt; b(new U);
}
</code></pre>

<p>Results in:</p>

<pre><code>prog.cpp:25: error: conversion from ¡®U*¡¯ to non-scalar type ¡®T¡¯ requested
prog.cpp:27: error: conversion from ¡®U*¡¯ to non-scalar type ¡®std::auto_ptr&lt;U&gt;¡¯ requested
</code></pre>

<p>Here my <a href=""http://ideone.com/jz3RT"" rel=""nofollow"">ideone</a> study...</p>
",4
9195739,140935,1,"<blockquote>
  <p>This is not possible in C++, it will give you an error about redefining already-defined 
  classes. If you'd like to share behavior, consider inheritance.</p>
</blockquote>

<p>I do agree on this. Partial classes is strange construct that makes it very difficult to maintain afterwards. It is difficult to locate on which partial class each member is declared and redefinition or even reimplementation of features are hard to avoid.</p>

<p>Do you want to extend the std::vector, you have to inherit from it. This is because of several reasons. First of all you change the responsibility of the class and (properly?) its class invariants. Secondly, from a security point of view this should be avoided. 
Consider a class that handles user authentication... </p>

<pre><code>partial class UserAuthentication {
  private string user;
  private string password;
  public bool signon(string usr, string pwd);
}

partial class UserAuthentication {
  private string getPassword() { return password; }
}
</code></pre>

<p>A lot of other reasons could be mentioned...</p>
",1
15499524,15499437,0,"<p>No. It has no external visibility.</p>
",0
15499544,15499437,2,"<p>The <code>static</code> variable is not part of the function's interface, so it won't affect binary compatibility. You should be aware, none the less, that if the function is really that simple, it might have been inlined in which case unless you recompile all users you will be breaking the ODR.</p>

<p>Simple advice: recompile if at all possible. Make sure that it was not inlined in the original code if not possible.</p>
",0
15499930,15499437,1,"<p>It does not break binary compatibility in the sense that something is certain to crash, or that program will not start.</p>

<p>However, it may well break functionality, if that method ever got inlined. Inlined versions will still access that static variable, and then code built against new header file will produce methods which do not use the static variable. It depends on code if this is a problem or not, but often it is, the static variable (which will not be used by recompiled code) probably wasn't there just for fun, and neither is the replacement (which will not be used by old inlined code).</p>

<p>Lesson: If you want to avoid recompilation of everything after library header modification, do not access static variables from any code in header files, or do anything else which you might want to change. Assume all code in header files may get inlined.</p>

<p>Related question: <a href=""https://stackoverflow.com/questions/185624/static-variables-in-an-inlined-function"">static variables in an inlined function</a></p>
",0
18943634,2841315,0,"<p>Although pure C++ doesn't have notions of class at run-time, there are libraries that provide such functionality. </p>

<p>Qt has a meta-object system that provides run-time class reflection/introspection, dynamic properties, and async communication.</p>

<p><a href=""http://qt-project.org/doc/qt-4.8/qmetaobject.html#details"" rel=""nofollow"">http://qt-project.org/doc/qt-4.8/qmetaobject.html#details</a></p>

<p>Also, CERN's ROOT provides similar capabilities. See TObject and TClass.</p>

<p><a href=""http://root.cern.ch/drupal/content/reflex"" rel=""nofollow"">http://root.cern.ch/drupal/content/reflex</a></p>

<p>Both are cross-platform and fairly tool chain compatible. For larger and more complex projects especially, something like these can remove many of the drawbacks of using C++ compared to other languages.</p>
",0
11502363,212006,-1,"<pre><code>//Baseclass.h  or  .cpp

#ifndef CDerivedclass
#include ""Derivedclass.h""
#endif

or
//COthercls.h    or .cpp

#ifndef CCommonheadercls
#include ""Commonheadercls.h""
#endif

I think this suffice all instances.
</code></pre>
",0
13408763,77293,0,"<p>Change the message as below. This may be the simplest way I think.</p>

<pre><code>DialogResult result = MessageBox::Show(
       ""This may take awhile, do you wish to continue?**\nClick Yes to continue.\nClick No to cancel.**"",
       ""Warning"",
       MessageBoxButtons::YesNo,
       MessageBoxIcon::Exclamation
);
</code></pre>
",0
18709715,370283,0,"<p>here is my understanding based on Stroustrup's statement about in-class definition </p>

<blockquote>
  <p>A class is typically declared in a header file and a header file is
  typically included into many translation units. However, to avoid
  complicated linker rules, C++ requires that every object has a unique
  definition. That rule would be broken if C++ allowed in-class
  definition of entities that needed to be stored in memory as objects.</p>
</blockquote>

<p><a href=""http://www.stroustrup.com/bs_faq2.html#in-class"" rel=""nofollow"">http://www.stroustrup.com/bs_faq2.html#in-class</a></p>

<p>so basically, this is not allowed because C++ do not allow this. In order to make linker rules more simple, C++ requires that every object has a unique definition.</p>

<p>static member has only one instance in the class scope, not like regular static variables used heavily in C, which has only one instatnce inside one translation unit. </p>

<p>If static member is defined in class, and the class definition will be included into many translation unit, so that the linker has to do more work to decide which static member should be used as the only one through all the related translation unit. </p>

<p>But for regular static variables, they can only be used inside one translation unit, even in the case different static variables in different translation unit with same name, they will not affect each other. Linker can do simple work to link regular static variables inside one translation unit.</p>

<p>in order to decrease the complications and give the base function, C++ provide the only in-class definition for a static const of integral or enumeration type.</p>
",0
8801355,8801213,5,"<p>If you absolutely need the results as a string, you'll have to measure,
but I doubt that anything will be significantly faster than the most 
intuitive:</p>

<pre><code>std::string
getTrailer( std::string const&amp; original, std::string const&amp; key )
{
    std::string::const_iterator pivot
        = std::search( original.begin(), original.end(), key.begin(), key.end() );
    return pivot == original.end()
        ? std::string()  // or some error condition...
        : std::string( pivot + key.size(), original.end() );
}
</code></pre>

<p>However, the fastest way is probably not to extract the string at all,
but to simply keep it as a pair of iterators.  If you need this a lot,
it might be worth defining a <code>Substring</code> class which encapsulates this.
(I've found a mutable variant of this to be very effective when
parsing.)  If you go this way, don't forget that the iterators will
become invalid if the original string disappears; be sure to convert
anything you want to keep into a string before this occurs.</p>
",1
8801366,8801213,0,"<p>you can use <code>std::string::find()</code> : </p>

<p>if its a char* than just move the pointer to the position right after ""url=""</p>

<pre><code>yourstring = (yourstring + yourstring.find(""url="")+4 );
</code></pre>

<p>I cant think of anything faster..</p>
",0
8801585,8801213,0,"<p>You could also look into the boost libraries.
For example <a href=""http://www.boost.org/doc/libs/1_41_0/doc/html/boost/algorithm/split_id1113872.html"" rel=""nofollow"">boost::split()</a></p>

<p>I don't know how they actually perform in terms of speed, but it's definitely worth a try.</p>
",1
8801592,8801213,2,"<pre><code>std::string inStr;

//this step is necessary
size_t pos = inStr.find(""url="")£»

if(pos !=  std::string::npos){
  char const * url = &amp;inStr[pos + 4];
  // it is fine to  do any read only operations with url
  // if you would apply some modifications to url, please make a copy string
}
</code></pre>
",0
9844866,9844684,0,"<p>I've recently decided to do this. I like doing it as a sort of consistency with <code>const &amp;</code> and <code>const *</code> parameters. const correctness makes life better, so why not go all in for it? If you know you're not going to change the value, why not make it const? Making it const communicates that intention clearly.</p>
",0
9844701,9844684,5,"<p>The top-level <code>const</code> here affects only the definition of the function and only prevents you from modifying the value of <code>nValue</code> in the function.</p>

<p>The top-level <code>const</code> does not affect the function declaration.  The following two declarations are exactly the same:</p>

<pre><code>void foo(size_t nValue);
void foo(const size_t nValue);
</code></pre>
",4
9844707,9844684,0,"<p>Using const you also ensure that you're not incorrectly trying to alter the value of the parameter inside the function, regardless if the parameter is modifiable or not.</p>
",0
9844708,9844684,4,"<p>Of course there is. You can't modify <code>nValue</code> inside the function.</p>

<p>As with <code>const</code>-ness in general, it's not a security measure, since you can cast it away, but a design matter. </p>

<p>You're explicitly telling other programmers that see your code - </p>

<blockquote>
  <p>""I will not modify <code>nValue</code> inside this function</p>
</blockquote>

<p>and programmers that maintain or change your code </p>

<blockquote>
  <p>""If you want to modify <code>nValue</code>, you're probably doing something wrong. You shouldn't need to do this"".</p>
</blockquote>
",1
9844753,9844684,0,"<p>if you define the input parameter const, you can just call const functions on that object.</p>

<p>anyway if you try to change that object accidentally, you will get a compiler error.</p>
",0
11544631,300208,1,"<p>In C++11 you can write ( in case of void ) :</p>

<pre><code>somecondition ? foo() : [] {} () ;
</code></pre>

<p>So the NOP is actually an empty lambda.
Besides void you could return any type and value.</p>

<p>This might look a bit overkill all by itself but suppose you have this :</p>

<pre><code>somecondition1 ? foo1() :
somecondition2 ? foo2() :
somecondition3 ? foo3() :
                 flip_out_because_unhandled_condition() ;
</code></pre>

<p>Now if someone adds somecondition4, but forgets to include it in the handling code, the software will call the flip_out_... function causing all kinds of unwanted effects.
But maybe somecondition4 doesn't need any special attention, it just needs to be ignored.
Well then you could write :</p>

<pre><code>somecondition1 ? foo1()   :
somecondition2 ? foo2()   :
somecondition3 ? foo3()   :
somecondition4 ? []{}() :
                 flip_out_because_unhandled_condition() ;
</code></pre>
",0
18212056,18209404,1,"<p>I agree with Maxim Yegorushkin's answer that it is best to try to use static mechanisms, but here's a couple of runtime approaches that meet the requirement of keeping the behavior and the function name together.</p>

<p>Approach #1, Command Object:</p>

<pre><code>class AbstractCommand{
public:
    virtual ~AbstractCommand() {}
    virtual void exec() = 0;
    virtual const char *commandName() const = 0;
};

class Command1 : public AbstractCommand{
public:
    virtual void exec() { /* do stuff */ }
    virtual const char *commandName() const { return ""command name 1""; }
};

class Command2 : public AbstractCommand{
public:
    virtual void exec() { /* do stuff */ }
    virtual const char *commandName() const { return ""command name 2""; }
};

static AbstractCommand *s_commands[] {
    new Command1(),
    new Command2(),
    ...,
    0
};
</code></pre>

<p>Approach #2, function with selector:</p>

<pre><code>enum CommandExecOption { GET_NAME, EXEC };

typedef void* (*command_func_t)( CommandExecOption opt );

void *Command1Func( CommandExecOption opt )
{
    switch(opt){
    case GET_NAME: return ""command 1""; break;
    case EXEC:
        /* do stuff */
        break;
    }
    return 0;
}

void *Command2Func( CommandExecOption opt )
{
    switch(opt){
    case GET_NAME: return ""command 2""; break;
    case EXEC:
        /* do stuff */
        break;
    }
    return 0;
}

command_func_t s_commands[] = { 
    Command1Func,
    Command2Func,
    ...,
    0
};
</code></pre>
",0
16440879,16440777,8,"<p>You're writing ASCII to your file, not binary.</p>

<p>Try writing your array like this instead of using <code>fprintf</code> in a loop.</p>

<pre><code>fwrite(db_, sizeof(db_[0]), dbsize, f);
</code></pre>

<p><code>fprintf</code> always formats numbers and other types to text, whether you've opened the file in binary mode or not. Binary mode just keeps the runtime from doing things like converting <code>\n</code> to <code>\r\n</code>.</p>
",3
16440960,16440777,2,"<p><code>fprintf</code> will convert you number to a series of ASCII characters and write them to a file. Depending on its value, a 32-bit int will be from 1 to 10 characters long when expressed as a string. You need to use <code>fwrite</code> to write raw binary values to a file.</p>
",0
16441027,16440777,2,"<p>The source of confusion is likely to be that the ""b"" in <code>FILE* f = fopen(fname, ""wb"");</code> <a href=""https://stackoverflow.com/questions/229924/difference-between-files-writen-in-binary-and-text-mode?rq=1"">does not do what you think it does</a>.</p>

<p>Most significantly, it doesn't change any of the print or scan statements to use binary values instead of ASCII values.  Like others have said - use <code>fwrite</code> instead.</p>
",0
18233985,18233825,1,"<p>When you say a = MyClass( 2 ); you apply the default assignment operator to the object a. In this case the value of a.myVar shall change to 2.</p>

<p>Instead try:</p>

<pre><code>int main(int argc, const char * argv[])
{
    MyClass a( 1 );
    MyClass b( 2 );
    return 0;
}
</code></pre>
",1
18233991,18233825,3,"<pre><code>a = MyClass(2);
</code></pre>

<p>Uses the copy assignment operator <code>operator=</code> provided by the compiler. This is the reason why you see <code>destructing 2</code>.</p>

<p>So during the copy, a.myVar get the value <code>2</code> instead of <code>1</code>.</p>

<p>The temporary object is destroyed after the semicolon of the line :</p>

<pre><code>a = MyClass(2);
//             ^- Here
</code></pre>

<p>And at the end of the block, <code>a</code> is also destructed.</p>

<hr>

<p>All the process here :</p>

<pre><code>int main(int argc, const char * argv[])
{
    MyClass a = MyClass(1);    // Create an object
    a = MyClass(2); // Create a temporary object and use the operator= to proceed to the copy, now a.intVar = 2
                // ^- Here the temporary object is destructed 
    return 0;
}               // a is now destructed
</code></pre>
",0
18234273,18233825,2,"<pre><code>MyClass a = MyClass(1);
</code></pre>

<p>This constructs an object with value 1, so you see</p>

<pre><code>constructing 1
</code></pre>

<p>then</p>

<pre><code>a = MyClass(2);
</code></pre>

<p>constructs a temporary object with value 2, so you see </p>

<pre><code>constructing 2
</code></pre>

<p>the temporary object is assigned to <code>a</code>, giving <code>a</code> the same value, 2, then the temporary goes out of scope and is destroyed, so you see</p>

<pre><code>destructing 2
</code></pre>

<p>Then at the end of <code>main</code> the variable <code>a</code> gets destroyed, and since it was re-assigned a new value you see</p>

<pre><code>destructing 2
</code></pre>

<p>This is C++, not Java or C#, so <code>a</code> is an object not a reference. The line <code>a = MyClass(2);</code> doesn't make <code>a</code> refer to a different object, it modifies the object <code>a</code> to be a copy of the other object.</p>
",4
13778914,13778782,2,"<pre><code>#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

struct blocker
{
  blocker () : done (false) {}

  void
  notify ()
  {
    std::unique_lock&lt;std::mutex&gt; lock (m);
    done = true;
    c.notify_all (); 
  }

  void
  wait ()
  {
    std::unique_lock&lt;std::mutex&gt; lock (m);
    while (!done)
      c.wait (lock);
  }

  bool done;
  std::mutex m;
  std::condition_variable c;
};
</code></pre>
",3
11117611,11080225,0,"<p>I've solved my problem. Here is the code which is nicely concise.
The signal is also a template class which simply defines the message types it may emit. 
Thus, when connecting the signal with a slot, the Link constructor can check the polymorphic compatibility of the message type emitted by the signal and the message type accepted by the slot. It then copies the appropriate function pointer whether a dynamic cast is required or not. What is not shown here is the Type class and how it is used to check message type compatibility.  </p>

<p>The answer was how to define the two slot functions and their function pointers. </p>

<p>Here is an example how the slots would be defined in a class:</p>

<pre><code>class MyAction : public Action
{
public:
    //! Define shared pointer on object
    typedef std::shared_ptr&lt;MyAction&gt; Ptr;

    //! Constructor
    MyAction( const std::string&amp; name )
        : Action(name),
          m_slotMsgM( this ),
          m_slotMsgA( this ),
          m_slotMsgB( this )
    {
    }

    //! Register the slots with their name for dynamic linking
    void configure()
    {
        add(""processMsgM"", &amp;m_slotMsgM );
        add(""processMsgA"", &amp;m_slotMsgA );
        add(""processMsgB"", &amp;m_slotMsgB );
    }

    //! Slot method 
    void processMsgM( Message::Ptr msg, Link * link = nullptr )
    {
        cout &lt;&lt; ""MyAction::processMsgM: Msg "" &lt;&lt; msg-&gt;type().name() &lt;&lt; endl;
    }

    //! Slot method 
    void processMsgA( MsgA::Ptr msg, Link * link = nullptr )
    {
        cout &lt;&lt; ""MyAction::processMsgA: Msg "" &lt;&lt; msg-&gt;type().name() &lt;&lt; endl;
    }

    //! Slot method 
    void processMsgB( MsgB::Ptr msg, Link * link = nullptr )
    {
        cout &lt;&lt; ""MyAction::processMsgB: Msg "" &lt;&lt; msg-&gt;type().name() &lt;&lt; endl;
    }

protected:
    //! Define slots
    SlotT&lt;MyAction, Message, &amp;MyAction::processMsgM&gt; m_slotMsgM;
    SlotT&lt;MyAction, MsgA, &amp;MyAction::processMsgA&gt; m_slotMsgA;
    SlotT&lt;MyAction, MsgB, &amp;MyAction::processMsgB&gt; m_slotMsgB;
};
</code></pre>

<p>Here is the Slot and SlotT classes definition.</p>

<pre><code>class Link;
typedef std::set&lt;Link*&gt; LinkSet;

//! Base class for Slot template class
class Slot
{
    friend class Link;
public:
    //! Slot function pointer
    typedef std::function&lt;void ( Message::Ptr, Link* )&gt; Function;

    //! Disconnect all links
    ~Slot();

    //! Return the type of message accepted by this Slot function
    const TypeDef&amp; messageType() const { return m_msgType; }

    //! Return slot function applying a dynamic cast on the message pointer
    Function getDynamicCastFunction() const
        { return m_dynamicCastFunction; }

    //! Return slot function applying a static cast on the message pointer
    Function getStaticCastFunction() const
        { return m_staticCastFunction; }

    //! Operator () using the dynamic cast
    void operator()(Message::Ptr msg, Link * link = nullptr )
        { m_dynamicCastFunction( msg, link); }

protected:

    //! Construct Slot by derived class instance construction only
    Slot( const TypeDef&amp; type, Function dynamicCastFunction,
          Function staticCastFunction ) :
        m_msgType(type),
        m_dynamicCastFunction(dynamicCastFunction),
        m_staticCastFunction(staticCastFunction)
    {
    }

    //! Insert link in set
    void connect( Link* link )
        { m_links.insert( link ); }

    //! Remove link from set
    void disconnect( Link* link )
        { m_links.erase( link ); }

    //! Set of active links
    LinkSet m_links;

    //! Type of accepted messages
    const TypeDef&amp; m_msgType;

    //! Slot method usind dynamic cast on message pointer
    const Function m_dynamicCastFunction;

    //! Slot method using static cast on message pointer
    const Function m_staticCastFunction;
};


template &lt;class TObj, class TMsg, 
          void (TObj::*TMethod)(typename TMsg::Ptr, Link*)&gt;
class SlotT : public Slot
{
public:

    //! SlotT constructor with templated type
    SlotT( TObj* obj )
        : Slot(TMsg::Type(),
          std::bind( &amp;SlotT&lt;TObj,TMsg,TMethod&gt;::dynamicCastFunction, obj,
                                      std::placeholders::_1,
                                      std::placeholders::_2 ),
          std::bind( &amp;SlotT&lt;TObj,TMsg,TMethod&gt;::staticCastFunction, obj,
                                           std::placeholders::_1,
                                           std::placeholders::_2 ) )
    {
    }

private:
    //! dynamic cast function
    static void dynamicCastFunction( TObj* obj, 
                                     typename Message::Ptr msg, 
                                     Link* link )
    {
        typename TMsg::Ptr m = std::dynamic_pointer_cast&lt;TMsg&gt;(msg);
        if( m &amp;&amp; obj )
            (obj-&gt;*TMethod)(m, link);
    }

    //! static cast function
    static void staticCastFunction( TObj* obj, 
                                    typename Message::Ptr msg, 
                                    Link* link )
    {
        typename TMsg::Ptr m = std::static_pointer_cast&lt;TMsg&gt;(msg);
        if( m &amp;&amp; obj )
            (obj-&gt;*TMethod)(m, link);
    }    
};
</code></pre>
",0
16949513,16948732,3,"<p>Warning! Not tested.</p>

<p>You could use a compile-time map to connect the flags to the type of objects to pass:</p>

<pre><code>template &lt; unsigned tflags, typename ttype &gt;
struct kv
{
    static const unsigned flags = tflags;
    using type = ttype;
};


using flag_type_map = std::tuple
    &lt;
        kv&lt;syn|ack, receive_syn_ack&gt;,
        kv&lt;syn    , receive_syn    &gt;,
        kv&lt;fin|ack, receive_fin_ack&gt;,
        kv&lt;fin    , receive_fin    &gt;,
        kv&lt;ack    , receive_ack    &gt;
    &gt;;
</code></pre>

<p>In order to process this at run-time, you'd have to do some kind of iteration or recursion. If the compiler is smart enough (and inlines), you could get the same performance.</p>

<pre><code>template &lt; typename &gt;
struct tuple_pop;

  template &lt; typename T, typename... TT &gt;
  struct tuple_pop &lt; std::tuple &lt; T, TT... &gt; &gt;
  {
      using type = std::tuple &lt; TT... &gt;;
  };

template &lt; typename T &gt;
void call(unsigned flags, std::true_type)
{
    throw std::invalid_argument(""flag combination not known / invalid"");
}

template &lt; typename T &gt;
void call(unsigned flags, std::false_type = {})
{
    using tuple_first = typename std::tuple_element&lt;0, T&gt;::type;
    using tuple_popped = typename tuple_pop&lt;T&gt;::type;
    using is_last = std::integral_constant&lt;bool,
                                           0 == -1+std::tuple_size&lt;T&gt;::value &gt;;

    if(flags == tuple_first::flags)
    {
        // could replace this hard-wired call with a passed function object
        // to make it more generic
        state_machine.process_event( typename tuple_first::type{} );
    }else
    {
        create_obj&lt;tuple_popped&gt;(flags, is_last{});
    }
}

void receive(const Segment&amp; segment)
{
    call&lt;flag_type_map&gt;(segment.getFlags());
}
</code></pre>
",0
16949998,16948732,2,"<p>I think the following should work (untested code), and with not too many flags should still be quite efficient ¡ª O(log n), but with fast iteration:</p>

<pre><code>// your enum
enum: unsigned
{
  fin = (1 &lt;&lt; 0),
  syn = (1 &lt;&lt; 1),
  ack = (1 &lt;&lt; 4)
  // etc...
};

// this is used for the magic:
unsigned all = fin|syn|ack|...;

// this replaces your individual receive types:
template&lt;unsigned&gt; struct receive {};

// this is the magic translation to compile time
template&lt;unsigned bit = 1, unsigned mask = all, unsigned value = 0&gt; struct call
{
  void process(state_machine_type&amp; state_machine, unsigned flags)
  {
    if (flags &amp; bit)
      call&lt;(bit &lt;&lt; 1), mask &amp; ~bit, value | bit&gt;::process(state_machine, flags);
    else
      call&lt;(bit &lt;&lt; 1), mask &amp; ~bit, value&gt;::process(state_machine, flags);
  }
};

template&lt;unsigned bit, unsigned value&gt; struct call&lt;bit, 0, value&gt;
{
  void process(state_machine_type&amp; state_machine, unsigned)
  {
    state_machine.process_event(receive&lt;value&gt;{});
  }
};

// the rewrite of your receive function
void receive(const Segment&amp; segment)
{
  call&lt;&gt;::process(state_machine, segment.getFlags());
}
</code></pre>
",2
17088980,17088900,5,"<p>The implementations are not the same.  What will happen in either implementation if a and b are equal?  One will return a reference to a one will return a reference to b.  The values of course are identical.  But consider a struct in which the compare function only cared about one value, but some other values were different.  This could have dramatic implications on sorting functions attempting to guarantee a stable sort.</p>

<p>Ultimately it's a style choice, in the event of equality should we return the first or second parameter?  However, now that this style choice has been made, that it remains the same is very important, this is why things like standards definitions exist!  </p>

<p><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf"" rel=""nofollow"">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a></p>

<p>Search for ""25.4.7"" regarding maximum and minimum.</p>
",7
17088983,17088900,6,"<p>The two different implementations would determine whether you choose the first or the second object as minimum if they are equal, which may make a difference for objects, if not for primitive types.</p>
<p>This, coupled with implementation of some other algorithms could have a larger impact. For example, if a sort algorithm uses <code>min(a[i], a[j])</code> where <code>i &lt; j</code> and <code>a[i]</code> and <code>a[j]</code> have the same value, the first implementation would result in no swap between the elements while the second does, making the sort unstable.</p>
<hr />
<p>Note: As <a href=""https://stackoverflow.com/questions/17088900/implementation-of-stdmin/17089637#comment24719041_17088900"">BoBTFish</a> mentioned, the C++11 standard guarantees that both min and max return the left most minimum:</p>
<blockquote>
<p>25.4.7:</p>
<p>3 <em>Remarks:</em> Returns the first argument when the arguments are equivalent</p>
<p>6 <em>Remarks:</em> Returns a copy of the leftmost argument when several arguments are equivalent to the smallest</p>
</blockquote>
",6
17089637,17088900,-2,"<p>-- INCORRECT ANSWER -- SEE COMMENTS -- bb</p>

<p>FWIW, it hasn't been my observation that STL was written to be especially easy to read, necessarily, but it's beautifully simple; in this case, the only other possible way to get the same result would be </p>

<pre><code>return (a &lt;= b) ? a : b;
</code></pre>

<p>which would be one more character, and, IMHO, actually not as easy to read.  Additionally, see @Shahbaz 's commentary above on sort stability--operations like min have a well-defined behavior for inclusivity and exclusivity. </p>

<p>TL;DR because ""Less than"" is not the same as ""Less than or equal to""</p>

<p>See comments below--this answer would be correct as a macro in C but actually is incorrect in C++ for reasons explained in the comments below.  I'm marking this as incorrect but leaving it up because the comments are useful and important to understand.  I apologize if I confused the issue for anyone.</p>
",11
17806668,1692319,0,"<p>This is possible with a void pointer taking function. You would simply have to create a as a void* then have it point to one of your chosen variables. Then your function can simply handle which type it is. For example:</p>

<pre><code>void *a;
int b;
char c;
double d;
char typeofa;
if(foo == 1){
    a = &amp;b;
    typeofa = 0;
} else if(foo == 2){
    a = &amp;c;
    typeofa = 1;
} else {
    a = &amp;d
    typeofa = 2;
}

int bar(void* a, char typeofa)
{
    //etc, do right thing dependant on typeofa
    //casting a to right type then dereferencing
}
</code></pre>

<p>Note, I have not tested this code so it may contain minor syntax errors but demonstrates the principal.</p>
",0
8807259,8807224,7,"<p>You cannot reseat a Reference but you can reseat a Pointer to point to new variables, this behavior cannot be simulated anyway in references(References always remain bound to the variable they are initialized to) and the convenience which pointers provide in achieving this would practically make C++ without pointers and only references virtually impossible .</p>
",5
8807293,8807224,7,"<p>What would be needed? Rebindable references - aka pointers. References are, once bound, not able to change their referee.</p>

<pre><code>struct Anchor{ /*some data*/ };

struct Sprite{
  void set_anchor(Anchor const&amp; a){ _anchor = &amp;a; }
  Anchor const* _anchor;
};

struct Entity{
  Anchror _anchor;
};
</code></pre>

<p>With something like this, you can just reposition a <code>Sprite</code> on the screen by changing its anchor. How would you do that with references?</p>
",9
8808151,8807224,-5,"<p>I have reassigned C++ references in the past using code something like this:</p>

<pre><code>struct EmptyType {};
const EmptyType Null;

template&lt;typename DataT&gt;
class DynamicReferenceT
{
    union
    {
        DataT &amp; _ref;
        DataT * _ptr;
    };

public:
    DynamicReferenceT(DataT &amp; r) : _ref(r) { }

    void operator=(DataT &amp; r) { _ptr = &amp;r; }
    void operator=(const EmptyType &amp;) { _ptr = NULL; }
    DataT &amp; operator()() { return _ref; }
};

class SomeClass
{
    int _value;

public:
    SomeClass(int val) : _value(val) {}
    int value() { return _value; }
};

int _tmain(int argc, _TCHAR* argv[])
{
    SomeClass objA1(100), objA2(200), objA3(300);

    // initially define the dynamic ref
    DynamicReferenceT&lt;SomeClass&gt; refObj(objA1);
    cout &lt;&lt; ""refObj = "" &lt;&lt; refObj().value() &lt;&lt; endl;

    // reassign the dynamic ref
    refObj = objA2;
    cout &lt;&lt; ""refObj = "" &lt;&lt; refObj().value() &lt;&lt; endl;

    refObj = objA3;
    cout &lt;&lt; ""refObj = "" &lt;&lt; refObj().value() &lt;&lt; endl;

    // assign ""null"" to reference
    refObj = Null;

    return 0;
}

// output
100
200
300
</code></pre>

<p>You can't overload the <code>.</code> operator in C++, so I overload the <code>()</code> operator to ""dereference"" the dynamic reference.</p>

<p>This is just a toy example -- you should further flesh out the implementation to handle deletion of objects and copying.</p>

<p><strong>Update</strong><br>
I concede to the C++ community here that this was a very poor C++ example on my part and really stands as a good example of how to abuse C++. I don't actually promote such constructs in practice save for the one case I mentioned where I had to redefine references in a very, very bad legacy C++ library I inherited some years ago (at a dot-com who shall remain nameless).</p>
",11
8809155,8807224,2,"<p>You can't reseat a reference, and you can't have a null reference.  What Java calls references are actually pointers.  And I don't know why you would want to avoid them.  References (in C++) have a specific role: they allow using the same syntax as pass/return by value, without the overhead; they can also be used for inout parameters and for exposing the internals of an object (e.g. an <code>operator[]</code> will often return a reference).  Other than as function parameters or return values, they should be fairly rare.</p>
",5
8809405,8807224,1,"<p>The Null Object Pattern is really bad, just so you know. It's not any sort of far-reaching solution.</p>

<p>Pointers are needed to be rebindable, and that's it. Also, Java's ""references"" are actually C++'s ""pointers"". C++'s ""references"" have no Java equivalent.</p>
",1
16381551,3213954,5,"<p>A solution that provides the length of the stringstream including any initial string provided in the constructor:</p>

<pre><code>#include &lt;sstream&gt;
using namespace std;

#ifndef STRINGBUFFER_H_
#define STRINGBUFFER_H_

class StringBuffer: public stringstream
{
public:
    /**
     * Create an empty stringstream
     */
    StringBuffer() : stringstream() {}

    /**
     * Create a string stream with initial contents, underlying
     * stringstream is set to append mode
     *
     * @param initial contents
     */
    StringBuffer(const char* initial)
        : stringstream(initial, ios_base::ate | ios_base::in | ios_base::out)
    {
        // Using GCC the ios_base::ate flag does not seem to have the desired effect
        // As a backup seek the output pointer to the end of buffer
        seekp(0, ios::end);
    }

    /**
     * @return the length of a str held in the underlying stringstream
     */
    long length()
    {
        /*
         * if stream is empty, tellp returns eof(-1)
         *
         * tellp can be used to obtain the number of characters inserted
         * into the stream
         */
        long length = tellp();

        if(length &lt; 0)
            length = 0;

        return length;

    }
};
</code></pre>
",0
15817331,15817259,8,"<p>That is because of how they are defined in the C++11 Standard. Paragraph 23.3.6.1 specifies their signature:</p>

<pre><code>template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</code></pre>

<p>While the parameters of the available overloads of <code>push_back()</code> do not have any <code>volatile</code> qualification, the argument of the <code>emplace_back()</code> function template can bind to lvalues with any <code>cv</code>-qualification.</p>

<blockquote>
  <p>However, emplace_back also takes a reference (rvalue-references are references). Why is it ttreated differently?</p>
</blockquote>

<p>Yes, because <code>emplace_back()</code> is a function <em>template</em>, and type deduction will infer <code>Args</code> to be an argument pack of length one, whose only element has type <code>int volatile&amp;</code> (see Paragraph 14.8.2.1/3). </p>

<p>The overloads of <code>push_back()</code>, on the other hand, are regular member functions of the <code>std::vector&lt;&gt;</code> class template, and there is no type deduction going on when invoking them. Since references to non-<code>volatile</code> cannot bind to objects qualified as <code>volatile</code> (see Paragraph 8.5.3/4-5), the compiler won't be able to resolve the call.</p>
",0
14737290,14737078,8,"<p>The STL container adaptor <code>std::stack</code> has an assignment <code>operator=</code> that allows you to do exactly that</p>

<pre><code>#include &lt;stack&gt;

int main()
{
   std::stack&lt;int&gt; s1;
   std::stack&lt;int&gt; s2;
   s1 = s2;
}
</code></pre>

<p>If you need to do it manually, you can use @FredOverflow's recursive solution, or you could do it with two loops and a temporary Stack, which the recurisve version keeps on the stack frame (pun intended).</p>

<pre><code>void copy_reverse(Stack&amp; source, Stack&amp; dest)
{
    while(!source.empty())
        dest.push(Element(source.top()));
        source.pop();
    }
}

Stack src, tmp, dst;
copy_reverse(src, tmp);
copy_reverse(tmp, dst);
</code></pre>
",0
18178677,18178438,-12,"<p>No, not at all. For a very limited subset, you could provide your own definitions, causing the linker to error at the duplicates. This would be <em>very</em> undefined behaviour though. And a good portion is templates that aren't susceptible to this. Without doing drastic things like deleting the iostream header, or using a compiler like Clang and modifying the source code, there's really nothing you can do.</p>
",2
8804201,8804147,19,"<p>If you have a C++11 library, you can use <a href=""http://en.cppreference.com/w/cpp/types/is_polymorphic""><code>std::is_polymorphic&lt;T&gt;</code></a>:</p>

<blockquote>
  <p>If T is a polymorphic class (that is, a class that declares or inherits at least one virtual function), provides the member constant value equal true. For any other type, value is false.</p>
</blockquote>
",5
16448011,16447951,5,"<p>In short, you can't.</p>

<p>All you can do is write an equivalent member function that takes a <code>va_list</code> instead of variable arguments, and pass the initialized <code>va_list</code> down.</p>
",3
16448036,16447951,0,"<p>For that to work, <code>Logger::Error</code> would have to be declared to accept a <code>va_list</code> as a parameter, much like vfprintf, rather than variable arguments in the form of  <code>...</code> like fprintf.</p>
",0
16448191,16447951,26,"<p>The typical formulation of this in C is to have two functions, one that accepts <code>...</code> and one that accepts a <code>va_list</code> (e.g., <code>printf</code> versus <code>vprintf</code>). In C++ it¡¯s convenient to do this with overloads:</p>

<pre><code>// public
void Logger::Error(const std::string&amp; format, ...) {
    va_list args;
    va_start(args, format);
    Error(format, args);
    va_end(args);
}

// private
void Logger::Error(const std::string&amp; format, va_list args) {
    if (this != &amp;errorsLogger)
        errorsLogger.Error(format, args);

    vfprintf(logFile, format.c_str(), args);
    fprintf(logFile, ""\n"");
    fflush(logFile);
}
</code></pre>

<p>Using C++11, it is possible to do directly with a variadic template. You can also forward arguments to C-style variadic functions.</p>

<pre><code>template&lt;class... Args&gt;
void Logger::Error(const std::string&amp; format, Args&amp;&amp;... args) {    
    if (this != &amp;errorsLogger)
        errorsLogger.Error(format, std::forward&lt;Args&gt;(args)...);

    fprintf(logFile, format.c_str(), std::forward&lt;Args&gt;(args)...);
    fprintf(logFile, ""\n"");
    fflush(logFile);
}
</code></pre>
",1
14725180,14725111,7,"<p>Associativity has nothing to do with order of evaluation.</p>

<p>In fact, you're invoking unspecified behavior. You can't tell which part of <code>==</code> will evaluate first.</p>

<p>Think about this:</p>

<pre><code>int x;  // x is 0 initially
int foo()
{
   x++;
   return x;
}
int goo()
{
   return x;
}

int main()
{
   bool b = foo() == goo();
}
</code></pre>

<p>If <code>foo</code> (returns 1) evaluates first, <code>b</code> will be <code>true</code> (<code>goo</code> will return 1). </p>

<p>If <code>goo</code> (returns 0) evaluates first, <code>b</code> will be <code>false</code> (<code>foo</code> will return 1).</p>
",2
14725207,14725111,3,"<p>It being left associative does not affect the order in which its parameters are evaluated which is unspecifed by the language. It simply means that if you write ""a == b == c"" then it will interpret it as ((a==b) == c). But it can calculate a, b and c in advance and in any order it likes.</p>
",0
9209909,594582,3,"<p>In my opinion, to write a complex piece of software, it is a good approach to <strong>separate the GUI</strong> from the rest, i.e., in general, the rest must be <strong><em>able to work even without the GUI</em></strong>.  </p>

<p>In this case it can be convenient to manage I/O with cin/cout.</p>
",5
11562443,11562375,12,"<p>In C++, certain things are left up to the implementation.  For example, when you write</p>

<pre><code>int x = f(a) + f(b);
</code></pre>

<p>The implementation may choose to call f(a) first or f(b) first.</p>
",0
11563631,11562375,2,"<p>In addition to the unspecified order in which sub-expressions are evaluated that others have already mentioned, keep in mind that C++11 adds threading, which makes order of execution even less deterministic. </p>

<p>For example, if you have two threads executing, and each just prints out ""thread A"" or ""thread B"", the order in which those outputs are produced is entirely unspecified. You might get all of the ""thread A"" outputs followed by all the ""thread B"" outputs, or vice versa, or they might be arbitrarily interleaved (with interleaving being more likely).</p>
",0
11562450,11562375,8,"<p>Consider:</p>

<pre><code>x = f() + g();
</code></pre>

<p>This allows two possible execution sequences:</p>

<pre><code>__temp1 = f();           /*or*/     __temp1 = g();
__temp2 = g();           /*or*/     __temp2 = f();
x = __temp1 + __temp2;   /*or*/     x = __temp2 + __temp1;
</code></pre>

<p>The standard does not specify which of these must be performed; just that the program must behave as if one of these two were performed. If <code>f()</code> and <code>g()</code> have side effects, then the program could have one of two different observable behaviours.</p>
",3
11562549,11562375,3,"<p>The C++ standard doesn't define evaluation order for some expressions. For example, in:</p>

<pre><code>    proc( a(), b() );
</code></pre>

<p>both a() and b() have to be evaluated before proc(), but a() may be evaluated before or after b(). So there are two legal execution sequences, and if a() and b() have side effects (eg, print statements), you can tell which the compiler used.</p>

<p>(This freedom about evaluation order is intended to help the compiler generate more efficient code. Whether it does in fact help with modern machines is open to dispute.)</p>
",0
8724737,8706589,3,"<p>Following a simple rule to derive through a template class it is possible.</p>

<pre><code>#include &lt;iostream&gt;

struct TEvent
{
};

struct Base {
    virtual void CallOnEvent(TEvent * e)
    {
        OnEvent(e);
    }
    virtual void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Base::Event"" &lt;&lt; std::endl;
    }
    void CallUp(TEvent * e)
    {
    }

};

template &lt;typename B&gt;
struct TDerived : public B
{
    void CallUp( TEvent * e )
    {
        B::CallUp(e);
        B::OnEvent(e);
    }
    virtual void CallOnEvent( TEvent * e )
    {
        CallUp(e);
        this-&gt;OnEvent(e);
    }
};

struct Derived01 : public TDerived&lt; Base &gt;
{
    void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Derived01::Event"" &lt;&lt; std::endl;
    }
};

struct Derived02 : public TDerived&lt; Derived01 &gt;
{
    void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Derived02::Event"" &lt;&lt; std::endl;
    }
};

struct Derived03 : public TDerived&lt; Derived02 &gt;
{
    void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Derived03::Event"" &lt;&lt; std::endl;
    }
};

struct Derived04 : public TDerived&lt; Derived03 &gt;
{
    void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Derived04::Event"" &lt;&lt; std::endl;
    }
};


int main( void )
{
 Derived04 lD4;
 lD4.CallOnEvent(0);
 return 0;
}
</code></pre>

<p>This code yields (<a href=""http://codepad.org/OlSwkfHc"" rel=""nofollow"">codepad</a>):</p>

<pre><code>Base::Event
Derived01::Event
Derived02::Event
Derived03::Event
Derived04::Event
</code></pre>

<p>Regarding some answers using <code>typeid</code>. I would never consider using <code>typeid</code> for anything else than debugging. This is due to two things:</p>

<ul>
<li>dynamic type checking can be done in a much more efficient ways (without creating <code>type_info</code> object i.e. using <code>dynamic_cast</code>, some methods</li>
<li>C++ standard basically guarantees only the existance of typeid, but not really anything regarding how it works (most things are ""compiler specific"")</li>
</ul>

<p><strong>edit:</strong></p>

<p>A slightly more complex example with multiple inheritance.
This one unfortunately is not solvable without explicit calls in classes that do inherit from multiple bases (mainly because it is not clear what should happen in such cases, so we have to explicitly define the behaviour).</p>

<pre><code>#include &lt;iostream&gt;

struct TEvent
{
};

struct Base {
    virtual void CallOnEvent(TEvent * e)
    {
        OnEvent(e);
    }
    virtual void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Base::Event"" &lt;&lt; std::endl;
    }

    void CallUp(TEvent * e)
    {
    }
};

template &lt;typename B &gt;
struct TDerived : public B
{
    void CallUp( TEvent * e )
    {
        B::CallUp(e);
        B::OnEvent(e);
    }
    virtual void CallOnEvent( TEvent * e )
    {
        CallUp(e);
        this-&gt;OnEvent(e);
    }
};

struct Derived01 : virtual public TDerived&lt; Base &gt;
{
    void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Derived01::Event"" &lt;&lt; std::endl;
    }
};

struct Derived02 : virtual public TDerived&lt; Derived01 &gt;
{
    void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Derived02::Event"" &lt;&lt; std::endl;
    }
};

typedef TDerived&lt; Derived02 &gt; TDerived02;
typedef TDerived&lt; Derived01 &gt; TDerived01;
struct Derived03 : virtual public TDerived02, virtual public TDerived01
{
    void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Derived03::Event"" &lt;&lt; std::endl;
    }

    virtual void CallOnEvent( TEvent * e )
    {
        CallUp(e);
        Derived03::OnEvent(e);
    }
    void CallUp( TEvent * e )
    {
        TDerived02::CallUp(e);
        TDerived01::CallUp(e);
    }
};

struct Derived04 : public TDerived&lt; Derived03 &gt;
{
    void OnEvent(TEvent * e)
    {
        std::cout &lt;&lt; ""Derived04::Event"" &lt;&lt; std::endl;
    }
};


int main( void )
{
 Derived04 lD4;
 Derived03 lD3;

 lD3.CallOnEvent( 0 );
 std::cout &lt;&lt; std::endl;
 lD4.CallOnEvent( 0 );

 return ( 0 );
}
</code></pre>

<p>Result is (<a href=""http://ideone.com/nq6aD"" rel=""nofollow"">ideone</a>):</p>

<pre><code>Base::Event      \                  \
Derived01::Event | - from Derived02 |
Derived02::Event /                  |-- from Derived03
Base::Event      \__ from Derived01 |
Derived01::Event /                  |
Derived03::Event                    /

Base::Event      \                  \                  \
Derived01::Event | - from Derived02 |                  |
Derived02::Event /                  |-- from Derived03 |-- from Derived04
Base::Event      \__ from Derived01 |                  |
Derived01::Event /                  |                  |
Derived03::Event                    /                  |
Derived04::Event                                       /
</code></pre>
",0
9849814,2428404,0,"<p>A solution to #2 is:</p>

<pre><code>#define _SR_H_

int count = 0;

class SR {
private:
    int&amp; ref;
public:
    SR(int&amp; val) : ref(val) {
        count++;
    }
    ~SR() {
        if (count == (161700 + 1)) {
            ref = 100;
        } else {
            ref = 1;
        }
    }
};

#endif
</code></pre>

<p>I know this solution is a bit ugly, and it runs the <code>for</code> loop 161700 times to add the numbers. This would work for any number, but I am not sure why 161700 was chosen. It doesn't factorize nicely either.</p>
",1
9835582,9835552,9,"<p><code>std::tuple</code> is a generalization of <code>std::pair</code> that lets you store a collection of some size that you specify. So, you can say:</p>

<pre><code>typedef std::tuple&lt;std::string, std::string, std::string&gt; Triad;
</code></pre>

<p>to get a type <code>Triad</code> that stores three strings.</p>
",1
9835588,9835552,5,"<p>You can use tuples from boost: <a href=""http://www.boost.org/doc/libs/1_49_0/libs/tuple/doc/tuple_users_guide.html"">http://www.boost.org/doc/libs/1_49_0/libs/tuple/doc/tuple_users_guide.html</a></p>

<p>(In C++11 tuples are part of standard library: <a href=""http://en.wikipedia.org/wiki/C%2B%2B11#Tuple_types"">http://en.wikipedia.org/wiki/C%2B%2B11#Tuple_types</a>)</p>
",0
9835779,9835552,3,"<p>As others have mentioned, you should use <code>std::tuple</code> (or <code>boost::tuple</code>).  Nevertheless, I think there are things that you can learn from a critique of your code:</p>

<ol>
<li>If you want something like <code>std::pair</code>, why didn't you write something that behaved like <code>std::pair</code>?  That is, a class with public data members that copies its items by value?</li>
<li>If you want something like <code>std::pair</code>, why not make it more generic like <code>std::pair</code>, where the different members can have different types?  Or if you care only about storing <code>std::string</code> members, why bother making it a template class?</li>
<li>Your copy constructor should take its argument by <code>const</code> reference.</li>
<li>You didn't follow the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29"" rel=""nofollow"">Rule of Three</a>.  You have a non-trivial copy constructor and a non-trivial destructor but neglected to implement a copy assignment operator.  However, if you did #1, you wouldn't need to worry about this.</li>
<li>As written, it is impossible to set your class's data members.  There is no constructor to initialize them with specified values, and there is no way to set them after construction. (If you try <code>triad.get1() = ...</code>, you'll crash trying to dereference a null pointer!)</li>
<li><p>Your constructors should initialize their data members using initialization lists.  For example:</p>

<p><code>triad() : one(0), two(0), three(0) { }</code></p></li>
<li><p>One of the things that makes <code>std::pair</code> useful over simply making a <code>struct</code> of the desired members is that it comes with <code>operator==</code> and <code>operator&lt;</code>.</p></li>
<li>If you really want to use accessor methods, then you should provide <code>const</code> versions.</li>
</ol>
",0
9837322,9835552,1,"<p>If your triad is specific then create a class, or at least a struct so you can give meaningful names to the members.</p>

<pre><code>struct Contact
{
    std::string name;
    std::string nickname;
    std::string email;
};

std::vector&lt;Contact&gt; contacts;
</code></pre>
",0
10168242,1389899,0,"<p>There's one more important thing regarding the declaration of member-variable <code>CTypeSize::m_nSize</code>. Do you notice a <code>const</code> modifier in that declaration?</p>

<p><code>class member-var declared as ""const""</code> can be initialized only in initialization list.</p>

<p>As AraK mentioned, in C++11 const member-var may also be initialized with the const expression. This is compile-time case, while initialization list allows const member-var to be initialized at run-time.</p>
",0
9813622,445475,0,"<p>I don't think this shows that auto_ptr has an encapsulation problem. Whenever dealing with owned pointers, it is critical for people to understand who owns what. In the case of auto_ptr, it owns the pointer that it holds[1]; this is part of auto_ptr's abstraction. Therefore, deleting that pointer in any other way violates the contract that auto_ptr provides.</p>

<p>I'd agree that it's relatively easy to mis-use auto_ptr[2], which is very not ideal, but in C++, you can never avoid the fundamental issue of ""who owns this pointer?"", because for better or worse, C++ does not manage memory for you.</p>

<p>[1] Quote from cplusplus.com: ""auto_ptr objects have the peculiarity of taking ownership of the pointers assigned to them"": <a href=""http://www.cplusplus.com/reference/std/memory/auto_ptr/"" rel=""nofollow"">http://www.cplusplus.com/reference/std/memory/auto_ptr/</a></p>

<p>[2] For example, you might mistakenly believe that it has value semantics, and use it as a vector template parameter: <a href=""http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;ved=0CEEQFjAD&amp;url=http%3A%2F%2Fwww.gamedev.net%2Ftopic%2F502150-c-why-is-stdvectorstdauto_ptrmytype--bad%2F&amp;ei=XU1qT5i9GcnRiAKCiu20BQ&amp;usg=AFQjCNHigbgumbMG3MTmMPla2zo4LhaE1Q&amp;sig2=WSyJF2eWrq2aB2qw8dF3Dw"" rel=""nofollow"">http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;ved=0CEEQFjAD&amp;url=http%3A%2F%2Fwww.gamedev.net%2Ftopic%2F502150-c-why-is-stdvectorstdauto_ptrmytype--bad%2F&amp;ei=XU1qT5i9GcnRiAKCiu20BQ&amp;usg=AFQjCNHigbgumbMG3MTmMPla2zo4LhaE1Q&amp;sig2=WSyJF2eWrq2aB2qw8dF3Dw</a></p>
",0
13731044,13730492,5,"<p>I have no VS2010 to check if it compiles there, but the following matches your example.</p>

<pre><code>template &lt;typename T&gt; // if std::declval is not supported by VS10
typename std::add_rvalue_reference&lt;T&gt;::type declval();

template &lt;typename T&gt;
decltype(new T(declval&lt;std::string&gt;()))
create_(std::string param, int) { return new T(param); }
template &lt;typename T&gt;
T * create_(std::string, ...) { return new T(); }

template &lt;typename T&gt;
T * create(std::string param) { return create_&lt;T&gt;(param, 0); }

int main()
{
  std::cout &lt;&lt; *create&lt;int&gt;(""a"") &lt;&lt; '\n';
  std::cout &lt;&lt; *create&lt;std::string&gt;(""b"") &lt;&lt; '\n';
}
</code></pre>

<p>Output:</p>

<pre><code>0
b
</code></pre>
",20
10819896,10819808,3,"<p>Stanley Lippman's book <a href=""https://rads.stackoverflow.com/amzn/click/com/0201834545"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">""Inside the C++ Object Model""</a> has a great run-through of the subject (though dated, but still valid).</p>
",1
10821134,10819808,2,"<p>Virtuality is about indirection. Let's start simple:</p>

<pre><code>struct Foo { void bar(int, bool) {} } x;
x.bar(12, false);
</code></pre>

<p>Here the call to <code>Foo::bar()</code> for the instance <code>x</code> is fully known at compile time and resolved statically: One fixed function which is given the instance reference and the function arguments. Function name, call, done. No problem so far.</p>

<p>Moving on:</p>

<pre><code>struct Boo { virtual void bar(char, float) = 0; };
extern Boo * foreign_function();

Boo * p = foreign_function();
p-&gt;bar('a', -1.5);
</code></pre>

<p>This time, there is no way to know at compile time where the <code>bar()</code> call is supposed to go. The only way to resolve this is to add a level of indirection that allows you to look up all possible overrides of this member function and pick the correct one at runtime, depending on the dynamic type of <code>*p</code>. This time we start with the function name, perform the lookup at runtime, and then make the call. This pattern should still be fairly familiar.</p>

<p>The point here is that it is enough to know that the dynamic type of <code>*p</code> is a subtype of the (non-virtual) base <code>Boo</code> so that we can implement this with just one single lookup (e.g. a vtable pointer to a table that's compatible with that of <code>Boo</code>).</p>

<p>Now on to the big fish:</p>

<pre><code>struct Voo { virtual void doo(double, void *) = 0; };
struct Left  : virtual Voo { virtual void doo(double, void *); } };
struct Right : virtual Voo { virtual void doo(double, void *); } };
struct Most : Left, Right  { virtual void doo(double, void *); } };

Left * p = /* address of a Most object, say */;
p-&gt;doo(0.1, nullptr);
</code></pre>

<p>We already know that we don't know where <code>doo()</code> is supposed to go, and we have to look it up at runtime. However, a simple one-step indirection is no longer possible. Even though <code>Left</code> is a subclass of <code>Voo</code> and <code>Right</code> also is a subclass of <code>Voo</code>, the actual <code>Voo</code> base subobject of <code>*p</code> is not actually a subobject of the <code>Left</code>- or of the <code>Right</code>-subobject -- the (unique!) virtual subobject belongs to <code>Most</code> directly (or whatever the most-derived object is). In implementation terms, a single vtable pointer is no good, because we don't want <code>Left</code>'s vpointer, nor do we want <code>Right</code>'s vptr. Instead, we want whichever vpointer the actual object has.</p>

<p>So now we find ourselves in a familiar situation: We need to look something up that we can only know at runtime. And this time the thing we need to look up is the actual virtual base. So the process goes like this: Function name, look up virtual base at runtime, look up virtual function in virtual base, and make the call. (In the typical vtable implementation of virtuality, this is usually done with an extra piece of lookup via a ""thunk"", or a ""pointer to a pointer"".)</p>

<p>In a nutshell, ""virtual"" means ""determined at runtime"".</p>

<p>(That does not <em>force</em> your compiler to generate runtime code. If the target of the dispatch is provably known at compile time, the call may be devirtualized. But the <em>behaviour</em> of your program is ""as if"".)</p>
",1
10795070,10794820,10,"<p>If you read the description for <code>operator&gt;&gt;</code> (e.g. <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt"" rel=""noreferrer"">here</a>), then you will see that it skips whitespace before reading, until it hits whitespace again. Whitespace is not only space (<code>0x20</code>) but also things like tab (<code>0x09</code>)  and newline (<code>0x0a</code>).</p>

<p>So if your binary data contains bytes that are considered whitespace for a text file, then <code>operator&gt;&gt;</code> will read but not store them, which will skew the numbers reported by <code>tellg</code>.</p>
",0
10795081,10794820,4,"<p>It is not a good Idea to use the <code>operator&gt;&gt;</code> when you open a stream in binary.<br>
I assume that in your case there is some sort of white space character(e.g 0x20) in your stream.<br>
You could use the <code>skipws</code> modifier that those are also read.</p>
",1
19798983,599321,0,"<p>In some system you don't have access to the time.h header. Therefore, you can use the following code snippet to find out how long does it take for your program to run, with the accuracy of seconds.</p>

<pre><code>void function()
{
time_t currentTime;
time(&amp;currentTime);
int startTime = currentTime;

   /* Your program starts from here */


  time(&amp;currentTime);
  int timeElapsed = currentTime - startTime;

  cout&lt;&lt;""It took ""&lt;&lt;timeElapsed&lt;&lt;"" seconds to run the program""&lt;&lt;endl;



}
</code></pre>
",0
12872249,12871711,0,"<p>The function <code>show(ClOldClass&amp;)</code> in class <code>MyFooClass</code> is a different function than the function <code>show(OtherClass&amp;)</code> in class <code>CustomFoo</code>. The new definition hides the other one.</p>

<p>Did you really mean to overload here as opposed to override? If you meant to override, your new function needs to have the same signature as in the parent classes. If really did mean to overload the function, you still need that other <code>show</code>. Add a <code>using CustomFoo::show;</code> directive to your class <code>MyFooClass</code>.</p>

<pre><code>//MyFooClass.h
class MyFooClass : public CustomFoo&lt; ClOldClass, ClNewClass &gt;
{
    public:
        virtual std::auto_ptr&lt;ClNewClass&gt; show(ClOldClass &amp;oc) {...}

    protected:
        using CustomFoo::show;
};
</code></pre>
",2
9175340,728068,13,"<p>boost 1.46.0 and up includes the <a href=""http://www.boost.org/doc/libs/1_47_0/doc/html/chrono/reference.html#chrono.reference.other_clocks.thread_clock_hpp"" rel=""noreferrer"">Chrono</a> library:</p>

<blockquote>
  <p>thread_clock class provides access to the real thread wall-clock, i.e.
  the real CPU-time clock of the calling thread. The thread relative
  current time can be obtained by calling thread_clock::now()</p>
</blockquote>

<pre><code>#include &lt;boost/chrono/thread_clock.hpp&gt;
{
...
    using namespace boost::chrono;
    thread_clock::time_point start = thread_clock::now();
    ...
    thread_clock::time_point stop = thread_clock::now();  
    std::cout &lt;&lt; ""duration: "" &lt;&lt; duration_cast&lt;milliseconds&gt;(stop - start).count() &lt;&lt; "" ms\n"";
</code></pre>
",1
19800231,728068,39,"<p>if you are using c++11, here is a simple wrapper (see this <a href=""https://gist.github.com/gongzhitaao/7062087"">gist</a>):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;

class Timer
{
public:
    Timer() : beg_(clock_::now()) {}
    void reset() { beg_ = clock_::now(); }
    double elapsed() const { 
        return std::chrono::duration_cast&lt;second_&gt;
            (clock_::now() - beg_).count(); }

private:
    typedef std::chrono::high_resolution_clock clock_;
    typedef std::chrono::duration&lt;double, std::ratio&lt;1&gt; &gt; second_;
    std::chrono::time_point&lt;clock_&gt; beg_;
};
</code></pre>

<p>Or for c++03 on *nix:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;

class Timer
{
public:
    Timer() { clock_gettime(CLOCK_REALTIME, &amp;beg_); }

    double elapsed() {
        clock_gettime(CLOCK_REALTIME, &amp;end_);
        return end_.tv_sec - beg_.tv_sec +
            (end_.tv_nsec - beg_.tv_nsec) / 1000000000.;
    }

    void reset() { clock_gettime(CLOCK_REALTIME, &amp;beg_); }

private:
    timespec beg_, end_;
};
</code></pre>

<p>Example of usage:</p>

<pre><code>int main()
{
    Timer tmr;
    double t = tmr.elapsed();
    std::cout &lt;&lt; t &lt;&lt; std::endl;

    tmr.reset();
    t = tmr.elapsed();
    std::cout &lt;&lt; t &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",2
11120866,11120473,0,"<p>Sorry, it's impossible to achieve with <code>iostream</code> <em>and</em> <code>printf</code>. The only options are:</p>

<ul>
<li>implement your own floating point formatting routine to do the correct rounding.</li>
<li>format the float into string and trim the zeros.</li>
<li>if the value is less than a threshold then round it to zero.</li>
</ul>

<p>The first is complicated, the last is inaccurate (can't represent exactly 10<sup>-n</sup> in binary floats).</p>

<p>All can be implemented by overriding the numput facet, which will allow you to leave the formatting code as clean as before.</p>

<p>Here is an implementation of the last option:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;math.h&gt;
using namespace std;

class my_put : public std::num_put&lt;char&gt; {
    iter_type do_put (iter_type out, ios_base&amp; str, char_type fill, double val) const
    {
        streamsize prec = str.precision();
        if((str.flags() &amp; ios_base::floatfield) == ios_base::fixed &amp;&amp; fabs(val)*2 &lt;= pow(10.0, -(int)prec))
            str.precision(0);
        out = std::num_put&lt;char&gt;::do_put(out, str, fill, val);
        str.precision(prec);
        return out;
    }
};

int main()
{
    double a[] = {123, 0, 0.001, 0.0001 };
    cout.imbue(locale(cout.getloc(), new my_put));
    cout.precision(3);
    cout.setf(ios_base::fixed, ios_base::floatfield);
    for(int i = 0; i &lt; 4; ++i)
        cout &lt;&lt; a[i] &lt;&lt; '\n';
}
</code></pre>

<p>See output here: <a href=""http://ideone.com/qaV0w"" rel=""nofollow"">http://ideone.com/qaV0w</a></p>

<p>Note that the correctness for the boundary case (0.0005) depends on the underlining floating point format and implementation.</p>
",1
11120898,11120473,0,"<p>Consider printing the values multiplied by 100, as integers (rounding for accuracy). That way although you will get trailing zeroes sometimes, you will never have to print the decimal place, which will be wasting 1 character for each value.</p>

<p>Alternatively, write the float in binary. Since all floats will have the same size (4 bytes), you retain all the precision of the original without worrying about trailing zeroes, your file size is very predictable and you don't have to waste space delimiting the values. 100 values takes 400 bytes. In text format, a value takes a minimum of 2 bytes (number + field delimiter) and a maximum of whatever your format permits (including one for the decimal point) plus the delimiter. In that format, 4 bytes gets you 2 significant figures of precision, instead of the 5 or 6 of a float.</p>
",0
15852359,15852318,1,"<p>Function declarations, variable declarations and class definitions for a given identifier may appear in the source code as often as you like. They just have to be identical each time they appear (which is automatic if you include a given header file in multiple translation units).</p>

<p>It is only the <em>definition</em> of functions, variables and class member functions that must appear precisely once (with a special rule for inlined functions).</p>

<p>(It's a little different for templates: Template <em>definitions</em> may appear repeatedly, but again all occurrences have to be identical. But templates require some non-trivial deduplication work from the linker.)</p>
",0
15518469,15518356,3,"<p>As I say in my comment, scope limited anonymous variables cannot be used.</p>

<pre><code>#define BEGIN_LOG   TraceObject abcdefghij( """", __func__ );

void Function(){
    BEGIN_LOG;

    //bla bla

}
</code></pre>

<p>This should do it, provided there is a compiler macro to get Class name.</p>

<p>Edit: No Luck with a easy way to get class name, you might have to do something like what is suggested at <a href=""https://stackoverflow.com/questions/3563783/class-name-macro"">Class name macro</a>. Or just make do with <code>__FILE__</code>.</p>

<p>Edit: You might want to try <code>__func__</code> and <code>__FUNCTION__</code> to see if either or both work as you want them to. Neither are C++ standard specified.</p>
",2
15518593,15518356,5,"<p><strong>No.</strong></p>

<p>There are anonymous objects in C++, temporaries that are the results of expressions, however they only live in the context of the statement they are in.</p>

<p>If you actually attempt to declare an anonymous object, you will confuse the parser and it'll think you are declaring... a function!</p>

<hr>

<p>But then, is it necessary ?</p>

<p>If you accept to use macros to actually declare the <code>TraceObject</code>, then it is as simple to use a macro for each trace; and thus provide the class and function there. Using <code>__func__</code> or equivalent you can extract the class name and function name (bit of string parsing required, depends on the compiler) and work from there.</p>

<p>And of course, you would be using a macro for each trace anyway, because you would probably want the file name and line number!</p>
",5
15518803,15518356,1,"<p>Some line number stuff:</p>

<pre><code>#define XPASTE(arg1, arg2) PASTEX(arg1, arg2)
#define PASTEX(arg1, arg2) arg1 ## arg2
#define TRACELOG() \
            TraceObject XPASTE(trace_object,  __LINE__)
</code></pre>
",1
11145292,2960596,4,"<p>The C++ standard has this to say about <code>getline</code>:</p>
<blockquote>
<p>C++ 2003, 21.3.7.9/5</p>
<p>[<code>getline(is, str, delim)</code>] ¡­ extracts characters from <code>is</code> ¡­ until any of the following occurs:</p>
<ul>
<li>end-of-file occurs on the input sequence ¡­</li>
<li><code>c == delim</code> [<strong>N.b. default delim is <code>'\n'</code></strong>] for the next available input character <code>c</code> (in which case, c is extracted but not appended)</li>
<li><code>str.max_size()</code> characters are stored</li>
</ul>
</blockquote>
<p><sup>Bracketd editorial comments added</sup></p>
<p>To put it in your vernacular, <code>getline</code> treats <code>'\n'</code> as a terminator, not a separator.</p>
",1
15831105,15831003,1,"<p>If you use Visual C++ you might be able to use <a href=""http://msdn.microsoft.com/en-us/library/c8xdzzhh%28v=vs.100%29.aspx"" rel=""nofollow""><code>#pragma deprecated</code></a>.</p>

<p>For GCC there the <a href=""http://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax"" rel=""nofollow""><code>__attribute__</code></a> compiler extension, which might be used to mark variables or functions as deprecated. Don't know about enumerations though.</p>
",1
11567971,11567547,4,"<p>I would suggest the use of templates to get what you want.</p>

<pre><code>template &lt;typename T&gt;
struct Index {
    Index(int value) : value(value) {}
    int value;
};
</code></pre>

<p>This is used like.</p>

<pre><code>struct PhoneRepoIx {};
Index&lt;PhoneRepoIx&gt; PhoneIndex(1);
list[PhoneIndex.value];
</code></pre>
",0
11568133,11567547,6,"<p>Different compilers have different optimization abilities and different bugs. It is theoretically possible to compile this with precisely zero overhead. Will your compiler attain this theoretical limit? The answer is a definite ""maybe"". At least some compilers are known to do it at least some of the time.</p>

<p>The more interesting question is whether you should be worried over a possible performance degradation. And the answer to this question is a strong ""no"". Not until your program does in fact show unacceptable performance figures.  </p>
",2
11568258,11567547,4,"<p>There are two functions which will commonly be called on this class:</p>

<ul>
<li>Constructor</li>
<li>operator&lt; (since STL map is a tree impl, the keys should support this)</li>
</ul>

<p>I think the above answer ""don't worry"" sounds pretty good (profile then optimize).  But to take a crack at why this won't cause any slowdown (guesswork):</p>

<ul>
<li>Constructor: No reason why a decent compiler couldn't turn this into a stack pointer increment (to make space for the int) followed by setting the available space.</li>
<li>operator&lt;: No reason why a decent compiler couldn't inline the simple comparison between the 'n's of the two objects.</li>
</ul>
",0
14227263,14227221,3,"<p>Karthik's answer is excellent, alternatively,  you could also do...</p>

<pre><code>  for(int i = 0; i &lt; 4; i++)
  {
     for(int j = 0; j &lt; 4; j++)
      {
         m[i][j] = matrix[i][j];
      }
  }
</code></pre>

<p>The principle is the same that WhozCraig mentioned in the comment.</p>
",0
14227292,14227221,1,"<p>Even though you declare the parameter to your constructor as <code>float matrix[4][4]</code>, the compiler ignores the first <code>4</code>.</p>
",4
14227246,14227221,4,"<p>If you are using c++11 try to change <code>float matrix[4][4]</code> to <code>std::array&lt;std::array&lt;float,4&gt;,4&gt;</code></p>

<p>It is a mouthful, but it supports such operations that c arrays do not natively support.</p>

<p>You could do something like this to clean up the syntax.</p>

<pre><code>typedef std::array&lt;std::array&lt;float,4&gt;,4&gt; Matrix;
</code></pre>

<p>Now you can do </p>

<pre><code>Matrix myMatrix;
</code></pre>

<p>p.s If you are not using C++11, you could use <code>vector</code> instead of <code>array</code>. It is a little different from array, but adds more features as well, and after you set it up access is identical.</p>
",3
10157971,6276576,0,"<p>If you are serious about the <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged 'c++'"" rel=""tag"">c++</a>, this is how I would suggest to do it.</p>

<pre><code>#include &lt;sstream&gt;

template &lt;typename Int&gt;
std::string intToStr(Int const i) {
  std::stringstream stream;
  stream &lt;&lt; std::hex &lt;&lt; i;
  return stream.str();
}
</code></pre>

<p>Which you may invoke as <code>intToStr(1231212)</code>. If you insist on getting a <code>char</code> array (I strongly suggest you use <code>std::string</code>), you can copy the <code>c_str()</code> result over:</p>

<pre><code>std::string const str = intToStr(1231212);
char* const chrs = new char[str.length()+1];
strcpy(chrs,str.c_str()); // needs &lt;string.h&gt;
</code></pre>
",0
10755512,10755496,10,"<p>Just change the function signature to look like</p>

<pre><code>bool someFunc(Something* &amp;something)
</code></pre>

<p>and you'll get a modifiable pointer in <code>someFunc()</code>.</p>
",0
10755517,10755496,3,"<pre><code>bool someFunc(Something * &amp;something)
</code></pre>
",0
10755523,10755496,2,"<pre><code>bool someFunc ( Something * &amp; something ); 
                         // ^ notice the reference symbol
</code></pre>
",0
10784272,9570823,0,"<p>Actually the compiler is doing exactly what it should.</p>

<pre><code>int transmogrify(int foo) {
    if (foo == 0) {
        return -1;
    } else if (foo == MAGIC_NUMBER_4711) {
        return 1;
    }
    // you know you shouldn't get here, but the compiler has
    // NO WAY of knowing that.  In addition, you are putting
    // great potential for the caller to create a nice bug.
    // Why don't you catch the error using an ELSE clause?
    else {
        error( ""transmorgify had invalid value %d"", foo ) ;
        return 0 ;
    } 
}
</code></pre>
",1
14151057,2497541,-3,"<p>All of these are valid answers, avoid Pointers, use copy constructors, etc. Unless you need to create a program that needs good performance, in my experience most of the performance related problems are with the copy constructors, and the overhead caused by them. (And smart pointers are not any better on this field, I'd to remove all my boost code and do the manual delete because it was taking too much milliseconds to do its job).</p>

<p>If you're creating a ""simple"" program (although ""simple"" means you should go with java or C#) then use copy constructors, avoid pointers and use smart pointers to deallocate the used memory, if you're creating a complex programs or you need a good performance, use pointers all over the place, and avoid copy constructors (if possible), just create your set of rules to delete pointers and use valgrind to detect memory leaks,</p>

<p>Maybe I will get some negative points, but I think you'll need to get the full picture to take your design choices.</p>

<p>I think that saying ""if you're returning pointers your design is wrong"" is little misleading. The output parameters tends to be confusing because it's not a natural choice for ""returning"" results.</p>

<p>I know this question is old, but I don't see any other argument pointing out the performance overhead of that design choices.</p>
",0
17815736,17815391,5,"<p>In Visual Studio, you should be able to get around the warning by using the <code>#pragma</code> directives (it'd be perfectly valid to do this, as you are aware of the warning and just wish to suppress it), for instance, your main function would look something like:</p>

<pre><code>#include &lt;vector&gt;
int main()
{
    std::vector&lt;int&gt;   input_data;
    std::vector&lt;float&gt; output_data;

#pragma warning(suppress: 4244)
    output_data.insert(output_data.end(), input_data.begin(), input_data.end());
}
</code></pre>

<p>This will suppress the warning C4244 for the following line of code (subsequent or preceding lines will still emit that warning). If you want to disable warning emissions for larger blocks of code, you may wish to look at the other <a href=""http://msdn.microsoft.com/en-us/library/2c8f766e%28v=vs.80%29.aspx"" rel=""nofollow""><code>#pragma warning</code> directives</a>.</p>
",6
17815884,17815391,1,"<p>What about using <code>boost::transform_iterator</code> with the existing insert?</p>

<pre><code>struct to_float { float operator()(int x) const { return static_cast&lt;float&gt;(x); };
output_data.insert(output_data.end(), boost::make_transform_iterator(input_data.begin(), to_float()), boost::make_transform_iterator(input_data.end(), to_float()));
</code></pre>
",0
9781003,9780087,2,"<p><sup><strong>TL;DR:</strong>  If the stream run out of content while trying to read a new value, <code>failbit</code> is set.</sup></p>

<hr>

<p>It's defined in the standard that using a <code>istream_iterator</code> has the same effect as doing:</p>

<pre><code>*in_stream &gt;&gt; value; /* istream_iterator::operator++ */
return        value; /* istream_iterator::operator*  */
</code></pre>

<hr>

<p>Which in the case with handling integers (such as <code>size_t</code>) will results in calls to the below (can be read about under <em>27.6.1.2.2/2 - lib.istream.formatted.arithmetic</em>).</p>

<pre><code>use_facet&lt;numget&gt; (loc).get (*this, 0, *this, err, lval)

...

setstate (err);
</code></pre>

<hr>

<p><code>err</code> is passed by reference and will be set to whatever errors the function might run into. Below is a snippet from the standards definition of <code>use_facet&lt;numget&gt; (loc).get</code>:</p>

<blockquote>
  <p><strong>22.2.2.1.2</strong>/8 <code>-</code> [<em>lib.facet.num.get.virtuals</em>]</p>
  
  <p>The <code>in</code> iterator is always left pointing one position beyond the last
  character successfully matched. If <code>val</code> is set, then <code>err</code> is set to
  <code>str.goodbit;</code> or to <code>str.eofbit</code> if, when seeking another character to
  match, it is found that <code>(in == end)</code>.</p>
  
  <p>If <code>val</code> is not set, then <code>err</code> is
  set to <code>str.failbit</code>; or to <code>(str.failbit|str.eofbit)</code> if the reason for
  the failure was that <code>(in == end)</code>.</p>
</blockquote>

<hr>

<p><sup><strong>TL;DR:</strong>  If the stream run out of content while trying to read a new value, <code>failbit</code> is set.</sup></p>
",0
13772494,13772475,3,"<p>Use a loop to put random index numbers into a <code>std::set</code> and stop when the <code>size()</code> reaches 20.</p>

<pre><code>std::set&lt;int&gt; indexes;
std::vector&lt;my_vector::value_type&gt; choices;
int max_index = my_vector.size();
while (indexes.size() &lt; min(20, max_index))
{
    int random_index = rand() % max_index;
    if (indexes.find(random_index) == indexes.end())
    {
        choices.push_back(my_vector[random_index]);
        indexes.insert(random_index);
    }
}
</code></pre>

<p>The random number generation is the first thing that popped into my head, feel free to use something better.</p>
",18
13772517,13772475,8,"<p>You can use Fisher Yates <a href=""http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle</a></p>

<blockquote>
  <p>The Fisher¨CYates shuffle (named after Ronald Fisher and Frank Yates), also known as the Knuth shuffle (after Donald Knuth), is an algorithm for generating a random permutation of a finite set¡ªin plain terms, for randomly shuffling the set. A variant of the Fisher¨CYates shuffle, known as Sattolo's algorithm, may be used to generate random cycles of length n instead. Properly implemented, the Fisher¨CYates shuffle is unbiased, so that every permutation is equally likely. The modern version of the algorithm is also rather efficient, requiring only time proportional to the number of items being shuffled and no additional storage space.
  The basic process of Fisher¨CYates shuffling is similar to randomly picking numbered tickets out of a hat, or cards from a deck, one after another until there are no more left. What the specific algorithm provides is a way of doing this numerically in an efficient and rigorous manner that, properly done, guarantees an unbiased result.</p>
</blockquote>

<p>I think this pseudocode should work (there is a chance of an off-by-one mistake or something so double check it!):</p>

<pre><code>std::list chosen; // you don't have to use this since the chosen ones will be in the back of the vector
for(int i = 0; i &lt; num; ++i) {
  int index = rand_between(0, vec.size() - i - 1);
  chosen.push_back(vec[index]);
  swap(vec[index], vec[vec.size() - i - 1]);
}
</code></pre>
",5
13772539,13772475,8,"<p>You want a random sample of size m from an n-vector:</p>

<p>Let rand(a) return 0..a-1 uniform</p>

<pre><code>for (int i = 0; i &lt; m; i++)
    swap(X[i],X[i+rand(n-i)]);
</code></pre>

<p><code>X[0..m-1]</code> is now a random sample.</p>
",0
13772594,13772475,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

template&lt;int N&gt;
struct NIntegers {
  int values[N];
};
template&lt;int N, int Max, typename RandomGenerator&gt;
NIntegers&lt;N&gt; MakeNRandomIntegers( RandomGenerator func ) {
  NIntegers&lt;N&gt; result;
  for(int i = 0; i &lt; N; ++i)
  {
    result.values[i] = func( Max-i );
  }
  std::sort(&amp;result.values[0], &amp;result.values[0]+N);
  for(int i = 0; i &lt; N; ++i)
  {
    result.values[i] += i;
  }
  return result;
};
</code></pre>

<p>Use example:</p>

<pre><code>// use a better one:
int BadRandomNumberGenerator(int Max) {
  return Max&gt;4?4:Max/2;
}
int main() {
  NIntegers&lt;100&gt; result = MakeNRandomIntegers&lt;100, 500&gt;( BadRandomNumberGenerator );
  for (int i = 0; i &lt; 100; ++i) {
    std::cout &lt;&lt; i &lt;&lt; "":"" &lt;&lt; result.values[i] &lt;&lt; ""\n"";
  }
}
</code></pre>

<p>make each number 1 smaller in max than the last.  Sort them, then bump up each value by the number of integers before it.</p>

<p>template stuff is just trade dress.</p>
",0
11870775,11870743,13,"<p><code>y</code> is never being reset within the <code>x</code> loop, so once it goes out of bounds on the first pass it stays out of bounds forevermore.</p>
",1
11871099,11870743,2,"<p>Since <code>x</code> and <code>y</code> exist also outside the loop and since the loop don't set their initial value, they retain the last value even when reused.
This, in particular, is about your <code>y</code>, that does not rewind to the initial value after the y-loop exit.</p>

<p>To avoid this kind of problem, avoid to use variables external to a loop as indexes.</p>

<pre><code>void someFunction(const int x, const int y, const int width, const int length)
{
    int endX = x+width;
    int endY = y+length;

    printf(""x will not exceed: %i\n"", endX);
    printf(""y will not exceed: %i\n"", endY);

    for(int ix=x; ix &lt; endX; ++ix)
    {
        for(int iy=0; iy &lt; endY; ++iy)
        {
            printf(""(%i, %i)\n"", ix, iy);
        }
    }
}
</code></pre>

<p>HEre, by making the parameter const we ensure we cannot touch them, even by mistake. Then we use ix and iy local to the loops to handle iterations.</p>

<p>Also, unless you must for some other reason, avoid to use the postfix increment, and use prefix. Until you are using integers it's not a big change, but with more complex variables can make the difference.</p>

<p>It will also be a good idea (since you tagged the question as <code>C++</code> and not <code>C</code>) if you avoid to code like a C programmer.</p>

<p>The idiomatic C++ equivalent is this:</p>

<pre><code>#include &lt;iostream&gt;

void someFunction(const int&amp; x, const int&amp; y, const int&amp; width, const int&amp; length)
{
    const int endX = x+width;
    const int endY = y+length;

    std::cout &lt;&lt; ""x will not exceed: "" &lt;&lt; endX &lt;&lt; std::endl;
    std::cout &lt;&lt; ""y will not exceed: "" &lt;&lt; endY &lt;&lt; std::endl;

    for(int ix=x; ix &lt; endX; ++ix)
    {
        for(int iy=y; iy &lt; endY; ++iy)
        {
            std::cout &lt;&lt; '('&lt;&lt;ix&lt;&lt;"", ""&lt;&lt;iy&lt;&lt;')'&lt;&lt; std::endl;    
        }
    }
}

int main()
{
    someFunction(1, 1, 5, 5);
    return 0;
}
</code></pre>
",0
14242320,2746593,1,"<p>Nothing beats <a href=""http://see.stanford.edu/player/SEEslplayer.aspx?coll=11f4f422-5670-4b4c-889c-008262e09e4e&amp;co=175420f7-f467-42e4-adf1-29ebdb24e199&amp;sl=true"" rel=""nofollow"">stanford course</a> Its quite comprehensive</p>
",0
17080640,1311242,4,"<p>I think this does what you want, in combination with the standard library's strtod():</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int dtostr(char* buf, size_t size, double n)
{
  int prec = 15;
  while(1)
  {
    int ret = snprintf(buf, size, ""%.*g"", prec, n);
    if(prec++ == 18 || n == strtod(buf, 0)) return ret;
  }
}
</code></pre>

<p>A simple demo, which doesn't bother to check input words for trailing garbage:</p>

<pre><code>int main(int argc, char** argv)
{
  int i;
  for(i = 1; i &lt; argc; i++)
  {
    char buf[32];
    dtostr(buf, sizeof(buf), strtod(argv[i], 0));
    printf(""%s\n"", buf);
  }
  return 0;
}
</code></pre>

<p>Some example inputs:</p>

<pre><code>% ./a.out 0.1 1234567890.1234567890 17 1e99 1.34 0.000001 0 -0 +INF NaN
0.1
1234567890.1234567
17
1e+99
1.34
1e-06
0
-0
inf
nan
</code></pre>

<p>I imagine your C library needs to conform to some sufficiently recent version of the standard in order to guarantee correct rounding.</p>

<p>I'm not sure I chose the ideal bounds on <code>prec</code>, but I imagine they must be close.  Maybe they could be tighter?  Similarly I think 32 characters for <code>buf</code> are always sufficient but never necessary.  Obviously this all assumes 64-bit IEEE doubles.  Might be worth checking that assumption with some kind of clever preprocessor directive -- <code>sizeof(double) == 8</code> would be a good start.</p>

<p>The exponent is a bit messy, but it wouldn't be difficult to fix after breaking out of the loop but before returning, perhaps using <code>memmove()</code> or suchlike to shift things leftwards.  I'm pretty sure there's guaranteed to be at most one <code>+</code> and at most one leading <code>0</code>, and I don't think they can even both occur at the same time for <code>prec &gt;= 10</code> or so.</p>

<p>Likewise if you'd rather ignore signed zero, as Javascript does, you can easily handle it up front, e.g.:</p>

<pre><code>if(n == 0) return snprintf(buf, size, ""0"");
</code></pre>

<p>I'd be curious to see a detailed comparison with that 3000-line monstrosity you dug up in the Python codebase.  Presumably the short version is slower, or less correct, or something?  It would be disappointing if it were neither....</p>
",1
8806877,8806791,1,"<p>Because you are casting to it.</p>

<pre><code>class Bar {};

int main() {
  Bar *b = 0;
  typedef const Bar&amp; type;
  const type t = b;
  (void)t;
}
</code></pre>

<p>The example above spits next error:</p>

<pre><code>error: invalid initialization of reference of type 'type {aka const Bar&amp;}' from expression of type 'Bar*'
</code></pre>
",1
8806908,8806791,0,"<p>It appears that references are castable to pointers. Your expression is essentially,</p>

<pre><code>Bar &amp; r = reinterpret_cast&lt;Bar&amp;&gt;(b);
</code></pre>

<p>But in this explicit form, I get <em>two</em> warnings:</p>

<pre><code>warning: casting ¡®Bar*¡¯ to ¡®Bar&amp;¡¯ does not dereference pointer [enabled by default]
warning: dereferencing type-punned pointer will break strict-aliasing rules [-Wstrict-aliasing]
</code></pre>

<p>But this isn't an error, it would seem.</p>
",0
8806931,8806791,4,"<p>A C-style cast tries different C++ cast types in turn:</p>

<blockquote>
  <p><code>[C++11: 5.4/5]:</code> <strong>The conversions performed by</strong></p>
  
  <ul>
  <li>a <code>const_cast</code> (5.2.11),</li>
  <li>a <code>static_cast</code> (5.2.9),</li>
  <li>a <code>static_cast</code> followed by a <code>const_cast</code>,</li>
  <li><strong>a <code>reinterpret_cast</code> (5.2.10)</strong>, or</li>
  <li>a <code>reinterpret_cast</code> followed by a <code>`const_cast</code>,</li>
  </ul>
  
  <p><strong>can be performed using the cast notation of explicit type conversion.</strong> The same semantic restrictions and behaviors apply, with the exception that in performing a static_cast in the following situations the conversion is valid even if the base class is inaccessible:</p>
  
  <ul>
  <li>[..]</li>
  </ul>
</blockquote>

<p>And then follows various complex rules that I can't be bothered to parse in detail.</p>

<p>You get the requisite warnings that it's a stupid cast, but since it's what you asked for it's what's attempted.</p>

<p>Compare with:</p>

<pre><code>class Bar {};

int main() {
  Bar *b = 0;
  typedef const Bar&amp; type;
  const type t = static_cast&lt;type&gt;(b);
}

// In function 'int main()':
// Line 6: error: invalid static_cast from type 'Bar*' to type 'const Bar&amp;'
// compilation terminated due to -Wfatal-errors.
</code></pre>
",9
13434557,1526792,0,"<p><strong>Flip them around if it isn't compiling. Put ""Position"" in front of ""Triangle""</strong></p>
",0
11521229,11521155,3,"<p><code>Can this be a problem?</code></p>

<p>-if you initilize them before usage and don't forget to release (in case of pointers) i don't see any problems. </p>

<p><code>What happens to members that aren't explicitly copied (btw, no pointers in these members)? they are also not initialized in the constructor</code></p>

<p>-they hold garbage</p>

<p><code>Can this lead to any ""hidden"" problems?</code></p>

<p>-no, if you are carefull</p>

<p>But I would suggest you to initilized them in constructor in any case because it will be easier to catch errors that way and that makes you objects always stay in a complete state. For example It is much easier to catch a <code>nullptr</code> pointer then a garbage pointer or a pointer to a deallocated object. Since in first case the program will just crash (dereferencing null pointer is UB, but usually it's just a crash)</p>

<p>Also I would prefere creating local variables for storing intermediate results if possible. If it's not a single method intermediate result - then it's potentially a pit where you might fall if using this variable in other method before it's initialized. In that case it's much better to store zero initialized variable - so you can <code>assert</code> it is in a valid state before making computation on it</p>
",0
11521731,11521155,1,"<p>From the c++ point of view there is nothing wrong here, but c++ does not protect you from shooting yourself in the foot. In a few months you might be debugging an error that happens only in release builds, and then you will spend few days on finding out why this happens. There are lots of questions why my app works in Release but not in Debug, one of the cause is that debug heap initializes allocated memory.</p>
",0
11522697,11521155,1,"<p>If those variables are part of the state of the object, then they should be copied. If the variables are not part of the state of the object, they should not be members. A variable is part of the state of the object if the outcome of any function in the interface depends on the value of that variable before the operation starts.</p>

<p>There are few exceptions to the general rule above, in particular there are a few member variables that do not take part on the state of the object (they are usually marked as <code>mutable</code>) as synchronization mechanisms or caches for results from complex operations.</p>

<p>Going back to your problem, from the description it seems that you might be using those members only as a communication mechanism between different member functions. One function in the interface sets the values and then calls other functions that read/modify them. If that is the case, consider passing the variables to the functions as arguments. By using members you are effectively hiding the dependency of the functions towards those values, and at the same time adding a dependency to the class.</p>

<p>This will be much worse if any of the functions in the interface access those members, in which case after the assignment (or copy construction) the source and destination will behave differently, which breaks the assumption that after copy-initialization/assignment the source and destination objects are <em>equivalent</em>.</p>

<p>Basically, from a practical point of view, if those members are not part of the state of the object, you might get away with your current approach, but I would really reconsider the design. If they do take part in the state of the object, you should not by any means avoid copying them.</p>
",0
14213797,14213765,6,"<blockquote>
  <p>So inside a method I am killing the pointer to myself... and this isn't crashing...</p>
</blockquote>

<p>There's absolutely no reason why it would crash. You can have many pointers to an object. The fact they you're resetting one or more of them to NULL doesn't automatically mean that anything bad should happen.</p>

<p>Two types of problems to be aware of are:</p>

<ol>
<li>if you try to dereference a pointer after setting it to NULL, the behaviour of your code will be undefined (most likely it'll crash).</li>
<li>if the object is allocated on the heap (yours isn't) and you reset <em>all</em> pointers to it without calling <code>delete</code>, you'd leak memory.</li>
</ol>
",0
14213833,14213765,1,"<p>Your object remains untouched. Merely <em>some pointer to</em> the object is changed. That¡¯s not a problem. Here¡¯s a visualisation:</p>

<pre><code>+---------+
|   Obj   |  &lt;-------- pObj
+---------+
</code></pre>

<p>Now all you are doing inside <code>A::DoSomething</code> is removing the arrow from the picture above. <code>Obj</code> goes on as if nothing happened.</p>
",0
14213898,14213765,0,"<p>It isn't crashing, because from inside the instance access doesn't happen through the pointer stored in the variable <code>pObj</code>, but an internal, implicit constant pointer, that can be accessed by the <code>this</code> keyword (not that <code>this</code> is not that variable, it's just a way to get a pointer to where the instance is actually located in memory, but it behaves as a constant pointer for any practical application).</p>

<p>So when you overwrite the variable <code>pObj</code> with NULL, your object doesn't go away, and all internal references within the object are still valid, as those don't rely on any variables you define, but are resolved by the compiler to directly refer to the instances position in memory.</p>
",2
14213918,14213765,2,"<p>Consider pObj to be a piece of paper with an address written on it. If you burn this piece of paper, the building it was ""pointing to"" will remain intact. Removing all references and pointers to object does not free it automatically.</p>

<p>By the way, you can even call <code>delete this;</code> inside class's method and it will also work <em>unless</em> you'll try to access members of that instance after deleting. However, this solution should be used <em>only</em> when <em>really</em> needed.</p>

<p>Remember though, that if it is the only pointer to the instance, you will no longer have access to it and it will result in memory leak.</p>
",0
9154708,9154687,4,"<p>Yes, for most cases (i.e. excluding NaN): After the assignment <code>a = b;</code> the condition <code>a == b</code> is true. So as long as you're only assigning and comparing to the thing you assign from, this should be reliable, even for floating-point types.</p>
",1
9154840,9154687,1,"<p>I would avoid it. While the comparison would almost certainly work in the example you gave, it could fall apart unexpectedly when you use values that cannot be exactly expressed using a floating point variable. Where a value cannot be exactly expressed in a floating point variable some precision may be lost when copying from the coprocessor to memory, which would not match a value that stayed in the coprocessor the whole time.</p>

<p>My preference would be to add a range e.g. if (fabs(d)&lt;0.0001) or keep the information in a boolean.</p>

<p><strong>Edit:</strong> From <a href=""http://en.wikipedia.org/wiki/Floating_point#Representable_numbers.2C_conversion_and_rounding"" rel=""nofollow"">wikipedia</a>: ""For example, the decimal number 0.1 is not representable in binary floating-point of any finite precision; the exact binary representation would have a ""1100"" sequence continuing endlessly:""</p>

<p>So if you had if (d==0.1) that has the potential to create a big mess - are you sure you will <strong>never</strong> have to change the code in this way?</p>
",0
20529637,4937180,2,"<pre><code>class Base
{
public:
    int a;
}

class Derived : public Base
{
public:
    float b;
}

Base * pBase = new Base();
pBase-&gt;a = 7; // setting the value of a in the base

// make a pDerived that points to the SAME DATA as pBase
Derived * pDerived = pBase;
pDerived-&gt;a = 5; // this would be okay, base has a public member 'a'
pDerived-&gt;b = 0.2f; // error pBase has no data member b and pDerived
                    // points to the SAME DATA as pBase
</code></pre>
",0
11105384,11105333,4,"<p>A <code>const_cast</code> can only add or remove <code>const</code>-ness (or <code>volatile</code>-ness, though this is much less common). </p>

<p>A C-style cast can do the same as any of the ""new"" casts, except for a <code>dynamic_cast</code> (and it can do a few things none of them can do, though it's not really relevant here).</p>
",1
11105392,11105333,0,"<p>A const_cast is more restricted and won't let you do anything other than change const-ness. That makes it safer i.e. less accident-prone.</p>

<p>In addition it's easier to search for.</p>
",0
11105395,11105333,1,"<p>Same action. A C-style cast can cast away the const all the same.</p>

<p>The reason for const_cast is that it can serve as a searchable red flag, something to search for and carefully review/punish the guilty. The idea is that C++ is much more type-tight that C. So deliberate violations of the type system (such as violating const correctness), if not impossible, are easy to spot.</p>

<p>Making such violations of the type safety completely impossible would break too much backwards compatibility.</p>
",0
11105399,11105333,1,"<p><code>const_cast</code> can modify only the <em>const-ness</em> (or <em>volatile-ness</em>) of the argument, not it's <em>basic</em> type. So </p>

<pre><code> const T *tc = f();
 volatile T *tv = g();

 U *ua = const_cast&lt;U*&gt;(tc); //error
 U *ub = const_cast&lt;U*&gt;(tv); //error

 U *ub = (U*)(tc); //okay
 U *ub = (U*)(tv); //okay
</code></pre>

<p>So c-style cast modifies cv-qualified <code>T*</code> to <code>U*</code> without any problem.</p>
",0
11105347,11105333,2,"<p>C-style cast in C++ attempts a static cast, a reinterpret cast, a const cast, or a combination of those.</p>

<p>It is recommended to avoid C casts mainly because...</p>

<ul>
<li>reinterpret casts and const casts are used seldomly enough that it's good to emphasize what you're doing,</li>
<li>in other cases, when you want a static cast, writing it explicitly gives you additional compile-time checks compared to C casts.</li>
</ul>
",4
11105364,11105333,11,"<p>A <code>const_cast</code> conveys specific information about the intent behind the cast that a C cast cannot.</p>

<p>If you accidentally try to use a <code>const_cast</code> for purposes other than adding or removing <code>const</code> or <code>volatile</code>, the compiler will help you with an error message.</p>

<p>Also, <code>const_cast</code> is searchable, unlike a C-style cast.</p>
",0
13744250,13744177,3,"<p>Your first version doesn't handle the value <code>-1</code> properly. If you run <code>printHalf(-1)</code> it will print <code>0.5</code>, because it doesn't know that it needs to display <code>-0</code> instead of <code>0</code>.</p>

<p>For other negative values, it will work correctly in C++11, but relies on implementation-defined behavior in C++03 (the C++03 standard doesn't specify how division of negative numbers is rounded).</p>

<p>The second version may also print incorrect results: If the value is very large, the conversion to floating-point will reduce accuracy (since double-precision floating point can't represent all 64-bit integers accurately), so the result may be off by a little.</p>
",2
14149396,14149331,0,"<p>The first example is just a useless <code>typedef</code>.  I believe it's syntactically legal, but it doesn't provide a name for the type definition, so it's equivalent to:</p>

<pre><code>enum testfoo { enum1, enum2, enum3 );
</code></pre>

<p>In C, this creates a type with the name <code>enum testfoo</code>; it's common (but not necessary) to use a typedef to allow the type to be referred to as just <code>testfoo</code>.</p>

<p>In C++, the type can be referred to either as <code>enum testfoo</code> or as <code>testfoo</code>, even without the typedef.</p>

<p>I suspect someone was confused about the rules, saw that the type can be referred to (in C++) as <code>testfoo</code>, and incorrectly assumed that this was because of the <code>typedef</code>.</p>
",0
14149369,14149331,0,"<p>There is a difference. The second creates an alias for the <code>enum</code> but the first doesn't. The <code>typedef</code> in the first example doesn't actually do anything. This gives me a warning in GCC so I suspect you can take it out.</p>

<p>In C, it's common to <code>typedef</code> structs and enums so as to avoid instantiating with the struct or enum name. For instance:</p>

<pre><code>struct A {};

struct A a;
</code></pre>

<p>To shorten this, a <code>typedef</code> does the trick:</p>

<pre><code>typedef struct {} A;
</code></pre>

<p>This is no longer necessary in C++ so I'm deriving my assumption of his misconception with this concept. Or maybe the author forgot to give it a name...</p>

<p>The same thing occurs when using classes or structs:</p>

<pre><code>typedef struct A {}; // simply a class-declaration, generates a warning
</code></pre>
",2
16925113,16922373,3,"<p>You <em>can</em> achieve this, however it comes at some cost:</p>

<p>in C++ you can have <em>internal linkage</em>. Anything inside a unnamed namespace has internal linkage* (see footnote), as well as static free functions (you should prefer the anonymous namespace).</p>

<p><strong>Update:</strong> here's the C++11 standard quote from <strong>¡ì3.5,4</strong>:</p>

<blockquote>
  <p>An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has
  internal linkage. All other namespaces have external linkage. A name having namespace scope that has not
  been given internal linkage above has the same linkage as the enclosing namespace if it is the name of<br>
  ¡ª a variable; or<br>
  ¡ª a function; or<br>
  ¡ª a named class (Clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage purposes (7.1.3); or<br>
  ¡ª a named enumeration (7.2), or an unnamed enumeration defined in a typedef declaration in which the enumeration has the typedef name for linkage purposes (7.1.3); or<br>
  ¡ª an enumerator belonging to an enumeration with linkage; or<br>
  ¡ª a template.</p>
</blockquote>

<p>However, internal linkage applies to translation units, not to static libraries. So if you would use the usual approach putting each class in its own translation unit (=cpp), you could not define them inside anonymous namespaces because you could not link them together to build the library.<br>
You can solve this dilemma by making the whole library one single translation unit: one header providing the library's public interface, one source with the function definitions, and anything else as headers, defined in anonymous namespaces:</p>

<p><strong>mylib.hpp</strong> </p>

<pre><code>class MyLib {
public:
 int foo();
 double bar(int i);
};
</code></pre>

<p><strong>mylib.cpp</strong></p>

<pre><code>#include ""mylib.hpp""
#include ""mylibimpl.h""

int MyLib::foo() {
  return fooimpl();
}

double MyLib::bar(int i) {
  return BarImpl(i).do();
}
</code></pre>

<p><strong>mylibimpl.h</strong></p>

<pre><code>namespace {
  inline int fooimpl() { return 42; }

  class BarImpl {
    double d;
  public:

    BarImpl(int i) : d(i*3.42) {}
    double do() { return 2*d; }
  };
}
</code></pre>

<p>You'll now have one translation unit (<code>mylib.o</code> / <code>mylib.lib</code>), and all the <code>*impl</code> classes and functions cannot be seen from outside, because they have internal linkage.</p>

<p>The cost is that you have to reorganize the sources of your internal classes (e.g. to resolve circular dependencies) and that every simple change of the library's internal code will lead to one big recompilation of everything in the lib, just because there is only the single huge translation unit. So you should do this only when the library code itself is very stable or if the library is not too big.
The benefit besides the complete hiding of internal symbols is that the compiler will be able to pull out any optimization it wants, because no implementation details are hidden in different translation units.</p>

<p>*<strong>Footnote:</strong>
As was commented by Billy ONeal, in C++03 entities in anonymous namespaces have <em>not</em> necessarily internal linkage. However, if they have external linkage, they have names unique to their tranlsation unit and are effectively not accessible from outside that TU, meaning that this procedure works in C++03 as well.</p>
",4
15536982,15536688,3,"<p>Provided that the size and alignment requirements of <code>typeT</code> and <code>typeU</code> are identical, you can use uninitialized storage allocated for <code>typeT</code> to hold a value of <code>typeU</code>.</p>

<p>If <code>typeT</code> and/or <code>typeU</code> have constructors or destructors, you must ensure that they are called appropriately, and in the right order.</p>

<pre><code>static_assert(sizeof(typeT) == sizeof(typeU))
static_assert(alignof(typeT) == alignof(typeU))

typeT t[10];

&amp;t[0]-&gt;~typeT(); // placement delete t[0] to uninitialize
typeU* p = &amp;t[0];
new (p) typeU(); // construct typeU at t[0]

typeU u&amp; = *p;

u.doStuff();

p-&gt;~typeU(); // placement delete typeU at t[0]

new (&amp;t[0]) typeT(); // reconstruct typeT at t[0]
</code></pre>
",5
15545380,15536688,0,"<p>I just discovered this <a href=""http://www.gotw.ca/publications/mill05.htm"" rel=""nofollow"">article by Sutter</a> which introduces something I didn't knew</p>

<blockquote>
  <p>Any memory that's allocated dynamically via new or malloc is
  guaranteed to be properly aligned for objects of any type, but buffers
  that are not allocated dynamically have no such guarantee</p>
</blockquote>

<p>This means, first of all, that doing like I was doing is wrong:</p>

<pre><code>typeT buff[N];
new (buff) typeU[K];
</code></pre>

<p>Because buff is not allocated dynamically, so there is no guarantee.</p>

<p>So, the point is: to do this kind of handling, memory has to be dynamically allocated. If it is not, the answer depends on the alignment.</p>
",0
12823481,12823452,0,"<p>They are evaluated right to left, as it written in the table you linked. It is equivalent of this:</p>

<pre><code>int myvalue = (true ? 1 : 0);
</code></pre>
",0
12823512,12823452,7,"<p>In this statement</p>

<pre><code>int myvalue = true ? 1 : 0;
</code></pre>

<p>there's only one operator, the ternary operator. There's no assignment operator here, so precedence doesn't matter.</p>

<p>Don't confuse initialization with assignment:</p>

<pre><code>int myvalue;
myvalue = true ? 1 : 0; // now priorities are important
</code></pre>
",18
12823581,12823452,3,"<p>From your link:</p>

<blockquote>
  <p>Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression a=b=c is parsed as a=(b=c), and not as (a=b)=c because of right-to-left associativity.</p>
</blockquote>

<p>Since both <code>=</code> and <code>?:</code> are in the same cell and have right-to-left associativity, the ternary is guaranteed to evaluate first.</p>
",1
12823661,12823452,0,"<p>Right-to-left:</p>

<pre><code>int myValue1 = 20, myValue2 = 30;

myValue1 = true ? 1 : 0; // which is the same as:
myValue1 = ((true) ? (1) : (0));

// myValue == 1 &amp;&amp; myValue2 == 30

true ? myValue1 : myValue2 = 5; // which is the same as:
(true) ? (myValue1) : ((myValue2) = (5));

// myValue == 1 &amp;&amp; myValue2 == 30

false ? myValue1 : myValue2 = 5; // which is the same as:
(false) ? (myValue1) : ((myValue2) = (5));

// myValue == 1 &amp;&amp; myValue2 == 5
</code></pre>

<p>This is guaranteed in the C++ language</p>
",0
18271166,1582372,1,"<p>Actually the RGBA part of unsigned long should be:</p>

<p>int iR = (value) &amp; 0xff;<br>
int iG = (value >> 8) &amp; 0xff;<br>
int iB = (value >> 16) &amp; 0xff;<br>
int iA = (value >> 24) &amp; 0xff;<br></p>

<p>and the whole question is about BGRA (according to question's example) rather than RGBA.</p>
",0
10645272,10644754,0,"<p>It's absolutely valid because, as GManNickG and tomato said, all enums are of type int (in fact, in C, enums ARE ints and you can assign them values outside the scope of the enum.</p>

<pre><code>typedef enum _foo
{
   val1 = 57
} foo;
...
foo f = 99; // compiles in C but not C++
</code></pre>

<p>In fact, most compilers won't complain if the function argument type was bool or float or some other primitive number type because enums act as constant integer values like 0, -1, 200, etc...</p>

<p>What I'd say though, is that, if you have control over someFunc's signature and you want to ensure in C++ that no invalid values are passed in, change it to be</p>

<pre><code>void someFunc(SomeEnum a);
</code></pre>

<p>for more typesafety</p>

<p>Also, always initialize your first enum value at least. I may be wrong on this but, back in the day, the compiler was allowed to pick an arbitrary starting value for your enum. Most of the time it picked 0 but not always. Even if that's not the case, it makes the code a little more self documenting and obvious.</p>
",1
10644824,10644754,7,"<p>An <code>enum</code> has an underlying integer type (the type used to store the value of the <code>enum</code>), and the <code>enum</code> value can be implicitly converted to that integer type's value.</p>

<p>In your case the underlying type is <code>int</code>, and the value is 0. Everything is okay.</p>
",1
10644902,10644754,0,"<p>The identi?ers in an enumerator list are declared as constants that have type int and may appear wherever such are permitted.</p>

<p>6.7.2.2 here <a href=""http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf"" rel=""nofollow"">http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf</a></p>
",0
9200852,9200827,23,"<p>It is not the passing-mode that involves a copy. </p>

<p>It is the initialization of the members that invove a copy (obviously? the parameters don't live in the class, and the class members need to get the same value: copy)</p>

<p>Let's examine</p>

<pre><code>Employee::Employee( const string &amp;first, const string &amp;last, 
   const Date &amp;dateOfBirth, const Data &amp;dateOfHire)
   : firstName( first),
     lastName( last),
     birthDate(dateOfBirth),
     hireDate(dateOfHire) { };

//
int main()
{
    const std::string fname = ""test"";
    Employee e(fname, /* ..... */);
}
</code></pre>

<ol>
<li>We invoke <code>Employee::Employee</code>, passing <code>fname</code> by <code>const&amp;</code> (<em>no copy</em>).</li>
<li>The constructor initializes it's member firstname from the first parameter</li>
<li>This exercises <code>std::string(const std::string&amp;)</code>, again passing the parameter on by <code>const&amp;</code> (still no copy).</li>
<li>The <code>std::string</code> copy constructor now takes all necessary steps to copy the the value of it's parameter into the object itself. <strong>This is the copy</strong></li>
</ol>

<p>It makes sense that when you construct a new <code>std::string</code> (in this case as a member of Employee), it results in a ... new <code>std::string</code>. Thinking of it this way makes it very easy to grasp, I think.</p>
",2
9200868,9200827,3,"<p>The point of ""pass by reference"" is to not make a copy as soon as Employee constructor is called, but only when you choose to initialize one of Employee's member with the Date passed.</p>
",3
9200883,9200827,5,"<p>Your original object <code>birth</code> is indeed passed by reference to the <code>Employee</code> copy constructor, so no copy is made at that stage. However, when the <code>Employee</code> copy is being constructred, the <strong>member</strong> <code>Employee::birthDate</code> object is initialized by using <em>its own</em> copy constructor, to which the outer <code>birth</code> object is passed by reference, but that copy constructor will of course make a copy of the <code>birth</code> object, which becomes the <code>Employee::birthDate</code> member object.</p>
",0
9200884,9200827,4,"<p>These two lines are going to invoke the Date's copy constructor :  </p>

<pre><code> birthDate(dateOfBirth),
 hireDate(dateOfHire)
</code></pre>
",0
11873553,11872965,-1,"<p>Use a custom string class that zeros the memory buffer in its destructor.</p>

<pre><code>class zeroed_string : public std::string
{
public:
    ~zeroed_string()
    {
        for (int i = 0; i &lt; size(); ++i)
            (*this)[i] = 0;
    }
// ...
};
</code></pre>
",6
11873110,11872965,8,"<p>I would use <code>std::vector</code> with a custom allocator that does the zero'ing out.  According to the answer at <a href=""https://stackoverflow.com/questions/8190950/may-stdvector-make-use-of-small-buffer-optimization"">May std::vector make use of small buffer optimization?</a>, it cannot use the small buffer optimization, and hence, with a custom allocator, you should be safe.  </p>

<p>If you take it a step further, and use that allocator to allocate the vector, and then use a smart pointer to ensure it's proper release (or do it manually), even the internal contents of the vector (such as the size) will be wiped out.</p>
",0
11873163,11872965,2,"<p>You can do this by allocating the string/vector using raw memory and placement new and when you're done with it, call the destructor, zero memory, and deallocate raw memory.</p>
",5
14175937,14175725,1,"<p>This is just some code for testing Remote desktop connection -</p>

<blockquote>
  <p>There is an ""echo"" listener that is implemented by the Remote Desktop Connection (RDC) client, which is always present and listening for incoming connections. When you are writing the server side of a dynamic virtual channel (DVC) module, as a quick test you can open an endpoint named ""ECHO"". Any write to a channel that is instantiated from this endpoint will result in the receipt of the same data.</p>
</blockquote>

<p>From <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb540879%28v=vs.85%29.aspx"" rel=""nofollow"">MSDN</a>.
Such projects are usually included in some SDK. And this one seems to be part of <a href=""http://msdn.microsoft.com/en-US/windows/desktop/aa904949"" rel=""nofollow"">Windows 8 SDK</a></p>

<p>Update: After a critique from Tim (see below), i've decided to add these links with MSDN information -
<a href=""http://blogs.msdn.com/b/rds/archive/2007/09/19/ts-teleport-sample-instructions.aspx"" rel=""nofollow"">Remote Desktop Services. TS-Teleport: Sample Instructions</a> and <a href=""http://blogs.msdn.com/b/rds/archive/2007/09/20/dynamic-virtual-channels.aspx"" rel=""nofollow"">
Remote Desktop Services Blog. Dynamic Virtual Channels</a></p>
",4
14152642,14152137,0,"<p>I think your problem is different than converting reference to value. Even if a function uses call by value method it will happily take a reference variable. I have tried that on visual studio and its works fine.</p>

<p>During function call the compiler generally does a type checking on the params. I think you should look at the type of the value returned by the collections[i]. 
Your compiler error indicates that there is type mismatch. I don't think it has anything to do with call by value and call by reference.</p>
",0
14154066,14152137,0,"<p>If you just want to pass the value to nextFunction you need to add a const to your method</p>

<pre><code>nextFunction(double&amp; par);
</code></pre>

<p>will cause your error.</p>

<pre><code>nextFunction(const double&amp; par);
</code></pre>

<p>or</p>

<pre><code>nextFunction(double par);
</code></pre>

<p>would cause automatic conversion.
So if you really want par to be changed inside of nextFunction you need</p>

<pre><code>nextFunction(int&amp; par);
</code></pre>
",0
10820366,10820329,4,"<p>Only a templated version can possibly make sense:</p>

<pre><code>Buffer(char * data, std::size_t len) { /* ... */ }

template &lt;std::size_t N&gt; Buffer(char (&amp;data)[N]) : Buffer(data, N) { }
</code></pre>

<p>(Note that delegating constructors are new and not very widely supported yet. I just use one here for example's sake.)</p>
",1
10820367,10820329,0,"<p>Sure, <code>Buffer(std::vector&lt;char&gt; data)</code>. (IOW, don't use <code>char*</code>.)</p>
",0
15592755,15592735,3,"<p>You are using a 32 bit integer. You could use instead a 64 bit integer, <code>int64_t</code>. Or if you need more range than that then use a big integer class with arbitrary precision.</p>

<p>But I urge you not to use floating point arithmetic for integer calculations. That will just be inaccurate.</p>
",0
15592766,15592735,0,"<blockquote>
  <p>Can I substitute double v1 = 0, v2 = 0 into my code?</p>
</blockquote>

<p>You can, but there are caveats which arise when you start using floating-point numbers. Watch out for them.</p>

<blockquote>
  <p>is there a way to make it output the full length of the answer</p>
</blockquote>

<p>You want to do some <code>iomanip</code>:</p>

<pre><code>#include &lt;iomanip&gt;

std::cout &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(2) &lt;&lt; val;
</code></pre>
",0
10786490,10786436,13,"<p>What exactly does your <code>throw</code> look like? Are you using your <code>operator&lt;&lt;</code> before calling throw, like this:</p>

<pre><code>throw w32file_exception&lt;T&gt;() &lt;&lt; ""fooobar"";
</code></pre>

<p>Then the answer is, that your <code>operator&lt;&lt;</code> returns an <code>error_stream</code> and no <code>w32file_exception</code> and so the type of the thrown exception is <code>error_stream</code>.</p>

<p>You could solve this problem this way:</p>

<pre><code>template&lt;typename T, typename DERIVED&gt;
    class error_stream : public std::runtime_error
{
public:
    // ...
    template &lt;typename U&gt;
        DERIVED &amp; operator &lt;&lt; (const T &amp; t)
    {
        *ss &lt;&lt; t;
        return static_cast&lt;DERIVED&amp;&gt;(*this);
    }
    // ...
};
</code></pre>

<p>But then you loose the ability to catch every <code>error_stream</code> exception because it is a new Type for every <code>DERIVED</code> type.</p>
",3
13723062,13723019,2,"<p>Yes there is. See the <a href=""http://www.cplusplus.com/reference/vector/vector/reserve/"" rel=""nofollow"">reserve</a> method. It will request that a vector's capacity be at least enough to contain the number of elements sent as its argument. If you can anticipate an upper bound on the number of items that you want to store in a vector, then you can reserve that amount of space in your vector.</p>

<p>Example from the above link -</p>

<pre><code>// vector::reserve
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main ()
{
    std::vector&lt;int&gt;::size_type sz;

    std::vector&lt;int&gt; foo;
    sz = foo.capacity();
    std::cout &lt;&lt; ""making foo grow:\n"";
    for (int i=0; i&lt;100; ++i) {
        foo.push_back(i);
        if (sz!=foo.capacity()) {
            sz = foo.capacity();
            std::cout &lt;&lt; ""capacity changed: "" &lt;&lt; sz &lt;&lt; '\n';
        }
    }

    std::vector&lt;int&gt; bar;
    sz = bar.capacity();
    bar.reserve(100);   // this is the only difference with foo above
    std::cout &lt;&lt; ""making bar grow:\n"";
    for (int i=0; i&lt;100; ++i) {
        bar.push_back(i);

        // This block will execute only once
        if (sz!=bar.capacity()) {
            sz = bar.capacity();
            std::cout &lt;&lt; ""capacity changed: "" &lt;&lt; sz &lt;&lt; '\n';
        }
    }

    return 0;
}
</code></pre>

<p>You will see that as you add more elements to the <code>foo</code> vector, its capacity keeps increasing, but in the second case, since it has already reserved 100 element's space, the capacity is changed only once.</p>

<p><a href=""http://ideone.com/Tl0rZc"" rel=""nofollow"">Here</a> is a running example.</p>
",3
13723159,13723019,1,"<p>Considering the class is given a value during the constructor the smart thing would be to store an initial size of the vector. Inefficiency comes along when the user is constantly extending the size of the vector as opposed to setting a base length of the vector to begin with. </p>

<pre><code>//consider the vector reads in chars from a string
VecClass::VecCalss(char * str)
{
    size_t LEN = strlen(str);
    Vect = std::vector&lt;char&gt;(LEN, '\0'); //start with the initial size of the char
}
</code></pre>

<p>setting an initial size reduces the amount of times a vector is needed to be extended in a program.</p>

<p>EDIT: or the reserve method would do just about the same, never knew a reserve function existed(pretty handy!). </p>
",0
12333085,12333062,-2,"<p>You allocate on the heap only when you need to dynamically allocate the memory. Meaning you do not know how much you need to allocate at compile time.
You allocate on the stack all other times</p>
",4
12333105,12333062,5,"<p>I prefer to allocate on the stack, for two reasons.  First, all else being equal, it is faster than heap.  Also, the deallocation happens automatically, I don't need to rememeber to <code>delete</code> it (of course, there are <code>auto_ptr</code>s and such to help with that).</p>

<blockquote>
  <p>a pointer is really needed</p>
</blockquote>

<p>It is OK to pass a pointer to an object on the stack.  Just make sure the user of that pointer does not access the object after its lifetime expires.</p>

<blockquote>
  <p>the class or array is too big for the stack</p>
</blockquote>

<p>Only for really big things should this matter.  You've probably got 1MB of stack, so you can put about 1000 1KB objects before there's a problem.</p>

<blockquote>
  <p>inheritance requires it</p>
</blockquote>

<p>Why would it?</p>

<blockquote>
  <p>something else?</p>
</blockquote>

<p>The lifetime required of the object is longer than the lifetime of the stack frame.  This is the principal reason to allocate on the heap.</p>
",3
12333199,12333062,8,"<p>Your default behavior should be:</p>

<p>If the lifespan of the object is consistent with a specific scope<br>
ie easily determined at compile time</p>

<blockquote>
  <p>then it should be an automatic storage duration object (stack like)</p>
</blockquote>

<p>If the lifespan of the object is defined at runtime and extends beyond the current scope</p>

<blockquote>
  <p>Then it should be a a dynamic storage duration object (heap like)</p>
</blockquote>

<p>Note: All dynamic storage duration objects should have their lifespan controlled by wrapping them in a an appropriate RAII class. Usually this means: For single objects a smart pointer, while multiple objects end up in a container.</p>

<p>I <strong>hate</strong> to see things defines as <em>stack Vs heap</em>. As it does not convey the real semantics of the situation.</p>

<pre><code> int x;       // its on the stack
 struct X
 {
     int x;   // Is this a stack or heap object?
 }            // It depends on its parent.


 // But in both cases it is an automatic storage duration object.
 // In both cases the lifespan's are well defined.
 //     The first is defined by the scope it is declared within.
 //     The second is defined by the lifespan of its parent.
</code></pre>

<p>You should be thinking in terms of automatic/dynamic 'storage duration' objects. This conveys the correct semantics of the language.</p>

<p>Note there are two other types of variable thus making four different types of variable. automatic/dynamic/static/thread 'storage duration' objects.</p>
",2
12333428,12333062,1,"<blockquote>
  <p>When should a class be allocated on the stack instead of the heap?</p>
</blockquote>

<p>Whenever possible and not a great inconvenience. There will be exceptions, but to answer your question as a general rule: When creating an instance, <code>new</code>/<code>new[]</code> should be <em>typed</em> less than one percent of the time.</p>

<hr>

<blockquote>
  <p>a pointer is really needed (ie the lifetime of the object to outlast the scope of declaration)</p>
</blockquote>

<p>Yes, in appropriate cases. Judging by your use of the heap described in the OP, this is likely going to be necessary far less often than you believe.</p>

<blockquote>
  <p>the class or array is too big for the stack</p>
</blockquote>

<p>Yes, <strong>but</strong> that should not be much of a concern -- a class that large <em>typically</em> indicates that something is fundamentally wrong with your class. Client friendly classes might consider creating those huge, fixed sized arrays on the heap.</p>

<blockquote>
  <p>inheritance requires it (abstract base class/interface)</p>
</blockquote>

<p>In some cases (e.g. where an abstract factory or deep clone of polymorphic type is present), but then it is the <em>factory</em> that creates the type, and the problem is often shifted away from your program's use of the stack before you can consider it.</p>

<blockquote>
  <p>something else?</p>
</blockquote>

<p>No</p>

<hr>

<p>The reasons:</p>

<ul>
<li>it's clear, succinct, and its lifetime and scope are well determined.</li>
<li>less resource consumption.</li>
<li>fewer memory related bugs or things that could go wrong.</li>
<li>speed. the stack allocation is very fast. fewer locks.</li>
</ul>
",0
14206672,1549930,31,"<p>In C++11, to_string is finally added to the standard.</p>

<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string"" rel=""noreferrer"">http://en.cppreference.com/w/cpp/string/basic_string/to_string</a></p>
",2
8783281,8783232,1,"<p>Use template specialization. The first Adaptor is the 'default' template, but the latter will be used only for <code>Adaptor&lt;A&gt;</code>.</p>

<pre><code>template&lt;typename T&gt;
struct Adaptor
{
    T t;

    Adaptor(int x, int y)
        : t(x,y)
    {
    }


};

template&lt;&gt;
struct Adaptor&lt;A&gt; {
    A t;
    Adaptor(int x, int y)
        : t(x)
    {
    }
};
</code></pre>
",1
8783495,8783232,6,"<p>A variant of @Aaron's approach:</p>

<pre><code>#include &lt;type_traits&gt;
#include &lt;utility&gt;

enum EArity { EZero = 0, EOne, ETwo, EThree, Error };

template &lt;typename T, typename A1, typename A2, typename A3&gt; struct getArity
{
    static const EArity arity =
       std::is_constructible&lt;T&gt;::value             ? EZero  :
       std::is_constructible&lt;T, A1&gt;::value         ? EOne   :
       std::is_constructible&lt;T, A1, A2&gt;::value     ? ETwo   :
       std::is_constructible&lt;T, A1, A2, A3&gt;::value ? EThree : Error;
};

template &lt;typename T, EArity A&gt; struct Construct;

template &lt;typename T&gt; struct Construct&lt;T, EZero&gt;
{
    T t;

    template &lt;typename A1, typename A2, typename A3&gt;
    Construct(A1 &amp;&amp; a1, A2 &amp;&amp; a2, A3 &amp;&amp; a3) : t() { }
};

template &lt;typename T&gt; struct Construct&lt;T, EOne&gt;
{
    T t;

    template &lt;typename A1, typename A2, typename A3&gt;
    Construct(A1 &amp;&amp; a1, A2 &amp;&amp; a2, A3 &amp;&amp; a3) : t(std::forward&lt;A1&gt;(a1)) { }
};

// ...

template &lt;typename T&gt;
struct AdapterIntIntInt : Construct&lt;T, getArity&lt;T, int, int, int&gt;::arity&gt;
{
    Adapter(int a, int b, int c)
    : Construct&lt;T, getArity&lt;T, int, int, int&gt;::arity&gt;(a, b, c) { }
};

template &lt;typename T, typename A1, typename A2, typename A3&gt;
struct Adapter : Construct&lt;T, getArity&lt;T, A1, A2, A3&gt;::arity&gt;
{
    Adapter(A1 &amp;&amp; a1, A2 &amp;&amp; a2, A3 &amp;&amp; a3)
    : Construct&lt;T, getArity&lt;T, A1, A2, A3&gt;::arity&gt;
      (std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2), std::forward&lt;A3&gt;(a3))
    { }
};
</code></pre>
",11
8783823,8783232,2,"<p>Another variant:</p>

<pre><code>#include &lt;boost/utility/enable_if.hpp&gt;

struct A {
    A(int) {}
};

struct B {
    B(int, int) {}
};

template &lt;class T&gt;
struct arg_count {
};

template &lt;&gt;
struct arg_count&lt;A&gt; {
    const static int count = 1;
};

template &lt;&gt;
struct arg_count&lt;B&gt; {
    const static int count = 2;
};

template &lt;class T&gt;
struct Adaptor : public T {
    template &lt;class A1, class A2&gt;
    Adaptor(A1 a1, A2 a2, typename boost::enable_if_c&lt;arg_count&lt;T&gt;::count == 1, A1&gt;::type* = 0) : T(a1) {}

    template &lt;class A1, class A2&gt;
    Adaptor(A1 a1, A2 a2, typename boost::enable_if_c&lt;arg_count&lt;T&gt;::count == 2, A2&gt;::type* = 0) : T(a1, a2) {}
};


int main() {
    Adaptor&lt;A&gt; a(1, 2);
    Adaptor&lt;B&gt; b(1, 2);
}
</code></pre>
",4
9855745,9855560,1,"<p>I don't think that's possible, without changing the function parameter of addListener() to having a MouseEvent* parameter (or one derived from MouseEvent) instead of an IEvent* parameter. </p>

<p>If you have eventHandlers that take pointers to other classes (derived from IEvent) as a parameter, you'd thus need a separate addListener() function for each of these, which probably isn't what you want.</p>

<p>Simply passing an IEvent* and then casting it to the appropriate type in the eventHandler (as you're currently doing) is probably the way to go.</p>

<p>As an example, Qt actually does something something similar for its eventFilters: <a href=""http://qt-project.org/doc/qt-4.8/eventsandfilters.html"" rel=""nofollow"">http://qt-project.org/doc/qt-4.8/eventsandfilters.html</a></p>
",0
9855903,9855560,1,"<p>Sort of wasteful as it creates a dummy wrapper around each listener.  However, I don't know if it is possible to cleanly convert <code>std::function</code> objects otherwise.  If you accept only function pointers (but then lambdas are ruled out, meh) in <code>addListener()</code>, you could convert directly.  Also, some <code>reinterpret_cast</code> could help, but I don't feel easy about that, so the solution doesn't feature one.</p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;

struct IEvent { };
struct MouseEvent : IEvent { };

template &lt;typename type&gt;
std::function &lt;void (IEvent*)&gt;
convert_callback (const std::function &lt;void (type*)&gt;&amp; callback)
{
  static_assert (std::is_convertible &lt;type*, IEvent*&gt;::value, ""wrong type"");
  return [=] (IEvent* event) { return callback (static_cast &lt;MouseEvent*&gt; (event)); };
}

struct dispatcher
{
  template &lt;typename type&gt;
  void
  addListener (std::function &lt;void (type*)&gt; callback)
  {
    std::function &lt;void (IEvent*)&gt;  real_callback (convert_callback (callback));
    MouseEvent  event;
    real_callback (&amp;event);
  }
};

void
callback (MouseEvent*)
{
  std::cout &lt;&lt; ""hello\n"";
}

int
main ()
{
  dispatcher x;
  x.addListener &lt;MouseEvent&gt; (&amp;callback);
}
</code></pre>

<p>Any reason to pass <code>event</code> as pointer and not reference, btw?</p>
",0
15573608,15573507,9,"<p>No, you do not have to. You can define a type alias for an incomplete class, and template arguments can be incomplete types (see Paragraph 14.3.1/2 of the C++11 Standard):</p>

<pre><code>#include &lt;memory&gt;

struct C;

typedef std::shared_ptr&lt;C&gt; ptrC; // C is incomplete here

struct C { void foo() { } };

int main()
{
    ptrC p = std::make_shared&lt;C&gt;();
    p-&gt;foo();
}
</code></pre>

<p>As correctly mentioned by <a href=""https://stackoverflow.com/users/964135/pubby"">Pubby</a> in the comments, function declarations do not require the types mentioned in their signature to be complete either:</p>

<pre><code>struct C;

void foo(C); // C is incomplete here

struct C { };

#include &lt;iostream&gt;

void foo(C)
{
    std::cout &lt;&lt; ""foo(C)"" &lt;&lt; std::endl;
}

int main()
{
    C c;
    foo(c);
}
</code></pre>
",2
15573646,15573507,3,"<p>No, <code>std::shared_ptr&lt;T&gt;</code> is explicitly designed to work when <code>T</code> is only forward-declared. Of course, this does not work for all cases, but the principle is the same as for a plain pointer. If <code>T</code> is forward-declared, you can do anything with <code>std::shared_ptr&lt;T&gt;</code> that you could do with <code>T*</code>.</p>
",0
15573728,15573507,0,"<p>you can use typedef with incomplete type.</p>

<p>But isn't it better to use full name of the smart pointer type?</p>

<p><code>MyClassPtr</code> is of course much shorter, but <code>std::unique_ptr&lt;MyClass&gt;</code> actually tells us how to use this pointer. So for not very long names I suggest using full names of smart pointers.</p>
",1
16443486,4141078,0,"<p>Mathematically speaking, the number of decimal digits of an integer is <code>1+int(log10(abs(a)+1))+(a&lt;0);</code>.</p>

<p>You will not use strings but go through floating points and the log functions. If your platform has whatever type of FP accelerator (every PC or similar has) that will not be a big deal ,and will beat whatever ""sting based"" algorithm (that is noting more than an iterative divide by ten and count)</p>
",0
9224435,9223623,1,"<p><a href=""http://valgrind.org/"" rel=""nofollow"">Valgrid</a> is good - works on Linux &amp; Mac. You might want to try <a href=""http://vld.codeplex.com/"" rel=""nofollow"">Visual Leak detector</a> for windows.</p>
",0
9223649,9223623,3,"<p>There are a lot of tools available for that. E.g special libraries like <a href=""http://dmalloc.com/"" rel=""nofollow"">dmalloc</a> libraries like libfence. On Linux especially Valgrind is very useful. </p>

<p>so the best ""bet"" probably is that you get some malloc debug libraries source code and use it in all your developments. </p>
",0
9223706,9223623,2,"<p>I would suggest running valgrind on Linux and Mac OSX, and Microsoft Application Verifier on Windows. Both tools are free.</p>

<p>If you would like to do it in code you can keep track of allocations in a map. At program exit you simply check if the map is empty. If you use macros you can store the source line and file with the allocation record in the map. I do however believe that using a tool is simpler and better. They can help you with much more than tracking new/delete, and do not require changes to your code.</p>
",2
9833145,9833112,1,"<p>Well one way (not necessarily the most efficient) is to implement the usual arithmetic operators and then just do the following:</p>

<pre><code>// (pseudo-code)
// String to BigInt

String s = ...;
BigInt x = 0;

while (!s.empty())
{
    x *= 10;
    x += s[0] - '0';
    s.pop_front();
}

Output(x);

// (pseudo-code)
// BigInt to String

BigInt x = ...;
String s;

while (x &gt; 0)
{
    s += '0' + x % 10;
    x /= 10;
}

Reverse(s);
Output(s);
</code></pre>

<p>If you wanted to do something trickier than you could try the following:</p>

<ol>
<li>If input I is &lt; 100 use above method.</li>
<li>Estimate D number of digits of I by bit length * 3 / 10.</li>
<li>Mod and Divide by factor F = 10 ^ (D/2), to get I = X*F + Y;</li>
<li>Execute recursively with I=X and I=Y</li>
</ol>
",0
9833148,9833112,0,"<p>Take a look at, for instance, <code>mp_toradix</code> and <code>mp_read_radix</code> in Michael Bromberger's MPI.</p>

<p>Note that repeated division by 10 (used in the above) performs very poorly, which shows up when you have very big integers. It's not the ""be all and end all"", but it's more than good enough for homework.</p>

<p>A divide and conquer approach is possible. Here is the gist. For instance, given the number 123456789, we can break it into pieces: 1234 56789, by dividing it by a power of 10. (You can think of these pieces of two large digits in base 100,000.   Now performing the repeated division by 10 is now cheaper on the two pieces! Dividing 1234 by 10 three times and 56879 by 10 four times is cheaper than dividing 123456789 by 10 eight times. </p>

<p>Of course, a really large number can be recursively broken into more than two pieces.</p>

<p>Bruno Haibl's CLN (used in CLISP) does something like that and it is blazingly fast compared to MPI, in converting numbers with thousands of digits to numeric text. </p>
",2
9833153,9833112,1,"<ol>
<li>Implement and test the string-to-number algorithm using a builtin type such as <code>int</code>.</li>
<li>Implement a bignum class with <code>operator+</code>, <code>operator*</code>, and whatever else the above algorithm uses.</li>
<li>Now the algorithm should work unchanged with the bignum class. </li>
</ol>

<p>Use the string conversion algo to debug the class, not the other way around.</p>

<p>Also, I'd encourage you to try and write at a high level, and not fall back on C constructs. C may be simpler, but usually does not make things easier.</p>
",0
12353086,12352876,3,"<p>Your managed code died with a NullReferenceException.  Its Exception.HResult value is 0x80004003, E_POINTER.</p>

<p>Clearly that's a very common reason for managed code to die.  In the transition from managed code back to native code, you'll lose a lot of context for the exception.  That puts a burden on the managed code to do some essential error logging, at least the all-mighty Exception.StackTrace.  The .NET 4 AppDomain.FirstChanceException event can be useful.</p>

<p>Debug the problem by enabling managed code debugging, Project + Properties, Debugging, Debugger Type = Mixed.  And Debug + Exceptions, Thrown checkbox for CLR exceptions so the debugger stops the program when the exception is thrown.</p>
",4
19373088,3420009,0,"<p>You want to use the manipulator called &quot;Fixed&quot; to format your digits correctly so they do not round or show in a scientific notation after you use fixed you will also be able to use set the precision() function to set the value placement to the right of the .
decimal point. the example would be as follows using your original code.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() 
{
    using namespace std;     
    
    double dValue = 0.19213;
    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; dValue &lt;&lt; endl;
    
}
</code></pre>
<p>outputs as:</p>
<pre><code>dValue = 0.19
</code></pre>
",0
9833582,9833464,1,"<p>Just from glancing at the code</p>

<ol>
<li><p>The virtual function should be the destructor. An abstract base class is best defined like this:</p>

<pre><code>class BaseGameObject {
public:
   virtual ~BaseGameObject() = 0;
};
inline BaseGameObject::~BaseGameObject() {}
</code></pre></li>
<li><p>The class inheritance should not be <code>virtual</code>. Virtual inheritance is only used if the base class will be multiply inherited from different branches of the inheritance hierarchy.</p></li>
<li><p>The binder should not be derived from BaseGameObject, because it is not a game object. Shouldn't it instead be derived from something like <code>BaseScriptObject</code>? Am I mistaken or is each expression/variable in the script engine either a reference to a game object or a native type like <code>int</code>? And the binder implements reference semantics like reference counting?</p></li>
</ol>
",1
8776116,2820285,20,"<p>std::abort and std::exit (and more: std::_Exit, std::quick_exit) are just lower level functions. You use them to tell the program what you want it to do exactly: what destructors (and if) to call, what other clean-up functions to call, what value to return, etc.</p>

<p>std::terminate is a higher level abstraction: it is called (by either run-time or you) to indicate that an error in the program occurred and that for some reason it is not possible to handle by throwing an exception. The necessity for that typically occurs when error occurs in the exception mechanism itself, but you can use it any time when you do not want your program to continue beyond the given error. I compiled the full list of situations when std::terminate is called <a href=""http://akrzemi1.wordpress.com/2011/09/28/who-calls-stdterminate/"">in my post</a>. It is not specified what std::terminate does, because you are in control of it. You can configure the behavior by registering any functions. The limitations you have are that the function cannot return back to the error site and it cannot exit via an exception, but technically you can even start your message pump inside. For the list of useful things that you can do inside, see <a href=""http://akrzemi1.wordpress.com/2011/10/05/using-stdterminate/"">my other post</a>.</p>

<p>In particular, note that std::terminate is considered an exception handler in contexts where std::terminate is called due to a thrown exception that could not be handled, and you can check what the exception was and inspect it by using C++11 using std::rethrow_exception and std::current_exception. It is all in <a href=""http://akrzemi1.wordpress.com/2011/10/05/using-stdterminate/"">my post</a>.</p>
",1
12295543,12293182,0,"<p>All visual studio versions have a matching redistributable package. This is an executable which when run will set up the SxS folder as needed. You're best off treating this as magic.</p>

<p><sup> I think SxS is one of the worst ideas Microsoft ever had in Win32 development </sup></p>
",1
17088737,17088601,4,"<p><a href=""http://en.cppreference.com/w/cpp/numeric/math/ldexp"" rel=""nofollow"">ldexp</a> and its dual, <a href=""http://en.cppreference.com/w/cpp/numeric/math/frexp"" rel=""nofollow"">frexp</a>, deal with the mantissa and exponent of a floating-point number.  They provide a way to get at the internal representation without doing direct bit manipulation.</p>
",0
17088781,17088601,4,"<p>When used with <code>frexp</code> , the <code>ldexp</code> function is useful in situations that require repeated multiplication by 2. If the next multiplication causes an overflow or underflow, use <code>frexp</code> to separate the mantissa from the exponent. This gives you complete control over the exponent and the mantissa, so you can operate on them separately without any loss of precision. When you are finished, use <code>ldexp</code> to combine the mantissa and exponent again.</p>

<p>See more details <a href=""http://support.sas.com/documentation/onlinedoc/sasc/doc700/html/lr1/z2055681.htm"" rel=""nofollow"">here</a>.</p>
",0
10154623,10154614,5,"<p>You are providing the constructor definition using initializer lists. So, it needs a <code>{}</code> like any other (member) function.</p>

<pre><code>MyCls2(int i, int j) : _i(i), 
                       _j(j) {} // Missing the opening and closing braces
</code></pre>
",0
10154624,10154614,3,"<p>You're missing the function body in your definition of the <code>MyCls2</code> constructor that takes two ints.</p>

<pre><code>MyCls2(int i, int j) : _i(i), 
                        _j(j) {}
</code></pre>

<p>Think of the initializer list as being part of the constructor itself (its definition, not its declaration). You can't have part of a function's definition somewhere, and another part elsewhere.</p>

<p>If you want the initializer list in the header, you need the rest of that definition (the constructor body) in the header too, as above.<br>
If you don't want the definition in the header, don't put the initializer list in the header, put it in the implementation file.</p>

<pre><code>//header
  MyCls2(int i, int j);
</code></pre>



<pre><code>// implementation

MyCls2::MyCls2(int i, int j) : _i(i), _j(j)
{
   // constructor body
}
</code></pre>
",6
10154629,10154614,1,"<p>replace</p>

<pre><code>MyCls2(int i, int j) : _i(i), 
                        _j(j)
</code></pre>

<p>with</p>

<pre><code>MyCls2(int i, int j) : _i(i), _j(j) { }
</code></pre>

<p>The constructor needs a body, even if it's an empty one.</p>
",0
10154637,10154614,1,"<p>Braces for constructor:</p>

<pre><code>MyCls2(int i, int j) : _i(i), 
                            _j(j) {}
</code></pre>
",0
9146523,9146167,13,"<p>This is actually possible (in C++11), and in two ways:</p>

<pre><code>struct Named {
  struct /*Unnamed*/ {
    void Function();
  } un;
  typedef decltype(un) Unnamed;
};

// #1
void Named::Unnamed::Function(){
}

//// #2
//typedef decltype(Named::un) Unnamed;
//void Unnamed::Function(){
//}
//// same way, using template alias
//template&lt;class T&gt; using alias = T;
//void alias&lt;decltype(Unnamed::un)&gt;::Function(){
//}

int main() {
  Named named;
  named.un.Function();
}
</code></pre>

<p><a href=""http://ideone.com/4LwlQ"">Live example on Ideone.</a></p>

<p>This is possible thanks to <code>$9.1 [class.name] p5</code>:</p>

<blockquote>
  <p>A <em>typedef-name</em> (7.1.3) that names a class type, or a cv-qualified version thereof, is also a <em>class-name</em>.</p>
</blockquote>
",1
11834333,11834316,3,"<p>You're returning an address that goes out of scope when the function exits, and so it's no longer valid: <code>std::string path</code> is local to the function <code>getINIFile</code> and so it's invalid after the function exits, as is the address that you get from <code>path.c_str()</code>.</p>

<p>In this case you can just return the <code>std::string</code> from your function. If you <em>really</em> need a C string later, you can use <code>c_str()</code> then:</p>

<pre><code>std::string getINIfile(void)
{
    //...

    return path;
}


int main()
{
    string path = getINIFile();

    // do something with path.c_str():
    const char *cPath = path.c_str();
}
</code></pre>

<p>Given your code I can't think of any reason that you must have a <code>char*</code> return, but if so you'll need to allocate a buffer on the heap:</p>

<pre><code>char *getINIfile(void)
{
    char *buffer[MAX_PATH];
    GetModuleFileName(NULL, buffer, MAX_PATH);
    string::size_type pos = string(buffer).find_last_of( ""\\/"" );
    string path = string(buffer).substr( 0, pos) + ""\\setup.ini"";

    char *ini_local = new[path.size()];
    strncpy(ini_local, path.c_str(), path.size());

    printf(ini_local); // so far output OK!

    return ini_local;
}
</code></pre>

<p>But this is a <strong>really awful mix</strong> of standard C strings and <code>std::string</code>: just using <code>string</code> to manipulate the path and passing around <code>char*</code> everywhere else.</p>

<p>Using only standard C, replacing <code>find_last_of</code> with <a href=""http://en.cppreference.com/w/c/string/byte/strrchr"" rel=""nofollow""><code>strrchr</code></a> - note the lack of error handling:</p>

<pre><code>char *getINIfile(void)
{
    char *buffer = new[MAX_PATH];
    char *pos = NULL;
    char *ini_local = NULL;

    GetModuleFileName(NULL, buffer, MAX_PATH);
    pos = strrchr(buffer, ""\\/"");
    // check for and handle pos == NULL

    buffer[pos] = '\0';

    strncat(buffer, ""\\setup.ini"", MAX_PATH - strlen(buffer));

    printf(buffer);

    return buffer;
}
</code></pre>
",2
11834336,11834316,1,"<p>The function is returning a pointer to a local variable, which goes out of scope, leaving you with a dangling pointer. Why not just return an <code>std::string</code> by value?</p>

<pre><code>std::string getINIfile() {
   ....
   return path;
}
</code></pre>

<p>Then you can just use the string's underlying <code>char*</code> on the caller side:</p>

<pre><code>const std::string s = getINIfile();
const char* c = s.c_str();
</code></pre>
",0
11834354,11834316,4,"<p>path goes out of scope at the end of the function and you are returning an internal pointer in that out of scope object. try returning an std::string instead</p>

<pre><code>std::string getINIfile(void)
{
    char buffer[MAX_PATH];
    GetModuleFileName( NULL, buffer, MAX_PATH );
    string::size_type pos = string( buffer ).find_last_of( ""\\/"" );
    string path = string( buffer ).substr( 0, pos) + ""\\setup.ini"";

    char *ini_local= (char*)path.c_str();

    printf(ini_local); // so far output OK!

    return path;
}
</code></pre>
",0
18183037,18182949,2,"<pre><code>struct Init
{
   Init() 
   {
      /* Your Initialization Code */
   }
} x;

int main()
{

}
</code></pre>
",0
18183057,18182949,10,"<h1>Initial answer</h1>

<p>You could use a constructor of an object at <code>namespace</code> scope.</p>

<pre><code>namespace {
struct Init
{
    Init()
    {
        // Initialization code here.
    }
} init_;
} // namespace
</code></pre>

<p>Beware, this has some limitations, especially on Windows. On Windows, the ctor is invoked with the loader lock held, thus you cannot do anything that would require loading DLLs and such. This includes initialization of WinSock because it can try to load external DLLs.</p>

<h1>Update</h1>

<p>According to some sources, you can work around this limitation by using <a href=""http://msdn.microsoft.com/en-us/library/ms684954%28v=vs.85%29.aspx"" rel=""nofollow noreferrer""><code>QueueUserAPC</code></a>. This technique has limitations as well, albeit different ones. I have used this and my experiments show that this only works if you are using Visual Studio and its C library as <em>DLL</em>, i.e., the MSVCRT.DLL, MSVCR100.DLL, etc. (<code>/MD</code> or <code>/MDd</code> switches)</p>

<h1>Update 2</h1>

<p>Here is a <a href=""https://stackoverflow.com/a/14726986/341065"">link to similar issue</a> (mine, actually) with one important bit:</p>

<blockquote>
  <p>After some testing it seems that the APC method works if I queue the APC from DllMain() but it does not work if I queue the APC from a ctor of a static global instance of a class.</p>
</blockquote>
",6
18183064,18182949,2,"<p>Global and static classes are constructed before main() starts executing.</p>

<pre><code>class hello {

    hello () { std::cout &lt;&lt; ""hello"" &lt;&lt; std::endl; }

};


hello hi;

int main(){
   std::cout &lt;&lt; ""hello again"" &lt;&lt; std::endl;
   return 0;

}
</code></pre>

<p>output will always be </p>

<pre><code>hello
hello again
</code></pre>

<p>since the hello object instance is created before main starts since hi is a global instance of class hello</p>
",0
18183354,18182949,2,"<p>My answer addresses your real problem - performing one-time initialization before the first instance of your class, not executing before main.</p>

<p>Just use a static variable to make sure you execute the one time init code only once. Use synchronization if you need to be thread-safe, though it would have a performance hit.</p>

<pre><code>class MyClass {
    MyClass() {
         // Perform the one-time initialization.
         static bool passed = false;
         if (!passed) {
             performOneTimeInitialization();
             passed = true;
         }

         // Continue with normal construction.
    }
};
</code></pre>
",6
18183567,18182949,1,"<p>An additional solution to your real problem (using factory methods):</p>

<pre><code>namespace 
{
    struct Initializer
    {
        Initializer()
        {
        /* initializing code goes here */
        }
    }
}

MyClass CreateMyClass()
{
    static Initializer init;
    return new MyClass();
}
</code></pre>

<p>The initializing code is executed the first time you call CreateMyClass. It should be even threadsafe with a C++11 compiler. If you don't have one and need the thread-safety, you can check boost::call_once.</p>
",0
11175653,11175623,16,"<p>I cheated by removing what I think is an extra right-parenthesis and pasting the result into <a href=""http://cdecl.org/"">cdecl</a>.</p>

<p><code>declare a as array 4 of pointer to function returning pointer to array 5 of char</code></p>
",2
11176101,11175623,13,"<p>And another example... of what to never ever do in anything other than an example.</p>

<pre><code>#include &lt;iostream&gt;

typedef char stuff[5];
stuff stuffarray[4] = { ""This"", ""Is"", ""Bad"", ""Code"" };

stuff* funcThis()   { return &amp;(stuffarray[0]); }
stuff* funcIs()     { return &amp;(stuffarray[1]); }
stuff* funcBad()    { return &amp;(stuffarray[2]); }
stuff* funcCode()   { return &amp;(stuffarray[3]); }

int main()
{
    char (*(*a[4])())[5] = { funcThis, funcIs, funcBad, funcCode };
    for(int i = 0; i &lt; 4; ++i)
    {
        std::cout &lt;&lt; *a[i]() &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
",3
11175760,11175623,25,"<p>Following the spiral rule (as linked to by chris), and starting with the identifier:</p>

<pre><code>a
</code></pre>

<p>...is...</p>

<pre><code>a[4]
</code></pre>

<p>...an array of 4...</p>

<pre><code>*a[4]
</code></pre>

<p>...pointers to...</p>

<pre><code>(*a[4])()
</code></pre>

<p>...a function taking no parameters...</p>

<pre><code>*(*a[4])()
</code></pre>

<p>...returning pointer to...</p>

<pre><code>(*(*a[4])())[5]
</code></pre>

<p>...an array of five...</p>

<pre><code>char (*(*a[4])())[5]
</code></pre>

<p>...chars.</p>

<p>Sidenote: Go give the architect who came up with this a good dressing-down, then find the programmer who wrote this code without a comment explaining it and give <em>him</em> a good dressing-down. In case this was given to you as a homework, tell your teacher that he should have instructed you on how to use cdecl instead, or how to design code in a way that it doesn't look like madman scrawlings, instead of wasting your time with this.</p>
",0
11176010,11175623,8,"<p>And here's an example ...</p>

<pre><code>#include &lt;stdio.h&gt;

char a[5] = ""abcd""; 
char b[5] = ""bcde""; 
char c[5] = ""cdef""; 
char d[5] = ""defg""; 

char (*f1())[5] { return &amp;a; }
char (*f2())[5] { return &amp;b; }
char (*f3())[5] { return &amp;c; }
char (*f4())[5] { return &amp;d; }

int main()
{
        char (*(*a[4])())[5] = { &amp;f1, &amp;f2, &amp;f3, &amp;f4 };
        for (int i = 0; i &lt; 4; i++)
                printf(""%s\n"", *a[i]());
        return 0;
}
</code></pre>
",1
19374228,3947885,0,"<p>I think you cannot pass anything from AFL to DLL using AmiDate. </p>

<p>The AmiDate Structure  is used internally FOR DLLs only, Just function like the GetStockArray() (also used internally in DLL) to retrieve O,H,L,C,V of each BarIndex. </p>

<p>Except  that it decode datetime of each BarIndex using the GetDateTimeArray() function</p>
",0
9775255,9775211,0,"<p>You get a most one implicit user-defined conversion.</p>
",0
9775257,9775211,2,"<p>It only looks for direct conversions from type A (what it is) to type B (what it should be). There are way too many ways to convert from A through C to B if it were to do that and the problem becomes unbounded; not to mention that ambiguities are quick to come up that way.</p>
",0
9775387,9775211,1,"<p>Per the C++ standard, the language will only try to resolve user type disconnects with 1 level of implicit conversion.  > 1 level requires explicit conversion.</p>
",0
13728951,13728816,1,"<p>I believe the typedef is just telling the compiler that <code>MyVec</code> can be seen as <code>vector&lt;int&gt;</code> gvien that the vector library is included.</p>

<p>However, no actual <code>MyVec</code> is constructed yet.</p>

<p>Also you should try the alternative and more preferred syntax for initializing member fields.</p>
",2
13728869,13728816,6,"<p>Try this syntax instead:</p>

<pre><code>struct Foo {

  typedef std::vector&lt;int&gt; MyVec;

  Foo ()
  : m_vec(12)
  {
  }

  MyVec m_vec; 
};
</code></pre>

<p>It's called a <a href=""https://www.google.com/search?q=c%2B%2B+member+initialization+list"" rel=""nofollow"">c++ member initialization list</a>.</p>

<hr>

<blockquote>
  <p>I can't use initializer lists because I need to do stuff in the constructor before the assignment.</p>
</blockquote>

<p>If you need to calculate how big the vector is, perhaps you can do that either before you call the constructor, or in a static method which you call from the constructor:</p>

<pre><code>struct Foo {

  typedef std::vector&lt;int&gt; MyVec;

  Foo ()
  : m_vec(calculateVectorSize())
  {
  }

  static int calculateVectorSize()
  {
      // determine how big the vector needs to be.
      // .....
  }

  MyVec m_vec; 
};
</code></pre>

<p>If those are impossible too, then a cheaper solution than your original post is:</p>

<pre><code>struct Foo {

  typedef std::vector&lt;int&gt; MyVec;

  Foo () {

    // determine how big the vector needs to be.
    // .....

    m_vec.resize(12);
  }

  MyVec m_vec; 
};
</code></pre>
",0
13728886,13728816,1,"<p>Yes.</p>

<p>And yes you can avoid it:</p>

<pre><code>Foo():
  m_vec(/*args_to_construct_m_vec*/)
{
  // body goes here
}
</code></pre>

<p>via the above syntax.</p>

<p>If you cannot use initializer list because you want to do work what to put into <code>m_vec</code>, another approach is to split your class.</p>

<p>The part of the class that needs to be initialized before <code>m_vec</code>'s size is calculated gets stuck into a parent class.  You construct it, then construct <code>m_vec</code> in the initializer list.</p>

<p>Note that <code>std::vector</code> default initialization is pretty damn cheap (usually ""<code>memset</code>"" <code>sizeof</code>( 3 pointers ) to <code>0</code>), so your concern is almost certainly misplaced.</p>
",0
9141314,9141300,5,"<p>You got the memset wrong:</p>

<pre><code>void * memset ( void * ptr, int value, size_t num );
</code></pre>

<p>it should be:</p>

<pre><code>memset(&amp;a,0,sizeof(A));
</code></pre>

<p>In your example, you're setting <code>0</code> bytes of <code>a</code> to <code>sizeof(A)</code>, so, obviously, no change.</p>
",2
9141316,9141300,9,"<p>You have the arguments to <code>memset</code> the wrong way round.  It's <code>memset(addr, value, number)</code>.</p>

<p><hr>
<em>Note: In C++, <code>memset</code> is usually avoided.</em></p>
",0
9141343,9141300,1,"<p>You have misplaced the arguments to memset. At first I thought this is stunning!
Write this:<code>memset(&amp;a,0,sizeof(A));</code></p>

<p>And all will be as expected.</p>
",0
9141465,9141300,2,"<p>The correct syntax of <code>memset</code> is <code>memset(&amp;a,0,sizeof(A))</code> because the first parameter is the array or the variable, the second is the value and the third parameter is the number of bytes.</p>

<p>For more details about <code>memset</code> visit <a href=""http://www.cplusplus.com/reference/clibrary/cstring/memset/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstring/memset/</a>.</p>
",0
9215257,9215210,20,"<p><code>std::fill()</code> should use <code>memset()</code> when possible.</p>
<pre><code>std::fill(std::begin(bArray), std::end(bArray), value);
</code></pre>
<p>If <code>bArray</code> is a pointer, then the following should be used:</p>
<pre><code>std::fill(bArray, bArray + arraySize, value);
</code></pre>
",3
9215289,9215210,5,"<pre><code>memset(buffer_start, value, sizeof(bool) * number_of_bools);
</code></pre>
",4
9215385,9215210,-1,"<p>To set array of 11 bool elements to e.g. true by using <code>memset</code>:</p>

<pre><code>const int N = 11;
bool arr[N];
memset(arr, 1, sizeof(bool) * N);
</code></pre>
",1
8762374,8762353,4,"<p>No, casting the function pointer is not safe.  Calling a function via a function pointer of the wrong type yields undefined behavior.</p>

<p>If you need your C++ code to interoperate with C code, do not use the C++ <code>bool</code> type (or, for that matter, any other C++ types that C does not have) in your interface.</p>
",7
12296395,12295980,0,"<p>The only thing that comes to my mind is <a href=""http://msdn.microsoft.com/en-us/library/aewtdfs3%28v=vs.80%29.aspx"" rel=""nofollow"">Visual Studio</a>.  If that was the case, you may want to put the <code>using</code> directive right after the corresponding <code>#include</code>.  As the remark on the page says:</p>

<blockquote>
  <p>Putt your using directive at the beginning of the source code file to
  reduce the potential for unexpected behavior with IntelliSense.</p>
</blockquote>

<p>Otherwise, it shouldn't make any difference.</p>
",4
14212070,14211960,4,"<p>That won't work. Enumerators can only be initialised with constant expressions, which your variables <code>a</code>, <code>b</code>, <code>c</code> definitely are not.</p>
",0
14212074,14211960,2,"<p>enum values are compile time constants, where as the return values of new are runtime values, as such you can not even do that (plus you would likely loose some data in the cast to int). I don't think it makes sense for SO to go into a lengthy discussion about whether it would be a good idea or not if it was possible.</p>
",0
14212122,14211960,0,"<p>I'm curius: why you need this implementation? 
By the way, I suggest you to use a vector/array with function pointer, if you need something for loop.</p>
",0
14212728,14211960,1,"<p>As others already said, this is not possible. But you could achieve something similar with a singleton pattern, e.g.:</p>

<pre><code>class MyClass
{
public:
    enum MyEnum { A, B, C };

    static MyClass* getAInstance()
    {
        static MyClass* a = new MyClass();
        return a;
    }

    static MyClass* getBInstance()
    {
        static MyClass* b = new MyClass();
        return b;
    }

    static MyClass* getCInstance()
    {
        static MyClass* c = new MyClass();
        return c;
    }

    static MyClass* getInstance(MyEnum instance)
    {
        switch(instance)
        {
        case A:
            return getAInstance();
        case B:
            return getBInstance();
        case C:
            return getCInstance();
        }
    }
};
</code></pre>

<p>So instead of <code>(MyClass*) (MyEnum::A)</code> you would write <code>MyClass::getInstance(MyClass::A)</code>.</p>
",4
14228498,2016608,1,"<p>The problem here is  mistaking concrete <em>type</em> for concrete <em>class</em>. As usual, Stroustrup defines an abstract class as one which cannot be instantiated because it has pure virtual member functions, i.e. it doesn't have a complete implementation; so, accordingly, a concrete class is simply a non-abstract class that can be instantiated. OTOH, a concrete type ""is the representation of a relatively simple concept with all the operations for the support of that concept. ... a concrete type resembles a built-in type. Naturally, the built-in types are all concrete."" Stroustrup p. 766</p>
",0
9835196,9835155,5,"<p>You are creating <code>struct TokensList * tokens</code> in the header file <code>lexan.h</code> and then including the header in both <code>lexan.cpp</code> &amp; <code>lexan2.cpp</code> which violates the <strong><a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow noreferrer"">One Definition Rule(ODR)</a></strong>.      </p>

<p>Note that, header guards prevent including the same header in the same <strong><a href=""https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c"">Translation Unit</a></strong>. When you create a variable in the header file, a copy of the variable with the same name gets created in every translation unit where you include the header. This leads to multiple same named variables in your project which the linker complains about.</p>

<p><strong>Solution:</strong><br>
If you need to share it across files, you need to use <code>extern</code>.      </p>

<p><strong>How to use <code>extern</code>?</strong><br>
Have a look at:<br>
<a href=""https://stackoverflow.com/questions/1433204/what-are-extern-variables-in-c"">What are extern variables in C?</a><br>
<a href=""https://stackoverflow.com/questions/496448/how-to-correctly-use-the-extern-keword-in-c"">How to correctly use the <code>extern</code> keyword in c?</a></p>
",0
9835221,9835155,0,"<p>You are violating the one definition rule, as hinted in comments.</p>

<p>Header files should declare variables; they should (almost) never define variables.  Your header is defining the variable <code>tokens</code>, which means that only one source file in a given program can use the header, which is not what was intended.</p>

<p>I suggest taking a look at <a href=""https://stackoverflow.com/questions/1433204/what-are-extern-variables-in-c/"">What are <code>extern</code> variables in C?</a> for an extensive (possibly too extensive) discussion of how to handle variables in headers.</p>

<p>But the fundamental rule is:</p>

<ul>
<li>Do not <em>define</em> variables in headers; only <em>declare</em> them.</li>
</ul>

<p>Of course, that assumes that the global variable is necessary.  When you can, avoid them.  But when they are necessary, the header should declare, not define, the variable.</p>
",0
9835225,9835155,0,"<p>Include guards only stop you from processing the same header twice <em>per translation unit</em> (source file).</p>

<p>Let's say you have a header, <code>X.h</code>, which has include guards:</p>

<pre><code>// x.h
#ifndef X_H
#define X_H

    // x.h stuff

#endif
</code></pre>

<p>You also have <code>A.h</code> and <code>B.h</code>, each of which include <code>X.h</code>:</p>

<pre><code>// a.h
#ifndef A_H
#define A_H

    #include ""x.h""

    // a.h stuff

#endif

// b.h
#ifndef B_H
#define B_H

    #include ""x.h""

    // b.h stuff

#endif
</code></pre>

<p>Then we have <code>j.cpp</code> and <code>k.cpp</code>:</p>

<pre><code>// j.cpp
#include ""a.h""
#include ""b.h""

    // j.cpp stuff

// k.cpp
#include ""a.h""
#include ""b.h""

    // k.cpp stuff
</code></pre>

<p>Here the include guards prevent <code>x.h</code> from being processed twice within <code>j.cpp</code>, likewise in <code>k.cpp</code>. <em>But <code>x.h</code> is still included twice, once for each translation unit.</em> So if <code>// x.h stuff</code> was this:</p>

<pre><code>int myGlobalInt; // x.h stuff
</code></pre>

<p>Although you prevent <code>j.cpp</code> (and <code>k.cpp</code>) from defining this variable twice, each still has defined it once. At link time, the linker finds them both and complains.</p>

<p>What you want ¡ª other than avoiding global variables, which you should try to do ¡ª is this:</p>

<pre><code>extern int myGlobalInt; // x.h stuff
</code></pre>

<p>Now each translation unit gets told ""there exists a <code>myGlobalInt</code> somewhere"", and you can explicit define it in a single translation unit of your choosing.</p>

<p>Also, don't use those kinds of header guards; names beginning with an underscore followed by a capital, as well as those beginning with two consecutive underscores <a href=""https://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier"">are reserved</a>.</p>
",0
15549979,2123699,0,"<p>In order to use a new library, only specifying the header file is not enough. You may also need to specify the related library defined in the header file by using -l[library name] and -L[library path] you want to be linked in your gcc commend. </p>

<p>For the difference between header file and library, please check this post: <a href=""https://stackoverflow.com/questions/6407975/what-are-header-files-and-library-files"">What are Header Files and Library Files?</a></p>
",1
15542773,15463065,0,"<p>As you said yourself its not a POD in C++03. Parts of it are (Parent1 and Parent2), but you want to treat the rest as a POD. Well, just make the rest a POD. Either by defining a local struct </p>

<pre><code>struct NotPod : public Parent1, public Parent2
{
    struct InternalPod
    {
       char z;
       short w;
    };
    InternalPod i; 
};
</code></pre>

<p>or by inheriting from a third struct:</p>

<pre><code>struct InternalPod
{
   char z;
   short w;
};

struct NotPod : public Parent1, public Parent2, public InternalPod
{
};
</code></pre>
",2
15544004,15463065,2,"<p>As I understand from your sample code, your question isn't about PODs. What you need is a guarantee that members of your most derived class are aggregates and they have continuous memory layout. </p>

<p>See 9.2.12 (ISO 14882:2003) </p>

<blockquote>
  <p>Nonstatic data members of a (non-union) class declared without an intervening access-specifier are allocated
  so that later members have higher addresses within a class object. The order of allocation of nonstatic
  data members separated by an access-specifier is unspecified (11.1).</p>
</blockquote>

<p>Simply speaking, don't put <code>public</code>/<code>protected</code>/<code>private</code> access specifiers in between of your sequence of aggregates and you'll get such a guarantee.</p>
",0
8794939,8794901,3,"<p>Visitor pattern to recover the type information, possibly with a templated helper implementing the <code>visit</code> function.</p>

<p>First, let's make your algorithm into a polymorphic functor object:</p>

<pre><code>struct Output
{
    std::ostream&amp; dest;
    Output(std::ostream&amp; destination) : dest(destination) {}

    template&lt;typename PixelType&gt;
    void operator()(const Image&lt;PixelType&gt;* image) const
    {
        dest &lt;&lt; image-&gt;GetPixel();
    }
};
</code></pre>

<p>Now, let's add a visitor interface:</p>

<pre><code>struct ImageVisitor /* abstract */
{
    virtual void Visit(Image&lt;RGBQUAD&gt;*) const = 0;
    virtual void Visit(Image&lt;RGBTRIPLE&gt;*) const = 0;
    virtual void Visit(Image&lt;RGBQUAD16&gt;*) const = 0;
    virtual void Visit(Image&lt;RGBTRIPLE16&gt;*) const = 0;
    virtual void Visit(Image&lt;RGBQUADF&gt;*) const = 0;
    virtual void Visit(Image&lt;RGBTRIPLEF&gt;*) const = 0;
    virtual void Visit(Image&lt;RGBQUADD&gt;*) const = 0;
    virtual void Visit(Image&lt;RGBTRIPLED&gt;*) const = 0;
};
</code></pre>

<p>And a forwarder:</p>

<pre><code>template&lt;typename Functor&gt;
struct ImageVisitorShim : ImageVisitor
{
    Functor&amp; fn;
    ImageVisitorShim(Functor&amp; algorithm) : fn(algorithm) {}

    virtual void Visit(Image&lt;RGBQUAD&gt;     *im) const { fn(im); }
    virtual void Visit(Image&lt;RGBTRIPLE&gt;   *im) const { fn(im); }
    virtual void Visit(Image&lt;RGBQUAD16&gt;   *im) const { fn(im); }
    virtual void Visit(Image&lt;RGBTRIPLE16&gt; *im) const { fn(im); }
    virtual void Visit(Image&lt;RGBQUADF&gt;    *im) const { fn(im); }
    virtual void Visit(Image&lt;RGBTRIPLEF&gt;  *im) const { fn(im); }
    virtual void Visit(Image&lt;RGBQUADD&gt;    *im) const { fn(im); }
    virtual void Visit(Image&lt;RGBTRIPLED&gt;  *im) const { fn(im); }
};
</code></pre>

<p>And a factory:</p>

<pre><code>template&lt;typename Functor&gt;
ImageVisitorShim&lt;Functor&gt; MakeImageVisitor(Functor&amp; f) { return f; }
</code></pre>

<p>Now a visitor-compliant image wrapper:</p>

<pre><code>struct VisitableImageBase
{
    virtual void VisitWith(const ImageVisitor&amp;) = 0;
};

template&lt;typename PixelType&gt;
struct VisitableImage : VisitableImageBase
{
    unique_ptr&lt;Image&lt;PixelType&gt;&gt; content; // or shared or raw pointer, if ownership is elsewhere

    VisitableImage(Image&lt;PixelType&gt;* im) : content(im) {}

    virtual void VisitWith(const ImageVisitor&amp; v) { v.Visit(content.get()); }
};
</code></pre>

<p>Finally, you are able to use a polymorphic vector of images!</p>

<pre><code>vector&lt;unique_ptr&lt;VisitableImageBase&gt;&gt; images;
Output outputter(std::cout);
for( auto vim : images ) vim-&gt;VisitWith(MakeImageVisitor(outputter));
</code></pre>

<p>That was a lot of code, but the good thing is that new types can be added without affecting existing functors (just extend the shim) as long as the functor was implemented with a template.  And not much code is needed to add more image processing functions (just a new template functor class, similar to <code>Output</code>).</p>
",5
12881647,12880803,0,"<p>Why not use shared_ptr? You don't have to create new objects and worry about deleting them if you use them.</p>

<pre><code>typedef shared_ptr&lt;Obstacle&gt; ObstaclePtr;
int main()
{
std::vector&lt;ObstaclePtr&gt; obstacles;
//Create objets using shared_ptr and push them in vector
ObstaclePtr obstacle1(new Circle());
obstacles.push_back(obstacle1);

ObstaclePtr obstacle2(new Circle());
obstacles.push_back(obstacle2);
//When vector obstacles goes out of scope here, all circles inside are destructed!
 }
</code></pre>
",0
13779640,13778664,2,"<p>It's important to note that <code>reset()</code> (without parameters) and <code>swap</code> are declared <code>nothrow</code> as well.</p>

<p>Also if we take a look at <code>boost::shared_ptr</code> it provides the same declarations, except it also declares it's destructor as <code>never throws</code> which <code>std::shared_ptr</code> for some reason doesn't.</p>

<p>As far as I understand, what it means is not ""I guarantee that ~T() will not throw"", but ""I <strong>prohibit</strong> ~T() to throw and hope you know what you are doing"". </p>
",0
13778749,13778664,9,"<p>Looks like a defect to me, though not one I can find in the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html"" rel=""nofollow"">active issues list</a> (though #2104 is <em>similar</em>).</p>

<ul>
<li><p>Per <code>[C++11: 20.7.2.2.3/1]</code>, the assignment is defined to be equivalent to <code>shared_ptr(r).swap(*this)</code>;</p></li>
<li><p>But per <code>[C++11: 20.7.2.2.2]</code>, <code>~shared_ptr</code> itself is not <code>noexcept</code>.</p></li>
</ul>

<p>Unless I've misunderstood the way in which <code>noexcept</code> works, this must be an error.</p>

<p>Alternatively it could simply mean that the assignment operator is only usable when neither the underlying object type nor the deleter type throw on destruction, though even in such a scenario, the lack of any informative note in the standard wording makes me think that this is unlikely.</p>
",13
13780043,13778664,4,"<p>According to the isocpp forums, <code>shared_ptr</code> simply assumes that the deleter will not throw, and otherwise is UB. This would mean that the real defect is that <code>shared_ptr</code>'s destructor is not marked as nothrow.</p>
",0
9822850,9822541,2,"<p>I guess my comment was not so clear so I write something as answer.</p>

<p>When you throw that exception you throw it <strong>by value</strong>. It means that it'll be copied (it doesn't matter if it's a primitive type or a copied object). Of course when an object is copied then its memory location changes (it's a <strong>new</strong> object). Why this? Because exceptions can unroll the stack to find a proper catch block. If you throw something by reference what you <strong>may</strong> get is garbage (because when a variable goes out of scope it'll be destroyed). I said <strong>may</strong> because in reality the compiler does not allow to throw a reference and you'll always have a copy.</p>

<p>If your exception object is really big you may consider to allocate the object with new and then throw its pointer. But <em>someone</em> has to deallocate it. Are you ready for the risk? Take a look (as example) at the <code>CException</code> implementation on MFC and its <a href=""http://msdn.microsoft.com/en-us/library/97z4sxfb%28v=vs.100%29.aspx"" rel=""nofollow"">Delete()</a> method (they try to make this easy but I'm not really happy of that).</p>

<p>Maybe you wonder <strong>why</strong> if you have to throw by value you catch by reference. First because it's how <code>std::exception</code> is designed to be used (try to call the <code>what()</code> method of an exception catched <em>by value</em>). Second because it lets the compiler to perform some optimizations (moreover, even if you do not use std::exception, you won't create useless copies of that object).</p>
",0
9822615,9822541,3,"<p>When you throw an object of any type, the Standard allows compilers to make copy of the object as many times as it wishes. Therefore, in the <code>catch</code> block, you might not get the original object you threw, and instead it can be a different object, which is  a <em>copy</em> of the original object, or a copy of the copy of the copy of the original object, or so on.</p>
",0
11811583,11811407,1,"<p>Define a struct.</p>

<pre><code>struct Coord3D{
     float x,y,z;
};
</code></pre>

<p>Define a insertion operator</p>

<pre><code>template&lt;typename ReadFunc&gt;
istream&amp; operator &gt;&gt; (istream&amp; stream, Coord3D&amp; coord){
     return ReaderFunc(stream, coord );
}
</code></pre>

<p>Define a reader function.</p>

<pre><code>istream&amp; MyCoordReader(istream&amp; stream, Coord3D&amp; coord){
     char trash_char = 0;
     return stream &gt;&gt; trash_char &gt;&gt; x &gt;&gt; y &gt;&gt; weight &gt;&gt; trash_char;
}
</code></pre>

<p>Use it like so</p>

<pre><code> //template instantiation, probably wrong syntax
template&lt;MyCoordReader&gt; istream&amp; opeartor &gt;&gt; (istream&amp;,Coord3D&amp;);

int main(){
   std::vector&lt;Coord3D&gt; coordinates;
   Coord3D coord;
   while( cin &gt;&gt; coord ){ coordinates.push_back(coord); }
   return 0;
}
</code></pre>
",0
11811453,11811407,0,"<p>Like this</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

string line;
getline(cin, line);
istringstream buffer(line);
while (buffer &gt;&gt; trash_char &gt;&gt; x &gt;&gt; y &gt;&gt; weight &gt;&gt; trash_char)
{
  // do something
}
</code></pre>

<p>use getline to read one line into a string. Then wrap that string in an istringstream so you can read the coords from that.</p>
",4
15550526,15550469,2,"<p>I think performance difference will be small enough so that it can be ignored. However maintainability, testability and design will suffer a lot so I would not use the first version.</p>

<p>My experience shows that each time I try to outsmart the compiler using such small optimization I end up with having the host being actually smaller.</p>
",0
15550539,15550469,2,"<p>Your first code is a maintenance and design nightmare. Think about the situation when you need to add new types!<br>
As for the performance. Only profiling can give you a definite answer for your respective platform and environment.</p>
",0
15550554,15550469,0,"<p>The version with the switch should be faster, since the polymorphism requires the object to be moved to cache, but this is really a micro-optimization.</p>

<p>I would go with polymorphism, because the code can be much better designed.</p>
",9
15550559,15550469,0,"<p>What you mean by faster?</p>

<p>Using polymorphism is faster just because</p>

<ul>
<li>it encapsulated behavior better</li>
<li>maintainability is surely better (so it's faster for you, which is important)</li>
<li>it allows more complex design in a simple way</li>
</ul>

<p>From the mere point of view of performance the implementation of polymorphism is done through a lookup table and what is required is a double indirect reference to obtain the address of the dynamic called method. <strong>This means that the time for polymorphism is constant</strong>, even if it's not trivial because the method could be not loaded into cache.</p>

<p>Having a switch to call the appropriate method is just forgetting about OOP. It makes no sense to do it. It could be faster by some CPU cycles just because of cache hits/misses but it is not worth doing it almost never.</p>
",0
15551916,15550469,3,"<p>I ran the following code to compare the two.  As I expected the virtual functions were slightly faster (I will explain why below).</p>

<pre><code>#include &lt;stdio.h&gt;

#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

class Object
{
    public:
        enum Type
        {
            BUTTON,
            NOT_BUTTON,
            WIDGET_ABC
        };

        Object(Type type);

        virtual void renderVirtual() = 0;
        void renderSwitch();

        int counter;

    private:
        void renderButton();
        void renderNotButton();
        void renderWidgetAbc();

        Type type;
};

class Button : public Object
{
    public:
        Button();

        virtual void renderVirtual();
};

class NotButton : public Object
{
    public:
        NotButton();

        virtual void renderVirtual();
};

class WidgetAbc : public Object
{
    public:
        WidgetAbc();

        virtual void renderVirtual();
};

Object::Object(Type type)
    :type(type),
     counter(0)
{

}

void Object::renderSwitch()
{
    switch(type)
    {
        case BUTTON:
            renderButton();
            break;
        case NOT_BUTTON:
            renderNotButton();
            break;
        case WIDGET_ABC:
            renderWidgetAbc();
            break;
    }
}

void Object::renderButton()
{
    counter += 1;
}

void Object::renderNotButton()
{
    counter += 2;
}

void Object::renderWidgetAbc()
{
    counter += 3;
}

Button::Button()
    :Object(BUTTON)
{

}

void Button::renderVirtual()
{
    counter += 1;
}

NotButton::NotButton()
    :Object(NOT_BUTTON)
{

}

void NotButton::renderVirtual()
{
    counter += 2;
}

WidgetAbc::WidgetAbc()
    :Object(WIDGET_ABC)
{

}

void WidgetAbc::renderVirtual()
{
    counter += 3;
}

static struct timeval start, end;
static long mtime, seconds, useconds;

static void startTime()
{
    gettimeofday(&amp;start, NULL);
}

static void printTimeDiff()
{
    gettimeofday(&amp;end, NULL);
    seconds  = end.tv_sec  - start.tv_sec;
    useconds = end.tv_usec - start.tv_usec;
    mtime = ((seconds) * 1000 + useconds/1000.0) + 0.5;
    printf(""Elapsed time: %ld milliseconds\n"", mtime);
}

int main()
{
    const int size = 10000000;
    Object *button = new Button();
    Object *notButton = new NotButton();
    Object *widgetAbc = new WidgetAbc();

    startTime();

    for(int i = 0; i &lt; size; i++)
    {
        button-&gt;renderVirtual();
        notButton-&gt;renderVirtual();
        widgetAbc-&gt;renderVirtual();
    }

    printf(""Virtual Function:\n"");
    printTimeDiff();
    printf(""button counter = %d\n"", button-&gt;counter);
    printf(""notButton counter = %d\n"", notButton-&gt;counter);
    printf(""widgetAbc counter = %d\n"", widgetAbc-&gt;counter);

    startTime();

    for(int i = 0; i &lt; size; i++)
    {
        button-&gt;renderSwitch();
        notButton-&gt;renderSwitch();
        widgetAbc-&gt;renderSwitch();
    }

    printf(""Switch Function:\n"");
    printTimeDiff();
    printf(""button counter = %d\n"", button-&gt;counter);
    printf(""notButton counter = %d\n"", notButton-&gt;counter);
    printf(""widgetAbc counter = %d\n"", widgetAbc-&gt;counter);

    return 0;
}
</code></pre>

<p>When I built using ""g++ main.cpp"" I got the following results</p>

<pre><code>Virtual Function
Elapsed time 132 milliseconds
button counter = 10000000
notButton counter = 20000000
widgetAbc counter = 30000000
Switch Function
Elapsed time 206 milliseconds
button counter = 20000000
notButton counter = 40000000
widgetAbc counter = 60000000
</code></pre>

<p>I then build with -02 added (for optimization) and had the following results</p>

<pre><code>Virtual Function
Elapsed time 58 milliseconds
button counter = 10000000
notButton counter = 20000000
widgetAbc counter = 30000000
Switch Function
Elapsed time 76 milliseconds
button counter = 20000000
notButton counter = 40000000
widgetAbc counter = 60000000
</code></pre>

<p>In both cases the virtual function was faster.</p>

<p>Although virtual functions are slower than non-virtual functions, the overhead is minimal.  A virtual function is most likely a function pointer (although a compiler could do it differently).  Therefore, when you call a virtual function, the only extra overhead is a pointer dereference.  Here is an example of what the compiler could be doing for a virtual call.  The compiler could do it a bit more elegantly but you can get the idea.</p>

<pre><code>#include &lt;stdio.h&gt;

class Object
{
    public:
        // function pointer acting as virtual function call
        void (*funcPtr) (void *this_ptr);
};

class Button : public Object
{
    public:
        Button();
        static void virtualFunc(void *this_ptr);

        int counter;
};

Button::Button()
    :counter(0)
{
    // set object function pointer to our ""virtual function""
    funcPtr = &amp;Button::virtualFunc;
}

void Button::virtualFunc(void *this_ptr)
{
    Button *button_ptr = reinterpret_cast&lt;Button*&gt;(this_ptr);
    button_ptr-&gt;counter++;
}

int main()
{
    Object *button = new Button();

    // virtual call using a function pointer
    button-&gt;funcPtr(button);

    printf(""button counter = %d\n"", static_cast&lt;Button*&gt;(button)-&gt;counter);

    return 0;
}
</code></pre>
",3
9835631,9835587,5,"<p>You're missing a <code>&lt;</code> in A's destructor:</p>

<pre><code> cout &lt;&lt; ""Destructor called for class A\n"";
</code></pre>

<p>If you're not getting a compilation error for the expression:</p>

<pre><code> cout &lt; ""Destructor called for class A\n""
      |
 //less than operator
</code></pre>

<p>well, your compiler is trying to compare <code>cout</code> to a <code>const char*</code>. Which is a weird thing to do. But, alas, change <code>&lt;</code> to <code>&lt;&lt;</code> and it should work: <a href=""http://ideone.com/8TDyy"" rel=""noreferrer"">http://ideone.com/8TDyy</a></p>
",4
9835632,9835587,3,"<p>You forgot a &lt; character in the destructor of A.</p>

<p>The line</p>

<pre><code>cout&lt;""Destructor called for class A\n""; 
</code></pre>

<p>just means: compare cout with the given string and return true or false.</p>

<p>You should write</p>

<pre><code>cout&lt;&lt;""Destructor called for class A\n""; 
</code></pre>

<p>And then it works correctly.</p>

<p>It's better to add spaces before and after the &lt;&lt; operator to make this clearer (I always say that code needs to breath (it needs some air)).</p>
",0
9835635,9835587,2,"<p>Your code shows:</p>

<p>cout&lt;""Destructor called for class A\n"";</p>

<p>There should be two &lt;&lt;'s, not one. I'm surprised it compiles at all...</p>
",2
9835691,9835587,1,"<pre><code>~A(){
        cout&lt;""Destructor called for class A\n"";
    }
</code></pre>

<p>the operator to be used with cout is <code>&lt;&lt;</code> and not <code>&lt;</code> its the less than operator
correct it and your code will be fine. </p>

<pre><code>~A(){
        cout&lt;&lt;""Destructor called for class A\n"";
    }
</code></pre>
",0
13723588,13723548,13,"<p>The crash is caused by the dereference of the null pointer:</p>

<pre><code>(*p) = 0; // &lt;--- Crash
</code></pre>

<p>Also as pointed out in the comments, the UNUSED macros is only there to suppress the ""unused parameter"" warning that most compilers will give.</p>

<p>It is usually also possible to prevent the warning by, simply, not specifying the variable name as follows:</p>

<pre><code>int MOAISim::_crash ( lua_State* ) 
{
    int *p = NULL;
    (*p) = 0;

    return 0;
}
</code></pre>

<p>It's also worth bearing in mind that the above is not a guaranteed crash. On one of the 32-bit consoles de-referencing a null pointer actually resulted in the number ""3"". This did make null dereferences quite hard to find, but generally if you saw a 3 sitting around in a register you could hazard a good guess as to what had just gone wrong.</p>

<p>Dereferencing is essentially asking for the value stored at a given pointer. If the pointer is not valid (that is, pointing at a memory location that the process does not own) then it results in a crash. In Windows this is called an Access Violation (0xC0000005). Under Linux it's a Segmentation Violation, SIGSEGV.</p>

<p><a href=""http://en.wikipedia.org/wiki/Dereference"" rel=""nofollow"">See also</a></p>
",1
13723607,13723548,3,"<p>The macro is replaced in the code, so for the compiler the function looks like this:</p>

<pre><code>int MOAISim::_crash ( lua_State* L ) {
    (( void )L);

    int *p = NULL;
    (*p) = 0;

    return 0;
}
</code></pre>

<p>The <code>(( void )L)</code> line evaluates <code>L</code> and throw away the result. The crash, however, isn't from that line, instead it from the assignment to a <code>NULL</code> address at <code>(*p) = 0</code>.</p>
",0
13724036,13723548,1,"<pre><code>int *p = NULL;
(*p) = 0;
</code></pre>

<p>The second line is an undefined behaviour (dereferencing a nullptr pointer). The fact that is crashes the application on your platform is just one form of undefined behavior (in my opinion good, because you can catch bugs sooner).</p>
",0
17862283,17862201,3,"<pre><code>A::ab
</code></pre>

<p>As long as <code>ab</code> is public.</p>

<p>Of course you need to fix the syntax of your enum first.</p>

<p>See also <a href=""https://stackoverflow.com/q/2503807/96780"">this question</a>.</p>
",0
17862285,17862201,2,"<p>Like this:</p>

<pre><code>class A
{
public:
   enum ab{
   a = 1,
   b = 2 };
}

class B
{
   A::ab myVariable;
}
</code></pre>
",0
17862315,17862201,2,"<p>You access the type via</p>

<pre><code>A::ab;
</code></pre>

<p>and the values via</p>

<pre><code>A::a;
A::b;
</code></pre>

<p>Of course, this assumes ab is public.</p>
",0
17862335,17862201,1,"<pre><code>#include &lt;iostream&gt;
using namespace std;

class A{
   public:
   enum ab{
   a= 1,
   b= 2 };
};

class B{
    public:
    void test()
    {
        enum A::ab x=A::a;
        cout &lt;&lt; ""test A::a = "" &lt;&lt; x &lt;&lt; endl;
        x=A::b;
        cout &lt;&lt; ""test A::b = "" &lt;&lt; x &lt;&lt; endl;
    }
};

int main()
{
    cout &lt;&lt; ""A::a = "" &lt;&lt; A::a &lt;&lt; endl;
    cout &lt;&lt; ""A::b = "" &lt;&lt; A::b &lt;&lt; endl;
    class B b;
    b.test();
}
</code></pre>

<p>The enumerated names a,b do reside in class A namespace so, you can access them using <code>A::</code> prefix like <code>A::a</code>.</p>
",1
10648872,10648829,0,"<p>Use the <a href=""http://www.cplusplus.com/reference/stl/map/"" rel=""nofollow"">STL map</a> to perform this. It works as you would do in PHP.</p>
",8
10648935,10648829,4,"<p>Using C++11 <a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow"">std::function</a> or <a href=""http://www.boost.org/doc/libs/1_49_0/doc/html/function.html"" rel=""nofollow"">boost::function</a> if you don't have C++11:</p>

<pre><code>std::map&lt;YourSwitchType, std::function&lt;void(void)&gt; functionMap;
</code></pre>

<p>then define functions such as</p>

<pre><code>void manufacturString() {
  for(; i &lt; queue_size; ++i) {
    prepared-&gt;setString(i+1, queue.at(i).manufacturer);
  }
}
</code></pre>

<p>for each case, and populate the map with these. </p>

<pre><code>functionMap[someSwitchValue] = std::bind(&amp;ThisType::manufactureString, this);
</code></pre>

<p>Then you can just call them:</p>

<pre><code>functionMap[someSwitchValue]();
</code></pre>

<p>One advantage of this approach is that it doesn't limit you to member functions. You can put non-member functions, functors, static member and non-member functions in the same map. The only limitation is that after binding, they return void and take no arguments (that is specific to this example).</p>
",0
10648971,10648829,1,"<p>If you can use enums instead of strings, then you can access name, manufacturer, etc. indexed off of the enum values. It depends on how dynamic you need to be.</p>
",0
10648991,10648829,3,"<p>You could do this with a <code>map</code> from your property names to pointer-to-member. But it's a bit of work (you need to create that mapping yourself), and the syntax gets a bit hairy. (And all the members you want to address this way must be of the same type.)</p>

<p>Demo:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;

struct Foo {
    std::string name;
    std::string address;
};

typedef std::string Foo::* FooMemPtr;
typedef std::map&lt;std::string, FooMemPtr&gt; propmap;

int main()
{
    propmap props;
    props[""name""] = &amp;Foo::name;
    props[""address""] = &amp;Foo::address;

    /* ... */

    Foo myfoo;
    myfoo.*(props[""name""]) = ""myname"";
    myfoo.*(props[""address""]) = ""myaddress"";
    std::cout &lt;&lt; myfoo.*(props[""address""]) &lt;&lt; std::endl;
    std::cout &lt;&lt; myfoo.*(props[""name""]) &lt;&lt; std::endl;
}
</code></pre>
",1
10649088,10648829,0,"<p>One option is to pass an extractor functor to the function:</p>

<pre><code>#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;boost/bind.hpp&gt;

struct Some {
    std::string model, manufacturer, name;
};

struct Prepared {
    void setString(size_t, std::string const&amp;);
};

template&lt;class Extractor&gt;
void foo(Extractor extract) {
    Prepared* prepared = 0;
    std::vector&lt;Some&gt; queue;
    size_t i, queue_size = queue.size();
    for(; i &lt; queue_size; ++i) {
        prepared-&gt;setString(i+1, extract(queue.at(i)));
    }
}

int main() {
    // C++03
    foo(boost::bind(&amp;Some::model, _1));
    foo(boost::bind(&amp;Some::manufacturer, _1));
    foo(boost::bind(&amp;Some::name, _1));

    // C++11
    foo([](Some const&amp; some){ return some.model; });
    foo([](Some const&amp; some){ return some.manufacturer; });
    foo([](Some const&amp; some){ return some.name; });
}
</code></pre>
",0
11818720,11818651,3,"<p>It won't show the mangled names, because it know the actual/real names written in code. Showing the mangled name would be counterproductive considering you might just have some name misspelled (and the mangled names are harder to work with).</p>

<p>As mentioned, under Linux/GCC there's the ""nm"" tool to print the mangled names. Under Windows, you can try <a href=""http://www.dependencywalker.com/"" rel=""nofollow"">Dependency Walker</a>, which used to be part of the samples for Visual C++ and is also very useful to ensure you've got all dynamic link libraries required on startup.</p>
",1
16950188,16949808,2,"<p>Overload resolution is complicated business, but here are the two rules that are relevant:</p>

<ul>
<li><p>The overloads that are viable are:</p>

<ol>
<li><p><code>template &lt;typename T&gt; Foo &amp; Foo::operator&lt;&lt;(T)</code></p></li>
<li><p><code>Foo &amp; operator&lt;&lt;(Foo &amp;, A &amp;)</code></p></li>
</ol></li>
<li><p>When you call <code>operator&lt;&lt;(f, a)</code>, then both overloads match, and they both match on the nose, deducing <code>T = A</code> in the template. There is <em>no difference</em> in exactness, since a reference counts as a ""perfect match"".</p></li>
<li><p>Thus the two overloads are tied, and the resolution would appear to be ambiguous. However, there is a tie breaker: No 1 is a template and No 2 is not. In this case, the non-template is  a better match.</p></li>
</ul>
",0
17090586,17090519,3,"<p>From <code>allocate</code> documentation:</p>

<blockquote>
  <p>Allocates <code>n * sizeof(T)</code> bytes of uninitialized storage by calling <code>::operator new(std::size_t)</code>, but <strong>it is unspecified when and how this function is called</strong>. </p>
</blockquote>

<p>Also, from <a href=""https://stackoverflow.com/questions/807939/what-is-the-difference-between-new-and-malloc-and-calloc-in-c"">this question</a>, you can see that <code>new</code> and <code>malloc</code> lead to different results.</p>
",2
17090685,17090519,0,"<p>Conceptually, these two functions do exactly the same thing. The only time you'll see a difference is if you start ""looking at the inside of the function"" or you run out of memory (<code>malloc</code> will return NULL, since <code>allocate</code> calls <code>::new</code>, it will throw a <code>bad_alloc</code> exception). </p>

<p>I think it's ""better C++"" to use <code>allocate</code> (if for no other reason than ""You don't have to cast <code>allocate</code>). </p>

<p>Having said that, using <code>::new T[elements]</code> would be the normal way in C++, and outside of places where you have a passed in <code>allocator</code>, this is what you should be doing. </p>
",1
17091166,17090519,3,"<p>It appears that the difference is that with <code>allocate</code> you only have to give the number of items you want rather than the total size, and the return type is automatically cast to the correct type for you.</p>

<p>In C++ you should almost never use either, but prefer <code>new</code> which will call appropriate constructors.</p>
",0
15549492,15549467,6,"<p>No. It's an automatic variable, meaning it is deallocated when it goes out of scope.</p>

<p>Also, you rarely use <code>free()</code> in C++, it's a C function.</p>
",0
15549493,15549467,1,"<p>No. The <code>int</code> object has automatic storage duration. It is destroyed at the end of its scope, i.e. when the function ends.</p>

<p>You should not be using <code>free</code> in C++ anyway. It is only used when you have used <code>malloc</code> to allocate memory, but <code>malloc</code> is not often used in C++. Instead, you should be using <code>new</code> to dynamically allocate objects. When you have created an object with dynamic storage duration with <code>new</code>, use <code>delete</code> to destroy it.</p>
",2
15549497,15549467,1,"<h1>No</h1>
<p><code>x</code> is a stack variable and will be deleted automatically when <code>doSomething()</code> returns.</p>
<p>Only those objects allocated manually with <code>malloc()</code> must be <code>free()</code>d (very uncommon in C++). Also do not use <code>free()</code> and <code>malloc()</code> in C++ - use <code>new</code> and <code>delete</code> instead.</p>
",0
15549510,15549467,1,"<p>No you only need to free memory if u have allocate it dynamically using <code>new</code> . In this case this variable is in the stack and is destroyed when the functions ends.</p>
",0
15549520,15549467,0,"<p>You only need to free variables for which you have allocated memory in code. In your example <code>x</code> is declared locally, and the program allocates memory for it on the stack. At the end of the function, the variable is automatically destroyed. So you don't need to worry about it.</p>
",0
15549564,15549467,16,"<p>Here are the memory manegement commandments for you</p>

<ul>
<li>Thou shalt <strong><em>free</em></strong> only what thou hast <em>malloc'ed</em> or <em>calloc'ed</em> </li>
<li>Thou shalt <strong><em>delete</em></strong> only what thou hast <em>new'ed</em></li>
<li>Thou shalt <strong><em>delete[]</em></strong> only what thou hast <em>new[]'ed</em></li>
<li>Thou shalt use <strong>RAII</strong> whenever possible</li>
</ul>
",4
11818383,11818365,5,"<p>There is nothing wrong with having a dot in a macro expansion, the error comes from the fact that when the macro is expanded in the definition of your enum it results in an invalid enum definition.</p>

<pre><code>enum MemorySizeUnit {Gb, Mb, Kb};
</code></pre>

<p>expands to:</p>

<pre><code>enum MemorySizeUnit {MemorySizeUnit.Gb, MemorySizeUnit.Mb, MemorySizeUnit.Kb};
</code></pre>

<p>which isn't what you want.</p>
",5
11818385,11818365,2,"<p>Just remove the <code>#define</code> altogether, enum values are placed in the outer namespace automatically.  It's not like C# or Java where the enum values have to be accessed through the enum name namespace, absnet a <code>using</code>-like declaration.</p>
",2
12319617,3876899,1,"<p>As of C++11, you can add the final keyword to your class, eg</p>

<pre><code>class CBase final
{
...
</code></pre>

<p>The main reason I can see for wanting to do this (and the reason I came looking for this question) is to mark a class as non subclassable so you can safely use a non-virtual destructor and avoid a vtable altogether.</p>
",3
15855302,15855284,12,"<p>The C++ Standard does not require a minimum. It has a recommended minimum, but not a required one. </p>

<blockquote>
  <p>Nesting levels of compound statements, iteration control structures, and selection control structures [256].</p>
</blockquote>

<p>Once the limit of an implementation is exceeded, the behavior is undefined.</p>
",3
15856868,15855284,1,"<p>Here are the Visual Studio C++ compiler limits (courtesy of Google).</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ft39hh4x%28v=vs.80%29.aspx?ppud=4"" rel=""nofollow"">MSVC compiler limits</a></p>
",0
11162413,11162273,4,"<p>You can make <code>OSImplementation</code> a friend method.</p>

<p>Or you can make <code>OSImplementation</code> a static method within the class (but that has to be declared in the header).</p>

<p>Or, probably the most common way to do this, is to have an internal implementation class, like  this:</p>

<pre><code>class SomeClass {
public:
    //...
private:
    struct Impl;
    Impl* intern;
};
</code></pre>

<p>In your cpp file, you declare <code>struct SomeClass::Impl</code>.</p>

<p>In your constructor, create the <code>SomeClass::Impl</code> instance. Delete it in the destructor. And implement the copy-constructor and the assignment operator!</p>

<p>This is called the PIMPL (pointer to implementation) idiom (<a href=""http://en.wikipedia.org/wiki/Opaque_pointer"" rel=""nofollow"">Wikipedia</a>, <a href=""http://c2.com/cgi/wiki?PimplIdiom"" rel=""nofollow"">c2.com</a>). It's used a lot in big projects like Qt.</p>
",5
11162530,11162273,1,"<p>Yes, it is possible, by making the <code>OSImplementation()</code> friend of SomeClass. Next example compiles without warnings and errors using g++ 4.6.1 :</p>

<pre><code>#include &lt;iostream&gt;

// declare in hpp
class SomeClass {

   friend SomeClass OSImplementation();

    public:
        static SomeClass SomeMethod();

        void foo();

    private:
        SomeClass(int);
};


int main()
{
  auto obj = SomeClass::SomeMethod();

  obj.foo();
}

// define in cpp
SomeClass SomeClass::SomeMethod(){
  return SomeClass( 5 );
}

SomeClass::SomeClass(int){
}

void SomeClass::foo(){
  std::cout&lt;&lt;""foo""&lt;&lt;std::endl;
}

SomeClass OSImplementation()
{
  return SomeClass::SomeMethod();
}
</code></pre>
",2
11874337,11873939,9,"<p>foo1 takes a pointer to a C function as shown in [dcl.link] 7.5p4</p>

<blockquote>
  <p>In a <em>linkage-specification</em>, the specified language linkage applies to
  the function types of <strong>all function declarators</strong>, function names with
  external linkage, and variable names with external linkage declared
  within the linkage-specification. <em>[Example:</em></p>
  
  <p><code>extern ""C"" void f1(void(*pf)(int));</code><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// the name f1 and its function type have C language</em><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>// linkage; pf is a pointer to a C function</em></p>
</blockquote>

<p>The example applies directly to <code>foo1</code> and the added emphasis highlights what I think is the reason. The function's parameter lists contains a function declarator for a parameter, and all function declarators are affected by the linkage specification. This applies to both braced and non-braced linkage specifications.</p>

<p>Some differences when not using braces are that names are automatically <code>extern</code> and explicit use of a storage specifier is prohibited.</p>

<pre><code>extern ""C"" int i; // not a definition

int main() {
    i = 1; // error, no definition
}

extern ""C"" static void g(); // error
</code></pre>

<p>As an example of where this difference matters, consider a header containing the following:</p>

<pre><code>extern ""C"" int a;
extern ""C"" double b;
extern ""C"" char c;
</code></pre>

<p>Someone might be tempted to change this to:</p>

<pre><code>extern ""C"" {
    int a;
    double b;
    char c;
}
</code></pre>

<p>But that would be incorrect because that converts the declarations into definitions. Instead the correct code using <code>extern ""C"" {}</code> is:</p>

<pre><code>extern ""C"" {
    extern int a;
    extern double b;
    extern char c;
}
</code></pre>
",10
11874548,11873939,1,"<p>The braces are used when you have many declarations and definitions. Often you can see a start and end in header files for <code>C</code> code to be usable in <code>C++</code></p>

<pre><code>#ifdef __cplusplus
extern ""C"" {
#endif

// C stuff here to be available for C++ code

#ifdef __cplusplus
}
#endif
</code></pre>

<p>I can recommend reading about ""name mangling"" <a href=""http://en.wikipedia.org/wiki/Name_mangling"" rel=""nofollow"">http://en.wikipedia.org/wiki/Name_mangling</a> The <code>extern ""C""</code> is a key to fallback to <code>C</code> linkage name conventions.</p>
",0
11874554,11873939,1,"<pre><code>extern ""C"" int foo1 (void (*)());
extern ""C"" { int foo2 (void (*)()); }
</code></pre>

<p>Those are the same.  The main reason to use braces is if you have more than one function, e.g: </p>

<pre><code>extern ""C"" int foo1 (void (*)());
extern ""C"" int foo2 (void (*)());
extern ""C"" int foo3 (void (*)());
extern ""C"" int foo4 (void (*)());
</code></pre>

<p>that can be written more simply as:</p>

<pre><code>extern ""C"" {
    int foo1 (void (*)());
    int foo2 (void (*)());
    int foo3 (void (*)());
    int foo4 (void (*)());
}
</code></pre>

<p>Additionally, if you're trying to make one header file that works with both C and C++, you might want to write that as:</p>

<pre><code>#ifdef __cplusplus
extern ""C"" {
#endif

    int foo1 (void (*)());
    int foo2 (void (*)());
    int foo3 (void (*)());
    int foo4 (void (*)());

#ifdef __cplusplus
}
#endif
</code></pre>

<p>P.S. I'm not aware of any compilers where there's a difference between ""C++ linkage"" or ""C linkage"" for function pointers.  When we talk about C or C++ linkage, we're talking about how the name gets mangled by the compiler.  For a function pointer, you're passing a pointer, so the name is irrelevant.  It's important that the <em>calling convention</em> is the same, but it usually is the same for C and C++, since people freely mix those languages.</p>
",2
15804770,15804747,5,"<p>The potential problem is that <code>this</code> points to an object that has not been fully constructed. So for example if you had this:</p>

<pre><code>template&lt;class T&gt;
struct fun
{
    fun(T* pointer) : memberPointer(pointer)
    {
        memberPointer-&gt;callMethod(); //this is 2nd to execute
    }

    T* memberPointer;
};

struct gun
{
    gun() : member(this) //this is 1st to execute
    {
       ptr = new char(); // this is 4rd to execute unless earlier UB prevents execution
    }
    void callMethod()
    {
       printf(""%s"", ptr); //this is 3rd to execute, you get UB here
    }
   fun&lt;gun&gt; member;
   char* ptr;
};
</code></pre>

<p>you would run into undefined behavior because you would pass a pointer to a not fully constructed object where only a pointer to a fully constructed object should be passed. I intentionally crafted some crappy code with UB to be more convincing, in real life you won't necessarily have UB as a problem, sometimes all the objects will be in valid states so you will get some really subtle initialization order bugs.</p>

<p>That's not your case. Your case is fine - you don't care that the object is not yet fully constructed. However you should be careful when changing your code so that you don't get into scenario as above.</p>
",0
15804787,15804747,1,"<p>It's only a warning. If you were to deference <code>this</code> inside the fun constructor then you would be accessing an uninitialised object. But you aren't, you are only storing the pointer, so you can ignore the warning. If you want to turn off the warning then add this at the top of your code</p>

<pre><code>#pragma warning (disable: 4355)
</code></pre>
",3
15804792,15804747,0,"<p>It is not completely wrong, but as you pass the pointer, your gun object might not be fully constructed yet. Hence, it might happen that you call methods in the base class that rely on the complete construction of your object.</p>
",0
15804885,15804747,0,"<p>What you want is to achieve static polymorphism, which is best handled through the <a href=""http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"" rel=""nofollow"">curiously recurring template pattern (CRTP)</a>. In your case, you're almost there:</p>

<pre><code>template&lt;class Base&gt;
struct fun : public Base
{
    void foo()
    {
        // call gun function
        Base::bar();
    }
};

struct gun : public fun&lt;gun&gt;
{
    void bar()
    {
        /*...*/
    }
};
</code></pre>
",2
11866352,11866174,17,"<p>Simple answer is <em>no</em>. There is no way to prevent delete from being called on a pointer to built-in type.</p>

<p><em>ADDENDUM</em>:</p>

<p>However I've run into similar situations to this .. my soltion was to stop using a normal pointer, and thus not need to worry about deletion. In my case a shared pointer made sense, but it yours a unique pointer or similar may suffice. </p>

<pre><code>//Custom do nothing deleter.
template&lt;typename T&gt; dont_delete( T* ) { /* Do Nothing */ }

shared_ptr&lt;const int&gt; const foo()
{
  static int a;
  return shared_ptr&lt;const int&gt;(&amp;a, &amp;dont_delete&lt;const int&gt; );
}

shared_ptr&lt;const int&gt; const bar()
{
  return shared_ptr&lt;const int&gt;(new int(7) );
}

main()
{
   shared_ptr&lt;const int&gt; p1 = foo();
   shared_ptr&lt;const int&gt; p2 = bar();

   //p1s data _not_ deleted here, 
   //p2s data is deleted here
}
</code></pre>
",0
11866362,11866174,39,"<p>You cannot declare a pointer to an arbitrary type in a way which prevents calling <code>delete</code> on the pointer. <a href=""https://stackoverflow.com/questions/755196/deleting-a-pointer-to-const-t-const"">Deleting a pointer to const (T const*)</a> explains why that is.</p>

<p><em>If</em> it was a pointer to a custom class you could make the <code>delete</code> operator private:</p>

<pre><code>class C {
    void operator delete( void * ) {}
};

int main() {
    C *c;
    delete c; // Compile error here - C::operator delete is private!
}
</code></pre>

<p>You certainly shouldn't make the destructor private (as suggested by others) since it would avoid creating objects on the stack, too:</p>

<pre><code>class C {
    ~C() {}
};

int main() {
    C c; // Compile error here - C::~C is private!
}
</code></pre>
",7
11866509,11866174,1,"<p>I don't fully understand what you are asking. If you want an object that can't be deleted you can try making foo a class and make the destructor private.</p>

<pre><code>class Foo {
public:
   int a;

   Foo(int v) {
       a = b;
   }

private:
   ~Foo() { }
};

int main() {

    Foo *c = new Foo(1);

    delete c; // compiler error, ~Foo() is private

    return 0;
}
</code></pre>

<p>I made variable ""a"" public since it was originally defined as a struct, but you can (and should) make it private and make accessors that enforce the access rules you wanted in your original code example.</p>

<p>This isn't foolproof and the compiler will only catch direct references to that class.</p>
",1
15532205,15532157,3,"<p>You can't store references in <code>map</code>. Use pointers instead.</p>

<p>Replace:</p>

<pre><code>map&lt;string, A&amp;&gt; m1;
</code></pre>

<p>With:</p>

<pre><code>map&lt;string, A*&gt; m1;
</code></pre>

<p>Or better yet (Thanks WhozCraig!):</p>

<pre><code>map&lt;string, shared_ptr&lt;A&gt; &gt; m1;
</code></pre>
",1
15532216,15532157,0,"<p>You're attempting to have a <code>map</code> that only stores references. This is a bit impossible because references usually have to be initialized with a reference the moment they are brought into conception</p>

<p>When you use <code>m1[""a""]</code>, that function by itself has to default-construct and item in-place before letting you assign to it (you can't default-construct a reference). If you're trying to avoid having a copy made, you can use the <code>emplace</code> flavor of functions to have the object constructed in-place, or just have <code>map&lt;std::string, A&gt;</code> and make your life easy.</p>

<p>If you need it to not make a copy, you can also try using a <code>map&lt;std::string, A*&gt;</code> that stores pointers. You'll be responsible for cleaning up the memory yourself, however (unless you use <code>std::unique_ptr</code> or a friend of that).</p>
",0
15532223,15532157,1,"<p>You can not use references as the key- or value-type of an container. You need to use a pointer, preferably a smart pointer like <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow""><code>std::shared_ptr</code></a> or, if this is not too expensive, you could store copies of the objects. Here's some options:</p>

<pre><code>map&lt;string,A&gt; mc; // stores copies of A

map&lt;string,A*&gt; mp; // you need to take care of memory management - avoid that

map&lt;string,shared_ptr&lt;A&gt;&gt; msp; // prefered
</code></pre>

<p>to use the latter, you could create and insert elements like this:</p>

<pre><code>msp[""a""] = make_shared&lt;A&gt;();
</code></pre>

<p>Hope it helps as a start.</p>
",2
15850895,15850840,21,"<p>The problem is that your class has a conversion operator to <code>uint32_t</code>, so the compiler does not know whether to:</p>

<ol>
<li>Construct a <code>std::string</code> from the string literal and invoke your overload accepting an <code>std::string</code>;</li>
<li>Convert your <code>Foo</code> object into an <code>uint32_t</code> and use it as an index into the string literal.</li>
</ol>

<p>While option 2 may sound confusing, consider that the following expression is legal in C++:</p>

<pre><code>1[""foo""];
</code></pre>

<p>This is because of how the built-in subscript operator is defined. Per Paragraph 8.3.4/6 of the C++11 Standard:</p>

<blockquote>
  <p>Except where it has been declared for a class (13.5.5), the subscript operator [] is interpreted in such
  a way that <code>E1[E2]</code> is identical to <code>*((E1)+(E2))</code>. Because of the conversion rules that apply to +, if <code>E1</code> is an
  array and <code>E2</code> an integer, then <code>E1[E2]</code> refers to the <code>E2</code>-th member of <code>E1</code>. Therefore, despite its asymmetric
  appearance, <strong>subscripting is a commutative operation</strong>.</p>
</blockquote>

<p>Therefore, the above expression <code>1[""foo""]</code> is equivalent to <code>""foo""[1]</code>, which evaluates to <code>o</code>. To resolve the ambiguity, you can either make the conversion operator <code>explicit</code> (in C++11):</p>

<pre><code>struct Foo
{
    explicit operator uint32_t() { /* ... */ }
//  ^^^^^^^^
};
</code></pre>

<p>Or you can leave that conversion operator as it is, and construct the <code>std::string</code> object explicitly:</p>

<pre><code>    f[std::string(""foo"")];
//    ^^^^^^^^^^^^     ^
</code></pre>

<p>Alternatively, you can add a further overload of the subscript operator that accepts a <code>const char*</code>, which would be a better match than any of the above (since it requires no user-defined conversion):</p>

<pre><code>struct Foo
{
    operator uint32_t() { /* ... */ }
    Foo&amp; operator[](const std::string &amp;foo) { /* ... */ }
    Foo&amp; operator[](size_t index) { /* ... */ }
    Foo&amp; operator[](const char* foo) { /* ... */ }
    //              ^^^^^^^^^^^
};
</code></pre>

<p>Also notice, that your functions have a non-void return type, but currently miss a <code>return</code> statement. This injects <strong>Undefined Behavior</strong> in your program.</p>
",5
15850901,15850840,3,"<p>The problem is that <code>f[""foo""]</code> can be resolved as:</p>

<ol>
<li>Convert <code>""foo""</code> to <code>std::string</code> (be it <code>s</code>) and do <code>f[s]</code> calling <code>Foo::operator[](const std::string&amp;)</code>.</li>
<li>Convert <code>f</code> to integer calling <code>Foo::operator int()</code> (be it <code>i</code>) and do <code>i[""foo""]</code> using the well known fact that built-in <code>[]</code> operator is commutative.</li>
</ol>

<p>Both have one custom type conversion, hence the ambiguity.</p>

<p>The easy solution is to add yet another overload:</p>

<pre><code>Foo&amp; operator[](const char *foo) {}
</code></pre>

<p>Now, calling <code>f[""foo""]</code> will call the new overload without needing any custom type conversion, so the ambiguity is broken.</p>

<p>NOTE: The conversion from type <code>char[4]</code> (type type of <code>""foo""</code>) into <code>char*</code> is considered trivial and doesn't count. </p>
",0
15851559,15850840,2,"<p>As noted in other answers, your problem is that <code>[]</code> commutes by default -- <code>a[b]</code> is the same as <code>b[a]</code> for <code>char const*</code>, and with your class being convertible to <code>uint32_t</code> this is as good a match as the <code>char*</code> being converted to <code>std::string</code>.</p>

<p>What I'm providing here is a way to make an ""extremely attractive overload"" for when you are having exactly this kind of problem, where an overload doesn't get called despite your belief that it should.</p>

<p>So here is a <code>Foo</code> with an ""extremely attractive overload"" for <code>std::string</code>:</p>

<pre><code>struct Foo
{
  operator uint32_t() {return 1;}
  Foo&amp; lookup_by_string(const std::string &amp;foo) { return *this; }
  Foo&amp; operator[](size_t index) {return *this;}
  template&lt;
    typename String,
    typename=typename std::enable_if&lt;
      std::is_convertible&lt; String, std::string &gt;::value
    &gt;::type
  &gt; Foo&amp; operator[]( String&amp;&amp; str ) {
    return lookup_by_string( std::forward&lt;String&gt;(str) );
  }
};
</code></pre>

<p>where we create a free standing ""lookup by string"" function, then write a template that captures <em>any</em> type that can be converted into a <code>std::string</code>.</p>

<p>Because it ""hides"" the user-defined conversion within the body of the template <code>operator[]</code>, when checking for matching no user defined conversion occurs, so this is preferred to other operations that require user defined conversions (like <code>uint32_t[char*]</code>).  In effect, this is a ""more attractive"" overload than any overload that doesn't match the arguments exactly.</p>

<p>This can lead to problems, if you have another overload that takes a <code>const Bar&amp;</code>, and <code>Bar</code> has a conversion to <code>std::string</code>, the above overload may surprise you and capture the passed in <code>Bar</code> -- both rvalues and non-const variables match the above <code>[]</code> signature better than <code>[const Bar&amp;]</code>!</p>
",0
17793862,17793773,0,"<p>I think it is shallow and Deep Copy Concept. According to me, it will not call Default C'tor i.e. it will directly call Default Copy C'tor in both the cases and By Default implementations is a shallow Copy since it will not take care of Memory Allocation of Data members if any.</p>
",0
17793956,17793773,3,"<p>(1) Will result in a default constructed vector (as it appears you know).</p>

<p>(2) and (3) will both result in copy-constructed vectors from <code>vec1</code> and <code>vec2</code> respectively.</p>

<p>The vector copy constructor will copy construct each element of the source vector into the new vector. You get a free shallow copy from this copy implementation. For your particular objects <code>A</code> and <code>B</code> shallow and deep copy are exactly the same, so you effectively also wind up with a deep copy.</p>
",2
17794132,17793773,4,"<p>First, all copy and assignment of <code>std::vector</code> are deep copy,
at least pre-C++11.  (In C++11, there are also versions which
involve move semantics.) </p>

<p>Second, your evaluation of:</p>

<pre><code>`std::vector&lt;A&gt; vec3 = vec2;
</code></pre>

<p>is not really correct.  Because the type of <code>vec2</code> is the same
as that of the variable being initialized, this is exactly like
your case 2.  (If the types were different, formally,
a converting constructor will be called to convert the right
hand side to the correct type, and then the copy constructor
would be used.  But the compiler is allowed to optimize out the
copy.)</p>

<p>Also: if you had written:</p>

<pre><code>std::vector&lt;A&gt; vec3;
vec3 = vec2;
</code></pre>

<p>The compiler would default construct an empty <code>vec3</code>, then
assign it.  But the assignment would still call the copy
constructor (and not the assignment operator) of each of the <code>A</code>
objects, because there aren't any constructed <code>A</code> objects in
<code>vec3</code> when you do the assignment (and assignment can only be to
a fully constructed object).</p>

<p>And finally: with regards to deep copy: <code>std::vector</code> copies as
deep as it knows, which are the contained elements.  Afterwards,
it is the responsibility of the contained elements to go deeper
(or not).  The default copy constructor will do a member by
member copy (so if all of the contained elements have copy
constructors, you're safe), but if there are e.g. raw pointers,
you may have to write your own, to give the object the copy
semantics you want.</p>
",3
15565497,15565400,2,"<p>If your implementation of the standard library does not work without RTTI or exceptions, get a different implementation.</p>

<p>Otherwise, QtCore implements pretty much everything in the standard library in their own way, along with a bunch of other stuff not available in the C++03/C++11 standard libraries.</p>
",4
15565677,15565400,0,"<p>Would recommend the following projects</p>

<p>For general purpose library<br/>
<a href=""http://pocoproject.org/"" rel=""nofollow"">Poco Library</a>  // does use exceptions <br/>
<a href=""https://code.google.com/p/coid/"" rel=""nofollow"">COID C++ object-serving networking library</a> // does use exception<br/>
<a href=""http://coid.sourceforge.net/"" rel=""nofollow"">COID Documentation</a></p>

<p>For UI and Framework (open source) <br/>
<a href=""http://qt.digia.com/"" rel=""nofollow"">Qt</a><br/>
<a href=""http://www.wxwidgets.org/"" rel=""nofollow"">WxWidgets</a><br/></p>
",3
15566622,15565400,1,"<p>Maybe <a href=""http://cxx.uclibc.org/index.html"" rel=""nofollow"">uCLibc++</a> is an alternative, at least amongst its features is lack of exceptions/RTTI. </p>

<p>Edit: Sorry it seems that <a href=""http://www.caravan.net/ec2plus/"" rel=""nofollow"">Embedded C++</a> is more suited.</p>
",0
15565432,15565400,2,"<p>The standard library implementation should also work well without RTTI and exception support. I can at least confirm that the GCC 4.x implementation does.</p>
",3
19787694,4156538,2,"<p>Here's my unscientific benchmark of accessing/inserting 3 billion elements from/into <code>bitset&lt;&gt;</code> and <code>vector&lt;bool&gt;</code> of sizes 100K, 1M and 5M. The compiler is GCC 4.8.2 on 64 bit Linux machine (Core i7):</p>

<p>With optimization (compiler flags: <code>-O2 -std=c++11</code>):</p>

<pre><code>[estan@pyret bitset_vs_vector]$ ./bitset_vs_vector 
bitset&lt;100000&gt; (3 billion accesses/inserts): 132.424 ms 
vector&lt;bool&gt;(100000) (3 billion accesses/inserts): 270.577 ms

bitset&lt;1000000&gt; (3 billion accesses/inserts): 67.752 ms 
vector&lt;bool&gt;(1000000) (3 billion accesses/inserts): 268.193 ms

bitset&lt;5000000&gt; (3 billion accesses/inserts): 67.426 ms 
vector&lt;bool&gt;(5000000) (3 billion accesses/inserts): 267.566 ms
</code></pre>

<p>Without optimization (compiler flags: <code>-std=c++11</code>):</p>

<pre><code>[estan@pyret bitset_vs_vector]$ make
g++ -std=c++11 -o bitset_vs_vector *.cpp
[estan@pyret bitset_vs_vector]$ ./bitset_vs_vector 
bitset&lt;100000&gt; (3 billion accesses/inserts): 1900.13 ms 
vector&lt;bool&gt;(100000) (3 billion accesses/inserts): 1784.76 ms

bitset&lt;1000000&gt; (3 billion accesses/inserts): 1825.09 ms 
vector&lt;bool&gt;(1000000) (3 billion accesses/inserts): 1768.03 ms

bitset&lt;5000000&gt; (3 billion accesses/inserts): 1846.73 ms 
vector&lt;bool&gt;(5000000) (3 billion accesses/inserts): 1763.48 ms
</code></pre>

<p>So it seems under these conditions, bitset is faster than vector when the code is optimized, while vector actually comes out on top by a (very) small margin when it's not.</p>

<p>That said, if your code is time critical you should probably perform benchmarks yourself, since I suspect these numbers are highly compiler/environment specific.</p>

<p>Benchmark code:
</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;bitset&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;

// Performs N access/insert on container.
template&lt;class T&gt;
void access_and_insert(T &amp;container, int N)
{
    const std::size_t size = container.size();
    for (int i = 0; i &lt; N; ++i) {
        bool v = container[i % size];
        container[i % size] = true;
    }
}

// Measure the time in milliseconds required to call f.
double measure(std::function&lt;void (void)&gt; f)
{
    clock_t start = std::clock();
    f();
    return 1000.0 * (std::clock() - start)/CLOCKS_PER_SEC;
}

int main (void)
{
    // Benchmark with 100K elements.
    std::bitset&lt;100000&gt; bitset100K;
    std::vector&lt;bool&gt; vector100K(100000);
    std::cout &lt;&lt; ""bitset&lt;100000&gt; (3 billion accesses/inserts): "";
    std::cout &lt;&lt; measure([&amp;]() { access_and_insert(bitset100K, 3E7); }) &lt;&lt; "" ms "" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""vector&lt;bool&gt;(100000) (3 billion accesses/inserts): "";
    std::cout &lt;&lt; measure([&amp;]() { access_and_insert(vector100K, 3E7); }) &lt;&lt; "" ms"" &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;

    // Benchmark with 1M elements.
    std::bitset&lt;1000000&gt; bitset1M;
    std::vector&lt;bool&gt; vector1M(1000000);
    std::cout &lt;&lt; ""bitset&lt;1000000&gt; (3 billion accesses/inserts): "";
    std::cout &lt;&lt; measure([&amp;]() { access_and_insert(bitset1M, 3E7); }) &lt;&lt; "" ms "" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""vector&lt;bool&gt;(1000000) (3 billion accesses/inserts): "";
    std::cout &lt;&lt; measure([&amp;]() { access_and_insert(vector1M, 3E7); }) &lt;&lt; "" ms"" &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;

    // Benchmark with 5M elements.
    std::bitset&lt;5000000&gt; bitset5M;
    std::vector&lt;bool&gt; vector5M(5000000);
    std::cout &lt;&lt; ""bitset&lt;5000000&gt; (3 billion accesses/inserts): "";
    std::cout &lt;&lt; measure([&amp;]() { access_and_insert(bitset5M, 3E7); }) &lt;&lt; "" ms "" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""vector&lt;bool&gt;(5000000) (3 billion accesses/inserts): "";
    std::cout &lt;&lt; measure([&amp;]() { access_and_insert(vector5M, 3E7); }) &lt;&lt; "" ms"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",3
11536871,11536823,1,"<p>The memory for bar is allocated at compile time. Thus, it never has to be deallocated.</p>

<p>There are different sections in a c++ binary. A few examples are text (where the code is stored), the stack, and the heap. There's also a section of read-only static memory. I believe that is where the strings would be stored.</p>

<p>Since the string is not on the heap, it does not need to be freed.</p>
",3
11536877,11536823,4,"<p>In your example, the argument is a string literal, which has static lifetime, and is never deleted.</p>
",0
11536883,11536823,2,"<p>""bar"" is defined in the data section and the address will replace it in all the places you have it.
The foo function will be called with a pointer to that address.</p>
",0
9166062,9166028,1,"<p>Since your class only contains two floats, I'd be inclined to suggest not using pointers at all (i.e. just return a <code>Complex</code>).</p>

<p>This would only be 8 bytes (at least on my system), which is the same size (again, at least on my system) as a pointer.</p>
",0
9166080,9166028,4,"<blockquote>
<pre><code>Complex* e = new Complex(0,0);

    //will this line bring memory leak? Because all plus function already build a Complex object on leap. I don't know how to release it
</code></pre>
  
  <p>since I have to return it. 
          e = c->plus(d);</p>
</blockquote>

<p>Yes it will leak.  You first allocate <code>e</code> and then you reassign it to point to whatever is returned by your function.  Now the memory you allocated first is lost in space without ever being deallocated. You should do this:</p>

<pre><code>Complex* e;
e = e-&gt;plus(d);
</code></pre>

<p>Then there is other issues like, why are you creating <code>plus</code> and <code>minus</code> functions, when you should really overload <code>operator+</code> and <code>operator-</code>.  </p>

<p>Returning everything by pointer is silly. Just return by value.  </p>
",0
9166085,9166028,4,"<p>Instead of working with all pointers, just return values.</p>

<pre><code>Complex* Complex::plus(Complex* another){
    Complex* result = new Complex(0,0);
    result-&gt;set_real(this-&gt;real + another-&gt;real);
    result-&gt;set_imaginary(this-&gt;imaginary + another-&gt;imaginary);
    return result;
}
</code></pre>

<p>Becomes:</p>

<pre><code>Complex Complex::plus(const Complex&amp; another){
    Complex result(0,0);
    result.set_real(real + another.real);
    result.set_imaginary(imaginary + another.imaginary);
    return result;
}
</code></pre>
",0
9166088,9166028,1,"<p>Remove all your heap allocation, ie dont use new at all.</p>

<p>Transform:</p>

<pre><code>Complex* Complex::plus(Complex* another){
    Complex* result = new Complex(0,0);
    result-&gt;set_real(this-&gt;real + another-&gt;real);
    result-&gt;set_imaginary(this-&gt;imaginary + another-&gt;imaginary);
    return result;
}
</code></pre>

<p>into:</p>

<pre><code>Complex Complex::plus(const Complex&amp; another) const{
    Complex result(0,0);
    result.set_real(this.real + another.real);
    result.set_imaginary(this.imaginary + another.imaginary);
    return result;
}
</code></pre>
",8
9166096,9166028,0,"<p>The (one?) problem is that you're allocating an 'e' pointer and then re-assigning the pointer later to the results of the add().  Inside the add function it's already creating a new Complex object to return.</p>

<p>So to fix this, in main you shouldn't be allocating E ahead of time.</p>

<p>[or you could restructure the code to use copy/assignments too]</p>
",0
9166114,9166028,6,"<p>Yes, your code leaks like mad.  If you absolutely need to return by pointer, return by <code>std::unique_ptr&lt;Complex&gt;</code> instead, which is nigh-leak proof.  But your code doesn't  need pointers for anything.</p>

<p>What you probably wanted was more like this:</p>

<pre><code>Complex Complex::operator+(const Complex&amp; another){ //pass by const reference
    Complex result = Complex(0,0);
    result.set_real(real + another.real);
    result.set_imaginary(imaginary + another.imaginary);
    return result;
}
</code></pre>

<p>or more simply:</p>

<pre><code>Complex Complex::operator+(const Complex&amp; another){
    return Complex(real + another.real, 
                   imaginary + another.imaginary);
}
</code></pre>

<p>In C++ we generally pass and return objects ""by value"" or ""by const reference"" and don't use pointers a whole lot for function parameters or returns.  Pointers are error-prone.  Passing by value (and using <code>operator+</code>) allows this:</p>

<pre><code>int main() {
    Complex c = Complex(3,4);
    Complex d = Complex(6,9);
    Complex e = Complex(0,0);
    Complex e = a + b; //magic!  no leaks!
    printf(""result is %f + i%f"", e.get_real(), e.get_imaginary());
    return 0;
}
</code></pre>

<p>On unrelated notes: </p>

<pre><code>Complex::Complex(float r, float i) 
    :real(r)  //faster for some types.  This is ""more correct""
    ,imaginary(i) 
{}

float Complex::get_real() const  //const since it doesn't change anything
{return real;}
</code></pre>

<p>and finally, in <code>main</code>, <code>return 0</code> means ""everything worked fine"" and returning any other value means ""something went wrong""</p>
",3
9166144,9166028,1,"<pre><code>e = c-&gt;plus(d);
</code></pre>

<p>will cause a leak, because the Complex pointed to by e is not freed before the new pointer to the new Complex is assigned.</p>

<p>Despite the fact, that the STL has a <code>template &lt;typename T&gt; class complex;</code></p>

<pre><code>#include &lt;complex&gt;
</code></pre>

<p>you can implement a member function for arithmetic returning values:</p>

<pre><code>Complex Complex::plus(const Complex&amp; another)const{
    Complex result(0,0);
    result.set_real(this-&gt;real + another.real);
    result.set_imaginary(this-&gt;imaginary + another.imaginary);
    return result;
}
</code></pre>
",0
9166052,9166028,0,"<p>One way is to use auto_ptr or a similar smart ptr. </p>

<p>Alternatively, you could also pass in a reference to the result objects in your plus or minus methods instead of a pointer that needs to be allocated. In other words, handle memory outside the class module.</p>
",2
9827780,9827645,1,"<p>The error message suggests that your function is not visible to the translation unit, so make sure you include the header.</p>

<p>Also, I doubt <code>&lt;map&gt;</code> has anything like <code>using std::copy</code>. You sure about this one?</p>

<p>In <code>algobase.h</code> (which is not standard C++), the <code>using</code> directives are parsed only if <code>__STL_USE_NAMESPACES</code> is defined. You should undefine it before including the header:</p>

<pre><code>#undef __STL_USE_NAMESPACES
#include ""algobase.h""
#endif
</code></pre>
",5
9827863,9827645,0,"<p>To the best of my knowledge the map stl class doesn't have a copy function. It is probably an include issue, you could try using a <a href=""http://www-subatech.in2p3.fr/~photons/subatech/soft/carnac/CPP-INC-1.shtml"" rel=""nofollow"">forward reference</a> to the class that contains the map and copy function. </p>
",0
9827882,9827645,1,"<p>You should be able to wrape the map include in a namespace i.e.</p>

<pre><code>
    namespace StopCollision
    { #include &lt;map> }
</code></pre>

<p>Then the map copy function would be available via <code>StopCollision::std::copy</code>.  This is very crude, but would solve your problem.</p>
",3
14154318,14154290,25,"<p>This is called as <strong>copy elision</strong>.<br>
The compilers are allowed to do this optimization. Though it is not guaranteed by the standard any commercial compiler will perform this optimization whenever it can.</p>

<hr>

<p><strong>Standard Reference</strong>:      </p>

<p><strong>C++03 12.8.15:</strong>      </p>

<blockquote>
  <p>[...] This elision of copy operations is
  permitted in the following
  circumstances (which may be combined
  to eliminate multiple copies):</p>
  
  <p>[...]</p>
  
  <ul>
  <li>when a temporary class object that has
  not been bound to a reference (12.2)
  would be copied to a class object with
  the same cv-unqualified type, the copy
  operation can be omitted by
  constructing the temporary object
  directly into the target of the
  omitted copy</li>
  </ul>
</blockquote>

<hr>

<p>You might use some compiler settings to disable this optimization, like in case of gcc, from the <strong><a href=""http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/C_002b_002b-Dialect-Options.html"">man page</a></strong>:</p>

<pre><code>-fno-elide-constructor
</code></pre>

<blockquote>
  <p>The C++ standard allows an implementation to omit creating a temporary which is only used to initialize another object of the same type.  Specifying this option disables that optimization, and 
  forces G++ to call the copy constructor in all cases.</p>
</blockquote>

<p>However, using this makes your code non portable across different compilers.</p>
",2
14154323,14154290,11,"<p>It is because of the optimization performed by your compiler. Compilers are <em>permitted</em> to perform such optimizations, though it is not a <em>requirement</em>, thus <strong>not</strong> guaranteed.</p>

<p>Note an important point that even though the copy-constructor is not invoked eventually, it is <strong>semantically required</strong> to be <em>accessible</em>. That is, if you make the copy-constructor <code>private</code>, your code will <strong>not</strong> compile!! It is because the semantic-check is done much before the optimization phase, means the compiler first checks that the copy-constructor is accessible or not; <strong>if</strong> it is <em>accessible</em>, then only comes the optimization phase where the copy-construction is elided.</p>
",2
14154614,14154290,0,"<p>As others have already well mentioned this is because of optimization from your compiler.</p>

<p>I haven't checked it but you could probably compile your code with optimization and again without and have a look at the assembler code. Then you should also definetely see some differences.</p>
",0
10127321,10127150,1,"<p>The result of <code>u8(filename).c_str()</code> should be usable until <code>avformat_open_input</code> returns. It's probably saving the pointer you give it and then using that during <code>avformat_find_stream_info</code>.</p>

<p>Post the docs for these avformat functions, or their implementations so we can see if it's actually doing that.</p>

<hr>

<p>It doesn't look like <code>avformat_open_input</code> is doing anything wrong. Now I suspect that there's undefined behavior occurring somewhere earlier in the program. Try using a tool like valgrind or static analysis and see if that turns up anything.</p>
",4
11850741,11850717,0,"<p>Asked and answered many times.</p>

<ul>
<li><a href=""http://cplus.about.com/od/howtodothingsi2/a/timing.htm"" rel=""nofollow noreferrer"">How do I do High Resolution Timing in C++ on Windows?</a></li>
<li><a href=""https://stackoverflow.com/questions/588307/c-obtaining-milliseconds-time-on-linux-clock-doesnt-seem-to-work-properl"">C++ obtaining milliseconds time on Linux ¡ª clock() doesn't seem to work properly</a></li>
<li><a href=""https://stackoverflow.com/questions/700392/high-resolution-timing-part-of-your-code"">High Resolution Timing Part of Your Code</a></li>
<li><a href=""https://stackoverflow.com/questions/538609/high-resolution-timer-with-c-and-linux?lq=1"">High resolution timer with C++ and Linux?</a></li>
</ul>

<p>If you're using C++11 you can consider <a href=""http://www.cplusplus.com/reference/std/chrono/"" rel=""nofollow noreferrer""><code>chrono</code></a>.</p>
",4
11850745,11850717,1,"<p>Take a look at <code>clock</code> and <code>clock_t</code>. For the resolution you're talking about, I don't think there's native support in C++. To get meaningful values, you'll have to time multiple calls or constructions, or use a profiler (desired).</p>
",0
11851314,11850717,0,"<p>I asked this exact question earlier today. The best solution I have at the moment is to use SDL, and call:</p>

<pre><code>uint32 a_time = SDL_GetTicks(); // Return uint32 count of milliseconds since SDL_Init was called
</code></pre>

<p>Although this is probably going to give you lots of overhead, even if you just init SDL with the timer functionality. (SDL_Init(SDL_INIT_TIMER).</p>

<p>Hope this helps you - I settled for this as a solution because it is portable.</p>
",0
11852840,11850717,9,"<p>The <code>&lt;chrono&gt;</code> library in standard C++ provides the best way to do this. This library provides a standard, type safe, generic API for clocks.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;

int main() {
    using std::chrono::duration_cast;
    using std::chrono::nanoseconds;
    typedef std::chrono::high_resolution_clock clock;

    auto start = clock::now();
    // stuff
    auto end = clock::now();
    std::cout &lt;&lt; duration_cast&lt;nanoseconds&gt;(end-start).count() &lt;&lt; ""ns\n"";
}
</code></pre>

<p>The actual resolution of the clock will vary between implementations, but this code will always show results in nanoseconds, as accurately as possible given the implementation's tick period.</p>
",6
11851452,11850717,2,"<p>In C++11 you can do it using chrono library where -</p>

<blockquote>
  <p>Class template std::chrono::duration represents a time interval.
  It consists of a count of ticks of type Rep and a tick period, where the tick period is a compile-time rational constant representing the number of seconds from one tick to the next.</p>
</blockquote>

<p>Currently implemented in GCC 4.5.1. (not yet in VC++). See sample code from <a href=""http://en.cppreference.com/w/cpp/chrono"" rel=""nofollow"">cppreference.com</a> on Ideone.com <a href=""http://ideone.com/3VobQ"" rel=""nofollow"">execution time of a function call</a></p>
",1
14232652,13703823,30,"<p>A custom destination for ostream means implementing your own ostreambuf. If you want your streambuf to actually buffer (i.e. don't connect to the database after each character), the easiest way to do that is by creating a class inheriting from <code>std::stringbuf</code>. The <strong>only</strong> function that you'll need to override is the <code>sync()</code> method, which is being called whenever the stream is flushed.</p>

<pre><code>class MyBuf : public std::stringbuf
{
public:
    virtual int sync() {
        // add this-&gt;str() to database here
        // (optionally clear buffer afterwards)
    }
};
</code></pre>

<p>You can then create a <code>std::ostream</code> using your buffer:</p>

<pre><code>MyBuf buff;
std::ostream stream(&amp;buf)
</code></pre>

<p>Most people advised against redirecting the stream to a database, but they ignored my description that the database basically has a single blob field where all text is going to.
In rare cases, I might send data to a different field. This can be facilitated with custom attributes understood by my stream. For example:</p>

<pre><code>MyStream &lt;&lt; ""Some text "" &lt;&lt; process_id(1234) &lt;&lt; ""more text"" &lt;&lt; std::flush
</code></pre>

<p>The code above will create a record in the database with:</p>

<pre><code>blob: 'Some text more text'
process_id: 1234
</code></pre>

<p><code>process_id()</code> is a method returning a structure <code>ProcessID</code>. Then, in the implementation of my ostream, I have an <code>operator&lt;&lt;(ProcessID const&amp; pid)</code>, which stores the process ID until it gets written. Works great!</p>
",5
13704536,13703823,4,"<p>my2c - I think you are tackling this the wrong way. A stream may sound like a nice idea, but you'll need a way to indicate the end of the row too (and then what if someone forgets?) I would suggest something along the lines of how the java PreparedStatements and batches work, as in provide a set of methods which accept the types and a column index, then a ""batch"" method which explicitly makes it clear that you are indeed batching that row and then an execute to push the batch in.</p>

<p>Any stream based operation will rely on type (typically) to indicate which column to fill - but what if you have two ints? IMO, as a user, it doesn't feel like a natural way of inserting records into a database... </p>
",0
13704122,13703823,23,"<p>The simplest way is to inherit <code>std::streambuf</code> and override just two methods:</p>

<ul>
<li><code>std::streamsize xsputn(const char_type* s, std::streamsize n)</code> ¨C to append a given buffer with size provided to your internal buffer, <code>std::string</code> for example;</li>
<li><code>int_type overflow(int_type c)</code> ¨C to append a single <code>char</code> to your internal buffer.</li>
</ul>

<p>Your streambuf can be constructed from whatever you want (DB connection for example). After append something into the internal buffer you may try to split it into lines and push something into DB (or just buffer an SQL statements to execute later).</p>

<p>To use it: just attach your <code>streambuf</code> to any <code>std::ostream</code> using constructor.</p>

<p>Simple! I've done something like this to output strings to syslog ¨C everything works fine with any custom <code>operator&lt;&lt;</code> for user defined classes.</p>
",2
13705155,13703823,1,"<p>To add a new source or destination of character input/output to the iostreams mechanism, you should create a new <code>streambuf</code> class. The task of the stream buffer classes is to communicate with the 'external device' that will store the characters and to provide buffering facilities.</p>

<p>The problem with using iostreams to communicate with your database is that a database table does not match with the concept of a character sequence. A bit like pushing a round peg in a square hole. A <code>streambuf</code> only operates on characters. That is the only thing ever presented to it. This means the <code>streambuf</code> has to parse the character stream presented to it to find the field and record separators.
If you decide to go this route, I predict you will end up writing a CSV-to-SQL converter in your <code>streambuf</code>, just to get it working.</p>

<p>You will probably be better of with just adding a few <code>operator&lt;&lt;</code> overloads to your class(es). You could look at the Qt framework for ideas here. They also have the possibility to use <code>operator&lt;&lt;</code> to add items to a collections and such.</p>
",0
15566981,15459563,0,"<p>This is what I ended up coming up with for a base solution.</p>

<ul>
<li>It gets ride of all subtractions from the test. </li>
<li>It reduces
tremendously the number of tests that need to be done. </li>
<li>It can easily
be split into different threads. </li>
<li>It gave me a hela bost to
performance. </li>
<li>It made me feel cool when it worked. </li>
<li><p>It focuses on what a computer is good at.</p>

<pre><code>void Collider::test_one(Actor * actor){
    std::sort(this-&gt;_stack-&gt;begin(),this-&gt;_stack-&gt;end(),*Collider::sort_x);

    vector&lt;Actor*&gt;::iterator it_target = std::find(this-&gt;_stack-&gt;begin(),this-&gt;_stack-&gt;end(),actor);
    vector&lt;Actor *&gt; possible_x;
    vector&lt;Actor *&gt; possible_y;



    int x = 1;
    int count = 0;

    Actor * one = *(it_target);
    Actor * two;



     /*
     for(int x= 0; x &lt; this-&gt;_stack-&gt;size(); x++){
     cout &lt;&lt; this-&gt;_stack-&gt;at(x)-&gt;x_loc &lt;&lt; ""\n"";
     }
    */

    //cout &lt;&lt; ""***"" &lt;&lt; ""\n"";

    while ( it_target +x != this-&gt;_stack-&gt;end()) {
        two = *(it_target+x);

        //cout &lt;&lt; one-&gt;half_width+two-&gt;half_width+one-&gt;x_loc &lt;&lt; ""\n"";
        //cout &lt;&lt; two-&gt;x_loc &lt;&lt; ""\n"";

        if(one-&gt;half_width+two-&gt;half_width+ one-&gt;x_loc &gt; two-&gt;x_loc){
            possible_x.push_back(two);
        }else{
            break;
        }
        count ++;
        x++;
    }

    reverse_iterator&lt;vector&lt;Actor*&gt;::iterator&gt; rit_target(it_target);
    x=0;
    while (rit_target +x != this-&gt;_stack-&gt;rend()) {
        two = *(rit_target+x);
        if(two-&gt;half_width+one-&gt;half_width+ two-&gt;x_loc &gt; one-&gt;x_loc){
            possible_x.push_back(two);
        }else{
            break;
        }
        count ++;
        x++;
    }

    //cout &lt;&lt;count &lt;&lt;"" POSSIBLE X \n"";



    x=1;
    count=0;
    std::sort(this-&gt;_stack-&gt;begin(),this-&gt;_stack-&gt;end(),*Collider::sort_y);
    it_target = std::find(this-&gt;_stack-&gt;begin(),this-&gt;_stack-&gt;end(),actor);

    /*
    for(int x= 0; x &lt; this-&gt;_stack-&gt;size(); x++){
       cout &lt;&lt; this-&gt;_stack-&gt;at(x)-&gt;y_loc &lt;&lt; ""\n"";
    }
    */

    while ( it_target +x != this-&gt;_stack-&gt;end()) {
        two = *(it_target+x);

        //cout &lt;&lt; one-&gt;half_width+two-&gt;half_width+ one-&gt;y_loc &lt;&lt; ""  DISTANCE\n"";
        //cout &lt;&lt; two-&gt;y_loc &lt;&lt; ""  Y_LOC \n"";

        if(one-&gt;half_width+two-&gt;half_width+ one-&gt;y_loc &gt; two-&gt;y_loc){
            possible_y.push_back(two);
        }else{
            break;
        }
        count ++;
        x++;
    }


    reverse_iterator&lt;vector&lt;Actor*&gt;::iterator&gt; yrit_target(it_target);
    x=0;
    while (yrit_target +x != this-&gt;_stack-&gt;rend()) {
        two = *(yrit_target+x);
        if(two-&gt;half_width+one-&gt;half_width+ two-&gt;y_loc &gt; one-&gt;y_loc){
            possible_y.push_back(two);
        }else{
            break;
        }
        count ++;
        x++;
    }

    //cout &lt;&lt;count &lt;&lt;"" POSSIBLE Y \n"";

    vector&lt;Actor *&gt; result;

    std::sort(possible_x.begin(),possible_x.end());
    std::sort(possible_y.begin(), possible_y.end());

    std::set_intersection(possible_x.begin(), possible_x.end(),possible_y.begin(),possible_y.end(),back_inserter(result));


    for(int x=0; x&lt; result.size();x++){
        //cout &lt;&lt; result.at(x)  &lt;&lt; "" COLLISION"";
        result.at(x)-&gt;collision(*actor);
    }


}
</code></pre>

<p>Any suggestions on making this faster? I know I have a mess here I didn`t even know how to muck with an iterator a week ago.</p></li>
</ul>
",0
10781145,10781130,4,"<p>Saw the discussion on a member-only forum. Since the answer is not well-known to most programmers, would like to post the answer and share it here.</p>
<p>From C++ standard draft N3337 ¡ì12.8.23:</p>
<blockquote>
<p>A defaulted copy/move assignment operator for class X is defined as deleted if X has:</p>
<ul>
<li>a variant member with a non-trivial corresponding assignment operator and X is a
union-like class, or</li>
<li>a non-static data member of const non-class type (or array thereof), or</li>
<li>a non-static data member of reference type, or</li>
<li>a non-static data member of class type M (or array thereof) that cannot be
copied/moved because overload resolution (13.3), as applied to M¡¯s corresponding
assignment operator, results in an ambiguity or a function that is deleted or
inaccessible from the defaulted assignment operator, or</li>
<li>a direct or virtual base class B that cannot be copied/moved because overload
resolution (13.3), as applied to B¡¯s corresponding assignment operator, results in
an ambiguity or a function that is deleted or inaccessible from the defaulted
assignment operator, or</li>
<li>for the move assignment operator, a non-static data member or direct base class
with a type that does not have a move assignment operator and is not trivially
copyable, or any direct or indirect virtual base class.</li>
</ul>
</blockquote>
",1
10781727,10781130,6,"<blockquote>
<p><strong>In C++, if a class has a reference data member the default assignment operator is not synthesized by compiler. Why?</strong></p>
</blockquote>
<p>What an copy assignment should do is defined in:</p>
<p><strong>C++03 Standard 12.8/13:</strong></p>
<blockquote>
<p>Each subobject is assigned in the manner appropriate to its type:</p>
<ul>
<li><p>if the subobject is of class type, the copy assignment operator for the class is used (as if by explicit qualification; that is, ignoring any possible virtual overriding functions in more derived classes);</p>
</li>
<li><p>if the subobject is an array, each element is assigned, in the manner appropriate to the element type;</p>
</li>
<li><p>if the subobject is of scalar type, the built-in assignment operator is used.</p>
</li>
</ul>
</blockquote>
<p>In short It implies that <em><strong>each of the member should assigned in an appropriate manner</strong></em><br />
which raises the question,<br />
<em><strong>What should be the behavior for assignment of a reference member in class?</strong></em><br />
Consider the following about references:</p>
<ol>
<li>References are inherently non assignable, they keep referring the same referrant to which they were initialized<sup>[Ref 1]</sup>.</li>
<li>By virtue of <code>#1</code> assigning to an reference doesn't reassign the reference, it changes the value of the referrant which is non-intuitive behavior.</li>
</ol>
<p>There is no default correct behavior to be enforced here but a rather situational one.So the C++ Standard mandates that designer of the class is in best position to determine this behavior and hence the decision that default assignment operator should not be synthesized by compiler if a class has a reference data member.</p>
<p>This decision is specified in:<br />
<strong>C++03 Standard 12.8/12:</strong></p>
<blockquote>
<p>An implicitly-declared copy assignment operator is implicitly defined when an object of its class type is assigned a value of its class type or a value of a class type derived from its class type. A program is ill formed if the class for which a copy assignment operator is implicitly defined has:<br />
.......<br />
¡ª a nonstatic data member of reference type, or<br />
.......</p>
</blockquote>
<hr />
<p><sup>[Ref 1]</sup><br />
<strong>C++03 Standard 8.5.3/2:</strong></p>
<blockquote>
<p><strong>A reference cannot be changed to refer to another object after initialization</strong>. Note that initialization of a reference is treated very differently from assignment to it. Argument passing (5.2.2) and function value return (6.6.3) are initializations.</p>
</blockquote>
",0
11837396,11837385,11,"<p>Put in a cast to void:</p>

<pre><code>int unused;
(void)unused;
</code></pre>
",2
11837409,11837385,2,"<p>To remove these warnings I make a <strong>macro</strong> that can be used throughout my project:</p>

<pre><code>#define UNUSED(x) (void)(x)
</code></pre>
",0
11837416,11837385,9,"<p>Compile with the <code>-Wno-unused-variable</code> option.</p>

<p>See the <a href=""http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html"" rel=""nofollow noreferrer"">GCC documentation on Warning Options</a> for more information.</p>

<p>The <code>-Wno-__</code> options turn off the options set by <code>-W__</code>. Here we are turning off <a href=""http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wunused_002dvariable-333"" rel=""nofollow noreferrer""><code>-Wunused-variable</code></a>.</p>

<p>Also, you can apply the <code>__attribute__((unused))</code> to the variable (or function, etc.) to suppress this warning on a case-by-case basis. Thanks <a href=""https://stackoverflow.com/users/906773/jesse-good"">Jesse Good</a> for mentioning this.</p>
",0
10762939,2942614,0,"<p>ILog Rules(IBM) is writen in C++.</p>
",0
9159778,9159768,3,"<p>The two variants are equivalent and interchangeable.</p>
",0
9159783,9159768,2,"<p>There's no difference in how you do it.</p>

<p>If the function returns <code>NumericType</code>, it should convert automatically by constructing an instance of <code>NumericType</code>.</p>
",0
9159823,9159768,2,"<p>It doesn't matter. The second one is just much longer than needed.</p>

<p>As a hint, you can (and should) initialize variables where they are declared.</p>

<pre><code>NumericType r_endoftheScale = NumericType (w_endoftheScale);
return r_endoftheScale;
</code></pre>

<p>You might also consider the appropriateness of Hungarian notation.</p>
",0
13707114,13707033,12,"<blockquote>
  <p>What is the rationale behind the fact that argument modifiers (i.e., const and volatile) are not part of a function's type or signature?</p>
</blockquote>

<p>From a caller's perspective, there is no difference between <code>void foo(int)</code> and <code>void foo(int const)</code>. Whatever you pass to it will not be modified, regardless of the modifier: the function will get a copy.</p>

<p>From an implementer's perspective the sole difference is that with <code>void foo(int x)</code> you can mutate <code>x</code> (i.e. your local copy) in the body, but you cannot mutate <code>x</code> with <code>void foo(int const x)</code>.</p>

<p>C++ acknowledges these two perspectives. The caller's perspective is acknowledged by making the two declarations <code>void foo(int);</code> and <code>void foo(int const);</code> declare the same function. The implementer's perspective is acknowledged by allowing you to declare a function as <code>void foo(int x);</code> but define it as <code>void foo(int const x)  { /*...*/ }</code> if you want to make sure you don't accidentally assign to the argument.</p>

<p>Note that this only applies for top-level <code>const</code>, i.e. <code>const</code> that applies to the whole type. In things like <code>int const&amp;</code> or <code>int const*</code> the modifier only applies to a part of the type, as ""pointer to (const (int))"", so it is not top-level <code>const</code>. In <code>int *const</code> however, the <code>const</code> again applies to the whole type as in ""const (pointer to (int))"".</p>
",4
11560701,11560098,2,"<p>Maybe try to use boost::any?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;boost/any.hpp&gt;

namespace problem {
    template &lt;typename T&gt;
    class data {
        public:
            inline data(T var) {
                this-&gt;var = var;
            }
        private:
            T var;
    };

    class storage {
        public:
            template&lt;class T&gt;
            inline void push(problem::data&lt;T&gt; * data) {
                this-&gt;VData.push_back(data);
            }
        private:
            std::vector&lt;boost::any&gt; VData;
    };
};

int main() {
    problem::storage * testStorage = new problem::storage();
    problem::data&lt;int&gt; * testData = new problem::data&lt;int&gt;(256);

    testStorage-&gt;push&lt;int&gt;(testData);

    problem::data&lt;float&gt; * testData1 = new problem::data&lt;float&gt;(1.);
    testStorage-&gt;push&lt;float&gt;(testData1);

    delete testData;
    delete testData1;
    delete testStorage;
    return 0;
}
</code></pre>

<p>But you need to cast from boost::any to your type before using data from vector</p>
",0
11560810,11560098,2,"<p>If you want storage that can store more than one type of value you can try something like this: <a href=""http://ideone.com/jjuVq"" rel=""nofollow"">http://ideone.com/jjuVq</a></p>

<pre><code>class storage {
    struct data_base {};

    template &lt;class K&gt; 
    struct data: data_base {
        data(K value): value_(value) {}
        K value_;
    };

    typedef std::vector&lt;data_base*&gt; container_type;

public:
    ~storage() {
        while(!this-&gt;VData.empty()) {
            delete this-&gt;VData.back();
            this-&gt;VData.pop_back();
        }
    }
    template &lt;class P&gt;
    inline void push(P v) {
        this-&gt;VData.push_back(new data&lt;P&gt;(v));
    }
    template &lt;class P&gt;
    P &amp;get(int i) { return static_cast&lt;data&lt;P&gt;*&gt;(this-&gt;VData[i])-&gt;value_; }
private:
    container_type VData;
};
</code></pre>

<p>or just use boost::any as a container's value type.</p>
",3
11560913,11560098,-3,"<p>I found a solution which is kinda what I was looking for, but I'm not sure if this is good practice. :P</p>

<pre><code>class storage {
    public:
        template &lt;typename T&gt;
        inline void push(problem::data&lt;T&gt; * data) {
            this-&gt;VData.push_back(reinterpret_cast&lt;char*&gt;(data));
        }
        template &lt;typename T&gt;
        inline problem::data&lt;T&gt; * draw() {
            problem::data&lt;T&gt; * data = reinterpret_cast&lt;problem::data&lt;T&gt;*&gt;(VData.back());
            return data;
        }
    private:
        std::vector&lt;char*&gt; VData;
};
</code></pre>
",6
11560259,11560098,1,"<p>Your storage class has a data member that depends on a template parameter, so you should make it a class template:</p>

<pre><code>template &lt;typename T&gt;
class storage {
    public:
        inline void push(problem::data&lt;T&gt; * data) {
            this-&gt;VData.push_back(data);
        }
    private:
        std::vector&lt;problem::data&lt;T&gt; *&gt; VData;
};
</code></pre>

<p>Otherwise, you could make <code>storage</code> work for a specific type <code>T</code>:</p>

<pre><code>class storage {
    public:
        inline void push(problem::data&lt;int&gt; * data) {
            this-&gt;VData.push_back(data);
        }
    private:
        std::vector&lt;problem::data&lt;int&gt; *&gt; VData;
};
</code></pre>
",2
12789452,12788950,1,"<p>The standard way to find the period length is to imagine your sequence is a string S over an alphabet of integers, and then find the leftmost position (greater than 0) where S can be found in the string SS (the concatenation of the string S with itself). That is, if <code>S = 'abcabc'</code>, you have to find the first position <code>i</code> greater than zero, such that S is found at position <code>i</code> in the string <code>SS = 'abcabcabcabc'</code>. In this case, this is 3, and that's the length of the period.</p>

<p>This can be done any of the string searching algorithms with linear performance, and should work perfectly fine for 2^20 numbers on a modern computer. I doubt that you can avoid saving the numbers in memory though.</p>
",1
12789541,12788950,2,"<p>This is a well-studied problem, with quite a number of algorithms depending on what exactly your resources and contraints are:</p>

<p><a href=""http://en.wikipedia.org/wiki/Cycle_detection"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Cycle_detection</a></p>

<p>You do not need to store everything in memory (just two pointers/indices in the basic algorithms), but you need to be able to access the sequence multiple times.</p>

<p>See also:</p>

<p><a href=""https://stackoverflow.com/questions/3880735/floyds-cycle-finding-algorithm"">Floyd&#39;s cycle-finding algorithm</a></p>
",4
9184915,9184886,2,"<p>Both are valid and both do the same thing. I'd use the first one because I find the second one confusing, but different strokes for different folks.</p>

<p>EDIT: Actually, I'd do even more than that. I'd mark <code>B</code>'s constructor as <code>explicit</code> in order to prevent just the sort of thing that makes the second one compile.</p>

<p>Note: I would avoid use of <code>(void)</code> in method signatures in C++.</p>
",6
9184967,9184886,1,"<p>Both are correct. First one explicitly creates <code>B</code> instance, and the second one implicitly creates <code>B</code> from <code>A</code>. I like neither of those. They just increase confusion level and nothing more.</p>
",6
9184985,9184886,1,"<p>I would decorate the constructor as <code>explicit</code>, and then use method one as the only available method:</p>

<pre><code>class B {
public:
    explicit B(A const &amp; a, int b = 10) : m_a(a), m_i(b) { }
    // ...
};

B foo()  { return B(A()); }
</code></pre>

<p>That way you can never accidentally construct a <code>B</code> from an <code>A</code>. If the constructor of <code>B</code> is expensive or may throw, then having this extra level of deliberateness in your code may well help make it more readable and less error-prone.</p>
",0
9206449,9206430,3,"<p>You cannot use <code>static</code> and <code>extern</code> together.<br>
If you want to use the variable in other files just remove the <code>static</code> and just declare it as <code>extern</code>.   </p>

<p><strong>Why you cannot use <code>static</code> and <code>extern</code> together?</strong></p>

<p><code>static</code> implies Internal linkage, while <code>extern</code> implies External linkage.    </p>

<p><strong>Internal Linkage</strong> means that the symbol is accessible only in the Translation unit in which it was declared, while <strong>External Linkage</strong> implies the symbol should be visible in all files accross your project, clearly, they are mutually exclusive.     </p>
",4
9206459,9206430,1,"<p>Well, an object defined as <code>static T x;</code> at namespace scope is visible only locally in the file where it is defined. In fact, this is precisely the function of using the <code>static</code> keyword (at namespace level). Just remove the <code>static</code>.</p>
",0
9857860,9857835,3,"<p>Sounds correct to me.</p>

<p>Because <code>struct node</code> is a ""<a href=""https://stackoverflow.com/questions/146452/what-are-pod-types-in-c"">Plain Old Datatype</a>"" the compiler won't actually create any destructor code at all, there's no need to specially destruct ints or pointers.</p>

<p>Even for non-POD types, the compiler default destructor will just take the form:</p>

<pre><code>~node() { }
</code></pre>

<p>Individual members will still have their destructors called, but if you didn't allocate any non-automatic resources, you generally don't need to provide a destructor. There are situations where you might, but they're somewhat special purpose.</p>

<p>You may want to refer to <a href=""https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">this question</a> on the rule of three.</p>
",0
13730009,13729657,3,"<p>I might be wrong, since I'm not sure what the definition of ""unnamed object"" is. But consider the argument of the foo() function below:</p>

<pre><code>void foo(int)
{ /* ... */ }

int main()
{ foo(5); }
</code></pre>

<p>foo()'s argument is unnamed, but it's not a temporary. Therefore, unnamed objects and temporary objects are not equivalent.</p>
",0
13730141,13729657,3,"<p>Temporary objects can be named.</p>

<p>Very common case - when passed as a parameter to a function.
Another less common case - binding a const reference to an rvalue result of a function.</p>

<pre><code>int f(int i) { return i + 1; }
int g() { const int &amp;j = f(1); return j; }
</code></pre>

<p>Unnamed objects are often temporary, but not always. For example - anonymous union object:</p>

<pre><code>struct S
{
   union { int x; char y; };
} s;
</code></pre>

<p>And, of course, any object created by <code>operator new</code>.</p>

<p>Perhaps there are other cases, but even only these can serve as counterexamples to the hypothesis :)</p>
",0
13730489,13729657,2,"<blockquote>
  <p>I have been pondering when the compiler will determine that a particular function argument is an rvalue reference, and when it will determine it to be an lvalue reference.</p>
</blockquote>

<p>I assume you are talking about function templates with universal reference <strong>parameters</strong>, like this?</p>

<pre><code>template&lt;typename T&gt;
void foo(T&amp;&amp; t)
{
}
</code></pre>

<p>The rules are very simple. If the argument is an rvalue of type <code>X</code>, then <code>T</code> will be deduced to be <code>X</code>, hence <code>T&amp;&amp;</code> means <code>X&amp;&amp;</code>. If the argument is an lvalue of type <code>X</code>, then <code>T</code> will be deduced to be <code>X&amp;</code>, hence <code>T&amp;&amp;</code> means <code>X&amp; &amp;&amp;</code>, which is collapsed into <code>X&amp;</code>.</p>

<p>If you were really asking about <strong>arguments</strong>, then the question does not make much sense, because arguments are never lvalue references or rvalue references, because an expression of type <code>X&amp;</code> is immediately converted to an expression of type <code>X</code>, which denotes the referenced object.</p>

<p>But if you actually meant ""How does the compiler distinguish lvalue arguments from rvalue arguments?"" (note the missing <strong>reference</strong>), then the answer is simple: the compiler knows the value category of every expression, because the standard specifies for every conceivable expression what its value category is. For example, the call of a function is an expression that can belong to one of three value categories:</p>

<pre><code>X   foo();   // the expression foo() is a prvalue
X&amp;  bar();   // the expression bar() is an lvalue
X&amp;&amp; baz();   // the expression baz() is an xvalue
</code></pre>

<p>(Provided, of course, that <code>X</code> itself is not a reference type.)</p>

<p>If none of this answers your question, please clarify the question. Also, <a href=""https://stackoverflow.com/a/11540204/252000"">somewhat relevant FAQ answer</a>.</p>
",6
13456440,13454953,1,"<p>There is no way to combine two relative paths with one of the functions of this family. I'd get an absolute path using GetCurrentDirectory() or GetModuleFileName() (depending on you case) and combining it with the first path and then would combine the result with the second. Usually you always have some point where you can build an absolute path to start with.</p>
",0
9146553,9146493,1,"<p>Just make a copy constructor and an operator=  of the big object private. In QT they made special macro for that  Q_DISABLE_COPY().</p>
",0
9146556,9146493,3,"<p>You could declare the copy constructor for the types as <code>private</code> - since the copy ctor is called when passing objects by value, your code will error at compile time at any call-site where you're passing by value. </p>

<p>You can also use the new <code>c++11</code> support to <code>delete</code> unwanted constructors/destructors, if your compiler supports it. Check out the details <a href=""http://www2.research.att.com/~bs/C++0xFAQ.html#default"" rel=""nofollow"">here</a>.</p>

<p>If you actually need to use the copy ctor in your code another option is to add a debug break-point within the copy ctor. You can then step through a debug build of your program and check when the copy ctor is called.</p>

<p>Hope this helps.</p>

<p>EDIT: Since you're looking to detect copy-ctor use on the standard containers things are a little less straightforward. You could try something along <a href=""http://ideone.com/8CcRd"" rel=""nofollow"">these</a> lines, which is a super-ugly hack, delegating all <code>std::vector</code> instances through a wrapper class with a disabled copy-ctor. </p>

<p>Note the warnings in the code. I would only use this kind of thing to identify your pass-by-value issues and then delete it - reverting to clean use of <code>std::vector</code> etc.</p>

<p>If you wanted to permanently disable copying of standard containers you could write your own wrapper classes that encapsulate (rather than inherit from) the standard containers. </p>
",2
9146584,9146493,2,"<p>One way you can do is have your heavy object inherit from class like:</p>

<pre><code>struct heavy {
    struct heavy_copy_ctor_invoked {};
    heavy(const heavy&amp;) {
        typename boost::mpl::print&lt;heavy_copy_ctor_invoked&gt;::type _;
    }
};

struct foo : heavy { ...
</code></pre>

<p>everytime heavy copy-ctor is called, mpl will throw a warning.</p>
",0
10156414,10156260,1,"<blockquote>
  <p>The full specialization declaration can omit explicit template
  arguments when template being specialized can be determined via
  argument deduction (using as argument types the parameter types
  provided in the declaration) and partial ordering.[from ""C++
  Templates"" by Vandervoode, Josuttis]</p>
</blockquote>

<p>This it the case in your example so you can write:</p>

<pre><code>template&lt;&gt;
void f(int){;}
</code></pre>

<p>to specialize (a) and </p>

<pre><code>template&lt;&gt;
void f(int*){;}
</code></pre>

<p>to specialize (b).</p>
",0
17090913,17090021,0,"<p>Just provide an overload for the stream output operator:</p>

<pre><code>std::ostream&amp; operator &lt;&lt;(std::ostream&amp; dst, const OS_type&amp; ostype)
{
    switch (ostype) {
        case Unknown: dst &lt;&lt; ""Unknown""; break;
        case Linux:   dst &lt;&lt; ""Linux""; break;
        case Apple:   dst &lt;&lt; ""Apple""; break;
        case Windows: dst &lt;&lt; ""Windows""; break;
        default:      dst &lt;&lt; ""invalid"";
    }
    return dst;
}
</code></pre>

<p>You can now just do:</p>

<pre><code>int main()
{
    OS_type ostype = Apple;
    std::cout &lt;&lt; ostype &lt;&lt; '\n';
}
</code></pre>
",1
13730742,13730706,4,"<p>Theoretically, since <code>goo</code> (and <code>foo</code> for that matter) returns by value, a copy of the variable referenced by <code>a</code> will be returned (and placed on the stack). Said copy will have its lifetime extended by <code>b</code>, until <code>b</code>'s scope ends.</p>

<p>I think the main point you're missing is that you return <strong>by value</strong>. Which means that after <code>foo</code> or <code>goo</code> return, it really makes no difference of anything that's inside them - you're left with a temporary string which you bind to a <code>const</code> reference.</p>

<p>In practice, everything will most likely be optimized out.</p>
",3
13730778,13730706,7,"<p>I think that there's a middle step you've failed to consider, which is that you are not binding <code>b</code> to <code>a</code>, but instead to a copy of <code>a</code>. And this isn't due to any fancy memory shenanigans!</p>

<p><code>goo</code> returns by value and, as such, that value is available within the scope of the <em>full-expression</em> inside <code>main</code> per all the usual mechanisms. It'll either be in <code>main</code>'s stack frame, or somewhere else, or (in this contrived case) likely optimised out entirely.</p>

<p>The only magic here is that it is <em>kept</em> in <code>main</code>'s scope until <code>b</code> goes out of scope, because <code>b</code> is a ref-to-<code>const</code> (instead of being near-immediately destroyed).</p>

<p>So, will the heap come into it in any way whatsoever? Well, if you have a heap, no. If you mean the free store then, still, no.</p>
",11
13730805,13730706,3,"<p>No, there will not be any dynamic allocation for the lifetime extension. The common implementation is equivalent to the following code transformation:</p>

<pre><code>std::string goo()
{
    std::string __compiler_generated_tmp = foo();
    const std::string &amp; a = __compiler_generated_tmp;
    return a;
}
</code></pre>

<p>There is no need for dynamic allocation as the lifetime will only be extended for as long as the reference is alive, and by the C++ lifetime rules that will happen at the end of the current scope. By placing an unnamed (<code>__compiler_generated_tmp</code> in the code above) variable in the scope, the usual lifetime rules will apply and do what you expect.</p>
",11
13730946,13730706,4,"<p>Here is an example of what the C++ standard allows the compiler to rebuild your code as.  I'm using full NRVO.  Note the use of placement <code>new</code>, which is a moderately obscure C++ feature.  You pass <code>new</code> a pointer, and it constructs the result there instead of in the free store.</p>

<pre><code>#include &lt;iostream&gt;

void __foo(void* __construct_std_string_at)
{
  new(__construct_std_string_at)std::string(""abc"");
}

void __goo(void* __construct_std_string_at)
{
  __foo(__construct_std_string_at);
}

int main()
{
  unsigned char __buff[sizeof(std::string)];
  // Is a temporary allocated on the heap to support this, even for a moment?
  __goo(&amp;__buff[0]);
  const std::string &amp; b = *reinterpret_cast&lt;std::string*&gt;(&amp;__buff[0]);
  // ... more code here using b I assume
  // end of scope destructor:
  reinterpret_cast&lt;std::string*&gt;(&amp;__buff[0])-&gt;~std::string();
}
</code></pre>

<p>If we blocked NRVO in <code>goo</code>, it would instead look like</p>

<pre><code>#include &lt;iostream&gt;

void __foo(void* __construct_std_string_at)
{
  new(__construct_std_string_at)std::string(""abc"");
}

void __goo(void* __construct_std_string_at)
{
  unsigned char __buff[sizeof(std::string)];
  __foo(&amp;__buff[0]);
  std::string &amp; a = *reinterpret_cast&lt;std::string*&gt;(&amp;__buff[0]);
  new(__construct_std_string_at)std::string(a);
  // end of scope destructor:
  reinterpret_cast&lt;std::string*&gt;(&amp;__buff[0])-&gt;~std::string();
}

int main()
{
  unsigned char __buff[sizeof(std::string)];
  // Is a temporary allocated on the heap to support this, even for a moment?
  __goo(&amp;__buff[0]);
  const std::string &amp; b = *reinterpret_cast&lt;std::string*&gt;(&amp;__buff[0]);
  // ... more code here using b I assume
  // end of scope destructor:
  reinterpret_cast&lt;std::string*&gt;(&amp;__buff[0])-&gt;~std::string();
}
</code></pre>

<p>basically, the compiler knows the lifetime of the references.  So it can create ""anonymous variables"" that store the actual instance of the variable, then create references to it.</p>

<p>I also noted that when you call a function, you effectively (implicitly) pass in a pointer to a buffer to where the return value goes.  So the called function constructs the object 'in place' in the caller's scope.</p>

<p>With NRVO, a named variable in the called function scope is <em>actually</em> constructed in the calling functions ""where the return value goes"", which makes returning easy.  Without it, you have to do everything locally, then at the return statement copy your return value to the implicit pointer to your return value via the equivalent of placement new.</p>

<p>Nothing needs be done on the heap (aka free store), because lifetimes are all easily provable and stack-ordered.</p>

<p>The original <code>foo</code> and <code>goo</code> with the expected signature would have to still exist, as they have external linkage, until possibly discarded when it is found that nobody uses them.</p>

<p>All variables and functions starting with <code>__</code> exist for exposition only.  The compiler/execution environment no more needs to have a named variable than you need to have a name for a red blood cell.  (In theory, because <code>__</code> is reserved, a compiler that did such a translation pass before compiling would probably be legal, and if you actually used those variable names and it failed to compile it would be your fault not the compiler's fault, but ... that would be a pretty hackey compiler.  ;) )</p>
",5
13731102,13730706,1,"<p>In <code>std::string goo()</code> , a std::string is returned by value.</p>

<p>When the compiler see you calling this function in main(), it notices that the return value is a std::string, and allocates space on the stack of main for a std::string. </p>

<p>when goo() returns, the reference <code>a</code> inside goo() is not valid anymore, but the std::string <code>a</code> references is copied into the space reserved on the stack in main()</p>

<p>In situations such as this, several optimizations are possbile, you can read about what one compiler can do <a href=""http://msdn.microsoft.com/en-us/library/ms364057%28VS.80%29.aspx"" rel=""nofollow"">here</a></p>
",1
10176605,10176433,3,"<p>Instead of returning a <code>bool</code> and passing in a reference have the function return a smart pointer, ensuring the caller cannot forget to deallocate:</p>

<pre><code>std::shared_ptr&lt;MyObject&gt; myObjectPtr = FindFlaggedObject();
if (myObjectPtr)
{
    // Found flagged object.
}

std::shared_ptr&lt;MyObject&gt; FindFlaggedObject()
{
    MyObject* result = nullptr;
    std::vector&lt;MyObject&gt; myObjects = GetSomeObjectList();
    for (UINT i = 0; i &lt; myObjects.size(); i++)
    {
        if (myObjects[i].Flag) {
            result = new MyObject(myObjects[i]);
            break;
        }
    }
    return std::shared_ptr&lt;MyObject&gt;(result);
}
</code></pre>
",4
10176516,10176433,0,"<p>No need to construct an automatic object with an default constructor.
Just pass constructor parameters.</p>

<pre><code>void main()
{
   MyObject myObject (12); 
   if (FindFlaggedObject(myObject))
   {
     ...
   }
}
</code></pre>

<p>On the other side, why don't do it this way?</p>

<pre><code>MyObject FindFlaggedObject()
{
 std::vector&lt;MyObject&gt; myObjects = GetSomeObjectList();
 for (UINT i = 0; i &lt; myObjects.size(); i++)
 {
     if (myObjects[i].Flag) {
         return myObjects[i];
     }
 }
 return 0;
}

void main()
{
   MyObject* res = FindFlaggedObject();
   if (res != 0) {
      ...
   }
}
</code></pre>

<p>You don't have to care to delete <strong>res</strong> as long <strong>res</strong> is still member in GetSomeObjectList</p>
",0
10176606,10176433,2,"<p>Instead of using an out parameter, return a value.  Since the value is optional, as indicated by the current return type of bool, you can use <code>boost::optional</code> for that purpose:</p>

<pre><code>boost::optional&lt;MyObject&gt; FindFlaggedObject()
{
    std::vector&lt;MyObject&gt; myObjects = GetSomeObjectList();
    for (UINT i = 0; i &lt; myObjects.size(); i++)
    {
        if (myObjects[i].Flag) {
            return myObjects[i];
        }
    }
    return boost::none;
}
</code></pre>
",1
10176618,10176433,5,"<p>Return by value is almost always the best solution if the object
supports copy (and objects which will be declared on the stack should
generally support copy).  If the function can fail, and not always 
return an object, you can use some sort of <code>Fallible</code> or <code>Maybe</code> class:</p>

<pre><code>Fallible&lt;MyObject&gt;
FindFlaggedObject()
{
    std::vector&lt;MyObject&gt; objects = GetSomeObjectList();
    std::vector&lt;MyObject&gt;::const_iterator current = objects.begin();
    while ( current != objects.end() &amp;&amp; !current-&gt;flag ) {
        ++ current;
    }
    return current == objects.end()
        ? Fallible&lt;MyObject&gt;()
        : Fallible&lt;MyObject&gt;( *current );
}
</code></pre>

<p>You might reflect, though: if GetSomeObjectList() can always return a
reference to an existing list (rather than constructing a list
internally), and you modify it to return a const reference, you could
just return a pointer:</p>

<pre><code>MyObject const*
FindFlaggedObject()
{
    std::vector&lt;MyObject&gt; const&amp; objects = GetSomeObjectList();
    std::vector&lt;MyObject&gt;::const_iterator current = objects.begin();
    while ( current != objects.end() &amp;&amp; !current-&gt;flag ) {
        ++ current;
    }
    return current == objects.end()
        ? NULL
        : &amp;*current;
}
</code></pre>

<p>This is a very typical C++ idiom.</p>
",9
9220276,3625545,1,"<p>New C++11 standard now supports explicit overrides and final of member functions!</p>
",0
10764636,10692748,0,"<pre><code>    int a[1024];
ifstream myfile;
myfile.open(""1.txt"");
for(i=0;i&lt;n;i++)
{
    getline (myfile, buffer);

    a[i]= atoi(buffer.c_str());
    cout &lt;&lt; buffer &lt;&lt; ""\n"";
}
</code></pre>

<p>this is the right answer </p>
",1
11490195,11489260,1,"<p>C++ only says that <code>gmtime</code> may fail. The standard that specifies the behavior of <code>gmtime</code> on large input is <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/gmtime.html"" rel=""nofollow"">POSIX</a>: </p>

<blockquote>
  <p>If an error is detected, gmtime() shall return a null pointer and set errno to indicate the error.</p>
  
  <p>ERRORS</p>
  
  <p>The gmtime() and gmtime_r() functions shall fail if:</p>
  
  <p>[EOVERFLOW]
   The result cannot be represented. </p>
</blockquote>

<p>It doesn't directly say what the limit is, although it does say that if the seconds since the Epoch are negative, their relationship to the actual time is <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15"" rel=""nofollow"">undefined</a>.</p>

<p>As an alternative, try boost</p>

<pre><code>auto testgmtime = [](std::time_t time)
{
    std::cout &lt;&lt; boost::posix_time::from_time_t(time) &lt;&lt; '\n';
};
</code></pre>

<p>(although on my linux setup, from_time_t() appears to hit the ceiling earlier than gmtime)</p>
",0
11490556,11489260,2,"<p>VS2012 is not being crappy. Do the math.</p>

<p>If <code>time_t</code> is a 64-bit integer, then the maximum number of seconds in it is 2<sup>64</sup>-1 if it's an unsigned integer or 2<sup>63</sup>-1 if it's a signed integer.</p>

<p>Roughly, 2<sup>63</sup> seconds corresponds to 2<sup>63</sup>/(60*60*24*365) ¡Ö 2.9*10<sup>11</sup> years.</p>

<p><code>time_t</code>'s <code>tm_year</code> is a 32-bit <code>int</code>, whose maximum value is 2<sup>31</sup>-1 ¡Ö 2.1*10<sup>9</sup>.</p>

<p>Clearly, you can't store ~2.9*10<sup>11</sup> in a 32-bit signed integer. And <code>gmtime()</code> rightfully fails when you ask it to.</p>

<p>You may be able to modify my implementation of <code>gmtime()</code> in <a href=""https://stackoverflow.com/a/11197532/968261"">this answer</a> to handle very large values. You'll need to workaround the overflow in <code>SecondsSinceEpoch + 11644473600ULL</code> and change some <code>ints</code> and <code>uints</code> to <code>uint64s</code>.</p>
",4
9807942,9807876,2,"<p>If you expect to call the function using a const pointer or reference, you must mark the function <code>const</code> to be able to do so. Otherwise it's completely up to you.</p>

<p>Edit: Giving this some more thought. Your object probably contains a handle to an OS window, and this handle can be passed to OS functions. The handle doesn't really have a concept of constness so it's an impedance mismatch with C++, but the function you pass it to will either be querying a window property (const) or modifying the window in some way (non-const). It would be useful for your object to enforce the constness concept even though the OS does not.</p>
",1
9807983,9807876,4,"<p>It may not change any state of any variable physically held within the Window object, but it does change the state of the thing the Window represents, so I would definitely argue non-<code>const</code>.</p>
",0
9808108,9807876,6,"<p>What you¡¯re probably grappling with is that C++ has no notion of purity, that is, whether or not a function has side-effects. <code>const</code> member functions only make the promise that the state of the <em>object itself</em> will not be modified.</p>

<p>However, some objects logically consist of more state than what the instance actually contains. This comes up very often when an object¡¯s role is to interact with state managed by another library¡ªespecially a GUI library.</p>

<p>Therefore, while <code>show()</code> can <em>incidentally</em> be marked <code>const</code>, it logically should <em>not</em> be. If it were truly <code>const</code>, then you would expect a function such as <code>is_visible()</code> to return the same value both before and after the call to <code>show()</code>, and clearly that is not the case.</p>

<p>In other words, <code>const</code> functions are those that change nothing about the object <em>that you can observe through its public interface</em>. That¡¯s the reasoning behind, for example, marking some member functions <code>const</code> but using a <code>mutable</code> member to do internal bookkeeping.</p>
",3
9808499,9807876,5,"<p>This is the classical logical const vs. bitwise const question.  It was
debated hotly back when I was learning C++ (early 1990's), but since
then, I think there is a consensus in favor of logical const: if the
logical state of an object changes, then the function should not be
<code>const</code> (even if the compiler would allow <code>const</code>), and if the logical
state doesn't change, then the function should be <code>const</code> (even if you 
need <code>mutable</code> or to cast away const to do; e.g. a cached result of a
computation).</p>

<p>In the specific case of <code>Window::show</code>, it's hard to say.  Is the fact
that the window is being displayed part of its ""logical state"" or not.</p>
",0
9808728,9807876,0,"<p>Usually you have this situation:</p>

<ul>
<li><p>For each API window, there is at most one C++ window object.</p></li>
<li><p>A C++ window object is not copyable (including that it is not cloneable).</p></li>
</ul>

<p>For this case it is possible to use <code>const</code> in the C++ object interface, so as to let client code offer no-state-change guarantees by e.g. declaring some parameter as <code>const</code>.</p>

<p>However, as soon as one or both constraint are removed, it becomes a futile and meaningless exercise. Consider, for example, removing the second constraint, making the C++ objects copyable. That might seem to make sense, treating the C++ objects almost like <code>shared_ptr</code> instances (except for destruction).</p>

<p>But any <code>const shared_ptr</code> can be copied to a non-<code>const</code> one, so any non-<code>const</code> methods can easily be called. For example, <code>shared_ptr::get</code> is a <code>const</code> method so that it can be called on a <code>const shared_ptr</code> object. But its result is <code>T*</code>, i.e. no <code>const</code> propagation to the result, because even if it was <code>T const*</code> it would not really restrict the client code: the client code could just copy that <code>const shared_ptr</code> to a non-<code>const</code> one, and then call <code>get</code> on the non-<code>const</code> instance.</p>

<p>Still, with both gurantees above in place the fact that <code>const</code> (or in your case the absence of <code>const</code>) <em>can</em> be used in a  possibly useful way to restrict operations on the referred API window, does not mean that it is necessarily a good idea to do it.</p>

<p>In particular, objects that represent windows are usually event receivers, and in my experience, events do not mix very well with <code>const</code>.</p>

<p>However, most programmers are used to pure <em>inspectors</em> being <code>const</code>. And for that usage, just improving the readability of the code, I would recommend <code>const</code> methods. For example, an inspector that returns the window size, would in my view better be <code>const</code> than non-<code>const</code>.</p>
",1
14860231,14859579,1,"<p>This looks like a bug in GCC and VS2010. Clang won't compile it, and it should not compile according to <code>[except.spec]/5</code>:</p>

<blockquote>
  <p>... A similar restriction applies to assignment to and initialization of pointers to functions, pointers to member functions, and references to functions: the target entity shall allow at least the exceptions allowed by the source value in the assignment or initialization.</p>
</blockquote>

<p>The standard also includes the following example:</p>

<pre><code>class A { /*...*/ };
void (*pf1)(); // no exception specification
void (*pf2)() throw(A);
void f() {
    pf1 = pf2; // OK: pf1 is less restrictive
    pf2 = pf1; // error: pf2 is more restrictive
}
</code></pre>
",0
14860318,14859579,1,"<p>It's a long-standing bug in g++: <a href=""http://gcc.gnu.org/bugzilla/show_bug.cgi?id=12255"" rel=""nofollow"">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=12255</a></p>

<blockquote>
  <p>The underlying issue is that G++ just ignores exception-specifications on
  non-function declarations.  I think this choice originated in the uncertainty
  about whether or not the exeception-specification would become part of a
  function type rather than remain associated with the declaration.</p>
</blockquote>

<p>It wouldn't surprise me if VS was similar in this regard.</p>
",0
9207825,9206776,0,"<p>One thing you are missing is keeping a reference to the predecessor while searching. This is necessary in order to keep the chain intact.</p>

<p>Here is a draft that should work (currently untested!):</p>

<pre><code>while (!done || current != NULL)
{ 
    //If we found the place to insert
    if (strncmp(current-&gt;name, name, MAX_ITEM_NAME_LEN) &lt; 0)
    {
        //If the place to insert was at head
        if(pred == NULL)
        {
            //The new node becomes the head
            head = temp;
        }
        else
        {
            //Set the previous nodes next to point at this node.
            pred-&gt;next = temp;
        }

        //Always set the node to be inserted's next
        //pointing to the node we should be inserted before
        temp-&gt;next = current;
    done = true;        
  }                     
    if (!done)
    {
        //No match, keep looking but keep an updated pred pointer
        pred = current;
        current = current-&gt;next;
    }
} 
</code></pre>
",0
9207975,9206776,0,"<pre><code>It's just pseudocode, but maybe it helps:

if(head == NULl)
    {
          //make newnode as head
}

if(head.name == new name)
    {
    //update quantity
    }

if(head.name &lt;new name)
    {
    //insert newnode before head
    //make newnode as head
    }

if (new name &gt; head.name)

{
    current = head;
    succ = current.next;

    while (succ &amp;&amp; new name &lt;succ.name)
        {
                 curent = succ;
         succ = succ.next
        }


    if(succ = NULL)
        current-&gt;next = newnode
    else
        if new name = succ-&gt;name
            update quantity
        else
            curent-&gt;next = newnode
            newnode-&gt;next = succ;
}
</code></pre>
",0
9217094,9216962,1,"<p>The key difference is that <code>Origin</code> and <code>Extends</code> are <em>types</em>, while <code>o</code> and <code>e</code> are <em>variables</em> and cannot be interpreted as types.</p>
",0
11857688,11857645,4,"<p>Overwhelmingly likely to be completely irrelevant. The compiler will likely not even generate different assembly for the two, and even if it did, the performance cost of a tiny thunk would be negligible. There's no reason to even think about this.</p>

<p>The best function is the one that is the most clear/etc, in this case. </p>
",0
11857859,11857645,1,"<p>I'd implement only the one that takes Point objects, then create a Point constructor that takes an <code>std::initializer_list</code>, so when you want to pass individual doubles, you can use something like:</p>

<pre><code>SetPoints({xA, yA}, {xB, yB}, {xC, yC});
</code></pre>
",0
16947953,16947908,7,"<p>The best solution I can come up with is to replace <code>arr[COUNT]</code> with <code>arr[]</code>, and then write a template to assert that <code>sizeof(arr) / sizeof(int) == COUNT</code>. This won't ensure that it's initalized to <code>-1</code>, but it will ensure that you've explicitly initialized the array with the correct number of elements.</p>

<p>C++11's <code>static_assert</code> would be even better, or Boost's macro version, but if you don't have either available, you'll have to come up with something on your own.</p>
",6
16948796,16947908,1,"<p>The <a href=""http://www.boost.org/doc/libs/1_53_0/libs/preprocessor/doc/index.html"" rel=""nofollow noreferrer"">Boost.Preprocessor</a> library might provide something useful, but I doubt whether you will be allowed to use it and it might turn out to be unwieldy to extract from the Boost sources.</p>

<p>This similar question has an answer that looks helpful:
<a href=""https://stackoverflow.com/questions/6080129/trick-filling-array-values-using-macros-code-generation"">Trick : filling array values using macros (code generation)</a></p>
",4
16948875,16947908,2,"<p>Answering my own question: while it seems to be impossible to provide the array with the right amount of initializers directly, it is really easy to just test the list of initializers for the right amount:</p>

<pre><code>#define INITIALIZERS -1, -1, -1,
struct check {
  check() {
    const char arr[] = {INITIALIZERS};
    typedef char t[sizeof(arr) == COUNT ? 1: -1];
  }
};

const int arr[COUNT] = { INITIALIZERS };
</code></pre>

<p>Thanks @dauphic for <a href=""https://stackoverflow.com/a/16947953/410126"">the idea to use a variable array to count the values</a>.</p>
",0
15846916,15846898,3,"<p><code>std::list</code> uses a bidirectional iterator, which doesn't support <code>operator-</code> or <code>operator+</code>. Use <code>std::prev(collisionActorsList.end())</code> and <code>std::next(_actorUpdateIter)</code>.</p>

<p>As pointed out below in the comments, you should be aware of whether your list is empty. If it is, these will fail to do what you want. There's a simple function for that: <code>collisionActorsList.empty()</code>.</p>
",8
9218324,9218278,4,"<p>Looks like you aren't linking the cln library. Try the following (assuming the library is installed correctly):</p>

<pre><code>g++ main.cpp LinearEquation.o -lcln
</code></pre>

<p>See the documentation for more details on compiling:
<a href=""http://www.ginac.de/CLN/cln_11.html#SEC64"" rel=""nofollow"">http://www.ginac.de/CLN/cln_11.html#SEC64</a></p>
",0
12293430,3536698,1,"<p>In my opinion multiple returns are fine and less complex. Multiple condition check statements reduce the performance and increases the code size unnecessarily. I always used to put multiple returns according to the situation. And its not a bad programming practice according to me.  </p>
",0
15891553,15891231,1,"<p>This is probably closer to what you're looking for, using pointers for neighbors. Hope this helps. Ultimately the difference is the by-pointer addressing of neighbors within the primary vertex container, as opposed to all those copies being made in your code. </p>

<p>Note: the add-construction just sets up a node to have the ""next"" node in the vertices collection as its neighbor, finishing with the last node getting the first for a neighbor. This seemed to be what you're code was trying to accomplish.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;utility&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;list&gt;

using namespace std;

enum class color_type {
    BLACK,
    WHITE,
    GRAY
};

struct vertex {
    char label;
    color_type color;
    int start;
    int finish;
    vertex *parent;
    vector&lt;vertex*&gt; adjacents;

    vertex(char label)
    :label(label), start(0), finish(0), color(color_type::WHITE) {
    }

    void add_neighbor(vertex &amp;v) {
        adjacents.push_back(std::addressof(v));
    }
};

class digraph {
private:
    vector&lt;vertex&gt; vertices;
    int count;

public:
    digraph()
    :count(0) {
        vertices.push_back(vertex('a'));
        vertices.push_back(vertex('b'));
        vertices.push_back(vertex('c'));
        for (size_t i=0; i&lt;vertices.size(); ++i)
        {
            vertices[i].color = color_type::WHITE;
            vertices[i].parent = NULL;
            vertices[i].add_neighbor(vertices[(i+1)%vertices.size()]);
        }
    }

    void dfs() {
        dfs_visit(vertices[0]);
    }

    void dfs_visit(vertex &amp;u) {
        count++;
        u.start = count;
        u.color = color_type::GRAY;
        cout &lt;&lt; ""??? visit = "" &lt;&lt; u.label &lt;&lt; endl;
        cout &lt;&lt; ""# neighbors: "" &lt;&lt; u.adjacents.size() &lt;&lt; '\n';
        for (int i = 0; i &lt; u.adjacents.size(); ++i) {
            if (u.adjacents[i]-&gt;color == color_type::WHITE) {
                cout &lt;&lt; ""visit neighbor of ["" &lt;&lt; u.label &lt;&lt; ""] is: "" &lt;&lt; u.adjacents[i]-&gt;label &lt;&lt; endl;
                u.adjacents[i]-&gt;parent = &amp;u;
                dfs_visit(*(u.adjacents[i]));
            }
        }
        u.color = color_type::BLACK;
        count++;
        u.finish = count;
    }

public:
    friend ostream&amp; operator &lt;&lt;(ostream&amp; o, const digraph &amp;dg) {
        for (int i = 0; i &lt; dg.vertices.size(); ++i) {
            o &lt;&lt; dg.vertices[i].label &lt;&lt; "":\n"";
            o &lt;&lt; ""\t start  = "" &lt;&lt; dg.vertices[i].start &lt;&lt; endl;
            o &lt;&lt; ""\t finish = "" &lt;&lt; dg.vertices[i].finish &lt;&lt; endl;
        }
        return o;
    }
};

int main() {
    digraph dg;
    dg.dfs();
    cout &lt;&lt; dg &lt;&lt; endl;
    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>??? visit = a
# neighbors: 1
visit neighbor of [a] is: b
??? visit = b
# neighbors: 1
visit neighbor of [b] is: c
??? visit = c
# neighbors: 1
a:
     start  = 1
     finish = 6
b:
     start  = 2
     finish = 5
c:
     start  = 3
     finish = 4
</code></pre>
",0
14150907,14150589,2,"<p>The important things to note in this template definition are:</p>

<ul>
<li>the template parameters are <em>values</em>, and not types as many people usually expect in templates;</li>
<li>the field <code>value</code> of the struct template is computed from these parameters;</li>
<li>the template has a partial specialization for the second parameter <code>N</code> when set with <code>0</code>.</li>
</ul>

<p>As you noticed, the template recurse on the <code>value</code> field computation. that recursion would be infinite, if the partial specialization were not defined. When the second parameter ""reaches"" <code>0</code>, ie. when, by following the nesting of template instantiation in the attempt of getting the successive value fields necessary to compute the outermost one, the compiler finally needs to instantiate the template with parameter N equal to <code>0</code>, and selects the partial specialization version, which contains a constant value of <code>1</code> for the field. Then the compiler can compute each nested value field, to finally return to the outermost one. </p>

<p>Using this technique, it is possible to have the compiler compute certain values offline (ie. at compile time). This let the programmer have his constant values defined by their parameters and formula, rather than having to hardcode them, or make the compiled program compute them at each run.</p>

<p>But the issue with this approach, how clever it may seem, is its readability and thus ease of maintenance. That's most probably the reason why the new standard offers the <code>constexpr</code> concept, which is a much proper way to define so called <a href=""http://en.m.wikipedia.org/wiki/Pure_function"" rel=""nofollow"">pure computation</a>.</p>

<hr>

<p>It should be noted that both fields of the templates are signed, and that the computation does not try to handle the negative values in any way. If N is initially set at <code>-1</code>, the result could be interesting.</p>
",0
14150613,14150589,3,"<p>it's a way to compute an integral power at compile time, relying on the compiler supporting the requisite number of template specializations (i.e., it's not exactly portable code)</p>

<p>read up on templates in your favorite c++ text book</p>

<p>if you don't have a c++ text book yet: you need it, take a look in the SO FAQ <strong><a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">C++ book list</a></strong></p>

<hr>

<p>a much better and (in a few years) probably much more portable way in C++11 is to use a <code>constexpr</code> function:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

constexpr int constpow( int base, int n )
{
    return (n == 0? 1 : base*constpow( base, n - 1 ));
}

int main()
{
    int const quarticOfThree = constpow( 3, 4 );
    wcout &lt;&lt; quarticOfThree &lt;&lt; endl;
}
</code></pre>

<p>however, that's not supported by visual c++ 11.0, the latest version of visual c++ as i write this</p>
",5
10126911,10126732,1,"<p>No.  In order to do so, the implementation of <code>std::basic_string</code> would need additional information as to whether the <code>wchar_t const*</code> came from a string literal or not, and this information is simply not available.  And even if it were, it would add to the cost of using the class, even when the argument wasn't a <code>wchar_t const*</code>.</p>

<p>If these strings are at global scope, the cost for constructing them is only at start up.  And if they are local variables, you can always declare them <code>static</code>, so the cost of constructing them will only be paid once, and not every time you enter the block.</p>
",0
10126922,10126732,1,"<p>There are indeed valid use-cases for this but the C++ string class flat out doesn¡¯t support it. If you really need it you are required to write your own string class which supports interning.</p>

<p>Note that several other languages support this natively; the C++ string classes unfortunately cover a rather specific use-case (lots of modifications) instead of the general one (lots of copies of essentially immutable strings).</p>

<p>To simplify the task, consider whether it¡¯s enough for you to use a thin wrapper class around a pair of (const) iterators which could just point to the beginning and end of the <code>wchar_t</code> buffer in static memory.</p>
",2
15842538,3205511,0,"<p>It is a hack.</p>

<p>Try this.  Run the example as is.  Remove the 4 instances of 1000.  You will get points instead of lines.
Put in 750 instead of 1000.  You get the same result as if you had put in 1000.</p>

<p>The 1000 is to make sure the lines get drawn across the image.  You could also do the following, which is
a little better:</p>

<p>Right after HoughLines(...) is called, add the following:</p>

<pre><code>int h = src.rows;
int w = src.cols;
int factor = (int) (sqrt(h * h + w * w));  // diagonal length of the image, maximum line length
</code></pre>

<p>Then instead of 1000, multiply by factor.  If your image is greater than 1000x1000, the original
code won't work.</p>

<p>Roy</p>
",0
10113246,10113208,24,"<p>No problem. The compiler promotes the 32-bit to 64-bit before the comparison</p>
",3
10113250,10113208,8,"<p>Short answer - yes. The 'smaller' is converted to bigger one before comparison.</p>
",0
9186735,9186718,3,"<p>In the second case, no operator is involved. There is nothing to override.</p>
",4
9186764,9186718,2,"<p>It doesn't make sense to be able to override the latter. The ""new"" operator is override-able to allow optimizations in allocating, for instance, using a slab allocater, etc. But when you create a variable on the stack, there is no decision to be made as to where it is placed.</p>
",0
9186885,9186718,0,"<p>If you want to create the creation of the object, you want to create a default constructor, not override the <code>new</code> operator.</p>

<p>In your header file:</p>

<pre><code>class CSomeClass
{
public:
    CSomeClass();
}
</code></pre>

<p>And then in your definition file:</p>

<pre><code>CSomeClass::CSomeClass()
{
    // Initialize your object here
}
</code></pre>

<p>That is, unless I misunderstood the question :-)</p>
",0
9187978,9186718,0,"<pre><code>CSomeClass* pSomeClass = new CSomeClass;
</code></pre>

<p>Here you create a dynamic object of the class CSomeClass. The compiler calls the no-argument constructor.</p>

<pre><code>CSomeClass pSomeClass;
</code></pre>

<p>You create non-dynamic object of the class CSomeClass. The compiler calls EXACTLY the same no argument constructor.</p>

<p>You can use operator new to allocate memory for dynamic variables:</p>

<pre><code>int *number= new int(1);
</code></pre>
",0
14754141,14753960,1,"<p>Or</p>

<pre><code>class A
{
    public:
         static void doWork();
};
class B
{
     B(void)
     {
          A::doWork();
     }
};
</code></pre>

<p>?</p>

<p>PS: Here B::B() will be private</p>
",0
14754179,14753960,3,"<p>In order for that to work you'd need to subclass it.</p>

<p>So it'd be like this:</p>

<pre><code>class A {
  doWork();
}

class B : A {
   B(){
     doWork();
   }
}
</code></pre>

<p>You could also do it like so going for a HAS-A rather than IS-A relationship:</p>

<pre><code>class A {
   doWork();
}

class B {
   A myA;
   B(){
      myA.doWork();
   }
}
</code></pre>

<p>Without knowing more of what you are doing I'd go with the top (IS-A) solution which is what I think you are trying to do.</p>
",0
14754229,14753960,4,"<p>You told us not enough to choose proper solution. Everything depends on what you are trying to achieve. A few solutions:</p>

<p>a) Mark A method as static.</p>

<pre><code>class A
{
public:
    static void DoSth()
    {
        // Cannot access non-static A members here!
    }
};

class B
{
public:
    B()
    {
        A::DoSth();
    }
};
</code></pre>

<p>b) You can instantiate A in place</p>

<pre><code>class A
{
public:
    void DoSth()
    {
        // Do something
    }
};

class B
{
public:
    B()
    {
        A a;
        a.DoSth();
    }
};
</code></pre>

<p>c) You can put A's instance into B:</p>

<pre><code>// A remains as in b)

class B
{
private:
    A a;
    // or: A * a;

public:
    B()
    {
        a.DoSth();
        // or: a = new A; a-&gt;DoSth();
        // Remember to free a somewhere
        // (probably in destructor)
    }
}
</code></pre>

<p>d) You may derive B from A:</p>

<pre><code>class A
{
protected:
    void DoSth()
    {
    }
};

class B : public A
{
public:
    B()
    {
        DoSth();
    }
};
</code></pre>

<p>e) You can forget about A class and make DoSth a function:</p>

<pre><code>void DoSth()
{
    // ...
}

class B
{
public:
    B()
    {
        DoSth();
    }
}
</code></pre>

<p>Since you provided not enough data, you have to choose solution on your own.</p>
",0
9142384,9142372,1,"<p>Return a <code>const_iterator</code> and declare the method const.</p>
",3
9142468,9142372,1,"<p>You could have a special type of iterator that was incompatible with the member functions of your <code>list</code> which take iterators to mutate the list, so that you can access the objects through the iterator but not pass them to the functions that change the list they belong to.</p>

<p>That assumes that iterators don't remember what container they came from. If they do, then just make that special iterator class have no functions that can change its parent container.</p>
",0
14826559,3296178,1,"<p>I wasn't able to google an appropriate get_last_line function for my needs and here's what i came up with. You can even read multiple non-empty last lines by recalling the instream get_last_line func without resetting the seeker. It supports a 1 char only file. I added the reset parameter, which can be set to ios_base::end to allow output operations after reading the last line(s)</p>

<pre><code>std::string&amp; get_last_line(
        std::istream&amp; in_stream, 
        std::string&amp; output = std::string(), 
        std::ios_base::seekdir reset = std::ios_base::cur)
{
    output.clear();
    std::streambuf&amp; buf = *in_stream.rdbuf();
    bool text_found = false;

    while(buf.pubseekoff(-1, std::ios_base::cur) &gt;= 0)
    {
        char c = buf.sgetc();
        if(!isspace(c))
            text_found = true;
        if(text_found)
        {
            if(c == '\n' || c == -1)
                break;
            output.insert(0, sizeof c, c);
        }
    }

    buf.pubseekoff(0, reset);
    return output;
}

std::string&amp; get_last_line(
        const std::string&amp; file_name, 
        std::string&amp; output = std::string())
{
    std::ifstream file_in(
        file_name.c_str(), 
        std::ios_base::in | std::ios_base::ate);
    if(!file_in.is_open())
    {
        output.clear();
        return output;
    }
    get_last_line(file_in, output);
    file_in.close();
    return output;
}
</code></pre>
",0
12867622,12867536,0,"<p>Just mark the source or header file as read-only in the Windows Explorer!! :)</p>
",2
12867599,12867536,0,"<p>Mark the files as read-only when you distribute them. This offers the minimum amount the protection, as the permissions can be restored easily. Even from Visual Studio, if you attempt to overwrite the file, it will bring up a dialog that asks for confirmation of removal of read-only protection. This also happens for standard library headers.</p>
",1
14829142,14828861,0,"<p>If you look closer at the <code>read</code> call in the trace, you will notice it returns zero meaning end-of-file.</p>

<p>When a file descriptor is at EOF (or remote socket closed, etc), the descriptor is readable with <code>read</code> returning zero.</p>

<p>If you would have pressed <kbd>CTRL</kbd>+<kbd>d</kbd> in the interactive shell, you would have gotten the same result.</p>
",5
14833828,14828861,0,"<p>If you just need a 1-second timeout don't pass any file descriptors to <code>select()</code>. In this case <code>select()</code> works as a portable <code>sleep()</code> function.</p>
",3
10102181,10102159,14,"<p>You cannot change the length of an array. In C++, you should use an <code>std::vector</code> for dynamic arrays:</p>

<pre><code>#include &lt;vector&gt;

int main() {
    std::vector::size_type length = 10;
    std::vector&lt;float&gt; tables(length); // create vector with 10 elements
    tables.resize(20); // resize to 20 elemets
    tables[15] = 12; // set element at index 15 to value 12
    float x = tables[5]; // retrieve value at index 5
}
</code></pre>
",0
10102283,10102159,0,"<p>You can not change the length of an array dinamically while running program in C++. About the way you want to declare the array I suggest you the following:</p>

<pre><code>const int length=10;
float newTables[length];
</code></pre>

<p>I'm not sure if it's what you want. In this case the variable ""length"" is a constant and can not be changed in execution.</p>

<p>I hope it helps you.</p>
",1
10102223,10102159,1,"<p>If you are fine defining the size of array during build-time, you can use #define</p>

<pre><code>#DEFINE ARRAY_SIZE 20
float tables[ARRAY_SIZE];
</code></pre>

<p>Or if you need to specify the size of array during runtime, use new</p>

<pre><code>float* newtables;
newtables = new float[20];
</code></pre>
",6
10102234,10102159,1,"<p>Arrays in C++ have a fixed length. If you want to stick with a pure array you need to allocate the memory dynamically using <a href=""http://linux.die.net/man/3/malloc"" rel=""nofollow"">malloc, realloc and free</a>. However, you should prefer a <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow"">std::vector</a> or <a href=""http://en.cppreference.com/w/cpp/container/deque"" rel=""nofollow"">std::deque</a> for dynamic memory allocation. </p>
",0
14211582,11227124,0,"<p>An interpreted language is not good enough. I need speed. The software itself is an interpreted language. So I added support for the tiny C compiler. It is only C, and I do check mingw, which probably would not be as tiny as this. Thanks for all your hints.</p>

<p>Added after several months:</p>

<p>I have now two tools, actually: TinyC and Python. The speed difference between those is noticable (factor 5-10), but that usually does not matter too much. Python is much easier for the user, though I managed to integrate both into the Euler GUI quite nicely.</p>
",0
10823139,10819139,0,"<p>This reminded me of Python (just a bit):</p>

<pre><code>#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;

#include &lt;boost/variant.hpp&gt;
#include &lt;boost/variant/get.hpp&gt;
#include &lt;boost/format.hpp&gt;

class Foo
{
  typedef boost::variant&lt;double, int, std::string&gt; var;

  struct NoSuchAttributeError {
    NoSuchAttributeError(const std::string &amp;key) {
      std::cout &lt;&lt; boost::format(""Attribute %s not found!\n"") % key; 
    }
  };

  std::map&lt;std::string, var&gt; attributes;

  var&amp; getattr(const std::string&amp; key) {
    std::map&lt;std::string, var&gt;::iterator it = attributes.find(key);
    if (it == attributes.end()) {
      throw NoSuchAttributeError(key);
    }
    else {
      return (*it).second;
    }
  }

  template&lt;typename T&gt; 
  T&amp; get(var&amp; v) {
    return boost::get&lt;T, double, int, std::string&gt;(v);
  }

public:
  Foo() {
    // TODO: add attributes according to configuration file
    attributes[""foo""] = 42;
    attributes[""bar""] = ""baz"";
  }

  // TODO: add appropriate getters/setters for attributes
  int&amp; foo() { return get&lt;int&gt;(attributes[""foo""]); }
  std::string&amp; bar() { return get&lt;std::string&gt;(attributes[""bar""]); }
};

int main() {
  Foo f;
  std::cout &lt;&lt; f.foo() &lt;&lt; "" "" &lt;&lt; f.bar() &lt;&lt; std::endl;
  f.foo() = 13;
  f.bar() = ""Hello World!"";
  std::cout &lt;&lt; f.foo() &lt;&lt; "" "" &lt;&lt; f.bar() &lt;&lt; std::endl;
  return 0;
}
</code></pre>
",0
10775076,10775056,2,"<p>You need to use a template specialization to achieve this, not <code>typeid</code>. SFINAE can help you write one for all fundamental types faster, I believe.</p>
",2
15588163,15588151,5,"<p>You can use templates:</p>

<pre><code>template &lt;typename T&gt;
CLog&amp; CLog::operator &lt;&lt;(const T&amp; p) {
    buffer &lt;&lt; p;
    return *this;
}
</code></pre>
",0
15588164,15588151,1,"<p>This can be done with templates:</p>

<pre><code>template &lt;class T&gt;
Clog&amp; Clog::operator &lt;&lt;(const T&amp; t) {
    buffer &lt;&lt; t;
    return *this;
}
</code></pre>
",0
15588166,15588151,1,"<p>You can use a <code>template</code> in this case.</p>

<pre><code>template&lt;class T&gt;
CLog&amp; Clog::operator &lt;&lt;(const T&amp; value) {
    buffer &lt;&lt; value;
    return *this;
}
</code></pre>

<p>Make sure you don't pass anything that's invalid for <code>ofstringstream</code> though.</p>
",1
15588198,15588151,0,"<p>The other answer are basically correct, but they don't support move operations. Use</p>

<pre><code>template &lt;typename T&gt;
CLog&amp; CLog::operator &lt;&lt;(T&amp;&amp; p) {
    buffer &lt;&lt; std::forward&lt;T&gt;(p);
    return *this;
}
</code></pre>
",0
11172504,11172217,2,"<p>The problem here is mostly parsing, which would be covered in a compiler course probably in second or third year. Once you can parse expressions to build up a recursive data structure representing the input (called a syntax tree) it's pretty trivial to evaluate such expressions. A recursive decent parser can also evaluate the expression as it goes without actually building a syntax tree.</p>

<p>For a full treatment you'd want a book on compilers, such as the dragon book. Also IIRC the book <em>Programming: Principals and Practice using C++</em> covers an example like this.</p>

<p>You could also wait for chapter ten of <em>The Art of Computer Programming</em> to be published, which will cover parsing. It's scheduled to be out around 2020.</p>
",2
11172599,11172217,0,"<p>The easiest way to solve a (not necessarily) simple mathematical expression is to use the <a href=""http://en.wikipedia.org/wiki/Shunting-yard_algorithm"" rel=""nofollow"">Shunting Yard algorithm</a> to convert it to <a href=""http://mathworld.wolfram.com/ReversePolishNotation.html"" rel=""nofollow"">Reverse Polish Notation</a>, which is almost trivial to parse using a stack. Of course it might not be feasible to do so for an assignment or an interview (perhaps unless a SY algorithm reference is available).</p>
",0
11172637,11172217,1,"<p>Here is my shortest attempt. It took about 40 minutes to type up, you can play with it on ideone (<a href=""http://ideone.com/fvV8C"" rel=""nofollow"">link</a>).</p>

<p>The code is very straightforward, assuming that you have at least a cursory familiarity with the basic <a href=""http://en.wikipedia.org/wiki/Recursive_descent_parser"" rel=""nofollow""><em>recursive descent parsing</em></a> technique.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cctype&gt;
using namespace std;
bool eval_expr(const char **pe, int &amp;lhs, bool inside = false);
// gets the next char after skipping optional whitespace
char skip_ws(const char **pe) {
    while (**pe == ' ') ++(*pe);
    return **pe;
}
// evaluates a parenthesized expression or a number
bool eval_prim(const char **pe, int &amp;res) {
    char c = skip_ws(pe);
    if (c == '(') {
        ++(*pe);
        if (!eval_expr(pe, res, true)) return false;
        ++(*pe);
        return true;
    }
    if (isdigit(c)) {
        res = 0;
        while (isdigit(c)) {
            res = 10*res + c - '0';
            c = *(++(*pe));
        }
        return true;
    }
    return false;
}
// evaluates a chain of + - * / operations
bool eval_expr(const char **pe, int &amp;lhs, bool inside) {
    if (!eval_prim(pe, lhs)) return false;
    char op;
    while ((op = skip_ws(pe)) &amp;&amp; (op == '+' || op == '-' || op == '*' || op == '/')) {
        ++(*pe);
        int rhs;
        if (!eval_prim(pe, rhs)) return false;
        switch (op) {
            case '+': lhs += rhs; break;
            case '-': lhs -= rhs; break;
            case '*': lhs *= rhs; break;
            case '/': lhs /= rhs; break;
        }
    }
    return inside ? op == ')' : !op;
}
// wrapper API to hide an extra level of indirection
bool evaluate(const char *e, int &amp;result) {
    return eval_expr(&amp;e, result);
}
</code></pre>
",2
11173051,11172217,1,"<p>This is a simple scan push apply (the twist is the braces).</p>

<ol>
<li>Look for a number:
<ul>
<li>If you see a number push onto stack</li>
<li>if you see a '(' push it onto stack and <strong>goto 1</strong></li>
<li>Otherwise an error.</li>
</ul></li>
<li>Look for an op:
<ul>
<li>If you see an op push it onto stack</li>
<li>Otherwise an error</li>
</ul></li>
<li>Look for a number:
<ul>
<li>If you see a number push onto stack</li>
<li>If you see a '(' push onto stack and <strong>goto 1</strong></li>
<li>Otherwise an error  </li>
</ul></li>
<li>pop last three items from the stack  (should be number op number)<br>
<ul>
<li>do the operation and push the result onto the stack.  </li>
</ul></li>
<li>Now the complex bit:
<ul>
<li>Peek to see if the next character is a <strong>')'</strong> if it is goto ""PopCode"" below.</li>
</ul></li>
<li>If no more input <strong>goto 7</strong>.
<ul>
<li>Otherewise <strong>goto 2</strong></li>
</ul></li>
<li>If only one item on the stack you have your result.
<ul>
<li>Otherwise an error.</li>
</ul></li>
</ol>

<p>PopCode</p>

<ol>
<li>Pop last two values from the stack. Should be '( Number'
<ul>
<li>If it is not then an error</li>
</ul></li>
<li>Throw away the '('</li>
<li>If the top of the stack is an op push value <strong>goto 4 (above)</strong> </li>
<li>Otherwise push the value onto the stack <strong>goto 5 (above)</strong></li>
</ol>

<p>When finished there should be one number on the stack.</p>

<p>Example:</p>

<pre><code>1+3
Rule 1: push 1             stack = '1'
Rule 2: push +             stack = '1 +'
Rule 3: push 3             stack = '1 + 3'
Rule 4: pop and do:        stack = '4'
Rule 5: Nothing            stack = '4'
Rule 6: goto 7             stack = '4'
Rule 7:                    stack = '4'

(1 + (12 * 2)
Rule 1: push ( goto 1      stack = '('
Rule 1: push 1             stack = '( 1'
Rule 2: push +             stack = '( 1 +'
Rule 3: push ( goto 1      stack = '( 1 + ('
Rule 1: push 12            stack = '( 1 + ( 12'
Rule 2: push *             stack = '( 1 + ( 12 *'
Rule 3: push 2             stack = '( 1 + ( 12 * 2'
Rule 4: Pop and do:        stack = '( 1 + ( 24'
Rule 5: Do 'PopCode'       stack = '( 1 + ( 24'
Pop  1: Pop 2              stack = '( 1 +'
Pop  2: Holding 24         stack = '( 1 +'
Pop  3: push 24 goto 4     stack = '( 1 + 24'
Rule 4: Pop and do         stack = '( 25'
Rule 5: Nothing            stack = '( 25'
Rule 6: goto 7             stacj = '( 25'
Rule 7: More than 1 item error

Re-Doing with correct formula
(1 + (12 * 2))
Rule 1: push ( goto 1      stack = '('
Rule 1: push 1             stack = '( 1'
Rule 2: push +             stack = '( 1 +'
Rule 3: push ( goto 1      stack = '( 1 + ('
Rule 1: push 12            stack = '( 1 + ( 12'
Rule 2: push *             stack = '( 1 + ( 12 *'
Rule 3: push 2             stack = '( 1 + ( 12 * 2'
Rule 4: Pop and do:        stack = '( 1 + ( 24'
Rule 5: Do 'PopCode'       stack = '( 1 + ( 24'
Pop  1: Pop 2              stack = '( 1 +'
Pop  2: Holding 24         stack = '( 1 +'
Pop  3: push 24 goto 4     stack = '( 1 + 24'
Rule 4: Pop and do         stack = '( 25'
Rule 5: Do 'PopCode'       stack = '( 25'
Pop  1: Pop 2              stack = ''
Pop  2: holding 25         stack = ''
Pop  3: Nothing.           stack = ''
Pop  4: push 25 goto 5     stack = '25'
Rule 5: Nothing            stack = '25'
Rule 6: goto 7             stack = '25'
Rule 7: Result = 25
</code></pre>
",0
11173940,11172217,1,"<p>Begin with a simple grammar:</p>

<pre><code>expr: n-expr {o-expr} | p-expr {o-expr}
n-expr: [0-9]n-expr
p-expr: ( expr )
o-expr: op expr
op: + | - | * | /
</code></pre>

<p>This is probably the largest hurdle for the question. You want to be able to write a simple top down recursive descent parser, so your grammar needs to be written in a way to allow that to happen.</p>

<p>Then, the implementation from there is fairly straightforward:</p>

<pre><code>bool expr (const char *&amp;s, int &amp;result, int eos = 0) {
    while (isspace(*s)) ++s;
    if (*s == eos) return false;
    if (isdigit(*s)) {
        if (!n_expr(s, result)) return false;
    } else if (*s == '(') {
        if (!p_expr(s, result)) return false;
    } else return false;
    while (isspace(*s)) ++s;
    if (*s == eos) return true;
    return o_expr(s, result, eos);
}

bool n_expr (const char *&amp;s, int &amp;result) {
    int n = 0;
    while (isdigit(*s)) n = 10 * n + (*s++ - '0');
    result = n;
    return true;
}

bool p_expr (const char *&amp;s, int &amp;result) {
    if (expr(++s, result, ')')) {
        ++s;
        return true;
    }
    return false;
}

bool o_expr (const char *&amp;s, int &amp;result, int eos) {
    int oresult = 0;
    const char *op = strchr(""+-*/"", *s);
    if (op == 0) return false;
    if (!expr(++s, oresult, eos)) return false;
    switch (*op) {
    case '+': result += oresult; break;
    case '-': result -= oresult; break;
    case '*': result *= oresult; break;
    case '/': result /= oresult; break;
    default: return false;
    }
    return true;
}
</code></pre>
",6
8765588,8765574,1,"<p>You can do this if you want an actual copy of the string (vital if the stringstream object is going to go out of scope at some point):</p>

<pre><code>const char *p = new char[ss.str().size()+1];
strcpy(p, ss.str().c_str());

...

delete [] p;
</code></pre>

<p>As discussed in comments below, you should be wary of doing it like this (manual memory management is error-prone, and very non-idiomatic C++).  Why do you want a raw char array?</p>
",11
8765590,8765574,12,"<p>Why not just</p>

<pre><code>std::string s = stringstream.str();
const char* p = s.c_str();
</code></pre>

<p>?</p>

<p>Edit: Note that you cannot freely give the <code>p</code> outside your function: its lifetime is bound to the lifetime of <code>s</code>, so you may want to copy it.</p>

<p>Edit 2: as @David suggests, <em>copy</em> above means copying of the content, not the pointer itself. There are several ways for that. You can either do it manually (legacy way ""inherited"" from C) -- this is done with the functions like <a href=""http://en.cppreference.com/w/cpp/string/byte/strcpy""><code>std::strcpy</code></a>. This way is quite complicated, since it involves manual resources management, which is usually discouraged, since it leads to a more complicated and error-prone code. Or you can use the smart pointers or containers: it can be either <code>std::vector&lt;char&gt;</code> or <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr""><code>std::unique_ptr</code></a>/<a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr""><code>std::shared_ptr</code></a>.</p>

<p>I personally would go for the second way. See the discussion to this and @Oli's answer, it can be useful.</p>
",5
8765699,8765574,7,"<p>If you want to get the data into a <code>char</code> buffer, why not put it there immediately anyway? Here is a stream class which takes an array, determines its size, fills it with null characters (primarily to make sure the resulting string is null terminated), and then sets up an <code>std::ostream</code> to write to this buffer directly.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

struct membuf: public std::streambuf {
    template &lt;size_t Size&gt; membuf(char (&amp;array)[Size]) {
        this-&gt;setp(array, array + Size - 1);
        std::fill_n(array, Size, 0);
    }
};

struct omemstream: virtual membuf, std::ostream {
    template &lt;size_t Size&gt; omemstream(char (&amp;array)[Size]):
        membuf(array),
        std::ostream(this)
    {
    }
};

int main() {
    char   array[20];
    omemstream out(array);

    out &lt;&lt; ""hello, world"";
    std::cout &lt;&lt; ""the buffer contains '"" &lt;&lt; array &lt;&lt; ""'\n"";
}
</code></pre>

<p>Obviously, this stream buffer and stream would probably live in a suitable namespace and would be implemented in some header (there isn't much point in putting anything of it into a C++ file because all the function are templates needing to instantiated). You could also use the [deprecated] class <code>std::ostrstream</code> to do something similar but it is so easy to create a custom stream that it may not worth bothering.</p>
",3
17825183,17824982,0,"<p>The problem is that you're mixing calls to getline() with "">>"":</p>

<p><a href=""https://stackoverflow.com/questions/7786994/c-getline-isnt-waiting-for-input-from-console-when-called-multiple-times"">c++ getline() isn&#39;t waiting for input from console when called multiple times</a></p>

<p>SUGGESTIONS:</p>

<ul>
<li><p>Substitute "">>"" for cin.getline()</p></li>
<li><p>At the same time, substitute ""std::string"" for ""char name[15]"".</p></li>
<li><p>Also consider substituting a class for ""struct bc_Detail"".</p></li>
</ul>
",0
17825359,17824982,1,"<p>Try using :</p>

<pre><code>std::cin.get();// will eatup the newline
</code></pre>

<p>after </p>

<pre><code> std::cin &gt;&gt; client.usAge;
</code></pre>

<p><code>cin</code> stores the number entered in the variable <code>client.usAge</code>, and the trailing newline character(s) needed to submit the entry is left in the buffer.</p>

<p>You can also try :</p>

<pre><code>cin.ignore();
</code></pre>
",0
11054036,11053982,3,"<p>No, it is only UB if the referenced object has been declared as <code>const</code> originally <strong>and</strong> you subsequently modify the data obtained by the cast (¡ì5.2.11/7 and ¡ì7.1.6.1/4). The following is legal:</p>

<pre><code>A a;
a.get()-&gt;clear();
</code></pre>

<p>while this isn¡¯t (and is consequently UB):</p>

<pre><code>A const a;
a.get()-&gt;clear();
</code></pre>
",2
11054054,11053982,9,"<blockquote>
  <p>Is dereferencing const_cast of this UB? Is there any time dereferencing the result from const_casting the constness of a pointer away doesn't invoke UB?</p>
</blockquote>

<p>Not always, only if the object <strong>is</strong> const (the <code>A</code> instance is <code>const A x;</code>) <strong>and</strong> the dereference is used to <em>modify</em> the data. If it is only used to <em>read</em> it will not be undefined behavior, if the object is not const, (maybe not at all, maybe a const-reference to a non-const object) it won't be UB either.</p>
",0
11054068,11053982,1,"<p>No. To wit:</p>
<blockquote>
<p><strong>5.2.2 Function call</strong></p>
<p>5 [ Note: a function can change the values of its non-const parameters, but these changes cannot affect the
values of the arguments except where a parameter is of a reference type (8.3.2); if the reference is to a
const-qualified type, const_cast is required to be used to cast away the constness in order to modify
the argument¡¯s value. Where a parameter is of const reference type a temporary object is introduced if
needed (7.1.6, 2.14, 2.14.5, 8.3.4, 12.2). In addition, it is possible to modify the values of nonconstant objects
through pointer parameters. ¡ªend note ]</p>
</blockquote>
<p>However,</p>
<blockquote>
<p><strong>5.2.11 Const cast</strong></p>
<p>12 [ Note: some conversions which involve only changes in cv-qualification cannot be done using const_cast.
For instance, conversions between pointers to functions are not covered because such conversions lead to
values whose use causes undefined behavior. For the same reasons, conversions between pointers to member
functions, and in particular, the conversion from a pointer to a const member function to a pointer to a
non-const member function, are not covered. ¡ªend note ]</p>
</blockquote>
",0
11054242,11053982,0,"<p>A compiler is free to store a const value in read-only memory, it is free to make assumptions that it will never change when optimising the program.  If you cast away the constness, you are breaking the contract with the compiler so technically <em>anything</em> can happen.</p>

<p>Realistically, it is pretty rare for a compiler to do something that will be broken by const_cast-ing, but in theory it is possible.</p>
",2
8742807,8742727,1,"<p>Your <code>for</code> loop does not run far enough to get to the <code>Sentence[i] == '\0'</code> case. It will only run up to the ""d"" of ""hello world"", so the conent of the stream is not written anymore into the output array.</p>

<p>You could for example write:</p>

<pre><code>const int Size = strlen(Sentence)+1;
</code></pre>

<p>and you have included the final null byte.</p>
",2
8742861,8742727,1,"<pre><code>const int Size = strlen(Sentence);
</code></pre>

<p>This calculates the length of the string data, but <em>not</em> the final null terminator, so your loop will not find the terminator, and won't include the last word. You want to add one to this value to get the full length of the terminated string.</p>
",0
8742916,8742727,1,"<p>You just need to change your <code>for</code> loop:</p>

<pre><code>for(int i=0; i &lt;= Size; i++)
</code></pre>
",0
9177188,9177154,2,"<p>It's because a string literal is treated as pointer (pointer arithmetic): adding an integer to a pointer moves forward the pointer:</p>

<pre><code>""passs"" + 1 = ""asss""
""passs"" + 2 = ""sss""
""passs"" + 3 = ""ss""
</code></pre>

<p>to add a number as a string you should use:</p>

<pre><code>cout &lt;&lt; i &lt;&lt; ""passs"" &lt;&lt; ""\n"";
</code></pre>
",0
9177191,9177154,2,"<p>You are correct, both <code>pointer + integer</code> and <code>integer + pointer</code> operate pointer arithmetic and give a new pointer and thus the output is ""normal"".</p>
",0
9177200,9177154,4,"<p>You're right.</p>

<p>The string literal is interpreted as a pointer to the start of the string. Adding an int to this is a pointer increment.</p>

<p>Once you go past the end, you're into undefined behaviour - it seems fairly harmless on your system, but might end in a coredump on another.</p>
",0
9177274,9177154,2,"<p>Your initial reasoning is correct.  You're doing pointer arithmetic here, so the first six lines (the sixth being <code>\0\n</code>) of output are good.  But you get into trouble when you walk off the end of the string.  There's nothing in your for-loop to stop the iteration, so your program theoretically could do anything with <code>""passs""</code> + 6, 7, 8, and 9.  Let's look into why.</p>

<p>Recall that a string literal has type <code>const char *</code>.  At some spot in memory determined by the compiler, you have:</p>

<pre><code>| p | a | s | s | s | \0 | * | * | * | * |
</code></pre>

<p>The <code>*</code> symbols represent a no-man's land of indeterminate memory past the end of your string.  As your for-loop runs, it starts at <code>p</code> and walks forward.  Since we're addressing a <code>const char *</code>, each step will be one byte.  At each step, <code>cout</code> tries to print as much as it can until reaches a null character (as you see in the output).  But you're not allowed to try to print anything from no-man's land.  Doing so results in <strong>undefined behavior</strong>.  In your case, that memory contained unprintable characters.</p>

<p>So in summary, you were mostly correct.  <code>cout</code> did stop printing when it reached a null.  But the for-loop didn't.</p>
",3
9801013,9800953,1,"<p>You are missing the <code>typename</code> keyword exactly as in the question that you linked to:</p>

<pre><code>typedef typename std::list &lt; TYPE &gt;::iterator  CIndexIt;
typedef typename std::list &lt; TYPE &gt;::difference_type  CIndexDiff;
</code></pre>
",0
9801032,9800953,2,"<p>You need to add the <code>typename</code> keyword because <code>std::list&lt;TYPE&gt;::iterator</code> and <code>std::list&lt;TYPE&gt;::difference_type</code> are dependent names:</p>

<pre><code>typedef typename std::list &lt; TYPE &gt;::iterator  CIndexIt;
typedef typename std::list &lt; TYPE &gt;::difference_type  CIndexDiff;
</code></pre>

<p>See <a href=""http://pages.cs.wisc.edu/~driscoll/typename.html"" rel=""nofollow"">http://pages.cs.wisc.edu/~driscoll/typename.html</a> for more information.</p>
",1
15505617,15505486,1,"<p>Looks like you want to make a pointer to a character.  This will behave just like an array without actually being an array, and requires nothing but <code>#include &lt;iostream&gt;</code> for the input and output.</p>

<pre><code>char* name;
</code></pre>

<p>You could also try using a vector of characters, but this is the long way around and would break the ""nothing but <code>&lt;iostream&gt;</code> rule:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

vector&lt;char&gt; CharVec;
vector&lt;char&gt;::iterator it;

int main ()
{
    char input;
    int i=0;
    while(i != 5){
        if(input != '&lt;'){ //this should be if, not while
            CharVec.push_back(input);
        }
        i++;
    }
    //move print to outside the character entering loop
    it = CharVec.begin();
    while(it != CharVec.end())
    {
        cout &lt;&lt; *it;
        it++;
    }
</code></pre>

<p>}</p>
",3
15505681,15505486,2,"<p>The solution is to reset the name variable right before this line:</p>

<pre><code>while (!(name != '&lt;' || name != '&gt;')) {
</code></pre>

<p>What you need to do would be this:</p>

<pre><code>name = 0;
</code></pre>

<p>Also, I'd recommend initializing the variable before entering the first while loop.</p>

<p>Edit:
Alternatively, you can use <code>'\0'</code> instead of  <code>0</code>. It makes no difference internally though. The code would only make more sense to most inexperienced users.</p>
",0
15505694,15505486,2,"<p>After the inner <code>while</code> terminates <code>name</code> holds either <code>&lt;</code> or <code>&gt;</code> and is not reset prior to the next encounter of the inner <code>while</code>, which terminates immediately as <code>name</code> is still either <code>&lt;</code> or <code>&gt;</code>. Just reset <code>name</code> prior to the inner <code>while</code> or slight restructure:</p>

<pre><code>while (cin &gt;&gt; name &amp;&amp; !(name != '&lt;' || name != '&gt;'))
{
}
</code></pre>
",1
9187657,9187616,28,"<p>In Visual Studio the <code>///</code> indicates <a href=""http://msdn.microsoft.com/en-us/library/cc998489.aspx"">documentation</a> not just comments.  Following your link the explanation is the same.  It is used to adorn comments that will be specifically formatted via your editor or some other tool as documentation for a class, method, namespace, etc.</p>
",10
9187669,9187616,5,"<ol>
<li>Surely, its easier to hit the same key thrice than hitting two separate keys.</li>
<li>Don't know about other IDEs, but XCode4 supports code snippets where you can type pretty much anything. On Visual Studio, I use Visual Assist X, which gives me the same thing. <a href=""http://cbpowell.wordpress.com/2011/06/15/easy-doxygen-code-snippets-for-xcode-4/"" rel=""noreferrer"">XCode4 Example</a>,<a href=""http://www.wholetomato.com/products/features/vasnippets.asp"" rel=""noreferrer"">Visual AssistX example</a>. I'd have to assume other IDEs provide similar functionality. </li>
</ol>

<p>That said, yes I have come across triple slashes too and they are generally used to indicate comments that an auto-documentation system like doxygen would pick. </p>
",1
9187703,9187616,10,"<p>The author might intend to put documentation after ///</p>

<p>At where I work, we use 3 styles of doxygen comment blocks for documentation because lack of coding style guidelines.</p>

<ol>
<li>///</li>
<li>//!</li>
<li>/**   */</li>
</ol>
",0
13466355,11152869,3,"<p>example:</p>

<pre><code>char phrase[30]=""whatever\n"";
</code></pre>

<p><code>phrase</code> is a pointer already. For compiler to access string, it accesses memory location of start of string so:</p>

<p><code>phrase[0]=*phrase</code> and this is w character in memory, address is given by pointer phrase (ok we are calling it a string array, but it really is a pointer, only a string array when specified as 
<code>phrase[30]</code>.
so if phrase is memory address of start of array - character <code>w</code> then
<code>(phrase+1)</code> is memory address for character h, given by <code>*(phrase+1)</code> same as <code>phrase[1]</code>
and <code>(phrase+2)</code> is memory address for character a, given by <code>*(phrase+2)</code> same as <code>phrase[2]</code>
etc....</p>
",0
11152946,11152869,1,"<p>Use the <a href=""http://www.cplusplus.com/reference/iostream/ofstream/"" rel=""nofollow"">ofstream</a> class for this. Open the file with the <a href=""http://www.cplusplus.com/reference/iostream/ofstream/open/"" rel=""nofollow"">open()</a> method, then iterate through the array and use the <code>&lt;&lt;</code> operator to write each short to the file.</p>

<p>You can get the size of the array (<code>short[] array</code>) by doing</p>

<pre><code>int arraySize = sizeof(array) / sizeof(short);
</code></pre>

<p>while for the pointer (<code>short* array</code>) you need to keep track yourself of the size of the array it points to.</p>
",1
11515741,3768048,0,"<p>It has nothing to do with the parsing. Your code is slow because of <code>Application::DoEvents();</code>.</p>
",0
15493496,15493471,6,"<p>This is known as <strong><a href=""http://www.gotw.ca/gotw/036.htm"" rel=""nofollow"">Copy initialization</a></strong>.     </p>

<p>Copy Initialization is defined as:      </p>

<pre><code>T t2 = t1;
</code></pre>

<p>Depending on <em>type</em> of <code>t1</code> two scenarios are possible:   </p>

<blockquote>
  <p><strong>If <code>t1</code> is NOT of the <em>type</em> <code>T</code>:</strong>     </p>
</blockquote>

<ul>
<li>It tries to convert <code>t1</code> to <em>type</em> <code>T</code> by using a implicit conversion sequence and </li>
<li>then copies the created object in to <code>t2</code> by calling the copy constructor.</li>
</ul>

<blockquote>
  <p><strong>If <code>t1</code> is of the <em>type</em> <code>T</code>:</strong></p>
</blockquote>

<ul>
<li>It copies <code>t1</code> in to <code>t2</code> by calling the copy constructor.</li>
</ul>

<p>Note though that the copy constructor call might be <strong>elided</strong> through <strong><a href=""http://en.wikipedia.org/wiki/Copy_elision"" rel=""nofollow"">copy elision</a></strong>. </p>

<hr>

<p>There is no assignment involved here. Assignment only occurs when you assign an already constructed object to another. Your code statement involves construction as well as value assigning in one single statement so there is no Assignment per se.</p>
",6
15493901,15493471,2,"<p>In this case,copy constructor is getting called. Because ""Class A"" class object ""a"" is constructed copying the values of already constructed ""Class A"" object b.</p>

<p>There is no chance of assignment operator being called which acts on two already created objects.</p>
",0
11817722,11817692,3,"<p>In this call:</p>

<pre><code>return merge(left_merged, merge_sort(right));
</code></pre>

<p>the second argument is a temporary, and you cannot bing a non-const reference to a temporary. You need</p>

<pre><code>vector&lt;int&gt; merge(vector&lt;int&gt;&amp; left, const vector&lt;int&gt;&amp; right);
</code></pre>

<p>and probably (although it wouldn't affect this particular example),</p>

<pre><code>vector&lt;int&gt; merge(const vector&lt;int&gt;&amp; left, const vector&lt;int&gt;&amp; right);
</code></pre>

<p>If you find yourself making copies of the arguments inside the functions, you could take them by value. For example, in case you were copying the second argument, then prefer this:</p>

<pre><code>vector&lt;int&gt; merge(const vector&lt;int&gt;&amp; left, vector&lt;int&gt; right);.
</code></pre>
",0
11817724,11817692,3,"<p>Change the parameter type, either to <code>const vector&lt;int&gt;&amp;</code> (const reference), or simply <code>vector&lt;int&gt;</code> (by value).</p>

<p>Prefer the first option (const reference) if inside the function you don't make any changes to the parameter.  Otherwise the second (by value).  If, inside the function, you are immediately copying the argument, and then manipulating the copy while ignoring the original, take the argument by value, skip the copy, and just use the argument directly.</p>
",0
11829420,11828943,8,"<p>Consider interposing a class between <code>Derived</code> and <code>Base</code>:</p>

<pre><code>class Derived: public UnpackToBase {
public:
    Derived(int a, int b, int c): UnpackToBase(FixParameters(a, b, c))

class UnpackToBase: public Base {
public:
    UnpackToBase(FixParameters params): Base(params.a, params.b, params.c)

struct FixParameters {
    int a, b, c;
    FixParameters(int a, int b, int c): a(a), b(b), c(c) {
         // do stuff
    }
</code></pre>

<p>In C++11 you can use a <em>delegating constructor</em> of <code>Derived</code>:</p>

<pre><code>class Derived: public Base {
public:
    Derived(int a, int b, int c): Derived(FixParameters(a, b, c)) { }
    Derived(FixParameters params): Base(params.a, params.b, params.c) { }
</code></pre>
",0
11829497,11828943,1,"<p>You can use the singleton pattern to resolve this. Please see the code below. Here the order of initialization of the construction initialization list doesn't matter. However, I'm doubtful, if this can be called elegant.</p>

<pre><code>class Base 
{ 
    // This class cannot be modified 
public:   Base(int a, int b, int c) 
          {      
              if ( a == 100 &amp;&amp; b == 200 &amp;&amp; c &lt; 100  ) // whatever condition
                  throw ""Error!"";   
          } 
};  

class Validator
{
public:

    static Validator&amp; instance(int a_in, int b_in, int c_in)
    {
        static Validator v(a_in,b_in,c_in);

        return v;
    }



    int&amp; a(){ return m_a;}
    int&amp; b(){ return m_b;}
    int&amp; c(){ return m_c;}

private:

    Validator(int a_in, int b_in, int c_in) : m_a(a_in), m_b(b_in), m_c(c_in)
    {
        //  perform validation and modify the members
        //  Example validation
        if(m_a &gt; 0 &amp;&amp; m_b &gt; 0)
        {
            m_c = 0;
        }
    }

    int m_a;
    int m_b;
    int m_c;
};

class Derived : public Base 
{ 
    // this class can be modified 
public:    
    Derived(int a, int b, int c) : Base(Validator::instance(a, b, c).a(), Validator::instance(a, b, c).b(), Validator::instance(a, b, c).c())
    {} 
};

int _tmain(int argc, _TCHAR* argv[])
{
    Derived d(1,2,3);

    return 0;
}
</code></pre>
",0
11829091,11828943,0,"<p>Looks like you don't have a problem with <em>hacking</em> what you have to make something weird happen, so why not use <em>good 'ol <strong>macros</strong></em>..</p>

<pre><code>#define FIX_ME(x) //do something
Derived(int a, int b, int c) : Base(FIX_ME(a), FIX_ME(b), FIX_ME(c)) {}
</code></pre>
",4
11139412,11139370,4,"<p>Yes, you can provide <strong>cast operators</strong> for <code>A</code>.</p>

<pre><code>class A
{ 
public:
  int f();
  float g();

  operator int() { return f(); }
  operator float() { return g(); }
};
</code></pre>

<p>But you then call <code>r</code> and <code>t</code> on an instance:</p>

<pre><code>A a;
r(a);
t(a);
</code></pre>

<p>Here's the full code: <a href=""http://ideone.com/Pfa4v"" rel=""nofollow"">http://ideone.com/Pfa4v</a></p>
",0
18222674,18222151,0,"<p>If you got it from a tarball, you should already have a <code>configure</code> script ready to be executed. If you checked from the repository, you probably need to run <code>./autogen.sh</code> to generate the <code>configure</code> script for you, using <code>configure.ac</code> as input.</p>

<p>The convention is:</p>

<ul>
<li><p><strong>./bootstrap</strong>: it invokes <strong>autoconf</strong> to process <code>configure.ac</code> and spit out <code>configure</code>. Often it also invokes <strong>automake</strong> to process all <code>Makefile.am</code> files and turn them into <code>Makefile.in</code>. Many moons ago, the name <code>autogen.sh</code> was used instead of <code>bootstrap</code>. And <code>configure.in</code> was used instead of <code>configure.ac</code>.</p></li>
<li><p><strong>./configure</strong>: detects everything on the system and creates <code>config.status</code>, then executes it.</p></li>
<li><p><strong>./config.status</strong>: processes all <code>*.in</code> files into versions without the <code>.in</code> suffix. That includes <code>Makefile.in</code> -> <code>Makefile</code>. You don't have to run this script by hand.</p></li>
<li><p><strong>INSTALL</strong>: this <strong>SHOULD</strong> contain build instructions, such as ""run <code>./autogen.sh</code> if you checked out a copy from the repository"". Shame on the ASIO developers, they just point the user to look for a non-existing ""doc"" directory.</p></li>
</ul>

<p>You need <strong>autoconf</strong> (and friends) installed to transform <code>configure.ac</code> into <code>configure</code>. Once that is done, the build system becomes self-contained. That is, you can do a <code>make dist-gzip</code> to pack all the sources (and the <code>configure</code> script), transfer the <em>tar.gz</em> it to another system, and follow from the <code>./configure</code> step, even if <strong>autoconf</strong> is not installed there.</p>
",0
12856887,12856845,0,"<pre><code>const char* oranges[] = {
    ""ORANGE"",
    ""RED ORANGE"",
    ""\0""
};
</code></pre>

<p>Your arrays are located in memory one after another so it continues printing others because the <code>while</code> condition is <code>false</code></p>
",0
12856903,12856845,5,"<p>You are checking that <code>fruit[i] != '\0'</code>. That is wrong because <code>fruit[i]</code> is a <code>char *</code>, not a char. Furthermore, your vectors aren't terminated. You probably wanted to check whether <code>fruit[i] != 0</code>, or <code>*fruit[i] != '\0'</code>. In the first case, you need to terminate the vectors like this:</p>

<pre><code>const char* oranges[] = {
    ""ORANGE"",
    ""RED ORANGE"",
    0  // or NULL
};
</code></pre>

<p>In the second:</p>

<pre><code>const char* oranges[] = {
    ""ORANGE"",
    ""RED ORANGE"",
    """"
};
</code></pre>
",2
12857153,12856845,2,"<p>IMHO, you'd  be better off knowing exactly how many elements that you're dealing with. The bad news is that a simple array of character pointers won't tell you (it's not a <code>std::vector</code>) so you won't be able to discover it in your <code>printFruit</code> function.</p>

<p>The good news, however, is that it is available at compile time so you don't have to worry about the overhead of finding it out. The following shows what I mean:</p>

<pre><code>void printFruit(const char** fruit, int fruitSize){
    int i =0;
    while (i &lt; fruitSize){
        std::cout &lt;&lt; ""---------------------\n"";
        std::cout &lt;&lt; fruit[i] &lt;&lt; ""\n"";
        i++;
    }
}

int main (int argc, const char * argv[])
{
   // The second parameter can be worked out by the compiler.
   printFruit(oranges, sizeof(oranges)/sizeof(const char*) ); 
   return 0;
}
</code></pre>

<p>Since you're using C++ though, I'd strongly recommend that you use one of the standard collection types such as <code>vector</code> as they're much safer when it comes to bounds checking, memory allocation etc.</p>
",2
12856922,12856845,7,"<p>You are having UB here. Your condition</p>

<pre><code>while (fruit[i] != '\0')
</code></pre>

<p>will never be met because there are no elements that are equal to <code>\0</code>. </p>

<p>All the arrays are placed exactly one after another in the memory. Your <code>i</code> keeps increasing forever. On <code>i = 1</code> you are on the first string in <code>oranges</code>. On <code>i = 2</code> you are on the second element.</p>

<p>After that, <code>i</code> becomes 3. Since right after <code>oranges</code>, in your mamory lies the <code>apples</code> array, your pointer starts pointing to it and the app prints <code>APPLE</code>. On <code>i = 4</code> the pointer is on the <code>lemons</code> array and the app prints <code>LEMONS</code>. After that you effectively go out of your own memory which for me results in a crash.</p>

<p>To fix that you need to explicitly add an empty element into each of the arrays, e.g.</p>

<pre><code>const char* oranges[] = {
    ""ORANGE"",
    ""RED ORANGE"",
    0
};
</code></pre>
",1
12856954,12856845,1,"<pre><code>const char* oranges[] = {
    ""ORANGE"",
    ""RED ORANGE""
};

const char* apples[] = {
    ""APPLE""
};

const char* lemons[] = {
    ""LEMON""
};
</code></pre>

<p>in memory will looks somthing like</p>

<p>""ORANGE""""RED ORANGE""""APPLE""""LEMON"" </p>

<pre><code>while (fruit[i] != '\0'){
    std::cout &lt;&lt; ""---------------------\n"";
    std::cout &lt;&lt; fruit[i] &lt;&lt; ""\n"";
    i++;
}
</code></pre>

<p>will end when you reach the end of ""big array"" which is ""LEMON""</p>

<p>to make your code working you need memory to looks like 
""ORANGE""""RED ORANGE""0""APPLE""0""LEMON""0 so </p>

<pre><code>   const char* oranges[] = {
        ""ORANGE"",
        ""RED ORANGE"",
    0
    };

    const char* apples[] = {
        ""APPLE"",
    0
    };

    const char* lemons[] = {
        ""LEMON""
     ,0
    };
</code></pre>
",0
8809490,8809435,4,"<p>The subscript-operator (<code>[]</code>) has a higher precedence than the derefence-operator (<code>*</code>), so <code>*param[i]</code> is actually <code>*(param[i])</code>. This means, you first go to the i-th element of <code>param</code>, and then dereference it - that is not what you want (<code>param</code> is not a pointer into an array). You want to dereference <code>param</code> and <em>then</em> go to the i-th element - this would be <code>(*param)[i]</code>.</p>
",5
8809521,8809435,1,"<p><code>vector</code> is type <code>int[10]</code>.  Therefore, <code>vector* is type int(*)[10]</code>.  That is, a pointer to an array of 10 ints.  So the distance between <code>param[i]</code> and <code>param[i+1]</code> is <code>sizeof(int) * 10</code></p>

<p>When you do this:</p>

<pre><code>if (*param[i] &gt; *param[i+1])
</code></pre>

<p>You are comparing one array of 10 ints to the next array of 10 ints.  I wish this would simply not compile, unfortunately, what happens is that the arrays are implicitly converted to pointers to their first element.  Since i &lt; i+1, the above comparison will never be true.</p>
",2
8809582,8809435,2,"<p>First of all: Why would you write the sorting yourself (not to mention that bubblesort is not exactly fast).
So why not simply use</p>

<pre><code>std::sort(tavi, tavi + 10, std::less&lt;int&gt;());
</code></pre>

<p>Of course if you have C++11 or boost its also a good idea to forget about c style arrays and use <code>std::array</code> or <code>boost::array</code> instead:</p>

<pre><code>std::array&lt;int, 10&gt; tavi = {10,88,77,192,7,27,82,1,882,13};

std::sort(tavi.begin(), tavi.end(), std::less&lt;int&gt;());
for (int i = 0 ; i &lt; tavi.size(); i ++)
    std::cout&lt;&lt;tavi[i]&lt;&lt;"" "";
</code></pre>

<p>If however you really want to do it like that, <code>*param[i]</code> is the same as <code>*(param[i])</code>, while you want to use <code>(*param)[i]</code>.</p>
",3
9151904,9151844,2,"<p>You can indeed use the PIMPL idiom; just write a forward declaration of the type and use a (smart) pointer to it as a member. That should take care of header files.</p>

<p>For the implementation, just have a separate header file that is included by the implementation of the library but not by any part of the interface. Example:</p>

<pre><code>// Interface.h

class Secret;

class Hi {
public:
    Hi();
    ~Hi();

    void stuff();

private:
    Secret* secret;
};
</code></pre>

<hr />

<pre><code>// Implementation.cpp

#include ""Secret.h""
#include ""Interface.h""

Hi::Hi() : secret(new Secret) { }
Hi::~Hi() { delete secret; }

void Hi::stuff() { secret-&gt;stuff(); }
</code></pre>

<hr />

<pre><code>// Secret.h

class Secret {
public:
    int data;
    void stuff() { ... }
};
</code></pre>
",0
9151931,9151844,0,"<p>This is probably not the best solution, especially if you need to use the class in multiple classes without a common ancestor, but you could use a private or protected nested class:</p>

<pre><code>class Foo {
protected:
    class SecretClass {
        // ...
    };
    // ...
};
</code></pre>
",0
9152251,9151844,1,"<p>You don't have to hide it specifically, just don't include the internal header in the .h files that define your API. </p>

<p>It is perfectly normal for a project to have internal helper classes and functions that are not part of the external interface. Compile them into your library, but don't distribute the headers.</p>
",0
11145500,11145253,6,"<p>Free Fuzzy Logic Library (FFLL) ...</p>

<p><a href=""http://ffll.sourceforge.net/"" rel=""noreferrer"">http://ffll.sourceforge.net/</a></p>
",0
9778523,8237827,1,"<p>I recommend to create a predicate as function object:</p>

<pre><code>struct compare
{
    bool operator()(const BookData&amp; x, const BookData&amp; y) const
    {
        return x &lt; y;
    }
};
</code></pre>

<p>Note the <code>const</code> at the end of <code>operator()</code>. You can pass this object to STL algorithms as follows:</p>

<pre><code>sort (books.begin(), books.end(), compare());
</code></pre>

<p>If you do not want to create the function object each time, you may include it as (static) member in <code>BookData</code>.</p>
",0
16915575,16915384,1,"<p>It's not asking you to supply an allocator; that's just the second template parameter in <code>std::vector</code>, which has a default value so you usually don't need to provide it. Note that there's no closing <code>&gt;</code> before it; it's still part of the <code>vector</code> type.</p>

<p>The problem appears to be that the function requires a mutable <code>string</code> for the second argument (a non-const reference), but you're trying to pass a <code>const</code> or temporary string - although since you forgot to show us how the function is called, I can't be completely sure of that.</p>

<p>You probably want the second and third parameters to be <code>const</code> references; unless the function is intended to modify the arguments, in which case you'll have to pass named, mutable variables to be modified.</p>
",1
10827964,10827453,2,"<blockquote>
  <p><strong>Do I need to dynamically allocate double arrays to pass them?</strong>     </p>
</blockquote>

<p>No you don't!<br>
Your misconception/doubt stems from the (Incorrect)fact that, Arrays are pointers</p>

<p><strong><em>No! Arrays are not pointers!!</em></strong><br>
An array name decays sometime to an pointer to its first element in scenarios where array name is not valid.      </p>

<p>A two dimensional array does not decay to an double pointer. It decays to an pointer to array.</p>

<p>Your declaration needs to be:     </p>

<pre><code>MixtureModel::MixtureModel(int, int, double [2], double [2][1], double [2][1], Distribution*);
</code></pre>

<p>or</p>

<pre><code>MixtureModel::MixtureModel(int, int, double *, double(*)[1], double (*)[1], Distribution*);
</code></pre>

<hr>

<p><strong>Good Read:</strong><br>
<a href=""https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c"">How do I use arrays in C++?</a></p>
",0
12818859,12818833,2,"<pre><code>list&lt;string&gt; str;
</code></pre>

<p>declares a variable.</p>

<pre><code>list&lt;string&gt; str();
</code></pre>

<p>declares a function that takes no parameters and returns a <code>list&lt;string&gt;</code>.</p>

<p>This is commonly known as a vexing parse.</p>
",1
12818868,12818833,2,"<p><code>list&lt;string&gt; str();</code> is treated as a function prototype declaration. See <a href=""http://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""nofollow"">""Most Vexing Parse""</a>.</p>
",0
10181874,5138935,0,"<p>I think what your all missing is the fact that ( A || B ) follows short circuiting rules.</p>

<p>If A is true then there is NO NEED to evaluate B.  Since B does not need to be evaluated DebugBreak() never gets called.</p>

<p>If A is false, then we HAVE to evaluate B to determine the output of ( A || B ).  There is no short circuit.  (DebugBreak(), 0) of more Appropriately (DebugBreak(), false)</p>

<p><a href=""http://www.student.cs.uwaterloo.ca/~cs132/Weekly/W02/SCBooleans.html"" rel=""nofollow"">http://www.student.cs.uwaterloo.ca/~cs132/Weekly/W02/SCBooleans.html</a></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/zs06xbxh(VS.80).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/zs06xbxh(VS.80).aspx</a></p>
",0
14222357,14222310,9,"<blockquote>
  <p>the problem comes in when an overriden function is called by the parent constructor,</p>
</blockquote>

<p>No, that never happens. Within the constructor of <code>BaseClass</code> its dynamic type is <code>BaseClass</code> as well, so the <code>printNumber()</code> call will resolve to its own <em>number</em> instead of some derived class. Why? Because at that time the constructors for <code>ChildClass</code> has not yet finished running and so it wasn't yet created.</p>

<p>As <em>@FredLarson</em> comments, here is more info on the subject: <a href=""http://parashift.com/c++-faq/calling-virtuals-from-ctors.html"" rel=""nofollow"">http://parashift.com/c++-faq/calling-virtuals-from-ctors.html</a></p>
",3
14222431,14222310,2,"<p>Like others said above, you shouldn't call a virtual member from a constructor. But to address your problem there is an idiom that might help you, it is called base-from-member:</p>

<p><a href=""http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Base-from-Member"" rel=""nofollow"">http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Base-from-Member</a></p>

<p>What it does basically, is take advantage of the fact that base classes are initialized in the order they are declared. You may be able to do what you need to do in a separate base class before your base class is initialized.</p>

<pre><code>class OtherBaseClass {
    int Num;
    OtherBaseclass(float num) : Num(num)
    {
        printf(""My number is %d\n"", this-&gt;Num);
    }
};


class ChildClass : OtherBaseClass, BaseClass {

public:
    float childNumber;

    ChildClass(float myNumber) : OtherBaseClass(myNumber), BaseClass() {
....
</code></pre>
",2
14222452,14222310,2,"<p>Note that the constructor of the base class cannot call to the virtual function version of the derived class, that is, your <code>ChildClass::printNumber()</code> function <strong>will not</strong> be called.</p>

<p>That said, if you want to execute something before the constructor of the base class, one way to do it is using yet another base class, and put it before the other one:</p>

<pre><code>class RunMeFirst
{
    public RunMeFirst()
    { printf(""whatever...\n""); }
};

class ChildClass : private RunMeFirst, public BaseClass 
{ /*...*/ };
</code></pre>
",0
14222527,14222310,0,"<p>There are several things that run before a base class' constructor:</p>

<ul>
<li>Initialization of arguments</li>
<li>Virtual base classes' constructors</li>
<li>Other base classes declared earlier's constructors</li>
</ul>

<p>One commonly used solution is called the ""base from member idiom"" and involves moving the member to a new base class that is constructed first.</p>
",0
14222638,14222310,1,"<p>Do you have to implement the rendering functionality in a base class?  Could you instead employ composition instead of inheritance.  Using composition would allow you to easily control the member initialization order, e.g.:</p>

<pre><code>#include &lt;iostream&gt;

class renderer
{
public:

    renderer(int number)
    {
        std::cout &lt;&lt; ""Number is "" &lt;&lt; number &lt;&lt; std::endl;
    }
};

class foo
{
public:

    foo()
        : number_(12)
        , renderer_(number_)
    {
    }

private:

    int number_;
    renderer renderer_;

};

int main()
{
    foo bar;
}
</code></pre>

<p>In general, <a href=""http://www.artima.com/cppsource/codestandards3.html"" rel=""nofollow"">prefer composition to inheritance</a>.  Also, the <a href=""http://en.wikipedia.org/wiki/Liskov_substitution_principle"" rel=""nofollow"">Liskov Substitution Principle</a> may be of use here, too, from a design point of view.</p>
",0
14222948,14222310,0,"<p>Thanks to @K-ballo for pointing out the error and because of that I was able to restructure the code a bit to do what I wanted, but as this isnt a technical correct answer to the question either, Ill leave the correct answer as is. </p>

<pre><code>class BaseClass {

public:
    int myNumber;

    BaseClass(bool initialize = true){
        myNumber = 0;
        if (initialize){
            this->initialize();
        }
    }

    void initialize(){
        this->printNumber();
    }

    virtual void printNumber(){
        printf(""My number is %d\n"", this->myNumber);
    }
}

class ChildClass : BaseClass {

public:
    float childNumber;

    ChildClass(float myNumber) : BaseClass(false) {
        this->childNumber = myNumber;
        this->initialize();
    }

    void printNumber(){
        printf(""My number is %f\n"", this->childNumber);
    }

}
</code></pre>
",0
10763264,10762894,0,"<p>Expanding on @tp1's excellent idea of an ID field in the Field class and an enum, you can actually make it very flexible. If you are comfortable limiting the number of field types to 32, you could even take a set of flags as the ID in <code>CompareTo</code>. Then you could compare multiple fields at the same time. Does that approach make sense?</p>
",0
11509419,11509167,1,"<p>In my opinion, this is one of those ""what can I do that should make another programmer feel dirty when they do it wrong"" sort of situations: it's not well handled by the language, so you don't want to be overly restrictive in your code, because that tends to make things confusing. Friend-container-delegate setups will, in my opinion, just confuse people trying to figure out your code in everyday ""how does this work"" situations. You want to make it harder to abuse your code in ""I need to hack on this"" situations.</p>

<p>What I would do is perhaps something as simple as document well and call the (public) functions <code>_setPosition</code> and <code>_setSize</code>. The underscore will (hopefully) make other programmers go, ""wha???"" and read your documentation - which will explain exactly why it's a very bad idea for non-<code>Container</code>s to call those functions.</p>

<p>It's slightly ugly, but that's the <em>point</em>. I would certainly feel dirty calling <code>rect._setPosition</code> without understanding what's going on. It's a psychological solution, but used a lot in other languages where the access protection facilities are lacking - like Javascript - so is not so unusual as to be hideously ugly. Or at least, not more hideously ugly than trying to specify your requirements in the features of the language :)</p>
",1
11509321,11509167,1,"<p>I'm afraid of writing this answer because it seems too obvious, but couldn't you just make <code>setPosition(x,y)</code> and <code>setSize(w,h)</code> members of <code>Container</code>?</p>

<p>or if there's some sort of unknown complexity could you make a <code>WidgetContainer</code> as a base class and put those methods in that class?</p>
",1
11509850,11509167,2,"<p>In case the suggestion was not clear from the comment, you can consider creating an interface with that subset of the methods and use private inheritance in <code>Widget</code>. Then use a protected (a single operation) in <code>Container</code> that would obtain that private interface for classes derived from it:</p>

<pre><code>struct Drawable {    // choose a better name
  virtual void setPosition( int x, int y );
  virtual void setSize( int w, int h );
  virtual ~Drawable() {}
};
class Widget : private Drawable {
   friend class Container;
};
class Container {
protected:
    Drawable&amp; getDrawable( Widget&amp; w ) { return w; };
};
class MyContainer : public Container {
   void changeSize( Widget &amp; w ) {
      getDrawable(w).setSize(10,20);
   }
};
</code></pre>

<p>The main difference with the forwarding options is that this scales better with the number of functions and is more maintainable (no need to update N-forwarders, just the accessor to the proper interface).</p>

<p>From a high level design point of view, a <code>Widget</code> is not <code>Drawable</code> in general, it is only <code>Drawable</code> from the context of <code>Widget</code> or <code>Container</code>.</p>
",0
13738705,4112519,2,"<pre><code>/******************************************************************
Name  :  Paul Rodgers
Source : HW1.CPP
Compiler :  Visual C++ .NET
Action : Program will read in from standard input and determine the
         frequency of word lengths found in input.  An appropriate
         table is also displayed.  Maximum word length is 15 characters
         words greater then 15 are counted as length 15. 
         Average word length also displayed.

Note   : Words include hyphenated and ones with apostrophes.  Words with
         apostrophes, i.e. Jim's, will count the apostrophe as part of the
         word length. Hyphen is counted if word on same line, else not.

         Also an int array is used to hold the number of words with
         length associated with matching subscript, with subscript 0
         not being used.  So subscript 1 corresponds to word length of 1,
         subscript 2 to word length of 2 and so on.
------------------------------------------------------------------------*/
#include &lt;iostream&gt;
#include &lt;ctype.h&gt;
#include &lt;iomanip&gt;
using namespace std;

int NextWordLength(void);                    // function prototypes
void DisplayFrequencyTable(const int Words[]);

const int WORD_LENGTH = 16;                // global constant for array

void main()
{
  int WordLength;                         // actual length of word 0 to X
  int NumOfWords[WORD_LENGTH] = {0};     // array holds # of lengths of words

  WordLength = NextWordLength();
  while (WordLength)                   // continue to loop until no word, i.e. 0
    {                                 // increment length counter
      (WordLength &lt;= 14) ? (++NumOfWords[WordLength]) : (++NumOfWords[15]);
      WordLength = NextWordLength();
    }

  DisplayFrequencyTable(NumOfWords);
}

/**********************  NextWordLength  ********************************
Action  : Will determine the length of the next word. Hyphenated words and
          words with apostrophes are counted as one word accordingly
Parameters : none
Returns   : the length of word, 0 if none, i.e. end of file
-----------------------------------------------------------------------*/
int NextWordLength(void)
{
  char Ch;
  int EndOfWord = 0,       //tells when we have read in one word
      LengthOfWord = 0;

  Ch = cin.get();                           // get first character
  while (!cin.eof() &amp;&amp; !EndOfWord)
   {
     while (isspace(Ch) || ispunct(Ch))      // Skips leading white spaces
        Ch = cin.get();                      // and leading punctation marks

     if (isalnum(Ch))          // if character is a letter or number
        ++LengthOfWord;        // then increment word length

     Ch = cin.get();           // get next character

     if ((Ch == '-') &amp;&amp; (cin.peek() == '\n')) //check for hyphenated word over two lines
       {
         Ch = cin.get();       // don't count hyphen and remove the newline char
         Ch = cin.get();       // get next character then on next line
       }

     if ((Ch == '-') &amp;&amp; (isalpha(cin.peek()))) //check for hyphenated word in one line
     {
         ++LengthOfWord;       // count the hyphen as part of word
         Ch = cin.get();       // get next character
     }

     if ((Ch == '\'') &amp;&amp; (isalpha(cin.peek()))) // check for apostrophe in word
      {
        ++LengthOfWord;        // count apostrophe in word length
        Ch = cin.get();        // and get next letter
      }

     if (isspace(Ch) || ispunct(Ch) || cin.eof())  // is it end of word
       EndOfWord++;
   }

  return LengthOfWord;
}

/***********************  DisplayFrequencyTable  **************************
Action      :  Will display the frequency of length of words along with the
               average word length
Parameters
  IN        : Pointer to array holding the frequency of the lengths
Returns     : Nothing
Precondition: for loop does not go beyond WORD_LENGTH
------------------------------------------------------------------------*/
void DisplayFrequencyTable(const int Words[])
{
  int TotalWords = 0, TotalLength = 0;

  cout &lt;&lt; ""\nWord Length      Frequency\n"";
  cout &lt;&lt; ""------------     ----------\n"";

  for (int i = 1; i &lt;= WORD_LENGTH-1; i++)
    {
     cout &lt;&lt; setw(4) &lt;&lt; i &lt;&lt; setw(18) &lt;&lt; Words[i] &lt;&lt; endl;
     TotalLength += (i*Words[i]);
     TotalWords += Words[i];
    }

  cout &lt;&lt; ""\nAverage word length is "";

  if (TotalLength)
     cout &lt;&lt; float(TotalLength)/TotalWords &lt;&lt; endl;
  else
    cout &lt;&lt; 0 &lt;&lt; endl;
}
</code></pre>
",1
12264445,12263941,0,"<blockquote>
  <p>My question why traverseR cannot have iterative counter part? Is it that if recursive call is not end of function i.e., like in traverse then we cannot have iterative, Is my understanding right?</p>
</blockquote>

<p>Correct. The functions <code>traverse</code> and <code>remove</code> end with a call to themselves. They are tail recursive functions. The call in <code>traverseR</code> to itself is not at the end of the function; <code>traverseR</code> is not tail recursive.</p>

<p>Recursion in general has an expense of creating and later destroying stack frames. This expense can be completely avoided with tail recursive functions by changing the recursion into iteration. Most compilers recognize tail recursive functions and convert the recursion to iteration.</p>
",0
12264120,12263941,4,"<p>Assuming that the list is single-linked, it is not possible to visit it iteratively in the backward order because there's no pointer from a node to a previous node.</p>

<p>What the recursive implementation of <code>traverseR</code> essentially does is that it implicitly reverses the list and visits it in the forward order.</p>
",2
12264155,12263941,5,"<p><code>traverseR</code> uses the call stack to store pointers to all the nodes of the list, so that they can be accessed in reverse order as the call stack unwinds.</p>

<p>In order to do this without a call stack (i.e. non-recursively), you'll need some other stack-like data structure to store these pointers in.</p>

<p>The other functions simply work on the current node and move on, with no need to store anything for use after the recursive function call returns. This means that the <em>tail recursion</em> can be replaced with a loop (either by modifying the code or, depending on the compiler, letting it determine that that's possible and make the transformation itself).</p>
",0
12264174,12263941,1,"<p>You could write and iterative version of <code>traverseR</code> using a stack: in a loop iterate from one node to another, pushing the nodes on the stack. When you get to the end of the list then, in another loop, pop and visit the nodes you visited.</p>

<p>But his is basically what the recursive version does.</p>
",0
12265117,12263941,0,"<p>It is possible to write an iterative version of <code>traverseR</code> depending on what you mean by iterative.  If you are limited so a single traversal through the list, it is not possible.  But if you can sacrifice a lot processing time it can be done.  It does use less memory in the classic speed vs. memory trade-off.</p>

<pre><code>void traverseRI(link h, void visit(link))
{
    if (h == 0) return;

    link last = 0;

    while (last != h)
    {
        link test = h;
        while (test-&gt;next != last)
        {
            test = test-&gt;next;
        }

        visit(test);
        last = test;
    }
}
</code></pre>
",0
12266239,12263941,1,"<p>It is possible to traverse a singly linked list in reverse order with only O(1) extra space -- i.e., without a stack of previously visited nodes. It is, however, a little tricky, and not at all thread safe.</p>

<p>The trick to this is to traverse the list from beginning to end, reversing it in place as you do so, then traverse it back to the beginning, reversing it again on the way back through.</p>

<p>Since it is a linked list, reversing it in place is fairly straightforward: as you get to a node, save the current value of its <code>next</code> pointer, and overwrite that with the address of the previous node in the list (see the code for more detail):</p>

<pre><code>void traverseR(node *list, void (*visit)(node *)) { 
    node *prev = nullptr;
    node *curr = list;
    node *next;

    if (!curr)
        return;

    // Traverse forwards, reversing list in-place as we go.
    do {
        next = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = next;
    } while (curr-&gt;next);

    // fix up so we have a fully reversed list
    curr-&gt;next = prev;
    prev = nullptr;

    // Traverse the reversed list, visiting each node and reversing again
    do { 
        visit(curr);
        next = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = next;
    } while (curr-&gt;next);
}
</code></pre>

<p>Like almost anything dealing with linked lists, I feel obliged to add that (at least IMO) they should almost always be treated as a purely intellectual exercise. Using them in real code is <em>usually</em> a net loss. You typically end up with code that's slow, fragile, and hard to understand, as well as typically wasting quite a bit of memory (unless the data you store in each node is pretty big, the pointer can often use as much space as the data itself).</p>
",0
13702340,13702220,1,"<p>For only 100 numbers there may not be significant performance differences and you could use sets or arrays; plain old arrays like <code>id_used[100]</code> probably win in the performance measure.</p>

<p>If you need a scalable solution, try out having a ""free-set"" and a ""used-set"", with the free-set storing id's which are open for use, and the used-set with id's in use already. After using an id, store it back to the free set.</p>

<p>For a large enough ratio of allowed id's vs. concurrent uses, use only the ""used-set"", and use rejection sampling to find a free id:</p>

<pre><code>do {
    id = generate_id();
} while(std::end != used_set.find(id));
</code></pre>

<p>Anyways, there is no definitive answer.</p>
",0
13702402,13702220,0,"<p>I haven't compiled it, but it should be something like this:  </p>

<pre><code>std::list&lt;int&gt; list;
for(int i=start; i&lt;=end; ++i)
  list.insert(i);

//when get Id request
Id2send = list.first();
list.remove(list.first());

//when delete id request
list.remove(id);

//when add id request (this happens when an id is freed or other times)
list.add(id);
</code></pre>
",0
13702873,13702220,2,"<p>You have to maintain a collection of unused ids at least. Additionally I would throw in a lookup table to verify that an id was handed out (for robustness). For both, I would suggest to use an <code>std::vector</code>, not a list.</p>

<p>First, store the unused collection in an <code>std::vector&lt;int&gt;</code>, which you can very easily initialise:</p>

<pre><code>class IdStore {
  private:
    std::vector&lt;int&gt; unused;
    static int const MIN_ID = -101;
    static int const MAX_ID = -2;
  public:
    IdStore::IdStore()
    : unused(MAX_ID - MIN_ID + 1) {
      for (auto i = 0; i &lt;= MAX_ID-MIN_ID; ++i) {
        unused[i] = i;
      }
    }
    int getId();
    void releaseId(int);
};
</code></pre>

<p>Additionally, you may want to keep track of the used ids, so you can verify if they were handed out; I'd use an <code>std::vector&lt;bool&gt; used;</code> member for that, which you can initialise simply with <code>used(MAX_ID - MIN_ID +1)</code> as its values will all default to <code>false</code> initially. Of course, you can make <code>used</code> also a <code>bitset</code> but note that this would require the distance from <code>MIN_ID</code> to <code>MAX_ID</code> to be known at compile time.</p>

<p>Handing out stuff is pretty simple from there:</p>

<pre><code>int IdStore::getId() {
  if (unused.empty())
    throw ""error""; // put something better here
  auto r = unused.back();
  used[r] = true;
  unused.pop_back();
  return MIN_ID + r;
}
</code></pre>

<p>And releasing them, also:</p>

<pre><code>void IdStore::releaseId(int id) {
  if (id &lt; MIN_ID || id &gt; MAX_ID)
    throw ""error""; // put something better here
  id -= MIN_ID;
  if (!used[id])
    throw ""error""; // put something better here
  used[id] = false;
  unused.push_back(id);
}
</code></pre>

<p>Note that no reallocations take place! The vector will <a href=""http://en.cppreference.com/w/cpp/container/vector/pop_back"" rel=""nofollow"">keep its size</a> and neither <code>getId</code> nor <code>releaseId</code> will require expensive calls to <code>malloc</code> or <code>free</code> contrary to an approach using a list.</p>
",4
13704919,13702220,3,"<p>Expanding on my <code>std::bitset</code> comment:</p>

<p>You can use the id as the index of the bitset and the value (<code>true/false</code>) as the availability of the id.</p>

<pre><code>class IdStorage {
    const int N = 100;
   std::bitset&lt;N&gt; ids;

   bool allIdsUsed() { 
       return ids.all();
   }

   int getId() {
     if(allIdsUsed())
         throw ""Error"";

     for(int i = 0; i &lt; N; ++i )
        if(ids.test(i))
            return i - 2;
   }

   void releaseId(int i) {
       ids.set(i + 2);
    }

}
</code></pre>

<p>Note that typed this in class, out of my head. Check the <a href=""http://en.cppreference.com/w/cpp/utility/bitset"" rel=""nofollow"">documentation</a></p>
",0
14248793,4931193,1,"<p>His question is specific enough. You need a test runner. Encapsulate each test in its own behavior and class. The test project is contained separately from the tested code. Afterwards just configure your XMLOutputter. You can find an excellent example of how to do this in the linux website. <a href=""http://www.yolinux.com/TUTORIALS/CppUnit.html"" rel=""nofollow"">http://www.yolinux.com/TUTORIALS/CppUnit.html</a></p>

<p>We use this way to compile our test projects for our main projects and observe if everything is ok. Now it all becomes the work of maintaining your test code. </p>
",0
17812971,17812585,1,"<blockquote>
  <p>Binary string class is needed to collect and manipulate binary streams of data.</p>
</blockquote>

<p>This essentially means the string (or stream) can contain an arbitrary number of elements (binary data; bits), which could represent anything and you can change those by using the class.</p>

<blockquote>
  <p>These data streams can represent anything from image data to the contents of objects.</p>
</blockquote>

<p>You can do with a stream whatever you want (usually only limited by implementation). For example, you can load raw image data into a stream object and then read single bytes. You could as well write single characters to a stream (or array) and save it as raw image data. The elemental string/stream doesn't limit you to any single interpretation. Instead the actual implementation/interface defines this part.</p>

<blockquote>
  <p>Here author also mentioned it is like object streaming or object persistance.</p>
</blockquote>

<p>""Object streaming"" here refers to transfering something. E.g. sending data over a network or port (e.g. using it as a buffer to send or receive data). ""Object persistance"" refers to keeping something (letting it persist) even while your program isn't running anymore (loading/saving).</p>

<hr>

<p>Essentially, pretty much any stream as well as the containers available in the STL are already what the author considers a <strong>binary string</strong>. The difference is just the grouping, e.g. are you able to access/read/write single bits or just bytes/words/whatever?</p>

<p>To get a real ""bit stream"", you could just use something as simple as <code>std::vector&lt;bool&gt;</code>. This allows you to store boolean values, but you might as well read them as something different (e.g. reading them blockwise by casting the contents to an array of integers).</p>

<p>But I'd say something as simple as a <code>std::stream</code> would even better match the description of the author: It can be used to keep persistent data, it can be used to transfer data and it can be used to store/load data in different formats/interpretations. For example, you can write single bits or bytes and later on read them as an integer or even a string.</p>
",1
17812749,17812585,0,"<blockquote>
  <p>What does author mean by object stream.</p>
</blockquote>

<p>They mean sending - from one part of a program - output that encodes the value of an object, such that the receiving code can construct an object with an equivalent value.  It's pretty much like persistence (e.g. saving an object to disk so you can load it later), except that the data isn't necessarily put somewhere persistent (so it could be lost if the power was turned off) but it arrives at some other code that effectively does the reload step immediately.</p>

<p>For example, and without production levels of error checking:</p>

<pre><code>struct X { int a; int b; };

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const X&amp; x)
    { return os &lt;&lt; x.a &lt;&lt; ' ' &lt;&lt; x.b; }

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, X&amp; x)
    { return is &gt;&gt; x.a &gt;&gt; x.b; }

X x1 = ...;
std::istringstream iss;
iss &lt;&lt; x1;
X x2;
if (iss &gt;&gt; x)
    assert(x2 == x1);
</code></pre>

<blockquote>
  <p>Can any one give me simple example on how we can write binary string class.</p>
</blockquote>

<p>You don't have to... the Standard includes <code>std::string</code>, which can handle binary data.</p>
",2
17805653,17805541,8,"<p>From C++ Coding Standards (Sutter, Alexandrescu)</p>

<blockquote>
  <p>Many modern C++ compilers recognize header   guards automatically (see
  Item 24) and don't even open the same header twice.   Some also offer
  precompiled headers, which help to ensure that often-used, 
  seldom-changed headers will not be parsed often</p>
</blockquote>

<p>So, I would consider those suggestions outdated (unless you are still using some very dated compiler).</p>

<p>As for your questions:</p>

<ol>
<li>it means: opening a file which is not needed (since it has been already included; which you will know because the include guard is already defined) is costy; and this might be an issue if you do it a lot of times (which can happen if you have hundreds of files in your project).</li>
<li>as opposed to using non-redundant compile guards.</li>
</ol>

<p>What is a redundant compile guard?</p>

<blockquote>
  <p>A naive compiler will reload the file every time it's included. To
  avoid that, put RedundantIncludeGuards around the include: header.h</p>
</blockquote>

<pre><code> #ifndef HEADER_H_
  #define HEADER_H_
  // declarations
  #endif
</code></pre>

<blockquote>
  <p>foo.c</p>
</blockquote>

<pre><code> #ifndef HEADER_H_
  #include ""header.h""
  #endif
</code></pre>

<p>read more <a href=""http://c2.com/cgi/wiki?RedundantIncludeGuards"">here</a>. Your reference claims that by doing so you can be as much as 20% faster during compilation than you would be if foo.c were only doing</p>

<pre><code> #include ""header.h""
</code></pre>
",1
17805700,17805541,7,"<p>I don't know what Lakos96 says, but I'm going to guess anyway...</p>
<p>A standard include guard is like:</p>
<h3>foo.h</h3>
<pre><code>#ifndef FOO_H_INCLUDED
#define FOO_H_INCLUDED
....
#endif
</code></pre>
<p>A redundant include guard is using the macro when including the file:</p>
<h3>bar.c</h3>
<pre><code>#ifndef FOO_H_INCLUDED 
#include &quot;foo.h&quot;
#endif
</code></pre>
<p>That way the second time the <code>foo.h</code> file is included, the compiler will not even search for it in the disk. Hence the speedup: imagine a large project, one single compilation unit may include <code>foo.h</code> 100 times, but only the first one will be parsed. The other 99 times it will be searched for, opened, tokenized, discarded by the pre-compiler and closed.</p>
<p>But note that that was in 1996. Today, GCC, to give a well known example, has specific optimizations that recognize the include guard pattern and makes the redundant include guard, well..., redundant.</p>
",0
17805703,17805541,1,"<p>In a large project, there may be many headers - perhaps 100s or even 1000s of files. In the normal case, where include guards are inside each header, the compiler has to check (but see below) the contents of the file to see if it's already been included.</p>

<p>These guards, inside the header, are ""standard"".</p>

<p>Lakos recommends (for large projects) putting the guards around the <code>#include</code> directive, meaning the header won't even need to be opened if it's already been included.</p>

<p>As far as I know, however, all modern C++ compilers support the <code>#pragma once</code> directive, which coupled with pre-compiled headers means the problem is no longer an issue in most cases.</p>
",0
17805713,17805541,1,"<p>I think what it refers to is to replicate the include guard outside of the header file, e.g.</p>

<pre><code>#ifndef _cache_h_
#include &lt;cache.h&gt;
#endif
</code></pre>

<p>However, if you do this, you'll have to consider that header guards are sometimes changing within a file. And you certainly won't see a 20x improvement in a modern system - unless all your files are on a very remote network drive, possibly - but then you'll have a much better improvement from copying the project files to your local drive!</p>

<p>There was a similar question a while back, regarding ""including redundant files"" (referring to including header files multiple times), and I built a smallish system with 30 source files, which included <code>&lt;iostream&gt;</code> ""unnecessarily"", and the overall difference in compile time was 0.3% between including and not including <code>&lt;iostream&gt;</code>. I believe this finding shows the improvement in GCC that ""automatically recognises files that produce nothing outside of include guards"". </p>
",0
17805726,17805541,6,"<p>Lakos' book is old. It may have been true once, but you should time things on your machine. Many people now disagree with him, e.g. 
<a href=""http://www.allankelly.net/static/writing/overload/IncludeFiles/AnExchangeWithHerbSutter.pdf"" rel=""noreferrer"">http://www.allankelly.net/static/writing/overload/IncludeFiles/AnExchangeWithHerbSutter.pdf</a>
or <a href=""http://c2.com/cgi/wiki?RedundantIncludeGuards"" rel=""noreferrer"">http://c2.com/cgi/wiki?RedundantIncludeGuards</a>
or <a href=""http://gamearchitect.net/Articles/ExperimentsWithIncludes.html"" rel=""noreferrer"">http://gamearchitect.net/Articles/ExperimentsWithIncludes.html</a></p>

<blockquote>
  <p>Herb Sutter, C++ guru and current chair of the ISO C++ standards
  committee, argues against external include guards:</p>
  
  <p>""Incidentally, I strongly disagree with Lakos' external include guards
  on two grounds:</p>
  
  <ol>
  <li><p>There's no benefit on most compilers. I admit that I haven't done measurements, as Lakos seems to have done back then, but as far as I
  know today's compilers already have smarts to avoid the build time
  reread overhead--even MSVC does this optimization (although it
  requires you to say ""#pragma once""), and it's the weakest compiler in
  many ways.</p></li>
  <li><p>External include guards violate encapsulation because they require many/all callers to know about the internals of the header -- in
  particular, the special #define name used as a guard. They're also
  fragile--what if you get the name wrong? what if the name changes?""</p></li>
  </ol>
</blockquote>
",6
17805786,17805541,0,"<ol>
<li><p>in larger projects with more people, there may be, for example, one module dealing with time transformation and it's author could chose to use <code>TIME</code> as a guard. Then you'll have another one, dealing with precise timing and it's author, unaware of the first one, may choose <code>TIME</code> too. Now you have a conflict. If they used <code>TIME_TRANSFORMATION</code> and <code>PRECISE_TIMING_MODULE</code>, they'll be ok</p></li>
<li><p>Don't know. I would guess it coud mean ""when you do it every time, consistently, it becomes your coding standard"".</p></li>
</ol>
",0
12278578,12278523,5,"<p>The difference between your two doubles is 0.0003. std::numeric_limits::epsilon() is much smaller than that.</p>
",0
12278807,12278523,2,"<p>Epsilon is much smaller than 0.0003, so they are clearly not equal.</p>

<p>If you want to see where it works check <a href=""http://ideone.com/blcmB"" rel=""nofollow"">http://ideone.com/blcmB</a></p>
",0
12278554,12278523,6,"<p>The are not equal (according to your function) because they differ by more than <code>epsilon</code>.</p>

<p>Epsilon is defined as ""<em>Machine epsilon (the difference between 1 and the least value greater than 1 that is representable)</em>"" - source <a href=""http://www.cplusplus.com/reference/std/limits/numeric_limits/"" rel=""noreferrer"">http://www.cplusplus.com/reference/std/limits/numeric_limits/</a>. This is approximately <code>2.22045e-016</code> (source <a href=""http://msdn.microsoft.com/en-us/library/6x7575x3(v=vs.71).aspx"" rel=""noreferrer"">http://msdn.microsoft.com/en-us/library/6x7575x3(v=vs.71).aspx</a>)</p>

<p>If you want to change the fudging factor, compare to another small double, for example:</p>

<pre><code>bool AreDoubleSame(double dFirstVal, double dSecondVal)
{
    return std::fabs(dFirstVal - dSecondVal) &lt; 1E-3;
}
</code></pre>
",3
12278565,12278523,17,"<p>The epsilon for 2 doubles is <code>2.22045e-016</code></p>

<blockquote>
  <p>By definition, epsilon is the difference between 1 and the smallest value greater than 1 that is
  representable for the data type.</p>
</blockquote>

<p>These differ by more than that and hence, it returns false</p>

<p>(<strong><a href=""http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon"" rel=""noreferrer"">Reference</a></strong>)</p>
",0
17810761,17810510,0,"<ol>
<li><p>The question here is ""can we store ANY old data in the string, or does certain byte-values need to be encoded in some special way. An example of that would be in the standard C language, if you want to use a newline character, it is ""encoded"" as <code>\n</code> to make it more readable and clear - of course, in this example I'm talking of in the source code. In the case of binary data stored in the string, how would you deal with ""strange"" data - e.g. what about zero bytes? Will they need special treatment? </p></li>
<li><p>The values guaranteed to fit in a <code>char</code> is ASCII characters and a few others (a total of 256 different characters in a typical implementation, but <code>char</code> is not GUARANTEED to be 8 bits by the standard). But if we take non-european languages, such as Chinese or Japanese, they consist of a vastly higher number than the ones available to fit in a single <code>char</code>. Unicode allows for several million different characters, so any character from any european, chinese, japanese, thai, arabic, mayan, and ancient hieroglyphic language can be represented in one ""unit"". This is done by using a wider character - for the full size, we need 32 bits. The drawback here is that most of the time, we don't actually use that many different characters, so it is a bit wasteful to use 32 bits for each character, only to have zero's in the upper 24 bits nearly all the time. </p></li>
</ol>

<p>A multibyte character encoding is a compromise, where ""common"" characters (common in the European languages) are used as one <code>char</code>, but less common characters are encoded with multiple <code>char</code> values, using a special range of character to indicate ""there is more data in the next <code>char</code> to combine into a single unit"". (Or,one could decide to use 2, 3, or 4 <code>char</code> each time, to encode a single character).</p>
",7
17810894,17810510,0,"<p>Regarding point one, ""Binary data"" refers to sequences of bytes, where ""bytes"" almost always means eight-bit words. In the olden days, most systems were based on ASCII, which requires seven bits (or eight, depending on who you ask). There was, therefore, no need to distinguish between bytes and characters. These days, we're more friendly to non-English speakers, and so we have to deal with Unicode (among other codesets). This raises the problem that string types need to deal with the fact that bytes and characters are no longer the same thing.</p>

<p>This segues onto point two, which is about how you represent strings of characters in a program. UTF-8 uses a variable-length encoding, which has the remarkable property that it encodes the entire ASCII character set using exactly the same bytes that ASCII encoding uses. However, it makes it more difficult to, e.g., count the number of characters in a string. For pure ASCII, the answer is simple: characters = bytes. But if your string might have non-ASCII characters, you now have to walk the string, decoding characters, in order to find out how many there are<sup>1</sup>.</p>

<p>These are the kinds of issues you need to think about when designing your string class.</p>

<hr>

<p><sup>1</sup>This isn't as difficult as it might seem, since the first byte of each character is guaranteed not to have 10 in its two high-bits. So you can simply count the bytes that satisfy <code>(c &amp; 0xc0) != 0xc0</code>. Nonetheless, it is still expensive relative to just treating the length of a string buffer as its character-count.</p>
",2
18141688,18141622,8,"<p>The reason is because the preprocessor basically does a search-and-replace on all macros that are defined. And it's done before the compiler proper gets the code, and it does not know anything about namespaces, classes or scope in general.</p>

<p>So if you have e.g.</p>

<pre><code>#define clear()  something
</code></pre>

<p>and then use</p>

<pre><code>wstr.clear();
</code></pre>

<p>The preprocessor will replace the <code>clear()</code> so that the compiler sees</p>

<pre><code>wstr.something;
</code></pre>
",3
11496475,11496426,2,"<p>On the contrary; using your first method, it is inefficient to remove items from the linked list as you ""lose"" the slot in the vector where that item was stored and would have to walk the whole list in a garbage-collection style to discover which slots are not being used.</p>

<p>With regard to memory fragmentation, having lots of small allocations is not an issue generally; indeed as a vector is required to be contiguous allocating the memory for it will <em>cause</em> fragmentation as you require larger and larger blocks of contiguous memory.  In addition, each time the vector is resized you are causing the copying of large blocks of memory.</p>

<p>In fact, your first answer is arrogating to yourself the job of the memory allocator and memory management unit.  The job of the memory allocator is to hand out small chunks of memory; the job of the MMU (among others) is to ensure that pointers between blocks of memory continue to point to the same logical memory even when moved around in physical memory.  Your <code>nextitem</code> int members are essentially functioning as pointers.  Unless you have very specialised requirements, the hardware, kernel and malloc can do this job far better than you can.</p>
",0
11496548,11496426,1,"<p>Your logic is completely backwards. The first approach requires that memory be contiguous and will fail as soon as insufficient contiguous memory is available. Your second approach can use memory whether contiguous or not and will continue to work until no memory at all remains.</p>
",0
11496477,11496426,0,"<p>Your first approach seems to blend two algorithms and, therefore, I would say is less efficient.</p>

<p>One of the advantages of a linked list is that items can easily be inserted and deleted. Yet using your approach, they require shifting data around. You may as well use a simply resizable array.</p>

<p>In addition, an array requires memory to be contiguous. In some circumstances, you will run out of memory sooner than with a true linked list when working with large amounts of data because there may be times when a certain amount of memory is available, but not contiguously.</p>
",0
11496491,11496426,3,"<p><strong>Implementing a list with a vector is misguided.</strong></p>

<hr>

<p>I'll explain.  Containers are typically designed to achieve a certain set of goals, and the underlying implementation is selected based on those goals.</p>

<p>A vector is very good because it has contiguous memory and you can reach any cell by pointer arithmetic.  Unfortunately, a vector has terrible performance when inserting or deleting an element in the center of the vector.</p>

<p>A list has the exact opposite intention.  Navigating to a point in a list is time consuming because you have to follow links because its not contiguous.  BUT the primary purpose of a list is to allow fast insertions, deletions, reordering, splicing, reversals, etc.</p>

<hr>

<p><strong>So, thinking of a vector as an implementation base for a list (while can be done) really isn't the way to look at this.  Implementing a list with a vector would basically mean you didn't have any of the advantages that made you choose a list in the first place.</strong></p>

<hr>

<p><strong>EDIT</strong></p>

<p>As other people have pointed out in the comments below, if you're thinking of more complex implementations, you could definitely get performance benefits out of this.</p>

<p>For example, if you maintain a vector with references to all of the pointers, and you work to keep that reference vector in order, you can have the benefits of pointer-arithmetic access while still having relatively fast removal/insertion, etc.  Also, since the reference vector just holds pointers to dynamically allocated objects, manipulating the reference vector isn't costly and you still don't have to have a massive region of contiguous memory being used (the vector would just be NumElements * sizeof(pointer) on your architecture).</p>

<p><strong>You should look at a std::deque implementation for some fun.</strong>  They have some interesting interplay between contiguous memory regions linked by pointers to speed up insert/delete/other operations.</p>
",8
11496497,11496426,0,"<p>If you remove an element from the list in the case #1, a good part of the remaining elements may get their <code>nextitem</code> indexes messed up. So #2 is the usual way to go and won't cause any memory problems if properly implemented, unless you try to insert an insane number of elements into the list, or any other container for that matter.</p>
",0
11496652,11496426,5,"<p>I'll go against everyone else here and say that, yes, the first approach might end up being more efficient. In the second approach, you're allocating memory on the heap O(N) times - N being the number of nodes in the list. If you're using a vector, you're only making O(log N) number of heap allocations.</p>

<p>Also, if you're on a 64 bit machine, the overhead of saving a pointer in each node may be a bit too much if you're dealing with lots of small items. Using a vector, you can use a smaller <code>nextItem</code> - e.g. 32 bit instead of 64, which, if you're making a list to hold 32 bit ints, would be a 1.5 improvement in memory usage.</p>

<p>Another possible optimization is that if you know up-front that you'll be dealing with a lot of elements, you can reserve a big vector and have a single heap allocation for a pretty long time.</p>

<p>I recently took a course on applications of automata and the lecturer is implementing some of the algorithms for pretty large data sets. One of the techniques he told us was exactly your first approach of representing a linked list. I had a course work that I tried implementing both ways (with pointers and with a vector and <code>nextItem</code> kind of thing) and the vector one was acting much better (it did have other optimizations too, but the vector definitely had an effect).</p>

<p><strong>NOTE TO OTHERS</strong></p>

<p>I think what @smilingbuddha is asking about is more like a collection of linked lists - or at least that's what I've used it for. For example, when you save a graph using a list of neighbors. You need a linked list (or array, or whatever) of all the neighbors for each node. So instead of keeping an array of linked lists or a vector of vectors, you just keep of array of indexes pointing to the last inserted neighbor for every node.</p>
",0
11495970,11495895,2,"<ol>
<li><p>Copy-and-swap is best practice. If you don't want to override <code>std::swap</code> because you're unfamiliar with templates, then you can also write a <code>swap_points</code> function or a <code>Point::swap(Point &amp;other)</code> member function.</p>

<p>The implementation of that (member) function is very simple: just call <code>std::swap</code> on all of the members.</p></li>
<li><p>Yes, implementing the Big Three yourself for this class is really an academic exercise.</p></li>
</ol>
",0
11495981,11495895,2,"<p>The naive works here, because <code>Point</code> doesn't manage any resources.<br>
Simply copying the double values won't throw an exception, so this code is exception-safe (and in turn is self-assignment safe).</p>

<pre><code>// Point.cpp

Point &amp; operator=(Point source);
    m_x = source.m_x;
    m_y = source.m_y;

    return *this;
}
</code></pre>
",2
14248107,14248044,14,"<p>The things that Microsoft calls anonymous structs are not standard. An unnamed struct is just an ordinary struct that doesn't have a name. There's not much you can do with one, unless you also define an object of that type:</p>

<pre><code>struct {
    int i;
    double d;
} my_object;

my_object.d = 2.3;
</code></pre>

<p>Anonymous <strong>unions</strong> are part of the standard, and they have the behavior you'd expect from reading <a href=""http://msdn.microsoft.com/en-us/library/vstudio/35ect93t.aspx"" rel=""noreferrer"">Microsoft's description</a> of their anonymous structs:</p>

<pre><code>union {
    int i;
    double d;
};

d = 2.3;
</code></pre>
",3
14248127,14248044,64,"<p>All the standard text refers to creating an ""unnamed struct"":</p>

<pre><code>struct {
   int hi;
   int bye;
};
</code></pre>

<p>Just a nice friendly type, with no accessible name.</p>

<p>In a standard way, it could be instantiated as a member like this:</p>

<pre><code>struct Foo {
   struct {
      int hi;
      int bye;
   } bar;
};

int main()
{
   Foo f;
   f.bar.hi = 3;
}
</code></pre>

<hr>

<p>But an ""anonymous struct"" is subtly different &mdash; it's the combination of an ""unnamed struct"" and the fact that you magically get members out of it in the parent object:</p>

<pre><code>struct Foo {
   struct {
      int hi;
      int bye;
   }; // &lt;--- no member name!
};

int main()
{
   Foo f;
   f.hi = 3;
}
</code></pre>

<p>Converse to intuition<sup>&dagger;</sup>, this does not merely create an unnamed struct that's nested witin <code>Foo</code>, but also automatically gives you an ""anonymous member"" of sorts which makes the members accessible within the parent object.</p>

<p>It is this functionality that is non-standard. GCC <a href=""http://gcc.gnu.org/onlinedocs/gcc/Unnamed-Fields.html"" rel=""noreferrer""><em>does</em> support it</a>, and so does Visual C++. Windows API headers make use of this feature by default, but you can specify that you don't want it by adding <code>#define NONAMELESSUNION</code> before including the Windows header files.</p>

<p>Compare with the <em>standard</em> functionality of ""anonymous unions"" which do a similar thing:</p>

<pre><code>struct Foo {
   union {
      int hi;
      int bye;
   }; // &lt;--- no member name!
};

int main()
{
   Foo f;
   f.hi = 3;
}
</code></pre>

<hr>

<p><sup>&dagger;</sup> It appears that, though the term ""unnamed"" refers to the type (i.e. ""the class"" or ""the struct"") itself, the term ""anonymous"" refers instead to the actual instantiated member (using an older meaning of ""the struct"" that's closer to ""an object of some <code>struct</code>y type""). This was likely the root of your initial confusion.</p>
",10
14248134,14248044,9,"<p>The standard talks about <em>anonymous unions</em>: [9.5]/5</p>

<blockquote>
  <p>A union of the form</p>

<pre><code>union { member-specification } ;
</code></pre>
  
  <p>is called an anonymous union; it defines an unnamed object of unnamed type. The member-specification of an anonymous union shall only define non-static data members. [ Note: Nested types and functions cannot be declared within an anonymous union. ¡ªend note ] The names of the members of an anonymous union shall be distinct from the names of any other entity in the scope in which the anonymous union is declared. For the purpose of name lookup, after the anonymous union definition, the members of the anonymous union are considered to have been defined in the scope in which the anonymous union is declared. [ Example:</p>

<pre><code>void f() {
    union { int a; const char* p; };
    a = 1;
    p = ""Jennifer"";
}
</code></pre>
  
  <p>Here a and p are used like ordinary (nonmember) variables, but since they are union members they have the same address. ¡ªend example ]</p>
</blockquote>

<p>The <em>anonymous structs</em> that <em>Microsoft</em> talks about is this feature for <code>unions</code> but applied to <code>structs</code>. Is not just an unnamed definition, its important to note that mebers of the anonymous union/struct are considered to have been defined in the scope in which the anonymous union/struct is declared.</p>

<p>As far as I know, there is no such behavior for <em>unnamed structs</em> in the Standard. Note how in the cited example you can achieve things that wouldn't be otherwise possible, like sharing storage for variables in the stack, while <em>anonymous structs</em> bring nothing new to the table.</p>
",9
15509028,15508834,2,"<p>Try this.</p>

<pre><code>    if ((i &amp; (i+1)) == 0) // print newline if i+1 is a power of two
</code></pre>
",5
15509089,15508834,0,"<p>As a starting point, try this:</p>

<pre><code>unsigned uNext = 0, power = 0;
for (unsigned i = 0; i &lt; v2.size(); ++i) {
  cout &lt;&lt; v2[i] &lt;&lt; (i == uNext) ? endl : "" "");
  uNext = (uNext == i) ? uNext + pow(2, ++power): uNext;
}
</code></pre>

<p>You have to check that you do not overflow the unsigned uNext so add some checks.</p>
",7
15509272,15508834,0,"<p>Supposing Roddy is right, and in fact, you want the length of
each line to increase to the next power of two, the problem is
easily solved using a variation on the standard idiom: </p>

<pre><code>int maxInLineCount = 2;
int inLineCount = 0;
for ( auto current = v.begin(); current != v.end(); ++ current ) {
    if ( inLineCount != 0 ) {
        std::cout &lt;&lt; ' ';
    }
    std::cout &lt;&lt; *current;
    ++ inLineCount;
    if ( inLineCount &gt;= maxInLineCount ) {
        std::cout &lt;&lt; '\n';
        inLineCount = 0;
        maxInLineCount *= 2;    //  This is the added bit.
    }
}
if ( inLineCount != 0 ) {
    std::cout &lt;&lt; '\n';
}
</code></pre>
",0
10761027,10760997,6,"<p>You can make all <code>BaseA</code>'s constructors private and add <code>DerivedB</code> as a <code>friend</code> of <code>BaseA</code>'s.</p>

<pre><code>class BaseA
{
    friend class DerivedB;
private:
    BaseA();
};
class DerivedB : BaseA
{
};
class DerivedC : BaseA  //error - I get it when I try to create an object in MSVS
                        //but in principle it works
{
};
</code></pre>
",2
15826977,15826969,2,"<p>a2 is a reference so it does not have a destructor.</p>

<p>The destructor for a1 will only be called when the program exits. What exactly are you expecting to happen when a2's local scope ends?</p>
",0
15827003,15826969,0,"<p>References are nothing but pointers and in fact many compilers convert references to pointers internally. As pointers don't have a destructor so does reference. Hence at the end of  function golbal object a1 will remain as it is and it's destuctor will be called only at the end of the program.</p>

<p>Thanks
Niraj Rathi</p>
",0
14726233,14726192,3,"<p>Take a look at <a href=""http://msdn.microsoft.com/en-us/library/8bbhbaew%28v=vs.80%29.aspx"" rel=""nofollow""><strong>setw</strong></a> format specifier:</p>

<pre><code>for (unsigned int dvIdx = 0; dvIdx &lt;  3; dvIdx++)
{
    dataFile &lt;&lt; myData.TimeChanged().Format().c_str() &lt;&lt; ""  "" 
        &lt;&lt; setw(10) &lt;&lt;  myData.GetValue() &lt;&lt; ""  ""
        &lt;&lt; setw(20) &lt;&lt;  myData.GetQuality() &lt;&lt; std::endl; 
}
</code></pre>
",1
14726264,14726192,0,"<p>Try <a href=""http://www.cplusplus.com/reference/iomanip/"" rel=""nofollow"">I/O manipulators</a>. Looks to me that <code>setw(10)</code> would do the job.</p>
",0
14726435,14726192,1,"<p>You must look for <a href=""http://www.cplusplus.com/reference/iomanip/"" rel=""nofollow""><code>&lt;iomanip&gt;</code></a>, <code>setw</code> and <code>setiosflags</code> </p>

<pre><code>dataFile &lt;&lt; myData.TimeChanged().Format() &lt;&lt; ""  ""
         &lt;&lt; std::setw(10) &lt;&lt; std::setiosflags(std::ios::right)
         &lt;&lt; myData.GetValue() 
         &lt;&lt; std::setw(10) &lt;&lt; std::setiosflags(std::ios::right)
         &lt;&lt; ""  "" &lt;&lt;  myData.GetQuality() &lt;&lt; std::endl; 
</code></pre>
",0
11504760,11504729,3,"<p>Use <code>std::string</code>:</p>

<pre><code>std::string objName;   
</code></pre>

<p>Now it will do the job of deep-copy. No need to worry about it anymore. </p>

<p>Also, in general, <code>std::string</code> is awesome, you will love it. Use it when you need  <code>char*</code> or <code>const char*</code> (as a general rule).</p>
",5
11505228,11504729,0,"<p>First, for the bit of code you show, shallow copy should work.  As long
as <code>objName</code> points to a string literal, there should be no problems.</p>

<p>If <code>objName</code> does start pointing to other things, then you probably need
special functions to manage it, not just for assignment, but also for
creation, etc.  At this point, you will need a wrapper class.  But
first, I'd ensure that you do need it: since you say that <code>Data</code> is in
an external library that you can't change, it might have some
constraints about this as well.  (Does the library copy <code>Data</code>
internally?  If so, then you must ensure the lifetime of the string you
pass it, someway or another.) </p>
",0
11504784,11504729,0,"<p>If you can change <code>Property</code> to use a <code>std::string</code> instead of a <code>const char*</code> everything will work.</p>

<p>If you can't, wrap <code>Data</code> in a class you <em>can</em> provide a copy ctor/assign operator for and store a vector of that.</p>
",1
11504823,11504729,0,"<p>You can create a new class DataRef which embeds Data and implement the rule-of-three in that on behalf of the Data/Property. Then use DataRef in the vector.</p>
",2
13450583,13450570,6,"<p><code>myfunc</code> needs to be accessible from the base class, so you would have to declare a public virtual <code>myfunc</code> in <code>base</code>. You could make it pure virtual if you intend for <code>base</code> to be an abstract base class, i.e one that cannot be instantiated and acts as an interface:</p>

<pre><code>class base
{
 public:
  virtual void myfunc() = 0; // pure virtual method
};
</code></pre>

<p>If you ant to be able to instantiate <code>base</code> objects then you would have to provide an implementation for <code>myfunc</code>:</p>

<pre><code>class base
{
 public:
  virtual void myfunc() {}; // virtual method with empty implementation 
};
</code></pre>

<p>There is <strong>no other clean way to do this</strong> if you want to access the function from a pointer to a base class. The safetest option is to use a <code>dynamic_cast</code></p>

<pre><code>base* pbase = new derived;

....
derived* pderived = dynamic_cast&lt;derived*&gt;(pbase);
if (derived) {
  // do something
} else {
  // error
}
</code></pre>
",1
13450590,13450570,3,"<p>To use the base class pointer, you <em>must</em> change the base class definition to be:</p>

<pre><code>class base
{
public:
    virtual void myFunc() { }
};
</code></pre>

<p>I see no other way around it. Sorry.</p>
",0
13450599,13450570,1,"<p>You could add it as a member of base and make it a virtual or pure virtual function. If using this route however, you should also add a virtual destructor in the base class to allow successful destruction of inherited objects.</p>

<pre><code>class base
{
public:
   virtual ~base(){};
   virtual void myFunc() = 0;
};

class derived : public base
{
  public:
   derived() {}
   void myFunc() { cout &lt;&lt; ""My derived function"" &lt;&lt; std::endl; }

};
</code></pre>
",1
13450662,13450570,6,"<p>If you are adamant that this function should NOT be a part of base, you have but 2 options to do it.</p>
<p>Either use a pointer to derived class</p>
<pre><code>derived* pDerived = new derived();
pDerived-&gt;myFunc();
</code></pre>
<p>Or (<strong>uglier</strong> &amp; <strong><em>vehemently</em> discouraged</strong>) static_cast the pointer up to derived class type and then call the function<br />
<strong>NOTE</strong>: To be used <strong>with caution</strong>. Only use when you are SURE of the type of the pointer you are casting, i.e. you are sure that <code>pbase</code> is a <code>derived</code> or a type derived from <code>derived</code>. In this particular case its ok, but im guessing this is only an example of the actual code.</p>
<pre><code>base* pbase = new derived();
static_cast&lt;derived*&gt;(pbase)-&gt;myFunc();
</code></pre>
",3
14744888,14742790,0,"<p>i Think you may embed the python code into C/C++ code.Please refer the following link for more details.</p>

<p><a href=""http://www.codeproject.com/Articles/11805/Embedding-Python-in-C-C-Part-I"" rel=""nofollow"">http://www.codeproject.com/Articles/11805/Embedding-Python-in-C-C-Part-I</a></p>

<p><a href=""http://www.linuxjournal.com/article/8497"" rel=""nofollow"">http://www.linuxjournal.com/article/8497</a></p>
",0
18152898,18152548,3,"<pre><code>x += '|' + b, x;
</code></pre>
<p>This compiles because the comma here is acting as an operator (instead of a separator) where the right-hand operand has no effect.</p>
<p>From <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow noreferrer"">Wikipedia</a>:</p>
<blockquote>
<p>In the C and C++ programming languages, the comma operator (represented by the token ,) is a binary operator that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type).</p>
<p>...</p>
<p>The comma operator has the lowest precedence of any C operator...</p>
</blockquote>
<p>In <code>x += '|' + b, x;</code>, operator <code>+=</code> has a higher precedence than <code>,</code> and operator <code>+</code> has a higher precedence than <code>+=</code>, meaning that it's equivalent to <code>(x += ('|' + b)), x</code>;</p>
<p>Additionally, if you compile your code with warnings on, you will likely receive a warning similar to this:</p>
<pre><code>warning: right-hand operand of comma has no effect
</code></pre>
",0
10168500,10168454,1,"<p>Since you want to customise how many seconds are in a day, all you're really doing is changing the ratio of 1 second : 1 second.</p>

<p>For instance, if you did was 1200 seconds in a day your ratio is:<br>
<code>1:72</code><br>
that is, for every 1 second that passes in your day, it is the equivilent of 72 real seconds.</p>

<p>So yes basically all you need to do in your program is find the ratio of 1 second to 1 second, times your elapsed seconds by that to get the 'fake' seconds, and then use that value...
The code may look something like this:</p>

<pre><code>// get the ratio second:fake_second
#define REAL_DAY_SECONDS 86400
int ratio = REAL_DAY_SECONDS / DAY;

fake_to_real = fake_second*ratio;
real_to_fake = real_second/ratio;
</code></pre>
",4
14735632,14735630,9,"<p>You're almost right. This behaviour actually comes from the function call specifically, not because of any sort of ""only works once"" rule.</p>

<p>Here's the wording for the whole lifetime extension ""feature"", with the pertinent rule emphasised in bold:</p>

<blockquote>
  <p><code>[C++11: 12.2/5]:</code> <em>[..]</em> The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference <strong>except</strong>:</p>
  
  <ul>
  <li><em>[..]</em></li>
  <li><strong>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</strong></li>
  <li><em>[..]</em></li>
  </ul>
</blockquote>
",7
14735707,14735630,3,"<p>The rule which applies here is common sense.  The standard is
poorly worded, and does in fact guarantee this.  But there's no
practical way to implement it. </p>
",3
14738884,14735630,7,"<p>This is subject of two issue reports, <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1299"">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1299</a> and <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1568"">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1568</a> . </p>

<p>The former issue report, of which I am the reporter, was intended to cover all these cases where a reference is bound to a temporary object, but is not intended to be lifetime-extending. The description in the body of the issue only mentions prvalues being confused with temporary expressions (that actually decide whether lifetime of what they evaluate to is lengthened or not). But lvalue and xvalues are likewise confused with these in the Standard. An example where that happens in the context of <code>static_cast</code> is issue number #1568 (in which the use of ""temporary variable"" further confuses the matter). </p>

<p>Actually, this: </p>

<blockquote>
  <p>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</p>
</blockquote>

<p>Contradicts the other rules in the same paragraph. Because the temporary is bound to <em>both</em> a reference parameter in a function call and to a local automatic reference variable. </p>
",1
10759840,10759729,3,"<p>When you create your object in this line</p>

<pre><code>cObj myObj();
</code></pre>

<p>(btw. you probably don't want these parentheses. You want to create an object, not declare a function).</p>

<p>you call the constructor. You can not call it again in switch statement. 
You could create a separate method:</p>

<pre><code>cObj::cObj()
{
}

void cObj::SetFilename(const std::string&amp; filename) {
// ...
}
</code></pre>

<p>and use it like that:</p>

<pre><code>void someThing() {
    cObj myObj;

    switch (someValue)
        case 0:
            myObj.SetFilename(""/some/path"");
            break;
        ...
}
</code></pre>

<p>I'm not sure what you're trying to do, but maybe better way would be to first determine what the filepath is and then create the object?</p>

<pre><code>void someThing() {
    std::string filepath = ""default/path"";

    switch (someValue)
        case 0:
            filepath = ""some/path"";
            break;
        ...

    cObj myObj(flepath);
}
</code></pre>

<p>You could also create a function that would make the decision what path to use and return the object:</p>
",3
10759777,10759729,4,"<p>You don't need a pointer for this.</p>

<pre><code>void someThing() {
    cObj myObj; // Don't use parentheses for the default constructor.
                // What you had was a function declaration, not an object creation.

    switch (someValue) {
        case 0:
            myObj = cObj(""/some/path"");
            break;
        ...
}
</code></pre>

<p>If you didn't have a default constructor, or you didn't want it to be called, then you could use a pointer, preferably smart:</p>

<pre><code>void someThing() {
    std::unique_ptr&lt;cObj&gt; myObj;

    switch (someValue) {
        case 0:
            myObj.reset(new cObj(""/some/path""));
            break;
        ...
}
</code></pre>

<p>Or, as lmmilewski hinted at, you could factor out the decision to a function, and return the object:</p>

<pre><code>cObj choose(someType someValue) {
    switch (someValue) {
        case 0:
            return cObj(""/some/path"");
        ...
}

void someThing() {
    cObj myObj(choose(someValue));
    ...
}
</code></pre>
",2
13698789,5537818,3,"<p>I have found <a href=""http://code.google.com/p/chromium-compact-language-detector/"" rel=""nofollow"">Google's CLD</a> very helpful, it's written in C++, and from their web site:</p>

<p><em>""CLD (Compact Language Detector) is the library embedded in Google's Chromium browser. The library detects the language from provided UTF8 text (plain text or HTML). It's implemented in C++, with very basic Python bindings.""</em></p>
",0
16382614,16382560,0,"<p>Yes. But in your case, it's most likely more efficient to simply read the whole file and parse out the numbers.</p>

<p>You could do something like this (and I'm writing this in pseudocode so you have to acutally write real code, since that's how you learn):</p>

<pre><code>   seek to end of file. 
   pos = current position
   while(pos &gt;= 0)
   {
       read a char from file. 
       if (char == space)
       {
          flag = false;
          process string to fetch out number and add to sum. 
       }
       else
       {
          add char to string
       }
       if (char == newline)
       {
           flag = true;
       }
       pos--
       seek to pos-2
   }
</code></pre>
",0
15808822,15808743,2,"<p>You want this:</p>

<pre><code>int checkEndGame()
{
    for (int j = 0; j &lt; boardHeight; ++j)
    {
        for (int i = 0; i &lt; boardWidth; ++i)
        {
            if (board[i][j] == alive)
                return 0;
        }
    }
    return 1;
}
</code></pre>

<p>Your function returns the moment it sees one <em>dead</em> cell, which is incorrect. You can abort if you see one live cell. But otherwise, you need to check every cell.</p>

<p>Also:</p>

<pre><code>        checkEndGame();
    }
    while (checkEndGame == 0);
</code></pre>

<p>is broken. <code>checkEndGame</code> will never be zero since it's a pointer to a function. You want:</p>

<pre><code>}
while (checkEndGame() == 0);
</code></pre>
",1
15808870,15808743,0,"<p>a
You function should be like that:</p>

<pre><code>int checkEndGame()
 {
 for (int j = 0; j &lt; boardHeight; ++j)
  {
    for (int i = 0; i &lt; boardWidth; ++i)
    {
        if (board[i][j] == alive){return 0; }
    }
  }

 return 1;
}
</code></pre>

<p>Because you either find ""alive"" and say game is not over yet, or have to go through the hole board and then say the game is over because you haven't found ""alive"".</p>

<p>And as said before:</p>

<pre><code>while(checkEndGame==0) 
</code></pre>

<p>doesn't run the function to see what the returned value is, done this way all it does is checking if the memory address of you function is 0 (which it will most certainly never be unless you assign it).</p>

<p>to run the function and see the returned value you have to write:</p>

<pre><code>while(checkEndGame()==0)
</code></pre>

<p>(notice the ""()"" at the end)</p>
",0
16391667,16391602,5,"<p>In your loop, you're reassigning <code>totalPayroll</code> the value of <code>stoi(line) + stoi(line)</code> for every line, so it ends up finally being 2*789.</p>

<p>You need to keep a continuous sum:</p>

<pre><code>totalPayroll = totalPayroll + stoi(line);
</code></pre>

<p>This also has a short form using a compound assignment operator, which does the same thing:</p>

<pre><code>totalPayroll += stoi(line);
</code></pre>
",0
16391671,16391602,2,"<p>As chris mentioned in his comment, <code>totalPayroll += stoi(line);</code> should solve your problem.</p>

<p>The C++ operator <code>+=</code> is a shorthand way of writing <code>totalPayroll = totalPayroll + stoi(line);</code>. It adds the value given on the righthand side of the operator to the current value of the variable.</p>
",3
10109489,10109434,4,"<p>This is a cross-platform function I use:</p>

<pre><code>unsigned Util::getTickCount()
{
#ifdef WINDOWS
    return GetTickCount();
#else
    struct timeval tv;
    gettimeofday(&amp;tv, 0);
    return unsigned((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
#endif
}
</code></pre>
",1
10109945,10109434,10,"<p>If you have boost you can do it this way:</p>

<pre><code>#include &lt;boost/thread.hpp&gt;

int main()
{
  boost::this_thread::sleep(boost::posix_time::millisec(2000));
  return 0;
}
</code></pre>

<p>This simple example, as you can see in the code, sleeps for 2000ms.</p>

<p>Edit:</p>

<p>Ok, I thought I understood the question but then I read the comments and now I'm not so sure anymore.</p>

<p>Perhaps you want to get how many milliseconds that has passed since some point/event? If that is the case then you could do something like:</p>

<pre><code>#include &lt;boost/chrono.hpp&gt;
#include &lt;boost/thread.hpp&gt;
#include &lt;iostream&gt;


int main()
{
  boost::chrono::high_resolution_clock::time_point start = boost::chrono::high_resolution_clock::now();
  boost::this_thread::sleep(boost::posix_time::millisec(2000));
  boost::chrono::milliseconds ms = boost::chrono::duration_cast&lt;boost::chrono::milliseconds&gt; (boost::chrono::high_resolution_clock::now() - start);
  std::cout &lt;&lt; ""2000ms sleep took "" &lt;&lt; ms.count() &lt;&lt; ""ms "" &lt;&lt; ""\n"";
  return 0;
}
</code></pre>

<p>(Please excuse the long lines)</p>
",0
12352439,12350540,1,"<p>I would create a single simple <code>Foo</code> wrapper class which can look up members data from the C API, and present it as a coherent class. No need for messing about with interfaces, virtual functions or inheritance for that. Just a single class will do.</p>

<p>So for each ""Foo""-entry  in the C API, you create a single Foo wrapper.</p>

<p>Then you have simple, well-behaved type representing individual instances of the data stored in your C library.</p>

<p>Now just take that and put it in a <code>std::vector</code>.</p>

<pre><code>struct Foo {
    Foo(&lt;handle-or-pointer-to-library-data&gt;);

    // member functions for retrieving member data from the C API
};


std::vector&lt;int&gt;
std::vector&lt;bool&gt;
std::vector&lt;std::string&gt;
std::vector&lt;Foo&gt;
</code></pre>

<p>As I understand your problem, that would be a simple and efficient solution.</p>
",0
12836581,12836330,1,"<p>Since the <code>std</code> is getting the object by dereferencing the iterator, I'd say:</p>

<pre><code>std::shared_ptr&lt;T&gt; operator*() { return _i; }
</code></pre>

<p>Also, note that if you're just trying to call methods on <code>T</code>, you don't need to get the pointer first, because <code>operator-&gt;()</code> is chaining. That means that</p>

<pre><code>it-&gt;foo();
</code></pre>

<p>will call <code>T::foo()</code> even though <code>it.operator-&gt;()</code> returns a shared poitner.</p>
",3
12836607,12836330,0,"<p>What about this solution?</p>

<pre><code>std::shared_ptr&lt;T&gt; operator()(){...}  
</code></pre>
",3
12836471,12836330,2,"<p>If you can edit the code you can add a simple <code>get</code> function that return the internal <code>shared_ptr</code>!! It's better than calling <code>operator-&gt;</code> directly, isn't it??</p>
",0
12836501,12836330,1,"<p>In terms of iterators you have to write  <code>operator*()</code> to dereference it. Actually it's your iterator and you can write anything you want. But since C++ programmers use <code>std</code> widely, better if you will use <code>operator*()</code> because its more clear for understanding.</p>
",0
13420476,13420410,4,"<p>In test code, and if you are <em>certain</em> that the user of the interface isn't going to mutate the char*, maybe you could use a <code>const_cast</code>?</p>

<p>That assumes the caller doesn't take ownership of the <code>char *</code>; if that is the case, then you should make a copy.</p>
",0
13420490,13420410,4,"<p>If you're absolutely certain that the interface function will not modify the string, you can use </p>

<pre><code>*result = const_cast&lt;char *&gt;((resultsI++)-&gt;c_str());
</code></pre>

<p>to remove <code>const</code>ness. </p>

<p>Otherwise, another option is to switch from using <code>std::vector&lt;std::string&gt;</code> to <code>std::vector&lt;std::vector&lt;char&gt;&gt;</code> but then you'll have to make sure you properly null terminate the strings.</p>
",0
13420493,13420410,6,"<p>Try:</p>

<pre><code>*result = &amp;(*resultsI++)[0];
</code></pre>

<p>Although this isn't guaranteed to work prior to C++11 it is known to be OK on most or all current compilers.</p>

<p>The danger is that if the function tries to change the length of the string, you could get some nasty errors. Changing individual characters should be OK.</p>
",5
11164416,11164394,26,"<p>This is known as <em>value-initialization</em>. From the C++03 standard, ¡ì8.5/7:</p>
<blockquote>
<p>An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized.</p>
</blockquote>
<p>And from ¡ì8.5/5:</p>
<blockquote>
<p>To <em>value-initialize</em> an object of type <code>T</code> means:</p>
<ul>
<li>if <code>T</code> is a class type with a user-declared constructor, then the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);</li>
<li>if <code>T</code> is a non-union class type without a user-declared constructor, then every non-static data member and base-class component of <code>T</code> is value-initialized;</li>
<li>if <code>T</code> is an array type, then each element is value-initialized;</li>
<li>otherwise, the object is zero-initialized</li>
</ul>
<p>To <em>zero-initialize</em> an object of type <code>T</code> means:</p>
<ul>
<li>if <code>T</code> is a scalar type, the object is set to the value of <code>0</code> (zero) converted to <code>T</code>;</li>
<li>if <code>T</code> is a non-union class type, each nonstatic data member and each base-class subobject is zero-initialized;</li>
<li>if <code>T</code> is a union type, the object¡¯s first named data member) is zero-initialized;</li>
<li>if <code>T</code> is an array type, each element is zero-initialized;</li>
<li>if <code>T</code> is a reference type, no initialization is performed.</li>
</ul>
</blockquote>
<p>So in your case, it depends on the definition of <code>SpiHandleT</code>:</p>
<ul>
<li>If it's a scalar, it will be zero-initialized</li>
<li>If it's a class type <em>without</em> a user-declared constructor, its subobjects will be (recursively) value-initialized</li>
<li>If it's a class type <em>with</em> a user-declared constructor, it will be default-constructed</li>
</ul>
",0
12280024,12279819,0,"<p>If I get you right, you just need to write a class template:</p>

<pre><code>template &lt;typename T&gt;
class ValueSetter
{
public:
    explicit ValueSetter(std::vector&lt;T&gt; values): _values(values)
    {
    }
    virtual void operator()(const T value, const int index) const
    {
        _container-&gt;values[index].value.i = value;
    }
// etc.
};
</code></pre>
",7
12280025,12279819,0,"<p>I guess I'm looking for something like this. I've only implemented for int below, but each type would get its own interface class and implementation class. I'd love to hear your comments on this approach!</p>

<pre><code>template&lt;typename V&gt;
class IValueSetter
{
public:
};

template&lt;&gt;
class IValueSetter&lt;std::string&gt; 
{
public:
    virtual void operator()(const std::string&amp; value, int index) const = 0;
};

template&lt;typename V&gt;
class ValueSetter
{
};

template&lt;&gt;
class ValueSetter&lt;std::string&gt;: public IValueSetter&lt;std::string&gt;
{
public:
    explicit ValueSetter2(CContainer* container)
        : _container(container)
    {
    }

    void operator()(const std::string&amp; value, int index) const
    {
        _container-&gt;values[index].value.s = _strdup(value.c_str());
    }

private:
    CContainer* _container;
};

template&lt;&gt;
class NewValueSetter&lt;std::string&gt;: public IValueSetter&lt;std::string&gt;
{
public:
    explicit NewValueSetter(std::shared_ptr&lt;std::list&lt;std::string&gt;&gt; values)
        : _values(values)
    {
    }

    void operator()(const std::string&amp; value, int index) const
    {
        (*values)[index] = value;
    }

private:
    std::shared_ptr&lt;std::list&lt;std::string&gt;&gt; _values;
};
</code></pre>
",0
12280077,12279819,4,"<p>Just do the obvious. There's no requirement that a template specialization have anything in common with another specialization or with the original template. So:</p>

<pre><code>class IIntValueSetter {
};

template &lt;class Ty&gt; class ValueSetter; // declared but not defined

template &lt;&gt;
class ValueSetter&lt;int&gt; : public IIntValueSetter {
    // whatever
};

ValueSetter&lt;int&gt; vsi;
</code></pre>
",3
16914205,16914164,4,"<p>Making the assumption that you aren't doing anything more than just the simple test, go with:</p>

<pre><code>bool MyClass::hasCContainerValues(CContainer* container) const
{
    return (container &amp;&amp; container-&gt;nrOfValues&gt;0);
}
</code></pre>

<p>However, if you were to do more, then it is sometimes thought that a single exit point is better (various static analysis rulesets complain about multiple exit points, <a href=""http://www.codingstandard.com/HICPPCM/High_Integrity_CPP_Rule_5.9.html"" rel=""nofollow noreferrer"">rightly</a> or <a href=""https://softwareengineering.stackexchange.com/q/18454"">wrongly</a>):</p>

<pre><code>bool MyClass::hasCContainerValues(CContainer* container) const
{
    bool retval = false;
    if(container &amp;&amp; container-&gt;nrOfValues&gt;0) 
    {
        // something else here perhaps
        retval = true;
    }
    return retval;
}
</code></pre>

<p>Also, as an aside, if you're only testing the content, then you could probably make the method <code>const</code>, but that's irrelevant to your question.</p>
",5
16914209,16914164,2,"<p>Assuming that it is an example and you don't want to do just <code>return (container &amp;&amp; container-&gt;nrOfValues&gt;0)</code>, they are both OK and equally correct.</p>

<p>The rest is personal opinion/taste and it will create a religious war here.
I personally prefer the first, but might choose either depending on complexity of both clauses i.e. logic in <code>true</code> and <code>false</code> path.</p>
",0
16914232,16914164,1,"<p>It doesn't really matter ... If you use a modern compiler, it will optimize and transform your code. 
Your 2 snippets can produce exactly the same code.</p>
",4
16914413,16914164,0,"<p>Well, the shorter form of code doesn't hurt the code readibility so it is better to use the shorter form which is, the first one. Because is is readable and in has less lines of code. </p>
",0
11133604,11133524,0,"<p><code>operator ==</code> is a binary operator. To make it <code>virtual</code>, it must be a class member.</p>

<pre><code>class IC
{
    virtual bool operator==(const IC&amp; b) = 0;
};
</code></pre>

<p>In this case, the first argument to <code>==</code> is implicitly <code>this</code>.</p>

<p>Your declaration is about a free function, not a class member.</p>

<p>EDIT: As suggested in the comments, you should avoid this and rather implement a <code>compare</code> function or similar.</p>
",6
11502978,11502955,3,"<blockquote>
  <p>I would like all my interface and abstract classes to inherit this class. Is it a good practice?</p>
</blockquote>

<p>It sounds good. The benefits are more like that of <a href=""https://stackoverflow.com/questions/7823990/what-are-the-advantages-of-boostnoncopyable""><code>noncopyable</code></a> class.</p>

<p>Any class deriving from them looks like documented just  by having a <em>quick</em> glance, otherwise one has to <em>see the declaration</em> of destructor to ensure whether the destructor is <code>virtual</code> or not.</p>

<p>Making the <em>default</em> constructor <code>protected</code> would be a good idea:</p>

<pre><code>class IHaveVirtualDestructor
{
  protected:
     virtual ~IHaveVirtualDestructor() {} //make it protected as well
     IHaveVirtualDestructor() {}
};
</code></pre>

<p>A better name is probably needed:</p>

<ul>
<li>AbstractBase</li>
<li>PolymorphicObject (taken from @James Kanze's answer)</li>
</ul>
",13
11503043,11502955,0,"<p>All subclasses will have implicit virtual distructor if base class distructor is defined virtual. It will be even better if you define distructor as pure virtual if its purpose is to make compulsion to subclasses define virtual distructor,</p>
",7
11503126,11502955,3,"<p>I'm not sure it's worth the effort, but if I were to do it, I'd give the class a name which expresses its purpose, not its implementation.  Something like <code>Interface</code> or <code>PolymorphicObject</code>.</p>
",5
11503353,11502955,3,"<p>It depends on whether you think it's harder to forget to add a virtual destructor to a class or to add IHaveVirtualDestructor as a base class. </p>

<p>If I where afraid of such errors, I would tend to use a static code analyzer.</p>

<p>And think about the reader of the class. The IHaveVirtualDestructor have to be looked up. Seeing a virtual, inlined and empty destructor is much more idiomatic.</p>

<p>Kind regards
Torsten</p>
",0
8798229,8798127,1,"<p>The code runs fine for me. However you never check if the file is successfully opened for writing, so it could be silently failing on your system. After you open <code>ofs</code> you should add</p>

<pre><code>if (!ofs) {
    std::cout &lt;&lt; ""Could not open file for writing"" &lt;&lt; std::endl;
    return 1;
}
</code></pre>

<p>And the same thing after you open <code>ifs</code></p>

<pre><code>if (!ifs) {
    std::cout &lt;&lt; ""Could not open file for reading"" &lt;&lt; std::endl;
    return 1;
}
</code></pre>

<p>Or something along those lines. Also I do not understand why you check if the file exists first since you do the same whether it exists or not.</p>
",3
9137578,9137563,0,"<p>The following will give you an empty <code>set</code> object:</p>

<pre><code>std::set&lt;std::string&gt;()
</code></pre>
",2
9137596,9137563,6,"<p>In order to set the default to <code>NULL</code>, you'd have to be passing an <code>std::set&lt;std::string&gt;*</code>, not a reference to a value type.</p>

<p>Furthermore, if you are passing a non-pointer type and you want to assign <em>any default value at all</em>, it has to be a <code>const</code> reference, because you can't (advisably!) assign a temporary to it otherwise.</p>

<p>So your choices for ""default"" values are basically:</p>

<pre><code>std::set&lt;std::string&gt;* = NULL
</code></pre>

<p>or:</p>

<pre><code>const std::set&lt;std::string&gt;&amp; = std::set&lt;std::string&gt;()
</code></pre>

<p>or option 3, using function overloading more directly:</p>

<pre><code>void myfunction() {dothing(0);}
void myfunction(std::set&lt;std::string&gt;&amp; optional_param) 
{ dothing(optional_param.size()); }
</code></pre>

<p>or option 4, having a corresponding <code>bool</code> indicating whether parameter is ""set"":</p>

<pre><code>void myfunction(std::set&lt;std::string&gt;&amp; param, bool param_has_meaning=true) {}
</code></pre>

<p>It looks like you're already on the track to the third option. You just need to write two definitions, one with and one without the parameter.</p>
",2
9137612,9137563,1,"<p>You can't have a <code>NULL</code> <em>reference</em> in C++.</p>

<p>The simplest way would be to have a dummy empty <code>set</code>:</p>

<pre><code>std::set&lt;std::string&gt; empty;
void func(int a, std::set&lt;std::string&gt;&amp; temp = empty)
{
    // ...
}
</code></pre>

<p>You can then call:    </p>

<pre><code>    func(1);
</code></pre>

<p>Neater, still, would be to use function overloading to create a wrapper so that you have no need to default:</p>

<pre><code>void func(int a, std::set&lt;std::string&gt;&amp; temp)
{
}

void func(int a)
{
    std::set&lt;std::string&gt; empty;
    func(a, empty);
}

    // And then...
    func(1);
</code></pre>

<p>All this assumes that if you pass in a <code>set</code> you're going to modify it somehow. It's not clear from your question what your intention is but I've made the assumption on the basis that your reference is non-<code>const</code>. If I've miscalculated, then the answer is even simpler:</p>

<pre><code>void func(int a, const std::set&lt;std::string&gt;&amp; temp = std::set&lt;std::string&gt;())
{
}
</code></pre>
",3
9137633,9137563,1,"<p>You have the right idea - using a reference. However, a reference cannot be NULL by default, like a pointer can. Therefore, what you probably want to do is overload the function so that you use <code>void func(int a)</code> when you don't want to pass a set as a parameter and use <code>void func( int a, std::set&lt;std::string&gt;&amp; temp)</code></p>

<p>This way, you can actually provide two separate implementations - one that works on a set and one that doesn't. From a usage point of view, it would have the same effect as a default parameter. From a coding point of view, each implementation would have a clearer purpose.</p>

<p>If you're not going to be modifying the set, might I suggest using a const reference instead:</p>

<pre><code>void func( int a, const std::set&lt;std::string&gt;&amp; temp )
</code></pre>
",0
11857635,11857604,3,"<p>Your <code>operator[]</code> returns a temporary (rvalue), which makes each one of its members an <em>rvalue</em>. The language forbids assigning to an rvalue (to be precise, assigning to an rvalue of non-class type), and that is what the error is telling you.</p>

<p>The reason for that restriction is that since the left hand side will be destroyed at the end of the full expression, the assignment would not make much sense (it will be forgotten with the temporary destruction). </p>

<p>If you meant to modify the element held inside the class, you need to return a reference (<em>lvalue</em>) to the stored element, rather than a copy.</p>
",0
11857636,11857604,5,"<p>Your <code>operator[]</code> returns by value, which means that it makes a temporary copy and returns that.  Temporaries are rvalues.  You should modify your operator to return a reference.  Actually, you should have two versions, a const version, which returns a const reference, and a non-const version, which returns a non-const reference.</p>

<p>Your method of handling an out of range index will have to change though.  You can either throw an exception, or simply leave it as undefined behavior, just be sure to document it.  Another option would be to have a dummy <code>MsgBodyData</code> object in the class that you return when you get a bad index, but that seems like a very silly design.</p>
",4
12323103,12323049,15,"<pre><code>LegacyFunction(ModernFunction().c_str());
</code></pre>

<p>Destruction of copy will be after evaluation of <code>full expression</code> (i.e. after return from <code>LegacyFunction</code>).</p>

<p>n3337 12.2/3
<Blockquote><P>
Temporary objects are destroyed as the last step
in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.
</P></Blockquote></p>

<p>n3337 1.9/10
<Blockquote><P>
A full-expression is an expression that is not a subexpression of another expression. If a language construct
is defined to produce an implicit call of a function, a use of the language construct is considered to be an
expression for the purposes of this definition. A call to a destructor generated at the end of the lifetime of
an object other than a temporary object is an implicit full-expression. Conversions applied to the result of
an expression in order to satisfy the requirements of the language construct in which the expression appears
are also considered to be part of the full-expression.
[ Example:</p>

<pre><code>struct S {
S(int i): I(i) { }
int&amp; v() { return I; }
private:
int I;
};
S s1(1); // full-expression is call of S::S(int)
S s2 = 2; // full-expression is call of S::S(int)
void f() {
if (S(3).v()) // full-expression includes lvalue-to-rvalue and
// int to bool conversions, performed before
// temporary is deleted at end of full-expression
{ }
}
</code></pre>

<p></P></Blockquote></p>
",0
12323166,12323049,9,"<blockquote>
  <p>There is a temporary string object that exists after ModernFunction has returned. When does it go out of scope?</p>
</blockquote>

<p>Strictly speaking, it's never <em>in</em> scope. Scope is a property of a name, not an object. It just so happens that automatic variables have a very close association between <em>scope</em> and <em>lifetime</em>. Objects that aren't automatic variables are different.</p>

<p>Temporary objects are destroyed at the end of the full-expression in which they appear, with a couple of exceptions that aren't relevant here. Anyway the special cases <em>extend</em> the lifetime of the temporary, they don't reduce it.</p>

<blockquote>
  <p>Is it possible for the compiler to call c_str(), destruct this temporary string object, and then pass a dangling pointer to LegacyFunction</p>
</blockquote>

<p>No, because the full-expression is <code>LegacyFunction(ModernFunction().c_str())</code> (excluding the semi-colon: feel that pedantry), so the temporary that is the return value of <code>ModernFunction</code> is not destroyed until <code>LegacyFunction</code> has returned.</p>

<blockquote>
  <p>If it's safe, why?</p>
</blockquote>

<p>Because the lifetime of the temporary is long enough.</p>

<p>In general with <code>c_str</code>, you have to worry about two things. First, the pointer it returns becomes invalid if the string is destroyed (which is what you're asking). Second, the pointer it returns becomes invalid if the string is modified. You haven't worried about that here, but it's OK, you don't need to, because nothing modifies the string either.</p>
",0
10106521,10106405,11,"<p>It's not legal because you can't use a statement as an expression.</p>

<p>So, it's not the declaring a variable inside an <code>if</code> that's illegal, but the comparison.</p>

<p>Just like:</p>

<pre><code>(int x = 3) == 3;
</code></pre>

<p>is illegal, whereas</p>

<pre><code>int x = 3;
x == 3;
</code></pre>

<p>isn't.</p>
",8
10108196,10106405,0,"<p>If you don't want to litter in your scope, you can use §Ñ <code>{}</code> block:</p>

<pre><code>...
{
  int val;
  if((val = getvalue()) == 3) { 
  ... 
  }
}
...
</code></pre>

<p><code>val</code> will be destroyed at the last <code>}</code> and won't be visible afterwards.</p>
",0
11578712,11578659,3,"<p>It seems you are looking for <a href=""http://en.cppreference.com/w/cpp/io/basic_ostringstream"" rel=""nofollow""><code>std::ostringstream</code></a>.</p>
",0
11578774,11578659,4,"<p>You can use <code>ostringstream</code>:</p>

<pre><code>std::ostringstream oss;
std::ostream &amp;os = oss;
os &lt;&lt; ""Hello"" &lt;&lt; endl;

std::string str = oss.str(); // str == ""Hello\n""
</code></pre>
",0
9812781,9812726,5,"<p>I'm assuming that you are using gcc, and hence the VLA extension.  This is not standard C++ and it was dropped from C++0x (1x).</p>

<p>The reasoning is that it is not really all that useful and that a C++ implementation would be much more complex than one in C due to the stronger type system.  </p>

<p>Really, if you are stack allocating arrays of unknown size, you are at the same time writing dangerous code that may very well blow the stack. If you know the size then it is a non-issue, otherwise just dynamically allocate it.  There are of course perfectly valid use cases and it is a ""nice to have"" feature, but they ultimately decided against it.</p>

<p><a href=""http://groups.google.com/group/comp.std.c++/browse_thread/thread/2bfe25800d4961e8/9545494bbb336dfa"" rel=""noreferrer"">Here is a good run down on the subject.</a> </p>
",1
9812786,9812726,0,"<p>The compiler just has to increase the stack size and point the buf variable at the newly created space on the stack. There is no reason this can't be done dynamically given a size at runtime. (Although it may not be wise to do from a programming perspective.)</p>
",2
9812787,9812726,4,"<p>A conforming C++ compiler won't accept your code. Despite being a <code>const</code>, <code>j</code> isn't a constant expression.</p>

<p>gcc accepts this in C++ code as an extension (according to the language standards, it's only permitted in C99 code). Basically, it's allocating space on the stack for <code>buf</code>. It (typically) does that by subtracting some amount from the current stack pointer. From a viewpoint of the code that's generated, it's pretty trivial to deal with that being non-constant on a typical machine.</p>
",4
12803230,12802970,0,"<p>Regarding directory paths to headers, I agree with the other posters.</p>

<p>In case you need to replace a certain pattern recursively in files, then you should learn how to use <code>find</code> and <code>sed</code>for this (in case you are on a Unixoid OS).</p>

<p>The solution in your case would look like</p>

<pre><code>find . -name \*.cpp -exec sed -i -e 's/old/new/g' {} \;
</code></pre>

<p>I bet you will need to make use of this at some point in your life 8^)</p>
",2
12803041,12802970,5,"<p>I'd recommend that you add your <code>headers</code> directory to the include path somewhere in project options instead.</p>
",3
17081273,17061955,1,"<p>There are several good solutions here already. But for the sake of completeness I'd like to add this one. If you don't want to rely on <code>boost::optional</code> you may easily implement your own class like</p>

<pre><code>class SearchResult
{
    SearchResult(std::string stringFound, bool isValid = true)
        : m_stringFound(stringFound),
        m_isResultValid(isValid)
    { }

    const std::string &amp;getString() const { return m_stringFound; }
    bool isValid() const { return m_isResultValid; }

private:
    std::string m_stringFound;
    bool m_isResultValid;
};
</code></pre>

<p>Obviously your method signature looks like this then</p>

<pre><code>const SearchResult&amp; find_response(const std::string&amp; id) const;
</code></pre>

<p>But basically that's the same as the boost solution.</p>
",0
8804920,8804853,5,"<p><code>_Exit(2)</code> is from C99. <code>_exit(2)</code> is from POSIX. At least, according to the manpage I have installed here.</p>

<p>They are entirely equivalent.</p>
",0
8804947,8804853,5,"<p>Right from the man page <a href=""http://www.kernel.org/doc/man-pages/online/pages/man2/exit.2.html"" rel=""nofollow noreferrer"">here</a>: </p>

<blockquote>
  <p>The function _Exit() is equivalent to _exit().</p>
</blockquote>

<p>Although in C++11, it is standardized as either std::_Exit or std::quick_exit. According to <a href=""https://stackoverflow.com/users/204847/mike-seymour"">Mike Seymour</a> <a href=""https://stackoverflow.com/questions/8804643/how-to-abort-a-c-program-and-exit-with-status-0/8804676#8804676"">here</a>.</p>
",1
13426282,13321922,2,"<p>As with everyone else, I recommend you should just use <code>weak_ptr</code>. But you asked why your approach doesn't work as well. There are some issue of elegant implementation and separation of concerns that your code walks all over, but I won't argue those. Instead, I'll just point out that your code is horribly not thread-safe.</p>

<p>Consider the following execution sequence of two threads of control:</p>

<pre><code>// Thread One
if ( ! ptr -&gt; isDestroyed() ) {     // Step One
    // ... interruption ...
    ptr -&gt; something();             // Step Three
</code></pre>

<p>And the other:</p>

<pre><code>// Thread Two
ptr -&gt; destroy();                   // Step Two
</code></pre>

<p>By the time step 3 comes around, the pointer is no longer valid. Now it's possible to fix this by implementing <code>lock()</code> or similar, but now you've incurred the possibility of defects about not releasing locks. The reason that everyone is recommending <code>weak_ptr</code> is that this whole class of problems has been worked out both in the interface of the class and its implementations.</p>

<p>One issue remains. You seem to want a facility where you can kill an object at will. This is the tantamount to requiring that the only pointers to an object are weak ones, that no strong ones are present that would break when the object was manually deleted. (I'll stipulate that this isn't a bad idea, though I must say I don't know why it's not in your case.) You can get this by building on top of <code>weak_ptr</code> and <code>shared_ptr</code>. These classes are generic, so if you want to disallow <code>shared_ptr</code> access to <code>BaseClass</code>, then you can write a specialization for <code>shared_ptr&lt;BaseClass&gt;</code> that behaves differently. Hide one instance of <code>shared_ptr&lt;BaseClass&gt;</code> to prevent deletion and provide such pointers through a factory method under your control.</p>

<p>In this model the semantics of <code>destroy()</code> need attention. The first choice is whether you want synchronous or asynchronous operation. A synchronous <code>destroy()</code> would block until all external pointers are released and not allow the issuing of new ones. (I'll assume that copy constructors are already disabled on the pointer.) There are two kinds of asynchronous <code>destroy()</code>. The simpler of the two fails if there still exist external references. Calling <code>unique()</code> on the hidden <code>shared_ptr()</code> makes this an easy implementation. The more complicated one acts like an asynchronous I/O call, scheduling the destruction to happen at some point in the future, presumably as soon as all external references are gone. This function might be called <code>mark_for_death()</code> to reflect the semantics, since the object might or might not be destroyed at return time.</p>
",2
13425371,13321922,5,"<p>You got some nasty comments to your question. Now I don't think they are deserved although there may be better ways to do what you want. I understand where you are coming from but actually you are using the destructor the same way you would use the reset function you refuse to write. Actually you gain nothing from calling a destructor  since calling a distructor has nothing to do with actually deleting or resetting anything unless you actually write the code to do it within the destructor. </p>

<p>As to your question about the placement new:</p>

<p>As you may know already the placement new doesn't allocate any memory so calling it will just create the object in the same place. I understand that is exactly what you want but it's just not ncessary. Since you don't call delete on your object just destroy, you can set destroyed to true without initializing the class.</p>

<p>To sum it up:</p>

<ol>
<li>If you use the destructor as a regular virtual function you gain nothing. Don't do it since you can get into trouble if a destructor is called twice</li>
<li>A call to a placement new will not allocate memory and just perform needless initialization. You can just set destroyed to true.</li>
</ol>

<p>To do what you want to do correctly and gain the benefits of destructors, you should overload the new and delete operators of your classes and use the normal  destruction mechanism. You can then opt not to release the memory but mark it as invalid or maybe release most of the memory but leave the pointer pointing to some flags.</p>

<p><strong>EDIT</strong></p>

<p>Following the comments I decided to sum up all the risks I see and the risks that others have pointed out:</p>

<ol>
<li>Accessing invalid pointer in a multi-threaded environment: Using your method a class may be accessed after the destructor has run but before the destroyed flag is set (As to your question in one of the comments - shared_ptr is for most purposes thread safe)</li>
<li>Relaying on a behavior you don't totally control: Your method relies on the way destructors auto call the destructors of other members which are not dynamically allocated: This means that you still have to release dynamically allocates memory specifically, You have no control on how exactly this is implemented, You have no control on the order in which other destructors are called.</li>
<li>Relaying on a behavior you don't totally control (Point 2): You are relaying on the way a compiler implements the part of the destructor which calls other destructors you have no way in telling whether your code will be portable or even how will it handle calling it twice.</li>
<li>Destructors may be called twice: Depending on your implementation this may cause memory leaks or heap corruption unless you guard against releasing the same memory twice. You claim you guard against that case by calling the placement new - However in a multi-threading environment this is not guaranteed further more you assume that all memory allocations are done by the default constructor - depending on your specific implementation this may or may not be true.</li>
<li>You are going against the better judgment of everyone that answered your question or commented on it - You may be onto something genius but most probably you are just shooting yourself in the leg by limiting your implementation to a small subset of situations where it will work correctly. It is like when you use the wrong screwdriver you will eventually end up damaging the screw. In the same way using a language construct in a way it was not intended to be used may end up with a buggy program - Destructors are intended to be called from delete and from the code generated by the compiler to clear the stack. Using it directly is not wise.</li>
</ol>

<p>And I repeat my suggestion - overload delete and new for what you want</p>
",13
20404503,9347052,0,"<pre><code>string str = ""test"";
anyFunction(str[x]);
</code></pre>

<p>The [ ] operator provides you with a char and if any function expects string, then surely an error will occur. But you can always try this sneaky conversion:</p>

<pre><code>string str = ""test"";
char c = str[x];
string temp = c;
anyFunction(temp);
</code></pre>
",0
10807323,10807299,5,"<p>Passing a parameter by reference allows the called function to modify its argument in a way that will be visible to the caller after the function returns, while passing by value means that any changes will be limited in scope to the called function. Therefore passing by (non-const) reference typically signifies that the callee intends to modify the argument or, less commonly, use it as an additional ""return value"".</p>

<p>Additionally, passing by reference means that no copy of the parameter needs to be made; passing by value requires such a copy (which may be detrimental for the memory footprint or runtime performance of your application). For this reason you will often see arguments of class type being passed as a <code>const</code> reference: the callee does not intend to modify the argument but it also wants to avoid a copy being made. Scalar arguments are of very small size, so they do not benefit from this approach.</p>

<p>See also <a href=""https://stackoverflow.com/questions/410593/pass-by-reference-value-in-c"">Pass by Reference / Value in C++</a>.</p>
",2
10807326,10807299,8,"<p>If you call <code>foo(scalar a)</code>, the argument <code>a</code> of type <code>scalar</code> will be COPIED from the caller and foo will have it's own COPY of the original object.</p>

<p>If you call <code>foo(scalar &amp;b)</code>, the argument <code>b</code> will be just a reference to the original object, so you will be able to modify it.</p>

<p>It's faster to pass an object by reference using the &amp;name syntax, since it avoids creating a copy of the given object, but it can be potentially dangerous and sometimes the behavior is unwanted because you simply want an actual copy.</p>

<p>That being said, there's actually an option that disallows the ability to modify the original object for the called function yet avoids creating a copy. It's <code>foo(const scalar &amp;x)</code> which explicitly states that the caller does not want the function <code>foo</code> to modify the object passed as an argument.</p>

<p><strong>Optional</strong> reading, carefully:</p>

<p>There's also a way of passing an argument as a raw pointer which is very rare in modern C++. Use with caution: <code>foo(scalar *a)</code>. The caller has got to provide the address of an object instead of the object itself in this scenario, so the caller would call <code>foo(&amp;a)</code>. For the called function <code>foo</code> to be able to modify the object itself in this case, it would need to <em>dereference</em> the pointer <code>a</code>, like this in <code>foo</code>: <code>*a =</code>. The star in front of the variable name in this case says that we don't want to modify the address that we have received (as a direct result of the calling function providing <code>&amp;a</code>, that is, the address of the object a).</p>
",2
10807362,10807299,1,"<p>Call by value (<code>funcb (scalar a)</code>) will give the function a copy of the argument, so changes made to the argument are not visible to the caller.</p>

<p>Call by reference (<code>funcb(scalar&amp; b)</code>) means that the function operates directly on the argument, so any changes made are directly visible to the caller.</p>

<p>Whether or not call by reference is a good practice depends on the circumstances. If you need the function to modify the argument (and the modifications to be visible to the caller) you obviously want to use call by reference. If you don't want to modify the argument using non-const reference arguments is misleading (since the signature indicates the argument could be changed), so call by value is more apropriate here. Of course for more complex types call by value can have a non-trivial overhead. In these cases call-by-const-reference is preferable (<code>funcc(const scalar&amp; c)</code>)</p>
",0
10807814,10807671,7,"<p>The code you posted is not valid, it will not compile. However, if you consider</p>

<pre><code>class MyClass {
  const int&amp; func (const scalar&amp; a) const {
    // ...
  }
};
</code></pre>

<p>The first <code>const</code> will specify that the return value is constant (i.e. immutable). The second <code>const</code> (<code>const scalar&amp; a</code>) specifies that the function does not modify the value of the value of the argument <code>a</code>. The third const specifies that <code>func</code> is a constant member function, i.e. it does not modify the <code>MyClass</code> instance itself.</p>
",4
10810852,10807671,0,"<p>Since nobody has mentioned it yet: there is absolutely no difference between</p>

<pre><code>const int some_function();
</code></pre>

<p>and</p>

<pre><code>int some_function();
</code></pre>

<p>The <code>const</code> on scalar return types (such as <code>int</code>) is ignored; it only matters for class types. <a href=""https://stackoverflow.com/questions/2169932/"">related</a></p>
",0
11098989,11098971,5,"<blockquote>
  <p><strong>Can you explain for me what the <code>typedef</code> is doing here?</strong></p>
</blockquote>

<pre><code>typedef bool (C::*implementation_defined_bool_type)(bool) const;
</code></pre>

<p><code>typedef</code>s a <strong>pointer to a const member function</strong> of a type <code>C</code>, which takes a <code>bool</code> as input parameter and also returns a <code>bool</code>.</p>

<p>While,     </p>

<pre><code>operator implementation_defined_bool_type() const?
</code></pre>

<p>Takes in an object of type <code>C</code> and returns a type <code>implementation_defined_bool_type</code>.<br>
It is known as an <strong>Conversion Operator</strong>.</p>

<blockquote>
  <p><strong>what is the purpose of it?</strong>     </p>
</blockquote>

<p>It implements the <strong>""Safe Bool Idiom""</strong>, which aims to validate an object in a boolean context.<br>
Note that the <a href=""https://stackoverflow.com/questions/6242768/is-the-safe-bool-idiom-obsolete-in-c11"">Safe Bool Idiom is obsolete</a> with the C++11 Standard.</p>

<p><strong>Good Read:</strong><br>
<a href=""http://www.google.co.in/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CFwQFjAA&amp;url=http://www.artima.com/cppsource/safebool.html&amp;ei=jFPgT-iuH4r3rQekpcz6DA&amp;usg=AFQjCNFFSCg8G7WxPya15C6J1iJapbPcGA"" rel=""nofollow noreferrer"">The Safe Bool Idiom</a></p>
",1
11116278,11116209,3,"<p>Turning a pointer into a number requires reinterpretation:</p>

<pre><code>add = reinterpret_cast&lt;int&gt;(str1);
</code></pre>

<p>But there are all kinds of problems associated with this approach:</p>

<ul>
<li>If sizeof(int) &lt; sizeof(char*) then part of the pointer is lost, you won't be able to restore it.</li>
<li>Some optimizations might turn your code invalid due to unexpected aliasing.</li>
</ul>

<p>If you need a variable which can hold pointers <em>or</em> integers, it would be better to use a union instead.</p>
",3
11116280,11116209,1,"<p>Use <code>reinterpret_cast</code> (see 5.2.10/p4):</p>

<blockquote>
  <p>4 A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is
  implementation-defined. [ Note: It is intended to be unsurprising to those who know the addressing structure
  of the underlying machine. ¡ªend note ]</p>
</blockquote>

<pre><code>static_assert( sizeof( unsigned int ) &gt;= sizeof( &amp;str1[ 0 ] ),  ""warning: use a wider type!"" );
unsigned int add = reinterpret_cast&lt; unsigned int &gt;( &amp;str1[ 0 ] );
</code></pre>
",0
11116261,11116209,4,"<p>If you want to store a memory address in a variable, the correct way is to type the variable as <code>std::intptr_t</code> or <code>std::uintptr_t</code>. That is because these types are <em>guaranteed</em> large enough to hold any memory address:</p>

<pre><code>char * str1 = ""Hello"";
uintptr_t p = (uintptr_t)str1;
</code></pre>

<p>Apart from that, note that the value of <code>str1</code> is already a memory address (it points to <code>H</code>) albeit a different one from the value of <code>&amp;str1</code> (which points to <code>str1</code>).</p>
",6
11117033,11116209,1,"<p>From your comment on Jon's accepted answer:</p>

<pre><code>char str1[] = ""Hello"";
char* str2 = &amp;str1[0];
uintptr_t p = (uintptr_t)str2;
std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;
p = (uintptr_t)&amp;str1[1];
std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;
p = (uintptr_t)&amp;str1[0];
std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;
</code></pre>

<p>This implies your objective is to be able to stream the pointer value in a readable format.  The Standard provides for this in an implementation-defined fashion as follows:</p>

<pre><code>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(const void* p);
</code></pre>

<p>So, perhaps what you really want is satisfied by the C++ style or (concise but less self-doncumenting and compiler-checked) C-style code below:</p>

<pre><code>std::cout &lt;&lt; static_cast&lt;void*&gt;(str1) &lt;&lt; '\n';
std::cout &lt;&lt; (void*)str1 &lt;&lt; '\n';
</code></pre>

<p>(But, if you specifically want a numeric versions, or to ensure it's displayed in hex with no leading 0x or whatever else an implementation may decide upon, then you're back to Jon's suggestion or your own (possibly compile-time checked) logic to find a big enough integral type.</p>
",0
9828183,9827936,5,"<p>I guess <code>Bool</code> is defined like</p>

<pre><code>template &lt;bool B&gt; struct Bool{};
</code></pre>

<p>You can use this for some rudimentary pattern matching:</p>

<pre><code>void exitActions(Bool&lt;true&gt;)  { std::cout &lt;&lt; ""called with true\n""; }
void exitActions(Bool&lt;false&gt;) { std::cout &lt;&lt; ""called with false\n""; }

int main()
{
  exitActions(Bool&lt;true&gt;());  // prints ""called with true""
  exitActions(Bool&lt;false&gt;()); // prints ""called with false""
}
</code></pre>

<p>This of course only makes sense if you overload <code>Bool&lt;true&gt;</code> with <code>Bool&lt;false&gt;</code>. But in the source <a href=""http://accu.org/index.php/journals/252"">http://accu.org/index.php/journals/252</a> (guessed by Marcin), this is the case.</p>

<p>There is also a similar function call</p>

<pre><code>Tran&lt;T,S,T&gt;::entryActions(host_, Bool&lt;false&gt;());
</code></pre>
",2
13485373,13485266,2,"<p>Either put <code>double tic_t;</code> as a global, and <code>#define tic tic_t = clock();</code> or add a <code>#define tictoc_init double tic_t</code> that you use at the top of each method (and change <code>tic</code> as above)</p>

<p>The second way is better since ""doSomething()"" may contain tics and tocs that would overwrite your global variable.</p>
",0
13485583,13485266,18,"<p>I'd implement it as a stack. Then, you can recurse, call it multiple times, do whatever you want, and it won't break, so long as you call <code>toc()</code> after every <code>tic()</code>. As a bonus, you don't have to resort to using macros:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;ctime&gt;

std::stack&lt;clock_t&gt; tictoc_stack;

void tic() {
    tictoc_stack.push(clock());
}

void toc() {
    std::cout &lt;&lt; ""Time elapsed: ""
              &lt;&lt; ((double)(clock() - tictoc_stack.top())) / CLOCKS_PER_SEC
              &lt;&lt; std::endl;
    tictoc_stack.pop();
}

int main(int argc, char *argv[]) {
    tic();
    doSomething();
    toc();
    return 0;
}
</code></pre>
",0
11142350,11142300,4,"<p>It is not possible because you have no declaration of <code>NeutrinoFunctor</code> before the typedef.</p>

<p>The following code, using typedefs within typedefs, is legal:</p>

<pre><code>#include &lt;string&gt;
#include &lt;vector&gt;

template &lt;typename T1, typename T2&gt; struct Foo {};

typedef std::vector&lt;int&gt; IntVector;
typedef std::string String;

typedef Foo&lt;String, IntVector&gt; Bar;

int main() {

  Bar b;

}
</code></pre>
",1
11142376,11142300,1,"<p>It is possible to <code>typedef</code> another <code>typedef</code> (if that is even the right verbage) because the compiler thinks it is just another <code>type</code>. However, your compiler error is due to the fact that it does not know what is <code>NeutrinoFunctor</code>.</p>
",0
11579086,11578946,5,"<p>Just cast it?</p>

<pre><code>time_t t = (time_t) x;
</code></pre>

<p>It will cut of the top 32 bits but you still have over 25 years until you really need 64-bit timestamps. :)</p>

<p>Of course, there might be trouble if your epoch is not the same as the POSIX epoch (1970-01-01 00:00:00).</p>
",9
11160861,8898885,0,"<p>Boost also has an implementation of signal and slots
<a href=""http://www.boost.org/doc/libs/1_49_0/doc/html/signals.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_49_0/doc/html/signals.html</a></p>
",0
8765640,8765218,3,"<p>If you are reading individual lines, you <strong>know</strong> that there is a newline after each read line. Well, except for the last line in the file which doesn't have to be delimited by a newline character for the read to be successful but you can detect if there is newline by checking <code>eof()</code>: if <code>std::getline()</code> was successful but <code>eof()</code> is set, the last line didn't contain a newline. Obviously, this requires the use of the <code>std::string</code> version of <code>std::getline()</code>:</p>

<pre><code>for (std::string line; std::getline(in, line); )
{
    std::cout &lt;&lt; line &lt;&lt; (in.eof()? """": ""\n"");
}
</code></pre>

<p>This should write the stream to <code>std::cout</code> as it was read.</p>

<p>The question asked for the data to be output but with newlines converted to say ""newline!"". You can achieve this with:</p>

<pre><code>for (std::string line; std::getline(in, line); )
{
    std::cout &lt;&lt; line &lt;&lt; (in.eof()? """": ""newline! "");
}
</code></pre>

<p>If you don't care about the stream being split into line but actually just want to get the entire file (including all newlines), you can just read the stream into a <code>std::string</code>:</p>

<pre><code>std::string file((std::istreambuf_iterator&lt;char&gt;(in)),
                 std::istreambuf_iterator&lt;char&gt;());
</code></pre>

<p>Note, however, that this exact approach is probably fairly slow (although I <strong>know</strong> that it can be made fast). If you know that the file doesn't contain a certain character, you can also use <code>std::getline()</code> to read the entire file into a <code>std::string</code>:</p>

<pre><code>std::getline(in, file, 0);
</code></pre>

<p>The above code assumes that your file doesn't contain any null characters.</p>
",4
8766422,8765218,2,"<p>A modification of @Dietmar's answer should do the trick:</p>

<pre><code>for (std::string line; std::getline(in, line); )
{
    std::istringstream iss(line);
    for (std::string word; iss &gt;&gt; word; ) { std::cout &lt;&lt; word &lt;&lt; "" ""; }
    if (in.eof()) { std::cout &lt;&lt; ""newline! ""; }
}
</code></pre>
",0
8769134,8765218,0,"<p>Just for the record, I ended up using this (I wanted to post it 11h ago)</p>

<pre><code>string s0, s1;
while(getline(cin,s0)){
    istringstream is(s0);
    while(is&gt;&gt;s1){
        cout&lt;&lt;s1&lt;&lt;"" "";
    }
    cout&lt;&lt;""newline! "";
}
</code></pre>
",1
11810995,11810986,4,"<p>The code is fine, it will return an int by value with the value of <code>i</code>. </p>
",0
11811018,11810986,6,"<p>This is a perfectly valid C++ code and does exactly what you expect it to do:</p>

<ul>
<li>Have a <strong>local</strong> variable</li>
<li>Have a local reference to that local variable</li>
<li>Make a copy of the variable referenced to by your local reference</li>
<li>Return that copy to a caller (unwind stack, destroying both local variable and a reference to it)</li>
</ul>

<p>Don't worry, you will not end up returning a reference to a local variable this way.</p>
",0
10112085,10111930,3,"<p>Since you have no control over what the <code>getValue()</code> function does, you need to check the return value for NULL before assigning it to the <code>std::string</code>.</p>

<pre><code>std::string value;  // value is an empty string
const char *retVal = NULL;

if( ( retVal = getValue(key) ) != NULL ) {
  value.assign( retVal );
}
</code></pre>
",1
10111974,10111930,5,"<p>First of all, if <code>valueString</code> is local to that function, using the pointer you return will give undefined behavior.</p>

<p>Second, whether returning a null pointer is reasonable will depend on how you use that pointer, of which you've told us nothing.</p>

<p>Unless you absolutely, positively must fiddle with pointers, just return a string and make your life a whole lot easier.</p>
",1
10112015,10111930,0,"<p>Since you are working with <code>std::string</code> values anyway, I would just return a <code>std::string</code> instead of a <code>char*</code>:</p>

<pre><code>std::string getValue(const char *key) 
{ 
    if (key found)
        return valueString; 
    else 
        return std::string(); 
} 
</code></pre>
",1
10112016,10111930,0,"<p>You want a <code>std::string</code> with an out of bound value.  <code>(char *)</code> might not be the ideal way to do it (see <code>boost::optional</code> for a better way), but it will work (assuming you aren't using a stack-local variable) ¡ª <em>if</em> you check for the out of bound value.  That is, the problem here is not really mixing <code>(char *)</code> and <code>std::string</code>, it is that you aren't checking for ""not found"" but blindly assuming something sensible will happen in that case.</p>

<p>Don't assume; determine what you need to do if the key is not found, and check for the <code>NULL</code> (or other out of band, if you choose to use something else).</p>
",0
10112209,10111930,0,"<p>First question: where does the data come from?  You cann't return the
results of <code>c_str()</code> on a local variable; it's undefined behavior, and
you've just been unlucky that it seems to work.  If <code>valueString</code> is
just a copy of some more long lasting data, then you can call <code>c_str</code>
directly on it.  More generally, however: whatever you return, you'll
have to verify that it is valid before trying to use it.  The simplest
solution (but not always possible) is just to use a sentinal value in
the <code>string</code>, e.g.: </p>

<pre><code>std::string
getValue( std::string const&amp; key )
{
    //  ...
    return condition ? valueString : std:;string();
}
</code></pre>

<p>for example, using an empty string as the sentinal.</p>

<p>If the semantics of the function don't provide a convenient sentinal
value&mdash;for example, if the function can return an empty string as a
valid value&mdash;then you'll have to do something else.</p>

<p>If the return value is the result of a lookup in some long
lived container, then you may be able to return a pointer to the element
in the container.  In general, however, pointers pose the problem of
what they point to; if you don't have something whose lifetime is
sufficient, then you don't want to use a pointer.</p>

<p>Another possibility is for the caller to provide the default value:</p>

<pre><code>std::string
getValue( std::string const&amp; key, std::string const&amp; ifNotFound )
{
    // ...
    return condition ? valueString : ifNotFound;
}
</code></pre>

<p>This shifts the responsibility of defining the sentinal off to the
callee.  In cases like string, there's almost always some value that the
callee can't do anything with, and so can use as a sentinal.</p>

<p>The most general alternative is some sort of <code>Fallible</code> or <code>Maybe</code>
class: a class object which combines a status (typically just a <code>bool</code>)
and an instance of the actual data type.  Whether the data are valid or
not depends on the value of the status, so you still have to check that:</p>

<pre><code>Fallible&lt;std::string&gt;
getValue( std::string const&amp; key )
{
    //  ...
    return condition
        ? Fallible&lt;std::string&gt;( valueString )
        : Fallible&lt;std::string&gt;();
}
</code></pre>

<p>This often works out well internally as well:</p>

<pre><code>Fallible&lt;std::string&gt;
getValue( std::string const&amp; key )
{
    Fallible&lt;std::string&gt; results;
    //  ...
    // At some point, I've got a valid return value, so I do:
        results.validate( valueString );
    // in a condition, of course...
    return results;
}
</code></pre>

<p>(Just an example of a frequent and convenient pattern.)</p>
",0
10113541,10111930,4,"<p>It is not a goot idea to report of occurrence of error (if key <em>not</em> found) by returning NULL. In this case you should generate meaningful exception inside the function. Something like <code>NotFoundEx</code>.</p>

<p>if you have no control over that function, you should wrap it into your safe code:</p>

<pre><code>const char* getSafeValue(const char *key)
{
  const char* value = getValue(key);
  if(value == NULL)
    throw NotFoundEx();

  return value;
}


std::string value = getSafeValue(key);
</code></pre>
",0
9149961,9149950,1,"<p>You cannot assign an <code>std::string</code> object to initialize and create a character array.     </p>

<p>You will need to copy the <code>std::string</code> in to the array.</p>

<pre><code>strcpy(myarray,myvar.c_str());
</code></pre>
",0
9149982,9149950,4,"<p>You can do this:</p>

<pre><code>string myvar = ""stringvar"";
const char * myarray = myvar.c_str(); //immutable string
</code></pre>

<p>In this case, the data which<code>myarray</code> points to, lives as long as the lifetime of <code>myvar</code>.</p>

<p>However, if you want a <em>mutable</em> string or, a string which may last longer (or shorter) than the lifetime of <code>myvar</code>, then you've to allocate memory yourself as:</p>

<pre><code>char * myarray = new char[myvar.size()+1]; //mutable string
std::strcpy(myarray, myvar.c_str());

//you've to deallocate the memory yourself as:
delete [] myarray;
</code></pre>
",2
9149991,9149950,1,"<pre><code>string myvar = ""stringvar""
char* myarray = (char*)myvar.c_str();
</code></pre>

<p>It should work.</p>
",0
9149995,9149950,1,"<p>There is error, because <code>char myarray[]</code> is equivalent to <code>char* myarray</code>. It is just a pointer to char. So you need a compatible initializer there (like <code>char*</code> or <code>const char*</code>). But you are trying to pass an instance of <code>string</code> class, that is not a pointer.</p>

<p>If you wish to assign myarray to a string (make it point to the same location) you may do this</p>

<pre><code>char myarray[] = const_cast&lt;char[]&gt; myvar.c_str();
</code></pre>

<p>But in any case, its not good idea, until you definitely know what you're doing.</p>
",0
11572291,5882872,0,"<p>For my program, I wrote the following bit of code that reads every single character of input until ctrl+x is pressed. Here's the code:</p>

<pre><code>char a;
string b;
while (a != 24)
{
cin.get(a);
b=b+a;
}
cout &lt;&lt; b;
</code></pre>

<p>For Ctrl+z, enter this:</p>

<pre><code>char a;
string b;
while (a != 26)
{
cin.get(a);
b=b+a;
}
cout &lt;&lt; b;
</code></pre>

<p>I can't confirm that the ctr+z solution works, as I'm on a UNIX machine, and ctrl+z kills the program. It may or may not work for windows, however; You'd have to see for yourself.</p>
",1
9772411,8763398,3,"<p>As others mentioned, we all agreed temporaries do have storage. </p>

<blockquote>
  <p>why is it illegal to take the address of a temporary?</p>
</blockquote>

<p>Because temporaries are allocated on stack, the compiler is free to use that address to any other purposes it wants to. </p>

<pre><code>int foo()
{
int myvar=5;
return &amp;myvar;
}

int main()
{
int *p=foo();
print(""%d"", *p);
return 0;
}
</code></pre>

<p>Let's say the address of 'myvar' is 0x1000. This program will most likely print 99 even though it's illegal to access 0x1000 in main(). Though, not necessarily all the time.</p>

<p>With a slight change to the above main():</p>

<pre><code>int foo()
{
int myvar=5;
return &amp;myvar; // address of myvar is 0x1000
}

int main()
{
int *p=foo(); //illegal to access 0x1000 here
print(""%d"", *p);
fun(p); // passing *that address* to fun()
return 0;
}

void fun(int *q) 
{
 int a,b; //some variables
 print(""%d"", *q);
}
</code></pre>

<p>The second printf is very unlikely to print '5' as the compiler might have even allocated the same portion of stack (which contains 0x1000) for fun() as well. No matter whether it prints '5' for both printfs OR in either of them, it is <em>purely</em> an unintentional side effect on how stack memory is being used/allocated. That's why it's illegal to access an address which is not <em>alive</em> in the scope.</p>
",1
9779765,8763398,53,"<p>Actually, in the original language design it <em>was</em> allowed to take the address of a temporary. As you have noticed correctly, there is no technical reason for not allowing this, and MSVC still allows it today through a non-standard language extension.</p>

<p>The reason why C++ made it illegal is that binding references to temporaries clashes with another C++ language feature that was inherited from C: Implicit type conversion.
Consider:</p>

<pre><code>void CalculateStuff(long&amp; out_param) {
    long result;
    // [...] complicated calculations
    out_param = result;
}

int stuff;
CalculateStuff(stuff);  //&lt; this won't compile in ISO C++
</code></pre>

<p><code>CalculateStuff()</code> is supposed to return its result via the output parameter. But what really happens is this: The function accepts a <code>long&amp;</code> but is given an argument of type <code>int</code>. Through C's implicit type conversion, that <code>int</code> is now implicitly converted to a variable of type <code>long</code>, <em>creating an unnamed temporary</em> in the process.
So instead of the variable <code>stuff</code>, the function really operates on an unnamed temporary, and all side-effects applied by that function will be lost once that temporary is destroyed. The  value of the variable <code>stuff</code> never changes.</p>

<p>References were introduced to C++ to allow operator overloading, because from the caller's point of view, they are syntactically identical to by-value calls (as opposed to pointer calls, which require an explicit <code>&amp;</code> on the caller's side). Unfortunately it is exactly that syntactical equivalence that leads to troubles when combined with C's implicit type conversion.</p>

<p>Since Stroustrup wanted to keep both features (references and C-compatibility), he introduced the rule we all know today: Unnamed temporaries only bind to const references. With that additional rule, the above sample no longer compiles. Since the problem only occurs when the function applies side-effects to a reference parameter, it is still safe to bind unnamed temporaries to const references, which is therefore still allowed.</p>

<p>This whole story is also described in Chapter 3.7 of Design and Evolution of C++:</p>

<blockquote>
  <p>The reason to allow references to be initialized by non-lvalues was to allow the distinction between call-by-value and call-by-reference to be a detail specified by the called function and of no interest to the caller. For <code>const</code> references, this is possible; for <code>non-const</code> references it is not. For Release 2.0 the definition of C++ was changed to reflect this.</p>
</blockquote>

<p>I also vaguely remember reading in a paper who first discovered this behavior, but I can't remember right now. Maybe someone can help me out?</p>
",0
9780041,8763398,11,"<p>You're right in saying that ""temporaries are not guaranteed to even have storage"", in the sense that the temporary may not be stored in addressable memory. In fact, very often functions compiled for RISC architectures (e.g. ARM) will return values in general use registers and would expect inputs in those registers as well.</p>

<p>MSVS, producing code for x86 architectures, may <em>always</em> produce functions that return their values on the stack. Therefore they're stored in addressable memory and have a valid address.</p>
",0
8763847,8763398,1,"<p>Temporaries do have storage. They are allocated on the stack of the caller (note: might be subject of calling convention, but I think they all use caller's stack):</p>

<pre><code>caller()
{
 callee1( Tmp() );
 callee2( Tmp() );
}
</code></pre>

<p>Compiler will allocate space for the result <code>Tmp()</code> on stack of the <code>caller</code>. You can take address of this memory location - it'll be some address on stack of <code>caller</code>. What compiler does not guarantee is that it will preserve values at this stack address after <code>callee</code> returns. For example, compiler can place there another temporary etc.</p>

<p>EDIT: I believe, it's disallowed to eliminate code like this :</p>

<pre><code>T bar();
T * ptr = &amp;bar();
</code></pre>

<p>because it will very likely lead to problems.</p>

<p>EDIT: here is a <a href=""http://ideone.com/XPt95"" rel=""nofollow"">little test</a>:</p>

<pre><code>#include &lt;iostream&gt;

typedef long long int T64;

T64 ** foo( T64 * fA )
{

 std::cout &lt;&lt; ""Address of tmp inside callee : "" &lt;&lt; &amp;fA &lt;&lt; std::endl;

 return ( &amp;fA );
}

int main( void )
{
 T64 lA = -1;
 T64 lB = -2;
 T64 lC = -3;
 T64 lD = -4;

T64 ** ptr_tmp = foo( &amp;lA );
 std::cout &lt;&lt; ""**ptr_tmp = *(*ptr_tmp ) = lA\t\t\t\t**"" &lt;&lt; ptr_tmp &lt;&lt; "" = *("" &lt;&lt; *ptr_tmp &lt;&lt; "") = "" &lt;&lt; **ptr_tmp &lt;&lt; "" = "" &lt;&lt; lA &lt;&lt; std::endl &lt;&lt; std::endl;

 foo( &amp;lB );
 std::cout &lt;&lt; ""**ptr_tmp = *(*ptr_tmp ) = lB (compiler override)\t**"" &lt;&lt; ptr_tmp &lt;&lt; "" = *("" &lt;&lt; *ptr_tmp &lt;&lt; "") = "" &lt;&lt; **ptr_tmp &lt;&lt; "" = "" &lt;&lt; lB &lt;&lt; std::endl
   &lt;&lt; std::endl;

 *ptr_tmp = &amp;lC;
 std::cout &lt;&lt; ""Manual override"" &lt;&lt; std::endl &lt;&lt; ""**ptr_tmp = *(*ptr_tmp ) = lC (manual override)\t\t**"" &lt;&lt; ptr_tmp &lt;&lt; "" = *("" &lt;&lt; *ptr_tmp &lt;&lt; "") = "" &lt;&lt; **ptr_tmp
   &lt;&lt; "" = "" &lt;&lt; lC &lt;&lt; std::endl &lt;&lt; std::endl;

 *ptr_tmp = &amp;lD;
 std::cout &lt;&lt; ""Another attempt to manually override"" &lt;&lt; std::endl;
 std::cout &lt;&lt; ""**ptr_tmp = *(*ptr_tmp ) = lD (manual override)\t\t**"" &lt;&lt; ptr_tmp &lt;&lt; "" = *("" &lt;&lt; *ptr_tmp &lt;&lt; "") = "" &lt;&lt; **ptr_tmp &lt;&lt; "" = "" &lt;&lt; lD &lt;&lt; std::endl
   &lt;&lt; std::endl;

 return ( 0 );
}
</code></pre>

<p>Program output GCC:</p>

<pre><code>Address of tmp inside callee : 0xbfe172f0
**ptr_tmp = *(*ptr_tmp ) = lA               **0xbfe172f0 = *(0xbfe17328) = -1 = -1

Address of tmp inside callee : 0xbfe172f0
**ptr_tmp = *(*ptr_tmp ) = lB (compiler override)   **0xbfe172f0 = *(0xbfe17320) = -2 = -2

Manual override
**ptr_tmp = *(*ptr_tmp ) = lC (manual override)     **0xbfe172f0 = *(0xbfe17318) = -3 = -3

Another attempt to manually override
**ptr_tmp = *(*ptr_tmp ) = lD (manual override)     **0xbfe172f0 = *(0x804a3a0) = -5221865215862754004 = -4
</code></pre>

<p>Program output VC++:</p>

<pre><code>Address of tmp inside callee :  00000000001EFC10
**ptr_tmp = *(*ptr_tmp ) = lA                           **00000000001EFC10 = *(000000013F42CB10) = -1 = -1

Address of tmp inside callee :  00000000001EFC10
**ptr_tmp = *(*ptr_tmp ) = lB (compiler override)       **00000000001EFC10 = *(000000013F42CB10) = -2 = -2

Manual override
**ptr_tmp = *(*ptr_tmp ) = lC (manual override)         **00000000001EFC10 = *(000000013F42CB10) = -3 = -3

Another attempt to manually override
**ptr_tmp = *(*ptr_tmp ) = lD (manual override)         **00000000001EFC10 = *(000000013F42CB10) = 5356268064 = -4
</code></pre>

<p>Notice, both GCC and VC++ reserve on the stack of <code>main</code> hidden local variable(s) for temporaries and MIGHT silently reuse them. Everything goes normal, until last manual override: after last manual override we have additional separate call to <code>std::cout</code>. It uses stack space to where we just wrote something, and as a result we get garbage.</p>

<p>Bottom line: both GCC and VC++ allocate space for temporaries on stack of caller. They might have different strategies on how much space to allocate, how to reuse this space (it might depend on optimizations as well). They both might reuse this space at their discretion and, therefore, it is not safe to take address of a temporary, since we might try to access through this address the value we assume it still has (say, write something there directly and then try to retrieve it), while compiler might have reused it already and overwrote our value.</p>
",0
8763478,8763398,12,"<p>Certainly temporaries have storage. You could do something like this:</p>

<pre><code>template&lt;typename T&gt;
const T *get_temporary_address(const T &amp;x) {
    return &amp;x;
}

int bar() { return 42; }

int main() {
    std::cout &lt;&lt; (const void *)get_temporary_address(bar()) &lt;&lt; std::endl;
}
</code></pre>

<p>In C++11, you can do this with non-const rvalue references too:</p>

<pre><code>template&lt;typename T&gt;
T *get_temporary_address(T &amp;&amp;x) {
    return &amp;x;
}

int bar() { return 42; }

int main() {
    std::cout &lt;&lt; (const void *)get_temporary_address(bar()) &lt;&lt; std::endl;
}
</code></pre>

<p>Note, of course, that dereferencing the pointer in question (outside of <code>get_temporary_address</code> itself) is a very bad idea; the temporary only lives to the end of the full expression, and so having a pointer to it escape the expression is almost always a recipe for disaster.</p>

<p>Further, note that no compiler is ever required to <em>reject</em> an invalid program. The C and C++ standards merely call for diagnostics (ie, an error <em>or</em> warning), upon which the compiler <em>may</em> reject the program, or it <em>may</em> compile a program, with undefined behavior at runtime. If you would like your compiler to strictly reject programs which produce diagnostics, configure it to convert warnings to errors.</p>
",4
8763639,8763398,4,"<p>Temporary objects do have memory. Sometimes the compiler creates temporaries as well. In poth cases these objects are about to go away, i.e. they shouldn't gather important changes by chance. Thus, you can get hold of a temporary only via an rvalue reference or a const reference but not via a non-const reference. Taking the address of an object which about to go away also feels like a dangerous thing and thus isn't supported.</p>

<p>If you are sure you really want a non-const reference or a pointer from a temporary object you can return it from a corresponding member function: you can call non-const member functions on temporaries. And you can return <code>this</code> from this member. However, note that the type system is trying to help you. When you trick it you better know that what you are diing is the Right Thing.</p>
",1
11545508,11545316,8,"<p>Your code is ambiguous and should not compile (it is <em>ill-formed</em> per 13.3.3:2).</p>

<p>lvalue-to-rvalue conversion has the same rank as identity conversion, so (per 13.3.3:1) there is no way to choose between them.</p>

<p><a href=""http://www.comeaucomputing.com/tryitout"" rel=""nofollow"">Comeau C++</a> (probably the most standards-compliant compiler) gives the following error:</p>

<pre><code>""ComeauTest.c"", line 11: error: more than one user-defined conversion from ""B"" to
          ""A"" applies:
            function ""B::operator A()""
            function ""B::operator A &amp;()""
    (A) b;
        ^
</code></pre>

<p>Here's the relevant text from the standard:</p>

<blockquote>
  <p><a href=""/questions/tagged/c%2b%2b11"" class=""post-tag"" title=""show questions tagged 'c++11'"" rel=""tag"">c++11</a></p>
  
  <h3>13.3.3 Best viable function [over.match.best]</h3>
  
  <p>[...] Given these de?nitions, a viable function F1 is de?ned to be a better function than another viable function F2 [...]</p>
  
  <p>2 - 
  If there is exactly one viable function that is a better function than all other viable functions, then it is the
  one selected by overload resolution; otherwise the call is ill-formed.</p>
</blockquote>

<p>The definitions themselves are complicated, but there's two things to note with user-defined conversions:</p>

<p>First, the application of user-defined conversion as a conversion sequence is specified to decompose into a sequence <code>S_a - U - S_b</code> of a standard conversion sequence followed by a user-defined conversion followed by another standard conversion sequence.  This covers all the cases; you can't have more than one user-defined conversion in a conversion sequence, and a standard conversion sequence can be the ""identity conversion"" i.e. no conversion required.</p>

<p>Second, when comparing user-defined conversion sequences the only part that matters is the second standard conversion sequence.  This is in 13.3.3:</p>

<blockquote>
  <p><a href=""/questions/tagged/c%2b%2b11"" class=""post-tag"" title=""show questions tagged 'c++11'"" rel=""tag"">c++11</a></p>
  
  <h3>13.3.3 Best viable function [over.match.best]</h3>
  
  <p>[...] a viable function F1 is de?ned to be a better function than another viable function
  F2 if [...]</p>
  
  <ul>
  <li>the context is an initialization by user-de?ned conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the
  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the
  entity being initialized) is a better conversion sequence than the standard conversion sequence from
  the return type of F2 to the destination type.</li>
  </ul>
</blockquote>

<p>and in 13.3.3.2:</p>

<blockquote>
  <p><a href=""/questions/tagged/c%2b%2b11"" class=""post-tag"" title=""show questions tagged 'c++11'"" rel=""tag"">c++11</a></p>
  
  <h3>13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</h3>
  
  <p>3 - Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of
  the following rules applies: [...]</p>
  
  <ul>
  <li>User-de?ned conversion sequence U1 is a better conversion sequence than another user-de?ned conversion sequence U2 if they contain the same user-de?ned conversion function or constructor or aggregate
  initialization and the second standard conversion sequence of U1 is better than the second standard
  conversion sequence of U2.</li>
  </ul>
</blockquote>

<p>So when comparing conversion sequences <code>U1 = (S1_a - U'1 - S1_b)</code> and <code>U2 = (S2_a - U'2 - S2_b)</code> the only thing that matters is the relative rank of <code>S1_b</code> and <code>S2_b</code>; the standard conversion sequences required to arrive at the parameter of the user-defined conversions do not matter.</p>

<p>So the possible conversion sequences for <code>(A) b</code>, requiring a conversion sequence yielding <code>B -&gt; A</code>, are:</p>

<pre><code>U1: B -&gt; B [identity], B::operator A() [user-defined], A -&gt; A [identity]
U2: B -&gt; B [identity], B::operator A &amp;() [user-defined], A &amp; -&gt; A [rvalue-to-lvalue]
</code></pre>

<p>Now, how do we rank standard conversion sequences?  The place to look is table 12 in 13.3.3.1.1, which specifies that lvalue-to-rvalue conversion has the same rank (""Exact Match"") as identity conversion. So the two user-defined conversion sequences cannot be distinguished, and the program is ill-formed.</p>

<hr/>

<h2>Sidebar</h2>

<p>What's the difference between 13.3.3 and 13.3.3.2 as regards ranking user-defined conversion sequences?</p>

<p>13.3.3 allows the compiler to distinguish between <em>different user-defined conversion operators</em>; 13.3.3.2 allows the compiler to distinguish between <em>different functions</em> that each require a user-defined conversion in their arguments.</p>

<p>So, in the code</p>

<pre><code>struct A {
    operator int();
    operator float();
} a;
void f(int);
f(a);
</code></pre>

<p>13.3.3 applies and <code>A::operator int()</code> is selected over <code>A::operator float()</code>; in the code</p>

<pre><code>struct A {
    operator int();
} a;
void f(int);
void f(double);
f(a);
</code></pre>

<p>13.3.3.2 applies and <code>void f(int)</code> is selected over <code>void f(double)</code>.  However in the code</p>

<pre><code>struct A {
    operator int();
    operator float();
} a;
void f(int);
void f(double);
f(a);
</code></pre>

<p>even though 13.3.3 prefers <code>A::operator int() -&gt; void f(int)</code> over <code>A::operator float() -&gt; void f(int)</code> and <code>float -&gt; double</code> over <code>int -&gt; double</code>, and 13.3.3.2 prefers <code>int -&gt; int</code> over <code>int -&gt; double</code> and <code>float -&gt; double</code> over <code>float -&gt; int</code>, there is no way to distinguish between the <code>int -&gt; int</code> and <code>float -&gt; double</code> conversion sequences (because they contain neither the same user-defined conversion operator nor the same overload of <code>f</code>), and so the code is ill-formed.</p>
",3
9154243,9154228,4,"<p>If you catch an exception, it is considered handled and execution resumes at the end of the <code>try</code>/<code>catch</code> block.</p>

<p>If you want the exception to continue up the chain further (and potentially cause the program to halt if it is not caught), then add a <code>throw</code> to the <code>catch</code>:</p>

<pre><code>catch(precExcp&amp; e)
{
    cerr &lt;&lt; e.what() &lt;&lt;endl;
    throw;
}
</code></pre>

<p>And if you want to halt the program there instead of propagating the exception upwards or letting execution resume, you can call <code>exit</code> (or <code>return</code> in this case, but only because you're in <code>main</code>).</p>
",0
9154250,9154228,1,"<p>Yes, that's normal: You <strong>caught</strong> the exception in the <code>catch</code> block, so the exception does not propagate outside the <code>try</code>/<code>catch</code>-block in which it was raised.</p>
",0
9154252,9154228,0,"<p>This is normal behavior, your unstable code is placed in <code>try</code> block, when something go not like should then <code>catch</code> block is executed when you can handle exception, after this process you can use optional <code>finally</code> block that is called after <code>try</code> in success and in fail after <code>catch</code>. After that code executing normally, code execution is stopped only in <code>try</code> block, you need <code>return</code> when you want stop executing this function (in <code>catch</code> block).</p>
",0
9154263,9154228,0,"<p>Well, you caught the exception that was thrown, so it is normal. Put the part of the code you don't want to execute if an exception occurs inside the try block:</p>

<pre><code>try {
    throw precExcp();
    cout &lt;&lt; ""hello"" &lt;&lt;endl;
}
catch(precExcp &amp;e) {
    // ...
}
</code></pre>
",0
9154493,9154228,1,"<p>Based on what I can understand from your question, if you want the ""hello"" output to be skipped, put it in the try block.</p>

<pre><code>try
{
   if(1)
       throw precExcp(); // throwing here will skip all remaining 
                         // instructions in the try block
    cout &lt;&lt; ""hello"" &lt;&lt;endl;
}
catch(precExcp&amp; e)
{
    cerr &lt;&lt; e.what() &lt;&lt;endl;
}
</code></pre>

<p>Also note that this isn't Java or Python. C++ exception-handling generally doesn't require you to define or catch too many different exception-types, as your main source of recovery is going to be the destructor (@see RAII) which often eliminates the need to have multiple catch branches (as well as a finally block). Often you can just catch <em>const std::exception&amp;</em> (make precExcp a subclass of it) and only in some rare cases do you need more granular checking than that.</p>

<p>You can also rethrow:</p>

<pre><code>try
{
   if(1)
       throw precExcp(); // throwing here will skip all remaining 
                         // instructions in the try block
}
catch(precExcp&amp; e)
{
    cerr &lt;&lt; e.what() &lt;&lt;endl;
    throw; // throw the original exception
}
</code></pre>

<p>However, if you do this in main and have no catch block to catch that second throw, it's going to crash with an unhandled exception which may or may not be what you are seeking.</p>
",0
10763799,10763738,1,"<p>I've ran your code, and I've successfully added a column. What do you mean by it failed?</p>

<p>Personally I would've flattened the 2 dimensional array into 1 using one single vector.</p>

<pre><code>class DynamicMatrix
{
   vector&lt;int&gt; array;
   int rows;
   int columns;
   public:

   DynamixMatrix(int r,int c):array(vector&lt;int&gt;(r*c)),rows(r),columns(c){};

   int getValue(int x,int y) { return array[x+y*c];}
   int setValue(int x,int y, int v) { array[x+y*c] = v;}

   void AddRow()
   {
        rows++;
        array.resize(rows*columns);
   }
   void AddColumn()
   {
        column++;
        array.resize(rows*columns);
   }

} 
</code></pre>
",0
8767105,8767097,22,"<p>Single-quotes denote a character literal.  Double-quotes denote a string literal.</p>

<p>So <code>'-'</code> is of type <code>char</code><sup>1</sup>, whereas <code>""-""</code> is of type <code>const char[2]</code> (which typically decays to <code>const char *</code>).</p>

<p><hr>
<sub>1 <code>int</code> in C.</sub></p>
",5
11545615,11545587,9,"<p>You are forward declaring the <code>mean</code> function using a different signature. Fix your forward declaration:</p>

<pre><code>int mean( int[] );
</code></pre>
",0
11545624,11545587,5,"<p>You're missing the brakets in your prototype. Try this:</p>

<pre><code>int mean(int[]);
</code></pre>
",0
11898558,11898297,4,"<p>Why dont you just wrap the buffer in a simple class containing the functions you want to be able to use.
Something like this will probably suffice, using the fact that pointers are iterators.</p>

<pre><code>template&lt;typename T&gt;
struct RawBuffer&lt;T&gt;
{
  RawBuffer( T* in_buffer, size_t in_n ) : buffer(in_buffer), n(in_n) {}
  T* buffer;
  size_t n;
  T* begin() { return buffer; }
  T* end() { return buffer+n; }
  const T* begin() const { return buffer; }
  cont T* end() const { return buffer+n; }
  T&amp; operator[](size_t i) { return buffer[i]; }
  const T&amp; operator[](size_t i) const { return buffer[i]; }
};
</code></pre>

<p>Now you can use it kinda like a vector:</p>

<pre><code>RawBuffer&lt;MyObject&gt; values( generate_objects(n), n );

//Set an entry
values[1] = MyObject()

//Or use an entry
values[1].do_something();

//Lets use some std functions on the object.
std::for_each( values.begin(), values.end(), my_object_fn );

//Or create a real vector from it
std::vector&lt;MyObject&gt; values_copy( values.begin(), values.end() );
</code></pre>

<p>If you also want to manage the memory that the buffer contains then you'll need to add a destrtuctor and remove the default copy constructor and assignment operator.</p>
",3
11828859,11828254,2,"<p>The key question is: what are the <em>semantics</em> of the returned pointer?</p>

<ul>
<li><p>if the returned parent/child/properties object has a lifetime <em>independent</em> of the returning (presumably, in some sense, owning) object, it's reasonable to return <code>shared_ptr</code>: this indicates that the caller and callee have <em>equal rights</em> to decide the object's lifetime</p>

<pre><code>std::shared_ptr&lt;IChild&gt; child = parent-&gt;getFirstChild();
// now I can keep child around ... if parent is destroyed, one
// orphaned subtree is magically kept around. Is this desirable?
</code></pre></li>
<li><p>if the returned object has a lifetime <em>dependent</em> on the callee's own lifetime, then:</p>

<ul>
<li><code>shared_ptr</code> will <em>wrongly</em> suggest it's meaningful for the caller to extend the returned object's lifetime beyond that of the callee</li>
<li><code>unique_ptr</code> will <em>wrongly</em> suggest transfer of ownership</li>
<li>raw pointer doesn't <em>explicitly</em> make any misleading promises, but doesn't give any hint about correct use either</li>
</ul></li>
</ul>

<p>So, if the caller is just getting a working reference to your object's internal state, without either transfer of ownership or extension of object lifetime, it doesn't suggest using <em>any</em> smart pointer.</p>

<p>Consider just returning a reference.</p>
",5
11828462,11828254,2,"<p>There's nothing wrong with returning a <code>shared_ptr</code>, but I'll try to convince you that this might not be the best option.</p>

<p>By using a smart pointer you gain the advantage of safety, but the users of your API lose the flexibility of using the type of smart pointer that best fits their needs and instead have to always use <code>shared_ptr</code>.</p>

<p>It also depends on how much you value safety over flexibility, but I would personally consider returning a naked pointer and allow the user to use the smart pointer he wants. Of course, if it is necessary that I use <code>shared_ptr</code> for some reason, I will.</p>
",9
11828963,11828254,0,"<p><code>shared_ptr</code> is fine, but it does provide some limitation to the end user, such as C++11 support.  A raw pointer, or a trait that allows them to tailor the smart pointer, may provide more flexibility to the end user.</p>

<p>Regardless of the pointer, I suggest being careful with the semantics introduced by the implementation.  With the current implementation, with a new wrapped being instantiated for every accessor call, equivalence checks will fail.  Consider the following code:</p>

<pre><code>auto child = parent-&gt;getFirstChild();
if ( parent == child-&gt;getParent() ) // Will be false, as they point to different
                                    // instantiations of Parent.
  ...

if ( child-&gt;getParent() == child-&gt;getParent() ) // False for the same reason.
  ...

auto sibling = child-&gt;getNextChild();
if ( parent == sibling-&gt;getParent() ) // Also false for the same reason.
  ... 
</code></pre>

<p>Also, when using <code>std::shared_ptr</code>, it can be worthwhile to consider using <code>std::make_shared</code> to reduce some of the overhead that occurs with the allocations.</p>
",0
16406519,5038497,0,"<pre><code>mylist.begin(); it!=mylist.end();
</code></pre>

<p>should be</p>

<pre><code>u.begin(); it!=u.end();
</code></pre>
",0
10114202,10114078,1,"<p>In B.hpp file, before the declaration of <code>function_in_b(state *)</code>, forward declare the <code>state</code> type:</p>

<pre><code>struct state;
</code></pre>
",0
10114203,10114078,2,"<p>In <code>B.hpp</code>, you say you forward-declared <code>A</code>, but not <code>state</code> - so when it first sees <code>function_in_b(state *s)</code> it doesn't know what <code>state</code> is. By the time you include <code>A.hpp</code> in <code>B.cpp</code> it's too late. You need to forward declare <code>state</code> in <code>B.hpp</code>, i.e.</p>

<pre><code>struct state;

bool function_in_b(state *s);
</code></pre>
",0
9860133,9860084,0,"<p>You should never take your chances on operator precedence.  Use parens.  They don't cost much.  So change the calculation for the third number as follows:</p>

<pre><code>((sim.howManyTimesDidWeRollACertainNumber(11) * 100.0) / times)
</code></pre>

<p>If it is still wrong after that then you need to show the code for that function...obviously no one can help you further without that.</p>
",19
9860218,9860084,5,"<pre><code>int timesRolled[6 * numberOfDice - 2];
// ...
this-&gt;timesRolled = timesRolled;
</code></pre>

<p>You can't do that. <code>timesRolled</code> is a local variable that will go out of scope at the end of the constructor. Once that happens the memory is no longer valid and accessing any pointer to that memory will lead to undefined behavior.</p>
",4
9860355,9860084,1,"<p>Yes, the answer has been given and accepted, but I still don't like this:</p>

<pre><code>int timesRolled[6 * numberOfDice - 2];

for(int i = numberOfDice; i &lt;= 6 * numberOfDice; i++)
{
    timesRolled[i - numberOfDice] = 0;
}
</code></pre>

<p>So that if, for instance, numberOfDice is 1, timesRolled is an array with 4 elements, and you fill elements 0 through 5 of it. You may want to look into that later.</p>
",2
10821445,10821417,2,"<p><strong>No.</strong> <br>
According to the standard <code>main()</code> must return an <code>int</code> and only that.</p>
",0
10821450,10821417,1,"<p>No.</p>

<p><code>main</code> must return <code>int</code>.</p>

<p>Other functions are free to have other names and return anything they want.</p>
",0
10821456,10821417,3,"<p>No. <em>main</em> must be declared in one of these two ways:</p>

<pre><code>int main()
</code></pre>

<p>or </p>

<pre><code>int main(int argc, char*[] argv)
</code></pre>

<p>Anything outside of this is not standard.</p>
",4
10821475,10821417,9,"<p>In C++, <code>main</code> needs to return an <code>int</code>:</p>
<blockquote>
<p>C++ standard, 3.6.1.2:</p>
<p>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type <code>int</code>, but otherwise its type is implementation-defined.</p>
</blockquote>
<p>.</p>
<blockquote>
<p>If not, what is the best way that it can output a vector?</p>
</blockquote>
<p>To <em>output</em> a vector, you need to copy it to a file or an output stream:</p>
<pre><code>ostream_iterator&lt;int&gt; out_it(cout, &quot;, &quot;);
copy(myvector.begin(), myvector.end(), out_it);
</code></pre>
<p>The code fragment above writes the content of <code>vector&lt;int&gt;</code> to the standard output.</p>
",3
10821483,10821417,0,"<p>The answer to your first question is no. 
The answer to your second question is yes, but you need to specify the name of your entry point to your executable (via linker settings ... may not be available on all linker tools).</p>

<p><strong>Below statement is wrong</strong>
See Ben's comment below. Useful info that.</p>

<p>Be aware that though the name of the entry-point can change, it MUST conform to the standard parameter and return types.</p>
",2
10822224,10821417,1,"<p>To expand on dashblinkenlight's answer, here is how two programs can communicate.  Not by one capturing the return value of the other, but by a process called ""piping"", directing the standard output of one program to the standard input of another.  Here, I'll print out a list of strings in one program, then the other program will expect a list of strings on its standard input, then I'll show you how to use the two together:</p>

<pre><code>// Output program
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace std;

    vector&lt;string&gt; v;
    v.push_back(""one"");
    v.push_back(""two"");
    v.push_back(""three"");

    for (int i=0; i&lt;v.size(); ++i)
        cout &lt;&lt; v[i] &lt;&lt; '\n';
}

// input program
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main()
{
    using namespace std;

    vector&lt;string&gt; v;
    for (string tmp; cin &gt;&gt; tmp; )
        v.push_back(tmp);

    // print the strings in reverse order
    for (int i=v.size()-1; i&gt;=0; --i)
        cout &lt;&lt; v[i] &lt;&lt; '\n';
}
</code></pre>

<p>If you run the first program by itself, it will just print the 3 strings out.  If you run the second program by itself, it will prompt the user for strings until he uses the termination command.  But on all of the most widely used operating systems, you can chain the two together.  Then the output of the first will become the input of the second.  On Unix-like systems, you do it like this:</p>

<pre><code>./output_program | ./input_program
</code></pre>

<p>On Windows, I think it's the same, or very similar.  Not sure though.</p>
",1
8744662,8744578,0,"<p>You're not passing the vector by value.</p>

<pre><code>vector&lt;Boson*&gt;* BosonMaker::remove_duplicates(vector&lt;Boson*&gt;* boson_candidates, vector&lt;Particle*&gt; *child_candidates);
</code></pre>

<p><strong>will pass a pointer</strong> to the <code>vector</code> <strong>by value</strong>. But the pointer, which is a copy of the original one, will point to the same <code>vector</code> as the original.</p>

<p>So you're basically changing the same vector as outside the call.</p>

<p>To pass by value, you need:</p>

<pre><code>vector&lt;Boson*&gt;* BosonMaker::remove_duplicates(vector&lt;Boson*&gt; boson_candidates, vector&lt;Particle*&gt; child_candidates);
</code></pre>

<p>But be careful when doing so. Copying will occur, so you probably need to override the virtual destructor, copy constructor and assignment operator for <code>Boson</code> and <code>Particle</code> if they're not <code>POD</code> types.</p>
",1
8744679,8744578,1,"<p>I'm a little confused about what you are saying about passing by value and passing by reference, so I'm going to give a short explanation on that first:</p>

<ul>
<li><p>When passing by value, the variable that the method is called with remains unchanged (since a copy is passed into the called method). Be careful though, this case can also incur a heavy performance penalty, since the whole variable is copied! In case of a vector holding many elements this might take quite some time! Passing by value is achieved like this in C++:</p></li>
<li><p>When passing by reference (or more or less equivalently by pointer) the outer variable is also changed - since you're only passing a reference into the method, which is referencing the same actual space in memory as the original variable!</p></li>
</ul>

<p>So basically what the difference is that in when using <em>call by value</em>, <strong>the original caller's value remains unchanged</strong>, while when using <em>call by reference</em>, a reference to the original caller's value is passed in, and therefore this value can change on both ends.</p>

<p>Now which method is needed simply depends on what you want to achieve. <em>Pass by Value</em> if the variable you're passing into the method should remain unchanged (<code>m_all_particle_candidates</code> in your example). Or if you need it to change, then pass by reference/pointer.</p>

<p>If the passed-in variable shouldn't change, but you also only need a read-only version of the variable inside the method, then the possible performance problems introduced by passing by value can be overcome by using a <strong>const reference</strong>. In you case, however, you seem to need a full copy (meaning a normal pass-by-value).</p>
",3
8744899,8744578,1,"<p>Does the code presented in the OP compile? I don't think so. In fairness, it should be passed through a compiler before posting.</p>

<pre><code>typedef struct {
   long double x, y, z;
} V3;

void fnExpectingPtrToVec(vector&lt;V3&gt; * pvec) {
}

void fnExpectingVec(vector&lt;V3&gt; vec) {
}

void testVecs() {
   vector&lt;V3&gt; v;
   //fnExpectingPtrToVec(v); Does not compile
   fnExpectingPtrToVec(&amp;v);
   fnExpectingVec(v);
}
</code></pre>

<p>If it is expecting a pointer to a vector in the 2nd param, and you passed in a vector instead, then its a compile error.</p>

<p>When you fix the function to accept a vector, not a pointer to one, and call it with your vector it will make a copy and the repeated calls to the function will leave <code>m_all_particle_candidates</code> unchanged.</p>
",0
11505396,11505328,0,"<p>Maybe you want something like <a href=""http://msdn.microsoft.com/en-us/library/k1f9b8cy.aspx"" rel=""nofollow""><code>mbstowcs()</code></a>:</p>

<pre><code>char input[6] =""qwerty"";
wchar_t output[6];
mbstowcs( output, input, 6 );
</code></pre>

<p>The code above will convert the ""qwerty"" string into <code>wchar_t</code> and put it into the <em>output</em> array.</p>
",0
11505414,11505328,0,"<p>Use MultiByteToWideChar function.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/bb202786.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/bb202786.aspx</a></p>
",0
11899119,5255954,10,"<pre><code>void func()
{
    static int static_var=1;
    int non_static_var=1;

    static_var++;
    non_static_var++;

    cout&lt;&lt;""Static=""&lt;&lt;static_var;
    cout&lt;&lt;""NonStatic=""&lt;&lt;non_static_var;
}

void main()
{
    clrscr();
    int i;
    for (i=0;i&lt;5;i++)
    {
        func();
    }
    getch();
}
</code></pre>

<p>The above gives output as:</p>

<pre class=""lang-none prettyprint-override""><code>Static=2
Nonstatic=2

Static=3
Nonstatic=2

Static=4
Nonstatic=2

Static=5
Nonstatic=2

Static=6
Nonstatic=2
</code></pre>

<p>Static variable retains its value while non-static or dynamic variable is initialized to '1' every time the function is called. Hope that helps.</p>
",2
11093162,11091411,1,"<pre><code>class Base
{
protected:      
    unsigned short  id;
public:
    void SetID(unsigned short);
    virtual inline unsigned short GetID() { return id; }
    virtual ~Base() {}
    Base(): id() {}
};


class Generic 
    : public Base
{
protected:  
    char    name[30];
public:
    const char* GetName() { return name; }
    Generic(const char* in_name): name() {}
};

class Actor
    : public Generic
{
public:     
    void DoSomething(const char* str) {}

    ~Actor() {}
    Actor(const char* in_name)
        : Generic( name )
    {}
};

class MyInterface
{
public:     
    // Our methods that need to implemented
    virtual const char* name() const = 0;      
    virtual int id() const = 0;
    virtual void doSomething( const char* str ) = 0;

    virtual ~MyInterface() {} 
};

template&lt; class TpBase &gt;
class MyInterfaceOn
    : public virtual MyInterface
    , public TpBase
{
public:
    typedef TpBase Base;

private:
    MyInterfaceOn&amp; mutableSelf() const
    { return *const_cast&lt;MyInterfaceOn*&gt;( this ); }

public:
    const char* name() const { return mutableSelf().Base::GetName(); }
    int id() const { return mutableSelf().Base::GetID(); }
    void doSomething(const char* str) { Base::DoSomething( str ); }

    MyInterfaceOn( char const name[] )
        : Base( name )
    {}
};

class MyActor
    : public MyInterfaceOn&lt; Actor &gt;
{
public:
    MyActor( char const name[] )
        : MyInterfaceOn&lt; Actor &gt;( name )
    {}
};

int main()
{
    MyInterface const&amp;  actor   = MyActor( ""NN"" );
}
</code></pre>
",6
12872191,12871687,2,"<p>You cannot have a declaration as a part of an expression.</p>

<pre><code>while ((char c = cin.get()) != 'q') { ...
//      |----------------| &lt;---------------------- this is a declaration
//     |-------------------------| &lt;-------------- this is an expression
</code></pre>

<p>You <em>can</em> have a declaration directly inside the parentheses of the loop (not in any nested parentheses):</p>

<pre><code>while (char c = cin.get()) { ...
</code></pre>

<p>but this stops on <code>!c</code>, which is not what you want.</p>

<p>This will work:</p>

<pre><code>while (int c = cin.get() - 'q') { // ugly code for illustrative purpose
 c += 'q';
 ...
}
</code></pre>

<p>and so will this:</p>

<pre><code>for (char c; (c = cin.get()) != 'q'; ) { // ugly code for illustrative purpose
  ...
}
</code></pre>

<p>Update: see also <a href=""https://stackoverflow.com/q/190748/775806"">this SO question</a>.</p>
",0
12871700,12871687,1,"<p>Try this:</p>

<pre><code>char c;
while((c = cin.get()) != 'q')
{  //do anything
}
</code></pre>

<p>You are declaring the variable inside parantheses, hence the error:</p>

<pre><code>while (char c = cin.get() != 'q')
</code></pre>
",6
11817670,5373461,0,"<p>You need not to scan whole array. Just keep checking remaining data also if it is less than current max white spaces, then stop the scanning. </p>

<p>example</p>

<p>1 space space 2 space space scape 3 4</p>

<p>here after coming to 3 u know that only 2 elements are left and those are less than ur current max spaces (3).</p>
",0
8766593,8766583,1,"<p>No.</p>

<p>[<em>Note: you don't need that cast.</em>]</p>
",2
8766595,8766583,2,"<p>Allocating and deleting memory from different functions is completely valid.  </p>
",0
8766599,8766583,-1,"<p>No, it's ok. 
Why do you cast StorageToDelete to (TData*) in DeleteStorage()?</p>
",0
8766600,8766583,-1,"<p>No, that's fine, and also don't typedef your structs. Just say <code>struct TData { /*...*/ };</code>.</p>
",3
8766635,8766583,0,"<p>As long as you're allocating and deallocating within the same library, it will be deleted safely. </p>

<p>However, there are things to note if you are allocating and deallocating in different libraries. Since the underlying class definition may be different amongst different libraries, you need to make sure that you're using the same definition.</p>

<p>One very common problem that arises is when you're using a precompiled open source C++ library and your program and the library use different C++ runtime library, it will sometimes crash while the open source library deallocates a STL container instance that has been allocated by your program because the definition of that class in the open source library is different from yours. The common workaround in solving this problem is to recompile the open source library using the compiler that you use.</p>
",2
15860115,15859381,1,"<p>After the user enters input, they press enter. That newline character <code>'\n'</code> is still in the <code>cin</code> stream. You need to <code>ignore</code> it:</p>

<pre><code>cin &gt;&gt; ch;
cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n'); //this ignores all subsequent characters until the newline character
</code></pre>
",1
13712356,13712285,6,"<p>There is no straight-up evaluate-struct-as-a-bool operator. That's <em>why</em> there's a way to <em>give</em> a struct an <code>operator bool</code> method. It tells the compiler how to interpret a value of the given struct type when it's used in a <code>bool</code> context.</p>

<p>The code you've shown would not use such an operator, though, since the operator applies to <em>structs</em>, not <em>pointers</em> to structs; you have an expression of type <code>foo*</code>, not <code>foo</code>. Pointers automatically convert to <code>bool</code> because that's an intrinsic conversion the compiler knows how to perform. Null pointers are false, and non-null pointers are true. The code shown in the question would never yield the reported error message.</p>

<p>If you do indeed have a struct in a place where the compiler expects a <code>bool</code>, and you cannot, for whatever reason, give the struct an <code>operator bool</code> method, then you can perform the conversion the old-fashioned way and use an ordinary function:</p>

<pre><code>bool interpret_foo_as_bool(foo const&amp; f);
</code></pre>

<p>Implement the function however you want, and then call it, passing your <code>foo</code> value. For example:</p>

<pre><code>foo* x = ...;
int y = interpret_foo_as_bool(*x) ? 3 : 4;
</code></pre>
",0
13712369,13712285,6,"<p>This can't be the correct code for that error. The error states that it can't convert <code>x</code> from <code>foo</code> to <code>bool</code>, but <code>x</code> is <em>not</em> a <code>foo</code>, it is a <code>foo*</code>. And a <code>foo*</code> <em>is</em> convertable to bool<sup>1</sup>, so there would be no error for the code you have given.</p>

<p>If you want to be able to use a <code>foo</code> object as a conditional, you need to provide <code>operator bool</code> member function for your <code>foo</code> class:</p>

<pre><code>struct foo {
  int bar;
  operator bool() { return true; }
};
foo x;
int y = x ? 3 : 4;
</code></pre>

<p>In this case, any <code>foo</code> will always evaluate to <code>true</code>. This conversion to <code>bool</code> is considered ""unsafe"" because your object may be converted to <code>bool</code> in some unexpected places. To get around this, in C++03 you can use the <a href=""http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool"" rel=""nofollow noreferrer"">safe bool idiom</a> and in C++11 you can mark your <code>operator bool</code> as <code>explicit</code>:</p>

<pre><code>struct foo {
  int bar;
  explicit operator bool() { return true; }
};
</code></pre>

<p>The <code>explicit operator bool</code> will still be used automatically in certain places, such as as a condition in <code>if</code> statements and <code>while</code> loops. There are <a href=""https://stackoverflow.com/a/6242355/150634"">other answers</a> that cover this.</p>

<hr>

<blockquote>
  <p><sup>1</sup> A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type <code>bool</code>. A zero value, null pointer value, or null member pointer value is converted to <code>false</code>; any other value is converted to <code>true</code>.</p>
</blockquote>
",3
16434919,16434778,1,"<p>Excel is capable of importing HTML-based files - checkout the official documentation at <a href=""http://msdn.microsoft.com/en-us/library/Aa155477%28office.10%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/Aa155477%28office.10%29.aspx</a></p>

<p>Since HTML is ""text-based"" you should be able to write is rather easily...</p>

<p>Another option is to use CSV (also text-based) which Excel does understand BUT there is no support in CSV for different sheets.</p>

<p>XLS is a binary file format defined by Microsoft which is rather complex... one option is a commercial library like <a href=""http://www.libxl.com/"" rel=""nofollow"">LibXL</a> - it can read and write the ""genuine Excel format (XLS etc.)"" including support for different sheets etc.</p>
",0
13485188,13485132,6,"<p>Any symbol left without a definition is to be replaced during the linking process, since the function <code>foo(type2)</code> could've been provided in another file.</p>

<p>The compiler is to say whether the function needed has been defined by the end of the entire process, when no further substitution can be applied.</p>

<p>In order to clarify the understanding, you must be aware of the steps required to compile, say, a common C program:</p>

<ul>
<li><p>first, you expand all the macros on your code;</p></li>
<li><p>then your code is validated according to the language syntax, so that it can be converted into assembly language -- the compilation process itself; during this step, every symbol found without a definition is annotated in a table with the entries <code>(symbol, definition)</code>, that shall be completed later, allowing your program to be constructed properly;</p></li>
<li><p>next, your code compiled into assembly will be converted to machine language, i.e., the objects will be created;</p></li>
<li><p>finally, you need to link your already executable objects, in order to solve any dependencies on symbol definitions; this last step checks your objects for undefined symbols, adding definitions from other modules or from libraries, thus, completing the program.</p></li>
</ul>

<p>If any symbol was not correctly ""linked"" to its definition, the compiler will point out an error in your program -- the classic <code>undefined reference to...</code>.</p>

<p>Considering the code you've posted, the process would be executed until it reaches the compiler. The compiler would traverse the code, notice the definition of <code>type1</code>, <code>type2</code>, <code>foo(type1 x)</code>, and <code>bar&lt;T&gt;()</code>.</p>

<pre><code>struct type1 {};
struct type2 {};
</code></pre>

<p>When it'd reached the main, it would find the call for <code>bar&lt;type1&gt;();</code>, and would call <code>foo(type1())</code>, which is already known, and can be used properly.</p>

<pre><code>void foo(type1 x) {
    std::cout &lt;&lt; ""foo(type1)"" &lt;&lt; std::endl;
}

template&lt;typename T&gt;
void bar() {
    foo(T());
}

int main() {

    bar&lt;type1&gt;();
    bar&lt;type2&gt;();
    return 0;

}
</code></pre>

<p>Once it'd reached the next call, <code>bar&lt;type2&gt;();</code>, it would try to call <code>foo(type2())</code>, but no such definition would be available for usage, so it would relate this call as an unknown symbol, that must be replaced by a definition in the later processes.</p>

<p>After the compiler runs through the <code>main</code>, it reaches a new definition, that is exactly the one lacking definition on the ""translation table"" being created.</p>

<pre><code>void foo(type2 x) {
    std::cout &lt;&lt; ""foo(type2)"" &lt;&lt; std::endl;
}
</code></pre>

<p>So, in the next step, the compilation is able to replace the symbol with its respective definition, and the program compiles correctly.</p>

<p>Regards!</p>
",4
13485843,13485132,3,"<p>The answer is found via argument-dependent name lookup (ADL) (which is also mentioned in the linked question). <code>foo(T());</code> has two lookups. First at template definition time, any functions defined at the point of definition are included in the overload set. This means when the compiler sees <code>foo(T());</code> inside of <code>bar</code>, it adds <em>only</em> <code>void foo(type1 x)</code> to the overload set. However there is a <strong>second</strong> lookup that is performed, called ADL. At template instantiation time, i.e. <code>bar&lt;type2&gt;();</code> it looks for a <code>foo</code> in the same namespace as the argument which is provided, which in this case is <code>type2</code>. Since <code>type2</code> is in the global namespace, it looks for a <code>foo</code> that takes a <code>type2</code> in the global namespace and finds it, and resolves the call. If you are looking for info from the standard, see <code>14.6.4.2 Candidate functions</code>.</p>

<p>Try the following and watch the code fail. This is because it cannot find <code>foo</code> in the same namespace as <code>a::type1</code>.</p>

<pre><code>#include &lt;iostream&gt;

namespace a
{
  struct type1 {};
}

template&lt;typename T&gt;
void bar() {
  foo(T());
}

int main()
{
  bar&lt;a::type1&gt;();
  return 0;
}

void foo(a::type1 x)
{
  std::cout &lt;&lt; ""foo(a::type1)"" &lt;&lt; std::endl;
}
</code></pre>
",3
10744598,10744451,6,"<blockquote>
  <p><code>T</code> can be <code>int</code>, double, <code>float</code>, etc.</p>
</blockquote>

<p>There are three overloads of <code>std::fabs</code> in C++ for <code>float</code>, <code>double</code>, and <code>long double</code>.</p>

<p>If you try to call <code>std::fabs</code> with an argument of type <code>int</code>, you will get a compilation error due to an overload ambiguity.  An <code>int</code> argument matches all three of the available overloads equally.</p>

<p>You could cast the argument to a known type (e.g. <code>double</code> or <code>long double</code>), which would resolve the ambiguity, or you could wrap the call to <code>fabs</code> in a template that performs disambiguation for integer-type arguments.</p>

<p>Alternatively, C++ has <code>std::abs</code>, which is overloaded for both integer and floating point types (declared in <code>&lt;cmath&gt;</code> and <code>&lt;cstdlib&gt;</code>).  Further, if you have a recent Standard Library implementation that implements C++11, a call to <code>std::fabs</code> with an integer type argument will automatically convert the argument to type <code>double</code>, so there is no ambiguity.</p>
",14
17780467,17780420,11,"<p>Have you actually tried to compile this code?</p>

<pre><code>Error   1   error C2652: 'Foo' : illegal copy constructor: first parameter must not be a 'Foo'  main.cpp    5   1   NativeConsoleSketchbook
</code></pre>

<h3>C++11 standard, 12.8.6:</h3>

<blockquote>
  <p>A declaration of a constructor for a class X is ill-formed if its first parameter is of type (optionally cv-qualified)
  X and either there are no other parameters or else all other parameters have default arguments.</p>
</blockquote>
",6
17780494,17780420,3,"<p>Quoting from <a href=""http://en.wikipedia.org/wiki/Copy_constructor"" rel=""nofollow"">this</a> Wikipedia article(emphasis mine):</p>

<blockquote>
  <p>The following are <strong>invalid copy constructors</strong> (Reason - <strong>copy_from_me is
  not passed as reference</strong>) :</p>
  
  <p>X(X copy_from_me);<br/>
  X(const X copy_from_me);</p>
  
  <p>because the call to those constructors would require a copy as well,
  which would result in an <strong>infinitely recursive call</strong>.</p>
</blockquote>
",0
17780503,17780420,2,"<p><code>Foo(Foo x)</code> will never be called since the code will try to interpret it as a copy constructor and fail at it (compile error).</p>

<p>Non-type methods (such as constructors, destructors etc.) should follow the syntax for each case.</p>
",0
12835604,12835504,3,"<p>None of them have meaning. What means Values or Types? Just abstract names. Better name them with more concrete for example as ObjectState or PacketField. Such names as Type means nothing, when you name your variable think that other people could read and understand what it means and when you forget what did you do you must remember what it is and dont read bunch of code to understand what this type for.</p>

<p>For more information about variables naming and more about software engineering you can buy wonderful book <a href=""https://rads.stackoverflow.com/amzn/click/com/0735619670"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Code complete</a> written by <a href=""http://en.wikipedia.org/wiki/Steve_McConnell"" rel=""nofollow noreferrer"">Steve McConnell</a>.</p>
",1
9219987,9219898,0,"<p>I seem to recall that originally (ARM) it was not allowed, and we used to use <code>enum</code> to define constants in class declarations.</p>

<p>The const case was explicitly introduced so as to support availability of the value in headers for use in constant expressions, such as array sizes. </p>

<p>I <em>think</em> (and please comment if I have this wrong) that strictly you still need to define the value:</p>

<p><code>const int Gone::a;</code></p>

<p>to comply with the One Definition Rule. However, in practice, you might find that the compiler optimises away the need for an address for <code>Gone::a</code> and you get away without it.</p>

<p>If you take:</p>

<p><code>const int* b = &amp;Gone::a;</code></p>

<p>then you might find you do need the definition.</p>

<p>See the standard, $9.4.2:</p>

<p>ISO 1998:</p>

<blockquote>
  <p>""4 If a static data member is of const integral or const enumeration
  type, its declaration in the class definition can specify a
  constantinitializer which shall be an integral constant expression
  (5.19). In that case, the member can appear in integral constant
  expressions within its scope. The member shall still be defined in a
  namespace scope if it is used in the program and the namespace scope
  definition shall not contain an initializer.""</p>
</blockquote>

<p>Draft for c++11:</p>

<blockquote>
  <p>""3 If a static data member is of const effective literal type, its
  declaration in the class definition can specify a constant-initializer
  brace-or-equal-initializer with an initializer-clause that is an
  integral constant expression. A static data member of effective
  literal type can be declared in the class definition with the
  constexpr specifier; if so, its declaration shall specify a
  constant-initializer brace-or-equal-initializer with an
  initializerclause that is an integral constant expression. In both
  these cases, the member may appear in integral constant expressions.
  The member shall still be defined in a namespace scope if it is used
  in the program and the namespace scope definition shall not contain an
  initializer.""</p>
</blockquote>

<p>I am not sure entirely what this covers, but I think it means that we can now use the same idiom for floating point and possibly string literals.</p>
",0
9220007,9219898,2,"<p>The <code>static const int</code> declaration is legal because you're declaring a constant, not a variable. <code>a</code> doesn't exist as a variable - the compiler is free to optimize it out, replacing it with the declared value <code>3</code> anywhere a reference to <code>Gone::a</code> appears. C++ allows the static initialization in this restricted case where it's an integer constant. </p>

<p>You can find more details, including an ISO C++ standard citation <a href=""https://stackoverflow.com/questions/2605520/c-where-to-initialize-static-const"">here</a>. </p>
",0
9220029,9219898,0,"<p>A static const is defined in the class definition since everybody that uses the code need to know the value at compile time, not link time. An ordinary static is actually only declared in the class definition, but defined once, in one translation unit.</p>
",0
9220067,9219898,7,"<p>This trick works only for constant compile-time expressions. Consider the following simple example:</p>

<pre><code>#include &lt;iostream&gt;

class Foo {
public:
    static const int bar = 0;
};

int main()
{
    std::cout &lt;&lt; Foo::bar &lt;&lt; endl;
}
</code></pre>

<p>It works just fine, because compiler knows that <code>Foo::bar</code> is 0 and never changes. Thus, it optimizes the whole thing away.</p>

<p>However, the whole thing breaks once you take the address of that variable like this:</p>

<pre><code>int main()
{
    std::cout &lt;&lt; Foo::bar &lt;&lt; "" ("" &lt;&lt; &amp;Foo::bar &lt;&lt; "")"" &lt;&lt; std::endl;
}
</code></pre>

<p>Linker sends you to fix the program because compile-time constants don't have addresses.</p>

<p>Now, the second case in your example doesn't work simply because a non-constant variable cannot be a constant compile-time expression. Thus, you have to define it somewhere and cannot assign any values in initialization.</p>

<p>C++11, by the way, has <code>constexpr</code>. You can check <a href=""https://en.wikipedia.org/wiki/C++11#constexpr_.E2.80.93_Generalized_constant_expressions"" rel=""nofollow noreferrer"">Generalized constant expressions</a> wiki (or C++11 standard :-)) for more info.</p>

<p>Also, be careful - with some toolchains you will never be able to link program as listed in your first example when optimizations are turned off, even if you never take an address of those variables. I think there is a <code>BOOST_STATIC_CONSTANT</code> macro in Boost to work around this problem (not sure if it works though because I reckon seeing linkage failures with some old gcc even with that macro).</p>
",0
9220076,9219898,2,"<p>Initialization of variables has to be done at the point of <em>definition</em>, not the point of <em>declaration</em> in the general case. Inside the class brackets you only have a <em>declaration</em> and you need to provide a <em>definition</em> in a single translation unit<sup>*</sup>:</p>

<pre><code>// can be in multiple translation units (i.e. a header included in different .cpp's)
struct test {
   static int x;    // declaration
   static double d; // declaration
};
// in a single translation unit in your program (i.e. a single .cpp file)
int test::x = 5;       // definition, can have initialization
double test::d = 5.0;  // definition
</code></pre>

<p>That being said, there is an exception for <code>static</code> integral constants (and only integral constants) where you can provide the value of the constant in the <em>declaration</em>. The reason for the exception is that it can be used as a <em>compile-time</em> constant (i.e. to define the size of an array), and that is only possible if the compiler <em>sees</em> the value of the constant in all translation units where it is needed.</p>

<pre><code>struct test {
   static const int x = 5;  // declaration with initialization
};
const int test::x;          // definition, cannot have initialization
</code></pre>

<p>Going back to the original question:</p>

<ul>
<li>Why is it not allowed for non-const integers?</li>
<li>because initialization happens in the <em>definition</em> and not <em>declaration</em>.</li>
<li>Why is it allowed for integral constants?</li>
<li>so that it can be used as a <em>compile-time constant</em> in all translation units</li>
</ul>

<hr>

<p><sup>*</sup> The actual rules require the definition whenever the member attribute is <em>used</em> in the program. Now the definition of <em>used</em> is a bit tricky in C++03 as it might not be all that intuitive, for example the use of that constant as an <em>rvalue</em> does not constitute <em>use</em> according to the standard. In C++11 the term <em>used</em> has been replaced with <em>odr-used</em> in an attempt to avoid confusion.</p>
",3
11512138,11512121,4,"<p>You can do it with templates:</p>

<pre><code>template&lt;typename T, typename S, typename U&gt;
print(T x, S y, U z)
{
    std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; z;
}
</code></pre>

<p>EDIT: If you're expecting to pass complex types (not just <code>int</code> or <code>char *</code>) you should follow James' answer and use <code>const</code> references.</p>
",0
11512139,11512121,2,"<p>you could use macros... (if you want to do that, can be ugly sometimes)</p>

<pre><code>#define PRINT(x,y,z) cout &lt;&lt; (x) &lt;&lt; (y) &lt;&lt; (z) &lt;&lt; endl;
</code></pre>
",7
11512142,11512121,14,"<pre><code>template &lt;typename T0, typename T1, typename T2&gt;
void print(T0 const&amp; t0, T1 const&amp; t1, T2 const&amp; t2)
{
    std::cout &lt;&lt; t0 &lt;&lt; t1 &lt;&lt; t2 &lt;&lt; std::endl;
}
</code></pre>
",8
11512153,11512121,2,"<p>If you are looking to simplify the specific task of printing three items, you can do it using a #define macro:</p>

<pre><code>#define print(A,B,C) cout &lt;&lt; (A) &lt;&lt; (B) &lt;&lt; (C) &lt;&lt; endl
</code></pre>

<p>If you prefer a function-call syntax, consider using C-style output instead: <code>printf</code> is a ""first-class member"" of the C++ standard library, there is no reason to shy away from it when it makes sense in your specific application:</p>

<pre><code>printf(""%d %s %s\n"", 5, ""is a"", ""number"");
</code></pre>

<p>The advantage of <code>printf</code> approach is that it is not limited to any specific number of arguments.</p>
",2
11512751,11512121,5,"<blockquote>
  <p>I would like to be able to make a function that can take just three arguments</p>
</blockquote>

<p>Are you sure?  C++11 affords us much more power than that.</p>

<pre><code>void print()
{
    std::cout &lt;&lt; std::endl;
}

template&lt;typename T, typename... Args&gt;
void print(const T &amp; val, Args&amp;&amp;... args)
{
    std::cout &lt;&lt; val;
    print(args...);
}
</code></pre>
",5
10102329,10102287,6,"<p>How did you decide it should be 5/4? (2/5) / (1/2) = 4/5 and it is correct result. Maybe you are calculating x/=y instead when you expect 5/4.</p>
",0
10102342,10102287,2,"<p><code>y/=x</code> is same as <code>y = y/x</code> which is <code>2/5 / 1/2</code> which is <code>2/5 x 2/1</code> = <code>4/5</code></p>
",1
17867745,8192969,-1,"<p>//here is a function to count letters in the word representation of a number</p>

<pre><code>int countLetters(int num)
{
int count = 0;

if( num &gt;= 1000000000 )
count += countLetters( num / 1000000000 ) + 7 + countLetters( num % 1000000000);
else if ( num &gt;= 1000000 )
count += countLetters( num / 1000000 ) + 7 + countLetters( num % 1000000);
else if( num &gt;= 1000 )
count += countLetters( num / 1000 ) + 8 + countLetters( num % 1000);
else if( num &gt;= 100 )
count += countLetters( num / 100 ) + 7 + countLetters( num % 100) + (num % 100 &gt; 0 ? 3 : 0);
else if( num &gt;= 20 )
{
    switch( num / 10 ) 
    {
        case  2: count += 6;    break;
        case  3: count += 6;    break;
        case  4: count += 5;     break;
        case  5: count += 5;     break;
        case  6: count += 5;     break;
        case  7: count += 7;   break;
        case  8: count += 6;    break;
        case  9: count += 6;     break;
    }
    count += countLetters( num % 10 );
}
else 
{
    switch( num )
    {
        case  1: count += 3;      break;
        case  2: count += 3;      break;
        case  3: count += 5;    break;
        case  4: count += 4;     break;
        case  5: count += 4;     break;
        case  6: count += 3;      break;
        case  7: count += 5;    break;
        case  8: count += 5;    break;
        case  9: count += 4;     break;
        case 10: count += 3;      break;
        case 11: count += 6;   break;
        case 12: count += 6;   break;
        case 13: count += 8; break;
        case 14: count += 8; break;
        case 15: count += 7;  break;
        case 16: count += 7;  break;
        case 17: count += 9;break;
        case 18: count += 8; break;
        case 19: count += 8; break;      
    }
}

return count;
</code></pre>

<p>}</p>
",0
12848444,4640162,3,"<p>You can also use a character array (which is basically what a string is anyway):</p>

<pre><code>char filename[20];

std::cout &lt;&lt; ""Enter the filename (no more than 20 characters): "";
std::cin &gt;&gt; filename;

std::ifstream inputFile( filename );
</code></pre>

<p>That should work and allow you to take dynamic user input for your filename.</p>
",0
18305810,18305742,9,"<p>Regarding this:</p>

<pre><code>int normalVariable = ReturnAReference();
</code></pre>

<p><code>normalVariable</code> is an integer, and is assigned the value of the int that <code>ReturnAReference()</code> references.  As such incrementing, assigning, or doing anything else to <code>normalVariable</code> will not affect whatever <code>ReturnAReference()</code> has internally.</p>

<p>Regarding this:</p>

<pre><code>int&amp; referenceVariable = ReturnAReference();
</code></pre>

<p><code>referenceVariable</code> is a reference to an integer that would otherwise be internal to <code>ReturnAReference()</code>.  As such incrementing, assigning, or doing anything else to <code>referenceVariable</code> <em>will</em> affect whatever <code>ReturnAReference()</code> has internally.</p>

<p>What is preferred depends on what you're trying to accomplish, but in many cases the second approach (using <code>referenceVariable</code>) violates ""encapsulation"" ( <a href=""http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)"" rel=""nofollow"">http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)</a> ), which is considered poor design.</p>

<p>EDIT:  And I should add that if ReturnAReference() is returning a reference to a variable that is local in that function, that reference will be invalid as soon as ReturnAReference() returns.</p>
",1
18305835,18305742,1,"<p>After a reference has been <em>initialized</em>, e.g. via</p>

<pre><code>int i = 42;

int&amp; r1 = i;
int&amp; r2 = ReturnAReference();
int&amp; r3(i);
int&amp; r4{i};      // C++11
int&amp; r5 = {i};   // C++11
</code></pre>

<p>it becomes an <em>alias</em>, i.e. another name, of the object it has been initialized with. It is <em>not</em> another integer. <sub>Note that in the language of the C++ Standard, an object is simply a region of storage, not necessarily an instance of a class.</sub></p>

<p>As a reference is an alias, if you operate with the reference, you'll operate <em>on the original object</em> (the one it has been initialized with):</p>

<pre><code>int i = 42;
int&amp; r = i;
// r is now an alias for i, both refer to the same object
r = 21;  // a true assignment
std::cout &lt;&lt; i; // will print 21
</code></pre>

<p>The statement</p>

<pre><code>int normalVariable = ReturnAReference();
</code></pre>

<p>introduces a new object of type <code>int</code> and a name for that object: <code>normalVariable</code>. This object is initialized with the object returned by <code>ReturnAReference()</code>, which means that the value of the returned object is copied into the new object called <code>normalVariable</code>.</p>

<p>On the other hand, the statement</p>

<pre><code>int&amp; referenceVariable = ReturnAReferene();
</code></pre>

<p>only introduces a new name for the object returned by <code>ReturnAReference()</code>.</p>

<hr>

<p>If your function would return a non-reference <code>int</code>, like <code>int ReturnAnInt();</code>, the statement</p>

<pre><code>int&amp; r = ReturnAnInt();
</code></pre>

<p>would become illegal, as the object returned by this function is a <em>temporary</em>, which only lives until the end of this line (in this case). In the next line, the name <code>r</code> would refer to an object that does not exist any more, so it has been made illegal to bind non-const references to temporary objects.</p>
",0
18305858,18305742,0,"<p>If you want to modify the variable returned by reference from the function, or to keep track of any changes to its value, use int&amp;. It's up to you to make sure the variable you are referencing will exist for as long as you access it. If you just care about the value of the variable returned by reference at that point, use int.</p>

<p>FYI, std::vector's operator [] and <code>at</code> functions return by reference allowing syntax such as the following <code>v.at(0) = 2</code>.</p>
",0
18306005,18305742,1,"<p>Let's suppose you have the following definitions :</p>

<pre><code>int test = 4;

int&amp; ReturnAReference() {
   return test;
}
</code></pre>

<p>1) Is there any difference between the two statements:</p>

<pre><code>int normalVariable = ReturnAReference();
</code></pre>

<p>In this case, <code>normalVariable</code> will hold a copy of the return value (not a reference), because the assignment operator copies the value referred by the return value into <code>normalVariable</code>.  This means that after</p>

<pre><code>normalVariable = 1;
</code></pre>

<p><code>normalVariable</code> will now be 1, but <code>test</code> will still be 4.  </p>

<p>However, if you were to have written </p>

<pre><code>int&amp; referenceVariable = ReturnAReferene();
</code></pre>

<p>and do</p>

<pre><code>normalVariable = 1;
</code></pre>

<p><code>normalVariable</code> would now be 1 and <code>test</code> would also be 1, since <code>normalVariable</code> is only an alias for <code>test</code>.  </p>

<p>Be careful though when you return a reference.  For instance, if you were to do</p>

<pre><code>int&amp; ReturnAReference() {
   int i = 0;
   return i;
}
</code></pre>

<p>the reference returned from <code>ReturnAReference()</code> would not be valid anymore, since it is only valid inside the function and will be destroyed when it is exited.  </p>

<p>2) Is one version preferred over the other?</p>

<p>In the case of ints or other primitive types, I would prefer the <code>int</code> return value over <code>int&amp;</code>, simply because an <code>int</code> is small and won't be expensive to copy (it will nearly always fit in a register).  Also, the <code>int&amp;</code> return value entails safety issues if the reference refers to a local variable.  For classes or structs, it always depends, but you have to be careful when returning local variables by reference or by pointer.  </p>
",0
14220364,5149334,1,"<p>In C++ variables are not guaranteed to be initialized with anything sensible.  If you create a variable of:
    MyType* next;</p>

<p>The <code>next</code> pointer can be <code>NULL</code> or it can be any other value.  This value will be junk, but will not be zero and will cause your access violation.</p>

<p>To guarantee that <code>next</code> is <code>NULL</code> you must ensure that it is set to <code>NULL</code> in the object's constructor.</p>

<p>See <a href=""https://stackoverflow.com/questions/2218254/variable-initialization-in-c"">Variable initialization in C++</a> for more information.</p>
",0
8741141,8741094,6,"<p>No, the error is in tool invocation. You need to link the two source files together (e.g. <code>g++ -o foo a.cc b.cc</code>). And remove one of the <code>main</code> functions, as you can't have two different ones.</p>
",1
14853492,12157685,11,"<p>You can calculate the z order curve value with the following code:</p>

<pre><code>uint32_t calcZOrder(uint16_t xPos, uint16_t yPos)
{
    static const uint32_t MASKS[] = {0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF};
    static const uint32_t SHIFTS[] = {1, 2, 4, 8};

    uint32_t x = xPos;  // Interleave lower 16 bits of x and y, so the bits of x
    uint32_t y = yPos;  // are in the even positions and bits from y in the odd;

    x = (x | (x &lt;&lt; SHIFTS[3])) &amp; MASKS[3];
    x = (x | (x &lt;&lt; SHIFTS[2])) &amp; MASKS[2];
    x = (x | (x &lt;&lt; SHIFTS[1])) &amp; MASKS[1];
    x = (x | (x &lt;&lt; SHIFTS[0])) &amp; MASKS[0];

    y = (y | (y &lt;&lt; SHIFTS[3])) &amp; MASKS[3];
    y = (y | (y &lt;&lt; SHIFTS[2])) &amp; MASKS[2];
    y = (y | (y &lt;&lt; SHIFTS[1])) &amp; MASKS[1];
    y = (y | (y &lt;&lt; SHIFTS[0])) &amp; MASKS[0];

    const uint32_t result = x | (y &lt;&lt; 1);
    return result;
}
</code></pre>

<p>It was taken from here <a href=""http://graphics.stanford.edu/~seander/bithacks.html"">Bit Twiddling Hacks</a></p>

<p>From you 128x128 array (or any other size) you can calculate easily the z order curve value from any position. For example:</p>

<pre><code>xPos = 2, yPos = 3 -&gt; z order curve value = 7
</code></pre>

<p>The max array size for the example code is 65536*65536. Just use a power of 2 for ease, in that case the maximum wasted space is approx. 3/4</p>
",4
8741323,8741294,6,"<p>A C++ compiler like <code>g++</code> will do the job. Write the string into a temporary file, run <code>g++ -fsyntax-only</code> on the file, and act on the return value.</p>
",0
8741333,8741294,2,"<p>You can paste the content of the string in a newly created <code>cpp</code> file and run <code>g++</code> or whatever compiler you can use on it and check the compiler's output.</p>
",0
9226251,9226221,4,"<p>If default construction and copy (or move) assignment are cheap, just use:</p>

<pre><code>myclass myobject;
if (set1)
    myobject = myclass(1, 2);
else
    myobject = myclass(3);
myobject.operation();
</code></pre>

<p>If it is acceptable to allocate things on the heap, use a pointer:</p>

<pre><code>std::unique_ptr&lt;myclass&gt; myobject;
// const std::auto_ptr&lt;myclass&gt; in C++03 (it's fine as long as you keep it unique)
if (set1)
    myobject.reset(new myclass(1, 2));
else
    myobject.reset(new myclass(3));
myobject-&gt;operation();
</code></pre>

<p>If you must allocate it on stack, I don't see anyway except using placement new (or changing the constructor to accept both possibilities).</p>

<pre><code>#include &lt;new&gt;

char myobject_buffer[sizeof(myclass)];
myclass* ptr;
if (set1)
    ptr = new (myobject_buffer) myclass(1, 2);
else
    ptr = new (myobject_buffer) myclass(3);
ptr-&gt;operation();
...
ptr-&gt;~myclass();  // &lt;-- use RAII to call this for exception safety
</code></pre>
",3
9226453,9226221,1,"<p>This is one of the cases where you need to use dynamic allocation, preferably with a smart pointer to keep automatic memory handling:</p>

<pre><code>std::unique_ptr&lt;myclass&gt; pmyobject;

if (set1)
{
    pmyobject.reset(new myclass(arg1, arg2));
}
else
{
    pmyobject.reset(new myclass(arg3));
}

pmyobject-&gt;operation();
</code></pre>

<p><code>std::unique_ptr</code> is a C++11 feature, but you can replace it with <code>boost::scoped_ptr</code> (which is not the exact equivalent, but is close enough).</p>

<p>You could also use <a href=""http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html"" rel=""nofollow"">Boost.Optional</a>, which can handle this kind of deferred initialization.</p>
",0
14225069,7347033,1,"<p>One usage I found is that if you want to automatically generate a huge number of lines in your class definition, it could be helpful to include the auto-generated file like this. </p>
",0
9850739,9850672,0,"<p>Your object construction and usage is correct and standard C++. The only problem is with your destruction code as you note. You are trying to take a pointer of a type - this is not going to work and the compiler won't let you do that. The destructor should be as simple as freeing the memory:</p>

<pre><code>~TestHSM() {
  if (state_)  {
    delete state_;
    state_ = 0;
  }
}
</code></pre>

<p>Also, be sure when you change states to delete the previous state. I.e. the next() function should look like this:</p>

<pre><code>void next(TopState&lt;TestHSM&gt; *state)
{ 
    if (state_)
      delete state_;
    state_ = state; 
}
</code></pre>

<p>You should always pass a state constructed using <code>new</code> to the next function and let <code>TestHSM</code> free it when it's unnecessary:</p>

<pre><code>int main()  {
  TestHSM test;
  test.next(new S211());
  // No freeing, TestHSM destructor frees everything
}
</code></pre>
",0
9850896,9850672,0,"<p>That class <code>TestHSM</code> presented is not following <a href=""https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">the rule of three</a>. It's missing a copy constructor and copy assignment operator, or a way to forbid them.</p>

<p>Your best option is to let someone else handle the resource management for you. For example, use a <code>std::unique_ptr</code>, or <code>boost::scoped_ptr</code> member. Either of these options will forbid copies of <code>TestHSM</code>. If the ability to copy is desirable, you will have to write a copy constructor by hand, along with some virtual copy mechanism (i.e. <code>clone()</code> member functions) for the states.</p>
",0
9185260,9185171,5,"<p>The difference between two pointers is undefined if the pointers do not point to the same array, or if the pointers were typecast from pointers to an unrelated type.</p>

<p>Also, the difference is not in bytes but is in the number of elements.</p>

<p>In your second case the difference is 1 byte, but it is being divided by sizeof(long). Note that because this is undefined behavior, absolutely any answer here would be correct.</p>
",4
9185262,9185171,2,"<p>Reinterpreting the underlying type of a pointer does not change its address. But pointer arithmetics yields different result depending on the pointer type. So what you have described here is perfectly correct and that is what I would expect. See <a href=""http://www.eskimo.com/~scs/cclass/notes/sx10b.html"" rel=""nofollow"">pointer arithmetics</a>.</p>
",0
9185272,9185171,0,"<p>Its doing integer (long) pointer arithmetic for <code>pi1 - pi</code>;</p>

<p>If <code>p1</code> were <code>&amp;p[4]</code> you'll see that it prints <code>1</code> for <code>d1</code> while the difference is actually 4 bytes. This is because <code>sizeof (long)</code> = 4 bytes.</p>
",1
9185303,9185171,10,"<p>As others have pointed, this is undefined behavior.  However, there is a very simple explanation for what you are seeing.</p>

<p>The difference between pointers is the number of elements, not the number of bytes between them.</p>

<p>pi and pi1 both point to longs, but the address pointed to by pi1 is only one byte further than pi.  Presuming longs are 4 bytes long, the difference in the addresses, 1, divided by the size of the element, 4, is 0.</p>

<p>Another way of thinking of this is you could imagine the compiler would generate code equivalent to this for calculating d1:</p>

<pre><code>int d1 = ((BYTE*)pi1 - (BYTE*)pi)/sizeof(long).
</code></pre>
",0
17097847,17097347,2,"<p>I agree with Csaba Toth in the comments.  This is a mess, and you should clean it properly.  Convince the people who put you on the project that it's worth taking the time to rewrite it with proper headers and source files.  It'll save them tons of development and support, and help to expose bugs before the customer finds it.</p>

<p>That said, you still need to deal with the extern.</p>

<p>Your choice 1 is very poor.  .cpp should never include another .cpp.  It's just short of a miracle that you don't get tons of ""already defined"" errors.</p>

<p>Choice 2 is defining another static-ish int in file B.  This will be a separate int from that in file C, and they can have different values.</p>

<p>What you need to do is declare file C's int as an <code>extern</code>.  You can do it in either the header or the cpp.  The trick is to make sure it's only instantiated in one place.</p>

<p>So, in some part of B, do this:</p>

<pre><code>extern int dog;
</code></pre>

<p>This tells the compiler that there will be an int called <code>dog</code> by the time the program is ready to run.  The linker will then look for one-and-only-one instance of that variable - currently residing in fileC.cpp - and point everything to the same place.</p>

<p>Your choice 3 was giving you issues because you have two globally scoped variables of the same name.  Using the <code>extern</code> will solve this.</p>

<p>Generally, good coding structure would be:</p>

<h3>Header files</h3>

<ul>
<li>Make sure to have wrappers, either <code>#ifdef MYFILE_H</code> or <code>#pragma once</code> if it's supported, to make sure that a .h can never be included more than one time.</li>
<li>Only put function declarations - you should have very few implementations, unless you're desperate to make it inline (and good compilers nowadays can optimize fine on their own for most situations). You should make sure any functions you implement are internal to that file only, and don't depend on other files.</li>
<li>You can refer to other file global variables using <code>extern</code>.</li>
</ul>

<h3>Cpp files</h3>

<p>The cleanest thing is to match implementations from your header, though compilers and linkers would let you implement anything anywhere.  The main rule to follow is that each function and each extern be implemented once and only once in all of your code.  There should only be one place with function <code>myFunc</code> and there should only be one place that declares <code>int dog</code> instead of <code>extern int dog</code>.  Both function declarations and <code>extern</code> variables tell the compiler ""don't worry about this, I'll make sure it's done"", and then the linker looks for it among all of your objects.</p>

<p>I'm guessing, from the fact that you didn't mention any errors in your choice 1 and choice 2, that you got as far as compiling, but never ran the linker.  My next guess is that this is a unix system, since Visual Studio takes care of both steps at once.  In that case, there must be some <code>make</code> system that will take care of building, or something.  You should've had errors with all three of your choices.</p>
",4
11550454,11550440,7,"<p>It's an array of pointers to an integer.  (array size is 9 elements.  Indexes: 0 - 8)</p>

<p>This can also be stated as being an array of integer pointers.</p>

<p><code>int array[9]</code> , is an array of integers.</p>
",1
11550463,11550440,1,"<p>an array of 9 pointers to int type</p>

<p>The asterisk means pointer. You can read the Backus-Naur form for C language to see the definitions of types.</p>
",1
11565007,11564053,0,"<p>you try to assign a void* to t which is of type Trigger.</p>

<p>since the ctor of Trigger accepts a void* try: </p>

<pre><code>for (int i = 0; i &lt; Gamma_Globals::gvTriggers.size(); i++)
{
    Trigger t( Gamma_Globals::gvTriggers[i] );
}
</code></pre>
",0
11565009,11564053,1,"<p>Your trigger.h includes globals.h. globals.h inturn includes trigger.h. So while compiling globals.h, the compiler has not seen Class Trigger.</p>

<p>Ideally, there should not be any cyclic dependency in your code. Either trigger.h will depend on globals.h or the opposite not both.</p>

<p>To compile this, you can create global.cpp and put the function definition in there. Note that this will not break the cyclic dependency.</p>
",0
9790717,9790679,0,"<p>Your assumption is correct.</p>

<p>You simply cannot create a temporary object with a single constructor argument in a context where the same statement could be a declaration. The grammar makes it ambiguous (or, it <em>would</em> be ambiguous if the behaviour you're seeing weren't defined to take precedence).</p>

<p>Why not give the object a name, instead?</p>

<pre><code>SomeClass obj(a);
</code></pre>

<p>Or, if you have a reason to want the object to be destroyed immediately (sometimes this is useful; e.g. a <code>boost::this_thread::interruption_point</code>, though that takes no arguments), you can still create a temporary but de-ambiguate the statement:</p>

<pre><code>(SomeClass(a));    // the parens prevent this from being a declarative statement
</code></pre>

<p>In some scenarios you may also be able to use C-style casts:</p>

<pre><code>(SomeClass)a;
</code></pre>

<p>But, hopefully, your <code>SomeClass</code> constructor is actually marked <code>explicit</code>, and we prefer not to use C-style casts anyway.</p>

<p>This problem doesn't arise in other contexts, ones in which a temporary might make more sense anyway:</p>

<pre><code>std::cout &lt;&lt; SomeClass(a);  // *can't* be a decl of a `SomeClass` called `a`
</code></pre>
",1
9790740,9790679,2,"<p>You can create that anonymouse object as the following:</p>

<pre><code>(SomeClass(a));
</code></pre>

<p>This resolves the ambiguity since it can't be a declaration of <code>a</code>.</p>

<pre><code>(SomeClass a); // Error: this can't be a declaration because of the parentheses
               //        but what else should it be?
</code></pre>
",0
9790742,9790679,3,"<p>You can construct a temporary object in a statement of its own with something like:</p>

<pre><code>(SomeClass)a;
</code></pre>

<p>or</p>

<pre><code>(SomeClass(a));
</code></pre>

<p>As you've observed, the parentheses are needed to resolve the ambiguity between a declaration and an expression statement.</p>
",0
9790755,9790679,1,"<p>In general, you avoid the most vexing parse by writing code with the same effect as what you wanted to write, but that can't be parsed as a declaration.</p>

<p>Often, this is done by adding parentheses.</p>

<p>In this case <code>(SomeClass(a));</code> will do, or <code>(void) SomeClass(a);</code></p>
",0
9790842,9790679,2,"<p>In that context, the braces are superfluous, which means</p>

<pre><code>SomeClass(a); //declaration of a
</code></pre>

<p>is exactly equivalent to</p>

<pre><code>SomeClass a; //declaration of a
</code></pre>

<p>which is again equivalent to these:</p>

<pre><code>SomeClass((a)));       //declaration of a
SomeClass(((a)));      //declaration of a
SomeClass((((a))));    //declaration of a
SomeClass(((((a)))));  //declaration of a
</code></pre>

<p>All of these declare a variable of name <code>a</code> and type <code>SomeClass</code>.</p>
",0
8758663,8758445,5,"<pre><code>KlasaNiePOD obiekt1; // first case
</code></pre>

<p>This is <em>default-initialised</em>; since it doesn't have a default constructor, members with a fundamental type (which includes numeric types) are left uninitialised.</p>

<pre><code>KlasaNiePOD obiekt2 = KlasaNiePOD(); // second case
</code></pre>

<p>The temporary <code>KlasaNiePOD()</code> is <em>value-initialised</em>; since it doesn't have a default constructor, members with a numeric type are initialised to zero.</p>
",12
8758734,8758445,3,"<p>The standard defines several different types of initialization,
depending on context.  Zero-initialization sets all of the members to 0
(converted to the appropriate type, so pointers will be set to a null
pointer value, even if the null pointer isn't all zero bits); no
constructor is called.  Default-initialization calls the default 
constructor, which be default doesn't do anything.  Value-initialization
calls the default constructor if a user defined constructor is present,
but does zero-initialization, followed by the default constructor, if
there is no user defined constructor.  An object whose initializer is
simply <code>()</code> (an empty list) is value-initialized.  An object with static
lifetime is zero-initialized before program start (always); if it has a
non-trivial constructor, its constructor will be called sometime later
(but before entering <code>main</code>).  All other objects defined with no
initializer are default-initialized.</p>

<p>In your code, <code>obiekt1</code> is default-initialized; in this case, a no-op
(leaving the members uninitialized).  <code>obiekt2</code> is initialized by copy
of a value-initialized temporary; the value-initialization sets <code>a</code> to
0.  (The actual copy may be optimized out, with the value-initialization
taking place directly on the object.)</p>
",0
8758760,8758445,1,"<p>ISO 14882:2011(e) 8.5.1 :</p>

<blockquote>
  <p>An aggregate is an array or a class (Clause 9) with no user-provided
  constructors (12.1), no brace-or-equalinitializers for non-static data
  members (9.2), no private or protected non-static data members (Clause
  11), no base classes (Clause 10), and no virtual functions (10.3).</p>
</blockquote>

<p>As such, your class is an aggregate.</p>

<pre><code>KlasaNiePOD obiekt2 = KlasaNiePOD(); // second case
</code></pre>

<p>will invoke aggregate and finally value initialization, causing the int to be zero intialized.</p>

<p>Add</p>

<pre><code>KlasaNiePOD(){}
</code></pre>

<p>to your class definition, and you will see that the setting to 0 will vanish (as this will make it not an aggregate anymore).</p>
",0
12329360,12329336,2,"<p>Don't know where the exception comes from, but this just doesn't work</p>

<pre><code>string s;
for(int i=0;i&lt;n;i++) 
    s[i]='i';
</code></pre>

<p>because the string is initially empty, and all <code>s[i]</code> will be out of bounds.</p>

<p>To add characters to the string in a loop, try</p>

<pre><code>string s;
for(int i=0;i&lt;n;i++) 
    s.push_back('i');
</code></pre>

<p>If you just want a string with lots of <code>'i'</code>s, you can do that when constructing it:</p>

<pre><code>string s(n, 'i');
</code></pre>
",1
15545408,15545330,6,"<p>From a language point of view, there is nothing to warn about.  <code>i</code> is promoted to <code>unsigned int</code> before the <code>&lt;</code> is evaluated.  And it's perfectly well-defined to increment an <code>unsigned char</code> such that it wraps around to zero.</p>

<p><s>The fact that this code does something irritating is unfortunate.  But it's not clear what rule a compiler would need to apply in order to detect this sort of thing.</s></p>

<p><strong>Thanks to @unwind in the comments below:</strong> you can get GCC to warn about the fact that this comparison must always evaluate to true using the <a href=""http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wtype_002dlimits-411"" rel=""nofollow""><code>-Wtype-limits</code></a> flag.</p>

<p><strong>Update 2:</strong> Apparently the above option doesn't work in this case (I don't have a ""modern"" version of GCC to hand right now...)</p>
",4
15545419,15545330,1,"<p><code>i</code> is promoted to <code>unsigned</code> and then compared to <code>test</code>. No problems here. Well. i++ will overflow the char, but that is a run-time problem. What I mean is that after 255 it will be 0, and that maybe not what the author espect, making the cycle potencialy infinite if there are not other form of terminating it ( a break, a retun, etc) That is a posible ""logical"" run time error.  </p>
",2
15545477,15545330,1,"<p>Because comparing an <code>unsigned char</code> and <code>unsigned</code> is perfectly legal. The problem only starts to show up due to the loop counter obviously overflowing, but I'm not sure compilers will ever be <a href=""http://en.wikipedia.org/wiki/Telepathy"" rel=""nofollow""><em>that</em> smart</a>.</p>
",5
15545514,15545330,1,"<p>From the draft standard:</p>
<blockquote>
<p><strong>4.5 Integral promotions</strong></p>
<p>A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer
conversion rank (4.13) is less than the rank of int can be converted
to a prvalue of type int if int can represent all the values of the
source type; otherwise, the source prvalue can be converted to a
prvalue of type unsigned int.</p>
</blockquote>
",0
15537864,15537817,24,"<p><strong>Edit from 2018</strong>: In C++17 the answer to this question is different. You still have to store your arguments in a <code>::std::tuple</code>, but when the time comes to call the function <a href=""https://en.cppreference.com/w/cpp/utility/apply"" rel=""noreferrer""><code>::std::apply</code></a> handles unpacking this tuple and calling the function for you. And if you need to use the indices trick for something other than what <code>::std::apply</code> does, there's <a href=""https://en.cppreference.com/w/cpp/utility/integer_sequence"" rel=""noreferrer""><code>::std::integer_sequence</code></a> and the associated helper function, <code>::std::make_index_sequence</code> that you should investigate.</p>

<p>Now back to your C++11/14 answer from way back in 2013.</p>

<p>You have to use <code>::std::tuple&lt;Args...&gt;</code> to store it. But then the question is how to unpack it when you need it. For that you need to use a technique called 'indices'.</p>

<p>So, here is a link to a place where I've done approximately what you're looking to do. The most relevant class here that's sort of the centerpiece is <code>suspended_call</code>.</p>

<p><a href=""https://bitbucket.org/omnifarious/sparkles/src/tip/sparkles/deferred.hpp?at=default"" rel=""noreferrer"">https://bitbucket.org/omnifarious/sparkles/src/tip/sparkles/deferred.hpp?at=default</a></p>

<p>In just a bit, I'll extract the most relevant bits and put them in terms of your code.</p>

<p><a href=""https://bitbucket.org/omnifarious/sparkles/src/d78af18c74b812d54f7e20146f465c9002a804a7/sparkles/deferred.hpp?at=default#cl-338"" rel=""noreferrer"">This line</a>:</p>

<pre><code>auto saved_args = ::std::make_tuple(::std::move(args)...);
</code></pre>

<p>saves the arguments into a tuple. I used <code>::std::move</code> there, and I think that's the right thing to do. But it's possible I'm wrong and I should use <code>::std::forward</code>. I've never been clear on the exact difference aside from signaling intent.</p>

<p>The code that actually does the call with the saved arguments can be found <a href=""https://bitbucket.org/omnifarious/sparkles/src/d78af18c74b812d54f7e20146f465c9002a804a7/sparkles/deferred.hpp?at=default#cl-208"" rel=""noreferrer"">here</a>. Now that code is fairly specific to exactly what I'm doing. The bit that implements the indices trick involves creating a pack of integers that maps to the indices to use as arguments the <code>::std::get&lt;I&gt;</code> template. Once you have this pack of integers, you can then use it to expand the call to <code>::std::get</code> to get all the tuple elements as individual arguments.</p>

<p>I'll try to come up with code that does that in a relatively straightforward way:</p>

<pre><code>#include &lt;tuple&gt;
#include &lt;cstddef&gt;
#include &lt;string&gt;
#include &lt;utility&gt;

template &lt; ::std::size_t... Indices&gt;
struct indices {};

template &lt; ::std::size_t N, ::std::size_t... Is&gt;
struct build_indices : build_indices&lt;N-1, N-1, Is...&gt;
{};

template &lt; ::std::size_t... Is&gt;
struct build_indices&lt;0, Is...&gt; : indices&lt;Is...&gt;
{};

template &lt;typename FuncT, typename ArgTuple, ::std::size_t... Indices&gt;
auto call(const FuncT &amp;f, ArgTuple &amp;&amp;args, const indices&lt;Indices...&gt; &amp;)
   -&gt; decltype(f(::std::get&lt;Indices&gt;(::std::forward&lt;ArgTuple&gt;(args))...))
{
   return ::std::move(f(::std::get&lt;Indices&gt;(::std::forward&lt;ArgTuple&gt;(args))...));
}

template &lt;typename FuncT, typename ArgTuple&gt;
auto call(const FuncT &amp;f, ArgTuple &amp;&amp;args)
     -&gt; decltype(call(f, args,
                      build_indices&lt; ::std::tuple_size&lt;ArgTuple&gt;::value&gt;{}))
{
    const build_indices&lt; ::std::tuple_size&lt;ArgTuple&gt;::value&gt; indices;

    return ::std::move(call(f, ::std::move(args), indices));
}

int myfunc(::std::string name, const unsigned int foo)
{
   return 0;
}

int foo(::std::tuple&lt; ::std::string, const unsigned int&gt; saved_args)
{
   return call(myfunc, ::std::move(saved_args));
}
</code></pre>

<p>A lot of this code was borrowed from <a href=""http://loungecpp.wikidot.com/tips-and-tricks:indices"" rel=""noreferrer"">this page on the indices trick</a>.</p>

<p>Also, that's sort of a sample that you will have to adapt slightly to your specific situation. Basically, just call <code>call(nestFunc, saved_args)</code> somewhere.</p>
",9
18262850,18262701,2,"<p>Looking over the code, you'll need to a way to instantiate your reference to <code>std::future&lt;Worldlet&gt; &amp;result;</code> </p>

<p>Typically, this is done through a constructor. </p>

<pre><code>struct LoadingWorldlet 
{
    LoadingWorldlet( std::future&lt;Worldlet&gt; &amp; inWorldlet ): 
        result( inWorldlet ) {}

    int x, z;
    std::future&lt;Worldlet&gt; &amp;result; 
};
</code></pre>

<p>Otherwise, you could simply not make the data member a reference ( this assumes that other data members don't also have mandatory constructors): </p>

<p><code>std::future&lt;Worldlet&gt; result;</code> </p>
",2
11134620,11134405,1,"<p>The code works for me if the 'end' is declared as const char *:</p>

<pre><code>#include &lt;string&gt;
using std::string;

string trim(char const *str){
  while(!isalnum(*str)) str++;
  char const *end = str + strlen(str) - 1;
  while(end &gt; str &amp;&amp; !isalnum(*end)) end--;
  return string(str, end+1);
}

int _tmain(int argc, _TCHAR* argv[])
{
  char buf[] = ""  abc "";
  printf(""%s"", trim(buf).c_str()); // got ""abc""
  return 0;
}
</code></pre>

<p>ps. vc10.</p>
",0
11134638,11134405,1,"<p>Here's a trio of functions I use that may be helpful:</p>

<p>The sch-parameter is a set of characters to be trimmed off.</p>

<pre><code>void LTRIM(std::string&amp; s, const char *sch)
{
    std::string ss=sch;
    int i=0, n=s.length();
    while ((i&lt;n) &amp;&amp; (ss.find(s.at(i),0)!=std::string::npos)) i++;
    s = (i&gt;0)?s.substr(i,n-i):s;
}

void RTRIM(std::string&amp; s, const char *sch)
{
    std::string ss=sch;
    int n = s.length()-1;
    int i=n;
    while ((i&gt;0) &amp;&amp; (ss.find( s.at(i),0)!=std::string::npos)) i--;
    s = (i&lt;n)?s.substr(0,i+1):s;
}

void TRIM(std::string&amp; s, const char *sch) { LTRIM(s, sch); RTRIM(s, sch); }
</code></pre>
",0
8769914,8769898,12,"<p>C++11 standardized <code>__func__</code> for the current function.</p>

<p>Various compilers support variations of <code>__FUNCTION__</code>, <code>__PRETTY_FUNCTION__</code>, and others.</p>
",0
8769917,8769898,2,"<p>If you're doing GNU compatible stuffs, you may want to try <a href=""http://www.gnu.org/software/libc/manual/html_node/Backtraces.html"" rel=""nofollow"">backtrace</a>.</p>
",1
8769918,8769898,0,"<p>No.</p>

<p>C++'s <a href=""http://en.wikipedia.org/wiki/Run-time_type_information"" rel=""nofollow"">run-time type identification</a> allows you to figure out the type of an object, but not the name of the method you're currently in.</p>
",0
8769920,8769898,0,"<p>No, it is not possible. C++ does not support reflection (neither static nor dynamic) (like e.g. C#). You would need some preprocessor magic to emulate that.</p>

<p>Apart from that, there is not necessarily a notion of a function/method name during run-time (this only available as debugging information if you compiled your sources with the corresponding flags).</p>
",0
15501048,15500704,3,"<p>You can do it like</p>

<pre><code>int h1,h2,m1,m2,s1,s2;
h1 = h2 = m1 = m2 = s1 = s2 = 0;
char mark;
if (scanf(""%1d%1d:%1d%1d:%1d%1d %c"", &amp;h1, &amp;h2, &amp;m1, &amp;m2, &amp;s1, &amp;s2, &amp;mark) != 7)
{
    //some error handling
}
</code></pre>

<p>It's indeed strange to use different variables for digits rather than for hours, mins and seconds, like</p>

<pre><code>scanf(""%d:%d:%d %c"", &amp;h, &amp;m, &amp;s, &amp;mark);
</code></pre>

<p>For those commenting that cstdio is obsolete, personally I like it more than <code>iostream</code>. </p>
",0
15501105,15500704,0,"<p>You can use a trash variable to scan the ':' part with %c</p>

<pre><code>scanf(""%1d%1d%c%1d%1d%c%1d%1d"", &amp;h1, &amp;h2, &amp;trash, &amp;m1, &amp;m2, &amp;trash, &amp;s1, &amp;s2);
</code></pre>

<p>But, I also vote to not use scanf and use more robust input parsers (depending on the context you are using it in)</p>
",1
15501031,15500704,1,"<p>Reading the <a href=""http://linux.die.net/man/3/scanf"" rel=""nofollow"">docs</a> you'll see that it's as simple as</p>

<pre><code>int h, m, s;
char mark;
const char* buf = ""00:15:14 D"";
sscanf(buf, ""%d:%d:%d %c"", &amp;h, &amp;m, &amp;s, &amp;mark);
fprintf(stdout, ""h = %d, m = %d, s = %d, mark = %c\n"", h, m, s, mark);
</code></pre>
",0
13729905,13729860,3,"<p>As long as the list stores the data by reference or pointer and the destructor is virtual you're fine.</p>

<p>The basic problem is that you are not allowed to store a C into a variable of <code>A</code>, but you can store it into <code>A&amp;</code> or <code>A*</code>. So <code>A a = C()</code> would be just as bad as storing a C into a <code>list&lt;A&gt;</code> or <code>vector&lt;A&gt;</code>. This would lead to <a href=""https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c"">slicing</a></p>
",4
13730197,13729860,0,"<p>Technically, as long as you add references or pointers of the objects to the list in order to avoid slicing and have virtual destructors you should be safe.</p>

<p>You could think of <code>A</code> and <code>B</code> as being interfaces to the polymorphic type. Take a look at this example:</p>

<pre><code>class Drawable
{
    public:
        virtual ~Drawable() { }
        virtual void draw();
};

class Circle : public Drawable
{
    public:
        void draw() { std::cout &lt;&lt; ""Drawing a circle\n""; }
}

class Square : public Drawable
{
    public:
        void draw() { std::cout &lt;&lt; ""Drawing a square\n""; }
}

int main()
{
    std::list&lt;Drawable*&gt; shapeList { new Square(), new Circle(), new Square() };
}
</code></pre>
",0
10768187,10768169,10,"<p>The problem is here:</p>

<pre><code>r=mark&gt;=35?""pass"":""fail"";
</code></pre>

<p>You cannot assign a string literal to a <code>char</code> array. You have several options:</p>

<ul>
<li>use <code>strcpy()</code> instead of assignment;</li>
<li>change <code>r</code> to be of type <code>const char*</code>;</li>
<li>change <code>r</code> to be of type <code>std::string</code>.</li>
</ul>

<p>The last option is by far the best.</p>
",9
12857381,12857297,2,"<p>You could:</p>

<ul>
<li><p>Use polymorphism by adding a virtual setter function for <code>i</code> and <code>j</code>:</p>

<pre><code>class A {
public:
    virtual void set( int ) = 0;
};

class B : public A {
public:
    void set( int value )
    {
        i = value;
    }

private:
    int i;
};

class C : public A {
public:
    void set( int value )
    {
        j = value;
    }

private:
    int j;
};

class P
{
public:
    void change(A * obj)
    {
        obj-&gt;set(1);
    }
};

int main()
{
    A *b = new B();
    A *c = new C();
    P p;
    p.change(b);
    p.change(c);
    return 0;
}
</code></pre></li>
<li><p>Case the pointer before passing it:</p>

<pre><code> A *b = new B();
 A *c = new C();
 P p;
 p.change(static_cast&lt;B*&gt;(b));
 p.change(static_cast&lt;C*&gt;(c));
</code></pre></li>
<li><p>Place the variable into the base class (and get rid of two <code>change()</code> functions):</p>

<pre><code>class A {
public:
    int i;
};

class B : public A {};

class C : public A {};
</code></pre></li>
</ul>
",0
12857429,12857297,1,"<p>I would tweak your class hierachy to use polymorphism:</p>

<pre><code>class A
{
public:
    virtual void SetVariable(const int value) = 0;
};

class B : public A
{
public:
    virtual void SetVariable(const int value) override { i = value; }
    int i;
};

class C : public A
{
public:
    virtual void SetVariable(const int value) override { j = value; }
    int j;
};

class P
{
public:
    void change(A *a)
    {
        a-&gt;SetVariable(1);
    }
};
</code></pre>

<p>This way you can use pointers to the base class (<code>A</code>) without knowing which specific derived type they are.</p>
",0
12857442,12857297,2,"<pre><code>Polymorphism is one answer

class A
{
public:
    virtual void set() = 0;
};


class B : public A
{
public:
    virtual void set() { i = 1; }
private:
    int i;
};

class C : public A
{
public:
    virtual void set() { j = 1; }
private:
    int j;
};

class P
{
public:
    void change(A *a)
    {
        a-&gt;set();
    }
};

int main()
{
    A *b = new B();
    A *c = new C();
    P p;
    p.change(b);
    p.change(c);
    return 0;
}
</code></pre>

<p>With polymorphism there is no need for multiple <code>change</code> methods.</p>
",0
12857460,12857297,1,"<p><strong>Root Cause:</strong>    </p>

<p>When you call <code>change()</code> the parameter you pass is of the type <code>A *</code>, there is no exact match for this function in class <code>P</code>. The compiler tries to find the best possible match and it has two choices:</p>

<pre><code>void change(B *); 
void change(C *);
</code></pre>

<p>None of them is a best match because each requires conversion from <code>A*</code> to <code>B*</code> or <code>C*</code>. Not that your classes do not provide for this conversion function and hence compiler reports the error.</p>

<p><strong>Resolution:</strong>     </p>

<p>You tell the compiler exactly which version of the function to chose by using casting.</p>

<pre><code>p.change(static_cast&lt;B*&gt;(b));  
p.change(static_cast&lt;C*&gt;(c)); 
</code></pre>

<p>In both of above cases you know the actual type of the object being pointed by <code>A *</code> and so you can use <code>static_cast</code> and guide the compiler to find the best match function.</p>
",0
9196106,9196028,4,"<p>Just take a reference to the value.</p>

<pre><code>EmployeeDetail&amp; det = iter-&gt;second;   // notice new '&amp;' character.
det.salary = 1000;   // modifies the 'EmployeeDetail' object in-place.
</code></pre>
",0
9196116,9196028,0,"<p>Get a reference to the EmployeeDetail.</p>
",2
9196121,9196028,6,"<p><code>iter-&gt;second</code> is a reference to the <code>EmployeeDetail</code> object, which you can modify directly - e.g.</p>

<pre><code>   foreach( iter, eMap )  
   {  
       if ( compareByNameAge(name, age, iter-&gt;first) )  
       {
           iter-&gt;second.salary = 1000;
       }  
   }  
</code></pre>

<p>No need for the <code>transformMap</code></p>
",3
9196129,9196028,9,"<p>You can simply modifiy the element directly through the iterator (which points directly to the corresponding item):</p>

<pre><code>foreach(iter, eMap)  
{  
   if (compareByNameAge(name, age, iter-&gt;first))  
     iter-&gt;second.salary = 1000;   
} 
</code></pre>

<p>for more complex modifications you could take the value by reference:</p>

<pre><code>EmployeeDetail&amp; det = iter-&gt;second;  
det.salary = 1000;  
</code></pre>

<p>In c++ you can typically not modify a collection while iterating, but that only means that you can't remove/add items. Modifying existing items is typically fine in C++11. What you can't modify is the key in a <code>map</code> and any part of the element in <code>set</code>, but those are <code>const</code> in c++11 anyways, so you can't modify those. In C++03 you need to remember not to change the keypart of an element in a <code>set</code>.</p>
",0
9196830,9196028,0,"<p>If you have C++11, try this:</p>

<pre><code>for (auto&amp; pair : eMap )
  if (pair.first.name == ""Rob"")
    pair.second.salary *= 1000;
</code></pre>

<p>Note: you can only change <code>pair.second</code>. <code>pair.first</code> is const, and must not be changed (it is, after all, the key to the map.)</p>

<p>If you don't have C++11, try this:</p>

<pre><code>for(EmployeeMap::iterator it = eMap.begin(); it != eMap.end(); ++it)
  if(pair.first.name == ""Rob"")
    pair.second.hours /= 2;
</code></pre>
",0
9196143,9196028,1,"<p>Wouldn't just iterating over the map and doing</p>

<p>iter->second.salary = 1000;</p>

<p>solve your problem?</p>
",0
9196853,9196028,1,"<p>You can't use <code>std::transform</code> because it assigns iterators, and the <code>first</code> element of a map iterator is always const.</p>

<p>Additionally your code doesn't show us the comparison for your employee key, so I'll assume you have one that implements strict weak ordering. A basic outline:</p>

<p>You can use <code>for_each</code> though, since the predicate can be stateless:</p>

<pre><code>class SalaryUpdater
{
public:
    SalaryUpdater(const std::string&amp; name, int age) : name_(name), age_(age) { }

    void operator()(EmployeeMap::value_type&amp; item)
    {
        if(compareByNameAge(name_, age_, item.first))
        {
            item.second.salary = 1000;
        }
    }

private:
    std::string name_;
    int age_;
};

int main()
{
    EmployeeMap eMap;
    // insert entries to the map

    std::for_each(eMap.begin(), eMap.end(), SalaryUpdater(""John"", 10));
}
</code></pre>
",0
9196152,9196028,1,"<p>It's fine to alter the values of the <code>map</code> objects (the <code>second</code> part of the <code>value_type</code>) during <code>foreach</code> iteration. You just can't add or remove any keys--no <code>insert</code> or <code>erase</code>. </p>
",0
9196236,9196028,2,"<p>Can't you just do the following?</p>

<pre><code>it-&gt;second.salary = 1000;
</code></pre>
",0
15892950,15892877,16,"<p>You probably have set std::cout to print hex in prior in the context of your code but forget to reset. For example:</p>

<pre><code>std::cout&lt;&lt;std::hex&lt;&lt;12;
/*blah blah blah*/
std::cout&lt;&lt;12; //this will print in hex form still
</code></pre>

<p>so you have to do like the following</p>

<pre><code>std::cout&lt;&lt;std::dec&lt;&lt;12;
</code></pre>

<p>to print in decimal form.</p>
",0
15893001,15892877,4,"<p>Try to find line like this <code>std::cout &lt;&lt; std::showbase &lt;&lt; std::hex;</code> some where in your code, which sets <code>std::cout</code> to print output in hexadecimal with <code>0x</code> base indicator prefix.
To reset it to show decimal add this line <code>std::cout&lt;&lt;std::dec</code> before the current cout. </p>

<p>You can learn more about c++ io manipulators flags <a href=""http://www.cplusplus.com/reference/ios/"" rel=""nofollow"">here</a></p>
",0
11166154,11166136,2,"<p>Consider using an <code>ifstream</code> to read the file.</p>

<p>Then you can use the <code>&gt;&gt; operator</code> to move the next word into the <code>string</code>.</p>
",0
11166168,11166136,5,"<p>There are ""fancier"" ways, but in my opinion the following's most understandable (and useful as a basis for variations) for beginners:</p>

<pre><code>if (std::ifstream input(filename))
{
    std::vector&lt;std::string&gt; words;
    std::string word;
    while (input &gt;&gt; word)
        words.push_back(word);
}
</code></pre>
",1
14779950,14779795,3,"<p>There are several <a href=""http://en.cppreference.com/w/cpp/container/vector/vector"" rel=""nofollow"">two-argument constructors</a> for <code>std::vector</code>.  You haven't provided the types of <code>row</code> and <code>col</code>, but I suspect your code is not going to do what you expect.  If you want to initialize a vector in two dimensions, you'll need the constructor that takes a size and a value for initializing each element.  In this case, that value is itself a vector.</p>

<pre><code>int row = 5;
std::vector&lt;bool&gt; col(5, false);
grid_ = std::vector&lt;std::vector&lt;bool&gt;&gt;(row, col);
</code></pre>

<p>This would initialize a 5x5 grid of bools, all set to <code>false</code>.</p>
",0
14780010,14779795,0,"<p>Given the original code</p>

<pre><code>grid_ = new vector&lt;vector&lt;bool&gt; &gt; (row, col);  
</code></pre>

<p>where &ldquo;<code>row</code> and <code>col</code> are both ""int""&rdquo;, here&rsquo;s what&rsquo;s wrong with it:</p>

<ul>
<li><p>The <code>vector</code> constructor used creates a vector of <code>row</code> elements, initialized to the <code>col</code> value. The probability that this is intended, is near zero.</p></li>
<li><p>A vector is dynamically allocated, which is almost never needed: <code>vector</code> is a resizable container.</p></li>
<li><p>It uses <code>vector&lt;bool&gt;</code>, which due to its impractical specialization (where each <code>bool</code> can be stored as a single bit, which means you can&rsquo;t obtain a reference to it) is generally avoided. </p></li>
</ul>

<p>Instead, a good solution for a matrix of boolean values is to use a single vector with elements of e.g. enumeration type, and compute indices.</p>

<hr>

<p>Update: checking it, the code does not even compile, i.e. <strong>the information given in the Q is incorrect</strong>.</p>

<pre><code>#include &lt;vector&gt;
using namespace std;

int main()
{
    int row = 0;
    int col = 0;
    auto x = new vector&lt;vector&lt;bool&gt; &gt; (row, col);
}
</code></pre>

<pre>
[D:\dev\test]
> <i>g++ foo.cpp</i>
In file included from d:\bin\mingw\bin\../lib/gcc/i686-pc-mingw32/4.7.2/../../../../include/c++/4.7.2/vector:65:0,
                 from foo.cpp:1:
d:\bin\mingw\bin\../lib/gcc/i686-pc-mingw32/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h: In instantiation of 'void std::vector::_M_initialize_dispatch(_Integer, _Integer, std::__true_type) [with _Integer = int; _Tp = std::vector; _Alloc = std::allocat
or >]':
d:\bin\mingw\bin\../lib/gcc/i686-pc-mingw32/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h:393:4:   required from 'std::vector::vector(_InputIterator, _InputIterator, const allocator_type&) [with _InputIterator = int; _Tp = std::vector; _Alloc = std::all
ocator >; std::vector::allocator_type = std::allocator >]'
foo.cpp:8:49:   required from here
d:\bin\mingw\bin\../lib/gcc/i686-pc-mingw32/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h:1137:4: error: no matching function for ca
ll to 'std::vector >::_M_fill_initialize(std::vector >::size_type, int&)'
d:\bin\mingw\bin\../lib/gcc/i686-pc-mingw32/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h:1137:4: note: candidate is:
d:\bin\mingw\bin\../lib/gcc/i686-pc-mingw32/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h:1179:7: note: void std::vector::_M_fill_initialize(std::vector::size_type, const value_type&) [with _Tp = std::vector; _Alloc = std::allocator >; std::vector::size_type = unsigned int; std::vector::value_type = std::vector]
d:\bin\mingw\bin\../lib/gcc/i686-pc-mingw32/4.7.2/../../../../include/c++/4.7.2/bits/stl_vector.h:1179:7: note:   no known conversion for ar
gument 2 from 'int' to 'const value_type& {aka const std::vector&}'

[D:\dev\test]
> _
</pre>
",2
12825199,5430566,0,"<p>usually, using std::stringstream is the right answer.
yet sometimes, when interfacing C code, using printf(fmt, ...) is necessary, so std::stringstream isn't possible.
in these cases one can still format a variable length string like so:</p>

<pre><code>static void append_format(std::string&amp; s, const char* format, va_list vl)
{
    auto cur_length = s.length();
    auto sz = vsnprintf(NULL, 0, format, vl);
    s.resize(cur_length + sz);
    auto sz2 = vsnprintf(&amp;s[cur_length], sz + 1, format, vl);
    assert(sz2 == sz);
}

static void example_usage()
{
   std::string s;
   append_format(s, ""%s %dD world"", ""hello"", 3); // s == ""hello 3D world""
   append_format(s, "", PI= ~%f"", 3.14); // s == ""hello 3D world, PI= ~3.14""
   std::cout &lt;&lt; s;
}
</code></pre>

<p>note, that this method is not type safe because printf and its clones are not type safe. but it will not cause buffer overruns for valid invocations, no matter how long the result string turns out to be</p>
",0
9203584,9203544,8,"<p>Yes, but not the way you've written it... If you want the function to modify the passed in object, accept a <em>reference</em> rather than by value...</p>

<p>It appears you've not learned about <a href=""http://en.wikipedia.org/wiki/Reference_%28C++%29"" rel=""noreferrer"">references</a> in c++.</p>

<pre><code>// Declaration of function in class
friend void updateInfo(myinfo&amp;);
</code></pre>

<p>implementation</p>

<pre><code>void updateInfo(myinfo&amp; c)
{
  strcat(c.name, "":updated"");  // now modifying passed in instance of c.
  c.id++;
  c.income += 1.1;
}
</code></pre>

<p>Btw. on a side note, prefer to use <code>std::string</code> and also learn about <em>rule of three</em> (specially for non-trivial classes such as this).</p>
",6
9203597,9203544,0,"<p>Yes, In principle, private and protected members of a class cannot be accessed from outside the same class in which they are declared. However, this rule does not affect friends.</p>

<p>Friends are functions or classes declared with the friend keyword.</p>

<p>If we want to declare an external function as friend of a class, thus allowing this function to have access to the private and protected members of this class, we do it by declaring a prototype of this external function within the class, and preceding it with the keyword friend. </p>

<p>See it here - <a href=""http://www.cplusplus.com/doc/tutorial/inheritance/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/inheritance/</a></p>
",0
14837620,14837484,9,"<p>C++ follows the normal mathematical orders of precedent.</p>

<p>This line:</p>

<pre><code>sum=sum+(vecx[i]-average*vecx[i]-average);
</code></pre>

<p>looks incorrect. Multiplication happens before subtraction so it's calculating this:</p>

<pre><code>sum=sum+((vecx[i]-(average*vecx[i]))-average);
</code></pre>

<p>but presumably you meant this:</p>

<pre><code>sum=sum+((vecx[i]-average)*(vecx[i]-average));
</code></pre>

<p>You might be interested in seeing <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""noreferrer"">the full list of precedence ordering</a>.</p>
",4
14837671,14837484,5,"<p>You are never writing data out to your file. Use your <code>ofstream outData</code> instead of <code>std::cout</code>. Otherwise, you are only sending your output to the console.</p>

<pre><code>//open output stream
ofstream outData;
outData.open(""out.txt"");
//output  mean and standard deviation

outData &lt;&lt; ""Average is "" &lt;&lt; average &lt;&lt; endl;
outData &lt;&lt; ""Standard deviation is "" &lt;&lt; stdev &lt;&lt; endl;

//close stream
outData.close();
</code></pre>
",4
13466771,13466373,1,"<p>The basic formula you need to calculate it is:</p>

<p><em>P pixels / S seconds * delta T seconds/frame = X pixels/frame</em></p>

<p>For example we'll use your tile size and move it in 1 second and the current frame rate is 30 fps.</p>

<p><em>32 pixels / 1 second * .033 seconds/frame = 1.056 pixels/frame</em></p>

<pre><code>int P = 32;
double S = 1.0;
double T = getFrameTime();
double X = P / S * T;
</code></pre>
",2
9806582,9806507,1,"<p>There is <a href=""http://www.boost.org/doc/libs/1_44_0/libs/multi_index/doc/index.html"" rel=""nofollow"">Boost.Multi-index</a>.  You need to specify all the columns you want to build indices for in advance, though.</p>

<p>If you <code>order by</code> a column which doesn't have an index in SQL, it'll just do a linear scan and build a sorted result set on the fly - you can always do the same in C++ if you want to order by some column you didn't index in advance.</p>
",1
9806612,9806507,2,"<p>well you would have to do some of the leg work.</p>

<p>Consder making a struct or tuple to hold a a row:</p>

<pre><code>struct row{
   unsigned rank;
   std::string city;
   double area;
   //so on
}; 
</code></pre>

<p>On populate a vector or other contain with your rows.</p>

<pre><code>std::vector&lt;row&gt; rows;
</code></pre>

<p>To sort use <code>std::sort</code> with custom comparison function which you look at certain values.</p>

<pre><code>std::sort(rows.begin(), rows.end(), [](const row&amp; r1, const row&amp; r2)-&gt;bool{
    return r1.area &lt; r2.area;
}); //sort by area
</code></pre>

<p>This could be made generic by having a vector of vectors and the comparison function could capture a varaible from it's enviroment: see my other answer</p>
",0
9806625,9806507,0,"<p>I would make a vector of structs, each struct models 1 ""row"" of that table. You can sort it by different members using std::sort and using sort functor that compares just the member you want to sort on.</p>
",0
9806708,9806507,0,"<p>I though I would post a generic answer separately</p>

<p>Consider:</p>

<pre><code>typedef std::vector&lt;std::string&gt; row;
std::vector&lt;row &gt; table;
</code></pre>

<p>populate each inner vector as though it was a row, just make sure they all have the same number of elements.</p>

<p>Then make a comparison function that can operate on a specified row</p>

<pre><code>bool compare_index(std::size_t i, const row&amp; v1, const row&amp; v2)
{
    return v1.at(i) &lt; v2.at(i);
}
</code></pre>

<p>now you can sort like so</p>

<pre><code>std::size_t column=2; //or which ever column
std::sort(table.begin(), table.end(), 
          std::bind(&amp;compare_index, col, 
              std::placeholders::_1, 
              std::placeholders::_2));
</code></pre>
",2
9841577,9806507,1,"<p>OK, so based on the following assumptions:</p>

<ul>
<li>you want to select the sort column by name</li>
<li>you want to store something like a <code>struct</code> for each row (using variant types buys you a limited amount here, but you could go the tuple/typelist route)</li>
</ul>

<p>you need:</p>

<ul>
<li>some way to match the column <em>name</em> to the actual column</li>
<li>somewhere to hang the type-specific sorting code</li>
</ul>

<p>Given that the input &amp; output types (an unsorted container and a sorted one, respectively) are the same, you can do this using a combination of runtime polymorphism and templates.</p>

<p>Here is a quick sketch:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;

template &lt;typename Row&gt; class Table
{
    std::vector&lt;Row*&gt; rows;

    class AbstractSorter
    {
    protected:
        // this doesn't have to go in AbstractSorter,
        // but it's only used from the derived classes
        template &lt;typename Comp&gt; static
        std::vector&lt;Row*&gt; sort(std::vector&lt;Row*&gt; const &amp;in, Comp comp)
        {
            std::vector&lt;Row*&gt; out;
            out.reserve(in.size());
            // or copy and sort in place, for example
            std::multiset&lt;Row*, Comp&gt; sorted(comp);
            std::copy(in.begin(), in.end(), std::inserter(sorted, sorted.end()));
            std::copy(sorted.begin(), sorted.end(), std::back_inserter(out));

            return out;
        }

    public:
        virtual ~AbstractSorter() {}
        virtual std::vector&lt;Row*&gt; sort(std::vector&lt;Row*&gt; const &amp;) const = 0;
    };

    typedef std::unique_ptr&lt;AbstractSorter&gt; SortPtr;
    typedef std::map&lt;std::string, SortPtr&gt; SortMap;
    static SortMap sorters;

    template &lt;typename ColType&gt;
    class ConcreteSorter: public AbstractSorter
    {
        ColType Row::*col;

    public:
        ConcreteSorter(ColType Row::*member) : col(member) {}
        virtual std::vector&lt;Row*&gt; sort(std::vector&lt;Row*&gt; const &amp;in) const
        {
            // assuming you have C++11 lambdas, otherwise you'll need to
            // write a comparator too
            return AbstractSorter::sort(
                in,
                [&amp;col](Row *a, Row *b){ return (a-&gt;*col) &lt; (b-&gt;*col); }
                );
        }
    };

public:
    template &lt;typename ColType&gt;
    static void bindSortableColumn(char const *name, ColType Row::*member)
    {
        sorters.insert(typename SortMap::value_type(
                std::string(name), 
                SortPtr(new ConcreteSorter&lt;ColType&gt;(member))
                ));
    }

    // error handling left as an exercise for the reader
    std::vector&lt;Row*&gt; sortBy(std::string const &amp;name) const
    {
        return sorters[name]-&gt;sort(rows);
    }
};

#define SORTABLE_COLUMN(ROW, COL) \
    Table&lt;ROW&gt;::bindSortableColumn(#COL, &amp;ROW::COL);

template &lt;typename Row&gt; typename Table&lt;Row&gt;::SortMap Table&lt;Row&gt;::sorters;

// now to define your own row type    
struct MyRow
{
    int id;
    std::string name;
    double salary;
};

// and the tedious bit: setting up the sorter objects for your columns
// (you could automate this further by using a tuple instead of a regular
//  struct for MyRow)
void init_columns()
{
    SORTABLE_COLUMN(MyRow, id);
    SORTABLE_COLUMN(MyRow, name);
    SORTABLE_COLUMN(MyRow, salary);
}
</code></pre>
",0
9173882,9173819,2,"<pre><code>T* t = new T[10];
</code></pre>

<p>Creates <code>10</code> objects of the type <code>T</code> on the freestore(Heap) by calling default constructor of <code>T</code>.<br>
Note that when you use <code>new</code> objects are always created on Freestore.</p>

<p>When you assign,     </p>

<pre><code>t[0] = x;   
</code></pre>

<p>The copy assignment operator(<code>=</code>) a.k.a assignment is invoked.Neither the constructor nor the copy constructor is invoked here.      </p>

<p>For simplicity remember the following rules:             </p>

<ul>
<li>When a object is being created and assigned to in same statement, then copy constructor will be used. This is known as Copy Initialization.</li>
</ul>

<p><strong>Example:</strong>     </p>

<pre><code>   Myclass obj1;
   Myclass obj2 = obj1;  //obj2 is Created &amp; Initialized in same statement
</code></pre>

<ul>
<li>When a object is already created in a previous statement and being assigned(<code>=</code>) to in another statement then the assignment operator will be called. </li>
</ul>

<p><strong>Example:</strong></p>

<pre><code>   Myclass obj1;      //obj1 is created
   Myclass obj2;      //obj2 is created
   obj2 = obj1;       //Already created object obj2 is assigned with obj1
</code></pre>

<p>Your examples fall in the second scenario.       </p>
",2
9173892,9173819,7,"<p>In your example:</p>

<pre><code>T* t = new T[10];
</code></pre>

<p>invokes the default constructor of T (10 times).  Then</p>

<pre><code>t[0] = x;
</code></pre>

<p>invokes the assignment operator.  This statement invokes no constructor.</p>
",0
9184301,9184231,3,"<p>In standard C++ there is no such thing as a stack. The standard only differentiates between the different lifetimes of objects. In that case a variable declared as <code>T t;</code> is said to have automatic storage duration, which means it life-time ends with the end of it's surrounding scope. Most (all?) compilers implement this through a stack. It is a reasonable assumption that all objects created that way actually live on the stack.</p>
",0
9184252,9184231,0,"<p>No idea what you mean in your first sentence, but: yes, objects in local variables are generally stored on the stack.</p>
",0
9184275,9184231,2,"<p><a href=""http://en.wikipedia.org/wiki/Automatic_memory_allocation"" rel=""nofollow"">Automatically allocated</a> [local] objects are located on automatic memory area [""stack""] while <a href=""http://en.wikipedia.org/wiki/Memory_management#Dynamic_memory_allocation"" rel=""nofollow"">dynamically allocated</a> objects are located in dynamic memory area [""heap""]. </p>

<p>As a rule of thumb: in C++, everyting that is not using <code>new</code> or <code>malloc</code> is automatically allocated.</p>

<p><strong>EDIT:</strong> Note that I use ""stack"" and ""heap"" with double quotes since the standard [AFAIK] does not specify how the data is managed in these areas, but [again AFAIK], compilers indeed tend to use stack for automatic area and heap for dynamic area.</p>
",3
14779445,14779355,2,"<p>The second parameter passed to the constructor is the element of the vector to be repeated <code>outersize</code> times. You should use this syntax:</p>

<pre><code>new vector&lt;vector&lt;type&gt; &gt; (outersize, vector&lt;type&gt;(innersize, elementValue));
</code></pre>

<p>For example, to make a 50x25 grid of <code>bool</code> initially set to <code>true</code>, use:</p>

<pre><code>vector&lt;vector&lt;bool&gt; &gt; *grid = new vector&lt;vector&lt;bool&gt; &gt;(50, vector&lt;bool&gt;(25, true));
</code></pre>
",7
18241557,18241287,2,"<pre><code>int nombre;
int affNombre = 1;
int tableau [] = {nombre};
</code></pre>

<p>This does not create a dynamic array; it initializes a pointer to an array to 1.  If your friend is looking to learn C++, I'd encourage them to take advantage of the C++ constructs (e.g. <code>vector</code>).  This entire program can be written in about 7 lines of C++ utilizing C++ constructs:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v;
    std::cout &lt;&lt; ""Enter values to average (Ctrl+Z to finish):  "";
    std::copy(std::istream_iterator&lt;int&gt;(std::cin), std::istream_iterator&lt;int&gt;(), std::back_inserter&lt;std::vector&lt;int&gt;&gt;(v));
    double result = std::accumulate(v.begin(), v.end(), 0.0) / v.size();
    std::cout.precision(8);
    std::cout &lt;&lt; ""Average = "" &lt;&lt; std::fixed &lt;&lt; result;
    return 0;
}
</code></pre>
",0
18241477,18241287,3,"<pre><code>int tableau [] = {nombre};
</code></pre>

<p>It doesn't declare an array with <em>nombre</em> size of elements.</p>

<p>It declares an array with 1 item which is initialized to <code>nombre</code>.</p>
",0
18241668,18241287,1,"<pre><code>int nombre;
int affNombre = 1;
int tableau [] = {nombre};
</code></pre>

<p>Above piece of code declares ""tableau"" array of size 1 with its value as nombre.</p>

<p>However, I think you running into memory corruption with following piece of code</p>

<pre><code>//Saisi des nombres du tableau
for (int i = 0; i &lt; largeurTab; i++)
{
cout &lt;&lt; endl &lt;&lt; ""Nombre "" &lt;&lt; affNombre &lt;&lt; endl;
cin &gt;&gt; nombre;
tableau [i] = nombre;
affNombre += 1;
}
</code></pre>

<p>You have an array tableau of size 1 elements. But you are looping for largeurTab and inserting that many elements in tableau but it can only hold single element legally. So you are actually running into buffer overflow. </p>

<p>It is just luck that your program is running fine. Please use vector as someone else already recommended or dynamically allocate the array.</p>
",2
17855584,17855518,5,"<p>Try</p>

<pre><code>PIPlayback pPlayBackInterfcace = (PIPlayback)(CAudioClientInterface*) pObj;
</code></pre>

<p>You are only allowed to cast to <code>void*</code> and back to the original type <code>CAudioClientInterface*</code>. Casting to another type is undefined behavior.</p>
",2
17836289,17836257,3,"<p>The compiler needs the full definition of the template at compile time. Thus, the definition of the template function needs to be in the header. (unless you specialize, that has to be in a c++ file or inlined)</p>
",1
17864145,17864116,5,"<p>No. This is not possible without some other variable telling you. The best thing you can do is make the methods <code>private</code> so only your class can call it. Then make sure that only the constructor calls it. Other than that, it you only want the constructor calling it, have you tried <em>not using a function and just putting the code there</em>?</p>
",1
10151286,10150468,260,"<p>Here is an working example of what you want to do. Read the comments to know what each line in the code does. I've tested it on my pc with gcc 4.6.1; it works fine.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

void f()
{
    std::string line;
    while(std::getline(std::cin, line))  //input from the file in.txt
    {
        std::cout &lt;&lt; line &lt;&lt; ""\n"";   //output to the file out.txt
    }
}
int main()
{
    std::ifstream in(""in.txt"");
    std::streambuf *cinbuf = std::cin.rdbuf(); //save old buf
    std::cin.rdbuf(in.rdbuf()); //redirect std::cin to in.txt!

    std::ofstream out(""out.txt"");
    std::streambuf *coutbuf = std::cout.rdbuf(); //save old buf
    std::cout.rdbuf(out.rdbuf()); //redirect std::cout to out.txt!

    std::string word;
    std::cin &gt;&gt; word;           //input from the file in.txt
    std::cout &lt;&lt; word &lt;&lt; ""  "";  //output to the file out.txt

    f(); //call function


    std::cin.rdbuf(cinbuf);   //reset to standard input again
    std::cout.rdbuf(coutbuf); //reset to standard output again

    std::cin &gt;&gt; word;   //input from the standard input
    std::cout &lt;&lt; word;  //output to the standard input
}
</code></pre>

<p>You could <em>save</em> and <em>redirect</em> in just one line as:</p>

<pre><code>auto cinbuf = std::cin.rdbuf(in.rdbuf()); //save and redirect
</code></pre>

<p>Here <code>std::cin.rdbuf(in.rdbuf())</code> sets <code>std::cin's</code> buffer to <code>in.rdbuf()</code> and then returns the old buffer associated with <code>std::cin</code>. The very same can be done with <code>std::cout</code> &mdash; or any <em>stream</em> for that matter.</p>

<p>Hope that helps.</p>
",4
14861611,14861246,1,"<p>The way I've handled this in the past was with inheritance and virtual functions:</p>

<p>When creating a variable, I do something like this:</p>

<pre><code>variable_base *var = new variable_int;
</code></pre>

<p>which is implemented something like this:</p>

<pre><code>class variable_base {
public:
    virtual ~variable_base() {}

public:
    virtual variable_base *clone() const = 0;

public:
    // all operations you can do to a variable as pure virtual functions here
    virtual variable_base *operator+=(const variable_base *rhs) = 0;
    // ...
};

class variable_int : public variable_base {
public:
    virtual variable_base *clone() const { return new variable_int(*this); }

public
    virtual variable_base *operator+=(const variable_base *rhs) {
        if(variable_int *other = dynamic_cast&lt;variable_int *&gt;(rhs)) {
            // int += int
            value_ += other-&gt;value_;
        } else {
            // throw exception, or convert, whatever you want
        }
        return this;
    }

private:
    int value_;
};
</code></pre>

<p>and I would do this for each possible variable type.</p>

<p>The only time it gets tricky is when an operation should ""up-convert"" the l-value. For example, in my scripting language <code>char + string == string</code> in order to be consistent with <code>string + char == string</code></p>
",2
14861616,14861246,0,"<p>The <a href=""http://www.boost.org/doc/libs/1_53_0/doc/html/program_options.html"" rel=""nofollow""><code>boost::program_options</code> library</a> basically does something similar. You register the type of known options and retrieve values using <a href=""http://www.boost.org/doc/libs/1_53_0/doc/html/any.html"" rel=""nofollow""><code>boost::any</code></a>. </p>

<p>You could discriminate the value extraction using your known <code>#Class</code> strings providing appropriate handlers (e.g. functors).</p>
",0
14861449,14861246,0,"<p>I had a similar problem recently.
I stored every variable as a <a href=""http://www.learncpp.com/cpp-tutorial/613-void-pointers/"" rel=""nofollow"" title=""void pointer"">void pointer</a> and then when I wanted to access the value I would just pass the void pointer and the value I wanted to set it to.</p>

<p>I had overloaded four or so functions, one for each variable type, but all with the same name.</p>

<pre><code>setValue(&amp;currentVoidPointerToVar , string(""value"") )
</code></pre>

<p>The correct function (in this case, the string one) would then check the type of variable stored at the void pointer. If it matches the specified value it would recast the void pointer into the correct type, then access this object, then set the value.</p>
",0
11110763,11110486,1,"<p>Create an interface that hides the details:</p>

<pre><code>class Foo {
    public:
        void AddBar(std::string name, Bar*);
        void RemoveBar(std::string name);

        Bar* GetBar(std::string name);
        Bar* GetBar(std::string name) const;

        void AddBaz(std::string name, Baz*);
        void RemoveBaz(std::string name);

        Baz* GetBaz(std::string name);
        Baz* GetBaz(std::string name) const;

    private:
        std::map&lt;std::string, Bar*&gt; bars_by_name;
        std::map&lt;std::string, Baz*&gt; bazs_by_name;
};
</code></pre>

<p>For all the user knows, you could be storing them in a std::pair inside a list, inside a vector, or even using parallel arrays...anything really.</p>

<p>EDIT:</p>

<p>The fact that you are storing it in a map but want the <em>user</em> to iterate over the underlying container smells of a bad/incorrect design. Either only allow them individual access as above or create methods that will do this for them.</p>
",1
11111010,11110486,1,"<p>You could pass the collection's iterators off as your own.</p>

<pre><code>class Foo {
  private:
    typedef std::map&lt;std::string, Bar*&gt; BarContainer;
    typedef std::map&lt;std::string, Baz*&gt; BazContainer;
  public:
    typedef BarContainer::const_iterator ConstBarIterator;
    ConstBarIterator beginBars() { return bars_by_name.cbegin(); }
    ConstBarIterator endBars()   { return bars_by_name.cend(); }
    typedef BazContainer::const_iterator ConstBazIterator;
    ConstBazIterator beginBazs() { return bazs_by_name.cbegin(); }
    ConstBazIterator endBazs()   { return bazs_by_name.cend(); }

  private:
    BarContainer bars_by_name;
    BazContainer bazs_by_name;
};
</code></pre>

<p>This saves you the work of implementing your own iterator, yet leaves you the flexibility of changing your container types later and only requiring callers to recompile.</p>

<p>It doesn't solve the problem of iterating them both together.</p>
",1
12335498,12335453,1,"<p>Try this: <code>std::numeric_limits&lt;double&gt;::infinity()</code> will provide a value that tells you whether a number is an infinity or not.</p>

<p>Here is an example code for a <code>vector</code> of <code>double</code> values; you can change the <code>repl_inf</code> to use <code>complex&lt;double&gt;</code> instead.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;limits&gt;

using namespace std;

int repl_inf (double v) { return (v== std::numeric_limits&lt;double&gt;::infinity() || -v== std::numeric_limits&lt;double&gt;::infinity()) ? 0.0 : v; }

int main() {
    vector&lt;double&gt; v;
    v.push_back(1);
    v.push_back(1.0/0.0);
    v.push_back(2);
    v.push_back(-1.0/0.0);
    transform (v.begin(), v.end(), v.begin(), repl_inf);
    for (int i = 0 ; i != v.size() ; i++) {
        cout &lt;&lt; v[i] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>On ideone: <a href=""http://ideone.com/XkAFV"" rel=""nofollow"">link</a>.</p>

<p>For <code>complex&lt;double&gt;</code>:</p>

<pre><code>bool isInf(double v) {
    return v== std::numeric_limits&lt;double&gt;::infinity()
       || -v== std::numeric_limits&lt;double&gt;::infinity();
}
bool isInf(complex&lt;double&gt; c) {
    return isInf(c.real) || isInf(c.imag);
}
</code></pre>
",4
12335523,12335453,1,"<pre><code>std::replace( array, array + N, std::complex( std::numeric_limits&lt;double&gt;::infinity(), 0.0), std::complex(0.0) );
std::replace( array, array + N, std::complex( -std::numeric_limits&lt;double&gt;::infinity(), 0.0), std::complex(0.0) );
</code></pre>

<p>or</p>

<pre><code>bool isinf( std::complex&lt;double&gt; d )
{
  return std::abs( d.real() ) == std::numeric_limits&lt;double&gt;::infinity()
}

std::replace_if( array, array + N, isinf, 0.0 );
</code></pre>
",5
19877215,8949982,0,"<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
   int side1, side2, side3;
   int counter=0;
   for(side1=1;side1&lt;=500;side1++)
    for(side2=1;side2&lt;=500;side2++)
     for(side3=1;side3&lt;=500;side3++)
       {
        int t1, t2, t3;
        t3=side1 * side1 + side2 *side2;
        t2=side1 * side1 + side3 * side3;
        t1=side2 * side2 + side3 * side3;
        if(t3==side3 * side3 || t2==side2 * side2 || t1==side1 * side1)
        {
            cout&lt;&lt;side1&lt;&lt;"" , ""&lt;&lt;side2&lt;&lt;"", ""&lt;&lt;side3&lt;&lt;endl;
            counter++;

        }
       }
   cout&lt;&lt;endl&lt;&lt;counter/6;
}
</code></pre>
",0
15893832,7656219,5,"<p>Wikipedia's MD5 simple implementation has easy code and is very fast.</p>

<p>I would recommend it over the above solutions (for MD5 if it must be MD5) because it does not require an external library and the code does not contain #ifdefs</p>

<pre><code>/*
 * Simple MD5 implementation
 *
 * Compile with: gcc -o md5 -O3 -lm md5.c
 *
 * NOTE: this code only works on little-endian machines.
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

// Constants are the integer part of the sines of integers (in radians) * 2^32.
const uint32_t k[64] = {
0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee ,
0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 ,
0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be ,
0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 ,
0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa ,
0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 ,
0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed ,
0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a ,
0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c ,
0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 ,
0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 ,
0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 ,
0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 ,
0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 ,
0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 ,
0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 };

// leftrotate function definition
#define LEFTROTATE(x, c) (((x) &lt;&lt; (c)) | ((x) &gt;&gt; (32 - (c))))

// These vars will contain the hash
uint32_t h0, h1, h2, h3;

void md5(uint8_t *initial_msg, size_t initial_len) {

    // Message (to prepare)
    uint8_t *msg = NULL;
    int new_len;
    uint32_t bits_len;
    int offset;
    uint32_t *w;
    uint32_t a, b, c, d, i, f, g, temp;

    // Note: All variables are unsigned 32 bit and wrap modulo 2^32 when calculating

    // r specifies the per-round shift amounts
    const uint32_t r[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
                          5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
                          4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
                          6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};

    // Initialize variables - simple count in nibbles:
    h0 = 0x67452301;
    h1 = 0xefcdab89;
    h2 = 0x98badcfe;
    h3 = 0x10325476;

    // Pre-processing: adding a single 1 bit
    //append ""1"" bit to message    
    /* Notice: the input bytes are considered as bits strings,
       where the first bit is the most significant bit of the byte.[37] */

    // Pre-processing: padding with zeros
    //append ""0"" bit until message length in bit ¡Ô 448 (mod 512)
    //append length mod (2 pow 64) to message

    for(new_len = initial_len*8 + 1; new_len%512!=448; new_len++);
    new_len /= 8;

    msg = (uint8_t*)calloc(new_len + 64, 1); // also appends ""0"" bits 
                                   // (we alloc also 64 extra bytes...)
    memcpy(msg, initial_msg, initial_len);
    msg[initial_len] = 128; // write the ""1"" bit

    bits_len = 8*initial_len; // note, we append the len
    memcpy(msg + new_len, &amp;bits_len, 4);           // in bits at the end of the buffer

    // Process the message in successive 512-bit chunks:
    //for each 512-bit chunk of message:
    for(offset=0; offset&lt;new_len; offset += (512/8)) {

        // break chunk into sixteen 32-bit words w[j], 0 ¡Ü j ¡Ü 15
        w = (uint32_t *) (msg + offset);

#ifdef DEBUG
        printf(""offset: %d %x\n"", offset, offset);

        int j;
        for(j =0; j &lt; 64; j++) printf(""%x "", ((uint8_t *) w)[j]);
        puts("""");
#endif

        // Initialize hash value for this chunk:
        a = h0;
        b = h1;
        c = h2;
        d = h3;

        // Main loop:
        for(i = 0; i&lt;64; i++) {

             if (i &lt; 16) {
                f = (b &amp; c) | ((~b) &amp; d);
                g = i;
            } else if (i &lt; 32) {
                f = (d &amp; b) | ((~d) &amp; c);
                g = (5*i + 1) % 16;
            } else if (i &lt; 48) {
                f = b ^ c ^ d;
                g = (3*i + 5) % 16;          
            } else {
                f = c ^ (b | (~d));
                g = (7*i) % 16;
            }

             temp = d;
            d = c;
            c = b;
            b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);
            a = temp;

        }

        // Add this chunk's hash to result so far:
        h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;

    }

    // cleanup
    free(msg);

}

int main(int argc, char **argv) {

    if (argc &lt; 2) {
        printf(""usage: %s 'string'\n"", argv[0]);
        return 1;
    }

    char *msg = argv[1];
    size_t len = strlen(msg);

    // benchmark
    int i;
    for (i = 0; i &lt; 1000000; i++) {
        md5((uint8_t*)msg, len);
    }

    //var char digest[16] := h0 append h1 append h2 append h3 //(Output is in little-endian)
    uint8_t *p;

    // display result

    p=(uint8_t *)&amp;h0;
    printf(""%2.2x%2.2x%2.2x%2.2x"", p[0], p[1], p[2], p[3], h0);

    p=(uint8_t *)&amp;h1;
    printf(""%2.2x%2.2x%2.2x%2.2x"", p[0], p[1], p[2], p[3], h1);

    p=(uint8_t *)&amp;h2;
    printf(""%2.2x%2.2x%2.2x%2.2x"", p[0], p[1], p[2], p[3], h2);

    p=(uint8_t *)&amp;h3;
    printf(""%2.2x%2.2x%2.2x%2.2x"", p[0], p[1], p[2], p[3], h3);
    puts("""");

    return 0;
}
</code></pre>
",1
8732512,8732485,7,"<p>You should put a <a href=""http://en.wikipedia.org/wiki/Function_prototype"" rel=""nofollow noreferrer"">function prototype</a> before using the function, for the compiler to know what it is going to be.</p>

<p>Put</p>

<pre><code>void s_v(); // prototype your functions, this is usually done in include files
</code></pre>

<p>Right after the <code>#include</code> line.</p>
",1
8732513,8732485,2,"<p>You need to add <code>void s_v();</code> before the <code>c_mes()</code> function. This is called a function prototype, and it lets the compiler know that that symbol exists and will be implemented later in the code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int tic_h;
int tic_v;
void s_v();

void echo(string e_val) {
   cout &lt;&lt; e_val;
}

void c_mes() {
    echo(""X|0|X\n"");
    echo(""-----\n"");
    echo(""X|0|X\n"");
    echo(""-----\n"");
    echo(""X|0|X\n"");
    s_v();
}

void s_v() {
    echo(""Please enter vertical coordinate: "");
    cin &gt;&gt; tic_v;
    if (tic_v &lt; 4 &amp;&amp; tic_v &gt; 0) {
        c_mes();
    } else {
        s_v();
    }
}

void s_h() {
    echo(""Please enter horizontal coordinate: "");
    cin &gt;&gt; tic_h;
    if (tic_h &lt; 4 &amp;&amp; tic_h &gt; 0) {
        s_v();
    } else {
        s_h();
    }
}

int main() {
  s_h();
  return 0;
}
</code></pre>

<p>Keep in mind that if you ever change the signature for <code>s_v()</code> (that is, add arguments or change the return type), you will need to update the prototype as well.</p>
",0
8732520,8732485,4,"<p>You'll need to <a href=""http://en.wikipedia.org/wiki/Forward_declaration"" rel=""nofollow"">forward declare</a> <code>dostuff</code>, as in the example below.</p>

<p>By doing this you pretty much tell the compiler that the function will be defined else where, but that you'd like to use it.</p>

<p><em>Excuse the wording, but putting it the way I did is easily comprehensive by a novice programmer.</em></p>

<hr>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void dostuff (); // forward declaration

void test(int b){ 
    if(b&lt;11&amp;&amp;b&gt;0){
        cout &lt;&lt; ""Yay!"";
    }   
    else{
        cout &lt;&lt; ""The number is not between 1 and 10."";
        dostuff();
    }   
}

void dostuff(){
    int numput;
    cout &lt;&lt; ""Please type a number between 1 and 10:"";
    cin &gt;&gt; numput;
    test(numput);
}

int main(){
    dostuff();
}
</code></pre>

<p><em>OP just edited the original snippet provided in his question (which the below is a modification off), I'll leave this post the way it is since it explains the situation quite well.</em></p>
",0
8732524,8732485,1,"<p>Declare <code>dostuff</code> somewhere before the <code>void test</code> definitionm e.g on line 3:</p>

<pre><code>void dostuff();
</code></pre>

<p>This way you introduce the signature of <code>dostuff</code> function to your program before the function is defined.</p>

<p>In C++ unlike javascript and some other languages, the parser doesn't find all functions then compile the code.</p>
",0
8732531,8732485,0,"<p>add </p>

<pre><code>void dostuff();
</code></pre>

<p>just after the using namespace std; and it will work :)</p>
",0
8732645,8732485,0,"<p>This is the same error, you use a function before declare it (s_v()), for solve your error you only should create a prototype of s_v():</p>

<pre><code>void s_v(); //at the start of your file
</code></pre>
",0
8733077,8732485,0,"<p>write this</p>

<pre><code>void c_mes(){
  echo(""X|0|X\n"");
  echo(""-----\n"");
  echo(""X|0|X\n"");
  echo(""-----\n"");
  echo(""X|0|X\n"");
  s_v();
}
</code></pre>

<p>after this</p>

<pre><code>void s_h(){
  echo(""Please enter horizontal coordinate: "");
  cin &gt;&gt; tic_h;
  if(tic_h&lt;4&amp;&amp;tic_h&gt;0){
    s_v();
  }else{
    s_h();
  }
}
</code></pre>
",0
11509280,8215137,1,"<pre><code>int OnResponse(int event, char *response, int length)
{  
    int resvalue = response[length];
    response[length] = 0;
    printf(response);
    response[length] = resvalue;

    return event;
}
</code></pre>
",0
11495319,11495292,14,"<p>Plain and simply (from C++11 6.6.3 ""The return statement""):</p>

<blockquote>
  <p>Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</p>
</blockquote>

<p>So the compiler is pretty much allowed to do whatever it wants.  Clearly, a diagnostic is something I'd prefer from a compiler, but there are times when it can be difficult to diagnose (like when the return is inside conditional logic, and the 'end' of the function would never be reached).</p>

<p>Note that I get the following warning with GCC 4.6.1 (using the <code>Wall</code> option):</p>

<pre><code>test.cpp:8:1: warning: no return statement in function returning non-void [-Wreturn-type]
</code></pre>

<p>I'm not sure what options ideone passes to GCC (I imagine that <code>-Wall</code> would do the same with the 4.3.4 version that ideone uses).</p>

<p>Some related information:</p>

<p>In C it's OK for a function that is declared to return a value to not actually do so in certain circumstances; in C it only results in undefined behavior if the function's return value is actually <em>used</em>. Pre-standard C didn't always support the <code>void</code> type, so functions that didn't return anything were often declared to return <code>int</code>, explicitly or implicitly. From C99 6.9.1/12 ""Function definitions"": If the <code>}</code> that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined. </p>

<p>Also, as mentioned in a couple comments, flowing off the end of <code>main()</code> is treated specially by C++ and C99 and later.</p>
",6
11495325,11495292,3,"<p>Not returning a value from a non-void function is a mistake, but not all compiler treats it as an error -- for example, GCC only emits a warning when it encounters this. Other compilers may be paranoid (and they're right) and don't let you compile such code. Of course compiler behavior may be modified using different switches and options.</p>

<p>The return value of 0 is just a random value -- it might equally be 255, -1 or any other garbage, as doing this is undefined behavior (except for main, for which C99 specifies that an implicit 0 return value should be assumed).</p>
",0
11495327,11495292,3,"<p>It appears that ideone doesn't display warnings, it only displays the compiler output if there was an error.  On the version of GCC that ideone is using (gcc 4.3) this isn't an error, it's just a warning.  </p>
",0
11495337,11495292,2,"<p>The code has undefined behavior. Even though what you're doing is wrong, the compiler is not required to diagnose it. The other point is that ideone uses what is now a fairly old version of gcc. A reasonably current version of gcc (e.g., 4.7) will at least give you a warning that your function is declared to return a value, but doesn't -- but not by default. You have to turn it on with something like <code>-Wall</code> to get the warning (but as a general rule, I'd <em>always</em> use at least -Wall with gcc).</p>
",0
11848241,11848031,3,"<p>When you try to initialize the base <code>C</code> of <code>F</code> with <code>*this</code>, both the compiler generated copy constructor for <code>C</code> and the constructor that you define taking a <code>T&amp;</code> are a match as the type of <code>*this</code> (<code>F</code>) is derived directly from both <code>C</code> and <code>T</code>. Your cast resolves this ambiguity.</p>

<p>I am surprised that the copy constructor is a better match than the one taking <code>T&amp;</code> as I would have thought that they would both be equally preferred. If the copy-constructor is chosen then the base will be initialized from itself which causes <em>undefined behavior</em> as the reference member will be initialized from an uninitialized reference (itself).</p>
",5
11848284,11848031,0,"<pre>
struct C
{
    <b>T& r;</b>
    C(T& v) : r(v) {}
};

struct E : T
{
    <b>T& r;</b>
    E(T const& v) : r(*this), T(v) {}   // ok
};
</pre>

<p>You need to initialize any reference at the time of declaration but here you have just declared it. This is not allowed in C++.</p>
",2
11848646,11848031,0,"<p>1)<strong>never use this in initialization list</strong>
<a href=""http://msdn.microsoft.com/en-us/library/3c594ae3(v=vs.80).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/3c594ae3(v=vs.80).aspx</a>
The this pointer is valid only within nonstatic member functions. It cannot be used in the initializer list for a base class.</p>

<p>The base-class constructors and class member constructors are called before this constructor. In effect, you've passed a pointer to an unconstructed object to another constructor. If those other constructors access any members or call member functions on this, the result will be undefined. You should not use the this pointer until all construction has completed.</p>

<p>shortly: C.r initialized by bad poiter</p>
",1
11848814,11848031,3,"<p>The code is ambiguous.</p>

<p>For constructing the <code>C</code> base of <code>F</code>, the context is direct-initialization, so 13.3.1.3 applies:</p>

<blockquote>
  <p><a href=""/questions/tagged/c%2b%2b11"" class=""post-tag"" title=""show questions tagged 'c++11'"" rel=""tag"">c++11</a></p>
  
  <h3>13.3.1.3 Initialization by constructor [over.match.ctor]</h3>
  
  <p>For direct-initialization, the candidate
  functions are all the constructors of the class of the object being initialized.</p>
</blockquote>

<p>The implicitly-declared copy constructor is included, per 12.8:8.</p>

<p>The candidates for the constructor of <code>C</code> are <code>C(T &amp;)</code> and (the default copy constructor) <code>C(const C &amp;)</code>, by parameter list <code>(F)</code>.  In both cases we have a reference binding (13.3.3.1.4) followed by a derived-to-base Conversion (13.3.3.1), with an additional cv-qualification adjustment in the latter case, giving overall rank of Conversion in both cases.</p>

<p>Since <code>C</code> and <code>T</code> are both base classes of <code>F</code>, but are distinct types and neither is a base class of the other, none of the clauses in 13.3.3.2:3 nor 13.3.3.2:4 apply and conversion sequences are indistinguishable.</p>

<p>Indeed, gcc-4.5.1 rejects the code with:</p>

<pre><code>prog.cpp: In constructor 'F::F(const T&amp;)':
prog.cpp:20:34: error: call of overloaded 'C(F&amp;)' is ambiguous
prog.cpp:9:5: note: candidates are: C::C(T&amp;)
prog.cpp:7:1: note:                 C::C(const C&amp;)
</code></pre>
",1
14245584,14245553,3,"<p><code>private</code> or <code>protected</code> base means the base is <em>inaccessible</em> to the world. So when you write an expression which requires conversion from the derived to the <em>inaccessible</em> base, that is forbidden due to accessibility rules <em>because</em> the conversion needs to take place at the call-site which is a part of the world.</p>

<p>In object-oriented terminology, <code>private</code> or <code>protected</code> base  doesn't define <strong>is-a</strong> relationship. It is actually an <em>implemented-in-terms-of</em> relationship, which is composition in simpler term.</p>
",2
14245600,14245553,1,"<p>because non-public inheritance does not define a ""is-a"" relationship, compiler generally will not allow implicit up-cast  </p>

<p>The following would have worked, but it's a bad idea/design</p>

<pre><code>D*d = (D*)(new E);
</code></pre>
",0
14855144,14855092,4,"<p>Because the standard says so, and the compiler is obliged to follow suit. There is no technical reason; in fact in C++11 it is <a href=""https://stackoverflow.com/questions/6482566/has-in-class-member-initialization-feature-made-into-c11"">possible</a> to do this.</p>
",0
13724417,13724401,3,"<p>It means do the comparsion <code>_a != MAX_A_VAL</code>, and then return its result (<code>true</code> or <code>false</code>)</p>
",0
13724431,13724401,3,"<p>It means that if <code>_a</code> is NOT equal to <code>MAX_A_VAL</code> it should return <code>true</code> and otherwise it should return <code>false</code></p>

<p>It's a boolean comparision.</p>

<p>It may be easier to read like so:</p>

<pre><code>return (_a != MAX_A_VAL);
</code></pre>

<p>or another way you could look at it is:</p>

<pre><code>bool retvalue = (_a != MAX_A_VAL);
return retvalue;
</code></pre>
",0
13724435,13724401,1,"<p>The <code>return</code> statement can use <em>any</em> expression as its return value, it doesn't have to be a simple one like a variable.</p>
",1
8796945,8796936,3,"<blockquote>
  <p>I'm pretty sure the compiler considers the whitespace between ""B"" and ""::C"" insignificant, so it is trying to find a member ""C"" inside ""B""</p>
</blockquote>

<p>That's precisely correct.</p>

<blockquote>
  <p>Is there any strong reason to prefer one over the other? Can I expect both to work correctly on other compilers?</p>
</blockquote>

<p>Option #3 looks fine to me (and is compliant); that is, if you're <em>really</em> stuck with this rather silly-looking requirement. :)</p>

<p>I use it myself to conclude <a href=""http://kera.name/articles/2011/02/befriending-your-parser/"" rel=""nofollow"">a blog post on a very similar ""issue""</a>.</p>
",1
13409844,13409832,1,"<p>You will only get a move if the argument of the function (in this case, the argument of <code>push_back</code>) is an rvalue, as well as in certain situations when you return objects from a function.</p>

<p>In your example, <code>pr</code> is not an rvalue, so you won't get it moved.</p>

<p>However, if you &ndash; for example &ndash; pass a temporary object to the vector, like this:</p>

<pre><code>v.push_back(std::pair&lt;std::string,bool&gt;());
</code></pre>

<p>This will be an rvalue and trigger a move.</p>

<p>You can also trigger the move by explicitly casting the argument to an rvalue in the way you suggested:</p>

<pre><code>v.push_back(std::move(pr));
</code></pre>

<p>Note, however, that in this case you won't be able to use <code>pr</code> after the call in a meaningful way any more as its contents have been moved away.</p>

<p>(Of course, another precondition for a move is that the function you call actually accepts rvalue references. For vector <code>push_back</code> this is indeed the case.)</p>
",4
10173362,10173312,4,"<p>You should write:</p>

<pre><code>std::cout &lt;&lt; ((*pB).*pf2)(3) &lt;&lt; std::endl;
</code></pre>

<p>As I checked, Boost does not define operator <code>-&gt;*</code> for any of the pointers, although it is possible (see C++ standard, sections 5.5 and 13.5).</p>

<p>Also, the C++11 standard does not define this operator for C++11 smart pointers.</p>
",2
10173374,10173312,3,"<p>I would guess that you should do it this way:</p>

<pre><code>std::cout &lt;&lt; ((*pB).*pf2)(3) &lt;&lt; std::endl;
</code></pre>

<p>although it's not tested.</p>
",0
9186953,9186702,2,"<p>As <a href=""http://opencv.jp/opencv-1.0.0_org/docs/ref/opencvref_highgui.htm"" rel=""nofollow"">the documentation says</a>, you can only pass the path to a local file to cvCreateFileCapture().</p>

<p>If you want to use openCV on an IP camera, you'll have to fetch images from the server by another mean, and then analyze the frames individually with openCV.</p>
",1
13735348,13735342,1,"<p>Of course it's not, because your container has pointers, not objects.</p>

<p>For it to be used, you'll need <code>std::vector&lt;QActionDonald&gt;</code> or, if that's not subject to change, to provide a custom comparator to <code>std::max_element</code> that applies the correct logic (i.e. compare objects, not pointers).</p>
",3
11818013,11817897,-3,"<p>So, it sounds like you need to save the data from multiple packets in a list until some point in the future.</p>

<p>If it was me, I'd use std::string or std::vector normally because that removes allocation issues and is generally plenty fast.</p>

<p>If you do intend to use char* or char[], then you'd want to use char*.  Declaring a variable like ""char buf[1024];"" allocates it on the stack, which means that when that function returns it goes away.  To save it in a list, you'd need to dynamically allocate it, so you would do something like  ""char *buf = new char[packet.size];"" and then copy the data and store the pointer and the length of the data in your list (or, as I said before, use std::string which avoids keeping the length separately).</p>

<p>How do you copy the data?</p>

<p>Probably memcpy.  The strcpy function would have problems with data which can have nul characters in it, which is common in networking situations.  So, something like:</p>

<pre><code>char *buf = new char[packet_length];
memcpy(buf, packet_data, packet_length);
// Put buf and packet_length into a structure in your list.
</code></pre>
",2
11818049,11817897,10,"<p>If the packet data is binary I'd prefer using <code>std::vector</code> to store the data, as opposed to one of the C <code>strXXX</code> functions, to avoid issues with a potential NULL character existing in the data stream. Most <code>strXXX</code> functions look for NULL characters and truncate their operation. Since the data is not a string, I'd also avoid <code>std::string</code> for this task.</p>

<pre><code>std::vector&lt;unsigned char&gt; v( buf, buf + datalen );
</code></pre>

<p>The vector constructor will copy all the data from <code>buf[0]</code> to <code>buf[datalen - 1]</code> and will deallocate the memory when the vector goes out of scope. You can get a pointer to the underlying buffer using <code>v.data()</code> or <code>&amp;v[0]</code>.</p>
",6
13408985,13408961,2,"<p>It appears as though you have forgotten to link your project with <code>Graph.cpp</code>, or whatever file(s) hold the implementations of the <code>Graph_lib</code> class methods.</p>
",3
13408991,13408961,1,"<p>Looks like your Graph library is missing.</p>

<p>When linking using <code>g++, use -l &lt;Graph lib&gt;</code></p>
",0
16910699,16910035,2,"<p>As others have noted, you will need to utilize dynamic allocation. When using <code>new</code>, you would typically need to obey the <a href=""https://stackoverflow.com/questions/4782757/rule-of-three-becomes-rule-of-five-with-c11"">Rule of Three, Four, or Five</a>. This means you would need to make decisions about how destruction, copy construction, assignment, move construction, and move assignment should behave, and implement them. Typically for a container, you want deep copy semantics. Even if you use smart pointers to make destruction simple, you would need to do something more to make copies deep.</p>

<p>However, one doesn't necessarily need to involve <code>new</code> to apply dynamic memory allocation. For example, you could use a <code>list&lt;&gt;</code> to represent <code>left</code> and <code>right</code> instead, and doing it this way gives you deep copy semantics automatically:</p>

<pre><code>template &lt;typename T&gt;
class MyBinaryTree {
    T val_;
    std::list&lt; MyBinaryTree&lt;T&gt; &gt; left_;
    std::list&lt; MyBinaryTree&lt;T&gt; &gt; right_;

    template &lt;typename U&gt;
    friend MyBinaryTree&lt;U&gt; MakeMyBinaryTree (U v,
                                             MyBinaryTree&lt;U&gt; *l = 0,
                                             MyBinaryTree&lt;U&gt; *r = 0) {
        MyBinaryTree&lt;U&gt; t;
        t.val_ = v;
        if (l) t.left_.push_back(*l);
        if (r) t.right_.push_back(*r);
        return t;
    }

public:
    MyBinaryTree&lt;T&gt;* left () { return left_.empty() ? 0 : &amp;*left_.begin(); }
    MyBinaryTree&lt;T&gt;* right () { return right_.empty() ? 0 : &amp;*right_.begin(); }
    T &amp; val () { return val_; }
};

MyBinaryTree&lt;int&gt; make_a_tree ()
{
    MyBinaryTree&lt;int&gt; n1 = MakeMyBinaryTree(1);
    MyBinaryTree&lt;int&gt; n3 = MakeMyBinaryTree(3);
    return MakeMyBinaryTree(2, &amp;n1, &amp;n3);
}
</code></pre>

<p>Instead of <code>list&lt;&gt;</code>, you could use <a href=""http://www.boost.org/doc/libs/release/libs/optional/"" rel=""nofollow noreferrer"">Boost.Optional</a>, or if C++14 is available to you, <a href=""http://en.cppreference.com/w/cpp/utility/optional"" rel=""nofollow noreferrer""><code>std::optional</code></a>.</p>
",7
16910101,16910035,1,"<p>You created a dynamic container - eg. the one, which is built during the runtime. In case of such structures, you have to allocate them dynamically and use pointer to refer to them. That is:</p>

<pre><code>MyBinaryTree * BuildSimpleTree()
{
    BinaryTree&lt;int&gt; * node1 = new BinaryTree(0, nullptr, nullptr);
    BinaryTree&lt;int&gt; * node2 = new BinaryTree(0, nullptr, nullptr);

    return new MyBinaryTree&lt;int&gt;(0, node1, node 2);
}

MyBinaryTree * tree = BuildSimpleTree();
</code></pre>

<p>The reason behind dynamic allocation requirement is that all local statically allocated objects (eg. residing on stack instead of heap) are automatically destroyed, when you leave the function or method. However, for the tree to work properly, all its children (and recursively their children) shall remain alive after returning from function, so they have to be allocated dynamically.</p>

<p>You have to remember though to free <em>all</em> instances of allocated classes. This may be done manually or automatically, recursively - in BinaryTree and MyBinaryTree dtors.</p>

<hr />

<p>If you are able to compile your code using C++11, there's always an option to use move semantics - you'll be able to return the tree by value and keep the code fast and memory-efficient at the same time. This solution would look like the following:</p>

<pre><code>template &lt;class T&gt;
struct MyBinaryTree 
{
    T val;
    BinaryTree&lt;T&gt;* left;
    BinaryTree&lt;T&gt;* right;
    BinaryTree&lt;T&gt;(T v, BinaryTree&lt;T&gt;* l, BinaryTree&lt;T&gt;* r)
      : val(v), left(l), right(r) 
    {
    }

    BinaryTree&lt;T&gt;(BinaryTree&lt;T&gt; &amp;&amp; r)
    {
        val = r.val;
        left = r.left;
        right = r.right;
    }
};
</code></pre>

<p>Then, you can return your tree by value (but still building nodes dynamically):</p>

<pre><code>MyBinaryTree BuildTree()
{
     auto left = new BinaryTree&lt;int&gt;(0, nullptr, nullptr);
     auto right = new BinaryTree&lt;int&gt;(0, nullptr, nullptr);
     MyBinaryTree&lt;int&gt; result(0, left, right);
     return result;
}
</code></pre>
",0
16910122,16910035,1,"<p>You need to dynamically allocate data. For example to create</p>

<pre><code>  2
 / \
1   3
</code></pre>

<p>using your structure you would do the following:</p>

<pre><code>MyBinaryTree&lt;int&gt;* getTestStructure(){
   MyBinaryTree&lt;int&gt; *root = new MyBinaryTree&lt;int&gt;(2);
   MyBinaryTree&lt;int&gt; *leftChild = new MyBinaryTree&lt;int&gt;(1);
   MyBinaryTree&lt;int&gt; *rightChild = new MyBinaryTree&lt;int&gt;(3);
   root.left = leftChild;
   root.right = rightChild;
   return root;
}
</code></pre>
",0
10770678,10770663,2,"<p>Your problem, as you correctly suspect, is that you are running out of stack space. You shouldn't be placing such big objects on the stack, which is a limited and precious resource. Instead, you can use pointers and allocate them dynamically on the heap.</p>

<p>The problematic code is here:</p>

<pre><code>int main() {
char command;
int listSize = 88801;
LinkedList HashList1[88801]; // &lt;&lt; this
LinkedList HashList2[88801]; // &lt;&lt; and this
</code></pre>

<p>also note that <code>LinkedList* hashbucket1[88801]</code> is an array of pointers, not a pointer to an array. What you want is:</p>

<pre><code>LinkedList (*HashList1)[88801]
</code></pre>

<p>or, with <code>typedef</code> to make it more readable:</p>

<pre><code>typedef LinkedList LinkedListArray[88801];
LinkedListArray* HashList1;
</code></pre>

<p>but by then it would be better to just do:</p>

<pre><code>LinkedList *HashList1 = new LinkedList[88801];
</code></pre>
",3
10813731,10813560,2,"<p>You cannot call other constructors like that in C++. But starting with C++11, you can forward constructor calls in the initialiser list:</p>

<pre><code>class Test {
public:
    Test (): Test(9) {
        cout &lt;&lt; "" Test::Test\n"";
    }

    Test (int a) : x(a) {
        cout &lt;&lt; "" Test::para\n"";
    }

private:
    int x;
};
</code></pre>

<p>See <a href=""https://stackoverflow.com/a/10814418/1968"">Wolfgang¡¯s answer</a> for an explanation of why your code crashes.</p>
",0
10814418,10813560,9,"<pre><code>Test (x);
</code></pre>

<p>is parsed as</p>

<pre><code>Test x;
</code></pre>

<p>... not as a constructor call.
You can also write</p>

<pre><code>Test (y);
</code></pre>

<p>and get the same behaviour.</p>
",1
8746955,8746840,10,"<p>Prefer free, non-friend functions over member functions, because these have less access to class members than member functions, and therefore have less of a chance to introduce bugs. </p>

<p>If the function is completely outside the interface scope then also put it in an unnamed namespace in the implementation file. This will reduce the chance of bugs even further, because other translation units will not be able to call the function.</p>

<p>Another advantage you get with a non-friend in an unnamed namespace is that there's less of a chance you change the header (since there's one less entity in there). Changing a header file often slows down build times considerably, because of the compile-time dependencies. Private or not, you'll probably have a number of translation units depending in terms of compilation on everything in the header.</p>
",1
8746995,8746840,1,"<p>As far as I can tell, you've pretty much got it. There's no difference other than your header file will needlessly grow. You may also be leaking some implementation details in your class's API, though.</p>
",0
8747022,8746840,7,"<p>Free functions that need access to private members would require friend declarations in the header anyway, so they're probably not better than private member functions.</p>

<p>Functions that don't need private access should be free functions whether they're declared in the header or not.</p>

<p>So if they need access to private members then make them members. Otherwise make them free functions.</p>

<p>Scott Meyers has this algorithm for deciding whether a function f related to a class C should be a member, friend non-member, or non-member non-friend:</p>

<p><a href=""http://drdobbs.com/184401197"" rel=""noreferrer"">http://drdobbs.com/184401197</a></p>

<blockquote>
<pre><code>if (f needs to be virtual)
   make f a member function of C;
else if (f is operator&gt;&gt; or
         operator&lt;&lt;)
   {
   make f a non-member function;
   if (f needs access to non-public
       members of C)
      make f a friend of C;
   }
else if (f needs type conversions
         on its left-most argument)
   {
   make f a non-member function;
   if (f needs access to non-public
       members of C)
      make f a friend of C;
   }
else if (f can be implemented via C's
         public interface)
   make f a non-member function;
else
   make f a member function of C;
</code></pre>
</blockquote>
",0
8747313,8746840,1,"<p>yes, there is a difference</p>

<p>if the functions are not parts of the class, it would be better if they are not tied to this particular class:</p>

<ul>
<li><p>there is a probability you will want to use them in another class, and in this case it will be very easy to move them in some shared place and use in both classes</p></li>
<li><p>if the function (which could be a free one) takes a thirdparty class as a parameter and if you make it a member function, you must either include another .h file (which has this class definition) or declare this class in your .h file. this means more coupling, which is bad :)</p></li>
</ul>

<p>so I would prefer to write them as free ones (maybe in .cpp file in unnamed namespace, if they aren't (and, probably, won't) used in other classes)</p>
",0
9150154,9150109,7,"<p>A child object <em>contains</em> a parent object in the way that a house <em>contains</em> a door. If you asked for the coordinates of a house, and I gave you the coordinates of the door, I'd be correct, yes? Especially for the example you give, in which there are no data members and no virtual methods: the child and parent objects not only have the same address, but they have the same size.</p>

<p>Now, if you use multiple inheritance -- if <code>Child</code> derives from both <code>Parent1</code> and <code>Parent2</code> -- and give both parent classes data members so they have non-zero size, and then run a similar diagnostic, you'll definitely find that at most one of the parent objects has the same address as the child.</p>

<p>Finally, note that different compilers will give different answers for all questions like this: the object layout is compiler dependent.</p>
",3
9150168,9150109,6,"<p>Suppose you have a base class with two data members; it will be laid out in memory like this:</p>

<pre><code>member1 &lt;-- object pointer points here
member2
</code></pre>

<p>If a derived class adds a couple more members it will be laid out like this:</p>

<pre><code>member1 &lt;-- object pointer points here
member2
member3
member4
</code></pre>

<p>So if you cast an object of the derived type to the base type the pointer doesn't actually change.  It's still pointing to the same place in memory.</p>
",0
13787851,13787786,1,"<p>As to your getter/setter problem, I would write</p>

<pre><code>const T&amp; value() const; // as getter
void value(const T&amp;); // as setter
</code></pre>

<p>Returning <code>const T&amp;</code> (const-reference) is exactly against situations like <code>c.value() = 10</code> (see eg. Effective C++ by Scott Meyers, item 23).</p>

<p>I think this also solves the copy problem: your class remains copyable.</p>
",1
13787867,13787786,3,"<p>If you want the user to be able to call non-const member functions on the object and you want to return a reference to the actualy object, you can't completely prohibit assignment, since the assignment operator is basically just that (you can rewrite <code>a = b</code> as <code>a.operator=(b)</code>). Therefore you either need to return only a const reference to your object, make the contained object <code>non_copyable</code> or live with the fact, that it can be assigned to.</p>

<p>Personally I would suggesting rethinking the design. Even if you could disallow assignment, there are really no guarantees that the object doesn't have a member function, which does basically the same think (<code>.swap(...)</code> is a typical candidate), so you haven't really won anything as long as you allow calling non const memberfunctions.</p>

<p>However if you are only concerned with disallowing accidential assignments, you can make it harder to make such an assignment. If your <code>T</code> isn't a builtin, you could create a derived class, which doesn't expose a public assignment operator and return a reference to that:</p>

<pre><code>template &lt;typename T&gt;
class C{
public :
    class Derived: public T {
    private:
       Derived(int size):T(size) {}
       Derived&amp; operator=(const Derived&amp;) = default; //used C++11 syntax for brevity, for C++03 code it has to be implemented here
       Derived(const Derived&amp;) = default; //don't want this class to be copyied outside of C
       ~Derived() = default;
       friend class C;    
    };

    C (int size) : value_(size), some_other_member_(size) {}
    Derived&amp; value () {return value_;}
    const Derived&amp; value() const {return value_;}
 private :
    Derived value_;
    SomeOtherType some_other_member_;
 };
</code></pre>

<p>This will give access to all public members by inheritence, but hide assignment operator (and constructors). Of course if you use c++11, this code could be enhanced by using/defining move constructors/assignments and using perfect forwarding, to allow different constructors. Note that the T-part of Derived can still be assigned to using <code>static_cast&lt;T&amp;&gt;(C.value()) = foo</code>;</p>

<p>To support types you can't derive from (builtins...), you'd need to create a proxy, which exposes all functionality except assignments.</p>
",1
10760699,10760658,6,"<p>You are missing the <code>class</code> keyword in your class definitions.</p>

<p>instead of <code>class1{...}</code> you need <code>class class1{...}</code>, etc.</p>
",3
10760737,10760658,1,"<p>In <code>class2.h</code>, the compiler does not ""know"" how <code>class1</code> is defined. There are two possible solutions:</p>

<ul>
<li>Add an <code>#include ""class1.h""</code> in <code>class2.h</code></li>
<li>Add a so-called <em>forward declaration</em> of <code>class1</code> in <code>class2.h</code> by simply declaring <code>class class1;</code> at the top of the header. You then need to change your <code>method2</code> to either expect a <em>reference</em> or a <em>pointer</em> to <code>class1</code>. If you then add <code>#include ""class1.h""</code> in <code>class2.cpp</code>, everything will work.</li>
</ul>
",0
10761030,10760658,1,"<p>the only clean solution is to include the header defining <code>class class1</code> before the definition of <code>class class2</code>. </p>

<p>Note that a forward declaration (al la Gnosophilon's answer) won't help here, as it only <em>declares</em> the class, but does not <em>define</em> it. This means that you can use a pointer or reference to the class, but not more, in particular you cannot pass <code>class1 myclass</code> by value as you try to do.</p>
",0
20656278,12958451,0,"<p>There's no operator like that. I implemented, some times ago, a matrix trying to be close to the stl standards. 
And I used this method: first I've overloaded the operator[] to return another class that I called _C_row:</p>

<pre><code>_C_row operator[](size_type index) { return _C_row(/*some parameters*/); } ///&lt; This operator is overloaded to permit the use of double pointer notation.
_C_row operator[](size_type index) const { return _C_row(/*some parameters*/); } ///&lt; This operator is overloaded to permit the use of double pointer notation.
</code></pre>

<p>And in _C_row I overloaded more than the operator[]:</p>

<pre><code>value_type operator*() { return _r[0]; }
pointer operator-&gt;() { return _i[_idx]; }
double_pointer operator&amp;() { return &amp;(_i[_idx]); }
reference operator[](size_type col) { return _r[col]; }
const_reference operator[](size_type col) const { return _r[col]; }
</code></pre>

<p>I found this solution is very flexible. I hope my answer could be useful for you.</p>
",0
17810032,10063884,2,"<p>This is due to the feature not being enable by default by the GCC compiler. If you're on Codeblocks, go to Settings --> Compiler and enable the feature as shown - <a href=""http://imgur.com/KrHx8nh"" rel=""nofollow"">http://imgur.com/KrHx8nh</a></p>
",0
17810268,10063884,9,"<p>To explain what the compiler is actually complaining about: <code>auto</code> used to be an old C keyword, declaring that this variable has <em>automatic storage</em>. These keywords have little to do with the type system, they specify how variable are represented in memory: where they're stored (processor register vs. main memory / stack) and how the memory is reclaimed. <code>auto</code> means the variable is stored on the stack (though the processor may optimise it into a processor register) and the memory is <em>automatically reclaimed</em> when the variable goes out of scope ¨C which is the right choice in almost any situation<sup>1</sup> and thus the default, so virtually nobody ever used this old <code>auto</code> keyword. Yet <code>C++03</code> still provided backwards compatibility for code that has it; today's compilers still want to support legacy code.</p>

<hr>

<p><sup>1</sup>Though often you want <em>objects</em> to reside on the heap, you'll still be accessing those through variables on the stack; C++ has its own methods of using heap-allocated memory (<code>new</code>, <code>std::vector</code> etc.), you don't need the unsafe C-style <code>malloc</code> stuff.</p>
",0
11138728,11138626,2,"<p>The <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms633520.aspx"" rel=""nofollow"">second parameter</a> of <code>GetWindowText</code> is an out parameter:</p>

<blockquote>
  <p>lpString [out] 
   Type: LPTSTR</p>
  
  <p>The buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a null character. </p>
</blockquote>

<p>So you need to supply a buffer to be filled, not a pointer to a constant string (the third parameter indicates the maximum size of the buffer to avoid overflow)</p>

<p>Try:</p>

<pre><code>const size_t BUFF_SIZE = 100;
TCHAR title_old[BUFF_SIZE];
int gettus = GetWindowText(g_hWnd, title_old, BUFF_SIZE);
</code></pre>

<p>Also, you only need to call <code>GetLastError</code> if <code>gettus</code> is 0 (<code>GetWindowText()</code> failed)</p>
",0
10769391,10769371,2,"<p>What you want to do is not possible. You are trying to re-initialize an array, and that cannot be done. Perhaps, given that your use case is for error strings, you can do something like this:</p>

<pre><code>    bool foo::ipitythefoo()
    {
        static const char* actualstringarray[] = {""Mr. T"",""Gold Chains"",""Mohawks""};
        *mystringarray = actualstringarray;

        return false;
    };
</code></pre>

<p>But then, it'd make more sense for an array of error strings to be <code>static</code> to begin with.</p>
",0
8753315,6703288,1,"<p>Just to add some extra information on the subject for MSVC and G++, and echoing exactly what @Charles Bailey, and @Ren¨¦ Richter said; Its acceptable C++03, and C++11 but depending on the age and implementation state of your compiler you are going to get differing errors if at all.</p>

<p>Actually I tried <a href=""http://www.dinkumware.com/exam/"" rel=""nofollow noreferrer"">Dinkum's online test compilers</a> for EDG, MSVC2008, and G++ and all compile the sample you gave but NOT the sample I give below.</p>

<p>So in short <strong>fully initialized</strong> <em>structs with const members</em> will successfully compile on MSVC2008 and G++4.5, however of the tested compilers <strong>none can compile</strong> <em>""partially initialized"" (or partially aggregate initialized)</em> POD structures even though that too is allowable in the C++ standard - I even contacted some G++ bug maintainers to make sure I was reading that standard correctly and they confirmed it should work even in current C++03 compilers.</p>

<p>You can see related bugs for this on both <a href=""http://gcc.gnu.org/bugzilla/show_bug.cgi?id=49132"" rel=""nofollow noreferrer"">GNU Bugzilla</a> and over at <a href=""http://connect.microsoft.com/VisualStudio/feedback/details/488660/improper-issuance-of-c4610"" rel=""nofollow noreferrer"">Microsoft's Visual Studio help pages</a> which was actually linked from this <a href=""https://stackoverflow.com/questions/7151298/why-do-i-get-these-warnings-in-visual-c-2008-when-building-a-struct"">other stackoverflow article titles ""why do I get this warnings in Visual Studio when building a struct?</a> which is also related to <a href=""http://msdn.microsoft.com/en-us/library/yhh8tk4w.aspx"" rel=""nofollow noreferrer"">Microsoft's Error C3852 as a known behavior of even MSVC2010</a></p>

<pre><code>// All sections refer to Draft C++03 (brackets refer to draft C++11)
//
// 3.9.3 CV (const/volatile) definition as ""const data-type [= optional init]""

// 7.1.5.1/1 The cv-qualifiers  [ 7.1.6.1/1 in C++11 ]
//    ""init-declarator-list of the declaration shall not be empty""
const int constval = 10 ;

// HOWEVER:
// 7.1.5.1/2 The cv-qualifiers  [ 7.1.6.1 in C++11 ]
//  [Note: as described in 8.5, the definition of an object or subobject
//  of const-qualified type must specify an initializer or be subject to 
//  default-initialization. ]

// 8.5 Initializers
// 8.5/9  (C++11 8.5/11)
//   Otherwise, if no initializer is specified for a non-static
//   object, the object and its sub-objects, if any, have an indeterminate 
//   initial value(*90); if the object or any of its sub-objects are of 
//   const-qualified type, the program is ill-formed.
//
// *90: This does not apply to aggregate objects with automatic storage 
//      duration initialized with an incomplete brace-enclosed initializer list
//      see 8.5.1.
// [ C++11 this sub-clause has been removed, however the list-initializer section
//   pretty much covers the same topic - see 8.5.1/7 below ]
// 
// 8.5.1 Aggregate definition
// 8.5.1/7 (C++11 8.5.1/7)
//   If there are fewer initializers in the list than there are members in the 
//   aggregate, then each member not explicitly initialized shall be 
//   value-initialized (8.5).
//
//   8.5/5 value initialization
//     if T is a class type (clause 9) with a user-declared constructor 
//     (12.1), then the default constructor for T is called (and the 
//     initialization is ill-formed if T has no accessible default constructor)
//     ...
//     otherwise, the object is zero-initialized
//
//   8.5/5 zero initialization
//     if T is a scalar type (3.9), the object is set to the value of 0 (zero) converted to T;
//

// POD type
struct A {
  int n ;
  const int m ;  // ""const"" causes failure in MSVC to make default constructor
} ;


// Example of non-POD
struct B {
  int bbb ;
  B(){}
} ;

#include &lt;stdio.h&gt;
int main() {
  // C++03/11 ill formed code, fails as expected
  const int c0 ;                        // per 7.1.5.1 ""not allowed to be default init""

  // OK
  const int c = *new int ;              // A default initialized constant
  const int c2 = *new int();            // A zero-init, above is DEFAULT-INIT
  printf( ""c: %i\n"", c ) ;              // should be an undef-value
  printf( ""c2: %i\n"", c2 ) ;            // should be 0

  // OK ; Array example making sure it works
  const int aa[5] = {}; // all items value-&gt;zero-initialized per the above 8.5.1/7
  printf( ""aa: %i %i %i\n"", aa[0], aa[2], aa[4] ) ;

  // C++03/11 ill formed code, no initializer (G++/MSVC should fail)
  A a0 ;                // Correct error - no default constructor or initializer (8.5/9)

  // C++03/11 correctly formed code, full initializer list (G++/MSVC should pass)
  A a1 = {1,2};         // Explicit initialization OK, G++/MSVC pass

  // C++03/11 correctly formed code; copy initialized from a value-initialized A()
  A a2 = A();           // G++ OK, MSVC FAIL

  // C++03/11 correctly formed code; aggregate partial intializer (8.5.1/7 agg list init)
  A a3 = {};            // G++/MSVC FAIL

  A a4{};               // C++11 only - doesnt work in G++ (didnt try MSVC2010)

  printf( ""a0.m=%i\n"", a0.m ) ; // a0 should not exist due compile errors
  printf( ""a1.m=%i\n"", a1.m ) ; // a1.m should be 2
  printf( ""a2.m=%i\n"", a2.m ) ; // a2.m should be 0
  printf( ""a3.m=%i\n"", a3.m ) ; // a3.m should be 0

  // C++03/11 correctly formed code; user-default constructor supplied.
  const B bee1 ;         // Default constructor marks bbb as ""initialized""
  const B bee2 = {} ;    // CORRECTLY flagged error; init of non-aggregate
  printf( ""%i\n"", bee1.bbb ) ;  
}
</code></pre>
",0
19874650,5603043,0,"<p>The bug can be happened even with <code>.cpp</code> file extension, when have the right <code>.h</code> entry in the HEADERS <code>.pro</code> section but the <code>.cpp</code> is skipped in the SOURCES. </p>

<p>Usually when <code>file.h</code> is copy and pasted to the SOURCES without the extension changing, in that case, the 'make' command also creates the (CC) entry in the makefile instead of (CXX) to process the header only.</p>
",0
11866800,11866729,3,"<p>You need to call copy.</p>

<pre><code>MyClass::MyClass(const char* param)
{
  std::copy(param, param + 4, chars);
}
</code></pre>

<p>This is slightly risky code since there is no guarantee that param has four characters to copy.</p>
",6
11866874,11866729,-2,"<p>Yes. You need to copy the contents from the input parameter.</p>
",6
11866903,11866729,-1,"<p>As I understood, you need to create <code>Conversion constructors</code>, it should looks like this:
<code>A::A(const char* string)
{strncpy(chars, string, 4);
}
</code></p>
",0
11866949,11866729,2,"<p>An alternative could be to use a <code>vector&lt;char&gt;</code> which can be initialised in the initialiser list:</p>

<pre><code>class A
{
public:
    A(char* a): a_(a, a + strlen(a)) {}
private:
    std::vector&lt;char&gt; a_;
};
</code></pre>

<p>See demo at <a href=""http://ideone.com/x9p6I"" rel=""nofollow"">http://ideone.com/x9p6I</a> .</p>

<hr>

<p>This could be made into a template to support different types but would require the number of elements in the array to be provided to the constructor (as <code>strlen()</code> would not be applicable to an array of <code>int</code>). For example:</p>

<pre><code>template &lt;class T&gt;
class A
{
public:
    A(const T* a, const size_t count): a_(a, a + count) {}
private:
    std::vector&lt;T&gt; a_;
};
</code></pre>

<p>See demo at <a href=""http://ideone.com/hhoaC"" rel=""nofollow"">http://ideone.com/hhoaC</a> .</p>
",2
11866995,11866729,5,"<p>Use <code>std::copy</code> like this: </p>

<pre><code>class MyClass
{
    char m_x[4];    
public:
    MyClass(const char (&amp;x)[4])
    {
        std::copy(x, x + 4, m_x);
    }
};
</code></pre>

<p>You should really be explicit with your types here to enforce that you pass exactly 4 elements.</p>
",8
11508408,11508163,3,"<p>Your problem is in <code>main</code> not <code>attack</code>. You set your access modifier for <code>Enemy::setAttackPower(int)</code> and <code>Enemy::getAttackPower()</code> to <code>protected</code>. That means these methods are treated as <code>private</code> unless if you're inside a class that <strong>extends Enemy</strong>.</p>

<p>That means when you are in <code>main</code> it can't access <code>ninjaObj.setAttackPower(23)</code> because <code>main</code> is <strong>outside the scope of any object</strong>.</p>

<p>If you call <code>ninjaObj.attack()</code>, however, it will also fail because you did not set an access modifier for <code>Ninja::attack()</code>, so it <strong>defaults to private</strong>.</p>

<p>To fix: add <code>public:</code> in front of <code>Ninja::attack()</code>, and do not call <code>Enemy::setAttackPower(int)</code> or <code>Enemy::getAttackPower()</code> in <code>main</code>.</p>
",2
13734123,13734077,6,"<p>What you have here is <em><a href=""https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c"">object slicing</a></em>. In order to use objects polymorphically, you <em>have</em> to access them through a pointer or a reference.</p>

<p>The signature of your factory method should be changed to return a <code>PrologConnector*</code> or <code>PrologConnector&amp;</code>, after which you will be able to see the expected behavior.</p>
",5
13734130,13734077,4,"<p>The problem is common and is called ""slicing"". You're assigning a derived class to an instance of the base class, and all attributes of the derived class are being lost during the copy.</p>

<p>Use a pointer or reference to the class instead.</p>
",0
13734146,13734077,2,"<p>Here is what happens in this method:</p>

<pre><code>PrologConnector PrologConnector::connectorFactory(Prolog prolog, char **argv) {
  if (prolog == swi) {
    SWIConnector sc;
    sc.init(argv);
    // return sc;
    return PrologConnector(sc);
  }
</code></pre>

<p>as you return variable of the type PrologConnector. And PrologConnector's methods will be called. </p>

<p>You need to return pointers rather than copy of objects.</p>
",1
13771661,13734077,0,"<p>Thanks for the answers, that was exactly what happened.. Never heard about that before :)</p>

<p>Another hint:</p>

<pre><code>PrologConnector* PrologConnector::connectorFactory(Prolog prolog, char **argv) {
  if (prolog == swi) {
  SWIConnector *sc = new SWIConnector;
  sc-&gt;init(argv);
  return sc;
} 
</code></pre>

<p>I had to use ""new"" to instantiate that SWIConnector, otherwise I get a ""segmentation fault"" in the main function. I am not completely sure why, because I thought the ""SWIConnector x"" already allocates memory, but there seems to be another reason :)</p>

<p>Regards</p>
",0
15861220,15861133,0,"<p>use <code>push_back</code> to add to the vector</p>

<pre><code>vector&lt;GLubyte&gt; m_coneIndices;

// Body triangles
for (int i = 0; i &lt; coneSlices * 3; i += 3) {
    m_coneIndices.push_back(i);
    m_coneIndices.push_back((i + 1) % (2 * coneSlices));
    m_coneIndices.push_back((i + 3) % (2 * coneSlices));
}

// Disk triangles
for (int i = 1; i &lt; coneSlices * 2 + 1; i += 2) {
    m_coneIndices.push_back(diskCenterIndex);
    m_coneIndices.push_back(i);
    m_coneIndices.push_back((i + 2) % (2 * coneSlices));
}
</code></pre>

<p>print:</p>

<pre><code>cout &lt;&lt; ""indices""&lt;&lt; ""\n"";

for (size_t i = 0; i&lt; m_coneIndices.size(); i+=3) {
    cout &lt;&lt; m_coneIndices[i*3] &lt;&lt; ' ' &lt;&lt; m_coneIndices[i*3+1] &lt;&lt; ' ' &lt;&lt;
            m_coneIndices[i*3+2] &lt;&lt; ' ' &lt;&lt; ""\n"";
}
</code></pre>
",0
15861813,15861133,0,"<p>I was doing right. I changed code by </p>

<pre><code>for (int i=0; i&lt;(coneSlices * 2 ); i+=2) {

     printf(""%d "",(int)m_coneIndices[i]);
}
</code></pre>

<p>and that worked.</p>
",0
15553346,15553246,1,"<p>Try this:</p>

<p>class Particles {</p>

<p>private:</p>

<pre><code>struct Particle {
    double x, y, z, vx, vy, vz;
};

Particle * parts;
</code></pre>

<p>public:</p>

<pre><code>Particles (int count)
{
    parts = new Particle [count]; // &lt; here is problem
}
</code></pre>

<p>};</p>
",0
15553270,15553246,6,"<p>Remove those <code>[]</code> from declaration. It should be</p>

<pre><code>Particle *parts;
</code></pre>

<p>Using C++, you can use benefits of <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a>:</p>

<pre><code>class Particles {
  // ...

 std::vector&lt;Particle&gt; parts;

 public:

    Particles (int count) : parts(count)
    {

    }
};
</code></pre>
",1
15553297,15553246,2,"<pre><code>Particle * parts[];
</code></pre>

<p>This is an array of pointers. To initialise this, you would need to loop through the array, initialising each of the pointers to point at a dynamically allocated <code>Particle</code> object.</p>

<p>You probably want to just make <code>parts</code> a pointer:</p>

<pre><code>Particle* parts;
</code></pre>

<p>The <code>new[]</code> expression returns a pointer to the first element of the array - a <code>Particle*</code> - so the initialisation will work just fine.</p>
",0
9849908,9849888,3,"<p>It is because of <a href=""http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8l.doc%2Flanguage%2Fref%2Ftemplate_argument_deduction.htm"" rel=""nofollow"">template argument deduction</a> which means the template argument is <em>deduced</em> from the type of the argument passed to the function call. This type deduction is done by the compiler. Go through <a href=""http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8l.doc%2Flanguage%2Fref%2Ftemplate_argument_deduction.htm"" rel=""nofollow"">the link</a> which explains it in great detail.</p>
",0
14815899,14815823,2,"<p>Type qualifiers, (<code>const</code> and <code>volatile</code>), create different types.  <code>int</code> is a different type from <code>const int</code>.  </p>

<p>So do references, pointers, and arrays. For example:</p>

<p><code>int</code>, <code>int&amp;</code>, <code>int[10]</code> and <code>int*</code> are all different types.</p>

<p><code>T</code> is a different type from <code>std::remove_reference&lt;T&gt;::type</code> if <code>T</code> is a reference.</p>

<p>The <code>&lt;typeinfo&gt;</code> output of <code>typeid(int).name()</code> is platform-dependent and doesn't have to distinguish between reference/non-reference types.  However, the C++ type system <em>definitely</em> distinguishes between <code>T</code> and <code>T&amp;</code>, as you've discovered through <code>type_traits</code>.</p>
",2
14816004,14815823,4,"<p>From Paragraph 5.2.7/4 of the C++11 Standard:</p>

<blockquote>
  <p>When typeid is applied to a type-id, the result refers to a std::type_info object representing the type of the type-id. <strong>If the type of the type-id is a reference to a possibly cv-qualified type, the result of the typeid expression refers to a std::type_info object representing the cv-unqualified referenced type</strong>. If the type of the type-id is a class type or a reference to a class type, the class shall be completely-defined.</p>
</blockquote>

<p>Thus, <code>typeid(int)</code> and <code>typeid(int&amp;)</code> will give the same result, although the two types are definitely different. Similarly, for the type system <code>int</code> and <code>int const</code> are different types, but the <code>typeid</code> operator ignores the <code>const</code> qualification. From Paragraph 5.2.7/5 of the C++11 Standard:</p>

<blockquote>
  <p>The top-level cv-qualifiers of the glvalue expression or the type-id that is the operand of typeid are always ignored.</p>
</blockquote>

<p>Finally, <code>int</code> and <code>int*</code> are again different types for the type system, and the <code>typeid</code> operator returns different results for them.</p>
",0
14816007,14815823,0,"<p><a href=""http://en.cppreference.com/w/cpp/types/type_info/name"" rel=""nofollow""><code>std::type_info::name</code></a> says nothing about identity. <em>If</em> you insist on using <code>typeid</code> to test for identity, try the following:</p>

<pre><code>assert(typeid(T) != typeid(U));
</code></pre>

<p>This is using the defined <a href=""http://en.cppreference.com/w/cpp/types/type_info/operator_cmp"" rel=""nofollow"">equality comparison operator</a> on the <code>type_info</code> objects. But prepare for disappointment: the above assertion will fail for <code>T = int</code> and <code>U = int&amp;</code> because of ¡ì5.2.7/4 (see Andy¡¯s anser).</p>
",3
17082931,17082841,3,"<p>According to the <a href=""http://www.open-std.org/jtc1/sc22/open/n2356/basic.html"" rel=""nofollow"">standard</a> (3.9.1  Fundamental types):</p>

<blockquote>
  <p>Plain char, signed char, and unsigned char are three distinct types.</p>
</blockquote>

<p>A string literal in the form of <code>""text""</code> consists of <code>const char</code> and not a <code>const signed char</code> or <code>const unsigned char</code>.</p>

<p>Since they are pointer types you can easily cast them to each other, but that won't be done implicitly.</p>
",0
17082950,17082841,3,"<p>The type of a string literal is <code>char []</code>, an array of <code>char</code>.  When passed to a function like this, it will be evaluated as a pointer to its first element, a <code>char *</code>.</p>

<p><code>char</code> and <code>signed char</code> are distinct types (even if <code>char</code> is signed on your platform).  A pointer to one cannot be implicitly converted to a pointer to the other.</p>

<p>Your function should be declared with the first parameter as <code>const char *</code> if you want to pass string literals without an explicit conversion.</p>
",0
17082968,17082841,0,"<p>You can try:</p>

<pre><code>CH_COM_DebugPrintf((S8*)""TunerCallback device id:[%du]\r\n"", ri_Device);
CH_COM_DebugPrintf((S8*)""TunerCallback event type:[%du]\r\n"", renm_EventType);
</code></pre>

<p>printing as unsigned values</p>

<p>Maybe you should use <code>typedef unsigned char S8;</code> instead of <code>signed</code> values, because device id and callback types representations  are semantically positive values.</p>
",3
11569674,11569634,5,"<p>C++ supports local classes.  The syntax is the same as for any class type, except that member functions and static member variables must be defined inside the class body, not declared and defined later (there's no way to name the member from outside the enclosing function).</p>

<p>Beginning in C++11, they can be used as template type parameters, which makes them much much more useful.</p>

<p>It would look something like:</p>

<pre><code>void Parent::func( EventProducer* blah )
{
    struct LocalListener : OnClickListener
    {
        virtual void clicked() { ... }
    };
    struct FancyLocalListener : OnClickListener
    {
        Parent* p;
        FancyLocalListener(Parent* p) : p(p) {} // but use better variable names, please ;)
        virtual void clicked() { p-&gt;func2(); }
    };

    blah-&gt;addOnClickListener(new LocalListener());
    blah-&gt;addOnClickListener(new FancyLocalListener(this));
}
</code></pre>

<p>(but watch out for leaks)</p>

<p>C++ tends not to use interfaces for this, though.  A better design is to accept a functor for the listener, which in C++11 allows the use of lambdas (the compiler creates the local class for you).</p>
",9
9784228,9783932,1,"<p>C++ wont let you compile Ambiguous code. If ambiguity is the in the code you have to try to resolve it. </p>

<p>Function cannot be overloaded which differs only in return type.</p>

<p>Check out this link for examples. <a href=""http://xania.org/200711/ambiguous-overloading"" rel=""nofollow"">http://xania.org/200711/ambiguous-overloading</a></p>

<p>the following will only work:</p>

<pre><code> #include &lt;stdio.h&gt;

    int     fct(int a)
    {
            printf(""a: %d\n"", a);
            return (0);
    }

    void    fct()
    {
        printf(""a: 0\n"", a);
    }



    int     main(void)
    {

            fct();
            return (0);
    }
</code></pre>
",0
9784011,9783932,6,"<p>No, because once you added default value to <code>fct(int)</code> compiler can't guess which one you want to call:</p>

<ul>
<li><code>fct(int)</code> with default value of arg</li>
<li><code>fct()</code></li>
</ul>

<p>What you can do is remove default value, and call <code>fct(0)</code> or remove the one without arguments completely.</p>
",0
9785712,9783932,0,"<p>You cannot overload functions by return type alone. Let me list down the functions that are generated for your case
    <code>int     fct(int a = 0)</code>
will generate two functions (one with argument, one without) : 
    <code>int     fct(int a)</code> and <code>int     fct()</code>
In addition to above functions you have introduced another method
    <code>void    fct()</code>
So you have two methods, differed by return type
    <code>void    fct()</code> and <code>int     fct()</code>
In C++, you <strong>CANNOT</strong> have overloaded functions with the variation in return type alone</p>
",0
14193897,14193830,11,"<p>The template is instantiated when used. However, it should be compiled when it's defined. Your code <code>A(0)</code> uses the name <code>A</code>, which doesn't depend on the template parameter <code>T</code>, so it should be resolved when the template is defined. This is called two-phase lookup. The way clang finds the error is simply by trying to resolve the call <code>A(0)</code> as soon as it sees it.</p>

<p>My version of GCC also compiles this code silently, even with <code>-pedantic-errors</code>. Both C++03 and C++11 say that no diagnostic is required, even though the program is ill-formed, so GCC conforms. This is 14.6/7 in C++03 and 14.6/8 in C++11:</p>

<blockquote>
  <p>If no valid specialization can be generated for a template definition,
  and that template is not instantiated, the template definition is
  ill-formed, no diagnostic required.</p>
</blockquote>
",5
14194082,14193830,5,"<ol>
<li><p>Yes. When no valid specialization exist but the template isn't instantiated -- like here -- the program is ill-formed, but no diagnostic is required (14.6/8).  So both clang and g++ are right.</p></li>
<li><p>clang does more checks than g++ on the template declaration.</p></li>
<li><p>See above.</p></li>
</ol>
",2
10160197,5789762,1,"<p>The <em>./ser.h</em> is not an executable file.  Please keep in mind, file extensions ending in <em>.h</em> are generally header files.  </p>

<p>If your platform is windows you will find executable files taking the file extension <em>.exe</em>.  </p>

<p>One <em>Ser.h</em> file <strong>is</strong> enough to receive all the declarations, so you do not need two of the same header files. </p>
",0
9154847,9154839,0,"<p>One <em>could</em> use structures:</p>

<pre><code>struct foo {
   int a,b,c;
   float f;
}
</code></pre>

<p>Sadly, you need to define them somewhere and the receiving function needs to accept them, you can't just make them up in-place.</p>

<p>At the end of the day, <strong>there's no language tool in C++ that could mimic the JavaScript 'idiom'</strong>. Such stuff lies in the nature of a dynamic language, which C++ is not.</p>
",0
9154852,9154839,0,"<p>Yes.</p>

<p>In C++, an object is an instance of a class. You could create a class holding all the possible arguments, instantiate it and fill it with your particular values, and then pass that instance to the function.</p>

<p>You cannot just pass an arbitrary object instead of the function's arguments, because C++ doesn't have <em>named arguments</em> - only the position matters, and the position within some kind of hash structure is lost. So you can't say <code>foo(y=3)</code> when you have a function <code>foo(int x, int y)</code> because the names <code>x</code> and <code>y</code> only have meaning within the function - not to its callers.</p>
",0
9154853,9154839,0,"<p>No, not really. There is a <code>map</code> class in the standard library, and of course you could write a function that accepted a <code>map</code> full of named values as input, but there's nothing that exists directly as a language feature equivalent to what you've shown.</p>

<p>As several other posters have pointed out, of course you can define a class to hold all the data values, but this just pushes the ordered parameter list from the function to the constructor of that object, so it buys you nothing at all.</p>
",0
9154858,9154839,4,"<p>boost parameter <a href=""http://www.boost.org/doc/libs/release/libs/parameter/"" rel=""nofollow"">http://www.boost.org/doc/libs/release/libs/parameter/</a> do exactly what you want.</p>

<p>From its abstract:</p>

<blockquote>
  <p>Use this library to write functions and class templates that can
  accept arguments by name</p>
</blockquote>

<p>Small example:</p>

<pre><code>// include boost parameter
#include &lt;boost/parameter/keyword.hpp&gt;
namespace parameter = boost::parameter;

// first declare named parameters
BOOST_PARAMETER_NAME(a)      // Note: no semicolon
BOOST_PARAMETER_NAME(b)

// then declare your function
BOOST_PARAMETER_FUNCTION(
      (int),                 // 1. parenthesized return type
      my_function,           // 2. name of the function
      tag,                   // 3. namespace of tag types (don't change!)
      (required (a, int) )   // 4. one required parameter of type int
      (optional              //    and an optional parameters, with default value
        (b, int, 0)
      )
)
{
  return a + b;
}

// then you can call it with no named parameters
int result = my_function(1, 2);

// or with named parameters
int result = my_function(_a=1, _b=2);

// also with optional parameters omitted
int result = my_function(_a=3);
</code></pre>
",0
9154875,9154839,0,"<p>Use structs or classes to group your data.</p>

<p>If you're looking for a way to pass key value pairs, use <a href=""http://www.cplusplus.com/reference/stl/map/"" rel=""nofollow"">STL maps</a></p>
",0
9154886,9154839,0,"<p>Not at the language level, but:</p>

<p><em>It is very useful when you have a lot of parameters to pass, IMO it makes using functions easier than using the classic approach.</em></p>

<p>You should really consider cutting down on your parameters if you can. Often this can be achieved by using aggregates:</p>

<pre><code>Example: 
    draw_rectangle(x1, y1, x2, y2, r, g, b, a)
Could be reduced to:
    draw_rectangle(p1, p2, color)
Or even further:
    draw_rectangle(rect, color)
</code></pre>

<p>The temptation for named parameters should be mitigated considerably if you do this.</p>

<p>You can also use alternative approaches like Boost Parameter which, through a lot of template magic, accomplishes something like this. However, it requires you turn all your functions using this technique into templates written in a very precise way, and it's a very bulky and heavy-handed attempt to force the language to do something it wasn't designed to do if you ask me.</p>
",0
9154893,9154839,1,"<p>You can use the ""named parameter idiom"":
<a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.20"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.20</a></p>

<p>Which would make your call look like:</p>

<pre><code>f(1).myOtherParam(""Hello"")
</code></pre>

<p>See <a href=""https://stackoverflow.com/questions/203667/c-named-parameter-idiom-vs-boostparameter-library"">here</a> for a comparison with Boost parameter.</p>
",1
9155048,9154839,0,"<p>You can do the following, which supports default values to a limited amount (limited by the template system of C++). You will need to compile this with the newest standard (C++11)</p>

<pre><code>// used to skip arguments and default to the previously specified value
struct UseDefault {
  // empty intentionally!
};

// using this is optional, and only required if you want to provide default values by the CALLED function
template &lt;typename T, T def&gt; struct Default {
  T value;
  operator T() {
    return value;
  }
  Default(T value) : value(value) {}
  Default(UseDefault ignore) : value(def) {(void)ignore;}
};

// using tuple, you can bundle any number of parameters to one
int myFunc(std::tuple&lt;Default&lt;int,7&gt;,Default&lt;char,'x'&gt;,std::string&gt; parameters) {
  std::cout &lt;&lt; std::get&lt;0&gt;(parameters) &lt;&lt; "", "" &lt;&lt; std::get&lt;1&gt;(parameters) &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p>You can then invoke <code>myFunc</code> like this:</p>

<pre><code>func(std::make_tuple(6,UseDefault(),""hi""));
</code></pre>

<p>Note however, that there are some limitation to the template parameter types, for instance, you cannot pass strings (or <code>char*</code>s for that matter) as template parameters. However, if you only need reasonable basic default values, this could work.</p>

<p>Of course if you drop your requirement to specify default values, you can simply use the <code>std::tuple</code> without my <code>Default</code> type.</p>
",0
12833899,12833858,2,"<p>This says that it's a member function that has a <code>this</code> pointer. Otherwise, it would be a free function, wouldn't have any idea what object it was operating on, and wouldn't be able to access any non-static member functions or member variables.</p>
",1
12833934,12833858,1,"<p>From <a href=""http://www.parashift.com/c++-faq/fnptr-vs-memfnptr-types.html"" rel=""nofollow noreferrer"">C++ FAQ</a></p>
<blockquote>
<p>Is the type of &quot;pointer-to-member-function&quot; different from &quot;pointer-to-function&quot;?</p>
<p>Yep.</p>
</blockquote>
<p><a href=""http://www.parashift.com/c++-faq/pointers-to-members.html"" rel=""nofollow noreferrer"">Link</a> which I've provided to you has a lot of information about this topic.</p>
",6
12833948,12833858,0,"<p>The function, you pass there, must be declared inside the class T - the template parameter of myButtoncb. So you can use a function like the following:</p>

<pre><code>class A
{
public:
     void foo(void);
};


myButton&lt;A&gt; b;
b.cback = &amp;A::foo;
</code></pre>
",0
11138480,11138411,5,"<p>Your target is a ¡°container¡± of length 1 (namely, a single object, <code>len</code>).</p>

<p>You are copying four subsequent byte values into this container, which of course fails ¨C in particular, it causes an overflow since the target only has space for a single element.</p>

<p>Other errors in your code (not an exhaustive list):</p>

<ul>
<li>You are confusing character codes and their string representation</li>
<li>You are performing redundant casts</li>
</ul>

<p>The first point in particular is relevant since what you actually want to do is <em>parse</em> the number encoded in the first four characters of the string as a decimal number. But what you actually do is copy its character codes.</p>

<p>To parse a number in C++, use as <a href=""http://en.cppreference.com/w/cpp/io/basic_stringstream""><code>std::stringstream</code></a> or, since C++11, <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol""><code>std::stoi</code></a></p>
",5
11138552,11138411,0,"<p>First of all, <code>std::copy</code> does roughly this:</p>

<pre><code>template &lt;typename InputItr, typename OutputItr&gt;
void copy(InputItr begin, InputItr end, OutputItr obegin)
{
    while (begin != end)
        *obegin++ = *begin++;
}
</code></pre>

<p>Your output iterator is <code>uint32_t*</code>, which would actually cause you to overwrite 4 32-bit words! (buffer overflow). You are seeing <code>49</code> because the first character that is copied (<code>'1'</code>) has the ASCII value 49.</p>
",0
11138575,11138411,1,"<p>std:copy doesn't work as you're expecting. It copies the source 'element-wise' to the destination. So it copies the first uint8 (= char '1' == 0x49 in hex) to 'len', and then proceeds to trample on three random uint32 values following on in memory.</p>

<p>This this instead to see what's actually happening.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
  uint32_t len[4];
  char abc[] = ""12345678"";
  copy(abc, &amp;abc[4], &amp;len[0]);
  cout &lt;&lt; "" len: "" &lt;&lt; len[0] &lt;&lt; "" "" &lt;&lt;len[1] &lt;&lt; "" "" &lt;&lt; len[2] &lt;&lt; "" "" &lt;&lt; len[3] &lt;&lt; endl;
} 
</code></pre>
",0
15831592,15831517,-1,"<p>Bad idea. </p>

<p>Use:</p>

<p>#define debug(x) do { if (DEBUG_LEVEL) print_stuff(x); } while(0)</p>

<p>which avoids the issue.</p>
",2
15831738,15831517,1,"<blockquote>
  <p>I would like to find in a c/c++ code project all if/else sentences which are not using curly braces. Is there any compiler check or utility to find them?</p>
</blockquote>

<p>This sounds like the <a href=""http://www.perlmonks.org/?node_id=542341"" rel=""nofollow"">x-y problem</a>. If you are trying to replace the DEBUG macro with a no-op that will not invalidate the syntax of the if, you can use:</p>

<pre><code>#ifdef DEBUG_ENABLED
#define DEBUG GET_DEBUG_DST(DEBUG_LEVEL_DEBUG).nospace() &lt;&lt; DEBUG_PREFIX // ...
#else
#define DEBUG do {;} while(false); /##/
#endif
</code></pre>

<p>In this case, the DEBUG will be a valid operation (doesn't invalidate the else due to nothing in the if block), and anything that's on the same line (the debug message data) will evaluate to:</p>

<pre><code>if (my condition)
    do {;} while(false); // &lt;&lt; ""hi there"";
else
    {some more code;}
</code></pre>

<p>This has the disadvantage of not allowing for multiline debug comments though:</p>

<pre><code>if (my condition)
    DEBUG &lt;&lt; ""hi there""
        &lt;&lt; ""some more data on a different line""; // causes error if DEBUG is no-op
else
    {some more code;}
</code></pre>
",2
15831897,15831517,4,"<p>Just invert the logic, and put the active part in the else
branch:</p>

<pre><code>#define DEBUG if( !getDebugmode( DEBUG_LEVEL_DEBUG ) )              \
        ;                                                           \
    else                                                            \
        GET_DEBUG_DST( DEBUG_LEVEL_DEBUG ).nospace()                \
            &lt;&lt; DEBUG_PREFIX &lt;&lt; __PRETTY_FUNCTION__
</code></pre>

<p>Since there is a matching <code>else</code> for the <code>if</code>, it can't pick up
any additional <code>else</code>.</p>
",3
8789454,8789322,4,"<p><strike>Do you mean ANSI, as in ANSI C?</strike> You can go ahead and use Xcode, it has modes for the two common ANSI C dialects, c89 and c99.</p>

<p>If you're doing C++, the C++ compiler in Xcode also supports the common C++ standards, C++98, C++03. It also supports one of the most complete C++11 implementations available. However these standards aren't usually called 'ANSI C++' even though the American National Standards Institute does participate in the ISO standards setting process that creates them. But this is probably what is meant by your instructor.</p>

<p><strike>If your instructor meant something else you'll have to provide more info, because as far as I'm aware ""ANCI"" is just gibberish in the context of C++.</strike></p>

<p>Bottom line, Xcode will be fine.</p>
",0
8770922,8770608,2,"<p>Well, actually the first isn't exact either, if we print the result out with more precision we get</p>

<pre><code>0.62500000000000011102
</code></pre>

<p>and, printing the intermediate results to full precision</p>

<pre><code>Prelude Text.FShow.RealFloat&gt; mapM_ print $ scanl (+) (FD 0) $ zipWith (*) (iterate (*0.1) 0.1) [6,2,5]
0.0
0.600000000000000088817841970012523233890533447265625
0.62000000000000010658141036401502788066864013671875
0.62500000000000011102230246251565404236316680908203125
</code></pre>

<p>To get the most accurate result possible, you have to employ a more complicated algorithm, for example parse the string as a rational number and convert from that.</p>

<p>A quick partial solution is to parse the fractional part to yield <code>numerator / (10^k)</code>,</p>

<pre><code>double denominator = 1.0;
uint64_t numerator = 0;
for(i = f0; i &lt; len; ++i) {  // f0 index of first digit after decimal point
    numerator = 10*numerator + (str[i] - '0');
    denominator *= 10;
}
double fractional_part = numerator / denominator;
</code></pre>

<p>powers of 10 (with nonnegative exponent) can be represented exactly as <code>double</code>s for a while (for exponents &lt;= 22, assuming 64-bit IEEE754 <code>double</code>s) and the numerator can be represented exactly too, if the fractional part is not too long. Then you have only one point where an inexact result occurs due to necessary rounding, the final division, and the result is (supposed to be) the closest representable number to the exact mathematical result. (A further point of inexactness is the addition of the fractional part to the integral part.)</p>

<p>The above will produce good results for input with not too big integral part and short enough fractional parts, but it will be very wrong for long fractional parts.</p>

<p>The correct parsing and displaying of floating point numbers <strong>is</strong> a complicated business.</p>
",2
8771137,8770608,0,"<p>It is not strange at all: double is a <strong>binary</strong> floating-point representation.</p>

<p>That means it will not be able to model some <strong>decimal</strong> numbers properly.</p>

<p>If this doesn't make sense to you, please read <a href=""http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html"" rel=""nofollow"">this</a>.</p>

<p>If you intend to model decimals, you may want to try decimal floating-point representation.</p>

<p>So, if have access to a C++11 compiler, like gcc 4.6.1, you can use std::decimal::decimal64 to accurately represent decimals.  If not, you can use <a href=""http://speleotrove.com/decimal/"" rel=""nofollow"">this lib</a>.</p>
",1
8770626,8770608,0,"<p>You need to set the precision to be able to output float and doubles up to precision of your choice:<br>
Try using <strong><a href=""http://www.cplusplus.com/reference/iostream/manipulators/setprecision/"" rel=""nofollow"">setprecision().</a></strong></p>
",2
17781224,12647130,12,"<p>When the solution is generated, it removes <code>#include &lt;windows.h&gt;</code>.</p>

<p>Simply adding <code>#include &lt;windows.h&gt;</code> will fix it.</p>

<p>In my case, I added it in the *.rc file.</p>
",1
9796563,9796545,1,"<p>This is because you are refering to testArray as though it was defined in the current function what you actually need is </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int* allocate(int&amp;);

int* allocate(int &amp;numOfScores)
{

    int *testArray;

    //prompt user for scores
    cout &lt;&lt; ""How many test scores would\n"";
    cout &lt;&lt; ""you like to process: "" &lt;&lt; endl;
    cin &gt;&gt; numOfScores;

    //dynammically allocate an arrray to hold the scores
    testArray = new int[numOfScores];

    //get the scores from user
    for(int count = 0; count &lt; numOfScores; count++)
    {
        cout &lt;&lt; ""Enter Score: "" &lt;&lt; endl;
        cin &gt;&gt; testArray[count];
    }


    //release the memory that was allocated for *ptr 
    delete [] testArray;
    testArray = 0;

    return testArray;
}

int main()
{   
    int* testArray;
    int numberOfScores;
    testArray=allocate(numberOfScores);
    delete[] testArray;
    return 0;
}
</code></pre>

<p>However I would discourage this style of coding. You should looking into using std::vectors.</p>

<p>for example</p>

<pre><code>size_t nun_scores;  
std::cin &gt;&gt; nun_scores;
std::vector&lt;int&gt; scores(num_scores);
//so on
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow"">http://en.cppreference.com/w/cpp/container/vector</a></p>
",2
9796569,9796545,2,"<p><code>testArray</code> is a local variable inside <code>allocate</code>, and doesn't exist and is not visible inside <code>main</code>. If you want to create a local variable inside <code>main</code> that will be assigned the return value of <code>allocate</code>, you'd do it this way:</p>

<pre><code>int numberOfScores;
int* testArray = allocate(numberOfScores);
</code></pre>

<p>But realise that since you have <code>delete[]</code>ed the array inside <code>allocate</code> and set it to 0, the <code>testArray</code> you create in <code>main</code> will point to <code>NULL</code>. You'd better not set it to 0 inside <code>allocate</code> and <code>delete[]</code> it at the end of <code>main</code> rather than inside <code>allocate</code>, or if you can, use <code>std::vector</code> to avoid having to do manual memory management.</p>

<p>Also, you might want to make sure that <code>cin &gt;&gt; numOfScores</code> did not fail, and that if it succeeded, <code>numOfScores</code> is greater than 0.</p>
",0
9796570,9796545,1,"<p>You are calling the allocate() function with a variable testArray which you never created.  The fact that a variable of the same name may exist in another function (i.e. scope) does not matter--it doesn't exist in main(), nor globally.</p>
",0
9832119,9832107,7,"<p>The <code>operator new</code> function does not return a <code>T*</code> since the returned value does not point to a <code>T</code> but just to arbitrary junk. It's not until the constructor is called that you have a pointer to a class instance.</p>
",1
9832157,9832107,5,"<p>C++ separates memory allocation and object construction. The allocation function (i.e. <code>operator new()</code>) returns a <code>void *</code> to some <em>memory</em>, and the <code>new</code> <em>operator</em> constructs an object in that memory. If you will, the <code>new</code> operator ""converts"" memory into an object, and a placement-<code>new</code> expression is a bit like a ""cast"":</p>

<pre><code>void * addr = ::operator new(sizeof(Foo));    // memory

Foo * p = ::new (addr) Foo(1, true, 'a');     // object (note: no cast!)

p-&gt;~Foo();                                    // it's almost over

::operator delete(addr);                      // now it's over!
</code></pre>

<p>The default, non-placement form of <code>new</code> performs allocation and construction in one go. It's morally equivalent to the first half of this example. But still, allocation and construction remain two distinct concepts.</p>
",3
9832180,9832107,1,"<p>There is a difference between <code>operator new</code> and the new operator. The latter creates objects of a given type, the former just allocates memory. The new operator calls <code>operator new</code> for the type being created, or, if no version is defined for the required type, uses the global <code>operator new</code>. You can't return a <code>T*</code> from the <code>operator new</code> function as that would be pointing to an object that hasn't been created yet. The object is only created once the constructor has run (and any housekeeping such as vtable creation ,RTTI information, etc).</p>

<p>Don't forget that you can override <code>operator new</code> for any class and change it's behviour - it does not need to actually allocate any memory, it just has to return a pointer to some memory. That memory could be from a pre-allocated chunk for example.</p>
",0
9833108,9832107,1,"<p><code>operator new</code> is a user-overridable run-time support function for the <code>new</code> operator, which just provides the service of allocating a suitably aligned and sized block of memory. This function is not the <code>new</code> operator itself; you are not rewriting the <code>new</code> operator itself when you override this function, but only replacing the allocation service. The <code>new</code> operator can be thought of as a syntactic sugar which compiles into a call to its helper, <code>operator new</code>, to get the memory, plus constructor calls to initialize it, if required.</p>
",0
13731196,13731126,4,"<p>Maybe <code>fileout &lt;&lt; 99999999 &lt;&lt; ' ' &lt;&lt; 1;</code> will work.</p>
",0
13731211,13731126,6,"<p>The problem is that <code>operator &lt;&lt;</code> and <code>operator &gt;&gt;</code> are not duals -- <code>operator &lt;&lt;</code> outputs things directly with no padding or delimeters, while <code>operator &gt;&gt;</code> parses whitespace delimited input.  So you need to manually add whitespace delimiters between things in your output to have it read back properly.  You also can't output things that contain whitespace and expect to have them read back properly.</p>
",0
13441898,13441858,9,"<p>The function <code>currency()</code> is a <em>manipulator</em>: The stream classes have special overloaded output operators taking functions with a specific sigunature as argument. They look something like this (with the templatization elided):</p>

<pre><code>class std::ostream
    public std::ios {
public:
     // ...
     std::ostream&amp; operator&lt;&lt; (std::ios_base&amp; (*manip)(std::ios_base&amp;));            
     std::ostream&amp; operator&lt;&lt; (std::ios&amp; (*manip)(std::ios&amp;));         
     std::ostream&amp; operator&lt;&lt; (std::ostream&amp; (*manip)(std::ostream&amp;));
};
</code></pre>

<p>That is, <code>currency</code> is passed as a function pointer which gets called with the stream as its argument.</p>
",0
13441913,13441858,2,"<p>This works (the code in the question):</p>

<pre><code>std::cout &lt;&lt; currency &lt;&lt; 7864.5;
</code></pre>

<p>So does this:</p>

<pre><code>currency(std::cout) &lt;&lt; 7864.5;
</code></pre>

<p>What you evidently tried and complained about, but didn't show, is this:</p>

<pre><code>std::cout &lt;&lt; currency(std::cout) &lt;&lt; 7864.5;
</code></pre>

<p>That's the same as:</p>

<pre><code>ostream&amp; retval = currency(std::cout); // prints ""RS "" as you expect
std::cout &lt;&lt; retval; // oops, this is cout &lt;&lt; cout, which is meaningless
std::cout &lt;&lt; 7864.5; // prints ""7864.5""
</code></pre>
",0
13441880,13441858,0,"<p>Your function is being treated as an ostream manipulator.</p>
",0
8811959,8811887,1,"<p>Static constants of <em>integral</em> types can be <em>initialized</em> inside a class definition. That doesn't mean that the object actually exists, since you haven't provided a definition yet, but because the compiler knows the <em>value</em> of the object, you can sometimes get away with it.</p>

<p>That is, if you're not attempting to take the address of the variable or pass it by reference, but only use its <em>value</em>, then you don't need to provide a defintion at all, and the compiler simply substitutes the value wherever you use the variable.</p>

<p>C++11 introduces the <code>constexpr</code> keyword which allows you to do the same for a much wider variety of types.</p>
",7
16386299,16386256,1,"<p>Maybe a better way to express it is ""If linkage is necessary, it will be external"".  Meaning, if you take the address of the inline function, that address will be externally visible (not a static to a module).</p>
",0
16386303,16386256,0,"<p>Inline functions aren't necessarily expanded inline. When they aren't, the language definition requires that there be only one copy of the function.</p>
",0
16386319,16386256,0,"<p>Inline functions are typically ""linkable"" from other compile units. They won't appear as inline functions. There is a copy of the function in the compiled file. This applies to free inline functions. Class member functions do not, typically get a copy of the function for ""non-inline"" use. Good linkers will also remove the code as ""dead code"" if it's never rerferenced. </p>
",0
16386407,16386256,13,"<p>The linkage of a name has nothing to do with where or how it is defined, just with where the name may be used to refer to a particular object or function.</p>

<p>Declaring a function inline does not force it to be inlined; it just relaxes the One Definition Rule to allow a definition in each translation unit in which it's used (and require one in each translation unit in which it's called), to make it easier to inline. It doesn't prevent a non-inline version being generated, if the compiler decides not to inline a particular call to it, or if you take the address of it.</p>

<p>So ""external linkage"" and ""inline"" are not exclusive; ""external linkage"" means that the function may be referred to in any translation unit, and ""inline"" means that it must be defined in any translation unit that calls it.</p>
",0
11824641,11824568,3,"<pre><code>     changeInt( int newInt );       // Assume newInt = 5
</code></pre>

<p>Remove the <code>int</code> from the above line.</p>

<pre><code>  void doSomething( ); {
</code></pre>

<p>Remove the <code>;</code> from the above line.</p>

<p><strong>Update:</strong> Now you're missing a <code>;</code> from the end of the header file. Fixing all the obvious bugs (that would likely keep it from even compiling), it works fine for me. Either there's still a difference between the code you pasted and the real code, or you've found a compiler bug.</p>

<pre><code>Constructor: myInt = 0
changeInt( int ) : myInt = 5
After constructor and calling changeInt(), myInt = 5
</code></pre>
",4
11825966,11824568,3,"<p>The ""selector"" argument to <code>schedule</code> should be a <code>SEL_SCHEDULE</code>, where</p>

<pre><code>typedef void(CCObject::* SEL_SCHEDULE)(float)
</code></pre>

<p>i.e it should be a member function of a <code>CCObject</code>.<br>
It is also supposed to be a member of the object you call <code>schedule</code> <em>on</em>, otherwise the target when it's called will be wrong.</p>

<p>I suspect that this</p>

<pre><code>this -&gt; m_fruitSprite -&gt; schedule( schedule_selector( Fruit::growFruit ), 1.0 );
</code></pre>

<p>causes a call to <code>Fruit::growFruit</code> with <code>this</code> pointing at the <em>sprite</em>, not the fruit, which leads to all kinds of unpleasantness.<br>
(Note that <code>schedule_selector</code> does a C-style cast, which means that it's inherently unsafe. Don't use it.)</p>
",2
12261689,12261657,15,"<p>Use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/rfind"" rel=""noreferrer""><code>std::string::rfind()</code></a> to locate the last occurrence of <code>::</code> and use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/substr"" rel=""noreferrer""><code>std::string::substr()</code></a> to extract the token:</p>

<pre><code>// Example without confirming that a '::' exists.
std::string last_element(str.substr(str.rfind(""::"") + 2));
</code></pre>
",3
16425572,16425512,2,"<p>Every class's destructor automatically calls the destructor for all subobjects, including base class subobjects.  So you can share <em>behavior</em> of the destructor by putting it in a base or member destructor.  Of course, the derived class still gets its own destructor, but in most cases the compiler-generated one (which does nothing besides the mandatory calls to subobject destructors) is enough.</p>
",0
16425594,16425512,1,"<p>If you don't implement a descructor in the inheriting class, a basic one will be generated that will simply call the base class destructor. So it is not shared, but the result is the same.</p>
",1
16425632,16425512,1,"<p>From your example the easiest thing to do is:</p>

<pre><code>class A
{
  public:
    virtual ~A()
    {
      // Do stuff
    }
}
</code></pre>
",5
16462064,16462006,2,"<p>If you want to keep <code>handle_</code> fully encapsulated, pass a local variable to <code>glGenBuffers</code>:</p>

<pre><code>GLuint handle;
glGenBuffers(1, &amp;handle);
SetHandle(handle);
</code></pre>
",0
16447562,16446293,3,"<blockquote>
  <p>Is a main thread counted also as ""normal"" thread?</p>
</blockquote>

<p>Yes.</p>
",6
11854349,11419915,0,"<p>I ended up deciding to use a plugin archtecture.  Each input gets it's own plugin loaded at runtime.  This is fast, keeps the code pretty well encapsulated, and I can detect new plugins and hotswap in the new code while the program is running.</p>
",0
15585833,15585818,2,"<p>Forget micro-optimizations!!</p>

<p>Use <code>static</code> if you want to limit the scope of the variable to a single translation unit.<br>
<code>static</code> gives you internal linkage.<br>
That should be the criteria to declare it <code>static</code> and not the optimizations. The compiler will do whatever optimizations are needed to be done. </p>
",1
15585853,15585818,3,"<p>If you make the same <code>static</code> from a header included in multiple translation units, each resultant file would get its own copy of the object, potentially increasing the footprint of your application. Moreover, the objects would reside at different addresses, potentially making equality comparisons slower. Link-time optimization can combine identical constants, but that would be optional.</p>

<p>A certain way of avoiding duplicates would be placing your constants in a separate translation unit (i.e. a CPP file), and using <code>extern</code> in your header file.</p>

<p>Header:</p>

<pre><code>extern const TCHAR m_szRoot[];
</code></pre>

<p>constants.cpp:</p>

<pre><code>const TCHAR m_szRoot[] = _T(""root"");
</code></pre>

<p>This would ensure a single definition for each constant.</p>
",5
16408718,16408687,3,"<p>When a function is <a href=""http://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/"" rel=""nofollow"">pure virtual</a> ( <code>= 0</code> ) all subclasses must implement it to be instantiatable. One or more pure virtual functions makes the class <strong>abstract</strong>, meaning it can't be instantiated. If the subclasses don't implement all pure virtual functions from the abstract base class, they also become abstract.</p>

<p>If you don't want a pure virtual function, remove the <code>= 0</code>. </p>
",4
8786212,8786183,19,"<p><code>stringstream</code> is defined in a different header:</p>

<pre><code>#include &lt;sstream&gt;
</code></pre>

<p>Also, if you want the initial contents to stick you'll want something like:</p>

<pre><code>std::stringstream message(""HI this is firet line from initialization"",
                                             ios_base::app | ios_base::out);
</code></pre>

<p>where <code>app</code> means that every output operation writes to the end of the stream. See <a href=""http://www.cplusplus.com/reference/iostream/stringstream/stringstream/"" rel=""noreferrer"">here</a>.</p>
",1
9219457,9219256,4,"<p>Both are valid. The reason to prefer use the first one is to make a reader of your code to understand that the member is static and belongs to the whole class of objects rather than each particular instance. </p>
",0
9219273,9219256,13,"<p>It is legal and correct, but the general consensus is to use the <strong>scope resolution operator</strong>.</p>

<pre><code>class_name::x
</code></pre>

<p>rather than </p>

<pre><code>instance.x
</code></pre>
",1
11154072,11153974,3,"<p>The newline character entered as a result of entering the username is still in standard input, and it is this that is read next thus the loop terminating condition is immeditately false. You need to skip past the newline character, which can be achieved using <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/ignore"" rel=""nofollow""><code>ignore()</code></a>:</p>

<pre><code>cin.ignore();
</code></pre>

<p>Suggest not mixing use of C and C++ IO functions (I am unsure of the exact rules how this interact but I prefer to avoid it):</p>

<pre><code>while (cin.get(c) &amp;&amp; '\n' != c)
{
    uPassword.push_back(c);
}
</code></pre>

<p>or just use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow""><code>std::getline()</code></a>:</p>

<pre><code>getline(cin, uPassword);
</code></pre>

<p>As mentioned in my comment, the map will be keyed by the address of the string literal, not the string content. Suggest using <code>map&lt;std::string, std::string&gt;</code> instead.</p>
",0
13416632,13416488,5,"<p>You can use boost::optional as @chris mentioned in his comment. It comes as a part of Boost libary. See <a href=""http://www.boost.org/doc/libs/1_52_0/libs/optional/doc/html/index.html"" rel=""nofollow"">this page</a> for more details.</p>

<p>Modified <code>MyArray</code> class:</p>

<pre><code>template &lt;typename T, int SIZE&gt;
class MyArray
{
  T arr[SIZE];
public:
  optional&lt;T&amp;&gt; operator[](int i)
  {
    if (i &gt;=0 &amp;&amp; i &lt; SIZE)
      return optional&lt;T&amp;&gt;(arr[i]);
    else
      return optional&lt;T&amp;&gt;();
  }
};
</code></pre>

<p>Usage:</p>

<pre><code>MyArray&lt;int&gt;() array;
// fill array with data

optional&lt;int&amp;&gt; result = array[0];
if (result) {
    // item was found
} else {
    // index out of bounds
}
</code></pre>
",4
13416941,13416488,2,"<p>Whatever you think of, your solution needs to fit into the type system. So your function signature must explicitly say (this way or another) that the result may be T, but it may be something else too.</p>

<p>Common ways for that are:</p>

<ul>
<li><p>Instead of returning a value, return a status code and output the value via an ""out"" parameter (a pointer or reference):</p>

<pre><code>bool tryGet(int i, T&amp; result);
</code></pre></li>
<li><p>Return a tuple (status, value) like:</p>

<pre><code>std::tuple&lt;bool, T&gt; get(int i)
</code></pre>

<p><em>(If couldn't get, consider the second tuple element irrelevant - requires T to have a default constructor)</em></p></li>
<li><p>Use <code>boost::variant</code> (flexible, but requires boost)</p></li>
<li>Use <code>boost::optional</code> (simpler version of the above, when you only need ""either T or nothing"")</li>
</ul>
",0
13417185,13416488,3,"<blockquote>
  <p>I wish there was an undefined value for every variable something like Javascript!</p>
</blockquote>

<p>You only have an ""undefined"" value for pointers (nullptr). A reference is (by definition) something pointing to a <em>valid</em> instance.</p>

<p>To return a reference to a static object, you should separate between const and non-const values of your operator:</p>

<pre><code>template &lt;typename T, int SIZE&gt;
class MyArray
{
  T arr[SIZE];
  static T badref;
public:
  T &amp;operator[](int i)
  {
    if (i &gt;=0 &amp;&amp; i &lt; SIZE)
      return arr[i];
    else
      // returning ref here would allow clients to write:
      // MyArray&lt;int&gt; a;
      // a[-1] = 5; // valid if you return a non-const reference
      throw std::string(""OUT-OF-BOUNDS"");
  }
  const T &amp;operator[](int i) const
  {
    if (i &gt;=0 &amp;&amp; i &lt; SIZE)
      return arr[i];
    else {
      // MyArray&lt;int&gt; a;
      // a[-1] = 5; // will not compile (cannot assign to const)
      static const T invalid = T();
      return invalid;
    }
  }
</code></pre>

<p>};</p>
",0
13419093,13416488,0,"<p>The main goal of references is to avoid invalid (NULL) values while allowing functions to modify their arguments and keep from copying data.  If you need a NULL value, use a pointer.</p>
",0
17826780,17826710,2,"<p>From <code>tuple_element</code> <a href=""http://en.cppreference.com/w/cpp/utility/tuple/tuple_element"" rel=""nofollow noreferrer"">reference</a>:</p>
<blockquote>
<h2>Member types:</h2>
<pre><code>type: the type of Ith element of the tuple, where I is in [0, sizeof...(Types))
</code></pre>
<h2>Possible implementation:</h2>
<pre><code>template&lt; std::size_t I, class T &gt;
struct tuple_element;
 
// recursive case
template&lt; std::size_t I, class Head, class... Tail &gt;
struct tuple_element&lt;I, std::tuple&lt;Head, Tail...&gt;&gt;
    : std::tuple_element&lt;I-1, std::tuple&lt;Tail...&gt;&gt; { };
 
// base case
template&lt; class Head, class... Tail &gt;
struct tuple_element&lt;0, std::tuple&lt;Head, Tail...&gt;&gt; {
   typedef Head type;
};
</code></pre>
</blockquote>
",0
17826784,17826710,7,"<p>The <code>type</code> in <code>typename tuple_element&lt; I, tuple&lt;Types...&gt; &gt;::type</code> is not a variable. It is a type within another type (<code>tuple_element&lt; I, tuple&lt;Types...&gt; &gt;</code>).</p>

<p>Referencing a type within another type can be done by using <code>::</code>, the scope resolution operator, just as you do when referencing a variable or function within a class or a namespace.</p>

<p>Example:</p>

<pre><code>namespace my_namespace {

    struct my_type {
        typedef int some_type;  // some_type here is an alias for int (both are types)
    };   

}

int main() {
    my_namespace::my_type::some_type some_variable;
}
</code></pre>
",0
17826818,17826710,4,"<p>Here, your class member is not a variable, but a type defined in the scope of the class. If you want a simple example :</p>

<pre><code>struct myClass
{
    typedef int myIntType;
};
</code></pre>

<p>you can write:</p>

<pre><code>myClass::myIntType i = 3;
</code></pre>
",0
12303341,12303288,3,"<p>If in files there is definition of classes, so, <code>forward declaration</code> is unnecessary in normal cases.</p>
",0
12303358,12303288,5,"<blockquote>
  <p>What is the purpose of this line?</p>
</blockquote>

<p>Ideally nothing. It's superfluous.</p>

<p>However, as @Luchian Grigore pointed out, there may be such a badly-designed code that due to the incorrect use of include guards and cross-includes, the forward declarations may be necessary.</p>
",7
12303361,12303288,1,"<p>No reason at all. You need to do one or the other, depending on the situation, but not both.</p>
",0
12303454,12303288,0,"<p>If your header files are correct i see no point in declaring because they should already declared in header</p>
",0
12303457,12303288,1,"<p>As it stands, there's no need.</p>

<p>However, this may have evolved historically: At some point, an incomplete type may have been enough:</p>

<pre><code>class Foo;

struct Gizmo
{
    void f(Foo);
};
</code></pre>

<p>Then, at a later point, the author decided she needed the complete type:</p>

<pre><code>#include ""Foo.hpp""

class Foo;

struct Gizmo
{
    void f(Foo);
    Foo x;
};
</code></pre>

<p>The original code may just have been amended with the now-necessary header inclusion...</p>
",4
12303462,12303288,1,"<p>I would guess there's some history to this. Orginally the coder tried not to include the header files and used forward declarations instead. Then as the code expanded they found they needed the header files after all, but didn't bother to deleted the forward declarations.</p>

<p>As others have said there's no purpose to having a forward declaration after the class declaration.</p>
",0
12303472,12303288,6,"<p>Consider this:</p>

<pre><code>//a.h
#ifndef A_H
#define A_H

#include ""b.h""
class A
{
   B* b;
};
#endif

//b.h
#ifndef B_H
#define B_H

#include ""a.h""
class B
{
   A* a;
};
#endif
</code></pre>

<p>Now you try to include one of the files in a different one, say you <code>#include ""a.h""</code>.</p>

<p>The compiler will parse it as:</p>

<pre><code>#ifndef A_H
#define A_H
</code></pre>

<p>fine - <code>A_H</code> isn't defined</p>

<pre><code>#include ""b.h""
</code></pre>

<p>try to paste the contents:</p>

<pre><code>#ifndef B_H
#define B_H
</code></pre>

<p>ok, since <code>B_H</code> isn't defined</p>

<pre><code>#include ""a.h""
</code></pre>

<p>this will not define <code>A</code>, because <code>A_H</code> is defined. So next, we have</p>

<pre><code>class B
{
   A* a;
};
</code></pre>

<p>which will lead to an error, because <code>A</code> wasn't defined or declared before the use.</p>

<p>The forward declaration fixes this.</p>

<p><strong>Of course</strong>, the best solution to this is to not include at all (unless you absolutely have to).</p>
",6
12303538,12303288,1,"<p>I notice that your header does not have guards against multiple inclusion. Also it is possible that some of the included other headers (headers usually have such guards) included that header back. As result it did not compile. So someone added forward declarations to fix the wrong bug.  </p>
",0
12302758,12302674,7,"<ol>
<li><p>The global <code>swap</code> template is specialized for each of the standard library types that supports <code>swap</code>; the specialization calls the member <code>swap</code>.</p></li>
<li><p>There should be no difference between <code>swap(a, b)</code> and <code>swap(b, a)</code>. (I can imagine perverse types where it would matter, but that would never occur in practice).</p></li>
<li><p>No, <code>std::swap</code>  typically doesn't check for equality. In many cases that would be slower than just doing the swap.</p></li>
</ol>
",3
13414387,13414288,5,"<p>From looking at the complete code, I see <code>edge</code> is also defined in the base class. You must also tell the compiler it's a dependent name, like this:</p>

<pre><code>if (k1 &lt; k2) // Below line makes error: expected primary-expression!!!!
  return std::find(this-&gt;edg.begin(), this-&gt;edg.end(), typename _base_graph&lt;K, void*, T&gt;::edge(k1, k2)) != this-&gt;edg.end();
return std::find(this-&gt;edg.begin(), this-&gt;edg.end(), typename _base_graph&lt;K, void*, T&gt;::edge(k2, k1)) != this-&gt;edg.end();
</code></pre>
",4
13414516,13414288,1,"<p>You can resolve through the derived class to the base class like so (at least LLVM can =):</p>

<pre><code>template &lt;typename K, typename T&gt;
bool graph&lt;K, T&gt;::is_edge(const K&amp; k1, const K&amp; k2)
{
    typedef typename graph::edge edge;

    if (this-&gt;nod.find(k1) == this-&gt;nod.end() || this-&gt;nod.find(k2) == this-&gt;nod.end())
        throw std::string(""is_edge: Node does not exist"");

    if (k1 &lt; k2)
        return std::find(this-&gt;edg.begin(), this-&gt;edg.end(), edge(k1, k2)) != this-&gt;edg.end();
    return std::find(this-&gt;edg.begin(), this-&gt;edg.end(), edge(k2, k1)) != this-&gt;edg.end();
}
</code></pre>
",0
11896485,11896452,0,"<p>C:</p>

<pre><code>struct Measurement *meas;
meas=(struct Measurement *) malloc(sizeof(Measurement));
              ^                             ^                         
              |                             |                 
              |                             |                
          this is shape                  this is the space allocated
</code></pre>

<p>C++:</p>

<pre><code>Measurement *meas;
meas=new Measurement;
</code></pre>
",10
11896493,11896452,2,"<p>As I saw in your question, you are using C, so here is solution for C. </p>

<p>Wherever you want to have instance of structure Measurement, simply type:</p>

<pre><code>struct Measurement meas;
</code></pre>

<p>and you will be able to access your structure elements as:</p>

<pre><code>meas.F1.X and so on...
</code></pre>

<p>And if you wish to have dynamic allocation(i.e. at run time) then simply use malloc/calloc as follows</p>

<pre><code>struct Measurement *meas = (struct Measurement *)malloc(sizeof(struct Measurement));
</code></pre>

<p>Doing so, you will have to access your structure elements as:</p>

<pre><code>meas-&gt;F1.X and so on...
</code></pre>
",0
11896676,11896452,1,"<p>Technically it works like you wrote it, but struct word is unnecessary on members (actually generates warning but works.) </p>

<pre><code>struct Force {
    float X[10];
    float Y[10];
    float Z[10];
};

struct Measurement {
    char serial_number[30];
    Force F1;
    Force F2;
};
</code></pre>

<p>Then in function use like this:</p>

<pre><code>Measurement somevar;
somevar.F1.Y = 999;
</code></pre>

<p>Now the proper way to do this (and save stack) is to use pointers.</p>

<pre><code>struct Measurement {
    char serial_number[30];
    Force* F1;
    Force* F2;
};
</code></pre>

<p>And then:</p>

<pre><code>Measurement* m = new Measurement;
if (m) {
    m-&gt;F1 = new Force;
    m-&gt;F2 = new Force;
}
</code></pre>

<p>After using you have to delete all pointers to avoid memory leaks:</p>

<pre><code>delete m-&gt;F1;
delete m-&gt;F2;
delete m;
</code></pre>

<p>There is another approach. Using:</p>

<pre><code>struct Force {
    float X[10];
    float Y[10];
    float Z[10];
};

struct Measurement {
    char serial_number[30];
    Force F1;
    Force F2;
};
</code></pre>

<p>You can allocate with malloc some amount of memory and treat it as struct (did not have time to test it, but I use that approach many times).</p>

<pre><code>Measurement* m = (Measurement*)malloc(sizeof( size in bytes of both structs ));
// zero memory on m pointer

// after use
free(m);
</code></pre>

<p>That's all.</p>
",3
13440896,13440831,1,"<p>Use the <code>.fail()</code> method of the stream. Something like below:-</p>

<pre><code>   cin &gt;&gt; aString;

  std::stringstream ss;
  ss &lt;&lt; aString;
  int n;
  ss &gt;&gt; n;

  if (!ss.fail()) {
   // int;
  } else {
  // not int;
   }
</code></pre>
",0
13440910,13440831,4,"<p>How about something like this:</p>

<pre><code>std::string str;
std::cin &gt;&gt; str;

if (std::find_if(str.begin(), str.end(), std::isdigit) != str.end())
{
    std::cout &lt;&lt; ""No digits allowed in name\n"";
}
</code></pre>

<p>The above code loops through the whole string, calling <a href=""http://en.cppreference.com/w/cpp/string/byte/isdigit"" rel=""nofollow""><code>std::isdigit</code></a> for each character. If the <code>std::isdigit</code> function returns true for any character, meaning it's a digit, then <a href=""http://en.cppreference.com/w/cpp/algorithm/find"" rel=""nofollow""><code>std::find_if</code></a> returns an iterator to that place in the string where it was found. If no digits were found then the <code>end</code> iterator is returned. This way we can see if there was any digits in the string or not.</p>

<p>The C++11 standard also introduced new <a href=""http://en.cppreference.com/w/cpp/algorithm"" rel=""nofollow"">algorithm functions</a> that can be used, but which basically does the above. The one that could be used instead is <a href=""http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"" rel=""nofollow""><code>std::any_of</code></a>:</p>

<pre><code>if (std::any_of(str.begin(), str.end(), std::isdigit))
{
    std::cout &lt;&lt; ""No digits allowed in name\n"";
}
</code></pre>
",3
13440911,13440831,13,"<p><code>cin</code> sets a <a href=""http://www.cplusplus.com/reference/iostream/ios/fail/"" rel=""noreferrer""><code>failbit</code></a> when it gets input of an invalid type.</p>

<pre><code>int x;
cin &gt;&gt; x;

if (!cin) {
    // input was not an integer
}
</code></pre>

<p>You can also use <code>cin.fail()</code> to check if the input was valid:</p>

<pre><code>if (cin.fail()) {
    // input was not valid
}
</code></pre>
",0
12843232,12843196,2,"<p>Maximal munch refers to processing a sequence of punctuation <strong>without any spaces</strong>.</p>

<p>Your code has spaces.  The parser/lexer won't create a single token when there's whitespace in the middle, because the grammar doesn't allow operators to contain whitespace.</p>
",3
12843250,12843196,0,"<p>Because of the space between the two <code>+</code>, each <code>+</code> is treated as a different token by the lexical analyzer.</p>
",0
12843255,12843196,2,"<p>You're missunderstanding what ""maximal munch"" does - it doesn't magically concatenate operators - <code>+ +</code> doesn't become <code>++</code>. The latter one is applied to <code>""world.""</code>, but that's it:</p>

<pre><code>string s = string(""Bob "") + (+""world."");
</code></pre>

<p>Think of</p>

<pre><code>int x = +1;
</code></pre>
",1
12843302,12843196,1,"<p>No, <code>+ +</code> is not the same as <code>+</code>. The final subexpression is <code>+""world.""</code>, which is a unary <code>+</code> on a pointer, which does nothing.</p>
",0
13783248,6994114,0,"<p>The entire idea of an iterator is to enable flexible data storage that is not contiguously stored in memory. Incrementing an iterator could, for example, move to another ""page"" in an array that is stored as separate chunks of elements.</p>

<p>If you call a function that takes a pointer, the called function will simply do pointer arithmetic on the address when you increment it (so it won't follow links in a linked list for example).</p>

<p>Passing an iterator to a function that takes a pointer can't work. Dereferencing the first element then taking its address could work, only if you know for sure that the data in the container is stored contiguously. This would work for a vector, but it can't work if the container is a list.</p>
",0
15567366,15567256,3,"<p><a href=""http://www.cplusplus.com/reference/cstdio/perror/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/perror/</a></p>

<p><code>perror</code> and <code>cerr</code> are different things. <code>cerr</code> - is object of <code>std::ostream</code> class connected with <code>stderr</code>. And <code>perror</code> prints <code>errno</code> and your string in <code>stderr</code>.</p>
",0
15567471,15567256,2,"<p>Your question basically boils down to iostream vs stdio. A similar question has been answered <a href=""https://stackoverflow.com/questions/2872543/printf-vs-cout-in-c"">here</a>.</p>

<p>If you're working in C++ cerr is definitely preferable to perror unless you want to do something very specific. The only real difference is that cerr is virtually the same as</p>

<pre><code>fprintf(stderr, const char*, arg1, ...);
</code></pre>

<p>while perror will also load and display the appropriate error message depending on errno. Also you can't display variables with perror so you can't do</p>

<pre><code>perror(""Something went wrong, i: %d"", i);
</code></pre>

<p>unless you preprocess your error message.</p>
",0
8760854,8760813,11,"<p>Meyers is correct that a copy is made, semantically:</p>
<blockquote>
<p><code>[C++11: 12.2/1]:</code> <strong>Temporaries of class type are created in various contexts</strong>: binding a reference to a prvalue (8.5.3), returning a prvalue (6.6.3), a conversion that creates a prvalue (4.1, 5.2.9, 5.2.11, 5.4), <strong>throwing an exception (15.1),</strong> entering a handler (15.3), and in some initializations (8.5). [..]</p>
<p><code>[C++11: 15.1/4]:</code> The memory for <strong>the temporary copy of the exception</strong> being thrown is allocated in an unspecified way, except as noted in 3.7.3.1. The temporary persists as long as there is a handler being executed for that exception.</p>
</blockquote>
<p>However, copies can be elided by clever compilers and they are allowed to do so regardless of side-effects.</p>
<blockquote>
<p><code>[C++11: 12.8/31]:</code> <strong>When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object</strong>, even if the copy/move constructor and/or destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>
<ul>
<li>[..]</li>
<li><strong>when a temporary class object</strong> that has not been bound to a reference (12.2) <strong>would be copied/moved to a class object</strong> with the same cv-unqualified type, <strong>the copy/move operation can be omitted</strong> by constructing the temporary object directly into the target of the omitted copy/move.</li>
<li>[..]</li>
</ul>
</blockquote>
",6
10188525,10188454,1,"<p>Think about it: you're asking for age in <em>years</em>. So 22.5 years should be considered 22 years and 6 months.</p>
",0
10188532,10188454,1,"<p>22.5 years is 22 years + 0.5 year. 0.5 year = 6 months.</p>

<p>This should work for you:</p>

<pre><code>int years = floor(age);         // get the integer part of age -- that's years
double frac = age - years;      // get the fractional part of age
int months = round(12. * frac); // convert the fractional part into # of months
</code></pre>
",5
8762032,8762013,3,"<p>This is because in order to pass an instance of <code>MyClass other</code> to a constructor with the second signature the constructor would need to call itself, resulting in infinite recustion leading to stack overflow.</p>

<p>Try it out, this is a very instructive exercise!</p>
",0
8762033,8762013,15,"<p>Because <code>MyClass(MyClass other)</code> is passing the parameter by value, which itself requires a copy to be created.  This would lead to an infinite loop (terminated only when your stack overflows).</p>
",0
8762039,8762013,2,"<p><code>MyClass(MyClass other)</code> is passing <code>other</code> by copy, which would invoke the copy constructor, which you are defining, thus you would end up with infinite recursion.</p>
",0
8762044,8762013,1,"<p><code>MyClass(MyClass other)</code> is already creating a copy of <code>other</code> because you are passing the parameter <code>other</code> as <strong>variable</strong> not as <strong>reference</strong>, so the copy constructor in this case would be meaningless</p>
",0
8762065,8762013,1,"<p>Valid copy constructor signatures are</p>

<p><code>MyClass(MyClass &amp;other)</code> 
<code>MyClass(const MyClass &amp;other)</code> 
<code>MyClass(MyClass const &amp;other)</code> </p>

<p>In C++ all function parameters are passed by value. This means that if you'll pass <code>other</code> by value it will be destroyed after the function call operator finishes.
Moreover, in case of copy constructor infinite loop of copy constructor execution will be met.
So copy constructor parameter is always passed by reference.</p>
",4
11581937,11581174,3,"<p>Declaring a conversion to a reference to self is not ill-formed. Your problem comes at the time where your reference is initialized. As the type of the reference and the type of the initialization expression are the same, the reference is <code>bound directly</code> and your user defined conversion operator is never considered. Thus normal conversion rules apply and const conversion makes the code ill-formed.</p>

<p>Anyway, what your are doing is basically asking yourself to get shot in the foot. If you don't like <code>constness</code>, <strong>don't use it</strong>. If you do it consistently, it will never bother you, but it is not going to make you new friends.</p>
",0
11581231,11581174,3,"<p>The proper way to do this would be to use <a href=""http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/keyword_const_cast.htm"" rel=""nofollow"">const_cast</a>.</p>

<p>For example,</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void f(int* p) {
  cout &lt;&lt; *p &lt;&lt; endl;
}

int main(void) {
  const int a = 10;
  const int* b = &amp;a;

  // Function f() expects int*, not const int*
  //   f(b);
  int* c = const_cast&lt;int*&gt;(b);
  f(c);

  // Lvalue is const
  //  *b = 20;

  // Undefined behavior
  //  *c = 30;

  int a1 = 40;
  const int* b1 = &amp;a1;
  int* c1 = const_cast&lt;int*&gt;(b1);

  // Integer a1, the object referred to by c1, has
  // not been declared const
  *c1 = 50;

  return 0;
}
</code></pre>
",6
11582064,11581174,4,"<p>You can't do this because it's explicitly forbidden. N3290 ¡ì 12.3.2 states:</p>

<blockquote>
  <p>Such functions are called
  conversion functions. No return type can be specified. If a conversion function is a member function, the
  type of the conversion function (8.3.5) is ¡°function taking no parameter returning conversion-type-id¡±. <strong>A
  conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified)
  same object type (or a reference to it)</strong>, to a (possibly cv-qualified) base class of that type (or a reference to
  it), or to (possibly cv-qualified) void.</p>
</blockquote>

<p>(Emphasis mine)</p>

<p>This is discussed further in a note:</p>

<blockquote>
  <p>These conversions are considered as standard conversions for the purposes of overload resolution (13.3.3.1, 13.3.3.1.4) and
  therefore initialization (8.5) and explicit casts (5.2.9).</p>
</blockquote>

<p>Which explains this decision - it would interfere with the built-in mechanics too much. (For little gain).</p>

<p>If you really want something non-<code>const</code> from a <code>const</code> object the only smart way to do this is constructing a new instance using the copy constructor.</p>

<p>As a work around you could introduce a lightweight intermediary (like a smart pointer):</p>

<pre><code>struct B {};

struct A {};

namespace {
  B b_inst;
  A a_inst;
}

struct A_wrapper {
  A&amp; inst;
  // This is perfectly fine: const alters the reference, not what it refers to
  operator A&amp;() const { return inst; }
  operator B&amp;() const { return b_inst; }
  A_wrapper() : inst(a_inst) {}
};

int main() {
  const A_wrapper a;
  B&amp; br = a;
  A&amp; ar = a;
}
</code></pre>

<p>But really, wanting to do this in the first place looks like a code smell.</p>
",2
9207400,9207096,3,"<p>It's remarkably easy to fill the stack up due to infinite recursion; </p>

<pre><code>void func() { func(); }
</code></pre>

<p>will do it well enough. Any function call pushes information onto the stack (at least a return address), and so if it doesn't stop calling itself at some point, it'll run out of available stack.</p>

<p>I find it hard to see why you would dislike such a function as you have shown as an example of doing it. It does what is needed and it does it fast.</p>

<p>However, it is possible that optimisation will cause the compiler to turn the function into an infinite loop, as it is easy to spot it doesn't do anything.</p>

<p>If you want a demonstration of a function that actually does something,</p>

<pre><code>int factorial(int n) { return n&lt;= 0 ? 1 : factorial(n - 1) * n; }
</code></pre>

<p>is a good example, given a suitably large value of n, and no compiler optimisation (or it might spot the opportunity for tail recursion and turn that into a loop as well).</p>

<p>Failing that, try this (Ackermann's function, an example of a recursive function that is not primitively recursive and is also not going to be subject to optimisation in the last line.</p>

<pre><code>unsigned int A(unsigned int m, unsigned int n)
{
    if (m == 0) return n + 1;
    if (n == 0) return A(m - 1, 1);
    return A(m - 1, A(m, n - 1));
} 
</code></pre>

<p>Exercise for the reader: Given an intelligent compiler, how much optimisation can be applied to minimise the recursion.</p>
",0
9207122,9207096,0,"<p>In <code>main()</code> you call <code>func()</code> which then calls <code>func()</code> (itself) which then calls <code>func()</code> (itself) etc.</p>

<p>Every time a function is called, pointers are pushed onto the stack. The stack is a limited amount of memory and will eventually fill and then you get a <code>stack overflow</code>.</p>

<p>Since your program will call <code>func()</code> endlessly the stack will quickly fill.</p>

<p>Note also that the local variable <code>arr</code> will also be allocated on the stack. This will more quickly fill up the stack.</p>
",2
9207126,9207096,0,"<p>When recursion is too deep ot can cause stack overflow since function local variables and return addresses are stored on the stack. In your case you have infinite recursion, that is, you don't have a condition to stop func() from calling itself, and thus you're overflowing the stack.</p>

<p>There's no defined limit, and it depends on language and architecture you run recursion over.</p>
",5
9808026,9807865,0,"<p>You can use wrapping mechanism, see <a href=""http://sourceware.org/binutils/docs/ld/Options.html"" rel=""nofollow"">http://sourceware.org/binutils/docs/ld/Options.html</a> (find <code>--wrap=symbol</code>) for example. This way gives you acess both to your and original function.</p>
",0
9808569,9807865,0,"<pre><code>find . -name '*.cpp' -print0 | xargs -0 -l sed -i -e 's/\&lt;memcpy\&gt;/customMemcpy/' 
</code></pre>
",0
9809869,9807865,0,"<pre><code>#define memcpy(dst,src,size) custom_memcpy(dst, src, size)

void custom_memcpy(void* dst, const void* src, size_t size)
{
  //TODO: Implement Custom Memcpy
}
</code></pre>
",0
11848828,11848801,12,"<p>constructors and destructors don't have return types! Should be:</p>

<pre><code>Vehicle();
Vehicle(string, string, int);
~Vehicle();
</code></pre>

<p>You need to pass an argument to your function:</p>

<pre><code>void guest(const Vehicle &amp;v)
{
    cout &lt;&lt; v.make; //friend allows you to access 'make' directly
}
</code></pre>

<p>Of course you must change the <code>friend</code> declaration accordingly</p>

<p>And don't forget <code>;</code> at the end of your class</p>

<p><strong>EDIT</strong></p>

<p>Full code that works:</p>

<pre><code>class Vehicle {
    friend void guest(const Vehicle &amp;v);
private:
    string make;
    string model;
    int year;
public:
    Vehicle() {}
    Vehicle(string make, string model, int year) : make(make), model(model), year(year) {}
    ~Vehicle() {}
    string getMake() const {return make;}
};

void guest(const Vehicle &amp;v) {
    cout &lt;&lt; v.make;
}



int main()
{
    guest(Vehicle(""foo"", ""bar"", 10));
    return 0;
}
</code></pre>
",3
11848860,11848801,1,"<p>Constructors and Destructors don't have return types. Just remove those and your code should compile. Having the return type </p>

<pre><code> void Vehicle(); 
</code></pre>

<p>tells the compiler you want to declare a function with name Vehicle() but as this is the same name as the class it is not allowed unless it is a constructor (which has no return type). The error messages were telling you exactly what your problem was in this case.</p>
",2
11848874,11848801,3,"<p>The error messages are actually pretty good in this case if you understand them.</p>

<pre><code>void Vehicle();
</code></pre>

<p>because the ""method"" has the same name as the class, your Intellisense thinks it should be a construtor. It's right! Constructors don't have return types, so make it:</p>

<pre><code>Vehicle();
</code></pre>

<p>Similarly:</p>

<pre><code>void Vehicle(string, string, int);
</code></pre>

<p>also appears to be a constructor because the name of the ""method"" is the same as the class. Just because it has parameters doesn't make it special. It should be:</p>

<pre><code>Vehicle(string, string, int);
</code></pre>

<p>Deconstructors don't have return types either, so</p>

<pre><code>void ~Vehicle();
</code></pre>

<p>should be:</p>

<pre><code>~Vehicle();
</code></pre>
",0
9800102,9800046,0,"<p>atoi or similar conversion would be expensive to use.</p>

<pre><code>const unsigned char _TRUE = '1';
const unsigned char* dbDATA = sqlite3_column_text(chkStmt, 1);
bool exists = (_TRUE == dbDATA[0]); //i assume you are expecting ""0"" or ""1"" from DB
</code></pre>
",2
9800130,9800046,0,"<p>First of all, the columns are indexed beginning with zero, so unless the query requested two (or more) columns, <code>sqlite3_column_text(..., 1)</code> returns the second column.</p>

<p>Secondly, the function returns a pointer to a character string, so you have to dereference the value from the pointer, and convert the string there:</p>

<pre><code>const char *data = sqlite3_column_text(chkStmt, 0);
int val = atoi (data);   // for ascii representation of a number
</code></pre>
",1
9800169,9800046,2,"<p>The first line, trying to convert to <code>bool</code> will always return <code>true</code>, as a string pointer will always be ""true"" if it's not NULL. If you want to use this there are a couple of ways to handle this:</p>

<pre><code>// 1. Dereference pointer to get first character in string
tblexist = (*sqlite3_column_text(chkStmt, 1) != '0');

// 2. Using string comparison
tblexist = (strcmp(sqlite3_column_text(chkStmt, 1), ""0"") != 0);
</code></pre>

<p>For the second, try this instead:</p>

<pre><code>t_exists = atoi((const char *) sqlite3_column_text(chkStmt, 1));
</code></pre>

<p>This is because <code>sqlite3_column_text</code> returns the type <code>const unsigned char *</code> but <code>atoi</code> wants <code>const char *</code>.</p>
",1
11890054,11889999,0,"<p>This sounds like a Project Euler problem, so I won't give an explicit solution. Here's two hints though:</p>

<ul>
<li>You do not have to actually calculate the factorial to find out how many zeroes it has at the end.</li>
<li>If a number is divisible by 2^N and by 5^N, the number has at least N zeroes at the end.</li>
</ul>
",0
9198182,9198000,7,"<p>The obvious answer is to multiply <code>partial</code> by some scaling factor;
<code>100</code> is a frequent choice, since the division then gives the percent as
an integral value (rounded down).  The problem is that if the values are
so large that they can't be represented precisely in a <code>double</code>, there's
also a good chance that the multiplication by the scaling factor will
overflow.  (For that matter, if they're that big, the initial values
will overflow an <code>int</code> on most machines.) </p>
",0
9198392,9198000,0,"<p>If you want a precise representation of the fraction, you'd have some sort of structure containing the numerator and the denominator as integers, and, for unique representation, you'd just factor out the greatest common divisor (with a special case for zero).  If you are just worried that after repeated operations the floating point representation might not be accurate enough, you need to just find some courses on numerical analysisas that issue isn't strictly a programming issue.  There are better ways than others to calculate certain results, but I can't really go into them (I've never done the coursework, just read about it).</p>
",0
9204067,9198000,1,"<p>Yes, there is an algorithm losing less information. Assuming you want to find the <code>double</code> value closest to the mathematical value of the fraction, you need an integer type capable of holding <code>total &lt;&lt; 53</code>. You can create your own or use a library like GMP for that. Then</p>

<ul>
<li>scale <code>partial</code> so that <code>(total &lt;&lt; 52) &lt;= numerator &lt; (total &lt;&lt; 53)</code>, where <code>numerator = (partial &lt;&lt; m)</code></li>
<li>let <code>q</code> be the integer quotient <code>numerator / total</code> and <code>r = numerator % total</code></li>
<li>let <code>mantissa = q</code> if <code>2*r &lt; total</code>, <code>= q+1</code> if <code>2*r &gt; total</code> and if <code>2*r == total</code>, <code>mantissa = q+1</code> if you want to round half up, <code>= q</code> if you want to round half down, the even of the two if you want round-half-to-even</li>
<li><code>result = scalbn(mantissa, -m)</code></li>
</ul>

<p>Most of the time you get the same value as for <code>(double)partial / (double)total</code>, differences of one least significant bit are probably not too rare, two or three LSB difference wouldn't surprise me either, but are rare, a bigger difference is unlikely (that said, somebody will probably give an example soon).</p>

<p>Now, is it worth the effort? Usually not.</p>
",0
9198694,9198666,-4,"<p>A typo, essentially--you need</p>

<pre><code>vector&lt;double&gt; x[10000];
...
</code></pre>

<p>Wrong brackets!</p>

<p>In addition, strictly speaking you are really defining an array of vectors, not double vectors, which would be <code>vector&lt; vector&lt;double&gt; &gt;</code>.  Either is fine depending on your purpose.</p>

<p>EDIT: This solution compiles and has no runtime errors with g++.</p>

<p>dist.h:</p>

<pre><code>#include &lt;vector&gt;
using namespace std;

struct my_distance{
    vector&lt;double&gt; x[10000];
    vector&lt;double&gt; y[10000];
    vector&lt;double&gt; z[10000];
};
</code></pre>

<p>dist.cpp:</p>

<pre><code>#include ""dist.h""

my_distance distance_old, distance_new;

int main()
{
    return 0;
}
</code></pre>

<p>NB 'distance' is already used by the STL for something else, so it has to be renamed.</p>
",14
9198750,9198666,6,"<p>You are trying to <em>construct</em> the vectors in the structure, which can't be done. You have to do it in a constructor just like a normal class:</p>

<pre><code>struct distance
{

    vector&lt;double&gt; x;
    vector&lt;double&gt; y;
    vector&lt;double&gt; z;

    distance()
        : x(10000), y(10000), z(10000)
        { }
};
</code></pre>
",1
9198802,9198666,1,"<p>You can't call the vector contructor in the struct declaration.  Get rid of the (10000) in your struct declaration.  If you want to use the non-default vector constructor to set the vector initial capacity, you need to do that in a constructor of your struct.</p>
",0
15809029,15808920,12,"<p><code>&lt;:</code> means <code>[</code>, <code>:&gt;</code> means <code>]</code> (they're digraphs).</p>

<p><code>??!</code> means <code>|</code> (it's a trigraph), so <code>??!??!</code> is logical <code>||</code></p>

<p>The last <code>?</code> on the first line is a conditional operator.</p>

<p>The remainder selects one character from one of the two emoticon strings. It will select from the first one, since regardless of how many <code>!</code> and <code>~</code> there are in the mess at the start, <code>anything || 1</code> is true.</p>

<p>So it actually selects <code>""^_^""[3]</code>, which is the nul terminator at the end of the string, which is 0.</p>

<p>Basically the code reads <code>return ((some mess) || 1) ? ""^_^""[3] : ""^.-""[1];</code>, since <code>0.0 &lt; 3</code> is true.</p>

<p>[Edit: I just realised (and commented below), it is possible to write a conforming implementation on which <code>~(expression equal to 0)</code> has undefined behavior. So to know whether or not this code is strictly conforming, you have to check that neither of the <code>~</code> is applied to a zero. In fact <code>!!!1</code> is <code>0</code>, so the code doesn't strictly conform. It'll work on any implementation you can name, though, since approximately everything uses 2's complement.]</p>
",3
15809172,15808920,4,"<p>First, replace the trigraphs and alternative tokens with their canonical forms: <code>??!</code> becomes <code>|</code>, <code>&lt;:</code> becomes <code>[</code> and <code>:&gt;</code> becomes <code>]</code>:</p>

<pre><code>!!!~!!!!!~!!!1 || 1 ? ""^_^""[3] : ""^.-""[0.0&lt;3]
</code></pre>

<p>The first part <code>&lt;something&gt; || 1</code> evaluates to true. You can work out what <code>!!!~!!!!!~!!!1</code> evaluates to if you like, but it doesn't matter (as long as the behaviour is defined, as noted in the comments). So the result of the conditional operator is the first branch, </p>

<pre><code>""_^_""[3]
</code></pre>

<p>The string literal has four characters, the final one being the zero terminator; so the value of the entire expression is zero.</p>
",2
15809174,15808920,0,"<p>By removing the trigraphs and digraphs (along with whitespace, and adding a parenthesis on the terniary operator), we get:</p>

<p>int main() {
    return !!!~!!!!!~!!!1||1?(""^_^"" [3]):""^.-""[0.0 &lt;3];
}</p>

<p>Now all we need to do is remove the unnecessary extra stuff...</p>
",0
10775184,10775146,3,"<p>The first element should be <code>vector[0]</code>.</p>

<p>For example:</p>

<pre><code>int anumber = 300;
std::vector&lt;int&gt; intvector;
intvector.push_back(anumber);

std::cout &lt;&lt; intvector[0];
</code></pre>

<p>Will print <code>300</code>. </p>
",0
10823743,10823682,2,"<p>Let's minimize the problem:</p>

<pre><code>while(n&lt;argc-1)
{
   Tnode node;
   //...
}
</code></pre>

<p>When <code>node</code> goes out of scope, so does its <code>std::string</code> member. You'll have dangling pointers to nodes in your tree. Inside the loop it works because the object is still alive. Outside... not so much.</p>

<p>Use dynamic allocation:</p>

<pre><code>while(n&lt;argc-1){
  Tnode* node = new Tnode;
  node-&gt;word = argv[n+1];
  node-&gt;left = insertP;
  node-&gt;right = NULL_cp;
  insertP-&gt;right = node;
  insertP = node;
  cout &lt;&lt; ""inside loop: "" &lt;&lt; insertP-&gt;word &lt;&lt;  endl;
  n++;
}
</code></pre>

<p>And don't forget to <code>delete</code> at the end.</p>
",0
19506840,7718207,2,"<p>In chapter 6.14 of his book, Daniel Shiffman proposes some algorithms to increase boid performance. It suggests that they shouldnt loop for all other existent boids, but only those close to it, pretty much like using a Quadtree.</p>

<p><a href=""http://natureofcode.com/book/chapter-6-autonomous-agents/"" rel=""nofollow"">http://natureofcode.com/book/chapter-6-autonomous-agents/</a></p>
",0
8758426,8758343,2,"<p>You <strong>can</strong> substract iterators:</p>

<pre><code>int distance = iter - agents.begin();
</code></pre>

<p>EDIT:</p>

<p>Only works for random access iterators. (+1 internet to Let_Me_Be)</p>
",4
8758746,8758343,1,"<p>Most generally, you can always hack up something yourself:</p>

<pre><code>{
    int i = 0;
    for (auto it = agents.begin(), end = agents.end(); it != end; ++it, ++i)
    {
         (*it)-&gt;set_int(i);
    }
}
</code></pre>

<p>If you have random access iterators, you can indeed use <code>std::distance(agents.begin(), it)</code> safely, as has been said already.</p>
",1
8758381,8758343,6,"<p>You want <code>distance</code> <a href=""http://www.cplusplus.com/reference/std/iterator/distance/"" rel=""noreferrer"">http://www.cplusplus.com/reference/std/iterator/distance/</a></p>

<pre><code>(*iter)-&gt;Index(distance(agents.begin(),iter));
</code></pre>
",1
9142358,9141656,1,"<p>You cannot use a tree inside <code>unordered_map</code>, even just within a bucket. <code>unordered_map</code>'s interface simply does not allow it. The key type is required only to be equality comparable, nothing more. That's why it's called an ""unordered"" map; because there is no specific ordering of elements. To use some kind of binary tree would require a strict weak ordering, which is not required.</p>

<p>If you want to use a variation of an <code>unordered_map</code>, you may. But it would not be an <code>unordered_map</code> as defined by the standard.</p>
",1
8796423,8796269,2,"<p>You cant do <code>std::vector&lt;int[]&gt; vector</code>. You have to specify the size of the array for it to compile like this <code>std::vector&lt;int[5]&gt; vector</code>.</p>

<p>However, this is a bad idea because you can`t assign arrays to other arrays, etc. and you will get all kinds of errors when you try to use vector.</p>

<p>Instead, use <code>vector&lt;vector&lt;int&gt;&gt; vector</code> or in C++11 use <code>vector&lt;std::array&lt;int, 5&gt;&gt; vector</code>.</p>

<p>Also, I don't know what implementation of <code>hash_map</code> you are using so I dont know if the above solutions will work in your case. (Also, C++11 has unordered_map, so that might be preferable)</p>
",3
13401643,13401606,4,"<p>This doesn't mean what you think it means:</p>

<pre><code>AddressPacketList IPsource();
</code></pre>

<p>You think it declares an object named <code>IPsource</code> of type <code>AddressPacketList</code> and initializes it using <code>AddressPacketList</code>'s default constructor.</p>

<p>What it <em>actually</em> is is a function declaration.  You are declaring a function named <code>IPsource</code> which takes no parameters and returns a <code>AddressPacketList</code> object by-value.</p>

<p>This seemingly bizarre conclusion is the result of the so-called <a href=""http://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""nofollow"">most vexing parse</a>.</p>

<p>Simply change the line to:</p>

<pre><code>AddressPacketList IPsource;
</code></pre>
",4
13401644,13401606,0,"<p>Try this:</p>

<pre><code>AddressPacketList IPsource;
</code></pre>

<p>Only if you declare a variable and want to initialize it with a non-default constructor, you are allowed to use brackets. If you had a constructor like this:</p>

<pre><code>AddressPacketList(std::string packet) { 
    masterList[0].initialize(packet);
    listCounter = 1; 
}
</code></pre>

<p>Then you could declare your local variable like this:</p>

<pre><code>AddressPacketList IPsource(""ABC"");
</code></pre>
",0
13401645,13401606,1,"<p>Well, you are declaring a function called <code>IPSource</code>, which returns a <code>AddressPacketList</code>:</p>

<pre><code>AddressPacketList IPsource(); // parsed as function declaration
</code></pre>

<p>Then you try to use it as an object. You can fix it by changing the declaration to</p>

<pre><code>AddressPacketList IPsource;
</code></pre>
",0
13465749,13465695,0,"<p>There are 4 things you want to check:</p>

<ul>
<li>Is there 8 characters ? If not, then don't even bother checking anything else. It's not in the proper format. </li>
<li>Are the third and fifth characters '/'. If not, then you still don't have the proper format.</li>
<li>Check each pair for its valid values. A month has days between 1 and
31 at most, there are no more than 12 months and months range from 01
to 12. A year can be any combination of any 2 digits.</li>
</ul>

<p>This should take care of the format, but if you want to make sure that the date is valid:</p>

<ul>
<li>Check for valid number of days in each month (january 31, february
28-29...) and indeed check for those leap years.</li>
</ul>
",1
13466679,13465695,0,"<p>This looks a lot like a project I am about to grade.... You should verify that it is Gregorian Calendar compliant if it is the project I am about to grade.  1/1/2012 is definitely valid though so what you may want to do and what I would hope you consider is creating a switch statement that examines for formats like 1/12/2012 and 10/2/2012 because these are valid. Then parse out the month day and year from these. Then verify that they are within the limit of the Gregorian calendar. If it is for a class which I would guess that it is, you should consider writing the verification as a separate function from the parsing function.</p>

<p>So first ask whether the date is too long if not, is it too short, if not which version is it, then pass the d m y to the verification function. This kind of modularity will simplify your code and reduce instructions.</p>

<p>something like</p>

<p>bool dateValidation(string shipDate)
{
     string temp;</p>

<pre><code>switch(shipDate.length())
{
     case(10):
        // do what  your doing
        verify(m,d,y);
        break;

     case(8):
        //dealing with single digits
        // verify 1 and 3 are '/' and the rest are numbers
        verifiy(m,d,y);
        break;

     case(9):
        //a little more heavy lifting here 
        // but its good thinking for a new programmer
        verifiy(m,d,y);
        break;
     default:       

      //fail message
        break;
}
</code></pre>
",0
11568371,11568146,0,"<p>Well, I know of a way of doing this in standard C.</p>

<pre><code>FILE *fp;

int check = 0;

fp = fopen(""output.txt"", ""w"");
fprintf(fp, ""%s"", ""char tempArr[100] = {"");
for (i = 0; arr[i]; i++)
{
    if (i)
        fputc(',', fp);
    check += 4;
    fputc('\'', fp);
    switch(arr[i])
    {
        case '\n':
            check++;
            fputc('\\', fp);
            fputc('n', fp);
            break;
        // ...
        default:
            fputc(arr[i], fp);
    }
}
fprintf(fp, ""%s"", ""};\n"");
if (check &gt;= 100)
    fprintf(stderr, ""WARNING: tempArr contains MORE than 100 characters!\n"");
</code></pre>
",0
11568176,11568146,0,"<p>Instead of having <code>'\n'</code> as one of your characters, you can have both <code>'\\'</code> and <code>'n'</code>.</p>

<p>To be clear, I mean for you to put both <code>'\\'</code> and <code>'n'</code> in your array.  That way, both <code>'\'</code> and <code>'n'</code> are printed.</p>
",0
11568245,11568146,0,"<p>Yes, here is a C solution:</p>

<pre><code>void printAndEscapeString(const char *input, FILE *output)
{
    const char escapeCodes[] = {
        '\n',
        '\t',
        '\v',
        '\'',
        '\""',
        '\?',
        '\a',
        '\b',
        '\f',
        '\r',
    };

    const char escapeReplacements[] = {
        'n',
        't',
        'v',
        '\'',
        '\""',
        '?',
        'a',
        'b',
        'f',
        'r',
    };

    while (*input) {
        for (int i = 0; i &lt; sizeof(escapeCodes); i++) {
            if (*input == escapeCodes[i])
            {
                putc('\\', output);
                putc(escapeReplacements[i], output);

                goto NEXT; // use goto because I'm too lazy to figure out a better way
            }
        }

        fputc(*input, output);

    NEXT:
        input++;
    }
}
</code></pre>
",0
10134381,10134314,2,"<p>The difference lies in which C++ mechanism is used to initialize <code>i</code> in your class.  Case (A) initializes it via constructor, and case (B) uses the assignment operator (or a copy constructor if no assignment operator is defined).</p>

<p>Most C++ compilers would generate exactly the same code for this particular example, because you're using int, which is a ""plain old data"" type.  If <code>i</code> were a class type, it could make a great deal of difference.</p>
",2
16417074,16417030,2,"<p>Your <code>class B</code> needs to inherit from <code>class A</code>. </p>

<pre><code>class B: public A ... 
</code></pre>

<p>Of course, calling <code>A::test2()</code> won't work, since that class is not implemented - it has no body. You could solve that by ALSO implementing it in class A, like this:</p>

<pre><code>std::string A::test2() { return ""some string""; }
</code></pre>
",4
16417230,16417030,2,"<p>Don't use explicit scope qualification if you want a virtual call. Using <code>A::test2</code>  will attempt to call <code>A::test2</code>, without dynamic dispatch. And this, in turn, will fail to link because <code>A::test2</code> has no implementation.</p>
",4
16418469,16417030,3,"<p>Don't get hung up on pure virtual versus virtual. Both of the functions declared in <code>A</code> are virtual, and you can just treat them as such. So <code>B</code>'s implementation of <code>test1</code> should simply call <code>test2</code>. No <code>A::</code> qualifier. That makes a virtual call, and will end up in the most-derived version of <code>test2</code>, i.e., the one defined in <code>C</code> or <code>C1</code>, depending on the type of the object. After I removed the <code>A::</code> from <code>A::test2()</code>, the following code works (as it should):</p>

<pre><code>int main() {
    C c;
    c.test1();
    C1 c1;
    c1.test1();
    return 0;
}

[work]$ g++ test.cpp
[work]$ ./a.out
hello WorldSup World[work]$ 
</code></pre>

<p>Yes, you should add a <code>\n</code> to the output. <code>&lt;g&gt;</code></p>
",0
16419037,16417030,2,"<p>The error message implies that, when you compiled it, <code>B</code> did not inherit from <code>A</code>, so there was no object of type <code>A</code> to call the member function on. The code you've posted gives me a different error: that <code>A::test2</code> is not defined.</p>

<p>Almost certainly, you want to call the function virtually (i.e. call the final override in <code>C</code> or <code>C1</code> or whatever). In that case don't qualify it at all:</p>

<pre><code>std::cout &lt;&lt; test2() &lt;&lt; std::endl;
</code></pre>

<p>Your code tries to specifically call the version declared in <code>A</code>, rather than any override. If that's actually what you want (which I doubt), then that function would need to be defined:</p>

<pre><code>std::string A::test2() {
    return ""I'm a pure virtual function. Why are you calling me?"";
}
</code></pre>

<p>Note that, due to a quirk in the language, pure virtual functions can't be defined inside the class definition; this definition will have to go outside the class.</p>
",0
20021537,9443102,0,"<pre><code>#include&lt;iostream&gt;
using namespace std;
class Base{
    private:
        int a;
    protected:
        Base(){}
        Base(int a) : a(a) {}
        virtual ~Base(){}
        void test2(){}
};

class Derived:private Base{
    private:
        int b;
        Derived(int b) : Base(b) {};
    public:
        Derived() : Base() {}; // uses protected constructor
        ~Derived(){};
        Base* test(){
            new Derived(-1); // uses the other protected constructor
        };

};
</code></pre>
",1
15857162,15857099,3,"<p>""Better"" may not a good way to describe it, but it usually is ""Faster"" to allocate memory on the stack, as opposed to on the heap.  You are correct that it is the allocation of the memory which is slower, not the use of that memory afterwards.</p>

<p>The reason that heap allocation tends to be slower is that heap managers need to do additional work: they often try to find a block of existing memory that closely approximates the size you are requesting, and when freeing blocks, they typically check adjoining memory areas to see if they can be merged.  Stack allocation is simply adding a value to a pointer, nothing more.</p>
",1
15857195,15857099,4,"<p>Caching issues aside, the CPU stack is just that, a stack, a LIFO list/queue. You remove things from it in the exactly opposite order from the one you put them there. You do not create holes in it by removing something in the middle of it. This makes its management extremely trivial:</p>

<pre><code>memory[--stackpointer] = value; // push
value = memory[stackpointer++]; // pop
</code></pre>

<p>Or you could allocate a large chunk:</p>

<pre><code>stackpointer -= size; // allocate
memset(&amp;memory[stackpointer], 0, size); // use
</code></pre>

<p>and free it likewise:</p>

<pre><code>stackpointer += size; // free
</code></pre>

<p>Your heap, OTOH, does not have the LIFO property. And for that reason it must keep track of all allocated blocks individually. Which means, it has to have some kind of list of free blocks and a list of allocated blocks and it needs to look for big enough blocks when allocating and look for the specified block when freeing and then likely do some block splitting and coalescing in the process. The simple stack does not need to do any of this.</p>

<p>This alone is a significant algorithmic difference between two ways of allocation and deallocation.</p>

<p>Caching and explicit calls to map physical memory into the virtual address space add up as well, but if you consider them to be equal in both cases, you still have a few instructions vs a few dozen to a few hundred instructions of difference.</p>
",2
10126947,10126897,3,"<p>You haven't declared the <code>operator*</code> in your header file, so it isn't visible in <code>main.cpp</code>.</p>
",0
10126937,10126897,5,"<p>You forgot to tell your users about the existence of your operator:</p>

<p><em>rational.h</em></p>

<pre><code>...
const rational operator*(const rational &amp;lhs, 
                         const rational &amp;rhs);
...
</code></pre>

<p>Generally, in C as well as in C++, we talk about ""definitions"" and ""declaration"". Declarations are annotations to make something visible to someone else, but in itself they do nothing. Definitions are the entititiess that actually do something:</p>

<pre><code>int foo();              // &lt;- we call it ""declaration""
int foo() { return 0; } // &lt;- we call it foo's ""definition""
</code></pre>

<p>In your code, there is no declaration of <code>operator*</code> visible in main.cpp, so you need to provide one somewhere (ideally in your rational's header).</p>

<p>As a style advice: In almost all cases, if a constructor takes builtin types, you want to make it explicit:</p>

<pre><code>explicit rational (int, int);
</code></pre>

<p>This prevents sometimes subtle bugs because (in your case) <code>rational</code>s might be unintentionally created (see <a href=""http://www.gotw.ca/gotw/019.htm"" rel=""nofollow"">Automatic Conversions</a>).</p>
",3
10777733,10777700,-3,"<p>For short-running programs it's OK to not delete the objects.    There is no adverse consequence.     </p>

<p>But well-designed application code is re-usable, and re-usable code is basically library code.   Library code should delete the objects it allocates, because it might be used in a long-running program.</p>

<p>So in other words, don't worry about it for a throw-away small program.    But for serious code, delete the objects rather than leaking them.</p>
",5
10777752,10777700,1,"<p>If you don't destroy objects when you're done with them, you are heading towards a memory/resource leak. If you lose track of the objects, then you have a leak.</p>

<p>This is a problem in a long running program, because you can run out of memory or resources. It's a bad sign in any program if objects are not properly kept track of. You made the object, why can't you destroy it too?</p>

<p>Most (every?) operating system will reclaim allocated memory from a process when the process exits, so you do not need to tidy up after yourself. In some cases avoiding this pointless tidying up may mean your users aren't waiting for too long when your process completes.</p>

<p>If your program behaves like this, it makes your code less available for re-use. If you want to package it into a library, you'll have to deal with this problem because you cannot know ahead of time how your library will be used.</p>

<p>As for your vector of pointers: iterate the vector and call delete on each pointer. Then destroy the vector.</p>
",0
10777920,10777700,1,"<blockquote>
  <p>how do I write a destructor that can destroy all the MyClass objects pointed to by the vector?</p>
</blockquote>

<p>Very good question! A class with such a destructor is called a <em>smart pointer</em>, and they are supplied by libraries like Boost, TR1, and the C++11 standard library, at least one of which probably came with your platform.</p>

<p>You should almost never use <code>new T</code> directly. Use <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""nofollow""><code>unique_ptr&lt;T&gt;</code></a> for straightforward ownership (the object persists if and only if the vector still exists) or <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow""><code>shared_ptr&lt;T&gt;</code></a> for shared ownership.  These templates exist in namespace <code>boost::</code>, <code>std::tr1::</code>, or <code>std::</code> depending on how you obtain them. The interfaces are much the same in any case.</p>

<p>Of course, you shouldn't use any kind of pointer at all if you can avoid it. <code>vector&lt;T&gt;</code> is preferable over <code>vector&lt; unique_ptr&lt; T &gt; &gt;</code> any day.</p>

<p>As for <em>whether</em> to free resources before exiting, of course you should. Good C++ practices make it harder to neglect to release resources than to do things correctly, so it's not really something we worry about.</p>
",3
10777842,10777700,5,"<p>It¡¯s a very simple contract ¨C one of the simplest in all of programming: <strong>if you allocate a resource you promise to the API that you will free it appropriately.</strong></p>

<p>Not doing so <em>will</em> have averse consequences. From waste of heap space to <a href=""http://www.catb.org/jargon/html/N/nasal-demons.html"" rel=""nofollow"">nasal demons</a> chewing on your entrails.</p>

<p>The fact is that there simply is no excuse not to free resources you have requested. Not doing so is sloppy, and I would see it as indicative of generally bad code quality (because it <em>is</em>!).</p>

<p>Furthermore, C++ makes incredibly easy not to have to make this decision: simply don¡¯t produce garbage, then you don¡¯t need to clean up. Don¡¯t allocate freestore memory, or if you absolutely have to, use smart pointers or special allocators to manage it.</p>

<p>If you use C++ properly, there simply is no compelling technical reason to be sloppy with resources, and plenty of incentive to pay attention.</p>

<p>As for the ¡°how¡±, I¡¯d question the decision to store pointers in the first place: raw C++ pointers shouldn¡¯t own memory. If you really need freestore memory, use smart pointers, or (preferably) use automatic objects instead: since they are in a vector, this already gives you the ownership and storage location and the vector class takes care of that memory automatically.</p>

<p>If you need polymorphic objects, you unfortunately <em>need</em> to store pointers. In that case, there are several possibilities but the simplest is probably the usage of smart pointers.</p>
",5
10116150,10116041,1,"<p>You can overload the operator>> to do this by doing</p>

<pre><code>struct SomeStruct
{
    string id;
    int data;
};

istream &amp; operator&gt;&gt;(istream&amp; is, SomeStruct&amp; someData)
{
    is &gt;&gt; (string&amp;)someData.id;
    is &gt;&gt; someData.data;

    return is;
}
</code></pre>

<p>Then later</p>

<pre><code>SomeStruct test;
cin &gt;&gt; test;
</code></pre>

<p>To learn more about the operator>>, take a look at <a href=""http://www.cplusplus.com/reference/iostream/istream/operator%3E%3E/"" rel=""nofollow"">istream::operator>></a>.</p>

<p>To learn more about operator overloading, take a look at <a href=""http://courses.cms.caltech.edu/cs11/material/cpp/donnie/cpp-ops.html"" rel=""nofollow"">C++ Operator Overloading Guidelines</a>.</p>
",5
11520572,7955145,5,"<p>add this header and function in your code: </p>

<pre><code>#include ""windows.h""

void gotoxy(int x, int y) 
{ 
    COORD coord;
    coord.X = x; 
    coord.Y = y;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
}
</code></pre>
",1
18326811,7955145,2,"<p>You could write it on your own:</p>

<pre><code>void gotoxy(int x, int y)
{
    COORD c = { x, y };  
    SetConsoleCursorPosition(  GetStdHandle(STD_OUTPUT_HANDLE) , c);
}
</code></pre>
",1
9810798,9810765,2,"<p>I think you want to change this line:</p>

<pre><code>if(testArray[numOfScores] &lt; lowest)
</code></pre>

<p>to this:</p>

<pre><code>if(testArray[count] &lt; lowest)
</code></pre>

<p>Also, as @jzworkman points out, the denominator for averaging should be (numScores - 1) since you are eliminating the lowest score from the numerator. (If applicable, you might want to test for the edge case where there is only one score, which leaves nothing to average once you eliminate the lowest score.)</p>
",0
9810834,9810765,2,"<p>Couple issues.  You shouldnt have those two for loops nested(instead just check if the value is lower than the lowest using an if statement).</p>

<p>Since this is homework I will give you the steps and then you can fix your code</p>

<ol>
<li>Loop through and calculate the total, finding the lowest score at the same time</li>
<li>Calculate the average as (total-lowest)/(numScores -1)</li>
<li>Return the average</li>
</ol>
",2
9810898,9810765,3,"<pre><code>std::vector&lt;double&gt; scores = {1.2,6.5,3.0,8.3,4.8,6,7.7};

// drop lowest score
scores.erase(min_element(begin(scores),end(scores)));

double average = accumulate(begin(scores),end(scores),0.0)/scores.size();
</code></pre>
",2
9810966,9810765,1,"<p>There are a lot of problems with your <code>averageScore</code> function, but i'll cover the most basic one for now.</p>

<p>First off, you should pass it some sort of data.  Right now you're using <code>testArray</code> I don't even see where it is allocated.  I'm surprised that you're not getting segmentation faults when you run this.  </p>

<p>But it's also not initialized.  In c++, when you declare a pointer, the variable it points to has a value.  It has a garbage value, and if you perform arithmetic operations with that garbage value, then your output will be garbage too.  </p>

<p>You have to make your list of scores available to your <code>averageScore</code> function, preferably by passing them in as a parameter.  </p>

<p>the beginning of your averaging function looks like the following:</p>

<pre><code>double averageScore(int &amp;numOfScores)
{   
    double* testArray;
    ...
</code></pre>

<p>instead it should look like this</p>

<pre><code>double averageScore(double*testArray, int numOfScores)
{   
    ...
</code></pre>

<p>when you use <code>&amp;numOfScores</code> instead of <code>numOfScores</code>, that means that if you change <code>numOfScores</code> in your <code>averageScore</code> function, than it will change in your <code>main</code> function as well, and you shouldn't do that.</p>

<p>now, on the <code>double* testArray;</code> line, you're declaring a brand new pointer, named ""testArray"", and there's no meaningful data in it, although it might be full of garbage.   there might be other double pointer variables, named ""testArray"" in your code, but none of them are in the scope of your <code>averageScore</code> function.  If you pass <code>testArray</code> in, in your method call, you'll then be able to use it.  for example: <code>double someNumber = testArray[i]</code>.  </p>

<p>Bare in mind that your array is also being passed by reference.  If you would rather pass it by value, you can try </p>

<pre><code>`double averageScore(double testArray[], int numOfScores)`
</code></pre>

<p>but don't quote me on that one</p>

<p>Once you've done that, your code will still have some issues, but the output should be meaningful enough that you'll hopefully be able to work those out on your own.</p>
",4
11815325,11815288,1,"<p>If you are going to do this once then just run through it. The programming effort may not be worth the time gained. </p>

<p>I am assuming you want to  do this again and again which is why you want to optimize it. It would surely help to know if your iteration and comparisons need to be done sequentially etc? Without some problem domain input it is kind of difficult to give a generic optimization here. </p>

<p>If it can be done in parallel and you have to do it multiple times I suggest you take a look at MapReduce techniques to solve this. </p>
",0
11815379,11815288,1,"<p>8 GB worth of data will inevitably ruin data locality so one way or the other you either have to manage your memory in smaller pieces or your OS will do the disk swapping of virtual memory.</p>

<p>There is, however, an alternative - a so-called <code>mmap</code>. Essentially this allows you to map a file into a virtual memory space and your OS then takes the task of accessing it and loading the necessary pages into RAM, while your access to this file becomes nothing more than just a simple memory addressing.</p>

<p>Read more about <code>mmap</code> at <a href=""http://en.wikipedia.org/wiki/Mmap"" rel=""nofollow"">http://en.wikipedia.org/wiki/Mmap</a></p>
",0
14221888,14221763,25,"<p>C++ random numbers aren't truly random - they are generated from initial value called seed. If you don't set the seed, it will always be the same, so generated sequence won't change. <code>std::random_shuffle</code> depends on random number generation, so it will behave this way as well. </p>

<p>So how to set the seed? Use:</p>

<pre><code>srand(time(0));
</code></pre>

<p>before any calls to functions using random numbers. It will set the seed to current time in seconds. Don't forget to add appropritate header files.</p>
",4
14221920,14221763,38,"<p><code>std::random_shuffle(b,e)</code> uses an implementation-defined source of randomness and so this cannot be portably controlled. Typically implementations use <code>std::rand()</code> and so using <code>std::srand()</code> to seed the rng often works.</p>

<pre><code>// not portable, depends on implementation defined source of randomness in random_shuffle
std::srand(some_seed);
std::random_shuffle(answerPositionArray, answerPositionArray+size);
</code></pre>

<p>There is an overload of <code>std::random_shuffle()</code> which takes as a third parameter a random number generator. You can use this form to define the source of randomness so you can seed it.</p>

<pre><code>struct RNG {
    int operator() (int n) {
        return std::rand() / (1.0 + RAND_MAX) * n;
    }
};

std::srand(seed);
std::random_shuffle(answerPositionArray, answerPositionArray+size, RNG());
</code></pre>

<p>C++11 introduces another algorithm <code>std::shuffle</code> which takes a UniformRandomNumberGenerator, allowing you to use the C++11 <code>&lt;random&gt;</code> generators:</p>

<pre><code>std::random_device r;
std::seed_seq seed{r(), r(), r(), r(), r(), r(), r(), r()};
std::mt19937 eng(seed);

std::shuffle(std::begin(answerPositionArray), std::end(answerPositionArray), eng);
</code></pre>

<hr>

<p>Your comments indicate that the problem was that you were not shuffling the entire array, that you were only shuffling the first two elements and the last element was not being touched.</p>

<p>This is a good demonstration of how using magic numbers, as in your code:</p>

<pre><code>std::random_shuffle(answerPositionArray, answerPositionArray + 2);
                                                               ^
                                                               |
                                                 magic number --
</code></pre>

<p>can be error prone. Instead you should try to write code that works independently of such values.</p>

<pre><code>// trick for getting an array size
template&lt;typename T, int N&gt; int array_size(T (&amp;)[N]) { return N; }

int answerPositionArray[] = {100, 400, 800};

std::random_shuffle(answerPositionArray,
                    answerPositionArray + array_size(answerPositionArray));
</code></pre>

<p>Or once you can use C++11 you can use <code>std::begin</code> and <code>std::end</code> on arrays:</p>

<pre><code>std::random_shuffle(std::begin(answerPositionArray), std::end(answerPositionArray));
</code></pre>

<p>Or you can implement <code>begin</code> and <code>end</code> functions yourself in C++03 using the above array size trick:</p>

<pre><code>template&lt;typename T, int N&gt; T *begin(T (&amp;a)[N]) { return a; }
template&lt;typename T, int N&gt; T   *end(T (&amp;a)[N]) { return a + N; }
</code></pre>

<p>These methods allow you to avoid having to use a magic number for the array size, and so when you write or modify code you'll be less likely to mistakenly use the wrong value. </p>
",3
15901773,7951662,3,"<p>You're getting these warnings because the initialization statements in the <code>for</code> loops are expressions that does nothing:</p>

<pre><code>for(col; col &lt; num_cols; col++)  // line 92: ""col"" has no effect
for(row; row &lt; num_rows; row++)  // line 95: ""row"" has no effect
</code></pre>

<p>Since you've already initialized these variables outside the loop, you might want to omit them from the <code>for</code> statement:</p>

<pre><code>for(; col &lt; num_cols; col++)  // line 92
for(; row &lt; num_rows; row++)  // line 95
</code></pre>

<p>However, the best thing to do here is to initialize the variables in the <code>for</code> loops themselves rather than outside them:</p>

<pre><code>// Call the gc enum callback for each nested table
size_t num_cols = m_table-&gt;numCols(), num_rows = m_table-&gt;numRows();

for(size_t col = 0; col &lt; num_cols; col++ )   // Line 92
{   
    if (m_table-&gt;getColType(col) == COL_TABLE) {
        for (size_t row = 0; row &lt; num_rows; row++){  // Line 95
            Table * tbl = m_table-&gt;getTable(row, col);
            engine-&gt;GCEnumCallback(tbl);
        }   
    }   
}
</code></pre>
",0
15847786,15847718,0,"<p>Your attempts so far would not actually print the entire matrix even if they did not loop continuously. First for the while loop, it's very likely you should be initializing looper at <code>NUMBER_OF_STUDENTS - 1</code> because if there are <code>NUMBER_OF_STUDENTS</code> rows in the array then the highest element would be <code>NUMBER_OF_STUDENTS - 1</code>. It's possible that you're saying <code>NUMBER_OF_STUDENTS + 1</code> because of a coding problem elsewhere however. If that's the case I'd try to take care of that issue first for simplicity's sake.</p>

<p>Regarding your for loop </p>

<pre><code>for (row = 0; row &lt; NUMBER_OF_STUDENTS + 1; col++) {
   cout &lt;&lt;  matrix[row][col];
   cout &lt;&lt; endl;
}
</code></pre>

<p>this will loop forever because your stop condition is dependent on row, but row never changes, only col does.</p>

<p>To print all the elements in your matrix you need two loops. Something like this:</p>

<pre><code>for(int row=0; row &lt; numOfRows; row++)
    for(int col=0; col &lt; numOfCols; col++)
         cout &lt;&lt; matrix[row][col];
</code></pre>
",0
15847846,15847718,1,"<p>Here's the normal way to print a table of values</p>

<pre><code>void printMatrix(string matrix[][NUMBER_OF_SCORES + 1], int NUMBER_OF_STUDENTS)
{
  for (int row = 0; row &lt; NUMBER_OF_STUDENTS + 1; ++row)
  {
    for (int col = 0; col &lt; NUMBER_OF_SCORES; ++col)
    {
      cout &lt;&lt; matrix[row][col] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
  }
}
</code></pre>

<p><strong>BUT</strong> there are lots of things about your code I don't like. So whether this is right I cannot say. In particular I'm dubious about</p>

<p>1) Why do you have <code>NUMBER_OF_STUDENTS + 1</code>? No obvious need for the <code>+ 1</code>, you are probably trying to compensate for a mistake you made elsewhere.</p>

<p>2) Why do you have a matrix of strings? Scores would normally be a number.</p>

<p>I guess the main lesson to learn is to think about <strong>exactly</strong> what the code you write does. Code isn't a mysterious magic spell, it's a <strong>precise</strong> series of instructions to the computer. If you had thought about exactly what your code does, followed it through step by step, you would have seen the errors you'd made, and hopefully been able to fix them. You've got to get into that way of thinking.</p>
",2
9164883,9164859,4,"<p>Use a forward declaration instead of inclusion in <code>Page.h</code>:</p>

<pre><code>//replace this:
//#include ""Process.h""

//with this:
class Process;

class Page {
public:
    Page();
    virtual ~Page();
    Process *process;
};
</code></pre>
",0
9164892,9164859,2,"<p>You have a <a href=""http://en.wikipedia.org/wiki/Circular_dependency"" rel=""nofollow""><em>circular dependency</em></a> between <code>Process</code> and <code>Page</code>.</p>

<p>Instead of...</p>

<pre><code>#include ""Process.h""
</code></pre>

<p>...in Page.h , forward declare...</p>

<pre><code>class Process;
</code></pre>

<p>...and this will allow you to have <code>Process* process;</code> in your <code>Page</code> <code>class</code>.</p>
",0
9164929,9164859,0,"<p>I think that Process.h is first included in Page.h rather than Page.h in Process.h. </p>
",0
8747967,8747943,0,"<p>Reference counting and shared pointers, though it's doubtful that this is accepted in your introductory course. Consequently I'd suggest that your design ought to be revisited to avoid the multiple-references.</p>
",1
8749242,8747943,0,"<p>If you want to stick with very simple C++ code then you have a number of ways that you could achieve this.  You could just loop through all the Loans and check that none of them are for the Person or Media you are trying to delete.  </p>

<p>Alternatively just as Loan refers to the instance of Person and Media that it is for you could make Person and Media also hold a reference to the Loan. One advantage of this approach is you can easily detect when a Media item is already on loan, complications are that a Person could have more than one Media item on loan and there is more housekeeping to do when a Media item is returned.</p>
",1
8744791,8744255,4,"<p>I'm pretty convinced such a project doesn't exist, and if it existed I probably wouldn't recommend it over a good book. There are several problems with your premise:</p>

<ul>
<li><p>Whole books have been written about the topic of best practices in c++, so I'd be very doubtful about any <strong>small</strong> project illustrating any reasonable number of those. Note that this doesn't mean that books can't have coherent examples instead of unrelated ones, but it's typically still picked from a bigger codebase</p></li>
<li><p>Best practices are kind of pointless without a thorough explanation, why they are sensible. For many best practices that explanation isn't exactly short enough to fit in your typical code comment (having 20 lines of comment between each line of code (slight exaggeration, but probably not by that much) doesn't make a project very readable). </p></li>
<li><p>Many <em>best practices</em> in c++ (or in programming in general, but it's particularly pronounced in c++) are controversial, so it is sometimes a good idea to show the different ways to solve a particular problem (and say why one is better), which is easily done implementing the same example several times in different ways in a book/tutorial, but that's not sensible in a project.</p></li>
</ul>

<p>So concluding I would rather recommend reading a good book about C++ practices. So pick a book from <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">here</a>. I'd consider Scott Meyers <code>Effective C++</code> (and <code>Effective STL</code> and possibly <code>More Effective C++</code> once you are finished) for best practices, but some others could do the job too.</p>
",0
10788466,10788441,6,"<p><code>&lt;&lt;</code> has a dedicated overload for <code>const char *</code>, because that's what a C-style string is.  Try this:</p>

<pre><code>cout &lt;&lt; static_cast&lt;const void *&gt;(bar2) &lt;&lt; endl;
</code></pre>
",7
15845789,15845518,-1,"<p>You can use the seekg() function which moves the FPM (i.e. File Position Marker) any amount of space you want.  That is probably the easiest way to do it.</p>

<p>From you code it would look something like</p>

<pre><code>inData.seekg(16, std::ios::beg) //Seeks past 16 character in the file
</code></pre>
",0
15845560,15845518,0,"<pre><code>string line;     
getline(infile, line)
for ( row = 0; row &lt; row_count; row++)
        for (col =0; col &lt;  column_count +1  ; col++)
            getline(infile, line);
            chart[row][col] = line;
</code></pre>

<p>Streams behave like their namesake. You can't skip what comes in the stream like jumping through an array, all you can do is ignore stuff as it floats by.</p>
",0
15845580,15845518,1,"<p>There's an answer here:
<a href=""https://stackoverflow.com/questions/164344/how-do-i-read-a-text-file-from-the-second-line-using-fstream"">How do I read a text file from the second line using fstream?</a></p>

<p>Just read the first line before doing the getData call.</p>
",0
9174050,9174019,5,"<p><code>drand48()</code> returns a <code>double</code>, whereas <code>rand()</code> returns <code>int</code>.</p>

<p>Furthermore, <code>drand48()</code> returns a value that's distributed between <code>[0.0, 1.0)</code>, so your formula needs to change:</p>

<pre><code>double x = drand48() * 1000.0 + 1; // floating-point values from [1, 1001)
</code></pre>

<p>or</p>

<pre><code>double x = (int)(drand48() * 1000.0) + 1; // integer values from [1, 1000]
</code></pre>

<p>You could either scale the result of <code>drand48()</code> as above, or use <code>lrand48()</code> with your existing formula.</p>
",0
9174072,9174019,8,"<p><code>drand48</code> returns a number from the interval <code>[0.0, 1.0)</code>. Are you looking for a number between 1 and 1000? In this case, you need to multiply by 999 and add 1.</p>

<p>Actually, what are you expecting?</p>
",2
9174082,9174019,3,"<p>drand48 returns a double in the range of 0.0 to 1.0.  You want to multiply that by the range you're looking to generate. <code>double x = drand48() * 1000.0</code></p>
",0
9222887,9222823,0,"<p>This can be done by adding constructor to <code>Player</code>: </p>

<pre><code>Player(ChessEngine * _ce) : ce(_ce) {}
</code></pre>

<p>and passing <code>ChessEngine</code> as a parameter: </p>

<pre><code>ChessEngine() {
    p1 = new Player(this);
}
</code></pre>
",0
10141448,10141302,10,"<p><code>b.a</code> is not a temporary so its lifetime is not affected by any references that are subsequently bound to it.</p>
",3
10142909,10141302,2,"<p>I'm not sure I understand what you're asking.  In your code, the only
temporary I see is the <code>A(""hey"")</code> in the expression that initializes <code>b</code>
in <code>main</code>.  And that is copied (using the copy constructor) into <code>b.a</code>
in <code>B::B</code>.  After that, there are no more temporaries, anywhere.</p>

<p>More generally, the fact that a temporary is bound to a reference
doesn't necessarily change its lifetime.  What extends the lifetime is
the fact that the temporary is used to initialize the reference: in your
case, for example, <code>temp</code> in <code>f</code> will never have an effect on the
lifetime of a temporary, because it is not initialized with a temporary,
but with another reference.  And there are exceptions to this rule: if
you use a temporary to initialize a member reference in the initializers 
of a class, it's lifetime will still not extend beyond the end of the
constructor, so:</p>

<pre><code>class A
{
    std::string const&amp; rString;
public:
    A() : rString( std::string( ""hey"" ) ) {}
    std::string get() const { retur rString; }
};
</code></pre>

<p>will not work.</p>
",2
12275627,12275589,6,"<p>In C++11:</p>

<pre><code>dodgy_function(std::to_string(value).c_str());
</code></pre>

<p>In older language versions:</p>

<pre><code>std::ostringstream ss;
ss &lt;&lt; value;
dodgy_function(ss.str().c_str());

// or
dodgy_function(boost::lexical_cast&lt;std::string&gt;(value).c_str());

// or in special circumstances
char buffer[i_hope_this_is_big_enough];
if (std::snprintf(buffer, sizeof buffer, ""%d"", value) &lt; sizeof buffer) {
    dodgy_function(buffer);
} else {
    // The buffer was too small - deal with it
} 
</code></pre>
",0
14746905,14746748,1,"<p>If you are declaring a ""static"" array as this,</p>

<p>static int i[100];</p>

<p>memory allocated for 100 integers remains through the life of the program. But for this,</p>

<p>int i[100]</p>

<p>the memory is getting free and goes out of stack (as this is local) while this goes out of scope. </p>
",0
14746779,14746748,3,"<p>You don't need to delete those. they are on the stack within the memory, not the heap and get cleared as soon as you leave their scope.</p>

<p>And in your example: j is cleared when you leave the loop.</p>
",1
14746780,14746748,2,"<p>No, in general variables on the stack must not be deleted.</p>
",2
14746839,14746748,3,"<blockquote>
  <p>what about static array like:</p>
</blockquote>

<pre><code>int i[100];
int i[]={1,2,3,4};
</code></pre>

<blockquote>
  <p>should it be deleted?</p>
</blockquote>

<p>No... both <code>static</code> data (which is used when definitions like these appear outside any function scope) and stack-based data (used for variables within a function) are automatically destructed (if needed) when the program terminates or scope exits respectively.  Memory for <code>static</code> variables does not need to be ""released"" explicitly by the program - the operating system will reclaim the memory when the program terminates.  Stack memory is a bit like waves on a beach... as scopes are entered and exit, the same memory (think area on the beach) is used (covered) then released automatically, then reused....</p>

<pre><code>bool fu()
{
  for(int i=0;i&lt;100;i++
  {
   int j[]={1,2,3,4};
  }
  return 0;
}
</code></pre>

<p>Here, <code>j[]</code> is recreated on the stack - probably at the same address each time through the loop though the C++ Standard doesn't discuss such implementation details - but it may be reinitialised by recopying data from the constant (static) array where {1, 2, 3, 4} are stored for that purpose.  (If the optimiser deduces you never change it, it might skip the reinitialisation, or even remove the stack variable and access the constant array values directly, or even remove the constant array and move specific values accessed into immediate values in the machine code opcodes - optimisers can do pretty much anything as long as it doesn't affect anything other than performance of the program).</p>
",0
14746886,14746748,1,"<p>Take a look <a href=""http://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/"" rel=""nofollow"">http://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/</a> where you'll find explanations for your questions</p>
",0
8756252,8756162,1,"<p>Seems to me a standard hashmap would suit you well - very fast look up and it will handle the collisions for you reliably and invisibly.</p>
",0
8756673,8756162,0,"<p>If you wish to explore other territories apart STL, take a look at <a href=""http://judy.sourceforge.net/"" rel=""nofollow"">Judy arrays</a>: these should fit your problem.</p>

<p>If you are on Linux you can experiment with them very easily, just install from your repository...</p>

<p><a href=""http://judy.sourceforge.net/examples/Judy_hashing.pdf"" rel=""nofollow"">This</a> application note could help to solve your task.</p>

<p><strong>EDIT</strong></p>

<p>There is <a href=""http://judyhash.sourceforge.net/"" rel=""nofollow"">this</a> STL interface: I'm going to experiment with it, then I'll report my results.</p>
",0
11817902,11817873,55,"<p>No. Whenever a local variable in a <code>return</code> statement is eligible for copy elision, it binds to an rvalue re&shy;fe&shy;rence, and thus <code>return t;</code> is identical to <code>return std::move(t);</code> in your example with respect to which constructors are eligible.</p>

<p>Note however that <code>return std::move(t);</code> <em>prevents</em> the compiler from exercising copy elision, while <code>return t</code>; does not, and thus the latter is the preferred style. [Thanks to @Johannes for the cor&shy;rect&shy;ion.] If copy elision happens, the question of whether or not move construction is used becomes a moot point.</p>

<p>See 12.8(31, 32) in the standard.</p>

<p>Note also that if <code>T</code> has an accessible copy- but a deleted move-constructor, then <code>return t;</code> will not com&shy;pile, because the move constructor must be considered first; you'd have to say something to the ef&shy;fect of <code>return static_cast&lt;T&amp;&gt;(t);</code> to make it work:</p>

<pre><code>T f()
{
    T t;
    return t;                 // most likely elided entirely
    return std::move(t);      // uses T::T(T &amp;&amp;) if defined; error if deleted or inaccessible
    return static_cast&lt;T&amp;&gt;(t) // uses T::T(T const &amp;)
}
</code></pre>
",4
10762414,10762393,3,"<p>There is no conversion done here, it's simply that <code>sizeof</code> will return the actual byte size of the object. Obviously std::string uses heap-allocated memory to store its actual content, so you have no real way to know exactly how many bytes in total are used for a specific string</p>
",5
10762417,10762393,13,"<p><code>sizeof</code> gives you the size in bytes. <code>std::string</code> contains a pointer to the actual data. The size of the single pointer stays the same no matter the size of what it's pointing to. This, combined with the other factors gives you your total size of 8.</p>

<p>You're looking for either <code>std::string::size</code> or <code>std::string::length</code> for the actual length of the string. If you're looking for a function to retrieve the size of any null-terminated C-String, use <code>strlen()</code>.</p>
",2
9214903,9214864,2,"<p>Well, you should implement the function <code>contains()</code> of the template class <code>Set</code>.</p>

<p>Remember that template functions have to be defined inline, so you'll like want to put the definition in the same header file.</p>
",3
9214929,9214864,0,"<p>So, where is the definition of </p>

<pre><code>    bool contains(const T&amp; e) const;
</code></pre>

<p>?</p>

<p>Looks like your definition is in some other file.
The definition of the template functions should be along with the class.
This is not like normal C++ classes.</p>
",2
12344083,12344065,3,"<p>Put the class definition of <code>B</code> into the header file:</p>

<p><strong>b.h:</strong></p>

<pre><code>#ifndef H_B_CLASS
#define H_B_CLASS

class B
{
    // member declarations
};

#endif
</code></pre>

<p><strong>a.cpp:</strong></p>

<pre><code>#include ""a.h""
#include ""b.h""

A::A() { B foo; /* ... */ }
</code></pre>

<p><strong>b.cpp:</strong></p>

<pre><code>#include ""b.h""

// B's member definitions
</code></pre>

<p>If there's nothing in class <code>B</code>, you can omit <code>b.cpp</code> and put the entire class definition into the header file.</p>
",2
12344105,12344065,0,"<p>If <code>B</code> is completely empty, as you say, then there's no public default constructor available.  You must at least define <code>B()</code> as a public member of <code>class B</code>, otherwise nobody can construct it.</p>
",1
11812594,11812555,8,"<p>You could zeroize using <code>memset</code>:</p>

<pre><code>memset(&amp;x, 0, sizeof(x));
</code></pre>
",1
11812606,11812555,7,"<p>For a union without a user-defined default constructor, <em>value initialization</em> is <em>zero initialization</em>.</p>

<p>However, zero-initialization of a union may not zero all memory, but only the padding and the first member.  If the first member isn't the largest, you could be left with non-zero content.</p>

<p>Since you know that <code>s2</code> is largest, you can make a default constructor that zeros it:</p>

<pre><code>struct T
{
    int a;
    union {
        int s1a;
        char s2b[1024];
    };
    T() : a(), s2b() {}
};
</code></pre>

<p>And now</p>

<pre><code>T x;
</code></pre>

<p>will be zeroed.</p>
",5
11812624,11812555,2,"<p>I would suggest to implement a constructor for <code>T</code>:</p>

<pre><code>struct T {
    int a;
    union {
        struct {
            int a;
        } s1;
        struct {
            char b[1024];
        } s2;
    };
    T() : a(), s2() {} // &lt;- proper initialisation
};
</code></pre>

<p>In this case, I picked the largest member of your <code>union</code> since it's transparent. Otherwise you could explicitly create the <code>union</code> itself.</p>
",0
13439663,13439610,2,"<p>You¡¯ve got the syntax wrong: the name of the struct comes before the body, not after it:</p>

<pre><code>struct Rect {
   float x, y;
   float width, height;
};
</code></pre>

<p>There, now you¡¯re good to go.</p>

<p>But note that ¡°union¡± means something completely different in C++. A <code>union</code> is a data structure which, like a <code>struct</code>, groups objects. But while every instance of a <code>struct</code> can hold multiple values simultaneously, an instance of a <code>union</code> can only hold a <em>single</em> value at a time. They have their uses, but those are pretty rare and there are usually better (and type safe) ways of accomplishing the same.</p>
",0
13439712,13439610,2,"<p>You're looking for <strong>anonymous unions</strong>. The syntax is:</p>

<pre><code>struct Rect {

   union {
       Vector2f pos;
       struct {
           float x,y;
       };
   };
   union {
       Vector2f size;
       struct {
           float width, height;
       };
   };

};
</code></pre>

<p>Demo: <a href=""http://ideone.com/JgqABu"" rel=""nofollow"">http://ideone.com/JgqABu</a></p>

<p><em>(I don't recommend doing that though; I'd just <a href=""http://en.wikipedia.org/wiki/KISS_principle"" rel=""nofollow"">KISS</a> and use the vectors.)</em></p>
",0
8792078,8791674,1,"<p>ybungalobill may have answered your question but I thought I would point out a mistake you have made that many people make when dealing with Unicode. The line:</p>

<pre><code>memset(buffer,0,sizeOfLine + 148);
</code></pre>

<p>Will not clear the entire buffer that you have allocated, it will only clear half of it.<br>
If you really want to clear the buffer you should do:</p>

<pre><code>memset(buffer, 0, sizeof(TCHAR) * (sizeOfLine + 148));
</code></pre>

<p>To answer your question about EM_GETLINE. If your project is configured for Unicode, SendMessage will be translated to SendMessageW which will return a Unicode string. Whether or not the string is properly formatted is up to the control receiving the message.</p>
",1
8792211,8791674,1,"<p>Could you give an example of text for which your code works? The example text you give for failure indicates that the upper 8 bits of the characters is getting zeroed out.</p>

<pre><code>ÄÃ (U+62FF) -&gt; ? (U+00FF)
? (U+B4EC) -&gt; ¨¬ (U+00EC)
Ô (U+58F4) -&gt; ? (U+00F4)
¸g (U+7AD2) -&gt; ¨° (U+00D2)
</code></pre>

<p>If the text that your code 'works' for is all in the range U+0000 to U+00FF (which covers characters used in the Americas and Western Europe) then you wouldn't notice a problem even if you're doing something wrong. This would indicate that this is probably not a problem with getting text from the control, but instead a problem with something your program does with the text elsewhere.</p>

<p>Assuming your program defines the <code>UNICODE</code> macros then <code>TCHAR</code> is <code>wchar_t</code>, which is two bytes on Windows. Make sure you're not mistakenly treating it as a one byte <code>char</code> anywhere, because that could easly truncate the character values the way you describe. Jim Rhodes already pointed out one area where you're not taking this into account.</p>
",0
13791285,13790828,0,"<p>One application of static methods is to create instances and return pointers. For example, there may be derived classes that the caller isn't supposed to know about - the ""factory"" function knows which derived class to use.</p>

<p>Of course when you need to create an object, you probably don't already have an object to use for that, and even if you do that other object isn't relevant.</p>

<p>Basically, sometimes some action is an aspect of the abstraction that a class provides, but that action isn't associated with a specific object - or at least not one that already exists. In that case, you should implement the action as a static function.</p>

<p>Similarly, some data is related to the abstraction provided by a class but not to a particular instance of that class. That data is probably best implemented as static member variables.</p>
",0
13790841,13790828,5,"<p>Normal member functions require a class instance to run. Static methods can be called directly without first creating an instance of the class.</p>

<p>Normal method:</p>

<pre><code>MyClass myClass;
myClass.NormalMethod();
</code></pre>

<p>Static method:</p>

<pre><code>MyClass::StaticMethod();
</code></pre>

<p>So normal methods are perfect for functions that work with the class data. If a method doesn't need to work with the class data, then it would be a candidate for possibly being made static.</p>
",1
13790896,13790828,2,"<p>Class methods, static or otherwise, can access private members of any of that class's objects, not just its own instance. Same goes for static methods, which don't have an instance unless you pass one to them.</p>

<p>You could also use a free function and declare it a friend, but a free function implies a higher level of abstraction that may operate on objects of different classes. A static class method says ""I only make sense in light of my class""</p>
",0
9213487,9213338,0,"<p><code>const int para</code>: useful to you as it stops you modifying para by mistake.  Not sure about the confusion issue.</p>

<p><code>const int &amp;para</code>: You should do this, indeed sometimes you have to if code elsewhere insists that you keep <code>para</code> constant (for example if you are writing a custom comparator function for a <code>map</code>).  It's also more efficient than <code>const int para</code> - if you are not modifying <code>para</code> why do you need to copy it?</p>

<p>I don't think it matters what <code>const int &amp;para</code> is implemented as underneath.  What matters is that on top you can't modify it (without being evil) so the effect is the same as <code>const int para</code> but more efficient.</p>
",3
9213503,9213338,0,"<p>I think it will only serve to clarify things for readers of header files, by marking a parameter <code>const</code> it is effectively saying it is input only. Likewise the <code>&amp;</code> reference operator is read as the parameter being modified in the function with effect on the passed parameter. This may be where the confusion arises, however <code>const int &amp;para</code> is <code>const</code> ""before"" it is <code>&amp;</code> reference and doesn't require much interpretation.</p>

<p>I confuse <code>&amp;</code> and <code>*</code> notation because I am used to C where the <code>&amp;</code> operator does not exist. But for C++, I would recommend you use it.</p>
",1
9213519,9213338,3,"<p>Declaring an argument as <code>const</code> serves three purposes:</p>

<ol>
<li><p>It tells the compiler that the value is constant, which may enable certain optimizations.  Given today's ""smart"" compilers, I'm not sure that it's still relevant.</p></li>
<li><p>It tells programmers at a glance that the value does not change within the function, which may be helpful as they debug/enhance the code.</p></li>
<li><p>It makes the compiler actually enforce your assertion that the function does not change the value.</p></li>
</ol>

<p>In general it's a good idea to declare variables as <code>const</code> if you can, for the same reason it's a good idea to eliminate compiler warnings: it makes your code easier to support.</p>
",4
9213579,9213338,5,"<p>If you do this at all (and some people do) then you should put the const in the definition (where it is useful) but not the declaration (where it is noise, it doesn't affect the caller).</p>

<p>So:</p>

<pre><code>void F(int param);

...


void F(int const param) {
   ...
}
</code></pre>
",1
9213590,9213338,-1,"<p>You should not. in C, parameters are been passed by value, so the caller don't need to know what do you do with the <code>int</code> it pass. even if your function is <code>void func(int)</code>, you can pass a <code>const int</code> to it.</p>

<pre><code>void func(int a) {
 a=5;
}
...
const int b=7;
func(b);
</code></pre>

<p>In this code, <code>b</code> will still be 7, since the function only changed the local variable <code>a</code>.</p>

<p>Of course, if the function get a pointer, or a reference, it's different. if the declaration is <code>void func(int &amp;a)</code>, then the above code is illegal, since <code>func</code> changed <code>b</code>, which is const, and therefor if your function doesn't change the reference, and you want the possibility to pass a <code>const int</code> to it, you should declare the parameter as const.</p>
",1
16390155,16390023,2,"<p>Here's a simplified example of how initialization across multiple TUs can be problematic.</p>

<p><strong>gadget.h:</strong></p>

<pre><code>struct Foo;

extern Foo gadget;
</code></pre>

<p><strong>gadget.cpp:</strong></p>

<pre><code>#include &lt;foo.h&gt;
#include &lt;gadget.h&gt;

Foo gadget(true, Blue, 'x');    // initialized here
</code></pre>

<p><strong>client.cpp:</strong></p>

<pre><code>#include &lt;foo.h&gt;
#include &lt;gadget.h&gt;

int do_something()
{
    int x = gadget.frumple();   // problem!

    return bar(x * 2);
}
</code></pre>

<p>The problem is that it is not guaranteed that the <code>gadget</code>object will have been initialized by the time that <code>do_something()</code> refers to it. It is only guaranteed that initializers within one TU are completed before a function in that TU is called.</p>

<p>(The solution is to replace <code>extern Foo gadget;</code> with <code>Foo &amp; gadget();</code>, implement that in gadget.cpp as <code>{ static Foo impl; return impl; }</code> and use <code>gadget().frumple()</code>.)</p>
",3
16390165,16390023,0,"<blockquote>
  <p>1) If the client code needs to use tfs, then there will be some sort of include statement. Therefore surely this code is all in one translation unit? I do not see how you could refer to code which is in a different translation unit? Surely a program is always one translation unit?</p>
</blockquote>

<p>A translation unit is (roughly) a single .cpp file after preprocessing. After you compile a single translation unit you get a module object (which typically have extension <code>.o</code> or <code>.obj</code>); after all TUs have been compiled, they are linked together by the linker to form the final executable. This is often hid by IDEs (and even by the compilers accepting multiple input files on the command line), but it's crucial to understand that building a C++ program is made in (at least) three passes: precompilation, compilation and linking.</p>

<p>The <code>#include</code> statement will include the declaration of the class and the <code>extern</code> declaration, telling to the current translation unit that the class <code>FileSystem</code> is made that way and that, in some translation unit, there's a variable <code>tfs</code> of type <code>FileSystem</code>.</p>

<blockquote>
  <p>2) If the client code included FileSystem.h would the line extern FileSystem tfs; be sufficient for the client code to call tfs</p>
</blockquote>

<p>Yes, the <code>extern</code> declaration tells the compiler that in some TU there's a variable defined like that; the compiler puts a placeholder for it in the object module and the linker, when tying together the various object modules, will fix it with the address of the actual <code>tfs</code> variable (<em>defined</em> in some other translation unit).</p>

<p>Keep in mind that when you write <code>extern</code> you are only <em>declaring</em> a variable (i.e. you are telling the compiler ""trust me, there's this thing somewhere""), when you omit it you are both declaring it and defining it (""there's this thing and you have to create it here"").</p>

<p>The distinction maybe is clearer with functions: when you write a prototype you are <em>declaring</em> a function (""somewhere there's a function x that takes such parameters and returns this type""), when you actually write the function (with the function body) you are <em>defining</em> it (""this is what this function actually does""), and, if you haven't declared it before, it counts also as a declaration.</p>

<hr>

<p>For how multiple TUs are actually used/managed, you can have a look at <a href=""https://stackoverflow.com/a/3731003/214671"">this answer of mine</a>.</p>
",8
16390276,16390023,0,"<p>Here's the example from the Standard C++03 (I've added the <code>a.h</code> and <code>b.h</code> headers):</p>

<p>[basic.start.init]/3</p>

<pre><code>// a.h
struct A { A(); Use(){} };

// b.h
struct B { Use(){} };

// ¨C File 1 ¨C
#include ""a.h""
#include ""b.h""
B b;
A::A(){
    b.Use();
}

// ¨C File 2 ¨C
#include ""a.h""
A a;

// ¨C File 3 ¨C
#include ""a.h""
#include ""b.h""
extern A a;
extern B b;
int main() {
    a.Use();
    b.Use();
}
</code></pre>

<p>It is implementation-defined whether either a or b is initialized before main is entered or whether the initializations are delayed until a is first used in main. In particular, if a is initialized before main is entered, it is not guaranteed that b will be initialized before it is used by the initialization of a, that is, before A::A is called. If, however, a is initialized at some point after the first statement of main, b will be initialized prior to its use in A::A. </p>
",2
14721925,14719911,1,"<p>One form of passing a generic function to be called is a callable templated type:</p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;

template&lt;typename F&gt;
void callFoo(F f) {
   f();
}

int main() {
   callFoo(std::bind([](int a, int b) {std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b;}, 5, 6));
}
</code></pre>

<p><code>callFoo</code> takes a callable type, <code>F</code>, and calls it. Around this call, you can, for example, do timer work to time the function. In <code>main</code>, it's called with a lambda that has two parameters and the values given to those parameters bound to it. <code>callFoo</code> can then call it without storing the arguments. This is very similar to taking a parameter with the type <code>std::function&lt;void()&gt;</code>.</p>

<p>If, however, you don't want to use <code>std::bind</code>, you can pass in the arguments separately with a couple changes:</p>

<pre><code>template&lt;typename F, typename... Args&gt;
void callFoo(F f, Args... args) { //ignoring perfect forwarding
    f(args...);
}

int main() {
    callFoo(/*lambda*/, 5, 6);
}
</code></pre>

<p>In these cases, passing void functions makes sense. Indeed, return values can be used as parameters and passed in with <code>std::ref</code>. If you plan on returning what the function returns, you'll have to handle the special case of the return type being <code>void</code>, as you can't assign to a <code>void</code> variable and return that. At this point, it's easier to direct you to my <a href=""https://stackoverflow.com/questions/9625526/check-at-compile-time-if-template-argument-is-void"">previous question</a> on the matter. My use case for it turned out to be moot, but the solution works great for other uses. </p>
",3
10775140,10774836,1,"<p>There are many ways to parse a string, here is one using substr()</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
    string strLine(""Humpty Dumpty sat on the wall"");
    string strTempString;
    vector&lt;int&gt; splitIndices;
    vector&lt;string&gt; splitLine;
    int nCharIndex = 0;
    int nLineSize = strLine.size();

    // find indices
    for(int i = 0; i &lt; nLineSize; i++)
    {
        if(strLine[i] == ' ')
            splitIndices.push_back(i);
    }
    splitIndices.push_back(nLineSize); // end index

    // fill split lines
    for(int i = 0; i &lt; (int)splitIndices.size(); i++)
    {
        strTempString = strLine.substr(nCharIndex, (splitIndices[i] - nCharIndex));
        splitLine.push_back(strTempString);
        cout &lt;&lt; strTempString &lt;&lt; endl;
        nCharIndex = splitIndices[i] + 1;
    }

    getchar();

    return 0;
}
</code></pre>
",0
14155859,14155801,2,"<p>I don't understand why <code>update</code>, <code>get</code> and <code>clear</code> need to be <code>private</code>. To me, this looks like a bad design. If you're planning on calling them from other classes, and, logically, they should be called from other classes, make them <code>public</code>. In fact, I'd probably just make <code>update</code> private and call it internally from <code>DataSet</code> whenever required (for example, call it at the beginning of <code>get</code>).</p>

<p>You could do it the way you want by just making <code>Renderer</code> a friend, and accessing those methods just through renderer, but, to be honest, that doesn't look clean at all.</p>
",1
14155999,14155801,1,"<p>Give the <code>DataSet</code> a public <code>render</code> function, and pass the <code>Renderer</code> to it.</p>

<p>If you need the update to be independent of rendering, make <code>update</code> public, too.</p>

<p>A good design principle is <a href=""http://pragprog.com/articles/tell-dont-ask"" rel=""nofollow"">Tell, Don't Ask</a>. Don't write getters, rearrange your design so that they are not needed.</p>

<p>The name <code>DataSet</code> hides the true meaning of the objects. They are visible, renderable, scene objects, props, solids.</p>

<p>It sounds as though you want to render a particular view of a scene, depending upon the camera position. The view is dynamic:</p>

<pre><code>View view(scene);    
...
view.render(renderer);
</code></pre>
",0
11546620,11546313,1,"<p>In general it's bad news to have two symbols with the same name but different meanings. Your option B, using a different name for the local pointer, sounds like the best solution.</p>

<p>If you insist on using the same name for both the function and the pointer, you could put one or the other into a namespace.</p>
",0
15864275,15864170,3,"<p>The function <code>RSGetViewports</code> uses the pointer to modify the value of the <code>int</code> so that is visible outside the function. In this way, you can think of that argument as being both an input and output argument. Of course, there must be an object available for it to modify. If you were to pass an integer literal, there would be no such object.</p>
",3
10648472,10646786,1,"<p>The easiest is to execute lsblk, pipe in the result and in the result </p>

<pre><code>sr0     11:0    1   308M  0 rom  
sda      8:0    0   120G  0 disk 
©À©¤sda1   8:1    0   300M  0 part /boot
©À©¤sda2   8:2    0 117.8G  0 part /
©¸©¤sda3   8:3    0     2G  0 part [SWAP]
</code></pre>

<p>check for a line such as:</p>

<p>""rom"" so, for me the CD-rom is /dev/sr0 . For you possibly it will be hd0</p>

<p>A little bit more work comes with using sysfs.h and the sysfs calls, more information is given in ""man sysfs"" or browsing the <a href=""http://lxr.free-electrons.com/source/include/linux/sysfs.h"" rel=""nofollow"">http://lxr.free-electrons.com/source/include/linux/sysfs.h</a> or the source of lsblk: <a href=""http://gitorious.org/util-linux-ng/util-linux-ng/blobs/cc6b1d11eabf9d86849a80f2ca8b4c0afd45844f/misc-utils/lsblk.c"" rel=""nofollow"">http://gitorious.org/util-linux-ng/util-linux-ng/blobs/cc6b1d11eabf9d86849a80f2ca8b4c0afd45844f/misc-utils/lsblk.c</a></p>

<p>Hopefully this helps a little bit more.</p>
",0
11109846,11109811,4,"<p>The problem is that you are returning a reference to a temporary value returned from <code>getValue</code>. Either make both functions return <code>double&amp;</code>, or both return <code>double</code>.</p>
",3
8792839,8792763,10,"<p>The member initialization depends on <code>Point</code> having a public copy constructor, since you explicitly calling <code>Point::Point(const Point&amp;)</code>.</p>

<p>If that doesn't exist or is not accessible, you can't call it.  If you can't call it, it isn't because the <em>initialization list</em> doesn't work, though.</p>

<p>Presumably <code>Point</code> has an accessible assignment operator, if the first version works.</p>

<hr>

<p>Just to confirm, now you've pasted the source for <code>Point</code>, the copy constructor should look like:</p>

<pre><code>Point::Point(const Point &amp;other) : x(other.x), y(other.y) {}
</code></pre>

<p>(you might as well get comfortable using the initializer list).
The key change is the argument must be a <code>const</code> reference: this prohibits accidentally damaging the source object when copying.</p>
",1
8792998,8792763,3,"<p>In</p>

<pre><code>Line(const Point&amp; p1, const Point&amp; p2): startpoint(p1), endpoint(p2)
</code></pre>

<p>You are invoking <code>Point::Point</code> with <code>p1</code> (<code>p2</code> respectively) which has type <code>const Point&amp;</code>, i.e. you promised never to change the parameters given to <code>Line::Line</code>. Now, let's look at your <code>Point</code> class. The only method with a matching number of arguments is</p>

<pre><code>Point(Point&amp; p);
</code></pre>

<p>Which takes a <code>Point&amp;</code>, something which is okay to modify inside <code>Point::Point(Point&amp;)</code>. Thus, you cannot pass <code>p1</code> (or <code>p2</code>) there because you already promised it would never be changed.</p>

<p>Make your constructor</p>

<pre><code>Point(const Point&amp; p);
</code></pre>

<p>and you can use the initialiser list like you do.</p>
",0
8793041,8792763,0,"<pre><code>Point(Point&amp; p);
</code></pre>

<p>Your copy constructor requires a non-<code>const</code> reference to a <code>Point</code>. This means your can't initialise a point from a <code>const</code> reference, which the initialiser list requires. Assignment works because you haven't implemented your own copy-assignment operator, so the implicit one is used.</p>

<p>You should either change the copy constructor to <code>Point(Point const &amp;);</code> or, better still, remove it entirely since it does exactly the same as the implicitly-defined one would. Likewise, there's no point in defining your own destructor unless it either needs to do something, or needs to be virtual or non-public.</p>
",0
14727835,14719170,0,"<p>Your main problem is to understand you can not up-cast, This yields null. you can downcast the dog into animal and use only the min attributes of the parent though,</p>

<p>So this problem can be easily solved like:
1- return vector and use polymorphic flow to do whatever you want later.
2- make some bool or int to check or mark the kind of animal as below. e.g. make it 2 for dogs, This variable is defined in animal class. then use virtual functions to dynamically go to whatever you want at run time. so the below code can be good skeleton for you.</p>

<pre><code>class Animal
{
    int type;
    virtual void setType()=0;
    virtual int getType()=0;
};

class Dog :public Animal
{
    void setType()
    {
        type = 2;
    }
    int gettype()
    {
        return type;
    }
}; 
</code></pre>

<p>Have fun.</p>
",0
8733012,8732919,2,"<p>With these sorts of declaration tests, it's often easiest to use a tool like <code>cdecl</code>.  I think in this case what the book is looking for is:</p>

<pre><code>c
</code></pre>

<p>is a pointer:</p>

<pre><code>*c
</code></pre>

<p>to an array:</p>

<pre><code>(*c)[]
</code></pre>

<p>of character strings:</p>

<pre><code>char *(*c)[]
</code></pre>

<p>Or from <code>cdecl</code>:</p>

<pre><code>cdecl&gt; declare c as pointer to array of pointer to char
char *(*c)[]
</code></pre>

<p>I just made a guess about what the book expects, but since the next request is ""pointer to a pointer to a character"", it would be weird for the two to be asking the same thing.</p>
",1
8733016,8732919,0,"<pre><code>typedef char* character_string;
typedef character_string[20] array_of_character_strings;
typedef array_of_character_strings* pointer_to_array_of_character_strings;
pointer_to_array_of_character_strings ptr; //done
</code></pre>

<p>or:</p>

<pre><code>char*(*var)[20];
</code></pre>

<p>shown at: <a href=""http://cdecl.ridiculousfish.com/?q=char%2a%28%2avar%29%5B20%5D"" rel=""nofollow"">cdecl.ridiculousfish.com</a>, ""declare var as pointer to array 20 of pointer to char""</p>
",0
8733031,8732919,0,"<p>1) Chapter 5 is about ""Pointers, Arrays and Structures"".
   I don't see any ""typedef's"" skimming the chapter, so I wouldn't use them in this exercise.</p>

<p>2) One could point to ""argv"" as an excellent example of ""A pointer to an array of character strings"":</p>

<pre><code>int main (int argc, char *argv[])
</code></pre>

<p>3) ""c_ptr"" in your first example would certainly work (although maybe a better name
   might be ""c_pp"" ;)):</p>

<pre><code>char* c[] = {""foo"", ""bar"", ""baz""};
char** c_ptr = c;
</code></pre>

<p>'Hope that helps!</p>
",0
8733047,8732919,0,"<p>Break it down into steps:</p>

<ol>
<li><p>A pointer to an array: <code>T (*p)[N]</code></p></li>
<li><p><code>T = char const *</code> gives you: <code>char const * (*p)[N]</code></p></li>
<li><p>We initialize a pointer with the address of an existing thing, so make an array first:</p>

<p><code>char const * arr[] = { ""hello"", ""world"" };</code></p></li>
<li><p>Now initialize the guy from (2): <code>char const * (*p)[2] = &amp;arr;</code></p></li>
</ol>
",0
9147873,9147858,3,"<p>Maybe the output  is just getting scrolled up, try outputting the values to a file, or try adding another line wherein the user is forced to enter a key value like ""Press enter"" before the next line is printed.</p>
",0
9147876,9147858,8,"<p>I don't see anything wrong with the code. Are you using Windows command prompt?</p>

<p>Your buffer size might not be long enough and the output is getting cut off. Right click on the command prompt title bar > properties > height and increase it</p>
",0
9147879,9147858,2,"<p>Your code works correctly, but your console window can only display 295 (365 - 70) lines at a time. This means that only the last 295 lines of output will be displayed.</p>
",0
9147892,9147858,0,"<p>As stated above, it looks like a console related issue, I don't know what do you use to connect. Try changing the cout line to: <code>cout&lt;&lt;i&lt;&lt;"" "";</code> and see that it prints everything.</p>
",0
11523498,11522926,0,"<pre><code>typedef std::map&lt;float, float&gt; Leafs;
typedef std::map&lt;float, Leafs&gt; Node;

Node root;
</code></pre>

<p>populate tree in this way:
let's say you want to add (a,b,c)</p>

<pre><code>Leafs l;
l[ b ] = c;
root[ a ] = l;
</code></pre>

<p>then when you add new value use <strong>find</strong> (check std::map::find method description) method to check if value exists. This should be fast enough solution of this 'problem'</p>
",0
11524048,11522926,2,"<p>Since you want to compare all the points with all the the other points, you can do an algorithm like the following. Assume a data structures like this:</p>

<pre><code>struct Data {
    double x_, y_, z_;
    bool skip;
    const std::pair&lt;double, double&gt; &amp; xy () const {
        return std::pair&lt;double, double&gt;(x, y);
    }
};

std::vector&lt;Data&gt; file;
typedef std::multimap&lt;std::pair&lt;double, double&gt;, unsigned&gt; PointMap;
PointMap xyline;
</code></pre>

<p>Then when you read in the file, you search the <code>xyline</code> to see if the current point already exists or not. If so, update the current point and the <code>file</code> vector accordingly (since you know the line numbers of all the matching points, you can modify all matches or only the latest one, your choice). Then insert the current point associated with the current line, and then iterate to the next line in the file.</p>

<p>After the file is processed, write out the contents of <code>file</code>. Then, you can use the output to replace the existing file if you so choose.</p>

<pre><code>void update (PointMap::iterator first, PointMap::iterator last, Data &amp;d) {
    //... revisit all matching points and decide which to keep
}

Data d;
std::ifstream ifile;
std::ofstream ofile;
ifile.open(""input.dat"");
while (ifile &gt;&gt; d.x_ &gt;&gt; d.y_ &gt;&gt; d.z_) {
    PointMap::iterator i = xyline.find(d.xy());
    if (i != xyline.end()) {
        update(i, xyline.upper_bound(d.xy(), d);
    }
    xyline.insert(i, std::pair&lt;d.xy(), file.size());
    file.push_back(d);
}

ofile.open(""output.dat"");
for (size_t i = 0; i &lt; file.size(); ++i) {
    d = file[i];
    if (!d.skip)
        ofile &lt;&lt; d.x_ &lt;&lt; "" "" &lt;&lt; d.y_ &lt;&lt; "" "" &lt;&lt; d.z_ &lt;&lt; ""\n"";
}
</code></pre>
",0
8755695,8755658,10,"<p>There's no difference, the compiler works out the address at compile time and dispatches execution to it in one step at run-time (if it doesn't inline it, which it's equally able/likely to do with either).</p>
",1
11179436,11179388,3,"<p>Variadic templates and initializer lists might work:</p>

<pre><code>struct Table
{
    std::vector&lt;double&gt; data;

    template &lt;typename ...Args&gt;
    Table(Args &amp;&amp;... args)
    : data({std::forward&lt;Args&gt;(args)...})
    {  }
};
</code></pre>
",3
16430026,16430002,3,"<p>There is no such thing as a global naming convention. At the time you know by what naming convention, you can look up the answer in it.</p>
",0
16430041,16430002,7,"<p>If you are trying to adhere to a specific naming convention, please name it. As the other answer explains, there is no global ""C++ Rule"" regarding naming conventions.</p>

<p>If you are using Hungarian notation, I believe that the convention is indeed to prefix 'I' as you did for 'IName'.</p>

<p><strong>Note:</strong> <em>Whilst there is no ""interface"" as such in C++, you can define classes with only pure virtual methods and no member variables.</em></p>
",0
16430205,16430002,11,"<p>As opposed to Oracles Java coding conventions, there is no ""The"" naming convention for C++. </p>

<ul>
<li><p>If you are working on a project for some company you should follow their naming conventions. If there are no documented conventions - look around the code base and try to follow the swarm, consistency is the key. </p></li>
<li><p>If you are starting something on your own, many find <a href=""https://google.github.io/styleguide/cppguide.html"" rel=""nofollow noreferrer"">google's c++ coding conventions</a> as a good start.</p></li>
</ul>
",6
8790990,8790923,2,"<p>When you set the entry point to <code>WinMain</code>, Windows doesn't give your program a console window, because <code>WinMain</code> is for programs with GUIs that don't need a console window. Your program is indeed running, though with no GUI you don't see anything happen.</p>
",9
8791732,8790923,7,"<p>A typical application should not mess up with <code>Entry point</code> setting of linker. Entry point should be set on a function included in the standard runtime library (which is <code>wWinMainCRTStartup</code> for unicode application for windows subsystem). This function does stuff like the proper initialization of CRT and creation of global objects. By rerouting entry point to your <code>WinMain</code> you will get undefined behavior unless you know precisely what you are doing and somehow implementing CRT initialization in your own <code>WinMain</code>. In my opinion the resulting size decrease will be negliable and the whole affair is hardly worth the risk.</p>
",7
8799209,8790923,0,"<p>For reference, here is the full program :</p>

<pre><code>#include &lt;Windows.h&gt;

// forward declarations
LRESULT CALLBACK WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); // WindowProcedure function

// The entry point into a windows program
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int  windowStyle )
{
// create and register a local window class &gt; exit on failure
WNDCLASSEX wcx;
HINSTANCE zhInstance = GetModuleHandle(NULL);
wcx.cbSize = sizeof(WNDCLASSEX);                // size of structure
wcx.style = CS_HREDRAW | CS_VREDRAW;            // redraw if size changes
wcx.lpfnWndProc = WndProc;                      // window procedure
wcx.cbClsExtra = 0;                             // no extra class memory
wcx.cbWndExtra = 0;                             // no extra windows memory
wcx.hInstance = zhInstance;                     // handle to instance (owner)
wcx.hIcon = LoadIcon(NULL, IDI_APPLICATION);    // predefined icon 
wcx.hCursor = LoadCursor (NULL, IDC_ARROW);     // predefined arrow
wcx.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//(HBRUSH) (COLOR_WINDOW + 1);// white background brush
wcx.lpszMenuName = NULL;                        // name of menu resource
wcx.lpszClassName = TEXT(""BasicWindow"");        // name of window class
wcx.hIconSm = (HICON)LoadImage(zhInstance,              // small class icon 
    MAKEINTRESOURCE(5),
    IMAGE_ICON, 
    GetSystemMetrics(SM_CXSMICON), 
    GetSystemMetrics(SM_CYSMICON), 
    LR_DEFAULTCOLOR); 

if (!RegisterClassEx(&amp;wcx))
{
    MessageBoxA(0, ""Error registering window class!"",""Error"",MB_ICONSTOP | MB_OK);
    DWORD result = GetLastError();
    return 0;
}

// create window &gt; exit on failure
HWND hwnd; // the window handle
hwnd = CreateWindowEx(
    WS_EX_STATICEDGE, 
    wcx.lpszClassName, 
    TEXT(""Basic Window""), 
    WS_OVERLAPPEDWINDOW,
    CW_USEDEFAULT,
    CW_USEDEFAULT,
    320,
    240,
    NULL,
    NULL,
    zhInstance,
    NULL);

if (hwnd == NULL)
{
    MessageBoxA(0,""Error creating window!"",""Error"",MB_ICONSTOP | MB_OK);
    return 0;
}

// show window
ShowWindow(hwnd, SW_MAXIMIZE);
// send a WM_PAINT message to the window
UpdateWindow(hwnd);

// enter message loop, break out of loop if there is an error (result = -1)
MSG msg;    // for storing the windows messages
int status; // for storing the status of the windows message service where -1 = error, 0 = WM_QUIT, n = any other message)
while ((status = GetMessage(&amp;msg,(HWND) NULL,0,0)) != 0 &amp;&amp; status != -1)
{
    TranslateMessage(&amp;msg);
    DispatchMessage(&amp;msg);
}

return msg.wParam;
    UNREFERENCED_PARAMETER(lpCmdLine);
}

LRESULT CALLBACK WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
switch(message)
{
case WM_CLOSE:
    DestroyWindow(hWnd);
    break;
case WM_DESTROY:
    PostQuitMessage(0);
default:
    return DefWindowProc(hWnd,message,wParam,lParam);
}
return 0;
}
</code></pre>
",0
11529119,11529086,1,"<p>If <code>CODON_M0</code> has two data members of type <code>CODON_alphabet</code>, they will be initialized before the constructor enters and thus the constructors called.</p>
",1
8740110,8740085,9,"<p>Due to temporal necessity, the value of <code>argument</code> before calling <code>myFunction</code> will be passed. This is simply because you don't have the return value yet.</p>

<p>The parameters to a function call have to be evaluated before the call. The order of evaluation <em>between parameters</em> is unspecified, but you only have one, so it is evaluated. Whatever it is at that point (before the call) is used, then the function is called. When the function returns, after being run, the return value is assigned to <code>argument</code>.</p>
",0
8740182,8740085,-5,"<p>Value assigned BEFORE the call will be used inside the function.</p>
",10
8740400,8740085,2,"<p>+1 - @peachykeen</p>

<p>Also may I add that if <code>argument</code> isn't assigned a value before being passed to <code>myFunction</code> then depending on the compiler and settings, <code>argument</code>'s value may be indeterminate before use. </p>

<p>This means that it's value may not be <code>null</code> or zero (depending on type).</p>
",1
14181509,14181448,1,"<p>You can create a <code>struct</code> with two integers if you don't want to use a <code>long</code>.</p>

<p>Like this:</p>

<pre><code>struct BigInteger{
  int lowerInt;
  int upperInt;
}; 
</code></pre>

<p>And then you can add, subtract, multiply or divide these structures according to the various algorithms. For example to multiply you can use the Shift-And-Add multiplier algorithm.</p>

<p>But doing this has serious performance issues. Use the full language instead of limiting yourself.</p>

<p>PS: what language problem is it? C or C++?</p>
",7
16403741,16403626,5,"<p>The C++ standard library classes by and large all implement strong value semantics, which means that each object owns all its data, and so the lifetime of the object is easy to reason about. While a reference-tracking implementation <em>might</em> be possible, it would come at a considerable complexity cost, and that doesn't fit the ""don't pay for what you didn't ask for"" philosophy of C++.</p>

<p>There have long been discussions about non-owning string-like classes (something like <code>string_ref</code> and <code>array_ref</code>, if you want to search for it), which would only be <em>views</em> on existing strings. This would put the burden on the user to ensure that the lifetime of the underlying shared data fits the application. It might become part of the standard in the future, but search around for existing implementations if you're interested.</p>
",0
9825212,9825162,1,"<p>By using a reference you are explicitly stating that it cannot be <code>0</code>. It makes sense when some value in code cannot be uninitialised. On the other hand pointers are useful when value can be either initialised or uninitialised. You can check it by comparing to <code>0</code>.</p>
",0
9825229,9825162,0,"<p>Dereferencing a null pointer to create a reference will result in undefined behavior.</p>

<p>See also <a href=""https://stackoverflow.com/questions/9383684/is-there-a-platform-or-situation-where-dereferencing-but-not-using-a-null-poin"">Is there a platform or situation where dereferencing (but not using) a null pointer to make a null reference will behave badly?</a></p>

<p>and <a href=""https://stackoverflow.com/questions/57483/what-are-the-differences-between-pointer-variable-and-reference-variable-in-c"">What are the differences between a pointer variable and a reference variable in C++?</a></p>
",0
9825265,9825162,1,"<ul>
<li><p>A reference cannot be null, as you said.</p></li>
<li><p>A reference is always initialized. A non-null pointer can still be not initialized at all.</p></li>
<li><p>A reference is stable. You cannot make the reference point first to A, and then to B. Once initialized, it is an alias of one and the same object</p></li>
<li><p>The syntax of references is somewhat neater.</p></li>
</ul>
",0
9825275,9825162,1,"<p>A reference to a pointer that can be null is not the same as a reference to the actual value or object. The pointer's value can be null, but the actual pointer is not! </p>

<p>Using references gives you peace of mind knowing that you are safe and weird stuff won't happen. So when you don't need the features of actual pointers, you should always use references. In general (and there are always exceptions) use pointers only if:</p>

<p>a. you need dynamic allocation of memory during execution.</p>

<p>b. you actually need pointer arithmetic (p++)</p>

<p>c. you need to save allocated objects inside containers, but in this case it's a generally good practice to wrap your pointers with something like shared_ptr.</p>
",0
9825284,9825162,1,"<p>The flexibility of pointers comes with a price:  every time you see one, you have to consider that you may be using that flexibility somewhere.  That's more to have to watch out for...more to debug..etc.  References, being simpler and less featurish, carry less mental baggage.</p>

<p>Add to that, the syntax is less cluttered with <code>*</code>s and <code>-&gt;</code>s.  :)</p>
",0
9825324,9825162,0,"<p>Usually, references are just syntactic sugar of pointers which means whereever you use one, can be used other as well (well, not always, though). But sometimes, references make more sense than pointers, especially when  you define a function whose argument(s) cannot be null, or checking for null argument is that elegant. In such cases, you simply make them references. One such example is <code>swap</code> function:</p>

<pre><code> template&lt;typename T&gt;
 void swap(T &amp; a, T &amp; b)
 {
       T temp(a);
       a = b;
       b = temp;
 }
</code></pre>

<p>If one uses pointers, then it would become this:</p>

<pre><code> template&lt;typename T&gt;
 void swap(T * a, T * b)
 {
       //do you want to check for null here?
       T temp(*a);
       *a = *b;
       *b = temp;
 }
</code></pre>

<p>I think, most C++ programmers will find the first solution using reference elegant, and the second solution <em>unnecessarily</em> cumbersome.</p>
",2
9825347,9825162,1,"<p>When in doubt, go to the source (Stroustrup): <a href=""http://www2.research.att.com/~bs/bs_faq2.html#pointers-and-references"" rel=""nofollow"">http://www2.research.att.com/~bs/bs_faq2.html#pointers-and-references</a></p>

<p>References are good for operator overloading and copy constructors.</p>

<p>References are guaranteed to not be null and to be initialized.</p>

<p>Using pointers as arguments works well when you want to have arguments that are optional or that can be ignored when the value is NULL.</p>
",0
9201327,9201291,1,"<p>Outside of a function, static means local to that compilation unit. You can achieve the same effect with an anonymous namespace.</p>
",0
9201343,9201291,3,"<p>Yes.</p>

<p>The lifetime of a static object is the life of the program and the linkage of the object is internal if the variable is declared at file scope (and no linkage if defined at block scope). </p>
",0
9201347,9201291,1,"<p>Sure, of course, for example:</p>

<pre><code>int sequence()
{
    static int result = 0;
    return ++result;
}
</code></pre>

<p>So, here, the result variable will continue to exist outside the scope of the function and constantly increase every time you enter the function.</p>
",0
9201357,9201291,1,"<p>Two other places:</p>

<ol>
<li><p>Global variables and functions </p>

<ul>
<li>Global <code>static</code> variables (or functions) are local to that compilation unit and cannot be ""seen"" from other compilation units</li>
</ul></li>
<li><p>Local variables</p>

<ul>
<li><code>static</code> local variables are initialised once when their declaration is crossed for the first time (this is useful for doing things only on the first time a function is called), and after that they retain their value even after the function has returned and is called again</li>
</ul></li>
</ol>

<p>Note that these different uses of <code>static</code> really have nothing to do with each other. <code>static</code> means different things depending on where you use it, much like <code>const</code>.</p>
",0
9201863,9201291,0,"<p>It depends what you mean by a static variable. The <code>static</code> keyword has different semantics depending on the situation in which you use it.</p>

<p>Member variables, when declared as static, have static storage duration. This means the lifetimes of these variables lasts for the duration of the program. This is the common meaning of a 'static variable'. There are 3 cases under which a variable will have static storage duration:</p>

<ol>
<li>When the <code>static</code> keyword is used on a local (function scope) variable.</li>
<li>When the <code>static</code> keyword is applied to a class member variable.</li>
<li>Any variable that does not have dynamic or thread storage duration and is not a local variable.</li>
</ol>

<p>Example:</p>

<pre><code>struct foo
{
  static int x; // This has static storage duration
};

void bar()
{
  static int y = 5; // This has static storage duration
}

int z = 1; // This has static storage duration
</code></pre>

<p>So to answer your question as if it were ""Can variables have static storage duration when not members of a class?"", the answer is yes. A global or namespace scope variable has static storage duration by default. A function scope variable declared as static also has static storage duration.</p>

<p>However, the <code>static</code> keyword has another meaning when it is used on variables in global or namespace scope. For these, <code>static</code> specifies that the variable has internal linkage. That is, they can only be referred to within the same translation unit.</p>

<p>Example:</p>

<pre><code>static int i = 5; // This has internal linkage
</code></pre>
",0
12862054,12861832,0,"<p>Well .. the compiler is telling you, according to the words you said in the error </p>

<p>Your usage of line <code>curr -&gt; item</code> is invalid in function <code>insert</code> as the struct doesn't have a member called <code>item</code> it has a member called <code>data</code></p>

<p>And your usage of line <code>curr -&gt; theData</code> in function remove is invalid for the same reason ... </p>

<p>Also check your insert, </p>

<p>I believe the code </p>

<pre><code>curr -&gt;  next = prev;
prev -&gt; next = curr;
</code></pre>

<p>Will make <code>curr</code> point to <code>prev</code>, and <code>prev</code> to <code>curr</code> ?! Close loop?! Is that what you want?! </p>

<p>Don't you mean</p>

<pre><code>curr -&gt; next = prev -&gt; next;
prev -&gt; next = curr;
</code></pre>
",0
12861920,12861832,2,"<p>The error message says it all.</p>

<p>This line which causes the error accesses <code>item</code> member of <code>ListNode</code> struct</p>

<pre><code>curr -&gt; item = item;
</code></pre>

<p><code>ListNode</code> doesn't have such a member, probably you meant <code>data</code> instead of <code>item</code>.</p>

<p>The same applies to the another line with the error</p>

<pre><code>theData = curr -&gt; theData;
</code></pre>
",2
12862006,12861832,0,"<p>The compiler refers to your using <code>item</code> and <code>theData</code> as a data member in this line:</p>

<pre><code>    curr -&gt; item = item;
</code></pre>

<p>where you probably meant:</p>

<pre><code>    curr -&gt; data = item;
</code></pre>

<p>and this line:</p>

<pre><code>theData = curr -&gt; theData;
</code></pre>

<p>where you probably meant:</p>

<pre><code>    curr -&gt; data = theData;
</code></pre>
",0
8757218,8757198,1,"<p>In every implementation I've looked at, it's calculated every time - in O(1) - by subtracting begin from end.  So, it makes very little difference.  The compiler may or may not optimise away the ""calculation"", but the time is so miniscule as to be irrelevant for all but the most desperate sitatuations.</p>

<p>Use whatever's more maintainable in your opinion: whatever reads best, localises the logic best etc..  It's arguably noteworthy that in using size() you ensure you accurately track the end of the vector even if there are deletions or insertions made inside the loop body, so there can be functional reasons to prefer (or avoid) calling size() repeatedly.</p>

<p>Note that for STL lists size() is NOT constant time - it's linear.</p>
",5
8757228,8757198,1,"<p><a href=""http://www.cplusplus.com/reference/stl/vector/size/"" rel=""nofollow"">http://www.cplusplus.com/reference/stl/vector/size/</a> suggests that the complexity of the operation is constant. This means that the size won't be recalculated each time you call <code>size()</code>, or that the overhead is in most cases negligible. So using it like it's in your code is okay: this won't be the bottleneck of your code. (Unless this is a tight inner loop, where every optimization is going to bring a lot.)</p>

<p>Moreover, you'll be on a safer (but not completely safe!) side if the vector is going to be changed inside the loop.</p>
",2
8757251,8757198,8,"<p>That is implementation defined. Assuming that implementations want to provide efficient standard libraries, the two most probable implementations are:</p>

<ul>
<li>subtracting the pointer pointing to the beginning of the storage from the pointer pointing to one after the end of the storage, and returning the result of that computation.</li>
<li>returning a size variable that is kept in sync for every operation in the vector.</li>
</ul>

<p>In any case the standard requires the complexity to be constant, and you should not really worry about it. Also compilers often optimize enough to make no difference to storing your size on your own.</p>
",0
8757259,8757198,5,"<p>Use iterators instead of such a loop for more flexibility and genrosity:   </p>

<pre><code>std::vector&lt;int&gt;::const_iterator iter = myVector.begin();

for(iter; iter!= myVector.end(); ++iter)
{

}
</code></pre>

<p>This ensures that if you change your container at later stage of development you have less tightly coupled code.</p>
",4
8757368,8757198,0,"<p>If you look at the implementation of vector::size()</p>

<pre><code>size_type size() const
{   // return length of sequence
        return (_Mylast - _Myfirst);
}
</code></pre>

<p>where _Mylast and _Myfirst are pointers.</p>

<p>Its just a pointer arithmetic and should be an atomic operation. Hence it shouldn't be an overhead!</p>
",5
8758230,8757198,1,"<p>Perhaps you are actually wondering whether the compiler can figure out that the value returned by the <code>size()</code> function never changes and <em>hoist</em> it out of the loop. While this seems sensible, the compiler would have to be able to prove that the hoisting produces the exact same behaviour as the version you have written (i.e. ""as if"" <code>size()</code> was called every time), and there are limits to how far the compiler can see, or indeed to how far this is actually provable.</p>

<p>Therefore, if you know that you aren't changing the size of the container, you should write the hoist manually:</p>

<pre><code>// index version:
for (std::size_t i = 0; end = v.size(); i != end; ++i) { work_with(v[i]); }

// iterator version:
for (auto it = v.begin(), end = v.end(); it != end; ++it) { work_with(*it); }
</code></pre>

<p>Calls to <code>std::vector::size()</code> have constant complexity, i.e. their cost is independent of the number of elements in the vector, but there may be a cost nonetheless. In the best circumstances you are simply <em>reading</em> a variable (so there's no difference in the hoisted and non-hoisted version of loops bar one copy), but it's also feasible that the implementation performs a pointer subtraction.</p>
",0
8758400,8757198,0,"<p>Computing the <code>size()</code> for a <code>std::vector</code> takes constant time but the computation may be more involved than the difference between two pointers. Although this seems like a cheap computation it adds constraints on the available registers. Also, other implementations of <code>std::vector</code> take even more effort in <code>size()</code> but make other operations more efficient.</p>

<p>For example, for many use cases it is better to represent a <code>std::vector</code> with just one pointer to the start of the range and the control data prepended to this range. Oddly enough this happens how memory allocated using an array allocation is often layed out anyway. The control data would contain two pointers (one to the end of the range, the other to the capacity). Getting the size in this case consists of an address adjustment (with fixed size, though), a pointer dereference, and a subtraction. Still not a lot but the less you do in a [tight] loop, the faster it runs (in most cases).</p>

<p>The upshot is: get the <code>size()</code> and the <code>end()</code> just once unless you container is changing its size. If it is changing the size it depends on the kind of container whether you should recompute things: e.g. for a <code>std::list</code> you dont need to get the <code>end()</code> again (and you don't want to get its <code>size()</code> at all inless you absolutely have to). I seem to recall that Scott Meyers has a discussion of this topic in ""Effective STL"" but I don't recall whether he says what I just did (or if he is just wrong ;).</p>
",0
8757829,8757815,5,"<p>1.5 is double, use 1.5f for float, what it actually does:</p>

<p><code>float a = (float)(1.5 * (double)b)</code></p>
",0
8758072,8757815,3,"<p><code>1.5</code> is a floating point literal, a double value. C++03 <code>2.13.3 Floating literals</code> has this to say:</p>
<blockquote>
<p>A floating literal consists of an integer part, a decimal point, a fraction part, an e or E, an optionally signed integer exponent, and an optional type suffix. ... The type of a floating literal is double unless explicitly specified by a suffix.</p>
</blockquote>
<p>Section <code>13.3.3.1 Standard conversion sequences</code> defines the way in which conversions are handled but it's a little dry to repeat here. Suffice to say that floating point promotion is done and section <code>4.6 Floating point promotion</code> states that:</p>
<blockquote>
<p>An rvalue of type float can be converted to an rvalue of type double. The value is unchanged.</p>
</blockquote>
<p>Hence the <code>float b</code> is promoted to a double to perform the multiplication.</p>
<p>Then the calculation is performed using (effectively) a temporary <code>double</code> and the result is shoe-horned back into the <code>float a</code>.</p>
<p>So, effectively:</p>
<pre><code>float b = something;

double xyzzy0 = 1.5;
double xyzzy1 = (double)b;
double xyzzy2 = xyzzy0 * xyzzy1;
float a = xyzzy2;
</code></pre>
<p>That last step may be problematic. Section <code>4.8 Floating point conversions</code> (which <em>doesn't</em> include the safer promotions like <code>float</code> to <code>double</code>) states:</p>
<blockquote>
<p>An rvalue of floating point type can be converted to an rvalue of another floating point type. If the source value can be exactly represented in the destination type, the result of the conversion is that exact representation. If the source value is between two adjacent destination values, the result of the conversion is an implementation-defined choice of either of those values. Otherwise, the behavior is undefined.</p>
<p>The conversions allowed as floating point promotions are excluded from the set of floating point conversions.</p>
</blockquote>
<p>In other words, if the multiplication results in a value outside the range of a float, all bets are off. This is likely to happen if <code>b</code> is about at 67% of the maximum absolute value of a float (positive or negative, doesn't matter).</p>
",0
13484023,13483990,0,"<p>If I were you, I'd allocate the objects on the heap, and would store smart pointers (e.g. <code>shared_ptr</code>) to them in both the set and the vector.</p>

<p>In my view this will drastically reduce the likelihood of memory- or pointer-related bugs. It would also decouple the lifetimes of the set and the vector.</p>
",0
13484031,13483990,1,"<p><code>I'm thinking that might not be a great idea</code>, why do you think that? The only thing I see you is that you could do is to use something along the lines of a smart pointer instead of a plain pointer to clarify ownership, and avoid memory leak mistakes that come along with them.</p>

<p>Or like suggested by Jerry, iterators are even better!</p>
",0
13484048,13483990,0,"<p>Have you tried something like</p>

<pre><code> typedef std::shared_ptr&lt;A&gt; APtr

 std::set&lt;APtr, compareClassThatTakesAPtr&gt; aSet;
 aSet.insert(new A());

 std::vector&lt;APtr&gt; aVec;

 //...
 aVec.push_back(aSet.begin());
</code></pre>

<p>Now that they're on the heap, <code>set</code>/<code>vector</code> aren't managing instance of A directly. Instead you take responsibility for the fact that your <code>set</code> and <code>vector</code> all point to the same objects.</p>
",0
8749534,8749440,5,"<p>C++11 <a href=""http://en.wikipedia.org/wiki/Variadic_template#C.2B.2B11"" rel=""noreferrer"">variadic templates</a> can do this for you.</p>

<p>You already have your new derived class:</p>

<pre><code>class Multiply: public Base {
public:
    Multiply(int i, int amount) { integer = i * amount; }
};
</code></pre>

<p>Then change your factory:</p>

<pre><code>template&lt;typename T, typename... Args&gt;
Base* createBaseObject(Args... as) {
    return new T(as...);
};
</code></pre>

<p>And, finally, allow the arguments to be deduced:</p>

<pre><code>objects.push_back(createBaseObject&lt;Multiply&gt;(3,4));
</code></pre>

<h3><a href=""http://www.ideone.com/bXqFY"" rel=""noreferrer"">Live demo.</a></h3>

<hr>

<p>As others have said, though, it does all seem a little pointless. Presumably your true use case is less contrived.</p>
",8
8749482,8749440,3,"<p>Why not provide multiple overloads with templated parameters? </p>

<pre><code>template&lt;typename TBase, TArg&gt;
Base* createBaseObject(TArg p1) {
    return new TBase(p1);
};

template&lt;typename TBase, TArg1, TArg2&gt;
Base* createBaseObject(TArg p1, TArg2 p2) {
    return new TBase(p1, p2);
};
</code></pre>
",2
8749494,8749440,1,"<p>Use variadic templates:</p>

<pre><code>template &lt;typename R, typename ...Args&gt;
Base * createInstance(Args &amp;&amp;... args)
{
    return new R(std::forward&lt;Args&gt;(args)...);
}
</code></pre>

<p>Usage: <code>objects.push_back(createInstance&lt;Gizmo&gt;(1, true, 'a'));</code></p>

<p>It's a bit hard to see why you would want this, though, as you might as well just say:</p>

<pre><code>objects.push_back(new Gizmo(1, true, 'a'));
</code></pre>

<p>Even better would be to declare the vector to carry <code>std::unique_ptr&lt;Base&gt;</code> elements.</p>
",1
13483214,13483096,0,"<p>If the game board is really just a few thousand places large, I wouldn't care about wasting space. For example</p>

<pre><code>10000 places * sizeof(Marble) = 10000 * 100 bytes ~ 1 MB
</code></pre>

<p>Not a big amount of memory by today's standards.</p>

<p>If it might grow very large, then you can indeed store your unique Marbles in a set and reference them with a pointer, as @BenRuijl already has shown.</p>
",1
13483505,13483096,0,"<p>Build a class <code>Marble</code> containing a pointer to a <code>MarbleType</code> defining the properties of each marble (for each sort of marble you have one instance of <code>MarbleType</code>). The vector may contain <code>Marble</code>s or shared pointers to <code>Marble</code>s or unique pointers. If the <code>Marble</code> class is small (flyweight pattern), you do not waste space, but nevertheless have a clean and flexible solution. The marble types could be named (e.g. by a string) and be stored in a <code>std::map</code>.</p>
",0
13483532,13483096,0,"<p>Yes, you can do what you are trying to do. You can store pointers in your vector, which pointers point to the Marbles in your set. Or you can store iterators in your vector, again which iterators point to Marbles in your set.</p>

<p>Here is how I would do it with pointers:</p>

<pre><code>// A useful helper funtction -- not required, but useful.
const Marble* Helper(const Marble&amp; m) {
  static std::set&lt;Marble&gt; uniqueMarbles;
  return &amp;*(uniqueMarbles.insert(m).first);
}

// A vector of pointers to marbles
std::vector&lt;const Marble*&gt; m_marbles;

// You can pass temporaries to the helper function, and it returns a permanent pointer
m_marbles.push_back(Helper(Marble(RED, 1.0));

Marble m;
m.setColor(BLUE);
m_marbles.push_back(Helper(m));


// You can reference your marbles
Color c = m_marbles[i]-&gt;getColor();

// Hopefully the following will produce a compiler error message
m_marbles[i]-&gt;setColor(GREEN); // Oops, m_marbles holds const pointers
</code></pre>
",3
13483149,13483096,0,"<p>You should make the vector contain <em>pointers</em> to Marble structures:</p>

<pre><code>std::vector&lt;Marble*&gt; m_marbles;
</code></pre>

<p>A pointer doesn't take up much space and you can still use <code>Marble</code> as a base class.</p>
",1
12333765,12333754,31,"<p>In C++ it's</p>

<pre><code>Method::printStuff();
</code></pre>

<p>and you have to declare the method as <code>static</code>.</p>

<pre><code>class Method{
    public:
    static void printStuff(void){
        cout &lt;&lt; ""hahaha!"";
    }
};
</code></pre>

<p><code>::</code> is called the <em>scope resolution operator</em>. You can call the method with <code>.</code> if it's on a class instance, but the instance is not required (it being static and all...).</p>
",0
11546434,11546311,2,"<p>It doesn't work because you are trying to <em>assign</em> something to a reference member (which, of course, does not affect the reference itself, but rather the referenced object). You are not <em>initializing</em> the reference in your code. References can only be initialized at the very moment they are ""born"", their initialization cannot be postponed for later. </p>

<p>When you do <code>new S</code>, you are asking the compiler to use the compiler-generated default constructor for <code>S</code>. The default constructor for <code>S</code> cannot be generated, since the compiler does not know how to initialize reference member <code>a</code>. References in C++ cannot be left uninitialized, they cannot be default-initialized, and they value-initialized. Specific initializer always has to be supplied explicitly.</p>

<p>Unfortunately in C++89/C++03 there's no way to do that for a dynamically allocated <code>struct S</code> (as defined in your code). You have to provide your own constructor for this.</p>

<p>In C++11 you can use uniform initailization syntax </p>

<pre><code>S *s = new S { a };
</code></pre>

<p>which will attach the <code>S::a</code> member of newly allocated object to <code>a</code>.</p>
",0
11546350,11546311,3,"<p>You need to initialize reference members within the initializer list of a constructor. Even the body of the constructor is too late, because the member has already been initialized, and can't be changed.</p>

<p>In your code, you are using the (compiler-provided) default constructor, and then trying to set the reference after the object has been constructed.</p>

<p>Try this:</p>

<pre><code>struct S
{
    S(A&amp; a_) : a(a_){} 
    A&amp; a;
};

int main()
{
    A a;

    S* s=new S(a);
...
</code></pre>
",5
17781267,17781231,1,"<p>Then return in json or xml or some other format. </p>

<p>or ASN.1 may be more compact </p>
",4
17781290,17781231,1,"<p>You cannot do that (at least, not with conventional C++), and I cannot think a good reason for which you should do that. If your internal struct is not the way you want to publish your information, find a suitable way/data type and define a conversion.</p>
",0
17781339,17781231,8,"<p>Instead of passing a structure you could pass an handle that contains a pointer to the real object:</p>

<pre><code>// public_interface.h

struct MySecretStruct; // I don't want to publish what's inside

struct WhatYouCanSee
{
    MySecretStruct *msp; // The ""P""ointer to ""IMPLE""mentation

    WhatYouCanSee(int a, double b);
    ~WhatYouCanSee();
    WhatYouCanSee&amp; operator=(const WhatYouCanSee&amp;);
    WhatYouCanSee(const WhatYouCanSee&amp;);

    void method1();
    void method2(int x);
};
</code></pre>

<p>The methods will be just wrappers to calls to methods of the real object.</p>
",3
17781378,17781231,7,"<p>What you want is the pimpl idiom.</p>

<p><a href=""http://c2.com/cgi/wiki?PimplIdiom"" rel=""noreferrer"">Pimple Idiom</a></p>

<p>Basically you declare a class that has an interface to the secret structure and holds a pointer to an instance of the secret structure. You can forward declare the struct without specifying implementation details. Then in the CPP file you access the secret structure. This can be provided in a header/binary format if you are providing it to 3rd parties.</p>
",0
15815695,15815649,3,"<p>To use pass by reference your functions should be declared like</p>

<pre><code>typedef unordered_map&lt;uint64_t, mer*&gt; mer_map;
void test_pass_by_ref3(mer_map&amp; kmers) {
}

void test_pass_by_ref2(mer_map&amp; kmers) {
    test_pass_by_ref3(kmers);
}

void test_pass_by_ref(mer_map&amp; kmers) {
    test_pass_by_ref2(kmers);
}
</code></pre>

<p>This will work normal for the access operator</p>

<pre><code>mer_map[key]
</code></pre>

<p>and to access member functions something like </p>

<pre><code>mer_map.find(
</code></pre>

<hr>

<p>To pass a pointer they should be of the form</p>

<pre><code>typedef unordered_map&lt;uint64_t, mer*&gt; mer_map;
void test_pass_by_poi3(mer_map *kmers) {
}

void test_pass_by_ref2(mer_map *kmers) {
    test_pass_by_poi3(kmers);
}

void test_pass_by_ref(mer_map *kmers) {
    test_pass_by_poi2(kmers);
} 
</code></pre>

<p>However in the pointer version to use the access operator you have to dereference the pointer first.</p>

<pre><code>(*mer_map)[key]
</code></pre>

<p>and to access member functions something like </p>

<pre><code>kmers-&gt;find(
</code></pre>
",0
15815732,15815649,13,"<p>I am guessing your problem is that <code>operator[]</code> is non <code>const</code>, because it adds a default constructed element when accessed with a key that isn't already in the map.
You can use <code>at()</code>, which assumes the key is present and throws an exception otherwise:</p>

<pre><code>typedef unordered_map&lt;uint64_t, mer*&gt; mer_map;

void foo(const mer_map&amp; m)
{
  mer* val = m.at(key);
}
</code></pre>

<p>or use <code>std::unordered_map::find()</code>:</p>

<pre><code>void foo(const mer_map&amp; m)
{
  auto it = m.find(key);
  if (it != m.end())
  {
    // element is in map, use it
    mer* val = it-&gt;second;
  }
}
</code></pre>

<p><strong>Note</strong>: You <em>could</em> also bypass the problem by passing a non-const reference, but by doing so you are saying the function would modify the map. You should only use a non-const reference if you really intend to modify an object.</p>

<pre><code>void foo(mer_map&amp; m)
{
  mer* val = m[key];
}
</code></pre>
",0
15815902,15815649,0,"<p>For <code>map</code> and <code>unordered_map</code> the index operator <code>[]</code> is non-const because calling it with an index that doesn't exist will cause that element to be created.  You use <code>at()</code> if you don't want to create the element.  Then you can use const reference to <code>map</code> or <code>unordered_map</code>.  Be aware that <code>at()</code> will throw if the element does not exist.</p>

<p>You can use an iterator to test for existence:</p>

<pre><code>bool
esists(const mer_map&amp; kmers, uint64_t i)
{
  unordered_map&lt;uint64_t, mer*::const_iterator it = kmers.find(i);
  return it != kmers.end();
}
</code></pre>

<p>Or you could just access mer_maps through iterators in your code.</p>
",0
11587003,11586873,1,"<p>There doesn't appear to be anything wrong with the code you posted, so the problem must be somewhere in the code you <em>didn't</em> post.</p>

<p>My bet would be on some out-of-bounds access that is clobbering the bookkeeping information required by the heap manager.</p>
",0
15815675,15815646,10,"<p>There is no way to do this currently. There is, however, a proposal to introduce <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3499.html"">digit seperators (N3499)</a>. They haven't yet chosen which character they'd like to use as a separator though. The current suggestions are:</p>

<ul>
<li>Space: <code>4 815 162 342</code></li>
<li>Grave accent: <code>4`815`162`342</code></li>
<li>Single quote: <code>4'815'162'342</code></li>
<li>Underscore: <code>4_815_162_342</code></li>
</ul>

<p>Unfortunately, they all have problems as described in the proposal.</p>

<p>You can take the hacky approach  by using a user-defined literal:</p>

<pre><code>long long operator """" _s(const char* cstr, size_t) 
{
    std::string str(cstr);
    str.erase(std::remove(str.begin(), str.end(), ','), str.end());
    return std::stoll(str);
}

int main()
{
    std::cout &lt;&lt; ""4,815,162,342""_s &lt;&lt; std::endl;
}
</code></pre>

<p>This will print out:</p>

<pre><code>4815162342
</code></pre>

<p>It simply removes all of the commas from the given literal and converts it to an integer.</p>
",0
15815836,15815646,0,"<p>What you are looking for is perfectly possible by <code>imbue()</code>ing the I/O stream with the appropriate locale facet (in this case, <a href=""http://en.cppreference.com/w/cpp/locale/num_put"" rel=""nofollow"">num_put</a>).</p>

<p>(This is assuming you are talking about I/O. If you are talking about the source itself, that is not possible as of C++11.)</p>
",7
15815983,15815646,15,"<p>As of C++14, you can use <code>'</code> as a <a href=""https://en.cppreference.com/w/cpp/language/integer_literal#Single_quote"" rel=""nofollow noreferrer"">digit group separator</a>:</p>
<pre><code>auto one_m = 1'000'000;
</code></pre>
<p>Previous versions of C++ did not support this natively. There were two major workarounds:</p>
<ul>
<li><p><a href=""https://stackoverflow.com/a/14220849/1968"">Using user-defined literals in C++11</a>; this would allow you to write code as follows:</p>
<pre><code>auto x = &quot;1_000_000&quot;_i;
</code></pre>
<p>(Writing this as a <code>constexpr</code> would be trickier ¨C?but is definitely possible.)</p>
</li>
<li><p><a href=""https://stackoverflow.com/a/14220401/1968"">Using a straightforward macro</a>, which would allow the following code:</p>
<pre><code>  auto x = NUM(1,000,000);
</code></pre>
</li>
</ul>
",1
15816036,15815646,2,"<p>you can always just define a variadic macro, used like <code>N(123,456,678)</code>. it's a bit more trouble than it's worth, though. in particular, you may have to workaround some visual c++ peculiarities for portable code for counting arguments.</p>
",0
15822139,15815646,5,"<pre><code>int main()
{
   int x = 1e6;
}
</code></pre>
",3
12278560,12278269,0,"<p>The loading, and especially <em>reloading</em> semantics of run-time loaded libraries is very platform and implementation-specific. It is best not to rely on any sort of global state, and instead pass an explicit initialization function to your library. Maybe like so:</p>

<pre><code>library_context_t context;

/* dlopen, dlsym, ... */

library_init(&amp;context);

library_do_thing(&amp;context);

// ...

library_destroy(&amp;context);

// maybe unload, or reuse
</code></pre>

<p>Linux in particular does <em>not</em> reload a library that has already been loaded.</p>
",0
13432243,13432168,2,"<p>When you say ""I cannot access fields in the class Hash"" I guess you mean, that you when you are using <code>Hash&lt;string, T&gt;</code> (for some type <code>T</code>) that you cannot call the overloaded functions from <code>Hash&lt;int, T&gt;</code>. The reason for this is name hiding: when you overload a member function in a derived class, all members with the same name in the base class are hidden unless you make them explicitly available. The way to do it is a <code>using</code> declaration:</p>

<pre><code>template &lt;class T&gt;
class Hash&lt;string, T&gt; : public Hash&lt;int, T&gt;
{
public:
    Hash(int slotN);

    using Hash&lt;int, T&gt;::insert;
    using Hash&lt;int, T&gt;::remove;
    using Hash&lt;int, T&gt;::contains;
    using Hash&lt;int, T&gt;::query;

    bool insert(string key, T val);
    bool remove(string key);
    bool contains(string key);
    bool query(string key, T&amp; val) ;

private:

    // Calculate the String's Hash Key.
    int str2key( string key);
};
</code></pre>

<p>If you just need to access the base class members from your derived class's implementation, you can also access the names using qualification with the class name. For example:</p>

<pre><code>template &lt;typename T&gt;
bool Hash&lt;string, T&gt;::insert(string key, T val) {
    return this-&gt;Hash&lt;int, T&gt;::insert(this-&gt;str2key(key, val);
}
</code></pre>

<p>Thinking a bit more about the question, there is another potential issue: If you access the data members in the base class you need to make sure that the compiler considers the name a dependent name. Otherwise it is looked up in phase one and won't the names in the base because the can only be found in phase two:</p>

<pre><code>template &lt;typename T&gt;
bool Hash&lt;string, T&gt;::insert(string key, T val) {
    int n0 = slotN; // doesn't work: looked up in phase 1
    int n1 = this-&gt;slotN; // OK: name is dependent
    int n2 = Hash&lt;int, T&gt;::slotN; // OK, too
}
</code></pre>

<p>Personally, I wouldn't publicly derive from a class with a different key but I assume you have your reasons. BTW, I assume that your primary declaration of <code>Hash</code> looks something like this although it doesn't matter for the problem, really:</p>

<pre><code>template &lt;typename K, typename T&gt;
class Hash;
</code></pre>

<p>(if it doesn't have any members, I would rather not define it, either).</p>
",0
12256449,12256445,1,"<p>Only you can answer this question.  If they will never be used outside of  <code>C::f</code> then there is no point in polluting the global namespace.  I personally would make them member functions of <code>C</code>. If they can be marked static, then do so, but if they really only matter to <code>f</code>, then just name them something that indicates that, and don't worry about the <code>static</code>.</p>
",1
12256485,12256445,3,"<p>I would suggest using an anonymous namespace:</p>

<pre><code>namespace {
    void C::h1() {/...}
    void C::h2() {/...}
    void C::h3() {/...}
}
</code></pre>

<p>(see <a href=""https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions"">this question</a>)</p>

<p>That way, you guarantee that the function is <em>not</em> visible outside the file it is defined and thus you are in no way polluting your global namespace - which would be my main concern for free static functions. </p>

<p>Making them private members of your class exposes the function interface to the whole world (as you publish your *.h file) and thus just makes the interface more complicated for no reason. (There are more arguments you could add here, for example higher compilation times when changing the definition of a private function)</p>

<p>Searching for ""anonymous namespaces"" results some interesting discussions on this topic.</p>
",3
16920883,16919995,6,"<p>This technique seems to guarantee fragmentation if in-between calls to <code>Check_MemBlock_Size()</code> you do some more dynamic allocation. This is because you release your 50K allocation after allocating your smaller chunk, creating a 50K object hole in memory, which can now be partially filled by some more memory, which your next rebuild of your <code>MemoryBlock</code> cannot use.</p>

<p>You could create a global vector instead of a temporary one to hold this 50K object allocation. Then, when you next rebuild a new <code>MemoryBlock</code>, instead of resizing a new 50K object vector, just swap in the global one. When you want to shrink it, swap out with the global one again. Reusing the 50K reserved memory this way will remove any fragmentation to which this allocation may have contributed.</p>

<p>However, there may be other sources of fragmentation in your program if you are sure there are no leaks. Typically, fragmentation is caused by a mix of large and small objects dynamically allocated, each with varying lifetimes. There are many ways to resolve it, but one way to handle it is with pools of memory. A pool in this sense is a collection of objects of the same size and same lifespan, grouped together within a custom allocator. Deallocation of such memory is returned to its pool. If the memory is never returned to the system with <code>delete</code>, the pool combats fragmentation by allowing future allocations to reuse memory that was allocated previously for the same object type. The pools grow to the peak runtime utilization, and the fragmentation is never worse than that.</p>
",4
10135341,10133680,13,"<p><code>std::basic_istream</code> and <code>std::basic_ostream</code> both take two template types, <code>CharT</code> and <code>Traits</code>. Given a class A that is derived from one of the basic-streams, the <code>Traits</code> data type can be retrieved as</p>

<pre><code>A::traits_type
</code></pre>

<p>According to ¡ì21.2 of the C++ standard, this data type must provide the following member types:</p>

<pre><code>char_type // must be identical to CharT of the basic-stream
off_type
pos_type
</code></pre>

<p>(and some further data types irrelevant to the present question). Given the <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/seekg"" rel=""noreferrer"">way the <code>std::basic_istream&lt;&gt;::seekg()</code> method is defined</a>, the intended meaning of <code>off_type</code> and <code>pos_type</code> is:</p>

<ul>
<li><code>pos_type</code> is used for absolute positions in the stream</li>
<li><code>off_type</code> is used for relative positions</li>
</ul>

<p>So if you want to use the absolute version of <code>seekg()</code>, the data type you should declare is <code>A::pos_type</code> (which is the same as <code>A::traits_type::pos_type</code>). For the relative version it is <code>A::off_type</code>.</p>

<p><strong>Regarding <code>std::streampos</code> and <code>std::streamoff</code>:</strong> These are defined, too, by the standard as the data types that are used for the <em>default</em> version of the <code>traits_type</code>. In other words, if you do not explicitly specify the <code>Traits</code> template parameter, the <code>A::pos_type</code> will <em>in fact</em> be <code>std::streampos</code>, and <code>A::off_type</code> will <em>in fact</em> be <code>std::streamoff</code>.</p>

<p><strong>If you create your own version of <code>Traits</code></strong> and want to use it with standard library templates like <code>std::basic_istream&lt;&gt;</code> etc., you must include typedefs for <code>pos_type</code> and <code>off_type</code> (and a lot of other data types), and ensure they comply with ¡ì27.2.2 and ¡ì27.3 of the standard.</p>
",1
11821122,11819532,1,"<pre><code>vector&lt;int64_t&gt; v;
copy(istream_iterator&lt;int64_t&gt;(cin), istream_iterator&lt;int64_t&gt;(), back_inserter(v)); 
set&lt;int64_t&gt; s;
vector&lt;int64_t&gt; ov; ov.reserve(v.size());
for( auto i = v.begin(); i != v.end(); ++i ) {
  if ( s.insert(v[i]).second ) 
     ov.push_back(v[i]);
}
// ov contains only unique numbers in the same order as the original input file.
</code></pre>
",0
9816658,9816640,-1,"<p>Just check for your three cases, otherwise if any of the characters isn't a digit, handle, otherwise convert and proceed.</p>

<pre><code>string input;
cin &gt;&gt; input;
if (input == ""help"" || input == ""/h"" or input == ""?"")
    help();
else {
    bool convertible = true;
    for(string::size_type i = 0; i &lt; input.size(); ++i) {
        if (!isdigit((int)input[0])) {
            convertible = false;
            break;
        }
    }
    if (convertible) {
        int digit = atoi(input.c_str());
        // do guessing game stuff
    }
    else {
        // handle
    }
}
</code></pre>
",0
9816680,9816640,-1,"<p>if no valid conversion can be perform, atoi returns 0. You can handle it then. </p>
",3
9816885,9816640,0,"<p>Use strtol (http://www.cplusplus.com/reference/clibrary/cstdlib/strtol/) instead of atoi.  </p>

<pre><code>long int strtol ( const char * str, char ** endptr, int base );
</code></pre>

<p>If successful you get a non-zero value AND the endptr has moved.  If the endptr didn't move you know it is a failure. If  a failure and the end pointer moved, you get a 0 and the memory address right before the end ptr is whitespace.</p>
",0
9858805,9858774,5,"<p>I didn't read your code, because its irrelevant. The question is in the title, and that's what I'm answering.</p>

<p>Writing a linked list into a file means writing each member of the linked list into a file. Linked list is a chain of objects that point one to the next one, and when you want to dump it into a file - you just dump each of these objects one after another.</p>

<p>When you need to rebuild your linked list - you read each object from the file, and chain it in a new linked list in the same order (if you saved FIFO - make sure to rebuilt the same, not in reverse). Needless to mention, you should not be saving the pointers and reading them from the file back.</p>

<p>If the question is about something in that enormous chunk of code - you'll have to refine the question and minimize the code.</p>

<p><strong>edit</strong></p>

<p>After you kindly mentioned what the real problem is - then in your <code>tryWrite</code> you're opening the same file over and over again, overwriting whatever was there previously. Obviously, it will leave you with the one last object from the list in the end, because all the previous ones would be overwritten.</p>

<p>You should use <code>ios::out | ios::in | ios::ate</code> or <code>ios::out | ios::app</code>, to seek to the end of the existing data and add, instead of just <code>ios::out</code>.</p>
",8
9858930,9858774,2,"<p>As far as I can tell without transcribing, compiling and running your code, there isn't anything fundamentally wrong with it. I would have extracted the ofstream out of the tryWrite() function, opened it once in writeFile() and pass it in as an argument, rather than opening and closing the file for each node in the linked list.</p>

<p>You MIGHT have some problems reading the linked list back in because you don't seem to do anything to scan for illegal characters in the data. You are using the space character as a delimiter, so you should be careful to make sure that any fields that you save to the file are first escaped (i.e. that you replace any space characters with some kind of escape sequence). Otherwise, when reading things back in, a wayward space could throw things off badly.</p>

<p>For future reference, if you are having problems with your code, rather than just listing all the code and asking what's wrong with it, you should probably try to at least describe what problems you're running into -- what is the output, where in the code do you think you are doing something wrong, etc. </p>
",1
10030060,10030031,5,"<p>That's because you're <strong>not calling</strong> <code>operator +</code>.</p>
<p>You're calling <code>ADD::plus()</code>:</p>
<pre><code>int plus(){
    return Fval+Sval;
}
</code></pre>
<p><code>Fval</code> and <code>Sval</code> are integers, which you're adding up. It's as simple as that.</p>
<h3>EDIT:</h3>
<p>Your code is fishy.</p>
<pre><code>ADD operator+(ADD&amp; add){
    add.Sval *= 1000;
    return add;
}
</code></pre>
<p>Multiplication inside <code>operator +</code>? Really? Also, not that you're modifying the parameter, which you shouldn't. It's not intuitive. If you <strong>really must</strong> do this:</p>
<pre><code>ADD operator+(const ADD&amp; add){
    ADD ret;
    ret.Sval = add.Sval * 1000;
    return ret;
}
</code></pre>
",1
10030282,10030031,0,"<p>The way operator overloading works is that if you have an object of type X, like so:</p>

<pre><code>class X {
    public:
        X( int v ) : x( v ) {}
        int value();
        X operator +( const X&amp; y ) {
            return X( value() + y.value() );
        }
    private:
        int y;
    };
</code></pre>

<p>Now if you declare two objects of type <code>X</code>, say <code>X ex</code> and <code>X wye</code>, you can say </p>

<pre><code>X zed = ex + wye;
</code></pre>

<p>and get the right result.  If type <code>X</code> had more than just a single <code>int</code> field the effect would be more interesting.  For example, you could implement 2D vectors and points, and then operations that add and subtract vectors, to get vectors, add and subtract vectors to/from points to get points, and subtract points to get vectors.</p>

<p>Hopefully this will give you enough of an idea of what's going on to be able to restructure your code to get it to do what you want.  I may have a detail of syntax wrong, as I'm typing as I go.  </p>

<p>Also, I often find the right thing is to declare a friend operator when I want a binary operator:</p>

<pre><code>friend operator + ( vector2D a, vector2D b );
</code></pre>

<p>...</p>

<pre><code>inline operator + ( vector2D a, vector 2D b ) {
    return vector2D ( a.x + b.x, a.y + b.y );
}
</code></pre>
",0
16400369,16400320,4,"<p>Change:</p>

<pre><code>my_message_t Messages::create_message(my_message_type_e type)
</code></pre>

<p>to:</p>

<pre><code>Messages::my_message_t Messages::create_message(my_message_e type)
^^^^^^^^^^
</code></pre>
",0
16400372,16400320,2,"<p><code>my_message_t</code> is a type defined inside of class <code>Messages</code>, so you need:</p>

<pre><code>Messages::my_message_t Messages::create_message(my_message_type_e type)
</code></pre>
",0
16400387,16400320,9,"<p><code>my_message_t</code> is scoped inside the <code>Messages</code> class, so it needs to be qualified when used outside a member of the class:</p>

<pre><code>Messages::my_message_t Messages::create_message(my_message_e type){
^^^^^^^^^^
    // do stuffs
}
</code></pre>

<p>Note that you don't need that in the function parameter list, only the return type; a quirk of the language means that the parameter list is scoped inside the function, and the return type outside.</p>
",4
9175750,9175479,0,"<p><code>unordered_map</code> is a hash table, so as well as a test for equality, you need to supply a hash function. The standard library will provide a hash function for the builtin types and a few others like <code>std::string</code>, which is used in the case of <code>unordered_map&lt;std::string,int&gt;</code>, but there won't be one for <code>struct tm</code>, so you'll have to write one. This must be provided as the third template parameter --- the equality test is the fourth parameter, so you need <code>unordered_map&lt;struct tm,long,myHash,valueComp&gt;</code>.</p>

<p>The hash function must be a callable object type, where the function call operator takes a value of the key type and returns a <code>size_t</code>:</p>

<pre><code>struct myHash{
    size_t operator()(struct tm const&amp;);
};
</code></pre>

<p>It's probably easier to just use a <code>std::map&lt;struct tm,long,compareTm&gt;</code> (and write the ordering comparison <code>compareTm</code>) rather than use an <code>unordered_map</code> and come up with a good hash function.</p>
",2
9823192,9810858,0,"<p>I'm would guess that the constructor for <code>yami::agent</code> throws an exception which is why all the couts are not being run. As Oli mentioned in the comments all member variables of a class will be constructed before the class constructor is entered so <code>yami::agent::agent()</code> will be run before <code>Base::Base()</code> is entered. </p>

<p>Edit:</p>

<p>If you have something like:</p>

<pre><code>class MyObject
{
     yami::agent m_Agent;    
public:
     MyObject::MyObject() { }
};
</code></pre>

<p>then m_Agent will get constructed using its default constructor which is declared as <code>agent(const parameters &amp; options = parameters());</code>. As you mention, for some reason yami::agent::agent() throws an exception which could due to any number of reasons such as a network initialization error, invalid input parameters, etc....</p>

<p>If you want to specify custom parameters to the yami::agent constructor you can do something like:</p>

<pre><code> yami::parameters&amp; GetDefaultYamiOptions (void)
 {
      static yami::parameters options;

            /* The following are just some example parameters */
      options.set_integer(yami::option_names::connection_retries, 1);
      options.set_integer(yami::option_names::connection_retry_delay_spread, 10);
      options.set_integer(yami::option_names::tcp_nonblocking, true);
      options.set_integer(yami::option_names::file_nonblocking, true);
      options.set_integer(yami::option_names::tcp_connect_timeout, 1000);

      return options;
 }

 class MyObject
 {
      yami::agent m_Agent;    
 public:

     MyObject::MyObject() : m_Agent(GetDefaultYamiOptions())
     {
     }
 };
</code></pre>

<p>What parameters you need may be different than what I use and the cause of the issue may not be even related to incorrect parameters. It could well be a low level networking error from the OS or even hardware. </p>
",1
9228253,9228173,5,"<p>Maybe something like this:</p>

<pre><code>#include &lt;iostream&gt;

class Component 
{
public:
    // Constructor, destructor and other stuff

    virtual std::ostream &amp;output(std::ostream &amp;os) const
        { os &lt;&lt; ""Generic component\n""; return os; }
};

class MotherBoard : public Component
{
public:
    // Constructor, destructor and other stuff

    virtual std::ostream &amp;output(std::ostream &amp;os) const
        { os &lt;&lt; ""Motherboard\n""; return os; }
};

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Component &amp;component)
{
    return component.output(os);
}

int main()
{
    MotherBoard mb; 
    Component &amp;component = mb;

    std::cout &lt;&lt; component;
}
</code></pre>
",2
8736141,8736106,1,"<p>Two potential errors:</p>

<ul>
<li>Is Sphere.h in the same directory as main.cpp? </li>
<li>Is Sphere.h named Sphere.h and not sphere.h?</li>
</ul>
",0
8736145,8736106,4,"<p>Sphere.h must either be in the same directory as each file that includes it, or the compiler must be directed to search the directory in which Sphere.h is located.</p>
",3
8736153,8736106,2,"<p>You should post your command line, but my guess is that you should tell the path to the header files to the compiler. If you're using linux try this:</p>

<pre><code>g++ main.cpp shpere.cpp -I&lt;path_to_Sphere.h&gt; -o main
</code></pre>
",0
8736158,8736106,6,"<p><strong>You need to add to your compile command a path to where the header files can be found.</strong></p>

<p>If your header is in the <code>headers</code> directory add <code>-Iheaders</code>:</p>

<pre><code>g++ -o main.o -c -Iheaders main.cpp
g++ -o sphere.o -c -Iheaders sphere.cpp
g++ -o app main.o sphere.o -L.
</code></pre>

<p>Or whatever your files are ...</p>
",0
12868591,12868576,1,"<p>The program is ill-formed for the reason you stated. The compiler is not required a diagnostics, but I don't see a point in discussing reasons for a crash in an ill-formed program.</p>

<p><em>Still, let's do it:</em></p>

<p>The first example probably doesn't crash because <code>FooBar</code>'s behavior doesn't affect the run of <code>main</code>. The method is called, it does something, and that's it.</p>

<p>In the second example, you attempt to return a <code>Foo</code>. <code>FooBar</code> returns the version of <code>Foo</code> defined in <code>2.cpp</code>. <code>main</code> appears in <code>1.cpp</code> so it expects the version of <code>Foo</code> defined in <code>1.cpp</code>, which is a completely different version - different members, sizes. You most likely get a corruption on the destructor. (just a guess)</p>

<h3>EDIT: this does break the one definition rule:</h3>

<h3>3.2 One definition rule [basic.def.odr]</h3>

<blockquote>
  <p>6) There can be more than one definition of a class type [...] in a program provided that each definition
  appears in a different translation unit, and provided the definitions satisfy the following requirements. [...]</p>
  
  <ul>
  <li>each definition of D shall consist of the same sequence of tokens;</li>
  </ul>
  
  <p>[...]</p>
</blockquote>
",4
12868739,12868576,0,"<p>Here is how compiler/linker work:</p>

<ol>
<li><p>Compiler translates cpp file having the headers that are provided. It generates an .obj file. In your case the o.bj file will have references to data-struct <code>Foo</code>. And there will be no any other details.</p></li>
<li><p>Linker links .obj files together. It compares only the string names. In your obj files your have the same <code>Foo</code>. Names match. For the linker this is the same thing.</p></li>
<li><p>After that you start your program. Most likely it will crash. To be more specific it will show undefined behavior. It can enter infinite loop, show strange messages, etc.</p></li>
</ol>

<p>It is your responsibility to provide identical headers or definitions in the cpp files into translations of every cpp file. Existing software tools cannot check this for you. This is how it works.</p>
",0
9211329,9211307,2,"<p><code>int(*)(char, int)</code> is a pointer to a function that returns an <code>int</code> and takes a <code>char</code> and an <code>int</code> as parameters.</p>
",0
9211346,9211307,7,"<pre><code>int(*)(char, int)
</code></pre>

<p>Is a pointer to a function accepting a <code>char</code> and an <code>int</code> as parameter and returning an <code>int</code>.</p>

<pre><code>B(A::*)(C&amp;)
</code></pre>

<p>Is a pointer to a member function on an <code>A</code> object, returning <code>B</code> and accepting a reference to <code>C</code> as a parameter.</p>
",1
9211348,9211307,0,"<pre><code>B(A::*)(C&amp;)
</code></pre>

<p>is a pointer to member function ( member of <code>A</code>) that takes a <code>C&amp;</code> and returns a <code>B</code></p>

<p>Example:</p>

<pre><code>class B{
public:
/*empty class*/
};
class A{
public:
 B DoSomething( C&amp; input){
 return B;
}

}
int main(){
auto G = &amp;A::DoSomething;
}
</code></pre>

<p>the type of <code>G</code> is <code>B(A::*)(C&amp;)</code></p>
",0
9211349,9211307,2,"<blockquote>
<pre><code>int(*)(char, int)
</code></pre>
</blockquote>

<p>A pointer to function taking <code>(char, int)</code> and returning <code>int</code>.</p>

<blockquote>
<pre><code>B(A::*)(C&amp;)
</code></pre>
</blockquote>

<p>A pointer to member function of <code>A</code> taking <code>C&amp;</code> returning <code>B</code>.</p>
",0
9211364,9211307,0,"<p><code>B(A::*)(C&amp;)</code> is a pointer to <code>A</code>'s member function taking a <code>C</code> reference parameter and returning a <code>B</code> object.</p>

<p>Luchian already answered for <code>int(*)(char, int)</code>.</p>
",0
15853567,15853457,4,"<p>It seems that you are accessing memory outside of the bounds of the array. One thing that could cause that is if tab[0][?] == var. this causes your condition to check tab[-1][?] and generates an exception.</p>
",0
11516708,11516657,20,"<p>The field identifiers are indeed C initializer syntax.  In C++ just give the values in the correct order without the field names. Unfortunately this means you need to give them all (actually you can omit trailing zero-valued fields and the result will be the same):</p>

<pre><code>address temp_address = { 0, 0, ""Hamilton"", ""Ontario"", 0 }; 
</code></pre>
",9
11516839,11516657,5,"<p>It's not implemented in C++. (also, <code>char*</code> strings? I hope not).</p>

<p>Usually if you have so many parameters it is a fairly serious code smell. But instead, why not simply value-initialize the struct and then assign each member?</p>
",4
11516847,11516657,210,"<p>If you want to make it clear what each initializer value is, just split it up on multiple lines, with a comment on each:</p>

<pre><code>address temp_addres = {
  0,  // street_no
  nullptr,  // street_name
  ""Hamilton"",  // city
  ""Ontario"",  // prov
  nullptr,  // postal_code
};
</code></pre>
",10
11517024,11516657,118,"<p>After <a href=""https://stackoverflow.com/questions/5790534/static-structure-initialization-with-tags-in-c"">my question</a> resulted in no satisfying result (because C++ doesn't implement tag-based init for structures), I took the trick I found here: <a href=""https://stackoverflow.com/questions/1069621/are-members-of-a-c-struct-initialized-to-0-by-default"">Are members of a C++ struct initialized to 0 by default?</a></p>

<p>For you it would amount to do that:</p>

<pre><code>address temp_address = {}; // will zero all fields in C++
temp_address.city = ""Hamilton"";
temp_address.prov = ""Ontario"";
</code></pre>

<p>This is certainly the closest to what you wanted originally (zero all the fields except those you want to initialize).</p>
",7
11519958,11516657,7,"<p>You can even pack Gui13's solution into single initialization statement:</p>

<pre><code>struct address {
                 int street_no;
                 char *street_name;
                 char *city;
                 char *prov;
                 char *postal_code;
               };


address ta = (ta = address(), ta.city = ""Hamilton"", ta.prov = ""Ontario"", ta);
</code></pre>

<p>Disclaimer: I don't recommend this style</p>
",1
15519105,15518894,14,"<pre><code>const auto&amp; const_container = container;

for (const auto&amp; v: const_container ) {
</code></pre>
",3
15519125,15518894,36,"<p>Update: <a href=""http://en.cppreference.com/w/cpp/utility/as_const"" rel=""noreferrer""><code>std::as_const</code></a> will be in C++17, in the <code>&lt;utility&gt;</code> header.</p>

<p><em>Prior to C++17</em>, there's no built-in syntax for it; however, you can easily write a convenience wrapper:</p>

<pre><code>template&lt;typename T&gt; constexpr const T &amp;as_const(T &amp;t) noexcept { return t; }
for (auto &amp;v: as_const(container))
</code></pre>

<p>Note that this calls <code>begin() const</code> rather than <code>cbegin()</code> specifically; the <a href=""http://eel.is/c++draft/container.requirements.general"" rel=""noreferrer"">Standard container general requirements</a> specify that <code>cbegin()</code> and <code>begin() const</code> behave identically.</p>

<p>If your container treats non-const iteration specially, it might make sense for it itself to have a member function:</p>

<pre><code>const Container &amp;crange() const noexcept { return *this; }
for (auto &amp;v: container.crange())
</code></pre>
",9
15856041,15856027,11,"<p>Officially, either side of the assignment could be evaluated first. It's up to the implementation to decide which. If <code>word_count</code> does not contain an <code>""a""</code>, one is inserted, and an lvalue reference to it returned. If <code>word_count</code> does contain one, only the latter part happens. Despite the uncertainty of which side is evaluated first, you can follow possible executions:</p>

<h2>Left Side First</h2>

<h3>No Element Exists:</h3>

<p><code>operator[]</code> inserts the element since it isn't already there. <code>count()</code> finds it and returns 1, so you end up with it being assigned a value of 2.</p>

<h3>Element Exists:</h3>

<p><code>operator[]</code> returns the existing element and <code>count()</code> finds it and returns 1, so you end up with it being assigned a value of 2.</p>

<h2>Right Side First</h2>

<h3>No Element Exists:</h3>

<p><code>count()</code> returns 0, so you get 1 from the right side. Then, <code>""a""</code> is inserted into the map and assigned a value of 1.</p>

<h3>Element Exists:</h3>

<p><code>count()</code> returns 1, so you get 2 from the right side. Then, <code>word_count[""a""]</code> is accessed and has 2 assigned to it.</p>

<h2>Conclusion</h2>

<p>In short, you can't rely on this to do what you want, so it's better to use something that you can rely on. mrfontanini made a good suggestion, so I'll edit it a bit:</p>

<pre><code>word_count[""a""]++;
word_count[""a""] = std::min(word_count[""a""], 2);
</code></pre>

<p>The first line ensures it is inserted and has a value of at least 1. The second limits that value to a maximum 2, in the case that you do this operation repeatedly.</p>

<h3>Notes</h3>

<p>I base this answer off of two things:</p>

<ol>
<li><p>When a side is picked to be evaluated, the whole side has to be evaluated before the other side can start.</p></li>
<li><p>Constructs such as <code>word_count[""a""] = 1</code> exhibit well-defined behaviour, even in the case that an element is inserted and then assigned to.</p></li>
</ol>

<p>There is some debate and discussion below about whether these are true or not. I've made it a bit <a href=""https://stackoverflow.com/questions/15865627/is-indexing-a-new-map-element-and-having-something-that-reads-it-assigned-to-it"">more official</a> now.</p>
",26
15856112,15856027,5,"<p>Looking at this line:</p>

<pre><code>word_count[""a""] = word_count.count(""a"") == 0 ? 1 : 2;
</code></pre>

<p>I <strong>believe</strong> that if <code>word_count[""a""]</code> does not exist in the map before that line is executed, you cause undefined behavior.</p>

<p>This is because <code>word_count[""a""]</code> will create an entry in the map if one doesn't exist, and this will change the behavior of <code>word_count.count(""a"")</code>. We also have no required sequencing between those two calls..</p>
",0
13449981,13449968,7,"<p><code>map::operator[]</code> <strong>automatically</strong> creates the key/value pair if it doesn't exist.<br />
(That's why it's not const!)
So you don't need to create the inner map manually.</p>
<p>If you want to <em>avoid</em> creating the pair automatically, then use <code>map::find()</code> or <code>map::at()</code>.</p>
",0
13450017,13449968,1,"<p>access the <code>operator[]</code> via <code>-&gt;</code>:</p>

<pre><code>nestedMap-&gt;operator[](5)[6] = 7;
</code></pre>

<p>This is analogous to</p>

<pre><code>nestedMap[5][6] = 7;
</code></pre>

<p>if <code>nestedMap</code> is not a pointer.</p>

<p>Note that in neither case do you have to explicitly insert a map.</p>
",0
13450038,13449968,1,"<p>If i understand your question properly, you can actually use reference instead of pointer. You are not having issue with nested map, instead your outter map.</p>

<p>See below code, is what you want?</p>

<pre><code>map&lt;int, map&lt;int, int&gt; &gt;* nestedMap  = new map&lt;int, map&lt;int, int&gt; &gt;;   
map&lt;int, map&lt;int, int&gt; &gt; &amp;nestedMapAlais = *nestedMap;
nestedMapAlais[1][2] = 3;
</code></pre>
",1
13450136,13449968,3,"<p>I believe the simplest one-liner is:</p>

<pre><code>(*nestedMap)[int][int] = int;
</code></pre>
",0
17394809,17394780,7,"<p><code>setw</code> isn't sticky, so you have to say it every time:</p>

<pre><code>cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; 8 &lt;&lt; "" ""
     &lt;&lt; setw(3) &lt;&lt; 9 &lt;&lt; endl;
</code></pre>
",0
10824432,10824409,4,"<p>You need the ""0x"" in a literal, like ""0x%03x"".  The <code>x</code> format just prints the digits in hex, it doesn't add the 0x decoration.</p>
",4
10824456,10824409,1,"<p>Use <code>L""0x%x"", value</code>. Making the buffer have only four elements is probably a bad idea (as soon as <code>value</code> is greater than <code>0xF</code>). You should store the return value and make sure the string didn't get truncated:</p>

<pre><code>int n = swprintf(buff, sizeof buff, L""0x%x"", value);

if (n &gt;= sizeof buff) { /* truncation! */ }
</code></pre>
",1
8722104,8722085,1,"<p><a href=""http://www.rawmaterialsoftware.com/juce.php"" rel=""nofollow"">Juce</a> wouldn't be a bad place to start.</p>
",0
15550923,15550677,1,"<p>No, not that way. <code>is_class</code> check if it class(not enum for example). If you will break <code>tmpl</code> instatioation with SFINAE, you will get compile error.</p>

<p>For example this way:</p>

<pre><code>template &lt;&gt;
struct tmpl&lt;int&gt;{ char off[-1];};
</code></pre>
",0
15550955,15550677,2,"<p>By naming the type you have instantiated it.  As soon as you refer to <code>tmpl&lt;SomeTypeNamedFoo&gt;</code> the compiler will auto-instantiate on your behalf.</p>
",0
15551664,15550677,1,"<p>Why do you need to determine if template-instantiation for particular type has happened or not. Let the compiler do it! </p>

<p>As soon as you make <code>Temp&lt;T&gt;</code>, the instantiation has occurred. Even it doesn't occur at this moment, it might have occurred in another translation unit. How are you going to figure out that, and what would you do if instantiation has occurred (or not) in another translation unit? The sequence of instantiations may also be different between different builds of the project.</p>
",2
8722321,8722217,0,"<p>I'm taking a bit of a stab in the dark here, but I think your problem <em>might</em> be that you're defining the function like this:</p>

<pre><code>void function(const string param1, string *p2param, string *retparam)
{
    .
    .
    .
}
</code></pre>

<p>but you're forward-declaring it somewhere (in a header file?) like this:</p>

<pre><code>string function(const string param1, string *p2param, string *retparam);
</code></pre>

<p>(promising that it will have return-type <code>string</code> rather than <code>void</code>). So when the function returns, the calling code tries to use its return-value, and pandemonium ensues when it turns out there <em>isn't</em> one.</p>

<p>(If that's not the case &mdash; and it may well not be &mdash; then I think it would help if you posted the full function definition, as well as the code that invokes the function.)</p>
",0
8722236,8722217,1,"<p>If <code>retparam</code> is the address of an actual <code>string</code> when you pass it in, then what you really want to do before returning is</p>

<pre><code>(*retparam) = f2;
</code></pre>

<p>Setting the value of <code>retparam</code> itself isn't doing you any good, since it's a local variable in the function, and changing its value won't change anything in the parent. But you can change the memory it <em>points</em> to, which is what happens here.</p>
",3
8722241,8722217,0,"<p>You are returning a pointer to f2 which is a local variable that gets destroyed when the function returns.</p>
",0
14188698,14188684,2,"<p>Your code works fine except you need to include functional header for <a href=""http://en.cppreference.com/w/cpp/utility/functional/greater"" rel=""nofollow"">std::greater</a> function operator on VS2012</p>

<pre><code>#include &lt;functional&gt;
</code></pre>
",1
16401757,16401639,4,"<p>A C-style cast can fit an octogonal peg into a trapezoidal hole, so I would say that given your extremely specific target hardware and requirements, I would use that cast, possibly wrapped into a template for greater clarity.</p>

<p>Alternately, the double cast to <code>void*</code> and then <code>int</code> does have the advantage of making the code stand out like a sore thumb so your future maintainers know something's going on and can pay special attention.</p>

<p>EDIT for comment:
It appears your compiler may have a bug. The following code compiles on g++ 4.5:</p>

<pre><code>#include &lt;iostream&gt;

int f()
{
    return 0;
}

int main()
{
    int value = (int)&amp;f;

    std::cout &lt;&lt; value &lt;&lt; std::endl;
}
</code></pre>

<p>EDIT2:
You may also wish to consider using the <code>intptr_t</code> type instead of <code>int</code>. It's an integral type large enough to hold a pointer.</p>
",2
16402859,16401639,-1,"<p>This is ansi compliant:</p>

<pre><code>int MyFunc(void* p)
{
    return 1;
}

int main()
{
   int arr[2];
   int (*foo)(int*);

   arr[0] = (int)(MyFunc);

   foo = (int (*)(int*))(arr[0]);

   arr[1] = (*foo)(NULL);
}
</code></pre>
",3
16403943,16401639,2,"<p>In C++ a pointer can be converted to a value of an integral type large enough to hold it. The conditionally-supported type <code>std::intptr_t</code> is defined such that you can convert a <code>void*</code> to <code>intptr_t</code> and back to get the original value. If <code>void*</code> has a size equal to or larger than function pointers on your platform then you can do the conversion in the following way.</p>

<pre><code>#include &lt;cstdint&gt;
#include &lt;cassert&gt;

void foo() {}

int main() {
    void (*a)() = &amp;foo;

    std::intptr_t b = reinterpret_cast&lt;std::intptr_t&gt;(a);

    void (*c)() = reinterpret_cast&lt;void(*)()&gt;(b);
    assert(a==c);
}
</code></pre>
",1
8772228,8772227,29,"<p>It won't leak the object you are deleting, its memory block will be freed. </p>

<p>If you have not declared the destructor in <code>base_class</code> to be virtual then it <em>will</em> leak any dynamically allocated objects contained within <code>derived_class</code> that rely on the destructor of <code>derived_class</code> being called to free them. This is because if the destructor is not virtual, the <code>derived_class</code> destructor is not called in this case. It also means that destructors of ""embedded objects"" within <code>derived_class</code> will not automatically be called, a seperate but additional problem, which can lead to further leaks and the non-execution of vital cleanup code.</p>

<p>In short, declare the destructor in <code>base_class</code> to be virtual and you can safely use the technique you have presented.</p>

<p>For a coded example, see:</p>

<p><a href=""https://stackoverflow.com/questions/8733894/in-what-kind-of-situation-c-destructor-will-not-be-called/8734224#8734224"">In what kind of situation, c++ destructor will not be called?</a></p>
",0
8782623,8782600,2,"<p>The implementation of template functions/classes has to be visible to the compiler at the point of instantiation. This means that you should put the whole templates in the header file, not in a <code>.cpp</code> file.</p>
",0
8782659,8782600,1,"<p>First, make sure you've defined the print function.  Then you should know that when you declare a templated class, you need to provide the implementation whenever you use that class. In other words, move the implementation out of the .cpp file and into the .h file.</p>
",0
8782689,8782600,0,"<p>Yeah, the implementation has to be in the header file, otherwise the compiler doesn't know the specialized function (after resolving the template) is needed.</p>

<p>You can also put the implementation in a .inl file (or simmilar) and include it at the end of the .h file. That's how it's usually done, to keep decleration and implementation in seperate files (to keep things clear).</p>
",0
11146391,11146379,2,"<pre><code>#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  std::string temp, mystring;
  std::set&lt;std::string&gt; myset;

  while(std::getline(std::cin, temp))
      mystring += temp + ' ';
  temp = """";      

  for (size_t i = 0; i &lt; mystring.length(); i++)
  {
    if (mystring.at(i) == ' ' || mystring.at(i) == '\n' || mystring.at(i) == '\t')
    {
      myset.insert(temp);
      temp = """";
    }
    else
    {
      temp.push_back(mystring.at(i));
    }
  }
  if (temp != "" "" || temp != ""\n"" || temp != ""\t"")
    myset.insert(temp);

  for (std::set&lt;std::string&gt;::iterator i = myset.begin(); i != myset.end(); i++)
  {
    std::cout &lt;&lt; *i &lt;&lt; std::endl;
  }
  return 0;
}
</code></pre>

<p>Let's start at the top. First off, you need a few variables to work with. <code>temp</code> is just a placeholder for the string while you build it from each character in the string you want to parse. <code>mystring</code> is the string you are looking to split up and <code>myset</code> is where you will be sticking the split strings.</p>

<p>So then we read the file (input through <code>&lt;</code> piping) and insert the contents into <code>mystring</code>. </p>

<p>Now we want to iterate down the length of the string, searching for spaces, newlines, or tabs to split the string up with. If we find one of those characters, then we need to <code>insert</code> the string into the set, and empty our placeholder string, otherwise, we add the character to the placeholder, which will build up the string. Once we finish, we need to add the last string to the set.</p>

<p>Finally, we iterate down the set, and print each string, which is simply for verification, but could be useful otherwise.</p>

<p>Edit: A significant improvement on my code provided by <a href=""https://stackoverflow.com/users/14065/loki-astari"">Loki Astari</a> in a <a href=""https://stackoverflow.com/questions/11146379/splitting-stdstring-and-inserting-into-a-stdset/11146391#comment14617346_11146391"">comment</a> which I thought should be integrated into the answer:</p>

<pre><code>#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  std::set&lt;std::string&gt; myset;
  std::string word;

  while(std::cin &gt;&gt; word)
  {
      myset.insert(std::move(word));
  }

  for(std::set&lt;std::string&gt;::const_iterator it=myset.begin(); it!=myset.end(); ++it)
    std::cout &lt;&lt; *it &lt;&lt; '\n';
}
</code></pre>
",7
11146421,11146379,25,"<p>The easiest way to construct any container from a source that holds a series of that element, is to use the constructor that takes a pair of iterators.  Use <code>istream_iterator</code> to iterate over a stream.</p>

<pre><code>#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

using namespace std;

int main()
{
  //I create an iterator that retrieves `string` objects from `cin`
  auto begin = istream_iterator&lt;string&gt;(cin);
  //I create an iterator that represents the end of a stream
  auto end = istream_iterator&lt;string&gt;();
  //and iterate over the file, and copy those elements into my `set`
  set&lt;string&gt; myset(begin, end);

  //this line copies the elements in the set to `cout`
  //I have this to verify that I did it all right
  copy(myset.begin(), myset.end(), ostream_iterator&lt;string&gt;(cout, ""\n""));
  return 0;
}
</code></pre>

<p><a href=""http://ideone.com/iz1q0"">http://ideone.com/iz1q0</a></p>
",8
9211185,9211138,2,"<p>Do like this</p>

<pre><code>strncpy (dest, ar + 7, 2);
</code></pre>

<p>generally</p>

<pre><code>strncpy (destination, source + start_index, number_of_chars);
</code></pre>

<blockquote>
<pre><code>   The strncpy() function is similar, except that at most n bytes of src are copied.  Warning: If there
   is no null byte among the first n bytes of src, the string placed in dest will  not  be  null-termi©\
   nated.
</code></pre>
</blockquote>

<p>Therefore you need to null terminate the string manually:</p>

<pre><code>dest[nos_of_chars] = '\0';
</code></pre>

<p><strong>UPDATE</strong></p>

<p>You can use something like this:</p>

<pre><code>char *make_substring (char *src, int start, int end)
{
  int nos_of_chars = end - start + 1;
  char *dest;
  if (nos_of_chars &lt; 0)
  {
    return NULL;
  }
  dest = malloc (sizeof (char) * (nos_of_chars + 1));
  dest[nos_of_chars] = '\0';
  strncpy (dest, src + start, nos_of_chars);
  return dest;
}
</code></pre>

<p>When you are using C++, do not use the char strings for processing instead use the string class.</p>
",1
9211196,9211138,1,"<p>In order to copy <code>n</code> characters starting from position <code>p</code> from <code>string1</code> to <code>string2</code>, you can use:</p>

<pre><code>strncpy(string2, string1 + p, n);
</code></pre>

<p>If you're dealing with C++ strings (<code>std::string</code>), then you can use the <code>substr</code> member function.</p>

<pre><code>std::string string1 = ""......"";
std::string string2 = string1.substr(p, n);
</code></pre>
",0
9211232,9211138,0,"<p>You can take the address of a specific place in the array by using e.g. <code>&amp;ar[i]</code>.</p>

<p>For example, if you add the following line before the <code>return</code></p>

<pre><code>cout &lt;&lt; &amp;ar[6] &lt;&lt; '\n';
</code></pre>

<p>it will print</p>

<pre>
is strange
</pre>
",0
9211242,9211138,2,"<p>Your code is in C++, so use the STL - don't create a fixed size character array, use std::string. That has a method substr(pos, n).</p>

<p>so your code would be:</p>

<pre><code>std::string str;
str = ""string is not so strange"";
cout &lt;&lt; str &lt;&lt; endl;
std::string small;
small = str.substr(7, 3);
cout &lt;&lt; small &lt;&lt; endl;
</code></pre>

<p>much easier than doing potentially unsafe pointer arithmetic using the C api.</p>
",0
9211262,9211138,0,"<p>you can use memcopy function</p>

<pre><code>void * memcpy ( void * destination, const void * source, size_t num );
</code></pre>

<p>in your example</p>

<pre><code>memcpy(cp,ar+p,sizeof(char)*n)
</code></pre>
",0
9211379,9211138,1,"<p>C++</p>

<p>What are you trying to achieve? 'string is strange' reminds me of spell checking -> permutations</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    std::string s = ""string is strange"";
    std::sort(s.begin(), s.end());

    while (std::next_permutation(s.begin(), s.end()))
        std::cout &lt;&lt; s &lt;&lt; ""\n"";

    return 0;
}
</code></pre>

<p>To really just exchange random positions: <strong><a href=""http://ideone.com/IzDAj"" rel=""nofollow"">http://ideone.com/IzDAj</a></strong></p>

<pre><code>#include &lt;random&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace std;
    mt19937 random;

    string s = ""string is strange"";
    uniform_int_distribution&lt;size_t&gt; gen(0,s.size()-1);

    for (int i=0; i&lt;20; i++)
    {
        swap(s[gen(random)], s[gen(random)]);
        cout &lt;&lt; s &lt;&lt; ""\n"";
    }

    return 0;
}
</code></pre>
",0
12336964,12336724,2,"<p>The posted code is <a href=""https://en.wikipedia.org/wiki/Insertion_sort"" rel=""nofollow"">Insertion sort</a>.</p>

<p>Most implementations will copy an out-of-order element to a temporary variable and then work backwards, moving elements up until the correct open spot is found to ""insert"" the current element. That's what the pseudocode in the Wikipedia article shows.</p>

<p>Some implementations just bubble the out-of-order element backwards while it's less than the element to its left. That's what the inner <code>do...while</code> loop in the posted code shows.</p>

<p>Both methods are valid ways to implement Insertion sort.</p>
",1
12337727,12336724,0,"<p>Given the fact that the term ""direct inclusion sort"" yields no google hits at all, and ""direct insertion sorting"" only 27 hits, the first three of which are this post here and two identically phrased <a href=""http://jisku.com/blog/2012/09/direct-inclusion-sorting/"" rel=""nofollow"">blog</a> <a href=""http://umeedaintimes.com/direct-inclusion-sorting/"" rel=""nofollow"">posts</a>, I doubt that this term has any widely accepted meaning. So the part of your question about</p>

<blockquote>
  <p>some book its saying they are the same with direct direct-inclusion sorting</p>
</blockquote>

<p>is hard to answer, unless we find a clear definition of what <em>direct-inclusion sorting</em> actually is.</p>
",0
12336779,12336724,1,"<p>The code you posted looks not like an algorithm for insertion sort, since you are doing a repeated swap of two neighboring elements.</p>

<p>Your code looks much more like some kind of bubble-sort.</p>

<p>Here a list of common sorting algorithms:
<a href=""https://en.wikipedia.org/wiki/Sorting_algorithm"" rel=""nofollow"">https://en.wikipedia.org/wiki/Sorting_algorithm</a></p>

<p>""straight insertion"" and ""direct inclusion"" sounds like pretty much the same .. so I quess they probably are different names for the same algorithm.</p>

<p>Edit:
Possibly the ""straight"" prefix should indicate that only one container is used .. however, if two neighboring elements are swaped, I would not call it insertion-sort, since no ""insert"" is done at all.</p>
",2
9790349,9789485,6,"<p>From my reading of the standard, this is not allowed.</p>

<p>If you look at the grammar definition only, it seems to allow it. The relevant parts are:</p>

<p>The <i>member-specification</i> is what appears between the <code>{ ... }</code> in the class declaration.</p>

<p><i>member-specification</i> is a sequence of <i>member-declaration</i> and access specifiers. One possible form for a <i>member-declaration</i> is:</p>

<blockquote>
  <p><i>attribute-speci?er-seq</i><sub>opt</sub> <i>decl-speci?er-seq</i><sub>opt</sub> <i>member-declarator-list</i><sub>opt</sub> ;</p>
</blockquote>

<p>Since everything before the semicolon is optional, it looks like it's allowed to have an empty 
 <i>member-declaration</i>, which consists of only a semicolon.</p>

<p>However, 9.2/1 says: </p>

<blockquote>
  <p>Except when used to declare friends (11.3) or to introduce the name of a member of a base class into a derived class (7.3.3), member-declarations declare members of the class, and <strong>each such member-declaration shall declare at least one member name of the class</strong>.</p>
</blockquote>

<p>Since an empty member-declaration does not declare at least one member of a class, it seems that this is not standard-compliant, even if some compilers accept it.</p>
",0
11169443,11169432,3,"<p>Get a book, seriously.</p>

<p><code>which()</code> returns reference to third element of the array; by <code>which(2) = ...</code> you assign value to variable referenced by that reference.</p>

<p>But to understand how it really works you have to understand what a <strong>reference</strong> is - which is explained in that book you should get.</p>
",0
11169450,11169432,1,"<p>Since the string ""ALICE"" is an array of chars, and an array starts at index 0, the 2nd index is the third char in the string.</p>

<p>You are also returning a reference instead of a copy of the char, this is why the string changes if you change it's value.</p>
",0
12795263,12795225,13,"<p>For a non-negative integer x the tens digit is <code>(x / 10) % 10</code>.</p>
",3
12795481,12795225,4,"<pre><code>#include &lt;math.h&gt;

int getdigit(int number, int digit)
{
   return (number / ((int) pow(10, digit)) % 10);
}
</code></pre>

<p>Where the first digit is 0. I don't really like floating point numbers getting involved (via pow), though.</p>
",0
12796051,12795225,3,"<p>Try to use very rarely used functions:</p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/div/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstdlib/div/</a></p>

<pre><code> div_t div (           int numer,           int denom );
 ldiv_t div (      long int numer,      long int denom );  // C++ only
lldiv_t div ( long long int numer, long long int denom );  // C++11 only
</code></pre>

<p>E.g. with a simple loop:</p>

<pre><code>std::vector&lt;int&gt; getDigits(unsigned int numer)
{
  std::deque&lt;int&gt; rv;
  do {
     div_t res = div(numer, 10);
     rv.push_front(res.rem);
     numer = res.quot;
  } while (numer &gt; 0);
  return std::vector&lt;int&gt;(rv.begin(), rv.end());  
}
</code></pre>
",0
9805649,9805611,2,"<p>in c++98 you can do</p>

<pre><code>std::string str(""1234"");
int i;
std::stringstream ss(str);
ss &gt;&gt; i;
</code></pre>

<p>in c++11 you should do:</p>

<pre><code>std::string str(""1234"");
int i=std::stoi(str);
</code></pre>
",0
9805778,9805611,-1,"<p>A more C++-way of doing this:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;string&gt;

// Converts a string to anything.
template&lt;typename T&gt;
T to(const std::string&amp; s)
{
    std::stringstream ss(s);
    T ret;
    ss &gt;&gt; ret;
    return ret;
}

// And with a default value for not-convertible strings:
template&lt;typename T&gt;
T to(const std::string&amp; s, T default_)
{
    std::stringstream ss(s);
    ss &gt;&gt; default_;
    return default_;
}
</code></pre>

<p>Use it as follows:</p>

<pre><code>int i = to&lt;int&gt;(""123"");
assert(i == 123);
int j = to&lt;int&gt;(""Not an integer"", 123);
assert(j == 123);
</code></pre>

<p>And extend it to support arbitrary types of yours:</p>

<pre><code>struct Vec3 {float x, y, z;};

template&lt;class T&gt;
T&amp; operator&gt;&gt;(T&amp; f, Vec3&amp; v) {
    f &gt;&gt; v.x &gt;&gt; v.y &gt;&gt; v.z;
    return f;
}

// Somewhere else:
Vec3 v = to&lt;Vec3&gt;(""1.0 2.0 3.0"");
</code></pre>
",0
8799589,8799518,1,"<p>You can't ""re-use"" functions, at least not in the way I understand your question.</p>

<p>But you can create a new function that calls the original function and then does some additional work of its own. For example:</p>

<pre><code>void PrevFunction(int one)
{
    int i = one;
    // do whatever
}

void NewFunction(int one)
{
    PrevFunction(one);

    // do new stuff
    // ...
}
</code></pre>

<p>You could also define a class, and then use inheritance and <code>virtual</code> functions to modify the behavior of a particular set of functions from the base class.</p>
",3
8799649,8799518,4,"<p>You're welcome to have one function call another. For example:</p>

<pre><code>void ANewFunction() {
  MainFunction(false);
}
void AnotherNewFunction() {
  MainFunction(true);
}
</code></pre>

<p>You can even get fancy:</p>

<pre><code>#include &lt;functional&gt;
auto ANewFunction = std::bind(&amp;MainFunction, false);
auto AnotherNewFunction = std::bind(&amp;MainFunction, true);
</code></pre>

<p>Either way, you can call <code>ANewFunction</code> or <code>AnotherNewFunction</code>, and <code>MainFunction</code> will get called with the given argument. (In the latter case, they're not really functions anymore. They're called function objects, or <em>functors</em>, but you cal still call them just like ordinary functions: <code>ANewFunction()</code>.)</p>
",1
8799666,8799518,0,"<p>Simply call MainFunction from your other function?</p>

<pre><code>void ANewFunction()
{
    MainFunction(false);
}
void AnotherNewFunction()
{
    MainFunction(true);
}
</code></pre>

<p>If your question is how do you make AnotherNewFunction refer to a different A and B than ANewFunction, the answer is you can't, at least not without help from MainFunction. You can, however, update MainFunction:</p>

<pre><code>void MainFunction(bool Whatever, bool&amp; A, bool&amp; B) {
    if(!Whatever) {
        A = true;
        if(A) {
            B = false;
        } else if(!A) {
            B = true;
        }
    }
}
bool A1 = false;
bool B1 = true;
void ANewFunction()
{
    MainFunction(false, A1, B1);
}
bool A2 = false;
bool B2 = true;
void AnotherNewFunction()
{
    MainFunction(true, A2, B2);
}
</code></pre>
",0
8799668,8799518,0,"<pre><code>typedef int (*function_t)(int); // new type - defines function type - address of function 


// your function, PrevFunction is simply variable holding address of the function:
int PrevFunction(int one) { return one; }

// new variable of type function_t initialized by PrevFunction address: 
function_t NewFunction = PrevFunction;

//And finally we can use either PrevFunction or NewFunction - they point to the same function body: 

int a = PrevFunction(1); // a == 1
int b = NewFunction(2); // a == 2
</code></pre>
",2
8800374,8799518,0,"<p>Another new-fangled solution, using <em>lambda's</em>:</p>

<pre><code>auto ANewFunction = [](){ MainFunction(false); }
auto AnotherNewFunction = [](){ MainFunction(true); }
</code></pre>
",0
17384933,17384921,11,"<p>It's just undefined behavior. You return a temporary by reference, anything can happen.</p>

<p>The <code>A&amp; g(int i) { A x(i); return x; }</code> is illegal.</p>

<p>A debug build will probably clear the memory and cause errors because the memory was cleared.</p>

<p>A release build doesn't bother. You pay for what you use, right? It just leaves the memory untouched, but marks it as reclaimable by the OS. All gloves are off afterwards.</p>

<p>It's an (arguably) good thing that comes with the VC++ compiler. You'll see all sort of stuff happening in debug build to help you... well... debug better. Uninitialized pointers set to some specific value so that you <em>know</em> it's uninitialized, memory zeroed out after a <code>delete</code> so that you <em>know</em> it was deleted. This helps in identifying problems sooner, because in a release build you'd probably still see the memory if it wasn't overwritten, or access an uninitialized pointer and have it <em>appear</em> to work, etc. Problems you wouldn't see otherwise, and at the time you would spot would cause a lot of harm and would be very hard to diagnose.</p>
",14
17386064,17384921,1,"<p>Here's what the speed-optimized (/O2 compiler switch) release build of Visual Studio 2012 64-bit actually does when it runs this code and prints out a one:</p>

<pre><code>int main()
{
000000013F7C7E50  sub         rsp,28h  
    const A&amp; r = g(1);
000000013F7C7E54  lea         rdx,[string ""Ctor\n"" (013F83DA4Ch)]  
000000013F7C7E5B  lea         rcx,[std::cout (013F85FAA0h)]  
000000013F7C7E62  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (013F7C1500h)  
000000013F7C7E67  lea         rdx,[string ""Dtor\n"" (013F83DA54h)]  
000000013F7C7E6E  lea         rcx,[std::cout (013F85FAA0h)]  
000000013F7C7E75  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (013F7C1500h)  
    std::cout &lt;&lt; ""Using the stack\n"";     
000000013F7C7E7A  lea         rdx,[string ""Using the stack\n"" (013F83DA60h)]  
000000013F7C7E81  lea         rcx,[std::cout (013F85FAA0h)]  
000000013F7C7E88  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (013F7C1500h)  
    std::cout &lt;&lt; r.i &lt;&lt; '\n';   // r.i has garbage in debug, but not in a release build.
000000013F7C7E8D  lea         rcx,[std::cout (013F85FAA0h)]  
000000013F7C7E94  mov         edx,1  
000000013F7C7E99  call        std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (013F7C1384h)  
000000013F7C7E9E  mov         dl,0Ah  
000000013F7C7EA0  mov         rcx,rax  
000000013F7C7EA3  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (013F7C10EBh)  
</code></pre>

<p>Note that it doesn't even bother to really create and destroy the <code>A</code> object.  All it does is call <code>cout</code> four times.  Each time, <code>rdx</code> holds the object to print.  The first three print the strings ""Ctor\n"", ""Dtor\n"", and ""Using the stack\n"".  The last one looks like it just prints the integer in <code>edx</code> which is a <code>1</code>.</p>

<p>The compiler can really do anything for undefined behavior.  It prints something besides a one for space-optimized (/O1 compiler switch), or as the OP found, not-optimized (/Od).</p>
",0
8804856,8804823,4,"<p>It depends:</p>

<pre><code>A a;
//this is not an assignment, it is equivalent to A b(a);
A b = a; //default copy constructor is called

A c;
//assignment
c = a; //default assignment operator is called
</code></pre>
",7
10821196,10821164,6,"<p><code>memcmp</code> is usually a compiler intrinsic, so will be optimised to be about as efficient as it's possible to get (will be vectorised, inlined, etc.).</p>

<p>So you almost certainly won't beat it.  But of course, if you want to know for sure, then just profile!</p>
",0
10821204,10821164,1,"<p>No, it won't be faster.  memcmp will just compare the raw memory of appropriate sizes as efficiently as possible.  Only a naive implementation of memcmp would do it byte by byte.</p>
",0
9221466,9221458,7,"<p>Although your testcase is woefully incomplete, from the presence of the keyword <code>virtual</code> it looks like this is inside a class definition.</p>

<p>In such a context, <code>= 0</code> is not an assignment at all, but a piece of confusing syntax that marks the virtual member function as being ""pure"". A pure virtual member function may have an implementation (defined elsewhere), but one is optional and the function's very existence prohibits the class from being instantiated.</p>

<p>That is, a class with pure virtual member functions may be called ""abstract"".</p>

<p><a href=""https://stackoverflow.com/q/388242/560648"">Your peer-reviewed C++ book</a> covers the topic in much greater detail.</p>
",4
9221470,9221458,2,"<p>It means that the method is pure, or abstract.  It means that the method is meant to be declared by extending classes (thanks for clarifying this--see comments below).</p>
",3
9221477,9221458,2,"<p>The <code>= 0</code> syntax is how you declare a <em>pure virtual</em> function in C++. A pure virtual has no implementation in the class declaring it -- any subclass <em>must</em> implement the function in order to be instantiable. </p>

<p><a href=""http://www2.research.att.com/~bs/glossary.html#Gpure-virtual-function"" rel=""nofollow"">http://www2.research.att.com/~bs/glossary.html#Gpure-virtual-function</a></p>
",4
9221482,9221458,2,"<p>That makes the function a <a href=""http://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions"" rel=""nofollow"">pure virtual function</a>. This means that the class that declares the function is abstract, and subclasses must provide an implementation for this function.</p>
",1
9221484,9221458,2,"<p>By adding the <code>= 0</code> you are declaring the <em>virtual function</em> to be <em>pure virtual function</em>. This means that derived classes must implement the method before they can be instantiated. Normally the base class does not have implementation.</p>

<p>This is also called an abstract function in other languages, such as Java and C#.</p>
",1
9226693,9221458,0,"<p>It simply means, that the implementor (Original writer) of the class in which <code>FOOx</code> and <code>FOOy</code> intended it to be used as an interfaces to its Derived Classes.</p>

<p>And these being <code>virtual</code> means, it will be possible that the <code>derived class</code>' implementation will be used, using the <code>base class</code>' pointer. So its being usable as an interface becomes possible by declaring them as <code>virtual</code>.</p>

<p>And finally, answering your question. Value-assignment, specifically assigning <code>0</code> to a function means, explicitly saying, that function doesn't has any definition. (Though you can specify a definition for it, but it will need to be called explicitly by the derived classes) </p>
",0
14238359,9140646,0,"<p><em>Header</em> (HPP):<br>
The header includes the declarations of your code, particularly function declarations. Technically speaking classes are <em>defined</em> in header-files, but again, the member functions are just declared.</p>

<p>Code in other files will include just this header and retain all necessary information from there.</p>

<p><em>Implementation</em> (CPP):<br>
The implementation includes the definition of functions, member-functions and variables.</p>

<p>Rationale:  </p>

<ul>
<li>Header-files gives a developer (a external user of your code) a plain overview and just offers the external available code (i.e. easy to read, only the information necessary for users).</li>
<li>Header-files allow the compiler to check the implementation for correctness</li>
<li>Header-files allow the compiler to check external code for correctness</li>
<li>Header-files allow for seperate-compilation. You need to keep in mind. that in former times, computers doesn't have enough resources to keep everything in main-memory during a compilation process. Header files are small, while implementation files are big.</li>
</ul>

<p>Use #style 1, even for simple programs. So you can learn easily to work with. That maybe look outated today, especially in background of modern Multi-Pass-Compilers. But seperate header-files are even today beneficial. Rumours about the next C++-Standard appeared, as far as I know something like <em>symbol export</em> ( Java or C#) will be possible. But don't nail me down on this!</p>

<p>Notes:<br>
  - member-functions which are <strong>defined</strong> inside a class are by default <strong>inline</strong>, normally you don't want this<br>
  - use <strong>always</strong> defined guards</p>
",0
9140673,9140646,4,"<p>The former - interfaces in header files and class bodies in implementation files.  You'll find this causes you fewer problems when working on large systems.</p>

<p><a href=""https://stackoverflow.com/questions/333889/in-c-why-have-header-files-and-cpp-files"">In C++ why have header files and cpp files?</a></p>
",0
9140676,9140646,8,"<p>For all but the simplest programs, style #2 is simply impossible. If you <code>#include</code> a <code>.cpp</code> file with function definitions from multiple other <code>.cpp</code> files, the definitions get added to multiple object files (<code>.o</code> / <code>.obj</code>) and the linker will complain about clashing symbols.</p>

<p>Use style #1 and learn to live with the confusion.</p>
",0
9140678,9140646,0,"<p>Since you tagged with c++, go for first style. I don't find it confusing, for a Java programmer, it may seem different, but in C++, you are always going to use this approach.</p>

<p>In fact in my favorite IDE (MSVS), I open header file, and cpp file side by side. Makes looking up prototypes, and class declaration easy.</p>

<p>And when you have a dozen classes; a dozen .h files, and another dozen .cpp file, will make your work simpler. Because, when you want just to see, what a class does, you just open relevant .h file, and take a look at class members, and maybe short comments. You don't need to wade through several lines deep code.</p>

<p>Conclusion : The style options you gave, are option only for a small code, typically single file, with very few methods etc. Otherwise, it is not even a option. (@Thomas has given the reason why #2 is not even a option)</p>
",0
9140700,9140646,0,"<p>C++ doesn't use ""interfaces"" they use classes - base/derived classes. I use one file to define class/and its implementation methods if the project is small and separate files if the project is large. 
In java, I pack them up into one package then import it once in need.</p>
",0
15544524,9140646,0,"<p>If you are developing large project, you'll find the first approach helps you a lot. The second approach may help you in small project. As your project becomes larger, management of complexity is a big issue of software development, and the first approach turns out to be a better choice. </p>
",0
9148713,9148683,4,"<p>You can find some predefined exception types in the header <code>&lt;stdexcept&gt;</code>.</p>

<p>Either use one of those or derive your class from it. It has all the machinery already implemented.</p>
",2
9148717,9148683,1,"<pre><code>class my_exception : public std::exception
{
public:
 my_exception(const std::string&amp; msg) : msg_(msg) {}
 const char* what(); // override what to return msg_;
private:
    std::string msg_;
};

//some other code..

throw my_exception(""Error""); 
</code></pre>

<p>This is how you'd create a new run-time exception.  It's just a <code>class</code></p>
",1
9151881,9151846,0,"<p>Yes. <code>shared_ptr</code> is a reference counting smart pointer who takes ownership of the new object.</p>

<p>When a Family is destructed its members including the _people map will be deleted. When a map is deleted it's contents are deleted.</p>

<p>If _people was just a map containing <code>Person *</code> the the destructor of Family would have to delete each Person (if not known by somebody else).</p>

<p>Using <code>shared_ptr</code> seems good for this example. You could for example return <code>shared_ptr</code> of the son of one family and make him the father of another family.</p>

<pre><code>std::tr1::shared_ptr&lt;Person&gt; getSon(){
      return someOne... ;
}
</code></pre>

<p>For the smart pointer stuff to work you need to return by value so that the copy constructor is called. Then you can safely delete one family without corrupting another.</p>
",0
9151887,9151846,0,"<p>Go through it: <code>Family</code> goes out of scope, <code>_people</code> is destroyed, the <code>map</code> destructor removes all it's elements, which means that for each element, the destructor is called. All <code>shared_ptrS</code> in the map decrement their reference count. If the reference count is now 0, the objects are destroyed. Although I don't see why you would store a pointer (smart or not) in your example, I guess you have your reasons. </p>
",0
9151891,9151846,0,"<p>Yes. That will behave as you expect and as it should. <code>std::tr1::shared_ptr</code> can be used in STL structures; on the other hand the old <code>auto_ptr</code> cannot. </p>
",2
9151913,9151846,0,"<p>The map member _people will be cleaned but not the Person shared pointers, unless some of them reach refcount 0</p>
",0
10775422,10775398,1,"<p>Implement a copy constructor for MyClass and copy the object. Not the pointer.</p>
",1
10775433,10775398,1,"<p>As you are storing the object by value (and not by pointer/referenence), changes to <code>vector[0]</code> are not reflected in <code>KeepCopy</code>, unless you share pointers to the same contained object in <code>MyClass</code> instances</p>

<p>If this is the case, you should implement a proper copy constructor that makes a deep copy of the original (instead of the default shallow copy that just blindly copies the values of pointers)</p>
",5
10775439,10775398,1,"<p>Exactly as you did it: <code>MyClass KeepCopy = vector[0];</code> will set <code>KeepCopy</code> to a copy of the original object (via its copy constructor). This copy has no connection to the vector, so it won't be affected by modifying the vector.</p>
",1
10775661,10775398,0,"<p>If I understand you correctly, the following steps happen in your function</p>

<ol>
<li>You do some things with vector[0] that modify it.</li>
<li>You reassign the whole vector.</li>
</ol>

<p>And the state of vector[0] after step 1, but before step 2, is the thing you want to return.  So that's the point in your code where you should make the copy.</p>

<pre><code>MyClass foo()
{
    //
    // some stuff
    //

    MyClass* a = new MyClass();
    vector[0] = *a;

    //
    // vector[0] gets modified
    //

    // you want vector[0]'s value here, so this is where you should create the copy
    MyClass KeepCopy = vector[0];


    //
    // Whole vector gets reassigned
    //

    return KeepCopy
}
</code></pre>
",0
11117474,11117450,36,"<p><strong>Most vexing parse</strong> comes into play here. You're actually declaring a function <code>i</code>, not an <code>int</code> variable. It shouldn't even compile (unless you actually have a function <code>i</code> defined somewhere... <strong>do you?</strong>).</p>

<p>To value-initialize the int, you need:</p>

<pre><code>int i = int(); 
</code></pre>
",12
16418285,16418242,2,"<p>Perhaps you meant something like this?</p>

<pre><code>class msg{
    typedef void (*callback_t)(void *);

    bool callback_check(callback_t callback);
};
</code></pre>

<p><code>void callback</code> attemtps to declare a parameter of type <code>void</code> (unrelated to the <code>callback</code> function pointer you declared previously), which is illegal.</p>

<p><code>void (*callback)(void *);</code> is a member declaration of type pointer to function. If that was your intention, you don't need to pass it to member function. You could do:</p>

<pre><code>class msg{
    void (*callback)(void *);
    bool callback_check()
    {
        return callback != nullptr;
    }
};
</code></pre>
",0
16418295,16418242,2,"<p>The type <code>void</code> basically means ""nothing"". And you can't have an argument to a function which is nothing. You have to give it a proper type.</p>

<p>If it's supposed to be the actual callback function, then declare it as a function pointer, e.g.:</p>

<pre><code>bool callback_check(const msg_type_e, void (*callback)(void*));
</code></pre>

<hr>

<p>However I would recommend you to use <a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow""><code>std::function</code></a> instead, because then you can pass all kind of functions (like lambdas, member function with the help of <a href=""http://en.cppreference.com/w/cpp/utility/functional/bind"" rel=""nofollow""><code>std::bind</code></a> or other callable objects that matches the signature):</p>

<pre><code>bool callback_check(const msg_type_e, std::function&lt;void(void*)&gt; callback);
</code></pre>

<p>Of course you should then make the <code>callback</code> member in the class also be a <code>std::function</code> object.</p>

<hr>

<p>Now to check if a <code>std::function</code> object have a valid callable ""function"" assigned to it, the class has a <a href=""http://en.cppreference.com/w/cpp/utility/functional/function/operator_bool"" rel=""nofollow"">boolean operator</a> so it can be used in boolean expressions. Like:</p>

<pre><code>if (this-&gt;callback)
{
    // Callback should be callable
    this-&gt;callback(...);
}
</code></pre>
",0
16418301,16418242,0,"<p>Your <code>callback</code> parameter is just plain wrong.  It should look this this:</p>

<pre><code>class msg{
//other stuffs before
        typedef void (*callback)(void *);
    bool callback_check(const msg_type_e, callback cb);
}
</code></pre>

<p>Parameter types of <code>void</code> don't mean a thing. They are not legal. The only place you can use <code>void</code> in a parameter list in C is when you want the function to take no parameters at all <code>void myfunc(void)</code> means that there will be no parameters.</p>

<p>A type you can pass to a function is <code>void*</code> which is a pointer to <code>void</code>, meaning that the type that is pointed to has no type associated with it.  Note that a pointer to void is something completely different to <code>void</code> by itself. </p>
",0
8730700,8730360,1,"<p>I see two problems with your code:</p>

<ol>
<li>You are making a lot of allocations (<code>new</code>) but you never free the memory.</li>
<li>In the <code>SendS</code> function you are taking the string length, but the data in that ""string"" is from a vector of integers and is binary. This means that the data can contain the string-terminating <code>'\0'</code> character (the integer 0).</li>
</ol>

<p>Besides that, I really don't follow what you are doing. Instead of reading into a vector, create a char-buffer and allocate enough memory to put the whole file into that buffer (<code>char *buffer = new char[length_of_file]</code>) and send it, with the length of the buffer first.</p>

<p>Something like this:</p>

<pre><code>std::pair&lt;size_t, char *&gt; getContFile(const char *pFile)
{
    ifstream vCin(pFile, ios::binary);
    ifstream::pos_type size;

    vCin.seekg(0, ios::end);
    size = vCin.tellg();
    vCin.seekg(0, ios::beg);

    char *buffer = new char[size];

    vCin.read(buffer, size);

    return std::make_pair(static_cast&lt;size_t&gt;(size), buffer);
}

void SendFile()
{
    SendS(""upFileUser"", strlen(""upFileUser""));
    std::pair&lt;size_t, char *&gt; vTmp = getContFile(""/usr/home/alex/Desktop/eval.tar"");

    SendS(vTmp.second, vTmp.first);

    delete [] vTmp.second;
}

void SendS(char *buffer, size_t length)
{
    // Send the length
    size_t tmp = htonl(length);
    write(pSocket, &amp;tmp, sizeof(tmp));

    // Send the buffer
    while (length &gt; 0)
    {
        ssize_t sent = write(pSocket, buffer, length);
        if (sent &lt;= 0)
        {
            // Some kind of error
            break;
        }

        buffer += sent;
        length -= sent;
    }
}
</code></pre>

<p>Do something similar on the receiving side.</p>
",1
9853117,9853085,3,"<pre><code>chdir(""cd /var/code/p1"")
</code></pre>

<p>should be</p>

<pre><code>chdir(""/var/code/p1"")
</code></pre>

<p>And the if test is incorrect since chdir returns 0 on success. You need</p>

<pre><code>if (chdir(""/var/code/p1"") == 0)
       system(""make"");    
</code></pre>
",1
9806479,9806435,15,"<p>Because you pass by value into your assignment operator:</p>

<pre><code>void operator=(const A a)
</code></pre>

<p>You probably meant to pass by reference and you should also return a reference to the assigned-to object:</p>

<pre><code>A&amp; operator=(const A&amp; a) { std::cout &lt;&lt; ""A assign"" &lt;&lt; std::endl; return *this; }
</code></pre>
",0
9806772,9806435,4,"<p>You seem to set up you assignment operator to be implemented properly:</p>

<pre><code>T&amp; T::operator= (T value) {
    value. swap(*this);
    return *this;
}
</code></pre>

<p>The argument is passed by copy to the assigment operator and the compiler actually needed to do this copy in your set up. If you had passed a temporary the copy could have been avoided:</p>

<pre><code>o2 = A();
</code></pre>

<p>Thus, the implementation above actually has a few interesting properties:</p>

<ul>
<li>it leverages already written functions: the copy constructor is either generated or written but does the Right Thing and if you want to have an assignment you probably want to have <code>swap()</code> member as well</li>
<li>the assignment is strong exception safe if the <code>swap()</code> operation is non-throwing as it should be. When allocators enter the picture things need to be done slightly different, though</li>
<li>the assignment tries to avoid actual copy operations as the copy during argument passing can be elided in some cases, i.e. the content is just <code>swap()</code>ed into place</li>
</ul>
",0
11831753,11831672,22,"<p><a href=""http://en.cppreference.com/w/cpp/io/basic_ios/imbue""><code>imbue</code></a> is inherited by <code>std::ostringstream</code> from <a href=""http://en.cppreference.com/w/cpp/io/ios_base""><code>std::ios_base</code></a> and it sets the locale of the stream to the specified locale. </p>

<p>This affects the way the stream prints (and reads) certain things; for instance, setting a French locale will cause the decimal point <code>.</code> to be replaced by <code>,</code>.</p>
",0
11831775,11831672,8,"<p>C++ streams perform their conversions to and from (numeric) types according to a <code>locale</code>, which is an object that summarizes all the localization information needed (decimal separator, date format, ...).</p>

<p>The default for streams is to use the current global locale, but you can set to a stream a custom locale using the <code>imbue</code> function, which is what your code does here - I suppose it's setting the default C locale to produce current locale-independent text (this is useful e.g. for serialization purposes).</p>
",0
9821436,9821372,10,"<p>Because after invalid input, the stream is in failed state and all further input operations are no-op. You always have to check the result of the input operation.</p>

<pre><code>do {
    std::cout&lt;&lt;""I need your password:""&lt;&lt;std::endl;          
    if (!(std::cin &gt;&gt; pswd)) {
        // clear error flags
        std::cin.clear();
        // discard erroneous input (include &lt;limits&gt;)
        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
    }
} while (pswd!=3855);
</code></pre>
",4
9821449,9821372,1,"<p>It is trying to read an <code>int</code> but it can take a peek into the buffer from STDIN. It notices that you have not got an <code>int</code> so the <code>cin&gt;&gt;</code> fails. (See <a href=""http://www.cplusplus.com/reference/iostream/istream/operator%3E%3E/"" rel=""nofollow"">fail bit</a>). </p>

<p>So it just goes around again. You need to check for failed type conversion.</p>
",0
9821503,9821372,1,"<p>I'm pretty sure you want to be reading in a string here, as there's nothing to control what the user is typing.</p>

<p>You want to read into a char buffer (the one below supports 256 characters) and then compare it with the password you're looking for using <code>strcmp</code>:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;iostream.h&gt;

static int pswd=0;
static char buffer[256];

int main()
{
    do
    {
        std::cout&lt;&lt;""I need your password:""&lt;&lt;std::endl;          
        std::cin&gt;&gt;buffer;
    }
    while (strcmp(""3855"", buffer));
    std::cout&lt;&lt;""Congratulations! Your password is correct! Your soul is free again!""&lt;&lt;std::endl;
}
</code></pre>

<p>Note that <code>strcmp</code> returns 0 when two strings match.</p>
",3
10146980,10146850,11,"<p>How about something like this:</p>

<pre><code>template &lt;typename U, typename T&gt;
void transfer_mat(Mat &amp; mat, T &amp; t)
{
    for (int i = 0, r = mat.rows; i != r; ++j)
    {
        for (int j = 0, c = mat.cols; j != c; ++j)
        {
            U src = mat.at&lt;U&gt;(i, j);
            U dst = mat.at&lt;U&gt;(i, j);

            t.transfer(src, dst);
        }
    }
}
</code></pre>

<p>Then you can say:</p>

<pre><code>switch(channels)
{
case 1:
    transfer_mat&lt;uchar&gt;(mat, t);
    break;
case 2:
    transfer_mat&lt;Vec3b&gt;(mat, t);
    break;
}
</code></pre>
",0
10146983,10146850,2,"<p>It's unclear as to the scope of your code (looks like a member function), and what type <code>t</code> is, but this should get you started:</p>

<pre><code>template&lt;typename AtT&gt;
Mat&amp; transfer_impl(Mat&amp; mat, T&amp; t)
{
    for (int i = 0; i &lt; mat.rows; ++i)
        for (int j = 0; j &lt; mat.cols; ++j)
            t.transfer(mat.at&lt;AtT&gt;(i, j), mat.at&lt;AtT&gt;(i, j));
    return mat;
};

Mat transfer(Mat const&amp; _mat, T&amp; t)
{
    Mat mat = _mat.clone();
    switch (mat.channels())
    {
    case 1:  return transfer_impl&lt;uchar&gt;(mat, t);
    case 3:  return transfer_impl&lt;Vec3b&gt;(mat, t);
    default: throw std::runtime_error(/*...*/);
    }
}
</code></pre>
",0
9152069,9152046,5,"<p>Creating a <code>shared_ptr</code> doesn't imbue magical powers on its pointee object. The magic is all in the <code>shared_ptr</code> &mdash; and its copies &mdash; itself. If you stop using it, you lose your reference counting; worse, because you used it <em>at some point</em>, the object will be automatically deleted when you don't expect it.</p>

<p>The <em>whole point</em> of having <code>shared_ptr</code> is that you know your object won't get destroyed when you're still using it somewhere.</p>

<p>In the following:</p>

<pre><code>T* foo() {
   shared_ptr&lt;T&gt; sp(new T());
   return sp.get();
   // ^ the only shared_ptr&lt;T&gt; referencing the obj is dead;
   // obj is deleted;
   // returned pointer invalid before you can even do anything with it
}
</code></pre>

<p>your pointer is immediately invalid.</p>

<p>There may well be circumstances in which you extract a raw pointer, but these should be rare. If you are in a function where you <em>know</em> you don't need the reference counting, then just pass the <code>shared_ptr</code> in by reference.</p>
",0
9168656,9168641,3,"<pre><code>#include &lt;algorithm&gt;
</code></pre>

<p>Have a look at the existing containers provided by the C++ standard, and functions such as <code>for_each</code>.</p>

<p>For a comparison of C++ container iteration to interfaces in ""modern"" languages, see <a href=""https://stackoverflow.com/a/8764816/103167"">this answer of mine</a>.  The other answers have good examples of what the idiomatic C++ way looks like in practice.</p>

<p>Using templated functors, as the standard containers and algorithms do, will definitely give you a speed advantage over virtual dispatch (although sometimes the compiler can devirtualize calls, don't count on it).</p>
",3
9168665,9168641,0,"<p>A function template perhaps:</p>

<pre><code>template &lt;typename C&gt;
void process(C &amp; c)
{
    typedef typename C::value_type type;
    for (type &amp; x : c) { do_something_with(x); }
}
</code></pre>

<p>The iteration will use the containers iterators, which is generally as efficient as you can get.</p>

<p>You can specialize the template for specific containers.</p>
",0
9168681,9168641,3,"<p>C++ has iterators already. It's not a particularly ""Java"" thing. (Note that their interface is different, though, and they're much more efficient than their Java equivalents)</p>

<p>As for the second approach, calling a virtual function <em>for every element</em> is going to hurt performance if you're worried about throughput.</p>

<p>If you can (pre-)sort your data so that all objects of the same type are stored consecutively, then you can select the function to call <em>once</em>, and then apply it to all elements of that type. Otherwise, you'll have to go through the indirection/type check of a virtual function or another mechanism to perform the appropriate action for every individual element.</p>
",0
9168694,9168641,1,"<p>What gave you the impression that iterators are not very C++-like? The standard library is full of them (see <a href=""http://www.cplusplus.com/reference/std/iterator/"" rel=""nofollow"">this</a>), and includes a wide range of algorithms that can be used to effectively perform tasks on a wide range of standard container types.</p>

<p>If you use the STL containers you can save re-inventing the wheel and get easy access to a wide variety of pre-defined algorithms. This is almost always better than writing your own equivalent container with an ad-hoc iteration solution.</p>
",2
8802709,8802682,4,"<p>It means that the compiler does not know what a <code>Vertex</code> is. It is not defined (or is not defined properly) in any of the header files that you included. Hence the function that tries to return a pointer to one cannot be compiled either.</p>

<p>Because you are only dealing with a pointer to a <code>Vertex</code> here in your header file, you could forward declare the class:</p>

<pre><code>class Vertex;

class Sphere
{   
    public:
      // ...
</code></pre>

<p>...but then, you do have to include the proper definition in your cpp file before accessing any methods or other members of the class.</p>
",3
8802727,8802682,0,"<p>What is the definition of Vertex? Maybe you need a namespace for it?<br>
And the second error is caused by the first: since the compiler doesn't know what a Vertex* is, it can't create the create_sphere function.</p>
",0
8802781,8802682,1,"<blockquote>
  <p>¡®Vertex¡¯ does not name a type</p>
</blockquote>

<p>This means that the compiler has not seen a declaration of <code>Vertex</code>, and so doesn't know that it's a type. Presumably it's defined in a header file that you're not including; you should include that from your header file.</p>

<p>(If it's a class type, then you only need to add a forward declaration (<code>class Vertex;</code>) to your <code>Sphere.h</code>, and include the header from <code>Sphere.cpp</code>. This would be a better option, since it doesn't introduce a header file dependency.)</p>

<blockquote>
  <p>¡®class Sphere¡¯ has no member named ¡®create_sphere¡¯</p>
</blockquote>

<p>This is a result of the previous error; the compiler failed to understand the declaration of <code>create_sphere</code>, so does not know that it exists. Fixing the first error will also fix this.</p>
",0
15849879,15849821,2,"<p>According to your comment, you are actually initializing tab to be <code>tab[0][0]</code>. I don't know how come the compiler allows that, but the important thing is that you're <strong>writing outside your array bounds, triggering <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a></strong>.</p>

<p>Try dynamically allocating your array <em>after</em> reading in n and m:</p>

<pre><code>int n, m;
file &gt;&gt; n &gt;&gt; m;

int **tab = new int* [n];
for(size_t i = 0; i &lt; n; ++i)
{
  tab[i] = new int[m];
}
</code></pre>

<p>This way you'll always be sure to allocate only as much memory as you need.</p>

<p>Also, don't forget to delete the array when you're done:</p>

<pre><code>for(size_t i = 0; i &lt; n; ++i) delete[] tab[i];
delete[] tab;
</code></pre>

<p>As you can see this method tends to add a bit too much unnecessary complexity. An elegant alternative would be using a container such as a <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>:</p>

<pre><code>using namespace std;

vector&lt;vector&lt;int&gt;&gt; tab;

  for(int i = 0; i &lt; n; ++i) {
    vector&lt;int&gt; current_row;
    for(int j = 0; j &lt; m; ++j) {
      int buff;
      file &gt;&gt; buff;
      current_row.push_back(buff);
    }

    tab.push_back(current_row);
  }
</code></pre>
",0
15849885,15849821,1,"<pre><code>int n=0, m=0; int tab[n][m];
</code></pre>

<p>This is not legal C++ for two reasons:</p>

<ol>
<li><p>Dimensions of an array must be constant expressions. <code>n</code> and <code>m</code> are not.</p></li>
<li><p>You are creating an array of 0 size.</p>

<blockquote>
  <p>If the constant-expression (5.19) is present, [...] its value shall be greater than zero.</p>
</blockquote></li>
</ol>

<p>Your compiler is accepting it because it has extensions that accept both of these. Nonetheless, your array has size 0 and so it has no elements. Anything you attempt to write to it will be outside the bounds of the array.</p>

<p>Reading <code>myfile&gt;&gt;n&gt;&gt;m;</code> doesn't automatically change the size of the array. You already declared it as being size 0. Nothing you do will change that.</p>

<p>Instead, you'd be much better off using a standard library container, such as a <code>std::vector</code>, which can change size at run-time. Consider:</p>

<pre><code>myfile &gt;&gt; n &gt;&gt; m;
std::vector&lt;std::vector&lt;int&gt;&gt; tab(n, std::vector&lt;int&gt;(m));
</code></pre>

<p>You can then use this <code>tab</code> object in exactly the same way as you have above.</p>
",1
9811689,9811677,1,"<p>Yes, you either create the object with <code>new</code> or use smart pointers instead.</p>

<p>Your intuition is correct:</p>

<pre><code>ObstacleManager::ObstacleManager(Application *lApp)
{
    //...
    StandardObstacle obstacle(obstacleVerts,-0.7f,0.0f,4);
    obstacle.manager=this;
    lApp-&gt;characters.push_back(&amp;obstacle);
}   //obstacle is destroyed here
</code></pre>

<p>The object <code>obstacle</code> is created in automatic storage. Its lifetime is limited by its enclosing scope, which is the closing bracket in the constructor.</p>

<p>So you take the address of an object, push it into your vector, and then the object is destroyed. That means that, inside the vector, you now have a dangling pointer.</p>

<p>This will most certainly lead to <strong>undefined behavior</strong>.</p>

<p>You can either use <code>new</code>, as you have, and make sure to clean up the memory. Or you can use smart pointers - which is more C++-ish than raw pointers.</p>
",0
9811706,9811677,2,"<p>You are passing the address of a local object to the vector, the local object does not exist once the constructor returns and your vector then has a pointer which points to invalidated memory.    </p>

<p>You will have to make the object persist, possible ways are:<br>
Just push the object by value or<br>
Use dynamically allocated object but instead of raw pointer use a smart pointer like <code>shared_ptr</code> as the vector element type.</p>
",3
11049053,11048911,1,"<p>You can't do type choice in <em>C++</em> at runtime. That is because <em>C++</em> is one of the <a href=""http://en.wikipedia.org/wiki/Strong_typing"" rel=""nofollow"">Strongly typed</a> languages.</p>

<p>You could do something similar to what you are suggesting in e.g. Python -- where variables are happy to change their type during runtime.</p>

<p>You can do something close -- but not quite the same, with inherited and derived classes. If you have a superclass, you could have a ""factory"" function that returns a pointer to a superclass (containing a diff object depending on some input). Now if all the objects have the desired functionality implemented, you could call a function on the pointer. E.g.:</p>

<pre><code>class Base{
    virtual void functionality();
};

class Squirrel : public Base{
    void functionality() {
        std::cout &lt;&lt; ""I love hazelnuts!"" &lt;&lt; std::endl;
    }
};

class Box : public Base{
    void functionality() {
        std::cout &lt;&lt; ""Stuff can be put in here!"" &lt;&lt; std::endl;
    }
};


Base *factoryMethod(std::string someInput){
     if (someInput == ""1"")
         return new Squirrel();
     else
         return new Box();
}

int main(void){
    std::cin &gt;&gt; input;
    Base *object = factoryMethod(input);
    object-&gt;functionality();
    return 0;
}
</code></pre>
",3
11053448,11048911,1,"<p>This is the low tech way of doing it. I don't know exactly what you mean by argument types array, but let's assume you are given some kind of vector called <code>args</code>, and you can determine if an element is a number or not, and convert the element into a number or string. Then, you can implement a loop like this one:</p>

<pre><code>std::string s[3];
int n[3];
unsigned mask = 0;
for (int i = 0; i &lt; args.size(); ++i) {
    if (is_number(args[i])) {
        mask |= (1U &lt;&lt; i);
        n[i] = get_number(args[i]);
    } else {
        s[i] = get_string(args[i]);
    }
}
</code></pre>

<p>And then, switch on the mask:</p>

<pre><code>switch (mask) {
case 0x01: call(n[0], s[1], s[2]); break;
case 0x07: call(n[0], n[1], n[2]); break;
default:
    std::cout &lt;&lt; ""unhandled combination: "" &lt;&lt; mask &lt;&lt; std::endl;
    break;
}
</code></pre>
",0
11050157,11048911,1,"<p>You could simply write anoverloaded member function with the relevant params?</p>

<p>If you are receiving an unknown number of arguments and want to call the correct functions based upon them then you will need to some additional work.  Perhaps have an enum as the first parameter which implies a parameter set e.g.:</p>

<pre><code>enum eParamList
{
    eParamList_START,
    IntIntInt,          // following data is 3 ints
    IntIntChar,         // following data is int, int, bool (only joking its a char)
    eParamList_ENDS
}
</code></pre>

<p>Or something like this?</p>
",0
11536497,11536028,1,"<p>You could do a quick test and compare the pointers returned by two calls to p_Helper->getSomeclass();</p>

<pre><code>bool do_not_delete =  p_Helper-&gt;getSomeclass() ==  p_Helper-&gt;getSomeclass();
</code></pre>

<p>If both pointers are equal, you are probable getting a pointer that is meant to be a (maybe optional) reference.</p>

<p>hth 
Torsten</p>
",1
11536072,11536028,2,"<p>If you are not the author of the p_Helper class, first:</p>

<p>Singletons usually do not have public destructors so in that case that would not compile.</p>

<p>Second, if you 'just get' a bare pointer without any further information, there's no way to know if you can delete it or not. <strong>That information needs to be provided in documentation</strong> for you to use the function/method.</p>

<p>If you are <em>designing</em> p_Helper, then let <em>it</em> return the smart pointer, rather than a bare pointer. If the method creates a new resource for each call, I suggest <code>unique_ptr</code>, have a look here: <a href=""https://stackoverflow.com/questions/6876751/differences-between-unique-ptr-and-shared-ptr"">Differences between unique_ptr and shared_ptr</a></p>
",4
11536075,11536028,1,"<p>The typical approach to this scenario is to use reference counting and a smart pointer like <code>shared_ptr</code> that will usually take care of all reasonable cases.</p>
",5
11536096,11536028,1,"<p>You can use raw pointers in this case.</p>

<pre><code>void f() {
   SomeClass *p_someClass = p_Helper-&gt;getSomeclass();
   p_someClass-&gt;doSomething();
}
</code></pre>
",4
11536356,11536028,3,"<p>What does the documentation of the helper class say?  That is the
ultimate issue.  You can't return a pointer or a reference without
specifying its lifetime: if it's a pointer to something internal in the
class, it might be the lifetime of the class object, but it could also
have static lifetime (until the end of the program&mdash;this is the
case of functions which return string literals as <code>char const*</code>), it
might have some shorter lifetime (e.g. references returned by
<code>operator[]</code> by the standard library containers), or the helper might
expect you to delete it.  The latter should be rare, however, in pure 
C++; the convention in such cases is to return <code>std::auto_ptr</code> (or
<code>std::unique_ptr</code> if you have a very modern compiler).  (In C, it was
frequent to document that the returned pointer had to be freed by
calling a specific function in the library which returned it.  Without
destructors, you have to do something to regain control at the end.)</p>

<p>In the absense of documentation, I'm tempted to say that the library is
not usable.  Still... supposing that it points to something internal and
has the lifetime of the class is probably the most reasonable guess;
it's the case which programmers most easily forget to document.
Deleting it, or putting it in a smart pointer which will delete it, is
probably not a good idea: enough has been said about ownership issues
that it seems unlikely that a class author would fail to document the
fact if you were supposed to delete it.  (Note, however, that the
lifetime issues remain even if you're not supposed to delete it.)</p>
",2
9206879,9181633,0,"<p>thanks hmjd for response .
 it works just as i eliminate some parts in prelim and setup header as :
 in prelim header:</p>

<pre><code>public: elastic(/*const Triangulation&lt;dim&gt; *triang*/);
 ~elastic() ; 
void run() ; in setup header :
 elastic&lt;dim&gt;::elastic(/*const Triangulation&lt;dim&gt; *triang*/): dof_handler (triangulation), 

fe (FE_Q&lt;dim&gt;(1)) 
{/*triangulation.copy_triangulation (*triang);*/} 
</code></pre>

<p>but these parts must not be deleted and actually i want to know what's the matter with these parts. </p>

<p>my apology i forgot to mention that with aplying changes suggested and without eliminating beforementioned parts the error is changed to : </p>

<pre><code> ==============debug========= main.cc  -&gt;  main.g.o main.g.o
main.cc: In function ¡®int main()¡¯:
main.cc:11:43: error: no matching function for call to ¡®elastic&lt;2&gt;::elastic()¡¯
main.cc:11:43: note: candidates are:
setup.h:12:3: note: elastic&lt;dim&gt;::elastic(const dealii::Triangulation&lt;dim&gt;*) [with int dim = 2]
setup.h:12:3: note:   candidate expects 1 argument, 0 provided
prelim.h:38:7: note: elastic&lt;2&gt;::elastic(const elastic&lt;2&gt;&amp;)
prelim.h:38:7: note:   candidate expects 1 argument, 0 provided
make: *** [main.g.o] Error 1
s
</code></pre>
",0
9191944,9191783,2,"<p>There are a whole range of libraries for drawing graphics using C/C++.</p>

<p>If you are on Windows and not afraid to use platform dependent code then you can use the <a href=""http://en.wikipedia.org/wiki/Graphics_Device_Interface"" rel=""nofollow"">Windows GDI</a> API. GDI is usually used to build interactive GUI Widgets, such as custom drawn buttons and edit boxes.</p>

<p>If you are looking for 3D rendering you can use Microsoft's own <a href=""http://en.wikipedia.org/wiki/DirectX"" rel=""nofollow"">DirectX</a> API. There is also an <a href=""http://en.wikipedia.org/wiki/OpenGL"" rel=""nofollow"">OpenGL</a> Windows implementation.</p>
",9
11825717,11825409,0,"<p>you can use write on Unix platforms:</p>

<pre><code>man 2 write;
</code></pre>

<p>this function allow you to specify the length of element to print.</p>

<p>but for sure, <code>snprintf</code> is a portable solution (as <code>size_t</code> size allow you to do it so).</p>

<p>doing that be careful in order not to segfault.</p>

<p>nb:
you can set char with value like <code>0</code> or <code>255</code>, or with negative value if it's a <code>signed char</code>...
you can set it with <code>0</code>, or with <code>48</code>, there are no differences.</p>
",0
11826193,11825409,0,"<p><strong>char* arr= new char[10];</strong> </p>

<p>as you have defined array of characters, when you assign 0 to any array member and pass whole array or print the array, the reason it takes it as data end because 0 is actually NULL and every character string is terminated by NULL. So if you really want to assign value of character 0 then you can assign ascii value of 0 or '0'.</p>

<p>hope it helps </p>
",1
11825801,11825409,1,"<p>You say you are ¡°not able to see any further data¡±, but you did not describe what you are doing to see the data. Are you printing it with printf and a %s format? Are you displaying it in a debugger?</p>

<p>When you use string operations on char data, a zero commonly indicates the end of the string. This is true when using %s with printf or when using strcpy or strlen. However, an array of char may be treated numerically. After <code>arr[3] = 3;</code>, 3 is stored in arr[3], and it is just a matter of seeing it.</p>

<p>You can print char data as decimal numerals by using the %d format with printf. %d prints one number, so you need to pass it one number to print, such as arr[0], arr[3], or, in a loop, arr[i]. This is different from %s, where you pass a pointer (such as the array, which becomes a pointer to the first element) to printf, and it prints multiple characters.</p>

<p>If you are looking at the char array with a debugger, you can likely look at arr[3] individually to see that it contains 3. Your debugger may have a way to display an array of char as a sequence of decimal numerals instead of as a string.</p>
",1
11825430,11825409,2,"<p>You are storing integers in a character array. Try something like this:</p>

<pre><code>char* arr= new char[10];
arr[0] = '1';
arr[1] = '2';
arr[2] = '0';
arr[3] = '3';
</code></pre>
",6
11825460,11825409,0,"<p>I think you should write it as:</p>

<pre><code>char* arr= new char[10];
arr[0] = '1';
arr[1] = '2';
arr[2] = '0';
arr[3] = '3';
</code></pre>

<p>Such that you do not need to use zero-value which indicates the termination as said by Aamir</p>
",0
11825484,11825409,2,"<p>You're syntax was in C++. But, disregarding that, you could use <code>snprintf</code> to store your data:</p>

<pre><code>snprintf(arr, 10, ""%d"", 1203);
</code></pre>
",0
11825536,11825409,0,"<p>Your debugger tool, as most, will take notice that it is displaying a char array. That from of data is commonly used in C as storage for null-terminated strings.</p>

<p>A null-terminated string, if the named wasn't revealing enough, is a bunch of characters (printable or not), finished by a zero. That mark tells printf and alike when to stop printing.</p>

<p>It also told the function used by the debugger to stop printing. To avoid this you should either tell your debugger ""this ain't no string, fool!"" or simply redeclare as short.</p>

<p>You seam to be a starter so take this advice: forget about ints, use short or longs. The int size is machine dependent, and it will get you into ""I assummed it was Xbits"" trouble later on.</p>
",5
11826874,11825409,1,"<p><code>0</code> means end of string in the <code>char*</code>.</p>

<p>Because <code>char*</code> is a string in C and it exists to be used as char array not as <code>integer</code> array. All function related on string are intended to be used with a string.</p>

<p>You can use <code>int*</code> to store <code>integer</code>s.</p>

<p>You can do the binary operations manually like this : </p>

<pre><code>int value = 1245; 

char* temp = new char[4]; 

temp[0] = (char)(value &gt;&gt; 24);
temp[1] = (char)(value &gt;&gt; 16);
temp[2] = (char)(value &gt;&gt; 8); 
temp[3] = (char)value;

return temp;
</code></pre>

<p>you can use <code>uint8_t</code> or <code>int</code> instead of <code>char</code>.</p>

<p>the <code>(char*)((int)value)</code> is not good because you cast the <code>int</code> to <code>char*</code>, but the <code>char*</code> is the variable <code>temp</code> not the number to be stored in <code>temp</code>.</p>

<p>If pointers is a new thing for you, it will be helpful to do some exercises in pointers : manipulate arrays, lists,...</p>
",6
16923295,16923221,2,"<p>The compiler at least needs a valid prototype for the function to then determine if it is used (and then subsequently compile the body or not).</p>
",0
16923391,16923221,2,"<p>It is because of lazy instantiation. When you do <code>DEF&lt;ABC&gt; obj</code>. The compiler will look at the prototype/definition of the class DEF. Thus <code>void f0(typename T::ab)</code> fails because ab doesn't exist and you get a compile error. </p>

<p>The reason why you don't get a compiler error for <code>void f1(){typename T::ab var}</code> is because it has never been instantiated. If you do <code>obj.f1()</code>, you will see that it will error out the same message as the one associated with DEF::f0. </p>
",0
16923432,16923221,4,"<p>Each member function <em>declaration</em> is an integral part of the entire <em>class definition</em>. Meanwhile, member function <em>definition</em> is a completely independent entity, which is not a part of class definition.</p>

<p>When you instantiate an object of some specialized template class, you are instantiating the entire definition of that class, i.e. you are ""using"" the entire definition of that class, which in turn means that you are ""using"" all member declarations as well.</p>

<p>Below is the part that turns into the class <em>definition</em> in your case, once the template is specialized</p>

<pre><code>template&lt;typename T&gt;
class DEF
{
   void f0(typename T::ab);
   void f1();
};
</code></pre>

<p>All the above has to be valid for the given value of <code>T</code> in order for the class definition to be usable, i.e. in order to be able to declare <code>DEF&lt;ABC&gt; obj;</code>.</p>

<p>Meanwhile the definition of</p>

<pre><code>template&lt;typename T&gt; void DEF&lt;T&gt;::f1() 
{
  typename T::ab var;
}
</code></pre>

<p>is an independent template. It is only instantiated if you use <code>f1</code>.</p>
",1
13479796,13479724,1,"<p>Your teacher meant that instead of hardcoding constants all over the place you need to declare your i as enum.</p>

<pre><code>enum some_type {
    type_techlit=1, type_fiction, type_textbook
};

some_type i;
</code></pre>

<p>And then read up on enums.</p>
",0
13479999,13479724,4,"<p>just use loops instead of gotos of it is going to be a spaghetti code.
Enums are fine to does not care about the numbers for the defines, because they are incremented automatically if you add a new one.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
void SetType();

using namespace std;
string Type;
int main()
{
    SetType();

    cout &lt;&lt; ""so you choose "" &lt;&lt; Type &lt;&lt; endl;
    return 0;
}
enum select
{
    Technical_literature = 1,
    Fiction_literature,
    Textbook
};

void SetType() {
    cout&lt;&lt;""Book SetType""&lt;&lt;endl;
    while(1)
    {
        cout&lt;&lt;""Please Select from the list: \n 1- Technical literature \n 2- Fiction literature \n 3- Textbook""&lt;&lt;endl;
        int i;
        cin &gt;&gt; i;

        switch(i) {
        case Technical_literature:
            Type=""Technical literature"";
            return;
        case Fiction_literature:
            Type=""Fiction literature"";
            return;
        case Textbook:
            Type=""Textbook"";
            return;
        default:
            cout &lt;&lt; ""Erorr you entered a wrong choice"" &lt;&lt; endl;

        }
    }
}
</code></pre>
",1
8788845,8737019,0,"<p>There is question addressing similar topic:</p>

<p><a href=""https://stackoverflow.com/a/2369593/1010666"">https://stackoverflow.com/a/2369593/1010666</a></p>

<p>Summary: do not try to write pointers into non-pointer variable.
If you need to print out the pointer value, there are other solutions.</p>
",0
8737391,8737019,1,"<p>What you probably want is to use <code>std::ostream</code>'s formatting of addresses:</p>

<pre><code>int x(0);
std::cout &lt;&lt; &amp;x &lt;&lt; '\n';
</code></pre>

<p>As to the length of the produced string, you need to determine the size of the respective pointer: for each used byte the output will use two hex digit because each hex digit can represent 16 values. All bytes are typically used even if it is unlikely that you have memory for all bytes e.g. when the size of pointers is 8 bytes as happens on 64 bit systems. This is because the stacks often grow from the biggest address downwards while the executable code start at the beginning of the address range (well, the very first page may be unused to cause segmentation violations if it is touched in any way). Above the executable code live some data segments, followed by the heap, and lots of unused pages.</p>
",0
8737039,8737019,2,"<p>On most 64-bit targets, int is still 32-bit, while pointer is 64bit, so it won't work.</p>

<p><a href=""http://en.wikipedia.org/wiki/64-bit#64-bit_data_models"" rel=""nofollow"">http://en.wikipedia.org/wiki/64-bit#64-bit_data_models</a></p>
",8
8737085,8737019,7,"<p>No, that's not safe. There's no guarantee <code>sizeof(int) == sizeof(int*)</code> </p>

<p>On a 64 bit platform you're almost guaranteed that it's not. </p>

<p>As for the ""hexadecimal value"" ... I'm not sure what you're talking about. If you're talking about the textual representation of the pointer in hexadecimal ... you'd need a string.</p>

<p><strong>Edit to try and help the OP based on comments:</strong></p>

<p>Because computers don't work in hex. I don't know how else to explain it. An <code>int</code> stores some amount of bits (binary), as does a long. Hexadecimal is a textual representation of those bits (specifically, the base16 representation). strings are used for textual representations of values. If you need a hexadecimal representation of a pointer, you would need to convert that pointer to text (hex). </p>

<p>Here's a c++ example of how you would do that:</p>

<h1>test.cpp</h1>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main()
{

    int *p; // declare a pointer to an int. 
    std::ostringstream oss; // create a stringstream
    std::string s; // create a string

    // this takes the value of p (the memory address), converts it to 
    // the hexadecimal textual representation, and puts it in the stream
    oss &lt;&lt; std::hex &lt;&lt; p;

    // Get a std::string from the stream
    s = oss.str();

    // Display the string
    std::cout &lt;&lt; s &lt;&lt; std::endl;

}
</code></pre>

<p>Sample output:</p>

<blockquote>
  <p>roach$ g++ -o test test.cpp<br>
  roach$ ./test<br>
  0x7fff68e07730<br></p>
</blockquote>

<p>It's worth noting that the same thing is needed when you want to see the base10 (decimal) representation of a number - you have to convert it to a string. Everything in memory is stored in binary (base2)</p>
",3
11165393,11165237,7,"<p>First of all: <strong>there is no definitive answer to this question.</strong></p>

<p>The reason is that the performance depends on the library implementation, the compiler and the options you use, the operating system you use and the CPU architecture you use.</p>

<p>The book is somewhat old(2005, hardware &amp; software have evolved), and the code it has has been tested on old compilers, on old implementations and on old hardware. Whatever it says about the performance is based on the observations by it's authors which definitely would vary between different people trying out the code with different compiler, library and hardware combinations.</p>

<p>The best you can do, is to try yourself. Simple ""benchmarks"" like these won't tell much about performance between C-style strings vs. <code>std::string</code>s in <em>real world</em>, common situations unless they provide extensive coverage of as many possible ways to test and compare the performance as possible - something which would be quite a big project itself.</p>

<p>Note that compiler optimizations can deceive you with code like shown in the book. For example because of the empty <code>if</code>-blocks, the whole <code>if</code>-statement and the expression within it(in this case for example call to strcpy) can be removed(*). It can be <strong>very</strong> hard to do meaningful, real-world applicable benchmarks with code blocks as given in the book. </p>

<p>Also note that whatever the results of these micro-benchmarks turns out to be, only applies to the operations they benchmark - in other words - just because string allocation, copy and comparison seem to be <em>x</em> times faster with either <code>std::string</code> or C-style string, does not mean that the other is <em>x</em> times faster than the other in general!</p>

<p>*: Tested the C-style string code with GCC 4.7.1 with <code>-Ofast</code> and there is no reference to <code>strcmp</code> in the compiled executable, suggesting that the string comparison was eliminated as unnecessary in the code - which it indeed <em>is</em> - because the <code>if</code>-block is empty so there's no reason to even have the whole <code>if</code> there in the first place!</p>

<p>To add my own observations: I broke the two pieces of code to distinct functions and then made 100 repeated calls(with a <code>for</code>-loop) to one of them and then measured the running time with the <code>time</code> unix-utility. Compiled with GCC 4.7.1 and <code>-Ofast</code>.</p>

<p>100 calls to the C-Style string function took about 7.05 seconds(3 runs, variation between 7 and 7.1 seconds) while the 100 calls to the std::string version took <strong>only</strong> around 1.4 seconds on average over 3 runs! Indeed, this would suggest that std::string far outperforms C-style strings.</p>
",2
11165488,11165237,1,"<p>Having agreed to what @zxcdw said, I'd like to add:</p>

<p><strong>There's no inherent reason that the library <code>std::string</code> should be (significantly) slower than the C-style string.</strong></p>

<p><code>std::string</code> could actually be doing more work, because it could be checking boundaries on each element access (which you should be able to turn off with a compile-time option), etc. It could actually be doing less work, because it knows the length (hence the end) of the string and doesn't have to search for it when you append something. <strong>So you never know (without measuring).</strong></p>

<p>On the other hand, knowing more means a bigger memory footprint (two pointers instead of one), and this could also affect the performance (due to more cache misses) when you deal with lots of different string objects in a short time. But I don't think this is what's happening in your case.</p>
",3
11165738,11165237,10,"<p>Your conclusion that C style strings are faster with this example with your compiler &amp; machine, is almost certainly because  &ndash; one must presume &ndash; you</p>

<ul>
<li>forgot to turn on optimization,</li>
<li>forgot to make the string length ""unknown"" to the compiler (this is tricky) so as to prevent it from optmizing away <code>strlen</code> calls, and</li>
<li>forgot and turn off safety range checking (if applicable) which would slow down <code>std::string</code>.</li>
</ul>

<p>Here's the code I tested with:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
using namespace std;

extern void doNothing( char const* );

class StopWatch
{
private:
    clock_t     start_;
    clock_t     end_;
    bool        isRunning_;
public:
    void start()
    {
        assert( !isRunning_ );
        start_ = clock();
        end_ = 0;
        isRunning_ = true;
    }

    void stop()
    {
        if( isRunning_ )
        {
            end_ = clock();
            isRunning_ = false;
        }
    }

    double seconds() const
    {
        return double( end_ - start_ )/CLOCKS_PER_SEC;
    }

    StopWatch(): start_(), end_(), isRunning_() {}
};

inline void testCStr( int const argc, char const* const argv0 )
{
    //  C-style character string implementation
    //const char *pc = ""a very long literal string"";
    const char *pc = (argc == 10000? argv0 : ""a very long literal string"");
    //const size_t  len = strlen(pc +1);    //  space to allocate
    const size_t  len = strlen(pc)+1;    //  space to allocate

    //  performance test on string allocation and copy
    for (size_t ix = 0; ix != 1000000; ++ix) {
        char *pc2 = new char[len + 1];  //  allocate the space
        strcpy(pc2, pc);                //  do the copy
        if (strcmp(pc2, pc))            //  use the new string
            //;   //  do nothing
            doNothing( pc2 );
        delete [] pc2;                  //  free the memory
    }
}

inline void testCppStr( int const argc, char const* const argv0 )
{
    //  string implementation
    //string str(""a very long literal string"");
    string str( argc == 10000? argv0 : ""a very long literal string"" );

    //  performance test on string allocation and copy
    for(int ix = 0; ix != 1000000; ++ix) {
        string str2 = str;  //  do the copy, automatically allocated
        if (str != str2)    //  use the new string
            //;   //  do nothing
            doNothing( &amp;str2[0] );
    }    //  str2 is automatically freed
}

int main( int argc, char* argv[] )
{
    StopWatch   timer;

    timer.start();  testCStr( argc, argv[0] );  timer.stop();
    cout &lt;&lt; ""C strings: "" &lt;&lt; timer.seconds() &lt;&lt; "" seconds."" &lt;&lt; endl;

    timer.start();  testCppStr( argc, argv[0] );  timer.stop();
    cout &lt;&lt; ""C++ strings: "" &lt;&lt; timer.seconds() &lt;&lt; "" seconds."" &lt;&lt; endl;
}
</code></pre>

<p>Typical result:</p>

<pre>
[d:\dev\test]
> g++ foo.cpp doNothing.cpp -O2

[d:\dev\test]
> a
C strings: 0.417 seconds.
C++ strings: 0.084 seconds.

[d:\dev\test]
> a
C strings: 0.398 seconds.
C++ strings: 0.082 seconds.

[d:\dev\test]
> a
C strings: 0.4 seconds.
C++ strings: 0.083 seconds.

[d:\dev\test]
> _
</pre>

<p>The said, C++ strings are not generally the fastest possible implementation of strings.</p>

<p>Generally, immutable strings (reference counted) beat C++ strings by a good margin, and, surprising to me when I learned that, a string implementation that simply copies the string data is faster still, when it uses an appropriate, fast custom allocator. However, don't ask me how to implement the latter. I only saw the code and test results in another forum, which someone graciously provided after I'd pointed out the general superiority of immutable strings in a discussion with STL and there was some disagreement. ;-)</p>
",11
10796070,10796041,5,"<p>Symbol (not just functions) name mangling comes into play at the linking stage. You're getting a compiler error.</p>

<p>The compiler doesn't see the mangled name. It just sees you have a function called <code>func</code> that returns an <code>int</code> and takes no parameters, and so can tell you your code is illegal.</p>
",0
10796071,10796041,5,"<p>This is an compilation error.<br>
Compiler checks for the validity of the C++ program as per the C++ Standard specification.</p>

<blockquote>
  <p><strong>Why does the compiler report an error here?</strong>    </p>
</blockquote>

<p>Because compiler <strong><em>can see</em></strong> that return type of the function is <code>int</code>and it is being used to initialize a variable of the type <code>std::string</code> and there is no valid implicit conversion for it.       </p>

<p>Note that the language is designed in such a way it allows the compiler to do these kind of type checking, C++ is a <strong><em><a href=""http://en.wikipedia.org/wiki/Programming_language#Static_versus_dynamic_typing"" rel=""noreferrer"">statically typed language</a></em></strong>.</p>
",0
9149894,9149875,5,"<p>The simplest way is to declare it in a header as <code>const static int i=10;</code> and include that header in all the <code>.cpp</code> that need that constant. This will allow it to be ""inlined"" by the compiler in every object file, still avoiding ODR violations.</p>

<p>---edit---</p>

<p>Actually, in C++ the <code>static</code> is not required, since <code>const</code> objects have internal linkage by default. But in C, you have to put that <code>static</code> (and in C++ it doesn't hurt).</p>

<p>Why is this better than the <code>extern</code> method? Because:</p>

<ol>
<li>it's more idiomatic. In C++ you'll always write integral constants in headers as <code>const</code> variables (and that's the very reason why they have internal linkage by default).</li>
<li>it's less typing. You just have to write the <code>const</code> declaration once, then your constants are just a <code>#include</code> away.</li>
<li>it (usually) produces more efficient code. The definition of <code>extern</code>-declared variables cannot be accessed by the compiler when it is producing the current object module, so it cannot optimize it by putting its actual value as an immediate value in the produced machine code, it cannot eliminate branches that cannot be reached with that value of the constant, ... Sure, cross-module optimization (""link time code generation"", ""whole program optimization"", ...) does exist, but at the moment compilers have more advanced optimizers than linkers.</li>
</ol>
",0
9149895,9149875,2,"<p>Put this global variable into header and <code>#include</code> this header in all .cpp files where you want to use it.</p>

<p>xyz.h:</p>

<pre><code>const int i = 10;
</code></pre>

<p>xyz.cpp:</p>

<pre><code>#include ""xyz.h""

void main()
{
    cout &lt;&lt; i;
}
</code></pre>

<p>Or if you want to avoid using header for this purpose, you can declare it as <code>extern const int i = 10;</code> in xyz.cpp, but then you have to declare this variable in abc.cpp too, so you should write <code>extern const int i;</code> at the beginning of abc.cpp in order to use it.</p>
",3
9149898,9149875,3,"<p>Add the keyword <code>extern</code> in front of it.   </p>

<p>Declare it in <code>abc.cpp</code> as:   </p>

<pre><code>extern const int i = 10;
</code></pre>

<p><code>const</code> variables in C++ have an internal linkage in C++(unlike C). So to be able to use it in another file you have to explicitly declare it as having external linkage.</p>
",3
9149902,9149875,11,"<p>You need to declare it <code>extern</code> in abc.cpp:</p>

<pre><code>extern const int i;
</code></pre>

<p><strong>EDIT</strong>: As stated in the comment below, in C++ (unlike C), to give a <code>const</code> variable external linkage, you need to declare it es <code>extern</code> also in xyz.cpp:</p>

<pre><code>extern const int i = 10;
</code></pre>

<p>Reference: <a href=""http://msdn.microsoft.com/en-us/library/357syhfh%28v=vs.71%29.aspx"" rel=""noreferrer"">MSDN</a></p>
",2
9149932,9149875,1,"<p>The same way as using extern variables. 
In the file xyz.cpp:</p>

<pre><code>extern const int i = 333;
</code></pre>

<p>In the file abc.cpp:</p>

<pre><code>extern const int i;
cout &lt;&lt; i;
</code></pre>
",0
9790732,9790483,4,"<p>Just to add little formalism here. Standard has strict definition for ""Copy constructor"" term (12.8 ):<br/>
<code>
A non-template constructor for class X is a copy constructor if its first parameter is of type X&amp;, const X&amp;,
volatile X&amp; or const volatile X&amp;, and either there are no other parameters or else all other parameters
have default arguments (8.3.6). [ Example: X::X(const X&amp;) and X::X(X&amp;,int=1) are copy constructors.
</code></p>
",0
9790529,9790483,7,"<p>A constructor with 2 (or more) <em>required</em> arguments is <em>not</em> a copy constructor.</p>

<p>1.:</p>

<pre><code>Sample s2(s1, 0);
</code></pre>
",2
9790558,9790483,2,"<p>A class will only really have one copy ctor, which can be invoked with only one argument. It can take two (or more) arguments, but only if it provides default values for the other arguments. Either way, the first argument must be a (normally const) reference to an object of the same type.</p>

<p>Your second ctor taking two arguments isn't really a copy ctor (at least as the term is normally used) -- it's just a ctor that happens to take an instance as an argument (may base the new instance on that argument, at least in part).</p>
",5
9791265,9791239,32,"<p>Simple:</p>

<pre><code>typedef LONGNAME LN;
</code></pre>

<p>Typedefs are used in C++ a bit like ""variables which can store types"". Example:</p>

<pre><code>class Car
{
public:
    typedef std::vector&lt;Wheel&gt; WheelCollection;

    WheelCollection wheels;
};
</code></pre>

<p>By using <code>Car::WheelCollection</code> everywhere instead of <code>std::vector&lt;Wheel&gt;</code>, you can change the container type in one place and have all your code reflect the changes. This is the C++ way to abstract data types (whereas eg. in C# you'd have a property returning <code>IEnumerable&lt;Wheel&gt;</code>).</p>


",4
9791289,9791239,6,"<p>You can use the <a href=""http://en.wikipedia.org/wiki/Typedef"" rel=""nofollow noreferrer"">typedef</a> keyword:</p>

<pre><code>typedef LONGNAME LN;
</code></pre>

<p>You can also do something like:</p>

<pre><code>typedef class {

...

} LN;
</code></pre>

<p><strong>Edit:</strong>
You may run into trouble when using templates though. See <a href=""https://stackoverflow.com/questions/3708593/alternative-to-template-declaration-of-typedef"">here</a> for a possible solution.</p>
",2
9798868,9791239,1,"<pre><code>typedef int mark;  // for in built data types

class abc
{
};

typedef abc XYZ; // for user written classes.
</code></pre>

<p>Typedef allows you to alias a class or datatype name with a more context sensitive name corresponding to the scenario. </p>
",0
12855816,12855531,2,"<p>At the class level, the usual reason for overloading them is to use a
memory pool.  This is typically only useful for very small classes which
will be dynamically allocated a lot; things like nodes in a graph, for
example, where a pool allocator may significantly improve locality and
allocation/deallocation speed. </p>

<p>You can also overload the global new and delete operators to use special
allocators (say allocating from a specific area in memory).  This can be
tricky, however, since there is no way to specify the additional
arguments in a delete expression.  Practically speaking, when you do
this, you also have to replace the non-placement new and delete
operators, and arrange for the new operators to somehow store the
information necessary to find the correct deleter.</p>

<p>And of course, although not overloading, you can replace the global new
and delete operators, with ones that are instrumented to collect
information concerning allocations and deletions, for debugging
purposes (or because you have some custom placement new/delete).</p>

<p>You should <em>not</em> do anything with the global new/delete in a library.
Since anything you do will require replacing the non-placement forms,
doing it in a library will risk conflicts (if the user also needs to do
it in his main application).</p>
",0
12855574,12855531,3,"<p>You should only overload them when you've got specific memory requirements for your class. For example, if you want to ensure that all instances of <code>Foo</code> are allocated out of a memory pool.</p>

<p>Other than this sort of thing it's rare to need to overload them.</p>
",0
12855659,12855531,1,"<p>Also If you create a custom allocation library like <a href=""http://code.google.com/p/gperftools/?redir=1"" rel=""nofollow"">TCMalloc</a> and you want that all allocations from <code>new</code> in a program go to your library. </p>
",0
12855707,12855531,1,"<p>There is an interesting document on <a href=""https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md"" rel=""nofollow"">Facebook's FBVector</a> type in their folly library, which explains why they use a custom allocator for vectors, in particular it permits in-place reallocation, optimised growth factor to avoid gcc's allocation crawl, and so on.</p>

<p>Generally, it's a bad idea to do allocation yourself, because it's a complex issue with a lot of trade-off decisions to make. </p>
",0
12855754,12855531,1,"<p>Some use cases that come to mind:</p>

<ul>
<li>Tracing memory allocations and deallocations, as @Joachim Pileborg said. Tools such as valgrind or address sanitizer can do that for you, but doing it yourself allow to target only a subset of allocations and thus have less impact on performances</li>
<li>Using a custom allocation mechanism, for instance producing aligned addresses (for SSE, or other hardware requirements), or allocating in shared memory, or using a memory pool, or allocating at specific address for low level driver needs</li>
<li>Use a different allocation algorithm than the one supplied with your compiler/standard library. Depending on your allocations and threading patterns, selecting an appropriate allocation policy may improve performance.</li>
</ul>
",0
12870222,12870214,5,"<p>There is no reason to create a class if you don't need one (especially not just a class for a few unrelated functions). I would choose your first option, and declare the function prototypes as they are in <code>util.h</code>.</p>
",3
13493951,13493917,6,"<p><code>xor</code> is a reserved keyword in C++. You should rename the function to something else.</p>

<p>The compiler isn't actually ""seeing"" an identifier, but a keyword. If, in your code snippet, you'd replace <code>xor</code> with <code>^</code> the obvious syntactic error becomes clear.</p>
",2
12322093,12321401,5,"<p>The definitive answer is that all compilers do static initialization
before <code>main</code>, <em>unless</em> the objects are in a DLL which is loaded later.
In practice, it's (almost) impossible to meet the requirements in the
text you cite otherwise.  (Think of what happens if there is a cycle.) </p>
",0
10170245,10170119,4,"<p>From :http://www.cplusplus.com/reference/string/string/append/</p>

<pre><code>formatted.append(1, alp[a]);

/*
string&amp; append ( const string&amp; str );
string&amp; append ( const string&amp; str, size_t pos, size_t n );
string&amp; append ( const char* s, size_t n );
string&amp; append ( const char* s );
string&amp; append ( size_t n, char c );
*/
</code></pre>
",2
10170254,10170119,0,"<p>If my guess is correct (and it's a guess because you don't specify what the error actually is), try:</p>

<p><code>formatted.append(alp, a, 1);</code></p>
",0
10752661,10752591,3,"<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/dd374130%28v=vs.85%29.aspx"" rel=""nofollow""><code>WideCharToMultiByte</code></a> does something <strong>much different</strong> than <code>wcstombs</code>, so it's at least somewhat doubtful1 that this replacement would be successful.</p>

<p>Specifically, WCTMB converts from UTF-16 to another character set (and encoding) of your choice. <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/wcstombs/"" rel=""nofollow""><code>wcstombs</code></a> converts from a ""wide character string"" to a ""multibyte string"", but the standard leaves the exact definition of these terms to the implementor.</p>

<p>In other words: WCTMB converts from a known encoding to another known encoding. <code>wcstombs</code> converts from an unknown encoding to another unknown encoding. You cannot replace the former with the latter, especially if you want to convert to a Chinese encoding (isn't that what 936 is?).</p>

<p>What's the reason for seeking to do this replacement? Whatever it may be, it's almost certain that there are more appropriate ways to achieve the goal.</p>

<p><strong>Update:</strong> If you want a platform-independent, reliable solution then I 'd recommend <a href=""http://site.icu-project.org/"" rel=""nofollow"">ICU</a>. Don't expect to find an one-line replacement for WCTMB because it simply doesn't exist.</p>

<hr>

<p>1 massive understatement</p>
",0
10752712,10752591,0,"<ul>
<li>The resulting encoding that <code>wcstombs</code> converts to depends on the current locale while <code>WideCharToMultiByte</code> can be explicitly given a codepage.</li>
<li><code>wcstombs</code> converts from ""wide character string"", which encoding depends on the implementation of the standard library. <code>WideCharToMultiByte</code> converts from the string in UTF-16. Wide characters <code>wcstombs</code> rely upon may not be encoded in UTF-16, but in Windows wide characters are UTF-16.</li>
<li><code>wcstombs</code> is portable, <code>WideCharToMultiByte</code> is not. If your target platform is Windows only then it doesn't matter.</li>
<li><code>WideCharToMultiByte</code> allows to specify a ""default character"" which will be used instead of characters that can't be represented in target encoding.</li>
</ul>

<p>So <code>WideCharToMultiByte</code> is much more powerful and is probably used as a backend for <code>wcstombs</code>.</p>

<p>If your current codepage is not 936, then the replacement you ask about is impossible.</p>
",2
8776232,8126155,0,"<p>The code as written should read an array of 16 bit values. The only problem is that it assumes that the byte order the file was written with is the same byte order as is used where it is read. Whether this is the case isn't clear from the question. In cases where files are exchanged e.g. between x86 and Sparc machines you it is common to choose <em>network byte order</em> and to process the values with <code>ntohs()</code> when reading (and <code>htons()</code> when writing). Although these look like functions they are typically just macros which don't do anything to the value on platforms using network byte order.</p>
",1
9823355,9790759,0,"<p>It looks like this exception is from a <code>core::io_error</code> result which is translated to a runtime exception by <code>details::translate_result_to_exception()</code>. Most of this error originates from the source code in yami/posix in your case.</p>

<p>What you have to do now is figure out where the error originates and ultimately the source of the issue. You should be able to get a rough idea from what happens in your code when the error occurs (are you creating a new connection, sending data, receiving data, etc...). </p>

<p>If that doesn't yield any obvious results I would probably create a test project using the yami source code instead of the library file so I would be able to trace into the yami code to  where the error originates from.</p>
",0
11865534,11865421,3,"<p>Generally streams cannot be copied. Your function <code>DBNotification::getValues()</code> returns a stream object.</p>

<p>Please see <a href=""https://stackoverflow.com/questions/7049770/problem-with-ostringstream-and-copy-constructor"">this answer</a></p>
",0
9151416,9151402,-1,"<p>As long as you understand how tr1 shared pointers work, yes.</p>

<p>Look at Boost C++ shared_ptr&lt;> also - it might be more what you want.</p>
",4
9151497,9151402,4,"<p>It's a reasonable band-aid, sure.</p>

<p>A shared pointer is a <em>reference-counted</em> pointer. So as long as one or more <code>shared_ptr</code>s exist pointing to an object, that object will be kept alive. The problem occurs if you have circular references. Then the reference count will never reach 0, and the object(s) will never be deleted.</p>

<p>So <code>shared_ptr</code> * still* require you to understand what you're doing and think about object ownership, as you always have to do in C++. But it simplifies some otherwise complex scenarios, where determining ownership is hard.</p>

<p>But the <em>real</em> fix to your problem is to:</p>

<ul>
<li>minimize how much you allocate with <code>new</code>. Can the object instead be stored on the stack? Can the object be rewritten as a RAII class, so that a small wrapper object is allocated on the stack (or elsewhere with automatic storage duration), and which, through its constructors and destructors, manages a heap-allocated memory resource? Then, as long as that object exists, its allocated memory will be preserved, and once it is destroyed, it will delete its allocated memory.</li>
<li>when you allocate objects with <code>new</code>, put them in <em>one of</em> the smart pointer classes. <code>shared_ptr</code> is popular because it is the one that comes closest to looking like a garbage collector, but it isn't, and if you treat it as one and use it as an excuse to not think about memory management, then it won't work. Understand <em>all</em> the smart pointer classes (scoped_ptr and auto_ptr in C++03, or unique_ptr replacing both in C++11, shared_ptr and weak_ptr), and use the one that best fits your scenario.</li>
<li>think about ownership. Any time you allocate memory, you need to determine an owner, whose lifetime will control the lifetime of the memory allocation. Think about how long a lifetime your allocation needs, and have another object (whose lifetime is automatically managed, probably because it is on the stack) <code>delete</code> your memory when its destructor is called.</li>
</ul>

<p>There's no quick and easy fix. The way to handle memory management in C++ is to avoid memory management. Delegate it out to your objects. If you're calling <code>delete</code> in your own code, you're doing it wrong. Often, you don't even need <code>new</code>, but <em>if</em> you do, assign ownership to a smart pointer immediately, and let that call <code>delete</code> for you.</p>

<p>As a rule of thumb, unless you're a library writer, you shouldn't write either <code>new</code> or <code>delete</code>. You should virtually never use raw pointers, and only when it is absolutely necessary, use smart pointers. Let your classes do the heavy lifting. Don't be afraid to put them on the stack, pass them by value, and let them handle their resources internally.</p>
",2
9151609,9151402,0,"<p>If you are new to C++ there are a few points with pointer management you need to understand and accept, regardless of whether you're using shared_ptr or not. </p>

<p>It is more than likely in your use of C++ you will need to use new and assign its return pointer to a class pointer that you have declared. I believe it is advisable to take the time to understand what is going on there, even if you write a small test program and watch the constructor execute in the debugger.  </p>

<p>If you use classes like std::string, its constructors and destructor will do string pointer management for you, but I believe it is a good idea to understand what is going on behind the scenes in that class, if nothing more than reading the documentation.</p>

<p>As another example, you cannot use some classes, without a lot of detailed reading of the API, or you'll get problems. I once worked at company that used a commercial class package years ago. Someone had written a multi-threaded program using this package's thread pool class. </p>

<p>The documentation clearly said you can't just exit with outstanding threads. Yet I saw where the author of the program did not bother to synch up and shutdown all threads on exit, and wound up throwing exceptions, when their program exited. And this was on a commercial financial product.</p>

<p>My suggestion is don't look to get saved from performing pointer management. There are std classes like string that can reduce your headaches, but nothing will prevent problems other than your own diligence and testing.</p>
",0
9797954,9797915,1,"<p>Make the constructor and destructor print the memory address of the object, so you can follow it's lifetime:</p>

<pre><code>virtual void f() { cout &lt;&lt; ""A: "" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; endl; }
virtual ~A(){ cout &lt;&lt; ""destruct A: "" &lt;&lt; std::hex &lt;&lt; this &lt;&lt; endl; }
</code></pre>
",1
9797956,9797915,5,"<p>Your vector reallocated its memory buffer on the second call to push_back.  This required the object that was in there to be copied to the new buffer, and the original object was destroyed.</p>

<p>If you call <code>O.reserve(2)</code> before you insert any objects, that will give your vector enough space to accomadate both objects.  So it shouldn't need to reallocate, and you should not see any destructions before the end of main. Technically there could be more destructions, if your compiler sucks and makes unnecessary copies.  However, from what you've shown so far, it doesn't appear to do that.</p>
",0
9798075,9797915,1,"<p>After we had print statements to the copy constructor we get this:</p>

<pre><code>constructor A(0x7fff6e21e800)
constructor A(0x7fff6e21e7f8)
copy A(0x10e700910: From 0x7fff6e21e800)
1
copy A(0x10e700920: From 0x10e700910)
copy A(0x10e700928: From 0x7fff6e21e7f8)
destruct A(0x10e700910)
test
destruct A(0x10e700920)
destruct A(0x10e700928)
destruct A(0x7fff6e21e7f8)
destruct A(0x7fff6e21e800)
</code></pre>

<p>So now lets look at the code:</p>

<pre><code>int main()
{
   A o1,
     // constructor A(0x7fff6e21e800)
         o2;
     // constructor A(0x7fff6e21e7f8)
   vector &lt;A &gt; O;
   O.push_back(o1);
     // copy A(0x10e700910: From 0x7fff6e21e800)
   cout&lt;&lt;""1""&lt;&lt;endl;
     // 1

   O.push_back(o2);
    // copy A(0x10e700920: From 0x10e700910)    // O needs to expand.
                                                // So a new range is created and the old value
                                                // copied from the old range to the new range.

                                                // Now we push o2 into the vector
    // copy A(0x10e700928: From 0x7fff6e21e7f8)

                                                // Now the old range has to be destroyed.
    // destruct A(0x10e700910)


   cout&lt;&lt;""test""&lt;&lt;endl;
    // test


   return 0;
                 // Before we exit destroy the old vector (of two items)
    // destruct A(0x10e700920)
    // destruct A(0x10e700928)

                // Now destroy o2 then o1
    // destruct A(0x7fff6e21e7f8)
    // destruct A(0x7fff6e21e800)
}
</code></pre>
",2
9817044,9817002,3,"<p>Include this:</p>

<pre><code>#include &lt;sstream&gt;
</code></pre>

<p>Also, write this:</p>

<pre><code>if(ss &gt;&gt; num) //no .fail()
{ 
   return num; //read succeeded
}
return 0; //read failed
</code></pre>

<hr>

<p>By the way, you could use <code>std::cin &gt;&gt; test</code> in the <code>main()</code> itself as:</p>

<pre><code>int main(){
    int test;
    int t = 0;
    while (t !=1){
        std::cout &lt;&lt; ""input: "";
        if (std::cin &gt;&gt; test)
             std::cout &lt;&lt; test &lt;&lt; ""\n"";  //read succeeded
        else 
             std::cout &lt;&lt; ""Not a number..."";  //read failed
        std::cin &gt;&gt; t;
    }
    return 0;
}
</code></pre>

<p>No need of <code>str2int</code> function!</p>
",2
9817051,9817002,43,"<p>You need to include the following header file - </p>

<pre><code>#include &lt;sstream&gt;
</code></pre>

<p>Whenever you see errors like <code>undefined class</code>, you should always look for missing header files first. </p>

<p><a href=""http://www.cplusplus.com/reference/iostream/stringstream/"" rel=""noreferrer"">Here</a> is the documentation for the <code>stringstream</code> class.</p>
",1
9817057,9817002,3,"<p>To use stringstream, you need to do;</p>

<pre><code>#include &lt;sstream&gt;
</code></pre>

<p>After that, everything seems to work as it should.</p>
",1
9817058,9817002,4,"<p>You need to include sstream.</p>

<p><code>#include &lt;sstream&gt;</code></p>
",0
9796429,9796381,3,"<p>The error:</p>

<blockquote>
  <p>Error C2143 Syntax Error missing ';' before '.'</p>
</blockquote>

<p>is due to <code>test</code> being a type name. You need to define an instance:</p>

<pre><code>int main() {
   test mytest;
   mytest.deck[1] = 1;
   return 0;
}
</code></pre>
",1
9796468,9796381,5,"<p>If this is C++, no C, drop the test after the struct definition.</p>

<p>The following code works perfectly.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

struct Test {
  int a;
  int b;
  int c;
  int deck[52];
};

int main (int argc, char* argv[])
{
    Test t;
    t.deck[1] = 1;
    cout &lt;&lt; ""t.deck[1]: ""&lt;&lt; t.deck[1] &lt;&lt; endl;
    exit(0);
}
</code></pre>

<p>The problem:
 In C, you put the test <em>after</em> the definition to create a variable named test. So in C, test is <em>not</em> a type, it is a <em>global variable</em>, the way you wrote that.</p>

<p>This compiles:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

struct Test {
  int a;
  int b;
  int c;
  int deck[52];
} test;

int main (int argc, char* argv[])
{
    test.deck[1] = 1;
    cout &lt;&lt; ""test.deck[1]: ""&lt;&lt; test.deck[1] &lt;&lt; endl;
    exit(0);
}
</code></pre>
",2
9150550,9150538,8,"<p>That's inherently impossible.</p>

<p>A C++ enum is just a set of numbers with compile-time names.<br>
At runtime, they are indistinguishable from ordinary numbers.</p>

<p>You need to write a <code>switch</code> statement that returns a string.</p>
",2
9150554,9150538,0,"<p>You can store the names in an array of strings, indexed by the <code>enum</code> values.</p>

<pre><code>enum Colours
{
    Red =0,
    Green=1,
    Blue=2
};

char* names[3] = {""Red"", ""Green"", ""Blue""};
</code></pre>

<p>Then you can print: <code>""Invalid colour '"" + names[colour] + ""' selected.""</code></p>

<p>But this approach may not be very useful if you do not define the <code>enum</code> values sequentially. In that case this approach will waste memory. Writing a function with a <code>switch</code> over the <code>enum</code> value would be useful, as Alexander Gessler has mentioned. Another alternative may be the <code>map</code> from STL.</p>
",0
9150555,9150538,1,"<p>You have to do it manually, i.e.</p>

<pre><code>const char* ToString(Colours co) {
     switch(co) {
        case Red:
           return ""Red"";
        // ...
     }
}
</code></pre>

<p>A lookup table would also be possible. I've also seen people using custom scripts to generate such stuff on top of their source code. </p>
",0
9150582,9150538,3,"<pre><code>enum Color
{
    Red =0,
    Green=1,
    Blue=2
};

std::string ColorMap[] = { ""Red"", ""Green"",""Blue"" };
</code></pre>

<p>Use <code>ColorMap[c]</code> to get the string representation:</p>

<pre><code>std::string msg = ""Invalid colour '"" + ColorMap[c] + ""' selected."";
</code></pre>

<hr>

<p>However, if the values of enum are not continuous, then you can use <code>std::map</code> instead as:</p>

<pre><code>enum Color
{
    Red   = 0x1,
    Green = 0x2,
    Blue  = 0x4, 
    Black = 0x8, 
};

//C++11 only, as it uses std::initializer_list
std::map&lt;Color, std::string&gt; ColorMap = {
    {Red, ""Red""},
    {Green, ""Green""},
    {Blue, ""Blue""},
    {Black, ""Black""}
};

//same as before!
std::string msg = ""Invalid colour '"" + ColorMap[c] + ""' selected."";
</code></pre>
",1
9150589,9150538,0,"<p>As @FlopCoder said:</p>

<pre><code>enum Colours
{
    Red =0,
    Green=1,
    Blue=2
};
char* ColourNames[] = { ""Red"", ""Green"", ""Blue"" };
int colour = Green;
printf( ""Invalid colour '%s' selected."", ColourNames[ colour ] );
</code></pre>

<p>This of course will only work if your enum starts at 0 and is continuous.<br>
@Nawaz's way is more <em>C++ stylish</em> though.</p>
",1
9150607,9150538,22,"<p>While this is commonly done through switches, I prefer arrays:</p>

<pre><code>#include &lt;iostream&gt;

namespace foo {
  enum Colors { BLUE = 0, RED, GREEN, SIZE_OF_ENUM };
  static const char* ColorNames[] = { ""blue"", ""red"", ""green"" };

  // statically check that the size of ColorNames fits the number of Colors
  static_assert(sizeof(foo::ColorNames)/sizeof(char*) == foo::SIZE_OF_ENUM
    , ""sizes dont match"");
} // foo

int main()
{
  std::cout &lt;&lt; foo::ColorNames[foo::BLUE] &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p>The explicit array size has the benefit of generating a compile time
error should the size of the enum change and you forget to add the
appropriate string.</p>

<p>Alternatively, there is Boost.Enum in the Boost vault. The library
hasn't been officially released but is quite stable and provides what
you want. I wouldn't recommend it to a novice though.</p>
",6
9150779,9150538,18,"<p>How about a little magic with macros:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;


// http://stackoverflow.com/questions/236129/how-to-split-a-string-in-c
std::vector&lt;std::string&gt; split(const std::string &amp;text, char sep) {
    std::vector&lt;std::string&gt; tokens;
    int start = 0, end = 0;
    while ((end = text.find(sep, start)) != std::string::npos) {
        tokens.push_back(text.substr(start, end - start));
        start = end + 1;
    }
    tokens.push_back(text.substr(start));
    return tokens;
}

#define ENUM(name, ...)\
enum name \
{\
__VA_ARGS__\
};\
std::vector&lt;std::string&gt; name##Map = split(#__VA_ARGS__, ',');\
    std::string toString(const name v) { return name##Map.at(v);}


ENUM(Color, Red,Green,Blue)


int main(int c, char**v)
{
    std::cout &lt;&lt; toString(Red) &lt;&lt; toString(Blue);
    return 0;//a.exec();
}
</code></pre>

<p>Yes, I understand that this is ugly and you'd better not do do such things</p>
",3
9151009,9150996,6,"<p>There is nothing as strict as C# <code>out</code> parameters in C++.  You can use pointers and references to pass values back but there is no guarantee by the compiler that they are assigned to within the function.  They are much closer to C# <code>ref</code> than <code>out</code></p>

<pre><code>// Compiles just fine in C++
bool TryGetValue(int key, OrderType&amp; order) {
  return false;
}
</code></pre>
",0
9151014,9150996,5,"<p>No, there are no <code>out</code> parameters in C++ that force you to assign to it before exiting the function. Pointers and references are more like <code>ref</code> parameters in C#.</p>
",0
9151018,9150996,0,"<p>That would be one use of references:</p>

<pre><code>bool TryGetValue(int key, OrderType &amp;order)
</code></pre>

<p>Then you can simply assing to <code>order</code> and the calling function would get the data.</p>
",0
9151078,9150996,3,"<p>If you really like a 'out' keyword, you can define a maro:</p>

<pre><code>#define out
</code></pre>

<p>as a mark, although it has not effect for compiler. </p>

<p>Just like some one would define 'public', 'private' keyword for C.</p>
",1
9154019,9150996,1,"<p>You can use references or pointers to simulate out parameters, but a better way is to use tuples (<code>std::tuple</code> in C++11 or <code>boost::tuple</code> in C++98/03) to return multiple values from a function. You cannot return without a complete tuple.</p>

<pre><code>#include &lt;tuple&gt;

std::tuple&lt;bool, OrderType&gt; TryGetValue(int key) {
    OrderType ot;
    ...
    return std::tuple&lt;bool, OrderType&gt;(true, ot);
}

...

bool b;
OrderType o;
std::tie(b, o) = TryGetValue(k);
</code></pre>
",0
17384796,17384726,0,"<p>Let's say I declare an array: <code>int a[10];</code> Now <code>a</code> represents some memory address at the beginning of where the array is in memory, and you can think of the index as an offset from that memory address. </p>

<p>So when applying the index operation to the array, the value is defined as follows: <code>a[i] = *(a+i)</code> By the commutative property of addition, you can see that <code>a[0] = 0[a]</code> because of how the index operation is defined by the language.</p>
",5
17384738,17384726,4,"<p>Because array index operations are internally interpreted as <code>*(a+i)</code>.</p>
",6
12317767,12317635,0,"<p>Combining both classes should work as expected, have you tried it?</p>

<pre><code>class Vector {
  gsl_vector* vector_;
public:
  Vector(gsl_vector* vector): vector_(vector) {}

  const double&amp; operator()(int i) const {
    return *gsl_vector_ptr(vector_, i);
  }
  double&amp; operator()(int i) {
    return *gsl_vector_ptr(vector_, i);
  }

  operator const_Vector()
  { 
    return const_Vector(vector_);
  }

};


class const_Vector {
  const gsl_vector* vector_;
public:
  const_Vector(const gsl_vector* vector): vector_(vector) {}

  const double&amp; operator()(int i) const {
    return *gsl_vector_ptr(vector_, i);
  }
};
</code></pre>

<p>Function signature needs to look this way:</p>

<pre><code>int f(const_Vector&amp; x, Vector&amp; y) {
  \\ do some math 
  return 0;
}
</code></pre>

<p>This followes a similar scheme like the iterator and const_iterator.</p>

<p>Maybe you have a situation which this will not work,. you should post this situation and we can try to solve it.</p>
",5
12319882,12317635,0,"<p>Proposal (not wonderful, but should work):</p>

<pre><code>class Vector { 
  gsl_vector* vector_;
  const gsl_vector* const_vector_; 
public: 
  Vector(const gsl_vector* vector): vector_(nullptr), const_vector_(vector) {} 
  Vector(gsl_vector* vector): vector_(vector), const_vector_(vector) {}
  const double&amp; operator()(int i) const { 
    return *gsl_vector_ptr(const_vector_, i); 
  } 
  double&amp; operator () (int i) {
    return *gsl_vector_ptr(vector_, i);
  }
}; 
</code></pre>

<p>Second possibility:</p>

<pre><code>class Vector { 
private:
  gsl_vector* vector_;

  Vector(gsl_vector* vector): vector_(vector) {}

public:
  static const Vector* Create (const gsl_vector* vector) {
     return new Vector (const_cast&lt;Vector *&gt; vector);
  }

  static Vector* Create (gsl_vector* vector) {
     return new Vector (vector);
  }

  const double&amp; operator()(int i) const { 
    return *gsl_vector_ptr(vector_, i); 
  } 
  double&amp; operator () (int i) {
    return *gsl_vector_ptr(vector_, i);
  }
}; 
</code></pre>
",3
9153736,9153723,1,"<p>You can create a <code>std::set</code>, loop through the digits, add them to the set, and see if the number of digits is equal to the size of the set. If it is, no numbers are repeated.</p>

<p>If you suspect most numbers fail to meet the requirement, you can check after each insertion whether the digit was actually added to the set or not, and immediately reject the number if it wasn't.</p>
",3
9153781,9153723,0,"<p>Just convert number to string (itoa) and it will be easer to solve the core task. </p>
",0
9153784,9153723,0,"<p>Convert the number to a string, and set up 10 bits (all zero) that represent <code>1 &lt;&lt; ( digit - '0' )</code> you can then check for each digit whether it has been seen before, and if so return. Else set that bit.</p>
",0
9153793,9153723,2,"<p>I'd use a 'bit array' to track digits: this is more a 'C-like' way of solve...</p>

<pre><code>int number_orig = ...,
    number = number_orig;
    bits = 0;
bool duplicate = false;
while (number != 0 &amp;&amp; !duplicate)
{
 int digit = number % 10;
 if (bits &amp; (1 &lt;&lt; digit))
   duplicate = true;
 bits |= (1 &lt;&lt; digit);
 number /= 10;
}
if (!duplicate)
  cout &lt;&lt; number_orig;
</code></pre>
",0
9153794,9153723,1,"<p>A C-language compatible solution would be to convert the number to a string and keep a frequency count of the digits and return true if there are duplicates, e.g.:</p>

<pre class=""lang-c prettyprint-override""><code>int has_duplicate_digit(char * s) {
  char digit_count[10] = {0,0,0,0,0,0,0,0,0,0};
  for (int i=0; i&lt;strlen(s); i++) {
    if ('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9') {
      if (++digit_count[s[i]-'0'] &gt; 1) return 1; // true
    }
  }
  return 0; // false
}
</code></pre>

<p><strong>[Edit]</strong> You can also save a few bytes (and possibly some time) by using a bitset instead of an int array. For example:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdint.h&gt;
int has_duplicate_digit2(char * s) {
  uint16_t digit_count = 0;
  for (int i=0; i&lt;strlen(s); i++) {
    if ('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9') {
      uint16_t bit = 1 &lt;&lt; (s[i] - '0');
      if (digit_count &amp; bit) return 1; // true
      digit_count |= bit;
    }
  }
  return 0; // false
}
</code></pre>
",0
9153814,9153723,1,"<p>A simple string-based solution: Convert, sort, uniquify, count:</p>

<pre><code>#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

for (unsigned int i = 0; ; ++i)
{
    std::string sorig = std::to_string(i), suniq = sorig;
    std::sort(suniq.begin(), suniq.end());

    if (std::unique(suniq.begin(), suniq.end()) == suniq.end())
    {
        std::cout &lt;&lt; sorig &lt;&lt; std::endl;
    }
}
</code></pre>
",0
9142341,9142034,0,"<p>The base class doesn't <em>have</em> the requested member function, so there's no way around that. However, you can make the base function a <em>template</em> instead:</p>

<pre><code>template &lt;typename S&gt;
void processStuff(S * s, void (S::*procedure)(T *))
{
    for (int i = 0; i &lt; count; i++) { (s-&gt;*procedure)(content[i]); }
}
</code></pre>

<p>Invoke it as follows:</p>

<pre><code>processStuff(this, &amp;DrawableStorage::drawOne);
</code></pre>
",2
9142425,9142034,1,"<p>Here's the simpler version of your example:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct Arg
{
    int i;
};

class A;
typedef void (A::*fncptr)(Arg&amp;);
</code></pre>

<p><code>fncptr</code> is pointer to member function (method) of class <code>A</code> that takes <code>Arg</code> by reference. If someone gives you address of non-static function of this type, you will be able to call it only if you have an object of class <code>A</code> (otherwise it would have to be static function).</p>

<pre><code>class A
{
public:
    A(Arg a) : a(a) { }
    void process(fncptr f){ (this-&gt;*f)(a); }

protected:
    Arg a;
};

class B : public A
{
public:
    B(Arg a) : A(a) { } 
    void magic(){ process((fncptr)&amp;B::function); }
    void function(Arg&amp; a) { cout &lt;&lt; a.i; }
};
</code></pre>

<p>Here's the trick: since you are in function <code>process</code> which is member function of class <code>A</code>, you don't need pointer to an object of class <code>A</code> to call function <code>f</code> because you already have one: <code>this</code>. So you are able to call any function of this class or derived classes and you need only address of that function to do so.</p>

<p>Here's <code>main()</code>:</p>

<pre><code>int main()
{
    Arg a;
    a.i = 71;

    B* b = new B(a);
    b-&gt;magic();
    delete b;
}
</code></pre>

<p>output: <code>71</code></p>
",0
9142530,9142034,1,"<p>It is legal according to $5.2.9/12:</p>

<blockquote>
  <p>A prvalue of type ¡°pointer to member of D of type cv1 T¡± can be
  converted to a prvalue of type ¡°pointer to member of B¡± of type cv2 T,
  where B is a base class (Clause 10) of D, if a valid standard
  conversion from ¡°pointer to member of B of type T¡± to ¡°pointer to
  member of D of type T¡± exists (4.11), and cv2 is the same
  cv-quali?cation as, or greater cv-quali?cation than, cv1. 69 The null
  member pointer value (4.11) is converted to the null member pointer
  value of the destination type. If class B contains the original
  member, or is a base or derived class of the class containing the
  original member, the resulting pointer to member points to the
  original member. Otherwise, the result of the cast is unde?ned. [Note:
  although class B need not contain the original member, the dynamic
  type of the object on which the pointer to member is dereferenced must
  contain the original member; see 5.5. ¡ªend note ]</p>
</blockquote>

<p>However if you try to do this with multiple inheritance or virtual inheritance, that's when things start to break, because not all compilers implement member function pointers in a standard compliant way. On MSVC and Intel compilers all member function pointers do not have the same size, so you will lose crucial information on conversions.</p>
",0
9142143,9142034,3,"<p>This is one of the tricks possible with pointers.  It works because DrawableStorage is an ArrayStorage, and the function header matches what is expected (takes a pointer to a type matching the objects templated type and returns void).</p>

<p>Once the parent object has the pointer to the function, it can call it just fine even though it doesn't actually have that function as a member of itself.</p>

<p>While it may be a little confusing at first to read, it is a perfectly valid use of function pointers.</p>
",0
13742913,13742761,0,"<p>as mentioned by stefan, you can use <code>std::istringstream</code></p>

<pre><code>coords          getWinSize(const std::string&amp; s1, const std::string&amp; s2)
{
  coords winSize;
  std::istringstream iss1(s1);
  std::istringstream iss2(s2);

  if ((iss1 &gt;&gt; winSize.x).fail())
    throw blabla_exception(__FUNCTION__, __LINE__, ""Invalid width value"");
  /*
   .....
  */
}
</code></pre>

<p>in my code, coords is :</p>

<pre><code>typedef struct coords {
    int     x;
    int     y;
} coords;
</code></pre>
",1
13742949,13742761,5,"<p>Use <a href=""http://en.cppreference.com/w/cpp/io/basic_istringstream"" rel=""nofollow""><code>std::istringstream</code></a> and confirm all data was consumed using <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/eof"" rel=""nofollow""><code>eof()</code></a>:</p>

<pre><code>std::istringstream in(""123.34ab"");
double val;
if (in &gt;&gt; val &amp;&amp; in.eof())
{
    // Valid, with no trailing data.
}
else
{
    // Invalid.
}
</code></pre>

<p>See demo at <a href=""http://ideone.com/gpPvu8"" rel=""nofollow"">http://ideone.com/gpPvu8</a>.</p>
",1
13742989,13742761,0,"<p>Use <a href=""http://www.boost.org/doc/libs/1_52_0/doc/html/boost_lexical_cast.html"" rel=""nofollow""><code>boost::lexical_cast</code></a>, which throws an exception if conversion fails.</p>
",0
13743098,13742761,2,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stof"" rel=""nofollow"">std::stod()</a>. If the string can not be converted, an exception is thrown.</p>
",0
11528163,11528142,3,"<p>I assume this is just from printing with <code>cout</code>. If that's the case, use <a href=""http://en.cppreference.com/w/cpp/io/manip/fixed"" rel=""nofollow""><code>std::fixed</code></a>:</p>

<pre><code>std::cout &lt;&lt; std::fixed &lt;&lt; whateverNumberCurrentlyInScientific;
</code></pre>
",2
11528482,11528142,0,"<p>Is it crashing on reading it in or sending it out? Are you using cout or printf? One extremely common way to crash it to use printf with a %d and send it a floating point value. </p>
",0
11128515,11128287,2,"<p>You will need to introduce a separator between the numbers to be ablew to extract them out:</p>

<pre><code>ss &lt;&lt; vec[0] &lt;&lt; "" "";
ss &gt;&gt; ID;
ss &lt;&lt; vec[4] &lt;&lt; "" "";
ss &gt;&gt; sales;
ss &lt;&lt; vec[5] &lt;&lt; "" "";
ss &gt;&gt; percent;
</code></pre>

<p>Besides this, you need to revert back to the original decimal format after extracting the ID: </p>

<pre><code>ss &lt;&lt; hex;
ss &lt;&lt; vec[0] &lt;&lt; "" "";
ss &gt;&gt; ID;
ss &lt;&lt; dec;
</code></pre>

<p>Also, because you use the same <code>ss</code> stream to extract the vector elements, the state of the stream is in error after the last vector element is extracted.  You need to clear the error state before further insertion/extraction.  Using a new stream will solve the problem as well:</p>

<pre><code>ss = stringstream();
ss &lt;&lt; hex;
ss &lt;&lt; vec[0] &lt;&lt; "" "";
ss &gt;&gt; ID;
ss &lt;&lt; dec;
ss &lt;&lt; vec[4] &lt;&lt; "" "";
ss &gt;&gt; sales;
ss &lt;&lt; vec[5] &lt;&lt; "" "";
ss &gt;&gt; percent;
</code></pre>
",5
11129198,11128287,1,"<p>I got it to work. Here is a screenshot of my whole method: <a href=""http://i.imgur.com/lFb87.png"" rel=""nofollow"">http://i.imgur.com/lFb87.png</a> I think that since I used ss to load the vector, reusing it to get the values caused problems. Everything worked correctly when I added the 2nd stringstream ss2.</p>
",1
14734198,14734153,9,"<p>it is in the sub namespace</p>

<pre><code>boost::signals2::mutex 
</code></pre>
",0
13777188,13777167,3,"<p>It means the second parameter is passed by <strong><a href=""http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/topic/com.ibm.xlcpp8l.doc/language/ref/cplr110.htm"" rel=""nofollow"">reference</a></strong>. You have to simply pass:    </p>

<pre><code>namespace1::namespace2::var
</code></pre>
",1
13777416,13777167,1,"<p>This should work :</p>

<pre><code>const Common::Hashtable param = namespace1::namespace2::var();
opRaiseEvent(false, param, 100);
</code></pre>
",1
13777443,13777167,1,"<pre><code>namespace1::namespace2::var v;
testFunc(false, v, 100);
</code></pre>
",0
9194728,9191985,0,"<p>The problem is that the new line character is not extracted from the input stream when you do:</p>

<pre><code>cin &gt;&gt; bookno;
</code></pre>

<p>The quickest way for you would be to insert an extra cin.get() after it (in your input() method):</p>

<pre><code>cout &lt;&lt; ""\nEnter book number: "";
cin &gt;&gt; bookno;
cin.get();
cout &lt;&lt; ""\nEnter book title: "";
gets_s(bookt);                    // Now it will identify this.
cout &lt;&lt; ""\nEnter book price: "";
cin &gt;&gt; price;
</code></pre>

<p>Another suggestion is try to avoid to mix C and C++ functions.</p>
",0
9190740,9190673,0,"<p>You must add the operator &lt;&lt; function as a friend to be able to print values from your TicketOrder objects with cout. <a href=""http://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/"" rel=""nofollow"">Further reading</a></p>
",0
9190750,9190673,7,"<p>As the compiler is clumsily trying to explain, the code is <a href=""https://stackoverflow.com/questions/4421706/operator-overloading/4421719#4421719"">missing an <code>operator&lt;&lt;</code></a> for the <code>TicketOrder</code> class.</p>

<pre><code>class TicketOrder {
public:
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, TicketOrder const&amp; order) {
        os &lt;&lt; ""Type: "" &lt;&lt; type &lt;&lt; "", quantity: "" &lt;&lt; quantity;
        return os;
    }

    char type;
    int quantity;
};
</code></pre>

<p>(Note: you probably want to change <code>quantity</code> to <code>int</code>.)</p>
",7
9190829,9190673,0,"<p>You're attempting to use the &lt;&lt; operator on <code>cout</code> and a <code>TicketOrder</code> object.  That is undefined.  You should use the <code>TicketOrder</code> object to generate a string first, then output that via <code>cout</code>.  Either that, or you can define the &lt;&lt; operator for the <code>TicketOrder</code> class, as described in one of the other two answers.</p>
",0
9192001,9191428,6,"<p>As Luchian already posted, the algorithm (even if implemented correctly) is not suitable to find your way out of all sort of mazes: If you have some loop inside your maze, you might just end up running around this looping wall.</p>

<p>Also, as it seems, you don't really generate a maze but rather a big field with walls at the borders and the ""exit"" somewhere inside it. An algorithm, which really ""sticks to a wall"" will never find the exit, if the exit is not near the wall (which, again, is currently only at the borders of your ""maze"").</p>

<p>Since you're not removing the <code>SomeDude</code>s, i.e. the positions you've already been, and you're treating <code>SomeDude</code> the same way as a <code>Wall</code>, you're slowly filling up the maze with some kind of ""SomeDude-Wall"": You go just down until you hit the border and then go in big counterclockwise spirals around the field, leaving a trace of <code>SomeDude</code>s.</p>

<p>Depending on your starting point and the exit, you can easily run into the situation, where all four directions are blocked, either by a ""real"" wall or by some previous <code>SomeDude</code> you left there. Then, none of the four <code>if</code>-Statements is executed and you just have an infinite loop (since nothing is changed inside the loop body).</p>

<p>For an algorithm, wich sticks to a wall (and thus would be able to find a way out of <em>some kinds of mazes</em>), I would suggest the following steps:</p>

<ul>
<li>First, go into one direction, until you hit a wall.</li>
<li>Set your current <em>direction</em>, so that the wall is at your right side.</li>
<li>Follow your current direction (don't forget to delete your <code>SomeDude</code>-trace) until either
<ul>
<li>You've found the exit.</li>
<li>There is no wall at your right side: In this case, turn right and go one step forward.</li>
<li>Or, there is a wall just in front of you. In this case, turn <em>left</em> until the way ahead of you is free</li>
</ul></li>
</ul>

<p>This way, you ensure, that there is always ""the same"" wall at your right side, so you ""stick"" to that wall.</p>

<p>Remember, that this algorithm cannot find exits, if the exit is inside some free space (since it always stick to a wall, the exit must also be near a wall to be found).</p>

<p>For an algorithm which finds its way out of all possible mazes, you need to have some sort of <em>backtracking</em>: Remeber every point, where you have multiple choices to continue. Choose one way, and follow it. If it's a dead-end, go back to tha last point of decision and take the next choice. If no way leads to the exit, go to the previous last point and so on. This is a recursive approach, known as ""depth-first-search"" in graph theory (feel free to do a bit of googling, I'm confident, you'll find a lot of material about this :) ...)</p>

<p>HTH
Martin</p>
",1
9192067,9191428,24,"<p><img src=""https://i.stack.imgur.com/IucJT.gif"" alt=""enter image description here""></p>

<p>To have a chance in solving it, you must:</p>

<ul>
<li>Create a <code>Solve()</code> routine and recursively call itself:

<ul>
<li>if 1st, 2nd, 3rd, ... are true <code>Solve</code> has succeeded in finding a solution</li>
<li>if 1st, 2nd, 3rd, ... contains a false, it has to backtrack and find another way</li>
</ul></li>
<li>You need to build a buffer of places you've been to avoid infinite loops

<ul>
<li>as you make moves it needs to keep tabs on it</li>
<li>when we hit a dead end, we need to erase bad moves</li>
<li>we can implement the above by burning in a guess and removing it if it's wrong</li>
</ul></li>
</ul>

<p>Here's a crude implementation based on the above concepts:</p>

<pre><code>#include ""stdafx.h""
#include &lt;stdio.h&gt;

const int MazeHeight = 9;
const int MazeWidth = 9;

char Maze[MazeHeight][MazeWidth + 1] =
{
    ""# #######"",
    ""#   #   #"",
    ""# ### # #"",
    ""# #   # #"",
    ""# # # ###"",
    ""#   # # #"",
    ""# ### # #"",
    ""#   #   #"",
    ""####### #"",
};

const char Wall = '#';
const char Free = ' ';
const char SomeDude = '*';

class COORD
{
public:
    int X;
    int Y;
    COORD(int x = 0, int y = 0) { X = x, Y = y; }
    COORD(const COORD &amp;coord) { X = coord.X; Y = coord.Y; }
};

COORD StartingPoint(1, 0);
COORD EndingPoint(7, 8);

void PrintDaMaze()
{
    for (int Y = 0; Y &lt; MazeHeight; Y++)
    {
        printf(""%s\n"", Maze[Y]);
    }
    printf(""\n"");
}

bool Solve(int X, int Y)
{
    // Make the move (if it's wrong, we will backtrack later.
    Maze[Y][X] = SomeDude;

    // If you want progressive update, uncomment these lines...
    //PrintDaMaze();
    //Sleep(50);

    // Check if we have reached our goal.
    if (X == EndingPoint.X &amp;&amp; Y == EndingPoint.Y)
    {
        return true;
    }

    // Recursively search for our goal.
    if (X &gt; 0 &amp;&amp; Maze[Y][X - 1] == Free &amp;&amp; Solve(X - 1, Y))
    {
        return true;
    }
    if (X &lt; MazeWidth &amp;&amp; Maze[Y][X + 1] == Free &amp;&amp; Solve(X + 1, Y))
    {
        return true;
    }
    if (Y &gt; 0 &amp;&amp; Maze[Y - 1][X] == Free &amp;&amp; Solve(X, Y - 1))
    {
        return true;
    }
    if (Y &lt; MazeHeight &amp;&amp; Maze[Y + 1][X] == Free &amp;&amp; Solve(X, Y + 1))
    {
        return true;
    }

    // Otherwise we need to backtrack and find another solution.
    Maze[Y][X] = Free;

    // If you want progressive update, uncomment these lines...
    //PrintDaMaze();
    //Sleep(50);
    return false;
}

int _tmain(int argc, _TCHAR* argv[])
{
    if (Solve(StartingPoint.X, StartingPoint.Y))
    {
        PrintDaMaze();
    }
    else
    {
        printf(""Damn\n"");
    }

    return 0;
}
</code></pre>

<p>To illustrate, I have a version of the above in Javascript:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const MazeWidth = 9
const MazeHeight = 9

let Maze =
[
    ""# #######"",
    ""#   #   #"",
    ""# ### # #"",
    ""# #   # #"",
    ""# # # ###"",
    ""#   # # #"",
    ""# ### # #"",
    ""#   #   #"",
    ""####### #""
].map(line =&gt; line.split(''))

const Wall = '#'
const Free = ' '
const SomeDude = '*'

const StartingPoint = [1, 0]
const EndingPoint = [7, 8]

function PrintDaMaze()
{
    //Maze.forEach(line =&gt; console.log(line.join('')))
    let txt = Maze.reduce((p, c) =&gt; p += c.join('') + '\n', '')
    let html = txt.replace(/[*]/g, c =&gt; '&lt;font color=red&gt;*&lt;/font&gt;')
    $('#mazeOutput').html(html)
}

async function Solve(X, Y)
{
    // Make the move (if it's wrong, we will backtrack later.
    Maze[Y][X] = SomeDude;

    // If you want progressive update, uncomment these lines...
    PrintDaMaze()
    await sleep(100)

    // Check if we have reached our goal.
    if (X == EndingPoint[0] &amp;&amp; Y == EndingPoint[1])
    {
        return true
    }

    // Recursively search for our goal.
    if (X &gt; 0 &amp;&amp; Maze[Y][X - 1] == Free &amp;&amp; await Solve(X - 1, Y))
    {
        return true
    }
    if (X &lt; MazeWidth &amp;&amp; Maze[Y][X + 1] == Free &amp;&amp; await Solve(X + 1, Y))
    {
        return true
    }
    if (Y &gt; 0 &amp;&amp; Maze[Y - 1][X] == Free &amp;&amp; await Solve(X, Y - 1))
    {
        return true
    }
    if (Y &lt; MazeHeight &amp;&amp; Maze[Y + 1][X] == Free &amp;&amp; await Solve(X, Y + 1))
    {
        return true
    }

    // Otherwise we need to backtrack and find another solution.
    Maze[Y][X] = Free

    // If you want progressive update, uncomment these lines...
    PrintDaMaze()
    await sleep(100)
    return false
}

function sleep(ms) {
    return new Promise((resolve) =&gt; setTimeout(resolve, ms))
}

(async function() {
    if (await Solve(StartingPoint[0], StartingPoint[1]))
    {
        console.log(""Solved!"")
        PrintDaMaze()
    }
    else
    {
        console.log(""Cannot solve. :-("")
    }
})()</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js""&gt;&lt;/script&gt;
&lt;pre id=""mazeOutput""&gt;
&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
",0
9200414,9200294,0,"<p>You don't have a rectangular data set in general: each <code>a[i]</code> is a vector of a possibly different length. Supposing you do in fact take care to have a rectangular grid, your for loop is still off; it should be like this:</p>

<pre><code>for (int i = 0; i &lt; a.size(); i++)
{
    assert(a.size() &lt;= b.size() &amp;&amp; a.size() &lt;= t.size());

    for (int j = 0; j &lt; a[i].size(); j++)  // !!
    {
        assert(a[i].size() &lt;= b[i].size() &amp;&amp; a[i].size() &lt;= t[i].size());
        t[i][j] = a[i][j] + b[i][j];
    }
}
</code></pre>

<p>I added some assertions to indicate which preconditions you have to satisfy.</p>

<p>To initialize a rectangular array, you can do something like this:</p>

<pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; v(n_rows, std::vector&lt;int&gt;(n_cols, 0));
</code></pre>
",6
9200423,9200294,2,"<p>You'll need to initialize the rows and columns of <code>t</code> with something like:</p>

<pre><code>Matrix t = vector&lt; vector&lt;int&gt; &gt;(row_count, vector&lt;int&gt;(col_count, 0));
</code></pre>

<p>That will make a <code>row_count</code> by <code>col_count</code> matrix filled with zeroes.</p>

<hr>

<p>On a side note about performance: comparing to <code>.size()</code> in a for loop means that before each iteration, <code>.size()</code> has to be calculated again.  You can save a bit of processing (which adds up for massive data sets) by pre-calculating it like so:</p>

<pre><code>for (int row = 0, row_ct = mat.size(); row &lt; row_ct; ++row)
</code></pre>
",1
15895538,15891928,2,"<p>I modified your code like this:</p>

<pre><code>        else if
            (countWhile &lt; x &amp;&amp; number%2 == 0)
                {
                    for(countWhile+=2; countWhile&lt;x; countWhile+=2)
                        cout &lt;&lt; countWhile &lt;&lt; "" "";
                }

        else
            {
                    for(countDo+=2; countDo&lt;x; countDo+=2)
                        cout &lt;&lt; countDo &lt;&lt; "" "";
            }
</code></pre>

<p>And I get output like:</p>

<pre><code>Please enter a positive integer or zero to quit: 82
2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80

Do you wish to continue? (Y or N): y
Please enter a positive integer or zero to quit: 75
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73
</code></pre>

<p>Hope this helps.</p>
",0
11813037,11812999,3,"<p>tl;dr but - class managing memory + memory management errors -></p>

<p>You're implementing a destructor, which means your copy/destroy logic has more to it than a shallow-copy can handle. Which makes sense, since you have a member <code>Avlnode *root;</code>.</p>

<p>Either use RAII, or properly implement a copy constructor and assignment operator.</p>

<p>This is known as the rule of three. All terms used are easily googleable. </p>
",0
10770733,10770723,6,"<p>Should be</p>

<pre><code>void Bridge::insert(Bridge AddBridge)
</code></pre>

<p>instead of </p>

<pre><code>void insert(Bridge AddBridge)
</code></pre>
",3
10770738,10770723,2,"<p>Calling <code>reserve</code> on a <code>std::vector</code> ensures that it has enough capacity to host such many elements if they were added. It does not resize the vector, it only changes its capacity. What you are looking for is <code>resize</code>.</p>

<p>You are also missing <code>Bridge::</code> in your <code>insert</code> member function definition.</p>
",0
10770763,10770723,3,"<p>You're trying to duplicate functionality that's already part of <code>vector</code>.</p>

<p>Instead of keeping track of nextBridge on your own, you should just let the <code>vector</code> do its job, and keep track of how many <code>bridge</code>s you've inserted. Instead of <code>insert</code>ing at a specified location, you just need to use <code>push_back</code> to add to the end of the <code>vector</code>, so your code becomes:</p>

<pre><code>Bridge::Bridge(int size){
    AllBridges.reserve(size);
}

void Bridge::insert(Bridge AddBridge){
    AllBridges.push_back(AddBridge);
}
</code></pre>

<p>...and you can simply remove <code>nextBridge</code> from your definition of <code>Bridge</code> entirely.</p>

<p>As an aside, I think you're making a fundamental mistake though: you're conflating the notion of a single bridge with the notion of a collection of all bridges. This is a common mistake (sometimes made by people who definitely aren't beginners) but it leads almost inevitably to problems. Just for example, each <code>Bridge</code> you insert into your <code>AllBridges</code> has an <code>AllBridges</code> of its own (that'll probably be empty, but who knows).</p>

<p>You really want <code>Bridge</code> to <em>just</em> represent a single bridge, then (if necessary) have a separate type to represent a collection of bridges -- if it really adds something useful beyond <code>std::vector&lt;Bridge&gt;</code>.</p>

<p>Edit: I suppose I should add one other possibility: perhaps you really do want the <code>Bridge</code> type to keep track of all instances of itself that ever get instantiated. If so, you want to make your <code>AllBridges</code> a <code>static</code> member, so you have a single instance of it for the class instead of a separate instance of it for every object of the class.</p>
",0
12334992,12334930,0,"<p>i don't know dev C++ , but i would strongly advise if you do any serious coding to learn/move to the terminal and use make files, or a newer IDE such as visual studios.</p>

<p>heres a short script you can run save it as bash.sh
something like this</p>

<pre><code>g++ hello.cpp -O2 -g -c 
g++ hello.o printmessage.cpp -Wall -O2 -o print
</code></pre>

<p>then run it with ./print</p>
",1
12335682,12334930,0,"<blockquote>
  <p>I assume it has something to do with Dev-C++ (what I'm using to
  write/compile/run), but I can't figure it out.</p>
</blockquote>

<p>I guess so, too. Behind the scenes, the following things have to happen:</p>

<ol>
<li>Both files get <em>compiled</em>. This creates a <code>*.obj</code> file for every <code>*.cpp</code> file, and uses the header.</li>
<li>The object files are <em>linked</em> against one another and possibly against required libraries.</li>
</ol>

<p>Your problem lies in the ¡°one another¡± part of the second step: the code <em>compiles</em> all right, but linking fails. The header file is irrelevant at that point. More precisely, the linker invocation for <code>printingmessage.obj</code> contains a reference to a function which isn't defined in that object file or any of the default libraries. Most likely the problem is due to the <code>*.cpp</code> files not being part of the same project. You need to create a multi-source-file project where you can link multiple object files. How you do that with Dev-C++ is probably somewhere in their manuals.</p>
",0
13701048,13700860,4,"<p>C++ refers to a subclass as a ""derived class"".</p>

<p>In C++, classes are types, and the only ""subtypes"" are derived classes. So if you choose to use the words ""subtype"" and ""subclass"" in connection with C++, they're probably the same thing. Depending on your academic context, I suppose you might say that private inheritance does <em>not</em> create a subtype, in which case they're different. For that matter, in some academic contexts the concept of a ""subtype"" is not legitimate (formal type theory existed before OOP. For that matter before computer science unless you count Babbage).</p>

<p>In C++11 you can test whether <code>AClass</code> is a derived class of <code>Another</code> (optionally excluding the case where they're the same class):</p>

<pre><code>std::is_base_of&lt;Another, AClass&gt;::value &amp;&amp; !std::is_same&lt;Another, AClass&gt;::value
</code></pre>

<p>This expression is true even if the inheritance is private.</p>
",2
13702505,13700860,2,"<p>Those are theoretical concepts, not C++ one. But let's see how they can be applied to C++.</p>

<ul>
<li><p><em>subclassing</em> refers to the formation of new types by inheriting from another. C++ provides that mechanism and calls subclasses ""derived classes"".</p></li>
<li><p><em>subtyping</em> refers to the possibility to use values of the subtype in places where values of the type are expected.  In C++ you can consider that public inheritance implies a subtyping relationship, or you could be more restrictive and consider as subtyping only the cases where the overrides of virtual functions ensure respecting the LSP. And considering that private or protected inheritance doesn't (but still is a case of subclassing) is sane whatever constraints you put or not on virtual function overrides.</p></li>
</ul>

<p>So, as usual, the precise definitions -- and I purposefully gave none -- used will accept or exclude some corner cases (private or protected base classes in C++) or even a whole domain (do you consider the constraints that type template parameters have to comply to a typing system or not? if your definitions are open enough to apply to lot of languages, you may end up by answering yes and thus consider that C++ has two typing systems, with interactions. And now consider the effect of explicit specialization on the second.)  And precise definitions are usually made in order to ease the rest of the work in which they are proposed.</p>
",0
13701486,13700860,-3,"<p>Classes are new types defined by programmers, so I think that subclass == subtype.</p>

<p><strong>Steve Jessop</strong> wrote:</p>

<blockquote>
  <p>C++ refers to a subclass as a ""derived class"".</p>
</blockquote>

<p>I think no. Subclass is a class inside class (like Engine is a part of Car).</p>

<p>Look at the example below:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class Car
{
    public:
    class Engine //Engine is subclass
    {
        public:
        static void Start()
        {
               cout &lt;&lt; ""Engine is starting... \n"";
        }      
    };
};

class Animal
{
    public:
    static void Eat()
    {
           cout &lt;&lt; ""Animal is eating... \n"";
    }     
};

class Wolf : Animal //Wolf is derived class
{
      public:
      static void Howl()
      {
             cout &lt;&lt; ""Wolf is howling... \n"";
      }
};

int main()
{
    Car::Engine::Start();
    Animal::Eat();
    Wolf::Howl();

    system(""PAUSE""); //keep Console Window open in Debug Mode
    return 0;
}
</code></pre>
",2
13701004,13700860,1,"<p>From: <a href=""http://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html"" rel=""nofollow"">http://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html</a></p>

<blockquote>
  <p>There are important differences between subtypes and subclasses in supporting reuse. Subclasses allow one to reuse the code inside classes - both instance variable declarations and method definitions. Thus they are useful in supporting code reuse inside a class. Subtyping on the other hand is useful in supporting reuse externally, giving rise to a form of polymorphism. That is, once a data type is determined to be a subtype of another, any function or procedure that could be applied to elements of the supertype can also be applied to elements of the subtype.</p>
</blockquote>

<p>You should read the full article.</p>
",2
12285671,12285638,2,"<p>The order of initialization is the same as the order of declaration in the class.</p>

<p>If the order on the constructor's initialization list is different then compilers usually issue a warning. For example for the class:</p>

<pre><code>class A {
public:
    A() : b(1), a(b) {}
private
    int a;
    int b;
};
</code></pre>

<p>GCC will warn that:</p>

<pre><code>$ g++ -Wall c.cc
c.cc:5: error: expected `:' before ¡®int¡¯
c.cc: In constructor ¡®A::A()¡¯:
c.cc:6: warning: ¡®A::b¡¯ will be initialized after
c.cc:5: warning:   ¡®int A::a¡¯
c.cc:3: warning:   when initialized here
</code></pre>

<p>This is because it can easily lead to errors. In the above example value of <code>a</code> will be unspecified.</p>
",0
12285672,12285638,14,"<p>No. Members are constructed in the order in which they are declared.</p>
<p>You are advised to arrange your initializer list in the same order, but you are not required to do so. It's just very confusing if you don't and may lead to hard-to-detect errors.</p>
<p>Example:</p>
<pre><code>struct Foo {
    int a; int b;
    Foo() : b(4), a(b) { }  // does not do what you think!
};
</code></pre>
<p>This construction is actually undefined behaviour, because you're reading an uninitialized variable in the initializer <code>a(b)</code>.</p>
<hr />
<p>Standard reference (C++11, 12.6.2/10):</p>
<blockquote>
<p>¡ª Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).</p>
<p>¡ª Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).</p>
</blockquote>
",3
9828462,9828402,2,"<p><a href=""https://stackoverflow.com/questions/875479/what-is-the-difference-between-a-cpp-file-and-a-h-file"">What is the difference between a .cpp file and a .h file?</a></p>

<p>Look at this answer. Also a quick google search explains a bit too.</p>

<p>Pretty much .h (header) files are declerations and .cpp (source) files are definitions. It is possible to combine both files into one .cpp file but as projects get bigger and bigger its becomes annoying and almost unreasonable. </p>

<p>Hope that helps.</p>
",0
9828479,9828402,1,"<p>In C++ there is a notion of a function declaration (the function signature) and a function definition (the actual code).  </p>

<p>A header file (*.h) contains the declarations of functions and classes.  A source file (*.cpp, *.c++, *.C) contains the definitions.</p>

<p>A header file can be included in a source file using <code>#include</code> directive.</p>

<p>When you define a class in C++, you typically only include the declarations of the member functions (methods in Java lingo), and you put the class definition into a header file. The member function definitions containing the body of each function are typically put outside the class definition and into the source file.</p>

<p>Generally the best thing to do here is to get a book on C++ or C, and to look at some sample code.</p>
",0
9828483,9828402,0,"<p>Header files (.h) are supposed to contain definitions of classes, methods, and variables. Source file (.cpp) will contain the code. So in your .cpp file you need to include the header file as <code>#include ""header-file-name.h""</code>.</p>

<p>Then use g++ to compile the .cpp file. Make sure that the path to .h file is correct.</p>

<p>If you are using CodeBlocks or Visual Studio, then just compiling the project and running will do everything for you. You can also add .h or .cpp file from there. You need not worry about anything.</p>

<p>Hope this helps.</p>
",0
9828965,9828402,7,"<p>Hmm... Where to begin...</p>

<p>Somethings that happen behind the scenes in other languages are much more visible in C++. The process of obtaining a binary (say, an executable) from C++ involves first compiling the source code (There are sub-steps of this but the compiler handles them) to obtain object files, then the object files are linked by the linker to generate a binary.</p>

<p>In theory, you could simply <code>#include</code> all the cpp files in a project, and compile them all together and ""link"" (although there's nothing to link) but that would take a very long time, and more importantly, in complex projects that could deplete the memory available to your compiler.</p>

<p>So, we split our projects into compilation units, and by convention a .cpp file represents a single compilation unit. A compilation unit is the part of your project that gets compiled to generate one object file. Even though compilation units are compiled separately, some code has to be common among them, so that the piece of code in each of them can use the functionalities implemented by the others. .h files conventionally serve this purpose. Things are basically declared (sort of announced) in them, so that each compilation unit knows what to expect when it's a part of a linking process to generate a binary.</p>

<p>There's also the issue with libraries. You can find mainly two kinds of things in libraries; </p>

<ul>
<li>Already implemented functionality, shipped to you in the form of binary files including CPU instructions that can almost be run (but they've to be inserted in the right place). This form is accompanied by .h files to let your .cpp files know what to expect in the library. </li>
<li>The second type is functionality implemented directly in the .h
files. Yes, this is possible under special cases. There are cases,
where the implementation has to (a weak has to) accompany the
declaration (inlined functions, templated types etc.).</li>
</ul>

<p>The first type comes in two flavors: A ""static library"" (.lib in windows, .a in linux), that enters your executable and becomes a part of it during linking, and a ""dynamic library"", that is exposed to your binary (so it knows about it) but that doesn't become a part of it. So, your executable will be looking for that dynamic library (.dll files in windows and .so files in linux f.x.) while it's run.</p>

<p>So, in order for your .cpp files to be able to receive services from libraries, they have to <code>#include</code> their .h files, to know about what there is in them. Later on, during linking, you have to show the linker where (what path in the file system) to find the binary components of those libraries. Finally, if the library is dynamic, the .dll's (or .so's etc.) must be accessible during run time (keep them in the same folder for instance). </p>

<p>While compiling your compilation units you have to tell the compiler where to find the .h files. Otherwise, all it will see will be <code>#include &lt;something.h&gt;</code> and it won't know where to find that file. with gcc, you tell the compiler with the <code>-I</code> option. Note that, you just tell the folder. Also of importance is that if the include directive looks like <code>#include&lt;somefolder/somefile.h&gt;</code> you shouldn't include <code>somefolder</code> in the path. So the invocation looks like:</p>

<pre><code>g++ mycompilationunit.cpp -IPATH/TO/THE/INCLUDED/FILES -IPATH/TO/OTHER/INCLUDED/FILES -c
</code></pre>

<p>The <code>-c</code> option tells the compiler that it shouldn't attempt to make an executable just from this compilation unit, so it creates a .o file, to be linked with others later. Since we don't tell it the output file name, it spits out <code>mycompilationunit.o</code>.</p>

<p>Now we want to generate our binary (you probably want an executable, but you could also want to create a library of yours). So we have to tell the linker everything that goes into the binary. All the object files and all the static and dynamic libraries. So, we say: (Note g++ here also acts as the linker)</p>

<pre><code>g++ objectfile1.o objectfile2.o objectfile3.o -LPATH/TO/LIBRARY/BINARIES -llibrary1 -llibrary2 -o myexecutable
</code></pre>

<p>Here, -L option is self explanatory in the example. -l option tells which binaries to look for. The linker will accept both static and dynamic libraries if it finds them on the path, and if it finds both, it'll choose one. Note that what goes after -l is not the full binary name. For instance in linux library names take the form <code>liblibrary.so.0</code> but they're referred to as -llibrary in the linker command. finally -o tells the compiler what name to give to your executable. You need some other options to f.x. create a dynamic library, but you probably don't need to know about them now.</p>
",1
14861797,14861773,7,"<p>You need to overload the <code>operator &lt;&lt;</code> for LList. To do that implement the following:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(ostream&amp; out, const LList&amp; llist)
</code></pre>
",3
13782759,13782742,0,"<p>Undefined behaviour, which happens to successfully pretend it works.</p>
<blockquote>
<p>3.10 Lvalues and rvalues [basic.lval]</p>
<p>...</p>
<p>10 If a program attempts to access the stored value of an object through a glvalue of other than
one of the following types the behavior is undefined:</p>
<p>¡ª the dynamic type of the object</p>
</blockquote>
",0
13782761,13782742,4,"<p>Both <code>pstruct</code> and <code>pstruct2</code> point to the same location in memory (Since you assigned the address stored in <code>ptr</code> to both) and thus the data inserted by the <code>MyStruct::store</code> method was overwritten by the <code>MyStruct2::store</code> method.</p>

<p>In other words, this is happening because you are explicitly making it happen. If your two classes weren't identical or if the compiler had produced different memory layouts of them, you would've possibly read out garbage data.</p>

<hr>

<p>Basically, C++ allows you to write into any dynamically allocated memory as much as you want, happily ignorant and oblivious of the fact that you had previously used this memory for another object.</p>
",0
12788300,12788244,0,"<p>The ""new style"" cast is </p>

<pre><code>Rectangle *rect = reinterpret_cast&lt; Rectangle* &gt;( rawdata );
</code></pre>

<p>But you should be careful with the alignment, the padding in your class.</p>

<p>This will use the same memory, it will just interpret it like a <code>Rectanle</code> object.</p>

<p><code>memcpy</code> will copy it. Depends on your needs. Most probably, you don't need it.</p>
",2
12788344,12788244,2,"<p>I'd say having a constructor:</p>

<pre><code>Rectangle(const u_char*)
</code></pre>

<p>having casts all over the code could work fine for now, but it's a terrible idea in case you want to change your class later on. Having a constructor can mean <em>some</em> overhead, but you'd have a single point where the logic happens.</p>

<p>If later you decide you want to add a virtual method to <code>Rectangle</code>, all casts in the code will become useless.</p>

<p>This is of course if you want to construct a new object from data. If you frequently serialize/deserialize objects, I'd go with serializations methods:</p>

<pre><code>const u_char* toUChar() const;
void fromUChar(const u_char*) const;
</code></pre>
",4
12788398,12788244,2,"<pre><code>Rectangle&amp; rect = *reinterpret_cast&lt;Rectangle*&gt;(rawdata);
</code></pre>
<p>I'll do it this way if <code>rawdata</code> is <code>void</code> or cast directly to a reference if <code>rawdata</code> is any other type (one that I can deference directly).</p>
<p>I prefer the reference because I find it less error prone than using raw pointers. However, if you need to do pointer arithmetic there's no problem making it a raw pointer. Depending on usage you might want to cast to a <code>const Rectangle&amp;</code> instead of non-<code>const</code>.</p>
<p>However, usually with raw byte streams you need to invent a protocol and you <em>shouldn't</em> cast directly into a struct or class. Structs and classes may have padding which messes up your direct cast. The cast will silently succeed no matter what, but your values will be unexpected. A protocol would be something like...</p>
<blockquote>
<p>0 offset: (4 bytes - float) size</p>
<p>4 offset: (2 bytes - uint16_t) height</p>
</blockquote>
<p>etc. Doing the protocol approach would mean you'll have to assign the members one by one.</p>
",3
12788431,12788244,1,"<p>The easiest and most reliable method is to simply use a convert constructor:</p>

<pre><code>class Rectangle
{
public:
  Rectangle(uint8_t l, uint8_t h) : length(l), height(h) {};
  // ...
};
</code></pre>

<p>This should be your go-to method until for whatever reason this is impossible.</p>

<p>Barring this, the next best thing to do is simply do a memberwise initialization:</p>

<pre><code>Rectangle rect;
rect.width = 20;
rect.height = 40;
</code></pre>

<p>If it becomes impossible to do the above, and <em>iff</em> the object in question is what the Standard refers to as an ""aggregate"" (basically a POD), you can use an initializer like this:</p>

<pre><code>Recatagle rect = {10,20};
</code></pre>

<p>When doing this, you must bear in mind that the members will be initialized in the order in which they are declared in the class.  If you change the order of declaration, you will break every initialization like the above.  This is very brittle.  For this reason, I limit my use of a construct like this to cases where the class in question is highly localized (like a helper class in a single translation unit), and I document the need to keep the order of declaration intact.</p>

<p>EDIT PER COMMENTS:</p>

<p>In the instance you are trying to copy strings in to your class, or pointers to any sort of data, you will need to do a deep copy:</p>

<pre><code>class Gizmo
{
public:
  Gizmo(const char* str) : str_(0)
  {
    str_ = new char[strlen(str)+1];
    strcpy(str_,str);
  }
};
</code></pre>

<p>Note the clumsiness and how brittle the above code is.  There are plenty of things that could go wrong here.  Not the least of which are forgetting to <code>delete</code> <code>str_</code> when <code>Gizmo</code> is destroyed, the ugliness and seeming lack of necessity for <code>new</code>ing a <code>char</code> string in the first place, one-past-the-end errors ... the list goes on.  For these reasons, it's best to avoid using raw pointers at all and using either smart pointers (ie <code>unique_ptr</code>, <code>shared_ptr</code>, etc) or collection classes.  In this case, I'd use a <code>std::string</code>, which can be thought of as a collection class:</p>

<pre><code>class Gizmo
{
public:
  Gizmo(const char* str) : str_(str) {};
private:
  std::string str_;
};
</code></pre>

<p>Feel free to convert this for use with a <code>u_char*</code>, and to add robustness by means of verifying the source pointer is valid.</p>
",5
12788488,12788244,0,"<p>While directly casting is a little faster, doing it that way locks your class into a specific design.  If you later make changes to the data within the class, all casts will break.</p>

<p>A better way to handle raw data would be to either make a constructor and/or overload the input stream operator.  I personally prefer overloading the operator to a constructor because I hate having more than one simple constructor to a class.  The overload might look something like this:</p>

<pre><code>istream&amp; operator &gt;&gt; (istream&amp; input, char* rawData)
{
    //fill your object's variables directly from the raw data
}
</code></pre>

<p>This way you take control of filling your object from the data, and if the data or your object ever changes, you only have to change code in one location to fix it everywhere.</p>

<p>I also like using the operator overload over creating a function for it because I think it makes the code look nicer and faster to see what you're doing.</p>
",0
10151868,10151859,1,"<p><code>[]</code> has higher precedence than <code>*</code></p>

<p>This is likely what you intend:</p>

<p><code>(*mapPtr)[""a""].length();</code></p>
",0
10151879,10151859,3,"<pre><code>    (*mapPtr)['a'].length();
</code></pre>

<p>the <code>*</code> operator has a lower precedence than <code>[]</code> so you have to but that in brackets.  Also <code>""a""</code> is the string literal (char array) whereas you want <code>'a'</code></p>

<p>A complete list of operator precedences in C++ can be found <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow"">here</a></p>
",0
9797932,9797865,6,"<p>That's called the <em>static initialization fiasco</em>. Basically there is no fixed order on the execution of the constructors for variables with static duration defined in different translation units. In this particular case the <code>Word::DEFAULT_SETTINGS</code> has been constructed before the <code>Character::DEFAULT_SETTINGS</code> and thus has read the <code>0</code> value that variables of static duration have before being actually initialized. If you want to see something interesting, dump the contents of <code>Character::DEFAULT_SETTINGS</code> and you will see that <em>strangely</em> enough it is <code>14</code></p>
",5
9798574,9797865,1,"<p>The static initialization order problem can be solved with some clever (not really) header file tricks. </p>

<p>Basically the gist of the idea is this (and I have implemented it in practice, several times, though eons ago, so this is not just some idle Stack Overflow idea of the moment):</p>

<p>Basically, you put the definition of the static object, like <code>foo_class g_foo;</code> in a specially delimited area of your <code>foo.h</code> header file:</p>

<pre><code>#ifndef FOO_H
#define FOO_H

#include ""bar.h""  // dependency: crucial part!

// ... declares foo_class ...

// foo is a client of bar

// Now somewhere near the bottom:

#ifdef DEFINE_GLOBAL_SINGLETONS
foo_class g_foo;
#endif
</code></pre>

<p>Now you set up a specially designated singleton repository source file, where you include all the headers.</p>

<pre><code>// singletons.cc
#define DEFINE_GLOBAL_SINGLETONS
#include ""foo.h""
#include ""bar.h""  // note deliberately wrong order!
</code></pre>

<p>The header file include dependencies and guards will cause the headers to be included in the module dependency order, and thus the <code>DEFINE_GLOBAL_SINGLETONS</code> sections to be added to the translation unit in the proper order.</p>

<p>Within a single translation unit, C++ requires the objects to be constructed top to bottom.</p>

<p>So you get Ada/Modula like module initialization order: used module before user. <code>foo</code> users <code>bar</code> and soo the  <code>bar</code> singleton, if any, is initialized before the <code>foo</code> one.</p>

<p>Now the downside: recompiling the singleton repository every time a header changes. </p>
",0
12867241,12867223,8,"<p>How about converting your inches to feet first:</p>

<pre><code>feet = feet + inches / 12.0;
</code></pre>

<p>Now print out the result. Or if you don't want to change your <code>feet</code> variable, either do the calculation directly in your <code>cout</code> statement or use a temporary variable for the calculation.</p>
",1
12314989,12314926,6,"<p><code>dlopen</code> is <code>C</code> function. It doesn't throw any <code>exception</code>.</p>

<pre><code>void *dlopen(const char *filename, int flag);
</code></pre>

<p>From <code>man dlopen</code></p>

<blockquote>
  <p>If dlopen() fails for any reason, it returns NULL.</p>
</blockquote>

<p>So, check return value for <code>NULL</code>.</p>

<p>So, for check, that symbol exists you should use</p>

<pre><code>void *dlsym(void *handle, const char *symbol);
</code></pre>

<p><Blockquote><P>
If the symbol is not found, in the specified library or  any  of  the  libraries
       that  were  automatically loaded by dlopen() when that library was loaded, <strong>dlsym() returns NULL</strong>.  (The search performed by dlsym()
       is breadth first through the dependency tree of these libraries.)  <strong>Since the value of the symbol could actually be NULL (so that a
       NULL  return  from dlsym() need not indicate an error), the correct way to test for an error is to call dlerror() to clear any old
       error conditions, then call dlsym(), and then call dlerror() again, saving its return value into a  variable,  and  check  whether
       this saved value is not NULL</strong>.
</P></Blockquote></p>
",4
13434036,13433927,1,"<p>Depending on you needs you can either use a <code>std::vector&lt;std::vector&lt;T&gt; &gt;</code> or a class giving a <code>std::vector&lt;T&gt;</code> an interface of a two dimensional areay. For tha latter you would overload <code>operator[]()</code> to return an object giving a subrange of the internal <code>std::vector&lt;T&gt;</code> the felling of an array itself. If you just want to use the subscriot operator, returning a <code>std::vector&lt;T&gt;::iterator</code> would work but it wouldn't expose, e.g., <code>begin()</code> and <code>end()</code> iterators.</p>
",0
13433959,13433927,2,"<p>yes:</p>

<pre><code>std::vector&lt;std::vector&lt;int&gt; &gt; ...;
</code></pre>
",0
13433973,13433927,0,"<p>If you really want to use the <code>new</code> keyword, you would have to do a 2-step initialization:</p>

<pre><code>int **mapa;
Snake(int szer,int wys)
{
    mapa = new int*[szer];
    for (int i = 0; i &lt; szer; i ++)
        mapa[i] = new int[wys];
...
</code></pre>
",2
8787258,8787243,4,"<p>Use</p>

<pre><code>isUnique(str.c_str())
</code></pre>

<p>and make sure <code>isUnique</code> takes a <code>char const *</code> argument.</p>
",6
8787270,8787243,10,"<p>Pass the argument as:</p>

<pre><code>isUnique(str.c_str());
</code></pre>

<p>And make the parameter type of the function as<code>const char*</code>:</p>

<pre><code>bool isUnique(const char *s)
</code></pre>

<p>Because <code>std::string::c_str()</code> returns <code>const char*</code>.</p>

<p>Or even better, make the parameter <code>const string&amp;</code>:</p>

<pre><code>bool isUnique(const std::string &amp; s);
</code></pre>

<p>And pass as you do : <code>isUnique(str)</code>. Inside the function you can use <code>s[i]</code> to access the characters in the string, where  <code>0 &lt;= i &lt; s.size()</code>.</p>
",0
8787283,8787243,3,"<p>You are not passing a string. You are passing a <code>char *</code> and trying to create one from a <code>string</code>. Of course the conversion from <code>string</code> to <code>char *</code> is not automatic - they are two very different things.</p>

<p>I suggest that you write this function:</p>

<pre><code>bool isUnique(const std::string&amp; s)
</code></pre>
",4
8787284,8787243,3,"<p>Either change function to accept</p>

<p><code>bool isUnique(const string&amp; s)</code></p>

<p>and pass the string as a const reference</p>

<p>or do as the two other fine people suggested.</p>

<p>This being C++ it would be preferable to pass a <code>const std::string&amp;</code> unless of course you have to be compatible with some C code or just have a requirement of using C-strings.</p>
",0
10814162,10813930,15,"<p>Use a <a href=""http://www.boost.org/doc/libs/1_41_0/libs/iostreams/doc/classes/mapped_file.html"" rel=""noreferrer"">memory-mapped file</a> and walk backwards. The OS will page in the needed parts of the file in reverse order.</p>
",1
10814069,10813930,3,"<p>The short answer would be no. However, you can use the seek() function to move your pointer to where you want to go. Then read() some data from that point. If you know well how to manage buffers, then it should be pretty quick because you can read and cache the data and then search for the previous newline character(s). Have fun with \r\n which will be inverted...</p>

<p>-- Update: some elaboration on the possible algorithm --</p>

<p>This is not valid code, but it should give you an idea of what I'm trying to say here</p>

<p>File reads:</p>

<pre><code>int fpos = in.size() - BUFSIZ;
char buf[BUFSIZ];
in.seek(fpos);
in.read(buf, BUFSIZ);
fpos -= BUFSIZ; // repeat until fpos &lt; 0, although think of size % BUFSIZ != 0
// now buf has characters... reset buffer position
int bpos = BUFSIZ - 1;
</code></pre>

<p>Getting string:</p>

<pre><code>// first time you need to call the read
if(bpos == -1) do_a_read();
// getting string
std::string s;
while(bpos &gt;= 0 &amp;&amp; buf[bpos] != '\n') {
  s.insert(0, 1, buf[bpos]);
  --bpos;
}
// if bpos == -1 and buf[0] != '\n' then you need to read another BUFSIZ chars
// and repeat the previous loop...

// before leaving, skip all '\n'
while(bpos &gt;= 0 &amp;&amp; buf[bpos] == '\n') {
  --bpos;
}
return s;
</code></pre>

<p>To ease with '\r', you could have a first pass that transforms all '\r' to '\n'. Otherwise, all the tests of '\n' need to also test for '\r'.</p>
",2
10814273,10813930,9,"<p>As per comment, a possible (quite simple) alternative would be read the lines into a <code>vector</code>. For example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    std::ifstream in(""main.cpp"");

    if (in.is_open())
    {
        std::vector&lt;std::string&gt; lines_in_reverse;
        std::string line;
        while (std::getline(in, line))
        {
            // Store the lines in reverse order.
            lines_in_reverse.insert(lines_in_reverse.begin(), line);
        }
    }
}
</code></pre>

<p>EDIT:</p>

<p>As per <a href=""https://stackoverflow.com/users/947836/jrok"">jrok</a>'s and <a href=""https://stackoverflow.com/users/14065/loki-astari"">Loki Astari</a>'s comments, <code>push_back()</code> would be more efficient but the lines would be in file order, so reverse iteration (<code>reverse_iterator</code>) or <a href=""http://en.cppreference.com/w/cpp/algorithm/reverse"" rel=""nofollow noreferrer""><code>std::reverse()</code></a> would be necessary:</p>

<pre><code>    std::vector&lt;std::string&gt; lines_in_order;
    std::string line;
    while (std::getline(in, line))
    {
        lines_in_order.push_back(line);
    }
</code></pre>
",10
10814112,10813930,4,"<ol>
<li><p>Open the file for read, call <code>fseek()</code> to seek to the end of the file, then call <code>ftell()</code> to get the length of the file. Alternatively you can get the file length by calling <code>stat()</code> or <code>fstat()</code></p></li>
<li><p>Allocate a buffer pointer to the file size obtained in #1, above.</p></li>
<li><p>Read the entire file into that buffer -- you can probably use <code>fread()</code> to read the file all in one shot (assuming the file is small enough).</p></li>
<li><p>Use another char pointer to transverse the file from end to beginning of the buffer.</p></li>
</ol>
",1
16941243,16941194,0,"<p>Being in the same file changes nothing, your function can only access <code>a</code> as it is <code>public</code> and your function is not a member of <code>A</code> (for the <code>private</code> members) nor a sub class of it (for the <code>protected</code> members).</p>
",0
16941263,16941194,1,"<p>Those variables will be per-instance (non-static member variables), so you first need to create an object to access them. Only <code>public</code> members can be accessed from a free-standing function unless the function is declared <code>friend</code> of that class in which case all members can be accessed.</p>

<p>That said it doesn't matter if they are in the same file or not. Once the class definition is visible where the function is implemented the members can be accessed.</p>
",0
16941276,16941194,0,"<p>To my knowledge, using your above example ARandomFUnction can access the public variables and functions regardless of inheritance. THe protected variables can only be accessed if ARandomFunction is contained in a class that inherits from or is a member of class A. Private variables and methods can only be accessed from the same class.</p>
",2
9206926,9206230,0,"<p>You can just add all fields of struct_tm and here is your hash. Or xor them or something similar.</p>
",2
14149408,14149384,7,"<p>You've replaced <code>output</code> with a different pointer, so you aren't deleting the same thing you allocated:</p>

<pre><code>output = fgets(tmp_buffer, len, input);
</code></pre>

<p>I'm not sure why <code>read_stdin</code> has the <code>output</code> parameter.  If you just need to check the result of fgets, then you could use a local variable instead: </p>

<pre><code>inline bool read_stdin(char *tmp_buffer, const size_t &amp;len, FILE *input) {
    char *output = fgets(tmp_buffer, len, input);
    .
    .
    .
}
</code></pre>
",6
9161832,9161771,3,"<p>If you're using C++11, use <code>std::unordered_map</code>, defined in <code>&lt;unordered_map&gt;</code>.</p>

<p>Otherwise, use <code>std::tr1::unordered_map</code>, defined in <code>&lt;tr1/unordered_map&gt;</code>, or <code>boost::unordered_map</code>, defined in <code>&lt;boost/unordered_map.hpp&gt;</code>.</p>

<p>If your key is a user-defined type, then you'll need to either define <code>hash</code> and <code>operator==</code> for the type, or provide suitable function types as template arguments to <code>unordered_map</code>.</p>

<p>Of course, you should also measure the performance compared to <code>std::map</code>; that may be faster in some circumstances.</p>
",3
9162711,9161771,0,"<p>hash map is called unordered_map. You can get it from <a href=""http://www.boost.org/doc/libs/1_46_0/doc/html/boost/unordered_map.html"" rel=""nofollow"">boost</a> and that will probably work even if you can't get a std/tr1 one to work. In general the lookup time is ""constant"" which means it does not increase with the complexity of the nubmer of elements. However you have to look at this in more detail:</p>

<ul>
<li><p>""constant"" assumes you never have more than a fixed number of ""collisions"". It's unlikely you won't have any, and then you have to measure the fact that there will be some collisions.</p></li>
<li><p>""constant"" includes the time taken to hash the key. This is a constant time as it makes no difference how many other elements there are in the collection, however it is still a task that needs to be done, by which time your std::map may already have found your element.</p></li>
</ul>

<p>If the keys are extremely fast to hash and well distributed so very few collisions occur, then hashing will indeed be faster.</p>

<p>One thing I always found when working with hash maps was that for the optimal performance you almost always won by writing your own implementation rather than using a standard one. That is because you could custom-tune your own for the data you knew you were going to handle. Perhaps this is why they didn't put hash maps into the original standard.</p>

<p>One thing I did when writing my own was store the actual hash value (the originally generated one) with the key. This was the first comparison point (usually faster than comparing the key as it's just an int) and also meant it didn't need to be regenerated if you resized your hash-table.</p>

<p>Note that hash-tables are easier to implement if you never delete anything from them, i.e. it is load and read only.</p>
",2
8794811,8794760,3,"<p>Semi-colon after function name at definition:</p>

<pre><code>int scan();
{
    ...
}
</code></pre>

<p>Should be:</p>

<pre><code>int scan()
{
    ...
}
</code></pre>

<p>Same for <code>multiply()</code> and <code>print()</code> functions.</p>

<p>Also:</p>

<ul>
<li>Neither <code>scan()</code>, <code>multiply()</code> and <code>print()</code> return a value yet their return value is <code>int</code>.</li>
<li><code>scan()</code>, <code>multiply()</code>, <code>print()</code> and declared and defined within <code>main()</code>.</li>
</ul>

<p>Here is the posted code in a compilable state (I am making no declaration as to is correctness):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void scan();
void multiply();
void print();

int metxa[3][4],metxb[4][3],resut[3][3];

int main(int argc, char *argv[])
{
    scan();
    multiply();
    print();
    system(""PAUSE"");

    return 0;
}

void scan()
{
    int i;
    for(i=0;i&lt;3;i++)
    {
        scanf(""%d %d %d %d"",
              &amp;metxa[i][0],
              &amp;metxa[i][1],
              &amp;metxa[i][2],
              &amp;metxa[i][3]);
    }
    for(i=0;i&lt;4;i++)
    {
        scanf(""%d %d %d"",
              &amp;metxb[i][0],
              &amp;metxb[i][1],
              &amp;metxb[i][2]);
    }
}

void multiply()
{
    int i,j;
    for(i=0;i&lt;3;i++)
    {
        for(j=0;j&lt;3;j++)
        {
            resut[i][j] = metxa[i][0]*
                          metxb[0][j]+metxa[i][1]*
                          metxb[1][j]+metxa[i][2]*
                          metxb[2][j]+metxa[i][3]*
                          metxb[3][j];
        }
    }
}

void print()
{
    int i,j;
    for(i=0;i&lt;3;i++)
    {
        for(j=0;j&lt;3;j++)
        {
            printf(""%d\t"",resut[i][j]);
        }
        printf(""\n"");
    }
}
</code></pre>
",2
8794847,8794760,3,"<p>You need to either declare the function before you call it, or at least a forward declarations of it with the implementation somewhere later.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void scan();
int main(int argc, char *argv[])
{
    scan();
}

void scan()
{
  //do stuff
}
</code></pre>

<p>or</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void scan()
{
  //do stuff
}
int main(int argc, char *argv[])
{
    scan();
}
</code></pre>

<p>You also need to declare the matrix outside the body of main(). As with the functions, they will not be availiable if you do.</p>
",0
9785422,9785386,0,"<p>Easiest would to be slice the string into its component parts of year, month, day and compare those.</p>

<p><a href=""https://stackoverflow.com/questions/236129/how-to-split-a-string-in-c"">See here to split strings by delimiter.</a></p>
",0
9785432,9785386,2,"<p>Here's one idea for an algorithm:</p>

<ol>
<li>Check that the length is the expected one. This is quick.</li>
<li>Check that the colons are in the expected places.</li>
<li>Check that the first four characters are digits.</li>
<li>Check that the middle two characters are digits.</li>
<li>Check that the final two characters are digits.</li>
</ol>

<p>If either test fails, return <code>false</code>. If you get through them all, return <code>true</code>.</p>

<p>Of course, this doesn't validate the ranges of the values. Also, you're not really ""comparing"", you are ""validating"".</p>
",3
9785443,9785386,1,"<p>You can use <a href=""http://www.boost.org/doc/libs/1_49_0/libs/regex/doc/html/index.html"" rel=""nofollow"">Boost Regex</a> to check whether the string matches your pattern.</p>
",0
9785445,9785386,1,"<p>This is the job for regular expressions. Since you're using C++, <a href=""http://www.boost.org/doc/libs/1_49_0/libs/regex/doc/html/index.html"" rel=""nofollow"">Boost.Regex</a> is one option.</p>
",0
9785484,9785386,0,"<p>Does your compiler support regular expressions, i.e. are you using a somewhat C++11 compliant compiler? This would make the task <strong>much</strong> easier ¡­ Otherwise you might want to resort to <a href=""http://www.boost.org/doc/libs/1_49_0/libs/regex/doc/html/index.html"" rel=""nofollow"">Boost.Regex</a>.</p>

<p>Assuming that you can use C++11, the following code should do what you want (untested though):</p>

<pre><code>std::regex rx(""\\d{4}:\\d{2}:\\d{2}"");
return regex_match(s.begin(), s.end(), rx);
</code></pre>

<p>John Cook has written <a href=""http://www.johndcook.com/cpp_regex.html"" rel=""nofollow"">an introduction into C++ regular expressions</a>. Just replace every occurrence of <code>std::tr1</code> by <code>std</code> if your compiler supports C++11.</p>
",0
9785564,9785386,4,"<p>Don't use regex. Use <code>strptime()</code>, which is designed to parse time strings (hence the name: <code>str p time</code>, string -> parse -> time). A regex can't figure out that <code>2013:2:29</code> is invalid.</p>
",6
14242512,14242491,4,"<p>No optimization worthy of being called such.</p>

<p>The only benefit is slightly fewer characters to load into memory and parse.  I doubt you could even measure the difference.</p>

<p>Use a programming style consistent with the rest of the team, or your personal preference, as appropriate.</p>
",0
14242525,14242491,1,"<p>It is just a choice of coding style. Personally, I hate defining multiple variables on one line.</p>
",0
14242560,14242491,0,"<p>In terms of milliseconds, for example, you would see almost no difference. But yes, There's a difference and one line variables are compiled faster than the others.</p>
",1
14242613,14242491,3,"<p>Possibly, yes. Smaller input files are faster to read for the compiler. But it would depend a lot on the implementation of the compiler. If you are interested in reducing build times in a compiler independent manner, there are a lot of other optimisations which can be done. <strong>Large-Scale C++ Software Design</strong> by John Lakos is a very good book to read for this.</p>
",0
14203040,9449135,0,"<p>replace end1 by endl and it'll work just fine! :)</p>
",1
12847480,12847456,18,"<p>This is forbidden by:</p>

<h3>8.3.6 Default arguments [dcl.fct.default]</h3>

<blockquote>
  <p>9) Default arguments are evaluated each time the function is called.
  The order of evaluation of function arguments is unspecified.
  <strong>Consequently, parameters of a function shall not be used in default
  argument expressions, even if they are not evaluated.</strong> Parameters of a
  function declared before a default argument expression are in scope
  and can hide namespace and class member names. [ Example:</p>
  
  <p><code>int a;</code></p>
  
  <p><strong><code>int f(int a , int b = a); / / error: parameter a</code></strong></p>
  
  <p><code>/ / used as default argument</code></p>
  
  <p><code>typedef int I;</code></p>
  
  <p><code>int g( float I , int b = I (2)); / / error: parameter I found</code></p>
  
  <p><code>int h(int a , int b = sizeof (a )); / / error, parameter a used</code></p>
  
  <p><code>/ / in default argument</code></p>
  
  <p>¡ªend example ]</p>
</blockquote>

<p><strong>An alternative</strong> is overloading:</p>

<pre><code>int foo(int a, int b);

int foo(int a)
{
   return foo(a,a);
}
</code></pre>
",5
12847531,12847456,2,"<p>I recommend using overloading for this particular task as <a href=""https://stackoverflow.com/a/12847480/1149736"">Luchian Grigore suggested</a>, but common practice would be to reserve some value to say ""this is default"". For example</p>

<pre><code>int foo( int a, int b = -1)
{
    if( b == -1){
       b = a;
    }
}
</code></pre>

<p>Using object (not scalar values) this could be really nicely implemented (by creating new delivered class reserved to represent default value), but with int you have to do this.</p>

<p>Note that you have to be 100% sure that <code>b</code> cannot get value <code>-1</code> (or whatever your reserved value is).</p>
",4
12848148,12847456,3,"<p>The reason this is disallowed has already been addressed, but another solution along the lines of @Vyktor's is to use <code>boost::optional</code> instead of magic numbers (This has pros and cons compared to creating an overload):</p>

<pre><code>int foo(int a, boost::optional&lt;int&gt; b = boost::none)
{
    if(!b) b = a;
}
</code></pre>
",1
12848355,12847456,0,"<p>This is a little funny answer - but works:</p>

<pre><code>#define TWO_FROM_ONE(a) (a),(a)

f(TWO_FROM_ONE(12));
</code></pre>

<p>One disadvantage is that this will call some function twice (a known macro drawback):</p>

<pre><code>f(TWO_FROM_ONE(sin(123 / PI)));
</code></pre>
",0
15560492,15560470,1,"<p>How about a template:</p>

<pre><code>#include &lt;utility&gt;    // for std::forward

template &lt;typename T, typename N, typename ...Args&gt;
N &amp; add(N &amp; node, Args &amp;&amp;... args)
{
    node.data.reset(new T(node, std::forward&lt;Args&gt;(args)...));
    return node;
}
</code></pre>

<p>Usage:</p>

<pre><code>add&lt;t_Wing&gt;(node_a);                // appends new t_Wing(node_a)
add&lt;x_Wing&gt;(node_b, arg1, arg2);    // appends new x_Wing(node_b, arg1, arg2)
</code></pre>
",0
15560574,15560470,1,"<p>Have constructors that call <code>data.reset</code> themselves, you're already passing the node arguments.  </p>
",0
8768585,8768526,3,"<p>You <em>don't want</em> to modify any Standard Library file!</p>

<p>You <em>want</em> to stop <code>std::cout</code> updating the console. You can do this by <a href=""https://stackoverflow.com/a/3667321/78845"">redirecting <code>std::cout</code></a>. The example to which I linked redirects to a file, but you can easily modify it to redirect to nowhere:</p>

<pre><code>#include &lt;iostream&gt;

class scoped_cout_silencer
{
public:
    scoped_cout_silencer()
        :backup_(std::cout.rdbuf())
    {
        std::cout.rdbuf(NULL);
    }

    ~scoped_cout_silencer()
    {
        std::cout.rdbuf(backup_);
    }

private:
    scoped_cout_silencer(const scoped_cout_silencer&amp; copy);
    scoped_cout_silencer&amp; operator =(const scoped_cout_silencer&amp; assign);

    std::streambuf* backup_;
};

int main()
{
    std::cout &lt;&lt; ""Now you see me."" &lt;&lt; std::endl;
    {
        scoped_cout_silencer silence;
        std::cout &lt;&lt; ""Now you don't."" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""Now you see me."" &lt;&lt; std::endl;
}
</code></pre>

<p><a href=""http://ideone.com/85Sgo"" rel=""nofollow noreferrer"">See it run!</a></p>
",0
8804948,8773429,0,"<p>i believe you should be looking for completely different design pattern.</p>

<p>for example, the ""keeper"" members should form a full-featured class, while the rest of the members that you don't want to keep would be considered a context of this class (would be another class, used to do some operations on the first class).</p>

<p>this is kind of similar to the <a href=""http://en.wikipedia.org/wiki/Flyweight_pattern"" rel=""nofollow"">flyweight design pattern</a>.</p>
",4
8798459,8798420,7,"<p>The problem is not the constructor, but your declaration(s) of <code>operator+</code> for the Matrix template.  Do you have two of those (maybe you forgot to rename one of them to <code>operator*</code>)?</p>
",2
12255631,12255603,0,"<p>Only fast way is to use the formula:</p>

<pre><code>n * (n+1) / 2
</code></pre>

<p>Any other method (adding naively) will take way too long! (Even if you had a million years on a supercomputer, you wouldn't finish the calculation).</p>

<p>For such a large integer though, you cannot use normal integers. You will need to use a big integer object. So get a Big Integer library, eg. <a href=""https://www.google.com/#q=c%2B%2B+bigint"" rel=""nofollow"">Google search</a>, <a href=""https://mattmccutchen.net/bigint/"" rel=""nofollow"">https://mattmccutchen.net/bigint/</a>.</p>

<p>Note: a 256-bit integer may be able to hold results up to around that scale, but it is quite platform and compiler-dependent, as to whether 256-bit integers are readily available, and how they are used.</p>
",0
8720460,8718728,0,"<p>I do not think it is possible to know which iterator comes before. It is not even guaranteed that the ordering is respected. You may find more information <a href=""https://stackoverflow.com/questions/1595270/how-does-the-stls-multimap-insert-respect-orderings"">here</a>.</p>

<p>The key_compare object only compares key values to know whether the first key goes before the second. You may consider it as a <em>minor than</em> operator for keys. It returns false because both keys are equal.</p>
",0
8798216,8798138,2,"<p>While you can have multiple overloads of the ""subscript"" <code>operator[]</code>, they must all take precisely one <em>argument</em> (and the argument cannot have a default value):</p>

<pre><code>struct Foo {
    R1 operator[](T)               { /* ... */ }
    R2 operator[](S const &amp;) const { /* ... */ }
    void operator[](U *)           { /* ... */ }
};
</code></pre>

<p>The reason is simply one of grammar: The expression <code>a[n]</code> is valid, but <code>a[m,n]</code> is not a valid binary expression (it is something rather different), and neither is <code>a[]</code> valind in that context.</p>

<p>With C++11's initializer lists you can make something like <code>a[{1,2,3}]</code> work, though (pending compiler support.)</p>
",1
10123973,10123773,0,"<p>I assume that after reading the last number from the input file the <em>end of file</em> has not been seen, yet. Try adding </p>

<pre><code>if (!i.good()) break; 
</code></pre>

<p>after each input statement (<code>&gt;&gt;</code>) to prevent the loop body to be executed after a failed input.</p>
",0
10124312,10123773,4,"<p>Using <code>.eof()</code> or <code>.good()</code> as a loop condition almost always produces buggy code, as it does in this case.</p>

<p>Rather, perform the input and check its result in the loop condition, like so:</p>

<pre><code>while(i &gt;&gt; c &gt;&gt; l)
{   count++;
    o &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(4);
    o &lt;&lt; setw(7) &lt;&lt; c;
    ...
</code></pre>

<p>References:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/5605125/why-is-iostreameof-inside-a-loop-condition-considered-wrong"">Why is iostream::eof inside a loop condition considered wrong?</a></li>
<li><a href=""http://www.parashift.com/c++-faq-lite/input-output.html#faq-15.5"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq-lite/input-output.html#faq-15.5</a></li>
</ul>
",0
11809952,11809936,5,"<p><a href=""http://en.cppreference.com/w/cpp/container/vector/erase"" rel=""nofollow""><code>std::vector&lt;T&gt;::erase</code></a> will return you an iterator following the last removed element. If you remove the last element, the returned iterator will be <code>end()</code>. And then you increment the iterator and get an exception. Also, even if you don't delete the last entry but another, you will still ignore the following element. </p>

<p>By the way, what do you want to achieve with <code>five[*it]</code>? The iterator acts like a pointer to a given element in the container. Either use a simple for-loop with an <code>int i</code>  and <code>five[i]</code> (which will have the same problems I stated above) <em>or</em> <code>*it</code>.<sup>*</sup></p>

<p>Try the following code instead:</p>

<pre><code>for(vector&lt;int&gt;::iterator it = five.begin(); it != five.end();)
{
    if (*it % 3 == 0)
    {
        it = five.erase(it);
    }
    else
         ++it;
}
</code></pre>

<p><sub>* While it's true that the value of your iterator is its own key this will only last until you first changed the vector. So after your very first erase <code>five[*it] != *it</code>.</sub></p>
",1
11809994,11809936,0,"<p>I think what you want to achieve is done by the two first <code>for</code> loops. The first loop will gather all integers multiple of 3 and the second one all the integers multiple of five. The loops performing erasures are redundant (and in these loops lies your problem using <code>erase</code> on iterator already used in the loops)</p>
",0
11498789,11487361,1,"<p>A <em>static_cast</em> is indeed all that is required to cast a <em>pointer-to-member</em> of type <code>Child::*</code> to type <code>Base::*</code>, but please remember that this might be quite dangerous if you by accident use the <em>pointer-to-member</em> on an instance of <code>Base</code> (and not the related <code>Child</code>).</p>

<hr>

<p>In the example below we use the same exact approach as described earlier, though calling <code>Child::func</code> on a object of type <code>Base</code> is causing <em>undefined-behavior</em> since we are accessing a <em>non-existent</em> member of Base inside the function.</p>

<pre><code>struct Base {
  /* ... */
};

struct Child : Base {

  void func () {
    this-&gt;x = 123;
  }

  int x;
};
</code></pre>

<p><sup></sup></p>

<pre><code>int
main (int argc, char *argv[])
{
  typedef void (Base::*BaseFuncPtr) (); 

  BaseFuncPtr ptr_to_child_func = static_cast&lt;BaseFuncPtr&gt; (&amp;Child::func);

  Base b;

  (b.*ptr_to_child_func) (); /* undefined-behavior */
}
</code></pre>
",0
8755411,8752251,0,"<p>Bitmap is passed as a BYTE.  Probably it should be a BYTE-pointer.</p>

<p>Try defining your function like this:</p>

<pre><code>bool DrawBitmap(BYTE *Bitmap, int x, int y, int w, int h)
{  
    for(int i=0;i&lt;=w;i++)  
        for(int i2=0;i2&lt;=h; i2++)  
        {  
            setpixel(i+x,i2+h, Bitmap[(((w*i2)-1)+i)]);
        }  
}  
</code></pre>
",1
13444413,13444390,4,"<p>instead of saving the age you should save the birthday, this way the age can be calculated when needed</p>
",0
9138850,9138727,10,"<p><code>std::map&lt;std::string, std::ofstream&gt;</code> can't possibly work, because <code>std::map</code> requires its data type to be Assignable, which <code>std::ofstream</code> isn't. In the alternative, the data type must be a pointer to ofstream -- either a raw pointer or a smart pointer.</p>

<p>Here is how I would do it, using C++11 features:</p>

<pre><code>#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main (int ac, char **av)
{
  // Convenient access to argument array
  std::vector&lt;std::string&gt; fileNames(av+1, av+ac);

  // If I were smart, this would be std::shared_ptr or something
  std::map&lt;std::string, std::ofstream*&gt; fileMap;

  // Open all of the files
  for(auto&amp; fileName : fileNames) {
    fileMap[fileName] = new std::ofstream(""/tmp/xxx/""+fileName+"".txt"");
    if(!fileMap[fileName] || !*fileMap[fileName])
      perror(fileName.c_str());
  }

  // Write some data to all of the files
  for(auto&amp; pair : fileMap) {
    *pair.second &lt;&lt; ""Hello, world\n"";
  }

  // Close all of the files
  // If I had used std::shared_ptr, I could skip this step
  for(auto&amp; pair : fileMap) {
    delete pair.second;
    pair.second = 0;
  }
}
</code></pre>

<p>and the 2nd verse, in C++03:</p>

<pre><code>#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main (int ac, char **av)
{
  typedef std::map&lt;std::string, std::ofstream*&gt; Map;
  typedef Map::iterator Iterator;

  Map fileMap;

  // Open all of the files
  std::string xxx(""/tmp/xxx/"");
  while(av++,--ac) {
    fileMap[*av] = new std::ofstream( (xxx+*av+"".txt"").c_str() );
    if(!fileMap[*av] || !*fileMap[*av])
      perror(*av);
  }

  // Write some data to all of the files
  for(Iterator it = fileMap.begin(); it != fileMap.end(); ++it) {
    *(it-&gt;second) &lt;&lt; ""Hello, world\n"";
  }

  // Close all of the files
  for(Iterator it = fileMap.begin(); it != fileMap.end(); ++it) {
    delete it-&gt;second;
    it-&gt;second = 0;
  }
}
</code></pre>
",2
9858787,9858754,1,"<p>I would try to put the two static classes in another namespace and make this namespace useable in the implemention files of the other 5 classes.
More ideas possible, if you give minimal example source.</p>
",0
9858798,9858754,3,"<p>There aren't static classes in C++. If by <em>static classes</em> you mean helper classes used by other classes in your code, and are not meant to be used by client code, then you can use unnamed namespace, and define the helper classes inside them.</p>

<pre><code>namespace somespace
{
    namespace   //it is unnamed namespace
    {
           class helper
           {
               //define it here
           };
    }
    class A
    {
          helper m_helper;
    };
}
</code></pre>

<p>Boost uses another technique as well. It defines all the helper classes in a namepace called <code>details</code>.</p>

<pre><code>namespace somespace
{
    namespace details  //it is details namespace
    {
           class helper
           {
               //define it here
           };
    }
    class A
    {
          details::helper m_helper;  //use fully-qualified name
    };
}
</code></pre>
",3
9858899,9858754,2,"<p>There are 2 possibilities to prevent using classes in c++, first one is to make these classes private and nested inside the class where you go to use them.</p>

<pre><code>class User{
private:
  class Internal{};
};
</code></pre>

<p>The second possibility is to make the constructor of your class private and declare the friend classes which will be able to use it like:</p>

<pre><code>class Internal{
private:
 friend class User;
 Internal(){}
public:
 //class interface.
};
</code></pre>
",0
9862594,9862531,1,"<p>Move the return outside of the while loop. If you get into the case where you move the pointer you have to go through the while loop again and that return exits the method before you do that. </p>
",0
11514419,11514375,1,"<pre><code>#include &lt;utility&gt;
#include &lt;iostream&gt;

template &lt;typename T1, typename T2&gt;
std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const std::pair&lt;T1, T2&gt;&amp; v)
{
    out &lt;&lt; v.first;
    out &lt;&lt; "" "";
    out &lt;&lt; v.second &lt;&lt; std::endl;
    return out;
}

int main()
{
    std::pair&lt;int, int&gt; a = std::make_pair(12, 124);
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    return EXIT_SUCCESS;
}
</code></pre>

<p>Its an example how to declare and implement an operator &lt;&lt;</p>
",0
11514535,11514375,1,"<p>I will show your solution in code</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

/* our custom class */
class Developer 
{
public:
    Developer(const std::string&amp; name, int age) :
     m_name(name), 
     m_age(age) 
    {}

    const std::string&amp; name() const { return m_name; }
    int age() const { return m_age; }

private:
    std::string m_name;
    int m_age;
};

/* overloaded operator&lt;&lt; for output of custom class Developer */
std::ostream&amp; operator&lt;&lt; (std::ostream&amp; stream, const Developer&amp; developer) 
{
    stream &lt;&lt; ""Developer name:\t"" &lt;&lt; developer.name() &lt;&lt; std::endl;
    stream &lt;&lt; ""Developer age:\t""  &lt;&lt; developer.age()  &lt;&lt; std::endl;
    return stream;
}

/* test custom operator&lt;&lt; for class Developer */
int main(int argc, const char** argv) 
{    
    Developer max(""Maxim"", 23);
    std::cout &lt;&lt; max;

    return 0;   
}
</code></pre>
",0
11514574,11514375,5,"<p>Derp. I did not include iostream. However, this does not make much sense to me... since it worked whenever I did not add a string to the ostream. I would think that the compiler would not be able to find ostream at all, and would complain about that</p>
",1
10645243,10645214,2,"<p>Since <code>x</code> is declared <code>private</code> in <code>A</code>, nothing in <code>B</code> can directly access it.  Of course, it can be accessed indirectly -- <code>B</code> can call <code>A::show()</code> which can access <code>x</code>.  But <code>B::show()</code> cannot access <code>x</code>, nor can anything else in <code>B</code>.</p>
",2
10645349,10645214,2,"<p>You are not really accessing <code>A.x</code>, you are accessing <code>A.show()</code>. </p>

<p>To answer your question, <code>B::show()</code> is <strong>not</strong> accessing the private member <code>x</code> in <code>A</code>.</p>

<p>The reason for this is, <code>class A</code> can change the function <code>A::show()</code> and do something else, and <code>B</code> can just call <code>A::show()</code>. </p>

<p>This is the main point of encapsulation. You can tell A to do <em>things</em> (like <code>show()</code>), but <code>A</code> decides how to do them. </p>
",0
10645449,10645214,0,"<ol>
<li>A::show() can access any member variables in it's own class, class A.</li>
<li>Member functions in class B can access any public or protected member <em>variables</em> in class A.<br>
and</li>
<li>Member functions in class B can access any public of protected member <em>functions</em> in class A.</li>
</ol>

<p>2 and 3 are possible because the ""Most accessible level"" of A is defined as public.</p>

<pre><code>Class B: public A
</code></pre>

<p>In your code, specifically, the accessibility level of <code>int x;</code> doesn't matter, because it is never directly accessed from class B.</p>
",0
10744444,10744403,2,"<p>You are right, normally the address would be printed. Except there's a special overload for <code>char *</code>, which considers it as a C string and outputs all the characters, starting at <code>ptr</code>, up until it finds a zero (<code>\0</code>).</p>

<p>... or that would be what happens if your code was correct, because as it is now, it invokes UB by decrementing <code>ptr</code> on the first iteration (<code>ptr</code> moves out of range) and then incrementing it by 2 right after.</p>

<hr>

<p>If you want to display the <em>address</em> of the pointer, cast it to <code>void *</code>:</p>

<pre><code>cout &lt;&lt; static_cast&lt;void *&gt;(ptr) &lt;&lt; endl;
</code></pre>
",6
10744456,10744403,2,"<p>Nothing really hacky here. There's an <code>ostream::operator&lt;&lt;(const char *p)</code> which prints a character string. The pointer is walked along the string and the program prints it starting from various positions. The only weird thing is the crazy +2, -1 pointer incrementing.</p>
",1
10744465,10744403,3,"<p>This is <strong>undefined behavior</strong>. The first iteration, <code>ptr</code> points to <code>&quot;object&quot;</code>. All good, prints that out, but then you do <code>ptr--</code>. So now, <code>ptr</code> points to memory you no longer own. As long as you don't dereference it or do pointer arithmetics on it, it's ok. But you do when you increment it in the loop - <code>ptr+=2</code>.</p>
<h3>Why it's behaving like this:</h3>
<p>At the first iteration, <code>ptr</code> points to <code>&quot;object&quot;</code>, so it prints that. <code>cout::operator &lt;&lt; (const char*)</code> prints a null-terminated string. No <code>char</code> needs dereferencing.</p>
<p>On the second iteration, <code>ptr</code> is decremented and then increased by <code>2</code>, pointing to <code>&quot;bject&quot;</code>. And so on...</p>
",7
10112744,10112693,7,"<p>I would use a <a href=""http://www.cplusplus.com/reference/stl/map/"" rel=""noreferrer"">std::map</a> (or maybe an <code>std::unordered_map</code>) whose key is a <a href=""http://www.cplusplus.com/reference/std/utility/pair/"" rel=""noreferrer"">std::pair</a>, or perhaps use a map of maps.</p>

<p>C++11 improvements are probably helpful in that case. Or maybe some Boost thing.</p>
",0
10112979,10112693,1,"<p>With C++11, you could use tasks and futures. Let <code>f</code> be your function:</p>

<pre><code>int f(int a, int b)
{
    // Do hard work.
}
</code></pre>

<p>Then you would schedule the function execution, which returns you a handle to the return value. This handle is called a <em>future</em>:</p>

<pre><code>template &lt;typename F&gt;
std::future&lt;typename std::result_of&lt;F()&gt;::type&gt;
schedule(F f)
{
    typedef typename std::result_of&lt;F()&gt;::type result_type;
    std::packaged_task&lt;result_type&gt; task(f);
    auto future = task.get_future();

    tasks_.push_back(std::move(task)); // Queue the task, execute later.
    return std::move(future);
}
</code></pre>

<p>Then, you could use this mechanism as follows:</p>

<pre><code>auto future = schedule(std::bind(&amp;f, 42, 43)); // Via std::bind.
auto future = schedule([&amp;] { f(42, 43); });    // Lambda alternative.

if (future.has_value())
{
    auto x = future.get();  // Blocks if the result of f(a,b) is not yet availble.
    g(x);
}
</code></pre>

<p>Disclaimer: my compiler does not support tasks/futures, so the code may have some rough edges.</p>
",2
10113251,10112693,3,"<p>The poster asks:</p>

<blockquote>
  <p>I want to be able to check if the output of f(a,b) has already been delivered, and if so, deliver that output again without re-running through the f(a,b) process.</p>
</blockquote>

<p>It's pretty easy in C++ using a <code>std::map</code>. The fact that the function has exactly two parameters means that we can use <code>std::pair</code> to describe them.</p>

<pre><code>#include &lt;map&gt;
#include &lt;iostream&gt;

uint64_t real_f(int a, int b) {
  std::cout &lt;&lt; ""*"";
  // Do something tough:
  return (uint64_t)a*b;
}

uint64_t memo_f(int a, int b) {
  typedef std::pair&lt;int, int&gt; key;
  typedef std::map&lt;key, uint64_t&gt; map;
  static map m;
  key k(a,b);
  map::iterator it = m.find(k);
  if(it == m.end()) {
    return m[k] = real_f(a, b);
  }
  return it-&gt;second;
}

int main () {
  std::cout &lt;&lt; memo_f(1, 2) &lt;&lt; ""\n"";
  std::cout &lt;&lt; memo_f(3, 4) &lt;&lt; ""\n"";
  std::cout &lt;&lt; memo_f(1, 2) &lt;&lt; ""\n"";
  std::cout &lt;&lt; memo_f(3, 4) &lt;&lt; ""\n"";
  std::cout &lt;&lt; memo_f(5, 6) &lt;&lt; ""\n"";
}
</code></pre>

<p>The output of the above program is:</p>

<pre><code>*2
*12
2
12
*30
</code></pre>

<p>The lines without asterisks represent cached results.</p>
",1
10113350,10112693,0,"<p>The main point about this question are the relative expenses in CPU and RAM between calculating f(a,b) and keeping some sort of lookup table to cache results.</p>

<p>Since an exhaustive table of 128 bits index length is not (yet) feasable, we need to reduce the lookup space into a manageable size - this can't be done without some considerations inside your app:</p>

<ul>
<li>How big is the <strong>really used</strong> space of function inputs? Is there a pattern in it?</li>
<li>What about the temporal component? Do you expect repeated calculations to be close to one another or ditributed along the timeline?</li>
<li>What about the distribution? Do you assume a tiny part of the index space to consume the majority of function calls?</li>
</ul>

<p>I would simply start with a fixed-size array of <code>(a,b, f(a,b))</code> tuples and a linear search. Depending on your pattern as asked above, you might want to </p>

<ul>
<li>window-slide it (drop oldest on a cache miss): This is good for localized reocurrences</li>
<li>have <code>(a,b,f(a,b),count)</code> tuples with the tuple with the smallest count being expelled - this is good for non-localized occurrences</li>
<li>have some key-function determine a position in the cache (this is good for tiny index space usage)</li>
<li>whatever else Knuth or Google might have thought of</li>
</ul>

<p>You might also want to benchmark repeated calculation against the lookup mechanism, if the latter becomes more and more complex: <code>std::map</code> and freinds don't come for free, even if they are high-quality implementations.</p>
",0
8778139,8778113,2,"<p>Your program works correctly. </p>

<pre><code>6! = 6 * 5 * 4 * 3 * 2 = 720.
</code></pre>

<p>Btw, use recursion for such recursive problems.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{

    //declaration of the variabe
    unsigned int number;

    //prompt the user to enter the upper limit of integers
    cout &lt;&lt; ""Please enter the number of the factorial"";
    cin &gt;&gt; number;

    cout &lt;&lt; factorial(number);

    return 0;
}

unsigned int factorial(unsigned int n)
{
    if (n &lt;= 1)
    {
        return 1;
    }
    else
    {
        return n * factorial(n-1);
    }
}
</code></pre>
",2
8778140,8778113,0,"<p>First of all, it is initialised to 1 because of the following condition:</p>

<pre><code>Factorial(0) = 1
Factorial(1) = 1
</code></pre>

<p>So if  a user inputs a number less than <strong>2</strong>, you do not need some calculations, you just output <strong>1</strong></p>
",0
8778141,8778113,1,"<p>The initial assignment of <code>number</code> is indeed unnecessary. However, you should check the input operation for errors:</p>

<pre><code>int factorial = 1;
int number;

if (!(std::cin &gt;&gt; number))
{
    /* error! */
    return 1; // i.e. abort the program
}

while (number &gt; 1) { /* ... */ }
</code></pre>
",0
8778150,8778113,2,"<p>You are missing a ""&lt;"" in last line of the program. It should be</p>

<pre><code>cout&lt;&lt;""The factorial is ""&lt;&lt;factorial;
</code></pre>

<p>After making this change when I compile and run the program it works for me correctly i.e computes the correct factorial. For example factorial of 5 i.e 5!=5*4*3*2*1=120</p>
",0
8778293,8778113,0,"<p>The first thing I noticed was that there is an error in your code:</p>

<pre><code>cout&lt;&lt;""The factorial is "" &lt; factorial;
</code></pre>

<p>should be:</p>

<pre><code>cout&lt;&lt;""The factorial is "" &lt;&lt; factorial;
</code></pre>

<p>Correcting this should fix a compile error.</p>

<p><b>The essence of this code is:</b></p>

<ol>
<li>Get a number (<code>int number</code>) from user</li>
<li>Print print the <a href=""http://en.wikipedia.org/wiki/Factorial"" rel=""nofollow"">factorial</a> of <code>number</code></li>
</ol>
",0
8767149,8767141,4,"<pre><code>EventList::EventList()
{
    // ...
    EventList *head = new EventList();
    // ...
}
</code></pre>

<p>When an <code>EventList</code> is constructed, it starts constructing another <code>EventList</code>.  Since you do not terminate the recursion, you will eventually run out of stack space.</p>

<p>(Even if you terminated the recursion, you would leak all of these <code>EventList</code> objects that youv'e created, since you don't store the pointers to them outside of the constructor.)</p>
",5
9775650,9775313,1,"<p>You can just manipulate your number bitwise by generating smaller random numbers.</p>

<p>For instance, if you need a 32-bit random number:</p>

<pre><code>int32 x = 0;
for (int i = 0; i &lt; 4; ++i) { // 4 == 32/8
   int8 tmp = 8bit_random_number_generator();
   x &lt;&lt;= 8*i; x |= tmp;
}
</code></pre>

<p>If you don't need good randomness in your numbers, you can just use rand() &amp; 0xff for the 8-bit random number generator. Otherwise, something better will be necessary.</p>
",4
9775831,9775313,0,"<p>Are you using short ints? If so, you will see 32,767 as your max number because anything larger will overflow the short int.</p>
",0
9775361,9775313,0,"<p>Scale your numbers up by <code>N / RAND_MAX</code>, where <code>N</code> is your desired maximum. If the numbers fit, you can do something like this:</p>

<pre><code>unsigned long long int r = rand() * N / RAND_MAX;
</code></pre>

<p>Obviously if the initial part overflows you can't do this, but with <code>N = 250000</code> you should be fine. <code>RAND_MAX</code> is 32K on many popular platforms.</p>

<p>More generally, to get a random number uniformly in the interval <code>[A, B]</code>, use:</p>

<pre><code>A + rand() * (B - A) / RAND_MAX;
</code></pre>

<p>Of course you should probably use the proper C++-style <code>&lt;random&gt;</code> library; search this site for many similar questions explaining how to use it.</p>

<hr>

<p>Edit: In the hope of preventing an escalation of comments, here's yet another copy/paste of the Proper C++ solution for truly uniform distribution on an interval <code>[A, B]</code>:</p>

<pre><code>#include &lt;random&gt;

typedef std::mt19937 rng_type;
typedef unsigned long int int_type;  // anything you like

std::uniform_int_distribution&lt;int_type&gt; udist(A, B);
rng_type rng;

int main()
{
    // seed rng first:
    rng_type::result_type const seedval = get_seed();
    rng.seed(seedval);

    int_type random_number = udist(rng);
    // use random_number
}
</code></pre>

<p>Don't forget to seend the RNG! If you store the seed value, you can replay the same random sequence later on.</p>
",6
9775441,9775313,10,"<p>This is according to the definition of rand(), see:</p>

<p><a href=""http://cplusplus.com/reference/clibrary/cstdlib/rand/"" rel=""noreferrer"">http://cplusplus.com/reference/clibrary/cstdlib/rand/</a></p>

<p><a href=""http://cplusplus.com/reference/clibrary/cstdlib/RAND_MAX/"" rel=""noreferrer"">http://cplusplus.com/reference/clibrary/cstdlib/RAND_MAX/</a></p>

<p>If you need larger random numbers, you can use an external library (for example <a href=""http://www.boost.org/doc/libs/1_49_0/doc/html/boost_random.html"" rel=""noreferrer"">http://www.boost.org/doc/libs/1_49_0/doc/html/boost_random.html</a>) or calculate large random numbers out of multiple small random numbers by yourself.</p>

<p>But pay attention to the distribution you want to get. If you just sum up the small random numbers, the result will not be equally distributed.</p>

<p>If you just scale one small random number by a constant factor, there will be gaps between the possible values.</p>

<p>Taking the product of random numbers also doesn't work.</p>

<p>A possible solution is the following:</p>

<pre><code>1) Take two random numbers a,b
2) Calculate a*(RAND_MAX+1)+b
</code></pre>

<p>So you get equally distributed random values up to (RAND_MAX+1)^2-1</p>
",1
9775539,9775313,3,"<p>Presumably, you also want an equal distribution over this extended
range.  About the only way you can effectively do this is to generate a
sequence of smaller numbers, and scale them as if you were working in a
different base.  For example, for 250000, you might 4 random numbers
in the range [0,10) and one in range [0,25), along the lines: </p>

<pre><code>int
random250000()
{
    return randomInt(10) + 10 * randomInt(10)
        + 100 * randomInt(10) + 1000 * randomInt(10)
        + 10000 * randomInt(25);
}
</code></pre>

<p>For this to work, your random number generator must be good; many
implementations of <code>rand()</code> aren't (or at least weren't&mdash;I've not
verified the situation recently).  You'll also want to eliminate the
bias you get when you map <code>RAND_MAX + 1</code> different values into <code>10</code> or
<code>25</code> different values.  Unless <code>RAND_MAX + 1</code> is an exact multiple of
<code>10</code> and <code>25</code> (e.g. is an exact multiple of <code>50</code>), you'll need something
like:</p>

<pre><code>int
randomInt( int upperLimit )
{
    int const limit = (RAND_MAX + 1) - (RAND_MAX + 1) % upperLimit;
    int result = rand();
    while ( result &gt;= limit ) {
        result = rand();
    return result % upperLimit;
}
</code></pre>

<p>(Attention when doing this: there are some machines where <code>RAND_MAX + 1</code>
will overflow; if portability is an issue, you'll need to take
additional precautions.)</p>

<p>All of this, of course, supposes a good quality generator, which is far
from a given.</p>
",2
10168092,10168057,4,"<p>Because a) streams are not copyable, b) getting input from a stream means mutating it, so you need to modify the original and not a copy (however would that be realised). And reference to <code>PhoneNumber</code> should be obvious ¡ª you're getting input from the stream and into that object. If you'd pass it by copy, it wouldn't be visible outside of the operator, which makes the entire exercise rather pointless.</p>
",0
10168095,10168057,1,"<p>The biggest reason why you use pointers and references is not because it lets you use less memory (although it certainly does), but because it lets you use less time. Copying objects takes time, you often need to allocate additional memory, and then deallocate it in the end. </p>

<p>Even more importantly, objects such as streams are not meant to be copied at all: they contain internal state that is relevant to a physical object, - a file on disk or a network stream, - and their associated buffers, that does not make much sense to copy.</p>
",0
9179087,9179059,4,"<p><code>trap.GetPDU()</code> returns an object and <code>GetVarBindList()</code> is called on that object.</p>

<pre><code>trap.GetPDU().GetVarBindList()
</code></pre>

<p>is equivalent to:</p>

<pre><code>obj.GetVarBindList()
</code></pre>

<p>where <code>obj</code> is an object returned by <code>trap.GetPDU()</code>   </p>

<p>This is also known as <strong><a href=""http://www.parashift.com/c++-faq-lite/references.html#faq-8.4"" rel=""nofollow"">Method Chaining</a></strong>.</p>
",1
9179088,9179059,0,"<p>It's retrieving the object (or reference) that <code>GetPDU</code> returns, and then calling <code>GetVarBindList</code> on it. </p>

<p>Equivalent to something like:</p>

<pre><code>SomeObject &amp;PDU = trap.GetPDU();
SNMP_Sequence trapseq = PDU.GetVarBindList();
</code></pre>
",1
9179113,9179059,0,"<p>It is perfectly legitimate to call a member function upon the result of any expression, including the access to another member, should that expression be of appropriate type.</p>

<pre><code>std::vector&lt;std::vector&lt;std::vector&lt;std::string&gt;&gt;&gt; super_jaggy;
// insert stuff here
std::cout &lt;&lt; super_jaggy.front().front().front().size(); // legal
</code></pre>
",0
15825907,15825764,0,"<p>OK it has been pointed out that <a href=""https://stackoverflow.com/questions/5926103/most-vexing-parsec#"">compiler thinks that you are declaring a function</a>. By <strong>Pubby</strong> and <strong>Nbr44</strong>. This is a way how to get around it. Just let the compiler know that you are declaring variable.</p>

<pre><code>int main() {
    Bar bar = Foo();
    return 0;
}
</code></pre>
",10
15825994,15825764,1,"<p>To achieve the same without changing the semantics (ie. <a href=""https://stackoverflow.com/questions/2462773/c-copy-construct-construct-and-assign-question"">not using the copy or assignment constructor</a>), add parentheses to disambiguate the syntax (the compiler does not know if you declare a function locally or if you build an object, by default the former is prioritized by the C++ standard):</p>

<pre class=""lang-cpp prettyprint-override""><code>int main() {
    Bar bar ( (Foo()) );
    return 0;
}
</code></pre>

<p>As pointed out in the <a href=""http://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""nofollow noreferrer"">Wikipedia page</a> that was posted in the comments, it is an issue with the C++ grammar itself, not much you can do about it.</p>
",3
12786694,12786620,2,"<p>You did not implemented this method. You have to provide implementation for your template in .h file</p>
",0
12786701,12786620,2,"<p>Because you've not put the implementation of readObjectData in the header, you will need to provide an explicit specialization of the function - one that takes std::string&amp;.</p>

<p>This should go in Console.cpp:</p>

<pre><code>template &lt;&gt;
void Console::readObjectData(string&amp; o) {
    //cin &gt;&gt; o;
}
</code></pre>
",0
12786702,12786620,1,"<p>You cannot place your template method implementation in <code>Console.cpp</code> it must appear in the header file, or you must implement an explicit specialization for <code>std::string</code>.</p>
",0
12786713,12786620,3,"<p>You cannot define template&lt;>'d function in .cpp file.</p>

<p>Move</p>

<pre><code>template &lt;typename T&gt;
void Console::readObjectData(T&amp; o) {
     //cin &gt;&gt; o;
}
</code></pre>

<p>To header file.</p>
",0
12786720,12786620,0,"<p>The definition for the templated function (readObjectData) has to be inlined, not in a .cpp file. 
The compiler when it see's a class with a templated function, or a templated class, makes a copy of the entire class with the new type stuck in there. So if you stick the definition of the function in the .cpp file, the compiler will not know where the implementation is because it doesn't exist.</p>
",0
12786831,12786620,0,"<p>In the process of converting some C++ files to the output( executive, shared library or ... ) 2 tools will co-operate, first compiler that create object files and then linker that convert those objects to the output. What you should know is that linker has nothing to do with template( except in special case of explicit instantiation ), and templates will be instantiated by compiler and another note is compiler work with each source files and headers that included in that source file and ignore all other files of your project. So when compiler want to compile <code>main.cpp</code> it see no implementation of <code>readObjectData</code> and thus it can't generate any code in the object files for that function, and when linker want to link objects to result it will never find an implementation for that function! So the easiest way is to move your implementation of <code>readObjectData</code> to the <code>.h</code> file and every thing will work as expected.</p>
",0
10129182,10129091,6,"<p>Of course it can! Why not? It could be anything, really. Just for example - open a namespace in the header and forget to close it, then include this header in your project and you are done. Compiler will go cuckoo and start throwing errors at you pointing to different places that have actually nothing to do with the error. </p>
",3
10129365,10129091,3,"<p>Yes. But how is a much more difficult question.</p>

<p>There are at least two options to help debug this that I can think of.</p>

<ol>
<li><p>Add a -E to the commandline options compiling the file. This will cause the preprocessor to run and spit out the code with all of the headers attached and all macros expanded. You can then try and compile that prepocessed and can see exactly why it's choking.</p></li>
<li><p>Try compiling with clang rather than gcc. Clang is much better at giving intelligible error messages.</p></li>
</ol>

<p>The fact that putting ""any_iterator.hpp"" fixed the problem implies that any_iterator contains the offending code. It's probably indirectly including cmath and causing problems with that somehow. I'd bet if you include cmath above octave/oct.h it would break in the same way.</p>
",0
9214321,9214197,0,"<blockquote>
  <p>When I declare some variables inside a function and then call that
  function inside a loop, are the variables destroyed and reconstructed
  at each step?</p>
</blockquote>

<p>Functions can be inlined by your compiler, variables optimized away and all sort of unpredictable stuff, but you can assume that they are initialized and destroyed at each function call.</p>

<blockquote>
  <p>Is that bad and can/should be avoided?</p>
</blockquote>

<p>Most of the time it is unavoidable, but you must always try to minimize this when dealing with vectors if possible.</p>
",0
9214365,9214197,1,"<p>If you put the <code>static</code> qualifier on the variable in your function then it wouldn't be destroyed every time.  Otherwise, it will be, but that is not necessarily bad.  Refrain from doing optimizations for speed until you actually know there is a problem and know what is causing it.</p>
",1
9214384,9214197,0,"<p>C++ standard provides something called an ""as-if"" rule, which basically says that the compiler can do anything it wants with the code, provided that you cannot tell the difference. If the compiler observes that skipping constructor and destructor calls does not change the behavior of the program, it may skip it, or declare the variable outside of the function, or not declare it at all, if it does not change the behavior of the program. 
It depends on the quality of implementation. Although I am not sure if any compiler applies such optimizations. </p>
",0
9214407,9214197,0,"<p>Non-static local variables are destroyed when your function terminates. You cannot avoid it.
If you want to avoid creating them each time you enter the function, you can either declare them <code>static</code> or just pass them as an argument (by reference or pointer).</p>
",0
9214254,9214197,0,"<p>Depends on what you are doing with it, sometimes it leaves no choice but to do just that. What I mean to say is that, if its kind of reusable, you can have that ""inside-declared"" variable declared outside and pass that too as a reference argument to the function.</p>
",2
9214268,9214197,1,"<p>Yes they are destroyed. It is not bad.</p>
",0
11816687,11816602,1,"<p><strong>your answer is that you should try your self more!</strong><br>
But some goods:<br>
the ACM site: <a href=""http://icpc.baylor.edu"" rel=""nofollow"">http://icpc.baylor.edu</a><br>
<a href=""http://acm.uva.es/contest/"" rel=""nofollow"">http://acm.uva.es/contest/</a><br>
<a href=""http://www.codeforces.com"" rel=""nofollow"">http://www.codeforces.com</a><br>
<a href=""http://code.google.com/codejam/"" rel=""nofollow"">http://code.google.com/codejam/</a><br>
and also<br>
<a href=""http://www0.us.ioccc.org/index.html"" rel=""nofollow"">http://www0.us.ioccc.org/index.html</a><br>
<a href=""http://www.mycplus.com/featured-articles/programming-contests-and-challenges/"" rel=""nofollow"">http://www.mycplus.com/featured-articles/programming-contests-and-challenges/</a>  </p>
",0
14781488,14781468,3,"<p>If you have a pointer to a struct, you should use <code>-&gt;</code> to access it's members:</p>

<pre><code>student-&gt;no = 306;
</code></pre>

<p>This is syntactic sugar for doing <code>(*student).no = 306;</code>. The reason yours didn't work is  because of <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow"">operator precedence</a>. Without the parentheses, the <code>.</code> has higher precedence than <code>*</code>, and your code was equivalent to <code>*(student.no) = 306;</code>.</p>
",0
14781491,14781468,0,"<p><code>operator*</code> has very low precedence, so you have to control the evaluation with parenthesis:</p>

<pre><code>(*student).no = 306;
</code></pre>

<p>Though it can always be done as:</p>

<pre><code>student-&gt;no = 306;
</code></pre>

<p>which in my opinion is much easier.</p>
",0
14781951,14781468,0,"<p>You should use</p>

<pre><code>student-&gt;no = 36
</code></pre>

<p>While we are at it, it is not a good practice to pass structs by value to functions.</p>

<pre><code>// Use typedef it saves you from writing struct everywhere.
typedef struct {
     int no;
// use const char* insted of an array here.
     const char* grade;
 } Student;

 void set(Student* student);
 void display(Student* student);

 int main( ) {
     // Allocate dynmaic. 
     Student *harry = new Student;
      harry-&gt;no = 957;
      harry-&gt;grade = ""ABC"";

     set(harry);
     display(harry);
 }
 void set(Student *student){

     student-&gt;no = 306; 
 }
 void display(Student *student){

     cout &lt;&lt; ""Grades for "" &lt;&lt; student-&gt;no;
     cout &lt;&lt; "" : "" &lt;&lt; student-&gt;grade &lt;&lt; endl;

     delete student;
 }
</code></pre>
",0
13780611,13780538,2,"<p>A non-virtual method of a base class cannot be overridden by subclasses that inherit from it. (Note that this is different from ""redefining"" the method in a subclass)</p>

<p>A virtual method of a base class can be overridden by subclasses. (See @juanchopanza's comment about <code>private</code> visibility)</p>

<p>A pure virtual method in a base class means that it is an ""abstraction"" (think of it as an interface only) - as in it's not supposed to be used directly as is, but rather the base class expects subclasses to override the method to give an actual implementation.</p>
",3
9141568,9141534,2,"<p>You need a semicolon at the end of your class definition (the final <code>}</code> before you declare <code>main</code>).</p>

<p>Without that, it thinks you're trying to define the class as part of the return type of <code>main</code>, because there's no separator between the two, hence the error message:</p>

<p><code>error: new types may not be defined in a return type</code></p>

<p>And, of course, it also complains because you're not returning an <code>int</code> type from <code>main</code> as well (after it tosses away the <code>int</code> because you've already, albeit unwittingly, specified a return type):</p>

<p><code>error: extraneous 'int' ignored</code><br>
<code>error: 'main' must return 'int'</code><br>
<code>error: return type for 'main' change to ""int""</code></p>
",0
13738012,13737899,2,"<pre><code>#include &lt;sstream&gt;
#include &lt;string&gt;

using namespace std;

int main(){

  string myString = ""45"";
  istringstream buffer(myString);
  uint64_t value;
  buffer &gt;&gt; std::hex &gt;&gt; value;

  return 0;
}
</code></pre>
",0
13738023,13737899,4,"<p>If you're writing C++, why would you even consider using <code>sscanf</code> and <code>printf</code>? Avoid the pain and just use a <code>stringstream</code>:</p>

<pre><code>int main() { 

    std::istringstream buffer(""000005F5E101"");

    unsigned long long value;

    buffer &gt;&gt; std::hex &gt;&gt; value;

    std::cout &lt;&lt; std::hex &lt;&lt; value;
    return 0;
}
</code></pre>
",0
9777868,9776378,2,"<p>I'd recommend switching to <a href=""http://eigen.tuxfamily.org/index.php?title=Main_Page"" rel=""nofollow"">Eigen</a> or <a href=""http://glm.g-truc.net/"" rel=""nofollow"">GLM</a> for matrix-wrangling.  Eigen has SIMD routines to speed up batch operations.</p>

<p>They're both header-only.</p>
",0
10770571,10770543,2,"<pre><code>void push(node new)
</code></pre>

<p>you have to <strong>not</strong> make a copy of the object, like so:</p>

<pre><code>void push(node&amp; new)
</code></pre>

<p>otherwise you are taking the adress of an object that is deleted at the end of the function</p>
",0
10770700,10770543,0,"<p>At least in my opinion, you have a few things that are wrong to some degree or other.</p>

<p>First, <code>head</code> shouldn't really be a <code>node</code> -- it should be a <code>node *</code>. At least from the looks of things, all you're ever using it for is its <code>next</code> pointer, so you might as well just make it a pointer and be done with it.</p>

<p>Second, to insert new items at the beginning of the list, you don't really need to check for whether the head of the list is a null pointer or not.</p>

<p>Third, although @lezebulon's suggestion to use a reference to a node <em>will</em> work, I don't think it's really the <em>best</em> way to go in this case. Rather than having the user pass a pointer or reference to a <em>node</em>, they should really just pass in a data item, and your linked-list class should allocate a node to hold that item in the list.</p>

<pre><code>template &lt;class T&gt;
class linked_list { 

    class node { 
        T item;
        node *next;
    public:
        node(T const &amp;data, node *next_node) : item(data), next(next_node) {}
    };

    node *head;
public:

    linked_list() : head(NULL) {}

    void push(T const &amp;data) {
        head = new node(data, head);
    }
};
</code></pre>
",0
15551980,15551756,0,"<p>try </p>

<pre><code>#include &lt;conio.h&gt;
#include &lt;iostream&gt;
using namespace std;

int main()
{
     bool keepGoing = true;
     char key = ' ';
     while (keepGoing){
       cout &lt;&lt; ""Enter a key"" &lt;&lt; endl;
       while(_kbhit()){
         key = _getch();
         cout &lt;&lt; ""You entered: "" &lt;&lt; key &lt;&lt; endl;
       }
     }
}
</code></pre>

<p>then specify delimiter when to end loop.</p>

<p>if on linux curses are available. there is also a getch function. you should use curses if you aim for cross platform compatibility. ncurses library functions are similar to ones in conio.h.
<a href=""http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/"" rel=""nofollow"">ncurses tutorial</a></p>
",1
15552108,15551756,0,"<p>The Windows system call <a href=""http://msdn.microsoft.com/en-us/library/ms684961%28VS.85%29.aspx"" rel=""nofollow""><code>ReadConsoleInput</code></a> allows you to read console input directly. You may want to wrap that call into a function that just extracts the essential data from the several parameters of the <code>ReadConsoleInput</code> function. You can write a function to check if there is any input using <a href=""http://msdn.microsoft.com/en-us/library/ms683207%28v=vs.85%29.aspx"" rel=""nofollow""><code>GetNumberOfConsoleInputEvents</code></a>.</p>
",0
15552123,15551756,1,"<p>EDIT
Reading through your question again, I realize that I misinterpreted your question. I'll leave this since it might still be useful to you or others.</p>

<hr>

<p>What you're asking for doesn't have to do much with reading characters. In fact, CTRL is not a character at all. You're basically just checking for key pushes. Handling this kind of input is platform dependent, and even on a single platform, multiple methods will exist. One way to do it for windows is by using <code>GetAsyncKeyState</code>. This function will check whether a specified key is being pushed right now. Note that it doesn't 'remember' input, so you'll have to check this function many times per second to register all user input.</p>

<p>You supply the function with a single argument specifying the key of which you want to check the state. A list of all key codes can be found <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731%28v=vs.85%29.aspx"" rel=""nofollow"">here</a></p>

<p>Example:</p>

<pre><code>#include &lt;iostream&gt; //for output
#include &lt;windows.h&gt; //for GetAsyncKeyState

int main()
{
    while(true)
    {
        if( GetAsyncKeyState(VK_CONTROL) ) //CTRL-key is pressed
        {
            if( GetAsyncKeyState( 0x46 ) ) //F-key is pressed
                std::cout &lt;&lt; ""CTRL-F is pressed"" &lt;&lt; std::endl;
            if( GetAsyncKeyState( 0x58 ) ) //X-key is pressed
                break;
        }
    }
    std::cout &lt;&lt; ""CTRL-X was pressed, stopping.."" &lt;&lt; std::endl;
}
</code></pre>

<p>This example will continuously check if <code>CTRL-F</code> is being pushed and if so write output, until <code>CTRL-X</code> is pressed.</p>
",0
9859514,9859479,1,"<p><code>std::cin</code> reads till the first space but keeps the rest in buffer, which will be used on the following <code>std::cin</code>s.</p>

<p>If you want to read till the first <code>'\n'</code>(hitting enter) you have to replace <code>std::cin</code> with</p>

<pre><code>std::getline(std::cin, name);
</code></pre>
",3
10167944,10167860,0,"<p>The expression</p>

<pre><code>if (answer = '(')
</code></pre>

<p>assigns <code>'('</code> to answer and checks if it is non-zero (which it is) -- so the first branch is always executed.</p>

<p>You need: </p>

<pre><code>if (answer == '(')
</code></pre>

<p>instead (similarly for the other).</p>

<p>you also need a closing <code>}</code> before the <code>while</code></p>
",0
10167883,10167860,0,"<p>NO.
You are reading whole expression where as you are trying to compare it with one character. </p>

<pre><code>if (answer = '(')
</code></pre>

<p>Also the loop is doing nothing </p>

<pre><code> while (answer != ';');
</code></pre>
",2
16440421,16440363,0,"<p>Yes, you can change the value of your matrix using the address(what you called location), but you have to calculate the right offset from the start. The offset calculation should be something like this : </p>

<pre><code>(matrix_x_len * Y + X) * sizeof(unsigned int) + offset to the beggining of the matrix
</code></pre>

<p>then when you have the offset you can change mat like this : <code>*(val + offset) = new_value</code>.</p>
",2
16440437,16440363,2,"<p>Yes, it is possible, unless either of the array members or the pointer target is <code>const</code>.</p>

<p>For example:</p>

<pre><code>int array[3][2] = { { 0, 1 }, { 2, 3 }, { 4, 5 } };
int *p = &amp;array[1][1];
*p = 42;

// array is now: { { 0, 1 }, { 2, 42 }, { 4, 5 } };
</code></pre>
",4
16440475,16440363,0,"<p>You can of course modify the bits since <code>unsigned char mat[24][8]</code> gives you a memory chunk with 24*8*sizeof(char) bytes.
(I assume that unsigned char is 1 byte (=8 bits) in size and unsigned int is 4 Bytes (=32 bits) from here but this may be dependant on your system.</p>

<p>But accessing memory elements of 1 byte width using a pointer to elements with 4 bytes width is tricky and can easily produce errors.</p>

<p>If you set element 0 of the int array to 1 for example</p>

<pre><code>#define ROWS 24
#define COLS 8

unsigned char mat[ROWS][COLS];
unsigned int * val = (unsigned int*)&amp;mat;

val[0] = 1;
</code></pre>

<p>You will see that mat[0][0] is 0, mat[0][1] is 0, mat[0][2] is 0 and mat[0][3] is 1.</p>

<p>Please not that you cannot edit the elements of mat directly using their offset in memory via such a ""miss-typed"" pointer.
Accessing <code>val[10*8+4]</code> for example will access byte 336 from the beginning of your memory chunk which has only 192 bytes.</p>

<p>You will have to calculate your index correctly:</p>

<pre><code>size_t byte_index = (10*COLS+4)*sizeof(unsigned char); // will be 84
size_t int_index = byte_index / sizeof(unsigned int); // will be 21
size_t sub_byte = byte_index%sizeof(unsigned int); // will be 0
</code></pre>

<p>Therefore you can access <code>val[int_index]</code> or <code>val[21]</code> to access the 4 bytes that contain the data of element mat[10][4] which is byte number <code>sub_byte</code> of the refered unsigned int value.</p>

<p>If you have the same types there is no problem except that you need to calculate the correct offset.</p>

<pre><code>#define ROWS 24
#define COLS 8

unsigned char mat[ROWS][COLS];
unsigned char * val = &amp;mat;

val[10*8+4] = 12; // set mat[10][4] to 12
*(val+10*8+5) = 13; // set mat[10][5] to 13
</code></pre>
",0
16440478,16440363,0,"<p>can do it but making val as <em>unsigned char</em>*</p>

<p>val = &mat;</p>

<p>will make easy to do modification of bits</p>
",0
10770523,10770515,4,"<p>In order to have an array of something, said something has to be <em>default-constructible</em>. Your <code>MyClass</code> isn't since it needs an <code>int</code> to be constructed.</p>

<p>What C# does is comparable to:</p>

<pre><code>MyClass** array = new MyClass*[size];
</code></pre>

<p>Where pointers are default constructible, so its allowed. Basically, whenever you do <code>SomeObject</code> in C# its the equivalent of <code>SomeObject*</code> in C++. Except that the code would be horribly inefficient, even worse than its C# counterpart, and there would be leaks everywhere.</p>
",15
10770629,10770515,3,"<p>You have a more fundamental problem with your approach here than how to construct an array.</p>

<p>Think about it this way:</p>

<pre><code>class A
{
   A* a;
public:
   A();
};
A::A()
{
   a = new A();
}
</code></pre>

<p>What happens? You try and create an <code>A</code>; within the constructor, a <code>new A</code> is created.  Within <em>that</em> constructor, another <code>new A</code> is created...</p>

<p>Boom, out of memory.</p>
",0
13775192,13774556,3,"<p>As an example, assume you have the following class definitions:</p>

<pre><code>class Container {
  public:
    // construct a container instance by making it point to an item
    Container(Item *pItem) : m_pItem(pItem) { }
  private:
    Item *m_pItem;
};

class Item {
  public:
    change() {
      // do something to change the item
    }
  private:
    // some private data
};
</code></pre>

<hr>

<blockquote>
  <p>At-most-once: A pointer to any specific object can exist in at most one container object at any point in time.</p>
</blockquote>

<p>Having two instances of <code>Container</code> with a pointer to the same instance of <code>Item</code> would violate this:</p>

<pre><code>Item *pItem = new Item();  // construct a new Item
Container c1(pItem);       // create a new container pointing to this item
Container c2(pItem);       // WRONG: create another container pointing to the same item
</code></pre>

<hr>

<blockquote>
  <p>Existence: An object must be dynamically allocated before a pointer to it is inserted.</p>
</blockquote>

<p>Dynamically allocating an object generally means creating a new instance of an object with the operator <code>new</code>, which returns a pointer to the newly created object allocated on heap memory (as opposed to stack). Two examples of a violation of this are:</p>

<pre><code>Item *pItem = NULL;
Container c1(pItem);  // WRONG: pItem is not dynamically allocated; it is NULL

Item item;
Container c2(&amp;item);  // WRONG: &amp;item does not point to a dynamically allocated heap
                      // object; the object is on stack;
</code></pre>

<hr>

<blockquote>
  <p>Ownership: Once a pointer to an object is inserted, that objects becomes property of the container. No one else may use or modify it in any way.</p>
</blockquote>

<p>When an object exists in memory, any object or function that has a pointer or reference to the object could potentially modify it (unless the pointer or reference is declared <code>const</code>):</p>

<pre><code>Item *pItem = new Item();  // the function containing this code obviously has a pointer
                           // to the newly created item
Container c(pItem);        // let the container c own this item

pItem-&gt;change();         // WRONG: attempt to modify an object owned by c
</code></pre>

<hr>

<blockquote>
  <p>Conservation: When a pointer is removed from a container, either the pointer must be inserted into some container, or its referent must be deleted.</p>
</blockquote>

<p>This means that when the container no longer wants to ""own"" (defined in exactly the same sense as above) the item instance it points to, it must either transfer ""ownership"" to another container, or delete the item. The following modification to the <code>Container</code> class implements this behavior:</p>

<pre><code>class Container {
  public:
    removeItem() {
      delete m_pItem;  // deallocate the item instance owned by this container
                       // the item is no longer owned because it no longer exists
    }
    giveItemTo(const Container&amp; other) {
      other.m_pItem = m_pItem;  // let the other container own this item instead
      m_pItem = NULL;           // the item is no longer owned by this container because the pointer is NULL
    }
};
</code></pre>
",0
11095689,11095653,7,"<pre><code>cout &lt;&lt; hex &lt;&lt; test &lt;&lt; endl; 
</code></pre>

<p>It prints the string, not the address. It is because there is an overload of <code>operator&lt;&lt;</code> which takes <code>char const*</code> as argument and this overload treats the argument as string.</p>

<p>If you want to print the address, cast the argument to <code>void*</code> so that <em>other</em> overload of <code>operator&lt;&lt;</code> will be invoked which will print the address.</p>

<pre><code>cout &lt;&lt; hex &lt;&lt; static_cast&lt;void*&gt;(test) &lt;&lt; endl;
</code></pre>

<p>will print the address, in hexadecimal format.</p>

<p>Note that <code>hex</code> stream-manipulator is not needed here, as the address will be printed in hexadecimal format anway. So </p>

<pre><code>cout &lt;&lt; static_cast&lt;void*&gt;(test) &lt;&lt; endl;
</code></pre>

<p>is enough.</p>
",7
11095945,11095653,2,"<p><code>test</code> itself is a pointer, i.e. it stores an address. Your <code>printf</code> statement prints the hexadecimal value of that address.</p>

<p>The <code>cout &lt;&lt;</code> statement then prints the entire string, because the <code>std::hex</code> manipulator does not affect the way strings are printed. It only affects the way integers are printed.</p>

<p>What you can do is</p>

<ol>
<li>Loop through the characters of the array</li>
<li>Convert each to an integer and print using the <code>std::hex</code> manipulator</li>
</ol>

<p>That would look like this:</p>

<pre><code>for (int i = 0 ; i &lt; 10 ; ++i)
  std::cout &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(array[i]) &lt;&lt; '\n';
</code></pre>
",0
11095962,11095653,0,"<p><code>cout &lt;&lt; HEX &lt;&lt;</code><br>
can't be used to a char* to print a hex char string,
but you can use it for int ,double,float,etc.</p>

<p>And, as you second print, why the string has some garbled strings is that you haven't gived
a '\n' to the string which means the end of string</p>
",0
11096578,11095653,6,"<p>Because your program has undefined behavior.  And because you ask it to
print different things.</p>

<p>Your invocation of <code>printf</code> is illegal, and results in undefined
behavior (and is a good example of why you should never use <code>printf</code>).
Your format specifier says to extract an <code>unsigned int</code> from the 
argument list, and output that in hexadecimal.  Passing it anything but
an <code>unsigned int</code> is undefined behavior.  As it happens, given the way
varargs are generally implemented, if you're on a machine where
<code>unsigned</code>s and pointers have the same size, you'll probably output the
value of the pointer, treating its bits as if it were an <code>unsigned</code>.
Other behaviors are certainly possible, however.  (If I'm not mistaken,
g++ will warn about this construct; it's also possible that on some
platforms, it will crash.)</p>

<p>In the case of <code>std::cout</code>, you're passig it a <code>char*</code>.  By definition,
the <code>char*</code> is treated as a '\0' string, <em>not</em> as a pointer (and
certainly not as an <code>unsigned int</code>).  And again, you have undefined
behavior, since your <code>char*</code> doesn't point to a '\0' terminated string;
you never put a '\0' at the end.  (This probably explains the <code>""N???""</code>
you see at the end of your output.  But again, undefined behavior is,
well, undefined.  The code could just as easily have crashed.)</p>

<p>Finally, you're using both <code>printf</code> and <code>std::cout</code>; the results are not
really specified unless you do a flush of the stream between the two.
(In practice, if you're outputting to an interactive device, the flush
should occur when you output the <code>'\n'</code> character.  If you redirect the
output to a file, however, you're likely to get something different.)</p>

<p>It's not clear what you want.  If you want to output the address of
<code>array</code>, it would be:</p>

<pre><code>printf( ""%p\n"", test );
std::cout &lt;&lt; static_cast&lt;void*&gt;( test ) &lt;&lt; std::endl;
</code></pre>

<p>If you want to output the string you've generated, then append a '\0' to
the end of it (without overflowing the buffer), and then:</p>

<pre><code>printf( ""%s\n"", test );
std::cout &lt;&lt; test &lt;&lt; std::endl;
</code></pre>

<p>I'm not sure what you're trying to make ""hex""; there is no such thing as
a hex representation of a string, and the representation of a pointer is
implementation defined, and not required to take into account any
formatting parameters in iostream.  (Typically, on most modern machines,
it will be hex.  But I've worked on more than a few where it would be
octal, and at least one where it wouldn't be just a number, regardless
of the base.)  If you want a hex dump of <code>array</code>, you'll have to loop,
outputting each value as an <code>unsigned</code> in hex:</p>

<pre><code>for ( int i = 0; i &lt; 10; ++ i ) {
    printf( ""%x"", static_cast&lt;unsigned char&gt;( test[i] ) );
}
printf( ""\n"" );
std::cout.setf( std::ios_base::hex, std::ios::basefield );
for ( int i = 0; i &lt; 10; ++ i ) {
    std::cout &lt;&lt; static_cast&lt;unsigned&gt;( static_cast&lt;unsigned char&gt;( test[i] ) );
}
std::cout.setf( std::ios_base::dec, std::ios::basefield );
std::cout &lt;&lt; std::endl;
</code></pre>

<p>Finally: a word about the casts: plain <code>char</code> may be either signed or
unsigned; if it is signed, converting it to an <code>int</code> or an
<code>unsigned</code>, might produce either a negative value (<code>int</code>) or a very
large positive value (<code>unsigned</code>).  Thus, the first conversion to
<code>unsigned char</code>, which guarantees a result in the range <code>[0, UINT_MAX]</code>.
Second, of course, we have to convert the <code>unsigned char</code> to <code>unsigned</code>:</p>

<ul>
<li><p>in the case of <code>printf</code>, because we would otherwise have undefined
behavior, but the conversion is implicit, since passing an <code>unsigned
char</code> as a vararg automatically promotes it to <code>unsigned</code>; and</p></li>
<li><p>in the case <code>std::cout</code>, because the rules are that any character
type be output as a character, not as a numerical value (and since the
type is used here in function overload resolution, and is not being
passed to a vararg or an <code>unsigned</code>, there is no implicit conversion).</p></li>
</ul>
",1
13487919,13487866,1,"<p>Try <a href=""http://www.cplusplus.com/reference/iostream/manipulators/setprecision/"" rel=""nofollow""><code>setprecision</code></a>.</p>

<p>For rounding a number, see <a href=""http://en.cppreference.com/w/cpp/numeric/math/round"" rel=""nofollow""><code>round</code></a>.</p>

<p>Also, if you decide to round to 0.1 precision, I believe you can just append the zero <code>0</code> after the rounded result.</p>

<hr>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

void p(double x) {
  cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; x &lt;&lt; 0 &lt;&lt; endl;
}

int main() {
  p(27.9933);
  p(18.992);
  p(9.754);
  p(11.2543);
  p(6.66);
  p(4.33);
  return 0;
}
</code></pre>

<p>The code above outputs:</p>

<pre><code>28.00
19.00
9.80
11.30
6.70
4.30
</code></pre>

<p>Hope this is what you want.</p>
",0
9773663,9773633,8,"<p>In C++, upon overload resolution, a set of viable overloads is selected, and the one candidate that requires the least
conversions (does it require changing the constness? is a promotion of integer to floating point needed?)
is chosen. If there are multiple matches that have the same weight, you have an ambiguous call and get an error
(e.g.: <code>int foo(int &amp;x, int y); int foo(int x, int &amp;y); ... int a,b; foo(a,b);</code> is ambiguous).</p>

<p>However, in your case, no valid conversion sequence can be found, because there exists no valid conversion from 
<code>int&amp;</code> to <code>unsigned int&amp;</code> (sidenote: there exists a conversion from <code>int</code> to <code>unsigned int</code> and vice versa), because
references to unrelated types are not compatible at all.</p>

<p>About the error message: The compiler uses the weakest allowed binding to filter out the set of viable functions. For <code>int</code>, this is <code>int&amp;</code>. 
But because no viable set of functions is found, an error message is spit out. The author of the message did not base
it on your code, but rather on the data he/she has had for the search, which is <code>int&amp;</code>. However, he/she
correctly proposes a viable alternative that really exists.</p>

<p>So we have more a compiler diagnostic <em>quality</em> issue here, rather than a C++ <em>correctness</em> issue.</p>

<hr>

<p>From the standard, here's the table of conversion. The least are required to make a function call
valid, the better the match:</p>

<pre><code>Conversion                         
-----------------------------------+----------------------------
No conversions required            | Identity
-----------------------------------+----------------------------
Lvalue-to-rvalue conversion        | Lvalue transformation
Array-to-pointer conversion        |
Function-to-pointer conversion     |
-----------------------------------+----------------------------
Qualification conversions          | Qualification adjustment
-----------------------------------+----------------------------
Integral promotions                | Promotion
Floating point promotion           |
-----------------------------------+----------------------------
Integral conversions               | Conversion
Floating point conversions         |
Floating-integral conversions      |
Pointer conversions                |
Pointer to member conversions      |
Boolean conversions                |
-----------------------------------+----------------------------
</code></pre>
",2
9773671,9773633,2,"<p>The signature of the function have the following arguments</p>

<pre><code>UInt_t&amp;, UInt_t&amp;, Bool_t
</code></pre>

<p>and you are passing</p>

<pre><code>int&amp;, int&amp;, Bool_t&amp;
</code></pre>

<p>Either convert your <code>int</code> to <code>UInt_t</code> before you call the method or directly declare them as <code>UInt_t</code>.</p>
",0
9773677,9773633,3,"<p>The problem isn't that the bool is passed by reference but that you line</p>

<pre><code>int xwidth=0,ywidth=0;
</code></pre>

<p>Should be of type <code>UInt_t</code></p>

<pre><code>UInt_t xwidth=0u,ywidth=0u;
</code></pre>

<p>The compiler doesn't know how you want to pass the variable to function with the unkown overload so it just assumes you meant by ref.</p>
",3
9774343,9773633,1,"<p>It is not.</p>

<p>Compiler messages are more or less useful. As it is, since it did not find a method that it can call with the arguments you supplied, the compiler is trying to synthetize, from the arguments you gave, a method signature that could have worked.</p>

<p>This is, unfortunately, ultimately doomed to fail, as there are just so many possible variations, but then gcc's messages have never been too great.</p>

<p>Clang took another approach, which I happen to prefer. Instead of trying to imagine what the function you wanted to call looks like and then listing the candidates and leaving you to spot the differences, it tells you why each candidate was discarded.</p>

<pre><code>void func(unsigned&amp;, unsigned&amp;);

int something() {
  int a = 0, b = 0;
  func(a, b);
  return a + b;
}
</code></pre>

<p>Yields the following error message:</p>

<pre><code>/tmp/webcompile/_3246_0.cc:5:3: error: no matching function for call to 'func'
  func(a, b);
  ^~~~
/tmp/webcompile/_3246_0.cc:1:6: note: candidate function not viable:
    no known conversion from 'int' to 'unsigned int &amp;' for 1st argument; 
void func(unsigned&amp;, unsigned&amp;);
</code></pre>

<p>Which I find much more useful. Patching this by turning <code>a</code> into an <code>unsigned</code> and leaving <code>b</code> as is we get:</p>

<pre><code>/tmp/webcompile/_3710_0.cc:1:6: note: candidate function not viable:
    no known conversion from 'int' to 'unsigned int &amp;' for 2nd argument; 
void func(unsigned&amp;, unsigned&amp;);
</code></pre>

<p>And this way we advance one argument at a time until we ""fixed"" the call to our liking.</p>
",4
14745658,14745550,1,"<pre><code>for(i = 0; i &lt; n - 1; i += 2) {
</code></pre>

<p>You don't check the last character of the string, so the final <code>a</code> gets through.</p>

<p>Remember <code>strlen</code> does not include the null char, you dont need to adjust for it.</p>

<p>Also use <code>check(str[i] - '0')</code> since you want to check on the number and not its ascii code.</p>

<p>Final big issue - </p>

<pre><code>if(str[i] == '+' || str[i] == 
</code></pre>

<p>If check fails, <strong>you need to check if that char is an operator</strong>, <strong>not the next one</strong>, as above. <a href=""http://liveworkspace.org/code/1uXtKy%2419"" rel=""nofollow"">Output</a></p>

<p>Also set flag as 1 by default. I have <a href=""http://liveworkspace.org/code/1uXtKy%2419"" rel=""nofollow"">rewriten your code a little</a>.</p>

<p><a href=""http://liveworkspace.org/code/1uXtKy%2425"" rel=""nofollow"">Further rewritten code which catches repeated digits or operators</a></p>
",8
14745664,14745550,1,"<p>Here's a few hints:</p>

<ol>
<li>Your loop only checks an even amount of characters in your input. Your loop adds 2 to <code>n</code> each time, so it will check <code>3+</code> and <code>5/</code> but <code>a</code> will never get looked at.</li>
<li><p>If your input is always alternating between a single digit number and an operator, you can use something like the following:</p>

<pre><code>for (int i = 0; i &lt; n; i++) // read *every* character
{
    if (i % 2 == 0)
    {
        // you are looking at a character with an even index
    }
    else
    {
        // you are looking at a character with an odd index
    }
}
</code></pre>

<p>The <code>%</code> operator divides the left operand by the right and gives you the remainder of that division.</p></li>
<li><p>Your <code>check</code> function is checking whether the <code>char</code> value is less than 9, not whether the <code>char</code> value represents a digit character. You can include the <code>&lt;cctype&gt;</code> header and use <code>isdigit</code> instead of your <code>check</code> function, which checks to see if the input represents a digit character or not.</p></li>
</ol>
",0
14745596,14745550,0,"<p>The numbers are char type so check their ASCII value to see if they are numbers.</p>
",0
14745772,14745550,2,"<pre><code>int check(int stvalue) {
    if(stvalue &lt; 9) return(1);
    else return(0);
}
</code></pre>

<p>This is wrong because the number equivalents on the ASCII chart are 48 to 57, going from 0 to 9.</p>

<p>You can probably simplify your validation by passing it through a function similar to this one:</p>

<pre><code>#include &lt;cctype&gt;
bool validateString(const std::string&amp; str) {
   auto compare = [](char c) {
        return ((c == '+') || (c == '-') || (c == '*') || (c == '/'));
    };
    size_t length = str.length();
    for(size_t i = 0; i &lt; length; ++i) {
        if(!(std::isdigit(str[i]) || compare(str[i])))
            return false;
        if(compare(str[i]) &amp;&amp; (i &lt;= length-1) &amp;&amp; compare(str[i+1]))
            return false;
        if(compare(str[length-1]))
            return false;
    }
    return true;
}
</code></pre>
",3
14745932,14745550,0,"<p>ASCII value if 0 is 48 and 9 is 57.. not 9. So,
if(stvalue &lt; 9) return(1);</p>

<p>should be,
if(stvalue &lt;= 57) return(1);</p>

<p>By the way, this approach may work but other answers are more mature way of solving this problem. </p>
",0
9825211,9825114,2,"<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms738521%28v=vs.85%29.aspx"" rel=""nofollow""><code>gethostbyaddr</code></a> returns a null pointer whenever some error occurs. The error could be a bad IP address, an unknown host, a misconfigured DNS setup, etc. You need to check the actual error code. On Winsock, that will mean calling <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms741580%28v=vs.85%29.aspx"" rel=""nofollow""><code>WSAGetLastError</code></a>, while on POSIX (I think) you need to check the value of <a href=""http://linux.about.com/library/cmd/blcmdl3_gethostbyaddr.htm?rd=1"" rel=""nofollow""><code>h_errno</code></a>. (I could be wrong on POSIX, I don't have experience there)</p>
",4
9825250,9825114,5,"<p>You cannot pass a <em>c-style-string</em>  (ie. null-terminated) directly to <code>gethostbyaddr</code>.</p>

<p>You'll need to create a <code>struct in_addr</code> and pass a pointer to the created struct as first parameter to <code>gethostbyaddr</code>. To generate a <code>struct in_addr</code> from a <code>char const*</code> use <a href=""http://www.cl.cam.ac.uk/cgi-bin/manpage?3+inet_aton"" rel=""nofollow""><code>inet_aton</code></a>.</p>

<p>The below example is taken from <em>man gethostbyaddr</em>:</p>

<hr>

<p><strong>EXAMPLES</strong></p>

<ul>
<li><p>Print out the hostname associated with a specific IP address:</p>

<pre><code>const char *ipstr = ""127.0.0.1"";
struct in_addr ip;
struct hostent *hp;

if (!inet_aton(ipstr, &amp;ip))
        errx(1, ""can't parse IP address %s"", ipstr);

if ((hp = gethostbyaddr((const void *)&amp;ip, sizeof ip, AF_INET)) == NULL)
        errx(1, ""no name associated with %s"", ipstr);

 printf(""name associated with %s is %s\n"", ipstr, hp-&gt;h_name);
</code></pre></li>
</ul>

<hr>

<p><strong>How do I do further checks to pin-point what went wrong?</strong></p>

<p>If your use of <code>gethostbyaddr</code> returns <code>NULL</code> you should check what went wrong by looking at the variable <code>h_errno</code>.</p>

<p><code>h_errno</code> can have one of the below defined values:</p>

<ol>
<li><code>HOST_NOT_FOUND</code></li>
<li><code>TRY_AGAIN</code></li>
<li><code>NO_RECOVERY</code></li>
<li><code>NO_DATA</code></li>
</ol>

<p>Please consult your manual for more details regarding the issue.</p>

<hr>

<p><strike>
<sup><strong>Your snippet is completely wrong..</strong></sup></p>

<p><sup>The snippet provided by you doesn't even compile, but you are in a way showing what you are trying to accomplish but I cannot know this for certain.</sup>
<sup>This post contains details that should be considered to be ""<em>educated guesses</em>"".</sup></strike></p>

<p><sup>OP changed his post..</sup></p>
",0
11866368,11866267,2,"<p>I would not change my code just to fit in with the foibles of a documentation tool. So, no, I wouldn't consider it good practise.</p>
",0
11867274,11866267,0,"<p>Basic on the answers, it is definitely not a good practice to declare all global functions as friend functions. Doxygen also provides a keyword to connect the functions that has close relations with the class:  <a href=""http://www.doxygen.nl/manual/commands.html#cmdrelates"" rel=""nofollow noreferrer"">/relates</a></p>
",0
11866511,11866267,1,"<p>Using friend function mechanism is never a good practice, so try to avoid it. Nothing from outside of the definition of a class should've an access to its private data. C++ encourage you to use encapsulation/modular mechanism and friend definition only weakens this mechanism. </p>
",3
11866583,11866267,6,"<p>Doxygen allows you to create and refer to <a href=""http://www.doxygen.nl/manual/grouping.html"" rel=""nofollow noreferrer"">groups of functions and other global things</a>. That would make a lot more sense than breaking useful language-level protection just to exploit a quirk of Doxygen's behaviour.</p>
",0
10144861,10144832,5,"<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;

std::string make_filename(std::string prefix, int id) {
  std::stringstream ss;
  ss &lt;&lt; prefix &lt;&lt; ""_"" &lt;&lt; id &lt;&lt; "".dat"";
  return ss.str();
}
</code></pre>

<p>and then I convert the string to char.</p>
",0
10144932,10144832,0,"<p>if you are working with c you may try the function described in here <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/itoa/"" rel=""nofollow"">itoa</a></p>

<p>else if you are working woth c++ you may try something like this:</p>

<pre><code>#include &lt;sstream&gt;

int i = 5;
std::string s;
std::stringstream out;
out &lt;&lt; i;
s = out.str();
</code></pre>
",0
10759993,9075618,1,"<p>Use boost:</p>

<ul>
<li><a href=""http://www.boost.org/doc/libs/1_49_0/libs/smart_ptr/scoped_ptr.htm"" rel=""nofollow"" title=""scoped_ptr"">scoped_ptr</a> for handles, etc</li>
<li><a href=""http://www.boost.org/doc/libs/1_37_0/doc/html/boost/interprocess/scoped_lock.html"" rel=""nofollow"">scoped_lock</a> to control mutex.</li>
</ul>
",0
10135522,10135423,2,"<p>In Visual Studio if you right-click on the project then go to Properties->Linker->System->SubSystem, you can set it to Console so it will not exit immediately and prevents you from having to use System(""pause"").  System(""pause"") is a Windows thing and prevents portability.</p>
",5
10135458,10135423,4,"<p>You need to enter a word and then press enter. You say ""And it quits the program, nothing happens"", but something does happen. It just happens so fast you probably do see it happening and the program closes. If you are in debug mode and want to have a ""press key to exit message"" then do</p>

<pre><code> system(""PAUSE"");
</code></pre>

<p>after</p>

<pre><code>theGame.displayWord();
</code></pre>

<p>And you will see your <code>cout</code> display.</p>

<p>Also, there are some optimization and errors with your code.</p>

<ol>
<li>You are missing a return value from <code>main</code>.</li>
<li>For <code>setWord</code> you should pass by const reference, so the function would be.</li>
</ol>

<p><code>void setWord( const string&amp; word )</code></p>

<ol>
<li>For <code>getWord</code> you should return by const reference, so the function would be</li>
</ol>

<p><code>string getWord()</code></p>

<p>For more information on passing by const reference, please take a look at <a href=""http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/"" rel=""nofollow"">Passing arguments by reference</a>.</p>
",1
10135728,10135423,0,"<p>Other answers have already suggested changing your IDE properties to prevent the console exiting immediately, or using system(""PAUSE""); you can also simply load your own console, and run the executable manually from there (which is neither IDE nor platform dependent).</p>

<p>Ultimately however, your don't know what environment your user will be working from or how they will be loading the program, so a more suitable solution would be to implement something yourself which prevents the program from exiting until you are sure the user is done reading the output. For example:</p>

<pre><code>WordGame theGame;
bool exit = false
while (!exit)
{
    cout &lt;&lt; ""Enter a word. Entering \""exit\"" will terminate the program."" &lt;&lt; endl; 
    string aWord; 
    cin &gt;&gt; aWord;
    if (aWord == ""exit"") exit = true;
    else
    {
        theGame.setWord(aWord); 
        theGame.displayWord(); 
    }
}
</code></pre>
",5
15558117,15558087,5,"<p>Use an <a href=""http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic"" rel=""nofollow noreferrer"">arbitrary-precision arithmetic</a> library like <a href=""http://gmplib.org/"" rel=""nofollow noreferrer"">GMP</a> or <a href=""http://www.boost.org/doc/libs/release/libs/multiprecision/"" rel=""nofollow noreferrer"">Boost.Multiprecision</a>.</p>
",0
15558157,15558087,2,"<p>What you are looking for is a library like <a href=""http://gmplib.org/"" rel=""nofollow"">GMP</a> or <a href=""http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html"" rel=""nofollow"">Boost-Multiprecision</a> or <a href=""http://www.ttmath.org/"" rel=""nofollow"">TTmath</a>.</p>

<p>Or, you might challenge yourself to write a low level representation that handles longer than standard bit representations, and do arithmetic with it.</p>

<p>Stick with the first option though, if it does the job you have in mind.</p>
",0
11508166,11508013,5,"<p>You can use a map like: <code>map&lt;string, int&gt;</code>. One element would be like <code>pair&lt;string,int&gt;(""newline"", VK_RETURN&gt;</code>:</p>

<pre><code>map&lt;string, int&gt; NameToKey;
NameToKey.insert(make_pair(""newline"", VK_RETURN));
</code></pre>

<p>And use the same in switch case like:    </p>

<pre><code>map&lt;string,int&gt;::const_iterator iter = NameToKey.find(_specialKey);
switch(iter-&gt;second)
{
case VK_RETURN: // Handle as ""newline""
   ;
 }
</code></pre>
",3
11508203,11508013,9,"<p>You have more than 127 <code>else if</code> blocks. While this ought to compile and it's certainly a bug in Microsoft's C++ compiler, it's still a pretty strong smell that something is wrong with your code.</p>

<p>You're storing data in your control flow, the vast majority of these 128 blocks are redundant copy and pasted blocks. You shouldn't be doing that if it's at all possible not to. Separate your code and data, use control flow for special cases while refactoring all the common cases into a single hash map that deals with it as one type.</p>
",1
11508552,11508013,2,"<p>Little bit OOP  instead pointer to functions way. </p>

<pre><code>class ICommand
{
  public:
  virtual void execute() const =0;
  virtual void ~ICommand(){};
};

class KeyUpCommand : public ICommand
{
  DWORD key_; //not suare about win api here
  public:
  KeyUpCommand(key) : key_(key) {};
  virtual void execute() const
  {
     keyUp(key_);
  };
};

class KeyDownCommand : public ICommand
{
  DWORD key_; //not suare about win api here
  public:
  KeyDownCommand(key) : key_(key) {};
  virtual void execute() const
  {
     keyDown(key_);
  };
};


int main()
{
  std::map&lt;std::string, ICommand *&gt; commands;
  commands[""t-""]=new KeyUpCommand(VK_TAB);

  //execute now
  std::map&lt;std::string, ICommand *&gt;::const_iterator iter = commands.find(_specialKey);
  iter-&gt;second-&gt;execute();
};
</code></pre>
",6
16411283,16410878,4,"<p>A transparent class wrapper is a wrapper around a type, where the wrapper behaves the same as the underlying type - hence ""transparent"".</p>

<p>To explain it as well as its use, here's an example where we wrap an <code>int</code> but overload <code>operator++()</code> to output a message whenever it is used (inspired by <a href=""http://bytes.com/topic/c/answers/428034-transparent-class-wrapper"" rel=""nofollow"">this thread</a>):</p>

<pre><code>class IntWrapper {
    int data;
public:
    IntWrapper&amp; operator++() {
        std::cout &lt;&lt; ""++IntWrapper\n"";
        data++;
        return *this;
    }

    IntWrapper(int i) : data(i) {}

    IntWrapper&amp; operator=(const IntWrapper&amp; other)
    {
        data = other.data;
        return *this;
    }

    bool operator&lt;(const IntWrapper&amp; rhs) const { return data &lt; rhs.data; }

    // ... other overloads ...
};
</code></pre>

<p>We can then replace usages of <code>int</code> with <code>IntWrapper</code> if we choose to:</p>

<pre><code>for (int i = 0; i &lt; 100; ++i) { /* ... */ }
// becomes
for (IntWrapper i = 0; i &lt; 100; ++i) { /* ... */ }
</code></pre>

<p>Except the latter will print a message whenever preincrement is called.</p>

<p>Note that I supplied a non-explicit constructor <code>IntWrapper(int i)</code>. This ensures that whenever I use an <code>int</code> where an <code>IntWrapper</code> is expected (such as <code>IntWrapper i = 0</code>), the compiler can silently use the constructor to create an <code>IntWrapper</code> out of the <code>int</code>. The Google C++ style Guide discourages single-argument non-explicit constructors for precisely this reason, as there may be conversions where you didn't expect, which hurts type safety. On the other hand, this is exactly what you want for transparent class wrappers, because you do want the two types to be readily convertible.</p>

<p>That is:</p>

<pre><code>// ...
explicit IntWrapper(int i) ...
// ...
IntWrapper i = 0;   // this will now cause a compile error
</code></pre>
",0
16410920,16410878,0,"<p>Most likely, you're referring to a lightweight inline (header file) wrapper class, though I'm not familiar with the term.  Adding a level of abstraction like this is useful in permitting generic client code.</p>
",1
13460190,13460181,1,"<p>This is valid in C++11. In C++03 you'll have to initialize it in the constructor. Alternitively, in C++11:</p>

<pre><code>class Stack{
    int const _maxsize{10};
};
</code></pre>
",3
13460197,13460181,2,"<p>Yes, initialize this in your constructor</p>

<pre><code>const int NumItems;

Foo::Foo():
NumItems(15)
{
//....
}
</code></pre>
",0
13460223,13460181,1,"<p>You can use <code>enum</code></p>

<pre><code>class C {
  protected:
    enum { var = 10 }; 
}
</code></pre>

<p>In this case C::var will be compile-time constant, that can be even used in a template.</p>

<p>Also, c++11 allows the declaration you're trying to use.</p>
",2
10116878,10116837,2,"<p>You declared a variable named <code>table_info</code>, and there's a type named <code>table_info</code>, and that's confusing the compiler. When I ran  this through g++, it started complaining at the line</p>

<pre><code>table_info new_table;
</code></pre>

<p>because at that point <code>table_info</code> is a variable name, not a type name any longer.</p>
",1
10116880,10116837,4,"<p>Is that the first compiler error?</p>

<pre><code>   table_info* table_info;
   table_info = get_table_info(tablename);
   table_info new_table;
</code></pre>

<p>In the first line you are creating a local variable <code>table_info</code> that hides the type <code>table_info</code> in the outer context. The third line should be a compiler error telling you that the syntax is wrong. From there on, whatever the compiler had tried to interpret does not yield it to believe that <code>new_table</code> is an object of type <code>table_info</code>.</p>
",0
10117337,10117256,1,"<p>If this is homework, I <strong>strongly</strong> suggest you ask this question in class as most teachers have some particular requirements that an online community is unlikely to know about (unless you tell us ;-).  That being said, we might be able to get you started in the right direction.</p>

<p>The <em>preamble</em> is usually a (short) description of what a particular file, class or function does.</p>

<p>The <em>pre-conditions</em> are the requirements on the arguments passed by the caller, as well as the program state prior to the call.  They establish under what conditions the function will produce the correct results.  For instance, you may request that the first and last names in your example class constructor are non-empty.</p>

<p>A <em>post-condition</em> usually documents side-effects applied by a function.  For instance,</p>

<pre><code>class Person
{
public:
    std::string firstName () const;

    // post-condition: firstName() returns 'name'.
    void setFirstName (std::string name);
};
</code></pre>

<p>The wikipedia articles on <a href=""http://en.wikipedia.org/wiki/Precondition"" rel=""nofollow"">pre-conditions</a> and <a href=""http://en.wikipedia.org/wiki/Postcondition"" rel=""nofollow"">post-conditions</a> provide more elaborate descriptions.</p>
",2
10117383,10117256,8,"<p>preamble is a source code comment appearing before the function that documents its behaviour, normally in a way that a tool like doxygen can automatically create useful documentation from it.</p>

<p>A good policy for documentation is to <strong>document everything that isn't obvious and nothing that is</strong>.  On that basis, I'd say your getXXX() have no pre- or post-conditions worth documenting.  Something like ""must be called on a properly constructed object"" is just a waste of the reader's time, as is a post-condition like ""the caller will have received a copy of the student-specific XXX data"".  Don't do it!  The question of whether the values can legally be empty strings is one for the constructor (or may even be a class invariant - something the class maintains as true, for instance by having the constructor throw if a value is empty and by not providing functions that wipe out the values), not for the <code>get</code> function documentation.</p>

<p>Similarly, your comments for firstName, lastName and major add absolutely no value, but your comment for <code>uid</code> does add value - documenting a requirement for a string format!  From that I can tell you've made a mistake, as the field is an <code>int</code>, and there's something to investigate and correct.  But more generally, say you had a string type - a comment might usefully communicate some restrictions on the format of the id, say that these ids relate to some other API or source, give an example etc.</p>

<p>More generally, pre-conditions aren't only for mutator (data changing) functions.  For example, a function <code>day_for_date(int year, int month, int day)</code> that tells you what day of the week a particular date falls on may have a pre-condition that year/month/day does actually describe say a valid date between 1000 and 3000 A.D..  That's nasty, but it means if you've already checked that somewhere the function call doesn't waste time re-verifying it.  In Defensive Programming style (which IMHO tends to make for more robust code) you would tend not to make that a precondition; instead, accept redundant verification as a net win (though you may provide explicit options to disable it if the caller needs the performance), and document an exception or error outcome should the date not meet expectations.  The difference is that a precondition is something the caller must guarantee for the function to operate as documented, where-as in defensive programming you generally let the caller try something and have a defined/documented manageable behaviour - a change in state, return value or error reported in a predictable way - for as broad a range of prior states and inputs as is practical.</p>

<p>Post-conditions only make sense for mutators: whatever could be asserted about the state after the call to a non-mutating accessor must have been true beforehand - it might be a class invariant.</p>
",7
9779242,9779174,1,"<p>You prof/teacher should have told you about initializer lists. The syntax looks something like this:</p>

<pre><code>class MyClass {
    std::vector&lt;int&gt; data;
public:
    MyClass(int max) : data(max) { }
};
</code></pre>
",3
13415446,13415281,3,"<p><code>MediaFactory::returnMedia()</code> is a <em>non-static member function</em>, and can only be called via an instance of <code>MediaFactory</code>.</p>

<p><code>typedef Media* (*funPointer)();</code> defines a pointer to a <em>static</em> or <em>non-member</em> function, which is called without any object. It's therefore a different type, incompatible with a pointer to a member function.</p>

<p>If you don't need it to point to a member function, then make <code>returnMedia()</code> either static or a non-member (as you note in at the end of the question).</p>

<p>If you do need it to point to a member function, then you need a pointer-to-member:</p>

<pre><code>typedef Media* (MediaFactory::*funPointer)();
</code></pre>

<p>which can be set to point to a member function:</p>

<pre><code>somePointer = &amp;MediaFactory::returnMedia;
</code></pre>

<p>and can be called on a factory object:</p>

<pre><code>Media * media = (someFactory.*somePointer)();
</code></pre>

<p>Alternatively, you might want to bind the function pointer to an object when you set the pointer, rather than when you use it. In this case, you could use <code>std::function</code> (or <code>boost::function</code> if you're stuck with an outdated compiler) to store an arbitrary callable object:</p>

<pre><code>typedef std::function&lt;Media*()&gt; function;
function someFunction;

someFunction = std::bind(&amp;MediaFactory::returnMedia, &amp;someFactory);

Media * media = someFunction();
</code></pre>
",2
13415331,13415281,0,"<p>You cannot assign a method of a class to a global function pointer without an instance of this class.</p>
",0
16410909,16410896,1,"<p>You should initialize members with a constructor. See this thread: <a href=""https://stackoverflow.com/questions/13662441/c11-allows-in-class-initialization-of-non-static-and-non-const-members-what-c"">in-class initialization of non-static and non-const members</a> for good information.</p>
",0
16410914,16410896,1,"<p>It is not a static member so initialize it in constructor.Non static member cannot be initialize without constructor<br>Also <a href=""http://cscie160-distance.com/nonstatic.html"" rel=""nofollow"">see this</a> for further details about the initialization of static and non staic data</p>
",3
16410938,16410896,2,"<p>It's a new feature in C++11. compile your code with <code>-std=c++11</code></p>
",0
15526662,15526637,1,"<p><code>delete[]</code> is called the ""array delete operator"". It deletes an array allocated using <code>new[]</code>.</p>

<p>It is important to note that it is not allowed to use array <code>delete</code> with non-array <code>new</code> and vice versa.</p>

<p>For more information, see <a href=""https://stackoverflow.com/questions/252515/why-do-we-even-need-the-delete-operator"">Why do we even need the &quot;delete[]&quot; operator?</a></p>

<p>As a side note, your class violates the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29"" rel=""nofollow noreferrer"">Rule of Three</a>. You should provide (or disable) the copy constructor and copy assignment operator.</p>
",0
15526667,15526637,1,"<p>When you have an array allocated using <code>new []</code> you need to use <code>delete []</code> if you use just <code>delete</code> with memory allocated using <code>new []</code> you will have undefined behavior. In the code posted you are allocating using <code>new []</code> in your constructor here:</p>

<pre><code>_v = new char[strlen(v) + 1];
</code></pre>

<p>hence the call to <code>delete []</code> later on in the destructor.</p>
",0
15526671,15526637,3,"<p>Look at how the object that <code>_v</code> points to was allocated:</p>

<pre><code>_v = new char[strlen(v) + 1];
</code></pre>

<p>It uses the <code>new char[...]</code> syntax, meaning that it is dynamically allocating an array of <code>char</code>. To destroy a dynamically allocated array, you need to use <code>delete[]</code>.</p>

<p>The reason that this is necessary is because the compiler cannot tell that <code>_v</code> is pointing at an array from the type of <code>_v</code> alone. Since <code>_v</code> is just a <code>char*</code>, there's no reason you couldn't point it at a single dynamically allocate <code>char</code>. So <code>delete[]</code> tells the compiler that it needs to find out exactly how much space was allocated here and then deallocate all of it.</p>
",0
15526675,15526637,4,"<p><code>delete x</code> will only delete the variable x
whereas the <code>[ ]</code> indicate to the memory manager that an array was allocated. <code>delete[] x</code> will delete the allocated array.</p>
",1
14173635,14173605,4,"<blockquote>
  <p>The problem is I don't know how assigning an int value to a character object truncates the digits except for the first.</p>
</blockquote>

<p>Let's for the sake of illustration assume that <code>char</code> is unsigned and is 8 bits wide, and <code>int</code> is 32 bits wide. What such an assignment would do is chop off the top 24 bits, leaving the bottom 8.</p>

<p>The truncation does not have anything to do with the <em>decimal</em> digits of the integer. For example, <code>9999</code> would become <code>15</code> (because <code>9999 &amp; 0xFF == 15</code>).</p>
",4
14173647,14173605,1,"<p>I am not sure what you mean by ""except for the first."" but let me see if I can explain what is happening. </p>

<p><code>unsigned char</code> is, I believe, required by the standard to be 1 byte in length. <code>int</code> is typically much longer, 4 bytes is typical. Thus when you enter a number >255, it looses all the value above that since all it can hold is one byte and leading 3 bytes of data are lost.</p>
",0
14866442,14866356,1,"<p>You basically just <code>&lt;&lt;</code> the elements you want printed inside your overload. For instance, assuming you have a <code>LList::front()</code> member function returning the first element, you could print that like this:</p>

<pre><code>ostream &amp;operator &lt;&lt;( ostream &amp;out, const LList&amp; llist ) {
  return out &lt;&lt; llist.front();
}
</code></pre>

<p>Obviously you would want to print the whole list, not just the first element (and check if the list is empty) but that is done the same way. This assumes that there is an overload for the elements that are stored by your <code>LList</code>, if not, you have to provide that as well.</p>
",14
12326290,10138918,2,"<p>This is my simple code. Modify it to reach your merge function purpose.</p>

<pre><code>int main() {
    int a[5];
    int b[5];
    int c[10];

    cout &lt;&lt; ""Enter elements for array a[5]:"" &lt;&lt; endl;
    int i = 0;
    do {
        cin &gt;&gt; a[i];
        i++;
    } while (i &lt;= 4);

    cout &lt;&lt; ""Enter elements for array b[5]:"" &lt;&lt; endl;
    i = 0;
    do {
        cin &gt;&gt; b[i];
        i++;
    } while (i &lt;= 4);

    for (register int x = 0; x &lt;= 5; x++) {
        if (x == 5) {
            for (register int h = 0; h &lt; 5; h++) {
                c[x] = b[h];
                x++;
            }
            break;
        }
        c[x] = a[x];
    }

    for (register int x = 0; x &lt; 10; x++) {
        cout &lt;&lt; c[x] &lt;&lt; "" "";
    }
    return (0);
}
</code></pre>
",0
10139121,10138918,0,"<p>The inner loop can be rewrite as:</p>

<pre><code>for(int j=0;k=n;j&lt;m,k&lt;x;j++,k++)
</code></pre>

<p>{</p>

<pre><code>     c[k]=b[j];
</code></pre>

<p>}</p>

<p>I hope youu got the point...</p>
",0
10139134,10138918,-1,"<pre><code>#include&lt;iostream&gt;
#include&lt;assert.h&gt;


void merge(int first[], int nLenFirst, int second[], int nLenSecond, int merged[]) 
{
    int nTotal = nLenFirst + nLenSecond;

    for(int i= 0; i &lt; nLenFirst; ++i)
        merged[i] = first[i];

    for(int i= nLenFirst, j = 0; i &lt; nTotal; ++i,++j)
        merged[i] = second[j];

}

void main()
{
    int a[] = {2, 4, 5, 7};
    int b[] = {3, 7, 11, 19, 25};

    int nLenA = sizeof(a)/sizeof(int);
    int nLenB = sizeof(b)/sizeof(int);

    int c[100] = {0};

    int nTotal = nLenA + nLenB;
    assert(sizeof(c)/sizeof(int) &gt;= nTotal);

    merge(a, nLenA, b, nLenB, c);

    for(int i = 0; i &lt; nTotal; ++i)
    {
        std::cout &lt;&lt; c[i] &lt;&lt; std::endl;
    }
}
</code></pre>

<p>Focus on the assert !</p>
",5
10138959,10138918,5,"<p>Problems:</p>

<ol>
<li>You need to dynamically create the array of the right size - might be more that 100 items.</li>
<li>You need to start copying from <code>b[0]</code> not <code>b[n]</code>.</li>
</ol>
",1
10138964,10138918,0,"<pre><code>c[j] = b[j];
</code></pre>

<p>is the problem here. The first <code>j</code> is correct, but the second <code>j</code> should really be <code>j - n</code>.</p>
",0
10138967,10138918,0,"<p>in second loop</p>

<pre><code>for(int j = n ; j &lt; x ; j++)
c[j] = b[j];    &lt;---- b[j] not defined, you need to start from b[0]
</code></pre>

<p>Try this:</p>

<pre><code>for(int j = n ; j &lt; x ; j++)
c[j] = b[j-n];
</code></pre>
",1
10138978,10138918,0,"<pre><code>void merge (int a[], int n, int b[],int m) 
{
  int* c = new int[n+m];

  for(int i = 0; i &lt; n; i++)
    c[i]=a[i];

  for(int j = 0 ; j &lt; m ; j++)
    c[n+j] = b[j]; // &lt;-- there was your fault

  cout&lt;&lt;endl&lt;&lt;endl;
  for(int k = 0; k &lt; n+m; k++)
    cout&lt;&lt;c[k]&lt;&lt;"" "";

  delete [] c;
}
</code></pre>
",3
10139462,10138918,1,"<p>Why not just use vectors? Something like this:</p>

<pre><code>std::vector&lt;int&gt; concat(const std::vector&lt;int&gt;&amp; a, const std::vector&lt;int&gt;&amp; b) {
    std::vector&lt;int&gt; c;
    c.reserve(a.size() + b.size());
    c.insert(c.end(), a.begin(), a.end());
    c.insert(c.end(), b.begin(), b.end());
    return c;
}
</code></pre>
",0
10139492,10138918,0,"<pre><code>void merge (int a[], int n, int b[],int m) 
{

    int c = new int[n + m];
    std::copy(a, a + n, c);
    std::copy(b, b + m, c + n);

    cout&lt;&lt;endl&lt;&lt;endl;
    for(int k = 0; k &lt; n+m; k++)
        cout&lt;&lt;c[k]&lt;&lt;"" "";    

    delete[] c;
}
</code></pre>
",0
11805370,11805322,0,"<blockquote>
  <p>(I remember I've read in Effective C++)</p>
</blockquote>

<p>No, you don't, because Scott Meyers wouldn't make such a mistake.</p>

<p><code>const T&amp;</code> is the best option because it never involves a copy but can still take rvalues. Consider</p>

<pre><code>void foo(int&amp; p);
void foo(const std::string s);
int main() { 
    foo(1); // illegal!
    foo(""A reaaaaaaaallllllllllllllllllllllllllllllllllllllllllly long string"");
    // Nasty copy
}
</code></pre>

<p>If you need a copy of an item, make one in the parameter list (take by value) but there's little reason for this value to be <code>const</code>. Else, use <code>const T&amp;</code>. For some cheap types there's little point not taking by value because you know in advance that copying is cheap.</p>
",3
11805377,11805322,0,"<p>Your rule to always pass by const reference is overly general.</p>

<p>Passing by const reference generally indicates that</p>

<ul>
<li>the method is not going to modify the argument</li>
<li>that the method may not claim ownership of the argument</li>
<li>that the caller guarantees the
argument's lifetime will be longer than the call</li>
</ul>

<p>If you need something different, then you should choose something other than passing by const reference.</p>
",0
11805380,11805322,1,"<p>const T is passed by value (copy is needed), which may be too much for a class while should be ok for built-in types.</p>

<p>T&amp; is passed by reference, which could be modified in the function while const T&amp; can't, so it depends on what you need to do.</p>
",0
11805395,11805322,8,"<p>You could pass any of the three (<em>const T, T&amp;,</em> or <em>const T&amp;</em>). They all have different meanings. Up to you whether you want to pass a copy of the object that cannot be modified, a non-const reference to the object, or a const reference to the object. What you choose depends on the semantics of your code. Overall, you would want to choose <code>const T&amp;</code> over <code>const T</code> in order to refrain from having to copy the value over from the caller to this function (save time and memory). Moreover (according to <a href=""http://www.cprogramming.com/tutorial/const_correctness.html"" rel=""noreferrer"">this helpful link</a>), you would want to use <code>const T&amp;</code> over <code>T&amp;</code> whenever you want to refrain from changing neither the <em>value</em> nor the <em>state</em> of the passed reference. This can prevent silly and overlooked coding errors, such as changing a field for testing purposes.</p>

<p>For your question about passing as a parameter a reference to a const primitive type, see this: <a href=""https://stackoverflow.com/questions/1333176/c-and-qt4-5-is-passing-a-const-int-overkill-does-pass-by-reference-helps-i"">C++ and QT4.5 - is passing a const int&amp; overkill? Does pass by reference helps in signals/slots?</a></p>
",3
8789072,8789024,5,"<p>To get the underlying data from a <code>std::string</code> You can use:   </p>

<p><strong><a href=""http://www.cplusplus.com/reference/string/string/data/"" rel=""nofollow"">string::data()</a></strong> or <strong><a href=""http://www.cplusplus.com/reference/string/string/c_str/"" rel=""nofollow"">string::c_str()</a></strong>, both return a <code>const char *</code>. </p>

<p>In either case the returned data is <code>const char *</code> because the memory for it is allocated in some read only implementation defined region which an user program is not allowed to modify. Any attempt to modify the returned <code>const char *</code> would result in <strong>Undefined Behavior</strong>.   </p>

<p>So you cannot and should not(through <code>const_cast</code>) modify the returned character string.</p>

<p>The only correct way to achieve this by creating a new <code>char*</code>, allocate it, and copy in the contents from the <code>const char*</code>:</p>

<pre><code>std::string myString = ""blabla"";
char* myPtr = new char[myString.size() + 1];
myString.copy(myPtr, myString.size());
myPtr[myString.size()] = '\0';
</code></pre>
",14
8789101,8789024,2,"<p>I would suggest making a copy of the buffer, calling your function, and then setting the original string to the new char buffer.  Something like:</p>

<pre><code>std::string str(""some string"");
char tmp[str.length() + 1];
memset(tmp, 0, sizeof(tmp));
copy(str.begin(), str.end(), tmp);
str = removeDup(tmp);
</code></pre>

<p>Using the const buffer returned by c_str() directly and modifying it is asking for trouble.  The buffer is owned by the string object and you should think of modifying that as breaking encapsulation and at minimum implementation dependent.</p>
",2
8789117,8789024,0,"<p>I think you want this method from string:</p>

<p><strong>Copy sequence of characters from string:</strong>
<a href=""http://www.cplusplus.com/reference/string/string/copy/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/copy/</a></p>

<p>eg. If you had a string 'str', you could do this:</p>

<pre><code>char buf[str.len()+1]
str.copy(buf, str.len())

//terminate with newline
buf[str.len() = '\n']
</code></pre>

<p>Hope that helps.</p>
",0
8789140,8789024,1,"<p>Just copy it.</p>

<pre><code>string str = ""Hello"";
char * cStr = new char[str.size()];
memcpy(cStr, str.c_str(), str.size());
</code></pre>
",1
8790539,8789024,1,"<p>The only way to legally make modifications to a <code>std::string</code> is through
it's member functions (including the access paths they indirectly 
provide).  Thus, you should rewrite your <code>removeDup</code> to take
<code>std::string::iterator</code> as arguments, something like:</p>

<pre><code>std::string
removeDup( std::string&amp; original )
{
    std::string::iterator current = original.begin();
    std::string::iterator end = original.end();
    while ( current != end ) {
        end = std::remove( current + 1, end, *current );
        ++ current;
    }
    original.erase( end, original.end() );
    return original;
}
</code></pre>

<p>(I think this does what your original code does.  I can't be sure,
because I couldn't really figure out your original code.)</p>

<p>From a design point of view, this is ugly; you should probably pass a
<code>std::string const&amp;</code>, and return a new <code>std::string</code>:</p>

<pre><code>std::string
removeDup( std::string const&amp; original )
{
    std::string results;
    std::bitset&lt;UCHAR_MAX + 1&gt; alreadySeen;
    for ( std::string::const_iterator current = original.begin();
            current != original.end();
            ++ current ) {
        if (! alreadySeen.test( static_cast&lt;unsigned char&gt;( *current ) ) ) {
            results += *current;
            alreadySeen.set( static_cast&lt;unsigned char&gt;( *current ));
        }
    }
    return results;
}
</code></pre>

<p>The only time you want to get a <code>char*</code> from a <code>std::string</code> is to pass
it to legacy code (or C).  In such cases, <code>std::string::c_str()</code> is the
approved method; if the function you are calling requires a <code>char*</code>,
then:</p>

<ul>
<li><p>if the function doesn't actually modify the string (it's not const
correct, but this is the case for many C functions), then use
<code>const_cast</code> on the return value of <code>std::string::c_str()</code>, otherwise</p></li>
<li><p>you must allocate a local buffer, and pass it:</p>

<p>std::vector localBuffer( s.begin(), s.end() );
localBuffer.push_back( '\0' );
legacyFunction( &amp;localBuffer[0], localBuffer.size() );</p></li>
</ul>
",0
8791284,8789024,0,"<p>In the realm of 'possible' as opposed to 'sensible' you could do:</p>

<pre><code>std::string str(""foo"");
str = removeDup( std::auto_ptr&lt;char&gt;(strdup(str.c_str()).get() );
</code></pre>

<p>But rewriting in terms of std::string would be better.</p>
",1
9792160,9792117,-1,"<p>Default values for arguments have to be statically known. You cannot use a runtime value as default argument.</p>

<p>The latter fails because it's not a valid syntax and makes no sense pretty much.</p>
",4
9792190,9792117,5,"<p>Use an overload:</p>

<pre><code>LinkedInteger accessElement(int index){
  return accessElement(index, &amp;DataArray[0]);
}
</code></pre>
",0
9792203,9792117,1,"<p>Try:</p>

<pre><code>// 0 or NULL; your preference

LinkedInteger accessElement(int index, LinkedInteger *startElement = 0)
{
   if (startElement == 0)
       startElement = &amp;DataArray[0];  // or just startElement = DataArray;
   // ...
}
</code></pre>
",1
8779617,8779591,2,"<p>The problem with <code>std::set&lt;&gt;</code> is that you cannot modify its elements in place because you could violate the ordering it has. You can however iterate from <code>set.begin()</code> to <code>set.end()</code> using iterators (instead of <code>operator[]</code>) and remove and reinsert modified elements.</p>
",2
8779809,8779591,2,"<p>(Sample correct code on <a href=""http://ideone.com/maOMd"" rel=""nofollow"">ideone</a>)</p>

<p>The error is that this line</p>

<pre><code>if (m.find(""5-"") == 0)
</code></pre>

<p>will never succeed. You maybe be surprised at this. <code>m.find(""5-"")</code> searches through the entire map looking for an entry whose key is <em>exactly</em> equal to ""5-"". Your keys are ""4-2"" and ""5-2"".</p>

<p>Do you wish to find <em>keys</em> which <em>contain</em> the substring ""5-""? Then you need something like</p>

<pre><code>it4-&gt;first.find(""5-""); // check if the key string at this entry contains ""5-""
</code></pre>

<p>I think you want a loop like this:</p>

<pre><code>multimap&lt;string, string&gt;::iterator it4;
for ( it4 = m.begin(); it4 !=m.end(); it4++)
{
    if (it4-&gt;first.find(""5-"") != string :: pos)
            cout &lt;&lt; "" result of 5 search is"" &lt;&lt; it4-&gt;first &lt;&lt; "", "" &lt;&lt; it4-&gt;second &lt;&lt;endl;      
}
</code></pre>

<p>As others have pointed out, you are <em>not</em> interested in the the <code>find</code> method of <code>vector</code> or <code>map</code>. You are interested in the find method of <code>string</code> - this is quite different. The title of your question is a little misleading as a result (unintentionally).</p>
",1
9225085,9225047,1,"<p>C++ is originally from c, this book may help you to understand c++: ""Inside the C++ Object Model""</p>
",1
9225195,9225047,2,"<p>If you want to learn C++, Stroustrups ""The C++ language"" is a very good starting point imo. Personally I also learned a lot from Scott Meyers ""Effective C++"" and ""More Effective C++""</p>

<p>Also I think that, considering your embedded background, you might not only need to ""learn the language"" but also work on your understanding of Object Oriented Programming. I think one of the basic books in this field is Grady Booch's ""Object Oriented Analysis and Design"" and the ""Gang of Four"": Gamma/Helm/Johnson/Vlissides ""Design Patterns"" (although both books are written with a Java background)</p>
",0
9225394,9225047,5,"<p>Have a look at <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">Definitive C++ Book Guide</a>. Since you have a C background I'd recommend ""Accelerated C++"" by Koenig and Moo, because it shows code in Modern C++ ideoms from the start. 
this will probably help you focus on the differences between C and C++ and show you which parts of your C habits you will have to unlearn.</p>
",0
9225538,9225047,0,"<p>The concept of ""Class"" can be easily modeled thinking to a C <code>struct</code> containing data members and a pointer to a struct containing function pointers (the v-table), where all functions have a ""hidden"" parameter <code>Class* this</code>.</p>

<p>That said, if you are already familiar with struct, pointer and function pointers, classes are nothing ""misterious"".</p>

<p>Everything else is ""<em>art of usage</em>"" and is not itself related to the class concept itself but to how they can be arranged to have an effective maintainable code.</p>

<p>At this point you can</p>

<ul>
<li>try yourself to code a C program designed tat way (noting complicated, just to get the clue) or</li>
<li>forget about C itself, and try understand how the concept should be used (rather then for what it technically is). </li>
</ul>

<p>For the last point the <em>Koenig and Moo</em> ""Accelerated C++"" book can be a good starter: it does not consider C, but how C++ and it's library should be used, and -after going deeper and deeper in detail- show where those concepts come from.</p>
",5
8806709,8806477,0,"<p>Is this ptr class compiled in this first static library and only *.h is available as a interface to second one? If yes then in this first library template ptr wasn't created with int type and this kind of constructor/destructor isn't there so you can use it from second library.</p>

<p>The easiest way to deal with this is to include ptr.cpp and compile it also in second library. This will allow to create template code for int type during compilation.
Another solution is to somehow use ptr template with int type in this first library so it will be created there.</p>
",0
17832100,17832004,1,"<p>You can ""go back in time"" to a place where you've been before using <code>setjmp</code> and <code>longjmp</code>, but there is nothing to jump to a random new location in the code (aside from various system dependent things, like using inline assembler or some such - and this would still be hard to make very generic, as you need to care for stack cleanup and other things like that). </p>
",0
17832154,17832004,1,"<p>If you have common functionality then make a (<code>private</code>) method and call it from all methods that need that functionality:</p>

<pre><code>class timeBomb {
public:
  void detonate(int time){
    sleep(time);
    blast();
  };
  timeBomb();

private:
  void blast(){
    delete this;   // Very dangerous!
  }
};
</code></pre>
",0
9836620,9836616,5,"<p>It returns <code>true</code> or <code>false</code>, depending on whether the expression is true or not.</p>

<p>It's the same as:</p>

<pre><code>if ( (tail+1)%N == head%N )
   return true;
else
   return false;
</code></pre>
",2
9836630,9836616,2,"<p>you're returning a boolean value. The value represents whether or not the remainder of (tail+1) divided by N is the same as that of head.</p>
",0
9836631,9836616,2,"<p>It evaluates the expression, and return the result. In this case it's two modulo operations that are compared, and the result is either <code>true</code> or <code>false</code> which will be returned.</p>
",0
9836656,9836616,2,"<p>it returns true if remainder of the division for tail + 1 and head is the same</p>

<p>for example if tail is 2, head is 1 and N is 2</p>

<p>(tail + 1) % N is 1</p>

<p>head % N is 1 too</p>

<p>so whole expression returns true</p>
",0
9836694,9836616,3,"<p>this </p>

<blockquote>
  <p>(tail+1)%N == head%N</p>
</blockquote>

<p>returns a boolean value, either true or false. This statement means that after adding 1 to trail (trail + 1) and the remainder obtained after division with N is equal to remainder of  head divided with N. % is used for division with remainder</p>

<blockquote>
  <p>(%). Modulo is the operation that gives the remainder of a division of two values.</p>
</blockquote>

<p>Check this link for c++ operators : <a href=""http://www.cplusplus.com/doc/tutorial/operators/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/operators/</a></p>
",0
9836799,9836616,2,"<p><strong>Short Answer:</strong></p>

<p>Because of the <code>==</code> operator your function will return a <code>bool</code>, meaning it can only be <code>true</code>or <code>false</code>. An equivalent would be something like:</p>

<pre><code>return 5 == 4;
</code></pre>

<p>which would return <code>false</code> since 5 is not equal to 4. </p>

<p><strong>Long Answer:</strong></p>

<p>Instead of writing this in a single line you could split it up into more lines of code. Let's just assume that <code>tail</code>, <code>head</code> and <code>N</code> are integer values, then you could write it like this:</p>

<pre><code>int x, y;
x = (tail+1)%N;
y = head%N;
if ( x == y )
{
    return true;
}
else
{
    return false;
}
</code></pre>

<p>Now in this code there may be also that <code>%</code>confuses you a bit. The <code>%</code>is called the <code>Modulus Operator</code> and can give you the remainder of arithmetic operations. In a simple example this would mean:</p>

<p><code>10 % 3 = 1</code> because <code>10/3</code> is 3 with a remainder of 1. So to make it more clear let's just make another example with your specific problem:</p>

<p>Lets just assume that <code>tail=10</code>,<code>head=6</code> and <code>N=2</code>. Then you would get something like this:</p>

<pre><code>x = (10+1)%2
x = 11 % 2
x = 1

y = 6 % 2
y = 0

y != x
</code></pre>

<p>This would return <code>false</code> cause <code>x</code> and <code>y</code> are not equal. ( If you would run your code with the given example values )</p>

<p>To learn more about <code>Modulus</code> you can look <a href=""http://www.cprogramming.com/tutorial/modulus.html"" rel=""nofollow"">here</a>, or just on any other basic C++ Tutorial.</p>
",0
11565104,11554771,0,"<p>This is the correct code that will work. I suggest anybody trying this problem gives some time to actually see the pattern by pencil and paper. The problem is very easy in itself.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int input [20][20] ={{8,2,22,97,38,15,0,40,0,75,4,5,7,78,52,12,50,77,91,8},   {49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,4,56,62,0},
{81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,3,49,13,36,65},
{52,70,95,23,4,60,11,42,69,24,68,56,1,32,56,71,37,2,36,91},
{22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80},
{24,47,32,60,99,3,45,2,44,75,33,53,78,36,84,20,35,17,12,50},
{32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70},
{67,26,20,68,2,62,12,20,95,63,94,39,63,8,40,91,66,49,94,21},
{24,55,58,5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72},
{21,36,23,9,75,0,76,44,20,45,35,14,0,61,33,97,34,31,33,95},
{78,17,53,28,22,75,31,67,15,94,3,80,4,62,16,14,9,53,56,92},
{16,39,5,42,96,35,31,47,55,58,88,24,0,17,54,24,36,29,85,57},
{86,56,0,48,35,71,89,7,5,44,44,37,44,60,21,58,51,54,17,58},
{19,80,81,68,5,94,47,69,28,73,92,13,86,52,17,77,4,89,55,40},
{4,52,8,83,97,35,99,16,7,97,57,32,16,26,26,79,33,27,98,66},
{88,36,68,87,57,62,20,72,3,46,33,67,46,55,12,32,63,93,53,69},
{4,42,16,73,38,25,39,11,24,94,72,18,8,46,29,32,40,62,76,36},
{20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,4,36,16},
{20,73,35,29,78,31,90,1,74,31,49,71,48,86,81,16,23,57,5,54},
{1,70,54,71,83,51,54,69,16,92,33,48,61,43,52,1,89,19,67,48}};

/* if element is a[i][j], its diagonal to the right is a[i+1][j+1]
   if element is a[i][j], its diagonal to the left is a[i+1][j-1]   
   IF element is a[i][j], the element below it is a[i+1][j]
   IF element is a[i][j], the element on right of it is a[i][j+1]
*/


/*
approach:

=&gt; find the greatest product of diagonals
=&gt; find the greatest prodct of elements below each other
=&gt; find the greatest prodct of element on right of each other
=&gt; compare  them
*/

int main(void)
{

unsigned long hr=0,hb=0,hdr=0, hdl=0;
//hr is the highest product on the right side traversal
//similraly for others


//for diagonal right
for(int i =0; i&lt;17;i++) //going from 0 to 16 so that we dont land up beyond the     array for (i+1),(j+1) etc
{
    for(int j=0;j&lt;17;j++)
    {
        if(input[i][j]*input[i+1][j+1]*input[i+2][j+2]*input[i+3][j+3] &gt; hdr)
        {
            hdr = input[i][j]*input[i+1][j+1]*input[i+2][j+2]*input[i+3][j+3];

        }
    }
}


for(int i =0; i&lt;17;i++)     //for diagonal left
{
    for(int j=19;j&gt;=3;j--)
    {
        if(input[i][j]*input[i+1][j-1]*input[i+2][j-2]*input[i+3][j-3] &gt; hdl)
        {
            hdl = input[i][j]*input[i+1][j-1]*input[i+2][j-2]*input[i+3][j-3];

        }
    }
}


for(int i =0; i&lt;17;i++)     //for elements below each other
{
    for(int j=0;j&lt;20;j++)
    {
        if(input[i][j]*input[i+1][j]*input[i+2][j]*input[i+3][j] &gt; hb)
        {
            hb = input[i][j]*input[i+1][j]*input[i+2][j]*input[i+3][j];
        }
    }
}

for(int i =0; i&lt;20;i++)     //on right
{
    for(int j=0;j&lt;17;j++)
    {
        if(input[i][j]*input[i][j+1]*input[i][j+2]*input[i][j+3] &gt; hr)
        {
            hr = input[i][j]*input[i][j+1]*input[i][j]*input[i][j+3];
        }
    }
}


if(hdr&gt;hb &amp;&amp; hdr &gt; hr &amp;&amp; hdr&gt;hdl )
{
    cout&lt;&lt;hdr&lt;&lt;endl;
}
else if (hb &gt; hdr &amp;&amp; hb &gt; hr &amp;&amp; hb&gt;hdl)
{
    cout&lt;&lt;hb&lt;&lt;endl;
}
else if(hr&gt;hb &amp;&amp; hr&gt; hdr &amp;&amp; hr &gt; hdl)
{
    cout&lt;&lt;hr&lt;&lt;endl;
}
else
{
    cout&lt;&lt;hdl&lt;&lt;endl;
}
return 0;
}
</code></pre>
",0
14154070,14154042,0,"<p>You can check <a href=""http://www.stroustrup.com/3rd.html"" rel=""nofollow""><em>The C++ Programming Language</em></a>, which is like the Bible? for C++ programmers, at least, new incomers.</p>
",4
10171624,10171584,0,"<p>You'll need to dynamically allocate the array and release the memory when done:</p>

<pre><code>char** th = new char*[x];
for ( int i = 0 ; i &lt; x ; i++ )
   th[i] = new char[y];

//rest of the code

for ( int i = 0 ; i &lt; x ; i++ )
   delete[] th[i];
delete[] th;
</code></pre>

<p>I must suggest you also look into <code>std::vector</code>, it could be better suited for what you're actually doing.</p>
",3
10171671,10171584,4,"<p>Use the character code representations and the fact that 'b' == 'a' + 1 (and so forth).</p>

<p>If you have a zero-based index I, and you want to convert that to letters, it really is as easy as printing 'a' + I.  If you want it in caps, print 'A' + I.</p>

<p>Also note that you can really simplify those loops.  There's no reason to have three loops nested.  You need a single for loop for the first row (generating the numeric column headers), and then a doubly-nested for-loop for the remaining rows.  Something like the following (completely untested) code:</p>

<pre><code>// print header
std::cout &lt;&lt; ' ';
for (int i = 0; i != x; ++i)
  std::cout &lt;&lt; ' ' &lt;&lt; i;
std::cout &lt;&lt; '\n';

// print body
for (int j = 0; j != y; ++j)
{
  // column leader
  std::cout &lt;&lt; char('a' + j);

  // column body
  for (int i = 0; i != x; ++i)
    std::cout &lt;&lt; "" _"";
  std::cout &lt;&lt; ""\n"";
}
</code></pre>

<p>Following up on your desire to have data in cells, you need to allocate space for them.  if you have X columns by Y rows, you need X*Y cells.  You can index these by using X*j+i, where i,j is the column,row you want to access.  Something like:</p>

<pre><code>std::vector&lt;int&gt; cells(x * y);

// inside the loop, in place of printing "" _"", use:
std::cout &lt;&lt; ' ' &lt;&lt; cells(x * j + i);
</code></pre>

<p>If you want to keep the underscore for ""empty"" values, you need to pick some integer to represent a nil value (zero, negative, INT_MAX, whatever) and fill the vector with that.  Then put in an if condition to print the underscore if the cell value is the nil value, and print the cell value directly otherwise.</p>
",8
10103825,10103349,2,"<p>If you know, that each member will publish different functions, you may always create methods like EnumerateActions(), CallAction(std::string action) and so on - which will be safer, but might be compared to shooting a sparrow with a bazooka.</p>

<p>Another option is to make interfaces: IAction1, IAction2 and implement them in the member derived classes. Then you just check, if a member implement an interface and use it. Container won't be aware of specific member classes, yet you will still be able to access their specific functionalities.</p>
",0
10103631,10103349,0,"<p>One option I can think of o check each object whether it is MemberType1 object, and if the condition is true, then you can call the action2(). Its a very naive solution but I am sure someone else will soon come up with a smart one :)</p>
",1
10104154,10103349,2,"<p>Honestly, the more I look at it and it looks like a typical <a href=""http://www.vincehuston.org/dp/visitor.html"" rel=""nofollow"">Visitor</a> application to me.</p>

<p>I would suggest avoiding implementing any intelligence in your <code>Container</code> class, and instead delegate the actions to a specific <code>Visitor</code> class. The base <code>Visitor</code> can be given some way to safely interact with the underlying container structure (erase/insert).</p>

<pre><code>// MemberBase.hpp
class Visitor;

class MemberBase {
public:
  virtual MemberBase* clone() const = 0;

  virtual void accept(Visitor&amp;) = 0;
  virtual void accept(Visitor&amp;) const = 0;
}; // class MemberBase

// Visitor.hpp
class Member1;
class Member2;

class Visitor {
public:
  virtual void visit(Member1&amp;) = 0;
  virtual void visit(Member1 const&amp;) = 0;

  virtual void visit(Member2&amp;) = 0;
  virtual void visit(Member2 const&amp;) = 0;
};

// Container.hpp
#include &lt;MemberBase.hpp&gt;

class Container {
public:
  void accept(Visitor&amp; v) {
    BOOST_FOREACH(MemberBase&amp; mb, _members) {
      mb.accept(v);
    }
  }

  void accept(Visitor&amp; v) const {
    BOOST_FOREACH(MemberBase const&amp; mb, _members) {
      mb.accept(v);
    }
  }

private:
  boost::ptr_vector&lt;MemberBase&gt; _members;
};
</code></pre>

<p>Then you need to implement the member's <code>accept</code> methods. It's purely mechanical.</p>

<pre><code>// Member1.hpp
#include &lt;MemberBase.hpp&gt;

class Member1: public MemberBase {
public:
  virtual Member1* clone() const { return new Member1(*this); }

  virtual void accept(Visitor&amp; v);
  virtual void accept(Visitor&amp; v) const;
};

// Member1.cpp
#include &lt;Member1.hpp&gt;
#include &lt;Visitor.hpp&gt;

void Member1::accept(Visitor&amp; v) { v.visit(*this); }
void Member1::accept(Visitor&amp; v) const { v.visit(*this); }
</code></pre>

<p>And finally you can implement a visitor:</p>

<pre><code>// CountVisitor.hpp
#include &lt;Visitor.hpp&gt;

class CountVisitor: public Visitor {
public:
  CountVisitor(): _count(0) {}

  size_t count() const { return _count; }

  virtual void visit(Member1&amp;);
  virtual void visit(Member1 const&amp;);

  virtual void visit(Member2&amp;);
  virtual void visit(Member2 const&amp;);

private:
  size_t _count;
};

// CountVisitor.cpp
#include &lt;CountVisitor.hpp&gt;
//#include &lt;Member1.hpp&gt; // where you would include, but unnecessary here

void CountVisitor::visit(Member1&amp;) { ++_count; }
void CountVisitor::visit(Member1 const&amp;) { ++_count; }

void CountVisitor::visit(Member2&amp;) { ++_count; }
void CountVisitor::visit(Member2 const&amp;) { ++_count; }
</code></pre>

<p>And you use it as:</p>

<pre><code>// main.cpp
#include &lt;iostream&gt;

#include &lt;Container.hpp&gt;
#include &lt;CountVisitor.hpp&gt;

int main() {
  Container const c = /* something */;

  CountVisitor cv;
  c.accept(cv);

  std::cout &lt;&lt; cv.count() &lt;&lt; "" items in the container\n"";
}
</code></pre>

<p>The weakness of this design is that a new <code>visit</code> method need be implemented for each new class directly deriving from <code>MemberBase</code>, and thus the <code>MemberBase</code> hierarchy is not so open. This can be alleviated using the <a href=""http://www.objectmentor.com/resources/articles/acv.pdf"" rel=""nofollow"">Acyclic Visitor</a>; however, I have rarely needed it.</p>

<p>To ""extend"" the ability, you can have <code>Visitor::visit</code> and <code>MemberBase::accept</code> return an ""action"" to be executed (erase, clone, etc...) and deal with this in the <strong>two</strong> loops you actually have. <em>It could be reduced to one loop using some tricks...</em></p>
",3
10785576,10785471,1,"<p>Accessing data through a pointer is a little slower than doing it directly, but the dereference operation is very fast and this is usually not a big deal unless you are doing some very specific repetative number crunching tasks.</p>

<p>You are exactly correct about passing pointers for big vs. small objects. For example, the size of int* and int may be the same depending on the implementation.</p>

<p>References and pointers are usually the same with regards to performance. However, if you are in the habit of doing const Foo&amp; rather than Foo*, the compilers can frequently do a better job optimiznig your code.</p>
",11
10785581,10785471,4,"<blockquote>
  <p>Are references generally better than pointers in this performance context?</p>
</blockquote>

<p>Yes, use references when you can, pointers when you must. <strong>Performance-wise, they are the same.</strong></p>

<p>It's usually better to pass large structures by reference or pointer to prevent the extra copying, yes.</p>

<blockquote>
  <p>Accessing a variable or object through a pointer or reference may be
  just as fast as  accessing it directly. The reason for this efficiency
  lies in the way microprocessors are  constructed. All non-static
  variables and objects declared inside a function are stored on the 
  stack and are in fact addressed relative to the stack pointer.
  Likewise, all non-static  variables and objects declared in a class
  are accessed through the implicit pointer known in  C++ as 'this'. We
  can therefore conclude that most variables in a well-structured C++ 
  program are in fact accessed through pointers in one way or another.
  Therefore, microprocessors have to be designed so as to make pointers
  efficient, and that's what they are.</p>
</blockquote>

<p>There are <strong>some</strong> disadvantages though, but they apply to both pointers and references:</p>

<blockquote>
  <p>However, there are disadvantages of using pointers and references.
  Most importantly, it  requires an extra register to hold the value of
  the pointer or reference. Registers are a  scarce resource, especially
  in 32-bit mode. If there are not enough registers then the pointer 
  has to be loaded from memory each time it is used and this will make
  the program slower.  Another disadvantage is that the value of the
  pointer is needed a few clock cycles before  the time the variable
  pointed to can be accessed.</p>
</blockquote>

<p>And <a href=""http://www.agner.org/optimize/optimizing_cpp.pdf"" rel=""nofollow"">here is the source</a>. If you asked this question, I imagine you'll find it a good read.</p>

<p>Let's look at some code:</p>

<pre><code>   int x = 0;
00412E0E  mov         dword ptr [x],0 
   foo(x);
00412E15  lea         eax,[x] 
00412E18  push        eax  
00412E19  call        foo (4111C2h) 
00412E1E  add         esp,4 
   foo(&amp;x);
00412E21  lea         eax,[x] 
00412E24  push        eax  
00412E25  call        foo (4111BDh) 
00412E2A  add         esp,4 
</code></pre>

<p><strong>No difference when calling the functions.</strong></p>

<pre><code>void foo (int&amp; x)
{
00411370  push        ebp  
00411371  mov         ebp,esp 
00411373  sub         esp,0C0h 
00411379  push        ebx  
0041137A  push        esi  
0041137B  push        edi  
0041137C  lea         edi,[ebp-0C0h] 
00411382  mov         ecx,30h 
00411387  mov         eax,0CCCCCCCCh 
0041138C  rep stos    dword ptr es:[edi] 
   x = 3;
0041138E  mov         eax,dword ptr [x] 
00411391  mov         dword ptr [eax],3 
}

void foo (int* x)
{
004117A0  push        ebp  
004117A1  mov         ebp,esp 
004117A3  sub         esp,0C0h 
004117A9  push        ebx  
004117AA  push        esi  
004117AB  push        edi  
004117AC  lea         edi,[ebp-0C0h] 
004117B2  mov         ecx,30h 
004117B7  mov         eax,0CCCCCCCCh 
004117BC  rep stos    dword ptr es:[edi] 
   *x = 3;
004117BE  mov         eax,dword ptr [x] 
004117C1  mov         dword ptr [eax],3 
}
</code></pre>

<p><strong>No difference inside the functions.</strong></p>
",1
10785584,10785471,-2,"<p>Using pointers has no performance implications. The use of pointers is very fast. Pointers are used as a common tool in most (all?) professional projects. They are use to build lists, queues, maps, trees, data bases, every where. Get used to them!!!</p>
",2
10785618,10785471,1,"<p>your biggest problem with heap-based objects is that they will often not be located together when you need them, which means you require a lot more time to read those objects into the CPUs cache to work on them (ie, if you had 10 objects that you needed to work with, if they were all allocated contiguously a single memory read would shove them all into cache in one go, if they are scattered  all over the heap,  then a read for each of them is required).</p>

<p>To be fair, this applies to all heap systems, including garbage collected ones even after a garbage compaction. The answer (obviously) is to allocate these objects together, or to provide a buffer with  free space to allocate them into over time.</p>

<p>The other problem with pointers is that you require an indirection to access the pointer-to objects. If you have an array of objects, you're fine - they are usually contiguous. But if you have an array of pointers, you'll have to read those pointers in order to find out where to read the objects.</p>

<p>Now, pointers can be fast too - if you use pointer arithmetic to access your contiguous objects (as you only need a single pointer read to find out where all the objects are).</p>

<p>So in short, the problem isn't with pointers themselves, but with how you organise the data they point to.</p>
",1
10785793,10785471,7,"<p>I know that performance can be important, but semantics are <em>more</em> important: fast and wrong is useless.</p>

<p>Using pointers or references have semantics implications, such as sharing:</p>

<pre><code>void foo(A&amp; a) {
    a.a = 1;
    if (a.b != 0) { throw ... }
    a.b = 0;
}
</code></pre>

<p>In the case <code>a.b == 0</code>, then the first field of <code>a</code> has been changed but not its second.</p>

<p>Also, such sharing may create potential aliasing:</p>

<pre><code>void foo(struct A a, struct A b);

void foo(struct A* a, struct A* b);
</code></pre>

<p>In the first case, the two structures are necessarily distinct, but in the latter they are not. This possible aliasing might prevent optimizations.</p>

<p>Focus on semantics first. Once you get them right, you can tweak and measure the effects in your particular situation.</p>
",1
10786004,10785471,1,"<p>It depends on where is pointer pointing to. If object allocated on stack and you pass  pointer parameter in many cases will be faster than pointer that points to object on heap. If object you passing was actively used in function before most of the chances it was already cached by CPU so then performance will be about the same. </p>

<p>About copying ... Most of the compilers will use CPU registers to pass pointers that's the fastest memory available in CPU. However if you'll pass as value compiler will require to copy whole object and also call ctor / dtor. </p>

<p>So my advice try keep things on stack and pass by pointers / references.</p>

<p>It's hard to say about performance it something that not constant and may change on different hardware / OS / compilers, so my advice is to profile the code with profiler tool to analyse things like cache misses,  memory  fragmentation,  cpu usage.</p>

<p><a href=""http://en.wikipedia.org/wiki/VTune"" rel=""nofollow"">http://en.wikipedia.org/wiki/VTune</a></p>

<p><a href=""http://developer.amd.com/tools/CodeAnalyst/Pages/default.aspx"" rel=""nofollow"">http://developer.amd.com/tools/CodeAnalyst/Pages/default.aspx</a></p>
",0
11897059,11897038,0,"<p>Link against the library and declare the prototype (usually done by including the header where the function is declared).</p>

<p>Under Windows, you have to explicitly mark the function as import/export (google for <code>declspec(dllimport)</code> and <code>declspec(dllexport</code>).</p>
",2
11897098,11897038,0,"<p>It very much depends on the compiler. On some systems (Windows), for example, you have to add some things in front - __declspec(dllexport) / __declspec(dllimport). On others (Linux), this is not needed.</p>

<p><a href=""http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html"" rel=""nofollow"">Here</a> is a nice tutorial on how to do it with gcc in Linux.</p>
",2
11153453,11153393,2,"<p><code>idj</code> is of type <code>int</code>; it should be <code>unsigned int</code> to be passed as parameter <code>b</code>.</p>
",0
11153475,11153393,4,"<p>You should read about <a href=""https://stackoverflow.com/questions/4919460/c-access-specifiers"">access specifiers</a>.</p>

<pre><code>class Abc{
 bool func(const std::string&amp; text,::DE::d type,unsigned a,unsigned&amp; b);
};
</code></pre>

<p><code>Abc::func()</code> is private, so cannot be called, or referenced, from outside. Same with enum in <code>DE</code>.</p>

<p>Plus, you cannot pass <code>int</code>, where reference to <code>unsigned int</code> is required.</p>
",2
11153478,11153393,2,"<p>The last parameter type is a reference to <code>unsigned</code>. You are trying to pass a reference to <code>int</code>, which is a different type.</p>

<p>Once you fix that, you'll find that you can't call the function because it is private; likewise, you can't access <code>DE::U</code> since that's also private. (<strong>UPDATE</strong>: this refers to the question as originally posted, before <code>public</code> access specifiers were added.)</p>
",0
10819372,9735639,3,"<p>I had the same problem. The way to solve this is not by downloading an older XCode (which will crash) or a newer version of the Stanford library (which is non-existent)-- the preferred way is to use the new assignment files (each of them come with the attached requisite library files) and open those directly in XCode 4 by opening the xcode project file in each of those folders. You can find these files in the current class website:
<a href=""http://www.stanford.edu/class/cs106b/"" rel=""nofollow"">http://www.stanford.edu/class/cs106b/</a></p>

<p>The unfortunate thing is that you cannot directly get the old assignment files in this format. Given that, you can either 1) Follow the new exercises on the current class website, or 2) Use the blank project folders and tweak slightly to follow the old assignment.</p>
",0
10155608,10155415,4,"<p>C++ Says about function declarations</p>

<blockquote>
  <p>After determining the type of each parameter, any parameter of type ¡°array of T¡± or ¡°function returning T¡± is adjusted to be ¡°pointer to T¡± or ¡°pointer to function returning T,¡± <em><strong>[dcl.fct] 8.3.5/5</strong></em></p>
</blockquote>

<p>So when you want to pass an array C++ ends up passing a pointer to the first element of the original array, instead of making a copy and passing it by value as would be consistent with other types. This is an unfortunate consequence of C compatibility, and I have no idea why C thought this inconsistency was a good idea.</p>

<p>In any case, C++ offers <code>std::array</code> for statically sized arrays and <code>std::vector</code> for dynamically sized arrays. Because of the oddities with C arrays you should avoid them whenever possible. (There's rarely a situation where you can't avoid them)</p>

<p><code>int tab[]</code> is an array with an unknown bound, so you can't use a statically sized <code>std::array</code> and must use <code>std::vector</code>:</p>

<pre><code>int bogoSort(std::vector&lt;int&gt; tab){
</code></pre>

<p>Not that you no longer need the <code>n</code> parameter because the vector knows its own size. This is one of the ways std::vector and std::array are safer than an array. And even though a vector does have extra overhead associated with remembering that size, it's really zero overhead because it's saving you from having to do that work elsewhere.</p>

<hr>

<p>If you really want to take a C array (which you should not) you can simply copy it manually.</p>

<pre><code>int bogoSort(int const *tab,int n) {
    std::vector&lt;int&gt; tab_copy(tab,tab+n);
    bogoSort(tab_copy);
}

int bogoSort(std::vector&lt;int&gt; tab) {
    ...
}
</code></pre>

<p>As you can see, internally I'm using a vector and I have an overload of bogoSort that takes a vector. Compare this with making the copy a raw array:</p>

<pre><code>int bogoSort(int const *tab,int n) {
  int *tab_copy = new int[n];
  std::copy(tab,tab+n,tab_copy);             // manual copying
  bogoSort_impl(tab_copy,n);                 // not overloading, hidden internal function
  delete [] tab_copy;                        // resource cleanup. We're not exception safe!
}

// or

int bogoSort(int const *tab,int n) {
  // unqiue_ptr for exception safety
  std::unqiue_ptr&lt;int[]&gt; tab_copy = std::unqiue_ptr&lt;int[]&gt;(new int[n]);
  std::copy(tab,tab+n,tab_copy.get());
  bogoSort_impl(tab_copy.get(),n);
}
</code></pre>

<p>So again, you really should not be using C arrays. They're too much trouble and there's no benefit.</p>
",0
10155432,10155415,8,"<p>There is no way to pass an array by value in C++. If you don't want to modify the original array, then you either have to make a separate copy yourself and manipulate the copy, or use <code>std::vector</code> or <code>std::array</code> (if you have C++11) and pass and return it by value (because you <em>can</em> copy <code>std::vector</code> or <code>array</code>).</p>
",2
10155467,10155415,3,"<p>You <em>cannot</em> pass C-style arrays by value. End of story.</p>

<p>You <em>can</em> however pass variables of class-type by value which <em>contain</em> arrays. The easiest way to exploit this is to use <code>std::array</code>:</p>

<pre><code>void f(std::array&lt;int, 10&gt; a);

std::array&lt;int, 10&gt; a;
f(a);
</code></pre>

<p>The class is basically just something like <code>struct { int data[10]; };</code>, so you could even roll this yourself if you really wanted to.</p>
",0
18164079,18164047,6,"<p>No, you cannot cast the object returned by <code>my_function</code> to a subclass of <code>Parent</code>.</p>

<p>Since:</p>

<pre><code>Parent my_function(int x) {
</code></pre>

<p>returns the object by value, it always returns an object of class <code>Parent</code>, and never a subclass. This is due to <a href=""http://en.wikipedia.org/wiki/Object_slicing"" rel=""nofollow noreferrer"">slicing</a>.</p>

<p>For a discussion, see <a href=""https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c"">What is object slicing?</a></p>
",1
9851660,9851587,4,"<p>Yes, it will be deep copied, so use const reference is recommended.</p>

<pre><code>void fun(const std::string &amp; arg)
</code></pre>

<p>Typically std::string has 2 fields, a pointer pointing to dynamic allocated memory and the length, so it is 16+actual length on 64bit machines.</p>
",2
9852277,9851587,0,"<p>Spoiler Alert: My answer wont be that relevant, just an optimization technique.</p>

<p>If you dont want to duplicate the string, write your customized string class, which has two pointers or one pointer with size. In the past it has reduced me a lot of duplicates. This will work only as read-only and do a copy_on_write, i.e duplicate only if you encounter a write. </p>
",1
9853685,9851587,0,"<p>When passing an argument by value in C++ it is conceptually copied. Whether this copy really happens is another question, though, and depends on how the argument is passed and, to some extend, on the compiler: the compiler is explicitly allowed to elide certain copies, in particular copies of temporary objects. For example, when you return an object from a function and it us clear that the object will be returned, the copy is likely to be elided. Similarily, when passing the result of a function directly on to another function, it is likely not to be copied.</p>

<p>Beyond this C++ 2011 added another dimension of possibilities by supporting move constructors. These cover to some extend similar ground but also allow you to have better control: you can explicitly indicate that it would be acceptable for an object to be moved rather than being copied. Still, in no event will an object passed by reference.</p>

<p>With respect to the used bytes per element, the <code>std::string</code> uses just <code>sizeof(cT)</code> bytes (where <code>cT</code> is the character template argument of the <code>std::basic_string</code>). However, the string will overallocate the space in many cases and certainly when characters are added to the string. You can determine the overallocation by comparing <code>size()</code> and <code>capacity()</code> and control it to some extend with <code>reserve()</code> although this function isn't required of getting rid of any overallocation but the <code>capacity()</code> has to be at least as much as was last <code>reserve()</code>d. If the string is small (e.g. at most 15 characters) modern implementations won't make any allocation. This is called the <em>string optimization</em>.</p>

<p>With respect to the actual represention of the string:  unless it is small it will use one word for the address of the storage, one word each for the the size and the capacity, and for strings with stateful allocators the size of the allocator (typically another word). Given alignment requirements this effectively means that in most cases the string will take four words in addition to the elements. Typically the small string optimization uses these words to store characters if the string firs there unless, of course, it needs to store a stateful allocator.</p>
",0
10775981,10775955,0,"<p>Why not just set an array of size n*m vector[].
you can get each row as index % n and column as index % m.
Much simpler and cleaner.</p>
",0
10775986,10775955,4,"<p>Is your code by any chance similar to:</p>

<pre><code>int n, m;
matriz cartas;
cin&gt;&gt;n&gt;&gt;m;
cartas(n,rows(m, cards(0)));
</code></pre>

<p>?</p>

<p>That won't work, <code>matriz cartas;</code> is already an initialization. Either define <code>cartaz</code> after the <code>cin</code> statement, or assign afterwards.</p>

<p>Optimal:</p>

<pre><code>int n, m;
cin&gt;&gt;n&gt;&gt;m;
matriz cartas(n,rows(m, cards(0)));
</code></pre>

<p>Alternative:</p>

<pre><code>int n, m;
matriz cartas;
cin&gt;&gt;n&gt;&gt;m;
cartas = matriz(n,rows(m, cards(0)));
</code></pre>
",0
10756871,10756624,1,"<p>Your syntax is fine and this shouldn't cause any issues in your code; I don't think you'd see any warnings on a UNIX/MAC system while compiling this (except for the fact that you're doing a DLL export which is windows oriented).  I belive you're just seeing fallout of managed C++.</p>

<p>From MSDN:</p>

<blockquote>
  <p><strong>'variable' : the initializer for exported data will not be run until
  managed code is first executed in the host assembly</strong></p>
  
  <p>When accessing data between managed components, it is recommended that
  you not use native C++ import and export mechanisms. Instead, declare
  your data members inside a managed type and reference the metadata
  with #using in the client. For more information, see #using Directive
  (C/C++).</p>
</blockquote>

<p>Your static data member will be in the initialized test segment of your program when compiled on unix.  It is guaranteed to be initialized to the value you provided prior to execution, so it will start at 0, and it will be completely usable in your constructor by the time it is invoked.</p>
",0
10756875,10756624,1,"<p>From the <a href=""http://msdn.microsoft.com/en-us/library/ms173716%28v=vs.80%29.aspx"" rel=""nofollow"">documentation</a> it seems that the issue only arise if you attempt to use the value in the initialization phase (prior to <code>main</code>). Apparently an issue related to <em>managed mode</em>.</p>

<p>The C++ Standard is very clear regarding this: <code>_last_id</code> it will be first statically initialized to <code>0</code> prior to any dynamic initialization, meaning that any conformant compiler will produce code that works as you would expect.</p>

<p>Therefore, it will work with gcc and clang (whatever the OS).</p>

<p>For Visual Studio, I am not sure (not savvy enough) if the issue will appear systematically or only if you require the <em>managed mode</em> with some flags.</p>
",0
15841594,15841511,6,"<p>Directly, no. But you can:</p>

<ul>
<li>write that string to a file.</li>
<li>invoke the compiler and compile that file.</li>
<li>execute the resulting binary.</li>
</ul>
",0
15841608,15841511,5,"<p>C++ is a <em>compiled</em> language. You compile C++ source into machine code, the executable. That is loaded and executed. The compiler knows about C++ (and has all the library headers available). The executable doesn't, and that is why it cannot turn a string into executable code. You can, indeed, <em>execute</em> the contents of a string if it happens to contain machine code instructions, but that is generally a very bad idea... </p>

<p>That doesn't mean that it wouldn't be <em>possible</em> to do this kind of run-time compilation. Very little (if, indeed, anything) is impossible in C++. But what you'd be doing would be implementing a C++ compiler object... look at other compiler projects before deciding you really want this.</p>

<p><em>Interpreted</em> languages can do this with ease - they merely have to pass the string to the interpreter that is already running the program. They pay for this kind of flexibility in other regards.</p>
",0
15841612,15841511,10,"<p>You will need to invoke a compiler to compile the code. In addition, you will need to generate some code to wrap the string in a function declaration. Finally, you'll then somehow need to load the compiled code.</p>

<p>If I were doing this (which I would <strong>not</strong>) I would:</p>

<ol>
<li>Concatenate a standard wrapper function header around the code </li>
<li>Invoke a compiler via the command line (<code>system()</code>) to build a shared
library (<code>.dll</code> on windows or <code>.so</code> on linux) </li>
<li>Load the shared library and map the function</li>
<li>Invoke the function</li>
</ol>

<p>This is really not the way you want to write C code in most cases.</p>
",3
15841613,15841511,0,"<p>Short answer is no. Hackers would have a field day. You can however use the Windows IActiveScriptSite interface to utilize Java/VB script. Google IActiveScriptSite, there are numerous examples on the web. Or you can do what I am currently doing, roll your own script engine.</p>
",0
15841624,15841511,12,"<p>No, C++ is a static typed, compiled to native binary language.</p>

<p>Although you could use LLVM JIT compilation, compile and link without interrupting the runtime. Should be doable, but it is just not in the domain of C++.</p>

<p>If you want a scripting engine under C++, you could use for example JS - it is by far the fastest dynamic solution out there. Lua, Python, Ruby are OK as well, but typically slower, which may not be a terrible thing considering you are just using it for scripting.</p>

<p>For example, in Qt you can do something like:</p>

<pre><code>int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    QScriptEngine engine;
    QScriptValue value = engine.evaluate(""var a = 20; var b = 30; a + b"");

    cout &lt;&lt; value.toNumber();

    return a.exec();
}
</code></pre>

<p>And you will get 50 ;)</p>
",2
9183336,9183282,3,"<p>You just have to implement the default constructor and the destructor somewhere:</p>

<pre><code>Rect::Rect():length(0),breadth(0) {};
Rect::~Rect() {};
</code></pre>

<p>and then, making public <code>Rect::instance()</code>, <code>Rect::set_value(int, int)</code> and <code>Rect::area_rect()</code>, will help</p>
",2
9183700,9183282,1,"<p>The way you can enforce that your type can only be put on the heap but not on the heap is have a base class with a pure virtual destructor base and to make the destructr private: since the destructor isn't accessible to the full object, it can't be put on to the stack but it can be deleted through a pointer to the base. To prevent a derived class can be put on the stack (if this should be prevented, too) you want to make the type <code>final</code> (which is only available in C++2011, though):</p>

<pre><code>struct A { virtual ~A() = 0; };
A::~A() {}

struct B final: A { private: ~B() {} };

int main()
{
    //B  berror; // ERROR: destructor not accessible
    B* b = new B;
    delete static_cast&lt;A*&gt;(b);
}
</code></pre>

<p>The fact some some of your members were declared but not defined was already mentioned in other answers to this questions.</p>
",0
15585565,15585511,4,"<p>It's because the <code>iterator</code> class doesn't have a public constructor. You should implement a public copy-constructor (and probably a copy-assignment operator (see <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"" rel=""nofollow"">the rule of three</a>)).</p>
",1
15819767,15819653,2,"<blockquote>
  <p>When I call: A::setFn1(&amp;fn2) I get the following compiler error.</p>
</blockquote>

<p><code>fn2</code> is a <em>member function</em> of a <code>B</code>, so you have to qualify its name:</p>

<pre><code>A::setFn1(&amp;B::fn2)
//         ^^^
</code></pre>

<p>Moreover, <code>fn2</code> should be <code>static</code>, because non-<code>static</code> member functions actually work on an implicit <code>this</code> pointer, so they are accepting an argument:</p>

<pre><code>class B : public A{
public:
    B();
    static void fn2();
//  ^^^^^^
};
</code></pre>

<p>With these two changes, your program should compile.</p>
",3
15819799,15819653,3,"<p>A non-static member function is not a free function, the types differ. You cannot use a non-static member function as if it was a pointer to a function:</p>

<pre><code>struct test {
   void foo();
   static void bar();
};

&amp;test::foo --&gt; void (test::*)()
&amp;test::bar --&gt; void (*)()
</code></pre>

<p>I won't go in as much as recommending changing the function to be <code>static</code> as I don't find the current design particularly useful. But you can take this and try to rethink a design that will make more sense. (A single <em>callback</em> function for all the process? Why inheritance at all? A <em>user-defined</em> constructor that does the same as the compiler generated? In a class that should not be instantiated?...)</p>
",2
8765073,8765036,4,"<p>Use an anonymous namespace (within a source file, not a header):</p>

<pre><code>namespace {
    int factorial(int n){
         return n &lt;= 1 ? 1 : n*factorial(n-1);
    }
}

namespace HelperCalc{
    double getProbability(int x, int y){
        .....//do maths
        .... = factorial(x);
    }
}
</code></pre>
",3
8765093,8765036,2,"<p>Separate the declaration and definitions of the functions you want to be public.
In the implementation file define the public functions and the helper functions.</p>

<p><code>namespace.h</code>:</p>

<pre><code>namespace X
{
    void public_function();
}
</code></pre>

<p><code>namespace.cpp</code>:</p>

<pre><code>// An anonymous namespace means functions defined within it
// are only available to other functions in the same source file.
namespace {
    void helper_function()
    {
        // ...
    }
}

namespace X
{
    void public_function()
    {
        helper_function();
    }
}
</code></pre>
",0
12789842,12779548,2,"<p>Your tarball doesn't build because files are missing, but there is a declaration of an
<code>extern vector&lt;myFNode&gt; Formula;</code> that would cause the conflict.</p>

<p>It's very confusing that it's apparently possible to define the <code>Formula</code> class without causing a conflict while it's impossible to use it. </p>
",0
17077579,17077551,4,"<p>In-class initialization of an object using <code>()</code> is not possible because it gets interpreted as a function declaration. You can use the member-initializer list to do this instead:</p>

<pre><code>class B
{
    A a;

    public:
        B() : a(7)
    //      ^^^^^^
        {}
};
</code></pre>

<p>This would also work with assignment inside the constructor but the member-initializer list is recommended because <em>initializes</em> instead of assigns.</p>

<p>In C++11 you can use uniform-initialization:</p>

<pre><code>class B
{
    A a{7};                                                                    /*
    ^^^^^^^                                                                    */

    public:
        B() = default;
};
</code></pre>
",3
9794517,9762472,1,"<p>I found the answer to my own question. I really didn't want to use transform, but that does work as well. If anyone else stumbles across this here is how I figured it out...</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;

int main()
{
std::ifstream theFile;
theFile.open(""test.txt"");
std::string theLine;
while (!theFile.eof())
{
  theFile &gt;&gt; theLine;       
  for (size_t j=0; j&lt; theLine.length(); ++j)
  {
    theLine[j] = tolower(theLine[j]);
  }
  std::cout&lt;&lt;theLine&lt;&lt;std::endl;
     } 

 return 0;
}
</code></pre>
",0
9199630,9199575,3,"<p>I don't think you've shown the real code causing the error.  (For one thing, the alleged code has <code>Obectx</code> and the error says <code>Objectx</code>)</p>

<p>That error would occur if you passed a temporary value (rvalue), because an non-<code>const</code> reference cannot bind to an rvalue.</p>

<p>If the function doesn't change its parameter, change the signature to:</p>

<pre><code>void function(const Objectx &amp;x);
</code></pre>

<p>If the function does change its parameter, you will need to store the temporary value to a variable, and pass the variable.  That way any changes made by the function end up in a variable you can access after the call.</p>
",4
14165055,14165038,2,"<p>Why are you casting? </p>

<p>The address of the first <code>char *</code> element is automatically a <code>char **</code>, no need for casting. If this is not working, post the definition of <code>progList</code>. If the vector is empty, this will result in undefined behavior and likely lead your application to crash. Be sure that <code>list.size()</code> is greater than 0 (or <code>!list.emty()</code> - better).</p>
",3
14165132,14165038,3,"<p>You can access <code>char**</code> like so (but only if your compiler supports <a href=""http://en.wikipedia.org/wiki/C%2B%2B11"" rel=""nofollow"">C++11</a>):</p>

<pre><code>    progList = list.data();
</code></pre>
",0
14165786,14165038,1,"<p>This:</p>

<pre><code> progList = &amp;list[0];
</code></pre>

<p>Should work perfectly.</p>

<p>But because:</p>

<pre><code>std::vector&lt;char*&gt; list;
</code></pre>

<p>is local to the function it is only valid while the function is active. Once the function returns the pointer become invalid (as the vector no longer exists).</p>

<p>The reason I mention this is that you seem to be trying to use <code>progList</code> as an out parameters here:</p>

<pre><code>int glfxGetProgramList(int effect, char** progList, int* count)


// Because you call like this:  
glfxGetProgramList(effect, list, &amp;size );  // The value of list will not change
                                           // as you are passing by value.

fprintf(stderr, ""Output: %s\n"", list[0]);  // So here list has not changed.
                                           // But also note it would not have worked
                                           // as the object you were trying to make it 
                                           // point at would have gone out of scope.
</code></pre>

<p>Unfortunately (or fortunately) because these parameters are not references any changes you make locally do not affect the original values outside the function.</p>

<p>So you need to fix a couple of things:</p>

<ul>
<li>Make the vector last longer than the call to the function</li>
<li>Pass list by reference into the function.</li>
</ul>

<p>Try:</p>

<pre><code>int glfxGetProgramList(int effect, char**&amp; progList, int* count)
                               //        ^  pass by reference
{
    static std::vector&lt;char*&gt; list; // Static makes the list last past the end of the function
    list.clear();                   // Now we have to clear it each time we call to make sure
                                    // that old results do not pollute the list.

    gEffects[effect]-&gt;GetProgramList(list);
    fprintf(stderr, ""Lib Output: %s\n"", list[0]);

    progList = &amp;list[0];       // Value now passed correctly
                               // back to the calling function
                               // and list will still exist.

    int size = list.size();
    memcpy(count, &amp;size, sizeof(int));  // This copies the first value out
}
</code></pre>
",4
9164350,9164316,6,"<p>By default, <code>wait</code> and friends wait until a process has exited, then reap it. You can call <code>waitpid</code> with the <code>WNOHANG</code> to return immediately if no child has exited.</p>

<p>The defunct/""zombie"" process will sit around until you <code>wait</code> on it. So if you run it in the background, you must arrange to reap it eventually by any of several ways:</p>

<ul>
<li>try <code>waitpid</code> with <code>WNOHANG</code> routinely: <code>int pid = waitpid(-1, &amp;status, WNOHANG)</code></li>
<li>install a signal handler for <code>SIGCHLD</code> to be notified when it exits</li>
</ul>

<p>Additionally, under POSIX.1-2001, you can use <code>sigaction</code> set the <code>SA_NOCLDWAIT</code> on <code>SIGCHLD</code>. Or set its action to <code>SIG_IGN</code>. Older systems (including Linux 2.4.x, but not 2.6.x or 3.x) don't support this.</p>

<p>Check your system manpages, or alternative the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html"" rel=""nofollow"">wait in the Single Unix Specification</a>. The Single Unix Spec also gives some helpful code examples. <code>SA_NOCLDWAIT</code> is documented in <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaction.html"" rel=""nofollow"">sigaction</a>.</p>
",1
9164462,9164316,0,"<p>I think a signal handler would be the best way as indicated. I would like to point out another way this could be handled: Fork twice and have the child exit while the grandchild would call <code>execl</code>. The defunct process would then be cleaned up by the init process.</p>
",2
8790338,8790291,1,"<p>identifier() is a method/function call</p>

<p>identifier[i] returns the i'th element in an array.</p>

<p>identifier()[i] returns the i'th element of the array returned by identifier()</p>
",0
8790358,8790291,3,"<p>1)</p>

<pre><code>ImageSamples = rMrProt.kSpace().baseResolution()
</code></pre>

<p>This is just method chaining. You call the method <code>kSpace()</code> on <code>rMrPrto</code> which returns an object, and you call <code>baseResolution()</code> on that object.</p>

<p>2) Those are binary files. What would you expect to see? To read them you'd have to be an expert in asm or at least know some low-level concepts.</p>

<p>3) <code>__IMP_EXP</code> is a common type of directive that tells the compiler that the class is either exported or imported.</p>

<p>It expands to <code>_declspec(dllimport)</code> or <code>_declspec(dllexport)</code>, depending on whether the definition of the class is in the current module or another module.</p>
",0
8790359,8790291,5,"<p>Problem 1.</p>

<pre><code>rMrProt.sliceSeries()[0].readoutFOV()
</code></pre>

<p>means</p>

<ul>
<li>Take <code>rMrProt</code>'s <code>sliceSeries</code> member and call that. Apparently, it returns an array-like object, something that can be indexed.</li>
<li>From the result, take the first element (<code>[0]</code>). That's some kind of object.</li>
<li>On that element/object, call <code>readoutFOV</code>.</li>
</ul>

<p>Problem 2. You're not really supposed to read binary files. There should be documentation with them.</p>
",4
8790380,8790291,1,"<p>I can only help on problem 1:</p>

<p>if the return value of <code>rMrProt.kSpace()</code> is a struct. instead of saving it to a struct and then access it's member you can directly access a member of his with <code>rMrProt.kSpace().MemberName</code></p>

<p>same for <code>rMrProt.sliceSeries()</code> which I guess is returning an array. so <code>rMrProt.sliceSeries()[0]</code> will access the first value in the returning array.</p>
",0
8793909,8793869,4,"<p>It's better to pass them as parameters, as they don't really represent class state and storing them as members will probably be more performance costly than simply continuing to pass around the references.</p>

<p>But it doesn't really look like your class has any state at all, which leads me to believe <em>all</em> of these methods should be free-functions in a suitable namespace rather than members of a class (perhaps you come from a Java background?).</p>
",3
8793919,8793869,2,"<p>I prefer passing the parameter to the private functions. As far as your class may be access by multiple concurrent threads, it is better to send each data to its related function. </p>
",0
8793955,8793869,0,"<p>You should pass the arguments directly to your other methods. Even if other functions used them it would be very confusing because nothing in the function signature indicates that those arguments would be kept around.</p>

<p>If you need some of these parameters in other functions and those parameters remain the same through several calls, you could refactor your class. It would take the ones which stay the same in the constructor and then function calls just pass in the ones which will change. It really depends on the needs of your application to determine whether this is a better approach.</p>
",0
11144968,11144949,5,"<p>Make a forward declaration before Object:</p>

<pre><code>class World; //Now you can use pointers and references to World
class Object {
public:
World * Parent_World; //This here
Object(World * Parent_World=NULL) : Parent_World(Parent_World) {}
};

class World {
public:
Object * Objects = new Object[100];
}
</code></pre>

<p>Making a forward declaration gives a compiler enough information to deal with pointers and references to the type being declared</p>
",0
11144974,11144949,0,"<p>forward declare your class like this:</p>

<pre><code>   class World;
</code></pre>

<p>This works if you only use pointers to World until the World class is defined.</p>
",1
11144988,11144949,0,"<p>Simply put</p>

<pre><code>class World;
</code></pre>

<p>before</p>

<pre><code>class Object { ... }
</code></pre>

<p>This is called <a href=""http://www.adp-gmbh.ch/cpp/forward_decl.html"" rel=""nofollow"">forward declaration</a>.</p>
",0
11144994,11144949,1,"<p>Andrew's <a href=""https://stackoverflow.com/a/11144968/383402"">answer</a> has it right: you need a forward declaration.</p>

<p>It's worth noting, however, that you can't use a forward declaration when the compiler must know the size of the object. That means your <code>World*</code> member will work, but a <code>World</code> member would not.</p>
",0
9859631,9859608,2,"<p>You could say <code>f(static_cast&lt;const int &amp;&gt;(a)&gt;)</code> to force the use of the <code>int</code> overload. The non-const overloads cannot be disambiguated by argument, but you could cast the function itself:</p>

<pre><code>static_cast&lt;void(&amp;)(int&amp;)&gt;(f)(a);
</code></pre>

<p>(Of course you can always select a specific overload manually like this, so this isn't really ""overload resolution"" any more.)</p>
",0
9859647,9859608,2,"<p>You can do something like this:</p>

<pre><code>int main() 
{ 
    int a = 42;
    void (*fp)(int&amp;) = &amp;f; // (A)
    fp(a);
} 
</code></pre>

<p>Here, we're taking a function pointer to one of the overloaded functions <code>f</code>. As <a href=""https://stackoverflow.com/questions/2942426/how-to-specify-a-pointer-to-an-overloaded-function/2942442#2942442"">explained in my answer to another question</a>, the compiler will select the proper function to make line (A) work. Note that I didn't use a cast; that way if I change the function signatures such that the above doesn't work the compiler will issue an error instead of potentially allowing the code to invoke undefined behavior.</p>

<p>Although for this situation, it's better to simply give the two functions different names. Like so:</p>

<pre><code>void take_f(int)    {}
void modify_f(int&amp;) {}

int main() 
{ 
    int a = 42;
    modify_f(a);
}
</code></pre>

<p>This allows for code with a clearer intent and you won't have overloading issues. Of course, you can come up with better names than <code>take_f()</code> and <code>modify_f()</code>.</p>

<p>It makes more sense this way anyway since having one function takie an <code>int</code> and another an <code>int&amp;</code> is probably a good sign that they are doing significantly different things (and thus warrant different function names).</p>
",2
10121783,10121503,0,"<p>Well, you could keep the dirty typecasts at one place, encapsulated in your class. Therefore, it's not really dirty anymore.</p>

<pre><code>class CBaseMember {
public:
    virtual void SomeMemberMethod(){}
};

class CDerivedMember : public CBaseMember {
public:
    virtual void SomeMemberMethod() { /* do other stuff */ }
    virtual void SomeDerivedMethod() {}
};

//declaration
class CBaseClass
{
protected:
    virtual void GenericMethod();
    virtual void VirtualMethod() = 0;

    CBaseMember* member;
    virtual CBaseMember * getMember() {
    return member;
    }
};

//definition
void CBaseClass::GenericMethod()
{
    getMember()-&gt;SomeMemberMethod();
}

//declaration
class CDerivedClass : public CBaseClass
{
protected:
    virtual void VirtualMethod();
    virtual CDerivedMember * getMember() {return static_cast&lt;CDerivedMember *&gt;(member);}
};

//definition
void CDerivedClass::VirtualMethod()
{
    getMember()-&gt;SomeDerivedMethod();
}
</code></pre>

<p>In summary, you do the dirty typecasting inside the <code>getMember()</code> method of the derived class. At that point you should be sure that the type of the member is <code>CDerivedMember</code> anyway. So, as long as you know that the pointer you have is of type <code>CDerivedClass</code> you will have access to its <code>CDerivedMember</code> without typecasting. If you have to fall back to a <code>CBaseClass</code> pointer, you'll naturally fall back to the <code>CBaseMember</code> while accessing its member.</p>
",4
10122224,10121503,0,"<p>I suspect that you want to get rid of the templates, because the snippet you provided would work (if you added the <code>class</code> keyword to the declaration of your types).</p>

<p><strong>If you want to avoid downcasts from <code>CBaseMember*</code> to <code>CDerivedMember*</code>, you can approach the situation with dynamic binding and covariance</strong>:</p>

<pre><code>class CBaseClass {
  private:
    CBaseMember* const baseMember;
  protected:
    virtual CBaseMember* member() const {
    //      ^^^^^^^^^^^
      return baseMember;
    }
    /* everything else you need here. Just never ever access `baseMember` directly */
};
class CDerivedClass : public CBaseClass {
  private:
    CDerivedMember* const derivedMember;
  protected:
    virtual CDerivedMember* member() const {
    //      ^^^^^^^^^^^^^^
      return derivedMember;
    }
    /* everything else you need here. Just never ever access `derivedMember` directly */
};
</code></pre>

<p>However, this only works if you will never change the member to point somewhere else, because you cannot pull this trick with a setter: <code>virtual void CBaseClass::member(CBaseMember*)</code> cannot be overridden with <code>virtual void CDerivedClass::member(CDerivedMember*)</code>.</p>

<p>Note that you will still be carrying the <code>baseMember</code> pointer in your <code>CDerivedClass</code> around, although it is never ever used. So if memory is important to you, this might not be viable.</p>
",0
14183969,14183939,2,"<p>Yes. In C++11, you can do that. It is called <a href=""http://en.wikipedia.org/wiki/C%2B%2B11#Object_construction_improvement"" rel=""nofollow""><strong>constructor delegation</strong></a>.</p>

<pre><code>struct A
{
   A(int a) { /* code */ }

   A() : A(100)  //delegate to the other constructor
   {
   }
};
</code></pre>
",4
14183972,14183939,9,"<p>The term you're looking for is ""<a href=""http://en.wikipedia.org/wiki/C%2B%2B11#Object_construction_improvement""><em>constructor delegation</em></a>"" (or more generally, ""<em>chained constructors</em>"").  Prior to C++11, these didn't exist in C++.  But the syntax is just like invoking a base-class constructor:</p>

<pre><code>class Foo {
public:
    Foo(int x) : Foo() {
        /* Specific construction goes here */
    }
    Foo(string x) : Foo() {
        /* Specific construction goes here */
    }
private:
    Foo() { /* Common construction goes here */ }
};
</code></pre>

<p>If you're not using C++11, the best you can do is define a private helper function to deal with the stuff common to all constructors (although this is annoying for stuff that you'd like to put in the initialization list).  For example:</p>

<pre><code>class Foo {
public:
    Foo(int x) {
        /* Specific construction goes here */
        ctor_helper();
    }
    Foo(string x) {
        /* Specific construction goes here */
        ctor_helper();
    }
private:
    void ctor_helper() { /* Common ""construction"" goes here */ }
};
</code></pre>
",2
8735207,8735131,1,"<p>You can create an array of objects invoking the constructor directly.</p>

<pre><code>movie objs[2] = {movie(arg1, arg2, arg3), movie(arg1, arg2, arg3)};
</code></pre>
",0
8735217,8735131,1,"<p>The standard way to do this is to use a allocator object, like all the standard containers.</p>

<pre><code>template&lt;class T, class alloc_type =std::allocator&lt;T&gt; &gt;
class set {
     typedef alloc_type::pointer pointer; //bring in it's pointer type
     alloc_type alloc;
</code></pre>

<p>And then, use that for everything:</p>

<pre><code>pointer buffer = alloc.allocate(100);
alloc.construct(buffer+0); //deault construct T
alloc.construct(buffer+1, T()); //construct T from copy
alloc.construct(buffer+2, 17); //construct T from 17

alloc.destroy(buffer+2);  //clean up objects
alloc.destroy(buffer+1); 
alloc.destroy(buffer+0); 
alloc.deallocate(buffer); //clean up buffer
</code></pre>

<p>Remember, it's standard to construct from lowest index to highest, and to destroy in the reverse order.</p>

<p>The ""correct"" way to do this has changed with C++11, but since I use MSVC10, which <em>can't</em> do the correct way, I still use this way.</p>

<p>Basic implementations of each of these functions is rediculously simple, though.</p>

<pre><code>template&lt;class T&gt;
class myallocator {
public:
    typedef T value_type;
    typedef T* pointer;
    typedef T&amp; reference;
    typedef const T* const_pointer;
    typedef const T&amp; const_reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;

    myallocator () throw() {}
    template &lt;class U&gt; myallocator (const myallocator&lt;U&gt;&amp;) throw() {}
    pointer address (reference x) const {return &amp;x;}
    const_pointer address (const_reference x) const {return &amp;x;}
    size_type max_size() const throw() {return size_type(-1);}

pointer allocate(size_type c,const_pointer h=0){return(T*)new char[sizeof(T)*c];}
    void deallocate(pointer ptr, size_type c) {delete [] ptr;}
    pointer construct(pointer ptr) {return new(ptr)T;}
    template&lt;class U&gt;
    pointer construct(pointer ptr, const U&amp; from) {return new(ptr)T(from);}
    void destroy(pointer ptr) {ptr-&gt;~T();}
};
</code></pre>

<p>The two <code>construct</code> members use what is called ""placement new"" which creates the object in an already existing space.  Here, an array of <code>char</code>s.</p>
",2
8735224,8735131,2,"<p>Don't use built-in arrays, especially if you are new. Built-in arrays are best left to experts and even then they are often best avoided. Instead of using <code>T[n]</code> just use <code>std::vector&lt;T&gt;</code>. This one will start out empty an you can then e.g. <code>push_back()</code> the objects you are interested in.</p>

<p>That said, I don't see where you code excerpt actually has a problem.</p>
",0
8735458,8735131,0,"<p>You are trying to write your own container class, and you should not call it <code>set</code>. I will assume that you are calling it <code>my_set</code> in this answer.</p>

<p>I think this is the line you are interested in. You wish to pass in a default value here:</p>

<pre><code>my_set&lt;t&gt;::my_set(int b, t default_value)
//creates a my_set with 'b' elements, where each element is set to default_value
</code></pre>

<p>Is this your goal? If so, it's easier to define <code>niz</code> as a <code>*vector&lt;t&gt;</code> instead of as <code>t*</code></p>

<pre><code>template&lt;class t&gt;
struct my_set {
    int br;
    vector&lt;t&gt; *niz;
    my_set(int b, const t&amp; default_value);
}

template&lt;class t&gt;
my_set&lt;t&gt;::my_set(int b, const t&amp; default_value) {
//creates a my_set with 'b' elements, where each element is set to 0
    this-&gt;br=b;
    this-&gt;niz=new vector&lt;t&gt;(b, default_value);
}
</code></pre>

<p>There are other changes you may consider, such as defining niz simply as <code>vector&lt;t&gt;</code>, not as <code>vector&lt;t&gt;*</code>, but I think that's beyond the scope of you original question.</p>

<p>Finally, I have a question of my own for everybody. How can I do an uninitialized array <code>new[]</code> in C++? I'd like to <code>new</code> an array of known size, but with unconstructed data, and then use something like uninitialized_copy to copy data in.</p>
",0
8735477,8735131,0,"<p>The expression <code>new T[n]</code> will always allocate space for <em>n</em> <code>T</code> objects and call the <code>T</code> constructor on each element. Similarly, <code>delete[] niz</code>, will always call the <code>T</code> destructor on each element. It seems that you want to manually control when the <code>T</code> constructor and destructor are called, so rather than using <code>::operator new[]</code>, you could just use <code>::operator new</code> and its placement syntax.</p>

<p>You want <code>niz</code> to be an array of <code>br</code> <code>T</code> objects. Instead of this:</p>

<pre><code>niz = new T[br];
</code></pre>

<p>You can use this:</p>

<pre><code>niz = static_cast&lt;T *&gt;(::operator new(br * (sizeof (T))));
</code></pre>

<p>which will allocate space in the heap for <code>br</code> contiguous <code>T</code> objects, but not call the <code>T</code> constructor on any of them. It's basically like using <code>malloc()</code> to allocate space for the <code>T</code> objects.</p>

<p>But, now you have a problem: how do you actually use one of the <code>T</code> objects? Before you can do anything with <code>niz[i]</code>, you need to make sure that the <em>i</em><sup>th</sup> <code>T</code> object has been constructed. You can use placement new to construct it:</p>

<pre><code>new(niz + i) T();
</code></pre>

<p>Notice that <code>niz + i</code> is the pointer to the <em>i</em><sup>th</sup> <code>T</code> object. The effect of this statement is that the <code>T</code> constructor is called in place using the space at <code>reinterpret_cast&lt;char *&gt;(niz + i)</code> through <code>reinterpret_cast&lt;char *&gt;(niz + i) + (sizeof (T))</code>.</p>

<p>Now you have another problem: how do you keep track of which <code>T</code> objects have been constructed? You need to know this in order to call the destructor on the ones that have been constructed, or else you might leak memory.</p>

<p>One solution is to use a <code>std::vector&lt;bool&gt;</code> having <code>br</code> <code>bool</code> objects. If the <em>i</em><sup>th</sup> <code>bool</code> is <code>true</code>, then you will know that the <em>i</em><sup>th</sup> <code>T</code> object was constructed. Otherwise, it needs to be constructed.</p>

<p>In the <code>set&lt;T&gt;</code> destructor, you need to make sure to destroy all <code>T</code> objects that have been constructed. Suppose that the <em>i</em><sup>th</sup> <code>T</code> object has been constructed. To call the <code>T</code> destructor on the <em>i</em><sup>th</sup> <code>T</code> object, you can use this statement:</p>

<pre><code>(niz + i)-&gt;~T();
</code></pre>

<p>Putting it all together, you would get something like this:</p>

<pre><code>#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
class set
{
    std::size_t br;
    T *niz;
    std::vector&lt;bool&gt; constructed;

public:
    std::string name;

    set()
        : br(0), niz(NULL), constructed()
    {
    }

    set(std::size_t br)
        : br(br), niz(NULL), constructed(br, false)
    {
        niz = static_cast&lt;T *&gt;(::operator new(br * (sizeof (T))));
    }

    void destroy()
    {
        std::cout &lt;&lt; ""~set("" &lt;&lt; name &lt;&lt; "")\n"";

        if (niz) {
            std::vector&lt;bool&gt;::const_iterator begin = constructed.begin(), it, end = constructed.end();
            for (it = constructed.begin(); it != end; ++it) {
                if (*it) {
                    (niz + (it - begin))-&gt;~T();
                }
            }
            ::operator delete(niz);
        }
    }

    ~set()
    {
        destroy();
    }

    set&lt;T&gt;&amp; operator=(const set&lt;T&gt;&amp; other)
    {
        if (this != &amp;other) {
            destroy();
            niz = NULL;

            constructed = std::vector&lt;bool&gt;(other.br, false);
            br = other.br;
            T *tmp = static_cast&lt;T *&gt;(::operator new(other.br * (sizeof (T))));
            try {
                std::size_t i;
                for (i = 0; i &lt; other.br; ++i) {
                    if (other.constructed[i]) {
                        new(tmp + i) T(other.niz[i]);
                        constructed[i] = true;
                    }
                }
            } catch (...) {
                niz = tmp;
                destroy();
                throw;
            }
            niz = tmp;
            name = other.name + "" (2)"";
        }
        return *this;
    }

    T&amp; operator[](std::size_t i)
    {
        if (niz &amp;&amp; !constructed[i]) {
            new(niz + i) T();
            constructed[i] = true;
        }
        return niz[i];
    }
};

struct my_struct
{
    char c;

    my_struct(char c = 'a')
        : c(c)
    {
        std::cout &lt;&lt; ""my_struct('"" &lt;&lt; c &lt;&lt; ""')\n"";
    }

    ~my_struct()
    {
        std::cout &lt;&lt; ""~my_struct('"" &lt;&lt; c &lt;&lt; ""')\n"";
    }
};

int main()
{
    ::set&lt;char&gt; a, a2(3);
    a.name = ""a"";
    a2.name = ""a2"";

    {
        ::set&lt;my_struct&gt; b(3);
        b.name = ""b"";
        b[0].c = '1';
        b[2].c = '3';
        b[1].c = '2';

        ::set&lt;my_struct&gt; b2(4);
        b2.name = ""b2"";
        b = b2; b.name += "", going by the name 'b'"";

        b[0].c = 'A';
        b2[1].c = 'B';
    }
}
</code></pre>

<p>Note: I do not recommend actually using this code. The point is to learn about the placement new operator and explicitly invoking a destructor through a pointer.</p>

<p>See STL templates <code>vector</code> and <code>set</code> for standard alternatives.</p>
",0
8735753,8735131,0,"<p>One of the problems in your code is that this will fail if either string is <code>0</code></p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; izlaz,movie&amp; film)
{
    izlaz
        &lt;&lt; endl &lt;&lt; film.naziv // fails if film.naziv == 0
        &lt;&lt; endl &lt;&lt; film.reditelj  // fails if film.reditelj == 0
        &lt;&lt; endl &lt;&lt; film.trajanje &lt;&lt; endl;
    return izlaz;
}
</code></pre>

<p>That crashes for me. You should not do <code>cout &lt;&lt; (char*)0;</code>. It's better to do something like <code>cout &lt;&lt; """"</code>. You could fix it by changing the constructor of movie:</p>

<pre><code>movie::movie()
{
    this-&gt;naziv="""";    // an empty, non-null, string
    this-&gt;reditelj=""""; // an empty, non-null, string
    this-&gt;trajanje=0;
}
</code></pre>

<p>But a better solution is to stop using <code>char *</code> and use <code>std :: string</code> instead.</p>
",0
13444817,13444807,5,"<p>Store the birth date rather than the age, then calculate the age when you need it.</p>

<p>Just like someone said the last time you asked this question. Please don't ask the same question twice.</p>
",2
18316585,18316388,2,"<p>A simple solution, not necessarily the best. Make your grid of a struct instead of an int. This struct contains a flag for whether a ship is present, the ID of a ship there, (this lets you tell them apart; if no ship is present the value shouldn't be used) and a separate flag for whether the cell has been hit. Now make an array for each ship ID in your game, which contains the number of cells that make up your ship. So [0] -> 3, means ship ID 0 takes up 3 squares. Whenever a new hit is registered against a cell containing this ship ID, decrease the value in the array. When it is 0, you know the whole ship has been hit.</p>
",0
18316606,18316388,1,"<p>I suggest you make your grid cells have information, such as a pointer to the ship at that location.  </p>

<p>Another idea is to have a container of ships and each ship will contain the coordinates of each of it's cells (locations).  The ship would contain the status of those cells (visible, hit, sunk, etc.).  </p>
",0
18316660,18316388,2,"<p>You need to either store the coordinates of the ships in another data structure (so you can find the ship from a hit, and then mark all its squares as sunk) or make your matrix store more complex data (a ship ID) so you can mark all cases for that ship as sunk.</p>

<p>The latter would give you data such as:</p>

<pre><code>const unsigned int empty = 0x0000;
const unsigned int shipIdMask = 0x00FF;
const unsigned int hitFlag = 0x0100;
const unsigned int sunkFlag = 0x0200;
</code></pre>

<p>Display-wise, you just do a <code>if((value &amp; shipIdMask) != 0)</code> to check if there is a ship in there, and you check hits likewise. When a ship is hit, you can go the lazy way and simply sweep the entire matrix for squares with the same ship ID. If all of them are hit, you sweep them again and mark them all as sunk.</p>

<p>Both techniques can be combined if you don't want to sweep the whole matrix each time (use the ship ID to get the ship's actual coordinates in an array).</p>
",0
18316635,18316388,2,"<p>Maybe you could consider a <a href=""http://en.wikipedia.org/wiki/Bitboard"" rel=""nofollow"">bitboard</a> representation of the board. Typically I've seen it used for chess, but since your board has 64 squares it seems appropriate here as well. The basic idea is that each location on the grid is represented by exactly one bit in a 64 bit int. Then operations can be performed quickly and easily via bit manipulation. In that type of representation, you would determine if a ship is sunk via something like this:</p>

<pre><code>bool is_sunk(uint64_t board, uint64_t ship) {
    return board &amp; ship == ship;
}
</code></pre>

<p>And other operations, are equally easy.</p>

<p>For example, is a ship hit?</p>

<pre><code>bool is_hit(uint64_t board, uint64_t ship) {
    return board &amp; ship != 0;
}
</code></pre>

<p>Did I win the game?</p>

<pre><code>bool is_won(uint64_t board, uint64_t* ships, int size) {
    uint64_6 opponents_ships = 0;
    for (int i = 0; i &lt; size; i++) opponents_ships |= *ships;
    return is_sunk(board, opponents_ships); 
}
</code></pre>

<p>Apply a move to the board:</p>

<pre><code>bool make_move(uint64_t&amp; board, uint64_t move) {
    board &amp;= move;
}
</code></pre>
",3
10024812,10024796,48,"<p>You need to also define the virtual destructor, not only add it.</p>

<pre><code>//Media.h
class Media{
    //....
    virtual ~Media() = 0;
};

//Media.cpp
#include ""Media.h""
//....
Media::~Media() {};
</code></pre>

<p>The reason you get the warnings is that all classes that will be derived from should have a virtual or protected (credit @Steve) destructor, otherwise deleting an instance via a pointer to a base class results in undefined behavior.</p>

<p><strong>Note</strong> you HAVE TO provide a definition for destructors, even if they are pure virtual.</p>
",5
10024831,10024796,6,"<p>You should implement the virtual destructor, not make it pure virtual.</p>

<p>Look at <a href=""https://stackoverflow.com/questions/630950/pure-virtual-destructor-in-c"">this</a> similar question (identical maybe from the point of view of the virtual destructor error, not the warning) for more info.</p>

<p>EDIT: more generic solution, in reply to LuchianGrigore's comment (thank you for pointing it out)</p>

<p>You can also make the destructor pure virtual and implement as it is pointed in the above mentioned question. </p>

<p>The use of virtual destructors in you classes should be to prevent instantiation of the base class (i.e. when you have no other pure virtual methods to make the class abstract).</p>
",2
10024842,10024796,9,"<p>What you have commented out is a pure-virtual declaration for a destructor. That means the function must be overridden in a derived class to be able to instantiate an object of that class.</p>
<p>What you want is just a definition of the destructor as a virtual function:</p>
<pre class=""lang-cpp prettyprint-override""><code>virtual ~Media() {}
</code></pre>
<p>In C++ 11 or newer, it's generally preferable to define this as defaulted instead of using an empty body:</p>
<pre class=""lang-cpp prettyprint-override""><code>virtual ~Media() = default;
</code></pre>
",0
10024868,10024796,0,"<p>Uncomment declaration first and then
Try adding following line after class declaration</p>

<pre><code>Media::~Media(){}
</code></pre>
",4
10026522,10024796,24,"<blockquote>
  <p>The thing is: without the destructor, GCC gives me a bunch of warnings ""class has virtual functions but non-virtual destructor"", but still compiles and <strong>my program works fine</strong></p>
</blockquote>

<p>This is an annoying warning in Modern C++, but in old object-style C++ it is generally correct.</p>

<p>The problem is about the way your objects are destructed. A simple test:</p>

<pre><code>#include &lt;iostream&gt;

class Base {};
class Derived: public Base { public: ~Derived() { std::cout &lt;&lt; ""Aargh\n""; } };

int main() {
  Base* b = new Derived();
  Derived* d = new Derived();

  delete d;
  delete b;
}
</code></pre>

<p>This prints:</p>

<pre><code>Aargh
</code></pre>

<p>Yep, only once.</p>

<p>The problem is that when you call <code>delete</code> on a variable of type <code>Base*</code>, the <code>Base::~Base()</code> method is called. If it is <code>virtual</code>, then the call is dynamically dispatched to the final method (based on the dynamic type), in this case <code>Derived::~Derived()</code>, but if it is not, then <code>Derived::~Derived()</code> is never called, thus never executed.</p>

<p>Therefore, if you wish to call <code>delete</code> (or use smart pointers which do it for you) on base types, then you need to add <code>virtual ~Base() {}</code> in their class definitions. This is why gcc warns you when you create a polymorphic class without a <code>virtual</code> destructor.</p>

<hr>

<p><em>Note: time changed, and since then I implemented <code>-Wdelete-non-virtual-dtor</code> in Clang and it was replicated in gcc as well.</em></p>

<p><em><code>-Wnon-virtual-dtor</code> is useful for library writers (as it warns on the base class), but may have a higher false positive rate; on the other hand <a href=""https://gcc.gnu.org/wiki/VerboseDiagnostics#delete-non-virtual-dtor"" rel=""noreferrer""><code>-Wdelete-non-virtual-dtor</code></a> fires at the call site, and has a much lower false positive rates (which you can generally work around by peppering <code>final</code> to remove the ""polymorphic"" property of the class).</em></p>
",1
9147182,9147101,9,"<p>You're almost certainly referring to type fields as discussed in the book <a href=""https://rads.stackoverflow.com/amzn/click/com/0201889544"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">The C++ Programming Language</a> by Bjarne Stroustrup. A type field in this context would simply be a variable of some kind in a base class that indicates the actual type of its subclasses. Here's an example:</p>

<pre><code>class Pet
{
public:
    enum PetType { Dog, Cat, Bird, Fish };

    void ToString()
    {
        switch(type)
        {
        case Pet::Dog: std::cout &lt;&lt; ""Dog"" &lt;&lt; std::endl; break;
        case Pet::Cat: std::cout &lt;&lt; ""Cat"" &lt;&lt; std::endl; break;
        case Pet::Bird: std::cout &lt;&lt; ""Bird"" &lt;&lt; std::endl; break;
        case Pet::Fish: std::cout &lt;&lt; ""Fish"" &lt;&lt; std::endl; break;
        }
    }

private:
    PetType type; // A type field.
};

class Dog : public Pet
{
public:
    Dog() { type = Dog; }
};

// And so on...

void Test(const Pet&amp; p) { p.ToString(); }
int main()
{
    Dog d;
    Test(d);
    return 0;
}
</code></pre>

<p>This is an extraordinarily brittle way to implement a <code>ToString()</code> method. Every time you need to add a derived class of <code>Pet</code>, you would need to update the <code>PetType</code> enumeration and the <code>ToString()</code> method. For example, if I need a <code>Turtle</code> subclass, I would need to make these changes:</p>

<pre><code>// ...
enum PetType { Dog, Cat, Bird, Fish, Tutle /* Added */};
void ToString(const Pet&amp; p)
{
    switch(p.type)
    {
    case Pet::Dog: std::cout &lt;&lt; ""Dog"" &lt;&lt; std::endl; break;
    case Pet::Cat: std::cout &lt;&lt; ""Cat"" &lt;&lt; std::endl; break;
    case Pet::Bird: std::cout &lt;&lt; ""Bird"" &lt;&lt; std::endl; break;
    case Pet::Fish: std::cout &lt;&lt; ""Fish"" &lt;&lt; std::endl; break;
    case Pet::Turtle: std::cout &lt;&lt; ""Turtle"" &lt;&lt; std::endl; break; // Added
    }
}
// ...
class Turtle : public Pet
{
public:
    Turtle() { type = Turtle; } // Added
};
</code></pre>

<p>Imagine if the <code>Pet</code> class had more functions than just <code>ToString()</code>; maintenence becomes a nightmare. It's lot of code one needs to change, but the important thing is that in order to have a <code>Turtle</code> class, I need to modify the <code>Pet</code> class. That means more testing, code review, etc. is needed. It's a clear violation of <a href=""http://en.wikipedia.org/wiki/Open/closed_principle"" rel=""nofollow noreferrer"">the open/closed principle</a>. That's why type fields are extremely error-prone.</p>

<p>A significantly superior way would be to use <code>virtual</code> functions:</p>

<pre><code>class Pet
{
public:
    virtual void ToString() = 0;
};

class Dog : public Pet
{
public:
    virtual void ToString() { std::cout &lt;&lt; ""Dog"" &lt;&lt; std::endl; }
};

class Turtle : public Pet
{
public:
    virtual void ToString() { std::cout &lt;&lt; ""Turtle"" &lt;&lt; std::endl; }
};

// And so on...

void Test(const Pet&amp; p) { p.ToString(); }
int main()
{
    Turtle t
    // Will call Turtle::ToString(), even though
    // Test() was only given a const Pet&amp;
    Test(t); 
    return 0;
}
</code></pre>

<p>Note that the above code requires no extra <code>enum</code>s or <code>switch</code> statements. Calling <code>Pet::ToString()</code> will call the correct implementation of <code>ToString()</code> for <code>Dog</code>s, <code>Cat</code>s, etc. automatically, with much less code. I don't even need to change the <code>Pet</code> class; I can just drop in a <code>Turtle</code> class if needed, provided that <code>Pet</code> has been defined.</p>

<hr>

<p>For a possibly legitimate use of type fields, <a href=""https://stackoverflow.com/questions/3808220/are-type-fields-pure-evil"">see this Stack Overflow question and the answers to that question</a>.</p>
",1
9790242,9790200,5,"<p>You should write that as:</p>

<pre><code>Example::ValueType Example::returnMyType(const ValueType p_valueType)
{
     //...
}
</code></pre>

<p>That is, you've to use <code>Example::ValueType</code> from outside the class, when defining members functions and from the member functions.</p>

<p>--</p>

<p>From your comment: </p>

<blockquote>
  <p>I see, it the enum were public would this also be the case? </p>
</blockquote>

<p>Yes. It doesn't matter if it is <code>public</code> or <code>private</code>. </p>

<p>Accessibility (<em>public</em>, <em>protected</em> and <em>private</em>) only determines <strong>who</strong> is allowed to access, it doesn't determine <strong>how</strong> to access.</p>
",2
14151060,14151048,6,"<p>Outside a function, you can only put declarations/definitions. To just execute something like <code>he.h();</code>, that code needs to go in a function.</p>
",0
14151099,14151048,5,"<p>On the uppermost level, each C++ translation unit must consist of declarations</p>

<pre><code>translation-unit: 
  declaration-seq[opt]

declaration-seq:
  declaration
  declaration-seq declaration
</code></pre>

<p>Bur <code>he.h();</code> is not a declaration. Hence the error.</p>

<p>You can introduce a dummy variable to turn it into a declaration</p>

<pre><code>int dummy = he.h();
</code></pre>

<p>and the code will compile. But the original version is illegal.</p>
",0
9229056,9226878,1,"<p>I've experienced driver crashes myself (had some fancy shader code running out of memory..). I can confirm that at least Windows 7 tries to restart drivers after crash by itself - usually it takes ~10 seconds. Anyway I have such experience only whit NVIDIA cards (last ATI I had froze whole system whit weird short sound loop on failure) and this will be more problematic for other OS too. In case you can live with some openGL 2.x, I think best choice would be virtual OS.. easy to reboot in case of failure, fast and fresh.</p>

<p>But to stay in topic, I believe this article is way to go for if you have Windows OS: <a href=""http://www.codeproject.com/Articles/31905/A-C-class-wrapper-to-load-unload-device-drivers"" rel=""nofollow"">A C++ class wrapper to load/unload device drivers</a>. I don't see problem in shutting down and loading driver back (== restore) anyway, but in detecting crashed driver and meddling whit it while OS might be trying to restore it or when OS gets stuck..</p>
",0
11815261,11815182,0,"<p>Your loop goes for as long as x > rows? And then you are incrementing? I think this might run for ever...or for as long as you don't pass the maximal int value</p>

<p>Also, your push_back takes an int as argument and there is no constructor for string that takes an int value as argument. The overloaded function error might result from that?</p>
",1
13756184,13756078,2,"<p>No other <code>int</code> data member of this object, and no <code>mBlacks</code> member of a different instance of <code>SomeClass</code> in the same process, has the same address as the <code>mBlacks</code> member of this instance of <code>SomeClass</code>. So you're safe to use it as a unique ID within the process.</p>

<p>An empty base class subobject of <code>SomeClass</code> could have the same address as <code>mBlacks</code> (if <code>SomeClass</code> had any empty base classes, which it doesn't), and the <code>char</code> object that's the first byte of <code>mBlacks</code> has the same address as <code>mBlacks</code>. Aside from that, no other object has the same address.</p>

<p><code>void*</code> will work as the type. <code>int*</code> will work too, but maybe you want to use data members with different types for different ids.</p>

<p>However, the ID is unique to this instance. A different instance of the same type has a different ID. One of your comments suggests that this isn't actually what you want.</p>

<p>If you want each <em>value</em> of the type to have a unique ID, and for all objects that have the same value to have the same ID, then you'd be better of composing the ID from all of the significant fields of the object. Or just compare objects for equality instead of their IDs, with a suitable <code>operator==</code> and <code>operator!=</code>.</p>

<p>Alternatively if you want the ID to uniquely identify when a value was first constructed <em>other than</em> by copy constructors and copy assignment (so that all objects that are copies of the same ""original"" share an ID), then the way to do that would be to assign a new unique ID in all the other constructors, store it in a data member, and copy it in the copy constructor and copy assignment operator.</p>

<p>The canonical way to get a new ID is to have a global[<code>*</code>] counter that you increment each time you take a value. This may need to be made thread-safe depending what programs use the class (and how they use it). Values then will be unique within a given run of the program, provided that the counter is of a large enough type.</p>

<p>Another way is to generate a 128 bit random number. It's not theoretically satisfying, but assuming a decent source of randomness the chance of a collision is no larger than the chance of your program failing for some unavoidable reason like cosmic ray-induced data corruption. Random IDs are easier than sequential IDs when the sources of objects are widely distributed (for example if you need IDs that are unique across different processes or different machines). You can if you choose use some combination of the MAC address of the machine, a random number, the time, a per-process global[<code>*</code>] counter, the PID and anything else you think of and lay your hands on (or <a href=""https://en.wikipedia.org/wiki/Universally_unique_identifier"" rel=""nofollow"">a standard UUID</a>). But this might be overkill for your needs.</p>

<p>[<code>*</code>] needn't strictly be global - it can be a private static data member of the class, or a static local variable of a function.</p>
",1
11557032,11557020,1,"<p>You're defining a free function:</p>

<pre><code>ConnectFile* ReadConnectFile(ConnectFile *ConnectStruct)
</code></pre>

<p>not a member:</p>

<pre><code>ConnectFile* FileManager::ReadConnectFile(ConnectFile *ConnectStruct)
</code></pre>

<p>Totally different.</p>

<p>Also:</p>

<pre><code>using namespace FileManager;
</code></pre>

<p>and</p>

<blockquote>
  <p>error LNK2019: unresolved external symbol ""struct FileManager::ConnectFile [...]</p>
</blockquote>

<p>suggests you have a <code>namespace FileManager</code> and a <code>struct FileManager</code>... any reason for using the same name?</p>
",2
11557339,11557020,0,"<p>i fixed it by declaring the function out of the namespace:</p>

<pre><code>namespace FileManager
{
    struct ConnectFile
    {
        const char* GS_IP;
        unsigned int GS_Port;
    };
}

using namespace FileManager;
ConnectFile* ReadConnectFile(ConnectFile *ConnectStruct);
</code></pre>

<p>The IDE is VC11 Beta, thanks for the answers.</p>
",0
11560462,11557020,0,"<p>The code</p>

<p><code>using namespace FileManager;<br>
ConnectFile* ReadConnectFile(ConnectFile *ConnectStruct)<br>
{ ...some definition...}</code></p>

<p>defines the ReadConnectFile function <strong>not</strong> in the namespace FileManager, but in global namespace.</p>
",0
11812951,11812827,1,"<p>There's no practical way to do this. The problem is that parts of the function may be optimized away or inlined or split into pieces by the compiler. Furthermore, you'll likely have issues with linking, calling conventions, and the like. Finally, the function might depend on global state in which case it won't work anyway.</p>

<p>You're best bet is to define a serialization format that represents a sequence of calls to a particular set of core functions in your applicaton. Or just use a scripting language, which is the same thing except better and done for you. Lua is very light weight to embed.</p>
",1
9773618,9773594,3,"<p>The functions are called <code>findLowest</code> and <code>findHighest</code> respectively. The <code>int</code> is their return type and should not be specified when calling them.</p>

<p>If this is causing you confusion, I'd suggest you find a good beginner-level C++ book and read up on function declaration and calling.</p>
",3
9773682,9773594,1,"<p>The problem is your line:    </p>

<p><code>double total = score1 + score2 + score3 + score4 + score5 - int findLowest(a, b, c, d, e) - intfindHighest(a, b, c, d, e) / 3;</code></p>

<p>you shouldn't include the <code>int</code> identifier inline.  the complier already knows that your function returns an int.  instead write</p>

<p><code>double total = score1 + score2 + score3 + score4 + score5 - findLowest(a, b, c, d, e) - findHighest(a, b, c, d, e) / 3;</code></p>

<p>As someone else pointed out, you might want to cast that to a double.  in which case, you would do that like this.</p>

<p><code>double total = score1 + score2 + score3 + score4 + score5 - (double)findLowest(a, b, c, d, e) - (double)findHighest(a, b, c, d, e) / 3;</code></p>

<p>Still, this won't actually calculate the average, so you should use parenthesis to enforce order or operations.</p>

<p><code>double total = (score1 + score2 + score3 + score4 + score5 - (double)findLowest(a, b, c, d, e) - (double)findHighest(a, b, c, d, e)) / 3;</code></p>
",4
9773694,9773594,0,"<p>Did you want to perform a cast there? That is done with parentheses (double) , and I would assume double is what you would want to cast too, although I am not sure if it is needed there. </p>
",3
9773727,9773594,1,"<p>In addition to the answer provided by Chowlett, you will also want to reconsider your use of the comma operator within findLowest and findHighest.</p>

<p>For example, your line in findHighest</p>

<pre><code>if (score1 &gt; score2, score3, score4, score5)
</code></pre>

<p>is essentially exactly the same as </p>

<pre><code>if (score5)
</code></pre>

<p>which is not what you seem to intend.</p>
",3
9773763,9773594,2,"<p>In addition to your previous answers, your <code>getJudgeData</code> function is very broken. It needs to take a double <em>reference</em>, else you will never modify the original variable and the function is worthless. In addition, you have no protection against a Judge entering a bad score <em>twice</em>.</p>

<pre><code>void getJudgeData(double&amp; score)
{
    cout &lt;&lt; ""Judge, enter the contestant's score: "";
    cin &gt;&gt; score;
    if (score &lt; 0 || score &gt; 10) //validate score between 0-10, else display error msg
    {
        cout &lt;&lt; ""ERROR: Enter a value in the range 0-10: "";
        return getJudgeData(score);
    }
    return;
}
</code></pre>

<p>This simple recursion will protect you from a judge entering bad data every time, and it also will correctly modify the original variable as your code seems to be written expecting it would.</p>
",4
9788586,9788533,12,"<p>such an enum is specifically listed in clause 7 paragraph 3 of the C++ standard as
ill-formed. gcc does not accept it. there was a bug fix for this in gcc: </p>

<p><a href=""http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29018"" rel=""noreferrer"">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29018</a></p>
",2
9788628,9788533,6,"<p>According to the following snippet from the c++ standard we can deduce that it's indeed a valid statement:</p>

<blockquote>
  <p><strong>7.2</strong>/1 <strong>Enumeration declarations</strong> (C++03)<br />...<br />
  enum-specifier:
  <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enum <em>identifier<sub>opt</sub></em> { <em>enumerator-list<sub>opt</sub></em> }</p>
</blockquote>

<p>Note that both the <em>identifier</em> and the <em>enumerator-list</em> are optional, and therefor a statement as <code>enum {}</code> is valid (if you ask the standard).</p>

<hr>

<p><strong>But doesn't the standard also say that empty declarations are ill-formed?</strong></p>

<p>Yes, and there is even an example of <code>enum { };</code> in the below snippet from the standard.</p>

<blockquote>
  <p><strong>7</strong>/3 <strong>Specifiers</strong> (C++03)</p>
  
  <p>In these cases and whenever a class-specifier or enum-specifier is
  present in the decl-specifier-seq, the identifiers in these specifiers
  are among the names being declared by the declaration (as class-
  names, enum-names, or enumerators, depending on the syntax).</p>
  
  <p>In such cases, and except for the declaration of an unnamed bit-field
  (9.6), <strong>the <em>decl-specifier-seq</em> shall introduce one or more names into
  the program, or shall redeclare a name introduced by a previous
  declaration.</strong></p>
  
  <p>*Example?[</p>
</blockquote>

<pre><code> enum { };          // ill-formed
 typedef class { }; // ill-formed
</code></pre>

<blockquote>
  <p>*end example]</p>
</blockquote>

<hr>

<p><strong>Conclusion</strong></p>

<p>The statement seems to be ill-formed after a careful look at the standard, though compilers are written by humans - and humans tend to make mistakes and sometimes overlook things.</p>

<hr>

<p><strong>TL;DR</strong> You should not use an empty declaration such as <code>enum { };</code>, even though it compiles</p>
",5
9842844,9842782,1,"<p>In <code>void H_T()</code> you have:</p>

<pre><code>if ( HT = 'h')
</code></pre>

<p>that assigns the value <code>'h'</code> to <code>HT</code> which will always evaluate to true. You want <code>==</code> instead to test for equality.</p>

<p>Unfortunately you don't keep track of what the user selected anywhere in the code...</p>
",1
9842861,9842782,0,"<p>on first look..</p>

<pre><code>int head_win ()
    {
    int heads=0;
    heads++;
    return heads;
    }
    int tails_win ()
    {
    int tails=0;
    tails++;
    return tails;
    }
</code></pre>

<p>head_win() will return always 1 and tails_win() too..</p>

<pre><code>int head_win();       this doesn t mean nothing..
</code></pre>

<p>you have to declare a variable :</p>

<pre><code>int wins = head_win();
</code></pre>
",3
9842881,9842782,2,"<p>One obvious problem I see is:</p>

<pre><code>void H_T() { 
// ...
} 

// ...
cout &lt;&lt; ""How many times will "" &lt;&lt; H_T() &lt;&lt; ""come up?"";
</code></pre>

<p>This attempts to print out the return value from <code>H_T</code>, but since <code>H_T</code> has void return type, there is no such thing, and compilation will fail.</p>

<p>Glancing through the code, it looks like that's hardly the only one though. I think if I were you, I'd back up and more or less start over. Write little pieces at a time, and verify that each does what you intend before going to the next.</p>
",1
9843028,9842782,0,"<p>The problem is not that this code ""does not run""; it does not even compile. There are many mistakes in your code.</p>

<ol>
<li>In <code>numHT()</code> you are using the result of <code>H_T()</code>; but <code>H_T()</code> returns <code>void</code>.</li>
<li>You are trying to break out of the infinite loop comparing the value of <code>tosses_amount</code> with <code>0</code>; but <code>tosses_amount</code> is assigned the value of <code>tossingtimes()</code> which is always greater than <code>0</code>.</li>
<li>Inside the <code>for</code> loop commented as <code>// random number generator</code> it looks like you are trying to use functions <code>heads_win()</code> and <code>tails_win()</code>; in fact, you are declaring new functions with these names.</li>
<li>You are never actually trying to compare the number of heads or tails you get with the number entered by the user.</li>
<li>You are only tossing the coin once (at the beginning of <code>main()</code>), and just reusing the same value over and over.</li>
</ol>

<p>There are several other errors, but you may start with these.</p>
",0
12851397,12851379,7,"<p>You can use stringstreams:</p>

<pre><code>int x = 0xa1a56;
std::stringstream ss;
ss &lt;&lt; x;
cout &lt;&lt; ss.str();
</code></pre>

<p>Or if you prefer a function:</p>

<pre><code>std::string convert_int(int n)
{
   std::stringstream ss;
   ss &lt;&lt; n;
   return ss.str();
}
</code></pre>

<p>Edit:  Make sure you <code>#include &lt;sstream&gt;</code></p>
",0
12851410,12851379,1,"<pre><code>std::string HexDec2String(int hexIn) {
  char hexString[4*sizeof(int)+1];
  // returns decimal value of hex
  sprintf(hexString,""%i"", hexIn); 
  return std::string(hexString);
}
</code></pre>
",1
12851413,12851379,6,"<p>You can read the number from a string stream as hex, and write it back to a different string stream as decimal:</p>

<pre><code>int x;
istringstream iss(""a1a56"");
iss &gt;&gt; hex &gt;&gt; x;
ostringstream oss;
oss &lt;&lt; x;
string s(oss.str());
</code></pre>

<p><a href=""http://ideone.com/1bleE"" rel=""noreferrer"">Link to ideone.</a></p>
",0
12851530,12851379,3,"<p>The simplest way of doing this, using the latest version of the C++ Standard (C++11), is to use the <code>std::to_string</code> function:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  /* Convert: */
  std::string s { std::to_string(0xa1a56) };

  /* Print to confirm correctness: */
  std::cout &lt;&lt; s &lt;&lt; std::endl;
  return 0;
}
</code></pre>
",0
9851529,9851425,0,"<p>Your code</p>

<pre><code>A_Ind = (int)(rand()*12);
D_Ind = (int)(rand()*12);
</code></pre>

<p>indicates that you seem to think that <code>rand()</code> returns a number in the range [0,1), which is not the case. Instead, int returns an <em>integer</em> in the range <code>[0, RAND_MAX]</code>, so you need something like:</p>

<pre><code>A_Ind = rand() * 12.0 / RAND_MAX;
</code></pre>

<p>If your simulation has to be statistically accurate, you are probably better off with a random number generator from the <code>&lt;random&gt;</code> library:</p>

<pre><code>#include &lt;random&gt;

typedef std::mt19937 rng_type;
std::uniform_int_distribution&lt;std::size_t&gt; udist(0, 11);

rng_type rng;

// ...

// seed rng first:
rng.seed(some_seed_value);

// roll dice
std_size_t A_Ind = udist(rng), D_Ind = udist(rng);
</code></pre>
",1
10173223,10171091,0,"<p>The best source of information for Windows programming is MSDN.  The tricky part is knowing what the thing you are looking for is called.  In this case, MS calls these <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms646337%28v=vs.85%29.aspx"" rel=""nofollow"">""accelerators""</a>.</p>
",0
13736217,13736171,0,"<p>Yes there is the problem you describe. Either create <code>v</code> on the heap</p>

<pre><code>void f()
{
    std::vector&lt;int&gt;* v = new std::vector&lt;int&gt;();
    // ...
    g(v);
}

void g(std::vector&lt;int&gt;* a)
{
    // Store in blah
    // But don't forget to delete it.
}
</code></pre>

<p>or have it as a global from the start.</p>

<pre><code>std::vector&lt;int&gt; v;

void f()
{
    g();
}

void g()
{
    // Use v;
}
</code></pre>
",0
13740129,13736171,3,"<p>In addition to the answer James provided, there is a third possibility, having the same readability as your first idea without the dangling reference, without heap allocation of the vector itself and without unnecessary copies:</p>

<pre><code>std::vector&lt;int&gt; global; //somewehere - you don't have it really global, do you?

void f() {
  std::vector&lt;int&gt; vf; 
  /* ... */
  g(std::move(vf));
}

void g(std::vector&lt;int&gt; vg) //by value!
{
  /* ... */
  global.swap(vg);
}
</code></pre>

<p>Since you move <code>vf</code> ""out of"" <code>f()</code>, <code>vg</code>'s move-ctor is called, meaning it just takes ownership of the resources previously owned by <code>vf</code>, so no unnecessary copies and allocations are made. The <code>swap()</code> in <code>g()</code> only works if <code>global</code> exists before the call to <code>g()</code> (and thus <code>f()</code>). You said you want to store the vector in a reference, so I assume <code>g()</code> in fact <em>creates</em> the storage object and there is no <code>global</code> before the call. Then instead of swapping with an existing object <code>vg</code> should just be passed on via <code>std::move</code> to the storage object.</p>

<p>In total, you then really create only one vector (<code>vf</code>), all the others are really the same, <code>move</code>d on from the original, so you have basically the same performance as passing by reference, but without the dangling ref.</p>

<p>(For the nitpickers: Yes, moving a vector is a bit more than passing a ref, typically copying and zeroing three pointers instead of copying one. But it's really nothing compared to heap allocations, vector copies etc.)</p>
",0
17863756,17863715,2,"<p>It's not so much calling the destructor directly, as calling <code>delete this</code> which then calls the destructor. Either way the answer is a very definite YES as this pattern is used extensively in reference counted frameworks such as COM.</p>
",0
17863760,17863715,4,"<p>You can call <code>delete this;</code> to delete the object from within a method</p>
",2
17863829,17863715,0,"<p>Putting <code>this-&gt;~foo();</code> will call foo's destructor.</p>

<p>So, </p>

<pre><code>void foo::finalize()
{
     // do something
     this-&gt;~foo();
}
</code></pre>
",2
10116750,10116720,1,"<p>When you see an opening brace, you push it onto the stack.  When you see a closing brace, you make sure it is the counterpart of the brace on top of the stack, then pop it off.  When your input is done, you make sure the stack is empty.</p>
",6
9812469,9812411,38,"<p>You almost got it right -- the second nested <code>vector</code> should be <code>vector&lt;vector&lt;int&gt; &gt;</code>, not just a <code>vector&lt;int&gt;</code>:</p>

<pre><code>vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; vec (5,vector&lt;vector&lt;int&gt; &gt;(3,vector &lt;int&gt;(2,4)));
</code></pre>
",0
9772480,9772446,0,"<p>You cannot instantiate templates with local classes in C++03.</p>

<p>Also, the Standard already provides a function for this- <code>std::for_each</code>.</p>
",0
9772494,9772446,0,"<p>C++03 doesn't allow locally defined classes to be template arguments, as you've found out here.  C++11 allows this.  With gcc, you might try compiling with <code>--std=c++0x</code></p>
",1
9772505,9772446,9,"<p>In C++, prior to C++11, classes used as arguments to template functions must have external linkage. Local classes don't have external linkage so you can't use them this way.</p>

<p>C++11 changes this, so you may be able to fix this by setting your compiler to use C++11.</p>
",3
9773583,9772446,0,"<p>As has been said, using local classes for this was not possible pre-C++11, and about useless in C++11 because lambdas are less wordy.</p>

<p>You should simply declare your class outside the function.</p>
",0
9857378,9857320,24,"<p>Associativity and evaluation order are not the same thing. The expression <code>a &lt;&lt; b &lt;&lt; c</code> is equivalent to <code>(a &lt;&lt; b) &lt;&lt; c</code> due to left-to-right associativity, but when it comes to evaluation order, the compiler is free to evaluate <code>c</code> first then <code>a &lt;&lt; b</code> and, likewise, it can evaluate <code>b</code> before it evaluates <code>a</code>. In fact, it can even evaluate the terms in the order <code>b</code> &rarr; <code>c</code> &rarr; <code>a</code> if it wants, and it just might if it concludes that such an order will maximise performance by minimising pipeline stalls, cache misses, etc.</p>
",0
11833136,11832960,4,"<p>If you're not adverse to a macro, and are willing to accept the syntax:</p>

<pre><code>Debug( ""f1: "" &lt;&lt; f() &lt;&lt; '\n' );
</code></pre>

<p>it's pretty simple: just define something like:</p>

<pre><code>#define Debug( x ) debug != NULL &amp;&amp; *debug &lt;&lt; x;
</code></pre>

<p>It's somewhat dangerous, however, since you can't take the usual 
precaution of putting the argument in parentheses.  (On the other hand,
I've seen it used in a number of applications, without problems.)  The
macro approach has the added advantage of allowing you to insert
<code>__FILE__</code> and <code>__LINE__</code> automatically, if you want.  Or to
conditionally suppress <em>all</em> of the code completely, by defining the
macro to be nothing.</p>
",0
11833140,11832960,5,"<p>What you can do is define this macro:</p>

<pre><code>#define Debug_Stream \
if(!debug); else Output
</code></pre>

<p>This would make this:</p>

<pre><code>Debug_Stream &lt;&lt; ""f1: "" &lt;&lt; f1() &lt;&lt; ""\n"";
</code></pre>

<p>become equivalent to this:</p>

<pre><code>if(debug) {
    Output &lt;&lt; ""f1: "" &lt;&lt; f1() &lt;&lt; ""\n"";
}
</code></pre>

<p>But literally (plus whitespace for readability)</p>

<pre><code>if(!debug);
else
    Output &lt;&lt; ""f1: "" &lt;&lt; f1() &lt;&lt; ""\n"";
</code></pre>
",3
11833210,11832960,2,"<p>I think you can do this by creating a delayed-evaluator that wraps expensive function calls. Your stream would know for the delayed evaluator type it needs to call the referenced function but otherwise it no-ops it, preventing the expensive call. The no-debug stream knows that for your proxy evaluator objects to just skip the evaluation completely.</p>

<p>For example a call might look like:</p>

<pre><code>Debug &lt;&lt; ""123"" &lt;&lt; delay(f()) &lt;&lt; ""456"" &lt;&lt; std::endl;
</code></pre>

<p>This does involve remembering to invoke the delay in your debug lines. It does avoid the need for macros which may or may not be a key issue in your case.</p>
",0
10649432,10649205,-1,"<p>You don't call the destructor. You call operator delete(), and it figures out the destructor. Calling destructors directly is Undefined Behavior, in the same sense that dereferencing NULL is, i.e. blows up on every platform I've seen.</p>
",2
9149370,9149347,1,"<blockquote>
  <p>why does it increment i by one</p>
</blockquote>

<p>Array indexes run from <code>0</code> to <code>N-1</code>, where <code>N</code> is the number of elements in the array. 
<code>i++</code> increments the value of <code>i</code> by <code>1</code> (equivalent to <code>i = i + 1;</code>). Incrementing <code>i</code> in the <code>for</code> loop is a construct for accessing each element of the array <code>a</code> (in order):</p>

<pre><code>for (int i = 0; i &lt; 10; i++)
{
    a[i] = 2; /* just example */
}
</code></pre>

<p>is equivalent to:</p>

<pre><code>a[0] = 2;
a[1] = 2;
...
a[9] = 2;
</code></pre>

<p>As others have commented, get a C++ book (<a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">see this SO question for a list of C++ books</a>).</p>
",0
9149417,9149347,0,"<pre><code>#include &lt;iostream&gt;
using namespace std;

main()
{
    //declare space in memory for 10 numbers to be stored sequentially
    //this is like having ten variables, a1, a2, a3, a4 but rather than having
    //hardcoded names, you can say a[4] or rather i=4, a[i], to get variable a4.
    int a[10];  
    int sumOfSquares = 0 ;  //space for a number to be stored called sumOfSquares
    int i =0;               //space for a number to be stored called i

    cout &lt;&lt; ""Please enter the ten numbers one by one "" &lt;&lt; endl; //print msg to screen

    for (i = 0 ; i &lt; 10 ; i++) //make i = 0; while i &lt; 10 run this code! increase i by 1 each time
    {
        //a stores 10 numbers. put the number the user entered in space
        //a[0] the first time, a[1] the second time, a[2] the third time etc etc.
        cin &gt;&gt; a [i];

    }

    //run this code 10 times, with i=0 the first time, i=1 the second time,
    // i=3 the third time etc etc.
    for (i = 0 ; i &lt; 10 ; i++)
    {
        //get the number at a[0] multiple it by the number at a[0]
        //add it to value already in sumOfSquares so this number goes up and up and up.
        //the second time through the loop get a[1] and multiply it by a[1].
        sumOfSquares = sumOfSquares + a[i]*a[i]; 
    }

    //print answer to screen
    cout &lt;&lt; ""The sum of squares is ""&lt;&lt; sumOfSquares &lt;&lt; endl; //9
</code></pre>

<p>}</p>
",0
9857328,9857323,4,"<p>Your function works with the address of variables, but you're passing in number constants. You need to pass in the variables like:</p>

<pre><code>void swapInt (int &amp;a, int &amp;b);

int main() {
    int a = 1;
    int b = 2;

    swapInt(a, b);
    cout &lt;&lt; a &lt;&lt; "" "" &lt;&lt; b;

    return 0;
}

void swapInt (int &amp;a, int &amp;b) {
    int c = a;
    a = b;
    b = c;
    //cout &lt;&lt; a &lt;&lt; "" "" &lt;&lt; b;
}
</code></pre>
",3
9138218,9138188,2,"<p>Programming is just describing a series of steps to a computer</p>

<p>Edit - sorry, rereading the question it would be easier to store the value as a long integer and then increase it in a loop. </p>

<p>In which case you will have to understand how to get the first 3 digits by dividing by 10^6 (or whatever) and then taking only the integer part. 
You migth also want the modulus operator <code>%</code></p>
",2
9138281,9138188,0,"<p>You could setup a loop, that uses the modulus operator (%) to get the remainder of a number. I would setup an array with a legnth of 10, and modulus the number by 10 and put the result into the array (because you will read the numbers in reverse you need to place them into the array in reverse), until you have each digit.</p>

<p>I would then setup an int (named maybe <code>value</code>), and put the first value in the array, into this int. I would also designate another int (named maybe <code>place</code>) and set it equal to 1. Define a bool (named maybe <code>flag</code>).</p>

<p>I would then enter a loop so that you have the equation <code>if(value % place == 0) flag = 0</code>. 
Then have the loop break if <code>flag == 1</code>, and goto a label before the loop, where you have an algorithm that generates a new number (maybe somthing as simple as adding one, or what ever you want). Also inside the loop if <code>place == 10</code> and your last value in the number is 0, you need to print the number, and then jump to your label from earlier, before the loop, to pick a new number. Also don't forget that if <code>flag == 0</code>, and <code>place != 10</code> (the number hasn't failed yet, but isn't at the end yet) , that you need to multiply the <code>value</code> by 10 , then add the next number in the array to be able to test the next place. And you also need to increase <code>place</code> by 1 each time.</p>

<p>You said you're new, so I'll include a few definations:</p>

<ol>
<li>'=' sets a variable equal to somthing, '==' is used to test equality</li>
<li>'!=' means ""not equal to"". It's also used to test variables against other variables or numbers.</li>
<li>'%' or modulus divides two numbers but rather returns the remainder (ex. 10 % 3 = 1, because 10 / 3 = 9 <em>remainder 1</em>)</li>
</ol>
",4
15591337,15591306,0,"<p>Remove <code>Meeting</code> on line 79 and it would compile.</p>
",0
15591338,15591306,4,"<p>that's because of this line</p>

<pre><code>    Meeting mMeeting; //instance of Meeting Class
   Meeting //this line is creating error, remove this line
     string s;     // error `string' does not name a type 
</code></pre>
",1
15591352,15591306,3,"<p>Other than the errors mentioned by the others, here's a semantic error:</p>

<pre><code>Meeting::Meeting()
{
    string speaker = "" "";
    string topic = "" "";
    string venue = "" "";
    string date = "" "";
}
</code></pre>

<p>Here, you intend on assigning the class members the value <code>"" ""</code>, but what you're actually doing is defining 4 local string variables and initializing them with <code>"" ""</code>. To get expected results, you should do this:</p>

<pre><code>Meeting::Meeting()
{
    speaker = "" "";
    topic = "" "";
    venue = "" "";
    date = "" "";
}
</code></pre>

<p>The above function body assigns the 4 class members the values as you intend to do.</p>
",2
10794893,10794586,2,"<p>I have seen through the years that there are 2 different points of view on friendship and how it affects encapsulation:</p>

<ul>
<li>It helps improve encapsulation by not making members public to everybody, and only making them accessible to a controlled subset of entities.</li>
<li>It reduces encapsulation for the obvious classic reasons that the object should be self contained and should be the only entity to modify its internal parts, etc.</li>
</ul>

<p>I tend to avoid using friendship and try to work around it. I prefer to encapsulate everything, not just to make it private, but to be able to change how its implemented internally without affecting the users of the class.  If you want a base class to be able to modify the attributes of a derived class, maybe you could consider using a <a href=""http://en.wikipedia.org/wiki/Template_pattern"" rel=""nofollow"">Template Method</a> design pattern. Whereby the base class orchestrates calling methods on the derived classes, and be sure to have generic, abstract manipulation methods defined in the base class.</p>

<p>As for making all the attributes of a class public ""just in case"", (sounds very dangerous) I think it would be better to start off making them all private, and consider making individual attributes public as the needs arise.</p>
",11
10146765,10146732,13,"<p>This is the problem:</p>

<pre><code>addressType();
addressType(string,string,string,string);
...

addressType::addressType(string="" "",string="" "",string="" "",string="" ""){
</code></pre>

<p>You're declaring two constructors, but the second one has default values for all parameters. So if you call <code>addressType()</code>, it could either be the first, parameterless constructor, or the second, with all arguments set to their defaults.</p>

<p>As you seem to never implement the first constructor anyway, the easy fix is just to remove the declaration.</p>
",0
10146769,10146732,1,"<p>The problem is that you have 2 conflicting constructors in your <code>addressType</code> class:</p>

<pre><code>addressType();
addressType(string,string,string,string);
</code></pre>

<p>You declared default values for the second one in the definition: </p>

<pre><code>addressType::addressType(string="" "",string="" "",string="" "",string="" ""){

}
</code></pre>

<p>and you should remove them:</p>

<pre><code>addressType::addressType(string,string,string,string){

}
</code></pre>
",0
10146774,10146732,4,"<p>You've declared a constructor that takes no parameters and a constructor where all of the parameters default to <code>null</code>. When you call the constructor and pass no arguments, the compiler doesn't know whether you want the no-parameter one, or whether you want the multiple-parameter one, but with <code>null</code> passed for all the arguments.</p>
",0
10146796,10146732,0,"<p>These two function prototypes are indistinguishable:</p>

<pre><code>addressType::addressType(); 
addressType::addressType(string="" "",string="" "",string="" "",string="" ""); 
</code></pre>

<p>when you are creating an <code>addressType</code> object via the default constructor (same with <code>extPersonType</code>)</p>

<p>The <code>="" ""</code> notation means that if a parameter is not provided explicitly, the value after the <code>=</code> is used (also known as default parameter value).  So in this case the call to <code>addressType()</code> could be either the function that has no parameters, or the other function with all its parameters set to <code>"" ""</code> -- the compiler cannot decide which one you meant and throws an error.</p>

<p>To fix, remove the default value from (at least) the first parameter of the second function</p>
",0
17782916,17782872,5,"<p>You probably haven't provided the implementation:</p>

<p>MyClass.h:</p>

<pre><code>class MyClass {
private:
    static std::map&lt;int, MyClass *&gt; m_instances;
...
};
</code></pre>

<p>MyClass.cpp:</p>

<pre><code>#include ""MyClass.h""

// Add this
std::map&lt;int, MyClass *&gt; MyClass::m_instances;
</code></pre>
",1
13436974,9955501,1,"<p>all you need to do is add/write</p>

<pre><code>pragma once  
</code></pre>

<p>at the top of each header file </p>
",1
15507834,15507797,0,"<p>It works fine. All uses of the name <code>i</code> inside the function refer to the <code>i</code> declared inside that function. That is, the function will return 1 every time.</p>
",0
15507837,15507797,2,"<p>When you say <code>int i = 0</code> you're creating a new variable called <code>i</code> that hides the class member. If you want to access the class's <code>i</code>, you can do <code>this-&gt;i</code>. But it's usually better not to cause that kind of confusion in the first place.</p>
",0
15507838,15507797,1,"<p>Inside the body of <code>func1</code>, you will be referencing the locally declared <code>int i</code>. In order to reference the class member, you need to reference it explicitly by using the <code>this</code> pointer:</p>

<pre><code>this-&gt;i
</code></pre>

<p><code>this</code> is a const pointer passed in to all methods in a class to represent the current instance. It is not passed in when you have a <code>static</code> member function of course.</p>

<p>The reason the locally declared <code>int i</code> is being used first is because it is in the same scope as <code>i++</code> and <code>return i</code>.</p>
",0
15507862,15507797,0,"<p>What is your intention of i inside the func1(). Do you want to increment the outside i or the i inside the function. If you want the outside i to increment then this won't work.</p>
",0
15507897,15507797,0,"<p>Things get weird with scopes:</p>

<pre><code>int func1()
{
    int i = 0;
    i++;
    { //1
        int i = 41;
        i++;
    }
    { //2
        int j = i + 1;
        cout &lt;&lt; j &lt;&lt; endl // this prints 2
    }
    return i;
}
</code></pre>

<p>The rule when using variables in scope is, it always refers to the most local scope first and works it way up. So in your example the <code>i</code> inside your function will not refer to the <code>i</code> in the class.</p>
",0
15508061,15507797,0,"<p>The return will in fact refer to the <code>i</code> declared in <code>func1()</code>. It's all about scopes.</p>

<p>A scope starts with <code>{</code> and end with <code>}</code>. All variables declared inside a scope will only be defined as long you stay within the scope or if you go into another scope. Hence</p>

<pre><code>{ int i = 0; { int i = 1; { int i = 2; }}}
</code></pre>

<p>is perfectly possible. If you use <code>i</code> in one of the scopes you will always refer to the <code>i</code> in the same scope. To refer to an <code>i</code> of a higher scope is more difficult.</p>

<p>In your example you can still refer to the top <code>i</code> by using <code>this-&gt;i</code>, where <code>this</code> is a pointer to the object you are working with. <a href=""http://www.cplusplus.com/doc/tutorial/functions/"" rel=""nofollow"">Here</a> is some more info (scroll a bit down).</p>
",0
9220496,9220416,4,"<p><strong>Method 1:</strong></p>

<p>Think of how you would compute <code>500! / (20! * 20! * 20! * ...)</code> normally.</p>

<p>Don't multiply everything out and divide at the end. Do your divisions in the middle. Then combine this with the modulus reductions from your previous question.</p>

<p><strong>Method 2:</strong></p>

<p><a href=""http://en.wikipedia.org/wiki/Prime_factor"" rel=""nofollow"">Prime factorize</a> <code>500!</code> and <code>20!</code>. Then subtract out the prime factors of <code>20! * 20! * 20!</code> (or how ever many of them you have) from the prime factors of <code>500!</code>.</p>

<p>Then rebuild the number by multiplying back the remaining factors together. (while taking modulus along the way to keep the number from getting large)</p>

<p><strong>Method 3:</strong></p>

<p>If <code>1000000007</code> (or whatever modulus) is prime, you can do divisions using the <a href=""http://en.wikipedia.org/wiki/Modular_multiplicative_inverse"" rel=""nofollow"">modular inverse</a>.</p>

<p>Compute <code>20! mod 1000000007</code>. Then compute it's modular inverse and multiply it into <code>500! mod 1000000007</code>.</p>
",2
9206900,9206834,3,"<p>You need two underscores in <code>__gc</code>. See <a href=""http://msdn.microsoft.com/en-us/library/aa712825%28v=vs.71%29.aspx"" rel=""nofollow"">msdn</a>.</p>
",0
14820196,14818152,0,"<p>The base-from-member idiom you are exercising in this case means: you want a <code>class B</code> derived from <code>A</code> with have to be initialized using a member of <code>B</code> (with is: <code>string s</code>).  </p>

<pre><code>B b(10);
B b1(b); //   B(const B &amp;other) : B_base(other), A(other) { }
         //   now A::s in b1 is a ref to b.s
A &amp;a = b;//   and a.s is a ref to b.s too.
a.s =  ""FAIL""; // we modify b, and A::s in b1 to!
</code></pre>

<p>This problem can be solved making the copy constructor:</p>

<pre><code>B(const B &amp;other) : B_base(other), A(B_base::s) { }
</code></pre>

<p>Also, having <code>A::s</code> and <code>B_base::s</code> with the same name, make thing more difficult to understand.</p>

<p>EDIT: As a class designer, you have to decide with is the exact meaning of your copy constructor.<br>
For example, in this case you may want to keep track (with <code>A::c</code>) of the number of printing of each newly create object <code>A</code>. The copy constructor I proposed do it.</p>

<p>But if you want to keep track of all printing of the original string thing are more complex. Just note that if you copy the old <code>A::c</code> to the new <code>A</code> it will be correct initialized, bur not cross actualized when the the printing of the same original string is made using different copies of <code>A</code>. If this is not a problem you can modify the constructors:</p>

<pre><code>A(string &amp;s, int _c=0) : s(s), c(_c) { };
</code></pre>

<p>...</p>

<pre><code>B(const B &amp;other) : B_base(other), A(B_base::s, other.c) { }
</code></pre>
",2
18128678,18125943,0,"<p>There are several problems with your code, but for starters, you
shouldn't be reading lines into a <code>char[]</code>.  If you use
<code>std::string</code>, then you don't have to worry about reading
partial lines, etc. </p>

<p>Then there's the fact that <code>getline</code> extracts the <code>'\n'</code> from
the file, but does <em>not</em> store it, so your code (even modified
to use <code>std::string</code>) will never see a <code>'\n'</code> in the buffer.  If
you're using string, you iterate from <code>line.begin()</code> to
<code>line.end()</code>; if you're using a <code>char[]</code>, you iterate over the
number of bytes returned by <code>read.gcount()</code>, called after the
call to <code>getline</code>.  (It's very difficult to get this code right
using a <code>char[]</code> <em>unless</em> you assume that no text file in the
world contains a <code>'\0'</code>.)</p>

<p>Finally, if the last line doesn't end with a <code>'\n'</code> (a frequence
case under Windows), you won't process it.  If you're using
<code>std::string</code>, you can simply write:</p>

<pre><code>std::getline( read, line );
while ( read ) {
    //  ...
    std::getline( read, line );
}
</code></pre>

<p>or even:</p>

<pre><code>while ( std::getline( read, line ) ) {
    ++ nLines;
    for ( std::string::const_iterator current = line.begin();
            current != line.end();
            ++ current ) {
        //  process character *current in line...
    }
}
</code></pre>

<p>(The latter is ubiquitous, even if it is ugly.)</p>

<p>With <code>char[]</code>, you have to replace this with:</p>

<pre><code>while ( read.getline( buffer, sizeof(buffer) ) || read.gcount() != 0 ) {
    int l = read.gcount();
    if ( read ) {
        ++ nLines;
    } else {
        if ( read.eof() ) {
            ++ nLines;  //  Last line did not end with a '\n'
        } else {
            read.clear();   //  Line longer than buffer...
    }
    for ( int i = 0; i != l; ++ i ) {
        //  process character buffer[i] in line...
    }
}
</code></pre>

<p>One final question: what is <code>(int)line[i] &gt; 32</code> supposed to
mean?  Did you want <code>!isspace(?line[i]?) &amp;&amp;
!iscntrl(?line[i]?)</code>?  (That's not at all what it does, of
course.)</p>
",0
12860264,12860112,3,"<p>To implement a constructor (or any method, for that matter) outside the class definition, you need to specify the name of the class before the method name:</p>

<pre><code>EntitySphere::EntitySphere(GLuint shader): Entity(shader) {
  // ...
}
</code></pre>

<p>Notice the <code>EntitySphere::</code> part before the rest of the method.</p>

<p>Otherwise, the compiler doesn't know which method you're providing the definition for. (Maybe it could be allowed to guess, but what if it guessed wrong and associated that implementation with some other function in your program?)</p>
",1
9228566,9228528,2,"<p>You try to assign the value 0 to an array of int[2].
I think you can just remove the complete line as the item is filled already in the following two lines of code.</p>
",0
9228576,9228528,1,"<p>The line <code>iBlocks[iUCtr] = 0;</code> is not required. Delete it.</p>
",0
9228577,9228528,3,"<p>You are trying to set a whole ""row"" of a matrix with the ""0"" value.  The compiler won't let you do that.</p>

<p>Perhaps you missed the second index, since iBlocks is a matrix, what you would need is something like this:</p>

<pre><code>iBlocks[iUCtr][SecondIndex] = 0 
</code></pre>

<p>If instead you are trying to initialize a whole matrix with Zeros, write a function to do that.</p>
",1
16401134,16401099,7,"<p>In C++, all references to static members (or types) use <code>::</code>:</p>

<pre><code>MyModule::VersionChecker::GetDllVersion();
</code></pre>
",1
16401138,16401099,2,"<p>Try this:</p>

<pre><code>MyModule::VersionChecker::GetDllVersion();
</code></pre>
",0
11517233,11516932,0,"<p>I think the most general answer would be:</p>

<pre><code>class MyClass
{
   std::string mybuff;
 public:
   template&lt;class Any&gt;
   MyClass&amp; operator&lt;&lt;(const Any&amp; s)
   {
          std::stringstream strm;
          strm &lt;&lt; s;
          mybuff += strm.str();
   }

   MyClass&amp; operator&lt;&lt;( std::ostream&amp;(*f)(std::ostream&amp;) )
   {
    if( f == std::endl )
    {
        mybuff +='\n';
    }
    return *this;
}
}
</code></pre>

<p>std::endl was pasted from Timbo's answer <a href=""https://stackoverflow.com/questions/2212776/overload-handling-of-stdendl"">here</a></p>

<p>Thanks for the answers!</p>
",2
11516937,11516932,4,"<pre><code>class MyClass
{
?  ?std::string mybuff;
?public:
    //replace Whatever with what you need
    MyClass&amp; operator &lt;&lt; (const Whatever&amp; whatever)
    {
       //logic
       return *this;
    }

    //example:
    MyClass&amp; operator &lt;&lt; (const char* whatever)
    {
       //logic
       return *this;
    }
    MyClass&amp; operator &lt;&lt; (int whatever)
    {
       //logic
       return *this;
    }
};
</code></pre>
",3
9205467,9204981,0,"<p>Here`s a working example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

int main()
{
    std::ifstream file(""text.txt"");
    std::string line;

    std::vector&lt;std::tuple&lt;double, double, double&gt;&gt; node;
    std::vector&lt;std::tuple&lt;int, int, int, int&gt;&gt; element;

    bool isnode = false;
    bool iselement = false;
    while (std::getline(file, line))
    {
         if (line == ""*Node"")
         {
            isnode = true;
            continue;
         } else if (isnode)
         {
            std::istringstream iss(line);
            double d1, d2, d3;
            char c1, c2;

            if((iss &gt;&gt; d1 &gt;&gt; c1 &gt;&gt; d2 &gt;&gt; c2 &gt;&gt; d3))
            {
               node.emplace_back(d1, d2, d3);
            }
         }

         if (line == ""*Element"")
         {
            iselement = true;
            isnode = false;
            continue;
         } else if (iselement)
         {
            std::istringstream iss(line);
            int i1, i2, i3, i4;
            char c1, c2, c3;

            if((iss &gt;&gt; i1 &gt;&gt; c1 &gt;&gt; i2 &gt;&gt; c2 &gt;&gt; i3 &gt;&gt; c3 &gt;&gt; i4))
            {
                element.emplace_back(i1, i2, i3, i4);
            }
         }
    }

std::cout &lt;&lt; ""Printing node: "" &lt;&lt; '\n';
for (auto i = node.cbegin(); i != node.cend(); ++i)
{
    std::cout &lt;&lt; std::get&lt;0&gt;(*i) &lt;&lt; "", ""
            &lt;&lt; std::get&lt;1&gt;(*i) &lt;&lt; "", ""
            &lt;&lt; std::get&lt;2&gt;(*i) &lt;&lt; '\n';
}

std::cout &lt;&lt; ""Printing element: "" &lt;&lt; '\n';
for (auto i = element.cbegin(); i != element.cend(); ++i)
{
    std::cout &lt;&lt; std::get&lt;0&gt;(*i) &lt;&lt; "", ""
            &lt;&lt; std::get&lt;1&gt;(*i) &lt;&lt; "", ""
            &lt;&lt; std::get&lt;2&gt;(*i) &lt;&lt; "", ""
            &lt;&lt; std::get&lt;3&gt;(*i) &lt;&lt; '\n';
}
std::cout &lt;&lt; std::endl;

}
</code></pre>
",0
9204995,9204981,0,"<p>Include ""fstream"", declare an ifstream variable. Use var.open(fileNmae) and read just like cin: I.E. var >> stringVar.</p>
",2
15531777,15531590,3,"<p>You have started counting from 0 <code>int counter = 0, cars = 0;</code></p>

<p>You then count until you are equal to the number that was entered (the ""or equal to"" bit of <code>while (counter &lt;= cars)</code>).</p>

<p>As a worked example, if I want 3 entries:</p>

<pre><code>Start: counter = 0, cars = 3.
0 &lt;= 3: true
End of first iteration: counter = 1
1 &lt;= 3: true
End of second iteration: counter = 2
2 &lt;= 3: true
End of third iteration: counter = 3
3 &lt;= 3: true (the ""or equal"" part of this)
End of FORTH iteration: counter = 4
4 &lt;= 3: false -&gt; Stop
</code></pre>

<p>We have completed 4 iterations instead of 3. If we only checked for ""strictly less than"" (<code>counter &lt; cars</code>), the condition at the end of the third iteration would be false, and we'd have ended there.</p>
",0
15531781,15531590,1,"<p>The heading of your while loop should be:</p>

<pre><code>while(counter &lt; cars)
</code></pre>

<p>rather than</p>

<pre><code>while(counter &lt;= cars)
</code></pre>
",0
10812502,10812137,0,"<pre><code>cluster  clusters[LOTS];
vector&lt;cluster *&gt; pclust(numClust);
for (int i = 0; i &lt; numClust; ++i)
  pclust[i] = clusters + i;
</code></pre>

<p>But this mean you are still using an array to store clusters.
Can't you make <code>clusters</code> a vector ?</p>

<pre><code>vector&lt;cluster&gt; clusters(LOTS);
</code></pre>
",1
10812251,10812137,11,"<p><code>vector::reserve</code> doesn't change the size of your vector, it still contains only the <code>0</code> elements it was created with. What it does is make sure that the vector can potentially hold <code>numClust</code> without having to reallocate. See <a href=""http://www.cplusplus.com/reference/stl/vector/reserve/"" rel=""noreferrer"">here</a>.</p>

<p>What you want is to either declare the vector to have that size</p>

<pre><code>vector&lt;cluster *&gt; pclust(numClust);
</code></pre>

<p>or to <a href=""http://www.cplusplus.com/reference/stl/vector/resize/"" rel=""noreferrer"">resize the vector</a></p>

<pre><code>pclust.resize(numClust);
</code></pre>
",4
10812259,10812137,5,"<p><a href=""http://www.cplusplus.com/reference/stl/vector/reserve/"" rel=""nofollow noreferrer""><code>std::vector::reserve</code></a> <em>requests that the capacity of the allocated storage space for the elements of the vector container be at least enough to hold n elements</em>. It doesn't resize the vector, that's what <a href=""http://www.cplusplus.com/reference/stl/vector/resize/"" rel=""nofollow noreferrer""><code>std::vector::resize</code></a> does.</p>

<p>Replace <code>pclust.reserve(numClust);</code> with <code>pclust.resize(numClust);</code>.</p>

<p>Alternatively you could remove <code>pclust.reserve(numClust);</code> call and change construction of this vector to: <code>vector&lt;cluster *&gt; pclust(numClust);</code> which yields same result.</p>

<p>I also suggest you to have a look at this question: <a href=""https://stackoverflow.com/q/1461276/1168156"">std::vector reserve() and push_back() is faster than resize() and array index, why?</a> :)</p>
",3
10812276,10812137,0,"<p>operator[] used with vector returns reference to element on index-position. BUT, you haven't initialized vector with any values, so it was empty.</p>

<p>Altough you did a <code>pclust.reserve(numClust)</code>, but it only tells that size of the vector will change soon and it allocates storage space without changing vector's size yet.</p>
",1
10817374,10817278,2,"<p>Taking the addres of <code>c</code> makes the type a <code>char*</code>, which will be interpreted as a null terminated string. Global variables by default are zero initialised meaning <code>c</code> will be interpreted as an empty string, and thus nothing is printed.</p>
",0
10817355,10817278,5,"<p>There is an overload of <code>operator&lt;&lt;</code> that takes a <code>char*</code> and displays it as a null-terminated string. If you want to display the pointer address, cast the pointer to <code>void*</code>.</p>
",2
13758549,13758027,2,"<p>I assume the function is actually a bit more beefy than the one you posted (which don't compile returning a value from a function returning <code>void</code>). You could use function objects to customize the behavior, e.g.:</p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;
using namespace std::placeholders;

template &lt;typename Op&gt;
int operation(int a0, int a1, Op op = Op())
{
    return op(a0, a1);
}

int my_f0(int a0, int a2)
{
    return 2 * a0 + 3 * a2;
}

int my_f2(int a0, int a2, int f0, int f1)
{
    return f0 * a0 + f1 * a2;
}

int main()
{
    std::cout &lt;&lt; operation&lt;std::plus&lt;int&gt; &gt;(2, 3) &lt;&lt; ""\n"";
    std::cout &lt;&lt; operation&lt;std::minus&lt;int&gt; &gt;(2, 3) &lt;&lt; ""\n"";
    std::cout &lt;&lt; operation(2, 3, std::multiplies&lt;int&gt;()) &lt;&lt; ""\n"";
    std::cout &lt;&lt; operation(2, 3, my_f0) &lt;&lt; ""\n"";
    std::cout &lt;&lt; operation(2, 3, std::bind(&amp;my_f2, _1, _2, 2, 3)) &lt;&lt; ""\n"";
}
</code></pre>

<p>The customized function is <code>operation()</code>. The other code is just to show how it gets customized. The standard library algorithms use this approach all over the place.</p>
",0
13758124,13758027,3,"<p>Some one kind of beat me to this with the comments below the question, but here ya go! </p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;

std::unordered_map&lt;std::string, std::function&lt;int(int,int)&gt;&gt; operations =
{
  { ""plus"",   std::plus&lt;int&gt;()  },
  { ""minus"",  std::minus&lt;int&gt;() }
  // etc etc
};

int main(int argc, char** argv)
{
  std::cout &lt;&lt; operations[""plus""](1, 2) &lt;&lt; std::endl;
  std::cout &lt;&lt; operations[""minus""](2, 1) &lt;&lt; std::endl;

}
</code></pre>
",0
13758224,13758027,0,"<p>If you don't believe macros are evil from hell, you could do this:</p>

<pre><code>#define DEFINE_OPERATION(maName, maOp) \
  inline int maName (int a, int b) { return a maOp b; }

DEFINE_OPERATION(add, +)
DEFINE_OPERATION(sub, -)

#undef DEFINE_OPERATION
</code></pre>

<p>Or even:</p>

<pre><code>#include &lt;boost/preprocessor.hpp&gt;

#define OPERATIONS ((add, +))((sub, -))

#define DEFINE_OPERATION(maR, maData, maElem) \
  inline int BOOST_PP_TUPLE_ELEM(2, 0, maElem) (int a, int b) { return a BOOST_PP_TUPLE_ELEM(2, 1, maEleme) b; }

BOOST_PP_SEQ_FOR_EACH(OPERATIONS, unused_, DEFINE_OPERATION)

#undef DEFINE_OPERATION
</code></pre>
",0
13758313,13758027,1,"<p>Is it that you don't want to write separate functions, or that you want to call one thing from the call site? If you don't mind writing a little bit more, you can use operator objects:</p>

<pre><code>class Add {
  public:
  int operator(int a, int b) {
    return a+b:
  }
};

class Mul {
  public:
  int operator(int a, int b) {
    return a*b:
  }
};

template &lt;class Op&gt;
int doMyStuff(Op op, int a, int b) {
  return op(a,b);
}

// and you can call it like this:
doMyStuff(Add(),2,4);
</code></pre>

<p>This pattern is particularly useful when you implement certain transformations that do not rely on particular operator, but just on certain property of the operator. For example, you could implement an array-summator which either sums all elements of an array, or computes a product of all elements in array: the loop remains the same, it's just the operator that changes.</p>

<pre><code>template &lt;class Op&gt;
int summator(Op op, int* arr, int size) {
  int v = arr[0];
  for (int i=1; i&lt;size; ++i) {
    v = op(v,arr[i]);
  }
  return v;
}

...

summator(Add(),myarray,10); //sum all elements
summator(Mul(),myarray,10); //product of all elements
</code></pre>
",3
13758416,13758027,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;
using namespace std;

template&lt;template&lt;class&gt; class OP, class T&gt; 
T do_op(T a, T b) {
    return  OP&lt;T&gt;()(a,b);
}

int main () {
    cout &lt;&lt; do_op&lt;plus&gt;       (3,2) &lt;&lt; endl;
    cout &lt;&lt; do_op&lt;minus&gt;      (3,2) &lt;&lt; endl;
    cout &lt;&lt; do_op&lt;multiplies&gt; (3,2) &lt;&lt; endl;
    cout &lt;&lt; do_op&lt;divides&gt;    (3,2) &lt;&lt; endl;
}
</code></pre>
",4
11526135,11526087,0,"<p>The size of the second dimension, third, etc. in any array is always constant. Period. The standard is very clear about this.</p>

<p>The first dimension (actually the last index) can be variable if you allocate variable on the heap with array form of new, like this:</p>

<pre><code>int size = 50;
float *p = new float[size];

.... do stuffs

delete[] p;
</code></pre>

<p>Some compilers allow variable sized arrays on the stack, but it is better not to use this.</p>
",3
11526315,11526087,0,"<p>The compiler enforces this rule about a constant size of an array because it allocates the needed memory at compile time. In otherwords, all values needed to calculate the size of the array must be known at compile-time. In your first example, this is not the case, so the compiler complains.</p>

<p>If you really need to have dynamically sized arrays, you should use pointers and the new[] operator to allocate the array. You will also need to remember to use the delete[] operator to return the memory to the system and avoid any memory leaks.</p>
",2
13440449,13440354,6,"<p>Using <code>&gt;&gt;</code> operator directly won't work, because as you say it skips whitespace including newlines.</p>

<p>What you can do is to read a single line using <code>std::getline</code>, and then you can read all input from the line with <code>std::stringstream</code>.</p>

<pre><code>std::string line;
if (std::getline(std::cin, line)) {
    std::istringstream ss(line);
    int x;
    while (ss &gt;&gt; x) {
        //....
    }
}
</code></pre>
",0
12877363,12877345,8,"<p>It means that from then on in the code, when we type <code>cout</code> we mean <code>std::cout</code></p>

<p>It injects the <code>cout</code> defined in namespace <code>std</code> into the current namespace. We use this over <code>using namespace std</code> as this is much more controlled; not every single <code>std</code> name will be injected with this statement.</p>
",3
12877373,12877345,0,"<p>It's a namespace declaration. Allows you to type out <code>cout</code> instead of <code>std::cout</code> and is generally preferred instead of <code>using namespace std;</code></p>
",0
12877382,12877345,0,"<p>The <code>using</code> declaration introduces the name <code>cout</code> to the global namespace as a synonym for <code>std::cout</code>.</p>
",0
12877397,12877345,0,"<p>It is related with the ""namespace"" concept. In order to avoid name collisions (variables, classes, whatever, which have the same name in different files), you can put your code into a namespace as following:</p>

<pre><code>namespace exampleNS
{
    class A { ... }

    void aFunction (...){ ... }
}
</code></pre>

<p>When you are inside namespace <code>exampleNS</code>, you can refer to class <code>A</code> using just the name, but from outside you need to write <code>exampleNS::A</code>.</p>

<p>If you want to save the verbosity of adding the namespace before a name that you use a lot (and you are sure does not collide with anything inside your current namespace), you can write that <code>using</code> statement. </p>

<p>Mostly all standard library utilities are inside <code>namespace std</code>, as for instance the variables <code>cout</code> and <code>cin</code>. In your case, your code is not inside the namespace <code>std</code>: you can choose between writing <code>std::cout</code> each time you want to print something, or write <code>using std::cout</code> at the beginning and then using it as <code>cout</code> in the code. </p>
",0
12877412,12877345,0,"<pre><code>using A::B
</code></pre>

<p>Where <code>A</code> is a namespace, means that accessibility of <code>B</code> does not require the prefixing of it's derivative. Note that this is only relative to the scope in which it is placed. If placed in a lower-level scope, it's function will not have any affect in the outer scope.</p>
",0
10150434,10150410,4,"<p>Edit after reading the actual code (the ""note"" shown above is fairly misleading about the real problem).</p>

<p>Looking at the code, where you try to use <code>new Node&lt;T&gt;;</code>, that needs a default constructor for T (which in this case is <code>Tree</code>) because your Node template contains an instance of T:</p>

<pre><code>struct Node {
    T data;    // &lt;--- instance of T, not being initialized in your code.
    Node *next;
};
</code></pre>

<p><code>Tree</code> doesn't have a default constructor, so that fails (and the note is showing you where the default constructor would be needed).</p>

<p>You have a few choices about how to fix that. The most obvious would be for a <code>Node</code> to hold either a pointer or a reference to a <code>T</code> instead of containing an actual instance of T.</p>

<p>Another would be to have <code>Node</code>'s constructor take a reference to a (probably const) T, and copy that T into the Node:</p>

<pre><code>class Node { 
    T data;
    Node *next;
public:
    Node(T const &amp;dat) : data(dat), next(0) {}
};
</code></pre>

<p>The choice between these two approaches is fairly fundamental. If you have Node store a pointer/reference to T, then it will be the responsibility of calling code to ensure the passed object remains valid as long as the Node exists. The node and calling code will share access to a single instance of T.</p>

<p>By contrast, if you copy the passed object into the Node, then this copy will be destroyed when the <code>Node</code> is destroyed. The original T (Tree, in your case) you passed to the Node will remain the responsibility of the calling code, and the <code>Node</code> will take responsibility for its copy.</p>

<p>In the <em>usual</em> case, you'd tend to favor the latter -- it gives cleaner semantics, and keeps ownership of the data clear. In the case of a Tree, however, you probably don't want to copy an entire tree into a Node if you can avoid it. One compromise position would be to use something like a <code>Node&lt;shared_ptr&lt;Tree&gt; &gt;</code> instead. The shared_ptr can keep copying fast and cheap, while avoiding writing a Node that's only suitable for a few kinds of objects and situations. That also makes fairly explicit that you're storing only a pointer that gives shared access to the original object.</p>
",1
10150440,10150410,4,"<p>Do you have a default constructor for <code>Tree</code>?  If not, that might be your problem: Node holds in its <code>data</code> member a <code>Tree</code> type that must be default constructed when you call <code>new Node&lt;Tree&gt;</code>.</p>

<p>To fix, you can modify <code>Node</code>'s constructor to take <code>data</code> and <code>next</code> as a parameter, so you don't require default constructor on its template type (you still need assignment operator to be available).</p>
",4
13418691,13418650,1,"<p>You have to do it in an initialization list:</p>

<pre><code>Test::Test(void) : a(10) {
  ...
}
</code></pre>
",0
13418698,13418650,0,"<p><code>a</code> is const, so you cannot assign to it. You must, however, initialize it.</p>

<p>Do:</p>

<pre><code>Test::Test(void)
:a(10)
{
    ...
}
</code></pre>

<p>BTW, the <code>tekst[size]</code> doesn't do what you think, probably. It does nothing!</p>
",1
13418670,13418650,7,"<p>The error says it all, <code>a must be initialized in constructor base/member initializer list</code></p>

<pre><code>Test::Test(void) : a(10) // Initializer list
{
...
}
</code></pre>
",0
13418672,13418650,3,"<p>The error tells you what to do</p>

<pre><code>Test::Test(void) : a(10) // an initializer list
{
    b = 20;
    size = 20;
    tekst[size];
}
</code></pre>

<p>BTW i think you'll find that the code</p>

<pre><code>tekst[size];
</code></pre>

<p>does not do what you expect it to. Probably you mean</p>

<pre><code>tekst = new char[size];
</code></pre>
",1
10108452,10108260,1,"<p>You are creating <code>image</code> using the default constructor of <code>vector</code>, which initializes the vector as empty (containing no elements).  The subscript notation (<code>image[i]</code>) does not create an element, only assigns to an already exising one.</p>

<p>You have (at least) two ways to fix it:</p>

<ul>
<li>declare <code>image</code> using the ctor of <code>vector</code> that allocates the necessary size: <code>vector&lt;unsigned char&gt; image(512*512)</code> -- this will populate the vector with 512*512 elements of default value (0 for <code>unsigned char</code>)</li>
<li>add the elements one-by-one using the <code>push_back</code> method: <code>image.push_back((unsigned char) matrix[i]);</code></li>
</ul>

<p>You also will have to write the contents of <code>image</code> to <code>myfile</code> eventually.</p>

<p>Note: it is a good habit to use <code>static_cast&lt;unsigned char&gt;(...)</code> instead of the C-style <code>(unsigned char) ...</code> as the former can find errors that the latter will not flag; this is not an issue in this particular case, though</p>
",0
10108391,10108260,0,"<p>You image vector has zero size - you would have to at least do a push_back to add an element.  Also, the size of a double is not the same size of a char so you are going to lose information.</p>
",0
10108758,10108260,2,"<ul>
<li><strong>bug</strong>: You are creating a vector of size 0, and then writing to its non-existent elements.</li>
<li><strong>bug</strong>: You never write the data to a file</li>
<li><em>style</em>: You close the file needlessly. It will be closed when the <code>fstream</code> object goes out of scope</li>
<li><em>style</em>: You copy the data in a loop. Using <code>vector::vector</code> displays your intent more clearly.</li>
<li><em>potential bug</em>: You create an output vector of 512x512, regardless of the size of the input vector.</li>
<li><em><a href=""http://sscce.org"" rel=""nofollow"">SSCCE</a></em> Your testcase is incomplete.</li>
</ul>

<p>Try this:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

void writePNG(const std::vector&lt;double&gt;&amp; matrix)
{
  std::ofstream myfile(""newFile.txt"", std::ios::out); 

  if(!myfile.is_open())
  {
    std::cout &lt;&lt; ""Cannot open file"";
  }
  std::vector&lt;unsigned char&gt; image (matrix.begin(), matrix.end());
  myfile.write(reinterpret_cast&lt;const char*&gt;(&amp;image[0]), image.size());
}

int main () {
  writePNG({
    72, 101, 108.1, 108.2,
    111, 0x2c, 0x20, 0x77,
    0x6f, 0x72, 0x6c,
    100.3,  10.4});
}
</code></pre>
",1
11148740,11148595,1,"<p>Here is an article to detect infinite loops using GDB:</p>

<p><a href=""http://www.unknownroad.com/rtfm/gdbtut/gdbinfloop.html"" rel=""nofollow"">http://www.unknownroad.com/rtfm/gdbtut/gdbinfloop.html</a></p>

<p>Hopefully this will help you with the problem.</p>
",1
11165748,11148595,0,"<p>Well...here I go answering my own question.  I rewrote it with next_permutation, and it was massively easier and more efficient.  I still haven't solved the actual looping problem with the other solution, but now I don't need to.  Thanks everyone for the tips :)</p>
",0
10168587,10168459,2,"<pre><code>unsigned n,x1,x2;
vector&lt; list&lt;unsigned&gt; &gt; successor(n);
</code></pre>

<p>This is a clear error -- you're using <code>n</code> to specify the size of <code>successor</code>, but <code>n</code> hasn't been initialized yet, so it contains garbage (and the same is true with <code>count</code> and <code>marks</code> since you've specified their size as <code>n</code> as well). In other words, at this point, we have no clue about the size of <code>successor</code>.</p>

<p>You have a couple of choices. You could move your <code>idata &gt;&gt; n</code>; <em>before</em> you define <code>successor</code>, <code>count</code>, and <code>marks</code>, or you could define them without a size, and then use <code>resize</code> to specify their size after you read <code>n</code> from <code>idata</code>.</p>

<p>I'll leave off my usual rant about <code>std::list</code> beyond pointing out that I rarely find it an optimal choice.</p>
",0
10168510,10168459,0,"<p>What are the values read into <code>x1</code> and <code>x2</code>?  If the values are larger than <code>n</code>, access to the vector's element is invalid: <code>count[x2]</code>, <code>marks[x1]</code> and <code>successor[x1]</code> refer to invalid elements.</p>

<p>Instead of the subscript notation (<code>[]</code>), use the <code>at()</code> function, which performs bounds checking to catch the first invalid access.</p>
",0
11096523,11095650,1,"<p>Use <code>memset</code>:</p>

<pre><code>LoadsForADPLScript instance;
memset(&amp;instance, 0, sizeof(LoadsForADPScript));
</code></pre>
",3
11097415,11095650,2,"<p>If it's C++, an empty constructor will automatically initialize all member variables of simple numerical types with zero.</p>

<pre><code>struct LoadsForAPDLScript {
    ...
    LoadsForAPDLScript() {}
};
</code></pre>

<p>With C compatibility in mind, I'm not quite sure about whether an implicit default constructor will do this as well. Perhaps somebody has the C++ standard at hand (or knows it by heart), then please extend this answer.</p>
",2
11511888,11511779,5,"<p>Multidimensional arrays are simply syntactic sugar. Behind the scenes this is simply a one dimensional array 10 * 20 <code>int</code>s long. When you access an element at <code>x[5][6]</code> the compiler generates the equivalent to <code>x[5 * 20 + 6]</code>;</p>
",6
11511834,11511779,5,"<p>Arrays and pointers aren't the same thing.  In C and C++, multidimensional arrays are just ""arrays of arrays"", no pointers involved.</p>

<pre><code>int x[10][20];
</code></pre>

<p>Is an array of 10 arrays of 20 elements each.  If you use <code>x</code> in a context where it will decay into a pointer to its first element, then you end up with a  pointer to one of those 20-element arrays - that's your <code>int (*)[20]</code>.  Note that such a thing is <em>not</em> a pointer-to-a-pointer, so the conversion is impossible.</p>

<pre><code>int *p[10];
</code></pre>

<p>is an array of 10 pointers, so yes it's different from x.</p>

<p>In particular, you may be having trouble because you seem to think arrays and pointers are the same thing - your question says:</p>

<blockquote>
  <p>This is a 1-dimensional array with x being the base pointer that is it contains the address of the first element of the array. So x gives me that address and *x gives the first element.</p>
</blockquote>

<p>Which isn't true.  The 1-dimensional <code>x</code> is an array, it's just that in some contexts an array decays into a pointer to its first element.</p>

<p>Read the <a href=""http://c-faq.com/aryptr/index.html"" rel=""noreferrer"">FAQ</a> for everything you want to know about this subject.</p>
",3
11512902,11511779,2,"<p>Here's how it really works, see the code and comments:</p>

<pre><code>#include &lt;stdio.h&gt;

int x[3][5] =
{
  {  1,  2,  3,  4,  5 },
  {  6,  7,  8,  9, 10 },
  { 11, 12, 13, 14, 15 }
};

int (*pArr35)[3][5] = &amp;x;
// &amp;x is a pointer to an array of 3 arrays of 5 ints.

int (*pArr5a)[5] = x;
// x decays from an array of arrays of 5 ints to
// a pointer to an array of 5 ints,
// x is a pointer to an array of 5 ints.

int (*pArr5b)[5] = &amp;x[0];
// &amp;x[0] is a pointer to 0th element of x,
// x[0] is an array of 5 ints,
// &amp;x[0] is a pointer to an array of 5 ints.

int *pInta = x[0];
// x[0] is 0th element of x,
// x[0] is an array of 5 ints,
// x[0] decays from an array of 5 ints to
// a pointer to an int.

int *pIntb = *x;
// x decays from an array of arrays of 5 ints to
// a pointer to an array of 5 ints,
// x is a pointer to an array of 5 ints,
// *x is an array of 5 ints,
// *x decays from an array of 5 ints to
// a pointer to an int.

int *pIntc = &amp;x[0][0];
// x[0][0] is 0th element of x[0],
// where x[0] is an array of 5 ints,
// x[0][0] is an int,
// &amp;x[0][0] is a pointer to an int.

int main(void)
{
  printf(""&amp;x=%p x=%p &amp;x[0]=%p x[0]=%p *x=%p &amp;x[0][0]=%p\n"",
         pArr35, pArr5a, pArr5b, pInta, pIntb, pIntc);
  return 0;
}
</code></pre>

<p>Sample output:</p>

<blockquote>
  <p>&amp;x=0040805c x=0040805c &amp;x[0]=0040805c x[0]=0040805c *x=0040805c &amp;x[0][0]=0040805c</p>
</blockquote>

<p>All the resultant pointers are the same value-wise because I used explicitly or implicitly indices of 0 and because arrays are contiguous and their very first (IOW, 0th) element is always at the lowest address in the array. So, even though there are 3 different pointer types, all effectively point at x[0][0], at the element that's equal 1.</p>

<p>This decaying of arrays to pointers is a very important feature of C and C++, although it's hard to grasp immediately.</p>

<p>It lets us write more compact code when passing pointers to arrays, we can just write the array's name instead of taking the address of its first element:</p>

<pre><code>char str1[] = { 's', 't', 'r', '1', '\0' };
char str2[] = ""str2"";
printf(""%s %s %s %s\n"", &amp;str1[0], str1, &amp;str2[0], str2);
</code></pre>

<p>Output:</p>

<blockquote>
  <p>str1 str1 str2 str2</p>
</blockquote>

<p>It also lets us do crazy things:</p>

<pre><code>int y[3] = { 10, 20, 30 };
printf(""%d %d %d %d\n"", y[2], *(y+2), *(2+y), 2[y]);
</code></pre>

<p>Output:</p>

<blockquote>
  <p>30 30 30 30</p>
</blockquote>

<p>All because <code>a[b]</code> is equivalent to <code>*(a+b)</code> when it comes to arrays and pointers.</p>
",0
10166882,10166863,2,"<p>In the <code>.cpp</code> file, you're not supposed to redefine the class, but include the header and implement the methods. So, <code>Date.h</code> is ok, but <code>Date.cpp</code> should be something along the lines of:</p>

<pre><code>//Date.cpp
#include ""Date.h""

Date::Date ()
{
}

void Date::setValues()
{
}
Date Date::operator=(const Date &amp;)
{
   return *this;
}
Date::Date(const Date &amp;)
{
}
Date Date::operator-(const Date &amp;)
{
   return *this;
}
bool operator&gt;(Date a, Date b)
{
    return true;
}
bool operator==(Date a, Date b)
{
    return true;
}
ostream &amp;operator&lt;&lt;(ostream &amp;out, Date a)
{
    return out;
}
istream &amp;operator&gt;&gt;(istream &amp;in, Date &amp;a)
{
    return in;
}
</code></pre>

<p>The implementations are missing, the operators should be declared in another header, possibly <code>Date.h</code>, and <code>operator =</code> should return a <code>Date&amp;</code>, not a <code>Date</code> (though not mandatory.</p>

<p>Also, if you're looking to call <code>Date</code> with 3 parameters, you probably want:</p>

<pre><code>Date::Date (int day_, int month_, int year_ ) :
   day(day_), month(month_), year(_year)
{
}
</code></pre>

<p>in your implementation file, and also declare this constructor in the header.</p>
",4
10770209,10770185,2,"<p>You need to declare the <code>sort</code> function before you call it. Move its definition above <code>main</code>, or put <code>void sort(std::vector&lt;int&gt;);</code> before <code>main</code>.</p>

<p>And the same goes for <code>mergeSort</code>.</p>

<p>You should also fully qualify the call <code>sort(numbers.begin(), numbers.end());</code> as <code>std::sort(numbers.begin(), numbers.end());</code>, and the same for <code>copy</code>, <code>unique</code>. If you don't, then for technical reasons called ""ADL"", which you can look up if you like, then the call only compiles if the arguments that you're calling it on (the iterators) are classes in namespace <code>std</code>. It's up to the specific implementation whether or not they are, so the call won't work on some compilers.</p>
",1
10180501,10180460,6,"<p>All the stream classes in C++ are made noncopyable by having made their copy-constructor <code>private</code>. That means, you cannot return stream objects by value. Read <a href=""https://stackoverflow.com/questions/6010864/why-copying-stringstream-is-not-allowed"">this</a> for detail. End of the story.</p>

<p>So the solution is to pass a stream object to the function as reference, and open the file in the function, and return from it, or create the stream object using <code>new</code> and return the pointer to the stream object from the function, but then if you do so, you've to <code>delete</code> the object when you're done with it. I personally would not do either of them. </p>

<p>I will probably encapsulate the stream and the behaviour/work you would like to do with the object, in a class.</p>

<p>In C++11, you can use <code>std::move</code> to move the stream object, as streams are movable.</p>
",2
10180504,10180460,6,"<p>std::streams are not copyable.</p>
",0
10180596,10180460,2,"<p>As others have said file streams are not copyable. Maybe something more like this:</p>

<pre><code>bool bipgetConfigurationPath(std::ifstream&amp; ifs) {

    std::string bipdefaultConfigFileName(""D2B_config.txt"");

    // ...

    ifs.open(bipdefaultConfigFileName);
    return ifs.good();
}
</code></pre>
",0
9180583,9180048,2,"<p>I won't dive into your code, but I can point you to some mistakes in your code :</p>

<p><code>int n,a[n],x,c,u[n],m[n],e[n][4];</code></p>

<ul>
<li>These arrays, where the size is a local value, are called VLAs (Variable-Length Arrays) and are an extension to C++. Don't use them.</li>
<li>At the declaration of the arrays, <code>int n</code> has not yet been initialized (it is from user input two lines later). Thus, all these arrays have an invalid size.</li>
</ul>

<p><code>for(int y=1; y&lt;n+1; y++)</code></p>

<ul>
<li>For an array of size <code>n</code>, the valid indexes range from <code>0</code> to <code>n-1</code>.</li>
</ul>

<p><code>system(""PAUSE"");</code></p>

<ul>
<li>This is very platform-specific, and can be quite annoying in some cases. Prefer asking for a keystroke with <code>std::cin</code>.</li>
</ul>

<hr>

<p>Generally speaking, if you are using C++, you should drop the use of old-school C arrays. Prefer the nice data structures that the standard library offers you, such as <code>std::vector</code>, <code>std::list</code>, <code>std::deque</code>, or the C++11 <code>std::array</code>.</p>

<p>Hope that helps.</p>
",2
16448952,16448242,1,"<p>I just tried your code, and it works. I believe the problem is what sftrabbit said, the path of the file is incorrect.</p>

<p>If your text file is in the same folder as your main.cpp, the path is simply the name of the text file (e.g. textFile.txt).</p>

<p>If it's somewhere else, for example, in your C drive, then the path should be C:/textFile.txt.</p>
",0
10182079,10182021,0,"<p><code>&amp;</code> means <em>reference</em> in C++.  It's different from a pointer, because it can't be null and you can't do pointer arithmetic on it.</p>

<p>Vector and list data types are part of Standard Template Library (STL).  It's a standard set of data structures for C++, much like java.util Collections are for Java.</p>
",2
10182083,10182021,0,"<p>In this instance the <code>&amp;</code> symbol means that <code>idata</code> is a reference to an object of type <code>istream</code>.  <a href=""http://www.cplusplus.com/reference/iostream/istream/"" rel=""nofollow""><code>istream</code> is a standard type</a> that many other types of input streams (<code>iostream</code>, <code>ifstream</code>, etc.) derive from.</p>
",0
10182106,10182021,1,"<p>The istream &amp; means pass by reference. References are sort of like pointers only a bit safer. I would suggest that you get a good C++ book. Since you already know basic programming and can program Java, you might like <a href=""http://www.acceleratedcpp.com/"" rel=""nofollow"">Accelerated C++</a>. It's a very good book and will help you pick-up idiomatic C++ quickly</p>
",0
10182126,10182021,3,"<p>Well, here's some stuff to start with:</p>

<p><a href=""http://en.cppreference.com/w/cpp"" rel=""nofollow"">C++ Reference</a>: This will get you started if you need to look up a standard class type.</p>

<p><a href=""http://www.parashift.com/c++-faq-lite/"" rel=""nofollow"">C++ FAQ</a>: This will help you if you get REALLY lost.  Most of it is edge cases, but some is best practice.</p>

<p>And you already found here, which is possibly the best of all for weird cases.</p>

<p>But as for your specific question, remember that in C++ you don't need to have your methods in a class.  There are ""free functions"" that are like methods, but don't belong to any class.  So <code>testSort</code> isn't a class, or a method of a class, but a stand-alone function, much like a static method on a static class in Java.</p>

<p>Also, the <code>list&lt;&gt;</code> class is more like a linked list, rather than the <code>List&lt;&gt;</code> or <code>ArrayList</code> types of Java.  The <code>vector&lt;&gt;</code> class is what you want for an array-like class in C++.</p>

<p>As for the <code>&amp;</code> symbol, it means a reference, which you should look up in some basic C++ guides for an explanation of value types vs pointers vs references.</p>

<p>The istream types are streams, which I hope you are familiar with from Java.  The C++ reference above has more on those in the ""IOStream Library"" section.</p>

<p>Good luck, and welcome to C/C++!</p>
",0
15531976,15531941,12,"<p>Much of this code began life as C code, and dated from the 1980s. If it were being written from scratch today then you could expect the code to look a little different. </p>

<p>For example, you pick out the <code>BOOL</code> type. Back in the day, when the Windows API was first conceived, there was no boolean type in C.</p>

<p>You mention the <code>MIN</code> and <code>MAX</code> macros and propose templates. Well, there are no templates in C as you know and those macros probably even pre-date C++ templates.</p>

<p>Although MFC is a C++ library, it stands atop Win32 which is a C API. And so the implementation of MFC will clearly have to use that C API in its implementation.</p>
",4
15532015,15531941,8,"<p>In Ye Olden C days (MS-DOS), <code>far</code> and <code>near</code> were pointer keywords. Many of these libraries were written in C to start with: therefore, instead of re-inventing the whole standard library from scratch, they just used something that already worked, and already worked reasonably well.</p>

<p>Also, Windows is mostly in essence a C API, not a C++ one, so you can expect many things (like Macros, strange definitions, etc.) to be present in the code.</p>
",1
11496351,11496313,4,"<p>After handling an exception, C++ continues execution with the code <em>after</em> the <code>catch</code> block. It does not ""resume"" from where the exception was thrown.</p>

<p>The solution would be to move the <code>try</code>/<code>catch</code> block <em>inside</em> the <code>while</code> loop of <code>calculate()</code>:</p>

<pre><code>void calculate()
{
    while (cin) {
        try {
            cout &lt;&lt; prompt;
            Token t = ts.get();
            while (t.kind == print)
                    t=ts.get();
            if (t.kind == quit) {
                    return;
            }
            ts.putback(t);
            cout &lt;&lt; result &lt;&lt; expression() &lt;&lt; endl;
         } catch (exception&amp; e) {
             cerr &lt;&lt; e.what() &lt;&lt; endl;
             clean_up_mess();
         }
    }
}
</code></pre>
",1
11496363,11496313,1,"<p>This is not a simple problem to solve. I mean, just pointing the error is not going to solve it. When you catch the exception, you call <code>clean_up_mess()</code>:</p>

<pre><code>catch (exception&amp; e)
{
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        clean_up_mess();
}
</code></pre>

<p>However, then the function just exits. And in <code>main()</code>, you don't do anything else apart from calling <code>calculate()</code>, so it ends anyway. In your clean_up_mess function, you just make the stream ignore the offending entries, but anything else.</p>

<p>You have to put your code inside a loop so it is able to follow the execution.</p>
",0
11496364,11496313,1,"<p>In your case, <code>while</code> loop reading the input is inside a try-catch block. As a result, when exception is thrown, the loop is terminated and a function returns after handling an exception. What you need to do is to put try-catch block inside a while loop so that it continues to read and process input.</p>
",0
11543613,11543555,4,"<p>You can't have a pointer to a function template, only to a function.  So really the templating is irrelevant; you'd do something like</p>

<pre><code>A *(*funcptr)() = &amp;createT&lt;A,B&gt;;
</code></pre>

<p>Demo: <a href=""http://ideone.com/NoHYS"" rel=""nofollow"">http://ideone.com/NoHYS</a>.</p>
",1
11543626,11543555,1,"<p>Exactly the same:</p>

<pre><code>base *(*funcptr)() = &amp;createT&lt;base, derived&gt;;
</code></pre>
",0
12869090,12869064,6,"<p>Try adding the library dxguid.lib (and possibly dinput8.lib) to your linker flags.</p>
",3
13695002,13694985,7,"<p><code>std::string CucumberMarket::check</code> It seems to be under the assumption that check returns <code>string</code>. This is your issue, you are expected it to take the <code>bool</code> returning one.<br>
If you want it to work correctly, simplest fix would be to force cast <code>price[i]</code> to <code>long long</code> as below    </p>

<p><code>for(int i = 0; i &lt; n and ans; ++i) ans &amp;= (this -&gt; check(price,(long long)price[i],i));</code></p>

<p>I would recommend your overloads dont be so close together signature wise.</p>
",0
13695025,13694985,2,"<p>Look at your error message: it's trying</p>

<pre><code>ans &amp;= check(..., int, int)
</code></pre>

<p>And that version of check returns a string.  You need a boolean expression on the right hand side of <code>&amp;=</code></p>
",0
9176220,9176132,2,"<p>You must allocate memory for ""Table"". For example:</p>

<pre><code>SArray::SArray(const int&amp; tsize, const int&amp; ttype)
{
    SArray_Size = tsize;
    DType = ttype;
    Table= new int[tsize];
    ...
</code></pre>

<p>Don't forget to free it in destructor.</p>
",3
9176266,9176132,3,"<p>The culprit is <code>int Table[]</code> - you have not specified how large your table is.</p>

<p>You should really replace it with <code>std::vector&lt;int&gt; Table;</code> and initialize it with <code>tsize</code>.</p>

<p>For instance:</p>

<pre><code>#include &lt;vector&gt;

class SArray
{
  private:
    int DType;
    std::vector&lt;int&gt; Table;
  public:
    const size_t getSize() const { return Table.size(); }
  public:
    SArray::SArray(const int tsize, const int ttype) :
      DType(ttype), Table(tsize)
    {
      int i, n = getSize();
      switch( ttype )
      {
        case 0:
          for (i = 0; i &lt; n; ++i) 
            Table[i] = rand() % 2;
          break;
        case 1:
          for (i = 0; i &lt; n; ++i)
            Table[i] = 1;
          break;
      }
    }
 };
</code></pre>
",0
17098973,17098950,2,"<p>Use a <code>switch</code> statement when you're identifying cases of numeric or ordinal values.</p>

<pre><code>switch (number)
{
    case 1: DoSomething();
        break;

    case 2: DoSomethingElse();
        break;
}
</code></pre>

<p>Use <code>if</code>, <code>elseif</code> and <code>else</code> for more complex conditions, like numeric ranges.</p>

<pre><code>if (number &gt; 0 &amp;&amp; number &lt;= 100)
{
   DoSomething();
}
else if (number &gt; 100 &amp;&amp; number &lt;= 1000)
{
   DoSomethingElse()
}
else
{
   NotifyOutOfRange();
}
</code></pre>
",6
17098982,17098950,0,"<p>You can use switch statements if you have too many ""else if"" statements :)</p>

<p>More seriously, if a player has many different choices (like picking from 26 different options (a-z), then switch is the way to go).  </p>
",1
17099585,17098950,0,"<p>Well, you can't really put strings into <code>switch</code>/<code>case</code>. That leaves you with <code>if</code>. or you'll need to implement parser that reads strings, maps them to some <code>enum</code> type, and then uses said <code>enum</code> within <code>switch</code>/<code>case</code>. </p>

<p>However a better (more extensible) way would be to use map of function callbacks.</p>

<p>Something like this:</p>

<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

typedef void(*ActionCallback)();
typedef std::map&lt;std::string, ActionCallback&gt; ActionMap;
static bool running = true;

void leftAction(){
    std::cout &lt;&lt; ""\""left\"" entered"" &lt;&lt; std::endl;
}

void rightAction(){
    std::cout &lt;&lt; ""\""right\"" entered"" &lt;&lt; std::endl;
}

void quitAction(){
    std::cout &lt;&lt; ""game terminated"" &lt;&lt; std::endl;
    running = false;
}

int main(int argc, char** argv){
    ActionMap actionMap;
    actionMap[""left""] = leftAction;
    actionMap[""right""] = leftAction;
    actionMap[""quit""] = quitAction;

    while(running){
        std::string command;
        std::cout &lt;&lt; ""enter command. Enter \""quit\"" to close"" &lt;&lt; std::endl;
        std::cin &gt;&gt; command;

        ActionMap::iterator found = actionMap.find(command);
        if (found == actionMap.end())
            std::cout &lt;&lt; ""unknown command "" &lt;&lt; command &lt;&lt; std::endl;
        else
            (*found-&gt;second)();
    }
    return 0;
}
</code></pre>

<p>The big advantage of this approach is that you can change commands at runtime. Add new commands, remove them, etc. You could even go a bit further and add lisp/python/lua binding and make it even more extensible.</p>
",0
17099019,17098950,2,"<p>In this very scenario you've described an <code>if</code> statement is pretty much your best option since the code needs to compare an answer provided by the user with some pre-defined options.</p>

<p>Those options will most likely be strings. <code>switch</code> statements in C++ cannot work on strings. Thus a series of <code>if</code> statements will probably be simpler.</p>

<p>A <code>switch</code> statement can be used when the answer only consists of a number or a single character.</p>

<p>For example, the code piece for the game's main menu could look like this:</p>

<p>Console output:</p>

<pre><code>Please select an action:
1) Start a new game.
2) Go to options screen.
3) Quit game.
</code></pre>

<p>code:</p>

<pre><code>int userChoice = getUserInput();

switch(userChoice){
case START_NEW_GAME: //1
    startGame(); break;
case OPTIONS: //2
    showOptions(); break;
case QUIT: //3
    exit(); break;
}
</code></pre>
",11
17099304,17098950,3,"<p>There are (give or take) five different solutions to ""I've received this input, what do I do now"". </p>

<ol>
<li>If/else if/else ... chain. Advantage is that you can use any expression that can be made into <code>true</code> or <code>false</code>. Disadvantage is that it can get pretty messy when you have a long chain of them. </li>
<li>Switch - great for ""there are lots of almost similar things to do"". Drawback is that the <code>case</code> labels have to be integer values (or <code>char</code> values, but not strings, floating point values, etc). </li>
<li>A table which makes the long if/else into a much simpler <code>if(table[index].something) ...</code></li>
<li>Function pointers - sort of a table pointer variant - store a pointer to the function that does whatever you want to do if you move in that direction. </li>
<li>Objects using virtual functions. Again, a variant on the <code>table</code> solution, but instead of storing function pointers, we store objects with some member function that we can use to ""do whatever you need to do"". </li>
</ol>

<p>The correct solution in this case is perhaps a combination/variation on one of the latter 3 - in my opinion, at least.</p>
",1
9192952,9192844,1,"<p>""total"" is never initialised (or modified).</p>
",0
9192958,9192844,3,"<p>The author lies. I can't find any place in the code where any value is assigned to <code>total</code> variable. So, <code>total</code> value remains <code>0</code> (<code>0</code> initialization of the global variable). Thus <code>perc = total / 3;</code> is equals <code>0</code> too.</p>
",5
10644601,10644593,19,"<p>Because you're seeding with the same value each time &ndash; <code>time</code> only has second-level precision, and I'm quite sure your computer can process those six loop iterations within one second. ;-]</p>

<p>Seed <em>once</em>, at the beginning of the program.</p>
",0
10644604,10644593,3,"<p>Because certainly you are usually feeding the srand the same seed every time because your loop is going to take a lot less than 1 second.</p>

<p>The srand function should only be called once in the lifetime of your program.</p>
",0
10644611,10644593,3,"<p>You should use <code>srand</code> once, at the beginning. Each possible seed corresponds to a specific set of pseudorandom numbers, which are always the same when that seed is used. Since you're going based off of seconds, you're not giving it time to change. Therefore, you're getting the first number of the same set of numbers each time.</p>
",0
9203598,9203512,4,"<p>Your .cpp file is wrong because is re-declaring the class, so that's and error. It should be something along the lines of:</p>

<pre><code>#include &lt;iostream&gt;
#include ""TicketOrder.h""
using namespace std;

//Getters
int TicketOrder::getQuantity() const
{
    return quantity;
}
char TicketOrder::getType() const
{
    return type;
}

//and so on
</code></pre>

<p>Also, note that adding a <code>using namespace</code> in a header file, as you are doing is, considered <em>very</em> bad style.</p>
",8
9204142,9203512,2,"<p>You can play with <a href=""http://www.lazycplusplus.com"" rel=""nofollow"">lzz</a>, it does exactly this automatically.  In it's default mode it will show you more or less where things usually go.</p>
",0
9215812,9203512,0,"<p>Rodrigo already addressed your main problem. Let me just add some style comment:</p>

<ul>
<li>you don't need <code>using namespace std</code>, since you are already addressing the std members with the <code>std::</code> prefix. In my opinion this is (almost) always the best solution, since the <code>using namespace X</code> directive could be inherited by some other files that include your .h file.</li>
<li>if you really want to use <code>using namespace std</code>, place that directive <strong>inside</strong> your class, so that other files that include yours won't have it. They might define functions/classes with the same name of the std ones, which would cause compilation errors if there is a <code>using namespace std</code> directive above...</li>
<li>your .cpp file does not need to include <code>&lt;iostream&gt;</code>, since it's already included in the header... Yes, <code>&lt;iostream&gt;</code> has for sure a header guard, so it's not really included twice. But I think it's nice to not include what's already included in the header... But maybe it's just my taste... ;-)</li>
</ul>
",0
18155492,18155266,1,"<p>First off, don't do this:</p>

<pre><code>const char* one = new char[3];
one = ""abc"";
</code></pre>

<p>You need to use <code>new</code> if you want to something like this:</p>

<pre><code>char* one = new char[4];
one[0] = 'a';
one[1] = 'b';
one[2] = 'c';
one[3] = 0; // null terminator
</code></pre>

<p>But, that's overkill when you just want it to point to a <a href=""https://en.wikipedia.org/wiki/String_literal"" rel=""nofollow"">string literal</a> (like ""abc""). Just do this:</p>

<pre><code>const char* one = ""abc"";
</code></pre>

<p>Also, you'll find that C++ is <em>much</em> easier if you use <code>std::string</code> instead of <code>char*</code>.</p>
",0
18155494,18155266,2,"<pre><code>const char* one = new char[3];
one = ""abc"";
</code></pre>

<p>The above assignment doesn't do a deep copy to the memory location you acquired. <code>one</code> is pointing to the string literal causing memory leak.</p>

<p>You are not responsible for deleting string literals. They have static storage duration and the operating system reclaims it's memory once the program quits.</p>
",2
18155496,18155266,5,"<p>Your resize function resizes to the size you give it (i.e. <code>index</code>), but then you set the array up to (and including) <code>index</code>. That's an invalid index - your array goes from <code>0</code> to <code>index-1</code>.</p>

<p>I'm talking about those lines:</p>

<pre><code>resize(index);
for (int i = prevsize+1; i&lt;=index; i++)
</code></pre>

<p>So you need to call <code>resize</code> with <code>index+1</code> to fix this problem.</p>

<p>Also:</p>

<pre><code>const char* one = new char[3];
one = ""abc"";
</code></pre>

<p>This simply leaks memory (you allocate a new buffer and then immediately set <code>one</code> to <code>""abc""</code> which is a different pointer).</p>
",0
10779810,10779769,0,"<p>I think <code>str_in[j] = '\0'</code> is wrong when the string has no any punctuation. </p>
",2
10779850,10779769,0,"<p>Instead of modifying the same string, create a new string (e.g. <code>str_out</code>) and append to that:</p>

<pre><code>str_out += str_in[i];
</code></pre>
",3
10779864,10779769,1,"<p>the C++ string type is NOT implemented to be null terminated (although a <code>c_str()</code> call <em>will</em> give you a null terminated string.)</p>

<p>So yes, <code>str_in[j] = '\0'</code> is wrong for at least two reasons:</p>

<ol>
<li>The <code>str_in.length()</code> will not reflect the size of the string you expect with the punctuation removed.</li>
<li>The null charatcter is an extra charter which will be sent to any output stream,<br>such as <code>cout &lt;&lt; str_in;</code></li>
</ol>

<p>Using the <code>std::string</code> class you should probably not oveeride the same buffer, but probably use a <code>str_out</code> buffer instead which will have the right length after you copy all the wanted (i.e. excluding the punctuation character), OR you should instead adjust the length of the <code>str_in</code> instead of adding the null.</p>
",0
10779887,10779769,4,"<p>If you want to truncate <code>str_in</code> to the first <code>j</code> characters, you can say <code>str_in.resize(j)</code>.</p>

<p>If you want to use the standard library you could apply the <code>erase-remove</code> idiom like this:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string str_in;
    std::getline(std::cin, str_in);

    // Here is where the magic happens...
    str_in.erase(std::remove_if(str_in.begin(), str_in.end(), ::ispunct), str_in.end());

    std::cout &lt;&lt; str_in &lt;&lt; '\n';

    return 0;
}
</code></pre>
",1
10759781,10759734,3,"<p>You need a semicolon after the class definition:</p>

<pre><code>class A: public Z
{
private:
  int num;
  public:
  virtual Z* aa();
  // ...
}; // &lt;-- SEMICOLON!!1
</code></pre>

<p>Also, make sure that <code>Z</code> is defined <em>before</em> <code>A</code> is defined, by <code>#include</code>ing <code>z.h</code> in <code>a.h</code>.</p>
",10
11822673,11822511,1,"<p>Your code has several syntax errors. If I want to, say, make a function to add two integer numbers, I'd do something like this:</p>

<pre><code>int add(int a, int b) //VARIABLES MUST CARRY A NAME!
{
    return a+b;
}
</code></pre>

<p>If you want to work with conditions, do this:</p>

<pre><code>if(a==5 &amp;&amp; b==6 || a==6 &amp;&amp; b==7) //Just as an example
</code></pre>

<p>Your fixed condition would be this:</p>

<pre><code>if (die1+die2==5 || die1+die2==7 || die1+die2==12)
</code></pre>

<p>Also, study variable scope. Let's say I have the following:</p>

<pre><code>int main()
{
    int myVar = 1;
}

int anotherFunction()
{
    println(""%d"", myVar); //This will cause an error, because myVar doesn't exist here, it only exists in main()
}
</code></pre>

<p>These are the most notable errors I can see in your code.</p>
",1
13728531,13728430,28,"<pre><code>std::transform( v1.begin()+1, v1.end(),
                v2.begin()+1, v.begin(),  // assumes v1,v2 of same size &gt; 1, 
                                          //       v one element smaller
                std::multiplies&lt;int&gt;() ); // assumes values are 'int'
</code></pre>

<p>You can replace <code>v.begin()</code> with <a href=""http://en.cppreference.com/w/cpp/iterator/back_inserter"" rel=""noreferrer""><code>std::back_inserter(v)</code></a> if <code>v</code> is empty, you should <code>reserve()</code> memory upfront to avoid multiple allocations.</p>
",5
13728703,13728430,12,"<p>You could look into <a href=""http://en.cppreference.com/w/cpp/numeric/valarray"" rel=""noreferrer"">std::valarray</a>. It's designed to allow mathematical operations on every element in the array.</p>
",0
13754224,13754173,3,"<p><code>unknown</code> is a <code>pair&lt;pair&lt;double, double&gt;, long&gt;</code>.</p>

<p>Impossible to guess what <code>FF</code> and <code>SS</code> mean with any certainty though. The obvious interpretation would be something about <code>FirstFirst</code> and <code>SecondSecond</code> -- but those don't fit with how they're being used (and while FirstFirst sort of makes sense, SecondSecond really doesn't, since unknown.second is a <code>long</code>, not a pair).</p>

<p>Having ruled that out, about all that's left is that they just stand for <code>first</code> and <code>second</code>, so <code>unknown.FF.SS</code> is equivalent to <code>unknown.first.second</code> and <code>unknown.FF.FF</code> is equivalent to <code>unknown.first.first</code>.</p>

<p>As to how to put data into an <code>unknown</code> like this, one possibility would be something like:</p>

<pre><code>unknown x = std::make_pair(std::make_pair(1.0, 2.0), 3L);
</code></pre>
",1
13754283,13754173,3,"<p>In C++, <code>std::pair&lt;F, S&gt;</code> has two members:</p>

<pre><code>F first;
S second;
</code></pre>

<p>Thus:</p>

<pre><code>typedef pair&lt;double,double&gt; pairD;
pair&lt;pairD, long&gt; unknown;
</code></pre>

<p>expands to <code>pair&lt;pair&lt;double, double&gt;, long&gt;</code>. Given:</p>

<pre><code>unknown = std::make_pair(std::make_pair(1.2, 2.4), 3);
</code></pre>

<p>then:</p>

<pre><code>std::cout &lt;&lt; unknown.first.first &lt;&lt; std::endl;
std::cout &lt;&lt; unknown.first.second &lt;&lt; std::endl;
std::cout &lt;&lt; unknown.second &lt;&lt; std::endl;
</code></pre>

<p>prints:</p>

<pre><code>1.2
2.4
3
</code></pre>
",0
11499617,11499524,9,"<p>Image you have this code:</p>

<pre><code>SYNCHRONIZE_ON(myVariable)
   // Do stuff
END_SYNCHRONIZE
</code></pre>

<p>It'll be rewritten to:</p>

<pre><code>{
    abcd::LockBase&amp; __lock = abcd::MakeLock(myVariable);
    __lock;

    // Do stuff
}
</code></pre>

<p>Actually the <code>__lock</code> variable won't be used in your code, it's there only to dispose the critical section (if it's what it uses) when it'll go out of scope.</p>

<p>The <em>problem</em> with that code is that it'll generate tons of warning because <code>__lock</code> is declared but never used. That statement is there to prevent those warnings and it'll be optimized away by the compiler (because it has no side effects), this is what your compiler will actually perform:</p>

<pre><code>{
    abcd::LockBase&amp; __lock = abcd::MakeLock(myVariable);

    // Do stuff
}
</code></pre>

<p><strong>EDIT</strong><br/>
This code should suppress ""unused variable"" warning but it may not save from ""expression has no effect"" warning. <code>pragma</code>s to disable specific warning aren't portable at all and Internet is full of workarounds to avoid them, like this (it seems to be pretty portable across compilers).</p>

<pre><code>{
    abcd::LockBase&amp; __lock = abcd::MakeLock(myVariable);
    (void)__lock;

    // Do stuff
}
</code></pre>

<p>In this case a better solution may be to split declaration and lock acquisition, like this:</p>

<pre><code>{
    abcd::LockBase&amp; __lock = abcd::MakeLock(myVariable);
    __lock.Acquire();

    // Do stuff
}
</code></pre>
",0
11499713,11499524,4,"<p>From this code it's very hard to guess what <code>__lock</code> is. Generally you should never name your stuff with names that start with <code>__</code>, because those are reserved for compiler developers. </p>

<p>In your case, the __lock can be either a macro (more likely), or a global variable (less likely). </p>

<p>You also have this line:
<code>const abcd::LockBase &amp; __lock</code>. Most likely this line declares a reference <code>__lock</code> to an object of a class <code>LockBase</code>. </p>

<p>So, here:
<code>const abcd::LockBase &amp; __lock =  abcd::MakeLock(x);</code> we just execute a function call. However, <code>__lock</code> isn't used anywhere else within the block, so the compiler will give you a warning about ""<em>unused variable <code>__lock</code></em>"". Therefore, the <code>__lock;</code> statement is probably added to suppress this warning. This is, to mention, a way of warning-suppression that Herb Sutter recommends in his book <em>""C++ Coding Standards: 101 Rules, Guidelines, and Best Practices""</em></p>

<p>Sorry if my explanation is a bit messy, hope you'll get the general idea. </p>
",0
13410547,13410444,1,"<p>ADTs should not have any member variables, and because private member functions are part of the implementation, they should not have any of those either.</p>

<p>An ADT is a description of an interface. The interface of a class is (generally) a set of public member functions, which the outside world uses to interact with the underlying object. The phrase ""concrete details about the representation"" refers to information about how something is represented. For example, in C++, <code>vector</code>s are stored internally as dynamically allocated arrays. This fact is not important to their use as dynamic lists. Therefore, it is not included in the interface.</p>
",0
12875438,12875319,1,"<p>The problem with the line <code>projectile = new Projectile()</code> is that the return valued from the expression <code>new Projectile()</code> is a <code>Projectile*</code>, not a <code>Projectile</code> object. You're then trying to assign it to a Projectile object and that isn't going to work.</p>

<p>You should be able to get the code compiling by replacing that line with <code>projectile = Projectile()</code> if you don't want to convert the code to use pointers. Another option would be to add a member function that resets a Projectile object to its default state. The latter can be very beneficial if a Projectile object is expensive to construct and copy.</p>
",2
9857299,9857252,1,"<p>if the .cpp files are #include-ing their header file, all you need to do is to include the headerfiles in the main. Is that what you wanted to do? </p>

<p>main:</p>

<pre><code>#include List.h 
#include account.h
</code></pre>

<p>Account.cpp</p>

<pre><code>#include account.h
</code></pre>

<p>Same thing for list.cpp</p>
",1
9857303,9857252,0,"<p>Assuming that your files follow the standard header (.h) and implementation (.cpp) layout, you should just be able to include your header files in your main.cpp.</p>

<p>For example: If I had files Class.h with the class defenition, Class.cpp with the class implementation and main.cpp where I wish to use Class, I would simply add #include ""Class.h"" to the top of main.cpp</p>

<pre><code>#include &lt;iostream&gt;
#include ""Class.h""

int main()
{
    //...Rest of code
    return 0;
}
</code></pre>

<p>It would be helpful to know what compiler and platform you're using if you need further instructions. (e.g. Visual Studio/gcc, Windows/Linux/Mac, etc.)</p>
",9
9857357,9857252,0,"<p>You can put class declarations in a <code>.h</code> or <code>.hpp</code> file with the same name as the class name and put the definitions in <code>.cpp</code> with the same name as the class name. For example in your case assuming you have an <code>Account</code> class, put the class declarations in <code>Account.h</code> file and the class definition in <code>Account.cpp</code> file. <code>main.cpp</code> file would be the application code which uses this class. </p>

<p>This link would give a better idea:</p>

<p><a href=""http://pages.cs.wisc.edu/~hasti/cs368/CppTutorial/NOTES/CLASSES-INTRO.html"" rel=""nofollow"">http://pages.cs.wisc.edu/~hasti/cs368/CppTutorial/NOTES/CLASSES-INTRO.html</a></p>
",0
12335183,12335175,1,"<p>It's not needed, although private inheritance is a code smell as it doesn't fully reflect an is-a relationship (as should inheritance).</p>

<pre><code>class ChildClass : ParentClass
</code></pre>

<p>is equivalent to</p>

<pre><code>class ChildClass : private ParentClass
</code></pre>

<p>and it doesn't mean <code>ChildClass</code> inherits only private members of the base class, but limits their accesiblity to the specified level. That means methods inherited the base class become private in the derived class.</p>
",0
12335186,12335175,0,"<p>C++ also allows <strong>protected inheritance</strong> and <strong>private inheritance</strong>.</p>

<p>Classes default to private.  Structs default to public.</p>
",0
12335197,12335175,0,"<p>You can also have private and protected inheritance. What you have here</p>

<pre><code>class ChildClass : ParentClass {
</code></pre>

<p>would result in private inheritance. </p>
",0
12335216,12335175,1,"<p>If you didn't have <code>public</code> there, it would be the equivalent of the following:</p>

<pre><code>class ChildClass : private ParentClass
</code></pre>

<p>This is because <code>class</code>s have <code>private</code> access by default.</p>

<p>Also, <code>private</code>, <code>protected</code> and <code>public</code> are call <em>access-specifiers</em>. This has nothing to do with what gets inherited, but what you are able to <em>access</em> in the derived class.</p>

<p>If you want to have default <code>public</code> inheritance, use a <code>struct</code> instead:</p>

<pre><code>struct ChildClass : ParentClass
</code></pre>

<p>The above is the equivalent of <code>struct ChildClass : public ParentClass</code> because <code>struct</code>s have <code>public</code> access by default. </p>
",0
12335338,12335325,3,"<p>If <code>ChildClass</code> is derived from <code>ParentClass</code> then the derived destructor is called first, followed by the parent class. As it stands in your code, <code>ChildClass</code> does not inherit from <code>ParentClass</code></p>
",0
12335357,12335325,1,"<p>Yes, both constructors are call: construction and destruction are symmetric: All subobjects get destroyed in exactly the opposite order they were created. For the order of destruction it doesn't matter if the destructor is virtual. The only impact of virtual vs. non-virtual destructors is when <code>delete</code>ing an object of a dreived type using a pointer to a base: This results in undefined behavior if the destructor of the base isn't virtual.</p>
",0
18981035,9484588,0,"<p>It is one of the simplest logics, got it from a blog. in this logic you can limit the random numbers with that given modulus(%) operator inside the for loop, its just a copy and paste from that blog, but any way check it out:</p>

<pre><code>// random numbers generation in C++ using builtin functions
#include &lt;iostream&gt;

using namespace std;

#include &lt;iomanip&gt;

using std::setw;

#include &lt;cstdlib&gt;   // contains function prototype for rand

int main()
{
// loop 20 times
for ( int counter = 1; counter &lt;= 20; counter++ ) {

    // pick random number from 1 to 6 and output it
    cout &lt;&lt; setw( 10 ) &lt;&lt; ( 1 + rand() % 6 );

    // if counter divisible by 5, begin new line of output
    if ( counter % 5 == 0 )
        cout &lt;&lt; endl;

}

return 0;  // indicates successful termination

} // end main
</code></pre>

<p>- See more at: <a href=""http://www.programmingtunes.com/generation-of-random-numbers-c/#sthash.BTZoT5ot.dpuf"" rel=""nofollow noreferrer"">http://www.programmingtunes.com/generation-of-random-numbers-c/#sthash.BTZoT5ot.dpuf</a></p>
",0
9810122,9810088,6,"<p>I made a generic Numeric class a while ago. Here:</p>
<pre><code>template&lt; typename T&gt; class TypeWrapper
{
    T value;
public:
    TypeWrapper(T v): value(v) {}

    operator T() { return value; }

    // basic arithmetic operators
    void operator = (T v){  value = v; }

    TypeWrapper operator + (T v) { return TypeWrapper( value + v ); }
    TypeWrapper operator - (T v) { return TypeWrapper( value - v); }
    TypeWrapper operator * (T v) { return TypeWrapper( value * v); }
    TypeWrapper operator / (T v) { return TypeWrapper( value / v); }
    TypeWrapper operator % (T v) { return TypeWrapper( value % v); }

    void operator += (T v) { value += v; }
    void operator -= (T v) { value -= v; }
    void operator *= (T v) { value *= v; }
    void operator /= (T v) { value /= v; }
    void operator %= (T v) { value %= v; }

    T operator ++ () { return ++value; }
    T operator -- () { return --value;}
    T operator ++ (int v) { return value++; }
    T operator -- (int v) { return value--; }

    // conditions
    bool operator == (T v) { return value == v; }
    bool operator != (T v) { return value != v; }
    bool operator &gt; (T v) { return value &gt; v; }
    bool operator &lt; (T v) { return value &lt; v; }
    bool operator &gt;= (T v) { return value &gt;= v; }
    bool operator &lt;= (T v) { return value &lt;= v; }

    T toPrimitive() { return value; }
    string toString()
    {
        stringstream ss;
        string rtn;

        ss &lt;&lt; value;
        ss &gt;&gt; rtn;

        return rtn;
    }
};

// just to make things easier for a future move.
#define NumericTypeWrapper TypeWrapper

    typedef NumericTypeWrapper&lt; int &gt; Integer;
    typedef NumericTypeWrapper&lt; double &gt; Double;
    typedef NumericTypeWrapper&lt; float &gt; Float;
}
</code></pre>
",5
14782885,14782809,0,"<p>In extension to what David said:</p>

<p><code>ostream</code> is just the ""frame"" of an output stream, a definition of basic capabilities of an output stream (abstract class). It does nothing and is not implemented.</p>

<p>Did you try to write to <code>cout</code> perhaps? <code>cout</code> is defined in <code>iostream</code>, you do not need to define it, just use it!</p>
",0
14782904,14782809,3,"<p><a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/basic_ostream"" rel=""nofollow""><code>std::ostream::ostream()</code> constructor is protected</a>, which means it can only be invoked by its derived class, but not but its enclosing one.</p>

<p>To fix the error initialize member <code>out</code>. </p>

<p>The only public constructor of <code>std::ostream</code> accepts a <code>std::streambuf*</code>, e.g.:</p>

<pre><code>Log::Log(const char *file)
    : out(std::cout.rdbuf())
// ...
</code></pre>

<p>Note, that it is safe to initialize a <code>std::ostream</code> with the buffer from <code>std::cout.rdbuf()</code>, because destructor <code>std::ostream::~ostream()</code> does not deallocate its <code>std::streambuf*</code> member.</p>

<p>Alternatively, it can be initialized with a <code>NULL</code>/<code>nullptr</code>. In this case be careful to not output anything into the stream as it would try dereferencing that <code>NULL</code> leading to undefined behaviour, most likely just crash with <code>SIGSEGV</code>.</p>
",1
15890342,15890310,3,"<p>Assuming you aren't storing pointers in the queue, but instead actual values or objects, then when you store front() to a regular variable what you're really doing is a copy (if it's an object, the actual copy constructor will be called). The copy won't be effected when you pop() the element of the queue. </p>
",6
15890346,15890310,-2,"<p>If you store it with front() and you pop it afterwards your object does no longer exist (supposing you're using queue from STL)</p>

<p>This happens because front() returns the contained object by reference not copy.</p>
",0
15890428,15890310,2,"<p>I'll try to answer in code:</p>

<pre><code>#include &lt;queue&gt;
#include &lt;iostream&gt;

int main()
{
    // ""Q: If I create a queue in C++...""
    std::queue&lt;int&gt; q;

    // ""...add two elements to it...""
    q.push(42);
    q.push(1729);

    // ""...then call front(), store it in a regular variable (no pointer)...""
    int i = q.front();

    // ""...Then I call pop() on the queue...""
    q.pop();

    // ...The variable i stored will still exist right?""

    // A: ""Yes, of course! And it retained its value:""
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>

<p>Moreover:</p>

<blockquote>
  <p>""What happens if something edits the memory address where the pointer in queue used to live?""</p>
</blockquote>

<p>We did not store a pointer in the queue (see above)! Anyway, if you meant ""<em>What happens if the region of memory where the queue had its popped element stored gets released or overwritten</em>"", the answer is that we stored a <strong>copy</strong> of that object in <code>i</code>, and <code>i</code> lives in a completely different region of memory.</p>

<blockquote>
  <p>""Does that mean the local variable <code>i</code> stored earlier is no longer valid since it was created from a reference?""</p>
</blockquote>

<p>No, it is still valid, because even though it was assigned from an object which was referenced through the return value of <code>front()</code>, we made a <strong>copy</strong> of that object!</p>
",4
14831625,14831480,6,"<p>Do something like this:</p>

<pre><code>class GameObject
{
public:
    int id;
    GameObject() : id(++s_id) {}
protected:
    static std::atomic&lt;int&gt; s_id;
};

// in the .cpp file:
std::atomic&lt;int&gt; GameObject::s_id;
</code></pre>

<p>This way, each object constructed will get the next id, starting from 1 (because the static will be initialized to zero by default).  It probably doesn't matter what value you start from.  You might want to take care when writing copy constructors, assignment operators, and the like.  Finally, note that the atomic type is part of C++11; if you don't have support for it you can say ""boost"" instead of ""std"" there.  Either version will give you thread safety, in case you need it.</p>
",0
14831535,14831480,4,"<p>No, each instance of <code>GameObject</code> will have its own (uninitialized) instance of <code>id</code>. There needs to be a shared incrementing <code>id</code> instance available to all instances of <code>GameObject</code>. One mechanism to achieve this to use a <code>static</code> class variable. If threads are involved you need to synchronize access to the <code>static</code> variable:</p>

<pre><code>class GameObject
{
protected:
    static int id;
};

int GameObject::id; // defaults to zero and should be added to
                    // exactly one .cpp file only.

GameObject::GameObject() : instances(GameObject::id++) {}
</code></pre>

<p>Another alternative is to use <a href=""http://www.boost.org/doc/libs/1_53_0/libs/uuid/"" rel=""nofollow""><code>boost::uuid</code></a>:</p>

<pre><code>#include &lt;string&gt;
using std::string;

#include &lt;boost/lexical_cast.hpp&gt;
#include &lt;boost/uuid/uuid.hpp&gt;
#include &lt;boost/uuid/uuid_generators.hpp&gt;
#include &lt;boost/uuid/uuid_io.hpp&gt;
using boost::lexical_cast;
using boost::uuids::uuid;
using boost::uuids::random_generator;

class GameObject
{
public:
    string instances;
    GameObject() : instances(make_uuid_());
    void Display();
private:
    string make_uuid_()
    {
        return lexical_cast&lt;string&gt;((random_generator())());
    }
};
</code></pre>
",10
14831536,14831480,2,"<p>This is not correct because <code>id</code> merely has an <strong>indeterminate value</strong>(<em>since it is uninitialized</em>) not unique value.     </p>

<p>You could address of an object as the unique identifier. Each object in C++ is placed at an different address. However, if you need to identify each object this way there is something amiss in your design.</p>
",3
10164403,10164310,1,"<p>You are trying to assign a LONGLONG to a LARGE_INTEGER. No such assignment exists. Perhaps you meant to assign to numCounts.QuadPart.</p>
",1
9224133,9223619,1,"<p>Using <code>std::vector</code> on <code>fdata</code>:</p>

<pre><code>size_t rowCount = /* ... */;
std::vector&lt;SQLFLOAT&gt; fdata(rowCount);
// ...
SQLSetStmtAttr(SQL_ATTR_ROW_ARRAY_SIZE, rowCount);
// ...
SQLBindCol(3, &amp;fdata[0]);
// ...
</code></pre>

<p>For <code>cdata1</code>, <code>std::vector&lt;SQLCHAR&gt; cdata1(250 * rowCount);</code>  might work.</p>
",0
9224190,9223619,0,"<p>Use pointers.</p>

<p>Accept the ROWS argument from command line as you said. Allocate memory of desired size (ROWS argument that you get) using dynamic memory allocation by using malloc/new to all the variables you have declared like idata, cdata1 etc. That's it!</p>
",0
17843784,17843752,6,"<p>When you specify an array as a function argument, it degrades to a pointer. So <code>sizeof(a)</code> is the size of a pointer, <em>not</em> the (byte) size of the array. You'll need to pass the length in as a separate argument, or use something like <code>std::vector</code>.</p>
",3
17843825,17843752,1,"<p>C does not store the length of the array in memory, so the called function has no way
of knowing how long the array is.</p>

<p><code>sizeof</code> is evaluated at compile time, unless you apply it to a array literal, you will not get the length of the array.</p>

<p>You may want to consider passing a <code>std::vector&lt;int&gt;</code> by reference instead.</p>
",0
13411663,13411634,2,"<p>In the first case you're initializing <code>j</code> correctly and the cast is superfluous. In the second case you're doing it wrong (i.e. to an object of a different type) but the cast shuts the compiler up.</p>

<p>In this second case, what you get is probably the internal representation of <code>1.0</code> interpreted as in integer.</p>
",0
13411686,13411634,0,"<p>The first one first casts <code>b</code> to an <code>int</code> before assigning it to <code>i</code>. This is the ""proper"" way, as the compiler will properly convert the value.</p>

<p>The second one does no casting and re-interpret's <code>b</code>'s bits as an integer. If you read up on <a href=""http://en.wikipedia.org/wiki/IEEE_floating_point"" rel=""nofollow"">floating point format</a> you can see exactly why you're getting the value you're getting.</p>

<p>Under the covers, all your variables are just collections of bits. How you interpret those bits changes the perceived value they represent. In the first one, you're rearranging the bit pattern to preserve the ""perceived"" value (of 1). In the second one, you're not rearranging the bit pattern, and so the perceived value is not properly converted.</p>
",0
13411736,13411634,3,"<p>In the first one, you are doing everything fine. The compiler is able to convert <code>float b</code> to <code>int i</code>, losing precision, but it's fine. Now, take a look at my debugger window during the execution of your second example:</p>

<p><img src=""https://i.stack.imgur.com/aRO4V.png"" alt=""enter image description here""></p>

<p>Sorry for my Russian IDE interface, the first column is variable name, the second is value, and the third is type.</p>

<p>As you can see, now the float is simply interpreted as int. So the leading <code>1</code> bits are interpreted as the integer's bits, which leads to the result you are getting. So basically, you take the float's binary representation (usually it's represented as sign bit, mantissa and exponent), and try to interpret it as an <code>int</code>. </p>
",0
13412099,13411634,1,"<p>Integer <code>1</code> and floating-point <code>1.0f</code> may be mathematically the same value, but in C++ they have different types, with different representations.</p>

<p>Casting an <em>lvalue</em> to a reference is equivalent to <code>reinterpret_cast</code>; it says ""look at whatever is in this memory location, and interpret those bytes as an <code>int</code>"".</p>

<p>In the first case, the memory contains an <code>int</code>, so interpreting those bytes as an <code>int</code> gives expected value.</p>

<p>In the second case, the memory contains a <code>float</code>, so you see the bytes (or perhaps just some of them, or perhaps some extra ones too, if <code>sizeof(int) != sizeof(float)</code>) that represent the floating-point number, reinterpreted as an integer.</p>

<p>Your computer probably uses 32-bit <code>int</code> and 32-bit <a href=""http://en.wikipedia.org/wiki/IEEE_floating_point"" rel=""nofollow"">IEEE</a> <code>float</code> representations. The <code>float</code> value <code>1.0f</code> has a sign bit of zero, an exponent of zero (represented by the 8-bit value 127, or 01111111 in binary), and a mantissa of 1 (represented by the 23-bit value zero), so the 32-bit pattern would look like:</p>

<pre><code>00111111 10000000 00000000 00000000
</code></pre>

<p>When reinterpreted as an integer, this gives the hex value <code>0x3f800000</code>, which is 1065353216 in decimal.</p>
",2
13411761,13411634,1,"<p>Reference doesn't do any memory allocation, it just places an entry into table of local names and their addresses. In first case name 'j' points to the memory previously allocated to int datatype (for variable 'i'), while in second case name 'j' points to memory allocated to float datatype (for variable 'b'). When you use 'j' compiler interprets data at the appropriate address as if it was int, but in fact some float is placed there, that's why you get some ""strange"" numbers instead of 1</p>
",0
10775383,10775332,3,"<p>When you are calling <code>s = ss.str();</code>, it does not consume the buffer, so the next time you try to extract an <code>int</code>, the extraction fails as the <code>ss</code> buffer still contains the initial string (and not just the string representation of the number that you appended at the end).  You could create a new stringstream object for the <code>int</code> extractions or consume all content before attempting to extract the <code>int</code>s</p>
",1
10788629,10788611,2,"<p>It forces derived classes to implement it, while still providing derived implementations with a common behaviour that you don't want invoked from anywhere else than derived classes. </p>
",0
10788645,10788611,1,"<p>Pure <code>virtual</code> methods are meant to act as completely <code>abstract</code> methods akin to other languages, such as Java and C#. A C++ <code>class</code> filled with only pure <code>virtual</code> methods is representative of an <code>interface</code> from other languages.</p>

<p>Giving them a body is an abuse of that ideal, and it defeats the purpose. If the base <code>class</code> wants to provide functionality to only its children, then it should do so through a <code>protected</code>, non-pure <code>virtual</code> method (can still be <code>virtual</code> if it makes sense).</p>
",0
10788647,10788611,5,"<p>It is used in the exact way you mentioned in the question, that there is some common logic that can be reused by the derived classes but at the same time you want to <em>force</em> the derived classes to provide the implementation for the non-common part.</p>
",0
10788741,10788611,0,"<p>This question is propably a duplicate of <a href=""https://stackoverflow.com/questions/5481941/c-pure-virtual-function-have-body"">C++ pure virtual function have body</a>
I've seen this primarily used with pure virtual destructors (which need an implementation).
Another good answer that explains cases beyond the pure virtual destructor use can be found here: <a href=""http://www.gotw.ca/gotw/031.htm"" rel=""nofollow noreferrer"">(Im)pure Virtual Functions</a></p>
",0
9774872,9774803,2,"<p>Variadic function arguments are <strong>not</strong> typesafe, or any kind of 'safe' for that matter. It is <em>your</em> responsibility to communicate to your function how many arguments there are and what their types are.</p>

<p>In your code, the only thing that makes the loop terminate is when <code>x</code> evaluates as false. Your data, obscurely typed as it is, seems to consist of integral values, and that would necessitate your last variadic argument to be zero, which it isn't in your example.</p>

<p>Try calling the function wtih <code>(n, x1, x2, x3, 0)</code>.</p>
",0
9775009,9774803,1,"<pre><code>#include &lt;stdarg.h&gt;
#include &lt;iostream&gt;
void zytaj(int n, ...) {
  int i;
  va_list arg;
  va_start (arg, n); 
  for (i = 0; i &lt; n; i++) {
    int val = va_arg(arg, int);
    std::cout &lt;&lt; val &lt;&lt; std::endl;
  }
  va_end (arg);
}

int main()
{
  zytaj(3, 4, 1, 7); 
  return 0;
}
</code></pre>
",0
11554434,11545630,0,"<p>There are other ways to export from a DLL. 
See <a href=""http://msdn.microsoft.com/en-us/library/d91k01sh%28v=vs.100%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/d91k01sh%28v=vs.100%29.aspx</a></p>
",1
14847346,14847180,3,"<p><em>Almost</em> everything in your copying loop has problems.</p>

<pre><code>while (!in.eof())
</code></pre>

<p>This is broken. Not much more to say than that.</p>

<pre><code>       bzero(tempBuffer, size);
</code></pre>

<p>This is fairly harmless, but utterly pointless.</p>

<pre><code>            in.read(tempBuffer, size);
</code></pre>

<p>This the ""almost"" part -- i.e., the one piece that isn't obviously broken.</p>

<pre><code>            out.write(tempBuffer, strlen(tempBuffer));
</code></pre>

<p>You don't want to use <code>strlen</code> to determine the length -- it's intended only for NUL-terminated (C-style) strings. If (as is apparently the case) the data you read may contain zero-bytes (rather than using zero-bytes only to signal the end of a string), this will simply produce the wrong size.</p>

<p>What you normally want to do is a loop something like:</p>

<pre><code>while (read(some_amount) == succeeded)
    write(amount that was read);
</code></pre>

<p>In C++ that will typically be something like:</p>

<pre><code>while (infile.read(buffer, buffer_size))
    outfile.write(buffer, infile.gcount());
</code></pre>

<p>It's probably also worth noting that since you're allocating memory for the buffer using <code>new</code>, but never using <code>delete</code>, your function is leaking memory. Probably better to do without <code>new</code> for this -- an array or vector would be obvious alternatives here.</p>

<p>Edit: as for why <code>while (infile.read(...))</code> works, the <code>read</code> returns a reference to the stream. The stream in turn provides a conversion to <code>bool</code> (in C++11) or <code>void *</code> (in C++03) that can be interpreted as a Boolean. That conversion operator returns the state of the stream, so if reading failed, it will be interpreted as <code>false</code>, but as long as it succeeded, it will be interpreted as <code>true</code>.</p>
",6
14781727,14781629,4,"<p>You create <code>tmp</code> with <code>std::ostream tmp(buf);</code> and store the address of it in <code>out</code> with <code>this-&gt;out = &amp;tmp;</code>. However, <code>tmp</code> will go out of scope at the end of the constructor and the pointer will no longer be pointing at a valid object.</p>

<p>What you should do instead is make <code>out</code> not a <code>std::ostream*</code> but simply a <code>std::ostream</code>:</p>

<pre><code>std::ostream out;
</code></pre>

<p>Then in your constructor, once you've got the <code>buf</code> ready, you can give it to <code>out</code> by doing <code>out.rdbuf(buf);</code>.</p>

<hr>

<p>Response to edit:</p>

<p>The <code>std::ostream</code> doesn't have a default constructor - it has to take a buffer pointer. My mistake. However, the fix is simple. Use your constructor's member initialization list to pass a null pointer (<code>nullptr</code> in C++11, <code>0</code> or <code>NULL</code> in C++03):</p>

<pre><code>Log::Log(const char *file)
  : out(nullptr)
{
  // ...
}
</code></pre>
",7
15567592,15567517,4,"<p>The complexity of the program is huge - it would take forever to run. It is possibly valid, but the number of iterations in <code>for</code> loops is just enormous.</p>

<p>You are trying to run this loop:</p>

<pre><code>for (unsigned __int64 i = 300851475143; i &gt; 2; i--)
</code></pre>

<p>which alone is way too big for the program to finish quickly.</p>

<p>In addition to that, in <code>prime()</code> you're running a second loop:</p>

<pre><code>for (unsigned __int64 i = 2; i &lt; para; i++)
</code></pre>

<p>which (since <code>para</code> is related to <code>i</code> in the outer loop) makes the complexity O(n^2)</p>
",0
15567593,15567517,2,"<p>You know <code>300851475143</code> is a huge number and you have two nested loops which work around this number !</p>

<p>If each iteration takes <code>1ns</code> you need <code>300s x 300s = 25 hours</code> to finish the job. <em>(It's just an approximation)</em></p>
",1
11496042,11496033,5,"<p>That symbol is called a <a href=""http://en.wikipedia.org/wiki/Caret"" rel=""nofollow"">caret</a>. The ASCII code is <code>0x5e</code> in hexadecimal (= 94 in decimal).</p>

<p>C version:</p>

<pre><code>printf(""%c"", 0x5e);
</code></pre>

<p>C++ version:</p>

<pre><code>std::cout &lt;&lt; static_cast&lt;char&gt;(0x5e);
</code></pre>

<p>Both of these assume that you are running on a system where the default character encoding assigns the caret symbol the value <code>0x5e</code>.</p>

<p>To avoid having to rely on this assumption it is better to not use the ASCII code but instead use <code>'^'</code>.</p>
",2
11496046,11496033,0,"<p>According to this page: <a href=""http://www.ascii-code.com/"" rel=""nofollow"">http://www.ascii-code.com/</a></p>

<p>It's ASCII code 0x5e.</p>
",0
11496120,11496033,2,"<p>The hexadecimal value for the <em>caret</em> character (<code>^</code>) is <strong>most often</strong> <em>0x5e</em> (<em>94</em> in decimal).</p>
<pre><code>std::cout &lt;&lt; static_cast&lt;char&gt; (0x5e) &lt;&lt; &quot; &quot; &lt;&lt; (char)94 &lt;&lt; &quot; &quot; &lt;&lt; '\x5e';
</code></pre>
<p><sup><sup><strong>output on my playform</strong>: <code>&quot;^ ^ ^&quot;</code></sup></sup></p>
<hr />
<p>I write <em>&quot;most often&quot;</em> because the standard <strong>doesn't</strong> guarantee what integer value is used to represent a certain character, therefore you shouldn't do what you are implying.</p>
<p>Even though it will probably work out the way you want to (since most modern <em>operating-system</em> represent <em>caret</em> using that value) it's not recommended.. if it's not in the standard no one can guarantee you that it is going to work on all platforms, in all cases.</p>
<hr />
<h3>What does the standard say?</h3>
<blockquote>
<h3>2.3/3???Character sets???[lex.charset]</h3>
<p>The execution character set and the execution wide-character set are
implementation-defined supersets of the basic execution character set
and the basic execution wide-character set, respectively. <strong>The values
of the members of the execution character sets and the sets of
additional members are locale-specific</strong>.</p>
</blockquote>
",0
9796489,9796475,3,"<p>Several issues:</p>

<p>You are only resizing the first vector.  You need to resize all of them.</p>

<p>Instead consider using this:</p>

<pre><code>vector&lt; vector&lt;int&gt; &gt; vetor (10, vector&lt;int&gt;(10, 0));
</code></pre>

<p>this will create a 10 x 10 vector of vectors.</p>

<p>vector has a constructor (size_t size, T default_value) which constructs the vector with size elements of value default_value.</p>

<p>If the size of the vector is known at compiletime and is not going to change you can also use a std::array instead for a slight performance gain.</p>

<p>Secondly use vector::size() not vector::capacity() to determine the size of a vector (capacity refers to the backing store, and can be largely ignored except for optimization)</p>

<pre><code>for(int i = 0; i &lt; vetor.size(); i++){
    for(int h = 0; h &lt; vetor[0].size(); h++){
        vetor[i][h] = h;
    }
}
</code></pre>

<p>When you resize vetor[0].resize(10) you are only resizing the first element.</p>

<p>You would need to:</p>

<pre><code>vetor[0].resize(10)
vetor[1].resize(10)
vetor[2].resize(10)
.
.
vetor[10].resize(10)
</code></pre>

<p>to do what you want to do.</p>

<p>(Put another way each vector in the vector of vectors has a potentially different size.  It is not a matrix class.)</p>
",6
11857173,11857150,24,"<p>The first <code>()</code> is the name of the operator - it's the operator that is invoked when you use <code>()</code> on the object. The second <code>()</code> is for the parameters, of which there are none.</p>

<p>Here's an example of how you would use it:</p>

<pre><code>background_task task;
task();  // calls background_task::operator()
</code></pre>
",4
11857189,11857150,31,"<p>You can overload the <code>()</code> operator to call your object as if it was a function:</p>

<pre><code>class A {
public:
    void operator()(int x, int y) {
        // Do something
    }
};

A x;
x(5, 3); // at this point operator () gets called
</code></pre>

<p>So the first parentheses are always empty: this is the name of the function: <code>operator()</code>, the second parentheses might have parameters (as in my example), but they don't have to (as in your example).</p>

<p>So to call this operator in your particular case you would do something like <code>task()</code>.</p>
",3
11857220,11857150,8,"<p>The first part <code>operator()</code> is the way to declare the function that is called when an instance of the class is invoked as a function.  The second pair of parentheses would contain the actual arguments.</p>

<p>With a return value and arguments  this might make a bit more sense:</p>

<pre><code>class Adder{
public:
int operator()(int a, int b){
    //operator() -- this is the ""name"" of the operator
    //         in this case, it takes two integer arguments.
    return a+b;
}
};
Adder a;
assert( 5==a(2,3) );
</code></pre>

<p>In this context, the <code>std::thread</code> will internally invoke <code>f()</code> inside the thread, i.e. whatever is inside the body of <code>operator()</code> is what gets done inside that thread.</p>
",0
13431076,13430944,1,"<p>The first statement about ""Variables defined outside any function body"" refers to objects with static linkage, i.e., variables declared in namespaces: These are zero initialized. The members in the <code>struct</code> get initialized wherever this <code>struct</code> lives. If it lives on the stack or is allocated on the heap, the built-in variable won't get initialized without the assignments, e.g., when used like this:</p>

<pre><code>void f() {
    Sales_data data;
}
</code></pre>

<p>Even without the initialization in the declaration, they would get zero-initialized if the <code>struct</code> is used like this, though:</p>

<pre><code>Sales_data global; // &lt;--- the ""outside any function body"" case
void f() {
    Sales_data data0 = {};
    Sales_data data1 = Sales_data();
    Sales_data data2{};
}
</code></pre>

<p>However, these all require cooperation by the user of the <code>struct</code> and initializing them explicitly makes sure the values are set.</p>
",0
13431088,13430944,2,"<p>The quote seems to be in wrong context. A variable can have at least 3 states:</p>

<ol>
<li><strong>Default initialized</strong>: Variable is initialized inside the constructor
based on argument or no argument. <em>Value initialized</em> is a special case of this type</li>
<li><strong>In-class initialized</strong>: The C++11 feature which you have presented in
your code</li>
<li><strong>Uninitialized</strong>: Variable's initialization is not addressed anywhere
and it can contain any garbage value. Some compilers may automatically make it <code>0</code> or give a warning</li>
</ol>
",0
14220626,14220573,1,"<p><code>char * string = new char[20]</code> is going to be filled with whatever is in the allocated memory before it was allocated.</p>

<p>You can memset the array to 0 to achieve what you want.</p>

<pre><code>char * string = new char[20];
memset(string, 0x00, sizeof(char) * 20);
</code></pre>

<p>Overwriting new could do this as well.</p>

<pre><code>void* operator new(size_t n){
   void * mem = malloc(n);
   memset(mem, 0x00, n);
   return mem;
}
</code></pre>
",1
14220632,14220573,1,"<p><code>new</code> does not zero-initialize primtive types (like <code>char</code>).  Using <code>memset</code> is fine, but the idiomatic C++ way would be to use <code>std::fill</code>:</p>

<pre><code>std::fill(string, string+length, 0);
</code></pre>

<p>Of course, if you want a string, then you should just use a <code>std::string</code> in C++.</p>
",0
14220679,14220573,6,"<p>When you use:</p>

<pre><code>string = new char[20];
</code></pre>

<p>the allocated array is not initialized. In order to default-initialize it, you have to use:</p>

<pre><code>string = new char[20]();  // Allocates and initializes all members to 0
</code></pre>

<p>This is stated in C++03 ¡ì5.3.4/15:</p>

<blockquote>
  <p>A new-expression that creates an object of type T initializes that object as follows:
  ...</p>
  
  <p>If the new-initializer is of the form (), the item is
    value-initialized (8.5);</p>
</blockquote>

<p>As for your second question ¡ª yes, you can use <code>memset</code> to fill the memory with any values you want.</p>
",1
18101737,18101019,0,"<blockquote>
  <p>I allocate char* result = new char[32]; and never delete this. How
  should I deal with memory leak ? How should I free the memory ?</p>
</blockquote>

<pre><code>delete [] result;
</code></pre>

<p>and with your class,</p>

<pre><code>MyClass *obj = new MyClass(...)    
delete obj;
</code></pre>

<p>Because your function allocates memory and never destroys the array, it's a caller's responsibility to free memory. So if you pass <strong>result</strong> to <strong>MyClass</strong> constructor, you should probably implement delete [] result; in <strong>MyClass</strong> destructor.</p>
",3
17807720,17807634,1,"<p>Instead of saying:</p>

<pre><code>while (fp){
    string line;
    getline(fp, line);
    ...
</code></pre>

<p>You should say:</p>

<pre><code>string line;
while(getline(fp, line)) { ...
</code></pre>

<p>This is because when fp gets into eof state, getline fails (and sets fp to eof state). You do not check the result of the getline so for the last step you use the previously read value.</p>
",0
17807728,17807634,1,"<p>Issue is with the Loop. Once it reads last word from file and again comes to loop, that condition doesn't fail and again it goes to loop. </p>

<p>Change both <code>while</code> loops to</p>

<pre><code>while(getline(fp, line))
</code></pre>

<p><strong>&amp;</strong></p>

<pre><code>while (line_stream &gt;&gt; name)
</code></pre>

<p>This will prevent the repetition as in this condition, last <code>name</code> will not be processed twice. Currently when <code>fp</code> approaches <code>eof</code>, <code>getline</code> fails. <code>getline</code> is not checked and previously read value is used, without checking if it succeeded. </p>
",0
17807807,17807634,1,"<p>As well as the suggested changes detecting the end of file by checking the result of <code>getline</code>, the same principle should apply to the <code>stringstream</code>, so:</p>

<pre><code>while (line_stream){
</code></pre>

<p>should be:</p>

<pre><code>while (line_stream &gt;&gt; name) { 
</code></pre>

<p>That way, when there is ""nothing left to make another name"", you don't get the last <code>name</code> processed twice. </p>
",3
17808072,17807634,7,"<p>You are using the results of <code>getline</code> without checking whether
it succeeded.  This is the first error (and probably results in
an extra empty line with the code you show).  Similarly, you use
the results of <code>line_stream &gt;&gt; name</code> without checking whether it
succeeded; in this case (because <code>name</code> is not newly constructed
each time through), you may end up with the previously read
value (but in both cases, the contents of the string are
unspecified). </p>

<p>You must <em>never</em> use the results of input without first testing
whether it succeeded.  The most common way of doing this (but
certainly not the only way) is to do the input in the condition
of the loop:</p>

<pre><code>while ( std::getline( fp, line ) ) ...
</code></pre>

<p>and</p>

<pre><code>while ( line_stream &gt;&gt; name ) ...
</code></pre>

<p><em>If</em> you still want to limit the scope of the variable to the
loop, you'd have to write:</p>

<pre><code>while ( fp ) {
    std::string line;
    if ( std::getline( fp, line ) ) {
        //  rest of loop
    }
}
</code></pre>

<p>If you have (understandably) something against modifying global
state in a condition, you'd have to write:</p>

<pre><code>std::getline( fp, line );
while ( fp ) {
    //  ...
    std::getline( fp, line );
}
</code></pre>

<p>While I think that there are strong arguments in favor of this,
the <code>while ( std::getline( fp, line ) )</code> idiom is ubiquitous, to
the point where anything else will cause the reader to wonder
why.</p>
",0
10177917,10177904,7,"<p>It means the return type is const, it's the same as:</p>

<pre><code>virtual const bool VAtEnd() const = 0;
virtual const int VGetPostition() const = 0;
</code></pre>

<p>It has no practical meaning though, as the return value is copied anyway.</p>

<p>If you'd be returning an object though:</p>

<pre><code>struct A
{
    void goo() {}
};

const A foo() {return A();}



int main()
{
    A x = foo();
    x.goo();      //ok
    foo().goo();  //error
}
</code></pre>
",5
9809331,9809270,5,"<p>Do </p>

<pre><code>std::string line; 
std::getline(std::cin,line);
</code></pre>

<p>and then analyze the line manually, first splitting it into words. </p>

<p>It could be useful to have a function:</p>

<pre><code>void ToWords(const std::string &amp;line, std::vector&lt;std::string&gt; &amp;words);
</code></pre>

<p>But the implementation is left as an exercise to the reader ;-).</p>
",2
10135255,10135244,7,"<p>Get rid of the semicolon after <code>WordGame</code>.</p>

<p>You really should have discovered this problem when the class was a lot smaller. When you're writing code, you should be compiling about every time you add half a dozen lines.</p>
",0
10135260,10135244,37,"<p>There should be no semicolon here:</p>

<pre><code>class WordGame;
</code></pre>

<p>...but there should be one at the end of your class definition:</p>

<pre><code>...
private:
    string theWord;
}; // &lt;-- Semicolon should be at the end of your class definition
</code></pre>
",0
10135374,10135244,9,"<p>As a side note, consider passing strings in setWord() as const references to avoid excess copying.  Also, in displayWord, consider making this a const function to follow const-correctness.</p>

<pre><code>void setWord(const std::string&amp; word) {
  theWord = word;
}
</code></pre>
",0
16944183,16944127,3,"<p>If you want to customize assignment/copy, you have to implement both:</p>

<ul>
<li><code>operator=</code> is used for assignments, for instance: <code>ABC a; ABC b; a = b;</code></li>
<li><code>ABC::ABC(const ABC &amp;other)</code> is used for copies, for instance: <code>ABC a; ABC b(a);</code>.</li>
</ul>

<p>It's also very likely that you will want to implement a default constructor and a destructor too. You may want to read more about the <a href=""https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">rule of three</a>.</p>
",5
16944243,16944127,1,"<p>In your case you neither need to implement copy construction nor copy assignment, since the compiler will automatically generate these member functions for you. The generated functions will simply call the copy constructor or the copy assignment operator respectively for each data member. </p>

<p>You only need to implement functions, if you want to have customized behavior. By the way, if you implement the copy constructor, then the copy assignment operator will still have the same default behavior as described above and vice verse. Hence, if you customize one of the two, then you probably need to customize the other one too. And possibly the destructor as well. This is called the <a href=""https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three?lq=1"">rule of three</a>. In most cases the default behavior will be just fine. </p>
",0
16944284,16944127,4,"<p>The first thing you show is the <em>assignment operator</em> and the second is the <em>copy constructor</em>.  They are distinct functions doing different things. (namely the ctor sets up an object that is being born and op= changes the state of an existing object to match that of another.)</p>

<p>With some luck (helped by design) you do not implement either of them but leave it to the language to create them. If you use sensible members and base classes it will just happen.</p>

<p>If you need to go implementing them (checking twice it is really the case!) you will likely need both of them, see <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29"" rel=""nofollow"">Rule of 3</a></p>
",0
11874743,11874209,1,"<p>I'm not sure if I fully understand you, but maybe this is what you want:</p>

<pre><code>struct BaseClass {
    virtual double Function() {return const_cast&lt;const BaseClass*&gt;(this)-&gt;Function();}
    virtual double Function() const=0;
    virtual BaseClass() {}
};
struct DerivedClass1: public BaseClass {
    virtual double Function() {stuff};
    virtual double Function() const {throw std::logic_error(""UNIMPLEMENTED"");};
};
struct DerivedClass2: public BaseClass {
    virtual double Function() const {stuff};
};
</code></pre>

<p>Needless to say, this is a very bad idea.  The BaseClass implementation will redirect mutable instances to the existing <code>const</code> functions, unless they've been overriden by a derived class, as you want to do in <code>DerivedClass1</code>.  The problem is if you call <code>Function()</code> on a <code>const DerivedClass1</code>, then you get an exception at run-time.</p>
",0
11874873,11874209,1,"<p>You have:</p>

<pre><code>struct Base {
    virtual double Function() const;
};

struct Derived1 : Base {
    virtual double Function() const;
};

struct Derived2 : Base {
    virtual double Function() const;
};
</code></pre>

<p>You want:</p>

<pre><code>struct Derived1 : Base {
    virtual double Function(); // overrides virtual function in base
};
</code></pre>

<p>So, first thing you need to add a non-const virtual function to <code>Base</code>, otherwise you're not overriding anything. The question is, what should the base class function be defined as? For minimal disruption it should do the same thing that calling the function via a non-const reference currently does -- call the const function:</p>

<pre><code>struct Base {
    virtual double Function() const;
    virtual double Function() { return static_cast&lt;const Base*&gt;(this)-&gt;Function(); }
};

struct Derived1 : Base {
    virtual double Function() const;
    virtual double Function();
};

struct Derived2 : Base {
    virtual double Function() const;
    // no need to override non-const Function
};
</code></pre>

<p>I think this could still potentially break existing code, for example if you took pointers to the const and non-const versions of the function, then previously they would compare equal and now they don't:</p>

<pre><code>typedef double (Base::*constfunc)() const;
typedef double (Base::*mutfunc)();
((mutfunc)(constfunc(&amp;Base::Function)) == (mutfunc(&amp;Base::Function))); // was true, now false
</code></pre>

<p>For typical users of the <code>Base</code> class, adding the new function is probably harmless.</p>

<p>However, you say: ""using the above virtual function but with a non const return value"", and your example function already has a non-const return value (<code>double</code>) even with the const version of the function. So answers can't address this, and it's possible that by concealing your real use-case, you're getting worse answers than you would with an example that better reflects your actual code.</p>
",4
11874643,11874209,0,"<p>A derived method that wants to override a virtual base method <strong>MUST</strong> use the exact same signature as the base method, including uses of <code>const</code>, or else the derived method will merely hide the base method instead of overriding it.  You cannot change the signature in a derived class if you intend to override.</p>
",0
12339468,12339394,1,"<p>If your free hosting permits it (and you should check that) you might code a <a href=""http://en.wikipedia.org/wiki/Common_Gateway_Interface"" rel=""nofollow"">CGI</a> program, or a <a href=""http://en.wikipedia.org/wiki/Fastcgi"" rel=""nofollow"">fastCGI</a> application. There are several C++ libraries which might help, like <a href=""http://www.yolinux.com/TUTORIALS/LinuxTutorialC++CGI.html"" rel=""nofollow"">libcgicc</a> etc.</p>

<p>If you can afford a web server, there exist C++ libraries providing <a href=""http://en.wikipedia.org/wiki/Http"" rel=""nofollow"">HTTP</a> service, in particular <a href=""http://www.webtoolkit.eu/wt"" rel=""nofollow"">Wt</a> or (in C) <a href=""https://github.com/davidmoreno/onion"" rel=""nofollow"">Onion</a> etc.</p>

<p>You could also consider other technologies, like <a href=""http://opalang.org/"" rel=""nofollow"">OpaLang</a> or <a href=""http://ocsigen.org/"" rel=""nofollow"">Ocsigen</a> (but I would not recommend PHP, even if it is a lot used).</p>

<p>MAybe your hosting enable <code>ssh</code> so you could use <code>scp</code> ....</p>

<p>And if your application is free software (e.g. GPL licensed), several free software hosting (<a href=""http://freecode.com/"" rel=""nofollow"">freecode</a>, <a href=""http://sourceforge.net/"" rel=""nofollow"">sourceforge</a>, <a href=""http://github.com/"" rel=""nofollow"">github</a>, <a href=""http://gitorious.org/"" rel=""nofollow"">gitorious</a> ...) may offer also a bug database facility.</p>
",0
9826001,9825951,7,"<p>LPCWSTR is a pointer to a const string buffer. LPWSTR is a pointer to a non-const string buffer. Just create a new array of wchar_t and copy the contents of the LPCWSTR to it and use it in the function taking a LPWSTR.</p>
",0
9826012,9825951,0,"<p>You probably need to create a copy of the string, and pass a pointer to the copy. An LPCWSTR i a pointer to a <code>const</code>, which means the content can't be modified. An LPWSTR is a pointer to non-const, meaning it may modify the content, so you need to make a copy it can modify before you can use that function.</p>
",2
9826031,9825951,7,"<p>Create a new string, copy the contents into it, and then call the function that expects a modifiable string:</p>

<pre><code>LPCWSTR str = L""bar"";
std::wstring tempStr(str); 
foo(&amp;tempStr[0]);
</code></pre>
",0
15500562,15500141,1,"<p>Read and write don't work the way you are trying. They are only good for classes with no pointers, but string has pointers and your class has string so you cannot use them.</p>

<p>You are going to have to find a different way to read and write your data. What's wrong with this</p>

<pre><code>out &lt;&lt; studentName &lt;&lt; ' ' &lt;&lt; roll &lt;&lt; ' ' &lt;&lt; studentPassword &lt;&lt; '\n';
</code></pre>

<p>and</p>

<pre><code>in &gt;&gt; studentName &gt;&gt; roll &gt;&gt; studentPassword;`
</code></pre>

<p>Also not the question you asked but <code>in</code> and <code>out</code> should not be declared in your <code>Student</code> class. They should be declared in the functions where you use them. </p>
",2
9783036,9778743,0,"<p>First thing that comes to mind is whether <code>anc_map[ancestry].nr_hap</code> could be some bogus, probably huge, number. Probably because any of the variables got corrupt. I am not sure why it would get corrupt only without debugger, but it might be that the debugger affects where things are allocated and the corruption appears somewhere less harmful when debugging.</p>

<p>The other thing that comes to mind is, that if the program needs a lot of memory, the debugger might affect the 2-GB limit flag in Windows, so in one case there is enough memory and the other way you run out. I am, however, not sure how to change it with mingw32 compiler, as I only did it with the Microsoft one (/LARGEADDRESSAWARE option to Microsoft <code>link</code> and <code>editbin</code>). The reason is, that in some old software, they noticed people doing binary search like <code>(whatever *)(((unsigned)begin + (unsigned)end)/2)</code>, which, besides being incorrect C, does not work if the pointers are above 2GB, because the calculation overflows. So for old software, written before more than 2GB was common, they limited the memory to 2GB and provided option to get more, which means 3GB on 32-bit Windows (the last 1GB maps kernel space to avoid swapping page tables on kernel entry and exit; linux does the same thing) and 4GB for 32-bit process on 64-bit windows (the kernel can be mapped above 4GB there).</p>

<p>Hm, but most likely it's actually corruption of the memory management metadata, because that's the usual case where memory allocation or deallocation functions just hang instead of returning an error. Again the debugger would cause some addresses to be different and the corruption to happen elsewhere.</p>

<p>In the first and last case the corruption would probably be always there, so you might have some luck trying to run it:</p>

<ul>
<li>In linux under <a href=""http://valgrind.org"" rel=""nofollow"">valgrind</a>.</li>
<li>Under <a href=""http://duma.sourceforge.net"" rel=""nofollow"">DUMA</a>, but the Microsoft standard runtime library will try to resist replacing the memory allocation functions rather hard; I finally gave up when I found that IO streams use something like __debug_delete, but normal new. Or the other way around; I don't recall exactly.In either case one was the standard allocation function and the other was some their internal undocumented function. It will also use much more memory than usual, because each allocation will be at least 8kB. In Linux it's trivial, because GNU libc has special support for overriding memory allocation, but valgrind is superior there anyway.</li>
</ul>
",0
15822509,15822496,3,"<p>Your function must execute 1 and exactly 1 <code>return</code> statement.</p>

<p>So, either <code>return variable1</code> gets executed or <code>if(condition2)</code>, but never both.</p>
",2
15822539,15822496,0,"<p>As far as I remember (or at least as my teachers told me) is not quite a good idea to use <code>return</code> <em>before</em> the end of the execution, with the exception of recursive functions.</p>

<p>I suggest you use a variable to store the value you want to return as a result of your function and return it at the end of your function:</p>

<pre><code>if( condition1 )
{
    ans = variable1;
}

/* more code */

if( condition2 )
{
    ans = variable2;
}
return ans;
</code></pre>
",5
15822563,15822496,1,"<p>No, code is never executed after a <code>return</code> statement is reached. If, however, <code>condition1</code> is false, then the <code>return</code> statement isn't reached, so execution proceeds normally. This is exactly the way Java behaves, too.</p>

<p>There is an argument against early <code>return</code> statements, but personally I find them helpful; trying to avoid them can lead to extraneous cruft, such as temporary variables that don't really do you any good or large <code>if</code>-blocks that are mostly just confusing to read due to their scope. </p>
",0
15822574,15822496,5,"<p>No.  Once a <code>return</code> is encountered, nothing else in the function is processed.</p>
",2
15822580,15822496,0,"<p>It only is executed if it is called. At which point, you are leaving that function/method. 
In your case, if condition1 is false, it will run your extra processing and then proceed to test condition 2. </p>

<p>Now, in your case, your code probably won't compile. (I know it wouldn't in Java) 
This is because it is possible to have neither condition be satisfied in which case we get lost. So, you should probably have some return outside of your if statements.</p>

<p>In short, no execution of code happens after a return is called.</p>
",0
15822626,15822496,22,"<p>Although there is a way to run code after the return statement, there is no way to return again after a return statement has been executed.</p>

<p>Here is how you can make some code to run after a return statement:</p>

<pre><code>struct AfterReturn {
    ~AfterReturn() {
        // This code will run when an AfterReturn object goes out of scope
        cout &lt;&lt; ""after return"" &lt;&lt; endl;
    }
};

int foo() {
    AfterReturn guard; // This variable goes out of scope on return
    cout &lt;&lt; ""returning..."" &lt;&lt; endl;
    return 5;
    // This is when the destructor of ""guard"" will be executed
}

int main() {
    cout &lt;&lt; foo() &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>The above program <a href=""http://ideone.com/Pijpfw"" rel=""noreferrer"">prints</a></p>

<pre><code>returning...
after return
5
</code></pre>
",1
10748161,10748127,0,"<p>The way to do this is to return a std::string from disc, pass it as an argument into display, and compare it to the set values using ==.</p>

<p>For example:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

std::string valueFunction( int i)
{ 
  if ( i &gt;0 )
   return ""positive"";
  else
   return ""not positive"";
}

void resultFunction( std::string data)
{
   if (data == ""positive"")
      std::cout&lt;&lt;""It was a positive number""&lt;&lt;std::endl;
   else if (data == ""not positive"")
      std::cout&lt;&lt;""it was not a positive number""&lt;&lt; std::endl;
}

int main()
{  
   int i = 453;
   std::string result = valueFunction(i);
   resultFunction(result);
}
</code></pre>
",7
10751031,10750995,3,"<p><a href=""http://www.parashift.com/c++-faq-lite/templates.html#faq-35.12"" rel=""nofollow"">You should make implementations visible</a>. Move</p>

<pre><code>template &lt;class T&gt;
Vector&lt;T&gt;::Vector(Vector const&amp; r)
{
    //....
}
</code></pre>

<p>from the <code>cpp</code> file to the header.</p>
",0
10751037,10750995,2,"<p>See the C++ faq (http://www.parashift.com/c++-faq-lite/templates.html#faq-35.13). Basically place the code in the header file.</p>
",1
11093333,11093283,0,"<p>Consequtive string literals are concatenated at compile-time...</p>

<pre><code>#define A ""1234""
#define B ""ab""
fred::a = A;
fred::b = B;    
fred::c = A B;
</code></pre>
",1
11093336,11093283,0,"<p>You can't in a clean way, but you can use a trick to simulate an static constructor as shown <a href=""https://stackoverflow.com/questions/1197106/static-constructors-in-c-need-to-initialize-private-static-objects"">here</a>. </p>

<p>In that static constructor, you can initialize <code>c</code>.
This would be a possible implementation:</p>

<pre><code>class fred {
    static char *a = ""1234"";
    static char *b = ""ab"";
    static char c[4];
    public:
    fred(){
       strcpy(fred::c, fred::b);
       strncat(fred::c, fred::a, 1);
    }    
}

class Fred_staticInitializer{  
    static fred staticInitializer;  //This does the trick (launches constructor)
}
</code></pre>

<p>Hope it helps. Cheers</p>
",3
11093338,11093283,3,"<p><strong>Edit:</strong> Originally, I had <code>wilma</code> as a friend of <code>fred</code>, and a static instance of <code>wilma</code> doing the initialization. I have changed the example to have <code>dino</code> declared within <code>fred</code> since the OP said he thought that would be cleaner.</p>

<p>You can create a static instance of a class inside <code>fred</code> whose job is to initialize <code>c</code> for you.</p>

<pre><code>class fred {
    static char *a;
    static char *b;
    static char c[4];
    static struct dino { dino (); } dino_flintstone;
};

char *fred::a;
char *fred::b;
char fred::c[4];
fred::dino fred::dino_flintstone;

fred::dino::dino () {
    fred::a = ""1234"";
    fred::b = ""ab"";
    strcpy(fred::c, fred::b);
    strncat(fred::c, fred::a, 1);
}
</code></pre>
",8
10829026,10828937,31,"<p>When cin encounters an input it can't properly read in to the variable specified (such as inputing a character into an integer variable), it goes into an error state and leaves the input in it's buffer.</p>

<p>You have to do several things to properly handle this scenario.</p>

<ol>
<li>You have to test for this error state.</li>
<li>You have to clear the error state.</li>
<li>You have to either alternatively handle the input data that generated the error state, or flush it out and reprompt the user.</li>
</ol>

<p>The following code provides one of numerous methods of doing these three things.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;limits&gt;
using namespace std;
int main()
{

    cout &lt;&lt; ""Enter an int: "";
    int x = 0;
    while(!(cin &gt;&gt; x)){
        cin.clear();
        cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
        cout &lt;&lt; ""Invalid input.  Try again: "";
    }
    cout &lt;&lt; ""You enterd: "" &lt;&lt; x &lt;&lt; endl;        
}
</code></pre>

<p>You could just pass in some large value to cin.ignore like 1000 and it's likely to behave exactly the same for all practical purposes.</p>

<p>You can also test cin after the input attempt and handle it that way, something like 
if(!cin){//clean up the error} .</p>

<p>Check out the istream reference for other member functions to handle stream state: <a href=""http://cplusplus.com/reference/iostream/istream/"">http://cplusplus.com/reference/iostream/istream/</a></p>
",2
10829091,10828937,14,"<p>I would use <code>std::getline</code> and <code>std::string</code> to read the whole line and then only break out of the loop when you can convert the entire line to a double.</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;

int main()
{
    std::string line;
    double d;
    while (std::getline(std::cin, line))
    {
        std::stringstream ss(line);
        if (ss &gt;&gt; d)
        {
            if (ss.eof())
            {   // Success
                break;
            }
        }
        std::cout &lt;&lt; ""Error!"" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""Finally: "" &lt;&lt; d &lt;&lt; std::endl;
}
</code></pre>
",0
11166724,11166468,1,"<p>There is nothing mystery. The largest intermediate number overflows 31-bit of the signed integer. You need to declare <code>record.number</code> and <code>nextNumber</code> as <code>unsigned int</code>.</p>
",0
11166727,11166468,2,"<p>I'll try to give you a hint to nudge you into figuring out the problem.</p>

<p>The sample inputs are good as a smoke test, but they're often not good indicators that your program can handle the more extreme test cases too. You should always test with more than the sample inputs. If my calculations are correct, your program will produce the wrong result for the following input:</p>

<pre><code>999000 999250
</code></pre>

<p>For reference, the expected output for this is:</p>

<pre><code>999000 999250 321 
</code></pre>

<p>There, I narrowed your search space down to 251 cycles :) Now get your debugger and finish the job.</p>

<p>Anyway, what follows is the full explanation and solution in spoiler markup. Mouse over the blank space if you want to read it, stay put if you want to figure it yourself.</p>

<blockquote class=""spoiler"">
  <p> The problem states that i and j are less than one million and that no operation overflows a 32-bit integer. This means that no intermediate result will be larger than 4294967295. However, an <code>int</code> is a signed type, so, even if it has 32-bits, it only has 31 bits for the absolute value, and thus cannot fit any number larger than 2147483647. Numbers larger than these occur in the cycles of for several Ns in the problem range, one of which is 999167. Using an unsigned 32 bit integer is one solution.</p>
</blockquote>
",1
9811927,9811890,1,"<p>You should write the if statement like so <code>if(str[i]=='\""' or str[i]=='\'')</code> and as for the lowercase this should do it:</p>

<pre><code>std::transform(str.begin(), str.end(), str.begin(), ::tolower);
</code></pre>
",2
9812094,9811890,1,"<p>This piece of code will clean every "" , . ' from mesy_string:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

using namespace std;

//Chars to be removed
bool has_chars(char c){
  if(c=='\""' || c=='.' || c==',' || c=='\'')
    return true;
  else
    return false;  
}

int main () {
  string messy_string=""dfffsg.nfgfg,nsfvfvbnf\""nsdfnsdf\'ssvbssvns\""hhhfh\"""";

  cout&lt;&lt; messy_string&lt;&lt;endl;

  remove_if (messy_string.begin(), messy_string.end(), has_chars);

  cout&lt;&lt; messy_string&lt;&lt;endl;  
  return 0;
}
</code></pre>

<p>You should be able to modify it to your needs.</p>
",0
9830628,9830576,5,"<p><code>std::vector</code> iterators are invalidated once an <code>erase</code> operation has been performed.  <a href=""http://www.cplusplus.com/reference/stl/vector/erase/"" rel=""noreferrer"">(See reference here)</a></p>

<p>Try changing your code to:</p>

<pre><code>void Customer::removeRoomID(int rID)
{
   vector&lt;int&gt;::iterator iter;
   iter = roomsCheckedInto.begin();
   while(iter != roomsCheckedInto.end())   
   {
       if(*iter==rID)
       {
           // iter should now be set to the value
           // returned from the erase() method.
           iter = roomsCheckedInto.erase(iter);
       }
       else
       {
          ++iter;
       }
   }
}
</code></pre>
",1
9830636,9830576,0,"<p>Firstly, you have to increment iter somewhere, or you will never reach the end of roomsCheckedInto - that is you will have an infinite loop.</p>

<p>Secondly, erase invalidates iter.</p>

<p>Instead, replace your while loop with:</p>

<pre><code>while(iter != roomsCheckedInto.end())
{
   if(*iter==rID) iter = roomsCheckedInto.erase(iter);
   ++iter;
}
</code></pre>

<p>Also, is this homework? If so, tag as such =)</p>
",1
9830646,9830576,1,"<p>You are not advancing your iterator anywhere.</p>

<p>You need to do <code>++iter</code> at some point or your while loop will be endless.</p>

<p>Also don't forget <code>.erase</code> invalidates the iterator, so you can't simply advance after erase.
Do <code>iter = roomsCheckedInto.erase(iter);</code> in case of matching id.</p>
",0
9855181,9854963,0,"<p>If you want the head of an STL list, just call <code>list&lt;&gt;::begin()</code>.  A pointer to the head of the list is stored by the usual implementations, and if you literally need it to be a pointer, just say <code>&amp;myList.front()</code> (check for empty first!).</p>
",0
9830449,9830414,1,"<p>Use an <code>int</code> instead of a <code>char</code>:</p>

<pre><code>int result = islower(input);
cout &lt;&lt; result; 
</code></pre>

<p>Note that islower is only guaranteed to return ""0"" or ""something that isn't 0"". You can fix that by writing <code>cout &lt;&lt; (result ? 1 : 0)</code>, but I'm not sure if that is disallowed by your requirements.</p>
",3
9830457,9830414,0,"<p>Every value except 0 == true. 0 == false.</p>
",1
9830491,9830414,1,"<p><code>islower</code> should return 0 when the character is NOT a lowercase letter. </p>

<p>Remember that only 0 is <code>false</code>. Even if the function returns -1, it's still a <code>true</code> value.</p>

<p>Check out the reference <a href=""http://www.cplusplus.com/reference/clibrary/cctype/islower/"" rel=""nofollow"">here</a>.</p>

<p>EDIT: </p>

<p>You can try using <code>input = 1 &amp;&amp; islower(input);</code>. This will force you <code>true</code> value to become 1.</p>
",5
9830519,9830414,0,"<p>you can store the output of <code>islower(input)</code> in an integer variable, say <code>value</code>, and <code>cout &lt;&lt; value</code></p>

<pre><code>int value = islower(input);
cout &lt;&lt; input;
</code></pre>
",0
9830528,9830414,1,"<p>Both 0 and 1 are non-printable characters, that's why you don't see the output. If you redirect the output to a file and open with a hex editor you'll see the result.</p>

<p>Store the result in a boolean, or cast the result: <code>cout &lt;&lt; (bool) input;</code></p>
",3
9830537,9830414,0,"<pre><code>#include &lt;iostream&gt;

using namespace std;

int 
main() 
{
  char input;
  cout &lt;&lt; ""Input A Character: \n"";
  cin &gt;&gt; input;
  unsigned int bIsLower = islower(input);
  cout &lt;&lt; ""input: "" &lt;&lt; input &lt;&lt; "", bIsLower: "" &lt;&lt; bIsLower &lt;&lt; endl;    
  return 0;
}
</code></pre>

<blockquote>
  <p>Input A Character:<br>
  a<br>
  input: a, bIsLower: 2  </p>
  
  <p>Input A Character:<br>
  A<br>
  input: A, bIsLower: 0  </p>
  
  <p>Input A Character:<br>
  z<br>
  input: z, bIsLower: 2  </p>
</blockquote>
",0
9830542,9830414,5,"<p>To get either <code>0</code> or <code>1</code>, you can use the double <code>!</code> operation:</p>

<pre><code>cout &lt;&lt; !!input;
</code></pre>

<p><code>!!</code> is a common idiom to normalize boolean values. It yields <code>0</code> when the value is <code>0</code> and <code>1</code> when the value is non-<code>0</code>.</p>

<p>Some people don't like the double negation, and you can get the same result with the <code>!=</code> equality operator:</p>

<pre><code>cout &lt;&lt; (input != 0);
</code></pre>
",0
9833590,9830414,0,"<p>To print a boolean value use a variable of type <strong>bool</strong>.</p>

<pre><code>   char input;
   bool output;
// ^^^^
   cout &lt;&lt; ""Input A Character: \n"";
   cin &gt;&gt; input;
   output = islower(input);
// ^^^^^^  Store result in a bool variable (otherwise why have output)
   cout &lt;&lt; output;   
//         ^^^^^^^  Now print it.
</code></pre>
",0
15817994,15817941,21,"<p>It works because the standard says that it works.</p>

<p>In practice, the compiler inserts implicit calls to <code>~A()</code> and <code>~B()</code> into <code>~AB()</code>. The mechanism is exactly the same as with single inheritance, except that there are multiple base destructors for the compiler to call.</p>

<p>I think the main source of confusion in your diagram is the multiple separate vtable entries for the virtual destructor. In practice, there will be a single entry that would point to <code>~A()</code>, <code>~B()</code> and <code>~AB()</code> for <code>A</code>, <code>B</code> and <code>AB()</code> respectively.</p>

<p>For example, if I compile your code using <code>gcc</code> and examine the assembly, I see the following code in <code>~AB()</code>:</p>

<pre><code>LEHE0:
        movq    -24(%rbp), %rax
        addq    $16, %rax
        movq    %rax, %rdi
LEHB1:
        call    __ZN1BD2Ev
LEHE1:
        movq    -24(%rbp), %rax
        movq    %rax, %rdi
LEHB2:
        call    __ZN1AD2Ev
</code></pre>

<p>This calls <code>~B()</code> followed by <code>~A()</code>.</p>

<p>The virtual tables of the three classes look as follows:</p>

<pre><code>; A
__ZTV1A:
        .quad   0
        .quad   __ZTI1A
        .quad   __ZN1AD1Ev
        .quad   __ZN1AD0Ev

; B
__ZTV1B:
        .quad   0
        .quad   __ZTI1B
        .quad   __ZN1BD1Ev
        .quad   __ZN1BD0Ev

; AB
__ZTV2AB:
        .quad   0
        .quad   __ZTI2AB
        .quad   __ZN2ABD1Ev
        .quad   __ZN2ABD0Ev
        .quad   -16
        .quad   __ZTI2AB
        .quad   __ZThn16_N2ABD1Ev
        .quad   __ZThn16_N2ABD0Ev
</code></pre>

<p>For each class, entry #2 refers to the class's ""complete object destructor"". For <code>A</code>, this points to <code>~A()</code> etc.</p>
",0
15818010,15817941,14,"<p>The vtable entry simply points at the destructor for <code>AB</code>. It is just defined that after execution of a destructor, the base class destructors are then called:</p>

<blockquote>
  <p>After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class X calls [...] the destructors for <code>X</code>¡¯s direct base classes and [...].</p>
</blockquote>

<p>So when the compiler sees <code>delete a;</code> and then sees that the destructor of <code>A</code> is virtual, it looks the destructor up for the dynamic type of <code>a</code> (which is <code>AB</code>) by using the vtable. This finds <code>~AB</code> and executes it. This results in the calling of <code>~A</code> and <code>~B</code>.</p>

<p>It's not the vtable that says ""call <code>~AB</code>, then <code>~A</code>, then <code>~B</code>""; it simply says ""call <code>~AB</code>"" which <em>involves</em> calling <code>~A</code> and <code>~B</code>.</p>
",0
15818054,15817941,1,"<p>Destructors are called in the order ""most derived to most basal"", and in reverse order of declaration. So <code>~AB</code> is called first, then <code>~B</code>, then <code>~A</code>, because <code>AB</code> is the most derived class. </p>

<p>All destructors are called before the memory is actually freed. Exactly how the virtual function pointers are stored is an implementation detail, and really something you shouldn't be concerned about. A class with multiple inheritance will most likely contain two pointers to the VTABLES of the classes that it derives from, but as long as the compiler and runtime libraries together ""work as we expect"", it is entirely up to the compiler + runtime libraries to do what they fancy to solve these sort of issues. </p>
",1
9836867,9836835,4,"<p>You are trying to assign a member function pointer to a standalone function pointer. You can't use the two interchangeably, because member functions always implicitly have the <code>this</code> pointer as their first parameter.</p>

<pre><code>void (*x)();
</code></pre>

<p>declares a pointer to a standalone function, while <code>funcTest()</code> is a member function of <code>MyClass</code>.</p>

<p>You need to declare a member function pointer like this:</p>

<pre><code>void (MyClass::*x)();
</code></pre>

<p>For more details see <a href=""http://www.parashift.com/c++-faq-lite/pointers-to-members.html#faq-33.1"" rel=""nofollow"">the C++ FAQ</a>.</p>
",0
9836873,9836835,5,"<p>The type of <em>non-static</em> member-function is not <code>void (*)()</code>. It is <code>void (MyClass::*)()</code>, which means you need to declare <code>x</code> as:</p>

<pre><code>void (MyClass::*x)();

x = &amp;MyClass::funcTest; //use fully qualified name, must use &amp; also
</code></pre>
",0
9836879,9836835,1,"<p>You declare a pointer to a function not taking any arguments and returning void. But you try to assign a member function pointer to it. You will need to the declare a pointer to a member function pointer and take its address like this: <code>&amp;MyClass::funcTest</code> The type of this pointer is <code>void (MyClass::*)()</code> Have a look at the <a href=""http://www.newty.de/fpt/index.html"" rel=""nofollow"">function pointer tutorials</a></p>
",0
9836883,9836835,1,"<p>Yes your type definition for <code>x</code> is wrong. You need to defined it as a member function pointer as suggested by the compiler, i.e., <code>void(MyClass::*x)()</code>.</p>

<p><a href=""http://www.parashift.com/c++-faq-lite/pointers-to-members.html"" rel=""nofollow"">http://www.parashift.com/c++-faq-lite/pointers-to-members.html</a></p>
",0
9836904,9836835,4,"<p>it's because a member function is different from a normal function, and hence the function pointers are different. Hence you need to tell the compiler that you want a MyClass function pointer, not a normal function pointer.youneed to declare x as: <code>void (MyClass::*x)();</code></p>
",0
10146033,10146013,4,"<p>Well, it's quite clear, you haven't implemented the default constructor for <code>addressBookType</code>:</p>

<pre><code>class addressBookType {
//...
    addressBookType();                      //declare constructor
    void loadData(addressBookType *&amp;ptr);   //declare method
};

//missing constructor implementation

void addressBookType::loadData(addressBookType *&amp;ptr){ //implement method
//...
}
</code></pre>

<p>To solve the error, just add</p>

<pre><code>addressBookType::addressBookType() { }
</code></pre>

<p>Note that this will initialize your <code>string</code> members to the empty string, the objects</p>

<pre><code>addressType obj1;
dateType obj2;
extPersonType obj3;
</code></pre>

<p>with their respective default constructors, and POD types will remain uninitialized. </p>
",0
9851067,9850905,0,"<p>Create a Map of <code>&lt;int,string&gt;</code> and then index the map with the corresponding value you want to search</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;    
int main (){    
    std::pair&lt;int,string&gt; TestEvents[] = {
    make_pair( 70387,""EVT_ACP_CAPT_LAST1""  ),
    make_pair( 70???,""EVT_ACP_CAPT_LAST1""  ),
    make_pair( 70512,""EVT_ACP_CAPT_LAST2""  ),
    make_pair( 70512,""EVT_ACP_CAPT_LAST2""  ),
    make_pair(  70385, ""EVT_ACP_CAPT_MASK_BOOM_SWITCH"" ),
    make_pair( 70368,""EVT_ACP_CAPT_MIC_FLT""  ),
    make_pair( 70510,""EVT_ACP_CAPT_MIC_HF1""  ),
    make_pair( 70511,""EVT_ACP_CAPT_MIC_HF2""  )
    };
    map&lt;int,string&gt; mapTestEvents(TestEvents,TestEvents + sizeof TestEvents / sizeof TestEvents[0]);
    int var = 70368;
    const char* event = mapTestEvents[var].c_str();
    return 0;
    }
</code></pre>

<p>Please note, I assume the integer value is unique else the whole problem statement would be void.</p>

<p>And yet another way to do it using std::sort and std::lower_bound</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
struct NameOffset {
    string name;
    int offset;
    };
NameOffset TestEvents[] = {

    { ""EVT_ACP_CAPT_LAST1"", 70387 },
    { ""EVT_ACP_CAPT_LAST1"", 70387 },
    { ""EVT_ACP_CAPT_LAST2"", 70512 },
    { ""EVT_ACP_CAPT_LAST2"", 70512 },
    { ""EVT_ACP_CAPT_MASK_BOOM_SWITCH"", 70385 },
    { ""EVT_ACP_CAPT_MIC_FLT"", 70368 },
    { ""EVT_ACP_CAPT_MIC_HF1"", 70510 },
    { ""EVT_ACP_CAPT_MIC_HF2"", 70511 },
    };
bool CompareByEvent(NameOffset const&amp; lhs, NameOffset const&amp; rhs) {
    return lhs.offset &lt; rhs.offset;
    }
int main (){
    sort(TestEvents,TestEvents + sizeof TestEvents / sizeof TestEvents[0], &amp;CompareByEvent);
    NameOffset var = {"""",70510};
    const char* event =lower_bound(TestEvents,TestEvents + sizeof TestEvents / sizeof TestEvents[0], var,&amp;CompareByEvent)-&gt;name.c_str();
    return 0;
    }
</code></pre>
",0
9850940,9850905,1,"<p>Assuming that the fields of <code>struct NameOffset</code> are <code>Name</code> and <code>Offset</code>, you can find a match using a loop, like this:</p>

<pre><code>for (int i = 0 ; i != sizeof(TestEvents)/sizeof(struct NameOffset) ; i++) {
    if (PmdgEvents[i].Offset == intVar) {
        printf(""%s\n"", PmdgEvents[i].Name);
        break;
    }
}
</code></pre>
",2
9850958,9850905,0,"<p>The brute-force approach is to use a loop and compare the second struct member to identigfy the right struct.</p>

<p>If the code will be executed regularly, you should use a <code>unordered_map</code>: load the data to a <code>unordered_map&lt;int, string&gt;</code> (or <code>char *</code> instead of <code>string</code> if you like) and then use</p>

<pre><code>event_map[code];
</code></pre>

<p>to access the string.</p>

<pre><code>#include &lt;unordered_map&gt;
#include &lt;iostream&gt;

using namespace std;

struct NameOffset {
    const char *event;
    int code;
};

struct NameOffset TestEvents[] = {
    { ""EVT_ACP_CAPT_LAST1"", 70387 },
    { ""EVT_ACP_CAPT_LAST2"", 70512 },
    { ""EVT_ACP_CAPT_MASK_BOOM_SWITCH"", 70385 },
    { ""EVT_ACP_CAPT_MIC_FLT"", 70368 },
    { ""EVT_ACP_CAPT_MIC_HF1"", 70510 },
    { ""EVT_ACP_CAPT_MIC_HF2"", 70511 },
 };

#define N_ELEMENTS (sizeof(TestEvents) / sizeof(NameOffset))

int main() {
    unordered_map&lt;int, const char *&gt; event_map;
    for (NameOffset *it = TestEvents, *it_end = TestEvents + N_ELEMENTS;
            it != it_end; ++it) {
        event_map[it-&gt;code] = it-&gt;event;
    }

    cout &lt;&lt; event_map[70387] &lt;&lt; endl;
    cout &lt;&lt; event_map[70512] &lt;&lt; endl;
    cout &lt;&lt; event_map[70385] &lt;&lt; endl;
    cout &lt;&lt; event_map[70368] &lt;&lt; endl;
    cout &lt;&lt; event_map[70510] &lt;&lt; endl;
    cout &lt;&lt; event_map[70511] &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
10150847,10150427,2,"<p>Two problems with this line both related to the integer type:</p>

<p><code>if((number / (divisor * divisor))% 1 != 0){</code></p>

<p>Remembering that the result of an integer operation is an integer, what is the value of the first set of values that go into the function?  Assume <code>number</code> is 5.  Then we have:</p>

<p><code>5/(5*5) = 5/25 = 0</code></p>

<p>The same thing applies with the <code>% 1</code>.  ints are always whole numbers, so modding by 1 always returns 0.</p>
",2
9855470,9855446,3,"<p>In your case, <code>FindWindow</code> is not aware of your list of already seen windows so it will continue to return the same window (although this is implementation defined). Regardless, <code>FindWindow</code> does not have the capability to do what you are attempting (skip windows during its search).</p>

<p>If you want to enumerate all windows only once, you should use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms633497%28v=vs.85%29.aspx"" rel=""nofollow"">EnumWindows</a>. I wrote some example C code for <code>EnumWindows</code> that does what I am guessing you want to achieve. You will need to convert it to C++ but your usage of C++ is not particularly of the language at the moment anyway.</p>

<pre><code>BOOL CALLBACK EnumFunc(HWND hwnd, LPARAM lParam)
{
    /*
     * We don't care about getting the whole string,
     * just enough to do the comparison. GetWindowText
     * will truncate the string if we tell it to.
     */
    wchar_t lpString[32];

    GetWindowText(hwnd, lpString, _countof);

    if(wcscmp(lpString, L""Untitled - Notepad"") == 0) {
        (*(int *)param)++;
    }

    return TRUE;
}

int main(void)
{
    int numFound = 0;

    EnumWindows(EnumFunc, (LPARAM)&amp;numFound);
    return ERROR_SUCCESS;
}
</code></pre>

<p>(Just wrote this in the answer window so there might be small errors).</p>
",14
10156214,10156172,11,"<p>You can use Boost IOStreams to compress your data, for example something along these lines to compress/decompresses into/from a file (example adapted from <a href=""http://www.boost.org/doc/libs/1_49_0/libs/iostreams/doc/classes/gzip.html"" rel=""nofollow noreferrer"">Boost docs</a>):</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;

#include &lt;boost/iostreams/filtering_stream.hpp&gt;    
#include &lt;boost/iostreams/filtering_streambuf.hpp&gt;
#include &lt;boost/iostreams/copy.hpp&gt;
#include &lt;boost/iostreams/filter/gzip.hpp&gt;

namespace bo = boost::iostreams;

int main() 
{
    {
    std::ofstream ofile(""hello.gz"", std::ios_base::out | std::ios_base::binary);
    bo::filtering_ostream out;
    out.push(bo::gzip_compressor()); 
    out.push(ofile); 
    out &lt;&lt; ""This is a gz file\n"";
    }

    {
    std::ifstream ifile(""hello.gz"", std::ios_base::in | std::ios_base::binary);
    bo::filtering_streambuf&lt;bo::input&gt; in;
    in.push(bo::gzip_decompressor());
    in.push(ifile);
    boost::iostreams::copy(in, std::cout);
    }
}
</code></pre>

<p>You can also have a look at Boost Serialization - which can make saving your data much easier. It is possible to combine the two approaches (<a href=""https://stackoverflow.com/questions/1753469/how-to-hook-up-boost-serialization-iostreams-to-serialize-gzip-an-object-to"">example</a>). IOStreams support <code>bzip</code> compression as well.</p>

<p><strong>EDIT:</strong> To address your last comment - you can compress an existing file... but it would be better to write it as compressed to begin with. If you really want, you could tweak the following code:</p>

<pre><code>std::ifstream ifile(""file"", std::ios_base::in | std::ios_base::binary);
std::ofstream ofile(""file.gz"", std::ios_base::out | std::ios_base::binary);

bo::filtering_streambuf&lt;bo::output&gt; out;
out.push(bo::gzip_compressor());
out.push(ofile); 
bo::copy(ifile, out);
</code></pre>
",3
9810779,9810599,0,"<p>In your .ccp file goes:</p>

<pre><code>ostream &amp;operator &lt;&lt; ( ostream &amp;out_file, complx number )
{
  out_file &lt;&lt; number.Real() &lt;&lt; "","" &lt;&lt; number.Imaginary();
  return out_file;
}
</code></pre>

<p>Similarly for the others.</p>

<p>The trick is to decompose the complex number into its elements (Real and Imaginary) and perform the required operations on those (and create a new complex object for the return value of <code>+</code>, <code>-</code>, <code>*</code>).</p>
",3
18134470,18134314,-1,"<p>Your function get local copies of the pointers. The local copies are in fact switched, but not reflected in the calling functions since their scope ends within the order() function.</p>

<p>You may use strcpy() function to copy the string to a temporary char array and then swap them.</p>
",2
18134654,18134314,0,"<p>You're passing the pointers by value and expecting the value of those pointers to be changed inside that function. Similar to passing any variables by value. Pass them by reference as pointed out by others.</p>
",0
18134575,18134314,3,"<p>The easy solution is</p>

<pre><code>#include &lt;algorithm&gt;
</code></pre>

<p>then simply <code>std::swap</code> the two pointers, ie <code>std::swap(first, second)</code>.</p>

<p>The slightly harder solution is to write your own <code>swap</code>, and call it <code>order</code>.</p>

<pre><code>void order(const char*&amp; first, const char*&amp; second) {
  const char* temp = second;
  second = first;
  first =  temp; 
}
</code></pre>

<p>note the use of <code>&amp;</code> in the arguments.  This means that the arguments are passed <em>by reference</em>, which means that modifications to the pointers will be reflected in modifications to the passed in arguments.</p>

<p>References are a C++ feature that lets you make variables be aliases for other variables.</p>

<p>Your problem is that you confused the map (the pointer) for the territory (the data pointed to), then thought that <code>=</code> on the pointers modified the data.  Instead, you made a copy of the maps (the pointers), drew all over them in your function, and then discarded the copies you made after you left your subprocedure.</p>

<p>Because all of the changes (the swapping) was on the copies of the pointers (the duplicate maps), the original pointers (the maps) where left alone.</p>

<p>I'm using ""map"" and ""territory"" as a reference to Alfred Korzybski, neither of these words are being used in a programming context, or refer to what is usually called <code>map</code> in C++.</p>
",0
18134589,18134314,2,"<p>Your code passes only copies of <code>first</code> and <code>second</code> to order. To change <code>first</code> and <code>second</code>, you must pass either references or pointers to them. For references:</p>

<pre><code>void order(const char *&amp;first, const char *&amp;second)
{
    const char *temp = second;
    second = first;
    first =  temp; 
}
</code></pre>

<p>For pointers:</p>

<pre><code>void order(const char **first, const char **second)
{
    const char *temp = *second;
    *second = *first;
    *first =  temp; 
}
</code></pre>

<p>There is also <code>std::swap</code>, available by including <code>&lt;algorithm&gt;</code>:</p>

<pre><code>std::swap(first, second);
</code></pre>

<p>Additionally, if the strings were regular arrays rather than string literals, you could pass them as <code>char *</code> instead of <code>const char *</code> and swap the contents of the arrays rather than swapping pointers to them, provided each array were large enough to contain the string in the other.</p>
",0
11096511,11095741,3,"<p>Let <code>(x,y)</code> be the point you're after, <code>(ox, oy)</code> be your origin, and <code>(mx, my)</code> be the mouse location.  </p>

<p>The vector from the origin to the mouse is <code>(dx, dy) = (mx - ox, my - oy)</code>.</p>

<p>The distance between the mouse and the origin is the same as the norm of that vector:</p>

<pre><code>distance = sqrt(dx * dx + dy * dy);
</code></pre>

<p>Normalizing (scaling) the vector to get a new vector of length 1 (""unit length"") we get</p>

<pre><code>nx = dx / distance;
ny = dy / distance;
</code></pre>

<p>And finally we can scale those coordinates by the desired length (remembering to add back the origin)</p>

<pre><code>x = ox + length * nx;
y = oy + length * ny;
</code></pre>
",2
11165896,11058716,2,"<p>The purpose of overloading operators is mostly syntactic sugar. It makes ugly stuff look nice.
But it's also about unifying interfaces, and an important reason for unifying interfaces is polymoprphism, in this case especially with templates.</p>

<p>Imagine we have a lovely complex number class <code>Complex</code>, and we want to have a Taylor series approximation of sine that we want to make work for Complex and double types.</p>

<p>If we support operator overloading on <code>*</code>, <code>=</code>, <code>/</code> etc. then we can write it like this:</p>

<pre><code>template&lt;typename T&gt;
T sin(T t)
{
  T t2 = t*t;
  return t*(1 - t2/6 + (t2*t2)/120 );
}
</code></pre>

<p>If we cant have overloading on <code>*</code>, <code>/</code> etc. then it starts to get ugly, as we need a helper class to unify the interface for doubles and Complex, heres what it might look like. (I'm still allowing overloading of <code>operator=</code>, otherwise it gets even worse).</p>

<pre><code>template&lt;typename T&gt;
T sin(T t)
{
  T t2 = helper&lt;T&gt;::mult( t, t );
  T t4 = helper&lt;T&gt;::mult( t2, t2 );
  T s(1);
  helper&lt;T&gt;::sincrement( &amp;s, -1./6, t2);
  helper&lt;T&gt;::sincrement( &amp;s, -1./120, t4);
  return helper&lt;T&gt;::mult( t, s );
}

template&lt;&gt;
struct helper&lt;double&gt;
{
  static double mult( double a, double b) { return a*b; }
  static void sincrement( double * v, double s, double x) { *v += s*x; }
}

template&lt;&gt;
struct helper&lt;Complex&gt;
{
  static Complex mult( Complex a, Complex b ) { return a.mult(b); }
  static void sincrement( Complex * v, double s, Complex x ) { v-&gt;add( x.scale(s) ); }
}
</code></pre>

<p>Now I know operator overloading can be ugly, and can hide what's really happening, but used correctly I think that it makes cases like this much easier to understand.</p>
",0
10167148,10167087,1,"<p><strong>[EDIT]</strong> I believe that I didn't fully get the point of your question and that @DeadMG's answer is in fact what you are looking for. </p>

<p>The template below allows you to instantiate a class which given T, MIN, MAX can provide some number X between MIN and MAX between T.</p>

<pre><code>template&lt;int T, int MIN, int MAX, int X = MIN + T/(MAX - MIN)&gt;
class MyClass
{
  int foo() const
  {
    return X;
  }
};
</code></pre>
",1
10167200,10167087,2,"<p>This isn't a big deal. Consider the following:</p>

<pre><code>template&lt;typename T&gt; class MyClass {
public:
    int foo(int a, int b) const {
        return T()(a, b);
    }
};
</code></pre>

<p>Now if <code>T</code> is a type whose <code>operator()</code> returns the maximum of it's two arguments, then you will return the maximum, and ditto for any other binary algorithm you wish to apply.</p>
",2
9865509,9865443,4,"<p>You are iterating over <code>isduplicate</code> twice. You should iterate over <code>isduplicate[i]</code> in the inner loop:</p>

<pre><code>vector&lt;vector&lt;bool&gt;&gt; isduplicate(100);
for(int i=0;i&lt;isduplicate.size();i++){
    for(int s=0;s&lt;isduplicate[i].size();s++)
       isduplicate[i][s]=false;
} 
</code></pre>

<p>However, <code>isduplicate[i]</code> is empty for all <code>i</code>, therefore you won't iterate over anything in the inner loop.</p>

<p>If what you want is to have 100 vectors of 100 <code>bool</code>s containing the <code>false</code> value, then:</p>

<pre><code>vector&lt;vector&lt;bool&gt;&gt; isduplicate(100, vector&lt;bool&gt;(100, false));
</code></pre>

<p>Should do it.</p>
",0
17833945,17833902,8,"<p>The value doesn't matter, the type does. Since <code>p</code> is a void pointer and <code>s</code> a char pointer,  you have to cast, even if they have the same value. In C it will be ok, <code>void*</code> is the generic pointer, but this is incorrect in C++.</p>

<p>By the way, <code>p</code> doesn't <em>contains char pointer</em>, it's a void pointer and it contains a memory address.</p>
",1
17833963,17833902,17,"<p>That's valid C, but not C++; they are two different languages, even if they do have many features in common.</p>

<p>In C++, there is no implicit conversion from <code>void*</code> to a typed pointer, so you need a cast. You should prefer a C++ cast, since they restrict which conversions are allowed and so help to prevent mistakes:</p>

<pre><code>s = static_cast&lt;char*&gt;(p);
</code></pre>

<p>Better still, you should use polymorphic techniques (such as abstract base classes or templates) to avoid the need to use untyped pointers in the first place; but that's rather beyond the scope of this question.</p>
",0
17834007,17833902,0,"<p>In general, this rule doesn't even have anything to do with pointers. It's just that you can assign values of some type to variables of other types, but not always vice versa. A similar situation would be this:</p>

<pre><code>double d = 0.0;
int i = 0;

d = i;    // Totally OK
i = d;    // Warning!
</code></pre>

<p>So that's just something you have to live with.</p>
",3
12339764,12339544,1,"<p>The code compiles with only a warning using an up-to-date compiler (GCC 4.6.3). Your compiler must not be fully compliant.</p>

<p>For a compilation with GCC 4.3.4, see <a href=""http://ideone.com/g7oTM"" rel=""nofollow"">here</a>.</p>
",1
10177842,10177809,3,"<p>To access the base-class function from the derived class, you can simply use:</p>

<pre><code>Base::func();
</code></pre>

<p>In your case, you would have this as the first line of the derived implementation of <code>func()</code>.</p>
",0
10177847,10177809,23,"<pre><code>class Derived : public Base
{
  void func() {
      Base::func();   // Call the base method before doing our own.
      cout &lt;&lt; ""derived"" &lt;&lt; endl;
  } 
};
</code></pre>
",0
10180726,10180632,3,"<p>Downcasting is illegal. A <code>HuffmanTree</code> is neither a <code>HuffmanNode</code>, nor a <code>HuffmanLeaf</code>, but the other way around.</p>

<p>What you're trying to do doesn't really make sense. Why would you convert a <code>HuffmanTree</code> to a <code>HuffmanNode</code> or a <code>HuffmanLeaf</code>?</p>

<p>Either way, to get this to <strong>compile</strong> (but, again, it doesn't make sense), you either have to declare conversion constructors for <code>HuffmanNode</code> or <code>HuffmanLeaf</code> or add <code>operator HuffmanNode()</code> and <code>operator HuffmanLeaf()</code> to <code>HuffmanTree</code>.</p>
",6
12791930,12791821,0,"<p>NVM I think I found my problem...I needed to make it into an if...else if statement and delete one of the </p>

<pre><code>else
  {
    *pp = list2;
    list2 = list2-&gt;next;
    (*pp)-&gt;next = NULL;
  }
</code></pre>

<p>blocks</p>

<p>Thanks anyways for those fast responders</p>

<p>Update:</p>

<p>Also I needed to change</p>

<pre><code>if(list2-&gt;deg &gt; list1-&gt;deg)
</code></pre>

<p>To</p>

<pre><code>if(list2-&gt;coef &lt; list1-&gt;coef)
</code></pre>
",0
15800667,15800596,3,"<p>The first loop invokes <a href=""http://www.cplusplus.com/reference/map/map/begin/"" rel=""nofollow""><code>begin()</code></a> which returns <code>std::pair</code>'s (i.e. <code>value_type</code> of <code>std::map</code>'s). So it doesn't make much sense to iterate over a pair like that. I think what you want is:</p>

<pre><code>for (auto &amp;animation : animationKey.second) {
</code></pre>

<p>Which will iterate over the inner-map. Just remember that the same thing will happen with <code>animation</code>: <code>animation</code> will be a pair, with <code>animation.first</code> referring to the key and <code>animation.second</code> referring to the value.</p>
",2
15800679,15800596,2,"<p>The error is saying it can't iterate over a pair. The following fixes the problem as you're getting the key-value pair result from iterating over a map in the first loop.</p>

<pre><code>for (auto &amp;animation : animationKey.second)
</code></pre>

<p>See <a href=""http://www.cplusplus.com/reference/map/map/begin/"" rel=""nofollow"">map.begin()</a> to see examples of how the first loop outputs pairs and not values to the auto variable.</p>
",0
11869726,11869676,3,"<p>I think you have the wrong idea about <code>const</code>. Think less of it as related to implementation details (like memory), or runtime, and more there as a means to help the programmer and for the compiler.</p>

<p>It doesn't matter when the memory gets allocated (although it's  before you construct the object, before entering the initializer list - not specified by the standard), what matters is you can only initialize the variable in the intializer list (pre C++11) or even the class definition for <code>const</code> integral types.</p>
",5
11869754,11869676,1,"<blockquote>
  <p>when does memory gets allocated to a constant variable</p>
</blockquote>

<p>Here, <code>a</code> is a data member of <code>class constant</code>, so it's allocated <em>as part of</em> <code>constant</code>. Whenever you create an instance of <code>constant</code>, there's an <code>a</code> already included.</p>

<p>Note that <code>static</code> members are different, but just because <code>a</code> isn't allowed to change after initialization, doesn't make its <em>storage</em> different from any other regular data member.</p>

<blockquote>
  <p>... is it necessary that constant variables be initialized at the point where they are allocated memory</p>
</blockquote>

<p>Strictly, you have to have the memory available before you can call the constructor, so the phrase <em>at the point where</em> is a bit problematic (see specifically Andr¨¦ Caron's comment about placement new).</p>

<p>However, allocation and construction are tied together in most normal use, and initialization of a const member <em>must</em> happen when the object is constructed.</p>
",2
11869766,11869676,0,"<p>Exact memory place for object members depends from object creation.
If you create object by ""new"" it is would be a heap.
If you create stack object (like on your example) it is would be a stack memory.
""Constant"" memory - it is memory for ""constant"", not for ""const variables"".</p>

<p>Other words, const memory used for literal strings, literal numbers (""text"", 5), while a const modifier restrict the memory update.</p>
",0
11870091,11869676,1,"<p>If the variable is <code>const</code>, the compiler enforces you to not change that value after initialization. That is, you must initialize it (<em>must</em> in the sense of <a href=""http://www.ietf.org/rfc/rfc2119.txt"" rel=""nofollow"">RFC2119</a>).</p>

<p>You must directly initialize it:</p>

<pre><code>struct constant {
  const int a;
  constant(int k) : a(k) {
    /* everything is fine here */
  }   
};
</code></pre>

<p>You must not leave it uninitialized:</p>

<pre><code>struct constant {
  const int a;
  constant(int k) { 
    /* error: uninitialized member ¡®constant::a¡¯ with ¡®const¡¯ type ¡®const int¡¯ */
  }   
};
</code></pre>

<p>And you must not change it's value after construction:</p>

<pre><code>struct constant {
  const int a;
  constant(int k) { 
    a = k; 
    /* error: uninitialized member ¡®constant::a¡¯ with ¡®const¡¯ type ¡®const int¡¯ */
    /* error: assignment of read-only data-member ¡®constant::a¡¯ */ 
  }
};
</code></pre>
",0
10779203,10779195,3,"<p>The <strong><a href=""http://www.cplusplus.com/reference/algorithm/sort/"" rel=""nofollow"">std::sort</a></strong> algorithm takes 3 arguments:     </p>

<ul>
<li>Random-Access iterators to the initial position.    </li>
<li>Random-Access iterators to the final position and     </li>
<li>Sorting criteria     </li>
</ul>

<p>So as long as you have <strong><em>any type</em></strong> which can provide the initial and final iterators and you provide the sorting criteria, you can use <code>std::sort</code>on that type.<br>
It is important though that sorting criteria has <strong><em>Strict Weak Ordering</em></strong>.</p>
",4
10027162,10027091,0,"<p>To the crasher: Your code is missing the terminating condition for the recursion. It means that even if the input range is empty, you still enter the recursive calls (with negative indicies to the array, which is probably causing the crash). You should add condition like</p>

<pre><code>if(there's at most 1 element in the input range)
  return; // already sorted
</code></pre>
",0
10027176,10027091,2,"<p>What is missing is the point to cancel the algorithm. If you check the control flow of you function, you'll see that on every path the application can walk though this function the <code>quicksort</code> function is called again. Finding out when you are done is simple. You just need to exit the function <strong>without</strong> calling <code>quicksort</code> again in case the parameters <code>start</code> and <code>end</code> are equal. That should do the trick.</p>
",3
14843895,10027091,0,"<pre><code>QuickSort Algorithm:

    - QuickSort( A[], l, r)
      - P = A[l] // Select pivot as the beginning element from array or you can do better //with good pivots.
      - i = l + 1 // index i to be next of pivot
      - for j = l + 1 to r
         - if A[j] &lt; P
           - swap (A[j], A[i])
           - increment i
         - end if
     - end for
     - swap (A[i-1], A[l]);
     -- Call recursive on left partitioned array
     -- Call recursive on right partitioned array.




// QuickSort_2.cpp : Defines the entry point for the console application.
//

#include ""stdafx.h""

#define ARR_SIZE            200
#define PR_ARR_SIZE         200
unsigned int input_arr[ARR_SIZE];

void swap(unsigned int *a, unsigned int *b)
{
    unsigned int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}

void print_input(unsigned int input[], unsigned int l, unsigned  int n)
{
    unsigned int i;
    for (i = l; i &lt; n; i++)
        printf(""%d "", input[i]);
    printf(""\n"");
}

void QuickSort(unsigned int input[], unsigned int l, unsigned int r)
{
    unsigned int i = l + 1, j;
    unsigned int pivot = input[l];
    if (l + 1 &lt; r) {
        for (j = l + 1; j &lt; r; j++) {
            if (input[j] &lt; pivot) {
                swap(&amp;input[j], &amp;input[i]);
                i++;
            }
        }
        swap(&amp;input[i - 1], &amp;input[l]);

        QuickSort(input, l, i);
        QuickSort(input, i, r);
    }
}


int _tmain(int argc, _TCHAR* argv[])
{
    unsigned int i = 0;
    unsigned int val;
    FILE *fp;

    errno_t err = fopen_s(&amp;fp, ""IntegerArray.txt"", ""r+"");
    if (err) {
        printf(""unable to open a file\n"");
        return -1;
    }
    while (fscanf_s(fp, ""%ld\n"", &amp;val) != EOF) {
        input_arr[n++] = val;
    }

    print_input(input_arr, 0, n);
    QuickSort(input_arr, 0, n);
    print_input(input_arr, 0, n);

    return 0;
}

Put these values in ""IntegerArray.txt"" file and 

2
3
4
5
6
10
11
12
1
17
18
19
20
7
8
9
13
14
15
16
</code></pre>
",0
17080623,10424059,2,"<p>The illegal escape sequence errors makes me think that there might be white space to the right of one or more backslashes.</p>

<p>Now its solved..</p>

<p>thanks all..</p>
",0
11125996,11125906,0,"<pre><code>void OnTimer()
{
   static bool inTimer = false; 
   if ( inTimer ) 
       return; 
   inTimer = true;   
   .... // do things
   inTimer = false;
}
</code></pre>
",0
11126004,11125906,1,"<p>Use a semaphore.</p>

<p>Down the Semaphore when you begin the previous call.
Up the semaphore when you finish execution.</p>

<p>The timer can fire at any time, it will hit the semaphore and wait on the current task to be completed before it attempts to access the function.</p>
",0
11129172,11129077,2,"<p>It does work properly, but you have chosen bad test data.</p>

<p><a href=""http://en.cppreference.com/w/cpp/algorithm/inplace_merge"" rel=""nofollow""><code>std::inplace_merge</code></a> does a merge on two sorted consecutive ranges in a sequence, <strong>like in a merge sort</strong>.</p>

<p>That is, if you pass the string <code>adebcf</code> (supposing the parameters are set as in your question), it will be merged into <code>abcdef</code>. 
If you pass a string <code>abcdef</code>, the result is the same as the input, because this string is already in order.</p>
",0
15857601,15857556,4,"<p>Honestly, I believe the correct solution is to <strong>follow standard convention</strong> and make <code>MyCustomException</code> derive from <code>std::exception</code>. Then, you would implement the <code>what()</code> virtual member function to return a message, and you could eventually insert that string into the standard output through <code>operator &lt;&lt;</code>.</p>

<p>This is how your exception class would look like:</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;stdexcept&gt;

using std::string;
using std::stringstream;

class MyCustomException : public std::exception
{
public:

    MyCustomException(const int&amp; x) {
        stringstream ss;
        ss &lt;&lt; x;
        msg_ = ""Invalid index ["" + ss.str() + ""]"";
    }

    virtual const char* what() const noexcept {
        return (msg_.c_str());
    }

private:

    string msg_;
};
</code></pre>

<p>And here is how you would use it:</p>

<pre><code>#include &lt;iostream&gt;

using std::cout;

int main()
{
    try
    {
        throw MyCustomException(42);
    }
    catch(const MyCustomException &amp;e)
    {
        cout &lt;&lt; e.what();
    }
}
</code></pre>

<p>Finally, a <a href=""http://liveworkspace.org/code/4yc7Hy%243646"" rel=""nofollow"">live example</a>.</p>
",0
12275269,12275248,3,"<p>No, overflow in signed integral types results in undefined behavior.</p>

<p>EDIT: In addition to paxdiablo's quote:</p>

<p>3.9.1.</p>

<blockquote>
  <p>Note 46) This implies that unsigned arithmetic does not overflow because a
  result that cannot be represented by the resulting unsigned integer
  type is reduced modulo the number that is one greater than the largest
  value that can be represented by the resulting unsigned integer type.</p>
</blockquote>
",1
12275310,12275248,4,"<p>No, it's not guaranteed. C++03 has this to say in <code>5 Expressions, paragraph 5</code>:</p>
<blockquote>
<p>If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined, unless such an expression is a constant expression, in which case the program is ill-formed. [Note: most existing implementations of C + + ignore integer overflows].</p>
</blockquote>
<p>Further, there is nothing in <code>5.7 Additive operators</code> that modifies this behaviour. This is unchanged in C++11.</p>
<p>That's for signed types, which is what you asked about in your question.</p>
<hr />
<p>If you're also interested in unsigned types, section <code>3.9.1 Fundamental types, paragraph 4</code> states:</p>
<blockquote>
<p>Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the number of bits in the value representation of that particular size of integer (see footnote 41).</p>
<p>Footnote 41: This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</p>
</blockquote>
",11
10158663,10158616,-1,"<p><strong>Try this :</strong></p>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;

double tester;
using namespace std;

void stoupper (std::string&amp; s)
{
     std::string::iterator i = s.begin();
     std::string::iterator end = s.end();

     while (i != end) {
          *i = std::toupper((unsigned char)*i);
          ++i;
     }
}

double squarerootfinder (double number, double divisor){
     tester = (number / (divisor * divisor));

     if (divisor == 1) {
          return 1;
     }
     else {
          if (tester != (int)tester) divisor = squarerootfinder(number, divisor - 1);
     }

     return divisor;
}

int main() {
     string runagain;
     double number, divisor, squareroot, insidepart;

     do {    
          cout &lt;&lt; ""Enter a whole number to find the square root of it \n"";
          cin &gt;&gt; number;

          divisor = number;
          squareroot = squarerootfinder(number, divisor);
          insidepart = number / (squareroot * squareroot);

          if (insidepart != 1) {
               cout &lt;&lt; squareroot &lt;&lt; (char)251 &lt;&lt; insidepart;
               cout &lt;&lt; endl;
          }
          else {
               cout &lt;&lt; squareroot &lt;&lt; endl;                  
          }

          cout &lt;&lt; ""written by Arpan Gupta! \n"";
          cout &lt;&lt; ""Enter run again to run the program again. \n"";
          cin &gt;&gt; runagain;

          stoupper(runagain);

     } while (runagain == ""RUN AGAIN"");    

     return 0;
}
</code></pre>

<hr>

<p>The idea is to try and check any variation of ""RUN aGAiN"" the user may input (regardless of whether it is all <strong>uppercase/lowercase</strong> or whatever... most likely that's where your issue lies...)</p>

<p>OK, and I cleaned up your code a bit... :-)</p>

<hr>

<p>EDIT : And, yep : absolutely NO reason to re-declare <code>runagain</code> within your <code>do { } while()</code> loop.</p>
",0
10158677,10158616,1,"<p>You declare the <code>string runagain;</code> twice in your main loop which is unnecessary. Also <code>double tester</code> should be declared in <code>squarerootfinder</code> function as you don't use it anywhere else in the program.</p>

<p><code>cin</code> ignores whitespace you should look into the getline function instead. This <a href=""http://www.cplusplus.com/reference/string/getline/"" rel=""nofollow"">link</a> provides an example of how to use it. Using <code>cin</code> here is the source of the problem. You can test this by simply adding the line:</p>

<pre><code>cout&lt;&lt;runagain;
</code></pre>

<p>Directly after <code>cin&gt;&gt;runagain;</code>.</p>

<p>In this code:</p>

<pre><code> cout &lt;&lt; ""Enter a whole number to find the square root of it \n"";
 cin &gt;&gt; number;
 divisor = number;
 squareroot = squarerootfinder(number, divisor);
</code></pre>

<p>You set <code>divisor=number;</code> then call <code>squarerootfinder</code> but instead of using divisor why not just do it like this:</p>

<pre><code> cout &lt;&lt; ""Enter a whole number to find the square root of it \n"";
 cin &gt;&gt; number;
 squareroot = squarerootfinder(number, number);
</code></pre>

<p>Because <code>divisor</code> and <code>number</code> are equal after all.</p>
",0
15532100,15531961,1,"<p>You're passing the argument by reference, but your assignment below is copying the referenced object into the stack.</p>

<blockquote>
  <p>stack[top++]=c;</p>
</blockquote>

<p>This is using an implicitly generated assignment operator, which copies each of the members of the customer class.</p>
",0
15532457,15531961,0,"<p>You need to change the value of c2 before adding it to the stack.</p>
",0
14814102,14813989,1,"<p>The expression <code>&amp;buffer</code> will give you the address of <code>buffer</code>, which is somewhere on your stack. </p>

<p>The expresson <code>(void *)buffer</code> will give you the address contained in buffer, as a void pointer (in this case, that means that the <code>cout</code> will print the value as a hexnumber representing the pointer, rather than trying to, for example, print the value as a string, which would be what the code would normally do with a <code>char *</code>. </p>
",0
14814107,14813989,1,"<p>One of those displays the address of a variable, the other displays the value of the variable. Consider these:</p>

<pre><code>int i = 7;
std::cout &lt;&lt; &amp;i &lt;&lt; ""\n"";
std::cout &lt;&lt; i &lt;&lt; ""\n"";
</code></pre>

<p>The former displays the address of the variable called <code>i</code> (likely a large even number). The other displays its value (7).</p>

<p>Similarly:</p>

<pre><code>char *buffer;
std::cout &lt;&lt; &amp;buffer &lt;&lt; ""\n"";
std::cout &lt;&lt; (void*)buffer &lt;&lt; ""\n"";
</code></pre>

<p>The former displays the address of <code>buffer</code>. The latter displays its cast value.</p>
",0
14814112,14813989,3,"<p>Your question can be <strong><a href=""http://ideone.com/JqswSi"" rel=""nofollow"">essentially reduced to</a></strong>:</p>

<pre><code>#include&lt;iostream&gt;

int main()
{
    int i = 10;
    int *ptr = &amp;i;

    std::cout&lt;&lt;(void*)ptr&lt;&lt;""\n"";
    std::cout&lt;&lt;(void*)&amp;i&lt;&lt;""\n"";
    std::cout&lt;&lt; &amp;ptr&lt;&lt;""\n"";
}
</code></pre>

<p><strong>Output:</strong>     </p>

<pre><code>0xbfa080b8
0xbfa080b8
0xbfa080bc
</code></pre>

<p><code>ptr</code> gives you the address of object the pointer is pointing to i.e same as <code>&amp;i</code>.<br>
<code>&amp;ptr</code> gives the address of the location where the pointer itself is stored.</p>
",2
14814121,14813989,1,"<p>The difference is simple. <code>buffer</code> is a pointer-to-char, so <code>(void*)buffer</code> is the location in memory of the allocated character array (as a <code>void</code> pointer). <code>&amp;buffer</code>, on the other hand, is the location in memory of <code>buffer</code> <em>itself</em>.</p>

<p>A diagram may help; <strong>this is symbolic of what's happening and doesn't represent what the actual memory layout will look like!</strong></p>

<pre><code>Memory
AB AB AB AB 00 00 00 08  &lt;-- buffer = 00 00 00 08; the characters are stored starting at 0x08
             ^
             |---------     &amp;buffer is the memory location of buffer, and is 0x04
30 31 32 32 AB AB AB AB
^
|-------- char array starts at 0x08, and contains the string ""1234""
</code></pre>
",0
11577811,11519957,1,"<p>Got it, 
Need to start thrift server on hbase by <code>.&lt;hbaseinstallationpath&gt;/bin/hbase thrift -threadpool start</code></p>
",0
10770729,10770675,0,"<p><code>fwrite</code> is buffered, which is what you want. Though with that big files/writes it shouldn't make much or any difference.  Maybe experiment with a larger stream buffer with the <code>setbuf</code> call.</p>

<p>Since you are limited by physical disk i/o speeds, as long as you are making it as easy as possible for the system to use each available disk io efficiently there's not really more you can do.</p>

<p><code>vmstat</code> on linux (other similar tools on other systems) can tell you how many disk i/os your disk is doing, so you can test if your changes help anything.</p>
",0
10771024,10770675,1,"<p>What if you'll use memory mapped files limited to, for example, 1GB each? This should provide enough speed and buffer to work with all frames, especially if you'll manage to perform zero-copy frame allocation.</p>
",2
10771646,10770675,0,"<p>Asynchronous non-buffered output is a key to success in your case. Buffered IO will only cause double-buffering overhead and sync IO will make HDD heads  missing sequential sectors.</p>

<p>Boost.Asio provides a relatively good encapsulation of system-specific APIs for popular platforms.</p>

<p>There are few things to remember:</p>

<ul>
<li>on most non-Windows platforms you will have to write to raw partitions go get system's bufferization and internal threading out of the way.</li>
<li>keep the write queue non-empty all the time, so the SATA controller can help you by means of NCQ.</li>
<li>pay attention to system-specific requirements to buffer alignment and size for async non-buffered IO to work.</li>
<li>file open mode is also important to make the system to do what you want.</li>
</ul>
",2
10803721,10803523,0,"<p>In your example there's no way for the compiler to tell whether you mean the second or third constructor when it is invoked with only a single argument.</p>

<p>Typically if you need to add a new constructor with additional default arguments you would make the defaults result in the same behavior as the earlier constructor and get rid of the earlier version, e.g. in this case the default for b2 would have to be 54. Alternatively don't give the new constructor a default argument and just require the caller to pass it explicitly.</p>

<p>I suppose another option would be to have multiple derived classes with default constructors that pass different arguments to the base class constructor.</p>

<pre><code>class A
{
public:
    int a, b;
    A() { a = 5; b = 6; }
    A(int a1) { a = a1; b = 54; }
    A(int a1, int b1) { a = a1; b = b1; }
    ...
};

class B: public A
{
public:
    B(int a1): A(a1, 8) { }
};
</code></pre>

<p>Code that wants A::b initialized with 8 instead of 54 create a B instead. That isn't a good option in many situations though.</p>
",0
10803737,10803523,1,"<p>Remove <code>A(int a1)</code> function and instead of <code>A b(3)</code> call <code>A b(3, 54)</code></p>
",0
10803637,10803523,1,"<p>what you're asking for from the compiler has the ambiguity. </p>

<pre><code>A(int a1)
{
    a=a1;
    b=54;
}
</code></pre>

<p>and </p>

<pre><code>A(int a1,int b2=8)
{
    a=a1;
    b=b2;
}
</code></pre>

<p>are the same when your class gets created by only one parameter. write-down your expectation from the class in english language for yourself first. then, convert it to c++ code. Example: ""If my class A is created with only one parameter, than make my variable a equal to that parameter and let my variable b be 54. If it's created by two params than give the first one to a, and the second one to b"" and your code for this expression is:</p>

<pre><code>A(int a1,int b2=54)
{
    a=a1;
    b=b2;
}
</code></pre>
",0
10803696,10803523,4,"<p>First, answer this:</p>

<p>When you write <code>A a(4)</code>, do you want <code>a.b.</code> to be:</p>

<p>Option a) <strong>54</strong></p>

<pre><code>class A
{
    public:
    int a,b;
    A()
    {
        a=5;
        b=6;
    }
    A(int a1,int b2 = 54)
    {
        a=a1;
        b=b2;
    }
};    
</code></pre>

<p>Option b) <strong>8</strong></p>

<pre><code>class A
{
    public:
    int a,b;
    A()
    {
        a=5;
        b=6;
    }
    A(int a1,int b2 = 8)
    {
        a=a1;
        b=b2;
    }
};    
</code></pre>

<p>The error is there for a reason. <strong>If you don't know what you want from the code, how can you expect the compiler to?</strong></p>

<p>EDIT: After your edit - impossible. Not with that exact code. </p>
",1
11165241,11111568,0,"<p>One of the reasons may be the following:</p>

<pre><code>static char data[1000000000000000000000000000000];

void main(int argc)
{
    if (argc &gt; 0)
        data[0] = 0;
}
</code></pre>

<p>It might be reasonable to allocate and init this static array only when it turns out that it is really needed. It might happen that some application were coming across something similar and had enough voice to convince the committee. In my own experience with C# I came across situation when static members of the class were not allocated right after jitting the class. They were allocated one by one, on the first use. In that case there was absolutely no justification for doing that. It was a plain disaster. Maybe they fixed this now.</p>

<p>Other reasons are possible also.</p>
",2
11165894,11111568,0,"<p>From the C++11 draft:</p>

<blockquote>
  <p>It is implementation-defined whether the dynamic initialization of a non-local variable with static storage
  duration is done before the first statement of main. If the initialization is deferred to some point in time after the first statement of main, it shall occur before the <strong>first odr-use (3.2) of any function or variable defined in the same translation unit</strong> as the variable to be initialized. <em>[emphasis mine]</em></p>
</blockquote>

<p>That is, the static variable has to be initialized before any use of anything defined in the same translation unit.</p>

<p>It looks to me that it is done this way to allow dynamic libraries (DLLs or SOs) to be loaded and initialized lazily, or even dynamically (calling <code>dlopen</code> or <code>LoadLibrary</code> or whatever).
It is obvious that a variable defined in a DLL cannot be initialized before the DLL itself is loaded.</p>

<p>Naturally, C++ knows nothing about DLLs so there is no direct mention to them in the standard. But the people from the commitee do know about real environments and compilers, and certainly know about DLLs. Without this clause, lazy loading a DLL would technically violate the C++ specification. (Not that it would prevent implementators to do it anyway, but it is better if we all try to go along with each other.)</p>

<p>And about which systems support this, that I know of, at least the MS Visual C++ compiler supports lazy dynamic linking (the DLL will not even be loaded until first use). And most modern platforms support dynamic loading a DLL.</p>
",5
15822125,15822069,0,"<p>Without seeing your <code>Matrix</code> class definition it's hard to guess how it's implemented, but you probably want something like this:</p>

<pre><code>std::ostream&amp; operator&lt;&lt; (std::ostream &amp;os, const Matrix &amp;matrix) {
    for (int i = 0; i &lt; matrix.rows; ++i)
    {
        for (int j = 0; j &lt; matrix.cols; ++j)
            os &lt;&lt; "" "" &lt;&lt; matrix.data[i * matrix.cols + j];
        os &lt;&lt; std::endl;
    }
    return os;
}
</code></pre>

<p>To display the matrix you would then just do this:</p>

<pre><code> Matrix a;
 // fill in the matrix
 cout &lt;&lt; a;
</code></pre>

<p>This invokes the above <code>operator&lt;&lt;</code> implementation to print the matrix to stdout. Obviously you can use any other appropriate output stream instead of <code>cout</code>.</p>
",8
15822374,15822069,1,"<p>You either need to write the result from the <code>ostringstream</code> to <code>cout</code>:</p>

<pre><code>ostringstream os;
Matrix a;
// fill in the matrix
os &lt;&lt; a;
cout &lt;&lt; os.str();
</code></pre>

<p>or you do it directly:</p>

<pre><code>Matrix a;
// fill in the matrix
cout &lt;&lt; a;
</code></pre>
",2
11177766,11177684,2,"<pre><code>#include &lt;fstream&gt;
</code></pre>

<p>must be in your header file as well. It goes into the including translation unit, but it still needs to see it because upon expanding inside the .cpp file, it ends up above the #include of fstream. This way you make sure that order won't affect compilation because inclusion guards are in place. It won't try to expand it twice. Also, <code>#pragma once</code> saves kittens.</p>

<p>The reason your ordering gives the same errors is because your header lacks ""using std::goeshere"" etc.</p>

<p><strong>Code sample as a followup in the comments (preventing namespace pollution):</strong></p>

<pre><code>#ifndef GET_H
#define GET_H

#include &lt;fstream&gt;
using std::fstream;

int get_int(fstream&amp; stream, int offset);

#endif
</code></pre>

<p>or (#pragma once should be supported by all decent compilers)</p>

<pre><code>#pragma once

#include &lt;fstream&gt;
using std::fstream;

int get_int(fstream&amp; stream, int offset);
</code></pre>
",4
11177871,11177684,3,"<p>You must do this:</p>

<pre><code>#ifndef GET_H
#define GET_H

#include &lt;fstream&gt;

int get_int(std::fstream&amp; stream, int offset);

#endif
</code></pre>

<p>Notice the <code>#include &lt;fstream&gt;</code> and the added <code>std::</code> prefix. The qualification is needed because all C++ Standard library... things... are defined in that namespace. You should not add a <code>using namespace std;</code> or <code>using std::fstream;</code> in a header, because that pollutes the global namespace and defeats the purpose of the existence of <code>namespace std</code>: people including your header don't expect stuff to be pulled into the global namespace, which may conflict with naming used by others.</p>
",3
11812275,11812253,3,"<p>The <code>&amp;&amp;</code> and <code>||</code> operators are <em>short-circuiting</em>. They evaluate the left side, and then evaluate the right side only if necessary to determine the value.</p>

<p>Therefore, if the left side of <code>||</code> is true the right side is not evaluated, and if the left side of <code>&amp;&amp;</code> is false the right side is not evaluated.</p>

<p>In your example, since <code>++x</code> is true (<code>2</code>), the right side of the <code>||</code> is not evaluated.</p>
",0
11812287,11812253,3,"<p>Operator precedence tells you how to group expressions; it doesn't tell you in which order they are executed.</p>

<p><code>||</code> and <code>&amp;&amp;</code> are special in that the first operand is always evaluated first and the second operand (including all sub-expressions) is <em>only</em> evaluated if it is required to determine the value of the expression.</p>

<p>For <code>||</code>, if the first operand evaluates to <code>true</code> the second operand is not evaluated because the result of the logical-or will always be true.</p>

<p>Similarly, the second operand of <code>&amp;&amp;</code> will not be evaluated if the first operand evaluates to false as the logical-and must be false in this case.</p>

<p>In the expression <code>z=++x || ++y &amp;&amp; ++z</code>, the grammar rules specify a grouping:</p>

<pre><code>z = ((++x) || ((++y) &amp;&amp; (++z)));
</code></pre>

<p>In the sub-expression <code>(++x) || ((++y) &amp;&amp; (++z))</code>, as <code>(++x)</code> evaluates to <code>true</code> (as 2 is non-zero), the second operator <code>((++y) &amp;&amp; (++z))</code> is never evaluted. <code>x</code> becomes 2, <code>y</code> is unchanged and <code>z</code> is assigned <code>1</code> (<code>true</code> converted to an integer).</p>
",2
11812293,11812253,1,"<p>Logical OR Operator requires if any of the two operands is non zero then then condition becomes true. In the expression <code>A||B</code>, either <code>A</code> or <code>B</code> is non zero then <code>(A || B)</code> will br true or equal to <code>1</code>. 
So <code>++y</code> and  <code>++z</code> will be ignored by the compiler because value of <code>++x</code> is <code>1</code>.</p>
",0
11812310,11812253,1,"<p>Keep in mind that the compiler is going to execute the whole logical expression only if it NEEDS to. Otherwise, it tries to get away with as little work as possible. </p>

<p>For example, if you use the &amp;&amp; operator, it is necessary for both expressions to be evaluated. However, if you use the || operator (which you have), if the first expression on the left hand side is true, the right hand side is not executed. In your example, ++x gives 2, which is evaluated to a boolean TRUE. End of story for the compiler since once true, an OR statement will never revert to FALSE. This concept is called 'short-circuiting' by the compiler. That is why you got the output that you described.</p>
",0
12256452,12256440,3,"<p>Unless you use <code>static</code> on a free standing function or variable declared at global scope they will have <strong><em>external linkage</em></strong>.   </p>

<p>Note that using the keyword <code>inline</code> on a function does not change the linkage of an function.      </p>

<p>Another important point to note is that <code>const</code> variables have Internal Linkage in C++ unlike in C.</p>

<hr>

<blockquote>
  <p>The linkages implied by successive declarations for a given entity shall agree. That is, within a given scope, each declaration declaring the same object name or the same overloading of a function name shall imply the same linkage. Each function in a given set of overloaded functions can have a different linkage, however."" </p>
</blockquote>

<p>An declaration introduces an Identifier to the compiler, so that the compiler can know its type.In C++ an identifier can be declared as many times as you want, for example:      </p>

<pre><code>void doSomething(int, double);         // External Linkage
extern void doSomething(int, double);  // External Linkage is explicitly mentioned 
</code></pre>

<p>The quoted passage implies that all such declarations for the same identifier should specify the same linkage. For eg, following would be invalid:</p>

<pre><code>void doSomething(int, double);        //External Linkage
static void doSomething(int, double); //Internal Linkage due to static
</code></pre>

<p>While, overloaded versions of the same function can have different linkages, so following is valid:  </p>

<pre><code>void doSomething(int, double);
extern void doSomething(int, double);
void doSomething(double,int);
</code></pre>
",0
18148241,18147446,1,"<p>Use the <a href=""http://msdn.microsoft.com/en-us/library/vstudio/hh874892.aspx"" rel=""nofollow"">complete</a> function:</p>

<pre><code>auto full_path = std::tr2::sys::complete(path, folder);
</code></pre>

<p>Another simple way to do it would be be to simply append the filename to the path (tested on MSVC2012 with the <code>&lt;filesystem&gt;</code> in the <code>std::tr2::sys</code> namespace):</p>

<pre><code>for (; start != end; ++start) {
    auto path = start-&gt;path();
    auto full_path = folder / path;
}
</code></pre>
",1
15574614,15574551,1,"<p>We're passing a reference so that a copy of the <code>stack</code> object will not be made. If a copy was made, modification thereof will not affect the original <code>stack</code> object passed to the function.  It will only affect the <em>copy</em> which is local to the function.</p>

<p>A reference is like an alias to of an object; when declared as</p>

<pre><code>stack&lt;int&gt;&amp; source
</code></pre>

<p><code>source</code> now refers to that object.</p>
",0
15574635,15574551,1,"<p>The function used in the mentioned question had the following prototype:</p>

<pre><code>void Hanoi(int nDisks, stack&lt;int&gt; source, stack&lt;int&gt; intermed, stack&lt;int&gt; dest)
</code></pre>

<p>i.e. it takes all passed <code>stack&lt;int&gt;</code> objects by value. The copy of passed <code>stack</code> is created and any changes made to this object within the body of this function change the copy, not the original object that has been passed to it.</p>

<p>That's why the solution was to pass these <code>stack</code> objects by reference instead of passing by value. Basically references (such as <code>stack&lt;int&gt;&amp; dest</code>) allow you treat <code>dest</code> inside the <code>Hanoi</code> function just like its type would be <code>stack&lt;int&gt;</code>, there's just no copying and changes are visible to the caller :)</p>
",0
14840788,14840752,24,"<p>This is incorrect:</p>

<pre><code>Handler AQUI;
</code></pre>

<p>You cannot instantiate an abstract class.</p>

<p>What you want to do is define a pointer to <code>Handler</code> and assign it the address of a valid object from a child class, like <code>Oracle</code>.</p>
",0
13461427,13461248,0,"<p>Several issues in your code:</p>

<ul>
<li>you define <code>gf_ord</code> as <code>static</code>, and it cannot be, since it returns an instance field. You probably mean <code>const</code> instead,</li>
<li>same for <code>gf_inv</code></li>
<li><code>gf_ord</code> returns a <code>gf_t</code>, but the internal field is a int, you could get rounding errors</li>
</ul>

<p>Here's perhaps a better declaration:</p>

<pre><code>#include &lt;exception&gt;


class GaloisField{
protected:
    gf_t * gf_exp;
    gf_t * gf_log;
    int gf_extension_degree, gf_cardinality;
    gf_t gf_multiplicative_order;
public:
    GaloisField();
    gf_t gf_ord() const;
    int gf_inv(int x) throw(std::runtime_error);
    // ...
};
</code></pre>

<p>and in gf.cpp</p>

<pre><code>GaloisField::GaloisField() {
    // here you should initialize your protected fields to default values
    // and create the gf_exp and gf_log arrays
}

gf_t GaloisField::gf_ord() const {
    return gf_multiplicative_order;
}

int GaloisField::gf_inv(int x) {
     int idx = gf_ord() - gf_log[x];
     if (idx &gt;= 0)
       return gf_exp[idx];
     throw std::runtime_error(""gf_inv"");
}
</code></pre>

<p>If you don't initialize the arrays in your class, you will get runtime errors, notably at line 181.</p>

<p>Perhaps you will also need another constructor to give your internal fields proper values.</p>
",1
13461310,13461248,5,"<p>Since <code>gf_inv</code> is a static function, there is no <code>this</code> pointer. Without <code>this</code>, you can't access <code>gf_log</code>.</p>

<p>I don't know why the error message is so cryptic.</p>
",3
10179823,10179803,0,"<p>It's a reference to a pointer. A pointer is a data-type, why shouldn't you be allowed to have references to one?</p>

<p>It means the same thing as any other type reference - it's an alias for a pointer.</p>
",3
10179892,10179803,2,"<p>That is reference to a pointer. Think in this way:</p>

<pre><code>A *pa = new A(); //pa is pointer to A

A * &amp; rpa = pa; //rpa is reference to pa

rpa = nullptr;  //it modifies pa as well

if ( pa == nullptr )
{
     std::cout &lt;&lt; ""pa is nullptr"" &lt;&lt; std::endl;
}
</code></pre>

<p>It will print <em>""pa is nullptr""</em> on the console.</p>

<p>If you find <code>A * &amp;</code> difficult to read, then you can use typedef as:</p>

<pre><code>typedef A* PA;

PA &amp; rpa = pa; //same as before
</code></pre>
",1
10179914,10179803,2,"<p>The code like you wrote it won't compile, since it declares a reference to a pointer, but the reference is uninitialized. For example, the following code won't compile:</p>

<pre><code>string *&amp;s;
</code></pre>

<p>(unless it's a member in a class), but this will:</p>

<pre><code>string *p;
string *&amp;s = p;
</code></pre>

<p>Another possibility, is that this is just a typo and they meant to write <code>Obj *obj;</code> ;)</p>
",2
10179962,10179803,1,"<p>That's a reference to a pointer. After all, a pointer is also a value. You might use it to reassign a pointer held by the caller. To illustrate:</p>

<pre><code>bool allocate(t_object*&amp; p) {
  assert(0 == p);
  p = new t_object;
  ...
}
</code></pre>

<p>Then:</p>

<pre><code>t_object* obj(0);
if (!allocate(obj)) {...}
// obj now points to something
</code></pre>

<p>Some people find it easier to manage/read that its most direct alternative (<code>bool allocate(t_object** p)</code>).</p>

<p>As to why a reference to a pointer was chosen in the program -- there's not enough context, but you can ask yourself if the program would be <em>better</em> if the member were declared <code>t_object** const</code>?</p>
",0
11810457,11810432,5,"<p>Most vexing parse:</p>

<pre><code>Word a();
</code></pre>

<p>should be</p>

<pre><code>Word a;
</code></pre>
",1
9846445,9846416,3,"<p>It's comparing <code>const char*</code>, the result of <code>""1""</code> and <code>""0""</code> is undefined by the standard, whereas the comparison of 2 <code>std::string</code>s is defined and your output in that case is expected.</p>

<p>Quick case in point:</p>

<pre><code>char* y = ""0"";
char* x = ""1"";
std::cout &lt;&lt; (x&lt;y) &lt;&lt; endl;
    //output 1 on my platform
</code></pre>

<p>and</p>

<pre><code>char* x = ""1"";
char* y = ""0"";
std::cout &lt;&lt; (x&lt;y) &lt;&lt; endl;
    //output 0 on my platform
</code></pre>

<p>I'm specifying ""on my platform"" because there's no standard rule (but it can be a compiler rule) to where the pointers are created or in which order they are created. </p>

<p>In my case, the addresses are assigned in reverse order of declaration.</p>

<p>I'm willing to bet that if you run:</p>

<pre><code>cout &lt;&lt; (""1"" &lt; ""0"") &lt;&lt; endl;
</code></pre>

<p>and</p>

<pre><code>cout &lt;&lt; (""0"" &lt; ""1"") &lt;&lt; endl;
</code></pre>

<p>you'd get the same output (although it's not a rule). Note that you should run them in different instances of the program. If you run them in the same instance, you might get different results, as string literals reside in a single place in memory.</p>
",4
9846469,9846416,3,"<p>Expression ""1"" &lt; ""0"" compares values of two pointers. One points to character sequence ""1"" and the other points to character sequence. Your compiler placed character sequences in memory in such a way that address of char sequence ""1"" is before that of ""0"".</p>

<p>With strings, however, operator&lt;(const string&amp;, const string&amp;) is called, as expected.</p>
",0
9846485,9846416,1,"<p>Because you are comparing two pointers (the strings <code>""1""</code> and <code>""0""</code> are represented as arrays of <code>char</code>, synonymous (kinda) with pointer to char).  If you want the comparison between the numbers 0 and 1, you don't need the quotes.  Otherwise you need a string comparison function that compares the content of the strings, not their addresses.  Best if you wrap them in an <code>std::string</code> and use the <code>compare()</code> member function.</p>
",0
10189486,10189448,5,"<pre><code>std::istringstream istr(your_string);

std::vector&lt;int&gt; numbers;
int number;
while (istr &gt;&gt; number)
    numbers.push_back(number);
</code></pre>

<p>Or, simpler (though not really shorter):</p>

<pre><code>std::vector&lt;int&gt; numbers;
std::copy(
    std::istream_iterator&lt;int&gt;(istr),
    std::istream_iterator&lt;int&gt;(),
    std::back_inserter(numbers));
</code></pre>

<p>(Requires the standard headers <code>&lt;sstream&gt;</code>, <code>&lt;algorithm&gt;</code> and <code>&lt;iterator&gt;</code>.)</p>
",0
10189498,10189448,9,"<p>Try this:</p>

<pre><code>#include &lt;sstream&gt;

std::string str = ""12 34 56"";
int a,b,c;

std::istringstream stream(str);
stream &gt;&gt; a &gt;&gt; b &gt;&gt; c;
</code></pre>

<p>Read a lot about c++ streams here: <a href=""http://www.cplusplus.com/reference/iostream/"" rel=""noreferrer"">http://www.cplusplus.com/reference/iostream/</a></p>
",2
10189567,10189448,0,"<p>You can also opt for Boost tokenizer ......</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;boost/foreach.hpp&gt;
#include &lt;boost/tokenizer.hpp&gt;
using namespace std;
using namespace boost;

int main(int argc, char** argv)
{
    string str= ""India, gold   was dear"";
    char_separator&lt;char&gt; sep("", "");
    tokenizer&lt; char_separator&lt;char&gt; &gt; tokens(str, sep);
    BOOST_FOREACH(string t, tokens)
    {
        cout &lt;&lt; t &lt;&lt; ""."" &lt;&lt; endl;
    }
}
</code></pre>
",1
10189743,10189448,0,"<p><code>stringstream</code> and <code>boost::tokenizer</code> are two possibilities. Here is a more explicit solution using <code>string::find</code> and <code>string::substr</code>.</p>

<pre><code>std::list&lt;std::string&gt;
tokenize(
  std::string const&amp; str,
  char const token[])
{
  std::list&lt;std::string&gt; results;
  std::string::size_type j = 0;
  while (j &lt; str.length())
  {
    std::string::size_type k = str.find(token, j);
    if (k == std::string::npos)
      k = str.length();

    results.push_back(str.substr(j, k-j));
    j = k + 1;
  }
  return results;
}
</code></pre>

<p>Hope this helps. You can easily turn this into an algorithm that writes the tokens to arbitrary containers or takes a function handle that processes the tokens.</p>
",0
9862480,9862444,2,"<p><code>&lt;iomanip&gt;</code> is indeed the way to go:</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;

for (unsigned int i = 0; i != nrows; ++i)
{
    for (unsigned int j = 0; j != ncols; ++j)
    {
        if (j != 0) std::cout &lt;&lt; "" "";
        std::cout &lt;&lt; std::setw(5) &lt;&lt; std::setfill(' ') &lt;&lt; std::setprecision(2)
                  &lt;&lt; static_cast&lt;double&gt;(data[i][j]);
    }
    std::cout &lt;&lt; ""\n"";
}
</code></pre>
",0
10026690,10026637,1,"<p>Or pass aMedia by reference Media&amp; to &lt;&lt; so that virtual dispatching will occur.</p>

<p>You're passing a Media object directly, which means a new copy of the DVD object will be created, and the DVD only parts will be thrown away and just the Media parts of it will be end up in the aMedia parameter.</p>

<p>see:</p>

<pre><code>ostream&amp; operator &lt;&lt; (ostream&amp; out, const Media&amp; aMedia){
    aMedia.print(out);
    return out;
}
</code></pre>
",2
10026702,10026637,1,"<p>Problem is in this declaration <code>ostream&amp; operator &lt;&lt; (ostream&amp; out, Media aMedia)</code>. You are accepting the parameter <code>aMedia</code> by copy which causes object slicing, accept it by using a reference by changing the signature to <code>ostream&amp; operator &lt;&lt; (ostream&amp; out, const Media&amp; aMedia)</code> . </p>

<p>Because of the slice when you do <code>cout &lt;&lt; *ptr</code> , a <em>copy</em> of the <code>DVD</code> is created of type <code>Media</code> (i.e. DVD is sliced to a Media), now when you call <code>print</code> since the type of the object is <code>Media</code> call goes to the <code>Media::print</code>. You can read more about object slicing <a href=""https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c"">here</a>.</p>
",1
11167081,11167062,17,"<p>Your member function:</p>

<pre><code>void display(int l=this-&gt;length)
</code></pre>

<p>is conceptually equivalent to this:</p>

<pre><code>void display(A * this, int l=this-&gt;length); //translated by the compiler
</code></pre>

<p>which means, you're using one parameter in an expression which is the default argument for other parameter which is not allowed in C++, as ¡ì8.3.6/9 (C++03) says,</p>

<blockquote>
  <p>Default arguments are evaluated each
  time the function is called. <em>The order
  of evaluation of function arguments is
  unspecified</em>. <strong>Consequently, parameters
  of a function shall not be used in
  default argument expressions</strong>, even if
  they are not evaluated.</p>
</blockquote>

<p>Note that C++ doesn't allow this:</p>

<pre><code>int f(int a, int b = a); //illegal : ¡ì8.3.6/9
</code></pre>

<hr>

<p>The solution is to add one overload which takes no parameter as:</p>

<pre><code>void display()
{
    display(length); //call the other one!
}
</code></pre>

<p>If you don't want to add one more function then <em>choose an impossible default value</em> for the parameter. For example, since it describes <em>length</em> which can never be negative, then you may choose <code>-1</code> as the default value, and you may implement your function as:</p>

<pre><code>void display(int l = -1)
{
      if ( l &lt;= -1 ) 
           l = length; //use it as default value!
      //start using l 
}
</code></pre>
",5
11167082,11167062,1,"<p>At compile time, there is no object, so there is no this.</p>

<p>Why would you pass in one of your object's properties as a default value into a member function if that member function can access the property itself?</p>
",2
11167090,11167062,3,"<p>You could user overloading and forwarding instead.</p>

<pre><code>class A
{
    private:
    int length;
    public:
    A();

    void display()
    {
        display(this-&gt;length);
    }

    void display(int l)
    {
        cout&lt;&lt;""the length is ""&lt;&lt;l&lt;&lt;endl;
    }
};
</code></pre>
",0
18141476,18141449,2,"<p>Use a reference:</p>

<pre><code>const auto&amp; mygraph = ui.myplot-&gt;graph(0);
</code></pre>

<p>Or a mutable reference if you need to alter the value:</p>

<pre><code>auto&amp; mygraph = ui.myplot-&gt;graph(0);
</code></pre>

<p>References are designed to be used as <em>aliases</em>; the fact that this most often comes up in parameter passing is somewhat misleading. They can just as well be used locally to alias the results of complex expressions, such as deeply nested fields of an object.</p>
",7
18141641,18141449,1,"<p>I assume you're using Qt with Designer and UI files, since the code you're showing uses Qt paradigms.</p>

<p>Put a <code>Graph* mygraph</code> member in your class, and set it to point to your graph(0):</p>

<pre><code>MyClass {
  Q_OBJECT
public:
  Graph* mygraph;
  MyClass();
}
</code></pre>

<p>In the constructor, after the <code>ui-&gt;setupUI(this)</code>:</p>

<pre><code>MyClass::MyClass()
{
  ui-&gt;setupUi(this);
  mygraph = ui.myplot-&gt;graph(0);
} 
</code></pre>

<p>Now you can use it in your class methods.</p>

<pre><code>int MyClass::getValue()
{
  int a = mygraph-&gt;val();
  return a;
}
</code></pre>
",0
16387424,16387368,2,"<p>There are the same possibilities in C++ (Win)</p>

<p>You can either create a <a href=""https://en.wikipedia.org/wiki/Static_library"" rel=""nofollow"">static library</a> which you link to, or a <a href=""http://en.wikipedia.org/wiki/Dynamic-link_library"" rel=""nofollow"">dynamic library</a> (dll) that you load dynamically. Either way you have a header with the class. You could try the easier approach and that is with a static library</p>
",0
14155587,14155364,1,"<p>Your code does not work, because it is the <code>streambuf</code> that determines where the output written to a stream end up, not the stream itself.</p>

<p>C++ does not have any streams or streambufs that support directing the output to multiple destinations, but you could write one yourself.</p>
",2
14155788,14155364,12,"<p>The simplest you can do is create an output stream class that does this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

class my_ostream
{
public:
  my_ostream() : my_fstream(""some_file.txt"") {}; // check if opening file succeeded!!
  // for regular output of variables and stuff
  template&lt;typename T&gt; my_ostream&amp; operator&lt;&lt;(const T&amp; something)
  {
    std::cout &lt;&lt; something;
    my_fstream &lt;&lt; something;
    return *this;
  }
  // for manipulators like std::endl
  typedef std::ostream&amp; (*stream_function)(std::ostream&amp;);
  my_ostream&amp; operator&lt;&lt;(stream_function func)
  {
    func(std::cout);
    func(my_fstream);
    return *this;
  }
private:
  std::ofstream my_fstream;
};
</code></pre>

<p>See this ideone link for this code in action: <a href=""http://ideone.com/T5Cy1M"" rel=""noreferrer"">http://ideone.com/T5Cy1M</a>
I can't currently check if the file output is done correctly though it shouldn't be a problem.</p>
",0
14155794,14155364,3,"<p>You could also use <code>boost::iostreams::tee_device</code>. See <a href=""https://stackoverflow.com/questions/999120/c-hello-world-boost-tee-example-program"">C++ &quot;hello world&quot; Boost tee example program</a> for an example.</p>
",2
14733489,14733431,3,"<p>The difference between a const and non-const method is that in the first the <code>this</code> pointer in const and in the latter it is not. So when you try to return non-const pointer from a const function and return this, compiler complains, because there <code>this</code> is const and const-ness can not be automatically removed.</p>

<p><code>&amp;p2</code> is simply a pointer to an argument and thus it is not const. Please keep in mind, though that <code>&amp;p2</code> is pointer to local variable and it is never safe to return <strong>that</strong>.</p>
",0
14733614,14733431,3,"<p>When you have a ""const"" function, you are pretty much promising that ""We will not change the object instance in this call"". The compiler makes <code>this</code> a <code>const T* this</code> for that type of function (where T is the type of your class, e.g <code>Player</code>). </p>

<p>Obviously, returning a pointer to something that is <code>const</code> as as a non-<code>const</code> pointer is a breach of the rule - because once some code has a non-<code>const</code> pointer to your object, the code can modify the object... Which breaks the promise that ""this function won't modify"". </p>

<p>So adding <code>const</code> to the return type from function is the right solution here. </p>

<p>You probably also want to change your code so that it takes a <code>const *Player p2</code> as input - your current code returns a pointer to a local variable [it happens to be an argument, but it's the same principle - it doesn't exist when the function call has returned]. </p>

<p>Edit: Unless you are actually returning a copy of something (e.g. an integer, string or a new structure allocated with for example new) in a function with <code>const</code> attribute, the return type should be <code>const</code>.</p>
",2
14733472,14733431,7,"<blockquote>
  <p>The part that is confusing me is why does it allow me to return &amp;p2, which is not const and doesn't allow me to return this, which is a pointer to the object that called the function, which isn't a const as well?</p>
</blockquote>

<p><code>this</code> <em>is</em> <code>const</code> (or, more accurately, is a pointer-to-<code>const</code>) in a <code>const</code> member function, just like all the data members:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;type_traits&gt;

struct A
{
    void foo()
    {
        std::cout &lt;&lt; std::is_same&lt;decltype(this), const A*&gt;::value &lt;&lt; '\n';
    }

    void bar() const
    {
        std::cout &lt;&lt; std::is_same&lt;decltype(this), const A*&gt;::value &lt;&lt; '\n';
    }
};

int main()
{
    A a;
    a.foo();
    a.bar();
}
</code></pre>

<p><a href=""https://ideone.com/EtLglV"" rel=""nofollow"">Output</a>:</p>

<pre><code>0
1
</code></pre>

<hr>

<blockquote>
  <p>Also even when I declare the function return type as a const, it still allows me to return &amp;p2, even though the argument passed to the parameter is not a const Player object?</p>
</blockquote>

<p>We can't see what you tried, but presumably it was <code>Player* const</code>, which is not the same as <code>Player const*</code> (or <code>const Player*</code>). You can add <code>const</code>ness to <code>&amp;r2</code> just fine; taking <code>const</code>ness away is a different story.</p>
",2
10164935,10164904,0,"<p>The best advice I can give you is to learn how to use a debugger. Other advice: don't use <code>malloc/free</code> in C++, use <code>new/delete</code>.</p>
",6
10165193,10164904,0,"<p>There is quite a few issues in this code, the use of a debugger will definitely help here.</p>

<p>Your program ""just stops"" because it crashes at</p>

<pre><code>(**pL).value = x;
</code></pre>

<p>I am not sure if this code was provided to you as homework to fix, or if the empty function was provided to you, and you need to fill it out. Either way, that line is wrong.</p>

<p>Also, as others mentioned, you are using <code>malloc</code> in a C++ program when you should be using <code>new</code>.</p>
",2
15867956,15867800,2,"<p>You can use member function pointers like this (the C++11 is unrelated to that part):</p>

<pre><code>struct S {
   int foo(){std::cout&lt;&lt;""foo""; return 0;}
   int bar(){std::cout&lt;&lt;""bar""; return 0;}
};

int main() {
   std::vector&lt;int(S::*)()&gt; funcs{&amp;S::foo, &amp;S::bar};

   S s;
   for (auto func : funcs) {
      (s.*func)();
   }
}
</code></pre>

<p>However, if you use C++11, <code>std::function</code> can make it a bit cleaner:</p>

<pre><code>std::vector&lt;std::function&lt;int(S &amp;)&gt;&gt; funcs{&amp;S::foo, &amp;S::bar};

S s;
for (auto func : funcs) {
   func(s);
}
</code></pre>

<p>If you use C++03, Boost has <code>boost::function</code>, which is similar.</p>
",2
15868047,15867800,2,"<p>I'm curious where you're going to use them from. You see in order to call a C++ class member function you need to have an instance pointer with which to call it (each member function needs a this in order to access the class state). So normally you'd wrap the member function pointer together with the instance pointer with std::bind and then maybe store the result in std::function. To put them in vector they're all going to need the same signature.</p>

<p>Is this the kind of thing you were looking for:</p>

<pre><code>class P
{
    typedef std::function&lt;void (void)&gt; func_t;
    std::vector&lt;func_t&gt; functions;
public:
    P()
    {
        functions.push_back(std::bind(&amp;P::foo1, this));
        functions.push_back(std::bind(&amp;P::foo2, this));
        functions.push_back(std::bind(&amp;P::foo3, this));
    }
    void foo1(void)
    {
        std::cout &lt;&lt; ""foo1\n"";
    }
    void foo2(void)
    {
        std::cout &lt;&lt; ""foo2\n"";
    }
    void foo3(void)
    {
        std::cout &lt;&lt; ""foo3\n"";
    }
    void call()
    {
        for(auto it = functions.begin(); it != functions.end(); ++it)
        {
            (*it)();
        }
    }
};

int main()
{
    P p;
    p.call();
}
</code></pre>

<hr>

<p>After further clarification from the OP I'll propose this:</p>

<pre><code>class P
{
    typedef std::function&lt;void (void)&gt; func_t;
    std::map&lt;const char*, func_t&gt; functions;
public:
    P()
    {
        functions[""foo1""] = std::bind(&amp;P::foo1, this);
        functions[""foo2""] = std::bind(&amp;P::foo2, this);
        functions[""foo3""] = std::bind(&amp;P::foo3, this);
    }
    void foo1(void)
    {
        std::cout &lt;&lt; ""foo1\n"";
    }
    void foo2(void)
    {
        std::cout &lt;&lt; ""foo2\n"";
    }
    void foo3(void)
    {
        std::cout &lt;&lt; ""foo3\n"";
    }
    void call_by_name(const char* func_name)
    {
        functions[func_name]();
    }
};

int main()
{
    P p;
    p.call_by_name(""foo1"");
    p.call_by_name(""foo2"");
    p.call_by_name(""foo3"");
}
</code></pre>
",5
11118938,11118919,27,"<p>There's no other difference, <strong>but</strong> the third one you specify isn't correct:</p>

<blockquote>
  <p>Class can take part in template while structures cannot.</p>
</blockquote>

<p>In case of templates, the <code>class</code> keyword is just syntactic sugar, it doesn't mean the type has to be an actual class. Generally, programmers prefer <code>typename</code> for basic types and <code>class</code> for classes or structs, but that's just by convention.</p>

<p>Other than that, you can use both <code>class</code> and <code>struct</code> to specialize templates.</p>
",2
11118994,11118919,4,"<p>There are two main differences:</p>

<ul>
<li><p>In absence of an access-specifier for a base <code>class</code>, public is assumed when the derived class is declared <code>struct</code> and private is assumed when the class is declared class.</p></li>
<li><p>Member of a class defined with the keyword class are private by default. Members of a class defined with the keywords <code>struct</code> or <code>union</code> are public by default.</p></li>
</ul>
",1
11119252,11118919,1,"<p>A struct is just a class with all members public by default.</p>

<p>According to The C++ Programming Language (3rd ed.), section 10.2.8:</p>

<blockquote>
  <p>By definition, a struct is a class in which members are by default
  public; that is</p>

<pre><code>struct s{ ...
</code></pre>
  
  <p>is simply shorthand for</p>

<pre><code>class s { public: ...
</code></pre>
</blockquote>

<p>Then he goes on to say:</p>

<blockquote>
  <p>I usually prefer to use struct for classes that have all data public.
  I think of such classes as ""not quite proper types, just data
  structures.""</p>
</blockquote>

<p><strong>Edited per the comments</strong>:</p>

<p>In section 15.3.2 it says:</p>

<blockquote>
  <p>The access specifier for a base class can be left out. In that case,
  the base defaults to a private base for a <em>class</em> and a public base
  for a <em>struct</em>.</p>
</blockquote>
",2
13786141,13786107,1,"<p><code>b</code> is not initialised so will have a random value when first used as the index. Initialise <code>b</code> and ensure array indexes do not go beyond the bounds of the array.</p>

<p>Alternatively, use a <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector&lt;std::string&gt;</code></a> and <code>operator&gt;&gt;()</code> and forget about array indexes:</p>

<pre><code>std::string word;
std::vector&lt;std::string&gt; words;
while (cin &gt;&gt; word &amp;&amp; word != ""q"") words.push_back(word);
</code></pre>
",1
11808536,11808432,0,"<blockquote>
  <p>And I can't understand why, #define doesn't need ';' at the end.</p>
</blockquote>

<p>Because #define is not a statement, but a <em>preprocessor directive</em>, and the preprocessor is line-oriented when it comes to separating directives. For example, you cannot put two #defines on the same line.</p>
",0
11808543,11808432,9,"<p>First, the code you have posted begins with a stray backtick.  If that's really in your code, you should remove it.</p>

<p>Second, the compiler would be happier, and emit fewer warnings, if you ended your function with the line</p>

<pre><code>return 0; // unreachable
</code></pre>

<p>This is good C++ style and is recommended.  (In your case, the line may actually be <em>reachable,</em> in which case the line is not only good style but necessary for correct operation.  Check this.)</p>

<p>Otherwise, your code looks all right except for some small objections one could raise regarding the outdated, C-style use of <code>#define</code> and regarding one or two other minor points of style.  Regarding the <code>#define</code>, it is not C++ source code as such but is a <em>preprocessor directive.</em>  It is actually handled by a different program than the compiler, and is removed and replaced by proper C++ code before the compiler sees it.  The preprocessor is not interested in semicolons.  This is why the <code>#define</code> line does not end in a semicolon.  Neither do other lines that begin <code>#</code> usually end in semicolons.</p>

<p>As @JoachimIsaksson has noted, a needed semicolon may be missing from the end of the file <code>general_configuration.h</code> or the file <code>helper_function.h</code>.  You should check the last line in each file.</p>
",1
15845720,15845443,1,"<p>You currently have one <code>operator[]</code> signature:</p>

<pre><code>Proxy operator[](Matrix *this, int i)
</code></pre>

<p>You're trying to call this:</p>

<pre><code>Proxy operator[](const Matrix *, int)
</code></pre>

<p>The error is saying that in order to convert from <code>const Matrix *</code> to <code>Matrix *</code>, the <code>const</code> has to be discarded, which is bad. You should provide a <code>const</code> version inside your class:</p>

<pre><code>Proxy operator[](int) const {...}
</code></pre>

<p>When inside your class, it gains a first parameter of <code>this</code>, and the <code>const</code> after the parameter list means that the first parameter will be a pointer to a constant object of your class, not a non-constant one.</p>
",5
12349059,12349001,1,"<p>Have you tried</p>

<pre><code>uint8 Addr[] = {0x0,0x16,0x7a,0xcd,0x10,0x4};
uint8 *pAddr = Addr;
</code></pre>

<p>?</p>

<p><em>Note:</em> Do not use <code>0</code> prefix! It means the number is in octal, so <code>010</code> means <code>8</code> in dec.</p>
",0
11108854,11108815,0,"<p>When glob is inside the loop, its scope is each iteration of the loop. So, it will be deleted (popped of the stack) when it goes out of scope, and recreated in the next iteration (pushed onto the stack).</p>

<p>When glob is outside the loop, its scope is the method and it isn't deleted until the method is finished.</p>
",0
11108901,11108815,2,"<p>To clarify, you are asking about the difference between this:</p>

<pre><code>ostringstream glob;
for ( int i = 0; i &lt; 100; ++i )
{
    glob &lt;&lt; ""some words"";
    cout&lt;&lt; ""this is bob""&lt;&lt;glob.str()&lt;&lt;endl;
}
</code></pre>

<p>and this:</p>

<pre><code>for ( int i = 0; i &lt; 100; ++i )
{
    ostringstream glob;
    glob &lt;&lt; ""some words"";
    cout&lt;&lt; ""this is bob""&lt;&lt;glob.str()&lt;&lt;endl;
}
</code></pre>

<p>In the first, 'glob' is initialised once, before the loop, as its scope is outside the loop body. In the second 'glob' is within the loop body (within the braces that define the loop scope) and hence is newly placed on the stack and initialised with each iteration (and destroyed at the end of each iteration).</p>
",0
11108834,11108815,3,"<p>if you declare variable inside the scope, then it is created (constructed) every time that you enter the loop (it is on the stack). If you declare it ouside the loop than it is single instance that you are keep reusing.</p>

<p>See also:</p>

<ul>
<li><a href=""http://msdn.microsoft.com/en-us/library/b7kfh662%28v=vs.80%29.aspx"" rel=""nofollow"">C++ scope</a></li>
<li><a href=""http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/cplr374.htm"" rel=""nofollow"">Overview of constructors and destructors</a></li>
</ul>
",0
10744417,10744297,5,"<p>Not quite.</p>

<p>A class is ""like a data type"" in the sense that it's a template for the creation of an object, but it isn't itself an object that you can use.</p>

<p>When you use that template to create an instance of an object, then you can make use of that object.  You may create as many instances as you want - you can think of those instances as variables.</p>

<p>For example:</p>

<pre><code>class Person
{
    public:
        Person() : name(""Joe Bloggs"") {}

        std::string getName() { return name; } 

        void setName(std::string n) { name = n; }

    private:
        std::string name;    
};
</code></pre>

<p>This is a class definition for a Person.  It is not a variable.  You cannot call setName on it because it doens't exist yet.  But when you do:</p>

<pre><code>int main()
{
    Person p, q;
    p.setName(""Jill Bloggs"");
    q.setName(""Bob King"");
    std::cout &lt;&lt; p.getName() &lt;&lt; "" "" &lt;&lt; q.getName() &lt;&lt; std::endl;
}
</code></pre>

<p>You created two instances of people that you can assign to, change, and use - they are variables called instances.</p>

<p>I have no idea what ""data form"" means, ignore that.</p>

<p>As for declaration - the declaration states that an instance of something will be present.  For example, if you were creating a class, and your header file had:</p>

<pre><code>class foo
{
    public:

        foo(int value);

        void bar();

    private:
        int x;
};
</code></pre>

<p>You are declaring that you have a function called bar that returns void and that you have an integer called x.</p>

<p>No memory is allocated for the variable, x, and no definition is provided or bar, so they're just declarations.  Your source file would probably provide  definition for bar like:</p>

<pre><code>void foo::bar()
{
    //some code
}
</code></pre>

<p>and a constructor definiton for foo that would initialize x with a value and control how it was created (with an initializer list):</p>

<pre><code>foo::foo(int value) : x(value)
{
    //some code
}
</code></pre>
",6
11843501,11843469,1,"<p>An expression statement (like <code>b=100;</code>) must be inside a function.</p>

<p>Outside a function, you can declare and initialise variables, but you can't directly execute arbitrary code.</p>

<p>You get that particular error because the compiler interprets the code as a declaration with no type specifier (i.e. <code>int b=100;</code> with the <code>int</code> missing), rather than as an expression statement where it's not expecting such a thing. Such a declaration is allowed in C (although in this case, it would fail because there's already a variable called <code>b</code>), but not in C++.</p>
",0
11843502,11843469,1,"<p>You cannot assign to a variable in global scope, except when initialising it.</p>
",0
11843510,11843469,2,"<p>The global scope can only contain declarations and definitions, not arbitrary statements.</p>

<p>C++ thinks you're trying to declare and define another variable called <code>b</code>.</p>
",0
11843542,11843469,0,"<p>You would have to do </p>

<pre><code>b = 100; 
</code></pre>

<p>inside main. You can't change an already declared variable outside a function. </p>
",0
11843739,11843469,0,"<p>Any statement should occurred inside a function. Global variable can be defined and initialize   outside functions body. but assignment should be within some function body.</p>
",0
14731027,14730957,6,"<p>Having two reference variables equal to each other is in itself not an error. It may be confusing. However, what your code does is not setting a reference to another reference, it's altering the value of <code>_A</code> from <code>1</code> to <code>2</code>, which is what's in <code>_B</code>.</p>

<p>You can ONLY set a reference ONCE [where it is initialized]. Once it's been initialized, it will simply become an alias for the original variable. </p>

<p>You could do this:</p>

<pre><code>int &amp;a = _A;
int &amp;b = _A;
</code></pre>

<p>and</p>

<pre><code>a = b;  
</code></pre>

<p>would store the value <code>1</code> into <code>_A</code>, which already has the value <code>1</code>. </p>
",1
14731029,14730957,2,"<p>There is no error here, but I think I may know what you're confused about.  The reference won't be reassigned, however the value of what it is referencing is reassigned.</p>

<p>So when you do <code>a = b;</code> you're essentially saying this: <code>_A = _B</code>, because a reference is an alias.</p>

<p>A reference can never be reassigned like a pointer can.</p>

<p>A reference can also never be null.</p>
",0
14731052,14730957,2,"<p>You can not have statements outside a function.</p>

<pre><code>a = b;   //compile error?
</code></pre>

<p>That is a statement so must be in a function:</p>

<pre><code>int _A = 1;
int _B = 2;

int &amp;a = _A;
int &amp;b = _B;

int main()
{
   a = b;   //compile error? No. Now it compiles.

   // As 'a' and 'b' are references.
   // This means they are just another name for an already existing variable
   // ie they are alias
   //
   // It means that it is equivalent to using the original values.
   //
   // Thus it is equivalent too:
   _A = _B;
}
</code></pre>

<p>Now it compiles.</p>
",5
18211951,18211902,4,"<p>You need to pass <code>const</code> references to the comparison function because it should not be allowed to modify the items being compared:</p>

<pre><code>friend bool operator&lt; (const Myclass&amp; first, const Myclass&amp; second)
{ //                   ^^^^^                 ^^^^^
  return first.getval() &lt; second.getval();
}
</code></pre>

<p>This will require that you make <code>getVal()</code> <code>const</code> as well. This makes it callable on <code>const</code> instances or via <code>const</code> references:</p>

<pre><code>int getval() const {return storedval;}
//           ^^^^^
</code></pre>

<p>Note that you do not need <code>operator&gt;</code> for the set to work. Less-than is enough.</p>

<p>Strictly speaking, you do not need a <code>friend</code> function here, since you are calling <code>public</code> member functions. The only thing that <code>friend</code> brings here is to allow you to declare a non-member function inside of the class definition.</p>
",2
18212055,18211902,3,"<p>Elements of a set are immutable, so the set needs to be able to compare <code>const</code> values. So the comparison needs to be:</p>

<pre><code>friend bool operator&lt; (Myclass const &amp;first, Myclass const &amp;second)
//                             ^^^^^                 ^^^^^
</code></pre>

<p>(You should probably also do this with <code>operator&gt;</code> and any other non-mutating operations you provide; but <code>set</code> only needs <code>operator&lt;</code>).</p>

<p>Also, in order to access the value of a <code>const</code> object, the accessor also needs to be <code>const</code>:</p>

<pre><code>int getval() const
//           ^^^^^
</code></pre>
",0
18164362,18164340,2,"<p><code>FirstClass</code> doesn't have a default constructor, so you need to use <code>Secondclass</code>' constructor initialization list:</p>

<pre><code>Secondclass() : a(10) {}
</code></pre>

<p>C++11 allows you to initialize non-static data members at the point of declaration, so you can also do this:</p>

<pre><code>class Firstclass
{
  ....
private:
 Firstclass a{10};
};
</code></pre>

<p>What you are doing here:</p>

<pre><code>Secondclass()
{
  Firstclass a(10);
}
</code></pre>

<p>is wrong on two counts: 1) as I mentioned above, <code>FirstClass</code> has no default constructor, and by not initializing <code>a</code> in the initialization list, you are invoking its default constructor. 2) You are declaring a local variable <code>a</code> of type <code>Firstclass</code>, which only exists in the scope of the constructor body. This is <strong>not the same</strong> as your data member <code>a</code>.</p>
",0
18164366,18164340,8,"<p>Initialize it through the <em>member-initializer list</em>:</p>

<pre><code>Secondclass() : a(10) { }
</code></pre>

<p>This is required because <code>Firstclass</code> doesn't have a default constructor. Also, in-class initialization with parameters gets ambiguated with a function declaration, so you can do it in the class body. In C++11, this is resolved with <em>aggregate-initialization</em>:</p>

<pre><code>Firstclass a{10};
</code></pre>
",2
18164373,18164340,3,"<p>A way to do that correctly would be to use the constructor initialization list :</p>

<pre><code>Secondclass) : a(10)
{
    // ...
}
</code></pre>

<blockquote>
  <p>The initialization list also lets you specify which constructor gets called for the objects that are fields of the class.</p>
</blockquote>

<p>So instead of trying to initialize the <code>Secondclass</code>'s member <code>a</code> with a default constructor who does not exist, by using the constructor initialization list you specify the constructor to be called.</p>

<hr>

<p>There is a new way to do this since C++11. It is called <a href=""http://en.cppreference.com/w/cpp/language/aggregate_initialization"" rel=""nofollow"">aggregate-initialization</a>. The syntax is : </p>

<pre><code>T object {arg1, arg2, ...};
</code></pre>

<p>As in this case <code>a</code> is a non-static member of a class, so it will be <a href=""http://en.cppreference.com/w/cpp/language/copy_initialization"" rel=""nofollow"">copy-initialized</a>.</p>

<p>Here is what the <em>copy-initialization</em> does in this particular case :</p>

<blockquote>
  <p>The constructors of <code>Firstclass</code> are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.</p>
</blockquote>

<p>So if you want to use C++11, your class should look like :</p>

<pre><code>class Secondclass
{
public:
    Secondclass()
    {
    }

    void func()
    {
        //Do things with a
    }

private:
    Firstclass a{10};
};
</code></pre>

<hr>

<p>Just to point out another mistake :</p>

<pre><code>Secondclass()
{
    Firstclass a(10);
}
</code></pre>

<p>You are not doing what you think here. Here you are declaring a variable <code>a</code> of type <code>Firstclass</code> who will only live in the constructor scope, it will be destructed at the end of the scope. It is not the same as the <code>a</code> member.</p>
",0
10025497,10025469,5,"<pre><code>while(list-&gt;info!=search &amp;&amp; list!=NULL)
</code></pre>

<p>should be:</p>

<pre><code>while(list!=NULL &amp;&amp; list-&gt;info!=search) 
</code></pre>

<p>This is called as <strong><a href=""http://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""nofollow"">Short-circuit evaluation</a>.</strong><br>
When you use <code>&amp;&amp;</code> the first expression is guaranteed to be executed before the second <strong>for inbuilt primitive types</strong><sup>[#1]</sup>.     </p>

<p>In your case the dereferencing happens before the <code>NULL</code>check, So when <code>list == NULL</code>, You will end up derefrencing the <code>NULL</code>and causing an <strong>Undefined Behavior</strong> and a crash.    </p>

<p>In the sugeested solution:<br>
if <code>list == NULL</code> then the second condition will not be evaluated. </p>

<hr>

<p>Reference:<br>
<sup>[#1]</sup><strong>C++03 Standard 1.9.18:</strong></p>

<blockquote>
  <p>In the evaluation of the following expressions</p>

<pre><code>a &amp;&amp; b
a || b
a ? b : c
a , b
</code></pre>
  
  <p>using the built-in meaning of the operators in these expressions, there is a sequence point after the evaluation of the first expression (12).</p>
</blockquote>
",0
10025507,10025469,2,"<p>you are not checking for the validity of <code>list</code> here:</p>

<pre><code>while(list-&gt;info!=search &amp;&amp; list!=NULL)
</code></pre>

<p>try checking <code>list!=NULL</code> before <code>list-&gt;info</code>.</p>

<p>Also, don use the name <code>list</code>, it is the name of a standard library container.</p>
",0
10025524,10025469,1,"<p><code>&amp;&amp;</code> conditions are evaluated in the order they are specified, so in you case when <code>list</code> becomes <code>NULL</code> in the loop during the next iteration  you are first trying to do <code>list-&gt;info != search</code> which results in access violation. You need to reverse the condition to <code>list != NULL &amp;&amp; list-&gt;info != search</code>.</p>
",0
11177427,11177418,8,"<p>Yes, you can overload <em>type-conversion operators</em>:</p>

<pre><code>class Rofl {
public:
    operator float() const { return b; }

    ...
};
</code></pre>

<p>See <a href=""http://ideone.com/Y7UwV"">http://ideone.com/Y7UwV</a> for a demo.</p>

<p>However, see Item 5 of Scott Meyers' <a href=""http://www.amazon.co.uk/More-Effective-Programs-Professional-Computing/dp/020163371X/""><em>More Effective C++</em></a>, entitled ""<em>Be wary of user-defined conversion operations</em>"".  Allowing implicit conversions to-and-from complex types can often lead to all sorts of subtle typo bugs.</p>
",0
11177436,11177418,1,"<p>You can also go the other way around:</p>

<pre><code>class rofl {
public:
    float operator=(float f) { b = f; return f; }

    ...
};

rofl sup(5, 2.0f);
sup = 4.0f;
</code></pre>

<p><a href=""http://ideone.com/049ee"" rel=""nofollow noreferrer"">demo</a>, based on <a href=""https://stackoverflow.com/a/11177427/102441"">@Oli's answer</a></p>
",0
11178322,11177418,1,"<p>No, in the case that you stated this is not possible.  In your code, <code>sup</code> is not a <code>rofl</code> but a <code>rofl*</code>, and creating a <code>rofl*</code> to <code>float</code> conversion is not allowed.  Moreover, your question is ill-formed: <code>sup.b</code> does not refer to anything.</p>

<p>That said, you probably don't need to dynamically allocate the instance, in which case the other answers are correct.</p>
",0
16921034,16920979,3,"<p>Your team array has no storage associated with it. in C++ arrays are not dynamic, try using a vector instead, and resize it when you read teamCount</p>
",3
16921131,16920979,1,"<p>Try this:</p>

<pre><code>average = total / teamCount; //Lets calculate the average correctly. Note: Integer division

//output the list of the scores
 for(int i=0; i&lt;teamCount; i++){
     cout&lt;&lt;""Team ""&lt;&lt;i+1&lt;&lt;"" score is:""&lt;&lt;team[i]&lt;&lt;endl; //We want each value, not only team[0]
 }
</code></pre>
",0
16921145,16920979,6,"<p>Your array</p>

<pre><code>int team[0];
</code></pre>

<p>will not work in C++. Btw you can't allocate 0-sized array this way<br>
Try c++ containers instead</p>

<pre><code>std::vector&lt;int&gt; team;
</code></pre>
",6
16921154,16920979,2,"<p>In the line</p>

<pre><code>int team[0];
</code></pre>

<p>you are creating an array with 0 entries. Arrays in C++ can not increase or shrink. To solve this issue, either allocate the array dynamically after you know how large it needs to be:</p>

<pre><code>int * team = new int[teamCount];
</code></pre>

<p>(don't forget to call <code>delete[] team;</code> when you don't need it anymore, or the memory is never reclaimed)</p>

<p>Or better use the object-oriented way and use the class <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow"">std::vector</a> which is the C++ equivalent for the Java class ArrayList.</p>

<p>Your next mistake is here:</p>

<pre><code>//output the list of the scores
 for(int i=0; i&lt;teamCount; i++){
     cout&lt;&lt;""Team ""&lt;&lt;i+1&lt;&lt;"" score is:""&lt;&lt;team[0]&lt;&lt;endl;
 }
</code></pre>

<p>You are outputting the value of the first team again and again during each loop iteration.</p>

<p>By the way: Both mistakes would be just as wrong in Java :)</p>
",13
10159121,10159108,3,"<p>You are declaring a second variable called filename here, after the <code>else</code>:</p>

<pre><code>string filename = argv[1];
</code></pre>

<p>This goes out of scope by the time you get here:</p>

<pre><code> cout &lt;&lt; ""Filename: "" &lt;&lt; filename &lt;&lt; endl;
</code></pre>

<p>You are now printing the contents of the 1st variable you declared called <code>filename</code>, just under <code>main</code>.</p>
",2
10162215,10162187,2,"<p>There is no code that can change either <code>menu</code> or <code>choice</code> inside your <code>while</code> loop. So once it gets going, it will never stop.</p>
",2
10162217,10162187,0,"<p>It says <code>while (menu)</code> and that means it'll keep doing that until you set menu to <code>false</code>.</p>

<p>Also, I think you want to add the <code>cin &gt;&gt; choice</code> in the loop, or it'll just repeat the selection again and again.</p>
",0
10162218,10162187,0,"<p>I would suppose the while loop should include printing the menu options and having the user select an option like so:</p>

<pre><code>while (menu)
{
    cout &lt;&lt;""========Welcome to the database menu========\n"";
    cout &lt;&lt; ""Press 1 to insert a new record at a particular position\n""
            ""Press 2 to delete a record from a particular position\n""
            ""Press 3 to search the database  and print results\n""
            ""Press 5 to find the average experience points of players at a particular level\n""
            ""Press 6 to find and remove all duplicate entries\n""
            ""Press 0 to quit\n\n\n\n\n\n\n\n\n"";

    cout&lt;&lt; ""Choice: "";
    cin&gt;&gt; choice;

    switch (choice)
    {
        case 1:
            cout &lt;&lt; ""dixie"";
            break;
        case 2:
            cout &lt;&lt; ""bexie"";
            break;
        default:
            cout&lt;&lt; ""That is not a choice!!!\n"";
    }
}
</code></pre>

<p>Another possibility would be to start the while loop just before the <code>cout &lt;&lt; ""Choice: ""</code> line.</p>
",0
10162402,10162187,0,"<p><code>menu</code> variable is always <code>true</code> inside the loop. It's the same as <code>while(true)</code> at the moment.</p>
",0
16385365,16385303,4,"<p>This depends on what you're trying to do. If you're trying to do something if the value is 0.3, you <em>could</em> try <code>if (x &gt; 0.29 &amp;&amp; x &lt; 0.31)</code>, although this won't be completely accurate. But other than this the first comment is right, there is no way to get the value accurately.</p>

<p>I would comment before posting to check what is being done, but I lack the reputation to do so. If this turns out to be inaccurate, I will happily delete this answer, so please don't be too quick to downvote.</p>

<p>EDIT: you could also try storing the number as ten times larger and comparing for 3, but I wouldn't recommend this. Please provide details of why this needs to be done. </p>
",6
15804924,15804090,0,"<p>As an alternative, disable inclusion of precompiled header.</p>

<p>In Project properties -> C/C++ -> Precompiled Headers.      </p>

<p>Set ""Create/Use Precompiled Header"" to ""Not Using Precompiled Headers"".</p>
",0
15804361,15804090,3,"<p>In VC, everything before <code>#include ""stdafx.h""</code> is ignored. Include <code>Timer.h</code> and <code>stdlib.h</code> after <code>stdafx.h</code>.</p>
",0
15804391,15804090,2,"<p>The <code>#include ""stdafx.h""</code> should always be the first include in the .cpp file. Includes before it will be skipped by the compiler, because it assumes those are part of the precompiled header.</p>
",2
11842344,11842327,2,"<p>The problem is here: <code>cout&lt;&lt;b&lt;&lt;endl;</code> </p>

<p>You can't access the variable before it's declaration.</p>
",0
11842386,11842327,2,"<p>Read carefully. </p>

<p>A variable defined outside any function (B) is initialized before main is invoked (not compiled).</p>

<p>To be compiled correctly B should be defined(and declared) before it's first use (and that's your error: B is used before been declared anywhere).</p>
",0
11842452,11842327,5,"<p>The problem here is not initialisation order: <code>b</code> is indeed initialised before <code>main</code> starts running.</p>

<p>The problem is the ""visibility"" of <code>b</code>. At the point where <code>main</code> is being compiled, there <em>is</em> no <code>b</code>.</p>

<p>You can fix it by either moving the definition/initialisation of <code>b</code> to before <code>main</code>:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;
int a = 99;
int b = 100;
int main (int argc, char *argv[]) {
    cout &lt;&lt; a &lt;&lt; '\n';
    cout &lt;&lt; b &lt;&lt; '\n';
    return 0;
}
</code></pre>

<p>or simply indicate that <code>b</code> exists:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;
int a = 99;
extern int b;
int main (int argc, char *argv[]) {
    cout &lt;&lt; a &lt;&lt; '\n';
    cout &lt;&lt; b &lt;&lt; '\n';
    return 0;
}
int b = 100;
</code></pre>

<p>Neither of those two solutions change when <code>b</code> is created or initialised at run-time, they simply make <code>b</code> available within <code>main</code>.</p>
",0
11842456,11842327,3,"<p>Your lecturer is wrong; global variables are initialised in order of <em>definition</em>, not <em>declaration</em>.</p>

<p>For example,</p>

<pre><code>#include &lt;iostream&gt;
struct S { S(const char *s) { std::cout &lt;&lt; s &lt;&lt; '\n'; } };
extern S a;    // declaration
extern S b;    // declaration
int main() { }
S b(""b"");      // definition
S a(""a"");      // definition
</code></pre>

<p>will print</p>

<pre><code>b
a
</code></pre>

<p>The code you posted doesn't work because <code>b</code> is not even <em>declared</em> at the point of use.  A declaration (for example, <code>extern int b</code>), is required because C++ (like C) was originally designed as a <a href=""http://en.wikipedia.org/wiki/One-pass_compiler"" rel=""nofollow"">one-pass compiler</a>.</p>
",0
12309366,12309351,1,"<p>Can you show the line you used to compile? It sounds like you tried to compile <code>longgcd.cpp</code> independently as an executable, and since that file doesn't have <code>main</code>, the linker correctly complained that it couldn't find <code>main</code>.</p>

<p>The simplest solution is to compile both files together</p>

<pre><code>g++ $FLAGS longgcd.cpp main.cpp
</code></pre>
",3
12309374,12309351,1,"<p>You should be compiling the source file that contains the <code>main()</code> function.</p>

<p>Note that <code>#include</code>ing cpp's is generally discouraged. You can put the declaration for <code>gcd</code> in a header file and include this file from both the implementation cpp containing the code for it and the main file that calls it. In this case you will need to specify <em>both</em> cpp files to the compiler command line because they're both needed to assemble the final program. Even with this complication this way is much better than including cpps.</p>
",0
12309379,12309351,0,"<p>Do not include <code>longgcd.cpp</code>.  You should almost never include a <code>.cpp</code> (unless you really, really, know what is going down)</p>

<p>You should specify all the <code>cpp</code>s to the compiler.  E.g: <code>g++ main.cpp longgcd.cpp</code></p>

<p>Also move the <code>long gcd(long m, long n);</code> line above your main function.</p>
",0
12309386,12309351,1,"<p>One issue is that <code>main</code> should be in your .cpp file, and not your header.</p>

<p>Another is that you normally <code>#include</code> a header (.h or .hpp) into a .cpp file and not the other way around.</p>

<p>Also please get a decent C++ book to read.</p>
",0
14747567,14747439,4,"<p>I don't see any asymmetry here. In fact quite the opposite, it appears to be perfectly symmetrical. Just think of <code>find_first_of</code> as search to the <em>right</em> from some starting position, while <code>find_last_of</code> is a search to the <em>left</em> from some starting position.</p>

<p>The name <code>find_last_of</code> has a misleading quality about it: it implies a natural <em>forward</em> search, except that we return the last occurrence instead of the first one. However, with bidirectional sequences one can ignore the ""forward"" nature of the name and think of it as of as <em>backward</em> search. Backward search also returns the first occurrence, it just proceeds <em>to the left</em> from the starting point. From this point of view, the function is symmetrical with <code>find_first_of</code>.</p>

<p><strong>EDIT:</strong> After reading your comments I finally understand your point. So, the problem is that the current semantics of <code>pos</code> parameter makes it impossible to specify <em>empty</em> search region for <code>find_last_of</code>. Yes, that makes sense. I agree, that is indeed something that can be seen as inconsistency in <code>find_last_of</code> design. </p>

<p>For consistency purposes, I would actually expect <code>find_last_of</code> to be non-inclusive with respect to <code>pos</code> value. In that case the specification of the target position of <code>xpos</code> returned by <code>find_last_of</code> would be</p>

<blockquote>
  <p>xpos &lt; pos and xpos &lt; size();</p>
</blockquote>

<p>In that case <code>s.find_last_of(c, 0)</code> would search an empty prefix, while <code>s.find_last_of(c, s.size())</code> would search the entire string.</p>

<p>However the standard says </p>

<blockquote>
  <p>xpos &lt;= pos and xpos &lt; size();</p>
</blockquote>

<p>I don't really know why they decided to give the <code>pos</code> parameter such inclusive meaning. Probably they thought that it would make it easier to understand.</p>
",3
11806009,11801522,2,"<p>You mentioned your current code is too slow when the input string length is large.  It would be helpful if you could provide a specific example along with your timing info so we know what you consider to be ""too slow"".  You should also specify what you would consider to be an acceptable run time.  Here's an example:</p>

<p>I'll start with an initial version that I believe is similar to your current algorithm.  It generates all subsequences of length >= 2:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

void subsequences(const std::string&amp; prefix, const std::string&amp; suffix)
{
    if (prefix.length() &gt;= 2)
        std::cout &lt;&lt; prefix &lt;&lt; std::endl;

    for (size_t i=0; i &lt; suffix.length(); ++i)
        subsequences(prefix + suffix[i], suffix.substr(i + 1));
}

int main(int argc, char* argv[])
{
    subsequences("""", ""ABCD"");
}
</code></pre>

<p>Running this program produces the following output:</p>

<pre><code>AB
ABC
ABCD
ABD
AC
ACD
AD
BC
BCD
BD
CD
</code></pre>

<p>Now let's change the input string to something longer.  I'll use a 26-character input string:</p>

<pre><code>""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
</code></pre>

<p>This generates 67,108,837 subsequences.  I won't list them here :-).  On my machine, the code shown above takes just over 78 seconds to run (excluding output to cout) with the 26-character input string.</p>

<p>When I look for ways to optimize the above code, one thing that jumps out is that it's creating two new string objects for each recursive call to subsequences().  What if we could preallocate space once upfront and then simply pass pointers?  Version 2:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;string.h&gt;

void subsequences(char* prefix, int prefixLength, const char* suffix)
{
    if (prefixLength &gt;= 2)
        printf(""%s\n"", prefix);

    for (size_t i=0; i &lt; strlen(suffix); ++i) {
        prefix[prefixLength] = suffix[i];
        prefix[prefixLength + 1] = '\0';
        subsequences(prefix, prefixLength + 1, suffix + i + 1);
    }
}

int main(int argc, char* argv[])
{
    const char *inputString = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    char *prefix = (char*) _malloca(strlen(inputString) + 1);

    subsequences(prefix, 0, inputString);
}
</code></pre>

<p>This generates the same 67,108,837 subsequences, but execution time is now just over 2 seconds (again, excluding output via printf).</p>
",0
11569665,11568738,1,"<p>This is not a very good idea.  It sounds like a messy way to pass error codes around.  If you don't want to use exceptions, then use error codes.  At least with error codes people will understand what you are doing.</p>

<p>On another note, whenever I see people avoiding exceptions, I think to myself they really don't understand their use.  They're always talking about try/catch.  In reality, properly coded exception use has very few try/catches.  In most of the use cases I've come across, exceptions are just a way to pass an error message back up the stack so it can exit. There's only one try/catch block and it's in main.</p>

<p>Of course, I've coded long lived servers which don't exit.  They log the message passed by the exception, return the same message to the client, and continue in their wait loop.</p>

<p>Bottom line, there should be very few try/catch blocks in your system.  Once you understand that, then the logic flow for exception becomes easy to understand.  In fact, it's designed into the system.</p>
",0
11518138,11517921,2,"<p>Assuming that <code>BYTE</code> is a typedef for <code>char</code> (with or without <code>signed</code> or <code>unsigned</code>), then your code is fine, but slightly more verbose than necessary. The storage used by a <code>vector</code> is required to be a contiguous array, so taking the address of the first element gives you a pointer to that array. Any kind of <code>char</code> has the same layout and alignment as any other kind of <code>char</code>, so the pointer conversion is valid.</p>

<p>The argument to <code>send</code> is <code>const void*</code>, and (more or less) any pointer can be converted to that implicitly, so there's no need to cast:</p>

<pre><code>ret = send(_socket, &amp;buffer[0], buffer.size(), 0);
</code></pre>

<p>However, you should check (or otherwise ensure) that <code>buffer</code> isn't empty before using <code>[]</code>. </p>
",0
11164259,11164221,3,"<p>NO, your function does not behave the same as <code>memset</code>.  Your function sets a pointer to NULL and <code>memset</code> sets the values of the data to <em>the value supplied.</em></p>

<p>Different things altogether.</p>
",3
11878266,11878231,1,"<p>You have described an array of int, not a class that implements a <code>InputIterator</code>, which is what the for_each is designed for, even though you can use it to iterate an array, but you need to know the size of the array to iterate it.</p>

<p>If you want to use for_each you need to use a <code>vector</code>, <code>list</code>, or implement a class that keeps track of the number of elements it contains. IMO it is much easier to just use a <code>vector</code></p>

<p>If you want to just iterate your current array, assuming it is 0 terminated:</p>

<pre><code>for(int *value = myArray; *value != 0; ++value)
  printf(""%d\n"", *value);
</code></pre>

<p>Or, you can use indexes:</p>

<pre><code>for(int index = 0; myArray[index] != 0; ++index)
  printf(""%d\n"", myArray[index]);
</code></pre>

<p>IMO the pointer method is cleaner.</p>

<p>This code is still dangerous though, you should either keep track of the number of records in a seperate variable, or use a vector.</p>
",5
11878277,11878231,4,"<p><strong>Note</strong> when the question was first posted, the array in question was declared as</p>

<pre><code>int myArray[45];
</code></pre>

<p>This answer deals with that particular case.</p>

<p>If you have C++11 support, you can use a range based loop:</p>

<pre><code>for (int&amp; i : myArray) {
  std::cout &lt;&lt; i &lt;&lt; ""\n"";
}
</code></pre>

<p>C++11 also provides <a href=""http://en.cppreference.com/w/cpp/iterator/begin"" rel=""nofollow"">std::begin</a> and <a href=""http://en.cppreference.com/w/cpp/iterator/end"" rel=""nofollow"">std::end</a>, which you can use with a fixed size array to obtain iterators:</p>

<pre><code>std::for_each(std::begin(myArray), std::end(myArray), &lt;func&gt;);
</code></pre>

<p>Another option, which works for C++03 and you are dealing with fixed size arrays, is to define a function template:</p>

<pre><code>// taken a fixed size array by reference and loop over it
template &lt;typename T, unsigned int N&gt;
void array_for_each( T (&amp;a)[N]) {

  for (unsigned int i = 0; i &lt; N; ++i) {
    // do something with array elements
    std::cout &lt;&lt; a[i] &lt;&lt; "" "";
  }

}

int main() {
  int a[5];
  array_for_each(a);
}
</code></pre>
",6
11878357,11878231,1,"<p>You could use a <code>for_each</code>. In this case, you have allocated space for 45 elements in your array, but since it is NULL, you'd probably get a segfault if you tried to do anything. You either need to hold a value of the array, or use something like <code>sizeof(myArray)/sizeof(myArray[0])</code> (which has its own problems). </p>

<p>Anyway, for a <code>for_each</code> here, if we actually had 45 elements:</p>

<pre><code> std::for_each(myArray, myArray + 45, &lt;func&gt;);
</code></pre>

<p>Anyway, this is part of the reason to use vectors: <code>.begin()</code> and <code>.end()</code> reduces errors with using incorrect indexing.</p>
",0
11878623,11878231,2,"<p>If you use MSVC, you can use ""for each.""</p>

<pre><code>for each(int i in arr) {
    cout &lt;&lt; i &lt;&lt; ' ';
}
</code></pre>

<p>NOTE: This only works in the block of code the array is declared in.</p>

<p>If not, you can also use the new range-based for loop in the C++11 standard.</p>

<pre><code>for(int i : arr) {
    cout &lt;&lt; i &lt;&lt; ' ';
}
</code></pre>

<p>If you're intent upon the std::for_each:</p>

<pre><code>for_each(arr,arr + 10,[] (int i) {
        cout &lt;&lt; i &lt;&lt; ' ';
});
</code></pre>

<p>NOTE: This requires knowledge of the size of the array (in this example, 10).</p>
",3
13788743,13788722,1,"<p>You can't. If it's in <code>macro.h</code>, and that file is public, there's no going around it.</p>

<p>A common technique is defining the macro conditionally:</p>

<pre><code>#ifdef SOME_CONDITION
#define MY_MACRO
#endif
</code></pre>

<p>but a ""bad"" user can just as well define <code>SOME_CONDITION</code>.</p>

<p>What you should do is separate public headers from private ones. As you stated the problem, the macro you want hidden probably shouldn't be in a public header at all.</p>
",0
13788744,13788722,0,"<p>You cannot control the area of effect of the macro, especially if you have it in a .h which is included everywhere. </p>

<p>If you want it to exist only in a few .h and .cpp files then one option is to (re)define it at the top of those cpp files. You could also seperate just these macros into its own <code>.h</code> and include  it only in the cpp files that need it and not expose it to users of your code.</p>

<p>You might want to give a more specific example if you want more specific answers</p>
",0
17850407,17850374,4,"<p><code>*(p++)</code> gives <code>'h'</code> because you first ask the value and than increment the position of your pointer and it the same thing in the last line.</p>
",5
17850430,17850374,3,"<p>Doing <code>p++</code> actually requests the value, and then increment it. If you'd like to increment it then get the value incremented, use <code>++p</code>.</p>

<p>For your last question, the last value of a C string is always <code>'\0'</code>. That print nothing on the terminal in most case, but this is undefined behavior by the C++ Standard.</p>
",1
17850447,17850374,4,"<ol>
<li><p>If you use <code>p++</code> anywhere in your code, say:</p>

<pre><code>&lt;some code&gt; p++ &lt;some code&gt;
</code></pre>

<p>It's equivalent to</p>

<pre><code>&lt;some code&gt; p &lt;some code&gt;;
p = p + 1;
</code></pre>

<p>In contrast, if you write:</p>

<pre><code>&lt;some code&gt; ++p &lt;some code&gt;
</code></pre>

<p>It's equivalent to</p>

<pre><code>p = p + 1;
&lt;some code&gt; p &lt;some code&gt;
</code></pre>

<p>That should answer your first question.</p></li>
<li><p>The C-style strings automatically end with a \0 character. So if you declare:</p>

<pre><code>char *p=""Hello"";
</code></pre>

<p>The compiler automatically adds a \0 to the end of that string for you (otherwise functions like printf would not know, when the string finishes). So your string is actually:</p>

<pre><code>""Hello\0""
</code></pre>

<p>If you try to push the pointer further though, you will end up in invalid memory and you might encounter anything (garbage, which may be a series of zeros as well)</p></li>
</ol>
",4
17850463,17850374,1,"<p>The first <code>*(p++)</code> gives ""H"" because the ++ operator is defined to give its current value first, then do the increment.  The final <code>*(p++)</code> returns the character <code>'\0'</code>, because the string literal <code>""Hello""</code> points to an array of SIX characters, the last of which is <code>'\0'</code>.</p>
",0
17850478,17850374,0,"<p>Do this:</p>

<pre><code>{
    char *p=""Hello"";
    cout &lt;&lt;*p;     //gives H.
    cout &lt;&lt;*(++p); //gives e.
    cout &lt;&lt;*(++p); //gives l.
    cout &lt;&lt;*(++p); //gives l.
    cout &lt;&lt;*(++p); //gives o.
    cout &lt;&lt;*(++p); //gives 0.
    cout &lt;&lt;*(++p); //will either be a garbage value or throw an exception
}
</code></pre>

<p>The ++p will increment the pointer, and then return the value. p++ pushes the value on the stack, increments the pointer, and pops the stack to return it. It might also use a register; the implementation details are kind of up to the compiler. </p>
",0
17850505,17850374,1,"<p>It's because when using the post-increment (such as your <code>p++</code>), the value is evaluated <strong>before</strong> the increment is done.</p>

<p>So in your code, your first <code>cout &lt;&lt; *(p++);</code> will print 'H' because it will evaluate the value of <code>p</code> <strong>before</strong> the assignment, which is the address of <code>p</code>, and then the value of <code>p</code> is incremented.</p>

<p>To increment the value of <code>p</code> before it is evaluated, use pre-incremental <code>++p</code>.</p>

<p>So this is what would happen in your code:</p>

<pre><code>int main()
{
    char *p=""Hello"";
    cout &lt;&lt;*p;     //gives H
    cout &lt;&lt;*(++p); //this time it will give e
    cout &lt;&lt;*(++p); //gives l.
    cout &lt;&lt;*(++p); //gives l.
    cout &lt;&lt;*(++p); //gives o.
    cout &lt;&lt;*(++p); //gives no output since the character after a string is always \0 (credit to answer below)
}
</code></pre>

<p>Hope this helps! =D</p>
",1
17850506,17850374,0,"<pre><code>char *p=""Hello"";
cout &lt;&lt;*p;     //gives H
cout &lt;&lt;*(p++); //also gives H.Why?
</code></pre>

<p>Because post increment will increment <code>p</code> AFTER evaluation. 
To increment <code>p</code> BEFORE evaluation, use <code>*(++p)</code></p>

<pre><code>cout &lt;&lt;*(p++); //gives e.
cout &lt;&lt;*(p++); //gives l.
cout &lt;&lt;*(p++); //gives l.
cout &lt;&lt;*(p++); //gives 0.
cout &lt;&lt;*(p++); //gives no output.Why? It should give some garbage value!
</code></pre>

<p>There's a padding <code>\0</code> in every C-style strings.</p>
",0
17850514,17850374,3,"<p>What p++ does is increment p and return the old value of p, so *(p++) will always return the character stored at *p and after the statement *p will point to the next character.</p>

<pre><code>cout &lt;&lt;*(p++); //gives 0.
</code></pre>

<p>This does not actually give <code>0</code>, it gives the character ""o"", the last character in <code>Hello</code>.</p>

<pre><code>cout &lt;&lt;*(p++); //gives no output.Why? It should give some garbage value!
</code></pre>

<p>This outputs the NUL character <code>'\0'</code> that terminates the string. It's a non-printable character, and where you're seeing this output you don't see any probably because the software decides to not print non-printables. If you look at the hex dump of the output for example you could see the NUL right after the o:</p>

<pre><code>00000000  48 48 65 6c 6c 6f 00                              |HHello.|
</code></pre>

<p>If you added yet another <code>cout &lt;&lt;*(p++)</code> you <em>might</em> see garbage output, or the program might crash, or something else might happen, because it would be ""undefined behavior.""</p>
",4
10122878,10122771,3,"<p>If you need to know free space available on Windows you can read this:<br />
<a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa364937(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa364937(v=vs.85).aspx</a></p>

<p>On POSIX systems, you can try this:
<a href=""http://pubs.opengroup.org/onlinepubs/009604499/basedefs/sys/statvfs.h.html"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/009604499/basedefs/sys/statvfs.h.html</a></p>

<p>I believe that get the free space available without using the file system is not possible, because you will need to identify when a sequence of bytes is a file... (You will need to identify the total number of blocks on your HDD, which blocks are reserved for the system, a flag for the blocks that are in use and a flag for the ones that are free and probably a lot more related stuff...)</p>

<p>I can be wrong, but this is my guess...</p>

<p>I hope you understand...</p>

<p>=)</p>
",1
10822934,10822897,2,"<p>It's a definition for an <code>operator</code>, in this particular case <code>operator &lt;</code>. It's what gets called when someone does:</p>

<pre><code>Point a, b;
if( a &lt; b )
{ 
    //...
}
</code></pre>
",0
10822940,10822897,1,"<p>It's a member function that overloads the <code>&lt;</code> operator</p>

<pre><code>Point a,b;
a &lt; b; // the member function is used here.
</code></pre>
",7
10822948,10822897,7,"<p>Look, it's very simple.</p>

<p>You've defined a struct representing a point. Assuming you have two such structs, the code in question defines a <em>comparison operator</em> for them, so that you can write something like</p>

<pre><code>if (pt1 &lt; pt2) { ...
</code></pre>

<p>How can the compiler treat the <code>&lt;</code> sign? In C++ it's doing the following: the expression <code>pt1 &lt; pt2</code> gets interpreted as <code>pt1.operator &lt; (pt2)</code>. That is, the <em>method</em> with special name <code>operator &lt;</code> of object <code>pt1</code> is called, with argument equal to <code>pt2</code>.</p>

<p>Let's see what it is doing. <code>const Point &amp;p</code> in its argument denotes the other operand being compared. <code>const</code> says that we are not going to modify the operand (this allows the compiler to produce more effective code), and <code>&amp;</code> means that we are not copying the <code>struct</code> passed, but working with actual <code>Point</code> instance (this is faster again, as no copying is done for the comparison).</p>

<p>Now, the expression <code>x&lt;p.x</code> checks whether the <code>x</code> value at the left-hand operand (it's the <code>this</code> object, that is, the object in context of which the method is running)* against the <code>x</code> of the right-hand operand. Next, the code checks the case when the left-hand <code>x</code> is equal to the right-hand one, so the <code>y</code>'s are compared.</p>

<hr>

<p>*<em>For language purists: the wording is not precise, but for the beginner-oriented explanation it should be ok.</em></p>
",2
10822961,10822897,1,"<p>In C++ structs are very similar to classes. What you see there is an operator definition as instance method. It compares the ""this"" Point to the (unmodifiable) Point referenced as parameter ""p"" and is not allowed to modify the ""this"" Point due to the <code>const</code> after the parameter list.</p>
",0
11097539,10824569,4,"<p>You can use the same ""trick"" that you use for functions, that is use a proxy object with conversion operators:</p>

<pre><code>class A
{
  private:
    double* data_;
    int N_;
  public:
    A (int N = 0)
      : N_(N), data_(new double[N])
    {}
    ~A() { delete[] data_; }

    struct proxy
    {
        int i;
        double * data;
        operator double() const
        {
            return data[i];
        }

        operator double*()
        {
            return &amp;data[i];
        }

        operator double const *() const
        {
            return &amp;data[i];
        }
    };

    proxy operator[] (int const i) {
        proxy p { i, data_ };        
        return p;
    }

    proxy const operator[] (int const i) const {
        proxy p { i, data_ };        
        return p;
    }
};

int main()
{
  {
    A a(12);

    double d = a[0];
    double * pd = a[0];
  }

  {
    A const ca(12);

    double d = ca[0];
    //double * pd = ca[0]; // does not compile thanks to overloads on const
    double const * pcd = ca[0];
  }
}
</code></pre>

<p>However, I would argue that this is a <em>terrible</em> idea. Having your <code>operator[]</code> return either a value or a pointer to this value is guaranteed to confuse the users of your class, in addition to making it impractical to use in expressions where both types are possible. For instance, <code>std::cout &lt;&lt; a[0];</code> would not compile (ambiguous overloads).</p>
",2
10824728,10824569,0,"<p>Probably you need something like that:</p>

<pre><code>class A {

private:
    double* data_;
    int N_;
    ... // other stuff
public:
    double operator[] (const int i) const { // note const here
        return data_[i];
    }

    double&amp; operator[] (const int i) { // note reference here
        return data_[i];
    }
};
</code></pre>

<p>also operator should be public to have a sense.</p>
",2
10824585,10824569,14,"<p>Two method overloads must have different <em>signatures</em>. The return type is not part of the signature of a method.</p>
",1
11118218,11118115,2,"<p>If you use <code>&gt;&gt;</code> for input, leading whitespace will be skipped.  If you're reading binary data, you need to open the file in binary mode (<code>myfile.open( name, std::ios::in | std::ios::binary</code>) and use the non-formatting input functions, like <code>istream::get()</code>.  (And when writing, you'll also need to write binary.)</p>
",3
11158511,11158258,4,"<p>I tried compiling the code, and this was the only significant error:</p>

<pre><code>fixed.cpp: In member function ¡®void fixed::as_string()¡¯:
fixed.cpp:63:35: error: ¡®reverse¡¯ was not declared in this scope
</code></pre>

<p>I fixed that by using</p>

<pre><code>#include &lt;algorithm&gt;
</code></pre>

<p>in fixed.cpp</p>
",3
13398053,13397521,2,"<p>First, createImage(..) has to be a member function of class Image, as mentioned before.
Second, there are three ways to return the current object, by pointer, by reference and by value:</p>

<pre><code>class Image
{
    public:

    //by Pointer
    Image* PointerToImage()
    {
        return this;
    }
    const Image* ConstPointerToImage() const
    {
        return this;
    }
    //by Reference
    Image&amp; ReferenceToImage()
    {
        return *this;
    }
    const Image&amp; ReferenceToImage() const
    {
        return *this;
    }
    //by Value
    Image CopyOfImage() const
    {
        reuturn *this;
    }
}
</code></pre>

<p>Hope this helps.</p>
",0
13397545,13397521,-1,"<p>You don't need to return the instance, you already have it when you call createImage?</p>
",1
13397547,13397521,4,"<p>You've declared that function as a free one when it needs to be a member function. Only member functions have a <code>this</code> pointer.</p>

<pre><code>class image {
   //...
   Image *createImage(string str)
   //...
};

Image *Image::createImage(string str)
{
    return this;
}
</code></pre>

<p>Although if it's a create function your logic is probably wrong and you shouldn't be using <code>this</code>.</p>
",0
13397609,13397521,8,"<p><code>this</code> is only available in non-static member functions; they are called on an object, and <code>this</code> points to that object. <code>createImage()</code> is a non-member function; it's not called on an object, and so there is no <code>this</code> pointer.</p>

<p>Presumably, it's supposed to create an image and return a pointer to that. Perhaps you want:</p>

<pre><code>return new Image;
</code></pre>

<p>Remember that it's the caller's responsibility to <code>delete</code> the object once it's no longer needed - there is no garbage collection in C++. You would be wise to study <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow noreferrer"">RAII</a> to learn how to automatically manage dynamic objects in C++; in particular, a smart pointer would do the trick here:</p>

<pre><code>std::unique_ptr&lt;Image&gt; createImage() {
    return std::unique_ptr&lt;Image&gt;(new Image);
}
</code></pre>

<p>In general, you should forget any idioms you learned in Java, since that is a very different language. There are <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">many good books</a> on C++.</p>

<p>You should also avoid global variables, especially for things that logically belong to an instance of a class. It looks very much like <code>IImage *image;</code> should be a member of <code>Image</code> rather than a global variable (although perhaps it already is; I can't tell, since you haven't posted the definition of <code>Image</code>).</p>

<p>UPDATE: you now say that <code>createImage</code> is a member, and that the class should emulate the Java class you link to. In that case, it should be <code>static</code>. For a class member, that has roughly the same meaning that it does in Java: it is associated with the class itself, not any particular object. Then the definition needs to qualify the name with <code>Image::</code> to indicate that it is a member, not a different function declared in the namespace. So you want something like:</p>

<pre><code>class Image {
public:
    // some members
    static Image * createImage(string); // Add ""static"" to match the Java class.
                                        // Return a pointer (or a smart pointer)
};

Image * Image::createImage(string) {    // Add ""Image::"" to indicate it's a member
    return new Image;
}

// Usage example:
Image * image = Image::createImage(""whatever"");  // ""::"" rather than Java's "".""
</code></pre>

<p>Note that returning <code>Image</code> rather than <code>Image *</code> (or a smart pointer) will return a <em>copy</em> of the <code>Image</code> object, which is (probably) not what you want; that's another big difference from Java, where class objects are always passed by reference(*). Pointers are the closest things that C++ has to Java's object references.</p>

<p>(*) Note to pedants: by ""passed by reference"", I mean the object itself is not cloned; the object reference is passed by value.</p>
",2
17388759,17388738,8,"<p>In the first example (<code>*</code>) you are passing a pointer to your function and in the second example (<code>&amp;</code>) you are passing a reference.</p>
<p>To know the difference between both, read this post : <a href=""https://stackoverflow.com/questions/57483/what-are-the-differences-between-pointer-variable-and-reference-variable-in-c"">What are the differences between a pointer variable and a reference variable in C++?</a></p>
<p><strong>Bonus question :</strong></p>
<blockquote>
<p>One of the major disadvantages of pass by value is that all arguments passed by value are copied to the parameters. When the arguments are large structs or classes, this can take a lot of time. References provide a way to avoid this penalty. When an argument is passed by reference, a reference is created to the actual argument (which takes minimal time) and no copying of values takes place. This allows us to pass large structs and classes with a minimum performance penalty.</p>
<p>However, this also opens us up to potential trouble. References allow the function to change the value of the argument, which in many cases is undesirable. If we know that a function should not change the value of an argument, but don¡¯t want to pass by value, the best solution is to pass by const reference.</p>
<p>You already know that a const reference is a reference that does not allow the variable being referenced to be changed. Consequently, if we use a const reference as a parameter, we guarantee to the caller that the function will not (and can not) change the argument!</p>
</blockquote>
",0
17388767,17388738,3,"<p><code>*</code> means that parameter is a pointer and <code>&amp;</code> is passing by reference</p>
",0
12339839,12339812,2,"<p>A function such as</p>

<pre><code>string&amp; returnRefrence(){}
</code></pre>

<p>would only make sense in a context where is has access to a <code>string</code> that lives beyond it's own scope. This could be, for example, a member function of a class that has a <code>string</code> data member, or a function that has access to some global string object. A string created in the body of the function is destroyed on exiting that scope, so returning a reference to it results in a dangling reference.</p>

<p>Another option where is could make sense is if the function tkaes a string by reference, and returns a reference to that very string:</p>

<pre><code>string&amp; foo(string&amp; s) {
  // do something with s
  return s;
}
</code></pre>
",3
12341794,12339812,0,"<p>You could also declare the variable as static:</p>

<pre><code>std::string &amp;MyFunction()
{
    static std::string hello = ""Hello there"";
    return hello;
}
</code></pre>

<p>However, note that the exact same string object will be return as reference on each call.</p>

<p>For instance,</p>

<pre><code>std::string &amp;Call1 = MyFunction();
Call1 += ""123"";

std::string Call2 = MyFunction(); //Call2 = ""Hello there123"", NOT ""hello there""
</code></pre>

<p>The Call2 object is the same string referenced in Call1, so it returned its modified value</p>
",0
14778554,14778390,8,"<p>In general, wrapping a C header in <code>extern ""C""</code> is not a good idea. The header might include other files that break when you do this. A C header that is <strong>designed</strong> to be used in C++ will handle <code>extern ""C""</code> appropriately, without you having to do anything. Typical code:</p>

<pre><code>#ifndef MY_HEADER_INCLUDE_GUARD
#define MY_HEADER_INCLUDE_GUARD

#ifdef __cplusplus
extern ""C"" {
#endif

/* C callable stuff goes here */

#ifdef __cplusplus
}
#endif

#endif /* MY_HEADER_INCLUDE_GUARD */
</code></pre>
",4
11049540,11049493,2,"<p><code>void fill(int arr[], int size)</code> means that you need to pass an array of <code>int</code> to <code>fill</code>. However, you are passing it an instance of <code>City</code>, specifically <code>hm</code> in your main.</p>

<p>I am assuming that you are trying to read in a list of <code>City</code> descriptions from <code>cities.txt</code> (and thus have appropriate stream extraction/insertion operators). Change the signature of <code>fill</code> to accept a pointer to <code>City</code> objects so that you can fill in an array of <code>City</code> objects and not <code>int</code>s.</p>

<pre><code>void fill(City *arr, int size); 
</code></pre>

<p>Make sure that the argument you pass to <code>fill</code> in main is a properly allocated array of <code>City</code> objects of size at least <code>sz</code> where <code>sz</code> is what you pass in as the second parameter. Keep in mind to call <code>delete []</code> to free this array that you create.</p>

<p>A more idiomatic approach would be to use <code>vector&lt;City&gt;</code> so that you don't have to worry about memory management issues. Your modified <code>fill</code> signature would then be:</p>

<pre><code>void fill(std::vector&lt;City&gt;&amp; c); // note we no longer need the second argument
</code></pre>

<p>You will need to <code>#include &lt;vector&gt;</code> in order to be able to use <code>vector&lt;City&gt;</code> though.</p>

<p>Finally, to take advantage of RVO, simply return a <code>vector&lt;City&gt;</code> by value instead of passing it in as a parameter. So, you'd do something like:</p>

<pre><code>std::vector&lt;City&gt; fill(); // cleaner, faster
</code></pre>
",0
11049544,11049493,0,"<p><code>void fill(int arr[], int size)</code> expects an <code>int</code> array. You are trying to pass it a <code>City</code> array.</p>

<p>You can either write a new function, <code>void fill(City&amp; arr, int size)</code> or you could consider writing a templated function, <code>template&lt;class T&gt; void fill(T* arr, size)</code>, etc.</p>

<p>Also consider using <code>std::vector</code> or <code>std::array</code> instead of naked arrays. Bounds checking and memory management will be vastly easier.</p>

<p>Here's a couple of <code>fill</code> examples:</p>

<pre><code>// keep reading til we run out of cities in the file
void fill_vector(vector&lt;City&gt;&amp; cities)
{
    ifstream ifs(""cities.txt.""); 
    City city;

    while (!ifs.fail() &amp;&amp; !ifs.bad())
    {
        ifs &gt;&gt; city;
        cities.push_back(city);
    }
}

// only read 'n' cities
void fill_array(array&lt;City, 5&gt;&amp; cities, size_t count)
{
    ifstream ifs(""cities.txt.""); 
    for (size_t i = 0; i &lt; count; i++)
        ifs &gt;&gt; cities[i];
}
</code></pre>
",2
11049611,11049493,0,"<p>You're using the wrong <code>fill</code>. The function you want is the templated version in <code>&lt;algorithm&gt;</code>: <code>void fill (ForwardIterator first, ForwardIterator last, const T&amp; value);</code> (see <a href=""http://www.cplusplus.com/reference/algorithm/fill/"" rel=""nofollow"">here</a>).</p>

<p>So in order to initialize every element with an default <code>City</code> object, your call would become:</p>

<pre><code>std::fill(hm, &amp;(hm[n]), City());
</code></pre>

<p>or (more readable and shows intention):</p>

<pre><code>std::fill(&amp;(hm[0]), &amp;(hm[n]), City());
</code></pre>

<p><strong>Edit:</strong> I see now that I misunderstood your question and that you want to fill your <code>hm</code> array with stored objects.</p>

<p>As suggested in other answers, changing the signature of your <code>fill</code> function to <code>fill (City * const arr, size_t const n)</code> should fix that.</p>
",0
14738256,14738045,1,"<p>Have looked at your code and from what I can understand, you're probably looking for something like this:</p>

<pre><code>class MyStringClass
{
public:
    const char* data() const;

private:
const char* charptr;
};


const char* MyStringClass::data() const
{
    return charptr;
}


MyStringClass operator &amp; (const char String1 [], const MyStringClass &amp; String2)
{
    /* a different way of trying this... */
    int len = strlen(String1) + String2.Length();
    char * pTemp = new char [len + 1]; //total length of both strings
    strcpy (pTemp, String1);
    strcat (pTemp, String2.data()); // you need to have a public member function that returns the string as const char*
    MyStringClass str(pTemp); //requires MyStringClass to have constructor that takes char*
    return str; //return the string

}
</code></pre>
",2
10777050,10777017,0,"<p>There is a single version of standard. There is no difference between systems( it is one standard). You have to pay go get full version of the standard ( even for PDF file). Everyone is using: </p>

<p><a href=""https://github.com/cplusplus/draft"" rel=""nofollow"">https://github.com/cplusplus/draft</a> [EDITED TO THE NEWEST VERSION]</p>

<p>for free, because it is draft version and it is free. There are some different between draft and released one. </p>
",2
10777112,10777017,0,"<p>If you want to get a copy of <em>the</em> standard, you can buy it for a small fee from ISO, which is how they fund themselves.</p>

<p>However, if you simply follow the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf"" rel=""nofollow"">last draft</a> of C++11, which is currently the latest C++ standard, and will remain to be for some time, you will never notice a difference against the released standard.</p>

<p>It is a similar story with POSIX, a standard used for UNIX-like APIs on that family of operating systems.  In that case you would want to go <a href=""http://pubs.opengroup.org/onlinepubs/007904975/toc.htm"" rel=""nofollow"">here</a>.</p>

<p>However, while a perfect understanding of C++ is highly desirable whatever you do, it may well be that your portability needs will make POSIX somewhat irrelevant to you; either you might only need Linux compatibility, or you might restrict yourself to APIs (such as the standard C++ library or other portable libraries) that will support you even on non-POSIX operating systems.</p>
",5
11126801,11126203,0,"<p>The reason it doesn't work is simply because the Standard forbids it.  Pay special attention to <code>s</code> in the example:</p>

<p><img src=""https://i.stack.imgur.com/ELQxE.png"" alt=""enter image description here""></p>

<p>As a workaround, you can say:</p>

<pre><code>auto&amp; var = S1::var;
</code></pre>

<p>Making the Standard (and therefore all compilers) more complicated to handle an unusual case that has a convenient workaround just doesn't pass the cost-benefit test.</p>
",3
11840225,11839975,0,"<p>Your for/if/else structure is broken. If you don't match on the first element in the cart, you throw an exception, which you immediately catch. Try something more like this:</p>

<pre><code> for (i =0; i &lt; _Cart.size(); i++)
 {
    if(remove == _Cart[i].name)
    {
        if (q &gt;= 0)
        {
           _Cart[i].quant -= q;
           //inv-&gt;_Inv[i].quant += q;
           cout &lt;&lt;""\nYou removed "" &lt;&lt; q &lt;&lt; "" "" &lt;&lt; remove &lt;&lt;"" In your cart\n"" &lt;&lt; endl;
        }
        else
           cout &lt;&lt; ""Invalid number of "" &lt;&lt; remove &lt;&lt; "" being removed.\n"" &lt;&lt; endl;
        return true;
    }
 }
 cout &lt;&lt; ""\n"" &lt;&lt; remove &lt;&lt; "" doesn't exist in your cart\n"" &lt;&lt; endl;
 return true;
</code></pre>
",4
11840309,11839975,0,"<p>Is it a homework? :)</p>

<p>Firstly, ""Apple"" is the name of the variable you created, but you are passing ""Apples"" to the constructor of Food, so I suppose that this value is being assigned to its ""name"" member which is used in comparison.</p>

<p>Secondly, as David noticed, your loop will work only if you try to remove the first element in the cart. In your case the first element is named ""Apples"", so typing ""Apples"" works.</p>
",1
11810869,11810707,1,"<p>The concrete problem is that you don't initialize the new array (resp. <code>tempArray</code>) in your <code>Resize</code> function.</p>

<p>When calling</p>

<pre><code>int* tempArray = new int[newCapacity];
</code></pre>

<p>the array can contain arbitrary values. Only <code>newCapacity-1</code> values are copied from the old array, so the last value is undefined. It might be 0 but haven't to be. Use</p>

<pre><code>std::fill(tempArray, tempArray+newCapacity, 0);
</code></pre>

<p>to initialize your array with zero.</p>

<p>Apart from that, there are a few other problems:</p>

<ul>
<li>You don't delete the old array before allocating a new one. Use <code>delete[] gArray</code> for that. Also <code>tempArray</code>isn't deleted!</li>
<li>You don't need to copy the values twice. Just to a <code>gArray = tempArray</code> (after deleting the old <code>gArray</code>, see above)</li>
<li>You assume that <code>newCapacity</code> is just larger by one than <code>gCapacity</code> (you copy <code>newCapacity-1</code> values from the old array). It would be better to copy <code>gCapacity</code> values instead.</li>
<li>Dynamic arrays which only grow by one are inefficient, since adding a value takes linear time (you have to copy all the old values when inserting a single one). Usually, you double the size of the array every time you run out of space, this gives constant insertion time in average.</li>
<li>NULL is normally used only for pointers. For ints it is equal to zero which means, you cannot store <code>0</code> in your array (given your requirements)</li>
<li>In production code, I'd  <em>strongly</em> recommend using <code>std::vector</code> instead of any home-grown solution.</li>
</ul>

<p><strong>EDIT</strong></p>

<p>See @StackUnderflows answer for what is probably the real cause of the error. If you run in Debug mode, some compilers will automatically initialize the array for you, which might be the ccase here. </p>

<p>The <code>gArray[i]=gArray[i+1]</code> line in your <code>Remove</code> function is definitely wrong on the other hand, since it accesses a value which is beyond the limits of the array.</p>
",0
11810887,11810707,1,"<p>The problem occurs on the last iteration in the second loop of <code>Remove</code> when you do <code>gArray[i] = gArray[i + 1]</code>. On the last iteration, <code>gArray[i + 1]</code> is actually one past the end of your array, so you are now in undefined behavior territory. You are assigning this undefined value to the last element <code>gArray[i]</code>.</p>

<hr>

<p>I suggest using <code>std::vector&lt;int&gt;</code> instead. It manipulates an array under the hood which grows/resizes for you as you add more elements.</p>
",1
11810924,11810707,2,"<p>An option, since you are using the c++ standard library would be to remove all your code, and use <a href=""http://en.cppreference.com/w/cpp/container/list"" rel=""nofollow"">std::list</a> and its <code>insert</code> and <code>remove</code> methods. If you require the data to be in a dynamic array, then use <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow"">std::vector</a> and the <a href=""http://en.wikipedia.org/wiki/Erase-remove_idiom"" rel=""nofollow"">erase remove</a> idiom for removal.</p>

<p>I have to point out that, since your question is ""<em>Removing int value in dynamic array and setting it to NULL</em>"", that setting an int to <code>NULL</code> is essentially setting it to the value <code>0</code>, since <code>NULL</code> tends to be a define for <code>0</code>. So if your list were to contain zeroes, this setting to <code>NULL</code> and checking for equality with <code>NULL</code> would completely break the logic of your algorithm. C++11 has <code>nullptr</code>, an actual null type that cannot be assigned to an int, to deal with this kind of problem.</p>
",0
11112936,11112873,2,"<p>Normally you call <code>srand(time(NULL));</code> once (and only once) as the program is starting up.</p>

<p>To ask different questions, you'd normally get a random number with <code>rand</code>, reduce it to the range of the number of questions, and use that to select one of the questions.</p>
",1
11523817,11523705,2,"<p>If you are looking for speed, i don't recommend you a scalable variable usage in C++ but if you need flexibility instead of speed, here is your possible solution.</p>

<p><a href=""http://gmplib.org/"" rel=""nofollow"">http://gmplib.org/</a></p>
",1
11151819,11151687,6,"<p><code>size_t</code> is a type that can hold size of any allocable chunk of memory. It follows that you can't allocate more memory than what fits in your <code>size_t</code> and thus can't store more elements in any way.</p>

<p>Compiling in 64-bits will allow it, but realize that the array still needs to fit in memory. 2<sup>32</sup> is 4 billion, so you are going to go over 4 * sizeof(element) GiB of memory. More than 8 GiB of RAM is still rare, so that does not look reasonable.</p>

<p>I suggest replacing the vector with the one from <a href=""http://stxxl.sourceforge.net/"" rel=""nofollow noreferrer"">STXXL</a>. It uses external storage, so your vector is not limited by amount of RAM. The library claims to handle terabytes of data easily.</p>

<p>(edit) Pedantic note: <code>size_t</code> needs to hold size of maximal single object, not necessarily size of all available memory. In segmented memory models it only needs to accommodate the offset when each object has to live in single segment, but with different segments more memory may be accessible. It is even possible to use it on x86 with PAE, the ""long"" memory model. However I've not seen anybody actually use it.</p>
",5
11151886,11151687,0,"<p>A <code>vector</code> might be the wrong data structure for you. It requires storage in a single block of memory, which is limited by the size of <code>size_t</code>. This you can increase by compiling for 64 bit systems, but then you can't run on 32 bit systems which might be a requirement.</p>

<p>If you don't need <code>vector</code>'s particular characteristics (particularly O(1) lookup and contiguous memory layout), another structure such as a <code>std::list</code> might suit you, which has no size limits except what the computer can physically handle as it's a linked list instead of a conveniently-wrapped array.</p>
",2
11152454,11151687,3,"<p>There are a number of things to say.</p>

<p><strong>First</strong>, about <strong>the size of <code>std::size_t</code></strong> on 32-bit systems and 64-bit systems, respectively. This is what the standard says about <code>std::size_t</code> (¡ì18.2/6,7):</p>

<blockquote>
  <p>6 The type <code>size_t</code> is an implementation-de?ned unsigned integer type that is large enough to contain the size
  in bytes of any object.</p>
  
  <p>7 [ Note: It is recommended that implementations choose types for <code>ptrdiff_t</code> and <code>size_t</code> whose integer
  conversion ranks (4.13) are no greater than that of <code>signed long int</code> unless a larger size is necessary to
  contain all the possible values. ¡ª end note ]</p>
</blockquote>

<p>From this it follows that <code>std::size_t</code> will be <em>at least</em> 32 bits in size on a 32-bit system, and <em>at least</em> 64 bits on a 64-bit system. It could be larger, but that would obviously not make any sense.</p>

<p><strong>Second</strong>, about the idea of <strong>type casting</strong>: For this to work, <strong>even in theory</strong>, you would have to cast (or rather: <em>redefine</em>) the type inside the implementation of <code>std::vector</code> itself, wherever it occurs.</p>

<p><strong>Third</strong>, when you say you need this super-large vector ""in 32 bits"", does that mean you want to use it on a 32-bit system? In that case, as the others have pointed out already, what you want is impossible, because a 32-bit system simply doesn't have that much memory.</p>

<p>But, <strong>fourth</strong>, if what you want is to run your program on a 64-bit machine, and use only a 32-bit data type to refer to the <em>number</em> of elements, but possibly a 64-bit type to refer to the total size in bytes, then <code>std::size_t</code> is not relevant because that is used to refer to the total number of elements, and the index of individual elements, but not the size in bytes.</p>

<p><strong>Finally</strong>, if you are on a 64-bit system and want to use something of extreme proportions that works like a <code>std::vector</code>, that is certainly possible. Systems with 32 GB, 64 GB, or even 1 TB of main memory are perhaps not extremely common, but definitely available.</p>

<p><strong>However</strong>, to implement such a data type, it is <strong>generally not a good idea</strong> to simply allocate gigabytes of memory <strong>in one contiguous block</strong> (which is what a <code>std::vector</code> does), because of reasons like the following:</p>

<ul>
<li>Unless the total size of the vector is determined once and for all at initialization time, the vector will be resized, and quite likely re-allocated, possibly many times as you add elements. Re-allocating an extremely large vector can be a time-consuming operation. <strong>[</strong> I have added this item as an <strong>edit</strong> to my original answer. <strong>]</strong></li>
<li>The OS will have difficulties providing such a large portion of unfragmented memory, as other processes running in parallel require memory, too. [<strong>Edit:</strong> As correctly pointed out in the comments, this isn't really an issue on any standard OS in use today.]</li>
<li>On very large servers you also have tens of CPUs and typically NUMA-type memory architectures, where it is clearly preferable to work with relatively smaller chunks of memory, and have multiple threads (possibly each running on a different core) access various chunks of the vector in parallel.</li>
</ul>

<p><strong>Conclusions</strong></p>

<p><strong>A)</strong> If you are on a 32-bit system and want to use a vector that large, using disk-based methods such as the one suggested by @JanHudec is the <strong>only thing that is feasible</strong>.</p>

<p><strong>B)</strong> If you have access to a large 64-bit system with tens or hundreds of GB, you should look into an implementation that <strong>divides the entire memory area into chunks</strong>. Essentially something that works like a <code>std::vector&lt;std::vector&lt;T&gt;&gt;</code>, where each nested vector represents one chunk. If all chunks are full, you append a new chunk, etc. It is straight-forward to implement an iterator type for this, too. Of course, if you want to optimize this further to take advantage of multi-threading and NUMA features, it will get increasingly complex, but that is unavoidable.</p>
",4
11549760,11549727,1,"<p>You are saving a pointer to n in the array, but you constantly change the value of n.</p>
",0
11549823,11549727,0,"<p>You don't really need to mess with pointers here. Change your array definition, how you populate it, and how you display and you should have better luck.</p>

<pre><code>int array[9];
...
array[i] = n;
...
cout &lt;&lt; array[0] &lt;&lt; endl;
</code></pre>
",0
11549830,11549727,4,"<p>The line</p>

<pre><code>array[i] = &amp;n;
</code></pre>

<p>will store the same address in every entry in your array. This is just pointing to <code>n</code> so will always point to that value.</p>

<p>Either define the array as an array of integers</p>

<p>i.e. <code>int array[9];</code></p>

<p>and then place the value into that array </p>

<p>i.e. <code>array[i] = n;</code></p>

<p><strong>OR</strong></p>

<p>Allocate some memory off the heap</p>

<p>i.e.</p>

<pre><code>int *array[9];
...
array[i] = new int;
*array[i] = n;
</code></pre>

<p>But you will then have to free this memory with <code>delete</code> to avoid a memory leak.</p>
",2
11549880,11549727,2,"<p>There are several issues here.</p>

<ol>
<li>You have nowhere to store the values. You have an array of 8 pointers which are all set to point to the same variable n, which is on the stack and so goes out of scope.</li>
<li>The array has 8 elements so the loop goes one past the end</li>
<li>This is C++ so really best not to use C arrays unless you have a justifiable reason to.</li>
</ol>

<p>I would have something more like *NB not compiled and run)</p>

<pre><code>{
...
std::vector&lt;int&gt; array;

cout&lt;&lt;""Enter Number Between 0-9 Only""&lt;&lt;endl;
for(int i = 0; i&lt; 8; i++){
    int n;
    cout &lt;&lt; ""Enter Number "" &lt;&lt; (i + 1) &lt;&lt; endl;
    cin &gt;&gt; n;
    if((n &gt;= 0) &amp;&amp; (n &lt;= 9))
        array.push_back(n);
    else {
        cout &lt;&lt; ""Numbers from 0-9 only\n"" &lt;&lt; endl;
        i--;
    }

}

cout &lt;&lt; array[0] &lt;&lt; endl;
}
</code></pre>
",0
11559389,11558045,0,"<p>I should think that whether or not the structure is sensible depends somewhat on what you really want to achieve -- the system sounds very flexible, but usually there's a trade-off between flexibility and performance. Depending on the genre of the game, performance may be hard enough to come by.</p>

<p>Also, if all things derive from some BaseNode, they all need (although possibly empty) methods for all kinds of things whether or not they actually can be rendered, moved etc. Or you'd end up with lots of dynamic_casts, which isn't very nice either. It might therefore be better to have slightly less flexibility and differentiate between game entities and graphical entities, with the latter being part of the former (you might want to allow a game entity to be made up from multiple graphical entities, or sub-entities, though).</p>

<p>If you do go with your current architecture, I should think that each BaseObject has something like a vector and when you call, say, render() on a master object, it goes through all it's children and calls render on them. They do the same and do any render code that is appropriate to them.</p>

<p>Another question is, though, whether an object could feasibly be attached to several other objects (if there is a difference between rendering and physics, for example). If so, it can get hairy to know when to delete an object, unless you don't use plain BaseObject*, but some form of auto_ptr or shared_ptr.</p>

<p>I hope that this answer does help you a little, though I realise it's not a simple ""this is they way!"" one.</p>
",1
10767926,10767908,4,"<pre><code> Student st();
</code></pre>

<p>should be:</p>

<pre><code> Student st;
</code></pre>

<p><code>Student st();</code> does not create an object <code>st</code> of the type <code>Student</code> it declares a function by the name <code>st</code> which takes no parameters and returns a <code>Student</code> object.   </p>

<p>This is sometimes called <strong>Most Vexing Parse</strong> in C++.</p>
",0
10767932,10767908,4,"<p>Remove the parentheses from <code>st</code>'s declaration.</p>

<pre><code>Student st<del>()</del>;</code></pre>

<ul>
<li><a href=""http://codepad.org/QTNsKSkr"" rel=""nofollow"">Non-working demo</a></li>
<li><a href=""http://codepad.org/Pour0zNj"" rel=""nofollow"">Working demo</a></li>
</ul>
",0
11870515,11870512,5,"<blockquote>
  <p>So why this code works fine</p>
</blockquote>

<p>Undefined behaviour means the code can <em>appear</em> to work fine. But it's still undefined.</p>

<p>In your case, <code>a</code> is a dangling pointer. </p>
",6
11870531,11870512,0,"<p>The code is still wrong. It may <em>appear</em> to work now, but won't next week. It may appear to work now, but change one small thing and it no longer ""works"".</p>

<p>Try this. Add another function, <code>test2</code>:</p>

<pre><code>int *test()
{
    int a = 11;
    return &amp;a;
}

int test2()
{
    int b = 13;
}

int main()
{
    int *a;

    a = test();
    cout &lt;&lt; ""after test: "" &lt;&lt; *a &lt;&lt; endl;

    test2();
    cout &lt;&lt; ""after test2: "" &lt;&lt; *a &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Now is <code>11</code> printed both times? Note that it <em>could</em> still print <code>11</code> twice, but it probably won't. We are, after all, still flirting with undefined behavior here.</p>

<p>But on my machine, I see:</p>

<pre><code>after test: 11
after test2: 13
</code></pre>

<p><code>test2</code> has clobbered the space on the stack that my dangling pointer was pointing to. The code is incorrect. The variable defined inside the function <code>test</code> is out of scope when the function exits, and is no longer valid. Maintaining a reference to it doesn't change this.</p>
",0
10773245,10772921,0,"<p>You can use <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strtok/"" rel=""nofollow"">strtok</a> to tokenize the string and use white space char as your delimiter.</p>
",0
10773478,10772921,0,"<p>You could store the morse codes and their equivalent values in a map, 
split the morse string on spaces, loop over these elements and retrieve the resulting values from your map (and concatenate them together) for your final result</p>

<p>this is an example showing the decoded SOS '... --- ...'</p>

<pre><code>#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;


using namespace std;

vector&lt;string&gt; SplitString (string aString);
vector&lt;string&gt; SplitString (string aString){
  vector&lt;string&gt; vec;
  char * cstr, *p;
  string str = aString;

  cstr = new char [str.size()+1];
  strcpy (cstr, str.c_str());
  p=strtok (cstr,"" "");

  while (p!=NULL){
   vec.push_back(p);
   p = strtok(NULL,"" "");
  }

  delete[] cstr;
  return vec;
}

int main(){

  map&lt;string,string&gt; m;
  m[""...""] = ""S"";
  m[""---""] = ""0"";


  vector&lt;string&gt; v;
  string sentence = ""... --- ..."";
  v = SplitString(sentence);


  vector&lt;string&gt;::iterator it;

  cout &lt;&lt; ""Our morse ("" &lt;&lt; sentence &lt;&lt; "") decoded to: "";
  for ( it = v.begin() ; it &lt; v.end(); it++ ){
    cout &lt;&lt; m[*it];
  }

  cout &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>you can fill in the other morse codes, would've taken me too much time, sorry, used SOS since it's so well known. :) 
This example is also probably not very good nor optimised nor recommended, it's been years since I came near c++. Hope it sparks some better idea in you though.</p>
",1
17824337,17824209,0,"<p>Those are in <code>libstdc++</code> which is built as part of <code>gcc</code>.  You can download <code>gcc-core-X.Y.Z.tar.bz2</code> and find it there.</p>
",0
17824346,17824209,3,"<p>They're probably defined in <code>libstdc++</code>. You can get the source code on the <a href=""http://gcc.gnu.org/libstdc++/"" rel=""nofollow"">GCC website</a>. On Ubuntu distros, you just have the library installed (<code>libstdc++.so</code>), not the source code. The stuff you found are just the declarations, not the definitions.</p>
",0
17825900,17824209,1,"<p><code>std::out_of_range</code> is fully defined in <strong>¡ì19.2.5 Class <code>out_of_range</code> [out.of.range]</strong> of the C++11 standard.</p>
",0
17826060,17824209,0,"<p>here you go</p>

<p><a href=""http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-3.4/stdexcept_8cc-source.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-3.4/stdexcept_8cc-source.html</a></p>

<p>keep in mind that libstdc++ is no longer distributed as a single library, but the source of the library is actually bundled with gcc, so to download libstdc++ you have to download gcc.</p>
",0
17844965,17844836,3,"<p>You cannot print the values of pointer-to-member objects using the <code>%p</code> conversion specifier of <code>printf</code>.   They are not necessarily regular pointers. The <code>%p</code> specifier requires a <code>void *</code> value. Strictly speaking, you cannot even portably print a regular function pointer with <code>%p</code>, because this requires a conversion of a function pointer to <code>void *</code>.</p>

<p>Pointer-to-member types do not necessarily fit into one machine word that can hold an address. They can be data structures with several fields.</p>

<blockquote>
  <p>I believe vbtl is an entity associated with instantiated object, not with the class.</p>
</blockquote>

<p>This is incorrect. Virtual tables are static structures, and instances only point to them. All instances of a given class share a pointer to the same table.</p>

<p>A pointer to a non-static member function is simpler in one regard in that it doesn't have to deal with the offset of an arbitrary data member in a class instance. However, a pointer to a non-static member function is complicated by the need to support virtual functions, and by the fact that code which calls through a pointer like this doesn't know or care whether it's calling a virtual or non-virtual function.</p>

<p>One implementation strategy for pointers to member functions involves thunks: pieces of compiler-generated code which perform the right kind of logic to do the call in the right way. A pointer to member can then point at the thunk. The thunk knows where in the <code>this</code> object to find the vtable pointer, and which offset in the vtable is the function that is ultimately to be called.</p>
",0
10770891,10770870,2,"<p>hmm you could make 'var' a character array and use a while loop to read input until the array was full maybe?</p>

<pre><code>char var[somenumber + 1];
int count = 0;

while(count &lt; somenumber){
  cin &gt;&gt; var[count];
  count++;
}

var [somenumber] = '\0';
</code></pre>
",0
10770894,10770870,16,"<p>You can use <code>setw()</code></p>

<pre><code> cin &gt;&gt; setw(2) &gt;&gt; var;
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/iostream/manipulators/setw/"" rel=""noreferrer"">http://www.cplusplus.com/reference/iostream/manipulators/setw/</a></p>

<blockquote>
  <p>Sets the number of characters to be used as the field width for the
  next insertion operation.</p>
</blockquote>

<p>Working example provided by @chris: <a href=""http://ideone.com/R35NN"" rel=""noreferrer"">http://ideone.com/R35NN</a></p>
",6
11523394,11523356,7,"<p>It crashes because <code>data</code> is an unitialised pointer. <code>delete[]</code> on a null pointer is safe (no-op) so initialise <code>data</code> in the constructor:</p>

<pre><code>cAuthorisation() : size(0), data(0) {}
</code></pre>

<p>Note that the class as it stands is violating <a href=""https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">the rule of three</a>.</p>

<p>Unsure if this is a learning exercise, if it is not use <code>std::vector&lt;strAuthorisation&gt;</code>. The <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer""><code>std::vector</code></a> will dynamically grow as required and automatically destructed when it goes out of scope.</p>
",0
11523401,11523356,4,"<p>You have not initialized the <code>data</code> pointer. So you are making something like this:</p>

<pre><code>Foo *data;
delete [] data;
</code></pre>
",0
11523428,11523356,0,"<p>""data"" is a pointer who's value was never initialized.</p>
",0
11544449,11544415,7,"<p>Function is returning the address of a local variable. The code has undefined behaviour and gives unpredicted results.</p>

<p><code>ss</code> resides on stack and the function <code>get()</code> returns a pointer to it.</p>

<pre><code>char * get()
{
} // Life time of ss ends here
</code></pre>

<p>Use <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow"">std::string</a> instead.</p>
",2
11544476,11544415,2,"<p>When the get() function returns, the local  variable goes out of scope.  I.e., it's value becomes undefined.</p>

<p>To solve, you can use...</p>

<pre><code>static char ss[255];
// or  
char *ss = (char *)calloc(1,255);
// or with C++
char *ss = new char[255];
</code></pre>

<p>or so on...</p>

<p>You decide the trade-off.  With a static variable, every call to get() could change the contents of the buffer.  But with an approach involving allocation, your caller needs to free the memory and know whether to use free() or delete.  Some approach the problem by supplying the buffer to the function when called, like...</p>

<pre><code>void get(char *buf, int limit);
// or
void get(char *buf, int&amp; limitActual);
</code></pre>

<p>Then main thing is that when dealing with strings, in C/C++ (even std::string) you are dealing with memory that has to be managed somehow.  With string, be very careful with automatic variables.</p>
",3
11544488,11544415,2,"<p>Your array ss[] only exists within the scope of get().<br>
So the pointer to it that you return from get() is invalid as soon as you leave the function.</p>
",0
11491767,11491702,0,"<p>You are looking for the member function <code>.close ()</code> of the stream object, after closing the stream you are free to connect it elsewhere.</p>
<pre><code>stream.close ();
</code></pre>
<hr />
<h3>Documentation:</h3>
<ul>
<li><strong><a href=""http://www.boost.org/doc/libs/1_47_0/doc/html/boost_asio/reference/ip__tcp/iostream.html"" rel=""nofollow noreferrer"">www.boost.org - ip::tcp::iostream - Boost 1.47.0</a></strong></li>
<li><strong><a href=""http://www.boost.org/doc/libs/1_47_0/doc/html/boost_asio/reference/basic_socket_iostream/close.html"" rel=""nofollow noreferrer"">www.boost.org - basic_socket_iostream::close - Boost 1.47.0</a></strong></li>
</ul>
",0
11489676,11488048,1,"<p>In windows you can use libusb-win32, that can be found in:
<a href=""http://sourceforge.net/projects/libusb-win32/"" rel=""nofollow"">http://sourceforge.net/projects/libusb-win32/</a></p>

<p>It can be helpful.
Thanks</p>
",0
11889086,11889060,5,"<p>You called <code>s.get_data()</code>, but not <code>t.get_data</code>. Therefore <code>b, h</code> will be garbage in <code>t</code> and <code>r</code>.</p>
",4
11888353,11888314,3,"<p><code>f</code> itself needs to be a template, with its own template parameter:</p>

<pre><code>template&lt;typename T&gt;
class A
{
    template &lt;typename U&gt;
    void f(A&lt;U&gt;&amp; a);
}
</code></pre>

<p>When you call <code>object1.f(object2)</code>, <code>f</code> will be instantiated with <code>U</code> = <code>double</code>; when you call <code>object1.f(object3)</code>, <code>f</code> will be instantiated with <code>U</code> = <code>int</code>.</p>

<p>In both cases <code>T</code> = <code>double</code> because <code>object1</code> is of type <code>A&lt;double&gt;</code> and <code>T</code> is a template parameter of the class template <code>A</code>.</p>
",0
11888379,11888314,1,"<p>You need a member function template:</p>

<pre><code>template &lt;typename T&gt;
class A
{
    template &lt;typename U&gt;
    void f(A&lt;U&gt;&amp; a)
    {
        //...
    }
};
</code></pre>
",0
11888380,11888314,1,"<blockquote>
  <p>but it doesn't seem to work because it assumes that the argument must be of the exact same type as the calling object:</p>
</blockquote>

<p>Of course it does, because that's what you instruct it to do:</p>

<pre><code>template&lt;typename T&gt;
class A
{
    void f(A&lt;T&gt; &amp;a);
}
</code></pre>

<p>Perhaps you wanted to make <code>f</code> a template itself:</p>

<pre><code>template&lt;typename T&gt;
class A
{
    template &lt;typename T1&gt;   //&lt;--- different type
    void f(A&lt;T1&gt; &amp;a);
}
</code></pre>
",0
13421622,13421544,4,"<p>The line <code>Markov(reader);</code> is creating a variable called <code>reader</code> of type <code>Markov</code>. It is equivalent to the following: <code>Markov reader;</code>. Of course, since the compiler thinks you're declaring another variable called <code>reader</code>, it throws up this error. To create an instance of <code>Markov</code>, do this:</p>

<pre><code>Markov m(reader);
</code></pre>

<p>This is an ambiguity in the grammar of C++ that is always taken as a declaration of a variable, rather than the construction of a temporary. In fact, you can have as many parentheses as you like around the variable name in your declaration: <code>Markov (((((reader)))))</code>.</p>

<p><code>Markov(reader)</code> is of course perfectly fine syntax for creating a temporary of type <code>Markov</code>, as long as it isn't in a statement that could be parsed as a declaration. For example, if it's in the middle of an expression, you'll be okay. In the contrived expression <code>something += Markov(reader) - 6</code>, it can't be interpreted as a declaration.</p>

<p>Likewise, if there is more than one argument being passed to the constructor, <code>Markov(reader, writer)</code>, or if the single argument is not an identifier, <code>Markov(""foo"")</code>, it is not ambiguous.</p>

<p>If you're using a C++11 compiler, you can indeed create a temporary (although I see no reason to do it) that takes a single argument identifier using the new initialization syntax:</p>

<pre><code>Markov{reader};
</code></pre>
",4
13421649,13421544,2,"<p>You may want to pass that <code>fstream</code> by <strong>reference</strong>.</p>

<pre><code>Markov(fstream&amp; inStream)
</code></pre>

<p>And while you're at it, if you're only using it for input services, use an <code>ifstream&amp;</code> instead.</p>
",0
11572745,11572676,2,"<p>If the class is just a bunch of simple <code>setters/getters</code> I would consider making a <code>struct</code> (they are almost the same as class, but in case of public variables I prefere to name it <code>struct</code>) with public variables. But in any case if your methods are that simple compiler will probably <code>inline</code> them.</p>

<p>Also <code>don't optimize the code until you found a bottleneck</code></p>
",0
11572748,11572676,0,"<pre><code>class MathOperations{
    public:
    void Message();
    void setA(int);
    void setB(int);
    int getA();
    ing getB();
    int getSum();
    int getSub();
    int getMul();
    double getDiv();
    double getSqrt();
    private:
    int a, b;
</code></pre>

<p>Instead of storing the values for sum, sub, mul, and divide you want to set A and B then calculate the answers. Also, divide should return a double or float unless you are anticipating truncation. What I mean by this is if you have getDiv() return an int and a=1 and b=2 it will return 0 (1/2 = 0.5 which truncates to 0), if you are looking for a nice floating point answer you should be using a double or float.</p>

<p>Here is an example implementation of getDiv():</p>

<pre><code>double MathOperations::getDiv() {
    double tempa = (double)this-&gt;a;
    double tempb = (double)this-&gt;b;
    return tempa/tempb;
}
</code></pre>

<p>As far as optimising your current example goes, if you are doing something like the following:</p>

<pre><code>class foo {
    public:
    void setA(int);
    void setB(int);
    int getA();
    int getB();

    private:
    int A,B;
}
</code></pre>

<p>The only true overhead you are getting (assuming the compiler doesn't optimise this code) is you add a function call to the stack when getting or setting the variable and pop it off when done and making a copy of the variable to return. This is negligible on modern computers.</p>

<p><strong>EDIT:</strong><code>double tempa = (double)this-&gt;a</code> There is a lot going on in this little line of code, let me break it down and explain.</p>

<ol>
<li><code>this-&gt;a</code> refers to the local member of the class a which is an integer. Read more about classes here: <a href=""http://www.cplusplus.com/doc/tutorial/classes/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/classes/</a></li>
<li><code>(double)this-&gt;a</code> For the math we are going to do, we want <code>this-&gt;a</code> to be a double so we can get a nice number like 3.141519 when doing division. To do this we <code>cast</code> it to a double, basically telling the compiler to convert the integer to a double in memory before storing it in tempa. Read more about data types here: <a href=""http://www.cplusplus.com/doc/tutorial/variables/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/variables/</a> Read more about typecasting here: <a href=""http://www.cplusplus.com/doc/tutorial/typecasting/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/typecasting/</a></li>
<li><code>double tempa =</code> here we assign the new double value from 2. to a temporary value tempa that we can use for division.</li>
</ol>

<p>If you find cplusplus.com's tutorial a little hard to follow you can try your hand at <a href=""http://www.cprogramming.com/tutorial/c++-tutorial.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/c++-tutorial.html</a> which can be a little easier to read.</p>
",4
11568102,11568084,1,"<p>An enum is for abstracting away magic numbers.  </p>

<p>A struct is for holding a collection of different variables.  </p>

<p>You can almost think of an enum as a stand-in for an int or char to make things more readable.</p>
",1
11568111,11568084,8,"<blockquote>
  <p>Are struct in c++ similar to enum or classes?</p>
</blockquote>

<p>In C++, a struct is essentially the same as a class, except that the default access modifiers  for member variables, methods, and for base classes are all public, where in a class, the default access modifier is private.</p>
",0
11568139,11568084,1,"<p>struct is basically a class with all members public.</p>

<p>For instance:</p>

<pre><code>struct MyNewStruct {
    int myNewInt;
    double myNewDouble;
};
</code></pre>

<p>is equivalent to:</p>

<pre><code>class MyNewClass {
public:
    int myNewInt;
    double myNewDouble;
};
</code></pre>

<p>Hence, you can create a struct with constructor:</p>

<pre><code>struct MyNewStruct {
    int myNewInt;
    double myNewDouble;

    MyNewStruct(int i, double d) 
    : myNewInt(i), myNewDouble(d)
    {}
};
</code></pre>
",0
11503405,11503382,5,"<p><code>global</code> and <code>static</code> variables are initialized before <code>main</code>. Except for the <code>static</code> variables declared inside a function. They are initialized on a first call. So I think you should look at the static and global variables</p>
",1
12828130,12828091,1,"<p>Actually there will be a double free here, not a memory leak.</p>

<p>STL containers store objects, not references. In your case <code>object</code> is a pointer. Pointers are simply copied. Your line <code>a2 = a;</code> will duplicate pointer in the vector. After that each destructor will release the pointer.</p>

<p>Double free is much more dangerous than the memory leak. It causes nasty undefined behavior:</p>

<pre><code>MyStruct *p1 = new MyStruct();
delete p1;
.... do something, wait, etc.
delete p1;
</code></pre>

<p>at the same time on the other thread:</p>

<pre><code>MyOptherStruct *p2 = new MyOtherStruct();
.... do something, wait, etc.
p2-&gt;function();
</code></pre>

<p>It may turn out that memory allocator will assign to <code>p2</code> exactly the same value that was used for <code>p1</code>, because it is free after the first call to <code>delete p1</code>. A while later second <code>delete p1</code> will also go fine because allocator thinks that this is a legitimate pointer that was given out for <code>p2</code>. The problem will appear only at <code>p2-&gt;function();</code>. Looking at the code of thread 2 it is absolutely impossible to understand what went wrong and why. This is extremely difficult to debug, especially if the system is big.</p>
",0
12828138,12828091,2,"<p>Because without an assignment operator and a copy constructor you may end up with multiple <code>hold</code> vectors pointing to the same heap item, resulting in undefined behavior upon destruction:</p>

<pre><code>z firstZ;
if (somethingIsTrue) {
    z otherZ = firstZ;
    // play with otherZ...
    // now otherZ gets destructed, along with longlife's of the firstZ
}
// now it's time to destroy the firstZ, but its longlife's are long gone!
</code></pre>

<p>Of course you would not have this problem had you used a vector of objects or a vector of ""smart pointers"", rather than a vector of ""plain old"" pointers.</p>

<p>See the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29"" rel=""nofollow""><em>Rule of Three</em></a> for more information.</p>
",2
12828150,12828091,1,"<p>It would cause a double delete (and crash) on the destructor of <code>a</code> or <code>a2</code> (whichever was destroyed second) because the default assignment constructor would do a binary copy of the memory state of <code>hold</code>.  So each object <code>a</code> and <code>a2</code> would end up deleting the exact same memory.</p>
",0
12828162,12828091,3,"<p>Not only is the assignment operator required, you also need to implement a copy constructor. Otherwise the compiler will provide default implementations that will result in both copies (after assignment / copy construction) containing pointers to the same <code>longlife</code> instances. Destructors of both copies will then <code>delete</code> these instances leading to undefined behavior.</p>

<pre><code>z a;
a.hold.push_back( heap_item );
z a2;
a2 = a;
</code></pre>

<p>Both <code>a.hold[0]</code> and <code>a2.hold[0]</code> contain a pointer to the same <code>heap_item</code>; thus causing double deletion during destruction.</p>

<p>The easy way to avoid having to implement the assignment operator and copy constructor is to use a smart pointer to hold the <code>longlife</code> instances in the <code>vector</code>.</p>

<pre><code>std::vector&lt;std::unique_ptr&lt;longlife&gt;&gt; hold;
</code></pre>

<p>Now there's no need to even write a destructor for your class.</p>

<hr>

<p>For C++03, your options are to use <code>std::tr1::shared_ptr</code> (or <code>boost::shared_ptr</code>) instead of <code>unique_ptr</code> or use <a href=""http://www.boost.org/libs/ptr_container/doc/ptr_vector.html"" rel=""nofollow""><code>boost::ptr_vector</code></a> (of course, this is also an option for C++11) instead of <code>std::vector</code>.</p>
",6
12828286,12828091,1,"<p>From your comments:</p>

<blockquote>
  <p>@Xeo, I understand what the rule of three is, the question is mostly
  why is it a rule</p>
</blockquote>

<p>Consider what happens here:</p>

<pre><code>z&amp; operator=( const z&amp;ref )
{
 hold = ref.hold;
 return *this;
}
</code></pre>

<p>Lets say you have an instance of <code>z</code>:</p>

<pre><code>z myz;
myz.a.hold.push_back( new long_life );
</code></pre>

<p>...and then you create a copy of this <code>myz</code>:</p>

<pre><code>z my_other_z;
// ...
my_other_z = myz;
</code></pre>

<p>The <code>operator=</code> implementation you have provided above simply copies the contents of the <code>vector</code>.  If the <code>vector</code> has pointers, it doesn't make copies of whatever's being pointed to -- it just makes a literal copy of the pointer itself.</p>

<p>So after <code>operator=</code> returns, you will have 2 instances of <code>z</code> that have pointers pointing to the same thing.  When the first of those <code>z</code>s is destructed, it will delete the pointer:</p>

<pre><code>~z(){ for( auto it=hold.begin();it!=hold.end() ++it ) delete(*it); };
</code></pre>

<p>When it comes time for the second <code>z</code> to be destroyed, it will try to <code>delete</code> the same pointer a second time.  This results in Undefined Behavior.</p>

<p>The solution to this problem is to make deep copies when you assign or copy objects that maintain resources that need to be allocated and deleted.  That means providing an assignment operator and a copy constructor.</p>

<p>That is why the rule of three is a RULE.</p>

<p>EDIT:</p>

<p>As others have mentioned, this is all better avoided altogether by using value semantics and RAII.  Reengineering your objects to use the Rule of Zero, as others have called it, is a much better approach.</p>
",0
11527756,11527528,10,"<p>C++ distinguishes between declaration and definition of functions and classes. In general a C++ header file contain the declaration of a class. Since no partial declarations are allowed the header file needs to contain the complete class declaration including all private members (variables and member functions).</p>

<p>If you want to hide the complete implementation from the public you can use the <a href=""http://c2.com/cgi/wiki?PimplIdiom"" rel=""noreferrer"">pimpl idiom</a> to achieve this.</p>
",0
11527759,11527528,12,"<p>The primary functional purpose of C++ header files is that in the C++ language there aren't module imports or anything similar that exist in other languages. The only way for the compiler to know about types, functions, etc from other files is to paste the code into the current source file by using <code>#include</code>.</p>

<p>Theoretically you could put all your source code into the header as well and just have one source file that includes all the headers. The reason this isn't usually done is twofold. First, it would take longer to compile (a significant concern on some projects) and any change to any file would result in a complete recompilation of the project. Secondly, putting the implementation into a source file does in fact help separate the interface from the implementation, even if a portion of the implementation is still specified in the header file.</p>

<p>Note that inline methods in headers also walk a fine line of implementation detail exposed to the public/clients of your class.</p>

<p>If you really wish to completely separate the interface from the implementation (which has definite merit) the C++ way to do so is to utilize the pimpl idiom. Using that idiom all the private data is hidden away in the source file and only an abstract interface is provided to the public. Additionally using the non-virtual interface (NVI) pattern can further help isolate clients from interface changes.</p>
",0
11527779,11527528,0,"<p>In C/C++, one purpose of header files is to allow multiple translation units to use types with the same definition without duplicating the definition across multiple files. Part of the definition of a class is its private members.</p>
",0
11527827,11527528,7,"<p>The purpose of header files are to give the compiler the information it needs to share definitions between compilation units (.cpp source files). It's a mechanical thing, not a philosophy thing.</p>

<p>For example, private member variables need to be declared because they define the size of an object, and the compiler needs to know the size when it allocates an object.</p>
",5
17842383,17842215,0,"<p>You cannot call the variable initialization outside a function. As mentioned in a comment</p>

<pre><code>test.a=1
test.b=2
</code></pre>

<p>is thus invalid. If you really need an initialization, use a constructor like</p>

<pre><code>class foo
{
public:
    foo(const int a, const int b);

    int a;
    int b;
}
</code></pre>

<p>Otherwise you could put the initialization e.g. into the main function.</p>
",0
17842258,17842215,3,"<p>It's called a constructor. Include one that takes the wanted values as arguments.</p>

<p>Like</p>

<pre><code>class foo
{
public:
    foo(int aa, int bb)
        : a(aa), b(bb)  // Initializer list, set the member variables
        {}

private:
    int a, b;
};

foo test(1, 2);
</code></pre>

<hr>

<p>As noted by chris, you can also use aggregate initialization if the fields are <code>public</code>, like in your example:</p>

<pre><code>foo test = { 1, 2 };
</code></pre>

<p>This also works in C++11 compatible compilers with the constructor as in my example.</p>
",2
17842290,17842215,1,"<p>This should be:</p>

<pre><code>class foo
{
  public:
    int a; 
    int b;
};

foo test;
int main()
{
  test.a=1;
  test.b=2;
}
</code></pre>

<p>You can not write code outside of a method/function, you can only declare variables/classes/types, etc.</p>
",1
17842320,17842215,0,"<p>You need a default constructor:</p>

<pre><code>//add this
foo(): a(0), b(0) { };
//maybe a deconstructor, depending on your compiler
~foo() { };
</code></pre>
",1
10778982,10778962,1,"<p>Change:</p>

<pre><code>int i=0;
int sum=0;
for(i;i&lt;Max;i+Base)
{
   sum=i+sum;
};
</code></pre>

<p>To:</p>

<pre><code>int sum = 0;
for (int i = 0; i &lt; Max; i += Base)
{
  sum += i;
}
</code></pre>

<p>Note that the first statement in the original <code>for</code> loop does nothing, that the value of <code>i</code> must be incremented (which is accomplished most simply with the <code>+=</code> operator), and that the semicolon after the closing brace is unnecessary.</p>

<p>It's customary in C++ to declare a loop variable in the loop itself, to limit its scope and emphasize its purpose as a counter.</p>
",0
10778985,10778962,1,"<p>You have an extra Brace } at the end and you are not incrementing i</p>
",0
10779003,10778962,0,"<p>Change the </p>

<pre><code>for(i;i&lt;Max;i+Base)
        {
            sum=i+sum;
        };
    cout&lt;&lt;""The sum""&lt;&lt;sum;
</code></pre>

<p>into </p>

<pre><code>for(i;i&lt;Max;i=i+Base)
        {
            sum=i+sum;
        };
    cout&lt;&lt;""The sum""&lt;&lt;sum;
</code></pre>

<p>or </p>

<pre><code>for(i;i&lt;Max;i+=Base)
        {
            sum=i+sum;
        };
    cout&lt;&lt;""The sum""&lt;&lt;sum;
</code></pre>

<p>The above code will increment the counter i and display the necessary result </p>
",0
10778969,10778962,6,"<p>You missed to increment the <em>i</em>,</p>

<pre><code>for(i;i&lt;Max;i=i+Base)
{
..
}
</code></pre>

<p>Or</p>

<pre><code>for(i;i&lt;Max;i+=Base)
 {
  ..
 }
</code></pre>
",1
10779105,10778962,0,"<p>Also you aren't going to get the answer with that function. problem 1 is looking for the sum of all multiples of 3 or 5 from [1..999] </p>

<p>try this </p>

<pre><code>for ( int i = 1; i &lt; Max ; i++ ) 
    sum += ((i % 3 &amp;&amp; i % 5) ? 0 : i ; 
return sum
</code></pre>
",0
12868483,12868421,0,"<p>Since this looks like homework here are a few basic hints.</p>

<p>You can direct the output of one command as the input of another using pipes like:</p>

<pre><code>cat myfile.txt | myprogram
</code></pre>

<p><code>myprogram</code> can then read the data using <code>cin</code>.</p>

<p>That should be enough to get your started.  </p>
",0
12869088,12868421,0,"<pre><code>static const size_t START_SIZE = 100;

//allocate array of pointers
double** flt_arr = new double*[START_SIZE];

size_t current_size = START_SIZE;
size_t current_index = 0;

while (!cin.eof())
{
    double flt1, flt2, flt3;

    cin &gt;&gt; flt1 &gt;&gt; flt2 &gt;&gt; flt3;

    //check stream for bad read
    if (cin.fail())
    {
        cerr &lt;&lt; ""Input error on line "" &lt;&lt; current_index + 1 &lt;&lt; ""!"" &lt;&lt; endl;
        break;
    }

    if (current_size == current_index)
    {
        //grow array
        current_size += START_SIZE;

        double** tmp_arr = new double*[current_size];

        for (size_t count = 0; count &lt; current_index; count++)
        {
            tmp_arr[count] = flt_arr[count];
        }

        delete [] flt_arr;
        flt_arr = tmp_arr;
    }

    //allocate row for current line
    flt_arr[current_index] = new double[3];

    flt_arr[current_index][0] = flt1;
    flt_arr[current_index][1] = flt2;
    flt_arr[current_index][2] = flt3;

    current_index++;
}

//clean up rows
for (size_t count = 0; count &lt; current_index; count++)
{
    delete [] flt_arr[count];
}

//clean up array of pointers
delete [] flt_arr;
</code></pre>
",0
11127532,11127487,2,"<p>There is no bit pattern you can assign to an int that isn't an actual int.  You need to keep separate flags if you really have no integer values that are out of bounds.</p>
",0
11127535,11127487,1,"<p>If the domain of valid <code>int</code> values is unlimited, the only choice is a management bit indicating whether it is assigned or not.</p>

<p>But, are you sure <code>MAX_INT</code> is a desired choice?</p>
",0
11127551,11127487,1,"<p>There is no way to guarantee that a value you assign an int to is not going to be equal to another random int. The only way to assure that what you want to happen occurs, is to create a separate bool to account for changes.</p>
",0
11127555,11127487,1,"<p>No, you will have to create your own data type which contains the information about whether it has been assigned or not.</p>
",0
11127556,11127487,7,"<blockquote>
  <p>I could create a whole object consisting of an bool and a integer as
  members, where the bool indicates whether the number has been assigned
  its own value yet or not. This however seems like an overkill.</p>
</blockquote>

<p>What you described is called a ""<a href=""http://msdn.microsoft.com/en-us/library/1t3y8s4s%28v=vs.110%29.aspx"" rel=""noreferrer"">nullable type</a>"" in .NET. A C++ implementation is <a href=""http://www.boost.org/doc/libs/1_49_0/libs/optional/doc/html/index.html"" rel=""noreferrer"">boost::optional</a>:</p>

<pre><code>boost::optional&lt;int&gt; A;

if (A)
  do_something(*A);
</code></pre>
",1
11127682,11127487,0,"<blockquote>
  <p>I could create a whole object consisting of an bool and a integer as
  members, where the bool indicates whether the number has been assigned
  its own value yet or not. This however seems like an overkill.</p>
</blockquote>

<p>My first guess would be to effectively use a flag and mark each variable. But this is not your only choice of course.</p>

<ol>
<li>You can use pointers (which can be NULL) and assign dynamically the memory. Not very convenient.</li>
<li>You can pick a custom value which is almost never used. You can then define this value to be the default value. Ofc, some time, you will need to assign this value to your floats, but this case won't happen often and you just need to keep track of this variables. Given the occurrence of such case, a simple linked list should do.</li>
</ol>
",0
11127881,11127487,5,"<p>On a two's complement machine there's an integer value that is less useful than the others: <code>INT_MIN</code>. You can't make a valid positive value by negating it. Since it's the least useful value in the integer range, it makes a good choice for a marker value. It also has an easily recognizable hex value, 0x80000000.</p>
",0
11127581,11127487,0,"<p>If as you say, no integer value is off limits, then you cannot assign a default ""uninitialised"" value. Just use a struct with an int and a bool as you suggest in your question.</p>
",0
17810448,17810174,4,"<p>In general the problem is that <strong>objects introduce not only data, but also behaviors</strong>.</p>

<p>By copying the data manually we may break the inherent behavior of the object, which may rely on the copy constructor.</p>

<p>A great example would be any <em>shared</em> or <em>unique pointer</em> - by copying it we break the ""deal"" we made with that class when we used it.</p>

<p>Regardless of the copying process being semantically correct or not, the idea behind doing that is wrong and violates the object programming paradigm.</p>

<p>Sample code:</p>

<pre><code>/** a simple object wrapper around a pthread_mutex
 */
class PThreadMutex
{
   public:
    /** locks the mutex. Will block if mutex is already locked */
    void lock();

    /** unlocks the mutex. undefined behavior if mutex is unlocked */
    void unlock();

   private:
    pthread_mutex_t m_mutex;

};

/** a simple implementation of scoped mutex lock. Acquires and locks a Mutex on creation,
 * unlocks on destruction
 */
class ScopedLock
{
  public:
    /** constructor specifying the mutex object pointer to lock
     * Locks immediately or blocks until lock is free and then locks
     * @param mutex the mutex pointer to lock
     */
    ScopedLock ( PThreadMutex* mutex );

    /** default destructor. Unlocks the mutex */
    ~ScopedLock ();

    /** locks the mutex. Will block if mutex is already locked */
    void unlock();


  private:

    PThreadMutex* m_mutex;

    // flag to determine whether the mutex is locked
    bool m_locked;

    // private copy constructor - disable copying
    ScopedLock(ScopedLock &amp;mutex) { (void)mutex; /* to get rid of warning */ };

};
</code></pre>

<p>If you copy <code>ScopedLock</code> class, manually unlock it, then restore the value and perform another unlock in constructor it will result in an undefined behavior (or at least EPERM error in the destructor).</p>
",3
17810277,17810174,6,"<p>Imagine a class that holds some pointer to a buffer like this:</p>

<pre><code>class Abc {
    public:
    int* data;
    size_t n;
    Abc(size_t n)
    {
        this-&gt;n = n;
        data = new int[n];
    }

    // copy constructor:
    Abc(const Abc&amp; copy_from_me)
    {
        n = copy_from_me.n;
        data = new int[n];
        memcpy(data, copy_from_me.data, n*sizeof(int));
    }
    Abc&amp; operator=(const Abc&amp; copy_from_me)
    {
        n = copy_from_me.n;
        data = new int[n];
        memcpy(data, copy_from_me.data, n*sizeof(int));
        return *this;
    }

    ~Abc()
    {
        delete[] data;
    }
} ;
</code></pre>

<p>If you just memcopy one of its constructed instance, you'll get two instances pointing onto the same buffer <code>data</code>, because they will have the same address of buffer in <code>data</code> pointer. If you modify the data in one instance, it will be modified in the other too.</p>

<p>This means you didn't truly cloned it into two independent classes. Moreover, if you then delete both classes, the buffer would be freed twice from the memory which would crash.
So the class has to have a copy constructor defined and you have to rather copy it using the constructor.</p>
",6
17810307,17810174,17,"<p>Try bit-wise copying <code>std::shared_ptr&lt;&gt;</code>. You might find that your program blows up in your face more often than not.</p>

<p>You'll encounter this problem with any class whose copy constructor does something other than a bit-wise copy. In the case of <code>std::shared_ptr&lt;&gt;</code>, it'll copy the pointer but won't increment the reference count, so you'll end up freeing the shared object and its reference count early, and then blowing up when the copied <code>shared_ptr</code> tries to decrement the freed reference count.</p>

<hr>

<p><em>UPDATE:</em> It was pointed out that this doesn't quite answer the question, which is fair, since I mainly addressed the idea of copying shared_ptr to shared_ptr, not shared_ptr to char[] and back again. However, the principle still holds.</p>

<p>If you bit-wise copy a shared_ptr to a char[], assign a different value to the shared_ptr, then copy the char[] back over, the end result may be to leak one object and double-delete another, i.e., UB.</p>

<p>The same might happen with a POD, but that would be a bug in the program logic. Bit-wise copying back into the POD equivalent of a modified shared_ptr would be perfectly valid as long as the program understands and accommodates such an event. Doing so for a std::shared_ptr generally won't work.</p>
",2
17810312,17810174,1,"<p>Suppose for example that you are writing a <code>String</code> class. Any instance of the class should hold a pointer to some dynamically allocated <code>char</code> array. If you memcopy such an instance, then the two pointers will be equal. Any modification of one string will affect the other one.   </p>
",3
17812002,17810174,1,"<p><strong>C++11 note:</strong> The quote in the question is a rather old version of the rule.  Since C++11, the requirement is <em>trivially copyable</em> which is much weaker than <em>POD</em>.</p>

<hr>

<p><code>memcpy</code> can be used from any object.  You get a bitwise image of the object.</p>

<p>If the object is not POD, then the image cannot be used as if it were the same type as the original object, because the lifetime rules require initialization to complete first.</p>

<p>In such cases, the image is merely a bunch of bytes.  That might still be useful, for example to detect changes in the internal representation of an object over time, but only operations valid on bytes (such as comparison between two images) are legal, and not operations that require an object of the original type.</p>
",2
11872083,11872005,0,"<p>Open the .exe with DependencyWalker on the non-working system. It will show what DLLs are missing (usually some VS2008 Runtime).</p>

<p>Additionally in the Windows event manager under errors you should also get an error description when you tried to run your application, as to what it misses. 
When you know what file you are missing, you can just google it, and check to what Redistributable it goes.</p>
",1
11872114,11872005,0,"<p>You've created a command-line program. When Windows opens this program, it creates a command window for the input and output, and when the program is finished it closes the window immediately.</p>

<p>If you open your own command window and run it from there, the window won't close when the program finishes.</p>

<p>You can add a pause at the end of the program if you still want it to run directly but see the output.</p>

<pre><code>cout &lt;&lt; ""Please type any key to finish"" &lt;&lt; endl;
char ch;
cin &gt;&gt; ch;
</code></pre>
",4
11872675,11872005,0,"<p>Aside from the DependencyWalker tip that others have mentioned (which is worth doing first), I'd also suggest temporary installing the <a href=""http://msdn.microsoft.com/en-us/windows/hardware/gg463009.aspx"" rel=""nofollow"">Debugging Tools for Windows</a> on the target PC (it's only a small install).  Run <code>windbg</code> and choose <code>File -&gt; Open Executable</code> then run with F5.  When the application bombs out you'll get a more meaningful explanation as to where it's going wrong in terms of error messages and call stacks.  My guess would be a missing dll, or maybe a conflict with a different version of a dll than you have on your own system.</p>

<p>Another useful thing you can do with DependencyWalker is to run it on the target PC and choose the <code>Profile</code> option, which will give you lots of information as it's searching for dlls.</p>

<p>Note that both of these methods require you to install something on the target PC, but it's only temporary and without doing it you'll just be guessing as to why it's going wrong.</p>
",1
11872414,11872005,0,"<p>Try visiting the Code Generation property page and make sure Runtime Library reads /MT or  /MTd and nothing else (especially /clr). Do a clean build of the project and make sure the output states /MTd and the IDE isn't injecting any other conflicting flags. I don't have a lot of experience with VS2010, but this is all I've ever needed to do with 2008. </p>
",1
10773456,10773151,0,"<p>Here is your problem. The type of <code>inbox-&gt;messages</code> is <code>const std::vector&lt;Messages&gt; *</code>. If you want to return a reference to the value pointed to by <code>inbox-&gt;messages</code>, simply reference the pointer:</p>

<pre><code>return *inbox-&gt;messages;
</code></pre>

<p>There's no need for <code>const_cast</code> at all, because both the source and destination types are already <code>cosnt</code>.</p>

<p>That being said, your code is using an awful lot of pointers needlessly. Why is <code>inbox</code> a pointer? Why not just a value member? Why is <code>messages</code> a pointer to a <code>std::vector</code> instead of just a value?</p>
",3
10773460,10773151,0,"<p>Your return line should be</p>

<pre><code>return *inbox-&gt;messages;
</code></pre>

<p>Note that you should also be returning something if <code>messageBox != ""inbox""</code>.  This will be somewhat tricky since you can't legally just return a reference to a temporary local.</p>

<p>Your <code>getMessages</code> function might be better to return <code>std::vector&lt;Message&gt;*</code> since that's how it's held in the class, and it would make it clearer to users of the code that they should take the usual precautions when accessing the pointer (i.e. check for <code>nullptr</code>).</p>

<p>Even better would be to get rid of the raw pointer usage altogether.  Favour <code>std::shared_ptr</code> for <code>messages</code> since it's shared between <code>Box</code> and whatever calls <code>getMessages</code>, and favour <code>unique_ptr</code> for <code>Box</code> if its not shared.</p>

<p>You probably don't really need both of these to be pointers, so it would be even simpler to not use pointers at all.  Unless you're expecting the size of <code>messages</code> to be large and/or <code>getMessages</code> to be called very frequently, it's not unreasonable and far safer to just return a copy of <code>messages</code>.</p>
",0
12310083,12310058,5,"<p>Did you include windows.h?</p>

<pre><code>#include &lt;windows.h&gt;
</code></pre>
",0
15897979,15897853,0,"<p>If you are using QtMobility, you could use the <a href=""http://doc.qt.digia.com/qtmobility/qsystemstorageinfo.html"" rel=""nofollow"">QSystemStorageInfo</a> class.</p>
",2
15898115,15897853,0,"<p>I think this will be quite hard to achieve in a reliable and portable way. I'm sure all platforms have SOME way to find out if a drive is local or not, but I would have thought that a much more simple and reliable solution is to create a local temporary file whatever the base filesystem is.</p>
",1
17811344,17810923,2,"<p>The conversion operator you provided is already <em>implicit</em>. The problem you face is that the compiler is seeing two different conversion sequences from <code>B</code> to <code>const A&amp;</code>, the derived-to-base reference and your user provided conversion. There is an ordering on conversions, and the derived-to-base conversion is considered better than any user provided conversion, so your <code>operator const A&amp;() const</code> will not be chosen.</p>

<p>Just make inheritance public. You are trying to build a convoluted design that provides no benefit whatsoever. What do you want to obtain by making inheritance <em>protected</em>? Avoid upcasts? Why are you attempting to provide the same conversion anyway? Do you intend on only allowing half of the interface (the <code>const</code> part)? Then you are not following LSP, since your derived object cannot be used as a base...</p>
",4
17811442,17810923,0,"<p>Obviously, the type conversion operator is defined in B, so it is not available for objects of type A. What you are trying to do is not possible in C++. This is because, the 'this' pointer is a constant pointer.
So, if you try writing the following code within the body of A, it will not work:
<code>A(B* b)
{
this = b;//error, 'this' pointer is a constant pointer.
}</code></p>

<p>In other words, you cannot implicitly make a reference of type A refer to a B type object. At best, you can try a reinterpret cast and see if it works.</p>
",0
17812391,17810923,0,"<p>OK - so I have choosen another design - to use composition instead of inheritance. This way I can define an instance A which is protected</p>

<pre><code>class B {
protected:
  A a;
public
  operator const A&amp;()const { return a; }
};

B b;
const A&amp; a = b;
</code></pre>
",0
16913323,16911866,4,"<p>You need to supply either <code>--enable-stdcall-fixup</code> to the linker (which fixes up the problem automatically). When using with <code>gcc</code> or <code>g++</code>, this means <code>-Wl,--enable-stdcall-fixup</code>. </p>

<p>For details of these options, check section 2.1.1 of <a href=""http://sourceware.org/binutils/docs-2.20/ld/Options.html"" rel=""nofollow"">Gnu Linker options</a>. </p>
",0
11805043,11804844,0,"<p>int myArray[5]={0};
then you can initialize an array to all zeros !! 
just try !!</p>
",0
11804886,11804844,1,"<p>What it means is that the initialization syntax you are using was introduced in C++11. In order to get rid of the warning, you must enable C++11 support in the compiler by passing -std=c++0x.</p>

<p>Also, I think you got your ks and ns mixed up in the code sample. As it is, the outer loop does the same thing over and over.</p>
",0
11545336,11545304,7,"<p><code>Animation</code> is a <code>struct</code> name and can not be used as function name. Just rename:</p>

<pre><code>  Animation* someOtherNameForGettingAnimation(int pIndex);
</code></pre>
",1
11545444,11545304,-3,"<p>This is simply a case of me being extremely foolish.</p>

<p>The problem arises where I define a function with the same interface name as the actual type I have predefined.</p>

<p>This line: </p>

<pre><code>Animation*      Animation           (int pIndex);
</code></pre>

<p>I have clearly, incorrectly, called this function ""Animation"", and to solve the issue I have since named it:</p>

<pre><code>Animation*      GetAnimation            (int pIndex);
</code></pre>

<p>Sorry for wasting anybody's time.</p>
",2
11812032,11812014,13,"<p>Never #include .cpp files; that will lead to the kind of redefinition errors you are getting. Instead, <em>declare</em> the class in a header file and #include that one, and <em>define</em> the class methods in a .cpp file.</p>

<pre><code>// CShape.h
class CShape
{
protected:
    float area;
    virtual void calcArea();
public:
    float getArea();
}
</code></pre>

<p>.cpp file:</p>

<pre><code>// CShape.cpp
#include ""CShape.h""
#include &lt;iostream&gt;
using namespace std;

float CShape::getArea() {
    return area;
}
</code></pre>

<p>You should split up CCircle similarly - and CCircle.h should #include CShape.h, and CCircle.cpp should #include CCircle.h.</p>
",3
11812120,11812014,5,"<p>As you guessed, you should organize your classes in separate files for declaration (header file) and definition (.cpp file).
You may leave member function definitions (with body) as (suggested) inline in the header files.
Put appropriate include blockers into your header files, to avoid multiple class declarations.</p>

<p><strong>CShape.h:</strong></p>

<pre><code>#ifndef __CSHAPE_H__
#define __CSHAPE_H__
class CShape
{
protected:
    float area;
    virtual void calcArea();
public:
    float getArea()
    {
        return area;
    }
};
#endif
</code></pre>

<p><strong>CShape.cpp:</strong></p>

<pre><code>#include ""CShape.h""

void CShape::calcArea()
{
    // Your implementation
}
</code></pre>

<p><strong>CCircle.h:</strong></p>

<pre><code>#ifndef __CCIRCLE_H__
#define __CCIRCLE_H__
#include ""CShape.h""

class CCircle : public CShape
{
protected:
    int centerX;
    int centerY;
    float radius;
    virtual void calcArea();
    {
        area = M_PI * (radius * radius);
    }
public:
     CCircle(int pCenterX, int pCenterY, float pRadius);
     inline float getRadius()
     {
         return radius;
     }
};
#endif
</code></pre>

<p><strong>CCircle.cpp:</strong></p>

<pre><code>#include ""CCircle.h""

CCircle::CCircle(int pCenterX, int pCenterY, float pRadius)
: centerX(pCenterX)
, centerY(pCenterY)
, radius(pRadius)
{
}
</code></pre>
",0
16930727,16930490,1,"<p>Error 1 means the compiler sees the line of code as a function declaration without a return type. Maybe you meant</p>

<pre><code>ISBN::ISNB(...);
</code></pre>

<p>or</p>

<pre><code>void ISBN(...);
</code></pre>
",0
16930509,16930490,0,"<p>Have you included the other file with <code>#include ""otherfile.h""</code> ?</p>
",0
16930583,16930490,1,"<p>Forward declaration was needed.</p>

<pre><code>class ISBNPrefix;
class ISBN 
{
 etc, etc.
};
</code></pre>
",0
11526414,11526297,3,"<p>The default inheritance for <code>class</code> is <code>private</code>:</p>

<pre><code>class ConstComponent : Component
</code></pre>

<p>For all subclasses of <code>Component</code> you need <code>public</code> inheritance:</p>

<pre><code>class ConstComponent : public Component
</code></pre>

<p>if you are attempting to insert <code>new</code> instances of the subclasses into the <code>std::vector&lt;Component*&gt;</code> (which I <em>think</em> you are).
<code>private</code> inheritance is not an <code>is-a</code> relationship, but is a <code>has-a</code> relationship. See <a href=""http://www.parashift.com/c++-faq/priv-inherit-like-compos.html"" rel=""nofollow"">How are ""private inheritance"" and ""composition"" similar? </a>.</p>
",1
16434556,16434189,0,"<p>You can improve <code>ReadWStringFromCompiledDat</code> method with no memory allocation and memory initialization:</p>

<pre><code>wchar_t * pBuffer = NULL;
pBuffer = new wchar_t[len+1];
memset(pBuffer, 0, (len+1)*sizeof(wchar_t));
fread(pBuffer, sizeof(wchar_t), len, m_infile);
</code></pre>

<p>may be changed by:</p>

<pre><code>wchar_t pBuffer[len+1];
fread(pBuffer, sizeof(wchar_t), len, m_infile);
pBuffer[len] = 0;
</code></pre>

<p>With this new way, you don't overload this method with memory allocations.</p>
",2
16434567,16434189,0,"<p>In theory yes, but it requires a completely different way to structure the data and it risk to make your code ""platform dependent"".</p>

<p>let me give you some more ""hint"":</p>

<ul>
<li><p>Although we have no idea about how <code>ReadWString...</code> are implemented, think about how strings are wrote: if they may have a variable length, there is no way to make it in ""one rush"", since you have to know when a string ends, before you can read the following one.</p></li>
<li><p>If you can store all your data to be read/written in a statically defined non-polymorphic data structure like</p>

<p><code>struct
{
   /* only plain types and statically sized arrays here */;
};</code> </p></li>
</ul>

<p>you can fread / fwrite the entire strut (no matter how big) in one shot but yo uahve to take care about the struct member alignment (that are compiler and platform dependent) if you want your data to be readable by different type of machines.</p>

<p>But before afford ""random optimization"", try to profile your code after compiling it with all optimization enabled. How much of the ""slowness"" is due to processing and how much from IO waiting? </p>

<p>If the problem is I/O, you can read the entire file in a row buffer and then process the data from the buffer. If the problem is processing, then you have necessarily to rethink the way data are represented and the what the data structure is stored.</p>
",0
16434574,16434189,2,"<p>It is possible to write the memory image of a <a href=""http://en.wikipedia.org/wiki/Plain_old_data_structure"" rel=""nofollow"">POD</a> to the file and then read it back in (<code>fread(pMyPod, sizeof(*pMyPod), 1, pFile);</code>).<br>
However, this is very limited: the memory image is not standardized, so it could even change when switching versions of a compiler and there is a big chance that it changes when switching platforms.<br>
Also, changing the class makes the file useless.</p>

<p>When serializing (to disk), there are many things to consider.  I don't think speed should be a main issue.</p>
",0
11095337,11095291,2,"<pre><code>while (cin&gt;&gt;x) 
{
    words.push_back(x);
}
</code></pre>

<p>Here, you're reading until failure.  So, when this loop finishes, cin is in an error state.  You need to clear the error state:</p>

<pre><code>cin.clear();
</code></pre>
",1
11095366,11095291,1,"<p><a href=""http://www.cplusplus.com/forum/articles/6046/"" rel=""nofollow"">http://www.cplusplus.com/forum/articles/6046/</a></p>

<p>Read this as an example and probable issues !! </p>
",0
11095391,11095291,3,"<p>The program reads the word list until end of file.  So, at a terminal, you can type the EOF character (<kbd>Ctrl-D</kbd> on Linux, <kbd>Ctrl-Z</kbd> <kbd>Return</kbd> on Windows), but what then?</p>

<p>I think after resetting the stream, a terminal will continue to read.  But if the program is taking input from a disk file, pipe, etc., there is no hope.  End-of-file is forever.</p>

<p>Instead, use some sort of sentinel, or prefix it by a count.  That way the first loop can run until the logical end of the list.  And then it can read the word intended for the summary logic.</p>

<pre><code>while (cin&gt;&gt;x  &amp;&amp;  x != '*')   // The word ""*"" ends the list of words
   {
     words.push_back(x);
   }
   size=words.size();

   //now compare
   cout&lt;&lt;""enter your word:""&lt;&lt;endl;
</code></pre>
",2
11518510,11518488,0,"<p>In the first iteration:</p>

<pre><code>first = first-&gt;next;
</code></pre>

<p>you assign <code>first</code> to <code>NULL</code>, because that's what <code>first-&gt;next</code> is initially. You need to allocate space for it before the assignment.</p>

<pre><code>first-&gt;next = new polynomial;
first = first-&gt;next;
</code></pre>

<p>Also, are you sure you want to lose the pointer to the first node?</p>
",1
11518523,11518488,0,"<p>You didn't allocate memory for the whole list.
You need to write something like this:<br>
<code>first-&gt;next = new polynomial();<br>
first = first-&gt;next;</code></p>

<p>Otherwise, you're trying to read memory at <code>NULL</code> address.</p>
",0
11518532,11518488,0,"<p>Instead, you should do:</p>

<pre><code>second = new(polynomial);
first-&gt;next=second;
first=second;
</code></pre>
",0
11518555,11518488,0,"<pre><code>first = first-&gt;next;
</code></pre>

<p>Before this operation you must allocate a memory for a new link such as</p>

<pre><code>first-&gt;next = new polynomial();
</code></pre>

<p>and only after that you can write</p>

<pre><code>first = first-&gt;next;
</code></pre>
",0
15582649,15581211,1,"<p>Your bug is in your height method.  If you have a node which is not null but has no children, you are returning zero.  You should be returning 1.</p>

<p>Change this condition in your height method from:</p>

<pre><code>if (node == NULL || ((node-&gt;left == NULL) &amp;&amp; (node-&gt;right == NULL))) {
    return 0;
}
</code></pre>

<p>to:</p>

<pre><code>if (node == NULL) {
    return 0;
}
</code></pre>
",0
15581277,15581211,0,"<p>It appears the sign of your vector <code>A</code> is backwards. You have <code>1,-2,3,-4,...</code> but the correct solution has <code>-1,2,-3,4,...</code>. Similarly, you <code>B</code> is</p>

<pre><code>const vector&lt;float&gt; B { 0.5, 1.75, -3, 4.25, 5.50, -6.75, 8, 9.25, -10.5 };
</code></pre>

<p>Comparing this with the elements you say we are expecting:</p>

<pre><code>7, 3.25, 0.75, -7.75, -0.5, -11.5, 4.5, -4, 8.25
</code></pre>

<p>These don't look even close to identical.</p>

<p>Transcription error somewhere?</p>
",2
15582096,15581211,0,"<p>What is your height() function ?</p>

<p>I think you misunderstand the definition of the BST:</p>

<pre><code>A. the value of the left child is smaller than the value of root node.

B. the value of the right child is bigger than the value of root node.

C. his left child tree and right child tree are also a BST.
</code></pre>

<p>But through your code here:</p>

<pre><code>while(ptr1 != NULL) {
            ptr2 = ptr1;
            if(height(ptr1-&gt;left) &gt; height(ptr1-&gt;right)) {
                    placeRight = true;
                    ptr1 = ptr1-&gt;right;
            } else if (height(ptr1-&gt;right) &gt; height(ptr1-&gt;left)) {
                    placeRight = false;
                    ptr1 = ptr1-&gt;left;
            } else {
                    placeRight = false;
                    ptr1 = ptr1-&gt;left;
            }
    }
</code></pre>

<p>you just compare the height of your node instead of comparing the real value of the node.</p>
",1
11544279,11544053,0,"<p>here: run this program</p>

<pre><code>#include &lt;iostream.h&gt;
#include &lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;

int main()
{
    int x;
    int g;
    cin&gt;&gt;x;
    cin&gt;&gt;g;

    while(x&gt;g)
    {
        cout&lt;&lt;x%g&lt;&lt;endl;
        x/=g;
    }
            cout&lt;&lt;x%g&lt;&lt;endl;

    return 0;
    }
</code></pre>

<p>works for 105 and 2 and does not need an array</p>
",6
11545065,11544053,0,"<p>The <code>^</code> doesn't do exponentiation. It's the exclusive-or operator. To do exponentiation, use the <a href=""http://en.cppreference.com/w/cpp/numeric/math/pow"" rel=""nofollow""><code>pow</code></a> function.</p>

<pre><code>e=x/std::pow(double(g),double(k-b-1));
myArray[b]=e;
x=x-e*std::pow(double(g),double(k-b-1));
</code></pre>

<p><a href=""http://ideone.com/48BLv"" rel=""nofollow"">You can see your program in action, with my changes, on IDE One.</a></p>
",1
11158234,11158140,1,"<p>You aren't actually assigning to <code>position</code>.  You are making a temporary <code>Vector2</code> object, assigning to it, then implicitly copying it and returning the copy.  You are never modifying the actual object.</p>

<p>You need something like:</p>

<pre><code>Vector2&amp; Vector2::operator=(const Vector2 &amp;right)
{
    x = right.x;
    y = right.y;
    return *this;
}
</code></pre>
",0
11158181,11158140,14,"<p>Your <code>operator=()</code> is wrong, it should modify the current object, not the extra you create</p>

<pre><code>Vector2&amp; Vector2::operator=(const Vector2 &amp;right) 
{
  x = right.x; 
  y = right.y; 
  return *this; 
}
</code></pre>

<p><em>Note</em>: the return type is a reference and you are returning the reference to the current object, not a copy of it (or of a new one like in your code).</p>

<p>The reason it worked for </p>

<pre><code>Vector2 newPosition = ...;
</code></pre>

<p>is because this is not <em>default-construct + assignment</em> but a <em>copy-construct</em> call.</p>
",1
16945772,16945465,4,"<p>The key to remember is that constructors for virtual base classes are done as part of the most derived class initialization (and prior to the other base classes being constructed).  So your construction order slide is not correct.  </p>

<p>In fact, what is happening when you construct the ProtocolConnection is that it first constructs the Socket, followed by the Connection (since you inherited it virtually), and finally the ProtcolSocket.</p>

<p>To call the constructor of socket you want, you need to call its constructor as part of the ProtocolSocket member initializer list, as so</p>

<pre><code>class ProtocolConnection: public ProtocolSocket, public virtual Connection
{
    public:
    ProtocolConnection(int s, int ip) :
        Socket(s), Connection(ip), ProtocolSocket(s)  
        // Note, also reordered, since all virtual bases are initialized before the
        // non-virtual bases
    {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;
    }
};
</code></pre>

<p>Finally, as a note, I would recommend simplifying your inheritance hierarchy.  In particular, virtual inheritance and using multiple constructors complicates factors.</p>
",1
16946035,16945465,2,"<p>Inheritance DAG:</p>

<pre><code>       ProtocolConnection
           /        \
     non-virtual  virtual
         /            \
ProtocolSocket     Connection
       |               |
    virtual         virtual
       |               |
    Socket           Socket
</code></pre>

<p>Note there's only one <code>Socket</code> subobject in an object of type <code>ProtocolConnection</code> due to virtual inheritance.</p>

<p>[class.base.init]/10</p>

<blockquote>
  <p>First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where ¡°left-to-right¡± is the order of appearance of the base classes in the derived class base-specifier-list.</p>
</blockquote>

<p>Initialization of virtual base classes is done via a depth-first left-to right traversal. The traversal order:</p>

<pre><code>       (0) ProtocolConnection
             /             \
           nv               v
           /                 \
(1) ProtocolSocket    (3) Connection
         |                   |
         v                   nv
         |                   |
    (2) Socket         (4) Socket
</code></pre>

<p>Leads to an initialization order of:</p>

<p>(2); (3); (1); (0)<br />
<code>Socket</code>; <code>Connection</code>; <code>ProtocolSocket</code> (non-virtual base class); <code>ProtocolConnection</code></p>

<p>The most-derived class <code>ProtocolConnection</code> has to include the initalizers for <strong>all</strong> <em>virtual base classes</em>. If a virtual base class does not appear in the mem-initializer-list of the most-derived class, the subobject of this virtual base class will be default-constructed.</p>
",0
10763922,10763909,4,"<p>Use a vector and let it grow to the size you need.  Just <code>push_back()</code> the new rolls.</p>
",2
10763926,10763909,0,"<p>You can simply eliminate the array. You never access the values in the array outside of the loop, so you can replace it with a local variable.</p>

<p>Create a variable <code>int currentRoll</code> at the start and replace all occurances of <code>diceValues[i]</code> with currentRoll.</p>
",5
10744007,10743982,1,"<p>It appears you have unimplemented <code>virtual</code> methods.</p>

<pre><code>class PubSub
{
    //virtual destructors, although pure
    //MUST have an implementation
    virtual ~PubSub() = 0 { } 

    /*virtual?*/ void Run(); // &lt;--- have you implemented this one?
}; 
</code></pre>
",4
10744338,10743982,0,"<p>this is an error message from the <em>linker</em>, not the compiler. The linker cannot find some symbols which are declared, but not defined, in some files it tries to link together to make (most likely) an executable. The solution is to provide the definitions, i.e. the (compiled) code with those definitions. That code may already exist and you just have to ""link against it"" (tell the linker to search for symbols there) or may not, in which case you have to provide it...</p>

<p>for example, add the file defining the implementations of class <code>PubSub</code> to the linker/compiler command line should help ...</p>
",0
10744800,10743982,0,"<p>Maybe you've implemented the method, but you have not linked it. If you're using GCC, <em>-o</em> flag is your friend; all your class .o files must be specified when compiling the main.cpp.</p>
",0
10807706,10807681,2,"<p>Use <code>sleep()</code> : <a href=""http://www.gnu.org/software/libc/manual/html_node/Sleeping.html"" rel=""nofollow"">http://www.gnu.org/software/libc/manual/html_node/Sleeping.html</a></p>

<pre><code>int count = 0;
while(true)
{
    count++;

    cout &lt;&lt; count &lt;&lt; endl; // print every 10 second 
    sleep(10);

}
</code></pre>
",4
10807745,10807681,4,"<p>On Windows, you can use <code>Sleep</code> from <code>windows.h</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;windows.h&gt;


int _tmain(int argc, _TCHAR* argv[])
{
    int count = 0;
    while(true)
    {
        count +=1;
        std::cout &lt;&lt; count  &lt;&lt; std::endl;
        Sleep(10000);
    }
}
</code></pre>
",1
10807759,10807681,1,"<p>As others have said, you want a sleep() function. Cross-platform issues can come up though. I found <a href=""https://stackoverflow.com/questions/6134679/delaying-for-milliseconds-in-c-cross-platform"">this thread</a> about that issue, which you may want to look at.</p>
",0
10807811,10807681,11,"<p>My try. (Almost) perfectly POSIX. Works on both POSIX and MSVC/Win32 also.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

const int NUM_SECONDS = 10;

int main()
{
    int count = 1;

    double time_counter = 0;

    clock_t this_time = clock();
    clock_t last_time = this_time;

    printf(""Gran = %ld\n"", NUM_SECONDS * CLOCKS_PER_SEC);

    while(true)
    {
        this_time = clock();

        time_counter += (double)(this_time - last_time);

        last_time = this_time;

        if(time_counter &gt; (double)(NUM_SECONDS * CLOCKS_PER_SEC))
        {
            time_counter -= (double)(NUM_SECONDS * CLOCKS_PER_SEC);
            printf(""%d\n"", count);
            count++;
        }

        printf(""DebugTime = %f\n"", time_counter);
    }

    return 0;
}
</code></pre>

<p>This way you can also have the control on each iteration, unlike the sleep()-based approach.</p>

<p>This solution (or the same based on high-precision timer) also ensures that there is no error accumulation in timing.</p>

<p>EDIT:  OSX stuff, if all else fails</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

const int NUM_SECONDS = 10;

int main()
{
    int i;
    int count = 1;
    for(;;)
    {
        // delay for 10 seconds
        for(i = 0 ; i &lt; NUM_SECONDS ; i++) { usleep(1000 * 1000); }
        // print
        printf(""%d\n"", count++);
    }
    return 0;
}
</code></pre>
",10
13407246,13407205,6,"<p>If you can't rename your own member function, you can employ a dirty trick:</p>

<pre><code>static inline int dirty_trick(C const &amp; c)
{
    return size(c);
}

void B::doSomething(C const &amp; c)
{
    int x = dirty_trick(c);

    // ...
}
</code></pre>
",8
14733930,14733705,2,"<p>First, you will need to allocate the code as executable [using VirtualAlloc with ""executable"" flag in Windows, and mmap using ""MAP_EXECUTABLE"" as one of the flags]. It's probably a lot easier to allocate a large region of this kind of memory, and then have a ""allocation function"" for your content. You could possibly use virtualprotect and whatever the corresponding function is in Linux, but I'd say that allocating as executable in the first place is a better choice. I don't believe you need to flush instruction cache it the memory is already allocated as executable - certainly not on x86 at least - and since your instructions are x86 instructions, I guess that's a fair limitation. </p>

<p>Second, you'll need to make something like a function pointer to your code. SOmething like this should do it:</p>

<pre><code>typedef void (*funcptr)(void); 

funcptr f = reinterpret_cast&lt;funcptr&gt;(&amp;code_[0]); 
</code></pre>

<p>should do the trick.</p>
",2
12273975,12273949,1,"<p>Because TIMESTAMP_STRUCT is not part of the C++ standard.</p>
",0
12273991,12273949,5,"<p><code>TIMESTAMP_STRUCT</code> is something defined in sqlext.h</p>

<p>You must add</p>

<pre><code>#include &lt;sqlext.h&gt;
</code></pre>
",0
13772915,13772899,0,"<p>Arrays are passed by reference by default in c++ being adjusted to a pointer to the first element of the array.</p>
",1
13772920,13772899,3,"<p>Pretty simple really: when you use array notation for a parameter in C or C++, it's silently adjusted by the compiler to actually pass a pointer.</p>

<p>IOW, your function is really:</p>

<pre><code>void revalue(int r, int *ar, int n)
</code></pre>

<p>...and from there, most of it is pretty clear.</p>
",0
13772926,13772899,3,"<p>I guess, the confusion is with <code>int ar[]</code> which, in this context, is equivalent to writing <code>int* ar</code>: In C++ you cannot pass built-in arrays by value. However, they easily decay into pointers and the above is an alternative notation. Note that you could have used <code>int ar[10]</code> or <code>int ar[20]</code> and it would have been identical, too.</p>
",0
10819888,10819800,1,"<p>Typically <a href=""http://www.boost.org/doc/libs/1_49_0/libs/filesystem/v3/doc/index.htm"" rel=""nofollow""><code>boost.filesystem</code></a> to iterate through the file names.</p>

<p>Though many people wouldn't approve, extracting the ordinals may be easiest with <code>sscanf</code>, something like: <code>sscanf(filename, ""SUFFIX_%d.xml"", &amp;ordinal);</code></p>

<p>If you prefer to avoid <code>sscanf</code> (hard to blame you), it's still fairly easy with something like a <code>stringstream</code>:</p>

<pre><code>std::stringstream buffer(filename);

buffer.ignore(100, '_');
buffer &gt;&gt; ordinal;
</code></pre>
",0
11056064,11056017,5,"<pre><code>A.insert(B.begin(), B.end());      // done
</code></pre>
",0
11056068,11056017,4,"<p>You can use another overload of <code>insert</code> which takes a pair of iterators as:</p>

<pre><code>A.insert(B.begin(), B.end());
</code></pre>

<p>The above code copies the elements (which do <strong>not</strong> exist in <code>A</code>) from <code>B</code> to <code>A</code> (which means you don't need to handle the duplicates manually).</p>

<p>Have a look at all the overloads of <code>insert</code> here:</p>

<ul>
<li><a href=""http://en.cppreference.com/w/cpp/container/set/insert"" rel=""nofollow"">All overloads of std::set::insert</a></li>
</ul>
",2
11056079,11056017,4,"<p>Use</p>

<pre><code>template &lt;class InputIterator&gt;
void std::set::insert( InputIterator first, InputIterator last );
</code></pre>
",0
11056086,11056017,9,"<p>By default sets are unique values only and sorted so inserting the iterator range should work:</p>

<pre><code>A.insert(B.begin(), B.end());
</code></pre>
",4
11048673,11048615,0,"<p>There's no function body for <code>~library_card();</code>. Just remove that destructor, or populate it, whichever you like.</p>

<p>Whilst you're there, have a read about <a href=""http://www.parashift.com/c++-faq-lite/virtual-functions.html#faq-20.7"" rel=""nofollow"">virtual destructors</a>, and consider whether your classes need them.</p>
",0
11048650,11048615,7,"<p>Replace</p>

<pre><code>~library_card();
</code></pre>

<p>with</p>

<pre><code>~library_card() {}
</code></pre>

<p>You haven't implemented the destructor and this is exactly what your linker is saying.</p>

<p>Or you can remove this string as well if you don't know why you need this destructor.</p>
",1
16909201,16909164,3,"<p>The short answer is that <code>ptr_DetourPoint</code> declares a global function pointer, another piece of data like <code>Module</code>.  To fix it, you could mark it as ""extern"" as well.  But I doubt you need to expose it in your header, as it appears to just be an implementation detail in <code>header.cpp</code>.</p>
",0
16909211,16909164,3,"<p>The variable is defined in the header, which means that any source file that includes it defines that symbol. The result is that linking main.cpp and Header.cpp together defines ptr_DetourPoint twice. You need to define it in only one source file, and declare it as extern in a header if other files need to see it.</p>
",2
11051092,11051052,5,"<p><code>array[1]</code> <em>is</em> the second member. Your problem is however that you are reopening the file every time in your loop:</p>

<pre><code>for (int i=0; i&lt;N; i++){
    ifstream ifs(""reals.txt"");
    ifs&gt;&gt;array[i];
}
</code></pre>

<p>you need to open the file before the loop:</p>

<pre><code>ifstream ifs(""reals.txt"");
for (int i=0; i&lt;N; i++){
    ifs&gt;&gt;array[i];
}
</code></pre>
",3
11051094,11051052,0,"<p>Yes this is correct as arrays are <code>0</code> based. For example with an array of <code>5 elements</code> the last element would be <code>index 4 or array[4];</code></p>
",0
11051106,11051052,1,"<pre><code>for (int i=0; i&lt;N; i++){
    ifstream ifs(""reals.txt"");
    ifs&gt;&gt;array[i];
}
</code></pre>

<p>Should be </p>

<pre><code>ifstream ifs(""reals.txt"");
for (int i=0; i&lt;N; i++){        
    ifs&gt;&gt;array[i];
}
</code></pre>

<blockquote>
  <p>if(array[i] != array[1])   /// is this right? is array[1] second
  member?</p>
</blockquote>

<p>The answer is yes.</p>

<blockquote>
  <p>array = new int[N];</p>
</blockquote>

<p>don't forget to</p>

<pre><code>delete[] array;
</code></pre>

<p>If you want to access the prelast element, there is a drop-in replacement in the standard library for your array:</p>

<pre><code>#include &lt;vector&gt;

int main(){
  std::vector&lt;int&gt; array(1000);
  array[998]= 42;
  int prelast= *(array.end()- 2); // end() is an iterator to one-past the last element
}
</code></pre>
",2
17831966,17831882,0,"<p>You have to manually maintain an array of string ""descriptions"" of the enum values, which is tedious and error-prone:</p>

<pre><code>static const char *daydescs[] = {
    ""sunday"", ""monday"", ""tuesday"", ""wednesday"", ""thursday"", ""friday"", ""saturday""
};

int main()
{
    enum day{sunday,monday,tuesday,wednesday,thursday,friday,saturday};
    day d=wednesday;
    cout&lt;&lt; daydescs[(unsigned)d];
    return 0;
}
</code></pre>
",0
17831991,17831882,0,"<p>An enum is a number, the string representation (e.g. wednesday) is a compile time representation.</p>

<p>You would need something like:</p>

<pre><code>const char *dayname[] = {""sunday"",""monday"",""tuesday"",""wednesday"",""thursday"",""friday"",""saturday""};

...
cout &lt;&lt; dayname[(unsigned)d];
...
</code></pre>
",1
17831992,17831882,0,"<p>Try code below : </p>

<pre><code>int main()
{
    enum day{sunday,monday,tuesday,wednesday,thursday,friday,saturday};
    String days[7] = {""sunday"",""monday"",""tuesday"",""wednesday"",""thursday"",""friday"",""saturday""};
    day d=wednesday;
    cout&lt;&lt;days[d];
    return 0;
}
</code></pre>
",1
17832006,17831882,0,"<p>1) If you only want the integer value, you can write an <code>operator &lt;&lt;</code> overload:</p>

<pre><code>template&lt;typename _stream&gt;
_stream&amp; operator &lt;&lt; (const day&amp; value) {
  _stream &lt;&lt; static_cast&lt;int&gt;(value);
  return _stream;
}
</code></pre>

<p>Also, consider using <strong>enum class</strong> instead of a plain <strong>enum</strong> (if you are allowed to use C++11, of course).</p>

<p>2) I would say there could be 1 such case: namespace constants, say you have a <code>Person</code> class and want to have some in-class constants like <code>MaxAge</code> or <code>MaxNameLength</code>. But even in such cases, wrapping restrictions in something like <code>enum class Settings</code> is usually worth it.</p>
",0
17832025,17831882,8,"<p>1). Your code prints the value of the enum, not the index. In your specific example, the index is the same as the value (by default, the first value of an enum gets the numerical value 0, and the rest get consecutive increasing values.</p>

<p>To check:</p>

<pre><code>int main()
{
    enum day{sunday = 5,monday,tuesday,wednesday,thursday,friday,saturday};
    day d=wednesday;
    cout&lt;&lt;d; // will print 8 (as in 5 + 1 + 1 + 1)
    return 0;
}
</code></pre>

<p>If by ""print the value"" you meant printing ""wednesday"", you should do this:</p>

<pre><code>enum day{sunday,monday,tuesday,wednesday,thursday,friday,saturday};

std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const day d)
{
    static const char *as_strings[] = {""sunday"", ""monday"",
        ""tuesday"", ""wednesday"", ""thursday"", ""friday"", ""saturday""
    };
    return out &lt;&lt; as_strings[static_cast&lt;int&gt;(d)]; // this only works 
                 // for enum values starting from 0 and being consecutive
                 // otherwise you should use a switch(d) and 
                 // print each value separately
}

int main()
{
    day d=wednesday;
    cout&lt;&lt;d; // will print wednesday
    return 0;
}
</code></pre>

<p>Edit:</p>

<blockquote>
  <p>2) In what situation will I prefer anonymous enum over enum</p>
</blockquote>

<p>You prefer an anonymous enum when you do not need to pass it as a parameter, but need to assign meaningful names to constant numeric values:</p>

<pre><code>my_object record_to_myobject(record&amp; r)
{
    enum {id, value1, value2}; // indexes within record
    int result_id = r[id]; // much more meaningful than r[0]
    int result_value1 = r[value1];
    int result_value2 = r[value2];
    return my_object{result_id, result_value1, result_value2};
}
</code></pre>

<p>It's fine to use an anonymous enum here because where you pass the value as argument, you need an int, not an enum type. If you need an enum type, then you have to give it a name. Otherwise, you do not.</p>
",3
17832237,17831882,0,"<p>A type-safe variation on this theme would be to use <code>enum class</code> and use it as a key in <code>std::map</code></p>

<pre><code>#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;

int main()
{
    enum class day
    {
        sunday,
        monday,
        tuesday,
        wednesday,
        thursday,
        friday,
        saturday
    };    

    std::map&lt;day,std::string&gt; days = 
    {
        std::make_pair(day::sunday, ""Sunday""),
        std::make_pair(day::monday, ""Monday""),
        std::make_pair(day::tuesday, ""Tuesday""),
        std::make_pair(day::wednesday, ""Wednesday""),
        std::make_pair(day::thursday, ""Thursday""),
        std::make_pair(day::friday, ""Friday""),
        std::make_pair(day::saturday, ""Saturday"")
    };
    std::cout &lt;&lt; days[day::sunday] &lt;&lt; std::endl;
}
</code></pre>

<p>This means that accessing the map with an integral type will cause a compile-time error.</p>
",1
17832344,17831882,3,"<p>First, the language doesn't provide any means of mapping the
internal enum value to a string.  It can't, really; consider:</p>

<pre><code>enum Numbers {
    one = 1,
    two = 2,
    three = 3,
    un = 1,
    deux = 2,
    trois = 3
};
</code></pre>

<p>Once you've assigned the enum constant to an enum variable, it
contains the numerical value, and nothing else.  And if the
numerical value in the above is 2, how can the system know
whether it should map to <code>two</code> or to <code>deux</code>. </p>

<p>In practice, the mapping <em>is</em> useful in many contexts.  A long
time ago, I wrote a simple parser to generate the mapping code;
it ignores most of C++, won't work in cases where e.g. the
enum is wrapped in a macro, the code it generates won't
compile if the enum is private or protected, and it's undefined
which string you get in cases like the above, but I've still
found it extremely useful.</p>

<p>For the second question: anonymous enums are usually used when
the only purpose of the enum is to generate constants.  Things
like:</p>

<pre><code>enum { maxSize = 4096 };
</code></pre>

<p>were widely used before you could provide the initialization
constant for static member variables.  And I've often found it
convenient to define bit masks using an anonymous enum, even
when the actual values were on some sort of unsigned type.
Things like:</p>

<pre><code>enum {
    offsetMask = 0xF000,
    offsetShift = 12,
    NS = 0x100,
    CWR = 0x80,
    ECE = 0x40,
    URG = 0x20,
    ACK = 0x10,
    //  ...
};
uint16_t flags;
//  ...
flags = offset &lt;&lt; offsetShift | ACK;
</code></pre>

<p>I don't want to declare my variables to have an enum; they must
be exactly 16 bits (according to the TCP specification).  In C,
I'd probably have used a <code>#define</code>, and in modern C++, I might
use <code>static uint16_t const</code> member variables, but through out
most of my C++ career, something like the above would have been
the normal solution.</p>
",0
11143449,11143354,10,"<p>The local variable <code>c</code> is left <em>uninitialized</em>.  This means, as you say, that it has a <em>garbage value.</em>   The object may have any value, including <code>0</code>.  Zero is valid ""garbage value.""  In general, you are not allowed to read from an object that has not been initialized.</p>

<p>Why is the value of <code>c</code> zero?  It could be that the compiler (g++) is zero-initializing the stack when the function is entered, to ""help"" your program to perform ""correctly"" even if it makes use of uninitialized variables.  Or, it could be that the operating system is zero-initializing pages of memory before it gives them to your program.  Or, perhaps a function that was called before <code>main</code> stored the value zero in the byte array now occupied by <code>c</code>, so it has a zero value.</p>

<hr>

<p>The behavior of a binary compiled with Visual C++ depends on how it is compiled.  In a release binary, where performance is more important than debuggability, the stack is not implicitly initialized when a function is entered, so <code>c</code> will be left uninitialized and will have a garbage value.</p>

<p>In a debug binary, where debuggability is more important, all local variables are initialized with the byte <code>0xcc</code>.  This can help you to track down and debug usage of uninitialized variables.  Similarly, the debug heap initializes newly allocated storage with the byte <code>0xcd</code>, and it fills memory with <a href=""http://www.nobugs.org/developer/win32/debug_crt_heap.html#table"" rel=""noreferrer"">different bit patterns</a> as it is allocated and deallocated, to help you to debug the state of the program.</p>
",1
11143486,11143354,1,"<p>It's undefined behavior to read uninitialized variables, but in general, you'll
get whatever value the bits in memory at that location happen to
represent (which could be a trapping NaN).  In this case, the memory in
question has never been used for anything else, and when you get memory
from the system, it will normally have been cleared, for security
reasons.  Put the variables in a function, call a couple of other
functions first, and then see what you get.</p>
",0
16387162,16387152,-1,"<p>Use an unsigned iterator:</p>

<pre><code>for (unsigned int i = 0; i &lt; object.size(); i++)
{

}
</code></pre>
",4
16387283,16387152,0,"<p>The size of a vector is always positive. Just use an unsigned int as loop variable:</p>

<pre><code>for (unsigned int i = 0; i &lt; object.size(); i++)
{
    ...
}
</code></pre>

<p>An even safer way is to declare your loop variable using size_t, which is the same as unsigned int on most platforms. But since it is the return type of the vector::size() function, your counter variable is guaranteed to have the same value range as the possible size of a vector.</p>

<pre><code>for (size_t i = 0; i &lt; object.size(); i++)
{
    ...
}
</code></pre>
",2
16387356,16387152,7,"<p>The problem is that there is a potential (breaking) issue that one can incur when dealing with signed-to-unsigned comparisons. If you're on a 32-bit machine where a signed <code>int</code> is 4 bytes, it could be possible that the size of the vector could exceed the maximum quantity representable by that type. When that happens, you get signed overflow and consequentially Undefined Behavior.</p>

<p>Here are a few alternatives you can uses:</p>

<h3><a href=""http://en.cppreference.com/w/cpp/container/vector#Member_types"" rel=""nofollow""><code>vector&lt;T&gt;::size_type</code></a>:</h3>

<pre><code>for (std::vector&lt;classname&gt;::size_type i = 0; i &lt; object.size(); ++i);
</code></pre>

<p>This is guaranteed to be correct as it is the type the <code>size</code> returns.</p>

<h3>Iterators</h3>

<pre><code>std::vector&lt;classname&gt;::iterator it;

for (it = object.begin(); it != object.end(); ++it);
</code></pre>

<h3>C++11: <a href=""http://en.cppreference.com/w/cpp/language/range-for"" rel=""nofollow"">Range-based for</a>:</h3>

<pre><code>for (auto&amp; a : object)
{
     // ...
}
</code></pre>

<h3><a href=""http://en.cppreference.com/w/cpp/types/size_t"" rel=""nofollow""><code>std::size_t</code></a>:</h3>

<pre><code>for (std::size_t i = 0; i &lt; object.size(); ++i);
</code></pre>

<p>As doomster said in the comments, <code>std::size_t</code> is likely to have the bit-size of your underlying platform.</p>

<h3><code>unsigned int</code>:</h3>

<pre><code>for (unsigned int i = 0; i &lt; object.size(); ++i);
</code></pre>

<p><sub>Note: By using this, you're assuming that <code>size</code> returns a 32-bit integer. Generally this isn't a problem, but you can't be too sure; use any of the above if you can.</sub></p>

<p>Another tip relative to your code is to use a vector of <code>unique_ptr</code>/<code>shared_ptr</code> to facilitate memory-management:</p>

<pre><code>std::vector&lt;std::unique_ptr&lt;classname&gt;&gt; object;
</code></pre>
",3
11151532,11151415,0,"<p>As far as i can tell you never seem to initialize <code>z</code> in your <code>class A</code>.</p>

<p>try</p>

<pre><code>template &lt;class T&gt;class A
{
  public:

  A(int z_):z(z_)
  {

    cout&lt;&lt;""A constructor\n"";
  }
  int z;
  T sort_rishi_fun(T arr[]);
};

// then in main()
A&lt;int&gt; a(z);
</code></pre>
",0
11151593,11151415,2,"<p>You have two variables z, one global and another one inside the class. You only initialize the global one. Inside the class, the class variable is used and this is not initialized. That is why it works when it is a global method, but doesn't work when it is a class template method.</p>
",0
12874188,12874128,10,"<p>The <code>s.c_str()</code> returns a pointer to the const char to prevent you from modifying the backing up memory. You need to make a writable copy of this constant string say with <code>strdup()</code> function as <code>strtok()</code> really modifies the string that you are scanning for tokens.</p>
",5
12874196,12874128,1,"<p><code>strtok</code> modifies its argument. This is not allowed with <code>string.c_str()</code> since it is a <em>const</em> char*</p>

<p>Also, even if it worked your <code>if( tok == ""&amp;"" )</code> will not work since tok is a char*, not a string, and you will thus be doing pointer and not content comparisons.</p>

<p>You would need to use <code>strcmp()</code></p>

<p>Since you are using string, why not go for broke and use other c++ constructs?</p>

<pre><code>stringstream ss(s);
string tmp; 
while (ss &gt;&gt; buf) {
    if( buf == ""&amp;"" ) background = buf; // one wonders why
    cout &lt;&lt; buf &lt;&lt; '\n';
}
</code></pre>
",0
12874202,12874128,0,"<p>Your code is mixing C++ <code>string</code>s and <code>cout</code>s with the C <code>strtok_r</code> function. It's not a good combination.</p>

<p>The immediate cause of your error is that <code>c_str()</code> returns a <code>const char *</code> while <code>strtok()</code> asks for a non-const <code>char *</code>. It wants to modify the string you pass as an argument, and you're not allowed to modify the string that <code>c_str()</code> returns.</p>

<p>If you want to do this C-style, then switch <code>s</code> to a <code>char[]</code>.</p>

<pre><code>char s[] = ""hello hi here whola"";
int background = 0;
char *strval;

char* tok = strtok_r(s, "" "", &amp;strval);
while (tok != NULL)
{
    printf(""%s\n"", tok);

    if (strcmp(tok, ""&amp;"") == 0)
        background = 1;
    else
    {
        statement1;
        statement2;
        ...
    }

    tok = strtok_r(NULL, "" "", &amp;strval);
}
</code></pre>
",0
11894024,11893865,1,"<p>In the shared memory region you can use all fundamental data types like integers and floating point numbers. If you have problems with float, this is unrelated to the shared nature of the memory, like different understanding between C/Pascal of what float/double/long_double is. You cannot use pointers. Structures that do not nave VMTs and do not have pointers are fine also. Complex data structures can be emulated using offsets (direct or indirect) from the beginning of the shared region.</p>

<p>To make synchronization (like events) you can use named objects.</p>

<p>You can also pass handles between processes. Check the <code>DuplicateHandle</code> function.</p>

<p>Continuation:</p>

<pre><code>    Data[3] = &amp;ListOfModels[0];
</code></pre>

<p>Here you put into the shared memory an address that does not belong to the shared memory region. The data in the shared memory region should be completely self contained meaning that all pieces of data should be in that region. Definition of the structure should look like:</p>

<pre><code>struct SaredData
{
    int data_type;
    int status;
    union
    {
        struct
        {
            int       num_font_char_objects;
            FontChar  font_char_objects[MAX_FONT_CHARS_SUPPORTED];
        };
        ...........
    };
};
</code></pre>

<p>And you need to ensure that the size of the shared memory region is big enough to store all passed objects. It is highly unlikely that any container from STL with work with shared memory.</p>

<p>You cannot place your <code>Model</code> structure into the union above because it contains complex fields.</p>
",5
11883845,11881911,1,"<p>Without knowing the details about what exactly you are doing it's hard to say anything with certainty, but -1073740940 == 0xC0000374 == STATUS_HEAP_CORRUPTION. Does it shed any light?</p>

<p><strong>[UPD]</strong> Assuming the interpretation of the error value as an NTSTATUS was correct, you are corrupting your heap. Further assuming that it happens in the code you shown, it's most probable that either <code>nBin1 &lt; 3</code> or <code>nBin1 + 3 &gt;= vBandSubset.size()</code>. In either of those cases your assignment in the loop will overwrite technical heap areas before or after the <code>vBandSubset</code> data block.</p>

<p>Since it's a test, I suggest you use <code>vBandSubset.at(i)</code> instead of <code>vBandSubset[i]</code>. Unlike <code>operator[]</code>, <code>at()</code> validates its argument and will throw an exception if it's invalid. An exception is much easier to debug than memory corruption.</p>

<p>PS. You can edit your question and put the code there. It's more convenient for readers that way.</p>
",2
11175093,11175039,7,"<p>Rather than getting all tangled up with the offset, think of the problem like this:</p>

<pre><code>void bubbleSort(int arr[], int offset, int count)
{
   StandardBubbleSort(&amp;arr[offset], count);
}

void StandardBubbleSort(int arr[], int count)
{
// the standard algorithm from your text book
}
</code></pre>
",1
11175229,11175039,0,"<p>Try this code if it works for you.</p>

<pre><code>void bubbleSort(int arr[], int offset, int count) {  
    offset--;

    for (; offset &lt; count; offset ++) 
        for(int j=0;j&lt;count-1;j++)
        {
            if (arr[offset] &gt; arr[offset+1]) {
                int temp=arr[offset];
                arr[offset]=arr[offset+1];
                arr[offset+1]=temp;
            }
        }
}
</code></pre>
",0
17839296,17839235,12,"<p>The most simple example of a branch is an if statement:</p>

<pre><code>if (condition)
    doSomething();
</code></pre>

<p>Now if <code>condition</code> is <code>true</code> then <code>doSomething()</code> is executed. If not then the execution branches, by jumping to the statement that follows the end of the <code>if</code>.</p>

<p>In very simple machine pseudo code this might be compiled to something along these lines:</p>

<pre><code>TEST condition
JZ   label1       ; jump over the CALL if condition is 0
CALL doSomething
@@label1
</code></pre>

<p>The branch point is the <code>JZ</code> instruction. The subsequent execution point depends on the outcome of the test of <code>condition</code>.</p>

<p>Branching affects performance because modern processors predict the outcome of branches and perform speculative execution, ahead of time. If the prediction turns out to be wrong then the speculative execution has to be unwound. </p>

<p>If you can arrange the code so that prediction success rates are higher, then performance is increased. That's because the speculatively executed code is now less of an overhead since it has already been executed before it was even needed. That this is possible is down to the fact that modern processors are highly parallel. Spare execution units can be put to use performing this speculative execution.</p>

<p>Now, there's one sort of code that never has branch prediction misses. And that is code with no branches. For branch free code, the results of speculative execution are always useful. So, all other things being equal, code without branches executes faster than code with branches.</p>
",1
17839422,17839235,0,"<p>Any jump in your code is a branch. This happens in <code>if</code> statements function calls and loops.</p>

<p>Modern CPUs have long pipelines. This means the CPUs is processes various parts of multiple instructions at the same time. The problem with branches is that the pipeline might not have started processing the correct instructions. This means that the speculative instructions need to be thrown out and the processor will need to start processing the instructions from scratch.</p>

<p>When a branch is encountered, the CPU tries to predict which branch is going to be used. This is called branch prediction.</p>

<p>Most of the optimizations for branch prediction will be done by your compiler so you do not really need to worry about branching.</p>

<p>This probably falls into the category of only worry about branch optimizations if you have profiled the code and can see that this is a problem.</p>
",0
17839448,17839235,0,"<p>A branch is a deviation from normal control flow. Processors will execute instructions sequentially, but in a branch, the program counter is moved to another place in memory (for example, a branch depending on a condition, or a procedure call).</p>
",0
17844053,17839235,8,"<p>Essentially imagine an assembly line in a factory. Imagine that, as each item passes through the assembly line, it will go to employee 1, then employee 2, on up to employee 5. After employee 5 is done with it, the item is finished and is ready to be packaged. Thus all five employees can be working on different items at the same time and not having to just wait around on each other. Unlike most assembly lines though, every single time employee 1 starts working on a new item, it's potentially a new type of item - not just the same type over and over.</p>

<p>Well, for whatever weird and imaginative reason, imagine the manager is standing at the very end of the assembly line. And he has a list saying, ""Make this item first. Then make that type of item. Then that type of item."" And so on. As he sees employee 5 finish each item and move on to the next, the manager then tells employee 1 which type of item to start working on, looking at where they are in the list at that time.</p>

<p>Now let's say there's a point in that list - that ""sequence of computer instructions"" - where it says, ""Now start making a coffee cup. If it's nighttime when you finish making the cup, then start making a frozen dinner. If it's daytime, then start making a bag of coffee grounds."" This is your if statement. Since the manager, in this kind of fake example, doesn't really know what time of day it's going to be until he actually sees the cup after it's finished, he could just wait until that time to call out the next item to make - either a frozen dinner or some coffee grounds.</p>

<p>The problem there is that if waits until the very last second like that - which he has to wait until to be absolutely sure what time of day it'll be when the cup is finished, and thus what the next item's going to be - then workers 1-4 are not going to be working on anything at all until worker 5 is finished. That completely defeats the purpose of an assembly line! So the manager takes a guess. The factory is open 7 hours in the day and only 1 hour at night. So it is much more likely that the cup will be finished in the daytime, thus warranting the coffee grounds.</p>

<p>So as soon as employee 2 starts working on the coffee cup, the manager calls out the coffee grounds to the employee 1. Then the assembly line just keeps moving along like it had been, until employee 5 is finished with the cup. At that time the manager finally sees what time of day it is. If it's daytime, that's great! If it's nighttime, everything started on after that coffee cup must be thrown away, and the frozen dinner must be started on. ...So essentially branch prediction is where the manager temporarily ventures a guess like that, and the line moves along faster when he's right.</p>

<p><b>Pseudo-Edit:</b></p>

<p>It is largely hardware-related. The main search phrase would probably be ""computer pipeline cpu"". But the list of instructions is already made up - it's just that that list of instructions has branches within it; it's not always 1, 2, 3, etc. But as stage 5 of the pipeline is finishing up instruction 10, stage 1 can already be working on instruction 14. Usually computer instructions can be broken up like that and worked on in segments. If stages 1-n are all working on something at the same time, and nothing gets trashed later, that's just faster than finishing one before starting another.</p>
",0
11490568,11490061,1,"<p>In your copy constructor you have <code>new int(capacity)</code> where you should have <code>new int[capacity]</code>. These are not the same thing at all.</p>

<p>You might consider using the copy and swap idiom for your assignment operator - what you have is mostly correct but rather horrible, and could be a lot shorter and simpler.</p>
",0
11841823,11841679,0,"<pre><code>printf(""Student name: %s\n"", studentOne);
</code></pre>

<p>You can't pass a C++ <code>std::string</code> to the C <code>printf</code> function; you can only pass the basic types that are shared with the C language; passing a class type will cause undefined behaviour.</p>

<p>You could use C++ output:</p>

<pre><code>std::cout &lt;&lt; ""Student name: "" &lt;&lt; studentOne &lt;&lt; std::endl;
</code></pre>

<p>or, if you really want to use C ouput for some reason, you could extract a C-style string from the <code>std::string</code>:</p>

<pre><code>printf(""Student name: %s\n"", studentOne.c_str());
                                       ^^^^^^^^
</code></pre>

<blockquote>
  <p>Also, it is possible to have these member in a type of array so I could print it by going student[0] and student[1]?</p>
</blockquote>

<p>Yes, you can put most types, including classes, in an array:</p>

<pre><code>std::string student[2]; // array of two strings.
</code></pre>

<p>If you want a variable number, use a dynamic array:</p>

<pre><code>std::vector&lt;std::string&gt; student;
</code></pre>

<p>It seems a bit odd for a single <code>Student</code> to have two names and two IDs, though. Shouldn't that class just represent one person?</p>
",0
11841912,11841679,0,"<blockquote>
  <p>Also, it is possible to have these member in a type of array so I could print it by going student[0] and student[1]?</p>
</blockquote>

<p>Sure. If you know number of students upfront, then you can just:</p>

<pre><code>string students[2];
</code></pre>

<p>This statement will effectively allocate two <code>string</code> objects in memory and you can reference each of them by array index.</p>

<p>If you dont know how many students you would need, then the best is to use <code>std::vector</code> class, because it is preferred way of representing dynamic arrays in C++.</p>

<p>You placed studentOne, studentTwo, IDOne and IDTwo data members under private section of your class declaration. This means you are allowed to manipulate them directly only within <code>Student</code> class implementation. The approach that most of other programmers would expect you to follow is to create special getter and setter methods:</p>

<pre><code>const std::string&amp; studentOne() const {return studentOne;}
void setStudentOne(const std::string&amp; aStudentOne) {studentOne = aStudentOne;}
</code></pre>

<p>and so on. Creating <code>setStudentOne</code> is especially useful when you want to have some side effect. Otherwise, you can have single method to access it:</p>

<pre><code>std::string&amp; getStudentOne() {return studentOne;}
</code></pre>

<p>Alternatively, exposing direct access to fields (i.e. relocating them to under public section) is not a <em>taboo</em>. Just remember, this is not what most people would expect to see.</p>
",0
11841729,11841679,4,"<p>Read a reference about <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow""><code>std::string</code></a> and you will find a method named <a href=""http://en.cppreference.com/w/cpp/string/basic_string/c_str"" rel=""nofollow""><code>c_str</code></a> that is used to get a C-style character pointer usable in e.g. <code>printf</code>. </p>

<p>Or just start using <code>std::cout</code> instead:</p>

<pre><code>void Student::Print(void)
{
    std::cout &lt;&lt; ""Student name: "" &lt;&lt; studentOne &lt;&lt; '\n';
    std::cout &lt;&lt; ""Student ID: "" &lt;&lt; IDone &lt;&lt; '\n';
    std::cout &lt;&lt; ""Student name: "" &lt;&lt; studentTwo &lt;&lt; '\n';
    std::cout &lt;&lt; ""Student ID: "" &lt;&lt; IDtwo &lt;&lt; '\n';
}
</code></pre>
",0
11841735,11841679,1,"<p>You need to use stl containers like <a href=""http://www.cplusplus.com/reference/stl/vector/"" rel=""nofollow"">vector</a> instead of arrays to store your student detail and you should remodel your student class to something like this</p>

<pre><code>class Student
{
private:
 string Name;
 int    Id;
public:
 Student(string name, int id);
 string GetName();
 void SetName(name);
 int GetId();
 void SetId(int id);
 void Print();
};
</code></pre>

<p>and your main should be like this</p>

<pre><code>   void main()
    {
      vector&lt;Student&gt; studentList;

      Studen one(""John Doe"", 1);
      Studen two(""Jane Doe"", 2);

      studentList.push_back(one);
      studentList.push_back(two);

      vector&lt;Student&gt;::const_iterator cii;
      for(cii=Student.begin(); cii!=Student.end(); cii++)
       {
          *cii.Print();

       }

    }
</code></pre>
",0
11841753,11841679,0,"<pre><code>printf(""Student name: %s\n"", studentOne);
</code></pre>

<p>Results in undefined behavior. You need to pass a c style string which suits the <code>%s</code> format specifier, i.e. <code>studentOne.c_str()</code>.</p>

<blockquote>
  <p>it is possible to have these member in a type of array so I could
  print it by going student[0] and student[1]</p>
</blockquote>

<p>You can always declare an array of <code>std::string</code> as any other data type.</p>

<pre><code>class Student
{
  ...
  string students[N];  // or vector&lt;string&gt; students;
};
</code></pre>
",0
16922369,16922023,5,"<p>You can never provide an explicit template argument list to constructor templates. Constructor templates must always have their arguments deduced:</p>

<pre><code>struct A {
    template&lt;typename U&gt; A() {}
};
template &lt;typename T&gt;
struct B {
    B() {}
};
struct C {
    template&lt;typename U&gt; C(U t) {}
};
template &lt;typename T&gt;
struct D {
    template&lt;typename U&gt; D(U t) {}
};

int main()
{
    //auto a1 = A&lt;int&gt;{}; //illegal -- A is not a template
    //A can never be instantiated...

    auto b = B&lt;int&gt;{}; //default-constructs a B&lt;int&gt;

    //auto c = C&lt;double&gt;{1.}; //illegal - C not a template

    //Constructs a C, deduces `U = double` constructor:
    auto c = C{1.};
    //Constructs a D&lt;int&gt;, deduces `U = double` constructor:
    auto d = D&lt;int&gt;{1.};
}
</code></pre>
",4
12307828,12307796,2,"<p>You return a reference, but you then create a new object using that reference. <code>a</code> is the new object that gets copy-initialized using the reference returned from <code>GetAccount</code>.</p>

<p>Remember, a reference is an alias. It's like saying:</p>

<pre><code>int x = 0;
int&amp; y = x;

int z = y;
//is equivalent to
z = x;
</code></pre>

<p><code>z</code> doesn't refer to <code>x</code> nor <code>y</code> in this case, because <code>z</code> itself isn't a reference.</p>

<p>So:</p>

<pre><code>x = 1;
</code></pre>

<p>would modify both <code>x</code> and <code>y</code>, but <code>z</code> would still be 0.</p>
",0
12307860,12307796,0,"<p>It does matter.</p>

<p>This version</p>

<pre><code>Account a = GetAccount(); // note lack of ""&amp;""
</code></pre>

<p>creates a <em>copy</em> of the account, not a reference. Therefore when changing the balance, you change the balance of the copy, not the original.</p>
",0
12307866,12307796,3,"<blockquote>
  <p><em>I thought when returning a reference, the ""&amp;"" is redundant / not necessary?</em></p>
</blockquote>

<p>You thought wrong.</p>

<p>Consider these two different lines:</p>

<pre><code>Account &amp;a = GetAccount(); // Line 31

Account a = GetAccount(); // Line 31
</code></pre>

<p>In the first, you declare a reference called <code>a</code> which is bound to the object returned by the function <code>GetAccount</code>.</p>

<p>In the second, you declare an object <code>a</code> which is copy-initialized by the object returned by the function <code>GetAccount</code>.</p>

<p>Fundamentally: one declares a reference, the other declares an object.</p>

<hr>

<p><strong>EDIT</strong>: Answering the follow-on question:</p>

<blockquote>
  <p>""<em>can I remove the <code>&amp;</code> from the return type in the declaration of the <code>GetAccount</code> function: <code>Account GetAccount() { return mainAccount; }</code></em>""</p>
</blockquote>

<p>You certainly <em>can</em> remove the <code>&amp;</code>, but then your behavior will change. Consider these two functions:</p>

<pre><code>Account GetAccount() { return mainAccount; }

Account &amp;GetAccount() { return mainAccount; }
</code></pre>

<p>In the first, you return a temporary object which has been copy-initialized from the <code>mainAccount</code> object. In the second you return a reference to the <code>mainAccount</code> object.</p>

<ul>
<li><p>If you want <code>a</code> to be a reference to <code>mainAccount</code>, you need <code>&amp;</code> in both places.</p></li>
<li><p>If you want <code>a</code> to be a copy of <code>mainAccount</code>, you need no <code>&amp;</code> in the declaration of <code>a</code>. The other declaration won't matter <em>in this case</em>.</p></li>
<li><p>If you want <code>a</code> to be a reference to a compiler-generated temporary value (hint: you don't), declare <code>a</code> with <code>&amp;</code>, but <code>GetAccount</code> without.</p></li>
</ul>
",2
12307871,12307796,2,"<p>In both cases you return a reference, but there is a difference in how you use it:</p>

<pre><code>Account &amp;a = GetAccount(); 
</code></pre>

<p>In this case you use the reference to initialize another reference, making <code>a</code> a reference to the original Data. </p>

<pre><code>Account a = GetAccount(); 
</code></pre>

<p>In this case you use your returned reference to initialize an object of type <code>Account</code>, instead of a reference to Account. Therefore you <strong>copy</strong> the original object into the newly created <code>a</code>. </p>
",0
12314545,12307796,0,"<p>To answer the question from the title: Not directly.</p>

<pre><code>typedef Account&amp; AccountRef; // Hiding here
AccountRef GetAccount()
{
    return mainAccount;
}
</code></pre>

<p>BTW, <code>&amp;</code> isn't used as an operator here. It modifies the <code>Account</code> type. It can be used as an unary and binary operator, e.g. in <code>&amp;obj</code> or <code>5 &amp; 6</code>. When used as an operator, it must appear before or between expressions.</p>
",0
11498037,11497860,0,"<p>Instead of opening the file every time the timer slot fires, make the QFile a member of simulatorwindow. Open it when the program starts, read from it whenever the timer fires.</p>
",0
11498609,11497860,1,"<p>In <code>on_simON_clicked</code> you define <code>textsim</code> as a local variable, and you use a variable of the same name in <code>sendmsg</code>. But it is not the same variable!</p>

<p>In <code>on_simON_clicked</code> you should use the (apparently) member variable instead, as the local variable is not available outside the function. If you turn on more warnings in the compiler you will get a warning about having a local variable ""shadow"" a member/global variable.</p>
",0
11546231,11545319,3,"<p>Here's a solution that ensures numbers in the range [0,9], and ignores duplicates:</p>

<pre><code>#include &lt;algorithm&gt; //if using copy printing
#include &lt;iostream&gt; //for cin and cout
#include &lt;iterator&gt; //if using copy printing
#include &lt;set&gt; //for set

CHOOSE A METHOD BELOW AND ADD THE CORRESPONDING INCLUDE

int main() {
    std::set&lt;int&gt; nums; //here's the array

    std::cout &lt;&lt; ""Please enter nine different numbers."" 
                 ""Duplicates will be ignored.\n"";

    //ADD THE NEXT PART OF THE METHOD, THE DECLARATION

    do {
        std::cout &lt;&lt; ""Enter the next number: "";

        //ADD THE FINAL PART, GETTING INPUT AND INSERTING IT INTO THE SET
    } while (nums.size() &lt; 9); //do this until you have 9 numbers

    std::cout &lt;&lt; ""The numbers you entered, in order, are:\n"";

    //C++11 printing
    for (const int i : nums)   
        std::cout &lt;&lt; i &lt;&lt; ' ';

    //C++03 printing using copy
    std::copy (nums.begin(), nums.end(), 
               std::ostream_iterator&lt;int&gt; (std::cout, "" ""));

    //C++03 printing using an iterator loop
    for (std::set&lt;int&gt;::const_iterator it = nums.cbegin(); //this was to
                                       it != nums.cend();  //eliminate the
                                       ++it)               //scrollbar
        std::cout &lt;&lt; *it &lt;&lt; ' ';
}
</code></pre>

<p><strong>First Method:</strong> (better for a wider range)</p>

<pre><code>#include &lt;limits&gt; //for numeric_limits
...
int temp; //this holds the current entry
...
//works better when you get out of the range 0-9
while (!(std::cin &gt;&gt; temp) || temp &lt; 0 || temp &gt; 9) { 
//body executes if input isn't an int between 0 and 9

    //clear bad input flag
    std::cin.clear(); 

    //discard bad input
    std::cin.ignore (std::numeric_limits&lt;std::streamsize&gt;::max(), '\n'); 

    //prompt for new number (could also add that you're ignoring to beginning)
    std::cout &lt;&lt; ""Invalid number. Please enter a new one: ""; 
}

//insert the valid number, duplicates ignored, automatically sorted
nums.insert (temp); 
</code></pre>

<p><strong>Second Method:</strong> (better for a 0-9 range)</p>

<pre><code>#include &lt;cctype&gt; //for isdigit
...
char temp; //holds current entry
...
//suitable for 0-9 range 
do {
    std::cin &gt;&gt; temp; 
    if (!std::isdigit (temp))
        std::cout &lt;&lt; ""Invalid number. Please enter a new one: "";
while (!std::isdigit (temp));

nums.insert (temp - '0'); //add the integer value of the character processed
</code></pre>

<p>The key here is <code>std::set</code>, which only allows unique entries, and automatically sorts the elements.</p>
",10
11556288,11556274,4,"<p>You forgot to</p>

<pre><code>#include &lt;stdlib.h&gt;
</code></pre>
",13
11161302,11161126,10,"<p>This usually happens when libraries encounter internal error, so they call abort(), because they cant continue. This might happen when you overwrite one of it's data structures (the one which belongs to the function from libc for example). So this might be e.g. libc calling because you did overwrite something. And the application must then terminate because it's impossible to continue or handle it, which is called failed assertion.</p>
",0
18146154,18146092,3,"<p>There's a standard library container called <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow noreferrer""><code>std::string</code></a> defined in <code>&lt;string&gt;</code> header. The header <code>&lt;iostream&gt;</code> implicitly includes it.</p>

<p>Then you import the whole <code>std</code> namespace into global scope and define your own <code>string</code> class. Now you've got two <code>string</code> symbols in global scope and compiler is rightfully complaining that it doesn't know which one you mean when you say <code>string s1=123;</code></p>

<p>The best thing to do is not use <code>using namespace std;</code> at all. <a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice"">See why</a>.</p>

<p>Then, <code>itoa</code> is not a standard function.</p>

<p>The rest of the errors are mainly consequences of the first one.</p>
",0
18146164,18146092,4,"<p>To start with the first error, there is no <code>itoa</code> standard function, there is however in the ""new"" C++11 standard a <a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string"" rel=""nofollow""><code>std::to_string</code></a> function that can be used (or you can use <a href=""http://en.cppreference.com/w/cpp/string/byte/strtol"" rel=""nofollow""><code>std::strtol</code></a> if you're on an older compiler with no C++11 support). There are of course functions in the standard library to convert numeric values to strings as well, such as <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow""><code>std::stoi</code></a>.</p>

<p>And that leads me to another thing, if you want to learn C++ you should start using e.g. <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow""><code>std::string</code></a> for strings. It will help you a lot in the future. Don't reinvent what's already in the standard library.</p>

<p>As for some of the other problems, there are some that can be because you imported the whole namespace <code>std</code> into the global namespace, that means that <code>std::string</code> is now just <code>string</code>, which of course collides with the name of your own <code>string</code> class. If you don't want to write e.g. <code>std::cout</code> then you can just import the names you want like</p>

<pre><code>using std::cout;
</code></pre>
",0
16918929,16918780,0,"<p>It's a forward declaration. It can be used to inform the compiler of the existence of types when you're only going to use a pointer or reference to that type. The size of a pointer or reference is invariant of the type that it refers to, so the compiler doesn't need to see the entire definition of the type in that case; it just needs to know that the type exists first.</p>

<p>This can be useful in cases where the header that normally declares the type is large (think headers that include a lot of declarations or template instantiations), in which case it can decrease your compile times (sometimes significantly). You can just forward-declare the type and skip including the header, so your compiler doesn't need to process it.</p>
",0
16918833,16918780,3,"<p><code>Cursor</code> and <code>BufferAllocator</code> are simply being forward-declared in their namespace (so they can be used in pointer/reference contexts).</p>
",0
16918843,16918780,5,"<p>It's a forward declaration. It tells the following code that ""there is a class called Cursor. You don't need to know what's in it [because we're only using it as a pointer or reference in the code, until it has been defined]"". </p>
",1
16918848,16918780,9,"<p>It simply means ""these classes exists"" in the namespace <code>abc</code>, without providing any informations on their implementations.</p>

<p>It's called <em>forward declarations</em>.</p>

<p>It can be useful for : </p>

<ul>
<li>Avoiding cycles in header inclusions (When class A has a member of class B, and class B has a member of class A)</li>
<li>Reducing dependencies between classes (because you can have a member pointer to a forward-declared class, but can't have directly a member, as the compiler doesn't know what's the size of the class without its implementation details, but know the size of a pointer). This is used notably in the <a href=""http://en.wikipedia.org/wiki/Opaque_pointer"" rel=""nofollow"">Pimpl idiom</a>.</li>
</ul>

<p>(There might be other uses for this, but these are the most obvious that come to mind).</p>
",0
16919698,16918780,0,"<p>namespace are helpful in a way they avoid typing particular classname in  front of every function.</p>

<p>As you are new you will mostly see using namespace std;</p>

<p>so now you can use cout directly if you do not use this statement then you have to write std::cout for every use of cout</p>

<p>hope this helps</p>
",0
11508767,11508228,3,"<p>OK, I'm making a guess. Your original code has the line</p>

<pre><code>grid[3][3] = updateGrid(grid, move, playersMove);
</code></pre>

<p>And your grid definition is </p>

<pre><code>int grid[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
</code></pre>

<p>This means that your are writing out of the array bounds. This is undefined behavior.
Please correct this and check if your program works as expected.</p>
",0
11508658,11508228,4,"<p>[This is somewhat of a repost of my comment since OP said it solved his problem]</p>

<p>You have no return value defined outside of the while loop. If somehow you get outside of it, you do not return a value (though I have no idea what behavior is expected or even if any behavior is expected in this case)</p>

<p>To make my answer a bit more thorough, I have found this:
<a href=""https://stackoverflow.com/questions/1610030/why-can-you-return-from-a-non-void-function-without-returning-a-value-without-pr"">Why does flowing off the end of a non-void function without returning a value not produce a compiler error?</a></p>
",1
17077711,17077702,6,"<p><code>printf</code> is a primitive and simple function. It doesn't know what types you pass into it, much less how to convert them. If you specify <code>""%d""</code>, it'll just read the parameter you pass as an <code>int</code>, spit it out and go on to the next parameter. Or crash. Just don't do it. If you make a promise, keep it - the <code>%d</code> is a promise that you're passing in an <code>int</code>.</p>
",1
17077713,17077702,0,"<p>On line 13, there is no implicit conversion. The string format doesn't change the type of the object passed.</p>
",0
17077727,17077702,0,"<p>The format string you are passing to printf specifies a decimal integer, but you are passing an Array. You need to pass some numeric type that can be converted to an int (or better yet, an actual int). If you want to print multiple values, you may need to loop over the Array and print each element.</p>
",0
17077735,17077702,2,"<p>The conversion cannot be done implicitly because in variadic functions like <code>printf</code> the format string is parsed by the internals of <code>printf</code> at <em>run-time</em> and variadic parameter retrieval is performed by the internals of <code>printf</code> at <em>run-time</em>. For the compiler <code>""%d\n""</code> is just a string. The compiler does not parse format string and has no idea how to interpret that format string, so it does not know that the argument needs a conversion and it does not know what type to convert it to.</p>

<p>P.S. Some compilers have the capability to retrieve that information from format string for standard functions, like <code>printf</code>. They do it purely for the purposes of error checking. Using this knowledge for implicit parameter conversion is technically possible, but it would produce a rather far-reaching non-standard feature. Such feature has no place in C++. And, of course, compile-time parsing of format string is only possible when that string is actually known at compile-time, which is not always the case.</p>
",0
17077746,17077702,0,"<p><code>printf</code> is a varargs function. The types of the arguments to varargs functions are not specified, so there's no way to know what type the arguments should be converted to. There are some default conversions done for some primitive types (e.g. booleans are converted to int). But user-defined conversions will not be done implicitly.</p>
",0
13451540,13451454,2,"<p>If you use:</p>

<pre><code>Base *getAction() { return static_cast&lt;Base *&gt;(new Action); }
Base *getTitle() { return static_cast&lt;Base *&gt;(new Title); }
</code></pre>

<p>then you will not get this error.</p>

<p><a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow""><code>std::function</code></a> is a polymorphic function pointer wrapper provided by the STL.</p>

<p>Of course, using templates, you could write your own function wrapper that stores a target, passes forward arguments and does conversion. This has already been done though, and you should seriously consider carefully before you decide to roll your own. Unless you enjoy reinventing wheels or have very special requirements.</p>
",2
13452008,13451454,1,"<p>As a proof of concept I have this code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;functional&gt;

struct A
{
    virtual void f() = 0;
};

struct B : public A
{
    void f() { std::cout &lt;&lt; ""B::f\n""; }
};

struct C : public A
{
    void f() { std::cout &lt;&lt; ""C::f\n""; }
};

B* getB() { return new B; }
C* getC() { return new C; }

int main()
{
    std::map&lt;std::string, std::function&lt;A*()&gt;&gt; m;
    m[""b""] = getB;
    m[""c""] = getC;

    m[""b""]()-&gt;f();
    m[""c""]()-&gt;f();
}
</code></pre>

<p>It leaks memory, but it <a href=""http://ideone.com/Jj6bMP"" rel=""nofollow"">works</a>.</p>
",0
12858673,12858529,2,"<p>The code you have posted is dangerous as you are passing a pointer to storage that is in automatic scope. The buffer will be trashed when it leaves scope (the scope of the if in this case). </p>

<p>Instead try something like this:</p>

<pre><code>id = strdup((char*)cbuffer);
</code></pre>

<p>or even better you could use escape sequences and avoid having to specify the char values yourself:</p>

<pre><code>id = strdup(""\x01"");
</code></pre>

<p>You can then free the memory used by this string by using <code>free</code>.</p>
",2
12858725,12858529,3,"<p>I doubt that people have actually advised such a code here. If they did, they were reckless. <strong>This is bad code</strong>.</p>

<p>Chance your usage of <code>char*</code> to <code>std::string</code> and change the implementation of <code>someFunction</code> accordingly. However, this only helps to some extent because it¡¯s unclear what you actually want to do here:</p>

<blockquote>
  <p>is it the correct approach, to pass the {0x01, 0x00} to the id of type char*?</p>
</blockquote>

<p>That makes no sense. What do you want to achieve? What do these values signify and why do you want to reinterpret them as a string? If you just want to obtain a string consisting of the char value 0x01, the following works:</p>

<pre><code>std::string result = ""\x01"";
</code></pre>
",0
12859272,12858529,4,"<p>Are you trying to compare id to string value ""0x01"" or are you trying to compare the id value if it is char ASCII 0x01?</p>

<p>Also, how you free it depends on how you allocated <code>char*</code> returned by <code>someFunction()</code>? is this code pure C or is it C++? if <code>someFunction()</code> allocates using <code>new char[2]</code>, then you have to free it using <code>delete[]</code>. If you allocated using C style <code>malloc(sizeof(char)*2)</code>, then you have to do a <code>free(id)</code>.</p>

<p>Consider also that before you do <code>strdup</code>, as suggested in previous post, you have to free the original id. This is of course assuming, if by design, the pointer returned by <code>someFunction()</code> doesn't point to some global constant which is not supposed to be deallocated. </p>

<pre><code>char* id = someFunction();      
if (strcmp(id,""0x01"") == 0) { // no idea if this line make sense at all. 
    free(id); // or delete[] id; if id is allocated using new char[];
    static char[] cbuffer = {0x01, 0x00};
    id = (char*) malloc(sizeof(char)*2);
    strcpy(id, cbuffer);  
}
</code></pre>
",0
12873084,12873060,1,"<p>The first time the function f() is hit the statics will be initialized (lazy loading). Had they not been declared static then they would be local variables and recreated every time you called function f().</p>

<p>All calls to f() will result in using the same x1 and x2.</p>
",1
12873108,12873060,0,"<p>The difference between</p>

<pre><code>int f()
{
      int i = 0;
      ++i;
      return i;
}

int f2()
{
     static int i = 0;
     ++i;
     return i;    
}

int main()
{
      for (int i = 0; i &lt; 10; ++i) { cout &lt;&lt; f1() &lt;&lt; ' ' &lt;&lt; f2() &lt;&lt; endl; }
}
</code></pre>

<p>Is that f1 will always make a new local variable i and set it to zero then increment it, while f2 will create a <code>static</code> local variable i and initialize it to zero <strong>once</strong> and then each call it increments it from the previous call value.</p>
",0
12873112,12873060,0,"<p>Here is some code to test what does a static object within a function mean:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;
class A {
  public:
   void increase() {
     static int b = 0;
     b++;
     cout &lt;&lt; ""A::increase: "" &lt;&lt; b &lt;&lt; endl;
   }
};
int main() {
        A a;
        a.increase();
        a.increase();
        a.increase();
        return 0;
}
</code></pre>

<p>And the output is:</p>

<pre><code>A::increase: 1
A::increase: 2
A::increase: 3
</code></pre>

<p>Notice the value of b is kept between function calls? <a href=""http://ideone.com/7w2t6"" rel=""nofollow"">Here</a> is the example on ideone so that you can play with it.</p>
",0
12873285,12873060,1,"<p>For this code it makes no difference to the observable behavior of the program.</p>

<p>Change <code>main</code> to call <code>f</code> twice instead of only once, and observe the difference -- if the variables are <code>static</code> then only one pair of <code>X</code> objects is ever created (the first time <code>f</code> is called), whereas if they're not <code>static</code> then one pair of objects is created per call.</p>

<p>Alternatively, change <code>main</code> to print something after calling <code>f</code>. Then observe that with <code>static</code>, the <code>X</code> objects are destroyed <em>after</em> <code>main</code> prints (the static objects live until the end of the program), whereas without <code>static</code> the objects are destroyed <em>before</em> <code>main</code> prints (automatic objects only live until exit from their scope, in this case the function <code>f</code>).</p>
",0
13400575,13400196,1,"<p>The syntax <code>T(exp)</code> is a cast and equivalent to <code>(T)(exp)</code> (but <code>T()</code> correspond to the default constructor and <code>T(exp1, exp2, ...)</code> also call the corresponding constructors). This implies that</p>

<pre><code>int* ptr;
int i = int(ptr);
</code></pre>

<p>is allowed (under the same conditions and with the same meaning as <code>reinterpret_cast&lt;int&gt;(ptr)</code>), while</p>

<pre><code>int j = static_cast&lt;int&gt;(ptr);
int k(ptr);
</code></pre>

<p>aren't.</p>
",0
13400578,13400196,0,"<p>char(nextChar) is type casting from int data Type to char data type - equivalent to (char)nextChar</p>

<p><a href=""http://www.cplusplus.com/doc/tutorial/typecasting/"" rel=""nofollow"">for more detail goto below link</a></p>
",0
13400211,13400196,7,"<p>It appends <code>char(nextChar)</code> to the <code>std::string</code> <code>foundChar</code> using the overloaded <code>std::string::operator += (char)</code> and then discards the string.</p>

<p><code>char(nextChar)</code> is a cast from <code>int</code> to <code>char</code> (since <code>nextChar</code> is declared as <code>int</code>) - equivalent to <code>(char)nextChar</code>.</p>
",6
13400268,13400196,1,"<p>The behavior of this is undefined, since</p>

<pre><code>while ((nextChar == stream.get()) != EOF)
</code></pre>

<p>does not assing <code>stream.get()</code> to <code>nextChar</code> but instead compares the two values. After that nextChar still holds the memory garbage it did after the (missing) initialization.</p>

<p>Probably it was intended to assign the value and compare it to EOF:</p>

<pre><code>while ((nextChar = stream.get()) != EOF)
</code></pre>

<p>Furthermore <code>char(nextChar)</code> is effectively doing the same as the more often used <code>(char)nextChar</code>, or even better <code>static_cast&lt;char&gt;(nextChar)</code></p>

<p>BTW:</p>

<pre><code>int nextChar;

while ((nextChar = stream.get()) != EOF) { }
</code></pre>

<p>can safely be shortened to</p>

<pre><code>while ((int nextChar = stream.get()) != EOF) { }
</code></pre>

<p>as long as you don't need <code>nextChar</code> outside the loop.</p>
",3
11495676,11495644,1,"<p>0xde = 11011110b, ~(0xde) = 00100001b = 0x21 hex which in ASCII table stands for !</p>

<p>so ~ operator in c++ is a bitwise negation</p>
",2
11495685,11495644,0,"<p>Java is using UNICODE (64-bit values) for characters so when you try a -233 it ends up somewhere near the top part of the UNICODE table and is most likely cannot be represented on your system.</p>

<p>The program you saw in C was using a <code>char</code> datatype which is 8-bit wide. So a ~(-233) is pretty much the same (bit-wise) as a 33 (or the <code>!</code> character)</p>
",4
11495686,11495644,0,"<p><code>foo</code> is 0xde or 0x000000de;</p>

<p><code>~foo</code> is 0xffffff21;</p>

<p><code>(char)~foo</code> is 0x21 (the exclamation mark)</p>
",1
11495693,11495644,0,"<p>What is happening is how the processor handles two's complement operation AND negative numbers. The case is that they're the same: since characters are almost everytime 8-byte, what you get is:</p>

<p>foo = 222;
   unarfoo = ~foo = -(255 - foo) = - (255 - 222) = -233</p>

<p>So essentially it's just a matter of interpreting a char as signed or unsigned.</p>
",0
12291152,12290999,0,"<p>In one code, you're using <code>-&gt;_degree</code> and in the other you're using <code>-&gt;getDegree()</code>.  Are those really the same thing?</p>
",1
12291035,12290999,2,"<p>In both codes, you are writing off the end of the array, which can cause arbitrarily bad behavior.  You need to use <code>&lt;</code> instead of <code>&lt;=</code> in your loops, or allocate 2 extra slots.</p>

<p>To answer your question, you are otherwise using runtime-sized arrays correctly.</p>
",6
11549500,11549368,0,"<p>Most of it is fine, though there are two problems standing out.  </p>

<p>First, you have an array of size 9, but you are taking in 11 numbers since you're starting the for loop at 0 and going through to 10.</p>

<p>Second, since you have it so if the entered number is not between 0 and 9, inclusive, the for loop breaks.  This entails that fewer than 9 numbers will be put into the array if an invalid number is entered.  Change the entire loop to read this and you should be good:</p>

<pre><code>for(int i = 0; i &lt; 9; i++) {
    cout &lt;&lt; ""Enter Number "" &lt;&lt; (i + 1) &lt;&lt; endl;
    cin &gt;&gt; n;
    if((n &gt;= 0) &amp;&amp; (n &lt;= 9))
       array[i] = n;
    else {
        cout &lt;&lt; ""Numbers from 0-9 only\n"" &lt;&lt; endl;
        i--;
    }
}
</code></pre>

<p>The whole fire part was right, but I removed the break in the else-statement and added in the i--.  I added that in so when the user is prompted to re-enter the number, the entry number will be at the correct index.</p>

<p>I hope this was helpful.</p>
",0
11549677,11549368,1,"<p>(edit) complete, compiling code</p>

<p>To check if the numbers are used with higher performance, try something like this (using the working code from Jack Radcliffe):</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
  int n = 0;
  int array[9] = {0};

  bool isUsed[10] = {0};

  for(int i = 0; i &lt; 9; i++) 
  {
    cout &lt;&lt; ""Enter Number "" &lt;&lt; (i + 1) &lt;&lt; endl;
    cin &gt;&gt; n;

    if((n &gt;= 0) &amp;&amp; (n &lt;= 9))
    {
      if (isUsed[n] == false)
      {
        array[i] = n;
        isUsed[n] = true;
      }

      else
      {
        cout &lt;&lt; ""Number has already been used."" &lt;&lt; endl;
        i--;
      }
    }

    else 
    {
      cout &lt;&lt; ""Numbers from 0-9 only."" &lt;&lt; endl;
      i--;
    }
  }

  return 0;
}
</code></pre>

<p>Optimization isn't exactly necessary with this simple of code, but it's this seems to be an exercise of practice, so why not practice optimized code, too?</p>
",0
11562659,11562618,1,"<p>You need to use (*outer) to get what the iterator is pointing to:</p>

<pre><code>list&lt;char *&gt; pointers;

list&lt;list&lt;char&gt; &gt; undoValues;
list&lt;char&gt; undoValue;
for(list&lt;list&lt;char *&gt; &gt;::iterator outer=moves.begin();outer!=moves.end();outer++)
{
    for(list&lt;char *&gt;::iterator inner=(*outer).begin();inner!=(*outer).end();inner++)
    {

    }
}
</code></pre>
",0
11562676,11562618,1,"<pre><code>for(list&lt;list&lt;char *&gt; &gt;::iterator outer=moves.begin();outer!=moves.end();outer++)
    for(list&lt;char *&gt;::iterator inner=outer-&gt;begin();inner!=outer-&gt;end();inner++)
</code></pre>
",0
11562679,11562618,2,"<p>You need to dereference the iterators to get to the element. You can either use <code>*</code> or <code>-&gt;</code>:</p>

<pre><code>for(list&lt;char *&gt;::iterator inner=outer-&gt;begin();inner!=outer-&gt;end();inner++)
</code></pre>

<p>or</p>

<pre><code>for(list&lt;char *&gt;::iterator inner=(*outer).begin();inner!=(*outer).end();inner++)
</code></pre>
",0
11562710,11562618,0,"<p>To access members of the object an iterator refers to, you need indirection; so the <code>begin()</code> member of the <code>outer</code> list is <code>outer-&gt;begin()</code>, not <code>outer.begin()</code>. Likewise for <code>end()</code>.</p>
",0
16388037,16387732,0,"<p>You need to provide more details. What type of video did you make with Bitmap files? And how?</p>

<p>To create a video, frames (or images) must be given in uncompressed form.</p>

<p>For the same image, Bitmap and JPEG occupy the same space when they are uncompressed. So what you need to do is decode the JPEGs one by one, and pass them to some video codec like Xvid or x264 which compresses the stream. Although I don't know how you'll store that stream into the AVI container (which uses the RIFF format, btw).</p>

<p>Decoding JPEG files isn't as easy as Bitmap, I recommend using a library. For example, libjpeg. <a href=""http://www.ijg.org/"" rel=""nofollow"">http://www.ijg.org/</a></p>

<p><strong>EDIT:</strong> In a nutshell, reading JPEG instead of Bitmap will be of no use. What I suggest is that do what you are doing right now, and later compress the video using a library like <strong>ffmpeg</strong> <a href=""http://www.ffmpeg.org"" rel=""nofollow"">http://www.ffmpeg.org</a> or <strong>libav</strong> <a href=""http://libav.org/"" rel=""nofollow"">http://libav.org/</a>. I'm sure you will find usage examples by searching. Good luck!</p>
",3
14175273,14175198,2,"<p>According to the doc, <code>fgetws</code> 's second parameter is the number of wide chars in the array, not bytes, so:</p>

<pre><code>fgetws(buffer,sizeof(buffer)/sizeof(*buffer),fr);
</code></pre>

<p>A useful classic macro for this is is:</p>

<pre><code>#define countof(x) (sizeof(x)/sizeof(*(x)))
</code></pre>

<p>Or a fancy C++ template:</p>

<pre><code>template &lt;typename T, int N&gt;
int countof(T (&amp;a)[N])
{
    return N;
}
</code></pre>
",3
14175362,14175198,1,"<p>If the file contains only <a href=""http://en.wikipedia.org/wiki/Ascii"" rel=""nofollow"">ASCII</a> characters (remember that ASCII is a subset of <a href=""http://en.wikipedia.org/wiki/Unicode"" rel=""nofollow"">Unicode</a>, and that the size of <code>wchar_t</code> is implementation specific and might fit for some fixed-width encoding of a subset of Unicode characters; so <code>wchar_t</code> is not very portable) you need to convert each individual ASCII character to its wide character equivalent:</p>

<pre><code>{
#define SIZE 80
    char cbuf[SIZE];
    wchar_t wbuf[SIZE];
    char* pc;
    wchar_t* pw;
    memset (cbuf, 0, sizeof(cbuf));
    memset (wbuf, 0, sizeof(wbuf));
    fgets (cbuf, SIZE, fr);
    for ((pc=cbuf), (pw=wbuf); pc&lt;cbuf+SIZE &amp;&amp; *pc != 0; pc++, pw++)
      *pw = (wchar_t) *pc;
}
</code></pre>

<p>P.S. read carefully the <em>NOTES</em> of <a href=""http://linux.die.net/man/3/fgetws"" rel=""nofollow"">fgetws(3)</a> man page. It can be understood as scary.</p>
",0
11494243,11494180,0,"<p>You should use this to break loop :</p>

<pre><code>while(item[9].price != 0.00 &amp;&amp; temp != ""q"")
{
  // ur stuff
}
</code></pre>

<p>Loop will iterate because <b>item[9].price </b> will contain some value other then 0.00</p>
",0
11494224,11494180,2,"<pre><code>while(item[9].price != 0.00 || temp != ""q"")
</code></pre>

<p>Consider what this is saying.  ""<em>Loop while price isn't 0 <strong>or</strong> temp isn't ""q"".</em>""  Now consider what has to occur for this to stop looping.</p>
",0
11494225,11494180,4,"<p>Your while loop needs to read:</p>

<pre><code>while(item[9].price != 0.00 &amp;&amp; temp != ""q"")
</code></pre>

<p>The loop needs to continue while both conditions are true, so you need to say <code>&amp;&amp;</code> not <code>||</code>.</p>
",3
11545208,11545098,2,"<p>Check it out my question here: <a href=""https://stackoverflow.com/questions/2136998/using-a-stl-map-of-function-pointers"">Using a STL map of function pointers</a></p>

<p>The approach would be similar but instead that storing directly the function pointer you would have a struct </p>

<pre><code>enum ArgumentType
{
  BOOL,
  INT,
  whatever
};

struct FunctionDecl
{
  void *function;
  ArgumentType returnType;
  ArgumentType arguments[];
}
</code></pre>
",6
13721271,13721101,3,"<p>Use <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow"">std::vector</a> if you use C++. <code>std::vector</code> has <code>erase</code> method, use it.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;




int main ()
{
? std::vector&lt;int&gt; myvector;

? // set some values (from 1 to 10)
? for (int i=1; i&lt;=10; i++) myvector.push_back(i);

? // erase the 6th element
? myvector.erase (myvector.begin()+5);

? // erase the first 3 elements:
? myvector.erase (myvector.begin(),myvector.begin()+3);

? std::cout &lt;&lt; ""myvector contains:"";
? for (unsigned i=0; i&lt;myvector.size(); ++i)
? ? std::cout &lt;&lt; ' ' &lt;&lt; myvector[i];
? std::cout &lt;&lt; '\n';

? return 0;
}
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/vector/vector/erase/"" rel=""nofollow"">sts::vector::erase</a> documentation.</p>
",1
13721325,13721101,0,"<p>It's not easy to delete from an array, because an array has a fixed size (for example, 5) which is determined when the array is created.</p>

<p>Instead of deleting elements, copy elements down within the same array to replace the elements you don't want, for example:</p>

<pre><code>// Move element 2 to element 1, erasing the old element 1
Track[1] = Track[2];
Track[2] = 0;
</code></pre>

<p>Another solution is to use a std::vector instead of an array. If Track2 is a vector, then you can use the vector::erase method to remove an element.</p>

<p>Another solution is to copy elements into a smaller array, for example:</p>

<pre><code>// New temporary smaller array
int Temp[2];
// Copy elements we want to keep
Temp[0] = Track2[0];
Temp[1] = Track2[2];
</code></pre>
",2
13721353,13721101,1,"<p>Your program doesn't <em>erase</em> parts of the array, it should simply not print the last part of it (if I'm reading your question correct).</p>

<p>For that you can keep another variable, containing the last usable index, and loop until you reach that instead.</p>

<p>If you really want to <em>erase</em> entries from an array, I suggest you to use <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a> instead.</p>
",0
13721408,13721101,0,"<p>There are ways to delete elements from an array, but you will not find a function that deletes all the elements at the end that are zero.</p>

<p>You need to take care of this yourself. What you need is to find the length of the array up to the last non-zero element. You can do this but traversing the array backwards:</p>

<pre><code>int length;
for(length=Taille; i&gt;=0; --length) {
   if (Track2[index] != 0) {
      break;
   }
}
</code></pre>

<p><code>length</code>will have the length of the array, and you can use this as upper bound in printing your array</p>
",0
15841561,15729585,6,"<p>This seems already answered on SO</p>
<ul>
<li><a href=""https://stackoverflow.com/questions/7325910/debugging-template-instantiations"">Debugging template instantiations</a></li>
<li><a href=""https://stackoverflow.com/questions/4448094/can-we-see-the-template-instantiated-code-by-c-compiler"">link 2</a></li>
<li><a href=""https://stackoverflow.com/questions/1219007/c-template-metaprogramming-is-it-possible-to-output-the-generated-code"">link 3</a> (with a nice paper too)</li>
<li><a href=""https://stackoverflow.com/questions/563414/how-do-you-debug-heavily-templated-code-in-c"">How do you debug heavily templated code in c++?</a></li>
</ul>
<p>The Idea/principle from Alexey Frunze to use the disassembled code is quite good, together with the use of simplified templates there is a pretty good chance to understand exactly what it does.</p>
<p><strong>Edit 1</strong>
There are a few other possibilities on how to get an understanding of the things which the compiler had done</p>
<ol>
<li>Use: <code>gcc -S -O1 {yourcode.cpp}</code> to get the assembly and use the tool <code>c++filt</code> (its a part of <a href=""http://ftp.gnu.org/gnu/binutils/"" rel=""nofollow noreferrer"">binutils</a> to convert the disassembly to C-Code if you feel more comfortable with C-Code</li>
<li>Use: <code>g++ -fdump-tree-original file.cpp</code> to get some (pseudo) C++ code</li>
<li>Use the MSVC++ debugger with the breakpoint after the last instantiation and see all types and values which are the parameters of the instantiated template</li>
<li>Use: <a href=""https://gccxml.github.io/HTML/Index.html"" rel=""nofollow noreferrer"">GCC XML</a> for generating XML with instantiated templates (<a href=""https://gccxml.github.io/HTML/FAQ.html"" rel=""nofollow noreferrer"">FAQ</a>)</li>
<li>To know how the compiler instantiated and optimized the templates you can use Clang: <code>-emit-llvm</code> to get the LLVM IR, and use <code>llvm-dis</code> to convert it to text</li>
<li><a href=""https://cppinsights.io/"" rel=""nofollow noreferrer"">CPP insights</a> is a website of a LLVM based tool to see instantiations</li>
</ol>
",1
11864509,11864102,5,"<p>Class template member functions are part of the template and are therefore instantiated with the template, but friends are not.  Consider the non-template case:</p>

<pre><code>struct S {
    friend void foo(S);
};
</code></pre>

<p>Note that <code>void foo(S)</code> does not have to be declared at this point; the <code>friend</code> declaration is saying that <em>if a function <code>void foo(S)</code> is defined</em>, then that function will have access to <code>S</code>.  It might never actually be defined, and that's fine.</p>

<p>With templates, the situation is the same:</p>

<pre><code>template&lt;typename T&gt; struct S {
    friend void foo(S);
};
</code></pre>

<p>This is saying that for any type <code>T</code>, <em>if a function <code>void foo(S&lt;T&gt;)</code> is defined</em> then that function has access to <code>S&lt;T&gt;</code>.  That function is expected to be a concrete function, by overloading:</p>

<pre><code>void foo(S&lt;char&gt;) { }
void foo(S&lt;int&gt;) { }
</code></pre>

<p>The compiler doesn't know that you are planning later on to supply a function template that can be used for all <code>T</code>.  Instead, if an appropriate function template is already declared then it will be instantiated if you specify that it should by adding angle brackets.</p>

<p>As for why you have to forward-declare the template, there's no reason that ""the template"" has to have just one declaration.  Consider:</p>

<pre><code>#include &lt;iostream&gt;
template&lt;typename T&gt; struct S;
template&lt;typename T&gt; void foo(S&lt;T&gt;);
template&lt;typename T&gt; void foo(S&lt;T *&gt;);
template&lt;typename T&gt; struct S {
    friend void foo&lt;&gt;(S);
};
template&lt;typename T&gt; void foo(S&lt;T&gt;) { std::cout &lt;&lt; ""template template friend\n""; }
template&lt;typename T&gt; void foo(S&lt;T *&gt;) { std::cout &lt;&lt; ""template specialization template friend\n""; }
template void foo(S&lt;void *&gt;);
int main() {
    foo(S&lt;int&gt;());
    foo(S&lt;void *&gt;());
}
</code></pre>

<p>Here there are two specialisations of <code>foo</code>, and they have to both be forward declared so that the <code>friend</code> can select between them.</p>
",3
11825139,11825039,0,"<p>All i can see is that it would reduce the likeliness that you're linking to <code>SomeDerived::f()</code> rather than using the virtual <code>Base::f()</code>, although I don't remember I've caught a compiler guilty of this so far. Looking for someone else to propose a better answer ...</p>
",0
11825150,11825039,2,"<p>If a derived class declares <code>void f(int)</code>, then it <em>overrides</em> the virtual function, and the <code>virtual</code> specifier is implied. If a derived class declares <code>int f(int)</code>, it <em>hides</em> the base function. I gather that you're familiar with this.</p>

<p>The problem comes when you want others to develop code based on your base class. With the naive approach, each derived class must be careful to add the correct override so as not to accidentally hide the function and get a working, but wrong program (i.e. the user says <code>f()</code> but gets the wrong thing). With the ""public non-virtual"" idiom, the user always calls <code>f()</code> in confidence, and the library developer can override only those parts that she's interested in by overriding a uniquely named, protected function, without having to touch a name that may affect <em>other</em> users.</p>
",6
11825503,11825039,0,"<p>The main motivation, historically at least, for using non-public virtual
functions has been to support programming by contract.  The
(non-virtual) public functions in <code>Base</code> define a contract, with
<code>assert</code> (or something similar) of pre- and post-conditions and
invariants.  They forward to private or protected virtual functions for
the actual work.  Thus, for example, the classical <code>clone</code> function 
might be defined: </p>

<pre><code>class Base
{
    virtual Base* doClone() const = 0;
public:
    Base* clone() const
    {
        Base* results = doClone();
        assert( typeid(*this) == typeid( *results ) );
        return results;
    }
};
</code></pre>

<p>In the case of <code>clone</code>, this sort of protection is probably overkill;
I've yet to see any problems due to a derived class misimplementing it
(or failing to implement it, if there are multiple levels of
derivation).  For most other functions, however, it's a powerful and
effective means of developing robust software.</p>

<p>If you have overloaded functions in the interface, <em>and</em> they have
different implementations, I don't see any real reason not to overload
the virtual functions.</p>
",0
16377704,16377664,3,"<p>This will be the cause:</p>

<pre><code>temp.assign(NULL);
</code></pre>

<p>as <a href=""http://en.cppreference.com/w/cpp/string/basic_string/assign"" rel=""nofollow""><code>std::string::assign()</code></a> will attempt to read until a null terminator is found and dereferencing a <code>NULL</code> pointer is undefined behaviour: in this case a segmentation fault. Use <code>temp.clear()</code> or just create a new object on each iteration. </p>

<p>Use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow""><code>std::getline()</code></a> which reads lines including whitespace and avoids having to hardcode a fixed size array (i.e. <code>buffer[100]</code>):</p>

<pre><code>std::string line;
while (std::getline(std::cin, line) &amp;&amp; line != ""!"")
{
    vec.push_back(line);
}
</code></pre>
",0
16377705,16377664,1,"<pre><code>while (getline(cin, temp) &amp;&amp; temp != ""!"")
{
    vec.push_back(temp);
}
</code></pre>

<p>Using buffers like that is more a C thing to do than C++. In C++ there's usually a way to avoid such explicit memory management using classes -- this is a good example.</p>
",1
16377737,16377664,3,"<p>Other problems notwithstanding, running your program in <code>gdb</code> (or probably any other debugger) reveals the reason:</p>

<pre><code>tikal@seven ~$ g++ -o temp temp.cpp
tikal@seven ~$ gdb temp
GNU gdb 6.3.50-20050815 (Apple version gdb-1822) (Sun Aug  5 03:00:42 UTC 2012)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type ""show copying"" to see the conditions.
There is absolutely no warranty for GDB.  Type ""show warranty"" for details.
This GDB was configured as ""x86_64-apple-darwin""...Reading symbols for shared libraries ... done

(gdb) run
Starting program: /Users/tikal/temp 
Reading symbols for shared libraries ++............................. done
Enter String : asd
@@@@ asd
###asd

Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000000
0x00007fff9081e6b0 in strlen ()
(gdb) backtrace
#0  0x00007fff9081e6b0 in strlen ()
#1  0x00007fff9857ab95 in std::string::assign ()
#2  0x0000000100001642 in main ()
(gdb) 
</code></pre>

<p>Essentially, <code>temp.assign( NULL )</code> is a bad idea.  You could use <code>temp.clear()</code> instead, or don't bother clearing it (you'll just reassign it later).</p>
",1
13738354,13738346,2,"<p>That's the syntax for defining a <code>static</code> member of a class. It initializes <code>Test::i</code> to <code>0</code>. </p>

<p>To give it another value, you can do</p>

<pre><code>int Tent::i = 42;
</code></pre>
",2
13738406,13738346,2,"<pre><code>int Test::i;
</code></pre>

<p>defines the static member <code>i</code> of class <code>Test</code> initializing it to <code>0</code> by default.</p>

<pre><code>static int i;
</code></pre>

<p>just declares the member <code>i</code> but doesn't define it. You need to put the definition separately.</p>
",0
13738556,13738346,0,"<p>The line in question defines (instantiates) the static variable i in class Test and initializes it to the default value zero.</p>

<p>The program writes out the size of an object of type class Test, which is the size of the int ""j"" in bytes. The number is platform-dependent. A 32-bit Windows program will write 4.  The variable ""i"" does not enter into it, because it is not a member of objects of class Test, but rather a ""static member"", which is like a global except that it is only accessible through the namespace for class Test.</p>
",0
11869811,11869755,4,"<p>The file you sent already is an exe file, but it is most likely a debug version of the program. Also, you need to see if you are linking against other DLLs, and if you are, you should distribute those with the program as well.</p>

<p>Since you have a simple program, it is most likely you have no other DLL dependencies, so try compiling in release mode as a first step. There will be a dropdown at the top of VS with <code>Debug</code> and <code>Release</code>, and <code>Debug</code> is currently selected.</p>
",13
11869862,11869755,0,"<p>You already have the .exe file that is created by linking all the .obj files that are compiled from the .cpp files you created. To repeat myself, the linking is already happening behind the scenes. However, there are two other issues. First, you may have compiled it in debug mode. In order to run your program on another Windows machine, it is best to compile it in release mode. Also, if your program uses DLLs, such as for MFC classes, then you need to copy those DLLs to the other computer as well. In order to do this correctly, you should look at creating a <code>setup.exe</code> file which will correctly install your program and all the required DLLs. There are tools that can help you do this, such as InstallShield.</p>
",2
11869869,11869755,0,"<p>I think you should install runtime components of Visual C++ Libraries : ""Microsoft Visual C++ 2008 Redistributable Package (x86)"" required to run applications developed with Visual C++ on a computer that does not have Visual C++ 2008 installed.
<a href=""http://www.microsoft.com/en-us/download/details.aspx?id=29"" rel=""nofollow"">http://www.microsoft.com/en-us/download/details.aspx?id=29</a></p>
",7
17837406,17836952,1,"<p>Assuming that <code>UINT64 time;</code> should be <code>UINT64 timestamp;</code>...</p>

<p>There's lot's wrong with the code.  If <code>EU::recording</code> holds
a valid pointer, <code>EU::timestamp</code> will also be non-null, and
vice-versa.  (Probably: on a 32-bit big endian machine, a small
enough time stamp would not cause <code>recording</code> to be non-null.)
The copy constructor and assignment operator are superfluous
and confusing, since the test for the last initialized type is
incorrect.  They'll work, but more by chance than anything else.
And there is no need for the tests for self assignment.  (If you
needed them, the assignment operator probably wouldn't be thread
safe, but you don't need them here.) </p>

<p>As for how to manage the pointer: it's up to the user of the
union (<code>A</code>).  The union itself has no means of knowing whether
it contains a pointer or a timestamp, and no means of knowing
how the pointer was allocated.  As far as I can tell from the
code you've posted, the union never contains a pointer anyway,
and could be directly replaced by <code>UINT64 timestamp;</code>.  Which
would be the best solution, unless there's more to it than you
show.</p>
",9
12790835,12790693,1,"<p>The code works if you define <code>public stackADT&lt;Type&gt;</code> as an empty class, which implies that that probably shouldn't be there, or that you have some other wierdness with the code.</p>

<p>As far as syntax: in <code>(const stackType&lt;Type &amp; right) const</code> You missed a <code>&gt;</code>.  Also, you misspelled <code>stackTop</code> as <code>stacKTop</code> at one point.</p>
",1
11511409,11511381,1,"<blockquote>
  <p>So, from where and how memory is allocated to the object mymap?</p>
</blockquote>

<p>The default allocator for all Standard containters is <a href=""http://en.cppreference.com/w/cpp/memory/allocator"" rel=""nofollow""><code>std::allocator</code></a>, from where your container gets memory and releases to when it is done with the memory. You can use custom allocator, and then keep track of all the allocations and deallocations if you want to. </p>
",0
11511414,11511381,3,"<blockquote>
  <p>there is no dynamic allocation</p>
</blockquote>

<p>Sure there is, but it's under the hood. <code>std::map</code> is usually stored as a tree, so a new node is allocated whenever a new object is inserted into it. Dynamically. Just because you don't explicitly write <code>new</code>, it doesn't mean it doesn't happen under the hood.</p>

<p>On the destructor of <code>std::map</code>, the nodes are automatically deleted. Note however that if the nodes contain dynamically allocated objects, those will not be deleted by the map.</p>
",1
11828223,11828182,4,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;Winsock2.h&gt;
#pragma comment(lib, ""Ws2_32.lib"")
int main()
{
    char szPath[128] = """";
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
    gethostname(szPath, sizeof(szPath));
    printf(""%s"", szPath);
    WSACleanup();
    return 0;
} 
</code></pre>
",0
11817043,11780447,1,"<p>Here is one that displays the time.</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include&lt;time.h&gt;



int ch=0;
time_t now;

void gotoxy(int x, int y)
{
    COORD coord;
    coord.X = x; coord.Y = y;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
    return;
}

void setcolor(WORD color)
{
    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),color);
    return;
}

void clrscr()
{
    COORD coordScreen = { 0, 0 };
    DWORD cCharsWritten;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD dwConSize;
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

    GetConsoleScreenBufferInfo(hConsole, &amp;csbi);
    dwConSize = csbi.dwSize.X * csbi.dwSize.Y;
    FillConsoleOutputCharacter(hConsole, TEXT(' '), dwConSize, coordScreen, &amp;cCharsWritten);
    GetConsoleScreenBufferInfo(hConsole, &amp;csbi);
    FillConsoleOutputAttribute(hConsole, csbi.wAttributes, dwConSize, coordScreen, &amp;cCharsWritten);
    SetConsoleCursorPosition(hConsole, coordScreen);
    return;
}

void getkey(void)
{
  if (kbhit())
  {
    ch=getch();

  }
}



int main(void)
{



    while (ch!=27)
    {
        getkey();   
        time(&amp;now);

        gotoxy(50,1) ;
        setcolor(31);
        printf(""%s"", ctime(&amp;now));
        setcolor(0);
    }

    setcolor(7);
    clrscr();

    gotoxy(2,23) ;
    return 0;

}
</code></pre>
",0
11834586,11834281,0,"<p>If you want the paddles visible in more than the file they are defined in, you have to add a declaration to the header file</p>

<pre><code>extern paddle p1;
extern paddle p2;
</code></pre>

<p>so the other .cpp files will know that they exist.</p>
",2
11834924,11834281,0,"<p>Since you haven't provided a clear question, it's difficult to provide the right answer, but my guess is that you can't access p1 and p2 in the OnEvent-/OnLoop-Method.</p>

<p>Is it absolutely necessary to let the two paddle-objects live in the global namespace? Because in this scenario I think it would be best to have 2 paddle-members as part of the Pong class, also I would use initialization lists like so:</p>

<pre><code>class Pong {
private:

    SDL_Surface * Paddle;
    SDL_Surface * Ball; //SDL_Surface pointer for Ball
    SDL_Surface * screen;   //SDL_Surface  pointer to backbuffer

    paddle p1;
    paddle p2;

public:
    Pong() :
        h(768),
        w(1024),
        screen(NULL),
        Paddle(NULL),
        Ball(NULL),
        Running(true),
        p1(10, 384, 0),
        p2(1014, 384, 0) {
        atexit(SDL_Quit);
    };

    // ...
}; 
</code></pre>

<p>You might not even need all initializers depending on the optimization settings and the default memory initialization but that's not the point. This way you should have access to p1 and p2 in all of Pongs own methods. Bo Perssons answer may work as well, but I think this is a more object- and thus C++-oriented approach. </p>

<p>On a side note: You said that the header file contains some more methods - seeing that your constructor is implemented in the cpp-file and the redraw-Method in the header-file you might want to learn a bit more about inlining. It won't be much of an issue in this example but it's usually best practice to move the more complex methods to the translation units (cpp-files), especially when creating libraries. </p>
",7
14773975,14773958,4,"<p>You forgot to implement <code>A::fun</code>.</p>

<p>If you don't want to implement a virtual function, mark it as pure with <code>= 0</code>, but note that the class will become abstract and you won't be able to instantiate it.</p>
",2
14774002,14773958,2,"<p>Either implement <code>A::fun</code> or indicate it as pure virtual using <code>= 0</code>:</p>

<pre><code>virtual void fun(std::string) = 0;
</code></pre>

<p>Still keep in mind that if <code>fun</code> is pure virtual you will not be able to instantiate <code>A</code> in main.</p>
",0
11872098,11872068,8,"<p>The first line (<code>int *ptr;</code>) does not allocate any dynamic memory so there is no memory leak. The value you see is uninitialized. It is not a valid pointer. You should not delete the pointer before assigning a value to it. Doing so would be undefined behaviour.</p>
",1
11872112,11872068,1,"<p>No, it's not a memory leak. The difference is that when you say ""<code>new int</code>"", you're telling C++ to reserve a block of memory to hold an <code>int</code>; if you then lose the pointer to that reserved block, then it can't be recovered, and can't be freed, and therefore it's a leak because it can never be reused.</p>

<p>Just holding some bits in a pointer variable doesn't perform any magic; they're just bits. It's allocating the memory using <code>new</code> that can get you into trouble. Once you've reserved a block, you have to make sure not to lose it.</p>
",4
11872130,11872068,1,"<p>In C/C++, memory is not automatically released. So, yes, if you do this: </p>

<pre><code> YourType* ptr = new YourType();
 ptr = new YourType();
</code></pre>

<p>you will have a memory leak.</p>

<p>But in your case, you don't have a memory leak because the first value is not a valid memory location. It is an uninitialized pointer.</p>
",0
11872171,11872068,15,"<p>You need to understand that memory leaks are not about pointers  (really: <em>never</em> ¨C even though a lot of people will claim something different). The whole business with pointers is just misleading.</p>

<p>They are about a mismatch in dynamic memory allocations and deallocations.</p>

<p>Every allocation via <code>new</code> must be matched with <em>exactly one</em> deallocation via <code>delete</code>. Same for <code>malloc</code> and <code>free</code> and <code>new[]</code> and <code>delete[]</code> (and other conceivable dynamic resource allocation functions).</p>

<pre><code>int* x; // Not a memory leak: no dynamic allocation
new int; // Memory leak: we acquired a value via `new` and lost it.

int* y = new int;
int* z = y;
delete y; // Not a memory leak any more: we freed the memory.

delete z; // Oooh, bad: we deleted a value twice. The horror.
</code></pre>

<p>Modern C++ code uses very few (in most cases: <strong>no</strong>) manual dynamic memory allocations. That way, you cannot have leaks. In principle. This is very good, so do it. Instead of <em>manual</em> dynamic memory allocations, you can make use of standard containers and smart pointers which handle the memory management for you.</p>
",15
11879143,11879083,4,"<p>Well, pretty simple:</p>

<pre><code>#include &lt;iostream&gt; // This is the C++ I/O header, has basic functions like output an input.

int main(){ // the main function is generally an int, not a void.
   for(int i = 100; i &lt;= 200; i+=2){ // for loop to advance by 2.
       std::cout &lt;&lt; i &lt;&lt; std::endl; // print out the number and go to next line, std:: is a prefix used for functions in the std namespace.
   } // End for loop
   return 0; // Return int function
} // Close the int function, end of program
</code></pre>

<p>you were using C libraries, not C++ ones, as well as no function that is called <code>print</code> in C++, nor <code>C</code>. Also there is no void main function, use <code>int main()</code> instead. finally, you need to have <code>std::</code> in front of <code>cout</code> and <code>endl</code> as these lie in the <code>std</code> namespace.</p>
",9
11879199,11879083,0,"<p>Your code looks good....Only the printing part needs to be changed</p>

<pre><code>  #include &lt;stdio.h&gt;
  int main()
  {
    for (int i= 100; i&lt;= 200; i += 2){
      printf(""%d"",i);
    }
    return 0;
  }
</code></pre>
",8
11879306,11879083,0,"<p>Use the following code:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    int i;
    for (i= 100; i&lt;= 200; i += 2){
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
",2
14183773,14183574,0,"<p>you actually CAN declare a map with template arguments based on other variables types with decltype (in c++11) see this page <a href=""http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html"" rel=""nofollow"">http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html</a> however they are right if you're referring to c++98 in which case it would be impossible</p>
",1
14183789,14183574,3,"<p>C++ templates are only blueprint of classes and/or functions. </p>

<p>Having template definitions in your program, does not mean the compiler will generate code for them. </p>

<p>Compilers will only generate code if a template is <strong>instantiated</strong>, i.e. when you use the template by substituting the parameters with real data/class types. </p>

<p>Because without these information, compilers are not able to generate code. To actually build a house, you will need bricks and mortars, not only a blueprint.  </p>
",0
14185720,14183574,0,"<p>You might find <a href=""http://www.boost.org/doc/libs/release/doc/html/any.html"" rel=""nofollow""><code>boost::any</code></a> useful for this task, something like</p>

<pre><code>typedef std::map&lt;int, boost::any&gt; MyIntMap;
</code></pre>
",0
11811481,11811456,5,"<p>If you're printing data with <code>std::cout</code>, use <code>std::fixed</code> to prevent scientific notation</p>

<pre><code>double d = 145470197.00;
std::cout &lt;&lt; std::fixed &lt;&lt; d;
</code></pre>
",2
11807845,11807826,2,"<p>*<em>c</em>*ountryServer.cpp and *<em>C</em>*ountryServer.cpp are different files on a Linux/Unix system.</p>
",0
11807848,11807826,1,"<p>File paths are case sensitive in linux.</p>

<p>countryServer.cpp and CountryServer.cpp are not the same path.</p>
",0
11807900,11807826,4,"<p>Your <code>countryServer</code> program appears to be creating a socket file called <code>countryServer</code> in the current directory, overwriting itself in the process.</p>

<p>Delete that socket file before compiling your code, or better: change your code so that it doesn't overwrite its own executable.</p>
",1
11818631,11818594,0,"<p>When you send a string over a socket ... you do <em>not</em> necessarily get the null terminator <em>unless</em> you explicitly write it in the socket.</p>

<p>I suspect that's what's happening - your strings aren't getting terminated correctly.</p>

<p>IMHO...</p>

<p>STRONG SUGGESTION:</p>

<p>Fire up the debugger, and step through the inner loop in ""readLine()"".  Make sure it's not an <em>infinite</em> loop ;)</p>
",4
11869964,11869923,4,"<p>If <code>foo</code> is a function, then (except in some specific cases*) both <code>foo</code> and <code>&amp;foo</code> express a pointer to the function: Functions immediately decay to pointers to themselves, so <code>foo(x)</code>, <code>(*foo)(x)</code> and <code>(**foo)(x)</code> are all the same.</p>

<hr>

<p>When given a choice, prefer passing functions by reference rather than by value, though:</p>

<pre><code>template &lt;typename R, typename ...Args&gt; R invoke(R (*f)(Args...), Args... args)
{
    return f(args...);

    // bad: ""&amp;f"" is not useful
}
invoke_p(add, 1, 2);
</code></pre>

<p></p>

<pre><code>template &lt;typename R, typename ...Args&gt; R invoke_r(R (&amp;f)(Args...), Args... args)
{
    return f(args...);

    // good: ""&amp;f"" is the expected function pointer
}
invoke_r(add, 1, 2);
</code></pre>

<hr>

<p><sub>*) For example, <code>sizeof(foo)</code> and <code>sizeof(&amp;foo)</code> are not the same; the former isn't legal.</sub></p>
",3
11870088,11869923,0,"<p><code>printf(""%p\t%p"",pFcn,Add)</code></p>

<p>pFcn gives the address of the function which it is pointing which in this case is the address of funciton Add. pFcn(1,2) calls the function. </p>
",0
16410731,16410689,5,"<p>Use 1 if you can.  Use 3 if you must.  Never use 2.</p>

<p>Why? Option 1 uses only storage for a single line buffer.  It traverses the file only once.  Since an open file is generally not an expensive resource, it is likely to be the cheapest and simplest.  </p>

<p>However, option 1 won't always be adequate.  Sometimes you'll need to process lines in random order.  Here's where option 3 is best.  In this case, if there's enough memory, it's by far simplest to read the whole file and extract contents into memory.  An array of strings suffices in many cases.  In yours, the lines seem to contain text representations of doubles.  So extracting these as you read is appropriate.  In general, you want to extract in a storage- and/or access-efficient form.  </p>

<p>If the file is so big the contents won't fit memory, then you must use random file access (<code>fseek</code> or <code>seek</code> in C++).  For text lines, read through it to find the offsets of the line starts.  Store these in an array to serve as a line index. Visit lines by seeking to the line start using the appropriate index entry. Then reading to the next newline.  The index will be 8 bytes per line plus the buffer for a single line. If the file is <em>really</em> big, then you can store the index in a file and seek twice per line access.  Best to put the index and data on different disk drives to reduce seek time. Another option to eliminate the index is to require that all lines have the same length, so arithmetic suffices to find any line.  </p>

<p>Option 2 would make sense only if maintaining a single open file while you're processing a line presented an excessive cost.  This will practically never be the case.  Your code will have to read O(n^2) units of data for a file of n units.  Very bad for performance as the problem gets bigger.  Since file IO is often a bottleneck of programs, this can be very bad indeed.  </p>

<p>Moreover, file open and close are fairly expensive operations, not to be done willy nilly. I once worked on a large simulation system and was asked to see if I could speed it up.  Indeed it seemd unduly slow considering what it was doing. After a couple of weeks of reverse engineering code, I finally found that a trace file was being opened for append and closed once per iteration in the event loop.  I moved the open and close outside the loop (adding an occassional flush inside the loop to replace), and whahoo! The simulation sped up by a factor of 20 or more. The client was happy to say the least.</p>
",1
12792361,12792350,1,"<p><code>return e, f;</code> doesn't do what you think it does. The comma operator simply evaluates and discards <code>e</code> and then the value of <code>f</code> is returned as a function result. Since these are globals anyway there is no need to return anything from this function, but it would be better not to use globals and do this properly. Delete the global declaration <code>double e, f;</code> and change the function to something like this:</p>

<pre><code>void scaler (int a, int b, double &amp;e, double &amp;f) {
    if (a &lt; 256) {  e = (-1) * a / 256.0;
        if (b &lt; 256) {
            f = b / 256.0;
        } else {
            f = (-1) * (b - 256.0) / 256.0;
        }
    } else { e = (a - 256.0) / 256.0;
        if (b &lt; 256) {
            f = b / 256.0;
        } else {
            f = (-1) * (b - 256.0) / 256.0;
        }
    }
}
</code></pre>

<p>In your main function you would then change these lines:</p>

<pre><code>for (int i = 0; i &lt; dimention; i++) { f = i;
    for (int j = 0; j &lt; dimention; j++) { e = j;
        scaler (e, f);
        ...
</code></pre>

<p>to this:</p>

<pre><code>for (int i = 0; i &lt; dimention; i++) {
    for (int j = 0; j &lt; dimention; j++) {
        double e, f;
        scaler (j, i, e, f);
        ...
</code></pre>
",0
11809896,11809829,0,"<p>This one is simple:</p>

<pre><code>[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?
</code></pre>

<p>It only works for IPv4 addresses.</p>

<p>This one also worked for your string:</p>

<pre><code>([0-9]{1,3}\.){3}[0-9]{1,3}
</code></pre>

<p>I tested both on this <a href=""http://www.regular-expressions.info/javascriptexample.html"" rel=""nofollow"">random page</a>. I can not tell you how reliable they are.</p>
",1
12877495,12877475,2,"<p>Your 2d array is not an array of pointers to a <code>test</code> object. 
Memory is allocated for your 2d array anyway. So no need for the loop.</p>

<p>Unless you change your declaration </p>

<pre><code>test arr[9][9];
</code></pre>

<p>to something like:</p>

<pre><code> test*** arr = new (test**)[rows];


  for(unsigned int i = 0; i &lt; 9; i++)
    {
      for(unsigned int j = 0; j &lt; 9; j++)
      {
         cin &gt;&gt; s[i][j];
         arr[i][j] = new test(s[i][j]);
      }
     }
</code></pre>
",0
12877848,12877475,0,"<p>When you declare the array as <code>test arr[9][9];</code>
then the memory is allocated and default constructor is called for each member. So you don't need call <code>new</code> to allocate new memory.
I assume that you goal is to have array of <code>test</code> objects constructed with the value read from <code>std::cin</code>.</p>

<p>Then you have several options:</p>

<ul>
<li>Easiest solution is to use 2D array of pointers:</li>
</ul>

<p>It would look like:</p>

<pre><code>test* arr[9][9];
for(unsigned int i = 0; i &lt; 9; i++)
{
  for(unsigned int j = 0; j &lt; 9; j++)
  {
     cin &gt;&gt; s[i][j];
     arr[i][j] = new test(s[i][j]);
  }
}
</code></pre>

<ul>
<li>If you want to keep the array of plain <code>test</code> objects (without pointers), the use can either:</li>
</ul>

<p>Provide a <code>test::set(int)</code> method to set the value after is was constructed.</p>

<pre><code>test arr[9][9];
for(unsigned int i = 0; i &lt; 9; i++)
{
  for(unsigned int j = 0; j &lt; 9; j++)
  {
     cin &gt;&gt; s[i][j];
     arr[i][j].set(s[i][j]);
  }
}
</code></pre>

<p>Construct temporarily object and then assign it to your already allocated one in the array using <code>operator=(const test&amp;)</code> (or <code>operator=(test &amp;&amp;)</code> in c++11).  Note that there's no <code>new</code> here:</p>

<pre><code>test arr[9][9];
for(unsigned int i = 0; i &lt; 9; i++)
{
  for(unsigned int j = 0; j &lt; 9; j++)
  {
     cin &gt;&gt; s[i][j];
     arr[i][j] = test(s[i][j]);
  }
}
</code></pre>

<p>Or use placement new (this constructs new object in the pre-allocated memory block):</p>

<pre><code>test arr[9][9];
for(unsigned int i = 0; i &lt; 9; i++)
{
  for(unsigned int j = 0; j &lt; 9; j++)
  {
     cin &gt;&gt; s[i][j];
     new(&amp;arr[i][j]) test(s[i][j]);
  }
}
</code></pre>

<ul>
<li>And last one: If you don't have specific reason to use static 2D array, go for some STL container.</li>
</ul>
",0
16377204,16377156,8,"<p>No. But beware that the <code>size</code> may not reflect the actual size AFTER the mutex is released.</p>

<p>Edit:If you need to do some work that relies on <code>size</code> being correct, you will need to wrap that whole task with a mutex. </p>
",1
16377360,16377156,5,"<p>You haven't mentioned what the type of the <code>mutex</code> variable is, but assuming it is an <code>std::mutex</code> (or something similar meant to guarantee mutual exclusion), the compiler is prevented from performing a lot of optimizations. So you don't need to worry about return value optimization or some other optimization allowing the <code>size()</code> query from being performed outside of the mutex block.</p>

<p>However, as soon as the mutex lock is released, another waiting thread is free to access the vector and possibly mutate it, thus changing the size. Now, the number returned by your function is outdated. As Mats Petersson mentions in his <a href=""https://stackoverflow.com/a/16377204/241631"">answer</a>, if this is an issue, then the mutex lock needs to be acquired by the caller of <code>getNumber()</code>, and held until the caller is done using the result. This will ensure that the vector's size does not change during the operation.</p>

<hr>

<p>Explicitly calling <code>mutex::lock</code> followed by <code>mutex::unlock</code> quickly becomes unfeasible for more complicated functions involving exceptions, multiple return statements etc. A much easier alternative is to use <code>std::lock_guard</code> to acquire the mutex lock.</p>

<pre><code>int getNumber()
{
    std::lock_guard&lt;std::mutex&gt; l(mutex); // lock is acquired
    int size = someVector.size();
    return size;
} // lock is released automatically when l goes out of scope
</code></pre>
",0
16377366,16377156,1,"<p>Volatile is a keyword that you use to tell the compiler to literally actually write or read the variable and not to apply any optimizations. Here is an example</p>

<pre><code>int example_function() {
int a;
volatile int b;
a = 1; // this is ignored because nothing reads it before it is assigned again
a = 2; // same here
a = 3; // this is the last one, so a write takes place 
b = 1; // b gets written here, because b is volatile
b = 2; // and again
b = 3; // and again
return a + b; 
}
</code></pre>

<p>What is the real use of this?  I've seen it in delay functions (keep the CPU busy for a bit by making it count up to a number) and in systems where several threads might look at the same variable.    It can sometimes help a bit with multi-threaded things, but it isn't really a threading thing and is certainly not a silver bullet</p>
",0
11825008,11824964,2,"<p>There's no need for regular expression replaces (I would even advice against doing so). Instead of duplicating your new code, just create another macro:</p>

<pre><code>#ifdef LOAD_TEXTURES_FROM_CF
#define CreateTextureFromFile(a, b, c) CreateTextureFromResourceFile((a), (b), (c))
#else
#define CreateTextureFromFile(a, b, c) D3DXCreateTextureFromFileA((a), (b), (c))
#endif
</code></pre>

<p>Then just replace all previous occurances of <code>D3DXCreateTextureFromFileA</code> with <code>CreateTextureFromFile</code> and you should be fine.</p>
",2
15886759,15886726,4,"<p>They continue to be private since by default they are private. Public inheritance will not make them public. Otherwise, it violates encapsulation.</p>
",0
15886820,15886726,1,"<p>The private member of derived class remain as private irrespective of whether it inherits from base class as public.</p>
",0
11827187,11826885,2,"<p>If you are on C++11/use Boost (which I strongly recommend!) use regular expressions. Once you gain some level of understanding all text processing becomes easy-peasy!</p>

<pre><code>#include &lt;regex&gt; // or #include &lt;boost/regex&gt;

//! \return A separating character or 0, if str does not match the pattern
char getSeparator(const char* str)
{
    using namespace std; // change to ""boost"" if not on C++11
    static const regex re(""^AD(.)Andorra$"");
    cmatch match;
    if (regex_match(str, match, re))
    {
        return *(match[1].first);
    }
    return 0;
}
</code></pre>
",0
11826937,11826885,0,"<p>assuming your character always starts at position 3!
use the string functions <code>substr</code>:</p>

<pre><code>your_string.substr(your_string,2,1)
</code></pre>
",1
11826977,11826885,4,"<p>The problem can be solved generally with a regular expression match. However, for the specific problem you presented, this would work:</p>

<pre><code>std::string input = getinput();
char at2 = input[2];
input[2] = '#';
if (input == ""AD#Andorra"") {
    // match, and char of interest is in at2;
} else {
    // doesn't match
}
</code></pre>

<p>If the <code>?</code> is supposed to represent a string also, then you can do something like this:</p>

<pre><code>bool find_inbetween (std::string input,
                     std::string &amp;output,
                     const std::string front = ""AD"",
                     const std::string back = ""Andorra"") {
    if ((input.size() &lt; front.size() + back.size())
        || (input.compare(0, front.size(), front) != 0)
        || (input.compare(input.size()-back.size(), back.size(), back) != 0)) {
        return false;
    }
    output = input.substr(front.size(), input.size()-front.size()-back.size());
    return true;
}
</code></pre>
",1
11826993,11826885,0,"<p>If you are using C++11, i recommend you to use regex instead of direct searching in your string.</p>
",0
12785317,12779586,9,"<p>Even though it is undefined behavior, you should probably take note of the most likely result (for the sake of debugging such issues).</p>

<p>When you create an array via <code>new Object[100]</code>, the memory is first allocated. The default behavior (provided there were no overrides to the default allocator) is to simply call <code>malloc(100 * sizeof(Object))</code>. After that, the constructor for <code>Object</code> needs to be called on each <code>Object</code>-sized region. This is an important detail: <strong>the memory is allocated once</strong>, but the constructor is called in 100 locations.</p>

<p>When a block is allocated via <code>malloc</code>, it cannot be freed in pieces. Only a call to <code>free(block)</code> will release that memory. The C++ keyword <code>delete</code> internally calls <code>free</code> if the keyword <code>new</code> calls <code>malloc</code>. So, the proper way to delete an array is to call <code>delete [] array</code>. So, what happens if you call <code>delete array</code>? The likely answer is that the memory will be freed (all of it, not just the first element), but only one destructor will be called: the first element's destructor.</p>

<p>Obviously, there are lots of facts to consider. <code>new</code> and <code>delete</code> are not necessarily bound to <code>malloc</code> and <code>free</code>. They may use system calls unique to a specific architecture or operating system. (Windows, in particular, has a whole set of heap management functions outside of <code>malloc</code> and <code>free</code> in its C API.) I simply demonstrated the example with <code>malloc</code> and <code>free</code> because that is what I have seen the most often when stepping through code. Visual Studio, for example, lets you step into <code>new</code> calls and actually see the <code>new</code> function code. (That's another important detail. <code>new</code> and <code>delete</code> are simply function calls, which you can even override in many cases.)</p>

<hr>

<p>You can demonstrate this concept with this little program. Simply create an <code>Object</code> class that outputs something during the constructor and outputs something else during the destructor.</p>

<pre><code>int main(int argc, char** argv)
{
    Object* o = new Object[4];
    delete o;
    return 0;
}
</code></pre>

<p>I ran it, and sure enough: the constructor was called 4 times, and the destructor was called once.</p>
",16
12813879,12813765,0,"<p>o is the local variable of <code>output()</code> so it has scope and life time only inside the function. and as the function is returning a memory address its the deleted memory's address is being returned. </p>

<p>if it had been value which is returned the program would have worked because of the ""return by value"" method.</p>

<p>If you need the correct output instead of default memory specifier <code>auto</code> you need to use something else like <code>static</code> or <code>extern</code> memory allocation, or dynamic memory allocation. </p>
",0
12813787,12813765,4,"<p>Because you return a pointer to invalid memory - <code>o</code> is destroyed when <code>output</code> returns.</p>

<p>You have several options:</p>

<ul>
<li>allocate memory dynamically (using <code>malloc</code>), copy <code>""A""</code> into this memory and return its address</li>
<li>directly return string literal: <code>return ""A"";</code></li>
</ul>

<p>P.S. Of course, you may use <code>std::string</code> and you will not have this issue. Or use in/out param, instead of return.</p>
",0
11815477,11815453,2,"<p>Is that what you want? </p>

<pre><code>void showAllRecords ()
{
  int i=0;
  char * result;
  for (i=0; i&lt;NoOfRecordsRead; i++)
  {
    result = displayRecordContent (globalCountryDataArray [i]);
    if(*result == 'A') // or other letter
      printf (""(%d) %s\n"", i, result);
  }
}
</code></pre>
",0
11815479,11815453,2,"<pre><code>void showAllRecords (char begin)
{
  int i=0, j=0;
  char * result;
  for (i=0; i&lt;NoOfRecordsRead; i++)
  {
    result = displayRecordContent (globalCountryDataArray [i]);
    if (result[0] == begin) {
        printf (""(%d) %s\n"", j, result);
        j++;
    }
  }
}
</code></pre>
",0
16939256,16939147,11,"<p>Use <code>std::sort</code>.</p>

<pre><code>std::sort(vec.begin(), vec.end(), [](const cv::Point2f &amp;a, const cv::Point2f &amp;b) {
    return (/* This is where you would compare a and b however you want */);
});
</code></pre>

<p>Really, it's quite hard to tell what you deem as the greatest (x,y) pair and the least (x,y) pair. One solution is to add the coordinates to give them a magnitude.</p>

<p>I'd use the distance from the origin: <code>return a.x*a.x + a.y*a.y &lt; b.x*b.x + b.y*b.y</code></p>

<hr>

<p>In case you can't use C++11 functionality, here's the equivalent of the above solution:</p>

<pre><code>bool point_comparator(const cv::Point2f &amp;a, const cv::Point2f &amp;b) {
    return (/* Your expression */);
}

std::sort(vec.begin(), vec.end(), point_comparator);
</code></pre>
",4
16939266,16939147,2,"<p>If your Point class has operator &lt; that evaluates like your rule (or you can add one), just call <code>std::sort</code>.  Otherwise write your compare function and call  <a href=""http://www.cplusplus.com/reference/algorithm/sort/"" rel=""nofollow"">std::sort</a> second form passing it as last param.  You can make it a lambda if your compiler is C++11-compatible.</p>

<p>Remember that the compare function must be transitive. </p>
",0
16939336,16939147,2,"<p>Let's just arbitrarily assume that you determine the value of a point by adding the x and y (big assumption). Sorting is a fairly simply process:</p>

<pre><code>bool sort (const cv::Point p1, const cv::Point p2) { return (p1.x + p1.y) &lt; (p2.x + p2.y)); }

//int main or where ever
//assuming name of vector is myVector
std::sort(myVector.begin(), myVector.end(), sort);
</code></pre>

<p>Just change the sort method to illustrate how you want to sort</p>
",0
11826208,11826079,0,"<p>You would need a reliable way to find a location that you always expect the delimiter to be. If the first field is always 2 characters wide, you can check to see if the 3<sup>rd</sup> character is a <code>,</code>. Otherwise, you can scan backwards on the first line of text to see if the first non-currency related character is a <code>,</code>.</p>

<p><strong>Edit:</strong> Your <code>readData</code> routine is very C-centric, as has been pointed out in comments. You can simplify it considerably by using C++ features.</p>

<pre><code>std::string aLine;
std::ifstream pfile(INPUT_FILE_NAME);
while (pfile) {
    std::getline(pfile, aLine);
    if (aLine.size()) {
        globalCountryDataArray.push_back(createCountryRecord(aLine));
    }
}
</code></pre>
",0
11826354,11826079,0,"<pre><code>#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;

bool detect_comma(std::string file_name)
{
    // open C++ stream to file
    std::ifstream file(file_name.c_str());
    // file not opened, return false
    if(!file.is_open()) return false;
    // read a line from the file       
    std::string wtf;
    std::istream &amp;in= std::getline(file, wtf);
    // unable to read the line, return false
    if(!in) return false;
    // try to find a comma, return true if comma is found within the string
    return std::find(wtf.begin(), wtf.end(), ',')!= wtf.end();
}


#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main()
{
     if(!detect_comma(""yourfile.dat""))
     {
         std::cerr&lt;&lt; ""File is not comma delimited!\n"";
         return EXIT_FAILURE;
     }
     // file is OK, open it and start reading
}
</code></pre>

<p>Edit: Added comments &amp; example code</p>
",1
11826816,11826079,0,"<p>A good way to perform your check is using the Boost.Regex library. You only have to define your regular expression and perform a check if your input matches the expression.</p>

<p>Sample code:</p>

<pre><code>#include &lt;string&gt;
#include &lt;boost/regex.hpp&gt;

using namespace std;

int main()
{
  const string input(""AD,Andorra,AN,AD,AND,20.00,Andorra la Vella,Europe,Euro,EUR,67627.00"");
  const boost::regex ex(""(?:(?!,)(\\d+\\.\\d*)|(\\w|\\s)*)(,(?:(?!,)(\\d+\\.\\d*)|(\\w|\\s)*))*"");
  cout &lt;&lt; boost::regex_match(input.c_str(), ex) &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>By the way: I'm not a regex expert so validate the expression :-)</p>
",0
11845149,11844886,2,"<p>There are two possibilities:</p>

<ol>
<li><p><code>happyFunction</code> is supposed to take ownership of the pointer, and the caller never worries about it. In this case, it would be more sensible to write</p>

<pre><code>void happyFunction(std::unique_ptr&lt;Car&gt; &amp;&amp;car)
{
    // car is mine now, and is automatically destroyed when I return
    // unless I explicitly request otherwise
}

void caller()
{
    happyFunction(std::unique_ptr&lt;Car&gt;(new Car));
    // the new Car is immediately handed over to the unique_ptr
    // and I don't have to worry about leaks
}
</code></pre></li>
<li><p><code>happyFunction</code> is only supposed to <em>use</em> the pointer: the caller retains control and ownership. In this case, it would be better to pass a reference so there is no suggestion that ownership is transferred</p>

<pre><code>void happyFunction(Car &amp;car)
{
    // car is still owned by the caller,
    // I just get a reference to use in here
}

void automatic_caller()
{
    Car car;
    happyFunction(car);
    // car is always owned by me, and is
    // automatically destroyed at the end of this scope
}

// alternatively (only if car should live longer than the enclosing scope)
void dynamic_caller()
{
    std::unique_ptr&lt;Car&gt; car(new Car);
    // or get pointer from somewhere else ...
    // or get shared_pointer, etc. etc.
    happyFunction(*car);
    // again car is destroyed here unless we do something special
}
</code></pre></li>
</ol>
",5
11844950,11844886,7,"<pre><code>happyFunction(new Car()); 
</code></pre>

<p>It's not bad practice in itsself (although almost certainly is wrong), the memory could be deleted inside the function. But that would be confusing so it's really not the best idea.</p>

<p>Also although it's safe with one parameter, if it was like this </p>

<pre><code>happyFunction(new Car(), new Thing()); 
</code></pre>

<p>And one of the news threw an exception after the other new executed, the would be no way to free the memory so it's not safe.</p>

<p>You always have to free memory yourself in c++ so your second example leads to a big memory leak. There are classes such as unique_ptr and shared_ptr to help you manage it without having to write a delete yourself, you can find any number of tutorials online about them</p>
",0
16433015,16432959,14,"<pre><code>throw c;     
</code></pre>

<p>Creates a temporary object and it is this temporary object that is thrown. The creation of the temporary might be through copy/move constructor. And yes this copy/move can be elided.</p>

<hr>

<p><strong>References:</strong><br>
<strong>C++11  15.1 Throwing an exception</strong>       </p>

<p><strong>¡ì3:</strong> </p>

<blockquote>
  <p><strong>A throw-expression initializes a temporary object, called the exception object</strong>, the type of which is determined by removing any top-level cv-qualifiers from the static type of the operand of throw and adjusting the type.........</p>
</blockquote>

<p><strong>¡ì5:</strong>        </p>

<blockquote>
  <p>When the thrown object is a class object, the copy/move constructor and the destructor shall be accessible, even if the copy/move operation is elided (12.8). </p>
</blockquote>
",7
12784409,12784385,5,"<p>It's a <em>default</em> value for the template template argument. If you don't specify the argument, it will default to <code>myarray</code>.</p>

<p>Example:</p>

<pre><code>template &lt;typename&gt; class Foo;
template &lt;typename&gt; class Bar;

template &lt;typename T, template &lt;typename&gt; class C = Foo&gt;
class Zip
{
    typedef C&lt;T&gt; type;  // example use of ""C""
    // ...
};

Zip&lt;int, Bar&gt; x;  // OK
Zip&lt;int&gt;      y;  // OK, y has type Zip&lt;int, Foo&gt;
</code></pre>
",0
12784417,12784385,1,"<p>It is basically the ""default value"" for the argument.</p>
",0
11860988,11860970,0,"<p>Yes, you will</p>

<pre><code>p = new int [val+1]; //allocate array on the heap
p = &amp;buff[bBreak[k]]; //new allocated array is leaked because you lost the pointer to it
//and you are not able to call 'delete[]' to free the memory
</code></pre>

<p>Generally, every call to operator <code>new</code> should be paired with call of operator <code>delete</code> or <code>delete[]</code></p>
",0
11860997,11860970,1,"<p>Yes! You never free the memory. You should call <code>delete/delete[]</code> for every piece of memory you allocate with <code>new/new[]</code>.</p>
",3
11861128,11860970,0,"<p>Yes. You must <code>delete</code> every memory you allocate with <code>new</code>.</p>

<pre><code>p = new int [val+1];
p = &amp;buff[bBreak[k]]; // here you lose track of the memory you've just allocated
</code></pre>

<p>If you don't want to do memory management by-hand, use a <code>std::vector&lt;int&gt;</code>.</p>
",0
11815434,11815416,1,"<p>If x and y are C++ strings then you just say <code>x == y</code>. You are trying to use a C function <code>strcmp</code> on a C++ object. </p>

<p>If y is a C style string then the same code <code>x == y</code> will also work because the C style string will automatically be converted to a C++ style string, however in this case it might be better to do <code>strcmp(x.c_str(), y) == 0</code> because this avoids the automatic conversion.</p>

<p>Only if x and y are both C style strings should you do <code>strcmp(x, y) == 0</code>.</p>
",2
11815444,11815416,0,"<p>X is a string, and strcmp compares const char*
To convert a string to a const char* use</p>

<pre><code>x.c_str ()
</code></pre>
",0
11815447,11815416,1,"<p>The error is because strcmp expect a <code>const char*</code> that is different from a <code>std::string</code>. You can retrieve a const char * invoking method <code>c_str()</code> on that string:</p>

<pre><code>if (strcmp(x.c_str(),y) == 0)
</code></pre>

<p>In addition to that, it seems that 'y' parameter is declared nowhere inside your code. </p>
",0
11815450,11815416,-1,"<p>jahhaj is right, but if you want to call a C function on a string, you can use <code>string_instance.c_str()</code> to get the string as a <code>const char *</code></p>
",0
11815468,11815416,0,"<p>The compiler expect a <code>const char*</code> or something convertable to <code>const char*</code>. But <code>std::string</code> is not implicitly convertable to <code>const char*</code>.</p>

<p>If you want to use <code>strcmp</code>, you have to use the method <code>c_str</code> to get a <code>const char*</code>. But in your case, it's probably better to use <code>==</code> which is overloaded to work with std::string.</p>
",0
11887510,11884355,0,"<p>What OS? If Windows then instead of the CPU serial you could uniquely identify the pc using the volume serial number associated with the filesystem using the system call <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa364993%28v=vs.85%29.aspx"" rel=""nofollow"">GetVolumeInformation()</a></p>

<pre><code>DWORD serial;
::GetVolumeInformation(_T(""C:\\""), NULL, 0, &amp;serial, NULL, NULL, NULL, 0);
</code></pre>

<p>Then use <code>serial</code> as your unique identifier instead.</p>
",3
11822532,11822520,6,"<p>With this line:</p>

<pre><code>int *dd3 = new int(8);
</code></pre>

<p>You're allocating and initializing a <em>scalar</em>, not an array: a single <code>int</code>, initialized with the <em>value</em> <code>8</code>.</p>

<p>You need:</p>

<pre><code>int *dd3 = new int[8];
</code></pre>
",0
11822533,11822520,6,"<pre><code>int *dd3 = new int(8);
</code></pre>

<p>This statement only allocates space for a single integer (and then initializes it with the number 8). You then proceed in using this pointer like a larger array, leading to undefined behavior that may (and indeed, seems to) manifest itself later on.</p>

<p>Using <code>new</code> here seems unnecessary (and exception-unsafe, if nothing else). Just use a <code>vector</code> and be done with it (should you want to be able to resize the block inside the function, just pass the vector instead of a pointer).</p>
",1
11822536,11822520,6,"<p>This line allocates a <strong>single</strong> <code>int</code> and initializes it to the value <code>8</code>:</p>

<pre><code>int *dd3 = new int(8);
</code></pre>

<p>If you want an array of 8 <code>ints</code> do this instead:</p>

<pre><code>int *dd3 = new int[8];
</code></pre>

<p>Don't forget to correctly return the memory when you are done:</p>

<pre><code>delete [] dd3;
</code></pre>
",0
11834025,11833571,1,"<p>Unless you have a horrible compiler bug, I would guess something like this is happening:</p>

<p>_cycles has some small fraction remaining after the subtractions. As long the compiler knows nothing else is changing its contents, it keeps its value in a higher precision floating point register. When it sees the I/O operation it is not certain the value of _cycles is needed elsewhere, so it makes sure to store its contents back to the double-precision memory location, rounding off the extra bits that were in the register. The next check assumes pessimistically the value might have changed during the I/O operation, and loads it back from memory, now without the extra bits that made it non-zero in the previous test.</p>

<p>As Daniel Fischer mentioned in a comment, using <code>-ffloat-store</code> inhibits the use of high-precision registers. If the problem goes away when using this option then the scenario I described is very likely. Check the assembly output of <code>Router::Evaluate</code> to be sure.</p>
",16
13703192,13703112,3,"<p>Because they are different types. Even for this empty class template</p>

<pre><code>template &lt;int N&gt; struct Foo {};
</code></pre>

<p><code>Foo&lt;1&gt;</code> is a different type to <code>Foo&lt;2&gt;</code>. When such a template is instantiated with a template parameter, it creates a distinct class, irrespective of whether the template parameter is used in the code of the class. A class template is a recipe (a template) for building a class according to some (template) parameters.</p>

<p>Now, if you want to be able to construct one <code>Foo</code> instnatiation from another, then you can add an implicit converting constructor:</p>

<pre><code>template &lt;int N&gt; 
struct Foo 
{
  template &lt;int M&gt; Foo(const Foo&lt;M&gt;&amp; rhs) {}
};
</code></pre>

<p>Then you can implicitly convert between one and the other:</p>

<pre><code>Foo&lt;42&gt; a;
Foo&lt;1&gt; b (a);
Foo&lt;99&gt; c;
c = b;
</code></pre>
",6
13703282,13703112,0,"<p>How do you want compiler to prove that?</p>

<p>Consider:</p>

<pre><code>template&lt;int N&gt;
class xyz{
void foo () {external_function (N);}
};
</code></pre>

<p>Do you suggest compiler to go and check what <code>external_function</code> does?</p>

<p>Besides having compiler produce compatible types on the grdounds of N not being used would have been a maintanence nightmare.</p>
",1
13703367,13703112,1,"<p>Each time you use a different value of <code>N</code>, the compiler will create a new class definition.
Using template value or not change nothing.</p>

<p>it's the same for function parameters :</p>

<pre><code>int foo(void) {          // foo is of type `int (*)()`
    return 1;
}

int bar(int not_used) {  // bar is of type `int (*)(int)`
    return 1;
}
</code></pre>

<p><code>bar</code> don't use parameter, but it hasn't the same signature as <code>foo</code>.</p>

<p>Like you can't assign <code>foo</code> or <code>bar</code> to a same variable (because their types differs), you can't mix instances of <code>xyz&lt;0&gt;</code> and <code>xyz&lt;1&gt;</code>.</p>

<p>If you want to do this, you shoud consider using a classic inheritance.</p>
",0
13703450,13703112,0,"<p>I assume you mean ""copy-constructible and assignable from each other"" when you say compatible.</p>

<p>You will need to define the copy-constructor and assignment operator
to handle classes instantiated with arbitrary values of int.</p>

<pre><code>template&lt;int N&gt;
class Foo {
public:
  template&lt;int NO&gt;
  Foo(const Foo&lt;NO&gt;&amp; other) {
    // do stuff
  }

  template&lt;int NO&gt;
  Foo&amp; operator=(const Foo&lt;NO&gt;&amp; other) {
    // do stuff
    return *this;
  }
};
</code></pre>
",0
13703524,13703112,1,"<p>Template type equivalence rules are explicitly written out in the Standart (paragraph 14.4). One rule states:</p>

<blockquote>
  <p>Two template-ids refer to the same class or function if</p>
  
  <ul>
  <li>their corresponding non-type template arguments of integral or enumeration type have identical values</li>
  </ul>
</blockquote>

<p>Thus, different numeric template arguments will yield different types, regardless whether they are actually used or not. In the latter case you might want to use template copy constructor:</p>

<pre><code>template&lt;int N&gt;
class xyz{

  template&lt;int M&gt;
  xyz::xyz(const xyz&lt;M&gt;&amp;);

};
</code></pre>
",0
11875427,11875350,2,"<p>Flattening just means they want the nodes in a linear order. There are several common orderings of a tree: preorder, inorder, or postorder, where the parent node appears before, in between, or after its children respectively.</p>
",0
11875437,11875350,5,"<p>Suppose you have a binary tree like so:</p>

<pre><code>    a
   / \
  b   c
 / \   \
0   0   d
       / \
      0   0
</code></pre>

<p>Where <code>a</code>, <code>b</code>, etc. are nodes and <code>0</code> is nil. There are several possible recursive <a href=""http://en.wikipedia.org/wiki/Tree_traversal"" rel=""noreferrer"">traversals</a> of the tree:</p>

<ul>
<li><p>Pre-order, visiting parents before children: <code>a b c d</code></p></li>
<li><p>In-order, visiting parents between children: <code>b a c d</code></p></li>
<li><p>Post-order, visiting parents after children: <code>b d c a</code></p></li>
</ul>

<p>A ¡°flattening¡± of a tree is merely a list resulting from a traversal; your data structure is no longer nested, but flat instead. To flatten a tree, begin with an empty linked list. Then traverse the tree in the order of your choosing, appending each visited node to the linked list. I presume ¡°the tree can be modified¡± means that your function may alter the tree as it builds the list, if you find it necessary to do so.</p>
",2
12831033,12831008,1,"<p>If what your seeking to do is something like this:</p>

<pre><code>Square s;
Triangle t;
t.colour(); // invoke Square::colour() on a Triangle
</code></pre>

<p>I'm sorry but you can't, unless you declare a function in Triangle which simply mimics what <code>Square::colour</code> does.</p>

<p>A wise option if you really need that function to be shared is to declare it as a standalone templated function like this:</p>

<pre><code>template&lt;typename Shape&gt;
void colour(Shape s){
  //Do stuff
}
</code></pre>

<p>then in order to allow this access to the inner guts of Triangle and Square, make <code>void colour&lt;Triangle&gt;()</code> and <code>void colour&lt;Square&gt;()</code> friends of the appropriate classes.</p>
",1
12831077,12831008,0,"<p>The answer is no, your request is not possible.  The colour method is encapsulated within square and will not apply to an unrelated object of a difference class.  Either inherit (from shape - I know you said no inheritance), or re-implement the colour method for square as well.</p>
",0
12831090,12831008,0,"<p>No, sorry to bum you out. But i would recommend using a base class 'shape', and derive shapes from this class.</p>

<pre><code>class Abc //Abstract base class
{
    public:
        virtual ~Abc();                             //destructor
        virtual double Color();           
        virtual double Area() const = 0;                  //pure virtual, MUST be overridden
    private:
        //specific variables that apply to all shapes
};

class Square : public Abc //derived class from pure virtual class
{
    public:
        Square();
        virtual double Color();
        virtual double Area() const; //redefine color here
        ~Square(){}
    private:
        //square vars here
};
</code></pre>
",0
15872519,15872329,1,"<p>You don't have <code>break</code> statements in the <code>if (next == 0)</code>, meaning execution continues to the next <code>case</code> clause. If you want to re-run the switch statement, you need to put it in a loop and put breaks correctly.</p>

<p>The only cases where can have no break statement at the very end of case are (1) you have a return there instead, and (2) you actually want the next case clause to execute as well.</p>
",1
15872524,15872329,2,"<p>Switch statements don't recurse.</p>

<p>Imagine your code (it's a rather large example), without any of the switch statement code. No <code>switch</code>, <code>case</code>, <code>break</code>, etc.</p>

<p>If you execute your code, all of it will execute, the entire block.</p>

<p>The <code>switch</code> statement allows you to execute a part of that block. The <code>case</code> statement chooses where to begin and the <code>break</code> statement chooses where to end. That's all.</p>
",2
12803825,12803784,2,"<p>You only declare <code>static</code> member methods as <code>static</code> inside the class, not outside. The definition should be:</p>

<pre><code>float File2::computeData(string s,int a,int b,float c,float d)
{
   float result;
   //the compute code
   return result;
}
</code></pre>

<p>No <code>static</code> keyword outside the class.</p>

<p>Outside of a class definition, <code>static</code> gives internal (or static) linkage, which is not permitted for static member functions:</p>

<pre><code>class X
{
    static void foo(); //static class member
};

static void foo();     //static free function w/ internal linkage
</code></pre>
",0
12803864,12803784,2,"<p>These are two meanings of <code>static</code>.  Declaring a static member function is done in the class definition <strong>only</strong>, and means that the function takes no <code>this</code> pointer at runtime (i.e. it's a regular function which happens to have access to private data in class <code>File2</code>).  Declaring a function <code>static</code> in its definition is the C syntax for <code>static</code>, and means that the function is not visible/linkable outside its current file.  In C++, member functions cannot have static linkage.  Don't put <code>static</code> in the definition of a static member function.</p>
",0
11856324,11856316,8,"<p><code>""Derived""</code> is a <strong>string literal</strong> (look it up). If you attempt to modify a string literal, you get undefined behaviour, so the return type is marked <code>const</code> so you don't accidentally modify it.</p>
",0
11856333,11856316,1,"<p>What you are looking at is a <a href=""http://en.wikipedia.org/wiki/C_string"" rel=""nofollow"">C-String</a>. It is a pointer to the first element of an array of <code>chars</code>, and is <code>const</code> because you shouldn't edit a character literal.</p>
",0
11856371,11856316,0,"<p>Remember in C++ you cannot return a bunch of values from a function. As they said, this returns a pointer to where a group of sequential characters ares saved. A pointer is a reference to an address in memory.
When you write a getValue method in class most of the time you only want to let know whoever is outside what the value is, but just as read only, because you as the class are the only owner of that value and if the value gets changed from a random place and not from a setValue method it can cause problems.</p>
",0
12292500,12292422,4,"<p>If your file is that simple, you can simply do the following:</p>

<pre><code> std::vector&lt;std::vector&lt;int&gt;&gt; v;
 ifstream input(""input.txt"");
 for(int x, y, z; input &gt;&gt; x &gt;&gt; y &gt;&gt; z;)
     v.push_back(std::vector&lt;int&gt;{x, y, z});
</code></pre>

<p>Or with <code>std::tuple</code>:</p>

<pre><code> std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; v;
 ifstream input(""input.txt"");
 for(int x, y, z; input &gt;&gt; x &gt;&gt; y &gt;&gt; z;)
     v.emplace_back(x, y, z);
</code></pre>

<p>This requires no conversions at all and will fail as soon as the stream fails. Both require, C++11 support, so if you need a C++03 solution, let me know.</p>

<p>If you want to stick with plain, old arrays:</p>

<pre><code> ifstream input(""input.txt"");
 for(int i = 0; input &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; z[i]; ++i)
     ;
</code></pre>
",0
12292518,12292422,4,"<p>creating a stringstream with the string returned from getline will probably be the most ""C++"" way to do what you are trying to do.</p>

<pre><code>std::vector&lt;int&gt; x, y, z;
ifstream input (""input.txt"");
if(input.is_open())
{
    std::string line;
    int i;
    while (std::getline (input, line))
    {
        std::stringstream parse(line);
        // assuming 3 just like you had
        parse &gt;&gt; i;
        x.push_back (i);
        parse &gt;&gt; i;
        y.push_back (i);
        parse &gt;&gt; i;
        z.push_back (i);
    }
}
</code></pre>

<p>The conditional check isn't necessary, but I left it as you had it originally.</p>
",1
14730015,14729958,1,"<p>It's not a comment, but a valid and (probably) essential statement in your program:</p>

<pre><code>/*******************************/ -- comment
waitThread.push_front(workerID); -- statement
/******************************/ --comment
</code></pre>
",2
14730018,14729958,4,"<p>std::thread is not copyable so you can't call push_front with it. It makes no sense to copy a thread, what would it do?</p>

<p>You can perhaps move the thread onto the list using </p>

<pre><code>waitThread.push_front(std::move(workerID));
</code></pre>

<p>which will of course invalidate the thread object after that line.</p>

<p>However this line looks strange too :-</p>

<pre><code>std::thread workerID(insertList, workerID.get_id());
</code></pre>

<p>I doubt it's valid to call get_id on an object that isn't constructed at that point.</p>
",0
14730034,14729958,2,"<p><code>std::thread</code> is not copyable so you would have to move it in:</p>

<pre><code>waitThread.push_front(std::move(workerID));
</code></pre>

<p>alternatively, you can move it by passing a temporary:</p>

<pre><code>waitThread.push_front(std::thread(insertList, workerID.get_id());
</code></pre>
",0
12805744,12805337,-3,"<p>I will make my answer simple.</p>

<p>Consider a web application. It is typically written in HTML, Javascript, CSS and, say, PHP. There may also be SQL used within it.</p>

<p>I will assume that you do not need me to give code examples of this extremely common scenario, and instead leave you to ponder on how considering this scenario answers your question. :)</p>
",0
12805426,12805337,4,"<p>It might make sense to build different parts of an application in different technologies or languages. Some of the reasons might be:</p>

<ul>
<li>Performance requirements in a specific component; and therefore using a low-level language, when other components benefit more from a high-level language, allowing better developer productivity.</li>
<li>""Best tool for the job"" - the technology stack for presenting forms might not be good for crunching numbers.</li>
<li>Migrating legacy apps - if you have a large codebase you need to migrate, it could make sense to migrate small parts instead of doing one big bang integration (those tend to fail).</li>
</ul>

<p>If you are using two different languages that can run in the same runtime environment, the combination can be trivial. For example a .NET application that leverages both a C# and an F# assembly - or a C application with parts assembly code linked in.</p>

<p>However, for large applications today, the most common case is to have software components connected by services or message bus technologies; moving data and events from one component to another. Out-of-process communication can also be as simple as two components sharing a database or a file.</p>
",5
12805827,12805337,1,"<p>If you work in C++ you actually use programs written in different languages all the time, most likely.  Many of the functions in the Standard Library, like <code>operator new</code>, are implemented in Assmebly language, for speed.</p>

<p>@driis has already addressed two of the main ways in which components written in different languages can interract.  There's at least one more.</p>

<p>A single application can be made up of multiple components written in different languages.  For example, one program I work on has parts written in C++ and other parts written in Assembly.  I've worked on programs written in FORTRAN + C, even VB and C++ (Ick, not fun).</p>

<p>The idea is simple in concept.  All you need to do is make sure that one side knows where the other side's function is in memory, and that both sides using the same <a href=""http://en.wikipedia.org/wiki/Calling_convention"" rel=""nofollow"">calling convention</a> for the call.  </p>

<p>The calling convention is an agreement on what order parameters and return addresses are pushed on to the stack, and other stuff like that.</p>

<p>Getting the address of the functions can be anywhere from a piece of cake to a nightmare.  In Windows C++ DLLs for example, it's easy.  Just link to the .lib and you good.  Getting VB to call a C or C++ function is a little trickier because VB doesn't know how to use these .lib files -- at least it didn't back in the day.  You had to do tricky stuff like what's posted <a href=""http://www.dreamincode.net/forums/topic/287584-calling-a-function-in-c-dll-from-vb60/"" rel=""nofollow"">here</a>.  You have to load the DLL directly and then assign a pointer to the address of the function.</p>
",3
12805647,12805337,1,"<p>To answer the how:</p>

<p>Ultimately, all compiled languages and scripting languages must be converted to a given machine's native machine code in order to be executed.</p>

<p>Compiler programming languages typically pass through several stages of conversion on their journey from source code to executable binaries - and one step on that road is binary libraries.</p>

<p>Now, if there's a standardised ABI (application binary interface) at such a level that standardises how a function call is made (parameters are passed, stack behaviour etc) then it would be possible to compile a diverse set of languages to converge on this ABI, and have the linker link them to produce an executable binary that is formed from what was originally a mix of diverse languages.</p>

<p>However, you can't just choose a diverse set of languages on a given platform.  To support this scheme, there needs to be a front end compiler that converges on this common back-end.</p>

<p>Scripting languages may also have so called 'bindings' to compiled languages, allowing them to be integrated in this same way, but at run-time.</p>
",0
12805667,12805337,1,"<p>Firefox and Photoshop have language bindings and have various runtime plugins that allow for the other languages to be used. These are in cases where extensibility and ease of development is better and allows for third party additions to be made.</p>

<p>Examples of this are:</p>

<ul>
<li>Lua bindings</li>
<li>avascript bindings</li>
</ul>

<p>The other example you have of Amazon and mixing of languages allows for distributed parts of their system to be written in a language that makes more sense in that particular area. Does the portion require a lot of speed? C++. Is there not a lot of logic but you incur a lot of call backs? NodeJS. There are a lot of problems that can be solved much easier and quicker in other languages than say sticking with just Java or C++.</p>

<p>Examples of how this is done:</p>

<ul>
<li>Message passing</li>
<li>Databases</li>
<li>RPC calls</li>
<li>Remote API's</li>
</ul>
",1
11830116,11830081,3,"<p>Change</p>

<pre><code>RationalNumber(int n, int d)
</code></pre>

<p>in your .cpp to</p>

<pre><code>RationalNumber::RationalNumber(int n, int d)
</code></pre>
",6
11830130,11830081,1,"<p>Your .cpp file functions are defined as free functions.  Put RationalNumber:: before their names to define them as member functions of the class.</p>
",4
11809450,11809441,7,"<p>I believe that this is it</p>

<pre><code>int main(){}
</code></pre>
",8
11809473,11809441,6,"<p><code></code></p>

<p>This will compile, but not link. ;)</p>

<pre><code>~/blargh
16:48:24 $ cat t.cpp


~/blargh
16:50:21 $ clang++ -c t.cpp 
~/blargh
16:50:28 $ 
</code></pre>
",5
11809487,11809441,12,"<p>The following should be the shortest:</p>

<pre><code>int main(){}
</code></pre>

<p>Note that omitting the return value without invoking undefined behaviour is possible only with <code>main()</code>.</p>
",9
14839427,14838827,0,"<p>You need to allocate ground_truth_filename before you can copy characters into it. </p>

<pre><code> if (ground_truth_filename == 0)
  {
    int length = strlen(filename) + strlen("".yaml"") + 1;
    ground_truth_filename = new char[length];
    sprintf(ground_truth_filename,""%s.yaml"",filename);   
  }
</code></pre>
",4
14839443,14838827,1,"<p>The first argument of <code>sprintf</code> must be a pointer to a buffer large enough to hold the output.  A <code>NULL</code> pointer or a pointer to a smaller char buffer (e.g. the string literal """") will cause a crash.</p>

<p>Code that would work is:</p>

<pre><code>char buf[256];

if (ground_truth_filename == NULL) {
   int charsneeded = snprintf(buf,sizeof(buf),""%s.yaml"",filename);
   if (charsneeded &gt;= sizeof(buf)) {
     return FILE_ERROR; // filename too long
   }
   ground_truth_filename = buf;
}
</code></pre>

<p>The point is that <code>buf</code> gives the new <code>filename</code> a place in memory to live.  Strings need that.</p>

<p>Edit: added the charsneeded thing to protect you from too-long filenames as a safety measure.  If you actually expect to need it, dynamically allocate buf instead.</p>
",2
13738171,13738154,4,"<p>What happens is that</p>

<pre><code>vec_shots[curShotIndx];
</code></pre>

<p>returns a reference which you assign to <code>const ClassA&amp; curShot</code>. There is no object creation involved in this step. Therefore no constructor is invoked (neither default nor copy constructor).</p>

<p>The assignment operator is not invoked either since you are not assigning one object instance to another, but only a reference. You are not handling more than one (existing) object instance in this code. So, no construction or assignment is invoked.</p>
",1
13738174,13738154,1,"<p>No constructor is used, <code>curShot</code> is a reference, an alias to an already existing object, not a stand-alone object by itself.</p>

<p>Also, initialization and assignment cannot be done at the same step. For example, say you had</p>

<pre><code> ClassA original;
 ClassA copy = original;
</code></pre>

<p>Here, <code>copy</code> is not assigned <code>original</code>, it's initalized using <code>original</code>. This is called copy initialization.</p>

<p>If you did</p>

<pre><code> ClassA copy2(original);
</code></pre>

<p>this would be called direct initialization.</p>

<p>The copy constructor would be called in both instances. (<a href=""https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization"">copy elision</a> can occur, so it might not be called, but it must be available)</p>

<p>Assignment is when you use <code>operator =</code> on an already existing object:</p>

<pre><code> ClassA x;
 ClassA y;
 x = y;     //assignment
</code></pre>
",9
13738183,13738154,0,"<p>This statement just define curShot as a reference, it's not a new object.</p>
",0
13738225,13738154,1,"<p>Since you wrote ""it seems to call copy constructor"", <strong>I assume the ampersand in your question is a typo</strong>.<br>
In that case, if you would do </p>

<pre><code>const ClassA curShot = vec_shots[curShotIndx];
</code></pre>

<p>it is evaluated as copy construction. It is just the same as the ugly <code>const ClassA curShot( vec_shots[curShotIndx] )</code>.</p>

<p>However, if you write</p>

<pre><code>ClassA curShot;  // I skipped the ""const"", because otherwise the example would be invalid.
curShot = vec_shots[curShotIndx]; 
</code></pre>

<p>then a default constructor gets called and an <code>opearator=</code> is called on the second line.</p>

<hr>

<p>Moreover, ""="" so much can mean calling NEITHER copy constructor NOR <code>operator=</code>, that you can have this:</p>

<pre><code>const ClassA f(){ return ClassA(); }
//...
const ClassA curShot = f();  // we would expect here a copy constructor call
</code></pre>

<p>Here -- if the compiler uses return value optimization and usually it does -- only a default constructor gets called for curShot.</p>
",1
11820568,11820543,1,"<p>It looks like <code>tabela</code> is declared as <code>short unsigned tabela[9][9]</code>. In order to get an item of type <code>unsigned short</code> from it you have to provide two indexes, not one.</p>

<p>On the other hand, if you are looking to get an entire sub-array from <code>tabela</code>, the left side of the assignment needs to be compatible with a 1-D array of <code>unsigned short</code>, for example, an <code>unsigned short*</code> pointer.</p>
",0
11813581,11813568,2,"<p>You need to provide forward declarations only when you are not including the header for the corresponding class. Since you are including both <code>secondclass.h</code> and <code>thirdclass.h</code> already, you should skip the corresponding forward declarations altogether.</p>

<p>In the <code>thirdclass.h</code>, however, you do not need <code>firstclass.h</code>: you are declaring a pointer to <code>firstclass</code>, not using its members, so you do not need an include.</p>

<p>The general rule is that you should forward-declare your classes if all you need is a pointer, and include their headers when you need knowledge of the members of the class.</p>
",3
11813662,11813568,0,"<p>Remove the inclusion of firstclass.h that is in thirdclass.h.  It it causing firstclass to be defined before third class.  Beware of recursive includes.</p>

<p>To see when classes actually are getting defined (depending on your compiler), add #pragma messages before the actual class definitions.</p>
",0
15830158,15830097,6,"<p>The issue is that <code>f</code> is never removed from the input stream, so <code>cin &gt;&gt; ival</code> keeps trying to read it over and over again.</p>

<p>You need to skip past it. See, for example, <a href=""https://stackoverflow.com/questions/14693106/how-does-istreamignore-work"">How does istream::ignore( ) work?</a></p>
",2
13402490,13402380,1,"<p>The problem seems to be that when a student fails a course, the contents of the vector get modified. Removing things from a vector while you're iterating through its contents is tricky to get right. Seems like a more appropriate data model here would have the instructor remove students who fail, which would also make this problem much more tractable. So teach everyone, and then go through the list again to remove students who failed.</p>
",1
12878245,12878242,1,"<p>They're just empty statements.</p>

<pre><code>return 1;
; //do nothing
; //do nothing
//etc
</code></pre>

<p>I'll bet the difference you're seeing is that <code>int x = 0;;;;;</code> is in the global scope, so -pedantic gets it. It's like having an extra semicolon after a function definition. Move <code>int x = 0;;;;</code> into a function and it won't complain.</p>
",0
12878277,12878242,2,"<p>Quoted from K&amp;R, expression statement has product <code>expression-statement: expression;</code>.</p>

<blockquote>
  <p>If the expression is missing, the construction is called a null statement;
      it is often used to supply an empty body to an iteration statement to place
      a label.</p>
</blockquote>

<p>It is a valid language construct, so no complains from your compiler.</p>
",1
12347080,12347045,0,"<p>Even though you include the file, the linker will only include code that is actually used. This is why using static libraries is sometimes preferable to a dynamic library that has to include everything.</p>
",0
12347084,12347045,0,"<p>You can't. You need to actually include the file that links to the code that defines the function if you want to include the function. If you just need the interface and aren't going to use the function, you could simply declare the class in execute.cpp as follows</p>



<pre class=""lang-c prettyprint-override""><code>class fun
{
    public:
        void subtract();
};
</code></pre>

<p>But you couldn't use subtract there.</p>
",3
12347153,12347045,2,"<blockquote>
  <p>i dont want to include ""fun.cpp"" file into my execute.cpp</p>
</blockquote>

<p>Nor should you, as it would break the one definition rule (assuming the implementations are also in the cpp file).</p>

<p>The usual way to do this is to have the class definition in a header, and include only the header file.</p>

<p>To answer your question, you can, <strong>but it's fugly</strong>.</p>

<p>C++ allows us to define a class multiple times, <strong>as long as the definition is identical</strong>. So, in <code>execute.cpp</code> you can simply write:</p>

<pre><code>//execute.cpp
class fun2  //note lower-case 'c'
{

    public: 
     void subtract();
};
// use fun2 here
</code></pre>

<p>before you use it. But, again, the usual way is to break the class definition and implementation in a <code>.h</code> file and a <code>.cpp</code> file.</p>

<p><em>Mandatory advice:</em> read a good introductory C++ book.</p>
",0
12347188,12347045,0,"<p>You need to include the header file which defines the class <code>fun</code>(<em>and has the declaration of <code>subtract()</code></em>) in the cpp file where you want to use the function <code>subtract()</code>.<br>
Note that the function must be defined though.      </p>

<p><strong>fun2.h</strong>   </p>

<pre><code>#ifndef FUN2_H
#define FUN2_H

Class fun2  
{      
    public:        
       void subtract();   
};

#endif // FUN2_H
</code></pre>

<p><strong>fun2.cpp</strong>     </p>

<pre><code>#include ""fun2.h""
void func2::subtract()
{

}
</code></pre>

<p><strong>execute.cpp</strong></p>

<pre><code>#include ""fun2.h""

//use subtract() through object of `fun2`
</code></pre>

<p>Note that, to use a member function in a particular source file, the definition of the class which declares that function should be visible to the compiler, the actual job of linking to the particular definition is done at the linking stage and as long as you follow the above format the linker shall link the appropriate function for you.</p>
",1
15550583,15550427,1,"<p><strong>NOTE:</strong> Compiler: Apple GCC, OS: OSX 10.7</p>

<p>GCC finds nothing wrong with this, and I am able to use the type <code>type</code> later in the definition of Foo. However, you cannot use the type <code>type</code> outside of Foo.</p>
",2
15550845,15550427,0,"<p>It is possible to write that code. <code>type</code> and <code>Foo</code> are not reserved words, and C++ allows to define types within structs or classes. In fact, they are heavily used in templates for metaprogramming and type introspection.  See <a href=""https://stackoverflow.com/questions/1527849/how-do-you-understand-dependent-names-in-c"">How do you understand dependent names in C++</a> for further details on that aspect of the language.</p>
",0
11875863,11875830,0,"<p>This error appear because you need to access class member from pointer to class by using <code>-&gt;</code> operator: <code>cout &lt;&lt; classAobject-&gt;compareValues(.....)</code></p>

<p><code>Foo-&gt;bar()</code> is equivalent to <code>(*Foo).bar()</code>, and <code>Foo-&gt;baz</code> is equivalent to <code>(*Foo).baz</code></p>
",4
11869069,11868933,1,"<p>The <code>setSelection</code> method is defined as returning a string, yet it is not returning anything.  Perhaps adding a return statement (or changing it to void) will fix it:</p>

<pre><code>string Book::setSelection(string newSelection){
  selection = newSelection;
  return selection;
}
</code></pre>
",1
11869081,11868933,2,"<p>Your <code>setSelection()</code> function is declared as returning a string but no string is actually being returned. You should get a compile warning at least for this.</p>

<p>From running this through in a debugger, I <em>believe</em> that what's happening is that following the call to <code>setSelection()</code> the destructor is called on the returned string. As this string does not really exist, this causes an <code>abort()</code> within the runtime.</p>

<p>As a general rule, 'setters' tend not to return anything so would be written as follows:</p>

<pre><code>void setSelection(const string&amp; newSelection);
</code></pre>

<p>...</p>

<pre><code>void Book::setSelection(const string&amp; newSelection)
{
    selection = newSelection;
}
</code></pre>

<p>also note that the string is passed in by const reference rather than by value which is more efficient. This won't be the cause of your problem though.</p>

<p>Another suggestion would be to ensure that your 'getter' is declared const as it doesn't change anything in the object:</p>

<pre><code>string getSelection() const;
</code></pre>

<p>...</p>

<pre><code>string Book::getSelection() const
{
    return selection;
}
</code></pre>
",4
11876870,11876799,4,"<p>According to Wikipedia, starting with the Pentium III the CPUID assembler opcode is supported, however due to security concerns is no longer implemented.  See the following article for details: <a href=""http://en.wikipedia.org/wiki/CPUID#EAX.3D3:_Processor_Serial_Number"" rel=""nofollow"">http://en.wikipedia.org/wiki/CPUID#EAX.3D3:_Processor_Serial_Number</a></p>
",0
11877178,11876799,2,"<p>The best way is to derive a Machine Unique ID from different sources rather than depending on single parameter.</p>

<p>Check <a href=""http://sowkot.blogspot.com/2008/08/generating-unique-keyfinger-print-for.html"" rel=""nofollow noreferrer"">http://sowkot.blogspot.com/2008/08/generating-unique-keyfinger-print-for.html</a> for more information. </p>

<p>Even the method described in the above link can't guarantee always same MID (user might change the hardware).</p>

<p>Based on my experience, at the application start/launch generate MID and store in the application specific area (may be in registry) and use this for all other application related tasks instead of generating every time. In such case a normal GUID generation should suffice.</p>
",1
11877323,11876799,1,"<p>If you need a unique ID, you don't have to tie it up to the hardware, simply, generate a new <em>random</em> ID (128 bits or larger)! Store it in whatever persistent storage mechanism you prefer, so that next time you extract the same ID you generated before. </p>

<p>If you use processor or disk serial numbers, they will be subject to change, because users could upgrade their hardware. Your own unique ID will never change. The only downside of this, is that machines with dual boot will have two or more ID's -- one ID per instance of the OS.</p>
",3
12286645,12286618,3,"<blockquote>
  <p>Why was destructor of Derived class called in this code?</p>
</blockquote>

<p>Because the <code>Derived</code> instance created in <code>foo()</code> is going out of scope at the end of main program.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Base {
public:
    Base() {
        std::cout &lt;&lt; ""Base::Base() \n"";
    }
    ~Base() {
        std::cout &lt;&lt; ""Base::~Base() \n"";
    }
};

class Derived: public Base {
public:
    int i;
    Derived() {
        i = 10;
        std::cout &lt;&lt; ""Derived::Derived() \n"";
    }
    ~Derived() {
        i = 0;
        std::cout &lt;&lt; ""Derived::~Derived() \n"";
    }
    int get() {
        return i;
    }
};

Derived foo() {
    return Derived();
}

int main() {
    const Derived&amp; instance = foo();
    cout &lt;&lt; instance.i &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>The output is as follows:</p>

<pre><code>Base::Base()
Derived::Derived()
10
Derived::~Derived()
Base::~Base()
</code></pre>
",3
12286959,12286618,3,"<p>To make it more interesting, consider a modified <code>main</code>:</p>

<pre><code>const Base&amp; instance = foo();
</code></pre>

<p>That code creates a temporary (the object returned by <code>foo</code>) of type <code>Derived</code> and extends the lifetime of the object by binding it to a constant reference of type <code>Base</code>. The lifetime of the temporary will be extended until the reference goes out of scope at which point the object will get destroyed. The code is roughly translated to:</p>

<pre><code>Derived __tmp = foo();
const Base&amp; instance = __tmp;
</code></pre>

<p>At the end of the block holding the reference <code>instance</code>, the <code>__tmp</code> variable also goes out of scope and gets deleted. Note that even with no virtual destructor, the appropriate destructor is called, as <code>__tmp</code> is of type <code>Derived</code> (the type returned by the function).</p>
",0
14242953,14242936,3,"<p>Looks like the problem (or at least one problem) is a missing semicolon:</p>

<pre><code>set&lt;unsigned&gt;::iterator it
</code></pre>
",0
14242959,14242936,2,"<p>If you're not <code>using namespace std</code> then you must prefix the members of that namespace with <code>std::</code>:</p>

<pre><code>std::vector&lt;std::set&lt;unsigned&gt; &gt; a;
</code></pre>
",0
12786341,12786233,1,"<p>In each of your header files write:</p>

<pre><code>#ifndef MYHEADERNAME_H
#define MYHEADERNAME_H

code goes here....

#endif
</code></pre>
",2
12786262,12786233,5,"<p>You need to use include guards, or the easiest:</p>

<pre><code> #pragma once
</code></pre>

<p>in your header files</p>

<p>See <a href=""https://stackoverflow.com/questions/2979384/purpose-of-header-guards"">Purpose of Header guards</a> for more background</p>

<p>Idea: 1.hpp</p>

<pre><code>#ifndef HEADER_GUARD_H1_HPP__
#define HEADER_GUARD_H1_HPP__

// proceed to declare ClassOne

#endif // HEADER_GUARD_H1_HPP__
</code></pre>
",6
12788722,12786233,1,"<p>Its better like this:</p>

<pre><code>#ifndef DATA_H    /* Added */
#define DATA_H    /* Added */

#include &lt;iostream&gt;
#include &lt;string&gt;

// using namespace std;  /* Removed */

class Data
{
private:
   std::string sType;
public:
   Data();
   Data( std::string const&amp; );          // Prevent copy of string object.
   void setSType( std::string&amp; );       // Prevent copy of string object.
   std::string const&amp; getSType() const; // prevent copy on return
   std::string&amp; getSType();             // prevent copy on return
};

#endif /* DATA_H */
</code></pre>

<p>The big fix is adding ifndef,define,endif. The #include directive works as if copying and pasting the .h to that line. In your case the include from main.cpp are:</p>

<pre><code>   main.cpp
     -&gt; Data.h  (1)
     -&gt; Point.h
        -&gt; Data.h (2)
</code></pre>

<p>At (2), Data.h has already been `pasted' into main.cpp at (1). The class declaration of Data, i.e. ""class Data{ .... };"" , appears twice. This is an error.</p>

<p>Adding include guards to the top and bottom of every .h are standard practice to avoid this problem. Don't think about it. Just do it.</p>

<p>Another change I'd suggest is to remove any ""using namespace ..."" lines from any .h . This breaks the purpose of namespaces, which is to place names into separate groups so that they are not ambiguous in cases where someone else wants an object or function with the same name. This is not an error in your program, but is an error waiting to happen. </p>

<p>For example, if we have:</p>

<p>xstring.h:</p>

<pre><code>namespace xnames
{
    class string
    {
        ...
    };
}
</code></pre>

<p>Foo.h</p>

<pre><code>#include &lt;xstring&gt;
using namespace xnames;
...
</code></pre>

<p>test.cxx:</p>

<pre><code>#include ""Foo.h""  
#include ""Data.h""    // Breaks at:   Data( string );  -- std::string or xnames::string?

...
void test()
{
   string x;  // Breaks.  // std::string or xnames::string?
}
</code></pre>

<p>Here the compiler no longer knows whether you mean xnames::string or std::string. This fails in test.cxx, which is fixable by being more specific:</p>

<pre><code>void test()
{
   std::string x;
}
</code></pre>

<p>However, this compilation still now breaks in Data.h. Therefore, if you provide that header file to someone, there will be cases when it is incompatible with their code and only fixable by changing your header files and removing the ""using namespace ...;"" lines.</p>

<p>Again, this is just good coding style. Don't think about it. Just do it.</p>

<p>Also, in my version of Data.h, I've changed the method parameters and return types to be references (with the &amp;). This prevents the object and all of its state from being copied. Some clever-clogs will point our that the string class's is implementation prevents this by being copy-on-write. Maybe so, but in general, use references when passing or returning objects. It just better coding style. Get in the habit of doing it.</p>
",0
13438011,13437361,3,"<p>Firstly, as pointed out in the comments, there is no standard header file named <code>&lt;iostream.h&gt;</code>.  <code>iostream.h</code> was a header file used before the C++ language was standardized in 1998.  When the standard was published, the name was changed to just <code>&lt;iostream&gt;</code> (without the <code>.h</code>).</p>

<p>Secondly, the standard allows headers to include other headers (C++03 ¡ì17.4.4.1/1).  So it might happen that your <code>&lt;iostream.h&gt;</code> header includes <code>&lt;string.h&gt;</code>, probably because some of the template code there relies on some string function.  As a result, your code compiles cleanly.</p>

<p>Nevertheless, you should not rely on this behavior.  In order for your code to be most portable, you should <code>#include</code> every header file you need, whether or not they are <code>#include</code>d recursively by some other header file.</p>
",0
12795159,12794140,1,"<p>The error is being thrown because g++ could not find the required dependency of the PointD and Data definitions. Hence, classes these becomes undefined references.</p>

<p>use the following command to compile so that main will be able to find the class defintions</p>

<pre><code>   g++ main.cpp Data.cpp PointD.cpp -o main
</code></pre>

<p>Also, remove the statement</p>

<pre><code>  #include ""Data.h"" 
</code></pre>

<p>from your main.cpp; otherwise it will find the class definition twice.</p>

<p>Additionally, you'll have to add </p>

<pre><code>   int getXordinate();
   void setXordinate(int Xordinate);
</code></pre>

<p>to your PointD.h for error free compilation.</p>

<p>Hope this helps!</p>
",0
12794220,12794140,3,"<p>You are likely trying to compile and link main.cpp, without PointD.cpp or data.cpp. Try to add all the sources to the command, or <strong>compile only</strong> all the sources before linking them together.</p>
",1
15559181,15557596,3,"<p>I use Boost.Signals2 (which was the accepted answer for <a href=""https://stackoverflow.com/questions/4130755/c-event-system-design"">that StackOverflow question</a> you've already referenced).  I started using this when I was first learning Boost libraries three or four years ago, and it proved to be simple, flexible, elegant, and reliable; I've had no reason to look for another solution.</p>

<p>It's been quite some time since I've used Swing, so I can't really comment in depth.  Using Signals2, you still ""create"" a ""listener class"" (by defining a signal type; the listener is the resultant slot type); and you ""register"" a listener to a given signal instance via the <code>connect()</code> method.</p>

<p>With Signals2, each signal can accept multiple parameters, and if desired return a result to the signaler. There is a lot of flexibility in connection maintenance.</p>
",1
12823621,12823573,2,"<p>You must define a comparison operator for your class. How you determine whether one object is less than another isn't clear from your question.</p>
",0
12823634,12823573,26,"<p>The easiest way is to use the standard library:</p>

<pre><code>#include &lt;algorithm&gt;

std::sort(cone, cone + 10,
          [](ClassOne const &amp; a, ClassOne const &amp; b) -&gt; bool
          { return a.value &lt; b.value; } );
</code></pre>

<p>If you're willing to define a comparison operator globally, you don't even need the lambda:</p>

<pre><code>bool operator&lt;(ClassOne const &amp; a, ClassOne const &amp; b)
{
    return a.value &lt; b.value;
}

std::sort(cone, cone + 10);
</code></pre>

<p>Or you could make the comparator a member function. Or you could give the comparator function a custom name and pass that as the third argument of <code>sort</code>. This might be a good idea in the case where the comparison is specific to your situation and not ""natural"":</p>

<pre><code>bool ValueCmp(ClassOne const &amp; a, ClassOne const &amp; b)
{
    return a.value &lt; b.value;
}

std::sort(cone, cone + 10, ValueCmp);
</code></pre>

<p>The last version is useful if you don't have C++11 support (for lambdas, as in the first case), or if you want to reuse the comparator in multiple different situations.</p>
",10
12823638,12823573,11,"<p>Use <a href=""http://en.cppreference.com/w/cpp/algorithm/sort"" rel=""noreferrer""><code>std::sort</code></a> and a suitable sort function/functor:</p>

<pre><code>bool comp(const ClassOne&amp; lhs, const ClassOne&amp; rhs)
{
  return lhs.valueData &lt; rhs.valueData;
}

std::sort(cone, cone+10, comp);
</code></pre>

<p>or, in C++11,</p>

<pre><code>std::sort(std::begin(cone), std::end(cone), comp);
</code></pre>
",3
12823683,12823573,3,"<p>Look at your Bubble sort source.  At some point, it will be comparing one <code>int</code> to another, probably with either the less than operator (&lt;) or the greater than operator (>).  That's where the sort function determines the relative order of those two items.  By repeating that comparison many times, the sort function is able to determine the total order of the collection.</p>

<p>You need to replace that operation with your own comparison function.  A function that takes two objects of your class, and returns true if the first should be considered less than the second, false if the second should be considered less than the first, and false if they should be considered equivalent.</p>
",0
15895536,15895471,3,"<p>The following function call has a misplaced bracket  </p>

<pre><code>compute_duplicate((x,(y+1), array, array_length)==false)
</code></pre>

<p>it should be  </p>

<pre><code>(compute_duplicate(x,(y+1), array, array_length)==false)
</code></pre>

<p>the same error exists in two places within your loop.</p>
",0
15895540,15895471,1,"<p>Your problem is here:</p>

<pre><code>compute_duplicate((x,(y+1), array, array_length)==false))
</code></pre>

<p>I.e. you are trying to call <code>compute_duplicate</code> with <em>one</em> argument of type <code>bool</code>, which is the result of the <strong>valid expression</strong> <code>(x,(y+1), array, array_length)==false</code>. Note that comma is an operator in C/C++, so the effective result of the expression above is <code>array_length==false</code>. </p>

<p>What is probably meant is: </p>

<pre><code>compute_duplicate(x,(y+1), array, array_length)==false
</code></pre>
",0
15895545,15895471,1,"<p><code>compute_duplicate((x,(y+1), array, array_length)==false))</code> is calling <code>compute_duplicate</code> on the expression <code>(x,(y+1), array, array_length)==false)</code>, which is a single boolean value that is <code>true</code> if and only if <code>(x,(y+1), array, array_length)</code> is <code>false</code>. This is not what you want.</p>
",0
15895549,15895471,1,"<p>An extra pair of braces here:</p>

<pre><code>compute_duplicate((x,(y+1), array, array_length)==false)
</code></pre>

<p>Makes the compiler think you pass a single bool as argument. Loose them and error should be fixed.</p>
",0
15895552,15895471,1,"<p><code>compute_duplicate((x,(y+1), array, array_length)==false)</code> is calling <code>compute_duplicate</code> with one argument, the result of <code>(x,(y+1), array, array_length)==false</code>.</p>

<p>Did you mean <code>(compute_duplicate(x,(y+1), array, array_length)==false)</code> ?</p>

<p>(Just a slightly different arrangement of <code>()</code>s but a very different piece of C++.</p>
",0
11861871,11861806,3,"<p>The second argument to <code>listen()</code> states the maximum number of queued incoming requests. It is not a maximum on the number of connections that can be accepted.</p>

<p>From <a href=""http://linux.die.net/man/2/listen"" rel=""nofollow"">man listen</a> (where <em>backlog</em> is the name of the second argument):</p>

<blockquote>
  <p>The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.</p>
</blockquote>

<p>If a maximum of two accepted connections is required then you must code that explicitly.</p>
",0
14224368,14224305,2,"<p>Your code doesn't compile since the static function is using a variable which will only exist in objects instantiated by the class.</p>

<p>I'm not sure you've understood static. Only <strong>one</strong> static function exist. You can call it from anywhere. Which instance if CExample's x is it supposed to use?</p>
",9
14224387,14224305,0,"<p>It's illegal to access a non-static member from a static function. See the output of gcc when I try to compile your program:</p>

<pre><code>test.cpp: In static member function ¡®static void CExample::foo()¡¯:
test.cpp:9: error: invalid use of member ¡®CExample::x¡¯ in static member function
</code></pre>
",0
14224412,14224305,1,"<p>A static member function is a service of the class, not of a specific object of the class. A class's static data members and static member functions exist independently of instantiation of a object of that class. </p>

<p>The use of a static function will not call the constructor of its respective class, therefore your variable will not exist, causing a compilation error. </p>

<p>Just remember static member functions exist and operate independently of any objects of the class.</p>
",0
14224422,14224305,2,"<p>This looks like a case of bad design. You could fix it so that it compiles by making x static and initialising it with 5. However you are probably a lot of better rethinking your design and what you want it to do. Remember there is only ever one instance of something that is static but there are as many instances of CExample as times you call it's constructor.</p>
",1
14242964,14242694,5,"<p>Rewind a few lines.</p>

<p>14.3.2/1: a constant expression (5.19) that designates the address of an object with <em>static storage duration</em> and external or internal linkage.</p>
",0
14242974,14242694,4,"<p>Note that the following modification works:</p>

<pre><code>template &lt;const char* str&gt;
void foo() {}

char str[] = ""str"";

int main() {
    foo&lt;str&gt;();
}
</code></pre>

<p>See <a href=""http://www.comeaucomputing.com/techtalk/templates/#stringliteral"" rel=""nofollow"">http://www.comeaucomputing.com/techtalk/templates/#stringliteral</a> for a short explanation.</p>
",12
11827812,11827681,0,"<p>I read this in the substr doc <a href=""http://www.cplusplus.com/reference/string/string/substr/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/substr/</a>.</p>

<p>""If the position passed is past the end of the string, an out_of_range exception is thrown.""
I think it's because in sline.substr(2,1) you inverted the range.</p>
",0
11827813,11827681,5,"<p>It happens because you run the loop one time too many. The <code>eof</code> condition happens only <em>after</em> one read has already failed.</p>

<p>Try this instead</p>

<pre><code>myfile.open(""file.txt"");
while(getline(myfile,sline))
{ 
   delimiter = sline.substr(2,1);
 } 
</code></pre>
",2
13402437,13401377,0,"<p>I can't explain why this code is crashing. It's probably because you have bugs you haven't posted here. However you will find it easier to write operator>> this way.</p>

<pre><code>istream&amp; operator&gt;&gt;(istream &amp;input,Line3D &amp;line3d)
{
    int x1,y1,z1,x2,y2,z2;
    char c1,c2,c3,c4,c5,c6,c7;

    input &gt;&gt; c1 &gt;&gt; x1 &gt;&gt; c2 &gt;&gt; y1 &gt;&gt; c3 &gt;&gt; z1 &gt;&gt; c4 &gt;&gt; c5 &gt;&gt; x2 &gt;&gt; c6 &gt;&gt; y2 &gt;&gt; c7 &gt;&gt; z2;

    Point3D pt1(x1,y1,z1);
    Point3D pt2(x2,y2,z2);

    line3d.setPt1(pt1);
    line3d.setPt2(pt2);
    line3d.setLength();
    return input;

}
</code></pre>

<p>Use dummy char variables (c1, c2 etc.) to read in the commas and brackets you aren't interested in. This technique will also skip the spaces you aren't interested in. This is a much more realiable method than using ignore.</p>

<p>Other errors in your code are that <code>operator&gt;&gt;</code> should use <code>istream</code> not <code>ifstream</code>, and it should have <code>return input;</code> at the end. By writing your <code>operator&gt;&gt;</code> to use <code>istream</code> it will then work with any kind of input stream (including <code>cin</code> for instance) not just with file streams.</p>
",0
15854738,15854705,3,"<p>That line <em>is</em> a function declaration. It is named <code>CreateWAVResourceLoader</code>, has no parameters, and returns a <code>shared_ptr&lt;IResourceLoader&gt;</code>.</p>

<p>When you say:</p>

<pre><code>m_ResCache-&gt;RegisterLoader(CreateWAVResourceLoader());
</code></pre>

<p>That's when you call it. It passes the temporary shared pointer returned from the function into <code>RegisterLoader</code>.</p>
",0
15854751,15854705,0,"<pre><code>extern shared_ptr&lt;IResourceLoader&gt; CreateWAVResourceLoader();
</code></pre>

<p>just means that the function will be implemented in another file (extern) and that it will return shared_ptr. The whole line is just a function declaration and</p>

<pre><code>shared_ptr&lt;IResourceLoader&gt; CreateWAVResourceLoader()
{
    return shared_ptr&lt;IResourceLoader&gt;(GCC_NEW WaveResourceLoader());
}
</code></pre>

<p>is just an implementation of the function.</p>
",1
15854760,15854705,2,"<blockquote>
  <p>but how can I use that pointer without a name?</p>
</blockquote>

<p>You're not the one who will be using the shared_ptr, the object <code>m_ResCache</code> will be. I assume that object has an interface for handling resources, and keeps track of shared_ptrs internally.</p>

<p>i.e. it's like this:</p>

<pre><code>class foo {
  public:
    RegisterLoader(shared_ptr&lt;IResourceLoader&gt; ptr) { internal_ptr = ptr; }

    DoSomethingWithLoader() { /* ... */ }
  private:
    shared_ptr&lt;IResourceLoader&gt; internal_ptr;
};
</code></pre>
",1
12337889,12337868,2,"<p>Read carefully, the standard doesn't prohibit it, it even refers to it in the note.</p>
",2
12338063,12338047,0,"<p>Because it's parsed as</p>

<pre><code>(std::cout &lt;&lt; ""str"") &lt; 0;
</code></pre>

<p>and the comparison is useless.</p>
",2
12338069,12338047,0,"<ol>
<li>You have one &lt;</li>
<li>Why are you doing this?</li>
</ol>
",0
12338134,12338047,2,"<p>Because you should be using:</p>

<pre><code>std::cout &lt;&lt; ""str"" &lt;&lt; 0;
</code></pre>

<p>instead of</p>

<pre><code>std::cout &lt;&lt; ""str"" &lt; 0;
</code></pre>

<p>Maybe you already know this, but it's worth clarifying!</p>
",0
12261472,12261424,0,"<p><code>album[2]</code> is a <code>std::string</code>. You only need to pass <code>album</code> to match the <code>vector&lt;string&gt;&amp;</code> argument.</p>
",0
13478170,13478150,0,"<p>It's undefined what will happen so you can't say much. The best you can do is speculate for particular implementations/compilers.</p>
",0
13478171,13478150,3,"<p>You've asked two distinct questions in your post. I'll answer them separately.</p>

<blockquote>
  <blockquote>
    <p>but what would happen to obj now ?</p>
  </blockquote>
</blockquote>

<p>The behavior of your program is <strong>undefined</strong>. The C++ standard makes no comment on what happens to <code>obj</code> now. In fact, the standard makes no comment what your program does <em>before</em> the error, either. It simply is <strong>not defined</strong>.</p>

<p>Perhaps your compiler vendor makes a commitment to what happens, perhaps you can examine the assembly and predict what will happen, but C++, <em>per se</em>, does not define what happens.</p>

<p>Practially speaking<sup>1</sup>, you will likely get a warning message from your standard library, or you will get a seg fault, or both.</p>

<p><sup>1: Assuming that you are running in either Windows or a UNIX-like system with an MMU. Other rules apply to other compilers and OSes.</sup></p>

<hr>

<blockquote>
  <blockquote>
    <p>how can i make sure that [<code>delete</code>ing a stack variable] doesn't happen.</p>
  </blockquote>
</blockquote>

<p>Never initialize <code>smart_ptr</code> with the address of a stack variable. One way to do that is to document the interface to <code>smart_ptr</code>. Another way is to redefine the interface so that the user never passes a pointer to <code>smart_ptr</code>; make <code>smart_ptr</code> responsible for invoking <code>new</code>.</p>
",0
13478173,13478150,1,"<p>Your code has <em>undefined behaviour</em> because you used delete on a pointer that was not allocated with new. This means anything could happen and it's impossible to say what would happen to <code>obj</code>.</p>

<p>I would <em>guess</em> that on most platforms your code would crash.</p>
",0
13478229,13478150,1,"<p>Delete's trying to get access to obj space in memory, but opperation system don't allow to do this and throws (core dumped) exception.</p>
",1
13478260,13478150,0,"<p>It's not just undefined behavior, like stated in other answers. This will almost certainly crash.</p>

<p>The first issue is with attempting to free a stack variable.</p>

<p>The second issue will occur upon program termination, when <code>test</code> destructor will be called for <code>obj</code>.</p>
",0
12259618,12259498,2,"<p>Won't give you full code - use subsequent multiplications to find the power. The rest should be straight-forward.</p>

<p>Here's some code that, if this is homework, you can't use since it'll get you in trouble:</p>

<pre><code>bool isArmstrongNumber(int x)
{
   //some magic happens here
}

template&lt;int x&gt;
struct armstrong_number
{
    armstrong_number()
    {
        if ( isArmstrongNumber(x) )
            std::cout &lt;&lt; x &lt;&lt; endl;
        armstrong_number&lt;x-1&gt; y;
    }
};

template&lt;&gt;
struct armstrong_number&lt;0&gt;
{
    armstrong_number()
    {
        std::cout &lt;&lt; 0 &lt;&lt; endl;
    }
};

int main()
{
    armstrong_number&lt;999&gt; x;
}
</code></pre>
",1
11860215,11860173,1,"<p><code>namespace</code> is the usual way to go about this.</p>

<p>The function in the class should be declared <code>static</code> anyway, and having a class just so you can group functions together isn't good practice.</p>
",0
11860223,11860173,2,"<p>If it is useful to have state in your conversion, use a class. Preferably, a functor so you can pass an instance around as a callable entity. If there is no state, then use a function.</p>

<p>As an aside, your signature and return type should probably look like this:</p>

<pre><code>int ConvertStrToInt(const std::string&amp; str);
</code></pre>

<p><strong>Edit</strong> concerning this particular example, the C++ standard library provides this functionality already, so you don't need to re-implement it.</p>
",2
11860227,11860173,0,"<p>Neither. Go for a function object (sometimes called a <a href=""https://stackoverflow.com/questions/356950/c-functors-and-their-uses"">Functor</a>).</p>

<pre><code>struct str_to_int {
  int operator()(const std::string&amp; s) const { return 23; }
};
</code></pre>

<p>Why? This gives you the ability to add state if you need it. It works
with all standard algorithm facilities and every modern C++
library. You can make it a template function without your users every
noticing it.</p>

<p>Now you can do things like:</p>

<pre><code>std::vector&lt;std::string&gt; strings;
std::vector&lt;int&gt; integers;
std::transform(begin(strings), end(strings), 
               std::back_inserter(integers), str_to_int());
</code></pre>

<p>Or someday turn your definition into:</p>

<pre><code>struct str_to_int {
  int operator()(const std::string&amp; s) const { return 23; }
  // ha
  int operator()(const std::wstring&amp; s) const { return 42; }
  // haha!
  int operator()(const char* x) const { return 42; }
};
</code></pre>

<p>and the above code will continue to work without a problem. This wont be the case for a free function.</p>

<p>Random Remark: Why would you pass a pointer to a <code>string</code> for
something like that?</p>
",5
11860237,11860173,5,"<p>The class <code>Utility</code> as you have written it down above somehow contradicts the idea behind object oriented programming, as the method neither uses nor depends on any members of the class. Classes should rather be objects that have certain properties and methods on these properties.</p>
",0
11861297,11860173,0,"<p>I would normally just use a function.  Putting it into a class is just
noise (or pseudo-OO, since the class doesn't have any real behavior on
its own).</p>

<p>There is one exception: functional template arguments to the STL are
generally more efficient if you use a class with an <code>operator()()</code>,
rather than a function.  (If you use a functional object, the actual
function being called is a compile time constant, and can easily be
inlined.  If you use a function, the template argument is the type of
the function, not the function itself, and inlining is less likely.)
Even in this case, however, I'd start with the function, and add the
functional object type if needed. </p>
",0
17860664,17860627,2,"<p>Because the function returns a reference, it's possible to modify the underlying static variable.</p>

<p>On the first call, the <code>static int</code> variable is created, and then reference to it is returned. Then you set the value of the <code>x</code> to 10.</p>

<p>The <code>cout</code> statement obtains the reference again and uses it to write <code>x</code> to stdout.</p>

<p>It's worth noting that if <code>x</code> wasn't <code>static</code>, it would be destroyed at the end of function scope, and returned reference would be a <em>reference to temporary</em>, which is illegal.</p>

<hr>

<p>The most common practical application is <code>operator[]</code></p>

<pre><code>class ArrayWrapper {
    int v [100];

public:
    int&amp; operator[] (int index) { 
        return v[index];
    }
};

// usage:
ArrayWrapper aw;
aw[3] = 3;
cout &lt;&lt; aw[10];
</code></pre>

<p>Of course this is an example implementation; for real world overloaded <code>op[]</code> look at <code>std::vector</code> or <code>std::map</code>.</p>
",0
17860670,17860627,0,"<p>The function is returning a reference to a static variable. Static variables continue to exist after the function has exited. </p>

<p>Since the function returns a reference, you're able to set that value, and then it's output to the screen. It's basically ""hiding"" a global variable. I'm not sure where it makes a lot of sense to use this technique, however...</p>
",0
17860679,17860627,1,"<p><code>fun</code> will return a reference to the static variable <code>x</code>, which can then be used to modify the value of <code>x</code>. The C equivalent might be something like:</p>

<pre><code>int *fun()
{
    static int x;
    return &amp;x;
}

int main()
{
    int *ptr = fun();
    *ptr = 10;
    printf(""%d\n"", *fun());
    return 0;
}
</code></pre>
",1
17860681,17860627,4,"<p>You have a static int variable inside the function fun().<br>
The function returns a reference to that variable.<br>
You assign 10 to the variable.<br>
You print the variable.</p>
",0
17860685,17860627,0,"<p>a reference to the static variable x in f is being used to assign the value 10 to x; it (the reference) is then being passed to cout</p>
",0
17860695,17860627,5,"<p><code>fun()</code> returns reference of a static variable <code>x</code>, in first expression in <code>main()</code>: </p>

<pre><code> fun() = 10;
  ^       ^
  |       x assigned 10
   returned x 
</code></pre>

<p>Because static variable's value persists between different function calls, so in next expression: </p>

<pre><code>cout &lt;&lt; fun();
           ^
           return x with value 10
</code></pre>

<p>Note: Because your are returning reference of a static variable so its not an undefined behavior.</p>
",7
17860697,17860627,0,"<p>a static variable is essentially a global that can only be accessed directly from a single function. when your function returns a reference to this variable, it in fact returns its address. Since the variable is global, it is always the same address, therefore your function is in fact giving everyone access to this variable.</p>
",0
15539955,15539910,0,"<p>Part of your problem is that getline() is a blocking call, and won't return until someone inputs something.</p>

<p>What you could do is to research threading - have two different threads, one of which has the sole responsibility to watch time, and if the time has passed, then you send a signal to kill the other thread.</p>

<p>You are limited a lot by the input method that you showed here.</p>
",4
12336697,12336631,2,"<p>Create an Account class which implements printReciept() and other methods common to any account type. Then create CheckingAccount and SavingsAccount inheriting from Account.</p>
",1
12336708,12336631,1,"<p>I can point out one thing you better do right now:</p>

<pre><code>class Transaction {
private:
    BankAccount m_bao;
public:
    Transaction(BankAccount&amp;);
    void displayOptions();  
    void printReciept();
};
</code></pre>

<p>That BankAccount needs to be by reference (pointer or ref, makes no difference to me, but I'm a ref-kinda-guy). It should be a reference and initialized at construction in the object-initializer list:</p>

<pre><code>class Transaction {
private:
    BankAccount&amp; m_bao;
public:
    Transaction(BankAccount&amp;);
    void displayOptions();  
    void printReciept();
};
</code></pre>

<p>and</p>

<pre><code>Transaction::Transaction(BankAccount&amp; bao)
 : m_bao(bao)
{
}
</code></pre>

<p>I hope it is clear why this is the case. Each transaction was making a copy of the bank account, then modifying that copy.The original account was untouched. Bad. You likely discovered this but were unclear as to why it was happening, thus the Transaction objects were kept out of the for-loop. In actuality, your transactions were holding the accumulated modifications to their own internal bank account copy. The original was unmodified.</p>
",2
12263977,12263697,2,"<p>There are several solutions to your problem. One would be, that the transceiver informs all <code>Request</code> object about its destruction. For this, you would need a method like
<code>Transceiver::addRequest()</code> which a <code>Request</code> object uses to register itself. In the
destructor of <code>Transceiver</code> you have to inform all registered <code>Request</code>'s. For example:</p>

<pre><code>class Transceiver
{
    virtual ~Transceiver()
    {
        for (auto request : m_requests)
            request-&gt;deleteTransceiver(this);
    }

    void addRequest(Request* r)
    {
        m_requests.push_back(r);
    }

    void removeRequest(Request* r)
    {
        m_requests.erase(std::remove(m_requests.begin(), m_requests.end(), r), 
                         m_requests.end());
    }

    std::vector&lt;Request*&gt; m_requests;
};

class Request
{
    virtual void deleteTransceiver(Transceiver* t) = 0;
    virtual void notify() = 0;
};

class RequestImpl : public Request
{
    RequestImpl(Transceiver* t)
        : m_target(t)
    {
        if (t)
            t-&gt;addRequest(this);
    }

    ~RequestImpl()
    {
        if (m_target)
            m_target-&gt;removeRequest(this);
    }

    virtual void deleteTransceiver(Transceiver* t)
    {
        if (m_target == t)
            m_target = 0;
    }

    virtual void notify() 
    { 
        if (m_target)
            m_target-&gt;process(ResponseType()); 
    }

    Transceiver* m_target;
};
</code></pre>

<p>A second approach would of course be to prevent the destruction of a <code>Transceiver</code> as
long as it is in use. You could use a <code>std::shared_ptr&lt;Transceiver&gt; m_target</code> in the
<code>Request</code> class, which means the transceiver lives at least as long as the associated request.</p>

<p>For a bit more flexibility, there is also the possibility of an <code>std::weak_ptr&lt;Transceiver&gt;</code>. Then the transceiver could be destroyed when the request
is still alive. However, when you try a <code>std::weak_ptr&lt;Transceiver&gt;::lock()</code> and it
fails, you know that the <code>Transceiver</code> is dead.</p>

<p><strong>Edit:</strong> Added a method to remove a <code>Request</code> if it is destroyed before its <code>Transceiver</code>.</p>
",0
14176780,14176683,2,"<p>Judging from your other questions (<code>RegSetValueEx</code> in the title makes it somewhat obvious), I'll presume you're on Windows. For a pure Windows API solution, you can use the Toolhelp32 API to go through a snapshot of the running processes and compare their names to the name you're looking for. You have the note about only one name, but it might be beneficial in the future, or to someone else, to have all PIDs for that name, so I'll do that:</p>

<pre><code>std::vector&lt;DWORD&gt; pids;

HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //all processes

PROCESSENTRY32W entry; //current process
entry.dwSize = sizeof entry;

if (!Process32FirstW(snap, &amp;entry)) { //start with the first in snapshot
    return 0;
}

do {
    if (std::wstring(entry.szExeFile) == wantedProcessName) {
        pids.emplace_back(entry.th32ProcessID); //name matches; add to list
    }
} while (Process32NextW(snap, &amp;entry)); //keep going until end of snapshot
</code></pre>
",6
14176788,14176683,0,"<p>In an *nix environment, <code>man 3 sysctl</code>.</p>
",2
12871707,12871681,1,"<p>Place your code in functions/methods and invoke them in the corresponding cases.</p>
",3
12871708,12871681,3,"<p>You can't directly do that. You could put the case code in a function and then call that function though.</p>

<pre><code>switch(choice)
{
case 1:
//some compute
break;
case 2:
//some compute
break;
case 3:
doCase3stuff();
break;
case 4:
doCase4stuff();
break;
case 5:
doCase3stuff();
doCase4stuff();
//perform my own function
break;
}
</code></pre>
",0
12871709,12871681,1,"<p>My initial thought is that you could place it into a loop, and in case 5, change choice to 4. 
Or, if it's possible you could perform a recursive call, passing 4 as the choice instead of 5.</p>
",1
12871716,12871681,1,"<p>Then make case 3 and case 4 code as two functions so you can call it there with no duplicate code writing, otherwise you can only achieve that by goto which is not a good idea</p>
",0
12806428,12243109,0,"<p>Temporary variables should be used when a value doesn't need to persist beyond the scope of a statement block or function definition.  </p>

<p>There are exceptions:</p>

<ol>
<li>The variable is also used outside the scope the statment block, such
as indices in <code>for</code> loops.</li>
<li>The variable is of sufficient size that it would overrun the local
storage (i.e. stack).</li>
<li>Large read-only data, such as character text.</li>
<li>The variable needs to be returned to the client as a reference.</li>
</ol>

<p>Some rules of thumb or guidelines for locating variables (scope):</p>

<ul>
<li>Declare variables as close to their usage as possible.</li>
<li>Variables referenced both inside and outside a statement block should
be factored out of the statement block.</li>
<li>Variables shared between functions should be declared with ""file
local scope"" a.k.a. within the file outside any file.</li>
<li>Huge variables should use dynamic memory.</li>
<li>Variables larger than simple PODs should be use dynamic memory and
passed around via smart pointers.  </li>
</ul>

<p>HTH.</p>
",0
14847877,14846958,0,"<p>As you said you are finding emacs in you $PATH variable, all path variables are located in either ~/.cshrc or ~/.bashrc depending on whether or not you use csh or bash respectively.  You can see which shell you are using using the command ps.  Maybe you are using different shells in each OS.</p>
",1
14848561,14846958,0,"<p>The <code>SunOS</code> <code>which</code> command is a <code>csh</code> script that sources your <code>.cshrc</code> file as it searches csh aliases, which it could not do from outside csh. The linux <code>which</code> command is a posix shell script. They are different commands, operating in different ways.</p>

<p>It makes far more sense to search along the <code>PATH</code> environment variable than relying on the which command. The which command can turn into a shell built-in on certain shells (e.g. <code>zsh</code>), and operates in different ways depending on the operating system (I think the mac uses a binary).</p>
",0
11894301,11894215,10,"<p><em>Probably</em> there's something still in the input buffer from a previous operation when you enter the loop.</p>

<p>It's picked up by the <code>getline</code>, found to be invalid, then the loop runs again.</p>

<hr>

<p>By way of example, let's say that, before you enter the loop, you read a single character. But, in cooked mode, you'll need to enter the character <em>and</em> a newline before it's actioned.</p>

<p>So, you read the character and the newline is left in the input buffer.</p>

<p>Then your loop starts, reads the newline, and deems it invalid so it then loops back to get your <em>actual</em> input line.</p>

<p>That's one possibility though, of course, there may be others - it depends very much on the code <em>before</em> that loop and what it does with <code>cin</code>.</p>

<p>If that <em>is</em> the case, something like:</p>

<pre><code>cin.ignore(INT_MAX, '\n');
</code></pre>

<p>before the loop may fix it.</p>

<p>Alternatively, you may want to ensure that you're using line-based input everywhere.</p>

<hr>

<p>Here's some code to see that scenario in action:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;climits&gt;

int main(void) {
    char c;
    std::string s;

    std::cout &lt;&lt; ""Prompt 1: "";
    std::cin.get (c);
    std::cout &lt;&lt; ""char ["" &lt;&lt; c &lt;&lt; ""]\n"";
    // std::cin.ignore (INT_MAX, '\n')

    std::cout &lt;&lt; ""Prompt 2: "";
    getline (std::cin, s);
    std::cout &lt;&lt; ""str1 ["" &lt;&lt; s &lt;&lt; ""]\n"";

    std::cout &lt;&lt; ""Prompt 3: "";
    getline (std::cin, s);
    std::cout &lt;&lt; ""str2 ["" &lt;&lt; s &lt;&lt; ""]\n"";

    return 0;
}
</code></pre>

<p>Along with a transcript:</p>

<pre><code>Prompt 1: Hello
char [H]
Prompt 2: str1 [ello]
Prompt 3: from Pax
str2 [from Pax]
</code></pre>

<p>in which you can see that it doesn't actually wait around for new input for prompt 2, it just gets the rest of the line you entered at prompt 1, because the characters <kbd>e</kbd>, <kbd>l</kbd>, <kbd>l</kbd>, <kbd>o</kbd> and <kbd>\n</kbd> are still in the input buffer.</p>

<p>When you uncomment the <code>ignore</code> line, it acts in the manner you'd expect:</p>

<pre><code>Prompt 1: Hello
char [H]
Prompt 2: from Pax
str1 [from Pax]
Prompt 3: Goodbye
str2 [Goodbye]
</code></pre>
",1
11894486,11894215,1,"<p>I would use debugger (for example gdb in linux) to check why. Why make a theories when you can find out the real answer?</p>
",0
15539953,15539935,12,"<p>No strange behavior here. Your strings are not nul-terminated, so there's no way for the <code>strlen()</code> function to identify where they end.</p>

<p>When you initialize your string like this:</p>

<pre><code>char consonant[] = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'};
</code></pre>

<p>There's no nul char added. You can either make it a string (the double-quotes cause the compiler to automatically append the nul terminator):</p>

<pre><code>char consonant[] = ""bcd...z"";
</code></pre>

<p>or you can include it yourself explicitly at the end of the array:</p>

<pre><code>char consonant[] = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', '\0'};
</code></pre>

<p>Otherwise, <code>strlen()</code> will happily read off the end of your array until it happens to find a byte somewhere in memory with a value of 0.</p>
",1
15539957,15539935,8,"<p><code>strlen</code> can only be used on a string and not an arbitrary array of characters.</p>

<blockquote>
  <p>The strlen() function shall compute the number of bytes in the <strong>string</strong> to which s points, not including the terminating null byte. -- IEEE1003</p>
</blockquote>

<p>The C++ standard says that <code>strlen</code> is C++ is identical to <code>strlen</code> in C. The C standard says:</p>

<blockquote>
  <p>The <code>strlen</code> function computes the length of the <strong>string</strong> pointed to by <em>s</em>. -- C99 7.21.6.3</p>
</blockquote>

<p>And:</p>

<blockquote>
  <p>A <em>string</em> is a contiguous sequence of characters terminated by and including the first null
  character. -- C99 7.1.1</p>
</blockquote>

<p>So you must ensure that whatever you pass to <code>strlen</code> is in fact a <em>string</em>, not just an array of characters.</p>
",8
16431256,16431222,5,"<p><a href=""http://en.cppreference.com/w/cpp/io/basic_istream"" rel=""nofollow noreferrer""><code>istream</code></a> defines a <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/operator_bool"" rel=""nofollow noreferrer"">conversion to <code>bool</code></a> which indicates whether the last read was successful. You can use this to test whether parsing a <code>double</code> succeeded:</p>

<pre><code>if (cin &gt;&gt; money) {
    // success
} else {
    // failure
}
</code></pre>

<p>If the stream is in a failed state and you want to retry reading¡ªe.g., to prompt the user for a new value¡ªthen you can use the <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/clear"" rel=""nofollow noreferrer""><code>clear()</code></a> member function to return the state to normal:</p>

<pre><code>cin.clear();
</code></pre>

<p>However, this does not clear the input buffer, so you will end up reading the same data again. You can clear the input buffer until the next newline character:</p>

<pre><code>cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
</code></pre>

<p>Or you can read by lines instead, and use a <a href=""http://en.cppreference.com/w/cpp/io/basic_stringstream"" rel=""nofollow noreferrer""><code>stringstream</code></a> to read individual values:</p>

<pre><code>string line;
getline(cin, line);
istringstream stream(line);
if (stream &gt;&gt; money) {
    // success
} else {
    // failure
}
</code></pre>

<p>This has the advantage of forcing user input to be line-based¡ªit¡¯s token-based by default.</p>
",2
14162010,14161966,4,"<p>The keyword <code>friend</code> is there specifically to bypass access restrictions imposed by <code>private</code> and <code>protected</code> access control.</p>

<p>If you would like to access private variables without using <code>friend</code>, add <em>public</em> accessors to the class itself: this is the most common and intended way of accessing private variables:</p>

<pre><code>class Point
{
public:
    Point( void ) : m_i(0) {}
    void PrintPrivate( void ){cout &lt;&lt; m_i &lt;&lt; endl; }
    int getI() {return m_i;}
    void setI(int _i) {m_i = _i;}
private:
    int m_i;
};
...
Point sPoint;
sPoint.setI(sPoint.getI()+1);
</code></pre>
",6
14162039,14161966,1,"<pre><code> void ChangePrivate ( Point &amp;i ) { *(int*)( ((char*)&amp;i) + 0 ) += 1; }
</code></pre>

<p>Replace 0 with offsetof() if applicable or custom-calculated offset.</p>

<p>Or something like</p>

<pre><code>struct HackPoint
{
  int m_i;
};

void ChangePrivate ( Point &amp;i ) { ((HackPoint*)(void*)&amp;i)-&gt;m_i++; }
</code></pre>
",3
14162084,14161966,0,"<p>Try this</p>

<pre><code>*(int*)(&amp;sPoint) += 1;
</code></pre>

<p>Instead of</p>

<pre><code>ChangePrivate(sPoint);
</code></pre>

<p>But it's not a good coding style, just for fun.</p>

<p><em>Inside the C++ Object Model</em>  This book gives detailed analysis about C++ object model</p>
",2
14162321,14161966,2,"<p>Access control does not apply to arguments to explicit template instantiations (<code>[temp.explicit]/12</code>). This can be exploited to give public access to private members (<a href=""http://bloglitb.blogspot.com.au/2010/07/access-to-private-members-thats-easy.html"" rel=""nofollow"">courtesy of litb</a>):</p>

<p>First some setup code:</p>

<pre><code>template&lt;typename Tag&gt;
struct result {
  /* export it ... */
  typedef typename Tag::type type;
  static type ptr;
};

template&lt;typename Tag&gt;
typename result&lt;Tag&gt;::type result&lt;Tag&gt;::ptr;

template&lt;typename Tag, typename Tag::type p&gt;
struct rob : result&lt;Tag&gt; {
  /* fill it ... */
  struct filler {
    filler() { result&lt;Tag&gt;::ptr = p; }
  };
  static filler filler_obj;
};

template&lt;typename Tag, typename Tag::type p&gt;
typename rob&lt;Tag, p&gt;::filler rob&lt;Tag, p&gt;::filler_obj;
</code></pre>

<p>Now the definition of <code>Point</code>:</p>

<pre><code>class Point
{
public:
    Point() : m_i(0) {}
    void PrintPrivate(){cout &lt;&lt; m_i &lt;&lt; endl; }
private:
    int m_i;
};
</code></pre>

<p>Now fill in <code>result&lt;Pointm_i&gt;::ptr</code> by explicitly instantiating <code>rob&lt;Pointm_i, &amp;Point::m_i&gt;</code> -- this is an explicit template instantiation, so access control does not apply:</p>

<pre><code>struct Pointm_i { typedef int Point::*type; };
template class rob&lt;Pointm_i, &amp;Point::m_i&gt;;
</code></pre>

<p>And access the private members:</p>

<pre><code>void ChangePrivate ( Point &amp;i ) { (i.*result&lt;Pointm_i&gt;::ptr)++; }

int main()
{
     Point sPoint;
     sPoint.PrintPrivate();
     ChangePrivate(sPoint);
     sPoint.PrintPrivate();
}
</code></pre>
",0
14162362,14161966,2,"<p>Here's a standard compliant hack (<a href=""http://bloglitb.blogspot.ro/2010/07/access-to-private-members-thats-easy.html"" rel=""nofollow"">source</a>):</p>

<pre><code>template&lt;typename Tag, typename Tag::type M&gt;
struct Rob { 
  friend typename Tag::type get(Tag) {
    return M;
  }
};

class Point
{
public:
    Point( void ) : m_i(0) {}
    void PrintPrivate( void ){cout &lt;&lt; m_i &lt;&lt; endl; }
private:
    int m_i;
};

struct Point_f { 
  typedef int Point::*type;
  friend type get(Point_f);
};
template struct Rob&lt;Point_f, &amp;Point::m_i&gt;;

void ChangePrivate ( Point &amp;i ) 
{  
    i.*get(Point_f()) = 4;
}
</code></pre>

<p><a href=""http://ideone.com/rpyuvp"" rel=""nofollow"">Sample on ideone.</a></p>
",2
12307010,12306885,2,"<p>The standard is pretty clear here: the trailing comma <em>is</em> allowed (a similar feature exists for declarations of constants within enums). The fact that you can't use it is a matter of the quality of implementation that you're using.</p>
",1
16381092,16381025,10,"<p>You allocate memory for array with dimensions <code>[layer][levelSize.x][levelSize.y]</code>, but while deleting you operate with it like with array with dimensions <code>[levelSize.x][levelSize.y][somenting]</code>.</p>

<pre><code>for(int i = 0; i != layer; ++i)
//                  ^^^^^ not levelSize.x
{
    for(int j = 0; j != levelSize.x; ++j)
    //                  ^^^^^^^^^^^ not levelSize.y
    {
        delete[] level_array[i][j];
    }
    delete[] level_array[i];

}
delete[] level_array;
</code></pre>
",2
11889652,11889176,0,"<p>Just another shot in the dark:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

using namespace std;

int main() {

    ifstream ifstr(""project.txt"");
    ofstream ofstr(""past.txt"");
    if(ifstr.fail()){
        cout &lt;&lt; ""error!"" &lt;&lt; endl;
    } // if

    bool skipOutput = false;
    do
    {
        string word;
        ifstr &gt;&gt; word;
        if(!word.empty() &amp;&amp; word[0] == '&lt;')
        {
            skipOutput = true;
        }
        if(!skipOutput)
        {
            ofstr &lt;&lt; word &lt;&lt; "" "";
            // replicate the output to stdout
            cout &lt;&lt; word;
        }
        if(word[word.length()-1] != '&gt;')
        {
            skipOutput = false;
        }
    } while(!ifstr.eof());
    cout &lt;&lt; endl &lt;&lt; ""copy complete"" &lt;&lt; endl;

    ifstr.close();
    ofstr.close();

    //system (""pause""); Doesn't compile with my system
    return 0;
} // main
</code></pre>

<p>If you're really just want to filter out words enclosed within '&lt;' and '>' characters this should be sufficient. If you have more complex parsing rules for your <code>&lt;&gt;</code> tags you should elaborate your question.</p>
",0
11889817,11889176,0,"<p>Pseudo-code (iostream-esque conditions) for the question in title (also removes the angle brackets):</p>

<pre><code>char c;
while (read_char_succeeded(&amp;c))
    if (c == '&lt;')
        while (read_char_succeeded(&amp;c) &amp;&amp; c != '&gt;')
            ;
    else
        write_char(c);
</code></pre>
",0
11889430,11889176,0,"<p>I'm not sure, that this is what you wanted. Please take a look at the code!</p>

<pre><code>//we create a boolean value, to know if we started skipping
bool skipStarted = false;

while(ifstr.get(c))
{
    //if its a '&lt;' and we havent started skipping jet,
    //then we start skipping, and continue to the next char.
    if(c=='&lt;' &amp;&amp; !skipStarted)
    {
        skipStarted = true;
        continue;
    }

    //if its a '&gt;' and we started skipping,
    //then we finish skipping, and continue to the next char.
    if(c=='&gt;' &amp;&amp; skipStarted)
    {
        skipStared = false;
        ifstr.get(c);
        if(c==' ')
            continue; 
    }

    //if we are skipping, then we go to the next char.
    if(skipStarted)
        continue;

    //otherwise we simply output the character.
    ofstr&lt;&lt;c;

}
</code></pre>
",5
12271726,12271700,2,"<p>You may want to use the <a href=""http://gmplib.org/"" rel=""nofollow"">GNU Multiple Precision Arithmetic Library</a>.</p>
",4
12271735,12271700,1,"<p>There's no primitive type for that.<br />
Vlad's comment is a good solution for storage, but if you need to use that number for computations, you'll need to use a library allowing representation and arithmetic operations on big numbers.</p>

<p>You should start by taking a look at GMP:</p>

<p><a href=""http://gmplib.org/"" rel=""nofollow"">http://gmplib.org/</a></p>
",0
12271798,12271700,0,"<p>If you only need to store it then you can store it in a byte array like ""char num128[16]"".</p>

<p>If you need to manipulate it you need to use big numbers library like GMP.</p>
",0
12271800,12271700,0,"<p>It is not possible to store it in one primitive data type, so we have to be slightly more creative. Probably the easiest way to do it is to have the class hold two 64-bit ints, representing the upper and lower halves of the integer.</p>
",1
12292681,12292554,0,"<p>You're really talking about several completely different things here.  Here are examples for two of them:</p>

<p>1) ""Friends"":</p>

<ul>
<li><p><a href=""http://www.learncpp.com/cpp-tutorial/813-friend-functions-and-classes/"" rel=""nofollow"">http://www.learncpp.com/cpp-tutorial/813-friend-functions-and-classes/</a></p>

<p>// Class declaration
class Accumulator  {
private:
  int m_nValue;
public:
  Accumulator() { m_nValue = 0; }
  void Add(int nValue) { m_nValue += nValue; }</p>

<p>// Make the Reset() function a friend of this class
  friend void Reset(Accumulator &amp;cAccumulator);
};</p>

<p>// Reset() is now a friend of the Accumulator class
void Reset(Accumulator &amp;cAccumulator)
{
    // And can access the private data of Accumulator objects
    cAccumulator.m_nValue = 0;
}</p></li>
</ul>

<p>2) ""Nested classes"":</p>

<ul>
<li><a href=""http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr061.htm"" rel=""nofollow"">http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr061.htm</a></li>
</ul>
",0
12292755,12292554,0,"<p>A friend is not a member. Here is a good example of how ""friend"" is used in practice.</p>

<pre><code>namespace Bar {

class Foo {

    public:
       // whatever...

    friend void swap(Foo &amp;left, Foo &amp;right); // Declare that the non-member function
                                             // swap has access to private section.
    private:
       Obj1  o1;
       Obj2 o2;
 };

 void swap(Foo &amp;left, Foo &amp;right) {
     std::swap(left.o1, right.o1);
     std::swap(left.o2, right.o2);
 }

} // end namespace Bar
</code></pre>

<p>We have declared a function for swapping Foo's that is more efficient than std::swap would be, assuming that classes Obj1 and Obj2 have efficient move-semantics. (Darn it, you are quick with that green check mark! :))</p>

<p>It is useful to know that because the swap routine is parameterized by a Foo object (two in this case) and is declared in the same namespace as Foo, it becomes part of Foo's public interface, even though it is not a member. The mechanism is called ""argument-dependent lookup"" (ADL).</p>
",0
12292611,12292554,1,"<p>The <code>friend</code> keyword is only used to specify if a function or other class can have access to the private members of that class. You have no need for class inheritance or nesting because <code>FriendFunctionTest</code> is a global function. Global functions do not require any class prefixes when invoked.</p>

<p>Source for <code>friend</code>: <a href=""http://msdn.microsoft.com/en-us/library/465sdshe(v=vs.80).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/465sdshe(v=vs.80).aspx</a></p>
",3
14227473,14227438,1,"<p>Unless this class is a pure template class or other class which is supposed to be inline, you'd better put class implementation into cpp files instead of header files. In a word, put interface in header files, while put implementations in cpp files.</p>

<p>P.S.</p>

<p>As @jogojapan said, I'm talking about the class implementation instead of class definition. That's because despite that OP is talking about class definition, I strongly doubt that he's actually meaning class implementation. </p>
",3
13421992,13421963,1,"<p>You're inheriting from an abstract class which is fine, but you are never implementing the pure virtual function that the base class defines.</p>

<p>Also you need a virtual destructor in your base class;)</p>

<p>Edit:
You're also doing other things that probably aren't necessary like redeclaring most of your derived class functions.  I bet their implementation is the exact same as your base class?</p>
",0
13421993,13421963,11,"<p>The <code>CSCourse</code> class <em>is</em> abstract.</p>

<p>You have declared a pure virtual function <code>reg</code> in <code>Course</code>, but not provided an implementation in <code>CSCourse</code>.</p>

<p>You compiler undoubtedly told you exactly this as well.</p>
",0
13421994,13421963,1,"<p>You have not implemented the pure virtual function <code>reg</code> in your derived class:</p>

<p><code>virtual void reg(Student &amp;s)=0;</code></p>

<p>So yes, your class is abstract.</p>
",0
12880070,12879947,1,"<p>Yes it is contiguous in row major order. Suppose you have a 2d array named <code>a[3][3]</code>. Then in memory elements will be in this order: <code>a[0][0]</code>, <code>a[0][1]</code>, <code>a[0][2]</code>, <code>a[1][0]</code>, <code>a[1][1]</code>, <code>a[1][2]</code>, <code>a[2][0]</code>, <code>a[2][1]</code>, <code>a[2][2]</code>. </p>

<p><a href=""http://www.cplusplus.com/doc/tutorial/arrays/"" rel=""nofollow"">Here is more details with an example</a></p>
",0
12880160,12879947,1,"<p>Given a declaration <code>T D[C]</code>, where <code>T</code> is a type name, <code>D</code> an identifier and <code>C</code> an integral constant expression, the Standard says (highlighting mine):</p>

<blockquote>
  <p>(¡ì8.3.4/1) [...] then the type of the identifier [...] is an array type. [...] The constant expression speci?es the bound of (number of elements in) the array. If the value of the constant expression is N, the array has N elements numbered 0 to N-1, and the type of the identi?er of D is ¡°derived-declarator-type-list array of N T¡±. An object of array type contains a <strong>contiguously allocated non-empty set of N subobjects of type T.</strong> [...]</p>
</blockquote>

<p>And:</p>

<blockquote>
  <p>(¡ì8.3.4/3) When several ¡°array of¡± speci?cations are adjacent, a multidimensional array is created; [...]</p>
</blockquote>

<p>As well as:</p>

<blockquote>
  <p>(¡ì8.3.4/9) [ Note: It follows from all this that arrays in C++ are stored row-wise (last subscript varies fastest) and that the ?rst subscript in the declaration helps determine the amount of storage consumed by an array but plays no other part in subscript calculations. ¡ª end note ]</p>
</blockquote>

<p><strong>Conclusion</strong><br>
All this makes it clear that <code>T a[N][M]</code> is a <em>contiguously stored</em> list of <code>N</code> objects, each of which is <em>a contigously stored</em> list of <code>M</code> objects of type <code>T</code>. So yes, the whole two-dimensional array is one contiguously stored object.</p>

<p><em>Does that mean you can use one combined index to access the elements directly?</em>
So, given an array <code>int a[10][5]</code>, can you use <code>a[0][23]</code> instead of <code>a[2][3]</code>? Stricly speaking, no, because that is a violation of the first rule above, whereby only indexes <code>0..4</code> are valid for the second index. However, as far as that particular expression is concerned, if you were to consider <code>a[0]</code> as a pointer <code>p</code> to the first element of the first row of the array, and <code>a[0][23]</code> as <code>*(p+23)</code>, you could be sure to access the correct element. More on this question in <a href=""https://stackoverflow.com/questions/7269099/may-i-treat-a-2d-array-as-a-contiguous-1d-array"">this existing question</a>.</p>
",0
17829094,17829051,8,"<p>You've ran out of memory. On a 32bit system (on Windows at least) you can only allocate up to a maximum of ~2GB of memory. You need to dynamically load your data only when needed, and when you no longer need the image data, throw it away again.</p>

<p>In reality, the limit will be lower than 2GB, as memory is allocated in blocks (i.e. it isn't allocated contiguously). This means you will experience heap fragmentation if you mix small and large object allocations, and that will drastically reduce the amount of memory you can actually allocate.</p>
",2
17829233,17829051,1,"<p>Store the images in a folder and load one at a time. 
Dynamic memory allocation is your friend. </p>

<p>There is nothing I could think of to accomplish by loading 18,000 images together. You are never going to process it even on a super computer. </p>
",0
12256871,12256757,2,"<p>You can't read a <code>std::string</code> using <code>scanf</code>. <code>scanf(""%s"", ...)</code> expects a <code>char*</code> and you can't simply pass a pointer to <code>std::string</code>, it's a very different data structure. A quick fix would be to change the lines that look like this:</p>

<pre><code>scanf(""%s"",&amp;name);
</code></pre>

<p>to this:</p>

<pre><code>std::cin &gt;&gt; name;
</code></pre>

<p>or this:</p>

<pre><code>std::getline(std::cin, name);
</code></pre>
",3
13774411,13774385,1,"<p>You subclass implementation should look like:</p>

<pre><code>void SensorTemp::updateValue() {
    // ...
}
</code></pre>
",1
13774441,13774385,1,"<p>It seems you are trying to learn dynamic dispatch through <code>virtual</code> keyword. In dynamic dispatch the actual type of object determines the appropriate method from that class to be called. To achieve this, the base class should provide a <code>virtual</code> method and each of the sub-classes should overrie that virtual method to provide their own behavior.    </p>

<p>So each of your subclass should <strong>override</strong> the virtual method.       </p>

<p><strong>//.h file</strong></p>

<pre><code>class SensorTemp : public Sensor
{
 private:


 public:
    virtual void updateValue();

};
</code></pre>

<p><strong>//.cpp file</strong></p>

<pre><code>void SensorTemp::updateValue() 
{
// ....
}
</code></pre>

<p>If your sub-classes do not override the <code>virtual</code> method then irrespective of the actual <em>type</em> of the object(be it base or sub-class) the Base class <code>virtual</code> method will be called.</p>
",1
13440544,13440434,2,"<p>I bet the breakpoint you set isn't triggered because the condition isn't <code>true</code>: that is with <code>currentSemester</code> being <code>1</code> the condition is clearly <code>false</code> and the code skips to whatever is happening after the conditional block. You haven't shown what is happening, there, however.</p>
",1
13440626,13440434,0,"<blockquote>
<pre><code>for (int j = 0; j &lt; currentSemester - 1; j++) {
       if (studentsVector.at(i)-&gt;getPlan().at(j).size() &gt; 0) {
</code></pre>
</blockquote>

<p>Here you do not check that <code>studentsVector.at(i)-&gt;getPlan()</code> has <code>j</code> elements. Your code just assumes it based on what <code>currentSemester</code> is, but you never check. And clearly this correlation has broken down somewhere.</p>
",2
12339458,12338696,2,"<pre><code>CNeurona getElementoVectorNeuronas(int x)
</code></pre>

<p>returns a <strong>copy</strong> of the <code>CNeurona</code> object in the vector. When you call</p>

<pre><code>getElementoVectorNeuronas(j).setActivacion(i);
</code></pre>

<p>You call the <code>setActivation</code> method on a <strong>copy</strong> of the <code>CNeurona</code> object, returned by <code>getElementoVectorNeuronas</code>, this <strong>copy</strong> is subsequently discarded.</p>

<p>You need to use a reference instead; your function should be</p>

<pre><code>CNeurona&amp; getElementoVectorNeuronas(int x)
</code></pre>

<p>And if <code>getElementoVectorCapas</code> returns a copy too - it is an error in your case, it should return a reference.</p>
",2
12271895,12253613,0,"<p>I just realized a relatively simple solution that would give me pretty much what I want without too much fuss. For any particular instance of the <code>MyPropMap</code> type, I'm dealing with the properties of <em>one</em> particular kind of material: isotropic elastic, piezoelectric, anisotropic elastic, and so on. Given this, I can wrap the enums corresponding to each material type in its own namespace and put them in the appropriate header file, so for example,</p>

<pre><code>// MatPropKey/IsotropicElastic.hpp:
namespace IsotropicElastic {
   enum { ELASTIC_MODULUS, POISSONS_RATIO };
}

// MatPropKey/GenElastic.hpp
namespace GenElastic {
   enum { ELASTICITY_MATRIX }
}

// MatPropKey/PiezoElastic.hpp
namespace PiezoElastic {
   enum { PIEZO_CONST_MATRIX, ELASTICITY_MATRIX }
}
</code></pre>

<p>There is some redundancy here, but I can live with that. So long as I stick to the above convention, then within each namespace, the <code>enum</code> values are unique, and so long as I only use the <code>enum</code> values within a particular namespace for each instance of <code>MyPropMap</code>---which I want to do anyway---I'm fine. (Realistically, I'd also want to wrap each of these namespaces within a common <code>MPKey</code> namespace.) Of course, this isn't foolproof. A sufficiently creative fool could, for example, decide to <code>#include</code> both <code>GenElastic.hpp</code> and <code>PiezoElastic.hpp</code> and then use <code>GenElastic::ELASTICITY_MATRIX</code> with the <code>PiezoElastic::PIEZO_CONST_MATRIX</code>. Bad things could then happen. Still, the code communicates how the named constants are supposed to be grouped, and avoiding unwanted name clashes is trivial.</p>

<p>Wish I thought of it earlier.</p>
",0
12292105,12253613,0,"<p>After some thought, I realized a few things:</p>

<ol>
<li>It's better to wrap the map within a class, so that I have a bit more control over how it is written.</li>
<li>Even the wrapped map is generic and has to be able to accommodate any material parameter type, so there's only so much compile-type safety that I can provide.</li>
</ol>

<p>Given this, I decided to design a <code>MatProp</code> class roughly as follows:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;map&gt;

class MatProp {
public:
   // Skipping the constructor details ...

   void setProp_Raw(int propId, double val);
   void getProp_Raw(int propId, double &amp; val) const;

   void setProp_Raw(int propId, const std::vector&lt;double&gt; &amp; vals);
   void getProp_Raw(int propId, std::vector&lt;double&gt; &amp; vals) const;

   // More overloaded set/get funcs for complex scalars and vectors ...

private:
   // The typedef allows me to write MatPropMap_::iterator, etc. in the
   // implementation of the member functions, which is handy if, say, 
   // I want to swap the std::map for an unordered_map later on.
   typedef std::map&lt;PropertyLabel,std::vector&lt;double&gt; &gt; MatPropMap_;

   MatPropMap_ matPropMap_;

};
</code></pre>

<p>The set/get functions are suffixed with <code>_Raw</code> because it's easy to put in a wrong combination of property ID and value. I could pass in information to the constructor of <code>MatProp</code> so that the inputs to these functions could be validated at run time, but setting that up could get clunky and make the class harder to use. To add some extra safety, I can do this, for example:</p>

<pre><code>void setIsotropicLinearElasticParameter(MatProps mProp,
          ElasPropEnum propId, // ELASTIC_MODULUS and POISSONS_RATIO are the 
                               // *only* valid values of this parameter.
          double val) {
    mProp.setParam_Raw(propId, val);
}
</code></pre>

<p>The function is simple, but I'm declaring clearly that (1) only two keys are allowed and (2) they really are supposed to be of type <code>double</code>. The interface isn't totally foolproof, but it's fairly easy to use correctly and takes some effort to use wrong. FWIW, a similar thing was done here: <a href=""http://blog.knatten.org/2010/04/23/make-apis-hard-to-use-incorrectly/"" rel=""nofollow"">http://blog.knatten.org/2010/04/23/make-apis-hard-to-use-incorrectly/</a>.</p>
",1
16446392,16446361,3,"<p>Functions need to be at least declared before you use them, if not defined. Try putting this at the top of your file.</p>

<pre><code>bool startProcess(int argc, char* argv[]);
</code></pre>

<p>The above is a <em>declaration</em>, you're telling the compiler that at some point, you're going to provide a <em>definition</em> for the function, which is this:</p>

<pre><code>bool  startProcess(int argc, char* argv[])
{
   code here...    
}
</code></pre>

<p>This difference between a <em>declaration</em> and a <em>definition</em> is important for being able to separate your code into separate files. If you had placed your <em>definition</em> of <code>startProcess</code> in a different file, the compiler would never actually see it while compiling the file that contains <code>main</code>. However, with the <em>declaration</em>, you're making a promise that it exists somewhere.</p>
",0
16446394,16446361,3,"<p>You haven't declared that function before <code>main()</code>, so the compiler is unaware of the existence of <code>startProcess</code> at the point of call:</p>

<pre><code>bool startProcess(int argc, char* argv[]); // &lt;== Informs the compiler about
                                           //     the existence of startProcess
                                           //     (and about its signature)

int main(int argc, char* argv[])
{
    bool result = startProcess(argc, argv); // OK because of the declaration
                                            // above: the compiler knows that
                                            // somewhere (possibly in another
                                            // translation unit) the definition
                                            // of startProcess is provided
    return 0;
}

bool startProcess(int argc, char* argv[])
{
    // ...
}
</code></pre>

<p>Alternatively, you can put the definition directly before <code>main()</code>:</p>

<pre><code>bool  startProcess(int argc, char* argv[])
{
    // ...
}

int main(int argc, char* argv[])
{
    bool result = startProcess(argc, argv);
    return 0;
}
</code></pre>
",1
16446396,16446361,1,"<p>Make a prototype before your main function.</p>

<pre><code>bool startProcess(int argc, char* argv[]);
</code></pre>
",0
16446400,16446361,2,"<p>You should put the declaration of <code>startProcess</code> before main if you would like to put definition of it after <code>main</code>.</p>

<pre><code>bool  startProcess(int argc, char* argv[]); //declare here

int main(int argc, char* argv[])
{
    bool result=startProcess(argc, argv);
    return 0;
}

bool  startProcess(int argc, char* argv[])
{
}
</code></pre>

<p>or you can put the definition of <code>startProcess</code> directly before <code>main</code>.</p>
",0
14747433,14747409,7,"<p>That's not a <code>const</code> pointer, but a pointer to <code>const</code>. So you can modify the pointer, you can't that which it points to.</p>

<p>A <code>const</code> pointer is</p>

<pre><code>int* const x;
</code></pre>

<p>and your code wouldn't compile then.</p>
",0
13405972,13405716,1,"<p>In your constructors you use</p>

<pre><code>array.reserve(arraySize);
</code></pre>

<p>but <code>std::vector::reserve</code> only reserves some memory for easy array expansion and does not create elements (nor resizes array). So, your cells don't get constructed. </p>

<p>Then, when you are trying to assign something to array, you are actually go out of array range. </p>

<p>You should use <code>std::vector::resize</code> instead of <code>std::vector::reserve</code> (as a simplest solution)</p>

<pre><code>array.resize(arraySize);
</code></pre>
",0
13722175,13721970,3,"<p>No, there is nothing like that in the standard library. You can write one yourself:</p>

<pre><code>template&lt;typename T, typename Func&gt;
std::vector&lt;T&gt; transform(std::vector&lt;T&gt; const &amp;input, Func func) {
    std::vector&lt;T&gt; result(input.size());
    std::transform(input.begin(), input.end(), result.begin(), func);
    return result;
}
</code></pre>

<p>A better solution may be to use <a href=""http://www.boost.org/doc/libs/1_55_0/libs/range/doc/html/range/reference/adaptors/reference/transformed.html"" rel=""nofollow""><code>transformed</code> adaptor from Boost.Range</a> as it does not allocate additional container.</p>
",0
15831450,15831435,3,"<p>No, C++ standard doesn't support <a href=""http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html"" rel=""nofollow"">VLA</a></p>
",0
15831464,15831435,3,"<p>Your compiler is trying to use the non-standard <a href=""http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html"" rel=""nofollow"">Variable-Length Arrays</a> feature.</p>

<p>Frankly I've found that it doesn't always even work properly. Not sure why that has been the case, but I've learned to avoid it.</p>
",0
16471737,16471671,3,"<p>Without a suffix, the compiler will choose the first of <code>int</code>, <code>long int</code> and <code>long long int</code> in which the value will fit. However, you might specifically want a value that would fit in an <code>int</code> to be of <code>long long int</code> type. For that you would use the <code>LL</code> suffix.</p>

<p>Contrived example:</p>

<pre><code>template &lt;typename T&gt;
void foo(T x) {
  static_assert(std::is_same&lt;T, long long&gt;::value, ""Must be long long!"");
}

int main()
{
    foo(0); // Error because 0 without a suffix is an int
    foo(0LL);
}
</code></pre>

<p>To demonstrate that these literals have different sizes (assuming <code>int</code> and <code>long long int</code> have different sizes in your implementation), consider <a href=""http://ideone.com/ERpQpF"" rel=""nofollow"">the following example</a>:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; sizeof(0) &lt;&lt; ' ' &lt;&lt; sizeof(0LL) &lt;&lt; std::endl;
}
</code></pre>

<p>For me, this outputs:</p>

<pre><code>4 8
</code></pre>
",4
16471743,16471671,4,"<p>Your code is equivalent to</p>

<pre><code>long long x;
x = 5435666LL
</code></pre>

<p>Without the <code>LL</code> suffix, <code>5435666</code> is an <code>int</code>. In either case the result is the same because <code>5435666</code> fits in an <code>int</code>, unless you're on a 16 bit platform.</p>
",3
16471823,16471671,1,"<p>In your example it has only a cosmetic purpose.</p>

<p>I can think of the following examle where it could make a difference, because the literal is assumed to be <code>int</code>:</p>

<pre><code>enum {
    Flag1 = 1 &lt;&lt; 0,
    Flag2 = 1 &lt;&lt; 33,
    Flag3 = 1LL &lt;&lt; 33;
}
</code></pre>
",0
14191532,14191499,6,"<p>In your <code>sort_points</code> function, you declared <code>vect</code> as <code>const</code>. Later, you say:</p>

<pre><code>vect[j-1] = vect[j];
vect[j] = temp;
</code></pre>

<p>Since <code>vect</code> is <code>const</code>, this causes the <code>const</code> version of <code>operator[]</code> to be called, which returns a <code>const</code> reference to the object, which is not assignable.</p>

<p>Seeing as how it's named <code>sort_points</code> and does not return a new vector, I would expect it to modify the vector I pass in.</p>
",0
17830609,12381006,1,"<p>I suspect you have the following problem:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx</a></p>

<p>Scroll down to the remarks section, and look for ""Visual C++"": if the DLL contains _declspec-style thread local storage you can only load it dynamically in Vista or later.</p>

<p>I'm trying to achieve the same thing but apparently, for XP, we are simply out of luck...</p>
",0
13442207,13441796,1,"<p>Your code has several problems.</p>

<p>For example, you have a fixed array of 0 size. If you want a <strong>dynamically</strong> growable array, you can use <code>std::vector</code>: you can add new items at the end of the vector (dynamically resizing it) using <code>push_back()</code> method:</p>

<pre><code>#include &lt;vector&gt;

// Start with an empty vector
std::vector&lt;int&gt; v;

// Add some items to it
v.push_back(10);
v.push_back(20);
....
</code></pre>

<p>Note also that in header files it's not good to insert a <code>using namespace std;</code>. In this way you pollute the global namespace with STL classes, which is bad. Just <strong>use <code>std::</code> prefix in header files</strong>.</p>

<p>Moreover, if you want to print the class content to an output stream, you may want to take the class as a <strong>const reference</strong>, since instances of the class are input parameters (you <em>observe</em> them and print their content to the stream):</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const IntList&amp; a)
{
   ....
}
</code></pre>
",0
13441808,13441796,3,"<p>This looks bad:</p>

<pre><code>int arr[0];
</code></pre>

<p>First, C++ doesn't allow zero-sized fixed size arrays. Second, your code certainly needs more than a zero sized array. </p>

<p>Whatever use you make of this code is undefined behaviour (UB). UB includes code seemingly ""working perfectly fine"".</p>
",5
18200406,18199913,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
using namespace std;

bool isValidNumber (string str)
{
  if (str.length() &gt; 2 || str.length() == 0)
    return false;
  else if (str.length() == 2 &amp;&amp; str != ""10"")
    return false;
  else if (str.length() == 1 &amp;&amp; (str[0] &lt; '0' || str[0] &gt; '9'))
    return false;
  return true;
}

int main()
{
  ifstream fin(argv[1]);
  if(!fin.good())
  {
    cout&lt;&lt;""File does not exist -&gt;&gt; No File for reading"";
    exit(1);
  }

  //To check file is empty http://stackoverflow.com/a/2390938/1903116
  if(fin.peek() == std::ifstream::traits_type::eof())
  {
    cout&lt;&lt;""file is empty""&lt;&lt;endl;
    exit(1);
  }
  string tmp;
  getline(fin,tmp);
  if (isValidNumber(tmp) == false)
  {
    cerr &lt;&lt; ""Invalid number : "" + tmp &lt;&lt; endl;
  }
  else
  {
    cout &lt;&lt; ""Valid Number : "" + tmp &lt;&lt; endl;
  }
}
</code></pre>
",0
14190300,14190199,1,"<p>Yes, you have guessed correctly. The <a href=""http://www.cplusplus.com/reference/algorithm/set_difference/"" rel=""nofollow"">std::set_difference </a> function needs the &lt; operator to function. It uses it to check equality as (!a

<pre><code>The comparison to check for equivalence of values, uses either
operator&lt; for the first version, or comp for the second, in order to
test this; The value of an element, a, is equivalent to another one,
b, when (!a&lt;b &amp;&amp; !b&lt;a) or (!comp(a,b) &amp;&amp; !comp(b,a)).
</code></pre>

<p>All you would need to do is to add a function like below</p>

<pre><code>bool operator&lt;(const SPoint&amp; p1, const SPoint&amp;p2){
    return p1.id &lt;p2.id;
}
</code></pre>

<p>Assuming your <code>id</code> field is a unique field. Now you will be able to use the <code>std::set_difference</code> function. This compares two <code>SPoint</code> variables by their <code>id</code> fields.</p>

<p>Note that BOTH ranges need to be <strong>sorted</strong> for it to work correctly.</p>
",0
14190686,14190199,1,"<p>You could use e.g. <a href=""http://en.cppreference.com/w/cpp/algorithm/remove"" rel=""nofollow""><code>std::remove_if</code></a>:</p>

<pre><code>std::remove_if(std::begin(points), std::end(points), [](const SPoint&amp; point) {
    // Try to find the point in the `chosen` collection
    auto result = std::find_if(std::begin(chosen), std::end(chosen),
        [](const SPoint&amp; p) {
            return (p.id == point.id)
        });

    // Return `true` if the point was found in `chosen`
    return (result != std::end(chosen));
});
</code></pre>

<p>Note that I use C++11 <a href=""http://en.wikipedia.org/wiki/C%2B%2B11#Lambda_functions_and_expressions"" rel=""nofollow"">lambda functions</a> in the above code.</p>
",0
12878611,12878583,2,"<p>Maybe you can do something evil with logarithms</p>

<p>maybe there is a library that you can find that lets you deal with  big integers </p>
",4
12878659,12878583,2,"<p>You can try to use <a href=""http://en.wikipedia.org/wiki/Newton%27s_method"" rel=""nofollow"">Newton's method</a>. In this case you need to use <a href=""http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic"" rel=""nofollow"">arbitrary-precision arithmetic</a>. </p>

<p>I.e. you need to write class for arbitrary-precision number. It would be composition of mantissa, which is represented by array of digits and exponent, which is represented by integer. You should realize basic operations on numbers similar to pencil-and-paper methods. Then you should realize Newton's algoriithm as described in wiki.</p>
",0
12878679,12878583,2,"<p>It depends on the accuracy required. Since 1e100 cannot be exactly represented by a double, you have a problem.</p>

<p>This works, if you are willing to accept that it does not yield an exact solution. But then, I just said that 1e100 is not represented exactly as a double anyway. Thus, in MATLAB,</p>

<pre><code>exp(log(1e100)/4)
ans =
                     1e+25
</code></pre>

<p>Ok, so it looks like 1e25 is the answer, but is it really? In fact, the number we really get, in terms of a double, is: 10000000000000026675773440.</p>

<p>One problem is the original number was not represented exactly anyway. So 1e100, when stored in the IEEE format, is more accurately stored as something like this:</p>

<pre><code>1.00000000000000001590289110975991804683608085639452813897813e100
</code></pre>

<p>To solve this exactly, you would best be served by a big integer form, but a big decimal form would do reasonably well too.</p>

<p>Thus, in MATLAB, using my big decimal (HPF) form we see that 1e100 is exactly represented in 100 digits of precision.</p>

<pre><code>x = hpf('1e100',100)
x =
1.e100
</code></pre>

<p>And, to 100 digits of precision, the root is correct.</p>

<pre><code>exp(log(x)/4)
ans =
10000000000000000000000000
</code></pre>

<p>Actually though, be careful, as any floating point form cannot represent real numbers exactly. To more precision, we see that the number computed was actually slightly in error:</p>

<p>9999999999999999999999999.9999999999999999999999999999999999999999999999999999999999999999999999999999999999800</p>

<p>A big integer form will yield an exact result, if one exists. Thus, using a big integer form, we see the expected result:</p>

<pre><code>vpi(10)^100
ans =
    10000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000                                       

nthroot(vpi(10)^100,4)
ans =
    10000000000000000000000000
</code></pre>

<p>The point is, to do the computation you desire, you need to use tools that can do the computation. There are many such big decimal or big integer tools to be had. For example, Java has a <a href=""http://docs.oracle.com/javase/1.5.0/docs/api/java/math/package-summary.html"" rel=""nofollow"">BigDecimal and a BigInteger</a> form that I have used on occasion (though I've written my own tools anyway, thus in MATLAB, <a href=""http://www.mathworks.com/matlabcentral/fileexchange/36534-hpf-a-big-decimal-class"" rel=""nofollow"">HPF</a> and <a href=""http://www.mathworks.com/matlabcentral/fileexchange/22725-variable-precision-integer-arithmetic"" rel=""nofollow"">VPI</a>.)</p>
",0
14176339,14176317,0,"<p>To pass a vector as an argument to a function you do something like this:</p>

<pre><code>void func(const vector&lt;SPoint&gt;&amp; points) {
  ... do stuff
}
</code></pre>

<p>Then you call the function in you code like this:</p>

<pre><code>  ...some stuff
  vector&lt;SPoint&gt; a;
  func(a);
</code></pre>
",0
14176342,14176317,0,"<p>Just use a <code>const</code> reference to a vector and pass it to the function:</p>

<pre><code>void print(const vector&lt;SPoint&gt; &amp;data) const {

}

...

print(points);
</code></pre>
",0
14176354,14176317,1,"<p>You could do something like this:</p>

<pre><code>void
print(const std::vector&lt;SPoint&gt;&amp; vect, const std::string&amp; message)
{
    std::cout &lt;&lt; message &lt;&lt; "":"" &lt;&lt; std::endl;
    for (int i = 0, size = vect.size(); i &lt; size; ++i)
        std::cout &lt;&lt; vect[i].X &lt;&lt; "":"" &lt;&lt; vector[i].Y &lt;&lt; "" "";
    std::endl;
}

print(points, ""Points"");
print(points, ""Selected"");
print(points, ""Cleared"");
</code></pre>

<p>Good luck</p>
",2
14176359,14176317,0,"<p>Here is a full <em>C++</em> style approach:</p>

<pre><code>struct SPoint
{   
    int X;
    int Y;
};

std::ostream&amp; operator &lt;&lt;( std::ostream&amp; stream, SPoint const&amp; point )
{
    stream &lt;&lt; '(' &lt;&lt; point.X &lt;&lt; ',' &lt;&lt;point.Y &lt;&lt; ')';
    return stream;
}

void print_vector( std::ostream&amp; stream, std::vector&lt; SPoint &gt; const&amp; vector )
{
    std::copy(
        points.begin(), points.end()
      , std::ostream_iterator&lt; SPoint &gt;( std::cout, '\n' )
    );
}
</code></pre>

<p>and then:</p>

<pre><code>print_vector( std::cout, points );
print_vector( std::cout, selected );
print_vector( std::cout, cleared );
</code></pre>
",2
12336411,12336387,5,"<p>Your problem is this line:</p>

<pre><code>cout &lt;&lt; ""Current balance is now: "" &lt;&lt; m_bao.getBalance() + '\n';
</code></pre>

<p>Which the compiler sees as:</p>

<pre><code>cout &lt;&lt; ""Current balance is now: "" &lt;&lt; (m_bao.getBalance() + '\n');
</code></pre>

<p><code>'\n'</code> is <code>10</code> as an int, so you get this:</p>

<pre><code>cout &lt;&lt; ""Current balance is now: "" &lt;&lt; (m_bao.getBalance() + 10);
</code></pre>

<p>You probably meant to do this:</p>

<pre><code>cout &lt;&lt; ""Current balance is now: "" &lt;&lt; m_bao.getBalance() &lt;&lt; '\n';
</code></pre>

<p>Remember that in C++, <code>+</code> almost always means ""add these two numbers"".</p>
",10
16459317,16459195,4,"<p>You are trying to control a compiling (preprocessing) process using a run-time variable value. It is not possible.</p>

<p>You should either select parts of your code to be compiled at a preprocessing stage (using <code>#define</code>), or you can write a <code>switch</code> statement that will select the needed encoding (if the <code>code</code> is constant, then an optimizing compiler will efficiently eliminate the <code>switch</code>).</p>
",1
12788252,12788183,3,"<p>Destructor works fine, but copy constructor involved in pushing stuff around isn't incrementing counter.</p>

<p>Just implement explicit copy constructor taking care of the counter.</p>
",2
12788316,12788183,1,"<p>In the second case, each Task instance passed to push_back is a <em>temporary variable</em>. This means that its destructor is called once the call to push_back is complete. The destructor then decrements the counter before the next Task is created.</p>

<pre><code>myTasks.push_back( Task(""First Task"") ); // Task's destructor is called before the next line
</code></pre>

<p>Although the Task is copied into the vector (so the data exists elsewhere in memory), the implicit copy constructor that std::vector uses for this does not increment the counter.</p>
",2
14731374,14731334,2,"<p>For the same reason that you make other methods virtual.</p>

<pre><code>Person *p;
...

delete p;
</code></pre>

<p>wouldn't handle subclasses of <code>Person</code> properly if the destructor wasn't virtual. i.e. it would simply invoke the <code>Person</code> component and not the subclass component (e.g. <code>Employee</code>) </p>
",0
14731410,14731334,1,"<p>Because that's what the standard says. <code>delete p;</code> is undefined behavior otherwise. </p>

<h3>5.3.5 Delete [expr.delete]</h3>

<blockquote>
  <p>3) In the first alternative (delete object), if the static type of the object to be deleted is different from its
  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the
  static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete
  array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>
</blockquote>

<p>The reason it's like that is probably for it to be able to handle calling derived class destructors (like calling virtual functions) without adding overhead to classes that don't require it (i.e. don't make all classes polymorphic by introducing a <code>virtual</code> destructor by default just to handle this particular case).</p>
",0
14149660,14149629,2,"<p>The standard approach:</p>

<pre><code>class vpair
{
public:
    int vid;
    int vlabel;
};

bool operator &lt; (vpair const&amp; x, vpair const&amp; y)
{
     return std::tie(x.vid, x.vlabel) &lt; std::tie(y.vid, y.vlabel);
}
</code></pre>

<p>Of course, the operator can be a member:</p>

<pre><code>class vpair
{
    int vid;
    int vlabel;
public:
    bool operator &lt; (vpair const&amp; y) const
    {
         return std::tie(vid, vlabel) &lt; std::tie(y.vid, y.vlabel);
    }

};
</code></pre>
",3
14149666,14149629,1,"<p>Sort, by default, compares with the <code>operator&lt;</code>.  You can implement this operator for your class like so:</p>

<pre><code>public:
bool operator &lt; (const vpair&amp; other) const
{
     return (vid &lt; other.vid); // Uses vid but this can be vlable or something else.
}
</code></pre>

<p>If you don't have an overload for the <code>operator&lt;</code> with the class you're using, you can always pass in a comparison function as <code>std::sort</code>'s third argument:</p>

<pre><code>bool compare_func(vpair i,vpair j) { return (i.vid &lt; j.vid); }
sort(vpair_list, vpair_list+j, compare_func);
</code></pre>
",0
14149752,14149629,0,"<blockquote>
  <p>Does the sorting work like comparing each property(vid and vlabel) or....? </p>
</blockquote>

<p>It happens <strong>exactly how you want</strong> it to happen. </p>

<p>By default as people have mentioned, the <code>&lt;</code> operator is used by various sort algorithms to arrange elements in <strong>ascending order of that operator</strong>. However for classes/structs there is <strong>no default way</strong> to compare them meaning <strong>you the programmer</strong> has to code it in. </p>

<p>That is what </p>

<pre><code>bool operator &lt; (const vpair&amp; x, const vpair&amp; y);
</code></pre>

<p>is. It is just a declaration to the definition of the function the programmer has provided to compare 2 <code>vpair</code> order. The programmer uses his rules to decide and ultimately returns <code>true</code> or <code>false</code>. This is used to sort.</p>

<p>So <strong>you can decide</strong> exactly how you want it to sort. </p>

<pre><code>bool operator &lt; (const vpair&amp; x, const vpair&amp; y)
{
     if(x.vid != y.vid)
        return x.vid&lt;y.vid;

     return x.vlabel &lt;y.vlabel;
}
</code></pre>

<p>This would sort by ascending order of ID, if they are equal, It then sorts by ascending order of vlabel.</p>
",2
12336524,12336511,0,"<p>C arrays have a strange quirk that allows them to be accessed through the ""opposite"" direction. This is deeply rooted in the pointer arithmetic of arrays. For example, <code>a[1]</code> is equivalent to <code>*(a + 1)</code>. Likewise, <code>1[a]</code> is equivalent to <code>*(1 + a)</code>. Due to the commutative nature of addition, this works out quite nicely. More details can be found <a href=""https://stackoverflow.com/questions/381542/with-c-arrays-why-is-it-the-case-that-a5-5a?lq=1"">here</a>.</p>

<p>With that knowledge in tact, the expression <code>i[j[a]]</code> can be broken down into two different parts. <code>j[a]</code> is equivalent to <code>*(j + a)</code> which would return another array due to the multi-dimensional nature of the array you have, for example purposes we'll call this returned array <code>p</code>. Then you have the statement <code>i[p]</code> which would be equivalent to <code>*(i + p)</code>. Bringing it back all together would show you that <code>i[j[a]]</code> is equivalent to <code>*(i + *(j + a))</code>. Indeed, this means that <code>i[j[a]]</code> is just an obfuscated way of writing <code>a[j][i]</code>.</p>
",6
12336638,12336511,0,"<p>In C/C++, you can either subscript a pointer with an integral index, or subscript an integral index with a pointer, and the meaning (semantics) are exactly the same. I don't know offhand why the heck the insane syntax is valid, but so it is, and apparently so it will remain for ever after.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv)
{
  int i = 1, array[10];
  printf(""%ld\n"", &amp;(i[array])-&amp;(array[i]));
  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>0
</code></pre>
",0
12256310,12256297,1,"<p>Unless the docs (ie, the ISO C++11 standard) say it's thread-safe (and they don't), then that's it. Period. It's not thread-safe.</p>

<p>There may be <em>implementations</em> of a std::map that would allow this but it's by no means portable.</p>

<p>Maps are often built on red-black trees or other auto-balancing data structures so that a modification to the structure (such as inserting or deleting a key) will cause rebalancing.</p>

<p>You should wrap read and write operations on the map with something like a mutex semaphore, to ensure that synchronisation is done correctly.</p>
",0
12256315,12256297,5,"<p>Yes, doing concurrent updates without proper synchronization may cause crashes, even if your threads access different keys: the <code>std::map</code> is based on trees, trees get rebalanced, so you can cause a write to a parent of a node with a seemingly unrelated key.</p>

<p>Moreover, it is not safe to perform read-only access concurrently with writing, or searching unlocked + locking on write: if you have threads that may update or delete nodes, you must lock out all readers before you write.</p>
",1
12256352,12256297,2,"<p>You <strong>will</strong> have concurrency problems if any of the threads inserts into the tree. STL <code>map</code> is implemented using a red-black tree (or at least that's what I'm familiar with &mdash; I don't know whether the Standard mandates red-black tree). Red-black trees may be rebalanced upon insert, which would lead to all sorts of races between threads.</p>

<p>Read-only access (absolutely <strong>no</strong> writers) would be fine, but keep in mind <code>operator[]</code> is <strong>not</strong> read-only; it potentially adds a new element. You'd need to use the <code>find()</code> method, get the iterator, and derefence it yourself.</p>
",2
12291876,12291742,5,"<p>You have two options:
The first and unsafe option is to have </p>

<pre><code>private:     
    int* tellers;
</code></pre>

<p>and in your constructor: </p>

<pre><code>tellers = new int[yourParamGoesHere];
</code></pre>

<p>the second and safer option is to use a vector, you would then have</p>

<pre><code>private:
    std::vector&lt;int&gt; tellers;
</code></pre>

<p>and in your contructor you would do:</p>

<pre><code>Office(int numberOfTellers):
    tellers(std::vector&lt;int&gt;(numberOfTellers))
</code></pre>

<p>And then whenever you want to read or write any of the integers you index the vector like you would an array like so:</p>

<pre><code>tellers[0] = 42;
</code></pre>
",1
17804313,17803887,0,"<p>There are many ways to display 314:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
  const double PI = 3.1415926;
  cout.precision(3);
  cout&lt;&lt;PI * 100&lt;&lt;endl;
}

#include &lt;iostream&gt;
using namespace std;
int main() {
  const double PI = 3.1415926;
  cout&lt;&lt;(int)(PI * 100)&lt;&lt;endl;
}
</code></pre>
",0
17804326,17803887,1,"<p>There's actually a ""proper"" way to do this, without having to alter the value at all.  You can prepare an <code>std::ostringstream</code> that will do this for you by using your own <code>std::numpunct</code> subclass:</p>

<pre><code>#include &lt;locale&gt;

class no_decimal_punct: public std::numpunct&lt;char&gt; {
protected:
    virtual char do_decimal_point() const
    { return '\0'; }
};
</code></pre>

<p>You can now prepare an <code>std::ostringstream</code> that will use the above <code>no_decimal_punct</code> class:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;iostream&gt;

std::ostringstream strm;
strm.imbue(std::locale(strm.getloc(), new no_decimal_punct));
strm.precision(2);
std::fixed(strm);

double f = 3.14159;
strm &lt;&lt; f;
std::cout &lt;&lt; strm.str() &lt;&lt; '\n';
</code></pre>

<p>The advantage here is that you're not changing the value of <code>f</code>, which could potentially print something else than intended due to FP errors.</p>
",0
17803951,17803887,5,"<p>Multiply by a 100 and print with precision 0.</p>

<pre><code>int main () {
  double f =3.14159;
  std::cout.precision(0);

  std::cout &lt;&lt; std::fixed &lt;&lt; f*100 &lt;&lt; '\n';
  return 0;
}
</code></pre>
",2
12788481,12788407,4,"<p>You never reset <code>count</code> to zero, so your <code>table[i][j]=array1[count];</code> is running way past the end of <code>array1</code>.</p>
",1
17091859,17091517,1,"<p>You compute (a + b + c) / 3 and then you store it in avgResult.
avgResult is a double, but a + b + c is int, 3 is int, so the result of division is int. So you finally store an int in your double variable. </p>

<p>Another way to get a double result, besides the already mentioned one:</p>

<pre><code>avgResult = a + b + c;
avgResult /= 3;
</code></pre>
",0
17091538,17091517,12,"<p><code>((a + b + c) / 3)</code> - that has an <code>int</code> type. Change it to <code>((a + b + c) / 3.0)</code> to get <code>double</code></p>
",0
14198682,14198526,0,"<p>In general, modifying the container that's being iterated over is a bad idea. Also note that if <code>Chosen</code> is not sorted, it will work in <code>O(Points.size() * Chosen.size())</code> (+ reallocations); there's just no way other than comparing every element in Points to every element (until found or end) in Chosen. Thus, it would be a better idea to use <code>set</code> (or, even better, <code>unordered_set</code>) as a container for Chosen. Please also note that if you want to remove elements from the middle of the <code>Points</code>, it will have to do <em>a lot</em> of reallocations, and again, <code>set</code> or <code>list</code> would be a better idea.</p>

<p>You can pass additional predicate to <code>std::sort</code> to sort by a specific field of an object - you don't have to reimplement sort algorithm by yourself.</p>

<p>To check if the vector is sorted, you can use <code>is_sorted</code> method (or, if you are using old compiler, <code>adjacent_find</code>, as in <a href=""https://stackoverflow.com/a/2955163/752976"">here</a>).</p>
",7
14199472,14198526,0,"<p>I am going to advise a drasic change: Don't use <code>std::vector</code> here, but use <code>std::map</code> instead, using the point's <code>id</code> as a key and the <code>X</code>/<code>Y</code> coordinates as value:</p>

<pre><code>using namespace std;
struct SPoint
{
    int X;
    int Y;
};

map&lt;int, SPoint&gt; points;
vector&lt;int&gt; chosen; // only keeps chosen id's, not complete points

void print_points(const map&lt;int, SPoint&gt; &amp; points)
{
    for (map&lt;int, SPoint&gt;::const_iterator i = points.begin(); i != points.end(); ++i)
    {
        cout &lt;&lt; i-&gt;first &lt;&lt; "" ("" &lt;&lt; i-&gt;second.X &lt;&lt; "","" &lt;&lt; i-&gt;second.Y &lt;&lt; "")""&lt;&lt;endl;               
    }           

    cout &lt;&lt; endl;   
}

int tmain(int argc, char* argv[])
{
    SPoint temp;
    for (int i = 0; i &lt; 10; i++)
    {
        temp.X = i;
        temp.Y = i;
        points[i] = temp;
    }

    for (int i = 5; i &lt; 10; i++)
    {
        chosen.push_back(i);
    }

    cout &lt;&lt; ""Points:"" &lt;&lt; endl;
    print_points(points);
    cout &lt;&lt; endl &lt;&lt; endl;

    system(""pause"");

    for (vector&lt;int&gt;::iterator it = chosen.begin(); it != chosen.end(); it++)
    {       
        points.erase(*it); // erase all points with id corresponding to the current value of chosen
    }   

    print_points(points);
    system(""pause"");
    return 0;
}
</code></pre>
",0
12865974,12865949,1,"<p><code>int</code> is not a class, its a native type.</p>

<p>When you declare an int:</p>

<pre><code>int x;
</code></pre>

<p>You do create an instance of <code>int</code>.</p>

<p>C++ is different than many other languages in this respect where, like in Java or Ruby for instance, ""everything is an object.""  This generally means that everything is derived from one root class, or at least appears to be.</p>

<p>Consider for example Ruby, where everything is ultimately derived from <code>Object</code>.  <code>Object</code>, in turn, is implemented as a fully-fledged class.  It has methods on it like <code>to_s</code> and code that implements those methods.</p>

<p>C++ isn't like that.  C++ has very basic types, like <code>int</code>, that aren't derived from anything.  There's no code behind these types, and they have no methods on them.  You can't do something like this:</p>

<pre><code>int x = 42;
string s = x.to_s();
</code></pre>

<p>because there's no <code>to_s()</code> method on an <code>int</code>, or any methods.</p>

<p>You also asked,</p>

<blockquote>
  <p>If 'int' is a class , in which file it is stored??</p>
</blockquote>

<p><code>int</code> isn't ""stored"" in any file.  The meaning and definition of an <code>int</code> is built in to the compiler itself.  There's no file that you can open on your machine to see how an <code>int</code> is defined.  When you do something like:</p>

<pre><code>int x = 42;
x += 77;
</code></pre>

<p>...the compiler doesn't have to look in any header file to know how to add 77 to 42.  It already knows, because and <code>int</code> is something that the compiler already knows about.  Almost like a-priori knowledge, it's ""just there"".</p>

<p>How does the compiler already know?  Because the people who wrote the compiler (probably using C or C++, by the way) coded that knowledge in.  How did the compiler writes know what to write?  They followed a document, called the C++ Standard, which explains exactly how a conformant compiler should behave.</p>
",3
12865977,12865949,0,"<p>No, <code>int</code> is a built-in type. It is not a class. The compiler has built-in knowledge of how to deal with <code>int</code>.</p>
",0
12866014,12865949,4,"<p>No; <code>int</code> is <em>not</em> a type of ""class-type"". It is a so-called ""scalar"" type.</p>

<p>To determine more generally whether a given object type <code>T</code> is of scalar, array, union or class type, you can <code>#include &lt;type_traits&gt;</code> and use <code>std::is_scalar&lt;T&gt;::value</code>, and similarly for the traits <code>is_array</code>, <code>is_union</code> and <code>is_class</code>.</p>

<p>(Note further that not all types are object types; there are also reference types and function types. You can use <a href=""http://en.cppreference.com/w/cpp/types/is_object"" rel=""nofollow""><code>std::is_object</code></a> and <code>is_function</code> and <code>is_reference</code> to make that distincition first.)</p>
",0
12866041,12865949,0,"<p>No, <code>int</code> is a fundamental type, as defined in:</p>

<h3>3.9.1 Fundamental types [basic.fundamental]</h3>

<blockquote>
  <p>2) There are five signed integer types : ¡°<code>signed char</code>¡±, ¡°<code>short int</code>¡±, ¡°<code>int</code>¡±, ¡°<code>long int</code>¡±., and ¡°long long int¡±.
  In this list, each type provides at least as much storage as those preceding it in the list. Plain ints have the natural size
  suggested by the architecture of the execution environment); the other signed integer types are provided to meet special
  needs.</p>
</blockquote>
",0
12842419,12842273,5,"<p>This isn't allowed by 3.2/5 of the one definition rule section.</p>

<blockquote>
  <p>There can be more than one definition of a class type (clause 9),...[other types and conditions that don't matter]</p>
  
  <p>...and provided the definitions satisfy the following requirements.
  Given such an entity named D defined in more than one translation
  unit, then</p>
  
  <p>-- each definition of D shall consist of the same sequence of tokens;</p>
</blockquote>

<p>This clearly prohibits such a mechanism <em>if the header is included in any other linked translation unit</em>.</p>

<p>If you want to write C# just write it in C#. Your future maintainers will greatly appreciate it if you write idiomatic C++ instead of a dialect.</p>
",1
12842471,12842273,11,"<p>This falls into the realm of the One Definition Rule. In particular, a requirement that is put on multiple definitions across several TUs of a single program for the same class is:</p>

<blockquote>
  <p>[...] ¡ª each definition of D shall consist of the same sequence of tokens [...]</p>
</blockquote>

<p>(Paragraph 5 of 3.2 One definition rule [basic.def.odr])</p>

<p>So even if you 'fixed' the first version to declare the member functions <code>inline</code> to match the second version (where providing a definition of the members implicitly declares them <code>inline</code>) you would still run afoul of this rule: the function bodies are additional tokens that appear in the one but not in the other.</p>
",5
12842478,12842273,-1,"<p>A major issue will be circular references: if the code of class <code>A</code> contains an instance of class <code>B</code>, which itself uses class <code>A</code>, compilation will fail.</p>

<p>Separation of a class into its declaration (.h) and definition (.cpp) solves this issue. </p>

<p>But: if you still want to put the class definition in the header file, you can do so by making the class a template, effectively deferring type resolution. But this comes at the cost of an increase in compile time!</p>
",3
15892726,15892477,6,"<p>You have a lot of code in common between the <code>if</code> and the <code>else</code>.</p>

<pre><code>        if (first == NULL)
        {
            first-&gt;data = item;
            last-&gt;data = item;
            last-&gt;next = NULL;
            first-&gt;next = last;
            count = 1;
        }
        else
        {
            Node *newNode = new Node;
            newNode-&gt;data = last-&gt;data;
            newNode-&gt;next = last;
            last-&gt;data = item;
            last-&gt;next = NULL;
            count ++;
        }
</code></pre>

<p>In the <code>if</code>, you increment <code>count</code> from <code>0</code> to <code>1</code>.  In the <code>else</code>, you <em>also</em> increment it.</p>

<p><code>count</code> is <strong>always</strong> getting incremented.  So you don't need to type it twice.</p>

<pre><code>        if (first == NULL)
        {
            first-&gt;data = item;
            last-&gt;data = item;
            last-&gt;next = NULL;
            first-&gt;next = last;
        }
        else
        {
            Node *newNode = new Node;
            newNode-&gt;data = last-&gt;data;
            newNode-&gt;next = last;
            last-&gt;data = item;
            last-&gt;next = NULL;
        }
        count ++;
</code></pre>

<p>You're also setting <code>last-&gt;data</code> to <code>item</code> in both of them.</p>

<p>And you're setting <code>last-&gt;next</code> to <code>NULL</code> in both of them.</p>

<pre><code>        if (first == NULL)
        {
            first-&gt;data = item;
            first-&gt;next = last;
        }
        else
        {
            Node *newNode = new Node;
            newNode-&gt;data = last-&gt;data;
            newNode-&gt;next = last;
        }
        last-&gt;data = item;
        last-&gt;next = NULL;
        count ++;
</code></pre>

<p>You also forgot to create a <code>new Node</code> when it's the first new node.</p>

<pre><code>        if (first == NULL)
        {
            Node *newNode = new Node;   // Added
            first = newNode;            // Added
            last = newNode;             // Added
            first-&gt;data = item;
            first-&gt;next = last;
        }
        else
        {
            Node *newNode = new Node;
            newNode-&gt;data = last-&gt;data;
            newNode-&gt;next = last;
        }
        last-&gt;data = item;
        last-&gt;next = NULL;
        count ++;
</code></pre>

<p>The <code>first-&gt;data = item</code> in your <code>if</code> is redundant.  <code>first</code> is the same as <code>last</code> there, and <code>last-&gt;data = item</code> is already happening.</p>

<pre><code>        if (first == NULL)
        {
            Node *newNode = new Node;
            first = newNode; 
            last = newNode;
            // Removed
            first-&gt;next = last;
        }
        else
        {
            Node *newNode = new Node;
            newNode-&gt;data = last-&gt;data;
            newNode-&gt;next = last;
        }
        last-&gt;data = item;
        last-&gt;next = NULL;
        count ++;
</code></pre>

<p>And since <code>first</code> and <code>newNode</code> have <strong>the same value</strong> in that <code>if</code>, we can use the variable names interchangeably.</p>

<pre><code>        if (first == NULL)
        {
            Node *newNode = new Node; 
            first = newNode;            // These two pointers are equal!
            last = newNode;
            newNode-&gt;next = last;       // (same pointer)
        }
        else
        {
            Node *newNode = new Node;
            newNode-&gt;data = last-&gt;data;
            newNode-&gt;next = last;
        }
        last-&gt;data = item;
        last-&gt;next = NULL;
        count ++;
</code></pre>

<p>Now, <strong>almost everything</strong> in your <code>else</code> is also in your <code>if</code>.  It can <strong>all</strong> be moved out.</p>

<pre><code>        Node *newNode = new Node; 
        if (first == NULL)
        {
            first = newNode;
            last = newNode;
        }
        else
        {
            newNode-&gt;data = last-&gt;data;
        }
        newNode-&gt;next = last;
        last-&gt;data = item;
        last-&gt;next = NULL;
        count ++;
</code></pre>

<p>That code should be more understandable now, too.  The lesson: <a href=""http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"" rel=""nofollow"">Don't Repeat Yourself</a>.  :) </p>
",1
15892754,15892477,0,"<p>Have a look at <a href=""http://en.wikipedia.org/wiki/Linked_list"" rel=""nofollow"">linked list</a></p>

<p>There are few details, to start with when <code>first == NULL</code> you need to create first, insert it into linked list and hook it up, see linked article for some algorithms.</p>

<p>I would say the simplest is single linked list with a header node (instead of <code>first *</code>) which could point to itself, but there are many ways to implement linked list and it depends on what you choose how to hook up the elements.</p>

<p>It depends on what you are after but if you just need something working then you could pick up from <a href=""http://www.boost.org/doc/libs/1_53_0/doc/html/intrusive/node_algorithms.html"" rel=""nofollow"">boost intrusive circular slist algorithms</a> where you just define your own struct with data and next pointer, tell it how to access next and use provided algorithms to do all the work (link and unlink nodes).</p>
",0
15892509,15892477,3,"<pre><code>if (first == NULL)
{
    /* if first is NULL dereference it. Hooray! */
    first-&gt;data = item;
    ...
</code></pre>
",5
17769366,17769307,3,"<p>::helper has access to the private function and thus can address it, or in this case pass the address to another function.  Once it's referenced as a function pointer it can be passed around just as you could with a pointer to a class attribute.  It's dangerous in the wrong hands :).   </p>
",0
13736147,13736065,2,"<p>Use the <code>fixed</code> manipulator</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {
    cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; (double)8 &lt;&lt; ""\n"";
    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/ShcNIc"" rel=""nofollow"">http://ideone.com/ShcNIc</a></p>
",2
13736177,13736065,0,"<p>See <a href=""https://stackoverflow.com/questions/554063/how-do-i-print-a-double-value-with-full-precision-using-cout"">How do I print a double value with full precision using cout?</a></p>

<pre><code>cout.precision(15);
cout &lt;&lt; fixed &lt;&lt; 8.0;
</code></pre>
",0
12794466,12794448,6,"<p>A stand-alone function is just a normal function that is not a member of any class and is in a global namespace. For example, this is a member function:</p>

<pre><code>class SomeClass
{
public:
    SomeClass add( SomeClass other );
};
SomeClass::add( SomeClass other )
{
    &lt;...&gt;
}
</code></pre>

<p>And this is a stand-alone one:</p>

<pre><code>SomeClass add( SomeClass one, SomeClass two );
</code></pre>
",2
12794475,12794448,3,"<p>A stand-alone function is typically</p>

<ul>
<li>A global function which doesn't belong to any <code>class</code> or <code>namespace</code>.</li>
<li>Serves a single purpose of doing something (like a utility, say <code>strcpy()</code>)</li>
</ul>

<p>They should be used judiciously as too much of those will clutter the code.</p>
",0
12794482,12794448,3,"<p>A standalone function is one which doesn't depend on any <em>visible</em> state:</p>

<pre><code>int max(int a, int b) { return a &gt; b ? a : b; }
</code></pre>

<p>Here <code>max</code> is a standalone function. </p>

<p>Standalone functions are stateless. In C++, they're referred to as <em>free</em> functions.</p>
",0
12794146,12793368,1,"<p>I kept it as original as I could to what you had posted, so that you could follow it. Modify it to do as you need it to do, I didn't optimize, I did not use STL (since I assume this is homework since you're not using STL), and I wrote it to get it functional vs proper. As I said, you'll have to play with it to get the precedence that you wish, but it's functional as I said. Also on my assumption that it's homework: I didn't complete it either, just putting you in the right direction hopefully.</p>

<pre><code>#include &lt;iostream&gt;
#include&lt;conio.h&gt;
using namespace std;



int precedence(char s)
{
    int rVal = -1; //Let's assume we didn't succeed
    switch(s)
    {
    case '+':
            rVal = 7;
            break;
    case '-':
            rVal = 6;
            break;
    case '*':
            rVal = 5;
            break;
    case '/':
            rVal = 4;
            break;
    case '^':
            rVal = 3;
            break;
    case '(':
            rVal = 2;
            break;
    case ')':
            rVal = 1;
            break;
    default:
            break;
    }
    return rVal; //This satisfies the warning
}

char getpres(int num)
{
    char rVal = 0;
    switch(num)
    {
    case 7:
            rVal = '+';
            break;
    case 6:
            rVal = '-';
            break;
    case 5:
            rVal = '*';
            break;
    case 4:
            rVal = '/';
            break;
    case 3:
            rVal = '^';
            break;
    case 2:
            rVal = '(';
            break;
    case 1:
            rVal = ')';
            break;
    default:
            break;
    }
    return rVal; //This satisfies the warning
}

string reorder(string temp)
{

    string rVal = ""\0"";
    int *array = new int[temp.length()];
    unsigned int d = 0;
    for(unsigned int x = 0; x &lt;= temp.length(); ++x )
    {
        array[x] = precedence(temp[x]);
    }

    for(unsigned int i = 0;i&lt; temp.length() +1;i++)
        {
            for(unsigned int j = 1;j&lt;i;j++)
            {
                if(array[i] &gt; array[j])
                {
                    d = array[i]; //swap

                    array[i]=array[j];
                    array[j]=d;
                }

            }

        }
        d = 0;
        for(; d &lt; temp.length(); ++d)
        {
            rVal += getpres(array[d]);
        }
        return rVal;
}

int main()
{

    int itr=0;
    string infi = """" ,postfi = """" ,operato = """";
    std::cin&gt;&gt;infi;

    while(itr &lt;= infi.length())
    {
        if(precedence(infi[itr]) &gt; -1)
        {
            operato += infi[itr];
        }
        else
        {
            postfi += infi[itr];
        }
        ++itr;
    }


    postfi += reorder(operato);
    std::cout&lt;&lt;postfi&lt;&lt;std::endl;
    return 0;
}
</code></pre>
",2
14175869,14175858,24,"<p>You should use <code>std::set_difference</code>: <a href=""http://en.cppreference.com/w/cpp/algorithm/set_difference"">http://en.cppreference.com/w/cpp/algorithm/set_difference</a></p>

<p>First you will need to <code>sort</code> your <code>vectors</code>, since <code>set_difference</code> operates on <em>sorted</em> ranges. That is, unless they are <em>sorted</em> already (like in your use case).</p>

<pre><code>std::sort(vector1.begin(), vector1.end());
std::sort(vector2.begin(), vector2.end());
</code></pre>

<p>Then you call it like this:</p>

<pre><code>std::vector&lt;int&gt; difference;
std::set_difference(
    vector1.begin(), vector1.end(),
    vector2.begin(), vector2.end(),
    std::back_inserter( difference )
);
</code></pre>

<p>This will append to <code>difference</code> those elements found in <code>vector1</code> that are not found in <code>vector2</code>.</p>
",0
14176111,14175858,2,"<p>If you don't want to use <code>std::set_difference</code>, you can do this:</p>

<pre><code>// substracts b&lt;T&gt; to a&lt;T&gt;
template &lt;typename T&gt;                                                                                            
void
substract_vector(std::vector&lt;T&gt;&amp; a, const std::vector&lt;T&gt;&amp; b)                                                     
{
    typename std::vector&lt;T&gt;::iterator       it = a.begin();
    typename std::vector&lt;T&gt;::const_iterator it2 = b.begin();

    while (it != a.end())
    {
        while (it2 != b.end() &amp;&amp; it != a.end())
        {
            if (*it == *it2)
            {
                it = a.erase(it);
                it2 = b.begin();
            }

            else
                ++it2;
        }
        if (it != a.end())
            ++it;

        it2 = b.begin();
    }
}
</code></pre>

<p>This will erase from <code>a</code> all values that are in <code>b</code>.</p>

<p>Good luck</p>
",1
14181172,14181008,1,"<p>In your code, <code>set_difference</code> calls <code>operator&lt;</code> to compare elements in points/chosen:</p>

<pre><code>set_difference(points.begin(), points.end(),
    chosen.begin(), chosen.end(), back_inserter(cleared));
</code></pre>

<p>To make your code compile, you need to overload <code>operator&lt;</code> for SPoint type, for example:</p>

<pre><code>bool operator&lt;(const SPoint&amp; lhs, const SPoint&amp; rhs)
{
  return lhs.id &lt; rhs.id;
}
</code></pre>
",3
14773235,14773121,0,"<pre><code>ListItem(T theVal)
{
    this-&gt;value = theVal;
    this-&gt;next = NULL;
    this-&gt;prev = NULL;
}
</code></pre>

<p>This is a constructor for this struct, with <code>this-&gt;value = theVal;</code> the value that is passed in as an argument is assigned to the struct's member <code>value</code>.</p>

<p>If you don't know about constructors yet it would be wise to read up on them.</p>
",0
14773249,14773121,1,"<pre><code>ListItem(T theVal)
{
  this-&gt;value = theVal;
  this-&gt;next = NULL;
  this-&gt;prev = NULL;
}
</code></pre>

<p>is an inline constructor definition. It specifies how instances of your <code>ListItem</code> class template are initialized. the <code>value</code> data member is set to <code>theVal</code> and the list's <code>next</code> and <code>prev</code> pointers are set to <code>NULL</code>. You would call such a constructor as</p>

<pre><code>ListItem&lt;int&gt; li(42);
</code></pre>
",3
14857418,14857380,2,"<p>You need to move the definition to one and only one source file.</p>

<pre><code>int k = 10;
</code></pre>

<p>By defining the variable in header file you violate the one definition rule because a copy of the variable gets defined in each translation unit where you include the header.</p>
",7
14857585,14857380,0,"<p>I built this code exactly as you have it without any errors...is there more there?</p>

<p>Potentially, if you have another source file that includes ""Source1.h"", you would have a problem with this line:</p>

<p><code>int k = 10;</code> in the Source1.h</p>

<p>because then k would be multiply defined. I would move the <code>int k=10</code> to Source.cpp</p>
",11
9819025,9818875,4,"<p>There's no way for the code to know, from what you have there, that <code>ipSrc</code> should be treated specially, it's just going to pass it through as-is.</p>

<p>You can probably try to construct the query string dynamically as a C++ string, and then use that to populate the query. Something like:</p>

<pre><code>std::string strqry =
      ""SELECT  tblIP.[IPAddress], ""
    + ""        tblIP.[IPType], ""
    + ""        tblIP.[IPStatus], ""
    + ""        tblIP.[IPMax] ""
    + ""FROM    tblIP ""
    + ""WHERE   tblIP.[IPAddress] = '"" + ipSrc + ""' ""
    + ""AND     tblIP.[IPType] = 3 ""
    + ""AND     tblIP.[IPStatus] = 1 ""
    + ""AND     tblIP.[IPMax] = 0""
    + "";""; 

SQLCHAR *query = (SQLCHAR *)(strqry.c_str());

// Now use query
</code></pre>

<p>And make sure you have control over the <code>ipSrc</code> value. Otherwise, you're subject to SQL injection attacks (in which case you'll want to use prepared/parameterised statements).</p>
",0
12869208,12869191,1,"<p>Try changing</p>

<pre><code>Player player;
return player.potions;
</code></pre>

<p>to simply</p>

<pre><code>return potions;
</code></pre>

<p>You're creating a new player and returning <em>that</em> object's potions, not the potions of the ""this"" object.</p>
",2
12869218,12869191,7,"<p>First off, you are trying to return a <code>static</code> member of a class as if it were instantiated member of the object. Static members are referred to by <code>Class::member</code>, not <code>object.member</code>.</p>

<p>Second, I don't think you want <code>potions</code> to be static. Static members are shared between all objects of the class. So if player A has 100 health potions, then player B would have the same 100 health potions.</p>

<p>Third, you declare <code>Player::potions</code> at the top of your <code>.cpp</code> file. I don't think that's what you want. The <code>potions</code> member was already declared in your <code>.h</code> file.</p>

<p>player.h:</p>

<pre><code>class Player
{
    private:
        int potions;

    public:
        int getPotions();
};
</code></pre>

<p>player.cpp:</p>

<pre><code>int Player::getPotions()
{
    return potions;
}
</code></pre>

<p>If you DID want <code>potions</code> to be static, then change it to:</p>

<pre><code>return Player::potions;
</code></pre>
",0
12850858,12850833,3,"<p>For anyone interested, the question changed, so my old answer is lost to the edits.</p>

<p>If your <code>display</code> function is required to have a specific signature (<code>void()</code>), you can use <code>std::bind</code>, presuming you have access to C++11:</p>

<pre><code>void display(Robot &amp;robot){...}

//in main
Robot robot;
glutDisplayFunc(std::bind(std::ref(display), robot));
</code></pre>

<p>If you don't have C++11, <code>boost::bind</code> works just as well:</p>

<pre><code>glutDisplayFunc(boost::bind(boost::ref(display), robot));
</code></pre>

<p>If you have neither, you'll have to store <code>robot</code> more globally.</p>
",6
12850952,12850833,1,"<p>Since the glut display callback doesn't take parameters, you will have to use a global variable (Robot * gRobot; ) or a singleton pattern.</p>
",0
13783959,13783949,2,"<p>The pointer returned by <code>strtok</code> is not going to point to valid memory forever since the buffer that you're tokenizing is declared on the stack.  You'll need to actually copy the string being pointed to by the return pointer of <code>strtok</code>, not the pointer itself if you want to use the string outside the function body.</p>

<p>So basically modify your code to the following:</p>

<pre><code>levels[0] = new char[64];
char* temp = strtok(buf, "" "");

//check for NULL pointer return from strtok()
if (temp) 
{
    //if the pointer is not NULL, copy the contents of the temporary string
    //returned by strtok into more permanent memory allocated on the heap
    //and being pointed to by levels[0]

    //Use strncpy() to prevent the risk of a buffer overflow
    strncpy(levels[0], temp, 64);
}
</code></pre>

<p>Then in the destructor for your <code>Environment</code> object, make sure to have some loop to free the memory being pointed to by each of the members of the <code>levels</code> array that are pointing to memory allocated via <code>new []</code>.  You do this by calling <code>delete []</code></p>
",2
13784331,13783949,1,"<p>Here's your function:</p>

<pre><code>// Parse the level list file
int Environment::parseLevels() {
    ifstream data;
    data.open(""levels.txt"");

    char buf[64];

    for (int i=0; i&lt;sizeof(levels); i++) {
        data.getline(buf, 64);
        levels[0] = strtok(buf, "" "");
    }
}
</code></pre>

<p>You are assigning <code>levels[0] = strtok(buf,"" "");</code></p>

<p>This is creating an object in stack memory (no new operator being used) and returning a pointer to that memory, a pointer you are assigning to levels[0].</p>

<p>After you leave this function, the memory used by it is taken off the stack, destroying any memory it created, this would be the memory that the pointer returned from strtok pointed to.</p>

<p>This is why the pointer is no longer valid.</p>

<p>Somebody else got the proper way to copy the data though, strcopy().</p>

<p>// For every string allocate its length as a char buffer on the heap
levels[0] = new char[64];
// Get a pointer to the data
char* temp = strtok(buf, "" "");</p>

<p>//check for NULL pointer return from strtok()
if (temp) tstrncpy(levels[0], temp, 64); // Copy the data from temp, to heap</p>
",3
13784536,13783949,0,"<p>Here is what I ended up doing:</p>

<pre><code>int Environment::parseLevels(char* filename) {
    ifstream myfile(""levels.txt"", ifstream::in);
    int i = 0;
    while(myfile &gt;&gt; levels[i]) {
        i++;
    }
    return 0;
}
</code></pre>
",2
13458532,13458146,0,"<p>If you want the size of the array to be determined by the number of initializers you can do this:</p>

<pre><code>string names[] = {""John"",""Smith"",""Noob""};
</code></pre>

<p><code>string name[]</code> is an incomplete array type, and the language figures out the correct size necessary to complete it from the initializer. The size of the array will be 3 in this case.</p>

<p>Raw arrays aren't very friendly though, and so if possible you might want to avoid them and, in this case, use a vector:</p>

<pre><code>std::vector&lt;std::string&gt; names {""John"",""Smith"",""Noob""};
</code></pre>

<p>Although your compiler will need to support C++11 to use this method of initializing vectors.</p>

<hr>

<blockquote>
  <p>I need to get the number of elements initialized from the string array then loop through all elemements and convert them intro char array</p>
</blockquote>

<p>Why not just start with char* in the first place then?</p>

<pre><code>char const *names[] = {""John"",""Smith"",""Noob""};
</code></pre>
",0
13458182,13458146,4,"<p>The array size is still five.</p>

<p>The elements that you didn't provide values for are default-initialised, i.e. <code>""""</code>. But they're still <em>there</em> and everything.</p>
",14
13458217,13458146,0,"<p>Well, to answer the question, getting the size of array is as follows:</p>

<pre><code>int arr[17];
int arrSize = sizeof(arr) / sizeof(int);
</code></pre>

<p>But yes, in your case, it's init'd as 5, so it's 5.</p>
",6
12825696,12825453,0,"<p>Use <code>std::sort</code> in conjunction with something that compares two <code>Record</code>s.  There are at least 3 ways to provide this compoarison.</p>

<p>1: Implement an <code>operator&lt;</code> on <code>Record</code>:</p>

<pre><code>class Record
{
public:
  bool operator&lt;(const Record&amp; rhs) const
  {
    return valueData &lt; rhs.valurData;
  }
};
</code></pre>

<p>...then:</p>

<pre><code>sort(&amp;rec[0], &amp;rec[10]);
</code></pre>

<p>2: Provide a <a href=""http://en.wikipedia.org/wiki/Function_object"" rel=""nofollow"">functor</a>:</p>

<pre><code>struct compare_records : public std::binary_function&lt;bool, Record, Record&gt;
{
  bool operator()(const Record&amp; lhs, const Record&amp; rhs) const
  { 
    return lhs.valueData &lt; rhs.valueData;
  }
};
</code></pre>

<p>...then:</p>

<pre><code>sort_if(&amp;rec[0], &amp;rec[10], compare_records());
</code></pre>

<p>3: (If you have a C++11 compiler) Use a lambda:</p>

<pre><code>sort_if(&amp;rec[0], &amp;rec[10], [](const Record&amp; lhs, const Record&amp; rhs) -&gt; bool
{
  return lhs.vaklueData &lt; rhs.valueData;
});
</code></pre>

<p>EDIT:</p>

<p>Here is a complete sample that shows how to use the first method:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
using namespace std;

class Record
{
public:
    string name;
    int data;
    float valueData;
public:
    bool operator&lt;(const Record&amp; rhs) const
    {
        return valueData &lt; rhs.valueData;
    }
};

int main()
{
    Record rec[10];
    rec[0].name = ""jack1"";
    rec[0].data = 1;
    rec[0].valueData = 20;

    rec[1].name = ""jack2"";
    rec[1].data = 2;
    rec[1].valueData = 15;

    rec[2].name = ""jack3"";
    rec[2].data = 3;
    rec[2].valueData = 25;

    sort(&amp;rec[0], &amp;rec[3]);

    bool bk = true;
}
</code></pre>
",4
12826170,12825453,2,"<p>Do this instead:</p>

<pre><code>sort(&amp;rec[0], &amp;rec[3]);
</code></pre>

<p>You were only sorting the 1st two elements, because the 2nd iterator in a range defined by an iterator pair by convention always points <em>one past</em> the end of the range you want to operate on.</p>
",0
13694773,13694755,5,"<p><code>strlen</code> applies to a <code>const char*</code>, not to a <code>string</code>. You can (and should) instead use <code>str.length()</code>.</p>
",0
13694785,13694755,0,"<p>the c string and c++ string lib's are very different from each other, and cannot be mixed. A fix to this would be to treat the string as a c string:</p>

<pre><code>strlen(str.c_str()); //convert string into char *
</code></pre>

<p>c++ string holds and internal c string for easy portability into c code and c methods.</p>

<p>It would also be good to note that <code>cstring</code> and <code>string.h</code> refer to the same file, c is the c++ method to organize c++ libs and c libs</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt; //could be stdlib.h, but used to show that this lib is a c lib
#include &lt;csting&gt;  //same as string.h
#include &lt;string&gt;  //c++ string lib
</code></pre>
",0
17776618,17768152,10,"<p>Your problem was deliciously underspecified. This always prompts me to supply an overblown example implementation using Boost Spirit.</p>

<p><strong>Note</strong>: just <em>don't</em> hand this in as your homework assignment, please.</p>

<p>See it <strong><a href=""http://coliru.stacked-crooked.com/view?id=c64e825675981f1787285a2c1893ab94-acc21326bddb78ffadef615690276e19"" rel=""noreferrer"">Live on Coliru</a></strong> with the following sample input:</p>

<pre><code>ADD_STUDENT ALEX 5.11 175
ADD_STUDENT PUFF 6 7
ADD_STUDENT MAGIC 7 8
ADD_STUDENT DRAGON 8 9
ADD_TEACHER MERY 5.4  120 70000
PRINT MERY 
ADD_TEACHER DUPLO 5.4  120 140000
PRINTALL  10
REMOVE ALEX
PRINT  TEACHER SALARY
PRINT  MERY PUFF MAGIC DRAGON
REMOVE MERY PUFF MAGIC DRAGON
PRINT  TEACHER SALARY
</code></pre>

<p>Full code:</p>

<hr>

<p><strong>Update</strong> When including <code>make_visitor.hpp</code> as shown <strong><a href=""http://ideone.com/fSobD8"" rel=""noreferrer"">here</a></strong> you can write the visitor code more elegantly:</p>

<pre><code>auto print_salary = [&amp;] () 
{ 
    for(auto&amp; p : names) 
        boost::apply_visitor(make_visitor(
                    [](Teacher const&amp; v) { std::cout &lt;&lt; ""Teacher salary: "" &lt;&lt; v.salary &lt;&lt; ""\n""; },
                    [](Student const&amp; v) {}), 
                p.second);
};
</code></pre>

<p>See adapted example <strong><a href=""http://coliru.stacked-crooked.com/view?id=aeca4ca881a3b82ae26ad12a6ee7e473-acc21326bddb78ffadef615690276e19"" rel=""noreferrer"">Live on Coliru</a></strong></p>

<hr>

<pre><code>#define BOOST_SPIRIT_USE_PHOENIX_V3
#include &lt;boost/spirit/include/qi.hpp&gt;
#include &lt;boost/spirit/include/phoenix.hpp&gt;

namespace qi = boost::spirit::qi;
namespace phx= boost::phoenix;

struct Person
{
    std::string name;
    double height, weight;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Person const&amp; s) {
        return os &lt;&lt; ""Person { name:"" &lt;&lt; s.name &lt;&lt; "", height:"" &lt;&lt; s.height &lt;&lt; "", weight:"" &lt;&lt; s.weight &lt;&lt; "" }"";
    }
};

struct Student : Person
{
    Student() = default;
    Student(std::string n, double h, double w) : Person {n,h,w} {}
};

struct Teacher : Person
{
    Teacher() = default;
    Teacher(std::string n, double h, double w, double s) : Person {n,h,w}, salary(s) {}
    double salary;
};

int main()
{
    std::stringstream ss;
    ss &lt;&lt; std::cin.rdbuf();

    std::map&lt;std::string, boost::variant&lt;Student, Teacher&gt; &gt; names;

    using namespace qi;
    auto add_student  = phx::ref(names)[_1] = phx::construct&lt;Student&gt;(_1, _2, _3);
    auto add_teacher  = phx::ref(names)[_1] = phx::construct&lt;Teacher&gt;(_1, _2, _3, _4);
    auto remove       = phx::erase(phx::ref(names), _1);
    auto print_all    = [&amp;] (int i) { for(auto&amp; p : names) { std::cout &lt;&lt; p.second &lt;&lt; ""\n""; if (--i==0) break; } };
    auto print_salary = [&amp;] () 
    { 
        struct _ : boost::static_visitor&lt;&gt; {
            void operator()(Teacher const&amp; v) const { std::cout &lt;&lt; ""Teacher salary: "" &lt;&lt; v.salary &lt;&lt; ""\n""; }
            void operator()(Student const&amp; v) const { }
        } v_;
        for(auto&amp; p : names) boost::apply_visitor(v_, p.second);
    };

    auto name_ = as_string[lexeme[+graph]];

    if (phrase_parse(begin(ss.str()), end(ss.str()), 
                (
                     (""ADD_STUDENT"" &gt;&gt; name_ &gt;&gt; double_ &gt;&gt; double_)            [ add_student ]
                   | (""ADD_TEACHER"" &gt;&gt; name_ &gt;&gt; double_ &gt;&gt; double_ &gt;&gt; double_) [ add_teacher ]
                   | (eps &gt;&gt; ""PRINT"" &gt;&gt; ""TEACHER"" &gt;&gt; ""SALARY"")                 [ print_salary ]
                   | (""PRINTALL"" &gt;&gt; int_)      [ phx::bind(print_all, _1) ]
                   | (""PRINT""  &gt;&gt; +name_       [ std::cout &lt;&lt; phx::ref(names)[_1] &lt;&lt; std::endl ])
                   | (""REMOVE"" &gt;&gt; +name_       [ remove ])
                ) % +eol,
                qi::blank))
    {
        std::cout &lt;&lt; ""Success"";
    }
    else
    {
        std::cout &lt;&lt; ""Parse failure"";
    }
}
</code></pre>

<p>Output:</p>

<pre><code>Person { name:MERY, height:5.4, weight:120 }
Person { name:ALEX, height:5.11, weight:175 }
Person { name:DRAGON, height:8, weight:9 }
Person { name:DUPLO, height:5.4, weight:120 }
Person { name:MAGIC, height:7, weight:8 }
Person { name:MERY, height:5.4, weight:120 }
Person { name:PUFF, height:6, weight:7 }
Teacher salary: 140000
Teacher salary: 70000
Person { name:MERY, height:5.4, weight:120 }
Person { name:PUFF, height:6, weight:7 }
Person { name:MAGIC, height:7, weight:8 }
Person { name:DRAGON, height:8, weight:9 }
Teacher salary: 140000
Success
</code></pre>
",1
15829691,15829592,2,"<p><code>p.x,...</code> might be faster, however there's not much difference one would notice.
When you use array, there is a time spent on multiplication the size of each double in the given index to get the desired memory address; but in the other method (<code>p.x,...</code>) the compiler knows what address we are accessing so that calculation is not required.
However, if the compiler is smart enough to figure out constant numbers, there would be no difference.</p>
",1
15588116,15588065,5,"<p>The member initialiser list in a constructor of class <code>C</code> can only initialise:</p>

<ul>
<li>direct base classes of <code>C</code></li>
<li>direct members of <code>C</code></li>
<li>virtual base classes of <code>C</code> <em>(doesn't come up too often)</em></li>
</ul>

<p>The only way to initalise a member of a base class is through a constructor of the base class. Or just forego initialisation and then do an assignment in the body of <code>C</code>'s constructor. The latter cannot be used for <code>const</code> members or references, though, and in general does not do the same thing as just initialisation.</p>
",4
15588118,15588065,1,"<p>You need to initialize the base class before you can access it. If you want to initialize member variable in the base class, you have to do it via call to base class constructor in which will initialize it's members.</p>
",0
15588129,15588065,2,"<p>You could either move it from the initializer list to the body (if it is not const):</p>

<pre><code>Bar() : Foo(10), _temp(""something"")
{
    _bar = ""something_else"";
}
</code></pre>

<p>or provide a second (maybe protected) contructor for <code>Foo</code>:</p>

<pre><code>class Foo
{
public:
    Foo(int x) : _foo(x)
    {

    }

protected:
    Foo(int x,std::string s) : _foo(x), _bar(s)
    {
    }

private:
    int _foo;

protected:
    std::string _bar;
};

class Bar : public Foo
{
public:
    Bar() : Foo(10,""something_else""), _temp(""something"")
    { 

    }

private:
    std::string _temp;
};
</code></pre>
",0
15588136,15588065,1,"<p>You may put <code>_bar</code> in <code>Foo</code>'s constructor's initialization list. If <code>_bar</code> does not always need be to assigned something, you can use default value.</p>

<pre><code>class Foo
{
public:
   Foo(int x):_foo(x)
   {
   }
protected:
   Foo(int x, string s) : _foo(x),_bar(s)
   {

   }

private:
   int _foo;

protected:
   std::string _bar;
};

class Bar : public Foo
{
public:
   Bar() : Foo(10,""something else""), _temp(""something"")
   { 

   }
private:
  std::string _temp;
};
</code></pre>
",2
18247274,18247180,4,"<p><code>std::map::insert()</code> is a no-op if the key already exists in the map.</p>

<p>If you try to insert a duplicate key, the first version of your code will leak the object it has allocated using <code>new</code>.</p>

<p>The second version does not have this problem since you don't call <code>new</code> unless you've established that the key doesn't exist in the map.</p>

<p>Two good ways to fix the leak are:</p>

<ul>
<li>store the objects by value;</li>
<li>store smart pointers to objects.</li>
</ul>
",0
18247365,18247180,0,"<p>In your first AddNew function:
when you are inserting a member whose key have existed in the map,
you will create a T object,but you do not release it:</p>

<p>you can do like this:</p>

<pre><code>A::Addnew(std::string name)
    {
       T *temp = new T;
       if(mymap.insert(std::pair&lt;std::string,T*&gt;(name, temp)).second)
           return true;
       else
        {
           delete temp;
           return false;
         }
    }
</code></pre>
",0
13732730,13732546,0,"<p>If you have a square matrix, you can do it this way:</p>

<pre><code>void printMatrix(int matrix[], int edge)
{
    int i,j;
    for (j=0; j&lt;edge; ++j) {
        for (i=0; i&lt;edge; ++i) {
            std:cout &lt;&lt; matrix[j*edge + i] &lt;&lt; "" "";
        }
        std::cout &lt;&lt; std::endl;
    }
}
</code></pre>

<p>Essentially, store rows (or columns, it's up to you) one after another in a 1D array.
Note that the <em>inner</em> loop iterates over <code>j</code> - this way the loop accesses consecutive cells in memory.</p>

<p>The rest of your code should then use the same convention.</p>

<p>This approach isn't the best if you're paid (or given points) for every class, template, design pattern etc. you add to your code, though.</p>
",0
13732787,13732546,2,"<p>When you pass a multi-dimensional array to a function, you must fill in all its dimensions, except the first one. That is <code>arr[][X], arr[][X][Y], ...</code>.</p>

<p>The compiler knows how to do the array locations math according to the dimensions. For example, <code>arr[][5]</code> means every row contains 5 elements, so <code>arr[2][0]</code> will take it 10 elements from the start. So the first dimension isn't necessary, but all the others - are.</p>
",0
13732570,13732546,1,"<p>You shouldn't use raw arrays at all. <code>std::array</code> is much better. If you want the size to not be part of the type, you should use <code>std::vector</code>. There are cases where you might need to use a raw array or raw pointer, but this isn't something you should be worrying about as a beginner.</p>

<p>Here's an example of how you might do things (assuming C++11 support). This uses const correctness and the new foreach feature as well. I don't remember the exact syntax but it should look something like this.</p>

<pre><code>void printMatrix(const std::vector&lt;std::vector&lt;int&gt;&gt; matrix)
{
    for(const auto&amp; row : matrix){
        for(int x : row){
            std::cout &lt;&lt; x &lt;&lt; "" "";
        }

        std::cout&lt;&lt;std::endl;
    }
}
</code></pre>
",6
13732663,13732546,0,"<p>C++ does not pass the size of an array or the number of dimensions, it only passes the address of the start of the array (i.e. a pointer). You can get around this by using a template function with a reference. This way the size of the matrix is known at compile time.</p>

<pre><code>template&lt;int X, int Y&gt;
void printMatrix(int (&amp;matrix)[X][Y], int edge)
{
    int i,j;
    for (i=0; i&lt;edge; ++i) {
        for (j=0; j&lt;edge; ++j) {
        std:cout&lt;&lt;matrix[i][j]&lt;&lt;"" "";
        }
        std::cout&lt;&lt;std::endl;
    }
}
</code></pre>
",4
13738954,13732546,2,"<p>using one dimentional array, as ls.
and caculate the dimention by yourself</p>
",0
15843717,15843671,3,"<p>Yes, <code>std::map&lt;int, std::list&lt;SomeType&gt;&gt;</code> is possible in C++.</p>

<p>Have a look at <a href=""http://www.ideone.com"" rel=""nofollow"">ideone</a>, which is useful for testing simple things such as this.</p>
",2
14843284,14843257,5,"<p>One option is to sort both vectors, and then use <a href=""http://en.cppreference.com/w/cpp/algorithm/set_intersection""><code>std::set_intersection</code></a>.</p>
",1
14843286,14843257,1,"<p>Well, your <code>inter</code> function has a few problems:</p>

<ul>
<li>The return type is a single element</li>
<li>Two unused local variables</li>
<li>Only tests each element against the one in the identical position in the other set</li>
</ul>
",0
14843343,14843257,0,"<p>For the inter function, first change the return type to a vector, then use the v3 vector you are currently not using for the below operations.</p>

<pre><code>vector&lt;t&gt; inter(const vector &lt;t&gt; &amp; v1, const vector &lt;t&gt; &amp; v2)
{
    vector&lt;t&gt; v3;

    for(int i=0; i&lt;v1.size(); i++)
    {
         for(int j=0; j&lt;v2.size(); j++)
         {  
              if(v1[i] == v2[j])
              {
                    v3.push_back(v1[i])
              }
         }
    }
    return v3;
}
</code></pre>

<p>To print out the contents you have to assign the returned vector to a variable and then loop through it as such...</p>

<pre><code>vector&lt;t&gt; vec3 = inter(vec1, vec2);
for(int i=0; i&lt;vec3.size(); i++)
{
    cout&lt;&lt;vec3.at(i)&lt;&lt;"" "";
}
</code></pre>

<p>That will return a vector containing all of the answers, make sure to make the changes to the loop as before your loop was only checking if they were in the same place, not if they were both in the vector</p>

<p>Be mindful that this will produce duplicate results in the case of {x, x, y} and {x, z , a}</p>
",4
14843396,14843257,2,"<p>Use <a href=""http://en.cppreference.com/w/cpp/algorithm/set_intersection"" rel=""nofollow"">std::set_intersection</a> algorithm is much easier, it requires two sorted vectors:</p>

<pre><code>template &lt;typename T&gt;
std::vector&lt;T&gt; inter(const std::vector&lt;T&gt; &amp; v1, const std::vector&lt;T&gt; &amp; v2)
{
    std::vector&lt;T&gt; v3;   
    std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(v3));
    return v3;
}

std::sort(vec1.begin(), vec1.end());   // sort vec1
std::sort(vec2.begin(), vec2.end());   // sort vec2
std::vector&lt;std::string&gt; v3 = inter(vec1, vec2);
</code></pre>

<p>See <a href=""http://ideone.com/0IxFPE"" rel=""nofollow"">sample</a> code</p>
",0
9791169,9790465,1,"<p>Use a proper C++ solution.</p>

<p><em>Inline reverse the message:</em></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    string message;
    getline(cin, message);

    //inline reverse the message
    reverse(message.begin(),message.end());

    //print the reversed message:
    cout &lt;&lt; message &lt;&lt; endl;
    return 0;
}
</code></pre>

<p><em>Reverse a copy of the message string:</em></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    string message, reversed_message;
    getline(cin, message);

    //reverse message
    reversed_message = message;
    reverse(reversed_message.begin(), reversed_message.end());

    //print the reversed message:
    cout &lt;&lt; reversed_message &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>If you really need to save the reversed string in a C string, you can do it:</p>

<pre><code>char *msg = (char *)message.c_str();
</code></pre>

<p>but, as a rule of thumb use C++ STL strings if you can.</p>
",0
9790562,9790465,4,"<p>The buffer <code>reverse</code> needs to be <code>message.length() + 1</code> in length so that it can store a null termination byte.  (And the null termination byte needs to be placed in the last position in that buffer.)</p>
",2
9790640,9790465,2,"<p>Since you can't declare an array with a length that is only known at runtime, you have to use a container instead.</p>

<pre><code>std::vector&lt;char&gt; reverse(message.length());
</code></pre>

<p>Or better, use <code>std::string</code>.  The STL also offers some nice functions to you, for example building the reversed string in the constructor call:</p>

<pre><code>std::string reverse(message.rbegin(), message.rend();
</code></pre>
",0
9790675,9790465,1,"<p>Instead of reversing into a character buffer, you should build a new string. It's easier and less prone to bugs.</p>

<pre><code> string reverse;
 for(howlong; howLong &gt;= 0; howLong--)
 {
   reverse.push_back(message.at(howLong));
 }
</code></pre>
",0
9810811,9810709,4,"<p>I didn't look in enough detail to be <em>certain</em>, but I didn't see any code there to flush the data to the disk and/or ensure your reads actually came from the disk. That being the case, it appears that what you're measuring is primarily the performance of the operating system's disk caching. While the disk might contribute a little to the performance you're measuring, it's probably only a small contributor, with other factors dominating.</p>

<p>Since the code is apparently written for Windows, you might consider (for one example) opening the file with CreateFile, and passing the FILE_FLAG_NO_BUFFERING flag when you do so. This will (at least mostly) remove the operating system cache from the equation, and force each read or write to deal directly with the disk itself.</p>
",0
13781522,13781283,0,"<p>For class you may write your own constructor, which shows, how to construct inner objects, i.e</p>

<pre><code>class A{
    string s;
    int x;
    A(string t):s(t), x(17){} // x is always 17 after construction
}
</code></pre>

<p>But if inner object is default-constructable, you may leave it's construction and it will be costruct by default.</p>

<pre><code>A(int l):x(l){}
</code></pre>

<p>is equivalent to</p>

<pre><code>A(int l):x(l), s(){}
</code></pre>

<p>(except for primitive types), that may contain trash by default</p>

<p>If you use default constructor of <code>A</code>, all inner objects will construct by default.</p>
",0
13781587,13781283,0,"<p>If by <code>collection</code> you mean standard library classes, you would need copy ctor and assignment operator= overloaded.</p>

<p>std::map and std::set would reqire an additional comparison operator&lt; overloaded.
std::unorderd_map and std::unordered_set would need a std::hash specialized for your type.</p>
",0
13781750,13781283,0,"<p>Often you don't have to define a default constructor. The compiler will declare a default constructor implicitly if one is needed and no constructors are defined. Often it will be useful to define additional constructors (like the one you mention) in addition to the default one. In that case you need to define both:</p>

<pre><code>class A
{
public:

    string s;
    int x;

    // default constructor, no arguments
    A(): x(), s() {}

    // constructor
    A(int i, string t): x(i), s(t) {}
}

int main()
{
    A a1;
    A a2(5, ""text"");
    vector&lt;A&gt; ls;
    return 0;
}
</code></pre>

<p>As pwned mentions, in order to use your class A in an STL container, e.g. vector, it is required that A has a default constructor as in the example (either user-defined or implicit).</p>
",0
13781309,13781283,0,"<p>You mean enough to handle memory correctly? Depends on the type <code>X</code>. For example, if you have a <code>vector&lt;string&gt;</code> data member, you don't have to do any manual memory management in your class.</p>
",0
13781312,13781283,1,"<p>If by ""collection of 'x' objects"" you mean ""a standard container of 'x' objects"", and by ""enough"" you mean ""enough not to worry about resource management"" then yes. Same goes for any well-written container made by you or a third-party.</p>

<p>This is also assuming your X objects are handling <em>their</em> resources correctly. And that they have semantics that are compatible with the container you're putting them in.</p>

<p>Edit</p>

<p>You don't need a constructor like that if you are OK having an object filled with default values for everything. I.e. empty containers, zeroed members (or was it uninitialized? -_-), etc.</p>

<p>You only really need a custom constructor if your object will be in an invalid state without one or if you want some sort of custom logic to run.</p>
",0
9789102,9789052,2,"<p>You cannot safely access a local variable allocated in a different thread in most cases. By the time Thread1 starts up, the structure has likely already gone out of scope in the main thread. You should find another way, such as allocating the parameters with <code>new</code> in the main thread and deleting them when you're done with them in Thread1.</p>
",0
9789133,9789052,3,"<pre><code>ThreadParams threadparams;
</code></pre>

<p>Note that if it is a local variable, and the function which declares it returns after creating the thread, then the thread refers to an object which doesn't exist anymore, as the local variable gets destroyed when the function returns. If that is the case, then create a new instance using <code>new</code> instead as:</p>

<pre><code>ThreadParams * pthreadparams = new ThreadParams();
</code></pre>

<p>and pass it to the thread, so that it will exist even if the function which creates the thread returns. Of course, when you're done with it, you've to delete it manually.</p>
",0
15562018,15561992,6,"<p>You want a template.  You'll have to read up on them somewhere.  <a href=""http://www.cplusplus.com/doc/tutorial/templates/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/templates/</a></p>

<p>You can implement a max like</p>

<pre><code>template &lt;class T&gt;
T max(T one, T two)
{
   return one &gt; two ? one : two;
}
</code></pre>

<p>This will work on any object where you can compare the classes.  Ints, floats, and even use defined classes.</p>
",0
13405767,13405748,5,"<p>Why can't you just do this?</p>

<pre><code>for (i = n; i &gt; 0; i -= 2) 
{
}
</code></pre>
",4
13405869,13405748,0,"<p>here in this <code>for</code> loop</p>

<pre><code>for( int i = n; i&gt;0; i--){
// i = i-1;
}
</code></pre>

<p>so if you use <code>i= i-2</code> or <code>i-=2</code> it will decrement <code>i's</code> value by 2</p>

<pre><code>for(int i = n; i&gt;0; i-=2){
// i = i - 2;
}
</code></pre>
",0
12852981,12852679,0,"<p>Your code have nothing to show us detail of your situation but from your comments I have some points about it:</p>

<p>In line that you say <code>// after this while loop is terminating</code>, is your production code same as here or you really terminate your block after it?? Remember when you call <code>p.parseRequest(info)</code> you are doing the action in calling thread, so after the line you parsing is done but if you use a thread, after the line (<code>pthread_create(...)</code>) the specified thread is possibly not event started, thread scheduled by OS to run in a later time and you should not think parsing is done after it.</p>

<p>In line <code>// this is not reachable</code> do you think that the line should not executed? or this is behavior of code in runtime? in any case <code>pthread_create</code> return immediately and run job later in a different thread of execution, so in your code you almost immediately call <code>sleep(0)</code> and then reach specified line for sure!!</p>

<p>What is the reason of <code>sleep(0)</code> is it intended to let thread start or complete?? in any case OS schedule threads based upon internal algorithms so after <code>sleep(0)</code>, thread execution may still pending!! If you want to ensure that your thread is started/stopped you must use a synchronization mechanism (for example mutexes) between your thread an main thread</p>
",6
12854098,12852679,1,"<p>Look at your code:</p>

<pre><code>static void * Parse::parseRequest_helper(void *c)    
{
     cout&lt;&lt;""Inside Helper""; // Not coming here
     return ((Parse *)c)-&gt;parseRequest(c);
}
</code></pre>

<p>This only makes sense if the <code>void *</code> parameter passed to this function is a pointer to a <code>Parse</code>.</p>

<pre><code>void * Parse::parseRequest(void *info)
{

    cout&lt;&lt;""Inside Parse Request"";     //Not coming here
    clientInfo *cInfo = (struct clientInfo *)info;
        cout&lt;&lt;cInfo-&gt;ip;
}
</code></pre>

<p>This only makes sense if the <code>info</code> parameter passed to this function is a pointer to a <code>clientInfo</code>.</p>

<p>Since it's the same parameter, this code makes no sense. It can either be a pointer to a <code>Parse</code> or a pointer to a <code>clientInfo</code>, but it can't be both.</p>

<pre><code>     cout&lt;&lt;""Inside Helper""; // Not coming here
</code></pre>

<p>Your conclusion that you aren't getting to that line of code is incorrect. You are. You just can't tell because there's no <code>endl</code> so the buffer doesn't get flushed.</p>
",3
12867557,12867482,3,"<p>Use == for comparisons, not = (which performs assignment).</p>
",0
12867610,12867482,0,"<p>Is it possible that this is your actual code? You simply forget that in C++ <code>=</code> set the value and <code>==</code> compare it!! in line <code>if (toothpicks = 0)</code> you reset the value of <code>toothpicks</code> to 0 and since C++ consider 0 as false it will ignore this line and continue with other if that all have the same problem!! so you should just replace <code>=</code> with <code>==</code> and say <code>if (toothpicks == 0)</code> or <code>else if (toothpicks == 2)</code></p>
",0
12824851,12824802,2,"<p>Since the vector is being sorted alphabetically using <code>sort()</code>, any duplicate words will be next to one another (since they are the same word and will contend for the same spot in the sort). This way the <code>detect()</code> can just look at all pairs of adjacent words and detect duplicates that way. If the vector was not sorted then <code>detect()</code> would not work.</p>
",0
12825029,12824802,1,"<p>Answer1: If it is sorted alphabetically, any equal elements will be next to each-other.</p>

<p>Answer2: It <strong>does</strong> get only equal values adjacent to each-other, but because of the sort all equal values will be adjacent to each-other.</p>

<p>I hope this helps.</p>
",0
13737294,13737247,2,"<p>Under the circumstances, you can simply ignore the whitespace. Extract strings, and the extractor will automatically skip leading white-space, and read a string of non white-space characters:</p>

<pre><code>int main(int argc, char **argv) { 
    std::ifstream in(argv[1]);
    std::ofstream out(argv[2]);

    std::string temp1, temp2;

    while (in &gt;&gt; temp1 &gt;&gt; temp2)
        ;
    std::cout &lt;&lt; temp1 &lt;&lt; ""\n"" &lt;&lt; temp2;
    return 0;
}
</code></pre>
",2
17409808,17409745,13,"<p>Compiler implementations are allowed to elide/remove copy constructor calls in certain cases, the example you specify is a good example use case of such a scenario. Instead of creating a temporary object and then copying it to destination object the object is created directly in the destination object and the copy constructor call is removed out.</p>

<p>This optimization is known as <strong>Copy elision</strong> through <strong><a href=""http://www.efnetcpp.org/wiki/Return_value_optimization"" rel=""nofollow noreferrer"">Return value optimization</a></strong>.</p>

<p>Also, with C++11 <strong><a href=""https://stackoverflow.com/questions/5481539/what-does-t-mean-in-c11"">move semantics through rvalue references</a></strong> might kick in instead of the Copy semantics. Even with move semantics the compilers are still free to apply RVO.</p>
",0
12798436,12798395,3,"<p>There is no kind of string that would be compatible with <code>unsigned short[]</code>.</p>

<p>There is normal string that is <code>char []</code> (in C++ you should always keep it in <code>string</code> except for constants!) and wide string, that is <code>wchar_t[]</code> (in C++ you should always keep it in <code>wstring</code>). And C++11 adds <code>char16_t</code> and <code>char32_t</code> and their corresponding <code>u16string</code> and <code>u32string</code>.</p>

<p>You can read normal string from normal input stream like <code>cin</code>. You can read wide string from <em>wide</em> input stream like <code>wcin</code>.</p>

<p><code>wchar_t</code> used to be typedef to <code>unsigned short</code> in C, but C++ requires it to be a separate type. ISO/IEC
14882:2003 3.9.1/5:</p>

<blockquote>
  <p>Type <code>wchar_t</code> is a distinct type whose values can represent distinct codes for all members of the largest extended character set specified among the supported locales (22.1.1).</p>
</blockquote>
",4
13456570,13456535,10,"<p>In C++11 you can explicitly delete these functions (which is preferred over omitting the implementation, because it is more readable, and it will always generate a compiler-error, and not just a linker-error):</p>

<pre><code>class MyClass
{
  char* _str;
  int _len;
  MyClass(const MyClass&amp; rhs) = delete;
  MyClass&amp; operator=(const MyClass&amp; rhs) = delete;
public:
  MyClass();
  MyClass(const char *);
}
</code></pre>

<p>In C++03 you can use a base-class such as <a href=""http://www.boost.org/doc/libs/release/libs/utility/utility.htm#Class_noncopyable"" rel=""nofollow noreferrer""><code>boost::noncopyable</code></a> to achieve the same effect. This might be more readable (this is essentially the same approach as yours - this base-class has private copy-constructor and assignment-operator, so inheriting from it will make your class uncopyable):</p>

<pre><code>class MyClass : boost::noncopyable
{
  char* _str;
  int _len;
public:
  MyClass();
  MyClass(const char *);
}
</code></pre>

<p>The difference between shallow and deep copying in C++ rests entirely in how you implement your copy-constructor (because <a href=""https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">your assignment operator should be implemented using your copy-constructor</a>). If you don't have one, neither shallow nor deep copying is possible, if you have, it depends on how it is implemented.</p>
",1
13456615,13456535,3,"<p>You can create a preprocessor macro to achieve the same thing, e.g.</p>

<pre><code>#define DISABLE_COPY_AND_ASSIGN(className) private: \
    className(const className&amp;); \
    className&amp; operator=(const className&amp;);
</code></pre>

<p>and then use it like this:</p>

<pre><code>class MyClass
{
   DISABLE_COPY_AND_ASSIGN(MyClass)
public:
   ....
};
</code></pre>

<p>You can derive from <code>boost::noncopyable</code> as well:</p>

<pre><code>class MyClass : boost::noncopyable
{
public:
   ....
};
</code></pre>

<p>Moreover, in C++11, you can use <code>= delete</code>:</p>

<pre><code>MyClass(const MyClass&amp;) = delete;
MyClass&amp; operator=(const MyClass&amp;) = delete;
</code></pre>
",0
13456643,13456535,2,"<p>There are two ways, and both would cause a compilation errors :</p>

<p>C++11 way:</p>

<pre><code>class MyClass
{
  char* _str;
  int _len;
  MyClass(const MyClass&amp; rhs) = delete;
  MyClass&amp; operator=(const MyClass&amp; rhs); = delete
public:
  MyClass();
  MyClass(const char *);
};
</code></pre>

<p>C++03 way:</p>

<pre><code>class MyClass
{
  char* _str;
  int _len;
public:
  MyClass();
  MyClass(const char *);

  MyClass(const MyClass&amp; rhs);            //No implementation
  MyClass&amp; operator=(const MyClass&amp; rhs); //No implementation
}
</code></pre>

<p>If you just declare copy constructors public, you'll get linker errors, but the compilation will pass. Since the compilation happens before linking, breaking the compilation is better, because you'll catch the errors sooner.</p>
",2
12854868,12854757,0,"<p>The problem is that <code>cin</code> is a stream (see <a href=""http://www.cplusplus.com/reference/iostream/cin/"" rel=""nofollow noreferrer"">reference document</a>), so you cannot just stream the value into <code>userChoice</code> as it is an int. Instead you need to use a string:</p>

<pre><code>string response;
cin &gt;&gt; response;
</code></pre>

<p>Then you need to parse the string to get the int, using one of the methods in <a href=""https://stackoverflow.com/questions/194465/how-to-parse-a-string-to-an-int-in-c"">this SO question</a>, like <code>strtol</code>.</p>

<p>Similar question on reading ints here: <a href=""https://stackoverflow.com/questions/11605236/how-to-properly-read-and-parse-a-string-of-integers-from-stdin-c"">How to properly read and parse a string of integers from stdin C++</a></p>

<p>Alternatively, just use the string <code>response</code> for your comparison:</p>

<pre><code>if(response == '1') {
    //...
}
</code></pre>
",4
12855033,12854757,-1,"<p>You can't use <code>cin</code> to set an integer. Because <code>cin</code> is a stream, you can use it to set a string. From there you can convert the string into an integer using <code>atoi</code>. You can look that up on <a href=""http://cplusplus.com"" rel=""nofollow"">cplusplus.com</a> for more details.</p>

<p>Your implementation should be something like this:</p>

<pre><code>string userChoiceString;
cin &gt;&gt; userChoiceString;
userChoice = atoi(userChoiceString.c_str());
</code></pre>
",2
12856691,12854757,0,"<pre><code>for (int y=y-1; y &gt;= 1; y=y-1)
</code></pre>

<p>initializes y to an indeterminate value. This means that the loop will have a random, possibly very long,  duration.</p>
",0
12878023,12878010,2,"<p>There are many compile errors, to take care of the first one, put the semicolon at the end of the class:</p>

<pre><code>class token {
 public:
            int value;
            string unit;

            };
</code></pre>

<p>For the second one, add a semicolon at the end of the declaration of unit:</p>

<pre><code>string unit = """";
</code></pre>

<p>Third one, define ""x"":</p>

<pre><code>int x;
</code></pre>

<p>Fourth, change '}' for ')' here:</p>

<pre><code>if (unit=="" "")
</code></pre>

<p>There are many more, sorry.
Add semicolons at the ends of all statements to start.</p>
",0
12878272,12878010,0,"<p>Is it mistyping here or you forget all semicolons? and beside that you write <code>unit = ""tens""</code> for comparing <code>unit</code> and <code>""tens""</code>? shouldn't it be <code>unit == ""tens""</code>? and to check for empty string replace <code>if( unit = "" "" )</code> with <code>if( unit.empty() )</code></p>
",0
12879517,12878010,0,"<p>In this assignment, I wouldn't use a <code>std::vector</code>, but a fixed length array.  </p>

<p>In C language terms <em>(to show the thought)</em>:  </p>

<pre><code>struct Text_Entry
{
    unsigned int value; // Don't deal with negatives with words.
    const char * const text;
};

// Here's the table
struct Text_Entry  conversion_table[] = 
{
    {0, ""zero""},
    {1, ""one""},
    {2, ""two""},
//...
    {10, ""ten""},
    {11, ""eleven""},
//...
    {20, ""twenty""},
    {30, ""thirty""},
    {40, ""forty""},
};
</code></pre>

<p>The compiler will load the table for you before your program starts, eliminating the need to use <code>push_back</code> for every case.  The <code>value</code> field allows you to arrange the entries in any order.  </p>

<p>If you are allowed to, prefer <code>std::map</code>.  </p>

<p>Don't use the table for every combination.  For example 21 would use the entry for 20 and the entry for 1.  Similarly for 135.  </p>

<p>HTH.</p>
",0
12830380,12830346,3,"<p>C++ isn't Java. Move the class declaration from your <code>main.cpp</code> into a header file and put the definition in another .cpp file.</p>

<p>Then include the header file in whatever file uses the class (including <code>main.cpp</code>).</p>
",1
12830388,12830346,4,"<p>First rule; post your code.  The code itself is a much better debugging tool than your description is.  Anyhow...</p>

<blockquote>
  <p>I get it even when I include the main.cpp in my header file or in my .cpp file.</p>
</blockquote>

<p>This is backwards.  You include header files which contain class definitions <em>in the file which uses them</em>, not the other way around.  So...</p>

<pre><code>// foo.h
#ifndef FOO_H
#define FOO_H

#include &lt;string&gt;

class foo {
public:
    foo(const std::string&amp; s);
    void print_whatever() const;
private:
    std::string _whatever;
};

#endif
</code></pre>

<hr>

<pre><code>//foo.cpp
#include &lt;foo.h&gt;
#include &lt;iostream&gt;

foo::foo(const std::string&amp; s) 
  : _whatever(s) { }

void foo::print_whatever() const { 
    std::cout &lt;&lt; _whatever; 
}
</code></pre>

<hr>

<pre><code>//main.cpp
#include &lt;foo.h&gt;

int main() {
    foo f(""hola"");
    f.print_whatever();
}
</code></pre>
",1
13791981,13791958,1,"<p><code>inputFile&gt;&gt;studentID&gt;&gt;grade1&gt;&gt;grade2&gt;&gt;grade3&gt;&gt;grade4</code> appears in your while statement and instide the while statement.  Delete the instance that is not in the while condition (the one before <code>GPA=</code>.</p>

<p>You read the line in the while statement, then read the next line and therefore never see the first of the two lines.  Just because the code is in the <code>while()</code> doesn't mean it doesn't have side-effects</p>

<h2>EDIT</h2>

<p>Also make your</p>

<pre><code>if (studentCounter==0) // Prints header if at the start of the program.
    cout&lt;&lt;""Header placeholder""&lt;&lt;endl;
</code></pre>

<p>into:</p>

<pre><code>if (studentCounter==0) { // Prints header if at the start of the program.
    studentCounter++;
    cout&lt;&lt;""Header placeholder""&lt;&lt;endl;
    continue;
}
</code></pre>
",1
12868163,12868143,1,"<p>You're comparing pointers, not the actual strings. Use C++ <code>string</code> class instead of <code>char*</code> (or check <a href=""http://en.wikipedia.org/wiki/C_string_handling"" rel=""nofollow"">how C strings work</a>).</p>
",0
12868164,12868143,7,"<p>First, <code>int * price;</code> is a dangling pointer - you never initialize it. You have to do:</p>

<pre><code>int * price = new int[i];
</code></pre>

<p>Second, usually, <code>i</code> denotes an iterator index so I suggest you stick with that - so </p>

<pre><code>for (i=0; i&lt;n; i++) //some more refactoring needed
</code></pre>

<p>Third, you need to compare char arrays using <code>strncmp</code> in your case.</p>

<p><strong>Fourth and most important</strong> - use <code>std::string</code> and <code>std::vector</code> instead. This is C++, not C.</p>
",0
12868359,12868143,23,"<p>In C++ <code>==</code> only implemented internally for primitive types and array is not a primitive type, so comparing <code>char[100]</code> and string literal will only compare them as 2 <code>char*</code> or better to say as 2 pointers and since this 2 pointers can't be equal then <code>items[n] == ""ae""</code> can never be true, instead of this you should either use <code>std::string</code> to hold string as:</p>

<pre><code>std::string items[100];
// initialize items
if( items[n] == ""ae"" ) ...
</code></pre>

<p>or you should use <code>strcmp</code> to compare strings, but remeber <code>strcmp</code> return 0 for equal strings, so your code will be as:</p>

<pre><code>char items[100][100];
// initialize items
if( strcmp(items[n], ""ae"") == 0 ) ...
</code></pre>

<p>And one extra note is <code>if (items == 0)</code> is useless, since <code>items</code> allocated on stack and not in the heap!</p>
",1
13787507,13787471,3,"<p>Simply <code>&amp;</code> the number itself with 7. Also, <code>29 = 0b11101</code>. To generalise, the remainder when divided by a number <code>2 ^ n</code> is found by <code>&amp;</code>ing it with <code>(2 ^ n) - 1</code> (<code>^</code> == power of)</p>

<p>Thus, to obtain remainder <code>modulo 16</code>, <code>&amp;</code> with 15, and so on.</p>
",1
13787523,13787471,2,"<p>Since 8 is exactly <code>2^3</code>, the modulo-8 remainder of any number is composed of its last three binary digits, i. e. it equals the number bitwise-and 7:</p>

<pre><code>unsigned rem8 = number &amp; 7;
</code></pre>

<p>(7 is <code>111</code> in binary, that's why.)</p>
",0
12831645,12831622,4,"<p>Thing is <code>&gt;&gt;</code> stops when reaching a blank. Maybe you want <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow""><code>std::getline</code></a> instead ?</p>

<pre><code>std::getline(std::cin, str);
</code></pre>
",2
12831740,12831622,0,"<p>To expand on the answer from @cnicutar and fix some other things in your code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

int main()
{
    char* to_remove = ""aA"";

    while (!std::cin.eof())
    {
        std::string str;
        std::getline(std::cin, str);

        if (std::cin.fail())
        {
            std::cerr &lt;&lt; ""Error reading from STDIN"" &lt;&lt; std::endl;
            return 1;
        }


        size_t index = 0;

        while ((index = str.find_first_of(to_remove, index)) != string::npos)
        {
            str.erase(index);
        }

        std::cout &lt;&lt; str &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
",8
12831754,12831622,1,"<p>Extending @cnicutar's answer, here is the standard way of reading from <code>std::cin</code>,</p>

<pre><code>std::string str;
while (std::getline(std::cin, str))
{
    // str now contains text upto the first newline
}
</code></pre>

<p>But if you are to remove all the 'a' and 'A', a better approach is to iterate through the input stream one character at a time.</p>

<pre><code>std::cin &gt;&gt; std::noskipws; // Do not skip whitespaces in the input stream

std::istream_iterator&lt;char&gt; it(std::cin);
std::istream_iterator&lt;char&gt; end;

std::string result;

// Copy all characters except {'a', 'A') to result
std::copy_if(it, end, std::back_inserter(result),
                [](char c) -&gt; bool { return c != 'a' &amp;&amp; c != 'A'; }
                );
</code></pre>
",0
12831954,12831622,0,"<p>This is short and fairly simple. It shows one way to construct a <code>std::string</code> from an an input stream and the common <a href=""http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Erase-Remove"" rel=""nofollow"">erase-remove idiom</a>.</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

bool is_aorA(char ch)
{
    return ch == 'a' || ch == 'A';
}

int main()
{
    std::istreambuf_iterator&lt;char&gt; input(std::cin), end;
    std::string str(input, end);

    str.erase(std::remove_if(str.begin(), str.end(), is_aorA), str.end());

    std::cout &lt;&lt; str &lt;&lt; '\n';
}
</code></pre>

<p>See it in action at <a href=""http://ideone.com/53VRg"" rel=""nofollow"">ideone.com</a></p>
",0
13734332,13733604,8,"<p>Needed to compile Protobuf correctly. There is a vsprojects folder.  Just build ONLY the libprotobuf and add the libprotobuf.lib as reference to the project by going to:</p>

<p>Properties > Linker > Input :  Additional Dependencies > Edit...</p>

<p>If you copied it to your project folder/google  put in google/libprotobuf.lib</p>

<p>Everything should compile smoothly now.</p>
",2
12860857,12860822,5,"<pre><code>int x=6 ;
</code></pre>

<p>Here <code>x</code> is identifier i.e. the <code>name given to memory area</code> where value 6 is stored.<br/>
<code>x</code> is simple name just to identify memory area where value 6 is stored.<br/>
when u declares variable, that time compiler stores ur variable name in the identifier table.</p>

<p>For <code>person p</code>, here once again <code>p</code> is name given to the memory area,which stores two data member <code>type1</code> &amp; <code>type2</code><br/></p>

<p>For accessing the value of <code>type1</code> &amp; <code>type2</code>, first u have to find the memory area, where they are stored. That's why u have to first access the memory area <code>p</code> &amp; then u can access <code>type1 * type2</code></p>
",5
12860903,12860822,5,"<p>In the case <code>int x = 6</code>, <code>x</code> is just a name to help you write the code and the compiler compile it. It's basically an alias for some place in memory, so that it's easier to access it later via <code>x = 2</code> - this tells both you and the compiler that you want to write the value <code>2</code> in that same place.</p>

<p>Same as before, but it takes up more space (<code>sizeof(Person)</code> to be exact). <code>p-&gt;type1</code> is only valid if <code>p</code> is a pointer to a <code>Person</code> (or if you overloaded the <code>-&gt;</code> operator, but it's not the case), <code>p.type1</code> is the syntax used for an object, to specify which part of the it you want to access.</p>
",0
12860913,12860822,0,"<p>read about stack and heaps.</p>

<p>x will be pushed onto the stack with a unique adress. But you only have to call x.</p>

<p>but try cout &lt;&lt; &x;</p>

<p>That is the real adress</p>
",1
12860931,12860822,1,"<p><code>x</code> is a variable identifier. A variable differs from an address in that it has a size, and can't be null. The address of <code>x</code> can be obtained with <code>&amp;x</code>. Consider this code:</p>

<pre><code>int x = 5;
int* p = &amp;x; // the pointer p now refers to x
x = 6;
</code></pre>

<p>Now, even though you've only changed the value of <code>x</code>, if you get the value of <code>*p</code> (called 'dereferencing' the pointer) you will also get 6. <code>p</code> is also a variable, but it has the type 'pointer to int' rather than 'int', which is the type <code>x</code> has.</p>
",0
12860936,12860822,4,"<p><code>x</code> is an lvalue, which means ""locator value"". It's called like that because from <code>x</code> the compiler knows where it is located. So <code>x</code> in a sense is an address, or something that allows an address to be deduced. </p>

<p>That <em>thing</em> becomes a value only when read</p>

<pre><code>int a = x;
</code></pre>

<p>In that case, the compiler takes <code>x</code>, reads the value in its location and henceforth in that initialization the <code>x</code> stands for its value. Unfortunately this ""value reading"" is an implicit process, so whether the text <code>x</code> is a value or a lvalue depends on where it appears in. </p>
",10
12860986,12860822,-1,"<p>when you declare your variable, your compiler maps it with a variable attribute table. And that table contains address and size, type etc.So compiler gets things from this table when needed.</p>
",1
12861062,12860822,1,"<p><code>x</code> is a variable. Or more exactly the name or label of the place where is stored that piece of information (data) that variable refers to. 
You need labels to differentiate between different variables. It's just there for you (the programmer) to help you. </p>

<p><code>p</code> is again variable but of type <code>Person</code>. And <code>Person</code> is data structure - it holds data, that you access through the structure. 
And <code>p</code> is object (e.i. is instantiation of the structure) of this type. You can have two objects of the same type</p>

<pre><code>Person p;
Person someone;
</code></pre>

<p>In order to know which one's data/member you want access you use <code>p.data</code> <code>someone.data</code></p>

<p>Why <code>p-&gt;data</code>?</p>

<p><code>p-&gt;data</code> syntax is equivalent to <code>(*p).data</code> </p>

<p>That goes to explaining what is pointer. As I said variable is a place where you store some information (data). 
Simply said pointer is a variable that stores a memory address. 
In other words it points to another value stored somewhere in the memory</p>

<p>For example:</p>

<pre><code>Person p; // variable of type Person 
Person *pointer_to_p = &amp;p; 
// a pointer that points to the variable p 
// it holds the address of p - that's what &amp;p does it returns the address of a varible
</code></pre>

<p><code>*p</code> in <code>(*p).data</code> is called dereferencing a pointer (accessing the value that the pointer points to)</p>

<p>For more information it is a good idea to google pointers or even better get a <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">book to read</a></p>
",4
12861115,12860822,3,"<pre><code>int x = 6;
</code></pre>

<p><em>what exactly is X?</em></p>

<p><code>x</code> is a variable which can be defined as a <strong>name given to a location in memory.</strong></p>

<p><em>how does the compiler know where's x?</em></p>

<p>There is something called a <strong>symbol table</strong> which the compiler uses internally to map variable names to actual memory locations.</p>
",0
12861296,12860822,1,"<p>That it's a variable is all that can be said with confidence.</p>

<p>It might not have a memory address, if the optimizer placed it into a register.  If it does have a memory address, it could be given a fixed absolute address (for globals and statics in non-relocatable code), an address relative to some other object (for non-static members), or an address relative to the stack frame (for automatic local variables).</p>

<p>It might not even be a storage location, if the compiler determined that it could always predict the value and substitute that value at every use.</p>

<p>If you use the <code>&amp;</code> address-of operator on the variable, then the compiler will have to give it a memory location.</p>
",0
12863190,12860822,1,"<p>Let's take a step back ... it's important to understand that all programming languages (apart from assembly language) describe an abstraction of a problem in terms that are supposed to be easy for programmers to think about. It is the job of the compiler to read that abstract description and to generate a lower-level description that corresponds directly to the hardware.</p>

<p>When you write:</p>

<pre><code>int x = 6;
</code></pre>

<p>you are telling the compiler that you want to use an integer variable, that you want to call that variable x, and that you want the variable to have the value 6.</p>

<p>One of the jobs of the compiler is to decide how to store that variable. The C++ language describes various kinds of variable scope that help the compiler decide what sort of storage is appropriate.</p>

<ul>
<li><p>A local variable (declared inside a function) will normally be stored in memory on the stack, but a small value (such as an integer) could be held in a register.</p></li>
<li><p>A global or static variable will be stored in memory.</p></li>
</ul>

<p>The compiler remembers where it has chosen to store the value so that it can find it again -- for a local varaible that will be the register name or an address relative to the top of the stack; for a global or static it will be an address relative to the start of all the program's data. </p>

<p>The actual address in memory isn't known until the program has been compiled, linked, and loaded into memory (because the OS may not always load the program at the same address) -- the important thing is that the compiler knows where the variable <em>will</em> be, and that it can generate code to access it.</p>

<p>If, as in your second question, the type of the variable is some data structure the compiler chooses where to place it in memory in exactly the same way. When your program accesses a member of that structure the compiler can work out the address of the member because it knows the address of the structure and also the offset of the member within the structure.</p>

<p>So, in the case of your <code>person p</code> example, when the program refers to <code>p1.type2</code> the compiler takes the address of <code>p</code> and adds the offset of <code>type2</code> (which will probably be 4, because the first part of your <code>struct person</code> is taken up with <code>type1</code> which is an integer, which is 4 bytes (on most 32-bit architectures)).</p>

<p>You have to specify both <code>p</code> and <code>type2</code> because you might have another person (say <code>q</code>) and the compiler needs to be told which person you are trying to manipulate. <code>p.type2</code> is not the same variable as <code>q.type2</code>, and will have a different address.</p>
",0
12862985,12860822,1,"<p>The Word is not the Thing.</p>

<p>All <code>x</code>, and <code>p</code>, and for that matter <code>p.type1</code> <em>are</em> is names, or identifiers. So, I guess you're really asking <em>what they identify</em>. The answer is that they identify <em>something</em>, which behaves <em>as if</em> it fulfills certain requirements made by the language specification. What this identified thing <em>actually</em> is will depend on your platform, compiler, maybe what optimizations you have turned on, etc. etc.</p>

<p>So, let's take the statement</p>

<pre><code>int x = 6;
</code></pre>

<p>You're saying that <code>x</code> is now (in this scope and possibly nested scopes) going to refer to an <code>int</code> (whatever that is), and giving it the initial integer literal value <code>6</code>.</p>

<p>So, what is an <code>int</code>? It's a <em>thing</em> which can hold a single (positive or negative) integer value, within the range <code>[std::numeric_limits&lt;int&gt;::min(),std::numeric_limits&lt;int&gt;::max()]</code>. Its exact size is architecture-dependent, but it's at least as big as a <code>char</code> and no larger than a <code>long</code> (IIRC).</p>

<p>Likely candidates for what this <em>thing</em> could be:</p>

<ul>
<li>sufficient memory to hold whatever an <code>int</code> is on your platform, associated with a linker symbol (possibly relocated at runtime) if it's a global declaration, so all the code referring to <code>x</code> uses the same memory location</li>
<li>sufficient memory at a fixed offset from the stack (or stack-frame) pointer register if it's a function-scope local variable: the compiler is responsible for tracking the variables it's going to put here inside each function, and remembering which offset is associated with each identifier. This is a common default (unoptimized) case</li>
<li>a register, of sufficient size to store an <code>int</code>: if you never take the address of <code>x</code> it may be able to spend its whole life inside a register, but if you either take the address or the compiler runs out of registers for all your variables (or needs to save them across a function call), <code>x</code> may be loaded into a register when you're working with it, and spilled back to stack. Again, it's up to the compiler to remember <em>when</em> <code>x</code> is currently a register (and which one), and when it's a memory location</li>
</ul>

<hr>

<p>As you can see, the ""thing"" <code>x</code> identifies can really be lots of things, at different points during the execution of your program.</p>

<p>Unless you're optimizing something or carefully laying out your memory, a more useful question is <em>what are the properties of x</em>?</p>

<p>The point of the standard (or any language spec, really) is to make some useful guarantees about types, variables and behaviours, and then let the compiler choose how to achieve those guarantees.</p>
",0
12805282,12805095,2,"<p>Apart from the incorrect operator for squaring the values, and the missing parenthesis, the given program doesn't fulfill the part of the assignment that says that the functions should <em>return</em> the calculated values. For example:</p>

<pre><code>double calculate_mean()
{
    return (x1+x2+x3)/3;
}
</code></pre>
",4
12805170,12805095,6,"<ol>
<li><p>You can't take powers like that in C++</p>

<ul>
<li>Use <code>std::pow()</code> or <code>x*x</code> for mathematical x<sup>2</sup></li>
</ul></li>
<li><p>For multiple inputs it's <code>cin &gt;&gt; x1 &gt;&gt; x2 ...etc</code></p></li>
<li><p>In your SD equation, your close paren is in the wrong spot I think, mathematically.</p>

<ul>
<li>it should be <code>SD = sqrt( (x*x + y*y) / z )</code>. Your close paren makes it x + y*y/3 (or y<sup>2/3</sup>, forget precedence)</li>
</ul></li>
</ol>
",1
12840757,12840711,24,"<p>From the docs:</p>

<blockquote>
  <p>All the elements of the vector are dropped: their destructors are called, and then they are removed from the vector container, leaving the container with a size of 0.</p>
</blockquote>

<p>Basically you're invoking <strong>undefined behavior</strong> on <code>myvector[2]</code> because that item no longer exists. You only pushed 2 elements in the vector after calling <code>clear()</code>, so only indices <code>0</code> and <code>1</code> are accessible. </p>

<p>You're unlucky that it didn't crash, because appearing to work can hide bugs. There's no guarantee that the value is erased.</p>

<p>Trying to access the element with <code>.at(2)</code> instead will result in an exception being thrown (<code>operator[]()</code> doesn't do any bound-checking, whereas <code>at()</code> does).</p>
",0
12840780,12840711,7,"<p>If you attempt to run this code in <code>debug</code> mode, it's likely it will crash with a debug assertion.  Referencing past the end of an array is <strong>undefined behaviour</strong>.</p>

<p>What's actually happening is that vector has not wiped the memory it was previously using before you ran <code>clear()</code>.  This memory is still present but it's not defined what will happen if you access it.  It's up to you to perform bounds checking to avoid running off the end of a vector.  You can do this by looping with <code>size()</code> as a bounds, or by using <code>at()</code> and catching the <code>out_of_range</code> exception.  I wouldn't particularly recommend this latter approach since it's not a good idea to use exceptions for runtime checks.</p>
",0
12867740,12867695,2,"<p>When you set prime to false to say that a single number isn't prime, you never set prime to true again.</p>
",0
12867744,12867695,2,"<p>On the first line inside the first for loop, put this:</p>

<p><code>prime = true;</code></p>

<p>Currently, you never reset your <code>prime</code> flag back to <code>true</code>, so when you get to 4, and set <code>prime</code> to <code>false</code>, it never ""finds"" a prime number after, since <code>prime</code> is <em>always</em> false.</p>

<p>Full code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;conio.h&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    bool prime = true;

    for (int x = 3; x &lt;= 100; x++)
    {
        prime = true;
        for (int y = 2; y &lt;= (x - 1); y++)
        {
            if ((x % y) == 0)
            {
                prime = false;
                break;
            }
        }

        if (prime == true)
            cout&lt;&lt;x&lt;&lt;endl;
    }

    getche();
    return 0;
}
</code></pre>
",3
12867763,12867695,1,"<p>after the first loop initialize <strong>prime=true;</strong>. because once prime is false it is not getting true again.</p>

<pre><code>for (int x = 3; x &lt;= 100; x++)
{
     prime=true;
     ///rest of the code

}
</code></pre>
",0
12867768,12867695,1,"<p>you never reset prime to be true. After you cout you need to do
    prime = true;</p>
",0
12867786,12867695,0,"<p>Try this.</p>

<pre><code>for (int x = 3; x &lt;= 100; x++)
{
     for (int y = 2; y &lt;= (x - 1); y++)
     {
         if ((x % y) == 0)
         break;
         if((x-1)==y)
         cout&lt;&lt;x&lt;&lt;endl;
     }    
}
</code></pre>
",0
12867808,12867695,6,"<p>The problem is:</p>

<pre><code>for (int y = 2; y &lt;= (x - 1); y++)
{
    if ((x % y) == 0)
        prime = false;
        break;
}
</code></pre>

<p>when it should be</p>

<pre><code>for (int y = 2; y &lt;= (x - 1); y++)
{
    if ((x % y) == 0)
    {
        prime = false;
        break;
    }
}
</code></pre>

<p>You break every time with <code>prime</code> set to true unless the first condition is met.</p>

<p>You also have to reset <code>prime</code> to true on each iteration:</p>

<pre><code>for (int x = 3; x &lt;= 100; x++)
{
    prime = true;
</code></pre>
",0
12867823,12867695,0,"<p>The inner loop will always call the break statement since the IF only executes the first line because it is not wrapped in parentheses. Also you need to reset the bool variable for each number (i.e. inside the first loop)</p>

<pre><code>if ((x % y) == 0)
{
    prime = false;
    break; // previously it was always breaking
}
</code></pre>

<p>Previously it was basically doing this:    </p>

<pre><code>if ((x % y) == 0)
{
    prime = false;
}
break; // WRONG!   
</code></pre>
",0
12867835,12867695,0,"<pre><code>int main()
{

  for (int x = 3; x &lt;= 100; x++)
  {
    bool prime = true;
    for (int y = 2; y &lt;= (x - 1); y++)
    {
      if ((x % y) == 0)
      {
          prime = false;
          break;
      }
    }

    if (prime == true)
    { 
      cout&lt;&lt;x&lt;&lt;endl;
    } 
  }

  getche();
  return 0;
}
</code></pre>

<p>You needed to set prime inside the loop, and you wanted to set it to false and break on the test in your inner loop.</p>

<p>Old hand's tip number 45623, even though you can skip the braces if the code block is one line, don't.</p>
",0
12867916,12867695,0,"<p>As every one say this you have 2 errors:</p>

<p>1) you never reset value of <code>prime</code>, so add a <code>prime = true</code> to start of outer <code>for</code>.<br/>
2) convert <code>if ((x % y) == 0) prime = false; break;</code> to <code>if ((x % y) == 0) {prime = false; break;}</code> otherwise inner for will be executed only once!!</p>
",0
13463233,13463195,0,"<p>This function is expecting two arguments, <code>fname</code> and <code>lname</code></p>

<pre><code>case 1:          
    void_fullname();
</code></pre>
",0
13463240,13463195,0,"<p>You are calling void_fullname without any parameters, it requires 2 parameters.</p>
",0
13463252,13463195,1,"<p>You're not giving <code>void_fullname()</code> any arguments</p>

<pre><code>switch ( input ) {
    case 1:          
    void_fullname(); // Need args here
    break;
</code></pre>
",0
13463277,13463195,7,"<p>It's hard to figure what you're puzzled by. You write a function with two parameters, <code>void_fullname(char fname, char lname)</code>, you then call it with zero parameters, <code>void_fullname();</code>, the compiler then tells you exactly what you've done wrong. Maybe reading an introductory book on C++ will help?</p>

<p>I'm afraid to say there are many other errors in your code, as you'll discover once you've got the compiler errors out the way. </p>

<p>Here's a few tips,</p>

<p>1) <code>char</code> means a single char, not a sequence of chars. For something like a name you need a char array or a string.</p>

<p>2) <code>%d</code> is not the correct format specifier to read in character data.</p>

<p>3) When you wish to return data in the parameter of a function, you should pass a pointer or a reference to that function.</p>

<p>And so on... I think you should start with something simpler. For instance you will probably find this easier without writing any functions apart from main. Add some functions later when you've got it working without functions first. Start slowly and build up in small steps.</p>
",1
12871178,12871157,8,"<p>Multiple definitions of ""main"" suggests that you have another definition of main. Perhaps in another .c or .cpp file in your project. You can only have one function with the same name and signature (parameter types). Also, main is very special so you can only have one main function that can be used as the entry point (has either no parameters, one int, or an int and a char**) in your project.</p>

<p>P.S. Technically this is a linker error. It's a subtle difference, but basically it's complaining that the linker can't determine which function should be the entry point, because there's more than one definition with the same name.</p>
",3
14818544,14818391,0,"<p>Im assuming you have a <code>head</code> variable as a member variable in you <code>List</code> type</p>

<p>Also, from your <code>next</code>/<code>prev</code> references, I am assuming you have a doubly linked list:</p>

<pre><code>ListItem&lt;T&gt; *temp = head;

if (temp != NULL) {
    temp-&gt;prev = node;
    head = node;
    node-&gt;prev = NULL;
    node-&gt;next = temp;
} else {
    head = node;
    node-&gt;prev = NULL;
    node-&gt;next = NULL;
}    
</code></pre>
",0
16920323,16920198,1,"<p>As noted by @Lol4t0, Add a ctor for you struct:</p>

<pre><code>struct TestCaseSet {

    TestCaseSet()
    : numPass(0), numFail(0), numPWU(0) {}

};
</code></pre>

<p>Add your other variables like above.</p>
",4
13766511,13766479,4,"<p><code>type</code> is a <a href=""http://en.wikipedia.org/wiki/Dangling_pointer"" rel=""nofollow"">dangling pointer</a> as it is initialised to the internal member of a temporary <code>std::string</code> instance:</p>

<pre><code>const char *type = label.substr(0,f).c_str();
</code></pre>

<p>The <code>std::string</code> instance from which the result of <code>c_str()</code> is obtained is destructed immediately.</p>
",0
13766512,13766479,3,"<pre><code>const char *type = label.substr(0,f).c_str();
</code></pre>

<p>The pointer <code>type</code> refers to a piece of data inside a temporary (<code>label.substr(0,f)</code>). Any use of that pointer is undefined behavior.</p>
",0
13766535,13766479,0,"<p>When you get a pointer to <code>std::string</code>'s buffer by calling <code>.c_str()</code> you don't acquire the buffer. When, for example, the string object goes out of scope, the pointer is invalidated. </p>
",0
18171838,18171815,0,"<p>You have inline in cpp file remove inline and it will be fine. I mean for the Screen::move function. Alternative move definition to header file.</p>
",4
13790129,13790090,5,"<p>This</p>

<pre><code>eve(inputTime,inputDate); 
</code></pre>

<p>requires that your <code>Event</code> class have an <code>operator()(something, somethingElse)</code>, which it doesn't have. <code>something</code> and <code>somethingElse</code> would correspond to the types of <code>inputTime</code> and <code>inputDate</code> respectively, which are not specified in your question.</p>

<p>Presumably you want to construct an <code>Event</code> using the two argument constructor, which you can do like this:</p>

<pre><code>Event eve(inputTime,inputDate);
</code></pre>

<p>Since the error also mentions types <code>Time</code> and <code>Date</code>, you probably need to add a constructor that takes const references to those types, unless they can be implicitly converted to <code>int</code>.</p>
",0
18196366,18195297,1,"<p>if (costumes[i] == costume) // You are iterating through j=0 to costumes.size(), so change it to if (costumes[j] == costume).</p>
",1
17864299,17864064,7,"<p>There are essentially two ways to approach this (that I can think of ATM):</p>
<p><em>Note</em>: I would rename <code>cFunctor</code> and <code>bFunctor</code> to simply <code>Functor</code> in both cases. They are nested inside respective classes and thus such prefix makes little sense.</p>
<h2>Type erased</h2>
<p>Example of type erasure is <code>std::function</code>.</p>
<pre><code>class A {
public:
    int x;
    std::vector&lt;std::function&lt;void(void)&gt;&gt; functors;
    
    A() : functors { B::bFunctor(), C::cFunctor() }
    { }
};
</code></pre>
<p>If you need the functors to have more advanced behaviour, <code>Boost.TypeErasure</code> <code>any</code> might help.</p>
<h2>Polymorphic</h2>
<ol>
<li>Create an abstract functor type.</li>
<li>Make <code>B::bFunctor</code> and <code>C::cFunctor</code> inherit from it.</li>
<li>Store <code>vector</code> of that abstract functor type smart pointers.</li>
</ol>
<hr />
<pre><code>struct AbstractFunctor {
    virtual void operator()() const = 0;
};

class B {
public:
    struct Functor : public AbstractFunctor {
       void operator()() const {
       //some code
       }
    };
};

class A {
public:
    int x;
    std::vector&lt;std::unique_ptr&lt;AbstractFunctor&gt;&gt; functors;
    
    A() { 
        // this could most probably be shortened with make_unique
        functors.emplace_back(std::unique_ptr&lt;AbstractFunctor&gt;(new B::Functor()));
        functors.emplace_back(std::unique_ptr&lt;AbstractFunctor&gt;(new C::Functor()));
    }
};
</code></pre>
",1
13436067,13435993,1,"<p>The <code>myclass</code> defined in public.h has no members, and is therefore sized 1 byte. The <code>myclass</code> defined in private.h encapsulates <code>anotherClass</code>, and is therefore whatever size <code>anotherClass</code> is. This inconsistency is the root of your problem.</p>

<p>What you ought to do is have only one header, and use a pointer (which doesn't require a class definition) to enable hiding the implementation of <code>anotherClass</code>. I'll repeat Joachim's link to <a href=""http://c2.com/cgi/wiki?PimplIdiom"" rel=""nofollow"">the pimpl idiom</a> for elaboration.</p>
",0
13436075,13435993,6,"<p>You can't declare the same class 'myclass' in two different ways. There has to be a single class definition. If you want to hide the implementation's API you want to use the 'Pimpl' idiom. So your public class has a single pointer to a private class. For example:</p>

<p>public.h</p>

<pre><code>class myclass_private;
class myclass {
    private:
        myclass_private* pimpl; 
    public:
        myclass();
        void public_function();
};
</code></pre>

<p>public.cpp</p>

<pre><code>myclass::myclass() {
    pimpl = new myclass_private;
}

void myclass::public_function() {
     pimpl-&gt;private_function();
}
</code></pre>

<p>private.h</p>

<pre><code>class myclass_private {
    public:
        void private_function(); 
};
</code></pre>
",1
13436098,13435993,1,"<p>The definition of a class shall not changr between different translation units. This is one of the aspects of the One Definition Rule. What you might want to donis to define the publicly visible class to have a pointer to a private implementation: the Pimpl Idiom:</p>

<pre><code>class Public {
public:
    ...
private:
     struct Impl;
     Impl* impl_;
};
</code></pre>

<p>The <code>struct Impl</code> would only be defined in the implementation file.</p>
",0
13436141,13435993,1,"<p>Your class lacks a proper constructor, which means that the compiler will provide a default one based on the content of the class definition.  If that definition isn't consistent accross all the code, it won't get initialized the same way everywhere, and some data may be missing.</p>

<p>If you want to hide the implementation details of <code>instanceofClass</code>, just do a forward declaration in the header (the private header you're providing is correct, you can use it as your public one), and provide an implementation somewhere in your code.</p>
",0
12833794,12833743,1,"<p>You should explicitly instantiate your static variables the same way you've done it for <code>num</code>:</p>

<pre><code>private:
    static char username[10][20];
    static char password[10][20];
    static int num;
};

int User::num=0;
char User::username[10][20];
char User::password[10][20];
</code></pre>
",3
15539001,15538953,1,"<p><strong>Edited</strong> to reflect new information given in the question.</p>

<p><code>back</code> is a pointer to the last element in the queue, that is, the most recently added element.</p>

<p>Together with <code>i</code>, this is all the queue needs to maintain its internal data structure. Since <code>i</code> is statically allocated and elements are only ever indexed using <code>back</code>, it is unnecessary to explicitly delete elements from the queue; this is why no change is necessary to <code>i</code> within <code>purge()</code>. If you add elements, <code>purge()</code> or <code>deq()</code> them, and then add more elements, the new elements simply overwrite the previous elements in memory, which is exactly what you want; and since <code>back</code> is adjusted appropriately within each of these methods, it's impossible to access data members that are no longer logically in the queue, even though they still exist in system memory.</p>

<p>Note that the ""de"" in <code>deq</code> doesn't stand for ""delete""; <code>deq</code> is short for ""dequeue,"" which is the standard term for retrieving the oldest element from the queue. The corresponding term for adding an element to the back of the queue is ""enqueue.""</p>
",2
15539037,15538953,1,"<p>The front of the queue is at 0, the back is at q.back, so the q.back is initialized to -1 when the queue is empty.</p>

<p>Check if queue is empty should return true when back is -1, else false:</p>

<pre><code>bool empty(const Queue &amp; q)
{
    return (q.back == -1);
}
</code></pre>

<p>purge makes the queue empty again, so is the same as init.</p>
",1
15539100,15538953,0,"<p>Ok my guess is that the ADT is designed in such a way that the Queue always points to the first element added and <code>back</code> is always -1 when there are no elements in the queue.</p>

<p>Check the <code>create_queue</code>, a new queue is created and no elements are enqued yet and thus initialize <code>back</code> to -1</p>

<p>Similarly <code>empty</code>, if no elements are present <code>back</code> will be still -1</p>

<p>In <code>purge</code>, all the elements are removed and thus the <code>back</code> needs to be updated to -1</p>

<p>So if there was a function named <code>enqueue</code> .. <code>back</code> will be updated to a value which is <strong>not</strong> -1</p>

<p>P.S:- This is a wild guess as we cannot predict until we see the complete code :) </p>

<p><em><strong></em>*EDIT***</strong>
As per the updated code what I have suggested works fine, back will be -1 if queue is empty... else its an array pointing from 0 to n-1(max_queue_size) ... 0 --> first element</p>
",2
13737726,13737719,1,"<pre><code>test *ptr ;
ptr-&gt; a = 900;  
</code></pre>

<p>is undefined behavior because <code>ptr</code> is a dangling pointer, so <strong>anything can happen</strong>. The destructor may or may not be called, anything is possible.</p>

<p>To make it point to a valid object, you can assign it to the adress of obj:</p>

<pre><code>test* ptr = &amp;obj;
</code></pre>

<p>To create a new dynamically-allocated object, you can use <code>new</code>:</p>

<pre><code>test* ptr = new test;
</code></pre>

<p>but if you do this, you'll have to take care of memory management yourself:</p>

<pre><code>delete ptr;
</code></pre>
",5
13737748,13737719,1,"<p>No, the destructor will not be called because a segmentation fault is the result of the operating system sending an interrupt to the program for trying to access memory which is protected.  The interrupt will halt the execution of the program and it will not be able to continue any further.</p>
",6
13477526,13477488,3,"<p>It depends. Is returning an empty string part of the logic, or is it an exceptional condition.</p>

<p>If it's not supposed to happen, you should throw an error.</p>

<p>If it's okay for the string to be empty, you should just return an empty string:</p>

<pre><code> return std::string();
</code></pre>

<p>The reason it compiles as-is is that <code>false</code> is interpreted as <code>0</code>, which is <code>NULL</code>, which can be a <code>char*</code>, so a string is attempted to be constructed from it. However, constructing an <code>std::string</code> from a <code>NULL</code> pointer is invalid, that's why you're getting the exception. </p>

<p>Here's how I'd code it:</p>

<pre><code>static std::string getToto(){
   char buffer[1024];
   if ( CTX_Get_Env(buffer, ""Toto"", 1024) )
      throw InvalidDataInBufferException();
   return buffer;
}
</code></pre>

<p>if the string isn't supposed to be empty, or</p>

<pre><code>static std::string getToto(){
   char buffer[1024];
   if ( CTX_Get_Env(buffer, ""Toto"", 1024) )
      return std::string();
   return buffer;
}
</code></pre>

<p>if it's okay for the string to be empty.</p>
",1
13477560,13477488,3,"<p>The implicit <code>std::string(const char*)</code> constructor is being initialized with <code>false</code>, which is being interpreted as the null pointer. Constructing an <code>std::string</code> from a null pointer is disallowed by the standard. On your platform,  this results in an exception being thrown. If you cannot modify the function, you can place the function call inside of a try block, but note that <strong>this is by no means guaranteed to work on other platforms</strong>.</p>

<pre><code>try {
  std::string returned = Test::getToto().c_str();
  const char* c = returned.c_str();
} catch(...) {
  // handle the error
}
</code></pre>

<p><strong>Note 1</strong>: Since implementations are not required to raise an exception if an <code>std::string</code> is initialized from a null pointer, calling the <code>getToto()</code> function can result in undefined behaviour. The <code>try-catch</code> blocks only help if your implementation throws an exception, and is therefore not a portable solution. This also means that the library function <code>getToto()</code>, by invoking undefined behaviour, should be avoided.</p>

<p><strong>Note2</strong>: The exception was hiding another error, here:</p>

<pre><code>const char* returned = Test::getToto().c_str();
</code></pre>

<p><code>Test::getToto()</code> returns a temporary string, which you do not assign. Your <code>returned</code> pointer is left dangling. In my code example, I assign the return to an <code>std::string</code>, <em>then</em> get the pointer to its internal char data.</p>
",10
13480853,13477488,0,"<p>You should understand that you got an exception BEFORE even getToto() really returns. There is no way to do 'return false' from the function returning string and do not get an exception. It's just a bug.
You can override it with try/catch block like this:</p>

<pre><code>const char* returned = NULL;
try{
    returned = Test::getToto().c_str();
}catch(std::exception&amp; e){
    std::cout &lt;&lt; ""null pointer"" &lt;&lt; std::endl;
}
</code></pre>

<p>but it is still a BAD thing to do.</p>
",0
13484965,13484943,3,"<p>If your only need is to visualize your tree, a better method would be to output it into a dot format and draw it with grapviz.</p>

<p>You can look at <a href=""http://www.graphviz.org/pdf/dotguide.pdf"" rel=""nofollow noreferrer"">dot guide</a> for more information abt syntax etc</p>
",1
13484991,13484943,0,"<p>Do an in-order traversal, descending to children before moving to siblings. At each level, that is when you descent to a child, increase the indent. After each node you output, print a newline.</p>

<p>Some psuedocode. Call <code>Print</code> with the root of your tree.</p>

<pre><code>void PrintNode(int indent, Node* node)
{
    while (--indent &gt;= 0)
        std::cout &lt;&lt; "" "";
    std::cout &lt;&lt; node-&gt;value() &lt;&lt; ""\n"";
}

void PrintNodeChildren(int indent, Node* node)
{
    for (int child = 0; child &lt; node-&gt;ChildCount(); ++child)
    {
        Node* childNode = node-&gt;GetChild(child);
        PrintNode(indent, childNode);
        PrintNodeChildren(indent + 1, childNode);
    }
}

void Print(Node* root)
{
   int indent = 0;
   PrintNode(indent, root);
   PrintNodeChildren(indent + 1, root);  
}
</code></pre>
",0
13484997,13484943,17,"<p>In order to pretty-print a tree recursively, you need to pass two arguments to your printing function:</p>

<ul>
<li>The tree node to be printed, and</li>
<li>The indentation level</li>
</ul>

<p>For example, you can do this:</p>

<pre><code>void BinarySearchTree::postorder(tree_node* p, int indent=0)
{
    if(p != NULL) {
        if(p-&gt;left) postorder(p-&gt;left, indent+4);
        if(p-&gt;right) postorder(p-&gt;right, indent+4);
        if (indent) {
            std::cout &lt;&lt; std::setw(indent) &lt;&lt; ' ';
        }
        cout&lt;&lt; p-&gt;data &lt;&lt; ""\n "";
    }
}
</code></pre>

<p>The initial call should be <code>postorder(root);</code></p>

<p>If you would like to print the tree with the root at the top, move <code>cout</code> to the top of the <code>if</code>.</p>
",1
13485111,13484943,0,"<p>From your root, count the number of your left children. From the total number of left children, proceed with printing the root with the indention of the number of left children. Move to the next level of the tree with the decremented number of indention for the left child, followed by an initial two indentions for the right child. Decrement the indention of the left child based on its level and its parent with a double indention for its right sibling.</p>
",0
18286894,13484943,2,"<p>Here's a little example for printing out an array based heap in tree form. It would need a little adjusting to the algorithm for bigger numbers. I just made a grid on paper and figured out what space index each node would be to look nice, then noticed there was a pattern to how many spaces each node needed based on its parent's number of spaces and the level of recursion as well as how tall the tree is. This solution goes a bit beyond just printing in level order and satisfies the ""beauty"" requirement.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

static const int g_TerminationNodeValue = -999;

class HeapJ
{
public:
HeapJ(int* pHeapArray, int numElements)
{
    m_pHeapPointer = pHeapArray;
    m_numElements = numElements;

    m_treeHeight = GetTreeHeight(1);
}

void Print()
{
    m_printVec.clear();

    int initialIndex = 0;
    for(int i=1; i&lt;m_treeHeight; ++i)
    {
        int powerOfTwo = 1;
        for(int j=0; j&lt;i; ++j)
        {
            powerOfTwo *= 2;
        }

        initialIndex += powerOfTwo - (i-1);
    }

    DoPrintHeap(1,0,initialIndex);

    for(size_t i=0; i&lt;m_printVec.size(); ++i)
    {
        std::cout &lt;&lt; m_printVec[i] &lt;&lt; '\n' &lt;&lt; '\n';
    }
}

private:
int* m_pHeapPointer;
int m_numElements;
int m_treeHeight;
std::vector&lt;std::string&gt; m_printVec;

int GetTreeHeight(int index)
{
    const int value = m_pHeapPointer[index-1];

    if(value == g_TerminationNodeValue)
    {
        return -1;
    }

    const int childIndexLeft = 2*index;
    const int childIndexRight = childIndexLeft+1;

    int valLeft = 0;
    int valRight = 0;

    if(childIndexLeft &lt;= m_numElements)
    {
        valLeft = GetTreeHeight(childIndexLeft);
    }

    if(childIndexRight &lt;= m_numElements)
    {
        valRight = GetTreeHeight(childIndexRight);
    }

    return std::max(valLeft,valRight)+1;
}

void DoPrintHeap(int index, size_t recursionLevel, int numIndents)
{
    const int value = m_pHeapPointer[index-1];

    if(value == g_TerminationNodeValue)
    {
        return;
    }

    if(m_printVec.size() == recursionLevel)
    {
        m_printVec.push_back(std::string(""""));
    }

    const int numLoops = numIndents - (int)m_printVec[recursionLevel].size();
    for(int i=0; i&lt;numLoops; ++i)
    {
        m_printVec[recursionLevel].append("" "");
    }

    m_printVec[recursionLevel].append(std::to_string(value));

    const int childIndexLeft = 2*index;
    const int childIndexRight = childIndexLeft+1;

    const int exponent = m_treeHeight-(recursionLevel+1);
    int twoToPower = 1;
    for(int i=0; i&lt;exponent; ++i)
    {
        twoToPower *= 2;
    }
    const int recursionAdjust = twoToPower-(exponent-1);

    if(childIndexLeft &lt;= m_numElements)
    {
        DoPrintHeap(childIndexLeft, recursionLevel+1, numIndents-recursionAdjust);
    }

    if(childIndexRight &lt;= m_numElements)
    {
        DoPrintHeap(childIndexRight, recursionLevel+1, numIndents+recursionAdjust);
    }
}
};

const int g_heapArraySample_Size = 14;
int g_heapArraySample[g_heapArraySample_Size] = {16,14,10,8,7,9,3,2,4,1,g_TerminationNodeValue,g_TerminationNodeValue,g_TerminationNodeValue,0};

int main()
{
    HeapJ myHeap(g_heapArraySample,g_heapArraySample_Size);
    myHeap.Print();

    return 0;
}

/* output looks like this:

           16

     14          10

  8     7     9     3

2   4 1           0

*/
</code></pre>
",1
13706731,13546201,1,"<p>Copy the entire passed vector in the constructor (don't just have a pointer to it). Allowing anything to modify the internal structure of something that needs to have a specific structure (as in sorted elements) to work is a bad idea. You can do this simply as follows:</p>

<pre><code>class Heap
{
   ...
   Heap(std::vector&lt;A&gt; &amp;input): vect(input) { };
   std::vector&lt;A&gt; vect;
}
</code></pre>

<p>You will need to either have a copy constructor or override the <code>=</code> operator for A for the above to work, but doing both doesn't hurt. As in:</p>

<pre><code>class A
{
   ...
   A(const A &amp;o): a(o.a), b(o.b) {}; // Copy constructor
   void operator=(const A &amp;o): a(o.a), b(o.b) {}; // = operator
}
</code></pre>

<p>Adding both pieces of code will copy all the elements in the vector in the heap's constructor. Pointers won't work for this since are always be shallow-copied, unless you explicitly deep-copy them, which is a bit more effort.</p>

<p>An alternative to this is always starting with an empty heap and having an <code>add</code> method (still not using pointers).</p>

<p>If you don't want to copy elements, you can use the <code>const</code> keyword. As in use <code>const A</code> everywhere in your code where you used <code>A</code>.</p>

<p>Note 1 - I'd suggest getting rid of the makeHeap method and just doing that work in the constructor.</p>

<p>Note 2 - I used <code>class</code> above, and not <code>struct</code>. Don't use <code>struct</code> in C++, use <code>class</code> instead. <code>struct</code> is more C.</p>
",0
12874274,12874226,5,"<p><code>getline</code> discards the newline at the end of the input. However, on Windows, the newline delimiter is actually <code>\r\n</code>, i.e. a carriage return followed by a newline. Thus, <code>getline</code> ends up storing a string ending with a carriage return.</p>

<p>When you print a line ending with a carriage return, the console will print the text and back the cursor to the beginning of the line (since that's what a carriage return does). Normally, a newline would then push the cursor to the next line, but since the text doesn't contain a newline, the next line gets printed starting from the start of the current line -- overwriting the current line. That's why you only see the last line.</p>

<p>Thus, if you want to print out the lines, you have to output the <code>endl</code> that <code>getline</code> discards.</p>
",1
15873776,15873727,2,"<p><strike>The constructor you show doesn't initialize <code>logSize</code>. This could well be at least part of the problem.</strike></p>

<p>Also, <code>heap</code> has a fixed size and <code>enqueue()</code> doesn't check for overflow.</p>
",11
15873925,15873727,0,"<p>You are <strong>not using slot 0 of heap</strong>. Instead try post incrementing logSize.
Also, there has to be some kind of bounds check before accessing array heap.</p>

<pre><code>    void HeapPQueue::enqueue(const string&amp; elem) {
        heap[logSize] = elem;
        bubbleUp(logSize);
        logSize++;
    }
</code></pre>
",4
13488095,13487951,3,"<p>You get that error because of the stack/heap is corrupt. In the constructor, there's an error in the for loop:</p>

<p>`Trie::Trie(){
  ...</p>

<pre><code>for( int i=0; i&lt;CHARSIZE+1; i++ ){ ***// should not +1, just i &lt; CHARSIZE*** 

    this-&gt;pRoot-&gt;child[ i ] = NULL; 

}`
</code></pre>

<p>When the heap is corrupted, in debug version, an exception will occur at next memory allocation because of heap verification.</p>
",1
13724540,13724290,0,"<p>Just as you don't know in advance what your <code>vec[i]</code> is, so doesn't the compiler. Function overload resolution is a compile time process, while polymorphism - run time.</p>

<p>Thus it calls the <code>void foo(BASE*   a, BASE*   b)</code> version.</p>

<p>In other words, what you want to do is impossible, unless you use <code>dynamic_cast</code> to try to cast to every possible derived class. It will return <code>0</code> if the object is of wrong type.</p>

<p>However, many people will argue that use of  <code>dynamic_cast</code> is indication of bad design. And it's expensive as well.</p>
",0
13724604,13724290,0,"<p>You need dynamic dispatching for that, something like this:</p>

<pre><code>void foo(BASE *a, BASE *b) {
  if (DERIVED *bb = dynamic_cast&lt;DERIVED*&gt;(b)) {
    foo(a, bb);
  } else {
    std::cout &lt;&lt; "" full base "" &lt;&lt; std::endl;
  }
}
</code></pre>

<p>If you don't want to use a <code>dynamic_cast</code>, you could add a virtual function to <code>BASE</code> which would return some form of class identifier (e.g. an <code>enum</code>), override this in each derived class and then fork the call based on the return value of this function (along with <code>static_cast</code>).</p>
",1
13724616,13724290,2,"<p>The simplest (and quickest) way to get workaround is to introduce one more virtual function to unique identify derived classes (using <code>int</code>, <code>enum</code> values or <code>typeid</code>). So later you may call it and realize what exact derived class (or maybe base) you've got behind the <code>BASE*</code>, and do <code>dynamic_cast</code> to that type.</p>

<p>You gave no details about what problem you are trying to solve... just make sure that you've done a complete reaseach for existed solutions if you want to implement a <a href=""http://en.wikipedia.org/wiki/Double_dispatch"" rel=""nofollow"">Double Dispatch</a> (or some kind of)...</p>

<p>But usually, if you need <code>dynamic_cast</code> it means that smth wrong with you design (OOP model of domain)...</p>
",5
13462911,13462725,0,"<ol>
<li>Don't use strtok.</li>
<li>Don't use a linked list.</li>
<li>cin.ignore won't get you input from the user.</li>
<li>Put your words in a <code>std::set</code> (or unordered_set), and look for them with <code>your_set.find</code>.</li>
</ol>

<p>As an aside, I doubt this will be much good for a search engine, except (possibly) for the stop list -- figuring out whether the current word is one you want to ignore. For example, build a list of ""a"", ""an"", ""the"", etc., that aren't worth indexing, and as you index something, check whether it's in that last (and obviously ignore it if it is).</p>
",4
13488307,13488067,3,"<p>The problem is that <code>cin &gt;&gt; choice;</code> leaves the newline in the input stream so the <code>getline(cin, str);</code> immediately returns due to that newline.</p>

<p>Try adding a <code>cin.ignore();</code> after the <code>cin &gt;&gt; choice;</code> to consume the newline character.</p>
",1
17843346,17843145,1,"<p>That's just a way of creating objects of that type of Class. Structs mostly use them to initialize new variables.</p>
",0
17843459,17843145,2,"<p>You declare variables using the format <code>type variable_name;</code>.  For example:</p>

<pre><code>A x;
</code></pre>

<p>Where A may be the name of a class.</p>

<p>But instead of using a pre-existing class type, you can also define the class at the same time as you declare a variable of the new class's type:</p>

<pre><code>class { ... } x;
</code></pre>

<p>or define the class and give it a name:</p>

<pre><code>class A { ... } x;
</code></pre>

<p>In C++ it is common to just define the class and give it a name, but leave off the variable:</p>

<pre><code>class A { ... };
</code></pre>

<p>but you don't have to leave off the variable.</p>
",1
17843185,17843145,14,"<p>It's shorthand for:</p>

<pre><code>class C
{
    ....
};

C g_c;
</code></pre>
",1
17843217,17843145,21,"<pre><code>} g_c;
</code></pre>

<p>Here <code>g_c</code> is declared to be an object of the class type <code>C</code>. </p>

<p>Such construct enables you to create object(s) of unnamed type as:</p>

<pre><code>class  //Nameless class!
{
   //data members

}obj1, obj2;
</code></pre>

<p>In this example, <code>obj1</code> and <code>obj2</code> are declared to be objects of a class type which has not been given any name &mdash; the class is <em>nameless</em>! In such situation, you cannot declare objects in a conventional sense (i.e <code>Type obj1, obj2;</code> sense). So this construct helps you do that.</p>

<p>You can even derive from other <em>named</em> classes while being <em>nameless</em> (and declaring the objects of the nameless class):</p>

<pre><code>class : public A, public B //Nameless class is deriving from A and B
{
   //data members

}obj1, obj2;
</code></pre>

<p>In short, this construct ensures that the user wouldn't be able to create <em>more</em> objects than intended, unless some evil programmer uses/misuses/abuses C++11 (or template) as:</p>

<pre><code>decltype(obj1) obj3; //hehe!
</code></pre>

<p>Hope that helps!</p>
",1
13731312,13730868,0,"<p>Because every time concat is called, the index of str starts from 0. That's why the content of str is overwritten. Just skip all the filled positions in str before you append any to it.</p>
",0
13731450,13730868,0,"<p>The problem is that your function is not aware of the end of the string being passed in. To fix this you will need to intialize your <code>char *</code> to all <code>0</code>'s or <code>\0</code>. The other issue is you are converting your number to characters incorrectly. And finally there is nothing safe about the function since the size of the string is not passed in so you just have to make sure you allocate enough space before hand.</p>

<pre><code>void concat(char *str, const char *ch, int num)
{
    //This is function not safe since you do not
    //know how much space str has allocated
    str += strlen(str);
    *str = *ch; ++str;

    if(num &lt; 0)
    {
        *str = '-';//Add the -
        ++str;
        num *= -1; //Make the number positive
    }

    //Determine the number of digits first
    //because you need to add characters backwards
    int digits = 0, tmpnum = num;
    while (tmpnum) {
        tmpnum /= 10;
        ++digits;
    }

    while(digits--)
    {
        str[digits] = '0' + num % 10;
        num /= 10;
    }
}
</code></pre>

<p>Usage:</p>

<pre><code>char *runner = new char[20]();
//or
//char *runner = (char*)calloc(20, 1);    

concat(runner, ""a"", 10);
concat(runner, ""b"", 20);
concat(runner, ""c"", -30);

delete [] runner;
//or if you used calloc
//free(runner);
</code></pre>

<p>I did this assuming this was a homework assignment, there are easier/safer ways to accomplish this especially using <code>C++</code> which is what your question was tagged.</p>
",0
13730929,13730868,0,"<p>Well, the code does what you ask of it. </p>

<p>For this to work you need to find the end of the first string and then add to it: </p>

<pre><code>void concat(char *str, char *ch, int num)
{
    str += strlen(str); /* make sure we start adding at the end of str */
    *str= *ch; ++str;
    while (num&gt;0) {
        *str = '0' + num % 10;
        num /= 10;
        ++str;
    }
}
</code></pre>

<p>But now you must make sure str[0] is 0 at the beginning</p>
",0
13730933,13730868,2,"<p>I'm changing my answer altogether.  Put this in the beginning of your function:</p>

<pre><code>void concat(char * str, const char * ch, int num) {
    while (*str) {
         ++str;
    }
</code></pre>

<p>Then keep the rest the same.  This is really what concat should look like.  Just make sure that runner[0] == 0 before calling it the first time!  And add the following code to the end of your function, before the final brace:</p>

<pre><code>    *str = 0;
}
</code></pre>
",3
13738925,13730868,1,"<p>using &amp; should be ok
or actually in c, you can use **, two ways.</p>
",0
13401878,13401709,0,"<p>Here's a very simple example:</p>

<pre><code>#define MAX_COUNT 256
</code></pre>

<p>The preprocessor will replace every occurrence of <code>MAX_COUNT</code> in the relevant scope with <code>256</code> before passing it off to the compiler.</p>

<p>In a broad sense you can think of it as macroing:</p>

<pre><code>#define FOO(a,b) a*b+a+b
</code></pre>

<p>will replace <code>FOO(a,b)</code> with <code>a*b+a+b</code></p>

<p>For more reading on the preprocessor, you can also consult this <a href=""http://www.cprogramming.com/tutorial/cpreprocessor.html"" rel=""nofollow"">page</a>.</p>
",0
13401902,13401709,1,"<p>That's a somewhat fuzzy statement, but formally the preprocessor is a separate phase of compilation, and back in the olden days the preprocessor was a separate program that did its thing before the compiler got to see the code. Most compilers have an option to only do the preprocessing, which is sometimes helpful for figuring out where some code has gone astray. But under the ""as if"" rule, the compiler doesn't <strong>have to</strong> do preprocessing in a separate phase; it just has to produce the same result as if it had done that.</p>
",0
14733004,14732960,1,"<p><code>a/3 = b</code> should be <code>b = (double)a/3</code>. And it only divides once!
And as iamnotmaynard says: You have to print b not a: <code>cout &lt;&lt; ""The result of this is:""&lt;&lt; b &lt;&lt; endl;</code>.</p>
",0
14733017,14732960,6,"<p>You seem to be under the impression that the resulting answer of <code>1/3</code> will be <code>0.33333333333...[to infinity]</code>.</p>

<p>That is not correct. ?Floating-point numbers only have limited accuracy, and the resulting value would only be out to about 20 digits or so, <strong>not</strong> an infinite number of digits.</p>

<p>Variable <code>b</code> will have all the precision a variable of type <code>double</code> can handle.  There's no easy way to limit that.<p>However, if you only want to limit how much you display, you can restrict the output shown by <code>cout</code>:</p>

<pre><code>cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; b &lt;&lt; endl;
</code></pre>

<ul>
<li><p><code>fixed</code> will cause the output to use Fixed Point notation (the other option is <code>scientific</code>).</p></li>
<li><p><code>setprecision</code> will control the maximum number of digits to be shown.</p></li>
</ul>

<p>The output in this case should be:</p>

<pre><code>0.333
</code></pre>

<p>for a total of 4 digits (1 before the decimal place, and 3 more after it).</p>
",2
14733029,14732960,1,"<p><code>double</code> is a fixed-size type (8 bytes on most systems). So it only stores numbers to a certain precision. There's no need to fear ""infinite division"" (in the sense that 1/3.0 has no finite decimal representation).</p>

<p><strong>Edit</strong> (based on comments below)</p>

<p>If you are actually looking for an arbitrary-precision real number representation, you have to use a library for that, such as <a href=""http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html"" rel=""nofollow"">Boost.Multiprecision</a>.</p>
",13
14733318,14732960,1,"<p>In mathematics, 1/3 has an infinite decimal representation. In computers, there are no infinite representations. <code>1/3</code> divides to integers, and the result is an integer; since an integer doesn't hold fractional parts, the result is 0. If you use doubles instead, <code>1.0/3.0</code>, the same kind of thing happens: the result is the best approximation of the mathematical result that fits in a double. So don't be afraid of it. Try it.</p>
",0
13743395,13743357,5,"<blockquote>
  <p>Will the member be created on the stack?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>If so, what happens if <code>MySecondClass</code> is created via <code>new</code>? Will this member still be on the stack?</p>
</blockquote>

<p>No. It will be stored along with the rest of the object, ""on the heap"" or wherever your free store is implemented, or wherever the object gets dynamically allocated (which could be some memory pool or something else).</p>

<p>It's worth noting here that the terms ""stack"" and ""heap"" are generally mis-used. What you're <em>really</em> asking is the following:</p>

<p><strong>Does the member have <em>automatic storage duration</em>?</strong> Yes.</p>

<p><strong>Will it do so even when the encapsulating object has <em>dynamic storage duration</em>?</strong> No &mdash; the <em>dynamicness</em> of the encapsulating object is, in a sense, ""inherited"".</p>

<blockquote>
  <p><code>[C++11: 3.7.5]:</code> The storage duration of member subobjects, base class subobjects and array elements is that of their complete object (1.8).</p>
</blockquote>

<p>The practical location in memory in either case will be the stack and the free store (""heap"") respectively, and that doesn't really matter.</p>

<p>And, by the way, <code>main</code> <em>must</em> have <code>int</code> return type.</p>
",8
13743417,13743357,1,"<p>Yes, member is created on the stack.</p>

<p>If you create a  new object of MyClass using ""new"", resources will be allocated on the heap.</p>
",0
13443678,13443654,3,"<p>For the if statements, you should be using:</p>

<pre><code>if(strcmp(response,""Pick up the gun""))
</code></pre>

<p>But in reality, all of your problems will be made much easier if you use <code>std::string</code></p>

<pre><code>#include &lt;string&gt;
using namespace std;
int main()
{
  string name;
  string response;
  getline(cin, response);
  if !(response.compare(""Pick up the gun""))
  {
    //Do stuff here for picking up gun
  }
}
</code></pre>
",12
13443794,13443654,2,"<p>Just use strcmp, read about arrays and dereferencing, and know that 'A' denotes the ASCI uppercase A where ""A"" denotes a string ie ['A','null'].</p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstring/strcmp/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstring/strcmp/</a></p>
",1
13443594,13443578,3,"<p>You're getting that error because you cannot subtract one structure from another. You will have to define an <code>operator-()</code> function for your <code>struct</code>. </p>
",3
12802130,12801963,0,"<p>You need to make your structure visible to both main.c and bin_gals.c. Modify your header bin_gals.h to something like:</p>

<pre><code> #include &lt;stdlib.h&gt; 
 #include &lt;fstream&gt; 
 #include &lt;iomanip&gt; 
 #include &lt;stdio.h&gt; 
 #include &lt;math.h&gt; 
 #include &lt;string&gt;  

 struct basic_gal { 
    double ra,dec,z,dist,fkp,nbar; 
    double cp[3]; 
    double RSD[3]; 
 }; 

 void bin_NGP(int,int*,struct basic_gal*,int); 
</code></pre>

<p>bin_gals.c then would look like </p>

<pre><code> #include ""bin_gals.h""   
 #include &lt;all_the_others&gt;   

 void bin_NGP(int NGAL_MAX, int *NGAL, basic_gal *gal, int flag) {   

 /*read in files and add data etc*/   

 }   
</code></pre>

<p>And your main file would be like the following:</p>

<pre><code>#include ""bin_gals.h""      
#include &lt;all_the_others&gt;      

struct basic_gal *gal;        
int NGAL_MAX = 200000;      

main() {      

  if(!(gal = (struct basic_gal*)malloc(NGAL_MAX*sizeof(struct basic_gal))-1))       
  printf(""memory allocation problem for galaxies\n"");      

  int NGAL =0;      
  int *ipNGAL =&amp;NGAL;      
  bin_NGP(NRAN_MAX,ipNGAL,gal,1);      
}      
</code></pre>
",1
12802066,12801963,1,"<p>You need to forward declare <code>struct basic_gal*</code> for the declaration of <code>bin_NGP()</code> as <code>struct basic_gal</code> is defined in <code>main.c</code>. However, the definition of <code>struct basic_gal</code> will need to be available to the definition of <code>bin_NGP()</code> so you should move its definition out of <code>main.c</code> into a separate module:</p>

<pre><code>/* basic_gal.h */
#ifndef BASIC_GAL_DEFINITION
#define BASIC_GAL_DEFINITION

struct basic_gal {
   double ra,dec,z,dist,fkp,nbar;
   double cp[3];
   double RSD[3];
};

#endif
</code></pre>

<p>Note, if this is C you need to use <code>struct basic_gal</code>.</p>

<hr>

<p>After edit, this is the offending line:</p>

<pre><code>if(++NGAL&gt;NGAL_MAX) { NGAL--; break; }
</code></pre>

<p>as <code>NGAL</code> is an <code>int*</code> and <code>NGAL_MAX</code> is an <code>int</code>. Dereference <code>NGAL</code>:</p>

<pre><code>if(++*NGAL &gt; NGAL_MAX) { (*NGAL)--; break; }
</code></pre>

<p>Dereference <code>NGAL</code> when using as array index:</p>

<pre><code>gal[*NGAL].ra = ra*pi/180.;
</code></pre>
",5
12832210,12831733,1,"<p>This doesn't accept a file name on the command line (just processes its standard input) but might provide some inspiration for a general approach that could be somewhat simpler:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;size_t&gt; freqs(26);

    std::for_each(std::istream_iterator&lt;char&gt;(std::cin), 
        std::istream_iterator&lt;char&gt;(),
        [&amp;](char ch) { if(isalpha(ch)) ++freqs[tolower(ch)-'a']; });

    for (int i=0; i&lt;26; i++)
        std::cout &lt;&lt; (char)('a'+i) &lt;&lt; "":"" &lt;&lt; freqs[i] &lt;&lt; ""\n"";

    return 0;
}
</code></pre>
",0
12831782,12831733,1,"<p>The problem is <code>myfile.get(t)</code> which extracts a character from the stream and gets it in <code>t</code>. Now if the read character happens to be upper-case you are iterating over the array 26 times incrementing its lower-case letter count. You need to do it just once.</p>

<p>Also you need to handle non-alpha characters in the input stream.</p>

<pre><code>while(!myfile.eof()){     
    myfile.get(t);
    if(isalpha(t) { // process only alphabets.
        if(isupper(t)) // convert upper case to lower case
            t = tolower(t);
        array[t-'a']++; // increment the count
    }
}
</code></pre>
",1
13436029,13435247,1,"<pre><code>float chi2_float(const int dim, const float* const x, const float* const y) {
   float (*chi2_float)(const int, const float*, const float*) = chi2_baseline_float;
#ifdef __SSE__
   chi2_float = chi2_intrinsic_float;
#endif
   return chi2_float(dim, x, y);
}
</code></pre>

<p>Ugly.</p>

<p>The first thing to do to fix this code is to use something other than the function name as the name of the function pointer variable. That this variable shadows the name of the function is, I think, the source of James Crow's confusion.</p>

<p>The second thing to do to fix this code is to get rid of the function pointer entirely, resulting in the code Michael Burr posted in his answer.</p>
",1
13436727,13435247,1,"<p>Michael Burr suggested the following:</p>

<pre><code>float chi2_float(const int dim, const float* const x, const float* const y) 
{
#ifdef __SSE__
    return chi2_intrinsic_float(dim, x, y);
#else
    return chi2_baseline_float(dim, x, y);
#endif
}
</code></pre>

<p>Ignoring the compiler's optimiser for a moment; this may be improved.  Mr Burr's solution uses two function calls: main() (or whatever) calls chi2_float() which then calls the appropriate implementation.  That can be reduced to just one function call with the following:</p>

<pre><code>#ifdef __SSE__
    #define chi2_float(dim, x, y) chi2_intrinsic_float(dim, x, y)
#else
    #define chi2_float(dim, x, y) chi2_baseline_float(dim, x, y)
#endif
</code></pre>

<p>The same result can likely be achieved by declaring Mr Burr's chi2_float() as ""inline"".</p>

<p>However, returning to the real world (where compilers aggressively optimise code), you would expect a good optimiser to remove the extra function call, thus rendering Mr Burr's solution to be just as fast.</p>

<p>I have posted this discussion for completeness.  Although this does not improve on Mr Burr's solution, it adds a bit more context.  Technically it ought to have been a comment, rather than a new answer, but it isn't possible to format source code in a comment.  Such is life.</p>
",1
13435271,13435247,11,"<p>The line in question is setting a variable of type function pointer to one of two other functions depending on the value of <code>__SSE__</code>.</p>

<p>It then calls the function pointed to by chi2_float and returns the result.</p>
",1
13435316,13435247,7,"<p>This:</p>

<pre><code>float (*chi2_float)(const int, const float*, const float*)= chi2_baseline_float;
</code></pre>

<p>declares a function pointer names <code>chi2_float</code> and assigned to it a pointer to the function named <code>chi_baseline_float</code>.</p>

<p>Then, if the <code>__SSE__</code> macro is defined, the pointer is reassigned with a pointer to the function <code>chi2_intrinsic_float</code>.</p>

<p>The net effect of all this is something similar to:</p>

<pre><code>float chi2_float(const int dim, const float* const x, const float* const y) 
{
#ifdef __SSE__
    return chi2_intrinsic_float(dim, x, y);
#else
    return chi2_baseline_float(dim, x, y);
#endif
}
</code></pre>
",2
13435346,13435247,1,"<p>The code of your question with some comments:</p>

<pre><code>// beginning of the definition of function chi2_float 
float chi2_float(const int dim, const float* const x, const float* const y) {
    // declare the variable chi2_float as a function pointer
    // set variable chi2_float to the address of the function chi2_baseline_float
    float (*chi2_float)(const int, const float*, const float*) = chi2_baseline_float;
// if macro __SSE__ is defined (if the compiler enables SSE instructions set)
// [this is your case because you got an error in the below line when you have commented the above line] 
#ifdef __SSE__
    // then preprocessor adds the following line that sets again the variable chi2_float (but to another function) 
    chi2_float = chi2_intrinsic_float;
#endif
    // call the function pointed by the variable chi2_float
    return chi2_float(dim, x, y);
}
</code></pre>
",2
12877366,12876985,0,"<p>The biggest problem is how you are trying use the constructor for the list in your class. If you simply remove <code>(1, 2)</code> from the list declaration in your class, it should compile. Second, if you want to call the constructor of an object in your class, I recommend this method</p>

<pre><code>class isprime{
  public: 
   isprime() : pnums(1,2) { /*nothing...yet?*/ }
   ...
   list &lt;int&gt; pnums;
   ...
</code></pre>
",1
13779258,13779199,4,"<p>You are doing an integer division i.e if width is 3 and height is 2 it'd store 1 instead of 1.5 in <code>aspect</code>. One of the values should be double to make it a double division. Following should work:</p>

<pre><code>#include&lt;iostream&gt;

using namespace std;

int main(){

    int width = 1280;
    int height = 1024;
    double aspect = (double)width / height;

    cout &lt;&lt; ""aspect ration"" &lt;&lt; aspect &lt;&lt; endl;


    return 0;

}
</code></pre>
",0
13437900,13437884,1,"<p>Create a function inside of your class the handles the deletion of its private members, maybe called <code>FreeMem(int index)</code></p>

<pre><code>void myClass::FreeMem()
{
    delete [] num1
}
</code></pre>

<p>But honestly, freeing memory of an object without the use of a destructor in this sort of a program is hazardous and downright bad practice. I would recommend freeing the memory in your destructor, so when the object terminates it frees the memory,</p>

<pre><code>myClass::~myClass()
{
    delete [] num1;
}
</code></pre>

<p>Another thing to note on, if you're only creating one value in your dynamic variable, it would be easier to write it as:</p>

<pre><code>int * pnum = new int;
//or in your class..
pnum = new int;
</code></pre>

<p>among other things, you have a lot of flaws in your program. I would recommend re-reading up on classes again.</p>
",3
13438395,13437884,2,"<p>You cannot delete just a portion of an array created with <code>new</code>. <code>new</code> allocates a block of memory which can only be <code>delete</code>ed all together.</p>

<p>If you want an object to free its own internal data you'll have to arrange for the class, which should encapsulate and hide its own internal resources, to do that itself.</p>

<p>If you want a smaller block of memory holding the array you allocated, then you must allocate a smaller block and move the contents that you wish to keep into the new block, and then delete the entire old block:</p>

<pre><code>int *arr = new int[10];

int *tmp = new int[9];
std::copy(arr+1, arr+10, tmp);
delete [] arr;
arr = tmp;
</code></pre>

<hr>

<p>You need to design your class to manage its own resources, and to handle copying or moving. Your current <code>myClass</code> allocates an array but relies on other code to handle cleaning up. This is not a good way to go about doing this, because often no other code is in a good position to do the correct thing, and even when you could you'll very frequently make mistakes.</p>

<p>Since you're allocating in the constructor you need a destructor that handles deallocation. And then since you implement one of three special operations (copy-ctor, copy-assignment, destructor) you need to consider implementing them all. (This is called 'The Rule of Three'. In C++11 it becomes 'The Rule of Five' with the addition of move-ctors and move assignment.)</p>

<pre><code>class myClass {
public:
    myClass();

    // destructor to handle destroying internal resources correctly
    ~myClass();

    // copy constructor and copy assignment operator, to handle copying correctly
    myClass(myClass const &amp;rhs);
    myClass &amp;operator=(myClass const &amp;rhs);

    // move constructor and move assignment operator, to handle moves correctly (C++11)
    myClass(myClass &amp;&amp; rhs);
    myClass &amp;operator= (myClass &amp;&amp;rhs);

private:
   int *num1; // private so external code can't screw it up

public:
   // limited access to num1
   int size() const { if (num1) return 1; else return 0; }
   int &amp;operator[] (size_t i) { return num1[i]; }
};
</code></pre>

<p>You can implement the constructor just as you did, or you could use the initializer list and C++11 uniform initialization:</p>

<pre><code>myClass::myClass() : num1(new int[1]{10}) {}
</code></pre>

<p>Now, the destructor you want depends on the semantics you want the class to have, and the particular invariants you want to maintain. 'value' semantics are the norm in C++ (if you're familiar with Java or C# those languages encourage or require 'reference' semantics for user defined types). Here's a destructor you might use if you want value semantics, and if you maintain an invariant that num1 always owns memory or is null.</p>

<pre><code>myClass::~myClass() { delete num1; }
</code></pre>

<p>Copying and moving can be handled in different ways. If you want to disallow them entirely you can say (in C++11):</p>

<pre><code>myClass::myClass(myClass const &amp;rhs) = delete;
myClass &amp;myClass::operator=(myClass const &amp;rhs) = delete;

myClass::myClass(myClass &amp;&amp; rhs) = delete;
myClass &amp;myClass::operator= (myClass &amp;&amp;rhs) = delete;
</code></pre>

<p>Or if you want to allow copying and or moving (and maintain value semantics and the invariant mentioned above) then you can implement either or both of these pairs of functions:</p>

<pre><code>myClass::myClass(myClass const &amp;rhs) : num1( rhs.size() ? new int[1]{rhs[0]} : nullptr) {}
myClass &amp;myClass::operator=(myClass const &amp;rhs) {
    if (num1)
        num1[0] = rhs[0];
}

myClass::myClass(myClass &amp;&amp; rhs) : num1(rhs.num1) { rhs.num1 = nullptr; } // remember to maintain the invariant that num1 owns the thing it points at, and since raw pointers don't handle shared ownership only one thing can own the int, and therefore only one myClass may point at it. rhs.num1 must be made to point at something else...
myClass &amp;myClass::operator= (myClass &amp;&amp;rhs) { std::swap(num1, rhs.num1); } // steal rhs.num1 and leave it to rhs to destroy our own num1 if necessary. We could also destroy it ourselves if we wanted to.
</code></pre>

<p>With this implementation you can now treat a myClass object the same as you would an <code>int</code> or any other 'value' type. You no longer need to worry about managing its internal resources; it will take care of them itself.</p>

<pre><code>int main() {
    std::vector&lt;myClass&gt; myclassvec(10);

    cout &lt;&lt; myclassvec[0][0] &lt;&lt; '\n';

    myclassvec.erase(myclassvec.begin()); // erase the first element

    cout &lt;&lt; myclassvec[0][0] &lt;&lt; '\n'; // access the new first element (previously the second element);
}
</code></pre>
",0
13484357,13484248,0,"<p>The way to think about Abstract Data Types is that the data is defined by what it does (its signature) and not what it consists of.  So really, your implementation is not automatically high level or low level just because you used a class; it's high level or low level if:</p>

<ol>
<li>The user need not muck about with low level operations to use it.</li>
<li>The user uses the class solely in terms of its interface (black box).</li>
</ol>

<p>When designing your class, your should put yourself in the shoes of a user who does not know or want to know anything about the implementation.  To the user, the class is just something on which they call methods and it gets the job done.  How it's done is a mystery.</p>

<p>Let that be your guiding principle.  The implementation details then are the things you use to make them happen, and since they are not exposed to the user, they don't have anything to do with the ADT.  The ADT is in the interface.</p>

<p>A more concrete test you can apply is to try to use it yourself and see how high level is.  Write a separate program to use polynomials, instantiate the class, use it, then ask yourself whether it's high level enough.  Revise as necessary until you get the right interface.</p>
",0
13484409,13484248,1,"<p>An ADT is data along with a collection of operations that you can perform on that data.
A low level or ""C"" ADT will see it implemented as a collection of functions that receive a <strong>handle</strong> of some sort to the data, along with other required parameters, and do the operation they represent.</p>

<p>In C++, however, things become more simple because those functions that represent operations can be bound to the data itself, via a class defintion.</p>

<p>Now, in your example, let us think about the sort of operation that can be performed on a polynomial; Let's try addition:</p>

<p>In C you'd define a function like this:</p>

<pre><code>Poly poly_add (Poly p1, Polyp2)
{
/*addition code be here*/
}
</code></pre>

<p>How would we do it in C++?! Well, we want the method to be bound to the object, so we do something like this:</p>

<pre><code>class Polynomial
{
  ....
public:
  Polynomial add(Polynomial&amp; p2)
  {
    // addition code be here
  }
};
</code></pre>

<p>This will be called like this <code>p3 = p1.add(p2)</code>.</p>

<p>So to answer your question, your global methods that belong to the class can operate on the ""Low Level"" struct directly, and that's where you'd want to put that code.</p>

<p>You should also note the <code>Poly</code> and <code>Term</code> aren't pointers, but types. They are both the type of pointer that points to a <code>term_t</code> struct.</p>

<p>Naturally there is a lot of room for imporvment (i.e. we can make the binary operations friend functions, and even better, overloaded operators).</p>
",3
12858722,12858426,1,"<pre><code>if(**it1 &lt; **it2) return true;
it2++;
</code></pre>

<p>is not very good because in your for loop you don't check if it2 reach the end of list.</p>

<p>a version that should work will be :</p>

<pre><code>bool GrammarProduction::operator&lt;(const GrammarProduction&amp; other) const{
  if (mLhs &lt; other.Lhs()) return true;
  if (mRhs.size() &lt; other.Rhs().size()) return true;
  std::vector&lt;GrammarSymbol*&gt;::const_iterator it1, it2;
  it2 = other.Rhs().begin();
  it2End = other.Rhs().end();
  for(it1 = mRhs.begin(); it1 != mRhs.end(); it1++){
    std::cout &lt;&lt; (*it1) &lt;&lt; std::endl;
    if (it2 == it2End ) return true;
    std::cout &lt;&lt; (*it2) &lt;&lt; std::endl;
    if(**it1 &lt; **it2) return true;
    it2++;
  }
  return false; 
</code></pre>

<p>}</p>
",1
12858815,12858426,2,"<p>You should check for <code>it2 == other.Rhs().end()</code> in the loop. If you increment the iterator past the last element, dereferencing it is invalid and will likely cause a segmentation fault.</p>
",1
12860378,12858426,2,"<p>You're invoking undefined behaviour. Since your <code>Rhs()</code> function returns the vector <em>by value</em>, it's destroyed at the end of the full expression:</p>

<pre><code>//          vvvvv -- created here
it2 = other.Rhs().begin();
//          gone here -- ^
</code></pre>

<p>This makes <code>it2</code> a <em>dangling iterator</em>, which is basically the same as a dangling pointer. Dereferencing this iterator will cause UB. To fix, make the return type a reference:</p>

<pre><code>std::vector&lt;GrammarSymbol*&gt;&amp; Rhs(){ return mRhs; } // depending on your needs
std::vector&lt;GrammarSymbol*&gt; const&amp; Rhs() const{ return mRhs; }
</code></pre>
",0
13446924,13446917,7,"<p>It means exactly what it says. There's no guarantee that a <code>long long</code> can store more numbers than an <code>int</code>. It's <em>at least as big</em>, but it can be the same.</p>

<blockquote>
  <p>I know that int has a maximum of 2^31-1 and long long has a maximum of 2^63-1</p>
</blockquote>

<p>This can be true for some platform, with some compiler, but it's not always the same. C++ doesn't guarantee either.</p>

<h3>3.9.1 Fundamental types [basic.fundamental]</h3>

<blockquote>
  <p>2) There are five standard signed integer types : ¡°<code>signed char</code>¡±,
  ¡°<code>short int</code>¡±, ¡°<code>int</code>¡±, ¡°<code>long int</code>¡±, and ¡°<code>long long int</code>¡±. In this list,
  <strong>each type provides at least as much storage as those preceding it</strong> in
  the list. [...] (emphasis mine)</p>
</blockquote>
",21
13447076,13446917,2,"<p>The C standard specifies two relevant criteria:</p>

<ul>
<li><p><code>sizeof(char) ¡Ü sizeof(short) ¡Ü sizeof(int) ¡Ü sizeof(long) ¡Ü sizeof(long long) ¡Ü sizeof(uintmax_t)</code></p>

<p>This is specified indirectly in ISU/IEC 9899:2011, ¡ì6.2.5 Types, ?8: <em>For any two integer types with the same signedness and different integer conversion rank
(see 6.3.1.1), the range of values of the type with smaller integer conversion rank is a
subrange of the values of the other type.</em></p></li>
<li><p>The minimum permitted value for the maxima of the types (ISO/IEC 9899:2011, ¡ì5.2.4.2.1 Sizes of integer types <code>&lt;limits.h&gt;</code>):</p>

<ul>
<li><code>SCHAR_MAX</code> ¡Ý 127 // 2<sup>7</sup>-1</li>
<li><code>SHRT_MAX</code> ¡Ý 32,767 // 2<sup>15</sup>-1</li>
<li><code>INT_MAX</code> ¡Ý 32,767 // 2<sup>15</sup>-1</li>
<li><code>LONG_MAX</code> ¡Ý 2,147,483,647 // 2<sup>31</sup>-1</li>
<li><code>LLONG_MAX</code> ¡Ý 9,223,372,036,854,775,807 // 2<sup>63</sup>-1</li>
</ul></li>
</ul>

<p>The quote is formally correct; it is possible to devise systems where <code>long</code> does not store a larger range than <code>int</code> ¡ª indeed, this is the case on most 32-bit systems (all the ones I know of), and also true on Windows 64.  It is less likely to be accurate w.r.t <code>long long</code>; I know of no system where <code>sizeof(int) == sizeof(long long)</code> (and, because of the inequality quoted, <code>sizeof(int) == sizeof(long)</code>).  On most Unix 64-bit systems, <code>sizeof(int) == 4</code>, <code>sizeof(long) == 8</code>, and <code>sizeof(long long) == 8</code>; on Windows 64, <code>sizeof(long) == 4</code> and only <code>long long</code> (or <code>__int64</code>) is a 64-bit type.</p>
",2
13781557,13781505,4,"<p>Looks like you meant for <code>MaxCraft = 10;</code> (in your default constructor) to actually be <code>maxCraft = 10;</code>. As @chris says in the comments, it appears that you're using some (evil, evil) C++ extension that allows implicitly-typed variables, so the <code>MaxCraft = 10;</code> line is simply defining a new variable named <code>MaxCraft</code>.</p>
",12
16375334,16375223,1,"<p>Don't think to C++ object as OOP or Java. Example is not a refernce. It is the object itself. It exist because it has been decalred.</p>

<p>Checking for null (or making it null) can make sense if you can define a ""state"" for that object that you define to be null.</p>

<p>bor example you can define an</p>

<p><code>explicit operator bool() const</code> method and return true when the object members have values you define representing an ""non empty example"".</p>

<p>Checking for a null <code>Example actualexample</code>, at this point is just <code>if(!actualexample)</code></p>
",0
16375349,16375223,0,"<p>Instead of making a method that returns a value, simply rewrite the operator <code>==</code>, and make a control there, so if you do <code>if(example ==NULL)</code> the overloaded method for the control will return the desired boolean.</p>
",0
16375381,16375223,1,"<p>The other option is to use the <a href=""http://en.wikipedia.org/wiki/Null_Object_pattern"" rel=""nofollow"">Null Object Pattern</a>.  The Null Object Pattern basically allows yo to return a fully constructed object that you identify as null.</p>

<p>The example in the wikipedia article linked gives a good example of it in action:</p>

<pre><code>class animal 
{
public:
  virtual void make_sound() = 0;
};

class dog : public animal 
{
  void make_sound() { cout &lt;&lt; ""woof!"" &lt;&lt; endl; }
};

class null_animal : public animal 
{
  void make_sound() { }
};
</code></pre>

<p>Remember doing something like creating a specific ""Null Object"" (ie defining a global <code>Example kNullExample;</code> somewhere) is not a good solution because if you ever assign it to another Example object (ie <code>Example newObject = kNullExample;</code>) you won't be able to identify the fact the object is no longer null.  </p>

<p>Another option would be to store a boolean value somewhere in the object and write an ""IsNull()"" function.  This is only really a solution when you can't get your class to become virtual (mapping binary files, for example) or if you really can't afford the virtual table jump.</p>
",0
16375293,16375223,0,"<p>You cannot assign NULL pointer in that way, because the return object is not a pointer. If you don't want use pointers, a posible option may be the use of a specific NULL Example object. What I mean is check with a custom attribute of this class if the object instance is what you consider NULL. May be you can use the empty string passed in the constructor:</p>

<pre><code>exampleNull = Example example(""""); 
</code></pre>

<p>and check the string attribute to validate your ""null"" object</p>

<p>But remember: NULL only can be assigned to a pointer type</p>
",0
16375322,16375223,2,"<ol>
<li><p>Use pointers, <code>Example *ex = NULL</code>.</p></li>
<li><p>Construct a default <code>null_example</code> and overload the <code>==</code></p>

<p></p>

<pre><code>Example e;
if (e == null_example) {
    e.init();
}
</code></pre></li>
<li><p>but you could just provide a <code>is_init()</code> function.</p>

<pre><code>Example e;
if (!e.is_init()) {
     e.init();
}
</code></pre></li>
<li><p>you <code>get_example</code> could be something like:</p>

<pre><code>void get_example(Example &amp;e) {
     // method2 or method3
}
</code></pre></li>
</ol>
",0
13446958,13446941,4,"<p>Use an asterisk as precision, and place the wanted expression before the format argument:</p>

<pre><code>sprintf(s, ""%*s"", d, ""abc"");
</code></pre>
",2
16382800,16382775,2,"<pre><code>unsigned char* output;
rc4(data,pwd,output); 
</code></pre>

<p>not</p>

<pre><code>unsigned char output[256];
rc4(data,pwd,*output); 
</code></pre>

<p>But like the comments above say, why use pointers when you don't understand pointers? This code could be written more simply and with fewer bugs by using <code>std::string</code> and/or <code>std::vector</code>.</p>
",2
16383027,16382775,0,"<p>That example of yours is far from minimal, please reduce your code before posting. Anyway, the point is that an array is implicitly converted to a pointer to the first element when passed to a function. Assuming this code:</p>

<pre><code>void f(unsigned char*);
unsigned char array[100];
f(array);
</code></pre>

<p>This is equivalent to:</p>

<pre><code>void f(unsigned char*);
unsigned char array[100];
unsigned char* ptr = &amp;array[0];
f(ptr);
</code></pre>

<p>The point is that when passing a reference, you imply that the reference could be modified. This pointer here is an unnamed temporary created by the compiler though, so any modifications to it will be lost. For that reason, this conversion is forbidden, which is what the error is all about.</p>

<p>You don't want to pass an array but a real, non-temporary pointer. Also, you want to use <code>delete[]</code> on it when done. However, as others pointed out, using containers like vector or string are much cleaner ways. Get a good C++ book, these things should be explained there!</p>
",0
18196001,18195812,1,"<p>Since you are using <code>unique_ptr&lt;BaseComponent&gt;</code>, naturally there could be times when the conversion fails: the insertion of new data in the vector and consumption of that data are done in unrelated places, and in such a way that the compiler cannot enforce it.</p>

<p>Here is an example of an invalid cast:</p>

<pre><code>struct AnotherComponent : public Component&lt;AnotherComponent&gt;
{
    virtual ~AnotherComponent () {}
};

std::vector&lt;std::unique_ptr&lt;BaseComponent&gt;&gt; mComponents;
mComponents.emplace_back(new AnotherComponent);
// !!! This code compiles, but it is fundamentally broken !!!
auto *pos = mComponents[0]-&gt;as&lt;PositionComponent&gt;();
pos-&gt;x = 1337;
</code></pre>

<p>In this respect, using <code>dynamic_cast</code> would provide better protection against incorrect usage of the <code>as&lt;T&gt;</code> function. Note that the incorrect usage may not be intentional: any time the compiler cannot check the type for you, and you have a potential type mismatch, you should prefer <code>dynamic_cast&lt;T&gt;</code></p>

<p>Here is a <a href=""http://ideone.com/87DMco"" rel=""nofollow"">small demo</a> to illustrate how <code>dynamic_cast</code> would offer you a degree of protection.</p>
",0
18196003,18195812,1,"<p>You should always use <code>dynamic_cast</code> when casting polymorphic objects that are derived from a baseclass. </p>

<p>In a case where <code>mComponents[0]</code> is not <code>PositionComponent</code> (or a class derived therefrom), the above code would fail. Since the whole purpose of having <code>mComponents</code> hold a pointer to <code>BaseComponent</code> is so that you can put other things than <code>PositionComponent</code> objects into the vector, I'd say you need to care for that particular scenario. </p>

<p>In general, it's a ""bad smell"" when you are using <code>dynamic_cast</code> (or generally casting objects that are derived from a common baseclass). Typically it means the objects should not be held in a common container, because they are not closely enough related.</p>
",1
18196007,18195812,2,"<p>The code that you present is correct and well formed, but the cast in general is not safe. If the actual object was not a <code>PositionComponent</code>, then the compiler would very gladly assume that it is and you would be causing undefined behavior.</p>

<p>If you replace the cast with <code>dynamic_cast</code>, then the compiler will generate code that at runtime verifies that the conversion is valid.</p>

<p>The real question is why would you need this. There are reasons, but more often than not the use of casts are an indication of issues with your design. Reconsider whether you can do <em>better</em> (i.e. redesign your code so that you don't need to go explicitly converting types)</p>
",3
18196081,18195812,3,"<p>In your case there is no way to tell statically whether <code>this</code> is the right type or not.
What you may want is a CRTP (Curiously recurring template pattern):</p>

<pre><code>template &lt;class T&gt;
struct BaseComponent
{
    T* as()
    {
        return static_cast&lt;T*&gt;(this);
    }

    virtual ~BaseComponent() {}
};

template &lt;typename T&gt;
struct Component : public BaseComponent&lt;T&gt;
{
    virtual ~Component() {}
};

struct PositionComponent : public Component&lt;PositionComponent&gt;
{
    float x, y, z;

    virtual ~PositionComponent() {}
};
</code></pre>

<p>This way you can do:</p>

<pre><code>auto x = yourBaseComponent.as();
</code></pre>

<p>and have the right child type statically.</p>
",1
13463959,13463838,1,"<p>this is <strong>criminal</strong> :</p>

<pre><code>void A::addB()
{
      B* b;

      bs.push_back(b);
}
</code></pre>

<p>B* b <strong>is NOT initialized</strong>.
Having a reference on it in you container is criminal: dereferencing this address doesnt make sense and is undefined behaviour / crash.</p>

<p>you should assign this way:</p>

<pre><code>{
      B* b = new B;

      bs.push_back(b);
}
</code></pre>

<p><strong>Edit</strong>: as Kevin commented below as is there is still a memory leak. You'd rather use a container of <code>std::shared_ptr&lt;B&gt;</code>. This way the B oject will be deleted when nobody keeps a shared_ptr pointing to it.</p>
",1
14244013,14243778,3,"<p>Two things: Firstly you're defaulting <code>urlRegex</code> to <code>NULL</code>. Did you mean this to be empty string? If so, don't bother as that's the default for a string anyway. Then when you check for <code>urlRegex</code> being NULL, instead do:</p>

<pre><code>if(!urlRegex.empty()) { // ...
</code></pre>

<p>Secondly, you're trying to add <code>webServerPort</code> (an int) onto a std::string. That's not legal. If you really want to do this then the way to go about it would be:</p>

<pre><code>std::ostringstream ss;
ss &lt;&lt; ""http://0.0.0.0:"" &lt;&lt; webServerPort &lt;&lt; ""fake_settings/?file="" &lt;&lt; responseFile;
std::string url = ss.str();
</code></pre>
",0
14169197,14168737,0,"<p>Change from member function <code>A::OtherFunction()</code>  to stand alone function <code>OtherFunction(A*)</code>. </p>
",0
14168755,14168737,0,"<p>Both .cpp files should include both .h files.</p>

<p>A simplified example:</p>

<pre><code>// A.h
void funcA();

// A.c
#include ""A.h""
#include ""B.h""
void funcA() { funcB(); }

// B.h
void funcB();

// B.c
#include ""A.h""
#include ""B.h""
void funcB() { funcA(); }
</code></pre>

<p>Remember, unless you're dealing with templated classes, <em>declarations</em> go in <em>header files</em>, <em>definitions</em> (implementations) go in <em>source files</em>.</p>
",0
14168761,14168737,0,"<p>As long as you are <strong>using only pointers</strong> in your class definitions, you can <strong>forward declare the other class</strong> in front of each class in the .h files and then <strong>include both .h</strong> files in your .cpp files. </p>

<p><strong>Move any code</strong> from the definition of the class in the .h files to the definitions of the functions in <strong>the .cpp</strong> to reduce any dependencies. i.e Define all functions using other class details in the .cpp files.</p>
",0
14168775,14168737,1,"<p>If you need anything about A or B which is not just assigning a pointer of their type then you <strong>MUST</strong> move the related code in a .cpp file since you can't include them in a circular way. Solution is like the following:</p>

<p><strong>A.h</strong></p>

<pre><code>class B; // forward declaration

class A {
  B* b;

  // legal, you don't need to know anything about B
  void set(B* b) { this-&gt;b = b; } 

  // must be implemented in .cpp because it needs to know B
  void doSomethingWithB(); 
};
</code></pre>

<p><strong>A.cpp</strong></p>

<pre><code>#include ""A.h""
#include ""A.h""

void A::doSomethingWithB() {
  b-&gt;whatever();
</code></pre>

<p><strong>B.h</strong></p>

<pre><code>class A

class B {
  void methodWithA(A* a);
};
</code></pre>

<p><strong>B.cpp</strong></p>

<pre><code>#include ""B.h""
#include ""A.h""

void B::methodWithA(A* a) {
  a-&gt;whatever();
}
</code></pre>
",0
14151616,14151602,4,"<p>You can use std::map for readability and a little efficiency as well, though in your case efficiency is of small matter</p>

<pre><code>std::map&lt;int,int&gt; mapping;
.... //populate 
cout &lt;&lt;mapping[200]; //170
</code></pre>

<p>This is only 1 way (Array 1 -> Array 2) though. Im not sure if any easier way to do the other way, but create a second map.</p>

<p>To support reverse lookup, or going from (Array 2 -> Array 1), <a href=""https://stackoverflow.com/questions/5749073/reverse-map-lookup"">Reverse map lookup</a> suggests using <a href=""http://www.boost.org/doc/libs/release/libs/bimap/doc/html/index.html"" rel=""nofollow noreferrer"">Boost.Bimap</a></p>
",2
14152848,14151602,1,"<p>According to me there are 2 ways of doing it both have already been suggested;</p>

<ol>
<li><p>put the both arrays in a map as key pair value and traverse map to find the corresponding value or key.</p></li>
<li><p>Traverse the array for which the input is there and calculate the index. Get the value for that index int he other array.</p></li>
</ol>

<p>I would go for the second solution as it easier. Moreover with only 50 elements in a static array you don't need to worry about performance.</p>
",2
14741323,14741224,3,"<p>If you can't think of a good algorithm, try this technique:</p>

<ol>
<li>Run an example using pencil and graph paper.</li>
<li>Run an example again, this time write down each detailed step you
perform.</li>
<li>Run an example again, using your steps.  Adjust as necessary.</li>
<li>Convert your steps into code.</li>
</ol>

<p>Using this technique, you can come up with more appropriate questions to search on Stackoverflow, such as ""How do I implement a square area of memory / matrix?""  </p>

<p>Or ""How do I use a debugger?""</p>

<p>Or ""Here is the smallest program that recreates my issue of ...., what am I doing wrong?"" </p>

<h2>Edit 1: (to advance my S.O. reputation)</h2>

<p>Looks like, from the requirements, that you will need at least two functions:  Set a row to the given value or set a column to the given value.  </p>

<p>Let us start with something small like a 4x4 matrix.
And use the command: Set Row 1 0 // Set Row 1 to all zeros.
Remember that C++ indexes from 0 to N-1 not 1 to N as the requirements are, so we'll have to subtract one from our row number.
Let us use the notation: <code>board[row][column]</code> to represent a cell on the board.
By hand:</p>

<pre><code>  board[0][0] = 0;
  board[0][1] = 0; // Note the incrementing column numbers.
  board[0][2] = 0;
  board[0][3] = 0; // Note the last column index is 3 not 4.
</code></pre>

<p>Looking at the above code, we can note a pattern, namely, the column index is changing each time, by 1.  So we can put this into a loop:</p>

<pre><code>  Set column to zero.
  While column is less than 4 do:
      board[0][column] = 0;
      column = column + 1;
      end-while
</code></pre>

<p>The next step is to turn this into some code:  </p>

<pre><code>  unsigned int column;
  unsigned int board[4][4];
  for (column = 0; column &lt; 4; ++column)
  {
       board[0][column] = 0;
  }
</code></pre>

<p>Since the the <code>Set Row</code> command allows for a variable row index and a variable row value, we make those variables and insert them into our code:  </p>

<pre><code>unsigned int row = 0;
unsigned int value = 0;
unsigned int column;
unsigned int board[4][4];
for (column = 1; column &lt; 4; ++column)
{
    board[row][column] = value;
}
</code></pre>

<p>We could make this into an free standing function by providing a function signature:  </p>

<pre><code>void Set_Row(unsigned int&amp; array[4][4],
             unsigned int  row,
             unsigned int  value)
{
   // Insert above code fragment here.
}
</code></pre>

<p>Next, make functions for the other commands.<br>
Create a <code>main</code> function to read the commands.<br>
Run the program, notice where any issues are, such as being able to declare a matrix of any size at run-time.<br>
Add in code to resolve the issues.<br>
Repeat.</p>
",3
14866026,14865998,1,"<p>At least one error is:</p>

<pre><code>IntervalSet&lt;IntType&lt;();
                   ^^?
</code></pre>

<p>should be:</p>

<pre><code> IntervalSet&lt;IntType&gt;();
</code></pre>
",0
14866182,14865998,0,"<p>It looks like you are defining a template function in a cpp file.</p>

<p>Template functions must be defined and implemented in header files. There are several questions concerning this on Stack Overflow, e.g. <a href=""https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file"">Why can templates only be implemented in the header file?</a></p>
",3
15855224,15855132,2,"<ul>
<li><p>Is the code at file scope?</p>

<p>The answer appears to be yes given the updated code fragment.</p></li>
<li><p>If so, you can't have random assignments like <code>LPVar[0] = &amp;GlobalVar;</code> written at file scope. You can only have declarations (without initializers) or definitions (optionally with initializers) at file scope.</p></li>
</ul>

<p>In your question, this works (as indeed it should), because there are two variable definitions with initializers.</p>

<pre><code>int GlobalVar = 5;
int *LPVar[] = {&amp;GlobalVar};
</code></pre>

<p>This code does not work (as indeed it shouldn't), because the third line is an assignment statement and not a declaration or definition:</p>

<pre><code>int GlobalVar = 5;
int *LPVar[];          // Declaration, not definition
LPVar[0] = &amp;GlobalVar; // Assignment is not allowed outside a function body
</code></pre>

<p>Variant:</p>

<pre><code>int GlobalVar = 5;
int *LPVar[1];         // Definition without initializer
LPVar[0] = &amp;GlobalVar; // Assignment is not allowed outside a function body
</code></pre>
",0
13696945,13696932,1,"<p>You initialize it in the constructor member initialization list:</p>

<pre><code>class X
{
public:
    X() : CC1(25) {}  // &lt;--- here
    const char CC1;       
    static const int SCI = 50; 
} ;
</code></pre>

<p>But if it's <code>25</code> for all instances, why not make it <code>static</code> as well? Is it in your requirements to waste memory?</p>
",0
13704318,13703800,3,"<blockquote>
  <p>Supposedly, C++11 provides some new ""move"" functionality through
  rvalue references. Could those help?</p>
</blockquote>

<p>Yes, if the compiler doesn't use RVO for any reason then it will use a move in this case as std::vector has a move operator and it's applicable when returning a single variable like this. Your original code should just do this when compiler with a c++11 compiler without any changes.</p>
",2
13704047,13703800,0,"<p>One old school option is to <strong>pass the vector as a reference to the function</strong> and make the changes as you need it. </p>

<pre><code>void foo(vector&lt;string&gt; &amp;vec){
...

foo(bar);
</code></pre>

<p>On the other hand, move semantics as i understand it should do exactly what you want, it just might happen without any change to your code, you can check it by stepping through with a debugger, let me read further as well.</p>

<p>Edit: <a href=""https://stackoverflow.com/questions/9152798/c11-move-copy-construction-ambiguity"">This question</a> seems to indicate your original code should work as a move operation automatically.  <a href=""http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html"" rel=""nofollow noreferrer"">This Post</a> seems to have more information, but I am a little too sleepy to grasp everything..</p>
",0
14191140,14191119,3,"<p>Case 1: When you <strong>return <code>b</code> by value</strong> the local variable <code>b</code> is constructed using the copy constructor. All but one copy is optimized away by <a href=""http://en.wikipedia.org/wiki/Return_value_optimization"" rel=""nofollow"">Return Value Optimization</a>. The destruction of the local variable <code>b</code> triggers the destructor.</p>

<p>Case 2: When you return <code>&amp;b</code> all you are returning is a <strong>pointer to <code>b</code></strong> and so there is <strong>no destruction necessary</strong>.</p>

<p>Edit: <a href=""http://liveworkspace.org/code/2yMQdg%244"" rel=""nofollow"">The code</a> shows the destructor being called without a corresponding call to the constructor. This is because the function return copy is happening through the copy constructor.</p>

<p>Edit2: @ZarShardan is correct - the ""Many copies"" I refered to would likely not exist thanks to <a href=""http://en.wikipedia.org/wiki/Return_value_optimization"" rel=""nofollow"">Return Value Optimization</a>. </p>
",6
14191186,14191119,-1,"<p>Object a is never deleted, so neither its own destructor nor its member object(s) destructor(s) is(are) called. </p>

<p>Try adding </p>

<pre><code>delete a; 
</code></pre>

<p>in the end of your function fn()</p>

<p>or better use std::unique_ptr instead of a bare pointer. That's better design in case your Query member function throws an exception (RAII stuff) </p>
",2
14191195,14191119,0,"<p>I don't see you creating a <code>new</code> instance of <code>B</code> in the second case, thus the pointer that A holds as a member would be cleaned up with <code>A</code>'s destructor and since a constructor in <code>B</code> was never invoked a destructor won't be invoked either.</p>
",0
14191214,14191119,1,"<ul>
<li><code>a</code> will never get deleted, so no destructors for it or its members.</li>
<li><code>a-&gt;b</code> will be constructed using the default constructor, so that's the constructor call you see.</li>
<li><code>B b = a-&gt;Query();</code> will be created using the copy constructor, which doesn't print anything.</li>
<li>At the end of <code>fn</code>, the local <code>b</code> will go out of scope, so that's your destructor call.</li>
</ul>

<p>Things might become clearer if you add debug code for the copy constructor, if you have all debug code print the value of <code>this</code>, and if you eventually delete <code>a</code> to see those destructor calls as well.</p>
",0
13760814,13760336,3,"<p>As an addition to what have already been said, I would say that you could reduce the amount of code. As anyway you put chars into your stack, why not having a <code>std::stack&lt;char&gt;</code>?</p>

<p>You could save the braces into another string, to automatically compare it using one of the <a href=""http://en.cppreference.com/w/cpp/algorithm"" rel=""nofollow"">std::algorithms</a></p>

<pre><code>const std::string openingBraces(""{[("");
const std::string closingBraces(""}])"");

if (std::find(openingBraces.begin(), openingBraces.end(), currentChar) != openingBraces.end())
    yourStack.push(currentChar);
else if (std::find(closingBraces.begin(), closingBraces.end(), currentChar) != closingBraces.end())
{
    // check if currentChar is matching the one on top of your stack
}
</code></pre>

<p>I haven't written everything as it's always better to find answers by yourself.</p>
",0
13760853,13760336,1,"<blockquote>
  <p>but it doesn't seem to do anything</p>
</blockquote>

<p>It does do something. It prints <code>This program checks brace ([{}]) matching in a string.</code>.</p>

<p>You are calling <code>checkBraces (""{1+1}"")</code> but you aren't doing anything with the returned value. Since this call can be optimized away, you are in a sense correct that your program doesn't seem to do anything.</p>

<p>So make it do something. Print the string that is to be tested, then print the result of the test. Once you have done that, you should test, and when you're done with that, you should test some more. Don't just test easy cases such as <code>{i+1}</code>. Test convoluted cases that should pass, and also test cases that should fail.</p>

<p>Learning how to test and learning how to debug are just as important skills (if not more important skills) as is learning how to write code. </p>
",1
13760413,13760336,6,"<p>What makes you think it doesn't do anything? It does. It checks for braces, but you're not doing anything with the return of <code>checkBraces</code>, which, btw, should return a <code>bool</code>, not an <code>int</code>.</p>

<p>Did you perhaps meant something like:</p>

<pre><code>if (checkBraces (""{1+1}""))
   cout &lt;&lt; ""matching"";
else
   cout &lt;&lt; ""not matching"";
</code></pre>

<p>Pro-tip: <strong>learn how to use a debugger</strong>. You should learn how to debug before you start coding anything more than a ""hello world"".</p>
",5
13760436,13760336,2,"<p>Minimum you should do is to print the outcome of checkBraces.</p>
",0
13724181,13723868,8,"<p>The <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms646273%28v=vs.85%29.aspx"" rel=""noreferrer"">MOUSEINPUT</a> structure has three members that you aren't initializing - <code>dy</code>, <code>mouseData</code>, and <code>time</code>. Since the documentation doesn't mention default values, I assume the program is free to initially fill those members with whatever junk it wants. You should explicitly set the values to avoid this.</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;winable.h&gt;

int main()
{
    INPUT joyInput;
    joyInput.type = INPUT_MOUSE;
    joyInput.mi.dx = 10;
    joyInput.mi.dwFlags = MOUSEEVENTF_MOVE;

    joyInput.mi.dy = 0;
    joyInput.mi.mouseData = 0;
    joyInput.mi.time = 0;

    SendInput(1, &amp;joyInput, sizeof(INPUT));
    return 0;
}
</code></pre>
",0
14743485,14743311,0,"<p>You're weirdly equating array integer values in a sort of string context.  That usually means base-10 math.</p>

<p>Try:</p>

<pre><code>int val = 0;
do {
    val = 10 * val + areaInt[i];
    areaCheck = isRegistered(file, val);
    if (areaCheck != 1)
        i++;
} while (areaCheck != 1);
</code></pre>

<p>On the first pass, <code>val</code> will be the value of <code>areaInt[0]</code>;  On the second pass, it will be <code>areaInt[0]</code> followed by <code>areaInt[1]</code> (e.g. 0 and 1 become 1, 1 and 2 become 12).  And so on.</p>
",4
14743416,14743311,0,"<p>Have the function take in a list (vector). for every call add a new element to the end.</p>

<p>eg.</p>

<pre><code>List&lt; int?&gt; areaIntList;

do {
    areaIntList.Add(areaInt[i]);
    areaCheck = isRegistered(file, areaInt[i]);
    if (areaCheck != 1)
    {
        i++;
    }
} while (areaCheck != 1);
</code></pre>

<p>isRegistered takes in a List of your used type.</p>
",1
14743581,14743311,0,"<p>My understanding of your question is this:</p>

<ol>
<li><code>isRegistered</code> is a function that takes a file and a variable-length string of digits, returning <code>1</code> if the string is registered and <code>0</code> otherwise.</li>
<li><code>areaInt</code> is a C-style string like <code>""31526""</code>.</li>
<li>What you want is to see if <code>""3""</code> is registered; if not, see if <code>""31""</code> is registered; if not, try <code>""315""</code>, etc until all the digits of <code>areaInt</code> are exhausted.</li>
<li>The end result should be a substring of <code>areaInt</code> which is the shortest registered string, or an error if no registered string was found.</li>
</ol>

<p>This is how I'd do it.</p>

<blockquote>
  <ol>
  <li>If the input string <code>areaInt</code> is empty, return an error.</li>
  <li>Loop a counter <code>i</code> from 1 to the length of the string:
  <ol>
  <li>Construct a test string <code>s</code> from the first <code>i</code> characters in <code>areaInt</code>.</li>
  <li>Test if <code>s</code> is registered.  If it is, break out of the loop and return <code>s</code>.  If not, continue the loop.</li>
  </ol></li>
  <li>If the loop completes at the end of <code>areaInt</code> and no registered string has been found, return an error.</li>
  </ol>
</blockquote>

<p><strong>Note.</strong> Make sure you stop at the end of <code>areaInt</code>.  Otherwise if you get to the end of <code>areaInt</code> and still haven't found a string that is registered, then you will overrun the buffer and try to read an element not in the string.</p>
",3
13767263,13767170,1,"<p><code>CPath::getPathByCode()</code> does not return a value and the result is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behaviour</a>.  Your compiler is not required to tell you about this, but if you compile with all warnings enabled it almost certainly will.</p>

<p>As an aside, if you formatted your code correctly, this sort of error would be much easier to see.</p>
",4
14745039,14745017,5,"<p>switch(stringType)</p>

<p>case <code>std::string</code>:</p>

<pre><code>for (i = 0; i&lt;area.length() ; i++)
{
</code></pre>

<p>case <code>char*</code>:</p>

<pre><code>for (i = 0; area[i] != '\0' ; i++)
{
</code></pre>

<p>case fixed length <code>char[]</code>:</p>

<pre><code>for (i = 0; i&lt; sizeof(area)/sizeof(area[0]) ; i++)
{
</code></pre>
",1
14745047,14745017,2,"<pre><code>for (i = 0; area[i]!='\0'; i++)
{
    areaIntA[i] = area[i] - '0';
    areaCounter++;
}
</code></pre>
",2
12871730,12871712,1,"<p><code>string write(n, t[100])</code> is the prototype of your function (type omitted). If you want to call write, you need to do something like</p>

<pre><code>int main()  
{  
    int i,n;   
    char t[100];  
    scanf(""%i"" ,&amp;n);  

    for (i=1;i&lt;=n;i++) {
            t[i]='a';
            }
write(n,t);  
return 0;  
}
</code></pre>

<p>Passing <code>t[100]</code> to your <code>write</code> function will give the 100th element of you string to your function, and that is not what you want to do. To pass the whole string, just use <code>t</code>.</p>

<p>Another mistake is that you say write returns a string. But you <code>return 0</code> in your code, you want to modify the write prototype to <code>int write(int n, char t[100]);</code></p>
",0
12871952,12871712,1,"<p>The line</p>

<pre><code>string write (n,t[100]);  
</code></pre>

<p>in <code>main</code> doesn't call the <code>write</code> function - it defines a <em>variable</em> named ""write"" of type <code>string</code>, consisting of <code>n</code> elements, each having the same value as <code>t[100]</code> (which is an error in itself, as that is the 101st element of a 100-element array).<br>
To call the function you should write</p>

<pre><code>write(n, t);
</code></pre>

<p>You really ought to get a decent introductory book on C++.<br>
There are good lists of them here on SO, and you should make it your first exercise to find them.</p>
",0
12874723,12874399,1,"<p>just give some comments:</p>

<ol>
<li>new operater should be used with delete.</li>
<li>""int *result"" you declared is a point to int, so you should dereference this point to get the result you want.</li>
<li>exceptions should be taken into consideration, what if the input letter is not in your given list?</li>
</ol>
",0
12874417,12874399,3,"<pre><code>int * price = new int;
</code></pre>

<p>and</p>

<pre><code>int * result = new int;
</code></pre>

<p>allocate a single <code>int</code> respectively. You probably meant <code>new int[6]</code>. </p>

<p>But then again, you should be using <code>std::vector</code> instead.</p>

<p>I'm disappointed really that you took no advice from - <a href=""https://stackoverflow.com/a/12868164/673730"">https://stackoverflow.com/a/12868164/673730</a> - if you had, you wouldn't have this problem now. This is not a good way to learn.</p>
",2
12874418,12874399,1,"<p>With this declaration: <code>int * price = new int;</code> you only allocate space for a single <code>int</code>, but you go on to use <code>price</code> as an array of <code>int</code>.</p>

<p>To declare an array, use: <code>int *price = new int[5];</code></p>

<p>As for <code>result</code>, you declare that as a pointer to <code>int</code> also, but you later use it as an <code>int</code>: <code>result += price[n];</code>. No need to <code>result</code> to be a pointer. Also note that you need to initialize your variables explicitly: set <code>result</code> to zero before you begin using it. </p>
",0
12874438,12874399,0,"<p>Well, <code>result</code> is an <code>int *</code>. This kind of variable usually stores the address of another integer variable, which you get with <code>new int</code> in this specific case. However, with</p>

<pre><code> result += price[n];
</code></pre>

<p>you'll modify that address, which would lead to segmentation faults if you were to actually write/read from <code>*result</code>. This is also the reason why you output is strange:</p>

<pre><code>cout &lt;&lt; ""\nTotal gold for this build: "" &lt;&lt; result;
</code></pre>

<p>This prints the adress stored in result, not the value. Make <code>result</code> an integer and it should work.</p>

<p>Please note that <code>price</code> should be changed too, see <a href=""https://stackoverflow.com/a/12874417/1139697"">Luchian's answer</a>.</p>

<h3>Exercise</h3>

<ol>
<li>Change your code so that there is no use of <code>new</code>.</li>
<li>Your program could still fail. What is the initial value of <code>result</code>?</li>
<li>What happens if the user provides a code which is not in your list?</li>
</ol>
",1
12874453,12874399,0,"<p>Change the line:</p>

<pre><code>cout &lt;&lt; ""\nTotal gold for this build: "" &lt;&lt; result;
</code></pre>

<p>to</p>

<pre><code>cout &lt;&lt; ""\nTotal gold for this build: "" &lt;&lt; *result;
</code></pre>

<p><code>Result</code> is a pointer, so you need to dereference it, using the * operator;</p>

<p><strong>Edit:</strong> Change the declaration of the <code>price</code> array to</p>

<pre><code>int *price = new int[6];
</code></pre>

<p>The previous declaration declared a variable, not an array</p>
",0
15853520,15853499,0,"<p>Well, when you've read the last character in the file <code>file.eof()</code> is still false, because the stream doesn't yet know that it's reached the end. Only after you attempt to read the already nonexistent character is eof set to true. You should probably do this</p>

<pre><code>char ch;

while(file &gt;&gt; ch)
{
      ... 
}
</code></pre>
",0
15853522,15853499,0,"<p>The reason is because just because you haven't hit the end of the file yet, doesn't mean the next read is going to succeed. Because you are reading characters, the EOF will only be set when you actually attempt to read after the last character.</p>

<p>In fact, even when you are reading strings, integers or other similar things out of a file there is a similar problem. At the end of many text files is an extra <code>\n</code> with no text after it. So when the last line is read, there is still a <code>\n</code> in the stream but EOF has not been set. You then proceed to read the next line which is not there whatever you are extracting into is left with the same contents as before. This results in what appears to be a duplicate reading.</p>
",1
13410529,13410460,2,"<p>Yes, this is overloading. The term is defined in <code>[over]/1</code> as:</p>

<blockquote>
  <p>When two or more different declarations are specified for a single name in the same scope, that name is said to be overloaded.</p>
</blockquote>

<p>Here, there are clearly two different declarations with the same name.</p>
",1
13429408,13429388,3,"<p>Use a temporary stack.</p>

<pre><code>// On exit the stack 's' will have it's elements reversed.
void reverse_stack(std::stack&lt;int&gt;&amp; s)
{
    std::stack&lt;int&gt; tmp;
    while (!s.empty())
    {
        tmp.push(s.pop());
    }
    s.swap(tmp);
}
</code></pre>
",8
13429417,13429388,-1,"<p>To reverse the output use this simple recursive function (pseudo code)</p>

<pre><code>  void recursiveWalk(Node* current)
  {
       if (current-&gt;next != NULL)
           recusiveWalk(current-&gt;next);
        // do stuff here
  }

  //call passing top
  recursiveWalk(stack-&gt;top);
</code></pre>

<p>This will build up the stack in reverse order. When you're on the last element the call stack will start to unwind allowing you to operate on the stack from bottom to top.</p>
",5
13429420,13429388,1,"<p>If you don't want to or you can't use <code>stack</code> in desired way, first you should think that <code>do you really need stack?</code> for example it might be better to use <code>queue</code> or <code>deque</code> in place of <code>stack</code>, so you can control it better!</p>
",2
13429425,13429388,1,"<p>If you want to access the elements in any order, why use a stack in the first place?</p>

<p>Use <code>std::vector</code> or <code>std::deque</code> directly, then iterate backwards like</p>

<pre><code>for (auto iter = vec.rbegin(); iter != vec.rend(); ++iter) {
    process(*iter);
}
</code></pre>

<hr>

<p>If you really need to, there's a hackish-but-correct way to access the <code>stack</code>'s underlying container object.</p>

<p>See: <a href=""https://stackoverflow.com/questions/4523178/how-to-print-out-all-elements-in-a-stdstack-or-stdqueue-conveniently?rq=1"">how to print out all elements in a std::stack or std::queue conveniently</a></p>
",0
13429448,13429388,0,"<p>In general you should not do this.</p>

<p>It's inappropriate to choose a container which is specifically designed to limit your access to its contents and then say that you really do want that access.</p>

<p>It's preferable to choose a container that's built to meet your needs. In this case using a <a href=""http://www.cplusplus.com/reference/stl/deque/"" rel=""nofollow""><code>deque</code></a> seems more appropriate.</p>

<p>But, if you reeaaaaallllyyyy want to do something kind of stupid, this is how you'd access the members of the stack directly (note that this does not use gobs of extra memory and time to build a temporary reverse stack, as some of the other answers have suggested):</p>

<pre><code>#include &lt;stack&gt;
#include &lt;deque&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
using namespace std;

template &lt;class T, class S&gt;
    S&amp; Container(stack&lt;T, S&gt;&amp; q) {
        struct HackedStack : private stack&lt;T, S&gt; {
            static S&amp; Container(stack&lt;T, S&gt;&amp; q) {
                return q.*&amp;HackedStack::c;
            }
        };
    return HackedStack::Container(q);
}

int main()
{
    stack&lt;int&gt; st;
    deque&lt;int&gt; &amp;mems = Container(st);

    cout&lt;&lt;""Putting numbers into the stack""&lt;&lt;endl;
    for(int i=0;i&lt;20;i++){
        int temp=rand();
        cout&lt;&lt;temp&lt;&lt;endl;
        st.push(rand());
    }

    cout&lt;&lt;endl&lt;&lt;""Reading numbers in the stack""&lt;&lt;endl;
    for(deque&lt;int&gt;::iterator i=mems.begin();i!=mems.end();i++)
        cout&lt;&lt;*i&lt;&lt;endl;

    cout&lt;&lt;endl&lt;&lt;""Taking numbers out of the stack""&lt;&lt;endl;
    while(!st.empty()){
        int temp=st.top();
        st.pop();
        cout&lt;&lt;temp&lt;&lt;endl;
    }

    return 0;
}
</code></pre>

<p>And, yes, if you change all of the <code>deque</code> references to <code>vector</code> references, this will still work fine. But <code>deque</code> is probably the preferable container to use with your stack.</p>
",2
15811522,15811486,0,"<p>I won't solve this for you, but will give you a hint.</p>

<p>The outline should be as follows:</p>

<pre><code>VectorPQueue *VectorPQueue::merge(VectorPQueue *one, VectorPQueue *two) {
    VectorPQueue* result = new VectorPQueue;
    // TODO: populate *result
    return result;
}
</code></pre>
",2
16911800,16911754,4,"<p>You cannot do such thing in copy c-tor.
Use simply</p>

<pre><code>Axes(const Axes&amp; rhs) : X(rhs.X), Y(rhs.Y), Z(rhs.Z) {}
</code></pre>

<p>However, there is no need in copy c-tor here, since default-implemented copy c-tor will do same things (<code>memberwise-copy</code>).</p>
",1
16399500,16399486,10,"<p>Strings are represented by "", not '</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main() {
    cout &lt;&lt; ""Hello world!""; // Use "" not '
    return 0;
}
</code></pre>
",1
16399504,16399486,2,"<p>Try doing :</p>

<pre><code>cout &lt;&lt; ""Hello world!""; // &lt;---------Double Quotes
</code></pre>

<p>Strings use double quotes. Single quotes are for single characters. </p>
",0
16399511,16399486,3,"<p>You should use:</p>

<pre><code>cout &lt;&lt; ""Hello World!"" &lt;&lt; endl;
</code></pre>

<p>Use ' ' for characters not strings.
Characters are single alphabets like 'h', 'i', etc while string is ""hi"".</p>
",0
14183491,14183445,10,"<p><code>\0</code> is the NULL character, you can find it in your <code>ASCII table</code>, it has the value 0.</p>

<p>It is used to determinate the end of C-style strings.</p>

<p>However, C++ class <code>std::string</code> stores its size as an integer, and thus does not rely on it.</p>
",0
14183506,14183445,11,"<p>C++ has two string types:</p>

<p>The built-in C-style null-terminated strings which are really just byte arrays and the C++ standard library <code>std::string</code> class which is <em>not</em> null terminated.</p>

<p>Printing a null-terminated string prints everything up until the first null character. Printing a <code>std::string</code> prints the whole string, regardless of null characters in its middle.</p>
",1
14183508,14183445,4,"<p>You're representing strings in two different ways here, which is why the behaviour differs.</p>

<p>The second one is easier to explain; it's a C-style raw char array.  In a C-style string, <code>'\0'</code> denotes the <em>null terminator</em>; it's used to mark the end of the string.  So any functions that process/display strings will stop as soon as they hit it (which is why your last string is truncated).</p>

<p>The first example is creating a fully-formed C++ <code>std::string</code> object.  These don't assign any special meaning to <code>'\0'</code> (they don't have null terminators).</p>
",0
14183511,14183445,30,"<p>C++ <code>std::string</code>s are ""counted"" strings - i.e., their length is stored as an integer, and they can contain any character. When you replace the third character with a <code>\0</code> nothing special happens - it's printed as if it was any other character (in particular, your console simply ignores it).</p>

<p>In the last line, instead, you are printing a C string, whose end is determined by the first <code>\0</code> that is found. In such a case, <code>cout</code> goes on printing characters until it finds a <code>\0</code>, which, in your case, is after the third <code>h</code>.</p>
",0
16435396,16435339,2,"<p>First you declare </p>

<pre><code>void test();
</code></pre>

<p>Then you implement </p>

<pre><code>void Test::test(std::string* str) {
</code></pre>

<p>This is not supposed to work</p>
",1
15852880,15852870,3,"<p>Sure, sometimes. For example, utility functions used by the public static methods of the same class.</p>
",0
15852888,15852870,3,"<p>Yes, having a static private member function makes sense. It might, for example, be a stateless utility function used only by other members of the same class.</p>

<p>No, your class does not make sense. Since <code>MyClass</code> has no other members, no entity can ever see your <code>MyClass::foo</code>. </p>
",0
15852896,15852870,5,"<p>Yes. For example: private static member functions used for initialization or other purposes.</p>

<p>See this post for more information: <a href=""https://stackoverflow.com/questions/6445927/what-is-the-use-of-private-static-member-functions"">What is the use of private static member functions?</a></p>
",0
15852908,15852870,0,"<p>Absolutely! Imagine a class that is purely static such as a statistical functions class. Helper functions may be private and static.</p>
",0
15852919,15852870,0,"<p>of course. You might use it for internal purposes of your class, in private functions i.e.</p>

<pre><code>class A{
    public:
        static int i_;
private:
    void privatef(){hiden_i_++;}
    static int hiden_i_;
};
</code></pre>
",1
16446251,16446185,1,"<p>Several issues:</p>

<pre><code>int b=new int[n];
   //^^compile error
</code></pre>

<p>should be</p>

<pre><code>int* b=new int[n];  //also need initialize array b
</code></pre>

<p>Meanwhile:</p>

<pre><code>if (d&lt;sqrt(b[i]))
</code></pre>

<p>You should initialize <code>b</code> before you try to access it.</p>

<p>besides:</p>

<pre><code>cout &lt;&lt; b[i]+""\n"" &lt;&lt; endl;
</code></pre>

<p><strong>EDIT:</strong> @Daniel Fischer, this would compile with <code>std::</code> added before <code>cout</code> and <code>endl</code>, but will result in undefined behavior.
try:</p>

<pre><code>cout &lt;&lt; b[i] &lt;&lt; endl;
</code></pre>

<p>if you want to print <code>b[i]</code>s only.</p>

<p>Additionally, inside your <code>while</code> loop, you need to increment <code>c</code> after <code>b[c] = d</code>, otherwise, it is going to the element into the same index again and again.</p>
",3
16446279,16446185,0,"<p><code>int b</code> should be declared as <code>int *b</code></p>

<p>You need to add <code>using namespace std</code> if you want to use <code>cout</code> etc. without namespace prefixes.
With prefixes you can do std::cout.</p>

<p>Also you've got an infinite loop because c is never incremented.</p>
",0
16934738,16934691,3,"<p>You invoke UB with that, crashing is only one of many incarnations of UB. It may crash later at some (possibly unrelated) point, or not at all, seeming to work.</p>

<p>What might happen in your case is that <code>std::string</code> is internally just a pointer to some real string allocation, which is <code>nullptr</code> anyways already. But thats just a guess, depends on your implementation, possibly the moonphase, and is not to be relied upon.</p>
",0
16934751,16934691,0,"<p>Initialization it self may not cause crasches, but using such object is dangerous</p>
",3
16934773,16934691,1,"<p>It does crash on my 64bit ubuntu when calling string destructor:</p>

<pre><code>Program received signal SIGSEGV, Segmentation fault.
0x00007ffff7b78bca in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
(gdb) bt
#0  0x00007ffff7b78bca in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#1  0x00007ffff7b78c13 in std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#2  0x0000000000400808 in TestStruct::~TestStruct() ()
#3  0x0000000000400770 in main ()
</code></pre>
",0
16934775,16934691,3,"<p>The crash might happen because you change an object's internal state. Initialize like this instead:</p>

<pre><code>TestStruct t = { };
</code></pre>

<p>Easier on your fingers and also works in <code>C</code>.</p>
",5
16934822,16934691,0,"<p>The <code>memset</code> would be setting all the data in the <code>std::string</code> object to zero which will, almost certainly, give you <em>undefined behaviour</em> which, of course, can include <em>not</em> crashing. The stl that I use (StlPort) has a fancy string class that allocates short strings on the stack and longer strings on the heap. That probably would not crash immediately on a zero <code>memset</code> but, really, there is no point in speculating as the behaviour is certainly not portable.</p>

<p>You'd be better off writing a default constructor for the <code>struct</code>:</p>

<pre><code>TestStruct() : a(0){}
</code></pre>

<p>which explicitly zeros the memory for the <code>int</code> and relies on the default constructor for the string.</p>

<p>(Remember that classes and structures are equivalent apart from the default access.)</p>
",0
16373002,16372834,0,"<p>Firstly <code>new</code> is wrong. You aren't allocating an object, you are constructing an object.</p>

<p>Secondly, assuming I'm reading the header file right, and assuming I understand what you are trying to do, you just want</p>

<pre><code>ZZ alicePrime(INIT_VAL, lPrime);
</code></pre>

<p><code>INTI_VAL</code> is just a constant that forces the compile to choose the constructor that gives <code>alicePrime</code> an initial value, instead of, say, an initial bit size.</p>

<p>NTL documentation is poor.</p>
",0
17840421,17840057,1,"<p>First, I wonder if it got lost in anonymization, but it seems to me there's missing</p>

<pre><code>include &lt;string.h&gt;
</code></pre>

<p>and the commandline should really look more like:</p>

<pre><code>g++ file.cpp -o file -lssl
</code></pre>

<p>You're using C++ compiler. C++ compilers are usually very strict about types. You've defined <code>ibuf</code> to be <code>unsigned char</code> (and used in strlen it is treated as <code>unsigned char *</code>)  and <code>strlen</code> expects <code>const char*</code>, so it produces an error.</p>

<p>You have following options:</p>

<ol>
<li><p>you can just cast <code>ibuf</code> in <code>strlen</code>:</p>

<pre><code>SHA1(ibuf, strlen((const char *)ibuf), obuf);
</code></pre></li>
<li><p>you can use suggested <code>-fpermissive</code> flag to make <code>g++</code> more forgiving and transform errors to mere warnings, although I wouldn't recommend it:</p>

<pre><code>g++ -fpermissive file.cpp -o file -lssl
</code></pre></li>
<li><p>As the code looks just like a plain <code>C</code>, maybe you don't need <code>C++</code> compiler. If that's the case, just use C-compiler instead of <code>C++</code>:</p>

<pre><code>gcc file.cpp -o file -lssl
</code></pre>

<p>You would then need to remove <code>include &lt;algorithm&gt;</code> and <code>namespace..</code>.</p></li>
</ol>
",1
16458265,16457826,1,"<p>I guess, that Audit is some kind of log? You have to make a decision about its purpose.</p>

<ul>
<li>If it's a general purpose log with an option to store information about import statuses, it shall be made a singleton (a ""safe"" kind of global variable). It's consistent with OOP rules, yet the class is easily available for all interested parties.</li>
<li>If it's designed specifically for storing information about import statuses, it <em>has</em> to be available for object performing the calculations, but shall be stored one level above (eg. in object containing <em>list</em> of all calculation objects). In your case the FileList should be a parent for the Audit (eg. it should maintain its lifetime), but CurrentFile should get an instance of Audit in the constructor, such that it can store results of the calculation within. In both cases be cautious about the multitasking, if you plan to implement one.</li>
</ul>
",1
15593333,15593327,1,"<p>Simply accessing a certain key will default-initialize its corresponding value. For <code>int</code>, that is equivalent to setting it to 0:</p>

<pre><code>x[""foo""];
</code></pre>

<p>Although, to be honest, it'd be easier to read as <code>x[""foo""] = 0;</code>.</p>
",3
15820374,15820353,6,"<p>Yes, the standard explicitly says that lvalue-to-rvalue conversion on an uninitialized object will result in undefined behaviour:</p>

<blockquote>
  <p>A glvalue (3.10) of a non-function, non-array type <code>T</code> can be converted to a prvalue. If <code>T</code> is an incomplete type, a program that necessitates this conversion is ill-formed. If the object to which the glvalue refers is not an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has undefined behavior.</p>
</blockquote>

<p>Anything that requires using the value of object will invoke lvalue-to-rvalue conversion.</p>

<p>Undefined behavior is defined as:</p>

<blockquote>
  <p>behavior for which this International Standard imposes no requirements</p>
</blockquote>

<p>So yes, a program with undefined behaviour can do anything, even if it appears to work correctly. So you cannot always identify undefined behaviour from a program's output. <strong>The real solution is to write correct, well-defined code.</strong> To do this, I highly recommend having a copy of the C++ standard by your side. Writing code and making assumptions about what it does is a very bad things, so if you ever write any C++ that you're not sure about, be sure to check it up.</p>

<p>Why does undefined behaviour exist in the standard? Firstly, it means you really only get what you ask for. If an uninitialized variable were instead defined to automatically get the value 0 (for example), every variable you declare that you don't initialize will have some extra operation to set the value to 0 that probably isn't needed. The standard simply says that using the value of an uninitialized variable is undefined, allowing it to leave the garbage value that already existed in that memory location. No extra cost.</p>

<p>Secondly, it allows the compiler to make optimizations based on the assumption that any C++ programmer will write sane, well-defined code.</p>
",1
15820416,15820353,1,"<p>Undefined behaviour means exactly that. The behaviour is undefined. Some compilers will be nice and warn you, others will do crazy things. In theory they're allowed to erase your hard drive in that situation, but that would be a pretty bad compiler.</p>

<p>To get specific, an uninitialised variable could have any value. In practice, it will usually be 0 if your program has only just started (a security feature provided by the OS to stop your program reading memory from old programs), but once it's been running for a while, there's a high chance it will be a totally random value because the memory was previously used by another function. Hence the warning. If you ignore it, your program will randomly fail for no apparent reason.</p>
",1
16386012,16385931,1,"<p>It's a bit simpler, than you coded. And you've forgotten to <em>call</em> your function:</p>

<pre><code>template &lt;typename A, typename B&gt;
auto foo(A&amp;&amp; a, B&amp;&amp; b) -&gt; decltype((a.*b)())
{
    return ((std::forward&lt;A&gt;(a)).*(std::forward&lt;B&gt;(b)))();
}
</code></pre>
",4
14164323,14164282,1,"<p>You probably didn't link against the appropriate libraries, where the symbols the linker is complaining about are exported.</p>

<p><a href=""https://stackoverflow.com/a/12574400/673730"">Here's how to link against the libs</a> which are probably found in <a href=""http://sourceforge.net/projects/id3lib/files/windows%20binaries/3.8.3/"" rel=""nofollow noreferrer"">this archive</a> (version number subject to change).</p>
",13
13437641,13437637,2,"<pre><code>cin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;
</code></pre>
",2
18262829,18262791,4,"<p>Use references for <code>a</code> and <code>b</code>.</p>

<pre><code>void getvals(int &amp;a, int &amp;b)
{
    cout &lt;&lt; ""input value a "";
    cin &gt;&gt; a;
    cout &lt;&lt; ""input value b "";
    cin &gt;&gt; b;
}
</code></pre>

<p>This declares <code>getvals()</code> to take two reference parameters. Modification to the reference of an object modifies the object that was passed in to the function call.</p>

<p>Without the reference, the parameter is passed by value, which creates a copy of the object passed to the function. Then, modifications made to the parameter in the function only affect the copy.</p>

<p>Alternatively, you can use <code>std::pair&lt;int, int&gt;</code> to return two integer values from your function (it won't need <em>out-parameters</em> then). You can manually unpack the <code>first</code> and <code>second</code> members into your variables <code>x</code> and <code>y</code>, or you can implement a helper class to do that for you. For example:</p>

<pre><code>std::pair&lt;int, int&gt; getvals () {
    std::pair&lt;int, int&gt; p;
    std::cin &gt;&gt; p.first;
    std::cin &gt;&gt; p.second;
    return p;
}

template &lt;typename T, typename U&gt;
struct std_pair_receiver {
    T &amp;first;
    U &amp;second;
    std_pair_receiver (T &amp;a, U &amp;b) : first(a), second(b) {}
    std::pair&lt;T, U&gt; operator = (std::pair&lt;T, U&gt; p) {
        first = p.first;
        second = p.second;
        return p;
    }
};

template &lt;typename T, typename U&gt;
std_pair_receiver&lt;T, U&gt; receive_pair (T &amp;a, U &amp;b) {
    return std_pair_receiver&lt;T, U&gt;(a, b);
}

int main () {
    int x, y;
    receive_pair(x, y) = getvals();
    //...
}
</code></pre>

<p>If you have C++11 available to you, you can use the more general <code>tuple</code> and the <code>tie</code> helper to do this similarly in a more clean way. This is illustrated in Benjamin Lindley's answer.</p>
",4
18262842,18262791,2,"<p>You seem to be half way to returning through parameters. All you need to change is this:</p>

<pre><code>void getvals( int&amp; a, int&amp; b )
{
    cout &lt;&lt; ""input value a "";
    cin &gt;&gt; a;
    cout &lt;&lt; ""input value b "";
    cin &gt;&gt; b;
}
</code></pre>

<p>Notice the <code>&amp;</code> before the parameter names, meaning pass by reference. That means when they change in the function, they also change in the caller. No <code>return</code> is needed.</p>
",2
18262845,18262791,8,"<p>You can only return one value from a function.  Fortunately, you can wrap two values in a struct or a class and return that as one object.  Which is exactly what <a href=""http://en.cppreference.com/w/cpp/utility/pair"" rel=""noreferrer""><code>std::pair</code></a> was designed for.</p>

<pre><code>std::pair&lt;int,int&gt; getvals()
{
    std::pair&lt;int,int&gt; p;
    cout &lt;&lt; ""input value a "";
    cin &gt;&gt; p.first;
    cout &lt;&lt; ""input value b "";
    cin &gt;&gt; p.second;

    return p;
}

int main()
{
    std::pair&lt;int,int&gt; p = getvals();
    int result1 = p.first + p.second;
    ...
}
</code></pre>

<p>C++11 introduces the more general <a href=""http://en.cppreference.com/w/cpp/utility/tuple"" rel=""noreferrer""><code>std::tuple</code></a>, which allows an arbitrary number of elements.</p>

<pre><code>std::tuple&lt;int,int&gt; getvals()
{
    int a,b;
    cout &lt;&lt; ""input value a "";
    cin &gt;&gt; a;
    cout &lt;&lt; ""input value b "";
    cin &gt;&gt; b;

    return std::make_tuple(a,b);
}

int main()
{
    int x,y;
    std::tie(x,y) = getvals();
    ...
}
</code></pre>
",3
18262867,18262791,0,"<p>You can only return one thing from a function. That thing can be an array which can be appropriate in some cases. </p>

<p>More often the Right Thing(TM) will be to declare the variables in your calling function. Pass references to those variables to the function which should set them. Using the references you passed in the function can set the variables in the caller very much like returning them. If you go this route it's probably a good idea to have the function return success/failure and handle all data output through the references. </p>

<p>Good luck. I'm pulling for you. We're all in this together. </p>
",0
18262883,18262791,1,"<p>Pass the values by reference to your function and change it definitions to return void. Something like this:</p>

<pre><code>void getvals(int &amp;a,int &amp;b)
{
    cout &lt;&lt; ""input value a "";
    cin &gt;&gt; a;
    cout &lt;&lt; ""input value b "";
    cin &gt;&gt; b;
    return;
}
</code></pre>
",0
13415797,13191221,0,"<p>You can take the inputs as string, if the first character is not a digit then break the loop, covert the string to integer otherwise:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
#include&lt;cstdlib&gt;


using namespace std;

int main() {
    int grade;
    string input;
    int a, b, c, d, f;
    a=b=c=d=f=0;


    do
    {
        cout &lt;&lt; ""Enter a grade or enter done to stop: "";
        cin &gt;&gt; input;
        cout &lt;&lt; endl;
        if(!isdigit(input[0])) {
            break;
        } else {
            grade = atoi(input.c_str());
        }

        if (grade &gt;= 90 &amp;&amp; grade &lt;= 100)
          {a++;}
        if (grade &gt;= 80 &amp;&amp; grade &lt; 90)
          {b++;}
        if (grade &gt;= 70 &amp;&amp; grade &lt; 80)
          {c++;}
        if (grade &gt;= 60 &amp;&amp; grade &lt; 70)
          {d++;}
        if (grade &gt;= 0 &amp;&amp; grade &lt; 60)
          {f++;}


    } while (1==1);

    cout &lt;&lt; ""a = "" &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; ""b = "" &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; ""c = "" &lt;&lt; c &lt;&lt; endl;
    cout &lt;&lt; ""d = "" &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; ""f = "" &lt;&lt; f &lt;&lt; endl;

    getchar();
    return 0;
}
</code></pre>
",0
14743352,14743326,2,"<p>Write a program using <code>%</code> operator to take the unit place value</p>

<pre><code>void check ()
{
    int i, changeIndex =0;
    for ( i = 0; i &lt; 5; i++)
    {
        for (int k = 0; k &lt; 5; k++)
        {
            if (a[i]%10 == a[k]%10)
            {
                changeIndex++;        
            }
        }
        if (changeIndex != 4)
        {
             break;
        }
        changeIndex = 0;

    }
    cout&lt;&lt;a[i];
}
</code></pre>

<p>This will work for a count of 5 and if only one of the numbers have a different unit place value</p>
",5
14744237,14743326,3,"<p>Here's one way to do the job. Definitely not the most efficient possible, but kind of nice anyway. This one will work for any number of inputs, as long as only one is different from the rest (in the units digit, obviously).</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; n = {4, 14, 27, 24, 34};

    std::sort(std::begin(n), std::end(n),
        [](int a, int b) { return a%10 &lt; b%10;});

    std::cout &lt;&lt; ((n[0]%10 &lt; n[1]%10) ? n.front() : n.back());
}
</code></pre>

<p>Edit: I decided to add another. While this still does more comparisons than @Rici's (very nice) solution, it's at least linear (and doesn't rearrange the original data):</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; n = {4, 14, 27, 24, 34};

    auto pos = std::adjacent_find(std::begin(n), std::end(n),
        [](int a, int b) { return a%10 != b%10; });

    if (pos != std::begin(n))
        std::cout &lt;&lt; pos[1];
    else
        std::cout &lt;&lt; n[n[1]%10 != n[2]%10];
}
</code></pre>
",0
14743691,14743326,2,"<p>here you go... :p   </p>

<p>works for any number of inputs... and even detects if they're all the same.</p>

<pre><code>#include &lt;iostream&gt;
int main() {
   int a[] = {4,14,24,34,27,94};
   // assume a has more than 2 elements, otherwise, it makes no sense
   unsigned ri = 0;

   if (a[1]%10 == a[0]%10) {
      for (ri = 2; (ri &lt; sizeof(a)/sizeof(a[0])) &amp;&amp; (a[ri]%10 == a[0]%10); ri++);
   } else if (a[2]%10 == a[0]%10)
      ri = 1;

   if (ri &lt; sizeof(a)/sizeof(a[0]))
      std::cout &lt;&lt; ""weird number is a[""&lt;&lt; ri &lt;&lt;""] = ""&lt;&lt;a[ri] &lt;&lt; std::endl;
   else
      std::cout&lt;&lt;""they're all the same"" &lt;&lt; std::endl;
   return 0;
}
</code></pre>

<p>Notice that the actual work:</p>

<pre><code>   if (a[1]%10 == a[0]%10) {
      for (ri = 2; (ri &lt; sizeof(a)/sizeof(a[0])) &amp;&amp; (a[ri]%10 == a[0]%10); ri++);
   } else if (a[2]%10 == a[0]%10)
      ri = 1;
</code></pre>

<p>is only 4 lines long! :p</p>

<p><a href=""http://liveworkspace.org/code/2aBqCp%2421"" rel=""nofollow"">check it out on liveworkspace</a></p>

<p>The run time is max(1,[location of the exception #]), which is O(n) where n is the size of a. </p>
",1
14745415,14743326,3,"<p>Jerry Coffin's solution is unnecessarily <code>O(log N)</code>; it can be improved by using <code>std::partition</code> rather than <code>std::sort</code>:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; n = {4, 14, 27, 24, 34};

    int first = n[0]%10;    
    std::partition(std::next(std::begin(n)), std::end(n),
                   [&amp;](int a) { return first == a%10;});

    std::cout &lt;&lt; ((first != n[1]%10) ? n.front() : n.back());
}
</code></pre>

<p>But that still does way too many comparisons. The problem can be solved with at most <code>(N+1)/2</code> comparisons:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int odd_man_out(const std::vector&lt;int&gt; n) {
    size_t i;
    for (i = 0; i + 2 &lt; n.size(); i += 2) {
      if (n[i]%10 != n[i+1]%10)
        return n[i]%10 != n[i+2]%10 ? i : i + 1;
    }
    if (i + 2 == n.size() &amp;&amp; n[i]%10 == n[i-1]%10)
      return i + 1;
    else
      return i;
}

int main() {
    std::vector&lt;int&gt; n = {4, 14, 27, 24, 34};
    std::cout &lt;&lt; n[odd_man_out(n)];
}
</code></pre>
",1
17403007,17402980,1,"<p>You can get address of the starting of string by <code>char *address = &amp;str[0];</code>. No need to convert string to c-string representation.</p>
",12
17403042,17402980,0,"<p>In C++11, the pointer returned points to the internal array currently used by the string object to store the characters that conform its value.</p>

<p>Refer to <a href=""http://www.cplusplus.com/reference/string/string/c_str/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/c_str/</a> for more details.</p>
",3
17403070,17402980,4,"<p><strong>NOTE</strong>: My answer is only correct for <strong><a href=""https://stackoverflow.com/questions/7554039/is-stringc-str-no-longer-null-terminated-in-c11/7554172#7554172"">pre-C++11</a></strong>. For C++11, <a href=""https://stackoverflow.com/a/17403222/76722"">this</a> is the correct answer.</p>

<hr>

<ol>
<li><p>It returns a C-string with null-termination. <code>std::string</code> itself is not null-terminated, so an implementation is allowed to (and probably will) return a newly allocated array of <code>const char</code>. If the creating <code>std::string</code> goes out of scope or if it is mutated, the <code>c_str()</code>-returned string is invalidated.</p></li>
<li><p><code>data()</code> returns the data, but beware it is not a null-terminated string.</p></li>
</ol>

<p>In neither case, you are supposed to tweak that data, both <code>data()</code> and <code>c_str()</code> return pointers to <code>const char</code>, and you really shouldn't.</p>

<p>E.g., <code>std::string</code>s are allowed to be reference counted strings (though this is not common anymore) or may even use funky indexing schemes on their data (never seen that, though).</p>
",0
17403095,17402980,1,"<p>If you actually want the ""data"" inside the string, then <a href=""http://www.cplusplus.com/reference/string/string/data/"" rel=""nofollow""><code>string::data()</code></a> is the function you are looking for. </p>

<p>Note however, that like <code>c_str()</code>, it is a <code>const</code> pointer to the data - you are not supposed to modify this data. </p>
",0
17403222,17402980,30,"<p>In <em>C++11</em> standard it's explicitly stated that <code>.c_str()</code> (as well as newer <code>.data()</code>) shall return pointer to the internal buffer which is used by <code>std::string</code>.</p>

<p>Any modification of the std::string after obtaining the pointer via <code>.c_str()</code> <em>may</em> result in said <code>char *</code> returned to became invalid (that is - if <code>std::string</code> internally had to reallocate the space).</p>

<p>In previous C++ standards implementation is allowed to return anything. But as standard do not require user to deallocate the result, I've never seen any implementation returning anything newly allocated. At least GNU gcc's and MSVC++'s STL string are internally zero-terminated char arrays, which are returned by <code>c_str()</code>.</p>

<p>So it's safe to assume (with normal for C++ caution) that in any version of C++ in any it's implementation <code>.c_str()</code> will return internal buffer.</p>

<p>In other words - you should never ever keep the value of the <code>.c_str()</code> unless you are 100% sure it's won't change it's size anytime in future (unless it's a <code>const</code>, that is).</p>

<p>P.S. BTW, you should never ever do <code>char* pointer=(char*)str.c_str();</code>. It's <code>const char *</code> and you shall not modify the contents, partly because the above - you may end-up overwriting memory of some other object <em>or</em> corrupting internal state of <code>std::string</code>, in case implementation doing something fancy, like indexing characters for faster <code>.find()</code>(newer seen that, but hey - that's an encapsulation!)</p>
",6
13462079,13461797,0,"<p>cdhowie is right. You are negating twice. </p>

<p>That said, I don't think you need to change the implementation.</p>

<pre><code>Vector const NegVecE = -VecE;
cout &lt;&lt; ""-Vector E = "" &lt;&lt; NegVecE &lt;&lt; NegVecE.Magnitude() &lt;&lt; endl &lt;&lt; endl;
</code></pre>

<p>EDIT: As PiotrNycz notes, though this will work, the end state is un-intuitive and therefore the correct solution is to return a copy.</p>

<pre><code>{
int i = 3;
int j = -i; //you would expect i to still be 3 here
}
</code></pre>
",2
13461819,13461797,7,"<p>You need to return a <em>copy</em> of the vector.  The way this is written, the expression <code>-VecE</code> will actually <em>modify</em> <code>VecE</code>!  Since you evaluate <code>-VecE</code> twice, you are negating the vector twice, and (of course) the negation of the negation is the original value.</p>

<p>To implement this change, you need to alter the <code>operator-()</code> declaration to return a <code>Vector</code> instead of a <code>Vector &amp;</code>.</p>

<p>For example:</p>

<pre><code>Vector Vector::operator-()
{
    Vector copy(*this);

    copy.pVec[0] = -copy.pVec[0];
    copy.pVec[1] = -copy.pVec[1];
    copy.pVec[2] = -copy.pVec[2];

    return copy;
};
</code></pre>
",9
13744052,13744000,2,"<p>Your <code>&lt;instruction&gt;</code> parameter can either be a function pointer (i.e. a pointer to an <code>execute</code> function); or, it can be a reference to an instance of a class, which has an <code>execute</code> method.</p>
",0
13744075,13744000,3,"<p>Yes, if you use <a href=""http://en.cppreference.com/w/cpp/utility/functional/bind"" rel=""nofollow""><code>std::bind</code></a> (C++11):</p>

<pre><code>template &lt;class F&gt;
void execute_at_frame(int frame_number, F instruction)
{
    for(int f = 1 ; f &lt; F_MAX ; f++)
    {
        /* other instructions */
        if (f == frame_number)
            instruction();
        /* other instructions */
    }
}

/* ... */

execute_at_frame(5,process); // no bind for functions without parameters
execute_at_frame(5,std::bind(execute,42));
</code></pre>

<p>Otherwise you'll have to prepare a interface for instructions.</p>
",0
13744096,13744000,1,"<p>You can pass a function pointer along with (if needed) some parameters. It could look like this:</p>

<pre><code>typedef void (*Instruction)(int);

void foo(int)
{
    // do something
}

void execute_at_frame(int frame_number, Instruction ins, int param)
{
    for(int f = 1 ; f &lt; F_MAX ; f++)
    {
        /* other instructions */
        if (f == frame_number)
            ins(param);
    }
}
</code></pre>

<p>Sample usage:</p>

<pre><code>execute_at_frame(1000, foo, 42);
</code></pre>

<p>If you use variadic templates, you can make it work with any signature. Simplified example:</p>

<pre><code>void foo(int)
{
}

float bar(int, char, double)
{
    return 1.0;
}

template&lt;typename F, typename... Args&gt;
void execute(F ins, Args... params)
{
    ins(params...);
}

int main()
{
    execute(foo, 1);
    execute(bar, 1, 'a', 42.0);
}
</code></pre>

<p>You'll need C++11 compiler for that.</p>
",1
13744167,13744000,0,"<p>your  parameter also can be a base class pointer,point to Derived class which has  a virtual function</p>
",0
13744889,13744000,0,"<p>Code for using a function as a parameter:</p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;
using namespace std;

int instruction(int instruc)
{
     return instruc ;
}


template&lt;typename F&gt;
void execute_at_frame(int frame, const F&amp; function_instruction)
{
     std::cout &lt;&lt; function_instruction(frame) &lt;&lt; '\n';
}


int main()
{
     execute_at_frame(20, instruction);  //  use reference
     execute_at_frame(40, &amp;instruction); //  use pointer




  cout&lt;&lt;"" \nPress any key to continue\n"";
  cin.ignore();
  cin.get();

   return 0;
}
</code></pre>
",0
13435548,13435528,4,"<p>make these values static for the class, this way all object will inherit these same values.</p>

<pre><code>static const int x = 1;
static const int y = 2;
static const int z = 3;
</code></pre>

<p>through technically, this does not define the variable. If a static data member is of const integral or const enumeration type, you may specify a constant initializer in the static data member's declaration. This constant initializer must be an integral constant expression. Note that the constant initializer is not a definition. You still need to define the static member in an enclosing namespace.</p>

<pre><code>#include ""foo.h""
#include &lt;//libs....&gt;
int foo::x;
int foo::y;
int foo::z;
//class functions down below
</code></pre>
",11
13435574,13435528,3,"<p>You can also use an initializer list in the constructor to set these fields' initial values, just as with any other member:</p>

<pre><code>class foo {
public:
    const double x;
    const double y;
    const double z;

    foo() : x(1), y(2), z(3) {
    }
};
</code></pre>
",1
13435575,13435528,1,"<p>You don't <em>have</em> to make them static. You could declare them like this:</p>

<pre><code>class foo{

public:
    double var_1, var_2, var_3;
    const double x=1.0;
    const double y=2.0;
    const double z=3.0;

[functions go here]

};
</code></pre>

<p>Though if they are integer values then declaring them as <code>int</code>s would be better.</p>
",4
15809325,15808682,2,"<p>You're not updating temp1, it stays all the time pointing the Head.
here's the fix.</p>

<pre><code>  while (temp-&gt;next!=NULL)
     {
        temp=temp-&gt;next;
        //making new node every instance 
        temp1-&gt;next=new ListItem&lt;T&gt;(temp-&gt;next-&gt;value); 
        ListItem&lt;T&gt; *temp2=temp1-&gt;next;
        temp2-&gt;prev=temp1;   //setting the previous pointer of the new node
        temp1 = temp2;
     }
</code></pre>
",3
17852468,17852385,1,"<p><code>strlen()</code> wants a <code>const char *</code>, or at least a <code>char*</code>, the problem is that you're giving to it an <code>unsigned char*</code>. You should do this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;openssl/sha.h&gt;

int main()
{
    char ibuf[] = ""trysha"";
    unsigned char obuf[20];

    SHA1(ibuf, strlen(ibuf), obuf);

    int i;
    for (i = 0; i &lt; 20; i++) {
        printf(""%02x "", obuf[i]);
    }
    printf(""\n"");

    return 0;
}
</code></pre>

<p>If SHA1 expects an <code>unsigned char*</code> as first argument, you may have to cast <code>ibuf</code>: <code>SHA1(static_cast&lt;unsigned char*&gt;(ibuf), strlen(ibuf), obuf);</code></p>

<p>By the way you don't need <code>strlen()</code>, you can replace it by this:
<code>SHA1(ibuf, sizeof(ibuf), obuf);</code></p>
",0
17852475,17852385,0,"<p>It tells you exactly what is wrong -- <code>strlen</code> doesn't accept <code>unsigned char*</code>, but rather plain <code>const char*</code>. According to 3.9.1.1 of the C++98 standard, <code>signed char</code>, <code>unsigned char</code> and <code>char</code> are distinct types and you cannot convert them explicitly.</p>

<p>Why are you using <code>unsigned char</code> for C-style strings anyway?</p>
",0
15577068,15577016,7,"<blockquote>
  <p>I don't understand why 4 is happening. Why that copy constructor call?</p>
</blockquote>

<p>That is because of this line:</p>

<pre><code>Account(std::string number, float amount, CreditCard creditCard) 
: 
number(number), amount(amount), creditCard(creditCard)
//                              ^^^^^^^^^^^^^^^^^^^^^^
{ ... }
</code></pre>

<p>In the constructor of <code>Account</code>, you are copying the lvalue <code>creditCard</code> into the member variable <code>creditCard</code>. This causes a call to the copy constructor of <code>CreditCard</code>.</p>

<p>Actually, since you are taking <code>creditCard</code> by value, it is safe to <em>move</em> it:</p>

<pre><code>Account(std::string number, float amount, CreditCard creditCard) 
: 
number(number), amount(amount), creditCard(std::move(creditCard))
//                                         ^^^^^^^^^^^^^^^^^^^^^
{ ... }
</code></pre>

<p>This will cause a call to the <em>move</em> constructor of <code>CreditCard</code> rather than to the copy constructor in step 4.</p>
",1
15577080,15577016,2,"<ol>
<li><code>CreditCard(""12345"", 1, 2014, 1122)</code> is constructed. Let's call it <code>c1</code>.</li>
<li><code>c1</code> gets moved into the <code>creditCard</code> parameter of <code>Account</code> constructor.</li>
<li>Construction of <code>account1</code> starts.</li>
<li><code>account1.creditCard</code> is copy-constructed from the constructor parameter <code>creditCard</code>, as per the member initialiser list.</li>
</ol>
",0
15588394,15588370,5,"<p>IMO, you are overthinking it. Just create a function that takes a string (by <code>const</code> reference) and returns the modified string. Declare it in a header and define in the corresponding <code>.cpp</code> file.</p>

<p>Job done.</p>

<pre><code>[helper.hpp]
std::string myReplace(const std::string&amp; s);

[helper.cpp]
std::string myReplace(const std::string&amp; s) {
   ...
}

[somefile.cpp]
#include ""helper.hpp""
otherString3 = myReplace(myString3);
</code></pre>
",6
15588483,15588370,1,"<p>I just want to point out that your macro would have worked, you just used it incorrectly. However, this is <em>not the right way to solve this problem</em>, just wanted to point it out. Here's the correct usage:</p>

<pre><code>#define REPLACE .replace(""a"", ""b"").replace(""c"", ""d"").replace(""e"", ""f"")
otherString1 = myString1 REPLACE;
</code></pre>

<p>Or maybe better (if using macros can ever be better):</p>

<pre><code>#define REPLACE(str) str.replace(""a"", ""b"").replace(""c"", ""d"").replace(""e"", ""f"")
otherString1 = REPLACE(myString1);
</code></pre>

<p>Remember, <em>don't do this</em>, but this is how macros could be used.</p>
",2
13419208,13419186,22,"<p>For the <a href=""http://en.wikipedia.org/wiki/Null_character"" rel=""nofollow"">special <code>'\0'</code></a> char which indicates end of string.</p>

<p>(Remember, <em>C-style strings</em> are <em>null-terminated</em> arrays).</p>

<p>Additional helpful notes:</p>

<ul>
<li><code>strlen</code> <em>does not</em> count the <code>'\0'</code> (That's why you need this extra <em>byte</em>). </li>
<li><code>strcpy</code> <em>does</em> copy the <code>'\0'</code>. </li>
<li><code>char str[7] = ""String"";</code> - Adds <code>'\0'</code> by itself.</li>
<li><code>char str[] = {'S','t','r','i','n','g'}</code> - <em>Does not</em> add <code>'\0'</code>.</li>
<li><code>char str[7] = {'S','t','r','i','n','g'}</code> - Will add <code>'\0'</code>.</li>
</ul>
",6
13420103,13419186,2,"<p>In C based Strings there is always a special character at the end of string <code>'\0'</code> which also needs an extra byte.  This is why we need an extra character and we need array of <code>strlen(str)+1</code> to store the string.</p>
",0
14862721,14862639,0,"<blockquote>
  <p>After a short while these stored values are magically changed to contain some random garbage.</p>
</blockquote>

<p>Assuming that <code>stored_sNCharcb</code> is valid when <code>rapi_strcpy()</code> exits, and then <code>stored_sNCharcb</code> changes at a later time, that would suggest that code you have not shown is overwriting <code>stored_sNCharcb</code> when it should not be, such as due to a buffer overflow or such.  I suggest you put a data breakpoint on <code>stored_sNCharcb</code> after <code>rapi_strcpy()</code> exits, and then let the debugger tell you if it is being modified so you can see exactly which code is modifying it.</p>
",1
14862907,14862639,2,"<p>Is the data in <code>pData</code> NULL terminated?  If not, the <code>strcpy</code> call in <code>rapi_strcpy</code> may be running off the end and therefore copying beyond size allocated in the target.  </p>

<p>You probably want to be using something that forces a length, like <code>strncpy</code> or <code>memcpy</code>:</p>

<pre><code>strncpy(res-&gt;pData, rapistr.pData, rapistr.iDataLen);
</code></pre>
",2
13778601,13778568,1,"<p>C++ reserved words are <code>char</code>, <code>signed char</code>, and/or <code>unsigned char</code>. <code>uint8</code> is probably a typedef synonym for <code>unsigned char</code>.</p>
",0
13778639,13778568,3,"<p>Assuming that <code>uint8</code> is an 8 bit unsigned integer type, the main difference on a ""normal"" C++ implementation is that <code>char</code> is not necessarily unsigned.</p>

<p>On ""not normal"" C++ implementations, there could be more significant differences -- <code>char</code> might not be 8 bits. But then, what would you define <code>uint8</code> to be on such an implementation anyway?</p>

<p>Whether the sign difference matters or not depends how you're using it, but as a rule of thumb it's best to use unsigned types with bitwise operators. That said, they both get promoted to <code>int</code> in bitwise <code>&amp;</code> anyway (again on a ""normal"" C++ implementation) and it really doesn't matter for <code>&amp;</code>, it doesn't cause surprises in practice. But using <code>&lt;&lt;</code> on a negative signed value results in undefined behavior, so avoid that.</p>

<p>So, use an unsigned type. If the most convenient way for you to write that is <code>uint8</code>, and you know that your code deals in octets and will only run on systems where <code>char</code> is an octet, then you may as well use it.</p>

<p>If you want to use a standard type, use <code>unsigned char</code>. Or <code>uint8_t</code> in order to deliberately prevent your code compiling on ""not normal"" implementations where <code>char</code> is not an octet.</p>
",0
13437227,13437034,1,"<p>You can't do what you are asking for in your question, there are a couple of ways to do something similar.</p>

<p>You can use inheritance.</p>

<pre><code>class foo{

public:
    double a, b, c;
    double fn, val;

    // set a,b, and c
    void set(){
        a=1;
        b=1;
        c=1;
    }

    // constructor
    foo(double &amp;f){
        set();
    }
};

class X : public foo {
{
public:
    X (double &amp;f) : foo(f) {
        // do stuff for x
    }
};

class Y : public foo {
{
public:
    Y (double &amp;f) : foo(f) {
        // do stuff for y
    }
};

class Z : public foo {
{
public:
    Z (double &amp;f) : foo(f) {
        // do stuff for z
    }
};

main(){

    X x=1;Y y=1;Z z=1;

}
</code></pre>

<p>Or you can use an enumeration</p>

<pre><code>class foo{
public:
    enum Mode{
        Mode_X,
        Mode_Y,
        Mode_Z
    };
    Mode mode;

    double a, b, c;
    double fn, val;

    // set a,b, and c
    void set(){
        a=1;
        b=1;
        c=1;
    }

    foo(Mode m, double &amp;f) : mode(m) {
        set();

        switch(mode) {
        case Mode_X:
            // what I want to do here is say if ""name of variable f"" = ""x"", then do something
            break;
        case Mode_Y:
            // else if ""name of variable f"" = ""y"", do something else
            break;

        case Mode_Z:
            // else if ""name of variable f"" = ""z"", do something else
            break;
        }
    }
};

main(){

    foo x(foo::Mode_X,1), y(foo::Mode_Y,1), z(foo::Mode_Z,1);

}
</code></pre>

<p>You can use the preprocessor with the enumeration version to get the variable declaration closer to what you were originally asking for like this:</p>

<pre><code>#define X(value) x(foo::Mode_X,(value))
#define Y(value) y(foo::Mode_Y,(value))
#define Z(value) z(foo::Mode_Z,(value))

main(){
    foo X(1), Y(1), Z(1);
}
</code></pre>

<p>Many people, myself included, would advise against using the preprocessor like this.  I am only saying that it is possible.</p>
",1
13437931,13437034,0,"<p>You mention in comments that you're writing a class to do partial differentiation. Here's a suggested starting point:</p>

<pre><code>class Differentiator{
public:
    double a, b, c;
    double fn, val;
    void differentiateByX(double &amp;f);
    void differentiateByY(double &amp;f);
    void differentiateByZ(double &amp;f);

    Differentiator(): a(1), b(1), c(1)
    {} // Note the syntax above for initializing members.
};
</code></pre>

<p>If it seems useful, feel free to change the return type of the differentiate functions, or to add members so that you can do</p>

<pre><code>main(){
    Differentiator foo;
    foo.differentiateByX(1);
    // do something with the result
    foo.differentiateByY(2);
    // etc.
}
</code></pre>

<p>If you know you're always going to want to differentiate by X, Y, and Z, you could have a single <code>Differentiator</code> do all three with a single function, <code>differentiate(double &amp;x, double &amp;y, double &amp;z)</code> or go back to doing all the work in your constructor: <code>Differentiator foo(x, y, z);</code></p>
",0
13437202,13437034,0,"<p>What you're trying to do is called reflection (<a href=""http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29"" rel=""nofollow"">Wikipedia</a>). Since C++ is a compiled, non-managed language it doesn't support reflection.</p>

<p>Also, when code is compiled in C++, the compiler <a href=""http://en.wikipedia.org/wiki/Name_mangling#Name_mangling_in_C.2B.2B"" rel=""nofollow"">mangles the variable names</a> so the variables that you think you created (x, y, z) aren't named at all what you think they are and the new names have no meaning.</p>

<p>Unfortunately, when you're trying to accomplish by checking the name of a variable can't be done in C++.</p>
",1
13425121,13425093,4,"<pre><code>    switch(i) {
    case 1:
        Type=""Technical literature"";
        break;
    case 2:
        Type=""Fiction literature"";
        break;
    case 3:
        Type=""Textbook"";
        break;
    default:
        cout &lt;&lt; ""Erorr you entered a wrong choice"" &lt;&lt; endl;
        goto Choice;
    }
</code></pre>
",0
13425148,13425093,0,"<pre><code>void SetType(){
        cout&lt;&lt;""Book SetType""&lt;&lt;endl;
        Choice:
        cout&lt;&lt;""Please Select from the list: \n 1- Technical literature \n 2- Fiction literature \n 3- Textbook""&lt;&lt;endl;
        int i;
        cin &gt;&gt; i;
        switch(i)
        {
            case 1:
            {
                Type=""Technical literature"";
                break;
            }
            case 2:
            {
                Type=""Fiction literature"";
                break;
            }
            case 3:
            {
                Type=""Textbook"";
                break;
            }
            default:
            {
                cout &lt;&lt; ""Erorr you entered a wrong choice"" &lt;&lt; endl;
                goto Choice;
                break;
            }
        }

    }
</code></pre>
",0
13425176,13425093,2,"<p>A <code>switch</code> / <code>case</code> is totally fit for your situation.  Use a <code>switch</code> / <code>case</code> when you have discrete values you can test on a single variable, in your case <code>i</code>.</p>

<p>It works by defining each <code>case</code> and a <code>default</code> one in case the variable doesn't match with any case.  Here's what your code would look like with a <code>switch</code> / <code>case</code>:</p>

<pre><code>switch(i)
{
    case 1:
        Type=""Technical literature"";
        break;
    case 2:
        Type=""Fiction literature"";
        break;
    case 3:
        Type=""Textbook"";
        break;
    default: 
        cout &lt;&lt; ""Erorr you entered a wrong choice"" &lt;&lt; endl;
        goto Choice;
}
</code></pre>

<p><code>break</code> is used to prevent the code from one <code>case</code> to continue executing the code of the following <code>case</code>.</p>

<p>I would strongly advise you learn better methods than using a <code>goto</code> to go back to your Choice selection.</p>

<p>Here's a new version with a slightly better ""input loop"", without using <code>goto</code></p>

<pre><code>void SetType()
{
    cout &lt;&lt; ""Book SetType"" &lt;&lt; endl;
    bool validChoice;
    do
    {
        validChoice = true; // Invalidate it in case of wrong choice
        cout &lt;&lt; ""Please Select from the list: \n 1- Technical literature \n 2- Fiction literature \n 3- Textbook"" &lt;&lt; endl;
        int i;
        cin &gt;&gt; i;
        switch(i)
        {
        case 1:
            Type=""Technical literature"";
            break;
        case 2:
            Type=""Fiction literature"";
            break;
        case 3:
            Type=""Textbook"";
            break;
        default:
            cout &lt;&lt; ""Error you entered a wrong choice"" &lt;&lt; endl;
            validChoice = false;
            cin.clear();
            string dummyLine;
            getline(cin, dummyLine);
        }
    } while(validChoice == false);
}
</code></pre>

<p>I added some code to remove input that is not a number, otherwise cin will keep failing.</p>
",0
13425177,13425093,0,"<pre><code>void SetType(){
    cout&lt;&lt;""Book SetType""&lt;&lt;endl;
Choice:
    cout&lt;&lt;""Please Select from the list: \n 1- Technical literature \n 2- Fiction literature \n 3- Textbook""&lt;&lt;endl;
    int i;
    cin &gt;&gt; i;
    switch(i) {
        case 1: Type=""Technical literature""; break;
        case 2: Type=""Fiction literature""; break;
        case 3: Type=""Textbook""; break;
        default:
            cout &lt;&lt; ""Erorr you entered a wrong choice"" &lt;&lt; endl;
            goto Choice;
    }
}
</code></pre>

<p>P.s. Many folks break into a cold sweat and have palpitations at the sight of a goto.</p>
",0
15577399,15577374,3,"<p>Your constructors don't need to take any special action, so you can just use the constructor synthesized versions:</p>

<pre><code>CreditCard(const CreditCard&amp; creditCard)=default;
CreditCard(CreditCard&amp;&amp; creditCard)=default;
</code></pre>

<p>and so on.</p>

<p>If you really want to implement them, then this is an example of a hand-made move copy constructor. Note nothing happens in the constructor body.</p>

<pre><code>CreditCard(CreditCard&amp;&amp; creditCard)
: 
number(std::move(creditCard.number)), 
expMonth(std::move(creditCard.expMonth)), 
expYear(std::move(creditCard.expYear)), 
pin(std::move(creditCard.pin))
{}
</code></pre>

<p>Concerning the copy assignment opetators, if you care about exception safety you may want to look into the <a href=""http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Copy-and-swap"" rel=""nofollow"">copy and swap idiom</a>.</p>
",6
15577509,15577374,0,"<p>if your class members are</p>

<pre><code>std::string number;
int expMonth;
int expYear;
int pin;
</code></pre>

<p>and you write a copy constructor as:</p>

<pre><code>CreditCard(const CreditCard &amp;creditCard):number(creditCard.number),
 expMonth(creditCard.expMonth), expYear(creditCard.expYear), 
 pin(creditCard.pin){}
</code></pre>

<p>then this is exactly what compiler would provide if you didn't specify it yourself</p>

<p>you only have to write copy constructor in some special cases, i.e. when you have to dynamically alocate pointer and you don't want then to pointers beeing just 'value' copied in above way</p>

<p>note: you didn't provide initialization of your <code>std::string</code> but I don't think it was deliberately</p>
",0
14835640,14835524,0,"<p>An array with automatic storage duration always requires compile-time constant bounds. The fact that you can do <code>int array[x];</code> where <code>x</code> is not a compile-time constant in GCC is merely a non-portable extension. Indeed, you cannot pass such a non-standard array by reference to a function.</p>

<p>You could just pass the bounds along with the array, but you're much better off using a standard container such as <code>std::vector</code>.</p>
",5
14835860,14835524,0,"<p>Try:</p>

<pre><code>template&lt;int X, int Y&gt;
void ArrayFn( int (&amp;in)[X][Y] )
{
    in[X-1][Y-1] = 666; // or whatever
}
</code></pre>

<p>And call it like:</p>

<pre><code>int arr[3][3];
ArrayFn( arr );
</code></pre>
",0
13696314,13696274,5,"<pre><code>int largest_number(int score[], int max)
{ 
    for (int i=1; i&lt;5; i++)
    {
        cin &gt;&gt; score[i];
        if(score[i] &gt; max)
            max=score[i];

        return (max); //whoops! it's inside the for loop
    }
}
</code></pre>

<ul>
<li>You made a mistake by putting your return inside of the for loop,
this means no matter what you're only entering <code>score[1]</code> because the function will return max afterwards.</li>
</ul>

<p>Remove the return inside your for loop and put it at the end of the function, and you should be fine.</p>
",6
13696326,13696274,2,"<p>You need to separate flies from meatballs as we say here.
Good choice is to make function that only find max and to fill array separately.</p>

<p>Example:</p>

<pre><code>    int FindMax(int score[], int size)
    {
       int max = score[0];
       for(int i = 1; i &lt; size; i++)
           if(score[i] &gt; max)
              max = score[i];
       return max; 
    }

int main()
{
    const int SIZE = 5;
    int score[SIZE];
    for(int i = 0; i &lt; SIZE; i++)
    {
        cout &lt;&lt; ""Enter "" &lt;&lt; i &lt;&lt; "" number\n"";
        cin &gt;&gt; score[i];
    }

    cout &lt;&lt; ""\nMax is "" &lt;&lt; FindMax(score, SIZE);

    return 0;
}
</code></pre>
",1
13696330,13696274,2,"<p>in your for loop</p>

<pre><code>for (int i=1; i&lt;5; i++)
{
    cin &gt;&gt; score[i];
    if(score[i] &gt; max)
        max=score[i];

    return (max);
}
</code></pre>

<p>you return.  when you write that return statement, the function exits, and you don't go through the rest of the loop.</p>

<p>I think you meant to put the return statement outside the loop</p>

<pre><code>for (int i=1; i&lt;5; i++)
{
    cin &gt;&gt; score[i];
    if(score[i] &gt; max)
        max=score[i];
}
return (max);
</code></pre>

<p>also, <code>Fomin Arseniy</code>, had a good point(though not gracefully stated).</p>

<p>You should collect your input in one step, and then find the largest number in the next step.  For problems as simple as this, it doesn't make too much of a difference, but it's a pattern you should learn for harder problems.</p>
",0
13696416,13696274,2,"<p>Welcome to the wonderful world of code!</p>

<ol>
<li><p>Remember that when return is called, it breaks out of the for loop and goes back to the caller. With that said, within your <strong>largest_number</strong> function, simply pull the return statement...</p>

<pre><code>return (max);
</code></pre>

<p>...out of the for loop</p></li>
<li><p>Begin your for loop by initializing your variable <strong>i</strong> to 0, and not 1. That way you will get 5 cycles, rather than 4.</p></li>
<li><p>Ensure that the first time the for loop executes, the <strong>max</strong> variable gets set to whatever is entered. I'm making sure this happens by using the following condition in the if statement</p>

<p><code>score[i] &gt; max || i == 0</code></p>

<p>Notice the <strong>i == 0</strong>. Think about why that works.</p></li>
<li><p>Your <strong>largest_number</strong> function does not need to be passed the parameter <strong>max</strong>. You can simply create a local variable called <strong>max</strong> within your function and use that.</p></li>
<li><p>Also, try to name your functions using the 'Camel Hump' format (example below).</p></li>
</ol>

<p>Your final (working) function will look like this:</p>

<pre><code>int largestNumber(int score[])
{ 
   int max = 0;
   for (int i = 0; i &lt; 5; i++)
   {
      cin &gt;&gt; score[i];
      if (score[i] &gt; max || i == 0)
        max = score[i];
   }
   return (max);
}
</code></pre>
",0
14158543,14158356,-1,"<p>You can take this code as an reference, although it is implemented in Java. You can just take the algorithm as you need.</p>

<pre><code>public Cycle(Graph G) {
    if (hasSelfLoop(G)) return;
    if (hasParallelEdges(G)) return;
    marked = new boolean[G.V()];
    edgeTo = new int[G.V()];
    for (int v = 0; v &lt; G.V(); v++)
        if (!marked[v])
            dfs(G, -1, v);
}


// does this graph have a self loop?
// side effect: initialize cycle to be self loop
private boolean hasSelfLoop(Graph G) {
    for (int v = 0; v &lt; G.V(); v++) {
        for (int w : G.adj(v)) {
            if (v == w) {
                cycle = new Stack&lt;Integer&gt;();
                cycle.push(v);
                cycle.push(v);
                return true;
            }
        }
    }
    return false;
}

// does this graph have two parallel edges?
// side effect: initialize cycle to be two parallel edges
private boolean hasParallelEdges(Graph G) {
    marked = new boolean[G.V()];

    for (int v = 0; v &lt; G.V(); v++) {

        // check for parallel edges incident to v
        for (int w : G.adj(v)) {
            if (marked[w]) {
                cycle = new Stack&lt;Integer&gt;();
                cycle.push(v);
                cycle.push(w);
                cycle.push(v);
                return true;
            }
            marked[w] = true;
        }

        // reset so marked[v] = false for all v
        for (int w : G.adj(v)) {
            marked[w] = false;
        }
    }
    return false;
}
 private void dfs(Graph G, int u, int v) {
    marked[v] = true;
    for (int w : G.adj(v)) {

        // short circuit if cycle already found
        if (cycle != null) return;

        if (!marked[w]) {
            edgeTo[w] = v;
            dfs(G, v, w);
        }

        // check for cycle (but disregard reverse of edge leading to v)
        else if (w != u) {
            cycle = new Stack&lt;Integer&gt;();
            for (int x = v; x != w; x = edgeTo[x]) {
                cycle.push(x);
            }
            cycle.push(w);
            cycle.push(v);
        }
    }
}
</code></pre>
",1
13446678,13446541,0,"<p>Unfortunately if both of the following are true:</p>

<blockquote>
  <p>in short pseudocode. Basically, 'foo a' should always use the first if
  clause, 'foo b' should always use the second, and 'foo c' should
  always use the third.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>As part of this assignment, I MUST implement the main function in that
  way. It cannot be changed.</p>
</blockquote>

<p>...then you're out of luck. There is no difference at all in your main function between <code>a</code>, <code>b</code>, and <code>c</code> except for their names.</p>

<p>Maybe I'm misunderstanding something in your phrasing - if so, could you clarify?</p>
",0
13446584,13446541,2,"<p>Since it appears that your question is in regards to a homework assignment, I'm going to point you in the direction of <a href=""http://www.learncpp.com/cpp-tutorial/811-static-member-variables"" rel=""nofollow"">static member variables</a> which are, in short, class variables that are shared between all instances of a given class. You can use one or more of these variables to track the progress of the instantiation of your instances.</p>
",0
14158234,14158206,2,"<p><code>clear</code> removes all elements of the vector as opposed to setting all of them to 0 as you seem to be expecting. After calling clear the size of your vector is 0. Thus when you try to read <code>A[i][j]</code> you are accessing an index out of bounds and anything may happen(your code causes <code>undefined behavior</code>).</p>
",5
14158239,14158206,5,"<p>You are invoking undefined behaviour. <code>A.clear()</code> is working fine, but you are reading memory that you shouldn't be. Try with ""&lt; A.size()"" instead of ""&lt;= N""</p>
",0
14158240,14158206,8,"<p><code>A.clear()</code> does clear the array in the sense that as the result, <code>A</code> contains zero elements. This is not the same as setting every element to zero.</p>

<p>Your code has undefined behaviour since the post-<code>A.clear()</code> loop accesses elements past the end of the now empty vector. It just so happens that the memory is still accessible and still contains the old data. However, this is not guaranteed to be the case.</p>

<p>If you iterated using the correct dimensions, you'd see that <code>A</code> is empty:</p>

<pre><code>for (int i = 0; i &lt; A.size(); ++i)
{
    for (int j = 0; j &lt; A[i].size(); ++j)
    {
        cout &lt;&lt; A[i][j] &lt;&lt; ' ';
    }
    cout &lt;&lt; '\n';
}
</code></pre>
",1
18104196,18104129,6,"<p>The ""canonical"" C++ way is to use <code>stringstream</code>, something like this:</p>

<pre><code>std::string somefunc(int number)
{
  std::stringstream ss;
  ss &lt;&lt; ""You need "" &lt;&lt; number &lt;&lt; "" more coins"";
  std::string str = ss.str();
  return str;
}
</code></pre>
",0
14169973,14169752,5,"<p>The example code you give,</p>

<pre><code>WriteLine(&amp;String8(""Exception""));
</code></pre>

<p>is <strong>invalid</strong> as standard C++, unless the <code>String8</code> type defines a custom address operator.</p>

<hr>

<p>You ask,</p>

<blockquote>
  <p>&ldquo;Why do some compilers complain about taking an address of a temporary from a constructor and some dont?&rdquo;</p>
</blockquote>

<p>Some compilers complain, because the C++ standard says you can't use the built-in address operator to take the address of a temporary:</p>

<blockquote>
  <p><strong>C++11 ¡ì5.3.1/3</strong>:<br>
  &ldquo;The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a <em>qualified-id</em>.&rdquo;</p>
</blockquote>

<p>Some compilers, such as Visual C++, don't complain, because they offer the ability to take the address as a <strong>language extension</strong>.</p>

<hr>

<p>Note that a user defined type can define a custom address operator. Thus, in your case it <em>depends on the <code>String8</code> type</em>. As well as on the compiler.</p>

<hr>

<p>You further ask,</p>

<blockquote>
  <p>&ldquo;Is there a way to get that to work in one line?&rdquo;</p>
</blockquote>

<p>Yes you <em>can</em> define an address operator. But it's not a good idea. First of all it only creates problems with standard library etc., and secondly, the need for that is very rare.</p>

<p>I can only remember one case where I seriously considered such a solution, namely for passing a COM smart pointer as out-argument. Instead of defining an address operator I defined a named method. It's much more clear and doesn't interfere with other things.</p>
",5
14169904,14169752,2,"<p>The code is perfectly valid(<em>on MSVC</em>). And you can ignore the warning as red herring.    </p>

<p>There are two issues to consider:</p>

<ol>
<li>Taking the address of an temporary(<em>a.k.a: rvalue</em>), which is not allowed as per the standard &amp;</li>
<li>Lifetime of the temporary who's address is taken.</li>
</ol>

<p><strong>Counter Issue 1:</strong><br>
MSVC allows you to take the address of an temporary through an extension. So taking address of the temporary shall and will compile atleast in your case(courtesy MSVC).    </p>

<p><strong>Counter Issue 2:</strong><br>
Further the temporary <code>String8(""Exception"")</code> is guaranteed to live at least until the expression ends. Note that the expressions ends just after the return from <code>WriteLine()</code>, to be precise <code>;</code>(<em>the semicolon at the end of call</em>). So it is perfectly valid. In this case you can consider the warning as an red herring. </p>

<p><strong>C++03 Standard ¡ì12.2/3:</strong></p>

<blockquote>
  <p>Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. </p>
</blockquote>
",0
14249436,14249404,2,"<p>This syntax is known as <a href=""https://stackoverflow.com/questions/222557/what-uses-are-there-for-placement-new"">placement new</a>. It lets you construct objects in memory locations that you already own. It does NOT allocate memory for you.</p>

<p>In this case, a <code>T1</code> object is being constructed in the memory location pointed to by _Ptr, since <code>new</code> expects <code>void*</code>, it is being cast down. The cast would happen implicitly anyway, looks like the explicit cast is to make the intent clear.</p>
",4
13476482,13476430,1,"<p>Because you have created a dynamically allocated <em>array</em> that holds <code>Point</code> objects, not <code>Point*</code>. You access each member via <code>operator[]</code>:</p>

<pre><code>p[0].x = 42;
</code></pre>
",0
13476500,13476430,13,"<p>Actually, you use <code>p[index].x</code> and <code>p[index].y</code> to access elements of the <code>struct</code> inside an array, because in this case you are using a pointer to refer to a dynamically allocated array.</p>

<p>The <code>ptr-&gt;member</code> operator is simply a shorthand for <code>(*ptr).member</code>. In order to use it, you need a pointer on the left-hand side:</p>

<pre><code>Point *p = new Point;
p-&gt;x = 12.34;
p-&gt;y = 56.78;
</code></pre>

<p>Note that even for a dynamically allocated array the <code>-&gt;</code> operator would have worked:</p>

<pre><code>Point *p = new Point[10];
p-&gt;x = 12.34;
p-&gt;y = 56.78;
</code></pre>

<p>This is equivalent to</p>

<pre><code>p[0].x = 12.34;
p[0].y = 56.78;
</code></pre>

<p>because a pointer to an array is equal to the pointer to its first element.</p>
",0
13476522,13476430,1,"<blockquote>
  <p>Why do I use P[k].x and P[k].y instead of P[k]->x and P[k]->y to access the k-th point's elements?</p>
</blockquote>

<p>Because <code>P[k]</code> is <em>not</em> a pointer, it is the object at the <code>k</code>th position and its type is <code>Point</code>, not <code>Point*</code>. For example:</p>

<pre><code>Point p = P[0]; // Copy 0th object
p.x; // Access member x
Point* pp = &amp;(P[0]); // Get address of 0th element, equivalent to just P
pp-&gt;x; // Access member x
</code></pre>
",0
13476530,13476430,1,"<p>In general the arrow <code>-&gt;</code> operator is used to dereference a pointer. But in this case, P is an array of Points. if P was an array of Point pointers then you would have uses the latter</p>
",0
17819036,17818979,9,"<p>Your loop end condition seems curious, I presume</p>

<pre><code>for (int j = i + 1;i &lt; sizer;j++)
</code></pre>

<p>should really be</p>

<pre><code>for (int j = i + 1;j &lt; sizer;j++)
</code></pre>
",1
17819069,17818979,3,"<p>also your loop conditions are broken. should be comparing j &lt; sizer.</p>

<pre><code>for (int i = 0; i &lt; sizer;i++)
{
    // we don't check j here
    for (int j = i + 1;i &lt; sizer;j++)
    {
        //j can exceed the size of nenad and read from a bad address
        if (nenad[i] &gt; nenad[j])
        {
            int temp = nenad[i];
            // same as above
            nenad[i] = nenad[j];
            // or write to a bad address
            nenad[j] = temp;
        }
    }
}
</code></pre>

<p>Another thing you should <strong>really</strong> consider using / doing is making use of <strong>valgrind</strong>. It will catch this for you when our eye's can't.</p>
",0
15865282,15865194,4,"<p>There's a special rule for this situation. The compiler is allowed to skip the copy constructor, even though it has side effects, provided the expression with the copy constructor would have been legal. So</p>

<pre><code>T t = u;
</code></pre>

<p>is, as you say, equivalent to</p>

<pre><code>T t(T(u));
</code></pre>

<p>The compiler skips the copy constructor and treats this as</p>

<pre><code>T t(u);
</code></pre>

<p>One situation where this would not be allowed would be a class with a private copy constructor. In that case, <code>T t(T(u));</code> would not be legal, and the compiler would not be allowed to make it legal by skipping the copy constructor.</p>
",1
13480191,13480135,6,"<p>In C++ there's only one difference between a struct and a class: in a struct the default visibility is public while in a class it is private.</p>

<p>Other than that you can do anything you would do in a class in a struct and it will look exactly the same.</p>

<p>Write operator overloading in a struct as you would in a class.</p>
",1
13480206,13480135,23,"<p>Just do it:</p>

<pre><code>Point operator+( Point const&amp; lhs, Point const&amp; rhs );
Point operator+( Point const&amp; lhs, double rhs );
Point operator+( double lhs, Point const&amp; rhs );
</code></pre>

<p>With regards to your last question, the compiler makes <em>no</em>
assumptions concerning what your operator does.  (Remember, the
<code>+</code> operator on <code>std::string</code> is <em>not</em> commutative.)  So you
have to provide both overloads.</p>

<p>Alternatively, you can provide an implicit conversion of 
<code>double</code> to <code>Point</code> (by having a converting constructor in
<code>Point</code>).  In that case, the first overload above will handle
all three cases.</p>
",3
13480372,13480135,11,"<p>Here is how I would do it.</p>

<pre><code>struct Point {
   double x, y;
   struct Point&amp; operator+=(const Point&amp; rhs) { x += rhs.x; y += rhs.y; return *this; }
   struct Point&amp; operator+=(const double&amp; k) { x += k; y += k; return *this; }
};

Point operator+(Point lhs, const Point&amp; rhs) { return lhs += rhs; }
Point operator+(Point lhs, const double k) { return lhs += k; }
Point operator+(const double k, Point rhs) { return rhs += k; }
</code></pre>
",0
13444821,13444774,0,"<p>Create a boolean variable preset to FALSE.
If the user chooses ""Jump out the window"" change the boolean variable to TRUE.
Then put the entirity of your code in a loop.</p>

<pre><code>while (myBooleanVariable == FALSE) {

  //insert game code

}
</code></pre>
",2
13445257,13444774,2,"<p>If you are doing a lot of this, I suggest you make it easy for the reader...  Kind of a pick-a-path thing rather than the user having no idea what they're supposed to type.</p>

<pre><code>int GetChoice( vector&lt;string&gt; &amp; choices )
{
    cout &lt;&lt; ""Do you wish to:"" &lt;&lt; endl;

    // Output choices 1..N
    for( int i = 0; i &lt; choices.size(); i++ ) {
        cout &lt;&lt; ""  "" &lt;&lt; i+1 &lt;&lt; "". "" &lt;&lt; choices[i] &lt;&lt; endl;
    }

    // Ask user for their choice.
    for(;;) {
        // This is pretty basic.  You could use getline instead...
        cout &lt;&lt; ""Enter your choice: "";
        cout.flush();
        int n;
        cin &gt;&gt; n;

        if( n &lt; 1 || n &gt; choices.size() ) {
            cout &lt;&lt; ""Invalid choice.\n"";
            continue;
        }

        // Output the choice and clear the choices vector (so it can be used again)
        cout &lt;&lt; ""You "" &lt;&lt; choices[n-1] &lt;&lt; endl;
        choices.clear();
        return n;
    }
 }
</code></pre>

<p>Then:</p>

<pre><code> vector&lt;string&gt; opts;
 int choice;

 cout &lt;&lt; ""You see a door and a gun.\n"";
 do {
     opts.push_back( ""try the door"" );
     opts.push_back( ""pick up the gun"" );
     choice = GetChoice(opts);
     if( choice == 1 ) cout &lt;&lt; ""The door appears to be locked.\n"";
 } while( choice == 1 );
 if( choice != 2 ) GameQuit();

 cout &lt;&lt; ""You are armed and dangerous.  Now what?\n"";
 opts.push_back( ""assault the door with the gun"" );
 opts.push_back( ""look down the barrel and pull the trigger"" );
 choice = GetChoice(opts);

 if( choice == 1 ) {
    cout &lt;&lt; ""The door crashes from its hinges.\n"";
    cout &lt;&lt; ""You see a zombie and an open window.\n"";
    opts.push_back( ""shoot the zombie"" );
    opts.push_back( ""jump out the window"" );
    choice = GetChoice(opts);

    if( choice == 1 ) {
        cout &lt;&lt; ""The zombie explodes and it attracts hundreds more zombies.\n"";
        GameOver();
    } else if( choice == 2 ) {
        cout &lt;&lt; ""You plummet 17 stories to a grisly death.\n"";
        GameOver();
    } else {
        GameQuit();
    }
 } else if( choice == 2 ) {
    cout &lt;&lt; ""Your head explodes.\n"";
    GameOver();
 } else {
    GameQuit();
 }
</code></pre>

<p>Not saying it's pretty, but this format allows you to have other options available at all times (such as 'q' to quit, which returns zero maybe).</p>

<p>Obviously you'll see that doing the game in this fashion is going to cause lots of nested <code>if</code>-blocks...  It would be better to arrange the game as a state machine, as previously suggested in comments.  Ultimately, you could define a simple text-file containing the entire game.</p>
",0
14150523,14150492,3,"<p>Provide a non-<code>explicit</code> constructor to allow conversion and casting from a base type to your wrapper.
Provide a non-<code>explicit</code> conversion operator to allow conversion casting from your wrapper to a base class.</p>

<pre><code>class my_wrapper {
    my_wrapper(int); // casting from int
    operator int();  // casting to int
};
</code></pre>

<p>(make them <code>explicit</code> to allow explicit casting but not implicit conversion)</p>
",18
13404826,13404755,5,"<p>The compiler will select the version of a function that is the closest match. A function that takes the exact type for a parameter always wins over one that requires a conversion. In this case the template function is an exact match, since it matches anything; the <code>Interface</code> specialization would require the conversion of the parameter from a <code>Derived</code> to an <code>Interface</code>.</p>
",0
13404874,13404755,6,"<p>Try this (and <code>#include &lt;type_traits&gt;</code>):</p>

<pre><code>template &lt;typename T, typename = void&gt;
struct Selector
{
    static void Select(T &amp; o)
    {
        std::cout &lt;&lt; ""Generic method"" &lt;&lt; std::endl;
    }
};

template &lt;typename T&gt;
struct Selector&lt;T,
           typename std::enable_if&lt;std::is_base_of&lt;Interface, T&gt;::value&gt;::type&gt;
{
    static void Select(Interface &amp; o)
    {
        o.Method();
    }
};
</code></pre>

<p>It turns out that <code>enable_if</code> combined with defaulted template arguments can be used to guide partial specialisations.</p>
",0
13404921,13404755,0,"<p>This will allow you to achieve the desired result:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;type_traits&gt;
using namespace std;

class Interface {
    public :
       virtual void Method() = 0;
       virtual ~Interface() { }
};

class Derived : public Interface {
    public : 
       void Method() {
            cout&lt;&lt;""Interface method""&lt;&lt;endl;
       }
};

template&lt;typename T, typename S = void&gt; 
struct Selector {
    static void Select(T&amp; o) {
        cout&lt;&lt;""Generic method""&lt;&lt;endl;
    }
};

template&lt;typename T&gt;
struct Selector&lt;T, typename enable_if&lt; is_base_of&lt;Interface, T&gt;::value &gt;::type&gt; {
    static void Select(Interface&amp; o) {
        o.Method();
    }
};

int main()
{
int i;
Selector&lt;int&gt;::Select(i);       // prints out ""Generic method"" -&gt; ok
Derived d;
Selector&lt;Derived&gt;::Select(d);  // prints out ""Generic method"" -&gt; wrong
                               // should be ""Interface method""
}
</code></pre>
",0
14150104,14150061,1,"<p>The problem is that on a 2D char array <code>people.wishlist[i][k]</code> stands for a single <code>char</code> (<code>i</code>th row and <code>k</code>th column), but <code>getline</code> expects a string of them <code>char*</code>.</p>

<p>You need a pointer to a 1D char array, which you can get indexing just one other dimension. (with <code>i</code>) You could try it this way:</p>

<pre><code>read.getline(people.wishlist[i], MAX);
</code></pre>
",7
14150106,14150061,1,"<p>As the error says, you are passing a <code>char</code> where it expects a <code>char*</code>. Specifically you are passing the first element of the array, when you want to be passing the pointer to the start of the array. </p>

<p>As @Nick suggests, try this</p>

<pre><code>read.getline(people.wishlist[i], MAX);
</code></pre>
",1
13696352,13696211,2,"<p>If you want to check ranges I recommend you to use the if statement to avoid using a list of all possible values:</p>

<pre><code>if (a &gt;= 0 &amp;&amp; a &lt;= 5)
    cout &lt;&lt; ""Common"";
else if (a &gt;= 6 &amp;&amp; a &lt;= 8)
    cout &lt;&lt; ""Rare"";
else if (a &gt;= 9 &amp;&amp; a &lt;= 10)
    cout &lt;&lt; ""Very rare"";
</code></pre>
",1
13696240,13696211,4,"<p>You can't use comparison operators in a switch case.  Try this: </p>

<pre><code> switch (a)
    {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        cout &lt;&lt; ""Common"";
            break;

        case 6:
        case 7:
        case 8:
        cout &lt;&lt; ""Rare"";
            break;

        case 9:
        case 10:
        cout &lt;&lt; ""Very rare"";
            break;

        default:
            break;
    }
</code></pre>
",6
13437718,13437710,9,"<p><code>T-&gt;key &lt; key</code> is a condition. It will evaluate to either <code>true</code> or <code>false</code>.
If it evaluates to <code>true</code>, <code>dir</code> will get value <code>1</code>, otherwise it will get value <code>0</code>.</p>

<pre><code>int dir = T-&gt;key &lt; key;
</code></pre>

<p>is short form for writing</p>

<pre><code>int dir;
if(T-&gt;key &lt; key)
    dir = 1;
else
    dir = 0;
</code></pre>

<p>When a <code>boolean</code> is assigned to an <code>int</code>, it gets the value <code>0</code> or <code>1</code> corresponding to <code>false</code> or <code>true</code>.</p>
",0
13437720,13437710,0,"<p><code>&lt;</code> returns 1 if the first operand is less than the second operand, or 0 otherwise.</p>
",0
13437724,13437710,6,"<p>If the operator isn't overloaded, than it has the usual meaning; it evaluates to either <code>true</code> or <code>false</code>. This is a <code>bool</code> type, and therefore can be implicitly converted to an <code>int</code>.</p>

<p>However, if <code>TKey</code> is a class and overloads it, or there's a global overload, then we've no idea what it does unless we see the code.</p>
",1
13437725,13437710,0,"<p>The <code>&lt;</code> operator is a boolean comparison operator - i.e. it evaluates to <code>0</code> if the condition is false, and <code>1</code> if the condition is true. It's usually used in conditionals, but using the return value directly is perfectly valid. In this case, if the value of <code>T-&gt;key</code> is less than the value of <code>key</code>, <code>dir</code> will be <code>1</code> otherwise <code>dir</code> will be <code>0</code>.</p>
",0
13437735,13437710,0,"<p>Well, as the binary search tree stores values lesser than root on left and greater values on right, you need select which direction the insertion is gonna take place. To do this you are comparing the key with the current node's value. The result of this comparison is stored in dir variable. So if key is lesser than T's value, dir gets 1 which represents left side in the link[] that holds pointers to the left and right branches of the node T.  And then insertion is done recursively with the left node of T. That is why you do a comparison there. Just to see whether we must insert the element to the right or left of the current node.</p>
",0
13423471,13423402,4,"<p>After you complete your insertions, you need to determine again the beginning of the set:</p>

<pre><code>it = myset.begin();
</code></pre>

<p>Should go before the 2nd <code>while</code> loop.</p>

<hr>

<p>If you are able to use C++11 features, consider using a range-based for loop. Notice that it does not require the use of any iterator:</p>

<pre><code>for( auto const&amp; value : myset )
  std::cout &lt;&lt; value &lt;&lt; "" "";
std::cout &lt;&lt; ""\n"";
</code></pre>

<p>If you are not able to use C++11 features, consider a regular for loop. Notice that the scope of the iterator is limited to the for loop:</p>

<pre><code>for(std::set&lt;std::string&gt;::const_iterator it=myset.begin(), end=myset.end(); 
      it != end; ++it)
  std::cout &lt;&lt; *it &lt;&lt; "" "";
std::cout &lt;&lt; ""\n"";
</code></pre>
",1
13423489,13423402,3,"<pre><code>it = myset.begin();
</code></pre>

<p>Move this line to just before the loop that displays the names. The problem is that with it at the top, where there are no elements in the set, it gets the value of the end iterator, so the display loop ends immediately.</p>
",0
13423504,13423402,0,"<p><code>it == myset.end();</code> evaluates to <code>true</code> after the first while loop is done executing. You need to add this line of code between the loops <code>it = myset.begin();</code></p>
",0
15883427,15883302,4,"<p>The standard requires that, except where explicitly stated, you use complete types with the library templates. This basically inhibits your design (where each object maintains <em>by value</em> a list of the other type).</p>

<p>You can work around this by using [smart] pointers (either a pointer to the container or container of pointers).</p>
",0
13440310,13440272,0,"<p>Try backspace \b or erase the whole line and print it again.</p>
",0
13440321,13440272,9,"<p>Outputting the backspace character '\b' may help to move the output point back.</p>

<p>Specifically, outputting the string ""\b \b"" should blank out the last character output.</p>
",1
13440380,13440272,0,"<p>Sipmly write the <code>'\b'</code> character to stdout <code>std::cout&lt;&lt;""\b""</code>. If you are using cpp or <code>printf(""\b"")</code> for pure C</p>
",1
13452763,13452181,1,"<p>The problem could be that your <code>operator&lt;</code> is not antisymmetrical. Imagine this code:</p>

<pre><code>const oid oid1[] = {5};
oid_wrapper wrapper1(oid1, 1);

const oid oid2[] = {1, 4};
oid_wrapper wrapper2(oid2, 2);

bool b1 = wrapper1 &lt; wrapper2;
bool b2 = wrapper2 &lt; wrapper1;
</code></pre>

<p><code>b1</code> is <code>true</code>, because the legth of <code>wrapper1</code> is less than length of <code>wrapper2</code>.</p>

<p><code>b2</code> is also <code>true</code>, because the first oid in <code>wrapper2</code> is less than that in <code>wrapper1</code>.</p>

<p>You must make sure <code>operator&lt;</code> is a total ordering. It should return <code>false</code> if <code>oid_length &gt; rhs_length</code>.</p>

<p>Also, you cannot implement <code>operator&gt;</code> as <code>! &lt;</code>, because that doesn't hold for equal values. The best bet for operators is to implement <code>operator==</code> and <code>operator&lt;</code> and express the rest as (pseudo-code):</p>

<pre><code>operator!=(a, b)  {! (a == b)}
operator&lt;=(a, b)  {a &lt; b || a == b}
operator&gt;(a, b)   {! (a &lt; b)}
operator&gt;=(a, b)  {! (a &lt; b)}
</code></pre>
",2
13490294,13452181,0,"<p>I used net-snmp function snmp_oid_compare instead of implementing my own compare. That solved the problem.</p>

<pre><code>#ifndef OID_WRAPPER_H_
#define OID_WRAPPER_H_

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;ostream&gt;
#include &lt;sstream&gt;

#include &lt;net-snmp/net-snmp-config.h&gt;
#include &lt;net-snmp/net-snmp-includes.h&gt;

class oid_wrapper {
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; output, const oid_wrapper&amp; wrapper);
public:
    oid_wrapper(const oid* _oid_value, unsigned long _oid_length) : oid_value(0), oid_length(_oid_length) {
        oid_value = snmp_duplicate_objid(_oid_value, oid_length);

    }

    const oid* get_oid() const { return oid_value; }
    const unsigned long&amp; get_length() const { return oid_length; }

    int compare(const oid_wrapper&amp; rhs) const {
        return snmp_oid_compare(oid_value, oid_length, rhs.oid_value, rhs.oid_length);
    }

    void print(std::ostream &amp;out) const {
        for(unsigned long i = 0; i &lt; oid_length; i++) {
            if (i != 0) { out &lt;&lt; "".""; }
            out &lt;&lt; oid_value[i];
        }
    }

    /**
     * copy operator overload
     */
    oid_wrapper&amp; operator=(const oid_wrapper&amp; wrapper) {
        if (oid_value != 0) { free(oid_value); }

        oid_value = snmp_duplicate_objid(wrapper.oid_value, wrapper.oid_length);
        oid_length = wrapper.oid_length;

        return *this;
    }

    /**
     * assignment operator overload
     */
    oid operator[](unsigned long i) {
        return (i &lt; oid_length) ? oid_value[i] : oid();
    }

    bool operator==(const oid_wrapper&amp; rhs) const { return compare(rhs)==0; }
    bool operator!=(const oid_wrapper&amp; rhs) const { return compare(rhs)!=0; }
    bool operator&lt;(const oid_wrapper&amp; rhs) const { return compare(rhs)&lt;0; }
    bool operator&gt;(const oid_wrapper&amp; rhs) const { return compare(rhs)&gt;0; }
    bool operator&lt;=(const oid_wrapper&amp; rhs) const { return compare(rhs)&lt;=0; }
    bool operator&gt;=(const oid_wrapper&amp; rhs) const { return compare(rhs)&gt;=0; }

private:
    oid* oid_value;
    unsigned long oid_length;
};

/**
 * output operator overloader
 */
inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; output, const oid_wrapper&amp; wrapper) {
    wrapper.print(output);
    return output;
}

#endif /* OID_WRAPPER_H_ */
</code></pre>

<p><br/><br/>
The code for function snmp_oid_compare. This could be used for any implementation where one would need to compare arrays of long.</p>

<pre><code>    int snmp_oid_compare(const oid * in_name1, size_t len1, 
                     const oid * in_name2, size_t len2)
    {
        register int len;
        register const oid *name1 = in_name1;
        register const oid *name2 = in_name2;

        /*
         * len = minimum of len1 and len2
         */
        if (len1 &lt; len2) { len = len1; }
        else { len = len2; }

        /*
         * find first non-matching OID
         */
        while (len-- &gt; 0) {
            /*
             * these must be done in seperate comparisons, since
             * subtracting them and using that result has problems with
             * subids &gt; 2^31.
             */
            if (*(name1) != *(name2)) {
                if (*(name1) &lt; *(name2)) { return -1; }
                return 1;
            }
            name1++;
            name2++;
        }

        /*
         * both OIDs equal up to length of shorter OID
         */
        if (len1 &lt; len2) return -1;
        if (len2 &lt; len1) return 1;

        return 0;
    }        
</code></pre>
",0
18175599,18175579,1,"<p>A missing { here:</p>

<pre><code>if(UpdateOnNextRun || clock() - timeSinceLastUpdate &gt; 5000 )
</code></pre>

<p>And after the line with <code>GameStatus = ""AssaultCube Ready To Hack"";</code> there are two other <code>else</code> without <code>if</code>. Remove/comment them.</p>

<p>And next time, better indentation!</p>
",2
13479531,13479504,5,"<p>As long as <code>DelBook</code> only invokes <code>delete</code> ¡ª?nothing happens, it's a no-op. (and it is possible to invoke your <code>DelBook</code> with <code>NULL</code> as a parameter value, no extra action needed).</p>
",0
13479559,13479504,-2,"<p>Passing NULL itself usually isn't a problem. It's basically 0. Deleting NULL probably has no effect</p>
",0
13479627,13479504,0,"<p><code>NULL</code> is a valid pointer: it points to memory location zero. Therefore you can pass NULL into a function that takes a <code>Book*</code> pointer, because it IS a <code>Book*</code> pointer.</p>

<p>Additionally, NULL is special and doesn't need to be cast to <code>Book*</code> - you do not need to say <code>DelBook((Book*)NULL)</code>. Therefore, the program should compile already.</p>

<p>Deleting a null pointer does nothing, so you don't need a sanity check. However if you need to do something with a member of the <code>Book</code> class, you must check it is not NULL first:</p>

<pre><code>static void DelBook(Book * X)
{
    if (X){
        x-&gt;tidyUpBeforeDeletion();
        delete X;
    }
}
</code></pre>

<p>Failure to check this will result in a segfault - this is dereferencing a null pointer and is very bad news.</p>
",1
14724741,14724627,5,"<p>Your method is adequate, to call it <em>nice</em> I would just not mix bitwise operations and ""mathematical"" way of converting to decimal, i.e. use either</p>

<pre><code>    decimal = decimal &lt;&lt; 1 | array[i];
</code></pre>

<p>or</p>

<pre><code>    decimal = decimal * 2 + array[i];
</code></pre>
",1
14726005,14724627,2,"<p>It is important, before attempting any optimisation, to profile the code. Time it, look at the code being generated, and optimise only when you understand what is going on.</p>

<p>And as already pointed out, the best optimisation is to not do something, but to make a higher level change that removes the need.</p>

<p>However...</p>

<p>Most changes you might want to trivially make here, are likely to be things the compiler has already done (a shift is the same as a multiply to the compiler). Some may actually <em>prevent</em> the compiler from making an optimisation (changing an <code>add</code> to an <code>or</code> will restrict the compiler - there are more ways to add numbers, and only you know that in this case the result will be the same).</p>

<p>Pointer arithmetic may be better, but the compiler is not stupid - it ought to already be producing decent code for dereferencing the array, so you need to check that you have not in fact made matters worse by introducing an additional variable.</p>

<p>In this case the loop count is well defined and limited, so unrolling probably makes sense.</p>

<p>Further more it depends on how dependent you want the result to be on your target architecture. If you want portability, it is hard(er) to optimise.</p>

<p>For example, the following produces better code here:</p>

<pre><code>unsigned int x0 = *(unsigned int *)array;
unsigned int x1 = *(unsigned int *)(array+4);

int decimal = ((x0 * 0x8040201) &gt;&gt; 20) + ((x1 * 0x8040201) &gt;&gt; 24);
</code></pre>

<p>I could probably also roll a 64-bit version that did 8 bits at a time instead of 4.</p>

<p>But it is very definitely not portable code. I might use that locally if I knew what I was running on and I just wanted to crunch numbers quickly. But I probably wouldn't put it in production code. Certainly not without documenting what it did, and without the accompanying unit test that checks that it actually works.</p>
",0
14726013,14724627,0,"<p>You could use <code>accumulate</code>, with a doubling and adding binary operation:</p>

<pre><code>int doubleSumAndAdd(const int&amp; sum, const int&amp; next) {
    return (sum * 2) + next;
}

int decimal = accumulate(array, array+ARRAY_SIZE,
                         doubleSumAndAdd);
</code></pre>

<p>This produces big-endian integers, whereas OP code produces little-endian.</p>
",0
14728235,14724627,0,"<p>The binary 'compression' can be generalized as a problem of weighted sum -- and for that there are some interesting techniques.</p>

<ul>
<li>X mod (255) means essentially summing of all independent 8-bit numbers. </li>
<li><p>X mod 254 means summing each digit with a doubling weight, since 1 mod 254 = 1, 256 mod 254 = 2, 256*256 mod 254 = 2*2 = 4, etc.</p>

<p>If the encoding was big endian, then *(unsigned long long)array % 254 would produce a weighted sum (with truncated range of 0..253). Then removing the value with weight 2 and adding it manually would produce the correct result:</p>

<p>uint64_t a = *(uint64_t *)array;
return (a &amp; ~256) % 254 + ((a>>9) &amp; 2);</p></li>
</ul>

<p>Other mechanism to get the weight is to premultiply each binary digit by 255 and masking the correct bit:  </p>

<pre><code>uint64_t a = (*(uint64_t *)array * 255) &amp; 0x0102040810204080ULL; // little endian
uint64_t a = (*(uint64_t *)array * 255) &amp; 0x8040201008040201ULL; // big endian  
</code></pre>

<p>In both cases one can then take the remainder of 255 (and correct now with weight 1):  </p>

<pre><code>return (a &amp; 0x00ffffffffffffff) % 255 + (a&gt;&gt;56); // little endian, or  
return (a &amp; ~1) % 255 + (a&amp;1);  
</code></pre>

<p>For the sceptical mind: I actually did profile the modulus version to be (slightly) faster than iteration on x64.</p>

<p>To continue from the answer of JasonD, parallel bit selection can be iteratively utilized.
But first expressing the equation in full form would help the compiler to remove the artificial dependency created by the iterative approach using accumulation:</p>

<pre><code>ret =  ((a[0]&lt;&lt;7) | (a[1]&lt;&lt;6) | (a[2]&lt;&lt;5) | (a[3]&lt;&lt;4) |
        (a[4]&lt;&lt;3) | (a[5]&lt;&lt;2) | (a[6]&lt;&lt;1) | (a[7]&lt;&lt;0));
</code></pre>

<p>vs.  </p>

<pre><code>HI=*(uint32_t)array, LO=*(uint32_t)&amp;array[4];
LO |= (HI&lt;&lt;4);    // The HI dword has a weight 16 relative to Lo bytes
LO |= (LO&gt;&gt;14);   // High word has 4x weight compared to low word
LO |= (LO&gt;&gt;9);    // high byte has 2x weight compared to lower byte
return LO &amp; 255;
</code></pre>

<p>One more interesting technique would be to utilize crc32 as a compression function; then it just happens that the result would be LookUpTable[crc32(array) &amp; 255]; as there is no collision with this given small subset of 256 distinct arrays. However to apply that, one has already chosen the road of even less portability and could as well end up using SSE intrinsics.</p>
",0
13789488,13789462,18,"<p>This is only possible with C++11 <a href=""http://en.wikipedia.org/wiki/C%2B%2B11#Strongly_typed_enumerations"" rel=""noreferrer"">strongly typed enums</a>:</p>

<pre><code>enum class MyEnum : unsigned char { E1, E2 };
</code></pre>

<p>See <a href=""http://en.cppreference.com/w/cpp/language/enum"" rel=""noreferrer"">here</a> for more information</p>
",1
14860088,14860063,7,"<p>Use the <a href=""http://www.cplusplus.com/reference/string/string/string/"" rel=""noreferrer""><code>std::string(size_t, char)</code> constructor</a>:</p>

<pre><code>std::cout &lt;&lt; std::string(10, 'x');
</code></pre>

<p>Note that, unlike in Python, this only works with chars and not with strings.</p>
",4
14860175,14860063,3,"<pre><code>void print(const char *s, int n)
{
   if (n &gt; 0) 
   {
      cout &lt;&lt; s;
      print(s, n - 1);
   }
}
</code></pre>

<p>should do the trick.</p>
",4
14860331,14860063,1,"<p>The most extensible/reusable way is to just create a function similar to Ed, above -- although I'd use a stringstream and not couple the function with the printing</p>

<p>IMO, NPE's answer is too restrictive by forcing it to be a single character only, and Ed's is more of a C answer than a C++ answer. As a side-benifit, the function also allows you to stream characters, integers, strings, etc.</p>

<pre><code>template &lt;class T&gt;
std::string multiplyString(int count, const T &amp;input)
{
    std::stringstream ss;
    for(int i = 0; i &lt; count; i++)
       ss &lt;&lt; T;
    return ss.str();
}

int main(argc, char *argv[])
{
    std::cout &lt;&lt; multiplyString(10, 'x') &lt;&lt; std::endl;
    std::cout &lt;&lt; multiplyString(5, ""xx"") &lt;&lt; std::endl;
    std::cout &lt;&lt; multiplyString(5, 1234) &lt;&lt; std::endl;
}
</code></pre>

<p>Best of luck</p>
",3
14861196,14860063,1,"<pre><code>std::generate_n(
    std::ostream_iterator&lt;char&gt;(std::cout, """"),
    10,
    [](){ return 'x'; }
);
</code></pre>
",1
14861251,14860063,0,"<p>Since no one else has offered a reasonable implementation:</p>

<pre><code>std::string
multiplyStrings( int count, std::string const&amp; original )
{
    std::string results;
    results.reserve( count * original.size() );  //  Just optimization
    while ( count &gt; 0 ) {
        results += original;
    }
    return results;
}
</code></pre>

<p>Creating the overloads for <code>operator*</code> from this would not be
difficult.  Defining them in namespace std <em>would</em> be undefined
behavior, but IMHO, there's a reasonably good chance that you
could get away with it anyway. </p>
",0
13695286,13695271,5,"<p>You should not include C++ files in other C++ files. This leads to doubly-defined symbols. Instead, you should create a header file with a forward declaration, include it in both files sharing the function, and compile the files separately:</p>

<p>numGen.h:</p>

<pre><code>int numGen();
</code></pre>

<p>Include <code>numGen.h</code> in both <code>cc</code> files, and remove <code>#include ""NumGen.cc""</code>.</p>
",0
13695290,13695271,1,"<p>You're including the cc file. Only include the actual header</p>
",0
13695343,13695271,3,"<p>By <code>#include</code>ing <code>NumGen.cc</code> in your <code>main.cc</code> file, you are causing the preprocessor to create two files like the following:</p>

<p><code>NumGen.cc</code>:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int numGen()
{
    int rNum;
    srand(time(NULL)); //--Seeds a random number.
    rNum = 1 + (rand() % 100);

    return rNum;
}
</code></pre>

<p>and <code>main.cc</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int numGen()
{
    int rNum;
    srand(time(NULL)); //--Seeds a random number.
    rNum = 1 + (rand() % 100);

    return rNum;
}

int main()
{
    std::cout &lt;&lt; numGen();
    return 0;
}
</code></pre>

<p>because the <code>#include</code> preprocessor directive just inserts the contents of the file you are including where you are including it (unless of course it's been included before and is wrapped in an include guard.  I'm also assuming that you are compiling both <code>NumGen.cc</code> and <code>main.cc</code> on the same command line, so naturally you'll get a multiply defined symbol error given the function <code>numGen</code> is now defined and implemented in both files.</p>

<p>What you have to do is forward declare <code>numGen</code> in a header file, let's call it <code>NumGen.h</code>:</p>

<pre><code>int numGen();
</code></pre>

<p>and then put the line <code>#include ""NumGen.h""</code> in both <code>NumGen.cc</code> and <code>main.cc</code>.</p>
",0
15514779,15514763,3,"<p>The distinction is when you have a reference or pointer to the base class. A call to a virtual function will call the most-derived version while a call to a normal function will call the base-class version.</p>

<p>If you're using a variable directly or a reference or pointer to the most-derived class, there is no practical difference.</p>
",0
15514801,15514763,5,"<p>An example says it best:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class A {
public:
  virtual void f1() { cout &lt;&lt; ""Class A"" &lt;&lt; endl; }
  void f2() { cout &lt;&lt; ""Class A"" &lt;&lt; endl; }
  virtual ~A(){}
};

class B : public A {
public:
  virtual void f1() { cout &lt;&lt; ""Class B"" &lt;&lt; endl; }
  void f2() { cout &lt;&lt; ""Class B"" &lt;&lt; endl; }
  virtual ~B(){}
};

int main()
{
  A *a = new B;
  a-&gt;f1();
  a-&gt;f2();
}
</code></pre>

<p>...</p>

<pre><code>$ ./override 
Class B
Class A
</code></pre>

<p>You can see that when we reference the instance of B, <code>f1()</code> still calls <code>B</code>'s version, but <code>f2()</code> calls <code>A</code>'s.</p>

<p>When you declare a function virtual, you are saying that when we call it we should use the vtable to look up the right version of the function to call, and so you will always get the most derived version of the function, even if you reference it as an ancestor type. Without virtual, it will simply use the definition in the type you are referencing it as.</p>
",0
15514862,15514763,2,"<p><strong>TL;DR</strong></p>

<p>The only way to take advantage of the polymorphism in C++ is via virtual functions and pointers (and references). The virtual keyword will tell the compiler to allocate a virtual function table where to look when deciding what version of the virtual function to call when dealing with pointer to the base class with a dynamic type that is of a child class.</p>

<p><strong>How does polymorphism work in C++</strong></p>

<p>Let's take a simple example:</p>

<pre><code>class A { public: virtual void eat() { std::cout &lt;&lt; ""Class A"" &lt;&lt; std::endl; }
class B : public A {};
class C : public B { virtual void eat() { std::cout &lt;&lt; ""Class C"" &lt;&lt; std::endl; }
</code></pre>

<p><em>Note: the virtual keyword could be omitted after the first function/method definition.</em></p>

<p>The following:</p>

<pre><code>A a; B b; C c;
A* ptrA = &amp;a; A* ptrB = &amp;b; A* ptrC = &amp;c;
ptrA-&gt;eat();
ptrB-&gt;eat();
ptrC-&gt;eat();
</code></pre>

<p>will print:</p>

<pre><code>Class A
Class A
Class C
</code></pre>

<p>If we wouldn't have declared the function <code>eat</code> virtual, the output would have simply been:</p>

<pre><code>Class A
Class A
Class A
</code></pre>
",0
15574055,15573891,0,"<p>The C# answer should work here as well.</p>

<pre><code>void replace(long pos, std::string filename, std::string replacement)
{
   std::ofstream out(filename.c_str());
   out.seekp(pos);

   out.write(replacement.c_str(), replacement.size());
}
</code></pre>
",1
13483966,13483942,1,"<p>You should read ""Programming Interviews Exposed - Secrets to Landing Your Next Job"", it's a very good book for programming interviews.</p>
",0
13776649,13776516,0,"<p>No, you cannot.  But you can do the following:</p>

<pre><code>class X_foo_friend;

class X
{
    void foo();
    friend class X_foo_friend;
};

class Y
{
    X x;
public:
    void bar();
};

class X_foo_friend
{
    static void foo(X&amp; x);
    friend void Y::bar();
};

void X::foo() {};
void X_foo_friend::foo(X &amp; x) { x.foo(); }

void Y::bar()
{
    X_foo_friend::foo(x);
}
</code></pre>

<p>IMO, this is rather silly.  I mean, you're the one designing both X and Y, so you could simply restrict your usage in Y of X's functions.</p>
",0
13776650,13776516,1,"<p>If I understand you question correctly, you want something like this:</p>

<pre><code>class X;

class Y {
public:
    void bar(X&amp; x);
    void baz(X&amp; x);
};

class X {
    void foo() { }
    friend void Y::bar(X&amp; x);
};

void Y::bar(X&amp; x)
{
    x.foo();
}

void Y::baz(X&amp;)
{
    // the following would be an error
    // baz wasn't befriended with X
    // x.foo();
}

int main()
{
    X x;
    Y y;
    y.bar(x);
}
</code></pre>

<p>Note the order of declarations and definitions, you need it like this so you can actually make something useful with <code>X</code> inside <code>Y::bar()</code>.</p>

<p>If fail to think of a case where this would be a good idea to do, though. If you fell you only need to befriend ""parts"" of your classes, then maybe your classes are having too many responsibilities.</p>
",2
13776717,13776516,0,"<p>I would possibly explore on the lines of an intermediate proxy using ADL concept. This is of course a partial implementation showing the concept.</p>

<pre><code>namespace XNProxy {
    class XNP;
}

namespace XN
{
    using XNProxy::XNP;

    class X {
        friend void f(X *);
    private:
        void foo() { };
    };

    void f(X* p) {
        X x;
        x.foo();
    }
}

namespace XNProxy 
{
    class XNP { };
    using XN::X;
    void f(XNP *) {
        f((XN::X *)nullptr);
    }
};

namespace YN
{
    class Y {
    public:
        void bar() { 
            XNProxy::XNP x;
            f((XNProxy::XNP*)nullptr);
        }
    };
}

int main() {
    YN::Y y;
    y.bar();
}
</code></pre>
",0
14814683,14813498,0,"<p>Hmmmn... I'm pretty sure that the readUInt function is used to convert a string number to actual number, i.e. equivalent to atoi() function. I think the WriteDigit is the reverse, but I'm not sure.</p>
",0
14815454,14813498,1,"<p>First, I see no evidence that this code is a good exemplar that merits your study. The complete lack of any comments in itself makes me mistrust the code. You don't say where you are stuck with this code, if you really want to understand it step through it in a debugger and it should become clear. To get you started, some observations about read.</p>

<p>It seems pretty clear that the readUint() and writeUint() methods are working against a buffer, presumably that ioSpace, though you don't show the actual calls so we can't be sure, but your</p>

<pre><code>  read(STDIN_FILENO, ioSpace, sizeof(ioSpace));
</code></pre>

<p>shows the iospace obtaining date from STDIN. Quite what happens if the file is bigger than iospace isn't clear from what you show. Nor is what error handling is done. </p>

<p>The code for readUint() goes:</p>

<pre><code> while ((c = *readPos++) &gt;= '0')
</code></pre>

<p>Which grabs the next character, and increments the readPosition. When we see that we should immediately wonder when we stop. in this case when the character c is not</p>

<pre><code> &gt;= '0'
</code></pre>

<p>in other words when the character we see is less than ascii '0' so that could be any characters such a '&amp;' or '#', but probably the author is expecting a newline '\n' as that seems to be what they terminate the number with in writeUint() - see what I mean about lack of comments? Then </p>

<pre><code>c - '0'
</code></pre>

<p>yields the numeric value of the character '9' - '0' is the ascii code for 9 less the ascii code for 0, 57 - 48 , which of course is 9. </p>

<pre><code>while ((c = *readPos++) &gt;= '0')
    num = num * 10 + (c - '0');
</code></pre>

<p>we then build the decimal value by mutiplying by 10 and adding our most recently read value.</p>

<p>Now this code is vulnerable to a file containing letters. Look at what would happen if you had a line such as</p>

<pre><code> 23A4\n
</code></pre>

<p>So you need to have some reason to trust your input if you are using this code.</p>

<p>Writing just grabs the individual digits from the number by calling the writedigit() function.</p>
",0
15594399,15594290,1,"<p>You basically want to know when default constructor and copy constructor are called.</p>

<p>For your first question:</p>

<pre><code>Fraction E[4], F = D; // Line 3
</code></pre>

<p><code>E[4]</code> is an array of <code>Fraction</code> objects, which calls the default constructor 4 times since you did not explicitly call any other constructor to initialize those objects. Since at Line 2 object <code>D</code> is already constructed, therefore, <code>F</code> is constructed using the copy constructor, in this case, the compiler generates one for you since you did not define one for yourself.
So in this case, 4 default constructor calls and one copy constructor call.
At Line 4, both objects calls the default constructor, so two times on default ctor.</p>

<pre><code>debug(B, C)
call the copy constructor twice to pass copies of Fraction objects B and C?
</code></pre>

<p>Yes, since parameters are passed by value in <code>debug</code> function, so copy constructor is called for both <code>B</code> and <code>C</code></p>

<p>In general, copy constructor are called in the following situation:</p>

<ol>
<li>When instantiating one object with an existing object (as <code>F= D</code> or <code>F(D)</code>)</li>
<li>When passing an object by value.</li>
<li>When an object is returned from a function by value.</li>
</ol>

<p>Hope that this gives you enough information to understand the code.</p>
",5
13787912,13787702,6,"<p>Parsing is usually done on streams, not strings, but you can use a <code>stringstream</code>.</p>

<pre><code>std::istringstream date_s( ""04\\10\\1984"" );
struct tm date_c;
date_s &gt;&gt; std::get_time( &amp;date_c, ""%d\\%m\\%Y"" );
std::time_t seconds = std::mktime( &amp; date_c );
</code></pre>

<p>Now you can compare seconds using <code>&lt;</code> to determine which was earlier.</p>

<p>Note, <a href=""http://en.cppreference.com/w/cpp/io/manip/get_time"" rel=""nofollow noreferrer""><code>std::get_time</code></a> is new in C++11. It is defined in terms of <code>strptime</code>, which is from POSIX but not part of the C99 standard. You can use <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html"" rel=""nofollow noreferrer""><code>strptime</code></a> if a C++11 library is not available. If you're brave, you can also use the <code>std::time_get</code> facet¡­ it's ugly though.</p>

<p>If you don't want to know anything about the dates other than which is earlier, you can use <code>std::lexicographical_compare</code>. It would be a one-liner but the function name is so long.</p>

<pre><code>// return true if the date string at lhs is earlier than rhs
bool date_less_ddmmyyyy( char const *lhs, char const *rhs ) {
    // compare year
    if ( std::lexicographical_compare( lhs + 6, lhs + 10, rhs + 6, rhs + 10 ) )
        return true;
    if ( ! std::equal( lhs + 6, lhs + 10, rhs + 6 ) )
        return false;
    // if years equal, compare month
    if ( std::lexicographical_compare( lhs + 3, lhs + 5, rhs + 3, rhs + 5 ) )
        return true;
    if ( ! std::equal( lhs + 3, lhs + 5, rhs + 3 ) )
        return false;
    // if months equal, compare days
    return std::lexicographical_compare( lhs, lhs + 2, rhs, rhs+2 );
}
</code></pre>

<p>See also <a href=""https://stackoverflow.com/questions/1002542/how-to-convert-datetime-to-unix-timestamp-in-c"">how to convert datetime to unix timestamp in c?</a> .</p>
",1
13787960,13787702,1,"<p>You need to extract the numeric data from the string. Worst case scenario is a bunch of loops and string to integer conversion functions. </p>

<p>You can do it easily with sscanf and sprintf. If you're used to <a href=""http://en.cppreference.com/w/cpp/io/c/fprintf"" rel=""nofollow""><code>printf</code></a> and <a href=""http://en.cppreference.com/w/cpp/io/c/fscanf"" rel=""nofollow""><code>scanf</code></a> then this is simple to understand, and you can easily adapt it to other cases. There are no secret magic function calls.</p>

<pre><code>#include &lt;stdio.h&gt;
void main()
{
    char* date1 = ""9\\12\\2012""; 
    char* date2 = ""6\\11\\2013""; 

    int day1,month1,year1;
    int day2,month2,year2;

    sscanf(date1,""%d\\%d\\%d"",&amp;day1,&amp;month1,&amp;year1); //reads the numbers
    sscanf(date2,""%d\\%d\\%d"",&amp;day2,&amp;month2,&amp;year2); //from the string

    if (year1&lt;year2 || month1&lt;month2 || day1&lt;day2) //compares 2 dates
    {
        printf(""date1 &lt; date2\n"");
    }
    else
    {
        printf(""date1 &gt;= date2\n"");
    }

    char newdate[15];

    sprintf(newdate,""%d\\%d\\%d"",13,2,1998); //make a date string from numbers
    printf(""%s\n"",newdate);
}
</code></pre>
",3
13788001,13787702,2,"<p>If this is really a fixed format, you can do it with simple C string comparison</p>

<pre><code>int date_cmp(const char *d1, const char *d2)
{
    int rc;
    // compare years
    rc = strncmp(d1 + 6, d2 + 6, 4);
    if (rc != 0)
        return rc;

    // compare months
    rc = strncmp(d1 + 3, d2 + 3, 2);
    if (rc != 0)
        return rc;

    // compare days
    return strncmp(d1, d2, 2);
}
</code></pre>

<p>This works like <a href=""http://linux.die.net/man/3/strncmp"" rel=""nofollow""><code>strncmp</code></a>. It returns a value less than 0, if <code>d1</code> is earlier than <code>d2</code>, 0 if both are the same date, and a value greater than 0, if <code>d1</code> is later than <code>d2</code>.</p>

<p>Another approach would be to convert it with <a href=""http://linux.die.net/man/3/strptime"" rel=""nofollow""><code>strptime</code></a> and <a href=""http://linux.die.net/man/3/mktime"" rel=""nofollow""><code>mktime</code></a> to <code>time_t</code> and compare these with <a href=""http://linux.die.net/man/3/difftime"" rel=""nofollow""><code>difftime</code></a></p>

<pre><code>struct tm tm;
time_t t1, t2;
strptime(d1, ""%d\\%m\\%Y"", &amp;tm);
t1 = mktime(&amp;tm);
// do the same with d2
double diff = difftime(t1, t2);
</code></pre>
",0
17408394,17408325,0,"<p>1) The value the iterator points to can be anything, and not necessarily a value that can represent a count. count returns a numeric type, and the numeric type of choice is the difference_type of the iterator.</p>

<p>2) Again, value_type is the type of the thing the iterator points to, and not necessarily a numeric value.</p>
",2
17408415,17408325,1,"<p>1) <code>std::count</code> is supposed to count things that are equal to something. So if your container holds, for example, apples, it would not be useful to return an apple object, because an apple is not useful for counting apples (at least not the kind of apples I have in mind)</p>

<pre><code>std::vector&lt;Apple&gt; apples = ...;
Apple an_apple;
auto n = std::count(apples.begin(), apples.end(), an_apple);
</code></pre>

<p>Here, the type of <code>n</code> must be something that allows you to count a potentially large number of things. You are counting how many <code>Apple</code> objects are the same as <code>an_apple</code>.</p>

<p>2) <code>std::find</code> has to give you back something that can be used as a handle to an element of a container <em>and</em> to check whether the element exists or not. An iterator provides a good means to do exactly this. It would make no sense to return a value because a) you already have a copy of what you are looking for and b) you cannot generally return a ""null"" value to indicate that an element has not been found.</p>
",2
17408445,17408325,1,"<p>The <code>std::count</code> is supposed to return <em>count</em> of certain element, and therefore the return type needs to be an integral type, but <code>T</code> is not necessarily an integral type, as it could be anything (it is the type of the element, to be precise).</p>
",0
17408652,17408325,0,"<p>Why would you want find() to return object you've just specified in find() function? What find does is looking for a place inside container where the object you're are looking is stored.</p>
",1
15496742,15496427,1,"<p>I prefer to use <a href=""http://valgrind.org/docs/manual/ms-manual.html"" rel=""nofollow"">the valgrind <em>massif</em> heap profiler</a> on linux:</p>

<pre><code>valgrind --tool=massif ./testprogram
</code></pre>

<p>Then, </p>

<pre><code>ms_print ./massif.out.16766 # replace with actual generated name
</code></pre>

<p>Will give you a chart with samples and peak heap usage, and a breakdown like so</p>

<pre><code>19.63^                                               ###                      
     |                                               #                        
     |                                               #  ::                    
     |                                               #  : :::                 
     |                                      :::::::::#  : :  ::               
     |                                      :        #  : :  : ::             
     |                                      :        #  : :  : : :::          
     |                                      :        #  : :  : : :  ::        
     |                            :::::::::::        #  : :  : : :  : :::     
     |                            :         :        #  : :  : : :  : :  ::   
     |                        :::::         :        #  : :  : : :  : :  : :: 
     |                     @@@:   :         :        #  : :  : : :  : :  : : @
     |                   ::@  :   :         :        #  : :  : : :  : :  : : @
     |                :::: @  :   :         :        #  : :  : : :  : :  : : @
     |              :::  : @  :   :         :        #  : :  : : :  : :  : : @
     |            ::: :  : @  :   :         :        #  : :  : : :  : :  : : @
     |         :::: : :  : @  :   :         :        #  : :  : : :  : :  : : @
     |       :::  : : :  : @  :   :         :        #  : :  : : :  : :  : : @
     |    :::: :  : : :  : @  :   :         :        #  : :  : : :  : :  : : @
     |  :::  : :  : : :  : @  :   :         :        #  : :  : : :  : :  : : @
   0 +-----------------------------------------------------------------------&gt;KB     0                                                                   29.48

Number of snapshots: 25
 Detailed snapshots: [9, 14 (peak), 24]
</code></pre>

<p>The breakdowns would be like</p>

<pre><code>--------------------------------------------------------------------------------
  n        time(B)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
 10         10,080           10,080           10,000            80            0
 11         12,088           12,088           12,000            88            0
 12         16,096           16,096           16,000            96            0
 13         20,104           20,104           20,000           104            0
 14         20,104           20,104           20,000           104            0
99.48% (20,000B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
-&gt;49.74% (10,000B) 0x804841A: main (example.c:20)
| 
-&gt;39.79% (8,000B) 0x80483C2: g (example.c:5)
| -&gt;19.90% (4,000B) 0x80483E2: f (example.c:11)
| | -&gt;19.90% (4,000B) 0x8048431: main (example.c:23)
| |   
| -&gt;19.90% (4,000B) 0x8048436: main (example.c:25)
|   
-&gt;09.95% (2,000B) 0x80483DA: f (example.c:10)
  -&gt;09.95% (2,000B) 0x8048431: main (example.c:23)
</code></pre>
",1
15496904,15496427,0,"<p>Straight <code>sizeof()</code> of struct will return compile-time size, i.e. it will not take in consideration actual size of containers. So, you probably want to manually iterate through each container and add up sizes of each element.</p>

<p>But easier way for you is probably to use profiler (e.g. gprof (GNU Profiler)) or any other</p>
",3
13445325,13445219,0,"<p>Somewhere in your code, you are using the assignment operator on one of your <code>Student</code> objects.  But you haven't specially defined the assignment operator, you are just using the compiler-generated one.  But the compiler-generated assignment operator does not work when you have reference members.  Either disable the assignment operator (by making it private, or deleting it), or make the ostream member a pointer, instead of a reference. This is all assuming you really need this ostream object in your class, which I find suspect.</p>
",0
13445378,13445219,1,"<p>The problem with the code is, clearly, the <code>std::ostream&amp;</code> member in your class. Semantically, I doubt that it actually makes sense to have this member. However, let's assume for a moment that you want to keep it. There are a few implications:</p>

<ol>
<li>Any user-defined constructor needs to explicitly initialize the reference in its member initializer list. The compiler will refuse to accept the constructor otherwise.</li>
<li>The compiler won't be able to create an assignment operator because it doesn't know what should happen when assigning reference.</li>
</ol>

<p>The error message seems to be about the assignment operator. You can work around this problem by defining an assignment operator explicitly, e.g.</p>

<pre><code>Student&amp; Student::operator= (Student const&amp; other) {
    // assign all members necessary here
    return *this;
}
</code></pre>

<p>However, a better solution is to drop the reference parameter. You probably don't need it anyway: there are few classes for which it makes sense to store an <code>std::ostream&amp;</code> member. Most of the time any stream is an ephemeral entity, temporarily used to send objects to or to receive objects from.</p>
",0
16424530,16424489,3,"<pre><code>myRectangle mr(5);
</code></pre>

<p>Here, <code>mr</code> is a <code>myRectangle</code> instance, constructed using the <code>myRectangle</code> constructor that takes a single int parameter.</p>

<pre><code>myRectangle mr ();
</code></pre>

<p>Here, <code>mr</code> is a function with no parameters and returning a <code>myRectangle</code>. It is a confusing parse that can be avoided in C++11 by using brace initialization. It can also be avoided by omitting the brackets:</p>

<pre><code>myRectangle mr; //  C++03 and C++11
myRectangle{};  //  C++11
</code></pre>
",0
16424535,16424489,1,"<p>Inside:</p>

<pre><code> void runObject() 
 {
     myRectangle mr ();
 }
</code></pre>

<p><code>myRectangle mr();</code> is not creating an object of <code>myRectangle</code>, but rather, declares a function with name <code>mr</code> that takes no parameter and return type is <code>myRectangle</code>.</p>
",1
16424536,16424489,1,"<p><code>myRectangle mr = myRectangle();</code> instantiates and constructs an instance of the class <code>myRectangle</code>. In contrast, <code>myRectangle mr ();</code> declares <code>mr</code> as a function returning <code>myRectangle</code> and taking no arguments.</p>
",1
17814711,17814652,2,"<pre><code>fprintf(FILE*, ....)
</code></pre>

<p>but it isn't wise to mix and match.  Use new-style streams wherever possible.</p>

<p><a href=""http://www.cplusplus.com/reference/ios/ios_base/setf/"" rel=""nofollow"">http://www.cplusplus.com/reference/ios/ios_base/setf/</a></p>
",0
17814802,17814652,0,"<p>Have you tried <a href=""http://www.boost.org/doc/libs/1_54_0/libs/format/"" rel=""nofollow"">Boost.Format</a>, it uses <em>printf()</em> compatible format strings.</p>
",0
17814810,17814652,1,"<p>If you're looking for a printf-like solution in C++, I'd suggest <a href=""http://www.boost.org/doc/libs/1_54_0/libs/format/doc/format.html"" rel=""nofollow"">Boost.Format</a> library:</p>

<pre><code>myfile &lt;&lt; boost::format(""%s\\\n"") % ""something"";
</code></pre>
",0
13750223,13750192,5,"<p>There's a couple of bugs in the following <code>new</code> call. You need to use square brackets; also, the argument is off by one.</p>

<pre><code>lstring=new char[strlen(tokenized1[i]) + 1];
</code></pre>

<p>Without the square brackets, your are allocating space for <em>one</em> character. As a result, the <code>memcpy()</code> writes past the allocated memory.</p>

<p><strong>edit:</strong> I just noticed the other <code>new</code>, which will also need to be fixed:</p>

<pre><code>input=new char[s.size() + 1];
</code></pre>

<p>Finally, <code>s[i]</code> reads past the end of the string in:</p>

<pre><code>for(i=0;i&lt;=s.size();i++)
    input[i]=s[i];
</code></pre>

<p>There could well be other bugs, not to mention memory leaks...</p>
",0
13750233,13750192,0,"<p>You don't appear to be zero terminating 'input'</p>
",0
13750407,13750192,0,"<p>In addition to what NPE said, there's a couple of other small things:</p>

<pre><code>char *input;
input=new char(s.size());
</code></pre>

<p>This might have something to do with it - you are allocating a <em>single</em> character. You then write that one character, and overwrite other memory that is used for who-knows-what. Try this instead:</p>

<pre><code>char *input = new char[s.size() + 1];
</code></pre>

<p>Another issue is your loop, immediately below that:</p>

<pre><code>for(i=0;i&lt;=s.size();i++)
        input[i]=s[i];
</code></pre>

<p>At least on <em>my</em> system, using std::string::operator[] with an offset equal to s.size() fails; I don't know about your particular implementation, but I'm pretty it fails as well. Be safe, rather than sorry, and recode your loop thusly:</p>

<pre><code>for(i = 0; i &lt; s.size(); i++)
    input[i] = s[i];

input[i] = 0;
</code></pre>

<p>I hope this helps.</p>
",1
18278666,18278605,2,"<p>If you can set a breakpoint you can examine the call stack.</p>
",0
18278742,18278605,2,"<p>My first question would have to be: Why would you want to do this?</p>

<p>Having said that, there is absolutely no portable way to do this.  With GCC, and Clang to the best of my knowledge, you can use __builtin_return_address(0), but with Visual Studio (which I presume you are using, given exe/dll), I can't offer up any equivalent.</p>

<p>Normally if you are doing this, you need to look at your design, as there should be no reason to get the calling address unless you are writing, say, a trampoline function.</p>
",0
18278795,18278605,1,"<p>As chmeee said, there is no portable method for doing this.  On Windows, there are a set of debugging functions (which you can use in your code) to accomplish it (in a way):  <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms679303(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/ms679303(v=vs.85).aspx</a></p>
",0
18278938,18278605,0,"<p>If you are on Windows, you probably could use functions provided in dbghelp library. I think you could use the <a href=""http://msdn.microsoft.com/en-us/library/dn280332%28v=vs.85%29.aspx"" rel=""nofollow"">StackWalkEx</a>. </p>

<p>You can find an <a href=""http://www.codeproject.com/Articles/11132/Walking-the-callstack"" rel=""nofollow"">example on CodeProject</a>. It says:</p>

<blockquote>
  <p>The usage of the class is very simple. For example if you want to
  display the callstack of the current thread, just instantiate a
  StackWalk object and call the ShowCallstack member:</p>
</blockquote>

<pre><code>#include &lt;windows.h&gt;
#include ""StackWalker.h""

void Func5() { StackWalker sw; sw.ShowCallstack(); }
void Func4() { Func5(); }
void Func3() { Func4(); }
void Func2() { Func3(); }
void Func1() { Func2(); }

int main()
{
  Func1();
  return 0;
}
</code></pre>
",0
18278827,18278605,-2,"<p>I generally throw a fake exception. It has worked in Java. (and C++ in my past years). 
Like </p>

<pre><code>try {
    throw(new Exception());
}
catch(Exception e) {
    e.printStackTrace();
}
</code></pre>

<p>The only other programmatic way I know of is to use Aspects (AOP).</p>
",0
18279175,18278605,1,"<p>If it's your code, pass the caller's name as one of the parameters to the function.</p>

<p>Otherwise, there's no portable way to do this. And even the non-portable ways are not necessarily going to work exactly as you expect. Introspection is not C++'s thing.</p>
",0
14839853,14839725,5,"<p>Yes, you are on the right track. Your general structure is sound. These sorts of homework assignments almost always have a structure like this:</p>

<pre><code>int main () {
  // read in the data
  ...

  // Do the math
  ...

  // Write out the data
  ...
}
</code></pre>

<p>You do have some math errors. Try stepping through the code with a pencil and paper, pretending that <strong>you</strong> are the computer. Also, try stepping through the code with your debugger, examining the variables after each line. Compare what actually happened to what you expected.</p>
",4
14838623,14838551,1,"<p>Yes, it's fine. The standard does it all the time. As an example, consider <a href=""http://en.cppreference.com/w/cpp/iterator/back_inserter"" rel=""nofollow""><code>std::back_inserter</code></a> which, as your example does, presumes that its template type implements a <code>push_back</code> member function. While we still don't have <a href=""http://en.wikipedia.org/wiki/Concepts_%28C%2B%2B%29"" rel=""nofollow"">concepts</a> though, you had  better document your requirements. It also helps to name your template types in a meaningful way; so instead of <code>template &lt;typename T&gt;</code>, you might have <code>template &lt;typename Container&gt;</code>.</p>
",0
14838633,14838551,2,"<p>What you're describing is called a template policy (see <a href=""http://en.wikipedia.org/wiki/Policy-based_design"" rel=""nofollow"">this</a>) and it's a perfectly legitimate and common design pattern for classes or functions.</p>
",0
14838679,14838551,2,"<p>Sure.  Just document the requirements on template parameters when describing the class template.</p>

<p>Note that in your example, <code>T</code> actually only needs a <code>push_back</code> function if the default constructor <code>Foo&lt;T&gt;()</code> is used.  (As far as the language is concerned.  Your requirements could be stricter to be on the safe side.)</p>

<p>If you're using a recent compiler, you can also use <code>static_assert</code> to make sure most template parameter requirements are obeyed, and/or to make the error messages when a requirement is disobeyed more legible.</p>
",1
15849735,15849725,9,"<p>You forgot a <code>typedef</code>, to declare the type. Otherwise this declaration just creates a variable of type <code>int(*)(Medicine*,Medicine*)</code>.</p>

<pre><code>  typedef int (*filterFunc)(Medicine* criteria, Medicine*);
//^^^^^^^
</code></pre>
",1
15892954,15892928,1,"<p>Assuming</p>

<pre><code>int *p = NULL;
</code></pre>

<p>Then:</p>

<pre><code>if (p)
</code></pre>

<p>checks whether p is NULL or not and will return false.</p>

<pre><code>if (*p)
</code></pre>

<p>checks whether <code>(*p) == 0</code>, i.e. the integer pointed by <code>p</code> is 0 or not.</p>

<p>if you have</p>

<pre><code>int *p;
</code></pre>

<p>i.e., without initializing it, then <code>p</code> will point to random address in your memory, and</p>

<pre><code>if (p)
</code></pre>

<p>will most of the time return true. and </p>

<pre><code>if (*p)
</code></pre>

<p>will give undefined behavior.</p>
",3
14784039,14783999,6,"<p>You have the wrong direction of the the stream operator: Use <code>cin &gt;&gt; entry[i];</code> . A good way of remembering this is thinking of the operator as an arrow: For output, you point the stuff you want to output towards <code>cout</code>, for input, you point the values from <code>cin</code> towards the variable that should store the input.</p>

<p>By default, <code>cin &gt;&gt; ...</code> handles whitespace (spaces, tabs, newlines) automatically, so there is no need for the <code>&gt;&gt; endl</code> either.</p>

<p>Finally, the previous loop setting <code>entry[i] = i;</code> does not do anything useful in your current program as all the entries are overwritten anyways when the users input their values.</p>
",0
13772194,13772193,7,"<p>It's actually <code>int main()</code>, and the end must return an integer (so make the last line above ""}"" <code>return 0;</code> (indicates a successful run, anything non-zero is otherwise).</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int errors;

int main(arg stuff) {
    std::cout &lt;&lt; ""C++!"";

    if (errors &gt; 0)
         return 1;

    return 0;
}
</code></pre>
",3
13474915,13474713,3,"<p>Much of your code involving inputString is invalid.  There is no getline member of <code>istream</code> that takes a <code>std::string</code>, so this is invalid:</p>

<pre><code>cin.getline(inputStr,200);
</code></pre>

<p>What you want there instead is the global getline:</p>

<pre><code>getline(cin, inputStr);
</code></pre>

<p>Second, there is no global getline which reads directly from a <code>std::string</code>, so this is invalid:</p>

<pre><code>strVector[i]=getline(inputStr,"" "");
</code></pre>

<p>What you want to use there is an <code>istringstream</code>.  Altogether, your code might look something like this:</p>

<pre><code>std::getline(std::cin, inputStr);
std::istringstream iss(inputStr);
std::string word;
// read from the istringstream until failure
while (std::getline(iss,word,' '))
    strVector.push_back(word);
</code></pre>

<p>If you want to delimit on whitespace(including tabs) then you can use <code>operator&gt;&gt;</code> instead of getline.</p>
",8
13475293,13474713,0,"<p>Here is nother way:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;


using namespace std;



int main(int argc, char *argv[])
{
    vector&lt;string&gt; strVec;
    string str;
    cout&lt;&lt;""Enter # to quit \n\n"";
    int i=0;


    while (str!=""#"")
    {  
        cout&lt;&lt;""Input text No. ""&lt;&lt;i+1 &lt;&lt;"" here &gt; "";
        cin&gt;&gt;str ;
        strVec.push_back(str);


        i++;
    } 

    cout&lt;&lt;""\nStored text\n----------\n"";
    for (int j=0; j&lt;strVec.size()-1; j++)    cout&lt;&lt;j+1&lt;&lt;""  ""&lt;&lt; strVec[j]&lt;&lt;""\n"";


    cout&lt;&lt;""\n\n"";

    return(0);
}
</code></pre>
",0
13474762,13474713,1,"<p>I think you are looking for the <a href=""http://www.cplusplus.com/reference/stl/vector/push_back/"" rel=""nofollow""><code>push_back</code></a> method of the <code>std::vector</code> template</p>
",0
13783133,13783068,5,"<p>In your update you added this code:</p>

<pre><code>C = (int**) new int*[m];
for(i=0;i&lt;n;i++)
{
    C[i]=new int[n];
}
</code></pre>

<p>The loop condition is incorrect. Instead of <code>i&lt;n</code> you need <code>i&lt;m</code>.</p>

<p>Your multiplication loop looks like this:</p>

<pre><code>for(i=0;i&lt;m;i++)
{
    for(j=0;j&lt;n;j++)
    {
        for(int k=0;k&lt;l;k++)
        {
            sum =+ A[i][k]*B[k][j];
        }
    }
    C[i][j]=sum; 
}
</code></pre>

<p>The assignment <code>C[i][j]</code> is in the wrong block¨Cthe <code>[j]</code> array access is out-of-bounds. </p>

<p>It should be like this:</p>

<pre><code>for(i=0;i&lt;m;i++)
{
    for(j=0;j&lt;n;j++)
    {
        sum = 0;
        for(int k=0;k&lt;l;k++)
        {
            sum =+ A[i][k]*B[k][j];
        }
        C[i][j]=sum; 
    }
}
</code></pre>

<p>Note that I have initialised <code>sum</code> to 0 every time a new <code>j</code> loop is started. That corrects another error in your code.</p>

<p>It would be a lot better if you declared the variables with the tightest scope possible. Like this:</p>

<pre><code>for(int i=0;i&lt;m;i++)
{
    for(int j=0;j&lt;n;j++)
    {
        int sum = 0;
        for(int k=0;k&lt;l;k++)
        {
            sum =+ A[i][k]*B[k][j];
        }
        C[i][j]=sum; 
    }
}
</code></pre>

<p>Had you done that the compiler would have rejected your original placement of the assignment to <code>C[i][j]</code>.</p>

<p>Your <code>main</code> function should be declared like this:</p>

<pre><code>int main()
</code></pre>

<p>and you should return a value from your <code>main()</code>.</p>
",6
13790961,13790832,2,"<p>First off, the code shows that <code>class Event</code> is self-contained. Which is to say that <code>head</code> and <code>nxt</code> are part of the object itself. If you wish to use a Linked List of objects linking to each other but not maintaining the <code>head</code> outside then I would do the following...</p>

<pre><code>// event.cpp
event::event() {
    head = NULL;
}

event::event(int date, string name): date(date), name(name) {
    head = NULL;
}

event::event(event *prev, int date, string name): date(date), name(name) {
    if (prev-&gt;head != NULL) {
        this-&gt;head = prev-&gt;head;
    } else {
        prev-&gt;head = this-&gt;head = prev;
    }
    prev-&gt;nxt = this;
    this-&gt;nxt = NULL;
}
</code></pre>

<p>An example of using this would be as follows:</p>

<pre><code>event *tailEvent = new event(1, 'first');
event *nextEvent = new event(tailEvent, 2, 'second');
event *thirdEvent = new event(nextEvent, 3, 'third');
...
tailEvent = lastEvent;
</code></pre>

<p>and so on and so forth. So, <code>tailEvent-&gt;head</code> will always point to the first created event and the <code>tailEvent-&gt;nxt</code> will follow in the list.</p>

<p>BUT... This is highly prone to errors, so I would recommend keeping the list itself outside, if possible using STL. See <a href=""http://learningcppisfun.blogspot.in/2005/10/sample-linked-list.html"" rel=""nofollow"">Learning C++: A sample linked list</a> for an example.</p>

<p>EDIT:</p>

<p>Better approach:-</p>

<pre><code>class Event {
    private:
        Event *next;
        int date;
        string name;

    public:
        Event() {};
        Event(int date, string name) : date(date), name(name) {};
        setNext(Event *next) { this-&gt;next = next; };
        int date() { return date; };
        string name() { return name; };
        Event *next() { return next; };
};

class EventList {
    private:
        Event *head;

    public:
        EventList() { head = NULL };
        void add(int date, string name);
        Event *head() { return head; }
}

void EventList::add(int date, string name) {
    Event *newEvent = new Event(date, name);
    newEvent-&gt;setNext(NULL);
    Event *tmp = head;
    if (tmp != NULL) {
        while (tmp-&gt;next() != NULL) tmp = tmp-&gt;next();
        tmp-&gt;setNext(newEvent);
    } else {
        head = newEvent;
    }
}
</code></pre>
",0
13790902,13790832,1,"<p>A better approach is to have two classes here: One to store each event and another to manage and store information about the list.</p>

<p>There will be many event classes in your list. There will only be one list class.</p>

<p>Now, your event class will in fact need some helper methods such as next and previous pointers. You can implement them directly or create a third class that is either inherited from or have it contain the event class.</p>

<p>But either way, the class that manages the list should only require one instance. And in that instance the head can be initialized to null, and it will be updated as needed.</p>
",0
13790919,13790832,1,"<p>You need some controlling code for your list. List items cannot control themself. </p>

<p>I would recommend you use a container std::list which implements all list operations. </p>

<p>If you want to implement your list, you should create controlling class, eg EventContainer and implement insert/delete and search operations.</p>
",0
13720530,13720173,1,"<pre><code>while(!read.eof())
{
    read.getline(temp, TEMP_SIZE);
    ...
}
</code></pre>

<p>is not the way to write a read file loop in C++. <code>eof()</code> only returns true <strong>after</strong> an attempt to read past the end of the file, so you execute the body of the loop one time too many.</p>

<p>The correct way to write the loop is as follows:</p>

<pre><code>for (;;)
{
    read.getline(temp, TEMP_SIZE);
    if (read.failed())
        break;
    ...
}
</code></pre>

<p>or more idiomatically:</p>

<pre><code>while (read.getline(temp, TEMP_SIZE))
{
    ...
}
</code></pre>

<p>which means exactly the same thing.</p>

<p>Note also that I have used <code>failed()</code> instead of <code>eof()</code> - end-of-file is not the only reason reading could fail.</p>
",0
13768562,13768463,0,"<p>You'll need to be able to insert copies for the items stored in STL containers, that's why it's not allowed.</p>

<p>You may still use const references to export containers for read only access via a <code>const_iterator</code>from a class method (getter).</p>
",0
13768663,13768463,4,"<p>Items in a vector must be copy-constructible or (as of C++11) move-constructible.</p>

<p>The key in a map only needs to be destructible, not copy/move constructible, so the requirements are much looser in this respect.</p>

<p>As to why that is, it's pretty simple: when/if a vector gets resized, the data from the existing buffer must be copied or moved into the new buffer. By contrast, a map normally stores its contents as nodes in a tree. Once a node is created, it will simply exist until it is destroyed. While the tree does need balancing at times, that only requires manipulating pointers between the nodes -- the key in the node is never modified after the node is created.</p>
",0
19503803,13789152,0,"<p>The following code is part of what I think you need.  This code will take a number of elements as input and preps the vector on the CPU, then it does the bit shift operations in parallel on the GPU.  Then I set av[elements] back to 0 because I am using that element to store your final result.  It's rough, but AMP is pretty restrictive about what data types can be processed on the GPU, so I just use an extra element of the existing array for it.  After the bit shifting is done, I do another parallel for each for the bitwise OR function.  This one also happens on the GPU, but it is less satisfactory because every operation is ORing any given element of the array with exactly the av[elements] element, so that will create a bottleneck.  Your tree structure will make this part run much more quickly, but I was unable to figure out how to do that part easily.  As it is, this program can process 100 million elements in a couple seconds on a fairly old computer.  Apologies in advance for any best-practice violations in the code; I am a novice as well.  The code follows:</p>

<pre><code>#include &lt;conio.h&gt;
#include &lt;amp.h&gt;
#include &lt;iostream&gt;

using namespace concurrency;
using namespace std;

unsigned int doParallel(unsigned int);

unsigned int elements;

void main()
{
    int ch=NULL;
    cout&lt;&lt;""\nHow many elements to populate: "";
    cin&gt;&gt;elements;
    cout&lt;&lt;""The result is: ""&lt;&lt;doParallel(elements);
    cout&lt;&lt;""\nPress 'X' to exit."";
    do
    {
        ch=_getch();
    } while (ch!='X' &amp;&amp; ch!='x');
    exit(0);
}

unsigned int doParallel(unsigned int elements)
{
    vector&lt;unsigned int&gt; v(elements+1);

    for (unsigned int i = 0; i&lt;elements+1;i++)
        {
            v[i]=i;
        }
    array_view&lt;unsigned int,1&gt; av(elements+1,v);

    parallel_for_each(av.extent,[=](index&lt;1&gt; idx)
        restrict(amp)
        {
            av[idx] = static_cast&lt;unsigned int&gt;(av[idx])&lt;&lt;1;
        });
    av[elements]=0;
    parallel_for_each(av.extent,[=](index&lt;1&gt; idx)
    restrict(amp)
    {
        av[elements] |= static_cast&lt;unsigned int&gt;(av[idx]);
    });

    return av[elements];
}
</code></pre>
",0
13777124,13776751,1,"<p>Wrap the outer vector into a class which just provides at, begin, end and operator []. Let the class take only have one constructor taking its capacity.  </p>

<p>This most probably the best way.</p>
",1
13776822,13776751,2,"<p>by <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow"">definition</a>, </p>

<blockquote>
  <p>Vectors are sequence containers representing arrays that can change in
  size. Just like arrays, vectors use contiguous storage locations for
  their elements, which means that their elements can also be accessed
  using offsets on regular pointers to its elements, and just as
  efficiently as in arrays. But unlike arrays, their size can change
  dynamically, with their storage being handled automatically by the
  container.</p>
</blockquote>

<p>if you aren't looking to have a data structure that changes in size, a vector probably isn't the best choice for an outer layer, How about using an array of vectors. This way the array is of a fixed size and cannot be modified, while still having the freedom of having its size declared in runtime.</p>

<pre><code>vector&lt;int&gt; *outer;
int VectSize;
cout &gt;&gt; ""size of vector array?""
cin &gt;&gt; VectSize;
outer = new vector&lt;int&gt;[VectSize]; //array created with fixed size
outer.push_back() //not happening
</code></pre>
",0
13776830,13776751,1,"<pre><code>const vector&lt;unique_ptr&lt;vector&lt;int&gt;&gt;&gt; outer = something(n);
</code></pre>

<p>For the something, you might write a function, like this:</p>

<pre><code>vector&lt;unique_ptr&lt;vector&lt;int&gt;&gt;&gt; something(int n)
{
    vector&lt;unique_ptr&lt;vector&lt;int&gt;&gt;&gt; v(n);
    for (auto &amp; p : v)
        p.reset(new vector&lt;int&gt;);
    return v;
}
</code></pre>
",0
14214999,14214937,2,"<pre><code>class clasName{
 int x1= 0;
 int x2= 0;
 int x3= 0;
 int x4= 0;
 int x5= 0;
}
</code></pre>

<p>Only in C++11.</p>
",6
14215060,14214937,3,"<p>Value initialization:</p>

<pre><code>struct X
{
    int i, j;
};

X* x = new X(); // The '()' are required.
// 0 == x-&gt;i &amp;&amp; 0 == x-&gt;j
</code></pre>
",3
14215119,14214937,5,"<pre><code>class A
{
    int x_; 
    int y_; 

    public: 
        A() 
           : 
             x_(0),
             y_(0)
        {} 
};
</code></pre>

<p>The part of the A() constructor before the brackets ""{}"" is called an ""initializer list"", which you use to initialize the variables to a default value 0 in the case above, or to some other values that may be passed to a constructor that might take those values as arguments. However you initialize an object of type A (e.g. with ""new""), the attributes will be initialized to those values. It is good coding style to initialize the attributes in the same order they are declared, it makes the code more readable.</p>
",8
14187223,14187217,7,"<p>You can't assign arrays, and </p>

<pre><code>usrname = ""User""
</code></pre>

<p>does just that. Don't.</p>

<p>You meant</p>

<pre><code>usrname == ""User""
</code></pre>

<p>which is a comparison, <strong>but won't compare your strings</strong>. It just compares pointers.</p>

<p>Use <code>std::string</code> instead of <code>char</code> arrays or pointers and compare with <code>==</code>:</p>

<pre><code> #include &lt;string&gt;

 //...
 std::string usrname;
 cin &lt;&lt; usrname;

  if (usrname == ""User"")
  //          ^^
  //   note == instead of =
</code></pre>

<p>Side question - what's the point of shortening ""username"" to ""usrname""... you're saving a single character...</p>
",5
14187266,14187217,0,"<p>you need to use strcmp or similar.</p>

<pre><code>if (!strcmp(usrname, ""User""))
{
   cout &lt;&lt; ""Username correct!"";
}
</code></pre>

<p>what you are doing is assigning a value not comparing values.</p>
",0
17090336,17090243,3,"<p>Yes it does</p>

<p>Actually it creates a temporary rvalue of the underlying object of the pointer, in fact a copy. Notice that the return type is not <code>MyClass*</code> but <code>MyClass</code>. Thats why a copy is returned. <code>*variable.get()</code> also yields a rvalue.</p>
",0
17090347,17090243,4,"<p>since it is returned by value, yes, the object is fine, although I don't understand the use of pointer or heap allocation for the matter...
Would be simpler with a regular variable:</p>

<pre><code>MyClass var;
var.set_article_id(record-&gt;article_id);
return var;
</code></pre>
",12
18211950,18211876,1,"<p>gets() does not check for a length, so you could go past MAX_BUF without any bounds checks (since c/c++ does no bounds checking). Normally at compile time or runtime you will get a warning about gets() being unsafe. You should use a function that does some checking. std::string will resize itself dynamically to fit any size data you put into it, so it could just be an issue of changing MAX_BUF to a larger number as well.</p>
",0
18211960,18211876,3,"<p>Unlike <code>std::string</code> which is passed to the <code>operator &gt;&gt;</code> by reference and can be modified, <code>buf</code> is fixed, and it is passed by pointer. The buffer can fit only as much data as you have allocated, and cannot grow with the size of user's input. <code>gets</code> does not know where the buffer's limit is, so it does not check it, possibly writing past the end of the allocated space. This is undefined behavior, which can be exploited to fill the memory with data that represents executable code for malicious exploits of the <a href=""http://en.wikipedia.org/wiki/Heap_spraying"" rel=""nofollow"">heap spraying kind</a>.</p>

<p>Had the signature been <code>gets(char **)</code>, the writers of <code>gets</code> could require <code>malloc</code>-ed space and use <code>realloc</code> to expand the buffer; however, given the way the API is currently specified, the overflow could not be fixed even theoretically.</p>

<p>This problem is so serious that the designers of the C library decided to remove <code>gets</code> from the standard library in the upcoming standard of the language.</p>
",0
18211966,18211876,5,"<p><code>gets</code> reads until it finds a <code>'\n'</code>.  If there are more than
<code>MAX_BUF</code> characters in a line, it will just continue writing
them beyond the end of the buffer.  (<code>gets</code> has been deprecated
because there is no way of using it safely.)</p>

<p><code>cin &gt;&gt; s</code> reads until if finds white space (so the semantics
aren't the same), and will grow the string if need be.  Because
it grows the ""buffer"", it will never read beyond the end of the
it.</p>
",0
18211933,18211876,7,"<p>There's no way to tell <code>gets</code> function how much space there is in the buffer. It just writes the receiving input to the buffer you send it to. If there's more input than there is space, it'll happilly run out of bounds.</p>

<p><code>std::string</code>, on the other hand, is a container that keeps track about the size and it'll dynamically grow to accomodate the input.</p>

<p><code>gets</code> is hopelessly broken function. Never ever use it.</p>

<p>EDIT: As James Kanze points out, <code>gets</code> has been removed from the C language library altogether.</p>
",2
18211946,18211876,2,"<p>The interfaces are completely different. In the first case, the memory buffer has a fixed size, and the size is not passed to the function <code>gets</code>, so it has no way of controlling whether it writes beyond the limit.</p>

<p>In the second case, the memory buffer is managed by the <code>std::string</code>, and the function will ensure that it grows as needed. That is, the <code>std::string</code> will grow to have enough space for the whole input.</p>
",1
14733060,14733003,7,"<p>Yes, it will. However, if the compiler can determine that the value returned by <code>vect.end()</code> will never change, it could of course optimize it out. However, if you want to avoid doing it for sure, just change your code to:</p>

<pre><code>for(std::vector&lt;int&gt;::iterator i = vect.begin(), end = vect.end();
    i != end; ++i)
{
    //do smth here
}
</code></pre>

<p>You should, of course, make sure your code doesn't rely on <code>end()</code> being checked on every iteration. For example, if you were doing <code>vect.erase(i)</code> on elements in your vector, you would need to make sure you got the new <code>end()</code> iterator every time (and also make sure you assign the result of <code>erase</code> to <code>i</code>).</p>
",4
14733099,14733003,1,"<p>What you have seems perfectly fine. <code>vect.end()</code> should be an O(1) operation, so that's not a huge performance hit.</p>

<p>But if your looking for a alternative:</p>

<pre><code>typedef std::vector&lt;int&gt;::iterator iter;
iter end = vect.end();
for(iter it = vect.begin(); it != end; ++it) {

}
</code></pre>
",0
14733154,14733003,0,"<p>Nothing wrong with that.</p>

<p>or:</p>

<pre><code>std::vector&lt;int&gt;::iterator it = vect.begin();
std::vector&lt;int&gt;::iterator end = vect.end();

for(it; it != end; it++) ...
</code></pre>

<p>or, if your compiler supports C++11 range-based for loops you can iterate the vector like this:</p>

<pre><code>for(auto x : vect)
{
    //x is the actual int, not an iterator.
}
</code></pre>
",0
13407082,13407061,4,"<p>The token <code>delete</code> is a <a href=""http://en.cppreference.com/w/cpp/keyword"" rel=""nofollow"">reserved keyword in  C++</a>. Pick a different name for the function (like <code>remove</code>).</p>
",0
13407107,13407061,4,"<p><code>delete</code> is c++ keyword, you can't use it as function name <code>Node* Node::delete(int d)</code>
you can change your function name to <code>Node* Node::remove(int d)</code></p>

<p><a href=""http://en.cppreference.com/w/cpp/keyword"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/keyword</a></p>
",0
13407221,13407061,4,"<p>The previous posters have told you the issue - that <code>delete</code> is a reserved C++ keyword and you can't use it for your function name. </p>

<p>I want to point out a few other issues with your code:</p>

<ol>
<li>First of all, you call <code>delete[] root;</code> but that is wrong... <code>root</code> is not allocated by <code>new[]</code> but with <code>new</code> and so, must be deallocated with <code>delete</code> and not <code>delete[]</code>. </li>
<li>Secondly, you are not deleting any of the nodes in the list. That may be OK for this little program (the memory will be returned to the O/S when your program exits) you are still leaking memory. Every pointer that you allocate with <code>new</code> must be deallocated with <code>delete</code> and every pointer you allocate with <code>new[]</code> must be deallocated with <code>delete[]</code>. Remember, <code>new</code> and <code>delete</code> must come in pairs.</li>
<li>Last but not least: Look at what happens when you try to call 'printOut' on a list composed only of a single root. You will see that nothing gets printed. For a hint as to why this happens, look at the code in printOut() and speak out the logic of the code to yourself, as if you are a computer executing it.</li>
</ol>

<p>Good luck.</p>
",0
13749833,13749762,1,"<p>You are exiting the loop when the pointer is null and the delete it. That's not going to work.</p>

<p>I guess you meant to delete <code>temp</code> instead ? That would still not work with your current code.</p>
",1
13749838,13749762,0,"<p>Your code does not do anything: the exit condition of the loop is <code>NULL == current</code>, meaning that <code>delete current;</code> will <em>always</em> pass <code>NULL</code> to <code>delete</code>. This is OK, but it does not de-allocate anything.</p>

<p>You should change your loop to stop when <code>current-&gt;next == NULL</code>, but you must be extra careful to make sure that you do not dereference <code>current</code> when it is equal to <code>NULL</code>:</p>

<pre><code>temp = 0;
while(current &amp;&amp; current-&gt;next){
    temp = current;
    current = current-&gt;next;
}
if (temp) {
    delete current;
    temp-&gt;next = 0;
}
</code></pre>

<p><strong>EDIT :</strong> Your edited code mimics my answer to a large extent, except yours would fail if <code>head == NULL</code>. It would also fail if the list has exactly one node, because <code>temp</code> would remain unassigned.</p>
",3
13749888,13749762,1,"<p>Did you mean something like this:</p>

<pre><code>while (NULL != next) {
  prev = current;
  current = next;
  next = current-&gt;next;
}
delete current;
if (NULL != prev) {
  prev-&gt;next = NULL;
}
</code></pre>
",0
15530372,15530354,6,"<p>Replace this, which implies that <code>fw</code> is the name of a class or namespace:</p>

<pre><code> fw::create_event_file();
// ^^ This is a ""scope opearator""
</code></pre>

<p>With this, which implies that <code>fw</code> is a variable:</p>

<pre><code> fw.create_event_file();
// ^ This is a ""member access opearator""
</code></pre>
",2
13731282,13730704,2,"<p>The <code>std::allocator</code> defines <code>size_type</code> as <code>size_t</code>, so you can assume <code>size_type</code> as <code>size_t</code> <em><strong>iif</strong></em> you can guarantee there are no custom allocators that define a different type for their <code>size_type</code>s.</p>

<p>However you take the risk of someone coming back later and adding a custom allocator that may be incompatible with this assumption.</p>
",0
13730939,13730704,1,"<p>I think, at least in theory, what you want here is something like:</p>

<pre><code>std::common_type&lt;std::vector&lt;classA&gt;::size_type, 
                 std::vector&lt;classB&gt;::size_type&gt;::type i;

for (i=0; i!=vec1.size(); i++)
    // ...
</code></pre>

<p>I doubt you'll see that on a regular basis in most code though (nor, most likely, be the toast of the Christmas party for writing it either).</p>
",0
13731046,13730704,2,"<p>I'm not sure if this is guaranteed by the standard or not, but I'd expect all <code>vector::size_type</code> types to be identical no matter what template parameter you choose.</p>
",1
15591902,15591835,2,"<p>No, what you're doing is not safe. The past-the-end iterator (the one returned by <code>end()</code>) cannot be dereferenced. You're doing <code>-&gt;</code> on the result of <code>find()</code>: if that result is past-the-end, you're invoking undefined behaviour.</p>
",3
15591907,15591835,1,"<p>No it's not because it would mean dereferencing the end iterator and that is undefined behaviour.</p>
",0
15591998,15591835,2,"<p>No.</p>

<p>You should check that the iterator returned by find != end before trying to get the second element.</p>

<pre><code>const auto&amp; point_color = this-&gt;mBoard.find(Point(p.x - 1, p.y);
if (point_color != this-&gt;mBoard.end() &amp;&amp;
    point_color-&gt;second == lColour) {
  // something
}
</code></pre>
",0
13697295,13697265,13,"<p>Pre-C++11, only <strong><code>const</code> integral types</strong> could be directly initialized in the class definition. It's just a restriction imposed by the standard.</p>

<p>With C++11, this no longer applies.</p>
",6
13697456,13697265,62,"<p>The logic implemented by the C++03 language standard is based on the following rationale.</p>

<p>In C++ an <em>initializer</em> is a part of object <em>definition</em>. What you write inside the class for static members is actually only a <em>declaration</em>. So, formally speaking, specifying initializers for any static members directly inside the class is ""incorrect"". It is contrary to the general declaration/definition concepts of the language. Whatever static data you <em>declare</em> inside the class has to be <em>defined</em> later anyway. That's where you will have your chance to specify the initializers.</p>

<p>An exception from this rule was made for static integer constants, because such constants in C++ can form Integral Constant Expressions (ICEs). ICEs play an important role in the language, and in order for them to work as intended the values of integral constants have to be visible in all translation units. In order to make the value of some constant visible in all translation units, it has to be visible at the point of <em>declaration</em>. To achieve that the language allows specifying the initializer directly in class.</p>

<p>Additionally, on many hardware platforms constant integer operands can be embedded directly into the machine commands. Or the constant can be completely eliminated or replaced (like, for example, multiplication by <code>8</code> can be implemented as a shift by <code>3</code>). In order to facilitate generation of machine code with embedded operands and/or various arithmetical optimizations it is important to have the values of integral constants visible in all translation units.</p>

<p>Non-integral types do not have any functionality similar to ICE. Also, hardware platforms do not normally allow embedding non-integral operands directly into the machine commands. For this reason the above ""exception from the rules"" does not extend to non-integral types. It would simply achieve nothing.</p>
",2
13768119,13768089,17,"<p>I think the main reason why is because <code>std::pair</code> does not reallocate objects, so they don't have to be assignable.</p>

<p><strong>Update:</strong></p>

<p>Actually vector is the only container that requires assignable objects. This is because accordingly to the standard vector must have a contiguous storage location for it's elements. So if there will be no room for more objects to add, vector will have to reallocate it's data to another place (thus using the assignable property of the objects).</p>
",4
13768149,13768089,6,"<p><code>std::pair</code> only needs it's contents to be assignable if you attempt to assign to it. However, <code>std::vector</code> always requires assignment for reallocation purposes.</p>
",3
13778025,13777773,1,"<p>Your obsession is understandable and I do not disagree, but unless you have a really pressing <em>need</em> for it, the effort required might not be worth the effort.</p>

<p>Assuming you chose <code>vector</code> as your container based on your design requirement, I would not recommend changing it to <code>deque</code>, or any other type. It would only serve to confuse a future reader (which would likely be yourself), and is also a bad practice otherwise.</p>

<p>If we go with your wrapper solution, you would have to <strike>hide</strike> override all members which <em>could</em> modify the vector, which is a problem since there are a number of methods used to both access and modify, such as <code>operator[]</code>, <code>at()</code>, <code>front()</code>, <code>back()</code>. This could confuse a future reader, since they are used to the ""standard"" <code>vector</code> behavior. </p>

<p>By the way, are you sure <code>deque&lt;const int&gt; foo;</code> works? I get the following error:</p>

<pre><code>error: invalid conversion from 'const void*' to 'void*'
</code></pre>

<p><strong>Edit</strong> It seems I didn't quite answer your question. If you <em>have</em> to pick one, I would choose the wrapper approach.</p>
",0
13778106,13777773,0,"<p>There's nothing magic about the standard containers. If you need a container with characteristics that are different from those of the standard containers, write your own. If one of the standard containers is close to what you need, use that as the internal implementation. In short, <code>my_vector</code> is the way to go.</p>
",0
13778145,13777773,1,"<p>I prefer private inheritance for these sort of standard-container-almost-exactly-fits-my-needs cases. Public inheritance leads to slicing or non-virtual destruction through a pointer to a base class. Composition requires too much extra typing.</p>

<p>Private inheritance and the use of <code>using</code> expresses your intent well.</p>

<p>Here is an exmaple:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;

class my_vector : private std::vector&lt;int&gt; {
  // Utility type 
  typedef std::vector&lt;int&gt; base;
public:
  // Types I don't need to tweak:
  using base::value_type;
  using base::allocator_type;
  using base::size_type;
  using base::difference_type;
  using base::const_reference;
  using base::const_pointer;
  using base::const_iterator;
  using base::const_reverse_iterator;

  // Types I do need to tweak:
  typedef const_reference reference;
  typedef const_pointer pointer;
  typedef const_iterator iterator;
  typedef const_reverse_iterator reverse_iterator;

  // Constructors
    // Implicit constructors OK
  // Destructors
    // Implicit destructors OK
  // Assignment
    // Implicit assignment OK

  // Methods that I don't need to tweak:
  using base::assign;
  using base::get_allocator;
  using base::empty;
  using base::size;
  using base::max_size;
  using base::reserve;
  using base::capacity;
  using base::clear;
  using base::push_back;
  using base::pop_back;
  using base::swap;

  // Methods I need to tweak
  const_reference at( size_type pos ) const { return base::at(pos); }
  const_reference operator[](size_type pos) const { return base::operator[](pos); }
  const_reference front() const { return base::front(); }
  const_reference back() const { return base::back(); }
  const_iterator begin() const { return base::begin(); }
  const_iterator end() const { return base::end(); }
  const_reverse_iterator rbegin() const { return base::rbegin(); }
  const_reverse_iterator rend() const { return base::rend(); }

  // Methods I need to delete:
    // base::insert;
    // base::erase;
    // base::resize;

};

int main () {
  my_vector m;
  m.push_back(1);
  m.push_back(2);
  m.push_back(3);
  my_vector m2;
  m2 = m;
  std::copy(m2.begin(), m2.end(), std::ostream_iterator&lt;int&gt;(std::cout, ""\n""));
}
</code></pre>
",1
13777720,13777655,0,"<p>Are you using C programming?
You can try this.</p>

<pre><code>char str[80];
  FILE *fp;

  if((fp = fopen(""TEST"", ""w""))==NULL) {
    printf(""Cannot open file.\n"");
    exit(1);
  }

  do {
    printf(""Enter a string (CR to quit):\n"");
    gets(str);
    strcat(str, ""\n"");  /* add a newline */
    fputs(str, fp);
  } while(*str!='\n');

  return 0;
</code></pre>
",0
15579203,15578880,0,"<p><strong>Short answer:</strong> <code>myfile &lt;&lt; vertexcharacter &lt;&lt; a;</code></p>

<p>The comma does something very different than what you expect.  Think of comma kind of like a semicolon.  If you have multiple statements strung together by commas, each statement will be executed in order.  But the last statement is the one whose value is ""returned"".  For example:</p>

<pre><code>int x = 3;
cout &lt;&lt; (x+=2, x+5);
</code></pre>

<p>In this case, <code>x+=2</code> executes so that x=5, and then <code>x+5</code> is ""returned"", so the value 10 is inserted into cout.  Your example, on the other hand, is equivalent to</p>

<pre><code>(myfile &lt;&lt; vertexcharacter), a;
</code></pre>

<p>Basically, <code>vertexcharacter</code> is inserted into <code>myfile</code>, and then, if you were capturing the result somehow, like <code>x = (myfile &lt;&lt; vertexcharacter, a);</code> then you would get x=a.  What you really want is <code>myfile &lt;&lt; vertexcharacter &lt;&lt; a;</code></p>
",0
15579231,15578880,0,"<p>It must be</p>

<pre><code>myfile &lt;&lt; vertexcharacter &lt;&lt; a;
</code></pre>
",0
15578888,15578880,4,"<p>You appear to be looking for:</p>

<pre><code>myfile &lt;&lt; vertexcharacter &lt;&lt; a;
</code></pre>

<p>Currently, you're using the comma operator, so your line is equivalent to:</p>

<pre><code>(myfile &lt;&lt; vertexcharacter), a;
</code></pre>

<p>This inserts <code>vertexcharacter</code> into <code>myfile</code>, discards the result, then evaluates <code>a</code> which does nothing.</p>
",0
15578890,15578880,3,"<p>Like this:</p>

<pre><code>myfile &lt;&lt; vertexcharacter &lt;&lt; a;
</code></pre>

<p>What you currently have</p>

<pre><code>myfile &lt;&lt; vertexcharacter, a;
</code></pre>

<p>involves the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a>, which evaluates the first argument (<code>myfile &lt;&lt; vertexcharacter</code>), discards the result, then evaluates the second argument (<code>a</code>). The reason for this is that the comma operator has the lowest precedence.</p>
",0
13739028,13738996,23,"<p>They're both the same, so there really is no one <em>""best way""</em>.</p>

<p>I personally use</p>

<pre><code>int a = 0;
</code></pre>

<p>because I find it more clear and it's more widely used in practice.</p>

<p><em>This applies to your code, where the type is <code>int</code>. For class-types, the first is copy-initialization, whereas the other is direct-initialization, so in that case it would make a difference</em>.</p>
",8
13739089,13738996,2,"<p>It¡¯s that simple. (Well, almost ¡ª there are a few things you can¡¯t name your variables, which we¡¯ll talk about in the next section)</p>

<p>You can also assign values to your variables upon declaration. When we assign values to a variable using the assignment operator (equals sign), it¡¯s called an explicit assignment:</p>

<pre><code>int a= 5; // explicit assignment
</code></pre>

<p>You can also assign values to variables using an implicit assignment:</p>

<pre><code>int a(5); // implicit assignment
</code></pre>

<p>Even though implicit assignments look a lot like function calls, the compiler keeps track of which names are variables and which are functions so that they can be resolved properly.</p>
",2
13739177,13738996,5,"<p>There's no ""best"" way. For scalar types (like <code>int</code> in your example) both forms have exactly the same effect.</p>

<p>The <code>int a(0)</code> syntax for non-class types was introduced to support uniform direct-initialization syntax for class and non-class types, which is very useful in type-independent (template) code.</p>

<p>In non-template code the <code>int a(0)</code> is not needed. It is completely up to you whether you want to use the <code>int a(0)</code> syntax, or prefer to stick to more traditional <code>int a = 0</code> syntax. Both do the same thing. The latter is more readable, in my opinion.</p>
",0
13739232,13738996,63,"<p><code>int a = 0;</code> and <code>int a(0);</code> make no difference in the machine generated code. They are the same.</p>

<p>Following is the assembly code generated in Visual Studio</p>

<pre><code>int a = 10;   // mov dword ptr [a],0Ah  
int b(10);    // mov dword ptr [b],0Ah  
</code></pre>
",7
13739264,13738996,5,"<p>From a practical point of view: I would <strong>only</strong> use <code>int a = 0;</code>.</p>

<p>The <code>int a(0)</code> may be allowed but never used in practice in itself.</p>

<hr>

<p>I think it should not bother you on your level, but let us go further.</p>

<p>Let's say that <code>a</code> is a class, not an int. </p>

<pre><code>class Demo{
public:
  Demo(){}; 
  Demo(int){};
};
Demo a;
Demo b(a);   
Demo c = a;  // clearly expressing copy-init
</code></pre>

<p>In this example both <code>b(a)</code> and <code>c=a</code> do the same, and I would discourage you using the fist solution. My reason is, that is looks similar to <code>c(2)</code> which is a construction from arguments.</p>

<p>There are only two <strong>valid uses</strong> of this bracket-style initialization:</p>

<ul>
<li>initialization lists (<code>Demo(int i):data(i){}</code> if Demo has an int data member <code>data</code>),</li>
<li>new's: <code>Demo *p=new Demo(a); // copy constructing a pointer</code></li>
</ul>
",1
13739614,13738996,0,"<p>The difference is that <code>()</code> initialization is when you explicitly want it to take one parameter only, e.g:</p>

<p>You can:<br>
<code>int a = 44 + 2;</code><br>
but you can't:<br>
<code>int a(44) + 2;</code></p>
",1
13740789,13738996,0,"<p>In textbooks and literature, one is direct initialization and the other is copy initialization. But, in terms of machine code, there is no difference. </p>
",1
14783029,14782984,-1,"<p>From <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/sysconf.3.html"" rel=""nofollow"">SYSCONF(3)</a> </p>

<blockquote>
  <p><strong>POSIX.1 Variables</strong><br>
  <strong>ARG_MAX - _SC_ARG_MAX</strong><br>
  The maximum length of the arguments to the exec(3) family of functions. Must not be less than _POSIX_ARG_MAX (4096).  </p>
  
  <p><strong>POSIX.2 Variables</strong><br>
  <strong>LINE_MAX - _SC_LINE_MAX</strong><br>
  The maximum length of a utility's input line length, either from
                standard input or from a file.  This includes length for a trailing
                newline.</p>
  
  <p><strong>BUGS</strong><br>
  It is difficult to use ARG_MAX because it is not specified how much of the argument space for exec(3) is consumed by the user's environment variables.</p>
</blockquote>
",0
15494656,15494588,5,"<p>The empty array declares a zero-length array. It is used in C by placing a structure S in a memory zone bigger than sizeof(S) and then using the array to access the remaining memory:</p>

<pre><code>memory* ptr = malloc(sizeof(memory) + sizeof(char) * 10);
// you can now manipulate ptr-&gt;a as an array of 10 elements
</code></pre>

<p>This is a trick that is a lot less useful in C++. Simply use std::vector instead.</p>
",1
15494934,15494588,6,"<p>First, it's not legal C++.  It's an old hack, which C only made
legal in C98.  The basic idea is that such <code>struct</code> can only be
dynamically allocated (using <code>malloc</code>), and you allocate however
much memory is needed for the object after it.  So you'll do
something like <code>malloc( sizeof( library ) + strlen( s ) + 1 )</code>.
The hack is used to avoid an extra allocation.</p>

<p>A class which uses this hack <em>cannot</em> be used with <code>new</code>, nor
can it be a member or a base class.  (It cannot be a member in
C, either.) </p>

<p>You can sort of emulate this in C++:</p>

<pre><code>class Library
{
    //  ...
    char* buffer() { return reinterpret_cast&lt;char*&gt;( this + 1 );
    void* operator new( size_t n, size_t extra )
    {
        assert( n == sizeof( Library ) );
        return ::operator new( n + extra );
    }
};
</code></pre>

<p>Note, however, that unlike the C solution, this runs the risk of
alignment problems.  It works fine for character types, and it
will work if other members of the class require at least as much
alignment as the buffer type, but it can fail otherwise.  (The
implementation of std::basic_string in g++ uses it&mdash;and
will crash on some machines if instantiated with <code>double</code>.)</p>
",0
15494762,15494588,11,"<ol>
<li>There is no language called C/C++, So your Q cannot be tagged with both.</li>
<li>Since you are using classes, Your program can only be C++ and not C. </li>
</ol>

<hr>

<pre><code>public:
     void print();
     char a[];
</code></pre>

<p>This code is simply illegal in C++. Array size in C++ needs to be positive compile time constant. Solution is to replace it by:</p>

<pre><code>public:
      void print();
      std::string a;
</code></pre>

<hr>

<p>Note that the declaration,       </p>

<pre><code>char a[];
</code></pre>

<p>is valid in c99 and it is known as <strong>Incomplete array type</strong>, the C standard guarantees that <code>a</code> can store atleast one element of the type <code>char</code>. This is not valid in C++. C++ standard does not allow these. Simply because both are different languages.</p>
",4
15494802,15494588,1,"<p>It's commonly referred to as the <a href=""https://stackoverflow.com/q/3711233/1025391"">struct hack</a> in C. It uses a feature called <em>flexible array member</em>.</p>

<p>This is however not part of any C++ standard specification. Have a look at <a href=""https://stackoverflow.com/q/4412749/1025391"">this question</a>.</p>

<p>Note that the observation that something apparantly does work does not imply that you can rely on it to work reliably. If the behavior is undefined, technically anything can happen. Including raptors suddenly attacking.</p>

<p>In C++ you probably would use a <code>std::vector&lt;char&gt;</code> or a <code>std::string</code> instead.</p>
",0
16907847,16907834,2,"<p>Your code is undefined behavior. <code>int *x = S();</code> initializes <code>x</code> to an address to a temporary, which gets destroyed at the end of the full expression, so <code>*x</code> is illegal.</p>
",0
16907887,16907834,0,"<p>Perhaps you meant to define x of type S? There is no reason for it to call an overloaded operator when it is of type int.</p>
",0
16908103,16907834,1,"<p>Use <code>std::reference_wrapper</code>:</p>

<pre><code>#include &lt;memory&gt;
#include &lt;functional&gt;

int main()
{
    S s;
    auto x = std::make_shared&lt;S&gt;(std::ref(s));
    *x = 10;

    std::cout &lt;&lt; *x; // prints 5
}
</code></pre>

<p><a href=""http://ideone.com/XEXSiH#view_edit_box"" rel=""nofollow"">Here is a demo.</a></p>
",0
16908262,16907834,1,"<p>The local <code>x</code> variable in the main function is of type <code>pointer to int</code>.  The <code>int</code> it is pointing to is the <code>S::x</code> <em>subobject</em> of the <code>S</code> instance, as returned by <code>S::operator int*</code>.  When you dereference it you get an lvalue of type <code>int</code> which is still the <code>S::x</code> subobject.  So when you call <code>operator=</code> on this lvalue <code>int</code>, it dispatches to the builtin <code>int::operator=</code>, not your user-defined <code>S::operator=</code>.</p>

<p>The user-defined <code>S::operator=</code> function is not ""inherited"" by member subobjects of a class.  I think this is what is confusing you.</p>

<p>If you want to use the <code>S::operator=</code> then you need to call it with an lvalue of type <code>S</code>:</p>

<pre><code>int main()
{
    S s;
    S *x = &amp;s;
    *x = 10;

    std::cout &lt;&lt; x-&gt;x;
}
</code></pre>

<p>will do what you want and call <code>S::operator=</code>.</p>
",0
14743037,14743014,3,"<p><code>atoi</code> call expects a <code>const char *</code> arguement, while you pass a <code>char</code>, this is the problem.</p>

<p>You can just do the below to convert the character to number. This subtracts the ascii value of <code>0</code> from the character itself ( since 0-9 are sequentially increasing in the ascii code.)</p>

<pre><code>isbnInt[i] = str[i] - '0';
</code></pre>
",0
14743042,14743014,0,"<p>Try:</p>

<pre><code>for (i = 0; i &lt; 10; i++)
{
    isbnInt[i] = str[i] - '0';
    cout &lt;&lt; isbnInt[i] &lt;&lt; endl;
}
</code></pre>

<p><a href=""http://en.cppreference.com/w/c/string/byte/atoi"" rel=""nofollow"">atoi</a> takes <code>const char*</code> as input instead of single char.</p>
",0
14743062,14743014,0,"<p>Your code could also be written:</p>

<pre><code>for (i = 0; i &lt; 10; i++)
{
    char foo = str[i];
    isbnInt[i] = atoi(foo);
    cout &lt;&lt; isbnInt[i] &lt;&lt; endl;
}
</code></pre>

<p>Which won't work (as you've found); atoi expects a char*, not a char.</p>

<p>Try:</p>

<pre><code> int isbm = atoi(str);
</code></pre>

<p>and see if that does what you wanted.</p>
",0
15592712,15592456,2,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

ssize_t recurse(int limit, char* stack = NULL)
{
    char dummy;

    if (stack == NULL)
        stack = &amp;dummy;

    if (limit &gt; 0)
        return recurse(limit - 1, stack);
    else
        return stack - &amp;dummy;
}

int main(int argc, char* argv[])
{
    int limit = atoi(argv[1]);
    printf(""depth %d took %zd bytes\n"", limit, recurse(limit));
    return EXIT_SUCCESS;
}
</code></pre>

<p>If I run this with <code>4</code> I get:</p>

<pre><code>depth 4 took 192 bytes
</code></pre>

<p>As others have suggested in comments, this is not completely portable, but it should work on a fairly wide variety of current systems.  Note that the result type is signed in case something ""weird"" happens--you can surely check it for sanity (say, make sure it's between 5 and 500, depending on what else your function contains).</p>
",0
13753190,13752660,0,"<p>You <code>delete l4</code>, but you never change <code>l3</code>, and it points to <code>l4</code>s memory (now deleted) which still contains the data ('c')</p>

<p>You need to </p>

<pre><code>l3-&gt;setNext(NULL);
</code></pre>

<p>to remove the element from the list (and you must still delete it of course)</p>

<p>To use the <code>deleteElement</code> function, you would need to change it to iterate through the list (Pseudo code):</p>

<pre><code>void deleteElement( Element head , Element toBeDeleted)
{
    //are we deleting head (the first element of the list?) 
    //yes then head should be nulled, and delete as normal

    current = head ; ancestor = head;

    //scan through list (current becomes current-&gt;next until no more)
    //until we find toBeDeleted
    //maintain ancestor as we go 

    //if found set ancestor-&gt;next to current-&gt;next
    //delete toBeDeleted
}
</code></pre>
",0
14816713,14815869,0,"<p>You are expected to use CRTP:</p>

<pre><code>class myObject : public object&lt;myObject, 
                 pOwnershipRecursive, 
                 pInteractionPipeline&gt;
{
   // your real content here: 
   // an object that consists solely of policies is probably useless
};
</code></pre>
",1
13785837,13785818,1,"<p>Create an ofstream object and write to the desired path.</p>

<p>If you want to update simply loop and seek to that object and write.</p>

<p>As the file will be created in binary, you cant be able to read it in notepad, you have to read it back by ifstream object and output it into console or into text file..</p>

<p>Check this link <a href=""http://www.cplusplus.com/doc/tutorial/files/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/files/</a></p>
",5
14833853,14833733,0,"<p>Assuming <code>list</code> is the only member of <code>Stack</code> (since it is enough), and that <code>List</code> already has a correct copy constructor implemented, you currently are copying the list with the first assignment:</p>

<pre><code>template &lt;class T&gt;
Stack&lt;T&gt;::Stack(const Stack&lt;T&gt;&amp; otherStack)
{
        List&lt;T&gt; the=otherStack.list;        // &lt;-- list is copied
        ListItem&lt;T&gt; *temp=the.getHead();
        while(temp!=NULL)
        {
                push(temp-&gt;value);
                temp=temp-&gt;next;
        }
}
</code></pre>

<p>After taking a copy of the whole list, you are pushing the elements of that copy onto your stack. But just copying the list into the member <code>list</code> (or better said: initializing <code>list</code> with the list of the <code>otherStack</code>) is enough to copy the whole stack:</p>

<pre><code>template &lt;class T&gt;
Stack&lt;T&gt;::Stack(const Stack&lt;T&gt;&amp; otherStack) :
    list (otherStack.list)  // &lt;--- list is copied
{
}
</code></pre>

<p>This might very well just ""move"" the problem to the copy-construction of <code>List</code>.</p>
",4
14833854,14833733,-1,"<p>the code fragment is not enough to identity the issue.
For example line:</p>

<pre><code>List&lt;T&gt; the=otherStack.list;
</code></pre>

<p>makes a copy of the list, if the linked list implementation is custom maybe its copy constructor has issues.
Try</p>

<pre><code>List&lt;T&gt; &amp;the=otherStack.list;
</code></pre>
",2
14834381,14833733,1,"<p>If <code>List</code> and <code>Stack</code> have their usual semantics, your constructor reverses order of items in constructed object. So you should either traverse list in reverse order or do such copy twice to restore original order. It is also possible that <code>List</code> can be just copied with assignment operator and  </p>

<pre><code>this.list = otherStack.list
</code></pre>

<p>is enough. But not seeing <code>List</code> code I can't tell.</p>
",1
16374099,16374077,5,"<p>The derived class has:    </p>

<pre><code>All the members of base class + the additional members in derived class
</code></pre>

<p>The order of calling of constructors is well defined, the base class constructor is always called before the derived constructor. Depending on how you use the <a href=""https://stackoverflow.com/questions/1711990/what-is-this-weird-colon-member-syntax-in-the-constructor/8523361#8523361"">member initialization list</a>, either the default base class constructor or the parameterized version gets called.    </p>

<p>But it's always Base class constructor followed by Derived class constructor. So not sure what your second Q is.</p>

<hr>

<p>And just to be precise, Please remove the <code>char *</code> member and use <code>std::string</code>.</p>

<pre><code>class foo
{
    //char *item;     ----------------&gt;  Erroneous, difficult to handle
    std::string item;

    ....
</code></pre>
",2
16374238,16374077,1,"<p>You can see the memory layout as two sub-structs <code>foo</code> and <code>bar</code> gathered in one named <code>bar</code>.</p>

<p>Your bar class will look like that in memory:</p>

<pre><code>*******
foo members:
-char* item (sizeof(char*)
*******
bar members:
*******
</code></pre>

<p>When you will create a new <code>bar</code>, you will reserve memory for these two structures. 
In your case this will reserve enough memory for the char* which is probably 4 bytes in case of a x86 compiler.</p>

<p>In a normal usecase, <code>bar</code>'s constructor will contains everything related to <code>bar</code>'s member. <code>bar</code>'s constructor can also call ""manually"" <code>foo</code>'s constructor within the initialization list or a raw call. Otherwise the compiler will call the <code>foo</code>'s default constructor for you.</p>
",0
14855178,14855078,0,"<p>Also remember that the stream objects <code>failbit</code> becomes set if the extraction of a number fails. You can check for that, and if set you skip all non-digit characters in the stream until you see a digit again.</p>

<p>Something like this pseudo code:</p>

<pre><code>while (myfile)
{
    myfile &gt;&gt; value;

    if (myfile.fail())
    {
        clear_failbit();

        while (next_character_is_not_digit())
            get_and_discard_next_character();
    }
}
</code></pre>

<p>Of course, a better solution would probably be to <em>not</em> generate files containing errors.</p>
",0
18305960,18305891,0,"<pre><code>template&lt;typename T&gt;
void myDelete(T* p)
{
     /* do something */
    delete p;
}
</code></pre>

<p>This assumes p points to something allocated with new which is not an array.</p>
",0
14221697,14220029,1,"<p>Do what Beta said and create a <strong>minimal</strong> file opening and writing program first. Get that working. Then build the rest of the needed functionality around that, compiling and fixing errors every step of the way. If you can get this working, add a little bit of your desired functionality to it.  Look into permissions on the directory you are writing to if this doesn't work.  This compiles in visual studio, you may need to include other libraries on linux/unix/mac:</p>

<pre><code>#include &lt;fstream&gt;
int main()
{
    std::ofstream file;

    file.open(""file.txt"");      //open a file

    file&lt;&lt;""Hello file\n"";       //write to it

    file.close();           //close it
}
</code></pre>
",0
15804305,15804171,2,"<pre><code>#define DO_SOMETHING_TEST1(channel) WhatThe(""TEST1"", channel)
#define DO_SOMETHING_TEST2(channel) WhatThe(""TEST2"", channel)

#define DO_IT(type, channel) \
        DO_SOMETHING_##type(channel).Doitnow()
</code></pre>
",1
15804437,15804171,-1,"<pre><code>#define TEST ""TEST1""
#define CHANNEL 1

WhatThe(TEST, CHANNEL).DoitNow()
</code></pre>

<p>This has the same amount of code to change whenever you want to do a different TEST or CHANNEL, as your proposed solution. To do a different test, just change the defines.</p>

<p>To combine parameters, do this:</p>

<pre><code>#ifdef TEST1_CHANNEL1
    #define TEST ""TEST1""
    #define CHANNEL 1
#endif

#ifdef TEST1_CHANNEL2
    #define TEST ""TEST1""
    #define CHANNEL 2
#endif

...
</code></pre>
",3
17402457,17402346,8,"<p>Your code makes the assumption that <code>sizeof(struct Point) == 2*sizeof(double);</code>. This is a dangerous assumption because it will be true when you write and test the code but it's true by luck, not be definition. Luck has a habit of running out :)</p>

<p>Most likely in this case you'll never have a problem (since the definition of <code>struct Point</code> is unlikely to ever change, and machine alignment issues aren't likely in portability with this type either). That being said, it's a horrible pattern to base code on.</p>
",3
17402493,17402346,0,"<p>In theory the struct can have padding between members and after the end. So it is not necessarily layout-compatible with plain doubles. But if you add 0 packing and static_assert to ensure sizeof(Point) == 2* sizeof(double) I don't see a way to fail in practice.</p>
",0
17402702,17402346,0,"<p>Well, let's start with the fact I completely back what @mah said. Indeed that's terrible and should be avoided if possible.</p>

<p>But, sometimes, it is not possible. For example, you sometimes need to do the exactly other way around: you've received a stream of numbers which are in certain order, and you want to ""unpack it"" into structures for better handling. That's where strict control of memory layout is required.</p>

<p>In such cases, if may decorate the <code>struct Point</code> with proper <em>packing directives</em> like <code>#pragma pack(1)</code> that <strong>might</strong> tell your compiler to <strong>not add any align</strong>.</p>

<p>Please note that this is #pragma. While some may seem somewhat universal, they are by definition compiler/platform specific. Be sure to add some simple assertions that check if sizeofs are really equal in case you change the compiler or upgrade it to a version which treats pragmas differently..</p>

<p>Assuming your compiler have understood the pack(1) pragmas (or similar), your code will be safe and sizeof such POD struct will indeed equal to 2*double. See nice example here <a href=""https://stackoverflow.com/a/3318475/717732"">https://stackoverflow.com/a/3318475/717732</a></p>

<p>I actually do not remember about packing in arrays. I am almost sure that an array is guaranteed to be packed with zero align. But, only almost sure. Best check the STD.</p>
",0
17404071,17402346,0,"<p>I want to add something to the answers of mah &amp; quetzacoatl - which are both valid and correct.</p>

<ol>
<li>write the code in a way that it does not depend on undefined things. Here, your code probably works - because double are 8 byte aligned and normally packed. Still this is implicit. You should make sure it works always by using the sizeof the POD.</li>
<li>If you require the pod to be packed, make it explicit by adding the pragma pack or something similar. It declares your requirement in code.</li>
<li>Make sure the code fails if it does not meet your requirement. Use static_assert if possible, if not possible work with asserts, error handling code and/or unit tests.</li>
</ol>

<p>In your example - add pragma if packing is a requirement and make sure that the copy does not fail even if the compiler creates a different layout than you expect. Make sure that compiling fails in case the compiler wants to create a different layout than required.</p>
",0
14213167,14213085,9,"<p>Because you both inherited from Father and instantiated a member of type Father, so now Son has two Father objects- the direct base, and a member.</p>
",4
17087899,17087044,0,"<p>you need to implement your own find function, to get the id from the string, because when reading the whole string and save it, id is in middle of string.</p>

<p>try to have a data structure that contain all information for each line, so accessing the id is easier to find</p>
",1
17087920,17087044,0,"<p>There is a find_if for stl which can be useful</p>

<p><a href=""http://www.cplusplus.com/reference/algorithm/find_if/"" rel=""nofollow"">http://www.cplusplus.com/reference/algorithm/find_if/</a></p>

<p>You are given a full string and you have a student id which is the second column you can get the second column using a stringtokenizer and compare that with student id abd return true or false</p>
",1
17088130,17087044,1,"<p>You should define a struct for the student records and read the data into this struct. Then you can use <a href=""http://en.cppreference.com/w/cpp/algorithm/find_if"" rel=""nofollow"">std::find_if</a> and a functor to search for the id:</p>

<pre><code>struct find_by_id : std::unary_function&lt;student, bool&gt; {
    string m_id;

    find_by_id(const string &amp;id) : m_id(id) { }
    bool operator()(const student &amp;s) const {
        return s.id == m_id;
    }
};

it = std::find_if(temp_info.begin(), temp_info.end(), find_by_id(id));
</code></pre>
",1
13750150,13750141,1,"<p>Try:</p>

<pre><code>int a = 0;
findLastNthElementRecursive(3, a);
</code></pre>

<p>Also note that you're ignoring the return value of <code>findLastNthElementRecursive()</code>.</p>
",0
13750155,13750141,3,"<p>A temporary cannot bind to a non-<code>const</code> reference. In your first case, you attempt to pass a temorary as parameter, and it fails.</p>

<p>The second one doesn't work because <code>&amp;a</code> is the address of <code>a</code>, effectively an <code>int*</code>, so doesn't match the signature of the function.</p>

<p>The correct way would be</p>

<pre><code>int a = 0;
findLastNthElementRecursive(3,a);
</code></pre>
",0
13776025,13775564,0,"<p>Firstly, the <code>true</code> and <code>false</code> branches are the wrong way round.</p>

<p>Secondly (assuming <code>true</code>/<code>false</code> has been fixed), you conclude that the entire sequence is in the ascending order as soon as you've seen two numbers that are in order. That's not correct: you can't <code>return true</code> until you've examined <em>every pair</em>.</p>

<p>Lastly, the loop's terminal condition is off by one.</p>

<pre><code>bool IsInOrder(int numHold[]) {
    for (int i = 0; i &lt; 9; i++) {
        if (numHold[i] &gt;= numHold[i+1]) {
            return false;
        }
    }
    return true;
}
</code></pre>
",0
13775587,13775564,0,"<p>Your <code>IsInOrder</code> routine doesn't check all the values in the array, it returns immediately after encountering two different numbers.</p>

<p>Also, if it would run through the entire array (i.e. when all the numbers would be the same), it would have checked 11 elements by the time it ended instead of 10, and it wouldn't return anything.</p>
",0
13775603,13775564,0,"<pre><code>bool IsInOrder(int numHold[])
{
    bool inOrder = true;
    for (int i = 0; i &lt; 9; i++)
    {
        if (numHold[i] &gt; numHold[i+1])
        {
            inOrder = false;
            break;
        }
    }
    return inOrder;
}
</code></pre>
",2
13775688,13775564,2,"<p>in <code>IsInOrder</code> Function, run for loop till <code>i&lt;9</code> and remove else part and put <code>return true</code> outside the <code>for</code> loop.</p>

<p>Why <code>return true</code> outside the for loop?</p>

<p>Because return <code>true</code> only when you checked all the element, not every time. Take a look at your code you'll get it.</p>
",0
14745894,14745825,12,"<p>Because <code>unsigned char</code> cannot be represented by <code>char</code>. For example, if they're both 8 bits, and your unsigned char contains the value <code>255</code>, that overflows the <code>signed char</code> - and signed integer overflow invokes undefined behavior. Anyway, printable characters are generally expected to be stored in <code>char</code> and not <code>unsigned char</code> (and C strings are of type <code>char[]</code> and not <code>unsigned char[]</code>, etc.)</p>

<p>So the promotion to <code>int</code> is necessary to represent values greater than <code>1 &lt;&lt; (CHAR_BIT - 1)</code>.</p>
",3
14745985,14745825,-1,"<p>int and char are just different in range in C and C++, if char it ranges from 0 to 255 and if int, it has its range like 65535 (range of int will vary with OS). So compiler just treat it as int.</p>
",3
14746323,14745825,7,"<p>I believe the correct derivation from the Standard is based on the paragraph below, which is found section 13.3.3 <em>Best viable functions</em>, i.e. it's part of the (very complicated) rules for function overload resolution.</p>

<blockquote>
  <p>(¡ì13.3.3.2/4) Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a Promotion, which is a better conversion than a Conversion. Two conversion sequences with the same rank are indistinguishable unless one of the following rules applies: [...]</p>
</blockquote>

<p>Converting <code>unsigned char</code> to <code>int</code> is classified as <em>promotion</em> (defined in ¡ì4.5; when reading the below, note that <code>(unsigned) char</code> is an <em>integer type</em>):</p>

<blockquote>
  <p>¡ì4.5 Integral promotions<br>
  [...]</p>
  
  <p>(¡ì4.5/2) A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned int.</p>
</blockquote>

<p>Whereas converting <code>unsigned char</code> to <code>char</code> is not classified as <em>promotion</em> because their ranks are identical:</p>

<blockquote>
  <p>(¡ì4.13/1) [...] The rank of char shall equal the rank of signed char and unsigned char. [...]</p>
</blockquote>

<p>It is classified as <em>integral conversion</em> (¡ì4.7) instead, and, as described above, promotion is preferred over conversion during overload resolution.</p>
",0
14747015,14745825,3,"<p>In C++ standard , <code>char</code> isn't defined to be unsigned or signed (though size is 1 byte) , so it's implementation defined. So in your implementation I believe it's signed char that's why it got promoted.</p>
",0
15889339,15888423,3,"<blockquote>
  <p>I just want to use it so that it can search or return the filename without the .exe extension.</p>
</blockquote>

<p>Sure, just use the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb773746.aspx"" rel=""nofollow""><code>PathRemoveExtension</code></a> function. You just pass it a buffer of length <code>MAX_PATH</code> containing the string, and it strips off the extension (if one is present) in-place.</p>

<pre><code>std::wstring path(MAX_PATH, L'\0');
if (!GetCurrentDirectoryW(MAX_PATH, &amp;path[0]))
{
    throw std::runtime_error(""The GetCurrentDirectory function failed"");
}
PathRemoveExtension(&amp;path[0]);
</code></pre>

<p>And I would recommend using either <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb773571.aspx"" rel=""nofollow""><code>PathCombine</code></a> or <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb773565.aspx"" rel=""nofollow""><code>PathAppend</code></a> to concatenate path elements, rather than the C-style string manipulation functions. These functions are designed to work with paths, and automatically add the backslash (or whatever other path separator character) for you. </p>

<p><br/>
But I don't really understand the code you've posted in the question, starting with the comment:</p>

<pre><code>// Hack for Windows in case there are unicode chars in the path.
// The normal argv[] array has ????? instead of the unicode chars
// and fails, so instead we manually get the short file name, which
// is always using ANSI chars.
</code></pre>

<p>Perhaps a simpler way of explaining this would be that the standard <code>argv[]</code> array, passed as a parameter to the entry point of a C program, is required to be an array of type <code>char</code>. On Windows, that means that it does not support Unicode characters. Support for Unicode requires you to use <code>wchar_t</code> (or one of the equivalent macros).</p>

<p>You can work around this problem in Windows specifically by using <code>wmain</code> as the entry point, instead of <code>main</code>. To this function, <code>argv[]</code> is an array of wide characters (<code>wchar_t</code>). I assume that you're cross-compiling the code for multiple operating systems, in which case you'll need to use some preprocessor magic to ensure that you get the right entry point when targeting Windows.</p>

<p>If you absolutely can't do that, then just call the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms683156.aspx"" rel=""nofollow""><code>GetCommandLine</code></a> and <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb776391.aspx"" rel=""nofollow""><code>CommandLineToArgv</code></a> functions to retrieve the command line arguments, and then convert them into an <code>argv[]</code> style array that contains wide characters.</p>

<p>As an alternative to this, you could do as Alf suggested and call the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms683197.aspx"" rel=""nofollow""><code>GetModuleFileName</code></a> function, passing <code>NULL</code> as the first argument, to retrieve the path of your executable file.</p>

<p>Either way you approach it, it is important to realize that converting a short path is a <em>really</em> ugly hack and one that is actually subject to breaking if the underlying file system has short names disabled. Since your code is using Unicode APIs everywhere, there should be no problem for you to deal with Unicode characters in the path, as long as you obtain a valid path string in the first place.</p>
",1
15869023,15869006,3,"<p>You are calling it incorrectly, you need to pass the address of the variables as the arguments:</p>

<pre><code>foo(&amp;x,&amp;y,z);
</code></pre>

<p>Also, since you are passing z by value not reference, you should probably assign it to the return value of the function (it looks like that is what you are trying to do?):</p>

<pre><code>z=foo(&amp;x,&amp;y,z);
</code></pre>
",0
15869024,15869006,1,"<p>You're declaring variables where you're meant to be passing them..</p>

<pre><code>foo(&amp;x, &amp;y, z);
</code></pre>
",0
16426970,16422883,3,"<p>Try to verbose builder output to see exact steps of what's going on. I suppose, you use Visual Studio, right?</p>

<ol>
<li>Go to menu ""Tools -> Options""</li>
<li>In options dialog, select ""Projects and Solutions -> Build and Run""</li>
<li>Change current mode of ""MSBuild project build output verbosity"" from ""Minimal"" to something like ""Diagnostics"" or ""Detailed"".</li>
<li>Rebuild your project and investigate Output windows</li>
</ol>

<p>Builder dump should shed more light on your current settings (I suspect you have more references to that file than you expect)</p>
",2
16428880,16422883,12,"<p>OK, I have no idea how <strong>I did it</strong> but I'm still going to try to write what I did.</p>

<ol>
<li><strong>Save all</strong> and <strong>Close solution</strong></li>
<li>Open the <strong>.vcxproj</strong> file <em>(not .sln)</em></li>
<li><strong>Build</strong> -> <strong>Clean [Project Name]</strong></li>
<li><strong>Save all</strong> and <strong>Close</strong></li>
<li>Open the <strong>.sln</strong> file again.</li>
<li><strong>Build</strong> -> <strong>Project Only</strong> -> <strong>Clean Only [Project Name]</strong></li>
<li><strong>Build</strong> -> <strong>Project Only</strong> -> <strong>Build Only [Project Name]</strong></li>
</ol>

<p>That's exactly what I did and <strong>worked for me</strong>. I think the main thing to do is <strong>clean, save, close, open, build</strong>, but I'm not sure.</p>
",1
16468246,16468203,8,"<blockquote>
  <p>I've been told that a is actually a function that returns a MyClass [...]</p>
</blockquote>

<p>That is a function <strong>declaration</strong>. It just declares a function called <code>a</code> and makes the compiler aware of its existence and its signature (in this case, the function takes no arguments and returns an object of type <code>MyClass</code>). This means you may provide the <strong>definition</strong> of that function later on:</p>

<pre><code>#include ""iostream""

using namespace std;

class MyClass {
    public:
        int a;
};

int _tmain()
{
    MyClass a (); // This *declares* a function called ""a"" that takes no
                  // arguments and returns an object of type MyClass...

    MyClass b = a(); // This is all right, as long as a definition for
                     // function a() is provided. Otherwise, the linker
                     // will issue an undefined reference error.

    int exit; cin &gt;&gt; exit;
    return 0;
}

MyClass a() // ...and here is the definition of that function
{
    return MyClass();
}
</code></pre>
",6
14150144,14150134,1,"<p>You can't overload by return type;  only by parameters.</p>
",0
14150159,14150134,2,"<p>You can't overload by return type because:</p>

<pre><code>int main() {
   f();  // call to void f
   f();  // call to int returning one
   f();  // call to void
   return 0;
}
</code></pre>

<p>Are all ambiguous.</p>

<pre><code>float f() { return 0.0f; }
char  f() { return 'a';  }
int   i = f();
</code></pre>

<p>is also ambiguous.</p>
",0
14150169,14150134,4,"<p>According to the C++ standard, 13.2.1</p>

<blockquote>
  <p>Two function declarations of the same name refer to the same function if they are in the same scope and have equivalent parameter declarations.</p>
</blockquote>

<p>This means that only the name and parameter types are considered; return type is not.</p>

<p>This makes sense, because you can invoke a function with a return value, and disregard its return value. If language designers allowed overloads on the return type, compilers would not be able to resolve these overloads in some legitimate contexts.</p>
",0
13706608,13706095,2,"<p>This line is invalid C++ (and invalid C too, which your code appears to be written in):</p>

<pre><code>int bla[2] = findH(field, positionH);
</code></pre>

<p>bla is an array of 2 elements and cannot be initialised that way. findH returns int.</p>
",0
13706167,13706095,6,"<p><code>positionH[]</code> is an array, and its return type is <code>int</code>.</p>

<p>The compiler will not let you do that.  Either make the parameter an int:</p>

<pre><code>int findH(int positionH){
    return positionH;        
}
</code></pre>

<p>Or make the return type a pointer to an int:</p>

<pre><code>int* findH(int positionH[]){
    return positionH;        
}
</code></pre>

<p>Or convert the array to an integer before return:</p>

<pre><code>int findH(int positionH[]){
    return positionH[0];
}
</code></pre>
",0
13706185,13706095,0,"<p>The error was caused because you returned a pointer and the compiler is expecting a int.</p>

<p>There is a very BIG difference between int * and int. </p>

<p>Also why are you returning positionH, arrays are passed by reference, there is no need to return it.</p>

<p>Better code would be</p>

<pre><code>void option1(char** field, int[])   
   {
     int  findH(char **, int[]); 
     int positionH[2];
    findH(field, positionH);
      //positionH passed by reference, no need to return it
    }

void  findH(char **field, int positionH[])
{
    for(int n = 0;n &lt; 14 ; n++)
    {
        for(int m = 0; m &lt; 14; m++)
        {
                   if(field[m][n] == 'H')
                   {

                   positionH[0] = n;
                   positionH[1] = m;

        }
         }
    }

}
</code></pre>
",3
13728768,13728629,0,"<p>You are getting errors probably because you are caliing <code>Parameters()</code> function with <code>pParam</code> argument whereas you are initializing <code>p_param</code> members.</p>
",0
13733853,13733714,2,"<p>Personally, I would guess that printing the tokens is the biggest time sink. Try this instead and see if it runs faster:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main() {
    std::ios_base::sync_with_stdio(false);
    std::ifstream in(""data.txt"", std::ios_base::binary);
    for (std::string token; in &gt;&gt; token; ) {
        if (++count / 100000 == 0) {
            std::cout &lt;&lt; ""read "" &lt;&lt; count &lt;&lt; "" tokens\n"";
        }
    }
    std::cout &lt;&lt; ""read "" &lt;&lt; count &lt;&lt; "" tokens\n"";
}
</code></pre>
",0
15579735,15579709,2,"<p>The correct way is to use <code>std::string</code> instead of the dynamic array of <code>char</code>, and <code>std::vector&lt;PERSON&gt;</code> instead of the dynamic array of <code>PERSON</code>.</p>

<p>If you have dynamically and manually allocated data in a class, you have to make sure that you follow <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"" rel=""nofollow""><em>the rule of three</em></a>, that is, implement a copy constructor, assignment operator and destructor to perform ""deep copies"" of the data. This is to ensure that each instance of your class owns its dynamically allocated data, and makes copying and assigning safe. In C++11, this is generalized to <em>the rule of five</em>.</p>

<p>An unrelated matter: names containing leading underscores, or double underscores anywhere, are reserved for the implementation. So you shouldn't give your variables names such as <code>in__PeopleCount</code>.</p>
",7
15820243,15820224,5,"<p>If you need to preserve leading zeros, you should store <code>id</code> as a string and not an <code>int</code>.</p>
",0
15820290,15820224,1,"<p>If your IDs will always be a particular length, you can use C's <code>printf</code> function instead of streams, which gives you more power;</p>

<pre><code>printf( ""Student: %s %s ID %08d\n"", student.name, student.surname, student.id );
</code></pre>

<p>That will always print 8 digits of ID, and will prefix with 0s as needed (if it was just <code>%8d</code> it would prefix with spaces).</p>

<p>But as already pointed out, you're likely better off storing it as a string, because then you will be able to increase the length of the IDs in the future without needing to adjust all the old IDs.</p>
",1
15820857,15820224,0,"<p>If you need or want to keep the student id a number for some reason you can also us the following: </p>

<pre><code>#include &lt;iomanip&gt;

const int width = 8; //The length of your student ID numbers

cout &lt;&lt; ""\nStudent: "" &lt;&lt; student.name &lt;&lt; "" "" &lt;&lt;student.surname
     &lt;&lt; "" ID "" &lt;&lt; setfill('0') &lt;&lt; setw(width) &lt;&lt; student.id &lt;&lt; setfill(' ') &lt;&lt; endl;
</code></pre>

<p>If your ID numbers are not all the same length you will have to detect how long they are and use the appropriate width in each setw() call. </p>
",0
14180905,14180881,0,"<pre><code>while(i&gt;-1 &amp;&amp; a[i]&gt;k)
        {
           a[i+1] = a[i];
           i = i-1;
        }
</code></pre>

<p>make only this change and your insertion sort will work perfectly.</p>

<p>its not getting sorted because array starts from a[0] n your while gets terminated when its at a[0] so not visiting its element.</p>

<p>hope it helped you</p>
",2
14180917,14180881,3,"<p>The problem is the <code>&gt;0</code> in</p>

<pre><code>while(i&gt;0 
</code></pre>

<p>This should read</p>

<pre><code>while(i&gt;=0 
</code></pre>

<p>Also, there's undefined behaviour in </p>

<pre><code>    k = a[j];
</code></pre>

<p>when <code>j==6</code>.</p>
",1
13785103,13784995,1,"<p>A control statement executing a single line of code can be written in two different way.</p>

<pre><code>if (optketchup == ""yes"") {
  slcketchup = ""with"";
}
</code></pre>



<pre><code>if (optketchup == ""yes"") slcketchup = ""with"";
</code></pre>

<p>Also the following code is valid; the difference is that there isn't any instruction to execute when <code>optketchup</code> is equal to <code>""yes""</code>.</p>

<pre><code>if (optketchup == ""yes"");
</code></pre>

<p>This is true for other control statements, such as your <code>while</code>.</p>

<p>Also, <code>=</code> is the assignment operator, while <code>==</code> is the comparison operator. You are using the latter when you wanted to use the first.<br>
Then, as others already pointed out, just convert <code>optketchup</code> to lowercase: You will just need to compare the lowercase value with <code>""yes""</code>, instead of checking any possible variant of ""yes"" written using a mix of lowercase/uppercase characters.</p>
",1
13785160,13784995,3,"<p>You have a semicolon(';') in the <code>while</code>. That's causing the problem.</p>

<p>Don't write</p>

<pre><code>while(.... lots of conditions ...);
{
    //stuff
}
</code></pre>

<p>Write</p>

<pre><code>while(.... lots of conditions ...)
{
    //stuff
}
</code></pre>

<p>Notice the lack of the <code>;</code> in the 2nd one.</p>

<p>Other than that, what if you had to check for the word <code>Pneumonoultramicroscopicsilicovolcanoconiosis</code>. How many combinations of upper &amp; lower cases would you end up checking?
Instead, convert the input into upper case &amp; compare against upper case <code>YES</code> or <code>NO</code> or <code>PNEUMONOULTRAMICROSCOPICSILICOVOLCANOCONIOSIS</code>.</p>
",1
15822594,15821733,0,"<p>Once you delete your memory and set your pointer to NULL you no longer have access to that memory even if you want it.  So, there is no way to verify that it really gone.  However, if you did something wrong and the memory was never deleted it would consist of a memory leak which would cause your program to increase the amount of ram it uses, you could see this as a symptom of a pointer not properly disposed of.</p>

<p>You will probably learn later that you will not have to worry about the deletion of your pointers because of <code>std::shared_ptr</code> which will delete your object when the pointer goes out of scope.  Which will be safer later on because you will probably will learn that exceptions can cause your destructor to never fire leaving a memory leak.</p>
",0
15821802,15821733,2,"<p>Accessing deleted memory is undefined behaviour by the standard. For instance, if this was a multithreaded application (or some other process had injected a thread into your application) then a new allocation could allocate the memory you just deallocated before you are able to ""verify"" it.</p>
",0
15821824,15821733,-2,"<pre><code>...
... 
delete m_oCustomerList;

// Try using the deleted pointer here
// This should cause a runtime exception
// which means you did free the pointer
m_oCustomerList-&gt;someStrMemberVariable = ""This will fail""
...
...
</code></pre>

<p>Needless to say, don't do this in the actual code. Hope this helps.</p>
",3
15821904,15821733,7,"<p>Note that your code</p>

<pre><code>    void EmployeeRecord::destroyCustomerList()
    {
        if(m_oCustomerList != NULL)
        {
            delete m_oCustomerList;
            m_oCustomerList = NULL;           
        }
    }
</code></pre>

<p>Simplifies to:</p>

<pre><code>    void EmployeeRecord::destroyCustomerList()
    {
        delete m_oCustomerList;
        m_oCustomerList = NULL;
    } 
</code></pre>

<p>It is safe to invoke the <code>delete</code> operator on a null pointer in C++. It does nothing. In other words, the check for null is already ""built in"".</p>

<p>Once you delete an object, it no longer exists, and the pointer to that object becomes and indeterminate value (so it's not a bad idea to null out all copies of that pointer).</p>

<p>What <em>really</em> happens to the memory in actual C++ implementations, rather than in the abstract sense, is that it continues to exist at the same address, but is marked as free, so that it can be allocated for another purpose. An allocation request coming from the program (possibly a completely unrelated module) or possibly from another program in the system, could obtain that memory for its own use.</p>

<p>Any uses of a pointer to an object which no longer exists are ""undefined behavior"". Functions for safely verifying such a pointer do exist, but they are very platform-specific and rarely perfect.</p>

<p>The problem is that whereas it is not particularly hard for an implementation to confirm that a pointer is bad, it is not possible to confirm that a pointer is good. We can walk the internal memory data structures of the memory allocator to determine that some pointer refers to free storage. But what if the storage is subsequently allocated? Then the pointer no longer refers to free storage. But it does not refer to the original object which was allocated, either! This is known as an ""ABA ambiguity"": because some A changed into a B, but then back into A, indistinguishable from the original A.</p>

<p>Approaches exist to solve the ABA ambiguity (if not completely than at least partially). For instance, pointers be made ""fat"" so the they have an extra field in addition to the address bits. The field could contain a sequence number which is used to stamp the pointer that are returned from the allocator. Now when an object is deleted and reallocated, the new pointer to the same location has a different sequence number: we have ABA'. The pointer A has gone bad, making it B, but the when it is resurrected it comes back as A'.   If we ask the system to validate A, it will correctly determine that A is bad, because it does not have the expected sequence number. The correct, valid pointer to the object is A', which does not match A.</p>

<p>However, sequence number fields are only so many bits wide and they will wrap around eventually. So the ABA problem has not really been solved. The validation of good versus bad pointers has only been made substantially more reliable. To absolutely deal with the ABA problem, the system must always hand out new pointers which are not equal to any pointers which could still be in use. This means never actually freeing anything (thereby running out of memory) or implementing garbage collection. (Meaning that <code>delete</code> actually does nothing: deleted objects are destructed, but stick around in memory until they are garbage-collected, which happens when the program no longer remembers any copies of the pointer. At that point, the program no longer remembers A, and so A can be re-introduced, and there is no ABA problem.)</p>

<p>To make <em>all</em> pointers ""fat"", you have to change the entire toolchain and runtime: compilers, libraries, et cetera.  There are further difficulties because large programs tend to have multiple memory allocators. If you ask the wrong allocator ""is this pointer valid"", all it can say is ""this pointer is not from my arena"".  Another approach you can do is to invent your own pointers and implement them as smart pointers in C++. Your pointers can support an <code>is_valid</code> method which tries to be as reliable as possible (dealing with the ABA problem somehow: either partially with some sequence numbers and such, or by implementing your own garbage collection scheme.)</p>
",1
14215176,14215140,10,"<p>Calling the destructor manually is like calling a function - the code is executed, but the memory is not freed, as opposed to calling <code>delete</code>, when the memory is freed.</p>

<p>Accessing <code>a</code> after it was deleted will result in undefined behavior, and can appear to work.</p>
",0
14215191,14215140,2,"<blockquote>
  <p>So as you see, I'm calling the destructor ~A(), so to my expectation the program should crash when trying to access the variable 'a' a second time (because it was deleted 2 lines ago). Instead.. the program just prints this without any complaints:</p>
</blockquote>

<p>Not surprising. The code is buggy, as you note. So it's not going to do what you expect but something difficult to predict or understand. If you want code that behaves predictably, you have to follow the rules. That's what they're for.</p>

<blockquote>
  <p>""Somebody told me that in basketball you can't hold the ball and run. I got a basketball and tried it and it worked just fine. He obviously didn't understand basketball."" -- Roger Miller</p>
</blockquote>
",0
14215268,14215140,3,"<p>When you call ~A() directly, the code of the destructor is executed. This won't prevent the destructor from being called again ordinarily as it would by C++. Eg:</p>

<pre><code>void func()
{
   A a;
   a.~A();  // calls destructor
   // Destructor runs again here as it always would.
}
</code></pre>

<p>In your example the memory for the int will be freed. That just means the runtime makes a note to say your program is no longer using the memory... but it doesn't necessarily mean the memory instantly gets wiped or used for something else. So, when you access the memory for the int later it still contains the same value. But, there is potential for some other thread to have reused this memory and something else could have overwritten it, but that just doesn't happen to be happening in your program.</p>

<p>A situation where it's useful to call ~A() directly is where you want to handle your own memory allocation for some situation you want to optimize. Eg, you may have your own string class and reserve a large pool of memory in one go. You can call the constructor and destructor manually to setup regions of memory in this pool to be properly initialized strings. You can do so without having to make any new allocations - just reuse the pool. But... I would say this is expert level programming and you need to know what you're doing and be doing it for a worthwhile performance gain.</p>
",0
14215297,14215140,5,"<blockquote>
  <p>the program should crash when trying to access the variable 'a' a second time</p>
</blockquote>

<p>It is an undefined behavior to access a deleted variable. This means that anything can happen, including program crashing.</p>

<blockquote>
  <p>What happens exactly when I call ~A() directly?</p>
</blockquote>

<p>In your example nothing, because you do not delete that object, but <a href=""http://www.parashift.com/c++-faq/dont-call-dtor-on-obj-allocd-via-new.html"" rel=""noreferrer"">you shouldn't do it</a>.</p>

<blockquote>
  <p>Is there any situation when it's useful to do so?</p>
</blockquote>

<p>Yes, the destructor <a href=""http://www.parashift.com/c++-faq/placement-new.html"" rel=""noreferrer"">should be explicitly be called for placement new</a>, and that is the only case when the destructor should be called.</p>
",4
15542246,15542029,4,"<p>The best algorithm would be <code>O(n)</code>, where <code>n</code> is the number of elements.</p>

<p>As you need to check each element, you must go through the whole array.</p>

<p>The easies way I can think of, is already written in your own answer.</p>

<p>And there's no faster way to do this - the memory is continuous, the array is not sorted, you need to ""touch"" each element. That's the fastest possible solution. </p>

<hr>

<p>Regarding your edit: using <code>std::count</code> and ""manually"" looping through the array will give you the same performance.</p>

<hr>

<blockquote>
  <p>Are there any faster way to search for certain elements within Array</p>
</blockquote>

<p>Yes, if the array is sorted. Then you can achieve up to <code>O( log(n) )</code>. Then you would need some existing search algorithm, like binary search, for example.</p>

<hr>

<blockquote>
  <p>Would the speed be better if we made a copy of Array and sort it</p>
</blockquote>

<p>Depends. If you plan to search for a single char - absolutely not. Copying the array is an expensive operation. Sorting it - even more expensive.</p>

<p>Well, if you will have only one array and you plan to search for, let's say, 100 different characters, then this method could give you a better performance. Now, this really depends on your usage. And nobody will be able to give you the absolutely correct answer for this case. You need to run it and profile.</p>
",2
15542285,15542029,5,"<p>As others wrote, the complexity of the best algorithm is <code>O(n)</code>, especially since your array is not sorted.</p>

<p>To make the search faster, you could subdivide the array and scan each portion separately in <strong>separate threads</strong>. This would scale linearly with the number of CPU cores you have available on your machine.</p>

<p>If, for example, you have four cores available, then spawn four threads and let each thread scan one fourth of the array.</p>

<p>Probably this discussion might help: <a href=""http://www.dreamincode.net/forums/topic/245694-using-threads-to-reduce-array-search-time/"" rel=""nofollow"">Using threads to reduce array search time</a></p>

<hr>

<p>In any case (and this is true for any performance related issues), you should profile your code. Create a test case for the approach you have, measure the time it takes and take this as a baseline. Then, for each modification you do, redo the measurement to check if it really improves the execution time. Also make sure to do each measurement more than once (within the same test case) and calculate the average, to reduce caching and other warming up effects (ideally, execute the code at least once before starting the first measurement).</p>

<p>This is Java related, but gives some good feedback that it does not in all cases make sense to parallelize: <a href=""http://www.youtube.com/watch?v=DCdGlxBbKU4&amp;feature=player_embedded"" rel=""nofollow"">A Beginner¡äs Guide to Hardcore Concurrency</a></p>
",4
15542618,15542029,4,"<p>What dou you mean by ""fast""?</p>

<p>Fast as in complexity, or as an improvement by a constant? You cannot achieve a better complexity with an unsorted array. However, if you change the array very rarely and seach it very often, you can consider sorting it after each change, or better yet, use a different data structure (like a <code>multimap</code> or a <code>set</code>).</p>

<p>If you intend to have a better constant in your <code>O(n)</code>, there are some neat tricks which use/abuse the cache of your CPU. If you search for multiple elements, it's genrally faster to search the first few hundred array elements for each of the characters, then the next few hundred, and so on, rather then scan the whole array for each of your search terms. The improvements are not in the complexity, so the effect will usually not be that great. Unless this search happens at your bottleneck repeated deep inside some other algorithm, I would not recommend it. So unless it's inside a rendering algorithm, or a device driver, or for one specific architecture etc. it is most probably not worth it. However, in the rare cases where it might be appropiate, I've seen speed improvements of 3x - 4x or more by using inline assembly and abusing the CPU chache.</p>

<p><strong>EDIT:</strong></p>

<p>Your comment idicated it might be a good idea to include a short introduction about data structures.</p>

<ul>
<li>array, vector: fastest accessing, slow searching, slow adding/removing if not appended to the end.</li>
<li>list: slow accessing, slow searching, fastest adding/removing</li>
<li>trees, hash tables, etc. : <strong>best searching</strong> (some allow <code>O(0)</code> searching!), slow changing (depends on type)</li>
</ul>

<p>I recommend learning about the different data structures (vector, list, map, multimap, set, multiset, etc.) in C++, so you can use the one which best fits your needs.</p>

<p>About the CPU cache: it seems the choosing of a better fitting data structure and code organization is much more important. However, I include this for the sake of completeness.
If you search the array in shorter chunks rather than the whole array at once, that part of the array is added to the cache of your CPU, and accessing the cache is much faster than accessing RAM. So you can work on that smaller chunk of your data (for example, search for multiple elements), then switch to the next chunk of data, and so on. This means, for example, </p>

<pre><code>search ""a"" in elements 1..100
search ""b"" in elements 1..100
search ""c"" in elements 1..100
search ""a"" in elements 101..200
search ""b"" in elements 101..200
search ""c"" in elements 101..200
...
search ""c"" in elements 999901 .. 1000000
</code></pre>

<p>can be faster than </p>

<pre><code>search ""a"" in elements 1..1000000
search ""b"" in elements 1..1000000
search ""c"" in elements 1..1000000
</code></pre>

<p>If the number of searched elements (a, b, c, ..) is sufficiently large. Why? Because in case of a cache size of 100, in the first example, data is read 10000 times from the RAM, in the second example, 30000 times.</p>

<p>However, the efficiency of this (and your choice of the data chunk size) heavily depends on your architecture, and is only recommended if you are really sure that this is your real bottleneck. Usually it's not.</p>
",1
15542737,15542029,3,"<p>Depending on it is one time scan or many times.
Sorting will help a lot on the scan speed, you can always narrow down your scan by bisearch. And the complexity could be O(log(n)).</p>

<p>Or if you can beginning from inserting and build the array which will be scan, you can use red-black tree which is slow to insert, but always sorted.</p>

<p>Last but not least, for your very question in which you are scanning ""unsigned char array"", in which the number of element is limited. You can do one time scan, but it need more memory: use the value of each element inside your unsigned char array as the index of another array which used for storing the scan result.</p>

<p>If you want the position of every element, the other array could be:  int scanresult[256][n], where n is the biggest number for the number of certain char.</p>

<p>If you only need count how many 'a' in the array, the other array could be: int scanresult[256], take this as an example,  The complexity is O(n), but only need to run once:</p>

<pre><code>unsigned char* Array = new unsigned char[ 50000 ];
/* Fill Array */
int scanresult[256];
for ( int i=0;i&lt;256;++i) { scanresult[i]=0; }
for ( unsigned int Index = 0; Index != 50000; ++ Index )
   scanresult[Array[Index]]++;
</code></pre>
",0
15542945,15542029,0,"<p>Don't forget, unsigned char > 0 &amp;&amp; unsigned char &lt;= 256...</p>

<pre><code>#define MAX 50000 

unsigned char* Array = new unsigned char[ MAX ];
unsigned int Logs[ 256 ];

// Fill Array

::memset( &amp;Logs, 0, sizeof( Logs ) * 256 );
for( unsigned int Index = 0; Index != MAX; ++ Index )
   Logs[ Array[ Index ] ] ++;

delete [] Logs;
</code></pre>
",0
15543195,15542029,2,"<p>For a single character search, <code>std::count</code> is probably as fast
as you're going to get.  And for small sets of data (and 50000)
<em>is</em> small, you're not likely to notice the time anyway.  Of
course, for a single character, almost any reasonable algorithm
will take less time than it takes to read the data. 
(<code>std::count</code> on 50000 elements in a vector or a C style array
will be close to instantaneous on a modern machine.  Orders of
magnitude uner your ""at least a second"", at any rate.)</p>

<p>If you want to go faster, the solution is to not create the
array to begin with, but to do the processing on the fly, while
you're reading the data (or to get the array immediately, via
<code>mmap</code>).  And if you need the data for more than one
character... just build up a character frequency table as you
read the data.  And find the fastest way of reading the data
(almost certainly <code>mmap</code> under Linux, at least according to some
measures I made recently).  After that, just index into this
table when you want the count.  Reading the data will be O(n)
(and there's no way around that), but after that, getting the
count is O(1), with a very, very small contant factor as well
(under a nanosecond on a lot of machines).</p>
",0
17786469,17786318,6,"<p>There is a portable-ish equivalent if you use one of the ""curses"" libraries, such as <a href=""http://www.gnu.org/software/ncurses/"" rel=""noreferrer""><em>ncurses</em></a></p>
",1
14745920,14745610,2,"<p>The function <code>isRegistered</code> reads the file to its end, and you never rewind it. The first call to <code>isRegistered</code> works OK, but the next ones never enter the <code>while</code> loop because <code>fscanf</code> returns EOF.</p>

<p>If <code>isRegistered</code> is meant to search the whole file, try this:</p>

<pre><code>int isRegistered (FILE * file, int area)
{
    int areaDigit = 0;

    rewind (file);  // Go to beginning of file and clear flags

    while (fscanf (file, ""%d %*[^ ] %*[^\n]"", &amp;areaDigit) != EOF)
        if (area == areaDigit)
            return 1;

    return 0;
}
</code></pre>
",1
14838553,14825195,0,"<p>After hittig end of file on your infile you have to call infile.clear() to clear the EOF bit.</p>
",0
14178195,14178164,3,"<p>It seems that you're looking for an <a href=""http://en.wikipedia.org/wiki/Abstract_factory_pattern"" rel=""nofollow"">Abstract Factory</a>.</p>

<p>An Abstract Factory is a design pattern in which different types of objects can be created depending on the argument. So in this example, the factory will create a <code>ConcreteDataADialog</code> or a <code>ConcreteDataBDilaog</code> depending on the type of the data.</p>

<p>Code sketch:</p>

<pre><code>class DialogFactory {
public:
    virtual Dialog* createDialog() = 0;
};

class ADialogFactory : public DialogFactory {
public:
    Dialog* createDialog() {
        return new ADialog();
    }
};

class BDialogFactory : public DialogFactory {
public:
    Dialog* createDialog() {
        return new BDialog();
    }
};

class Application {

    Dialog* createSpecificDialog(Data data) {
        if (data.isA()) {
            return new ADialogFactory().createDialog();
        } else {
            return new BDialogFactory().createDialog();
        }
}
</code></pre>
",5
15558872,15558841,3,"<p>just pass in A. like this. also your second and third parameters are int values, so while i wont dive into the logic of your code, you should choose aninteger to provide bounds to your array sort. what you are passing in now is an int * to the first element in the array, and then the third parameter is that value + N. BAD NEWS BEARS!</p>

<pre><code>#include &lt;iostream&gt;

 using namespace std;

 #define N 10

 void QuickSort(int arr[],int left,int right)
{
int i = left, j = right;
int buffer;
int middle = arr[(left+right)/2];

//partition
while(i&lt;=j)
{
    while(arr[i]&lt;middle)
        i++;
    while(arr[j]&gt;middle)
        j--;
    if(i&lt;=j)
    {
        buffer = arr[i];
        arr[i] = arr[j];
        arr[j] = buffer;
        i++;
        j--;
    }
}

//recursion
 if (left &lt; j)
    QuickSort(arr, left, j);
 if (i &lt; right)
    QuickSort(arr, i, right);
}

int main()
{

  int A[N] = {10,9,8,7,6,5,4,3,2,1};
  QuickSort(A,0,N);     //DO THIS
  return 0;

}
</code></pre>
",1
15558893,15558841,0,"<p>You should not use braces when passing arrays to functions, also it seems your code should be:</p>

<pre><code>QuickSort(A,0,0+N);
</code></pre>
",0
15558930,15558841,1,"<p>Two things:</p>

<ol>
<li>Pass <code>A</code> by itself.  </li>
<li><code>left</code> and <code>right</code> are array indexes, not pointers.</li>
</ol>

<p>Give this a try:</p>

<pre><code>int A[N] = {10,9,8,7,6,5,4,3,2,1};
QuickSort(A, 0, N - 1); // array length N means the last element is index N-1.
</code></pre>
",1
14185119,14184310,1,"<p>there is a obvious bug: <code>stringclass::reset()</code> and <code>stringclass::alloc()</code> <code>delete[]</code>s <code>stringclass::mystring</code> even if that is NULL or unitialized. Better:</p>

<pre><code>stringclass::stringclass()
: mystring(0), memsize(0), length(0) {}

void stringclass::reset()
{
   if(mystring) delete[] mystring;
   mystring = 0;
   memsize = 0;
   length = 0;
}

void stringclass::alloc(long newsize)
{
  if(memsize &lt; newsize) {
    if(mystring) delete[] mystring;
    memsize = newsize;
    mystring = new char[memsize];
  }
  length = 0;
}
</code></pre>

<p>etc... But <strong>much better: use <code>std::string</code></strong>.</p>
",3
14185421,14184310,1,"<p>Your stringclass's copy constructor is not initializing the class members.</p>

<p>when implementing the copy constructor like this it should work.</p>

<pre><code>stringclass::stringclass(const stringclass &amp; other)
: mystring(0), memsize(0), length(0)
{
    copy(other);
}
</code></pre>
",0
14184759,14184310,2,"<p>I just tried running this, and got a segfault.  </p>

<p>Reading your code- You are not making sure if your strings are null terminated. strcpy() and strlen() expect the strings to be null terminated.  That will definitely cause random behavior. I ran your code, got a segfault- and when printing the length was junk value. That is most likely your issue.</p>
",1
16420894,16420030,0,"<p>I see several problems.</p>

<ol>
<li><p>You're missing a copy constructor and assignment operator.</p></li>
<li><p>You're explicitly calling the destructors of the elements.<br>
This will lead to trouble when <code>delete</code> does it again, as it does automatically.</p></li>
<li><p>You're not allocating the proper amount of memory for <code>temp.stack</code> in <code>double_size</code>. Even though you have access to the private members of <code>temp</code>, you should let it manage itself (see <em>copy constructor</em> above).
(BTW: that variable is unnecessary - just copy from your old memory block to a new one, then delete the old block and assign the new block pointer to <code>stack</code>.)</p></li>
<li><p>There may also be some problems with the indexing in <code>double_size</code>, but you should fix those three problems first.</p></li>
</ol>
",1
16385070,16384757,0,"<p>Use an anonymous namespace:</p>

<pre><code>namespace MyGraphicsLibrary
{
    namespace
    {
        class MatrixStack
        {

        };

        class Transform
        {
            MatrixStack mMatrixStack;
        };
    }

    class Renderer
    {
        Transform mTransform;
    };

}
</code></pre>
",0
16385084,16384757,2,"<p>you can use the PIMPL- (also called opaque pointer) idiom.
with hat you can entirely hide the classes from user the following way:</p>

<p>In your public header (in your include folder):
Renderer.h</p>

<pre><code>class RendererImpl; // forward declaration of internal render structure

//public classes for users
class Renderer
{
  public:
    Renderer();
    ~Renderer();
    // public interface comes here and delegates all calls to RendererImpl (have to be implemented in cpp)

  RendererImpl* renderer; // better use something like QScopedPointer here
};
</code></pre>

<p>the cpp:</p>

<pre><code>#include ""RendererImpl.h"" // your actual renderer that 

Renderer::Renderer()
:renderer(new RendererImpl)
{}
Renderer::~Renderer()
{
  delete renderer;
}
</code></pre>

<p>The implementations may be completely hidden from the API. The headers have to be separated from the real interfaces.</p>
",0
16385317,16384757,1,"<p>If you want to store Transform as a plain (non-pointer/reference) member, then for the compilation of your public header, its definition should also be visible, because it affects the layout of the container class.</p>

<p>Consequently, the type will be visible wherever you want to use the container class.</p>

<p>You have the following options:</p>

<ol>
<li>Signal that they are not for public use through naming. Either by putting into a namespace (like detail in boost), or prefixing/suffixing its name.</li>
<li>Use a technique that prevents clients from using that class. Make every member functions private and declare the container class friend. The attorney-client idiom is a more sophisticated way of fine-grained access control.</li>
<li>Store Transform indirectly (pointer or reference), so you do not need its definition in the public header. This is pimpl. A variant of this if the public type is an interface, a base class of the actual Transform implementation.</li>
</ol>

<p>Unnamed namespace: definitely a bad idea in a header. Unnamed namespaces are like C static: they get a compiler-generated identifier that is guaranteed to be unique to the given translation unit. You will end up with as many distinct Transform types as many places you included its definition.</p>
",1
14775853,14775559,1,"<p>Since you asked for an explanation, when you enter <code>1.2</code> </p>

<pre><code>cin &gt;&gt; z;   //Successfully reads '1' into 'z'

cin &gt;&gt; n1;  //Fails to read '.' into 'n1'. '.' remains the first character in the stream.

cin &gt;&gt; n2;  //Fails to read '.' into 'n2'. '.' remains the first character in the stream.
</code></pre>

<p>You then loop back to the beginning of your loop.</p>

<pre><code>cin.clear(); //clears the fail flag from the two previous failed inputs
cin.ignore(); // ignores the '.'

cin &gt;&gt; z;   //Reads '2' into 'z'. The stream is now empty.
</code></pre>

<p>The program then blocks on <code>cin &gt;&gt; n1</code> waiting for more characters to be placed in the stream.</p>

<p>After each input, you should see if the input failed. </p>

<pre><code>cin&gt;&gt;n1;
if(cin.fail())
   cin.ignore();
</code></pre>
",0
17840566,15744768,0,"<p>A bit late to the game, but the DataRefs sheet indicates that <code>sim/graphics/view/panel_render_type</code> is not writeable.</p>

<p>I don't have a good workaround at this point :/</p>
",0
18137887,18137865,2,"<p>You are returning a reference to <code>str</code> which is a local variable in your function.</p>

<p>Return a copy: <code>MyString operator+(char *s)</code>.</p>
",0
18138065,18137865,0,"<p>Another minor fault is strcpy(tmp, s) which is not correct.Change strcpy to strcat may be right.</p>
",1
14851253,14851214,4,"<p>With lifetime management:</p>

<pre><code>std::string query;
int n = 2;

{
    std::ostringstream oss;
    oss &lt;&lt; n;
    query = oss.str();
}
</code></pre>

<p>Shorter, but a bit tougher to read:</p>

<pre><code>int n = 2;
std::string query
          = static_cast&lt;std::ostringstream &amp;&gt;(std::ostringstream() &lt;&lt; n).str();
</code></pre>

<p>Possibly better, depending on your situation:</p>

<pre><code>auto query = std::to_string(2);
</code></pre>
",0
14851282,14851214,0,"<p>Just let it go out of scope:</p>

<pre><code>int n=2;
string query;
{
    ostringstream convert;
    convert &lt;&lt; n;
    query = convert.str();
}
</code></pre>
",0
14851294,14851214,0,"<p>you don't need to free the stream. the stream is on the stack, so it will destroyed automatically.</p>
",0
14851583,14851214,0,"<blockquote>
  <p>How can I free ostringstream?</p>
</blockquote>

<p>If by ""free"" you mean ""deallocate resources"" for the instance, then let it go out of scope.</p>

<pre><code>int n=2;
string query;
{
    ostringstream convert;   // stream used for the conversion
    convert &lt;&lt; n; 
    qyuery = convert.str();
}
</code></pre>

<p>If you mean ""clear the contents"" then you can use:</p>

<pre><code>int n=2;
ostringstream convert;   // stream used for the conversion
convert &lt;&lt; n; 
string query1 = convert.str();
// clear the contents &amp; reset error bits (thanks @PeterWood)
convert.str("""");
convert.clear();
convert &lt;&lt; n + 1;
string query2 = convert.str();
</code></pre>
",0
14150552,14150537,2,"<p>A template argument cannot be a temporary object. Only primitive types which can reasonably be compared for exact equality may be template non-type arguments. This includes</p>

<ul>
<li>integers,</li>
<li>enumerators, and</li>
<li>pointers to objects with <code>extern</code> linkage.</li>
</ul>

<p>But</p>

<ul>
<li>floating-point numbers aren't allowed because they can be very close yet not equal</li>
<li><code>static</code> objects might have the same name but different locations in different files, which would make the template-id confusingly resolve to different instantiations with the same name in different files</li>
<li>same goes for string literals</li>
<li>temporary objects don't have consistent addresses so you can't pass a pointer to one</li>
<li>the value of a temporary object as you passed, which can't even be tested for equality, would never let the language match one template instantiation to another!</li>
</ul>

<p>(As Pubby notes, <code>A()</code> is actually interpreted as the type of a function with no parameters returning <code>A</code>. So the compiler is just failing to find a template declaration taking two type parameters.)</p>
",0
14150562,14150537,2,"<p>Possible duplicate of <a href=""https://stackoverflow.com/questions/5687540/non-type-template-parameters"">Non-type template parameters</a></p>
<p>These are the rules of template non type parameters</p>
<blockquote>
<p>A non-type template-parameter shall have one of the following (optionally cv-qualified) types:</p>
<ul>
<li>integral or enumeration type,</li>
<li>pointer to object or pointer to function,</li>
<li>lvalue reference to object or lvalue reference to function,</li>
<li>pointer to member,</li>
<li><code>std::nullptr_t</code>.</li>
</ul>
</blockquote>
<p>What you are passing is an RValue (temporary object, etc which cannot be assigned to), which does not fall under any of these possibilities.</p>
<h2>edit:</h2>
<p>It appears that it is infact being interpreted as a function type, but your template signature expects a non type parameter of type <code>A</code> (exactly a <code>const A&amp;</code>)</p>
",3
14235071,14234741,2,"<p>Your array is not an object but a collection of consecutive position in memory containing <code>int</code>. You cannot dynamically grow it as <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow"">std::vector</a> does. Consider using std::vector, pre-allocate memory enough and then copy new values using <a href=""http://www.cplusplus.com/reference/cstring/memcpy/"" rel=""nofollow"">memcopy</a> or dynamically allocate and release (using <code>new</code> and <code>delete</code>) a new buffer when new size is known.</p>
",0
14234860,14234741,1,"<p>C++ does not support addition of rows into static arrays.In case you need dynamically growing array, vector is your guy for the job.
If you don't want to use vectors then initialize the array with the required number of rows and recompile your program. </p>
",0
14183609,14183546,3,"<p>Two dimensional arrays are not stored as pointer to pointers, but as a contiguous block of memory. </p>

<p>An object declared as type <code>int[y][x]</code> is a block of size <code>sizeof(int) * x * y</code> whereas, an object of type <code>int **</code> is a pointer to an <code>int*</code></p>
",1
14183554,14183546,63,"<blockquote>
  <p>Why does <code>int*[]</code> decay into <code>int**</code> but not <code>int[][]</code>?</p>
</blockquote>

<p>Because it would be impossible to do pointer arithmetic with it.</p>

<p>For example, <code>int p[5][4]</code> means an array of (length-4 array of <code>int</code>).  There are no pointers involved, it's simply a contiguous block of memory of size <code>5*4*sizeof(int)</code>.  When you ask for a particular element, e.g. <code>int a = p[i][j]</code>, the compiler is really doing this:</p>

<pre><code>char *tmp = (char *)p           // Work in units of bytes (char)
          + i * sizeof(int[4])  // Offset for outer dimension (int[4] is a type)
          + j * sizeof(int);    // Offset for inner dimension
int a = *(int *)tmp;            // Back to the contained type, and dereference
</code></pre>

<p>Obviously, it can only do this because it knows the size of the ""inner"" dimension(s).  Casting to an <code>int (*)[4]</code> retains this information; it's a pointer to (length-4 array of <code>int</code>).  However, an <code>int **</code> <em>doesn't</em>; it's merely a pointer to (pointer to <code>int</code>).</p>

<p>For another take on this, see the following sections of the C FAQ:</p>

<ul>
<li><a href=""http://c-faq.com/aryptr/pass2dary.html""><em>6.18: My compiler complained when I passed a two-dimensional array to a function expecting a pointer to a pointer.</em></a></li>
<li><a href=""http://c-faq.com/aryptr/ary2dfunc2.html""><em>6.19: How do I write functions which accept two-dimensional arrays when the width is not known at compile time?</em></a></li>
<li><a href=""http://c-faq.com/aryptr/ary2dfunc3.html""><em>6.20: How can I use statically- and dynamically-allocated multidimensional arrays interchangeably when passing them to functions?</em></a></li>
</ul>

<p>(This is all for C, but this behaviour is essentially unchanged in C++.)</p>
",1
14183565,14183546,8,"<p>Because <code>int[M][N]</code> and <code>int**</code> are incompatible types. </p>

<p>However, <code>int[M][N]</code> can decay into <code>int (*)[N]</code> type. So the following :</p>

<pre><code>std::is_same&lt;int(*)[1], std::decay&lt;int[1][1]&gt;::type&gt;::value;
</code></pre>

<p>should give you <code>true</code>.</p>
",1
14184821,14183546,10,"<p>C was not really ""designed"" as a language; instead, features were added as needs arose, with an effort not to break earlier code.  Such an evolutionary approach was a good thing in the days when C was being developed, since it meant that for the most part developers could reap the benefits of the earlier improvements in the language before everything the language might need to do was worked out.  Unfortunately, the way in which array- and pointer handling have evolved has led to a variety of rules which are, in retrospect, unfortunate.</p>

<p>In the C language of today, there is a fairly substantial type system, and variables have clearly defined types, but things were not always thus.  A declaration <code>char arr[8]</code>; would allocate 8 bytes in the present scope, and make <code>arr</code> point to the first of them.  The compiler wouldn't know that <code>arr</code> represented an array--it would represent a char pointer just like any other <code>char*</code>.  From what I understand, if one had declared <code>char arr1[8], arr2[8];</code>, the statement <code>arr1 = arr2;</code> would have been perfectly legal, being somewhat equivalent conceptually to <code>char *st1 = ""foo, *st2 = ""bar""; st1 = st2;</code>, but would have almost always represented a bug.</p>

<p>The rule that arrays decompose into pointers stemmed from a time when arrays and pointers really were the same thing.  Since then, arrays have come to be recognized as a distinct type, but the language needed to remain essentially compatible with the days when they weren't.  When the rules were being formulated, the question of how two-dimensional arrays should be handled wasn't an issue because there was no such thing.  One could do something like <code>char foo[20]; char *bar[4]; int i; for (i=0; i&lt;4; i++) bar[i] = foo + (i*5);</code> and then use <code>bar[x][y]</code> in the same way as one would now use a two-dimensional array, but a compiler wouldn't view things that way--it just saw <code>bar</code> as a pointer to a pointer.  If one wanted to make foo[1] point somewhere completely different from foo[2], one could perfectly legally do so.</p>

<p>When two two-dimensional arrays were added to C, it was not necessary to maintain compatibility with earlier code that declared two-dimensional arrays, because there wasn't any.  While it would have been possible to specify that <code>char bar[4][5];</code> would generate code equivalent to what was shown using the <code>foo[20]</code>, in which case a <code>char[][]</code> would have been usable as a <code>char**</code>, it was thought that just as assigning array variables would have been a mistake 99% of the time, so too would have been re-assignment of array rows, had that been legal.  Thus, arrays in C are recognized as distinct types, with their own rules which are a bit odd, but which are what they are.</p>
",3
14201173,14201135,7,"<p>Qt is what you're looking for: <a href=""http://qt-project.org"">http://qt-project.org</a></p>
",2
14201200,14201135,1,"<p>There's plenty: <a href=""http://www.wxwidgets.org/"" rel=""nofollow"">wxWidgets</a>, <a href=""http://qt-project.org/"" rel=""nofollow"">Qt</a>, <a href=""http://www.gtk.org/"" rel=""nofollow"">GTK+</a>, and many many more. All easy to find in short time using any search engine.</p>
",1
14233893,14233796,6,"<p>When <code>getline</code> fails on writing to your target <code>line</code> you are assuming it will not modify what is in that string but it is blanking the string, which internally is replacing character 0 with a null character.</p>

<p>The rest is undefined behaviour as you are reading characters off the end of the logical string.</p>

<p>To fix this issue change your code to;</p>

<pre><code>string line;

ifstream myfile (""hangman_word_collection.txt"");
if (myfile.is_open())
{
    while (myfile.good())
    {
       std::string temp;
       if( getline( myfile, temp ) )
       {
           temp.swap( line );
           cout &lt;&lt;line&lt;&lt;endl;
       }
    }
}
</code></pre>

<p>Note that it is bad practice to hard-code in magic numbers like 79. If you had put <code>line.size()</code> instead you would have seen what size the string actually is, and there would be no undefined behaviour. You can store this in a variable outside the loop if you are worried about performance, although chances are it makes little difference.</p>
",4
14234909,14234718,0,"<p><code>new coral::PropertyManager</code> allocates a new PropertyManager on the heap, but because it is a temporary variable you will never release it. This is the standard Java idiom, since Java is a garbage-collected language where the GC will take care of releasing this dangling reference for you.</p>

<p>If you want to use <code>new</code> here for some reason, the proper way to do this would be as follows:</p>

<pre><code>auto *pm = new coral::PropertyManager; // auto is C++11 syntax
m_propertyManager(pm);
delete pm; // when you're done using it
</code></pre>

<p>Your second option is correct, in that it allocates <code>Mgr</code> as an automatic variable on the stack, which will be released when the function exits. <code>m_propertyManager(&amp;Mgr);</code> passes the <em>address</em> of Mgr to the function, which will allow it to modify the Mgr object (although this is probably better done by passing Mgr as a reference).</p>

<p>Just note that if m_propertyManager is an object that persists after the current scope exits, and if it stores the reference to Mgr somewhere, then when you exit the current scope and the Mgr object is destroyed you will find m_propertyManager holding a reference to invalid memory.</p>
",3
14234924,14234718,0,"<p>If you allocate memory with <code>new</code>, you have to free it somewhere using <code>delete</code>. If <code>m_propertyManager</code> isn't supposed to manage the lifetime of <code>PropertyManager</code>, it will just throw the pointer away leaving the memory allocated and without access.</p>

<p>On the other hand, your second solution will crash. Look:</p>

<pre><code>{
    coral::PropertyManager Mgr;
    m_propertyManager-&gt;SetManager(&amp;Mgr); // You pass pointer to Mgr here
}
// Here Mgr no longer exists, so m_propertyManager
// now contains the pointer to non-existing object
</code></pre>

<p>You should either:</p>

<ul>
<li>Create <code>PropertyManager</code> dynamically (using <code>new</code>), hold a pointer to it somewhere and free it explicitly at some point using <code>delete</code>;</li>
<li>Implement move ctor in <code>PropertyManager</code> and pass by value (such that <code>m_propertyManager</code> will implicitly automatically allocate its own instance of <code>PropertyManager</code>)</li>
<li>Use static allocation (as in your second example), but keep the instance in the place, where it will be kept alive <em>at least</em> as long as <code>m_propertyManager</code>.</li>
<li>Use some kind of automatic pointer (like std::shared_ptr or std::unique_ptr) inside m_propertyManager</li>
</ul>
",0
15813063,15812911,1,"<p>It's called <code>reflection</code>, you cannot do this with c++. Use another languages like java or c# for that.</p>
",6
14248570,14248544,8,"<p>When you enter your data, you type the letter then press <kbd>ENTER</kbd>.  This adds your letter as well as the return character (<code>\n</code>) to the stream.  Since <code>cin.get()</code> isn't going to wait for your input when there are still characters to extract from the stream, it's picking up the <code>\n</code> every other pass.  </p>

<p>You can quickly fix this by adding <code>cin.ignore</code>:</p>

<pre><code>while (letter != '1')
{
    cout &lt;&lt; ""Enter a letter: "";
    cin.get(letter);
    cin.ignore(256, '\n');
    cout &lt;&lt; char(toupper(letter)) &lt;&lt; '\n';
}
</code></pre>

<p>An alterative would be to use the <code>&gt;&gt;</code> operator as <code>cin.get</code> only retrieves one char at a time:</p>

<pre><code>while (letter != '1')
{
    cout &lt;&lt; ""Enter a letter: "";
    cin &gt;&gt; letter;
    cout &lt;&lt; char(toupper(letter)) &lt;&lt; '\n';
}
</code></pre>
",4
14248574,14248544,3,"<p>Just change the <code>cin.get(letter)</code> to <code>cin &gt;&gt; letter;</code>, and it will work as expected.</p>

<p><b>EDIT:</b> Thought I give some more information on this. get() extracts exactly one character from the stream, which will leave the newline character in there as others have pointed out. The next call to get() will extract it and terminate immediately instead of waiting for input, since the stream still had data. The <code>&gt;&gt;</code>-operator on the other hand, is made exactly for what you're trying to do here: Read a value from stdin until the return key is pressed. So it consumes the newline as well, causing the next call to <code>operator&lt;&lt;()</code> to block until new data is entered by the user.</p>

<p><b>Note:</b> One more thing to keep in mind: <code>&gt;&gt;</code>-extracting into a char will extract at most one character from the stream, but it does not prevent the user from entering more characters before pressing enter. This will produce some output like the following:</p>

<pre><code>niko@lethal-guitar:~$ ./a.out 
Enter a letter: a
A
Enter a letter: asas
A
Enter a letter: S
Enter a letter: A
Enter a letter: S
</code></pre>

<p>This is because the operator removes one char and the newline, but keeps the remaining chars in the stream. These will terminate the next three <code>operator&gt;&gt;()</code>-calls immediately.</p>
",1
14248837,14248544,1,"<p>For starters, because you don't check whether <code>cin.get</code> succeeds
or not.  You will almost certainly output the last character you
read twice.  Your loop should be: </p>

<pre><code>while ( letter != '1' &amp;&amp; cin.get( letter ) ) ...
</code></pre>

<p>or</p>

<pre><code>while ( cin.get( letter ) &amp;&amp; letter != '1' ) ...
</code></pre>

<p>Note too that on most systems, <code>cin.get()</code> will not return until
you hit enter (supposing input from the keyboard).  So you'll
output <code>""Enter a letter: ""</code>, and then wait until the enter key
is pressed.  You'll then loop without waiting, reading all of
the characters you've entered, until you've read <code>'\n'</code>.  There
are no provisions for character-wise input in the C++ standard,
and the techiques for doing it vary radically from one system
to the next.</p>
",0
14728116,14727580,3,"<p>You're going to have to specify which <code>listNode</code> you're talking about at the <code>find</code> method's return type because you defined it as a member of the <code>List</code> class and you're also going to have to use <code>typename</code> (because <code>List&lt;T&gt;</code> is a dependent scope).</p>

<pre><code>template &lt;class T&gt;
typename List&lt;T&gt;::listNode* List&lt;T&gt;::find(listNode* place, int k)
{
    if ((k == 0) || (place == NULL))
        return place;
    else
        return find(place-&gt;next, k-1);
}
</code></pre>

<p>Assuming you're using c++11, you may also want to use <code>nullptr</code> instead of <code>NULL</code> since its safer and use the initializer list at the <code>List</code> constructor.</p>
",1
14170177,14170154,6,"<p>To be able to use <code>strcmp()</code>, you need to NUL-terminate <code>pass</code>. You also need to make sure that <code>pass</code> is large enough to accommodate the NUL.</p>
",8
14170317,14170154,0,"<p>As <code>&lt;conio.h&gt;</code> is in use, I'm assuming Windows is being used. For those who are interested, here is a start on the proper way to do this. I input a line as the password, ending when enter is pressed, and don't show asterisks, as they give away the length pretty easily.</p>

<pre><code>//stop echoing input completely
HANDLE inHandle = GetStdHandle(STD_INPUT_HANDLE); //get handle to input buffer
DWORD mode; //holds the console mode
GetConsoleMode(inHandle, &amp;mode); //get the current console mode
SetConsoleMode(inHandle, mode &amp; ~ENABLE_ECHO_INPUT); //disable echoing input

//read the password
std::string password; //holds our password
std::getline(std::cin, password); //reads a line from standard input to password

//compare it with the correct password
std::cout &lt;&lt; (password == ""luck"" ? ""Correct!\n"" : ""Wrong!\n""); //output result

//return console to original state
SetConsoleMode(inHandle, mode); //set the mode back to what it was when we got it
</code></pre>

<p>Of course there are things you can do to improve it (a hardcoded password string is never a good thing), and go ahead and do so if you wish, but the point is that it works as a basic password input system and has an easy-to-follow structure. You can still use the things you love when getting a password input, rather than going one character at a time and resorting to C strings and code.</p>
",3
15853841,15853785,11,"<p>The reason is because the second argument of <code>getline</code> is supposed to give the size of the buffer you are willing to give up and not the number of characters to extract. So in fact, the size includes the null character. You are saying that you want it to extract 12 characters (the length of the string) at most. Since we need to make room for the null character, of course we can only fit in one less than the whole string.</p>

<p>Really, you're supposed to use it like this:</p>

<pre><code>ss.getline(a, 256);
</code></pre>

<p>The argument is the <em>maximum</em> number of <code>char</code>s it will possibly write to in the array, <em>not</em> the number of characters from the string you want to take. The number of characters it extracts is determined by the delimeter (which is <code>\n</code> in this case). You can, of course, make <code>256</code> whatever number of <code>char</code>s from <code>a</code> you want to allow it to write to. Just remember that it includes the null character.</p>

<p>Note that <code>&amp;a[0]</code> is unnecessary. Arrays will undergo array-to-pointer conversion if need be.</p>
",0
15853853,15853785,1,"<p>Your problem is that you're passing a size of one too few to <code>getline()</code>, but there are better ways to do this. With C++11, you can emulate a modifiable character array (<code>std::string</code> has member functions for a non-modifiable one) by just using <code>std::string</code>:</p>

<pre><code>std::string str = ""Hello"";
someFunc(&amp;str[0], str.size());
</code></pre>

<p>Make sure, though, that <code>someFunc</code> does not overwrite the null character, even if it's with another null character. Pass the right size in to accommodate for that.</p>

<p>Without C++11, the easiest way is probably a vector:</p>

<pre><code>std::string str = ""Hello"";
std::vector&lt;char&gt; vec(str.begin(), str.end());
someFunc(&amp;vec[0], vec.size());
</code></pre>
",2
15853861,15853785,1,"<p>The second parameter of <code>getline()</code> is the maximum number of characters to write to <code>a</code> (including the null character).</p>
",0
15853906,15853785,2,"<p>Check <code>getline</code> <a href=""http://www.cplusplus.com/reference/istream/istream/getline"" rel=""nofollow"">documentation</a>,
second argument specifies string size with null terminating character, so in your program you should use:
<code>ss.getline(&amp;a[0], str.length() + 1);</code></p>
",0
14822285,14822279,5,"<p>Like this:</p>

<pre><code>#include &lt;vector&gt;

std::vector&lt;MemDigest&gt; v(numUniqueTypes);
</code></pre>

<p><br></p>

<p>""What's C++ about this?"", I hear you ask. This:</p>

<ul>
<li><p>Absence of manual memory and lifetime management</p></li>
<li><p>Absence of raw pointers</p></li>
<li><p>Exception safety</p></li>
<li><p>Trivial to resize the container at runtime</p></li>
<li><p>Avoid uninitialized states (by value-initializing your POD-class)</p></li>
</ul>
",5
14822369,14822279,0,"<p><code>vector</code> is a good way to go, but this is a more direct equivalent which is still ""c++ style"":</p>

<pre><code>std::unique_ptr&lt;MemDigest[]&gt; pMemDigestArray(new MemDigest[numUniqueTypes]);
</code></pre>
",1
15498003,15497953,3,"<p>In private inheritance all members of base class become <code>private</code> members of the derived class. Note that for classes the default inheritance is <code>private</code> when you do not specify any.      </p>

<p>Since <code>i</code> acts as an <code>private</code> member of <code>bar</code>, it can be accessed in <code>bar::bar()</code> but not from outside the member functions.</p>

<p><strong>Good Read:</strong>     </p>

<p><a href=""https://stackoverflow.com/questions/5447498/what-are-access-specifiers-should-i-inherit-with-private-protected-or-public"">What are access specifiers? Should I inherit with private, protected or public?</a></p>
",3
15498064,15497953,1,"<p>The reason for this is that you are using <strong>private inheritance</strong>.</p>

<p>For all <code>class</code>es, <code>private</code> is the default access modifier. This means that members and bases are <code>private</code> unless otherwise stated. </p>

<p>For a <code>struct</code> however, the default is <code>public</code>. Indeed, this is the only difference between a <code>class</code> and a <code>struct</code>.</p>

<p>Hence, when writing <code>class bar: foo</code>, this is equivalent to <code>class bar: private foo</code>.</p>

<p>To get rid of the issue, you need to do either <code>class bar: public foo</code> or <code>struct bar: foo</code>, both of which are equivalent in your example (since you have no members using the default access modifier).</p>
",0
15498088,15497953,0,"<p>You should directly specify name scope of fields, if they has same name in different classes:</p>

<pre><code>struct s1
{
  int i;
};

struct s2 : public s1
{
  int i;
};

int main()
{
  s2 v;

  v.s1::i = 1;
  v.s2::i = 2;

  std::cout &lt;&lt; v.s1::i &lt;&lt; v.s2::i &lt;&lt; std::endl;

  return 0;
}
</code></pre>

<p>Output will be 12</p>
",0
14156559,14156296,0,"<ol>
<li>To test for divisibility test for remainder of 0 with %</li>
<li>whiles should be ifs </li>
<li>For loop will print 0 to 99 </li>
</ol>

<p>Try something like this: </p>

<pre><code>for (int i=1; i &lt;= 100; i++) {       
    if ((i%3 != 0) &amp;&amp; (i%5 != 0)) {
        cout &lt;&lt; i;
    }
    else
    {    
        if (i%3 == 0) {
            cout &lt;&lt; ""Fizz"";
        }

        if (i%5 == 0) {
            cout &lt;&lt; ""Buzz"";
        }
    }
    cout &lt;&lt; endl;
}
</code></pre>
",0
14156326,14156296,1,"<p>Replace</p>

<pre><code>while (i * 3 ) {
</code></pre>

<p>with</p>

<pre><code>if (i % 3 == 0) {
</code></pre>

<p>etc.</p>
",1
14156331,14156296,5,"<p>You're approaching things wrong. Why do you need the <code>while (i*3)</code>? Do you know what a <code>while</code> does? Is that supposed to check the remainder? </p>

<p>Hint - use conditionals (<code>if</code>) and the <code>%</code> operator to check the remainder.</p>

<p>No full code for you! Learn to debug! (this is the best thing you can do at this stage)</p>
",5
16470511,16470433,1,"<p>There are a lot of applications, but here are two examples. Suppose you have eight one-bit values stored in a one-byte container. Bitwise-and with a power of two will access individual bits easily. </p>

<p>If you're scanning for high intensity pixels in an RGB image, you can use bitwise-and with 128 against the three color values; that's a faster operation than another Boolean expression like R>128.</p>
",0
14176753,14176687,0,"<p>See here for <a href=""http://en.wikipedia.org/wiki/Return_value_optimization"" rel=""nofollow noreferrer"">Return value optimization</a>.</p>

<p>The compiler is allowed, to eliminate the copy of a temporary object being returned.</p>

<p>With C++11, there's also the possibility of moving an object. See <a href=""https://stackoverflow.com/q/3106110/1741542"">What are move semantics?</a> for an explanation.</p>

<p><em>Update</em>:</p>

<p>This is not a problem at all, just a compiler optimization.</p>

<p>As long as there's nothing special going on in your constructor and destructor, there's no need to prevent this optimization. You should allow this instead, because it makes your program run faster by skipping one constructor and one destructor call.</p>
",5
14176249,14176191,1,"<p>Your <code>else break;</code> prevents the loop from ever looping.</p>
",0
14176251,14176191,0,"<p>The reason it only works when it's at the beginning is because you break out of the loop if it isn't, so it has no chance to check the rest:</p>

<pre><code>[first iteration]
if (0 == s2.find(""m"")) //if found at beginning
    //do stuff
else break; //exit loop if not found at beginning
</code></pre>

<p>Instead of the loop, if you're just trying to see whether there is an m, just use <code>find()</code>:</p>

<pre><code>if (s2.find('m') != std::string::npos)
    //""m"" found in string, do the operations on s1 and s3
</code></pre>
",0
14746915,14735977,0,"<p>Compilers only do optimizations that their authors</p>

<ol>
<li>have thought about and</li>
<li>considered practically useful to the point of being worth the effort to implement them.</li>
</ol>

<p>Your approach is unusual enough that probably not 1 and definitely not 2. Getters are simply more flexible and don't have any space cost and all C++ compilers can inline them if they are defined in the class directly (there are cases where they won't be, like when you want to maintain shared library ABI compatibility, but you have full control).</p>
",0
14190051,14189967,4,"<p>array decays to pointer, you only need </p>

<pre><code>char* pBuffer = buffer;
</code></pre>

<p>Also checkout: <a href=""http://en.cppreference.com/w/cpp/types/decay"" rel=""nofollow"">std::decay</a></p>

<pre><code>   std::cout &lt;&lt; ""int[] -&gt; int*; // "" &lt;&lt; std::boolalpha
              &lt;&lt; std::is_same&lt;int *, std::decay&lt;int[]&gt;::type&gt;::value;
</code></pre>

<p>Output:</p>

<pre><code>int[] -&gt; int*; // true
</code></pre>
",0
14190054,14189967,2,"<p>The error message is very clear; <code>&amp;buffer</code> is of the type <code>char (*)[9]</code>, i.e., a pointer to an array of char with 9 elements (yes, arrays are fully fledged types).  </p>

<p>That is not the same as a <code>char*</code>.  However, arrays degrade to pointers to the first element when needed, so...</p>

<pre><code>char *pbuffer = buffer;
</code></pre>
",1
14190056,14189967,-1,"<p>because the compiler can't implicitly convert char(<em>)[] to char</em>. So you need explicit type conversion</p>

<pre><code>char buffer[9] = ""12345678"";
char* pBuffer = (char*)&amp;buffer;
</code></pre>
",4
14189989,14189967,20,"<p>Instead of taking the address of the array, write</p>

<pre><code>char buffer[9] = ""12345678"";
char *pBuffer = buffer;
</code></pre>

<hr>

<p><strong>Edit</strong>: What does it all mean?</p>

<ul>
<li><p>An array of type <code>T</code> of length <code>n</code> is a (contiguous) sequence of <code>n</code> <code>T</code>'s in memory.</p></li>
<li><p>A pointer is a memory address.</p></li>
</ul>

<p>So <a href=""http://c-faq.com/aryptr/aryptr2.html"" rel=""nofollow noreferrer"">for example</a>, the following code</p>

<pre><code>char a[5] = ""hello"";
char *p = ""world"";
</code></pre>

<p>corresponds to the following situation in memory:</p>

<p><img src=""https://i.stack.imgur.com/P5odG.gif"" alt=""Comparing an array to a pointer.""></p>

<p>In your code, you have created an array</p>

<pre><code>char buffer[9] = ""12345678"";
</code></pre>

<p>in just the same way as the array <code>char a[5] = ""hello""</code> was created.  You intend to create a pointer <code>char *</code> which points to the first character of the array, just as <code>char *p</code> above points to the first character of the array <code>""world""</code>.</p>

<p>When an expression of type ""array of type"" (here <code>buffer</code>) is used, it always ""decays"" to a pointer to the first element unless</p>

<p><code>1.</code> the expression is used as the operand of <a href=""http://en.wikipedia.org/wiki/Sizeof"" rel=""nofollow noreferrer"">sizeof</a> (in <code>sizeof(buffer)</code>, <code>buffer</code> does not decay to a pointer)</p>

<p><code>2.</code> the expression is used as the operand of <a href=""http://en.wikipedia.org/wiki/Reference_%28computer_science%29"" rel=""nofollow noreferrer"">unary &amp;</a> (in <code>&amp;buffer</code>, <code>buffer</code> does not decay to a pointer)</p>

<p>or</p>

<p><code>3.</code> the expression is a string literal initializer for a character array (in <code>char someBuffer[3] = ""ab""</code>, the string literal <code>""ab""</code>, an array, does not decay to a pointer).</p>

<p>This is laid out in <a href=""http://eli-project.sourceforge.net/c_html/c.html#s6.2.2.1"" rel=""nofollow noreferrer"">section 6.2.2.1 of the standard</a>:</p>

<blockquote>
  <p>729 Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a string literal used to initialize an array, an expression that has type ¡°array of type¡± is converted to an expression with type ¡°pointer to type¡± that points to the initial element of the array object and is not an lvalue.</p>
</blockquote>

<p>As a result, all that you need to do to create a pointer <code>char *pBuffer</code> to the first character in your array is write</p>

<pre><code>char *pBuffer = buffer;
</code></pre>
",4
14190822,14189967,0,"<p>Name of array indicates it's base address, so if you just write buffer, it means address of buffer[0]. If you are using &amp;buffer, you need to take it in char** not in char *.</p>

<p>So,</p>

<pre><code>char* pBuffer = buffer;
</code></pre>

<p>Would be correct as suggested.</p>
",0
14192945,14189967,12,"<ul>
<li><p>The declaration <code>char buffer[9] = ""12345678"";</code> creates an array of <code>9</code> chars.<br>
Here, <code>buffer</code> is the address of its <strong>first <em>element</em></strong> but not of <strong>the array</strong>.   </p></li>
<li><p><code>char*  pBuffer = buffer;</code> is a correct expression as <code>pBuffer</code> is a pointer to char and can address the first element.  </p></li>
<li><p>But the expression <code>char* pBuffer = &amp;buffer</code> is <strong>wrong</strong>, because <code>pBuffer</code> can't address an array. (<em>error in your code, <code>&amp;buffer</code> address of array as explained below</em>)  </p></li>
</ul>

<h2>Difference between <code>buffer</code> and <code>&amp;buffer</code></h2>

<p><code>&amp;buffer</code> means <strong>address of array.</strong> The <em>values</em> of <code>buffer</code> and <code>&amp;buffer</code> are really the same, but <em>semantically</em> both are different. One is an address of a char, while the other is an address of an array of 9 chars.</p>

<pre><code>buffer[9] = ""12345678"";


+----+----+----+---+---+----+----+----+---+----+ 
| '1'| '2' |'3'|'4'|'5'| '6'| '7'|'8' | 0 |  ...........
+----+----+----+---+---+----+----+----+---+---+----+  
 201   202  203 204 205 206  207   208 209 210  211
  ^     ^                                         
  |     |                                         
(buffer) (buffer + 1)                                         
|                                         |
|-----------------------------------------|--------
|201                                      | 210
  ^                                          ^
  |                                          |
(&amp;buffer)                                 (&amp;buffer + 1)     
</code></pre>

<p><sub>I used decimal numbers for address instead of hexadecimal </sub> </p>

<p>Even though the value of <code>buffer</code> is <code>201</code> and the value of <code>&amp;buffer</code> is <code>201</code>, their  <em>meaning</em> is different:</p>

<ul>
<li><code>buffer</code>: first element's address&mdash;its type is <code>char*</code>.</li>
<li><code>&amp;buffer</code>: complete char array's address&mdash;its type is <code>char(*)[9]</code>.        </li>
</ul>

<p>Additionally, to <strong>observe the difference</strong>, add <code>1</code> :   </p>

<p><code>buffer + 1</code> gives <code>202</code>  that is the address of the second array element <code>'2'</code> but<br>
<code>&amp;buffer + 1</code> gives <code>210</code>  which is the address of the next array.</p>

<p>On My System, I write following code:   </p>

<pre><code>int main(){
   char buffer[9] = ""12345678"";
   char (*pBuffer)[9] =  &amp;buffer; 

   printf(""\n %p, %p\n"",buffer, buffer+1);
   printf(""\n %p, %p\n"",(&amp;buffer), (&amp;buffer+1));
}  
</code></pre>

<p>And the output is as below:   </p>

<pre><code>0xbfdc0343, 0xbfdc0344

0xbfdc0343, 0xbfdc034c
</code></pre>

<p><sub><strong>[ANSWER]</strong></sub>   </p>

<p>That's <strong>the reason Error is</strong>:  </p>

<blockquote>
  <p>error: cannot convert 'char (<em>)[9]' to 'char</em>' in initialization  </p>
</blockquote>

<p>You are trying to assign <code>'char (*)[9]'</code> type value to <code>char*</code>.     </p>

<ul>
<li><code>char (*ptr2)[9];</code>  Here <code>ptr2 is pointer to an array of 9 chars</code>, And this time<br>
<code>ptr2=&amp;buffer</code> is a valid expression. </li>
</ul>

<p><strong>How to correct your code?</strong> </p>

<p>As in Nate Chandler's answer:    </p>

<pre><code>char buffer[9] = ""12345678"";
char* pBuffer =   buffer;   
</code></pre>

<p>or another approach,</p>

<pre><code>char buffer[9] = ""12345678"";
char (*pBuffer)[9] =  &amp;buffer;       
</code></pre>

<p>Which you choose depends on what you need.</p>
",0
17857815,17857535,1,"<p>Writing <code>processName</code> to the stream fails because the <code>eof</code> bit is set. Clear the stream's error state flags with <code>sysSettings.clear()</code> before writing:</p>

<pre><code>while(!((sysSettings.getline(oneLine,sizeof(oneLine))).eof()))
{
        if(!strcmp(oneLine,processName))
            return;
}
sysSettings.clear();
sysSettings&lt;&lt;processName;
</code></pre>
",1
17857862,17857535,1,"<p>Never use eof() to control a loop. And what's with all the C strings?</p>

<pre><code>void pushSysSet(const char* processName)
{
    fstream sysSettings(""p_appmanager/src/sys_settings.txt"", ios::in | ios::out | ios::app);
    if(!sysSettings)
    {
        if(debugFlag)
        {
            cout&lt;&lt;currentTime()&lt;&lt;""::""&lt;&lt;""Unable to open sys_settings file""&lt;&lt;strerror(errno)&lt;&lt;endl;
            cout.flush();
        }
        return;
    }
    std::string oneLine;
    while(std::getline(sysSettings, oneLine))
    {
        if(oneLine == processName)
            return;
    }
    sysSettings.clear();
    sysSettings &lt;&lt; processName &lt;&lt; '\n';
}
</code></pre>

<p>I cleaned up the code a bit. No point in doing separate flush and close before going out of scope if you're not checking the result; that's part of the destructor anyway. Using std::string to get rid of possible buffer overflows or truncated names, and generally to make things nicer. Cleaned up the condition of the while loop.</p>

<p>I also added a newline after the <code>processName</code> output: since your reading code apparently expects that thing to be on a line by itself, it's only correct to make sure of that in the writing code.</p>

<p>Finally, as Casey pointed out, once you've read the entire file the stream is in an error state and won't respond to your write, so clear the state first.</p>
",2
14202923,14202889,1,"<p>At a first glance, I see two errors:</p>

<ul>
<li>a circular include which isn't necessary (<code>Tile.h</code> doesn't need to include <code>TileGrass.h</code> - you can just re-organize the file to remove the include)</li>
<li><code>TileGrass tileGrass = TileGrass(0);</code> is a definition, and it's in a header, so you'll get a multiple definition error if you include the header multiple times. If you want a global (<strong>rethink that</strong>), you have to use <code>extern</code>.</li>
</ul>
",5
14211058,14211005,2,"<p><code>INT32_MAX</code> is defined in <code>&lt;stdint.h&gt;</code>. You need:</p>

<pre><code>#include &lt;stdint.h&gt;
</code></pre>

<p>in the offending source file.</p>
",2
17404774,17378961,6,"<p>My comments were probably not very clear. So here is a C++11 ""solution"" relying on template meta programming : (Possibly not the nicest way of doing this though)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;utility&gt;


// Type list stuff: (perhaps use an existing library here)
class EmptyType {};

template&lt;class T1, class T2 = EmptyType&gt;
struct TypeList
{
    typedef T1 Head;
    typedef T2 Tail;
};

template&lt;class... Etc&gt;
struct MakeTypeList;

template &lt;class Head&gt;
struct MakeTypeList&lt;Head&gt;
{
    typedef TypeList&lt;Head&gt; Type;
};

template &lt;class Head, class... Etc&gt;
struct MakeTypeList&lt;Head, Etc...&gt;
{
    typedef TypeList&lt;Head, typename MakeTypeList&lt;Etc...&gt;::Type &gt; Type;
};

// Calling produce
template&lt;class TList, class BaseType&gt;
struct Producer;

template&lt;class BaseType&gt;
struct Producer&lt;EmptyType, BaseType&gt;
{
    template&lt;class... Args&gt;
    static BaseType* Produce(Args... args)
    {
        return nullptr;
    }
};

template&lt;class Head, class Tail, class BaseType&gt;
struct Producer&lt;TypeList&lt;Head, Tail&gt;, BaseType&gt;
{
    template&lt;class... Args&gt;
    static BaseType* Produce(Args... args)
    {
        BaseType* b = Head::Produce(args...);
        if(b != nullptr)
            return b;
        return Producer&lt;Tail, BaseType&gt;::Produce(args...);
    }
};

// Generic AbstractFactory:
template&lt;class BaseType, class Types&gt;
struct AbstractFactory {
    typedef Producer&lt;Types, BaseType&gt; ProducerType;

    template&lt;class... Args&gt;
    static BaseType* Produce(Args... args)
    {
        return ProducerType::Produce(args...);
    }
};

class Base {}; // Example base class you had

struct Derived0 : public Base { // Example derived class you had
    Derived0() = default;
    static Base* Produce(int value)
    {
        if(value == 0)
            return new Derived0();
        return nullptr;
    }
};

struct Derived1 : public Base { // Another example class
    Derived1() = default;
    static Base* Produce(int value)
    {
        if(value == 1)
            return new Derived1();
        return nullptr;
    }
};

int main()
{
    // This will be our abstract factory type:
    typedef AbstractFactory&lt;Base, MakeTypeList&lt;Derived0, Derived1&gt;::Type&gt; Factory;
    Base* b1 = Factory::Produce(1);
    Base* b0 = Factory::Produce(0);
    Base* b2 = Factory::Produce(2);
    // As expected b2 is nullptr
    std::cout &lt;&lt; b0 &lt;&lt; "", "" &lt;&lt; b1 &lt;&lt; "", "" &lt;&lt; b2 &lt;&lt; std::endl;
}
</code></pre>

<p>Advantages:</p>

<ol>
<li>No (additional) run-time overhead as you would have with the function pointers.
Works for any base type, and for any number of derived types. You still end up calling the functions of course.</li>
<li>Thanks to variadic templates this works with any number of arguments (giving an incorrect number of arguments will produce a compile-time error message).</li>
<li>Explicit registering of the produce member functions
    is not required.</li>
</ol>

<p>Disadvantages:</p>

<ol>
<li>All of your derived types must be available when you declare the
Factory type. (You must know what the possible derived types are and they must be complete.)</li>
<li>The produce member functions for the derived types must be public.</li>
<li>Can make compilation slower. (As always the case when relying on template metaprogramming)</li>
</ol>

<p>In the end, using the prototype design pattern might turn out better. I don't know since I haven't tried using my code.</p>

<p>I'd like to state some additional things (after further discussion on the chat):</p>

<ul>
<li>Each factory can only return a single object. This seems strange, as the users decide whether they will take the input to create their object or not. I would for that reason suggest your factory can return a collection of objects instead.</li>
<li>Be careful not to overcomplicate things. You want a plugin system, but I don't think you really want factories. I would propose you simply make users register their classes (in their shared object), and that you simply pass the arguments to the classes' <code>Produce</code> (static) member functions. You store the objects if and only if they're not the nullptr. </li>
</ul>
",9
17409442,17378961,10,"<p>If I understand this correctly, we want a factory function that can select which derived class to instantiate based on constructor inputs.  This is the most generic solution that I could come up with so far.  You specify mapping inputs to organize factory functions, and then you can specify constructor inputs upon factory invocation.  I hate to say that the code explains more than I could in words, however I think the example implementations of <code>FactoryGen.h</code> in <code>Base.h</code> and <code>Derived.h</code> are clear enough with the help of comments.  I can provide more details if necessary.</p>

<p>FactoryGen.h</p>

<pre><code>#pragma once

#include &lt;map&gt;
#include &lt;tuple&gt;
#include &lt;typeinfo&gt;

//C++11 typename aliasing, doesn't work in visual studio though...
/*
template&lt;typename Base&gt;
using FactoryGen&lt;Base&gt; = FactoryGen&lt;Base,void&gt;;
*/

//Assign unique ids to all classes within this map.  Better than typeid(class).hash_code() since there is no computation during run-time.
size_t __CLASS_UID = 0;

template&lt;typename T&gt;
inline size_t __GET_CLASS_UID(){
    static const size_t id = __CLASS_UID++;
    return id;
}

//These are the common code snippets from the factories and their specializations. 
template&lt;typename Base&gt;
struct FactoryGenCommon{
    typedef std::pair&lt;void*,size_t&gt; Factory; //A factory is a function pointer and its unique type identifier

    //Generates the function pointer type so that I don't have stupid looking typedefs everywhere
    template&lt;typename... InArgs&gt;
    struct FPInfo{ //stands for ""Function Pointer Information""
        typedef Base* (*Type)(InArgs...);
    };

    //Check to see if a Factory is not null and matches it's signature (helps make sure a factory actually takes the specified inputs)
    template&lt;typename... InArgs&gt;
    static bool isValid(const Factory&amp; factory){
        auto maker = factory.first;
        if(maker==nullptr) return false;

        //we have to check if the Factory will take those inArgs
        auto type = factory.second;
        auto intype = __GET_CLASS_UID&lt;FPInfo&lt;InArgs...&gt;&gt;();
        if(intype != type) return false;

        return true;
    }
};

//template inputs are the Base type for which the factory returns, and the Args... that will determine how the function pointers are indexed.
template&lt;typename Base, typename... Args&gt; 
struct FactoryGen : FactoryGenCommon&lt;Base&gt;{
    typedef std::tuple&lt;Args...&gt; Tuple;
    typedef std::map&lt;Tuple,Factory&gt; Map; //the Args... are keys to a map of function pointers

    inline static Map&amp; get(){ 
        static Map factoryMap;
        return factoryMap; 
    }

    template&lt;typename... InArgs&gt;
    static void add(void* factory, const Args&amp;... args){
        Tuple selTuple = std::make_tuple(args...); //selTuple means Selecting Tuple.  This Tuple is the key to the map that gives us a function pointer
        get()[selTuple] = Factory(factory,__GET_CLASS_UID&lt;FPInfo&lt;InArgs...&gt;&gt;());
    }

    template&lt;typename... InArgs&gt;
    static Base* make(const Args&amp;... args, const InArgs&amp;... inArgs){
        Factory factory = get()[std::make_tuple(args...)];
        if(!isValid&lt;InArgs...&gt;(factory)) return nullptr;
        return ((FPInfo&lt;InArgs...&gt;::Type)factory.first) (inArgs...);
    }
};

//Specialize for factories with no selection mapping
template&lt;typename Base&gt;
struct FactoryGen&lt;Base,void&gt; : FactoryGenCommon&lt;Base&gt;{
    inline static Factory&amp; get(){
        static Factory factory;
        return factory; 
    }

    template&lt;typename... InArgs&gt;
    static void add(void* factory){
        get() = Factory(factory,__GET_CLASS_UID&lt;FPInfo&lt;InArgs...&gt;&gt;());
    }

    template&lt;typename... InArgs&gt;
    static Base* make(const InArgs&amp;... inArgs){
        Factory factory = get();
        if(!isValid&lt;InArgs...&gt;(factory)) return nullptr;
        return ((FPInfo&lt;InArgs...&gt;::Type)factory.first) (inArgs...);
    }
};

//this calls the function ""initialize()"" function to register each class ONCE with the respective factory (even if a class tries to initialize multiple times)
//this step can probably be circumvented, but I'm not totally sure how
template &lt;class T&gt;
class RegisterInit {
  int&amp; count(void) { static int x = 0; return x; } //counts the number of callers per derived
public:
  RegisterInit(void) { 
    if ((count())++ == 0) { //only initialize on the first caller of that class T
      T::initialize();
    }
  }
};
</code></pre>

<p>Base.h</p>

<pre><code>#pragma once

#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include ""Procedure.h""
#include ""FactoryGen.h""

class Base {
public:
    static Base* makeBase(){ return new Base; }
    static void initialize(){ FactoryGen&lt;Base,void&gt;::add(Base::makeBase); } //we want this to be the default mapping, specify that it takes void inputs

    virtual void speak(){ std::cout &lt;&lt; ""Base"" &lt;&lt; std::endl; }
};

RegisterInit&lt;Base&gt; __Base; //calls initialize for Base
</code></pre>

<p>Derived.h</p>

<pre><code>#pragma once

#include ""Base.h""

class Derived0 : public Base {
private:
    std::string speakStr;
public:
    Derived0(std::string sayThis){ speakStr=sayThis; }

    static Base* make(std::string sayThis){ return new Derived0(sayThis); }
    static void initialize(){ FactoryGen&lt;Base,int&gt;::add&lt;std::string&gt;(Derived0::make,0); } //we map to this subclass via int with 0, but specify that it takes a string input

    virtual void speak(){ std::cout &lt;&lt; speakStr &lt;&lt; std::endl; }
};

RegisterInit&lt;Derived0&gt; __d0init; //calls initialize() for Derived0

class Derived1 : public Base {
private:
    std::string speakStr;
public:
    Derived1(std::string sayThis){ speakStr=sayThis; }

    static Base* make(std::string sayThat){ return new Derived0(sayThat); }
    static void initialize(){ FactoryGen&lt;Base,int&gt;::add&lt;std::string&gt;(Derived0::make,1); } //we map to this subclass via int with 1, but specify that it takes a string input

    virtual void speak(){ std::cout &lt;&lt; speakStr &lt;&lt; std::endl; }
};

RegisterInit&lt;Derived1&gt; __d1init; //calls initialize() for Derived1
</code></pre>

<p>Main.cpp</p>

<pre><code>#include &lt;windows.h&gt; //for Sleep()
#include ""Base.h""
#include ""Derived.h""

using namespace std;

int main(){
    Base* b = FactoryGen&lt;Base,void&gt;::make(); //no mapping, no inputs
    Base* d0 = FactoryGen&lt;Base,int&gt;::make&lt;string&gt;(0,""Derived0""); //int mapping, string input
    Base* d1 = FactoryGen&lt;Base,int&gt;::make&lt;string&gt;(1,""I am Derived1""); //int mapping, string input

    b-&gt;speak();
    d0-&gt;speak();
    d1-&gt;speak();

    cout &lt;&lt; ""Size of Base: "" &lt;&lt; sizeof(Base) &lt;&lt; endl;
    cout &lt;&lt; ""Size of Derived0: "" &lt;&lt; sizeof(Derived0) &lt;&lt; endl;

    Sleep(3000); //Windows &amp; Visual Studio, sry
}
</code></pre>

<p>I think this is a pretty flexible/extensible factory library.  While the code for it is not very intuitive, I think using it is fairly simple.  Of course, my view is biased seeing as  I'm the one that wrote it, so please let me know if it is the contrary.</p>

<p><strong>EDIT :</strong> Cleaned up the FactoryGen.h file.  This is probably my last update, however this has been a fun exercise.</p>
",7
17408318,17378961,4,"<p><strong>Update</strong>: This answer made the assumption that some kind of <a href=""https://en.wikipedia.org/wiki/File_format#Magic_number"" rel=""nofollow"">magic</a> existed that could be read and passed to the factory, but that's apparently not the case. I'm leaving the answer here because a) I may update it, and b) I like it anyway.</p>

<hr>

<p>Not hugely different from your own answer, not using C++11 techniques (I've not had a chance to update it yet, or have it return a smart pointer, etc), and not entirely my own work, but this is the factory class I use.  Importantly (IMHO) it doesn't call each possible class's methods to find the one that matches - it does this via the map.</p>

<pre><code>#include &lt;map&gt;
// extraneous code has been removed, such as empty constructors, ...
template &lt;typename _Key, typename _Base, typename _Pred = std::less&lt;_Key&gt; &gt;
class Factory {
public:
    typedef _Base* (*CreatorFunction) (void);
    typedef std::map&lt;_Key, CreatorFunction, _Pred&gt; _mapFactory;

    // called statically by all classes that can be created
    static _Key Register(_Key idKey, CreatorFunction classCreator) {
        get_mapFactory()-&gt;insert(std::pair&lt;_Key, CreatorFunction&gt;(idKey, classCreator));
        return idKey;
    }

    // Tries to create instance based on the key
    static _Base* Create(_Key idKey) {
        _mapFactory::iterator it = get_mapFactory()-&gt;find(idKey);
        if (it != get_mapFactory()-&gt;end()) {
            if (it-&gt;second) {
                return it-&gt;second();
            }
        }
        return 0;
    }

protected:
    static _mapFactory * get_mapFactory() {
        static _mapFactory m_sMapFactory;
        return &amp;m_sMapFactory;
    }
};
</code></pre>

<p>To use this you just declare the base-type, and for each class you register it as a static. Note that when you register, the key is returned, so I tend to add this as a member of the class, but it's not necessary, just neat :) ...</p>

<pre><code>// shape.h
// extraneous code has been removed, such as empty constructors, ...
// we also don't technically need the id() method, but it could be handy
// if at a later point you wish to query the type.
class Shape {
public:
    virtual std::string id() const = 0;
};
typedef Factory&lt;std::string, Shape&gt; TShapeFactory;
</code></pre>

<p>Now we can create a new derived class, and register it as creatable by <code>TShapeFactory</code>...</p>

<pre><code>// cube.h
// extraneous code has been removed, such as empty constructors, ...
class Cube : public Shape {
protected:
    static const std::string _id;
public:
    static Shape* Create() {return new Cube;}
    virtual std::string id() const {return _id;};
};

// cube.cpp
const std::string Cube::_id = TShapeFactory::Register(""cube"", Cube::Create);
</code></pre>

<p>Then we can create a new item based on, in this case, a string:</p>

<pre><code>Shape* a_cube = TShapeFactory::Create(""cube"");
Shape* a_triangle = TShapeFactory::Create(""triangle"");
// a_triangle is a null pointer, as we've not registered a ""triangle""
</code></pre>

<p>The advantage of this method is that if you create a new derived, factory-generatable class, you don't need to change any other code, providing you can see the factory class and derive from the base:</p>

<pre><code>// sphere.h
// extraneous code has been removed, such as empty constructors, ...
class Sphere : public Shape {
protected:
    static const std::string _id;
public:
    static Shape* Create() {return new Sphere;}
    virtual std::string id() const {return _id;};
};

// sphere.cpp
const std::string Sphere::_id = TShapeFactory::Register(""sphere"", Sphere::Create);
</code></pre>

<p>Possible improvements that I'll leave to the reader include adding things like: <code>typedef _Base base_class</code> to <code>Factory</code>, so that when you've declared your custom factory, you can make your classes derive from <code>TShapeFactory::base_class</code>, and so on.  The Factory should probably also check if a key already exists, but again... it's left as an exercise.</p>
",6
18101237,18101139,1,"<p>Your <code>operator T()</code> returns a T list initialized with <code>x,y,z</code>.  This means that the overload of <code>DoSomething</code> is ambiguous between the one that takes 2 vectors or the one that takes a vector and <code>double*</code>.  </p>

<p>So if you cast your second argument at the call site to what type it is that you want you will tell the compiler explicitly what overload to take.</p>

<p>The <code>std::enable_if</code> basically removes the overload that is not constructible using three <code>double</code>s, meaning it removes the ambiguity, and therefore it compiles. </p>

<p>Your vector is constructible with three <code>double</code>s.</p>

<pre><code>Vector(double x, double y, double z)
</code></pre>
",5
18101300,18101139,1,"<p>Without <code>enable_if</code>, your conversion operator exists for every type. You would get an error if attempting to instantiate the conversion operator for types that cannot be constructed from <code>{x, y, z}</code>, but that doesn't change the fact that the operator exists. Because it exists, the type is considered convertible to <code>double *</code>, and overload resolution cannot pick a best match.</p>
",0
14741086,14740989,2,"<p>Try the following:</p>

<pre><code>#include &lt;iostream&gt;

int main() {
   char input;

   std::cin &gt;&gt; input;

   if (input &gt;= 0 &amp;&amp; input &lt;= 127) {
      for (int i = 0; i &lt;= n; i++) std::cout &lt;&lt; i % 10;
   }
}
</code></pre>
",6
17769346,17769322,1,"<p>Its not a part of some ""magic syntax"". Its just a <strong>static member</strong> that works as factory for class <strong>Point</strong>. I'll copy example from this link and add explaining comments:</p>

<pre><code>#include &lt;cmath&gt;               // To get std::sin() and std::cos()

class Point {
public:
  static Point rectangular(float x, float y);      // Its a static function that returns Point object
  static Point polar(float radius, float angle);   // Its a static function that returns Point object
  // These static methods are the so-called ""named constructors""
  ...
private:
  Point(float x, float y);     // Rectangular coordinates
  float x_, y_;
};

inline Point::Point(float x, float y)
  : x_(x), y_(y) { }

inline Point Point::rectangular(float x, float y)
{ return Point(x, y); } //Create new Point object and return it by value

inline Point Point::polar(float radius, float angle)
{ return Point(radius*std::cos(angle), radius*std::sin(angle)); } //Create new Point object and return it by value
</code></pre>

<p>So, <code>Point::rectangular</code> and <code>Point::polar</code> is just a factory for class <strong>Point</strong></p>
",3
17769349,17769322,15,"<p>A non-static function is associated with an object of a class.</p>

<p>In this case, the whole point of the function is to <em>create</em> an object of the class. When you call the function, there <em>is</em> no instance of the class with which that function call could be associated.</p>
",0
17769368,17769322,3,"<p>They have to be <code>static</code> methods.</p>

<pre><code>class Point {
public:
  static Point rectangular(float x, float y);      // Rectangular coord's
  static Point polar(float radius, float angle);   // Polar coordinates

  ...
private:
  Point();
  Point(float x, float y);     // Rectangular coordinates
  float x_, y_;
};
</code></pre>

<p>In <em>Named Constructor Idiom</em> you should make constructors <code>private</code> or <code>protected</code>, so you <strong>cannot</strong> have an constructed object in a straight way.</p>

<p>On the other hand, <code>static</code> methods don't need to have objects to call, so they don't need constructors too.</p>

<p>Therefore, you can use <code>static</code> methods to do something such as returning a constructed object.</p>
",0
15835105,15835062,3,"<p>You are reusing <code>x</code> for both your array index and the data:</p>

<pre><code>for( int x = 0; x &lt; sizeOfArray; x++){
    cin &gt;&gt; x;
    examMarks[x] = x;
}
</code></pre>

<p>You need to use a separate variable for the array index:</p>

<pre><code>int x = 0;
for( int idx = 0; idx &lt; sizeOfArray; idx++){
    cin &gt;&gt; x;
    examMarks[idx] = x;
}
</code></pre>
",2
15835126,15835062,1,"<p>Problem is here:</p>

<pre><code>for( int x = 0; x &lt; sizeOfArray; x++){
   cin &gt;&gt; x;
   examMarks[x] = x;
}
</code></pre>

<p>You are using the <code>x</code> as array index, and always accepts <code>x</code> as input value. </p>
",0
15835128,15835062,1,"<pre><code>for( int x = 0; x &lt; sizeOfArray; x++){
    cin &gt;&gt; x;
</code></pre>

<p>You are reading into the loop iterator. It should be</p>

<pre><code>int temp
for( int x = 0; x &lt; sizeOfArray; x++){
    cin &gt;&gt; temp;
    examMarks[x] = temp;
</code></pre>
",0
14744857,14744713,0,"<p>Within the loop below, you are incrementing <code>i</code> several times, are you sure you have so many elements?</p>

<pre><code>while(i != doubleList.end())
{
</code></pre>
",1
14747070,14744713,0,"<p>If <code>s</code> and <code>j</code> are at the same position in the list, you'll erase <code>j</code>, which invalidates <code>s</code>.</p>

<p>You shouldn't need to start <code>j</code> from the beginning every time as you've already compared it against every element in front of <code>s</code>.</p>

<p>I think replacing</p>

<pre><code>j = sphereList.begin();
</code></pre>

<p>with </p>

<pre><code>j = s;
</code></pre>

<p>should be enough.</p>
",0
14783350,14783294,0,"<p>STL containers only store fixed size objects. If yo push BaseClass2 derived class object to <code>std::map&lt;int,BaseClass2&gt;</code>, objects will be sliced to BaseClass2 type.</p>

<p>If you want <code>std::map</code> to store subclasses of BaseClass2, you need to store pointer(smart pointer) in map. </p>

<p>For example:</p>

<pre><code>  struct BaseClass1 {
    virtual void obtain_map(std::map&lt;int, std::unique_ptr&lt;BaseClass2&gt;&gt; &amp;map) = 0;
  }

   struct DerivedClass1 : public BaseClass1 {
   virtual void obtain_map(std::map&lt;int, std::unique_ptr&lt;BaseClass2&gt;&gt; &amp;map)
   {
      // implementation
   }
 }
</code></pre>

<p>Storing smpart pointers has the advances compare to raw poiter because you don't need to  manually delete memories the pointers are pointing to.</p>
",0
14783367,14783294,1,"<p>If you derive your classes like so and use pointer as the second <code>map</code> template parameter (a smart pointer like <code>std::unique_ptr</code> will save you some memory management trouble):</p>

<pre><code>struct BaseClass1 {
    virtual void obtain_map(std::map&lt;int, std::unique_ptr&lt;BaseClass2&gt;&gt; &amp;map) = 0;
};
struct DerivedClass1 : public BaseClass1 {
    virtual void obtain_map(std::map&lt;int, std::unique_ptr&lt;BaseClass2&gt;&gt; &amp;map) override
    {
    }
};
</code></pre>

<p>You can still pass in <code>maps</code> with derived versions of BaseClass2 as the second type:</p>

<pre><code>struct DerivedClass2 : public BaseClass2;
// ...

std::map&lt;int, std::unique&lt;DerivedClass2&gt;&gt; mdc2;
DerivedClass1 dc1;
dc1.obtain_map(mdc2);
</code></pre>
",2
14841383,14841318,1,"<p>Something like this, perhaps:</p>

<pre><code>    CACHE *L2 = 0;
    CACHE *L1 = 0;


    if (L2_size)
    {
        L2 = new CACHE(L2_size, blocksize, L2_assoc, inclusion, 0);
    }
    L1 = new CACHE(L1_size, blocksize, L1_assoc, inclusion, L2);  
</code></pre>

<p>I'm sure there are other possibilities. </p>
",2
14841386,14841318,0,"<p>You could use a container such as <code>std::list</code> or <code>std::vector</code> before your <code>if</code> statement and just push_back as many CACHE objects as you need.</p>

<p>Example:</p>

<pre><code>int main()
    {
       std::list&lt;CACHE&gt; caches;
       if (L2_size == 0)
       {
          caches.push_front(CACHE(L1_size, blocksize, L1_assoc, inclusion, 0));
       }
       else
       {
          caches.push_front(CACHE(L2_size, blocksize, L2_assoc, inclusion, 0);
          caches.push_front(CACHE(L1_size, blocksize, L1_assoc, inclusion, &amp;(*caches.begin());
       }
    }
</code></pre>

<p>Whichever method you use, the idea is to create the stack variable (the <code>list</code>, <code>pointer</code>, or whatever) before your <code>if</code> statement, so that it stays in scope.</p>
",5
14844524,14844508,1,"<p>Most likely you can do this all with vectors.</p>

<pre><code>#include &lt;vector&gt;

std::vector&lt;int&gt; function_name(const std::vector&lt;int&gt;&amp; A, const std::vector&lt;int&gt;&amp; B);
</code></pre>
",0
15539796,15539733,1,"<p>x is a pointer to an int. You have allocated an array of ints, which is a single int long. Therefore x[0] is an int and *x is an int. However, *x[0] means you are saying that x[0] is a pointer which you are dereferencing. However, it isn't a pointer, it is an int. That is why there is an error.</p>
",0
15539805,15539733,1,"<p>What you are actually doing with that line of code is similar to:</p>

<pre><code>cout&lt;&lt;**x;
</code></pre>

<p>Because using <code>x[0]</code> will dereference the <code>0th</code> element of <code>x</code>.</p>

<p>As you can see by your definition of <code>x</code>, <code>x</code> is just a pointer, not a pointer to a pointer, so dereferencing it twice will not work since you are trying to dereference a variable.</p>

<p>What the line:</p>

<pre><code>x=new int[1];
</code></pre>

<p>is actually doing is just saying ""assign an array of ints, size 1 to this pointer"", which will just make <code>x</code> point to a block of memory big enough to store 1 int.</p>
",0
15539846,15539733,1,"<p>The meaning of the array:</p>

<pre><code>x[0]
</code></pre>

<p>is equivalent to *(x+0);</p>

<p>As you know array is array is nothing but pointer in its root.</p>

<p>So any array that has x[a] or x[a][b] can be expanded as </p>

<pre><code>*(x+a) or *(*(x+a)+b)
</code></pre>

<p>Based on this , i hope you found your answer.</p>
",1
15531304,15531258,2,"<p>Probably not, because it always examines all the elements of the vector even if the first two elements are different. Personally I'd just write a for loop.</p>
",0
15531336,15531258,9,"<p>In c++11 (or <a href=""http://www.boost.org/doc/libs/1_50_0/libs/algorithm/doc/html/algorithm/CXX11.html"">Boost Algorithm</a>)</p>

<pre><code>std::all_of(vecSamples.begin()+1,vecSamples.end(),
          [&amp;](const T &amp; r) {return r==vecSamples.front();})
</code></pre>
",2
15531504,15531258,4,"<p>As @john correctly points out, your solution iterates over the entire container even if the first two elements are different, which is quite a waste.</p>

<p>How about a purely no-boost no c++11 required solution?</p>

<pre><code>bool allAreEqual = 
  find_if(vecSamples.begin() + 1, 
    vecSamples.end(), 
    bind1st(not_equal_to&lt;int&gt;(), vecSamples.front())) == vecSamples.end();
</code></pre>

<p>Stops on first non-equal element found.
Just make sure your vecSamples is non-empty before running this.</p>
",0
15822202,15822144,4,"<p>To give the child process a new console you need to set the <code>CREATE_NEW_CONSOLE</code> flag in the <code>dwCreationFlags</code> argument of your call to <code>CreateProcess</code>. Documentation here: <a href=""http://msdn.microsoft.com/en-gb/library/windows/desktop/ms682425(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-gb/library/windows/desktop/ms682425(v=vs.85).aspx</a></p>
",1
14860572,14860340,5,"<p>Are you trying to copy every line?</p>

<pre><code>while(std::getline(inFile, temp)) {
  outFile &lt;&lt; temp &lt;&lt; ""\n"";
}
</code></pre>

<p>Are you trying to copy every non-blank line?</p>

<pre><code>while(std::getline(inFile, temp)) {
  if(temp != """")
    outFile &lt;&lt; temp &lt;&lt; ""\n"";
}
</code></pre>

<p>Are you trying to copy every 2nd non-blank line? </p>

<pre><code>int count = 0;
while(std::getline(inFile, temp)) {
  if(temp == """")
    continue;
  count++;
  if(count % 2)
    outFile &lt;&lt; temp &lt;&lt; ""\n"";
}
</code></pre>

<p>Are you simply trying to copy the entire file?</p>

<pre><code>outFile &lt;&lt; inFile.rdbuf();
</code></pre>
",0
14865468,14860340,0,"<p>You should use a mode to open files : see <a href=""http://www.cplusplus.com/reference/ios/ios_base/openmode/"" rel=""nofollow"">std::ios_base::openmode</a><br />
And don't forget to close the streams you open !<br />
You can even try catch your code to understand the problem if an exception occurred.</p>

<pre><code>#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;

using namespace std;

int main() 
{
    try {
        fstream inFile;
        fstream outFile;

        // open to read
        inFile.open(""ZRMK Matched - 010513.txt"", ios_base::in); 
        if (!inFile.is_open()) {
            cerr &lt;&lt; ""inFile is not open ! "" &lt;&lt; endl;
            return EXIT_FAILURE;
        }

        // Open to append
        outFile.open(""second.txt"", ios_base::app); 
        if (!inFile.is_open()) {
            cerr &lt;&lt; ""inFile is not open ! "" &lt;&lt; endl;
            return EXIT_FAILURE;
        }

        string line;
        while(getline(inFile, line)) {  
            if (!line.empty()) {
                outFile &lt;&lt; line &lt;&lt; endl;
            }
        }

        if (outFile.is_open()) {
            outFile.close(); // Close the stream if it's open
        }
        if (inFile.is_open()) {
            inFile.close(); // Close the stream if open
        }

        cout &lt;&lt; ""Data Transfer Finished"" &lt;&lt; endl;
        return EXIT_SUCCESS;

    } catch (const exception&amp; e) {
        cerr &lt;&lt; ""Exception occurred : "" &lt;&lt; e.what() &lt;&lt; endl;
    }

    return EXIT_FAILURE;
}
</code></pre>
",0
14170284,14170263,2,"<blockquote>
  <p>is it not possible to do this with the insert function?</p>
</blockquote>

<p>That's right, you can't do this with a single call to <code>insert()</code> since <code>std::string</code> does not have an <code>insert()</code> function with these semantics.</p>
",0
14170357,14170263,1,"<p>What you want to do is find the position of <code>a</code> by using <a href=""http://en.cppreference.com/w/cpp/string/basic_string/find"" rel=""nofollow"">std::string::find</a> then call <a href=""http://en.cppreference.com/w/cpp/string/basic_string/insert"" rel=""nofollow"">std::string::insert</a> to insert string to the right position. For example:</p>

<p>C++11</p>

<pre><code> auto pos = x.find(""a""); 
 x.insert(pos, ""app""); 
</code></pre>

<p>C++03:</p>

<pre><code>  std::string b(x);
  int n = 0;
  for(std::string::iterator iter = x.begin(); iter!=x.end(); ++iter)
  {
    if ((*iter) == 'a')
    {
      int pos = rep.size()* n + distance(x.begin(), iter);
      cout &lt;&lt; distance(x.begin(), iter) &lt;&lt; "" "" &lt;&lt; rep.size() &lt;&lt; endl;
      b.insert(pos,""app"");
      n++;
    }    
  }
</code></pre>

<p>Now string <code>b</code> is what you are after.</p>
",13
14170623,14170263,2,"<p>Following <a href=""https://stackoverflow.com/questions/14170263/is-there-a-way-to-put-strings-in-the-string-insert-function#comment19634577_14170357"">this comment</a>, here is how you can do this in a (non-infinite) loop:</p>

<pre><code>void insert_after_each(std::string&amp; s, const std::string&amp; target, const std::string&amp; to_insert)
{
    for (std::string::size_type i = s.find(target);
        i != std::string::npos;
        i = s.find(target, i + target.size() + to_insert.size()))
    {
        s.insert(i + target.size(), to_insert);
    }
}
</code></pre>

<p>This inserts the text after (what I call) the <code>target</code> string and skips past the target text (""a"") and the inserted text (""hello"") in each iteration.</p>

<h2>Sample usage:</h2>

<pre><code>std::string s = ""A cat sat on a mat"";
insert_after_each(s, ""a"", ""hello"");
assert(s == ""A cahellot sahellot on ahello mahellot"");
</code></pre>
",3
14183279,14183249,3,"<p>Your forgot to include <code>random</code>, the header defining the mt19937 (""Mersenne Twister"") generator.</p>

<p>Here is a complete example:</p>

<pre><code>edd@max:/tmp$ cat cxx12_random.cpp 

// use 'g++ -std=c++0x -o cxx12_random cxx12_random.cpp'

#include &lt;random&gt;
#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

  std::mt19937 engine(42);
  std::normal_distribution&lt;&gt; normal(0.0, 1.0);

  for (int i=0; i&lt;5; i++) {
    std::cout &lt;&lt; normal(engine) &lt;&lt; std::endl;
  }
}
edd@max:/tmp$ g++ -std=c++0x -o cxx12_random cxx12_random.cpp
edd@max:/tmp$ ./cxx12_random 
-0.550234
0.515433
0.473861
1.36845
-0.916827
edd@max:/tmp$ 
</code></pre>

<p>Note that I enabled the newer C++ extensions via <code>-std=c++0x</code>. You may have to do the same with your compiler.</p>
",5
14183295,14183249,1,"<p>I think this is only available in c++11. does your compiler support it?</p>
",4
17831854,17831030,1,"<p>Since you inherit <code>base</code> as a private base class, this means that all public members of <code>base</code> (including <code>base::func_1</code>) will be private in derived. The compiler will complain when you declare <code>derived::func_1</code> as <code>public</code>.</p>

<p>If you need <code>derived::func_1</code> as public, then you should inherit <code>base</code> publicly. If you do not need it to be public, then you should declare <code>derived::func_1</code> as being private.</p>
",2
17831353,17831030,1,"<p><code>private</code> indicates that names and members are not accessible from outside. The conversation to a private base class is one occourrence. You can simply wrap this conversation into a member function to let it work:</p>

<pre><code>class derived
  : private base {
public:
    // other stuff

    base* get_base() {
        return this;
    }
};

derived* d = new derived;
base* b = d-&gt;get_base();
b-&gt;func_t();
</code></pre>
",0
14214179,14213941,0,"<p>If you have an class with a pure virtual function (i.e. abstract) you MUST create a second class that implements that virtual function. Otherwise you will never be able to use that class.</p>

<p>In your code you implemented a function alright, but it's not virtual because it is not inside of a class. It needs to be declared and defined as part of a sub-class off of non_sense in order to work. Please keep in mind that only classes can have virtual functions. </p>
",0
14214245,14213941,1,"<p>Odd as it might seem, pure virtual methods <em>can</em> have an implementation in C++. That does not change the fact that the method is pure virtual and the class containing it is abstract.</p>

<p>If you want the class <code>non_sense</code> to be abstact for all types except <code>int</code>, you will have to provide a specialisation for the entire class, not just for the pure virtual members:</p>

<pre><code>template &lt;class T&gt;
class non_sense {
public:
    virtual void nonsense_func() = 0;
};

template &lt;&gt;
class non_sense&lt;int&gt; {
public:
    virtual void nonsense_func()
    {
        std::cout &lt;&lt; ""no_sense&lt;int&gt;::nonsense_func"" &lt;&lt; std::endl;
    }
};
</code></pre>

<p>With a larger class, inheritance would probably be easier, because then the derived class can inherit the other members from <code>non_sense</code>, instead of having to duplicate the entire class (as you need to do when creating a specialisation).</p>
",0
14213972,14213941,3,"<p>non_sense is an abstract class, so it can never be instantiated into an object.</p>

<p>This compiles and runs, however: </p>

<pre><code>#include &lt;iostream&gt;

template &lt;class T&gt;
class non_sense {
public:
    virtual void nonsesnse_func();
};

// Specialize the method
template&lt;&gt;
void non_sense&lt;int&gt;::nonsesnse_func(){
    std::cout &lt;&lt; ""no_sense&lt;int&gt;::nonsense_func"" &lt;&lt; std::endl;
}


int main(){
    non_sense&lt;int&gt; xx;

    xx.nonsesnse_func();

    return 0;
}
</code></pre>

<p>And here's code showing how to make this run with a pure abstract class  (I've renamed nosnsnsense to nonsense, it's easier to type ;) :</p>

<pre><code>#include &lt;iostream&gt;

template &lt;class T&gt;
class non_sense {
public:
    virtual void nonsense_func() = 0;
};

template&lt;class T&gt; 
class non_sense_concrete : public non_sense&lt;T&gt; {

    public: 
        void nonsense_func() {
            std::cout &lt;&lt; ""non_sense_concrete&lt;T&gt; generic code"" &lt;&lt; std::endl;
        }

};

// Specialize the concrete class
template&lt;&gt;
void non_sense_concrete&lt;int&gt;::nonsense_func(){
    std::cout &lt;&lt; ""no_sense&lt;int&gt;::nonsense_func"" &lt;&lt; std::endl;
}


int main(){

    non_sense_concrete&lt;double&gt; objectGeneric;
    objectGeneric.nonsense_func(); 

    non_sense_concrete&lt;int&gt; objectInt;
    objectInt.nonsense_func();


    return 0;
}
</code></pre>
",0
14777996,14777786,1,"<p>I would opt for a fourth option, make Graphics a namespace, not a class.</p>

<p>It doesn't sound like a Graphics is a data type, just a collection of functions.  That's exactly what namespaces are for.</p>
",4
14778090,14777786,1,"<p>I have trouble figuring out what a ""Graphics"" object is. An object in software is analogous to an object in real life, so what would a Graphics object represent?</p>

<p>The way I usually do it is not very different from a standard UI application: I have a Window class that can be instantiated multiple times and a MainWindow class that inherits from Window and is only instantiated once. In that MainWindow class I have all the graphics resources that will be used throughout execution (e.g. the Direct3D device object).</p>
",3
14778489,14777786,2,"<p>Well, I think that a ""graphics"" class can very well have a state, like, for example, a canvas it is drawing on. Therefore, making it a class is good; by creating a class you can make the same set of functions applicable to different types of ""canvases"" (opengl, directx, sdl, etc.)</p>

<p>Among your options, I think that option 1 would be the best, but option 2 would be the easiest (and option 3 is horrible, because it makes code dependent on global variables, eliminating reusability of your code - it is the hacker approach :D). </p>

<p>Option 1 is great, because you could write a graphics engine that does intelligent stuff with the things it draws: Assume that you have two objects that share the same textures, but use a different mesh. If programmed appropriately, the graphics engine can call the ""draw mesh"" functions of both objects with the same render settings, in this case the same texture, which speeds speeding up rendering. This is not possible with option 2, which usually groups draw functions for single object together, leading to more changes to the render settings.</p>

<p>Option 2, however, is easier to implement. If you do not need a lot of render speed, I would go for this one, as it is much less work, and leads to a more logical program structure. To realize option 1, like I explained, an object needs to have ""render properties"" or such, that need to be matched by the render engine, and different draw routines for different draw settings... very complicated in comparison to an object-draw function that just uses a central set of drawing functions like a Graphics class.</p>

<p>So if you opt for a ""large project"", choose option 1. For fast results, and if you do not need to draw a lot of things, option 2 is probably better. Usability for options 1 and 2 is similar.</p>

<p><em>PS: Sorry for the late edit, but my grammar was horrible in the previous version</em></p>
",2
15582125,15582044,2,"<p>No, the <em>compiler</em> in general does not care whether there is an <code>int main()</code> in any of your source files or in which source file it is (it <em>does</em> care if you have an invalid <code>main</code>, such as <code>void main()</code>). It most certainly does <em>not</em> search all source files for <code>main</code>.</p>

<p>When you compile a project with three source files:</p>

<p><code>g++ file1.cpp file2.cpp file3.cpp</code></p>

<p>each of them is separately translated into object code, just as if you did</p>

<p><code>g++ -c file1.cpp; g++ -c file1.cpp; g++ -c file1.cpp</code></p>

<p>and <em>then</em> linked together by the linker - you could do that manually by</p>

<p><code>g++ file1.o file2.o file3.o -o myprogram</code>.</p>

<p>Here, it's the linker's job to make sure that there is a <code>main</code> in your program. If there is none, you'll get an <code>undefined reference</code> error, but again, that all happens long after compilation is done.</p>

<p>(Your question becomes ambiguous when you talk about ""including files in a project"". If you're talking about <code>#include</code>, that includes code in one translation unit only. Apart from that, a ""project"" is not a well-defined concept in C++ but an abstraction that your IDE or build system uses - it mostly means that all source files that you placed in the ""project"" will be compiled and then linked together as in my example above.)</p>
",0
15582180,15582044,1,"<p>First of all, understand at a high level how a C++ program is compiled. If you have three files in your project - <code>main.cpp</code>, <code>foo.cpp</code>, and <code>foo.h</code> - you might compile the project like this:</p>

<pre><code>g++ main.cpp foo.cpp
</code></pre>

<p>These two files are compiled separately. The preprocessor and compiler have no concern about the relationship between these files at all. Preprocessing and compiling <code>main.cpp</code> results in an object file and preprocessing and compiling <code>foo.cpp</code> results in another object file.</p>

<p>It is only in the last step, the linking step, that the relationships are considered. The <em>linker</em> will see that <code>main</code> is defined in <code>main.cpp</code> and make that the start point of the program. The <em>linker</em> will see that inside <code>main.cpp</code> there is a call to a function called <code>foo</code> that is defined in <code>foo.cpp</code> and link those together.</p>

<p>So for each file you pass to the compiler, there are two main steps:</p>

<ol>
<li><p>Preprocessing - the file is processed in a very primitive way, resulting in preprocessing tokens. Some of those tokens are preprocessing directives which start with a <code>#</code>, such as <code>#include</code> or <code>#define</code>. These directives are executed. Executing a <code>#include</code> directive pretty much just copies the contents of the named file into the current file.</p>

<p>The preprocessing stage results in what is called a <em>translation unit</em>.</p></li>
<li><p>Compilation - the file is then syntactically and semantically analyzed and translated into an object file. This is where it begins to care what exactly your code is meant to be doing and whether it is correct or not. If you attempt to use a name that hasn't been declared, the compiler will tell you off. However, you can often use a name that hasn't been defined, because they may be defined in another translation unit.</p>

<p>This compilation stage results in the object files.</p></li>
</ol>

<p>After this, the resulting object files are combined by resolving references between them. If the object file corresponding to <code>main.cpp</code> makes use of a function <code>foo</code> that is defined in <code>foo.cpp</code> then they are linked together, and so on.</p>

<hr>

<p>To make it clearer, let's take a look at an example. Let's say we have the following source files:</p>

<ul>
<li><p><strong>main.cpp</strong></p>

<pre><code>#include ""foo.h""

int main() {
  foo();
}
</code></pre></li>
<li><p><strong>foo.h</strong></p>

<pre><code>void foo();
</code></pre></li>
<li><p><strong>foo.cpp</strong></p>

<pre><code>#include &lt;iostream&gt;
#include ""foo.h""

void foo() {
  std::cout &lt;&lt; ""Foo!"" &lt;&lt; std::endl;
}
</code></pre></li>
</ul>

<p>So we pass <code>main.cpp</code> and <code>foo.cpp</code> to the compiler on the command line. Note that we don't pass header files to the compiler. They are only included by the <code>.cpp</code> files. Also note that <code>.cpp</code> files generally don't include other <code>.cpp</code> files. Each <code>.cpp</code> file is compiled separately and linked later.</p>

<p>So after the preprocessing stage, we have two translation units:</p>

<ul>
<li><p><strong>main.cpp</strong> translation unit</p>

<pre><code>void foo();

int main() {
  foo();
}
</code></pre></li>
<li><p><strong>foo.cpp</strong> translation unit</p>

<pre><code>// contents of &lt;iostream&gt; here
void foo();

void foo() {
  std::cout &lt;&lt; ""Foo!"" &lt;&lt; std::endl;
}
</code></pre></li>
</ul>

<p>Notice that the contents of <code>foo.h</code> have been copied into each of the files. We now have two completely valid translation units. The first just defines the <code>main</code> function and calls the declared-only <code>foo</code> function. The second first declares <code>foo</code> and then defines it just after.</p>

<p>There translation units are then compiled to produce object files, often called <code>main.o</code> and <code>foo.o</code>. The linker will then look at certain unresolved references in the files. For instance, it will find the call to <code>foo</code> in <code>main.o</code> and see that it hasn't yet been defined. So it look through the other object files to see if it can find it, and, sure enough, it finds it in <code>foo.o</code>.</p>
",2
15582200,15582044,0,"<p>The compiler does not care about entry point function. The loader does(<a href=""http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html"" rel=""nofollow"">http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html</a>).</p>

<p>Very broadly, (for each source file e.g., .cpp/.c) the compiler's task is to:</p>

<ol>
<li>Pre-process the file (including the headers (e.g., .h, .hpp), and replacing the macros).
At this stage all the header files included in the source file are included (kind of copy-paste) into the source file. All the source files are compiled independently and has nothing to do with what other source files have included/defined.</li>
<li>Parses, Converts the program into an abstract syntax tree </li>
<li>checks for syntax and type errors. </li>
<li>converts the program into intermediate representation (IR).</li>
<li>The backend of the compiler takes the IR and optimizes the program.</li>
<li>After that the backend converts the optimized IT into target-specific machine code (object files).</li>
</ol>

<p>----- After this the job of compiler is done.
Besides other tasks, the linker (<a href=""http://en.wikipedia.org/wiki/Linker_(computing)"" rel=""nofollow"">http://en.wikipedia.org/wiki/Linker_(computing)</a>) only looks for if there is a <code>main</code> function in the program or not. If you dont have a main() function in any of the object files, you'll get linker error. In general, there should be one and only one definition of each function in the set of object files to be linked to generate an executable.</p>

<p>----- The executable is generated by the linker which can be run/executed.</p>

<p>----- To start the execution loader loads the program into main-memory and calls the <strong>main()</strong> function.</p>

<p>To know more just do an objdump on executable you will find a lot of function that gets called before the main.</p>

<p>on linux you can just do </p>

<p><code>objdump -d your_main_program &gt; dump_file</code></p>
",0
14739745,14739680,1,"<p>You can't have ""code"" outside of a function. You need to put the call to <code>new</code> inside a function - you only have one in your code: <code>main</code>, but as long as it is a function that is executed before you access the array, it's fine. </p>

<p>You can also, as the comment says, do <code>int *arr = new int[10];</code> - as long as it's part of the initialization, and not on a separate line.</p>
",1
14739753,14739680,3,"<p>That's invalid for the same reason that this is invalid</p>

<pre><code>#include &lt;iostream&gt;      

using namespace std;

int a = 0;
a = 2;

int main() {

}
</code></pre>

<p>You can't run statements outside of a function, only initializers. As a result, this works:</p>

<pre><code>#include &lt;iostream&gt;      

using namespace std;

int *arr = new int[10];

int main() {
   arr[0] = 1;
   return 0;
}
</code></pre>
",0
14739799,14739680,3,"<p>You don't even have to make the array dynamic, you can just put the array in static memory outside main, and it will live as long as the program.</p>

<pre><code>#include &lt;iostream&gt;     

int arr[10];

int main() {
   arr[0] = 1;
   return 0;
}
</code></pre>
",0
14739805,14739680,1,"<pre><code>int* arr = new int[10];
</code></pre>

<p>or (since you are allocate a constant size array):</p>

<pre><code>int arr[10];
</code></pre>
",0
15510704,15510569,0,"<p>Your code works <a href=""http://ideone.com/1QfgZY"" rel=""nofollow"">perfectly fine</a>:</p>

<p><strong>Input:</strong></p>

<pre><code>This is a test or something
New line
12345
Test 21
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>The number of a's: 1
The number of e's: 5
The number of i's: 4
The number of o's: 2
The number of u's: 0
The number of blanks: 7
The number of tabs: 0
The number of new lines: 3
</code></pre>

<p>I'd recommend checking out the <a href=""http://www.cplusplus.com/reference/locale/tolower/"" rel=""nofollow"">std::tolower</a>() function, for testing upper and lowercase characters at the same time.
Also, to check for <em>any</em> kind of letter, look into the <a href=""http://www.cplusplus.com/reference/locale/isalpha/"" rel=""nofollow"">std::isalpha</a>() <a href=""http://www.cplusplus.com/reference/locale/isdigit/"" rel=""nofollow"">std::isdigit</a>(), <a href=""http://www.cplusplus.com/reference/locale/isspace/"" rel=""nofollow"">std::isspace</a>(), and similar functions.</p>

<p>Further, you could make the function not dependant on std::cin, and instead use std::cin to get a string, and pass the string into the function, that way the function could be used for any string, not just std::cin input.</p>

<p>To avoid using <strong><em>noskipws</em></strong> (which I personally think is fine), one option is to do this: (as an alternative option to the other solutions already offered)</p>

<pre><code>std::string str;
//Continue grabbing text up until the first '#' is entered.
std::getline(cin, str, '#');
//Pass the string into your own custom function, to keep your function detached from the input.
countCharacters(str); 
</code></pre>

<p>(See <a href=""http://ideone.com/zn1jUX"" rel=""nofollow"">here for an example</a>)</p>
",1
15510718,15510569,5,"<p>You can avoid <code>noskipws</code> by replacing this</p>

<pre><code>while (cin &gt;&gt; noskipws &gt;&gt; c) 
</code></pre>

<p>with</p>

<pre><code>while ( cin.get(c) ) 
</code></pre>

<p>The extraction operator <code>&gt;&gt;</code> observes delimiter rules, including whitespace.</p>

<p><a href=""http://en.cppreference.com/w/cpp/io/basic_istream/get"" rel=""nofollow""><code>istream::get</code></a> does not, and extracts the data verbatim.</p>
",4
14780376,14780356,5,"<p>This is because you read two lines per loop </p>

<pre><code>while(getline(inData,fullName)){
    ...
    getline(inData,fullName);       
}
</code></pre>
",0
14780485,14780323,0,"<p>Remove the semicolon after <code>template&lt;class key, class value&gt;</code>:</p>

<pre><code>                                !--here
template&lt;class key, class value&gt;; 
keyValuePair&lt;key, value&gt;::keyValuePair()
{
}
</code></pre>
",0
14780507,14780323,0,"<p>keyValuePair.h should not include keyValuePair.cpp. Also the function bodies in keyValuePair.cpp should be declaired directly (different best practaces for templates than normal functions)</p>

<pre><code>template&lt;class key, class value&gt;
class keyValuePair
{
private:

    key kvar;

    value vvar; 

public:

    keyValuePair(){} //Default Constructor

    void setKvar(key object1){kvar = object1;} //Method to set kvar to a value

    void setVvar(value object2){vvar = object2;} //Method to set vvar to a value    

    key getKvar(){return kvar;} //Method to return kvar

    value getVvar(){return vvar;} //Method to return vvar

};
</code></pre>

<p>The semicolons after the</p>

<pre><code>template&lt;class key, class value&gt;;
</code></pre>

<p>are a typo too.</p>

<p>Also your setKvar function assigns the value of kvar to the parameter taken by reference. I don't this this is what you want seeing as the function is named set. </p>

<p>The reason the bodies of template class member functions are usually declared in line is that the compiler will only generate code for a particular type or types (which is called instantiating the template for the particular type) if it sees them being used in that compilation unit (usually a compilation unit and a .cpp file are the same thing).</p>

<p>This means that if you put the function bodies in keyValuePair.cpp and try to use them in main.cpp the linker will give you ""not found"" errors because in the compilation unit keyValuePair.cpp the compiler could not see them being used so it never created them.</p>

<p>You can cause the template to be instantiated for specific types directly like this:</p>

<pre><code>template keyValuePair&lt;int,long&gt;;
</code></pre>

<p>however this is probably bad style because every time you want to use your template with new types you need to add these declarations to your keyValuePair.cpp file which defeats the purpose of having the flexibility in the first place.</p>
",2
14780509,14780323,0,"<p>You have several small mistakes in the syntax.</p>

<ul>
<li><p>you declared <code>setKvar</code> and <code>setVvar</code> to take the parameter by value, but defined them to take a reference. (Drop the <code>&amp;</code> in .cpp file)</p></li>
<li><p>Do not put a semicolon after <code>template&lt;class key, class value&gt;</code></p></li>
<li><p>in <code>setKvar</code> and <code>setVvar</code>, you have the argumets swapped in the assignment. It should read like <code>kvar = object1;</code> in <code>setKvar</code> and analogically <code>vvar = object2;</code> in <code>setVvar</code></p></li>
<li><p>Do not include the cpp file in the header, include the content directly into the header file, like PorkyBrain said.</p></li>
</ul>
",0
15581579,15581569,4,"<p>If you're compiling with MinGW, <a href=""http://www.mingw.org/wiki/wide_characters"" rel=""nofollow"">wide characters are not yet supported</a>. If you really need it, an alternative is to use the <a href=""http://www.stlport.org/"" rel=""nofollow"">STLPort</a> library as an alternative to libstdc++.</p>
",3
15581929,15581569,1,"<p>Dev-C++ 4.9.9.2 that you're using comes with MinGW-gcc 3.4.2 which is <a href=""http://gcc.gnu.org/releases.html"" rel=""nofollow"">7+ years old</a>, likely doesn't have wide-chars properly supported as suggested by sftrabbit.</p>

<p>If you look at the top of the original <a href=""http://sourceforge.net/projects/dev-cpp/"" rel=""nofollow"">Dev-C++</a> at sourceforge you'll see that its been superseded by <a href=""http://sourceforge.net/projects/orwelldevcpp"" rel=""nofollow"">Orwell Dev-C++</a>. I would suggest using that if you need wide-char support since it packages a much more recent version of MinGW-gcc.</p>
",0
15521082,15520983,5,"<pre><code>unsigned long long a;
// bits 1 and 2 assuming 0 indexed
int first = static_cast&lt;int&gt;((a &amp; (3ULL&lt;&lt;1))&gt;&gt;1);
// bits 3 and 5 assuming 0 indexed
int second = static_cast&lt;int&gt;((a &amp; (3ULL &lt;&lt; 3)) &gt;&gt; 3);
// bits 6 and 7 assuming 0 indexed
int third = static_cast&lt;int&gt;((a &amp; (3ULL &lt;&lt; 5)) &gt;&gt; 5);
</code></pre>
",0
14815711,14815675,2,"<p><code>cv</code> us a notation commonly used to point out that the type can be marked as <code>volatile</code> or <code>const</code>.</p>
",1
14815814,14815675,1,"<p>In the C++ standard, <code>cv</code> refers to the <code>const</code> and <code>volatile</code> qualifiers of the type in question. <code>cv A</code> is shorthand for ""<code>A</code> and whatever <code>const</code> and <code>volatile</code> qualifiers it has"". Adding a number (<code>cv1</code>, <code>cv2</code>) is just a mechanism for saying that there are possibly different sets of cv qualifiers involved.</p>
",0
14823954,14823840,-2,"<p>On your example.</p>

<p>The array is not an array of characters, it is an array of strings.</p>

<p>Well, actually, a string is an array of characters.</p>

<pre><code>//Let's say:
string s = ""This is a string."";
//Therefore:
s[0] = T
s[1] = h
s[2] = i
s[3] = s
</code></pre>

<p>But based on your example,</p>

<p>I think you want to Split the text. (with SPACE as delimeter).</p>

<p>You can use the Split function of the String.</p>

<pre><code>string s = ""This is a string."";
string[] words = s.Split(' ');
//Therefore:
words[0] = This
words[1] = is
words[2] = a
words[3] = string.
</code></pre>
",1
14823957,14823840,1,"<p>Split your string into multiple strings based on a delimiter using the Boost library function 'split' like this:</p>

<pre><code>#include &lt;boost/algorithm/string.hpp&gt;
std::vector&lt;std::string&gt; strs;
boost::split(strs, ""string to split"", boost::is_any_of("" ""));
</code></pre>

<p>And then iterate over the <code>strs</code> vector.</p>

<p>This approach allows you to specify as many delimiters as you like.</p>

<p>See here for more:
<a href=""http://www.boost.org/doc/libs/1_48_0/doc/html/string_algo/usage.html#id3115768"" rel=""nofollow noreferrer"">http://www.boost.org/doc/libs/1_48_0/doc/html/string_algo/usage.html#id3115768</a></p>

<p>And there is a plethora of approaches here: <a href=""https://stackoverflow.com/questions/236129/splitting-a-string-in-c"">Split a string in C++?</a></p>
",0
14823977,14823840,3,"<p>You are trying to split string into strings. Try:</p>

<pre><code> #include &lt;sstream&gt;
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;string&gt;

 std::string s = ""This is a string."";

  std::vector&lt;std::string&gt; array;
  std::stringstream ss(s);
  std::string tmp;
  while(std::getline(ss, tmp, ' '))
  {
    array.push_back(tmp);
  }

  for(auto it = array.begin(); it != array.end(); ++it)
  {
    std::cout &lt;&lt; (*it) &lt;&lt; std:: endl;
  }
</code></pre>

<p>Or see this <a href=""https://stackoverflow.com/questions/236129/splitting-a-string-in-c"">split</a> </p>
",3
18110727,15312383,1,"<p>Since I'm not expert in programming, I came up with this simple code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int i,j,k,n;

    printf(""Enter no of rows : \n"");
    scanf(""%d"", &amp;n);

    for(i=0; i&lt;n; i++)
    {
        if(i == 0 || i == (n-1))
        {
            for(j=0; j &lt;n-1; j++)
                printf(""*"");
        }              
        else
        {
            for(k=0; k&lt;n; k++)
            {
                if (k == 0 || k == (n-2))
                    printf(""*"");
                else
                    printf("" "");
            }
        }

        printf(""\n"");
    }

    return 0; 
}
</code></pre>
",2
18121243,15312383,1,"<pre><code>for(int j=1;j&lt;=7;j++)
{
    if(j==1||j==7)
        printf(""*******\n"");
    else
        printf(""*     *\n"");
}

printf(""\n"");
</code></pre>
",0
14850937,14850831,0,"<p>The problem is that you simply cannot take the address of an rvalue expression. Your <code>ctlStyleGradient</code> returns a <code>ctlStyleBase</code> by value, copying it out of the function. This gives you a temporary and <code>ctlStyleGradient()</code> is an rvalue expression. You can't then do <code>&amp;</code> on this expression.</p>

<p>If you don't need to modify the object that you pass to <code>setStyle</code>, then you can change it to take a <code>const</code> reference:</p>

<pre><code>void setStyle(const ctlStyleBase&amp; style)
{
  //do something
}

if(style == 0) setStyle(ctlStyleGradient());
</code></pre>

<p>If you do need to modify it, then you'll have to take a local copy of the <code>ctlStyleBase</code> object and pass that by value or reference:</p>

<pre><code>void setStyle(ctlStyleBase style)
{
  //do something
}


if(style == 0) {
  ctlStyleBase styleCopy = ctlStyleGradient();
  setStyle(styleCopy);
}
</code></pre>
",0
14850946,14850831,0,"<p>You can do this:</p>

<pre><code>void create(const ctlStyleBase* style = 0)
{
      if(style == 0)
      {
          ctlStyleGradient temp;
          setStyle(&amp;temp);
      }
      else setStyle(style);
}
</code></pre>

<p>But, honestly, I would rework your code so you don't do this, passing pointers to local variables like this is risky business. Perhaps alter the <code>setStyle</code> call so that it checks for the null pointer?</p>
",1
14850952,14850831,2,"<p>Well, tough - it's a rule of the language that you cannot take the address of a temporary object. The reason for the rule is that there is basically never a good <em>reason</em> to do this.</p>

<p>In your example, <code>ctlStyleGradient()</code> returns some object of type <code>ctlStyleBase</code>. If you wanted to modify that object in the <code>setStyle</code> function (although you don't in this case), then as soon as you're done, the object ceases to exist, thus making the whole modification pointless.</p>

<p>Yes, you can contrive code where the operation has observable side effects, but that by itself would be very poor style. So, there's no deep technical reason why you shouldn't be able to take the address of a temporary, but the language decided not to let you do it because it's considered inappropriate.</p>

<p>But this doesn't seem what you're trying to do. Perhaps what you meant to do was for <code>ctlStyleGradient()</code> to return a pointer itself? Or, if you only need to <em>observe</em> a state and never change it, pass the state along by value or by const-reference.</p>
",1
14753932,14752243,1,"<p>You're overwriting the loop variable.</p>

<pre><code>    for(int i=0;i&lt;nS;i++) // Loop over 'i'
    {
        fscanf(fp, [...],&amp;i,[...]);   // Oops!
        this-&gt;Sph_obj[i].SphereSet([...]; // Bang!
    }
</code></pre>

<p>Declaring variables close to their use and not reusing them is a good thing - if you had declared <code>a</code>..<code>q</code> inside the loop, the compiler would have caught that error for you.</p>
",0
15552886,15552825,3,"<p>Because <code>result_type</code> and <code>argument_type</code> depend on the template parameters. Use:</p>

<pre><code>virtual typename std::unary_function&lt;ARGUEMENT, RESULT&gt;::result_type
  operator () (typename std::unary_function&lt;ARGUEMENT, RESULT&gt;::argument_type) = 0;
</code></pre>

<p>or, if you need it in more places, add</p>

<pre><code>using typename std::unary_function&lt;ARGUEMENT, RESULT&gt;::result_type;
using typename std::unary_function&lt;ARGUEMENT, RESULT&gt;::argument_type;
</code></pre>

<p>in the beginning of your class.</p>
",0
15552967,15552825,3,"<p>Because it is an <em>unqualified name</em>. </p>

<p>When you use unqualified names in a class template, you have to tell the compiler that it should not immediately search for global names during the first phase of the two-phase name lookup, but rather wait until instantiation (because the name could come from a base class, as is the case here).</p>

<p>In this case, you could do this (and make <code>result_type</code> a <em>dependent</em>, qualified name): </p>

<pre><code>typedef typename std::unary_function&lt;ARGUEMENT, RESULT&gt;::result_type result_type;
</code></pre>

<p>Notice that the same applies to <code>argument_type</code>.</p>

<pre><code>typedef typename std::unary_function&lt;ARGUEMENT, RESULT&gt;::argument_type argument_type;
</code></pre>

<p>Armed with those two <code>typedef</code>s, the original member function declaration will now compile:</p>

<pre><code>virtual result_type operator () (argument_type) = 0;
</code></pre>
",0
15553019,15552825,0,"<p>You can re-typedef it in your class:</p>

<pre><code>typedef typename std::unary_function&lt;ARGUEMENT, RESULT&gt;::result_type my_result_type;
</code></pre>

<p>(You can even rename it the exact same thing)
This is can work even if what you inherit from is private.</p>

<p>This <a href=""http://ideone.com/nXas0C"" rel=""nofollow"">compiles</a>:</p>

<pre><code>template &lt;typename blah&gt;
class MyTemplateBaseClass
{
    public: 
    typedef blah my_blah_typedef;
};

template &lt;typename arg&gt;
class DerivedFromTemplated : private MyTemplateBaseClass&lt;arg&gt;
{
public:
    //Either giving the full name:
    typename MyTemplateBaseClass&lt;arg&gt;::my_blah_typedef GetBlahType()
    {
        return typename MyTemplateBaseClass&lt;arg&gt;::my_blah_typedef();
    }

    //Or typedef-ing it locally:
    typedef typename MyTemplateBaseClass&lt;arg&gt;::my_blah_typedef my_blah_typedef;
    my_blah_typedef GetBlahType2()
    {
        return my_blah_typedef();
    }
};

int main()
{
    DerivedFromTemplated&lt;int&gt; test;
}
</code></pre>
",2
14817146,14817049,2,"<p>You need a library for big integers (assuming you can't just take a ready-to-use cryptographic library).</p>

<p>First you create a random 160-bit value, not necessarily prime. Depending on the platform, you may use <code>/dev/random</code>, <code>CryptGenRandom</code>, or some other enthropy source(s), (possible several ones, combined).</p>

<p>Then you increment the value in a loop, applying e.g. <a href=""http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test"" rel=""nofollow"">Miller-Rabin (pseudo-)primality test</a> to each candidate, until you find a prime number.</p>
",0
15883446,15883278,1,"<p>Assuming that you have someone who is sensible that is requesting that you have ""no warnings"", then you can request an exception and ""disabling this warning"". It should probably be done on a file-by-file basis, ideally with a written ""plan to fix in future"" solution, rather than a wholesale ""let's disable this warning for all files"". </p>

<p>The other option is to find all the places where this is causing a warning, and reordering the initializers. </p>

<p>Note that the warning is just saying ""the initialization happens in a different order than you wrote it"", so the re-ordering will not CHANGE the behaviour of your code at all - the compiler already does the re-ordering for you!</p>
",0
15883334,15883278,0,"<p>You can use </p>

<pre><code>-Wno-reorder
</code></pre>

<p>to just disable those warnings.</p>
",7
17817011,17816660,1,"<p>The short answer is yes, but this is generally only needed when you have some memory mapped IO (shared memory???).  AFAIK there is no speed increase gained.  Exactly what are you doing?</p>

<p>Have you considered using a 3rd party pool?  I found a really general implementation <a href=""http://www.codeproject.com/Articles/15527/C-Memory-Pool"" rel=""nofollow"">here</a>.  </p>

<p><a href=""http://www.boost.org/doc/libs/1_54_0/libs/pool/doc/html/index.html"" rel=""nofollow"">Boost::pool</a> might also be interesting</p>
",0
17816876,17816660,2,"<p>If your data types are variable length you are better using the standard heap for memory management. The standard heap is highly optimized for this use-case.</p>

<p>Using a memory pool generally only becomes useful when you are consistently allocating objects of the same size. It then becomes easy to divide your pool into equal sized cells are perform optimizations like free-lists that the system heap is unable to do. </p>
",1
14781140,14781057,0,"<p>Sounds like you could use a factory:</p>

<pre><code>BaseClass {
private:
  Data m_data;
public:
  void setData(const Data&amp; data) { m_data = data; }
  virtual Data generateData() = 0;
};

struct Factory
{
   template&lt;class T&gt;
   static BaseClass* getInstance()
   {
       BaseClass* t = new T;
       t-&gt;setData(t-&gt;generateData());
       return t;
   }
};
</code></pre>

<p>and call it as </p>

<pre><code>BaseClass* p = Factory::getInstance&lt;Derived&gt;();
</code></pre>

<p>As you can see, non-abstract derived classes are forced to call <code>generateData</code>, so they will have to generate a valid <code>Data</code>.</p>

<p>I only used raw pointers for ease of writing this, don't :)</p>
",1
14781155,14781057,1,"<p>Rather than a pattern, this is an anti pattern. Rule of thumb: protected variables are bad. Inherited behavior (inheriting from concrete classes in general) is bad. Of course there might be times when there's a reason to ignore either of these, but without you saying what you are actually trying to do it's hard to tell.</p>
",2
14781186,14781057,1,"<p>In my opinion, a protected variable should never be used. I prefer to use a private variable, with a protected method. In this way, if you want to use a polymorfic object you can override your method and avoid ""bad surprises"". If your class is <code>final</code>, of course you can use directly the protected var.</p>
",3
14781216,14781057,1,"<p>To me, this doesn't sound quite right. Although it's not unheard of to have the derived class make calls to the baseclass, it is more commonly that the derived class will override the (virtual) <code>public_method</code> to provide that information. </p>

<p>Or, as suggested, use a factory function. Or a static ""constructor"" member function, so rather than calling new, you call a function that calls <code>new</code> and the <code>special function to make set the data</code>.</p>

<p>All possible solutions. </p>
",0
14781291,14781057,1,"<blockquote>
  <p>If only the superclass constructor could be forced to be called AFTER the subclass constructor did its work. Then the superclass constructor could have the required parameters in it.</p>
</blockquote>

<p>The <em>ctor-initializer-list</em> is quite powerful.  Although you can only use expressions, those expressions can include function calls.  Virtually anything you can do inside the constructor body can be achieved from inside the initializer list.</p>

<p>Of course, you must respect construction order, so you can't call member functions on the base class before initializing it.  But you can access the base class when initializing members.</p>

<pre><code>class BaseClass
{
  Data m_data;
protected:
  BaseClass( Data&amp;&amp; data ) m_data(data) {}
public:
  Interesting public_method() {
    //returns something interesting about m_data
    //what exactly depends on what the subclass put into m_data
  }
};

class DerivedClass : public BaseClass
{
  static Data make_arg_into_data( const T&amp; arg ) { /* calculate and return the right value for m_data */ }
  static Interesting make_arg_into_member_init( BaseClass* pThis, const T&amp; arg ) { return pThis-&gt;public_method(); }
  V m_member;
public:
  DerivedClass( T arg ) BaseClass(make_arg_into_data(arg)), m_member(make_arg_into_member_init(this, arg)) {  }
};
</code></pre>
",0
15527908,15527827,13,"<p>Simply put <code>#include</code> tells the pre-compiler to simply copy and paste contents of the header file being included to the current translation unit. It is evaluated by the pre-compiler.         </p>

<p>While <code>using directive</code> directs the compiler to bring the symbol names from another scope in to current scope. This is essentially put in effect by the compiler.</p>

<blockquote>
  <p><strong>But then how am I supposed to create my own ""library"" which I could ""use""?</strong>    </p>
</blockquote>

<p>Namespaces are something which are used for preventing symbol name clashes. And usually every library implementer will have their functionality wrapped up in one or many namespaces.</p>
",0
15527981,15527827,4,"<p>'include' basically does a copy-paste the value of a file to the location of the ""include"" line. This is used to make your source code (usually .c file) aware of a declaration of other source code (usually sits in .h file).</p>

<p>'using' basically tells the compiler that in the next code you are using something (usually a namespace) so you won't have to do it explicitly each time:  </p>

<p>Instead of:</p>

<pre><code>std::string a;
std::string b;
std::string c;
</code></pre>

<p>You could write:</p>

<pre><code>using namespace std;
string a;
string b;
string c;
</code></pre>
",3
14831227,14831098,0,"<p>To read, try C++'s stream operators to read tokens: <a href=""https://stackoverflow.com/questions/275355/c-reading-file-tokens"">C++ Reading file Tokens</a></p>

<p>To write, try C++'s stream operators with <a href=""http://www.cplusplus.com/reference/iomanip/setw/"" rel=""nofollow noreferrer""><code>setw</code></a> to line up the columns.</p>
",0
16378508,16378464,1,"<p>Next should be learning the <a href=""http://www.cplusplus.com/reference/stl/"" rel=""nofollow noreferrer"">STL</a> library, and <a href=""https://rads.stackoverflow.com/amzn/click/com/0201633612"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">design patterns</a></p>
",1
16378586,16378464,1,"<p>I would recommend learning about <a href=""https://computing.llnl.gov/tutorials/pthreads/"" rel=""nofollow"">POSIX thread library</a>. Since you are interested in networking, if you haven't already done so, start looking at the code of some open source network simulator tools like <a href=""http://en.wikipedia.org/wiki/GloMoSim"" rel=""nofollow"">GloMoSim</a> or <a href=""http://www.nsnam.org/"" rel=""nofollow"">NS3</a> and implement your own protocol for a layer of your choice.</p>
",0
16437291,16436772,0,"<p>Each class will have it's own vtable. In this case, each class has a unique virtual destructor, so that in itself means that the vtable needs to be the different. If you were to construct a class that didn't have any virtual functions that are different, it is possible that the compiler may decide to ""reuse"" the same vtable. But not guaranteed.</p>

<p>If a class is deriving from more than one class, then there needs to be a vtable for each class that has virtual functions of any kind. This is so that the virtual functions of both base-classes can be called if the class is converted (either by using a pointer to the base or a dynamic_cast) into one of the base classes.</p>

<p>Note also: How the compiler deals with vtables is entirely up to the compiler, and no guarantees are made about ANY aspect of how they work. </p>
",1
16437358,16436772,0,"<p>First of all, <code>Derived2</code> is of another type than <code>Base1</code>, so it needs some other information apart from the virtual functions table. Second, at least <code>Derived2</code>'s destructor is another function than the one from <code>Base1</code>, so even if there were only the virtual functions in the table, that entry <em>has</em> to be differnt.
I am not sure about how MSVC implements RTTI on polymorphic types, but there has to be some identifcation of the type different to virtual functions, e.g. to enable <code>dynamic_cast</code>s. So that first entry could very well be the pointer to the RTTI. I have no MSVC around at the moment, but you could try this:</p>

<pre><code>struct Base {
  virtual void foo() {};
  virtual void bar() {};
  virtual ~Base();
};

struct Derived {
  virtual void foo() {};
  virtual ~Derived();
};

int main() {
  Base* b1 = new Base;
  Base* b2 = new Derived;
};
</code></pre>

<p>Now inspect the first four or five elements of the <code>__vfptr</code>'s of the two created objects, my guess is you will see one entry that is the same - it's the pointer to <code>Base::bar</code>. The others (Pointers to RTTI, foo and destructor) should be different.<br>
Here comes some gueswork: <em>Maybe</em> you can see a different region in memory the pointers point to, since the RTTI pointers might point to the data segment, while the virtual function pointers point to code segment.</p>

<p><strong>Update:</strong> there need not be an entry for RTTI in the vtable itself - it might be possible that some compilers implement RTTI just by <em>comparing</em> the addresses of the vtables.</p>
",0
14732860,14732783,3,"<p>You should change this:</p>

<pre><code>cout &lt;&lt; ""Your number is: "" &lt;&lt; tens[Ldight - 2] &lt;&lt; ones[num];
</code></pre>

<p>To</p>

<pre><code>cout &lt;&lt; ""Your number is: "" &lt;&lt; tens[Ldight - 2] &lt;&lt; ones[Rdight];
</code></pre>

<p>You compute a value you never use. And also in the line above <code>ones</code> num accesses index out of bounds.</p>
",4
14732902,14732783,-1,"<p>You could try by splitting user input to 2 pieces.
If user input is : 55 you split it in 5 and 5 and then print</p>

<p>tens[5] + ones[5]</p>

<p>That would be much better solution.
You will delete all those if-s that can cause problems</p>
",1
14732904,14732783,1,"<p>For your first question, your problem is in this line:</p>

<pre><code>cout &lt;&lt; ""Your number is: "" &lt;&lt; tens[Ldight - 2] &lt;&lt; ones[num];
</code></pre>

<p>You are using the wrong variable, although correctly calculating the value in the lines just above. I'm not telling you how to fix it, as you are the one learning programming, and you need to learn how to spot this type of problem. </p>

<p>[I personally would add two dummy fields to ""tens"", so as you don't have to do <code>-2</code> as well - that's a small price to pay]. </p>

<p>As for your second problem, you'll have to consider how you go about saying it, and you'll probably come up with something... It's not VERY different from solving single digits, let's say.  If you need more than about half a dozen or so lines, you are solving it wrong. </p>

<p>And once you have solved hundreds, it will be very trivial to add numbers up to millions, and even much further, with just a few lines of extra code.</p>
",0
14733410,14732783,0,"<p>Use following line :</p>

<p>cout &lt;&lt; ""Your number is: "" &lt;&lt; tens[Ldigit - 2] &lt;&lt; ones[<strong>Rdigit-1</strong>];</p>

<p>There is no need for element ""zero"" in ones[] since you output as <strong>error</strong> when i/p &lt;= 0 , so remove element <strong>""zero""</strong></p>
",0
15851644,15851630,3,"<p>In this case, I guess you don't need to keep any pointer. Give your data member <em>automatic storage duration</em>. It will be constructed when the <code>SymbolTable</code> object that contains it is constructed, and destructed when the <code>SymbolTable</code> object is destructed.</p>

<p>In other word, <code>SymbolTable</code> entirely encapsulates and owns the <code>DynHashtable&lt;string&gt;</code> object, having the exclusive responsibility of controlling its lifetime.</p>

<p>Also, in C++ you should use <code>std::string</code> for representing strings (you must include the <code>&lt;string&gt;</code> standard header to import its definition:</p>

<pre><code>#include &lt;string&gt;

class SymbolTable {
private:
    DynHashtable&lt;std::string&gt; hst;

public:
    SymbolTable() {
        // ...
    }
};
</code></pre>

<p><strong>UPDATE:</strong></p>

<p>From the comments, it seems that <code>DynHastable</code> is not default-constructible, and its constructor accepts an <code>int</code> as its parameter. In this case, you have to construct your object in the constructor's initialization list:</p>

<pre><code>class SymbolTable {
private:
    DynHashtable&lt;std::string&gt; hst;

public:
    SymbolTable() : hst(42) {
    //            ^^^^^^^^^
        // ...
    }
};
</code></pre>
",5
15851656,15851630,1,"<p>In C++ you usually embed the variable directly for value-semantics or you use a <code>std::shared_ptr</code> for reference-semantics. Here's value-semantics:</p>

<pre><code>#include &lt;string&gt;
#include &lt;unordered_set&gt; // the equivalent of DynHashtable AFAICT

class SymbolTable
{
private:
    std::unordered_set&lt;std::string&gt; hst;
public:
    SymbolTable() // automatically calls the default ctor for hst
    {
    }
};
</code></pre>

<p>and here's reference-semantics:</p>

<pre><code>#include &lt;string&gt;
#include &lt;unordered_set&gt; // the equivalent of DynHashtable AFAICT
#include &lt;memory&gt;        // for std::shared_ptr / std::make_shared

class SymbolTable
{
private:
    std::shared_ptr&lt;std::unordered_set&lt;std::string&gt;&gt; hst;
public:
    SymbolTable()
      : hst(std::make_shared&lt;std::unordered_set&lt;std::string&gt;&gt;())
    {
    }
};
</code></pre>

<p>but you usually need to define more methods like a copy-ctor, assignment operators, etc.</p>
",0
14845130,14845021,1,"<p>The usual way to access a bit in a number is to do a AND operation between the number and a mask. For example</p>

<pre><code>number = 0xFFAA0055; // an example
bit17 = 1 &lt;&lt; 17;     // counting bit0 as the least significant bit

bit17set = number &amp; bit17;
</code></pre>

<p>bit17set will be <code>true</code> if bit 17 is <code>1</code>, since only then will the logical <code>AND</code> produce a non-zero result.</p>

<p>If you are interested in multiple bits, you can simply sum their masks before the AND:</p>

<pre><code>bit6 = 1 &lt;&lt; 6;

bit6or17 = bit6 + bit17;
bit6or17set = number &amp; bit6or17;
</code></pre>

<p>When you want the address bits from MSB to LSB, the easiest operation is:</p>

<pre><code>temp = number &gt;&gt; LSB; // this shifts LSB numbers to the right
answer = temp &amp; ((1&lt;&lt;(MSB-LSB+1) - 1); // a mask of MSB-LSB bits
</code></pre>

<p>You could of course combine these two:</p>

<pre><code>int index = ((address &gt;&gt; index_LSB) &amp; (1&lt;&lt;(index_MSB - index_LSB+1)-1)).to_ulong();
</code></pre>

<p>Note: all the above assume ""normal"" numbers with bits stored ""conventionally"". If your <code>address</code> contains bits in a way that cannot be accessed by the above method, you can do the following instead:</p>

<pre><code>int ii, index=0;
for(ii=index_MSB; ii&gt;= index_LSB; ii--) {
    index = (index &lt;&lt; 1) + address[ii];
}
</code></pre>
",1
15554116,15554032,0,"<p>You shouldn't have to define virtual functions -- thre is no polymorphism.
All you code is good, but STL is better =)</p>

<p>look here </p>

<p><a href=""http://www.cplusplus.com/reference/functional/binary_function/"" rel=""nofollow"">http://www.cplusplus.com/reference/functional/binary_function/</a></p>

<p><a href=""http://www.cplusplus.com/reference/functional/unary_function/"" rel=""nofollow"">http://www.cplusplus.com/reference/functional/unary_function/</a></p>

<p>at example section </p>

<pre><code>struct IsOdd : public std::unary_function&lt;int,bool&gt; {
  bool operator() (int number) {return (number%2==1);}
};
</code></pre>

<p>PS: If you want to use wrapper not to copy functor, rewrite it this way</p>

<p>template </p>

<pre><code>class FunctorWrapper
{
public:
    typedef F::argument_type argument_type;
    typedef F::result_type result_type;

explicit FunctorWrapper(F *functor)
    : functor(functor)
{}

result_type operator () (argument_type const &amp; a) const
{
    return (*functor)(a);
}

result_type operator () (argument_type &amp; a) const
{
    return (*functor)(a);
}

private:
    F *functor;
};

template &lt;typename F&gt;
FunctorWrapper&lt;F&gt; make_unary_functor(F&amp; f)
{
    return FunctorWrapper&lt;ARGUEMENT, RESULT&gt;(&amp;f);
}
</code></pre>
",0
15554121,15554032,2,"<p>The problem is, that in C++ 98 types without external binding can not be template parameters. So the best you can do is, put your SetInc into an unnamed namespace.</p>

<p>I don't know if you workaround solves the problem in a portable way, but it's even harder to understand (you really need to comment your workaround, to make sure people understand why you did it this way). It's a lot harder for a compiler to optimize the virtual function calls away.</p>
",0
15554195,15554032,1,"<p>One clear issue is the virtual function call. With a normal function object the called function can be inlined; with a virtual function, probably not. So you end up with a <strong>great</strong> deal more overhead for small functions.</p>
",0
14866115,14865111,0,"<p>From the olden days of C, you can create a 4-bit variable by placing it into a structure:  </p>

<pre><code>struct PegState
{
    unsigned int view:2;
    unsigned int depth:2;
};
</code></pre>

<p>For a more compact representation, the requirements says it all:  use bit manipulation operations.<br>
To set a bit, use the 'OR' operator, '|':  </p>

<pre><code>unsigned int value = value | 16;
value |= (1 &lt;&lt; 8);
</code></pre>

<p>To erase a bit, use the 1's compliment and the 'AND' operator, '&amp;':</p>

<pre><code>unsigned int value = 0xFF;
value = value &amp; (~(1 &lt;&lt; 5));
</code></pre>

<p>To test the bit you can use the AND operator:</p>

<pre><code>unsigned int value = 0x55;
if (value &amp; (1 &lt;&lt; 2))
{
}
</code></pre>

<p>Search SO and the web for ""bit manipulation"".</p>
",2
17770297,17770291,11,"<p>You simply forgot:</p>

<pre><code>cin&gt;&gt;choice
</code></pre>

<p>after you display available choice options. So when you never assign value to choice, it'll always choose <code>default</code>. </p>
",1
14866518,14866496,2,"<p>Use <code>bind</code>:</p>

<pre><code>#include &lt;functional&gt;

auto h = std::bind(g, std::placeholders::_1, 5, 9);

h(""hi"");
</code></pre>

<p><code>bind</code> makes copies of the arguments, so beware if you're planning on taking arguments by reference (in which case you may want <code>std::ref</code>). Try to keep the result type <code>auto</code> to avoid unnecessary conversions.</p>

<hr>

<p>To get a normal C++ function:</p>

<pre><code>void h(char const * s) { g(s, 5, 9); }
</code></pre>

<p>Or:</p>

<pre><code>void (*ph)(char const *) = [](const char * s) { g(s, 5, 9); };
</code></pre>

<p>Or for the insane:</p>

<pre><code>struct Foo { static void bar(char const * s) { g(s, 5, 9); } };
void (*qh)(char const *) = &amp;Foo::bar;
</code></pre>

<p>Usage:</p>

<pre><code>h(""hi"");
ph(""hi"");
Foo::bar(""hi"");
qh(""hi"");
</code></pre>
",3
15850402,15850284,0,"<pre><code>printHisto(examMarks, 5, counter1, counter2);
</code></pre>

<p>will not print anything reason is counter1  and counter2 are initialize with 0, and they are passed as it is to the printHisto(...), my guess is you intend readExamMarks(...) to modify your counter(1,2), if that is the case, pass them by ref <a href=""http://www.cplusplus.com/doc/tutorial/functions2/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/functions2/</a></p>
",0
15850336,15850284,3,"<p>Your code is a bit strange, and I'm having some trouble following it. But I think the mistake you are making it that you are assuming that because you increment the variables <code>counter1</code> and <code>counter2</code> in <code>readExamMarks</code> then is somehow going to affect the values of <code>counter1</code> and <code>counter2</code> in <code>printHisto</code>. That's not true. You change the value in <code>readExamMarks</code> but that has no effect on the vairable in <code>main</code>, and so when you call <code>printHisto</code> <code>counter1</code> and <code>counter2</code> are still zero.</p>

<p>What you should understand is that variables in different functions are different variables even if they have the same name. If you want <code>readExamMarks</code> to change the variables in <code>main</code> then you should use references.</p>

<pre><code>void readExamMarks(int examMarks[], int sizeOfArray, int&amp; counter1, int&amp; counter2)
{
    ...
}
</code></pre>

<p>By using <code>int&amp;</code> instead of <code>int</code> <code>counter1</code> and <code>counter2</code> are now <em>references</em> to the variables in <code>main</code>, not <em>copies</em> of the variables in main.</p>
",2
15867143,15866904,1,"<p>Here you have two functions, one to interactively fill the hole sudoku by getting the user input. The other for printing the sudoku. With the little information you gave it's what I think you seek:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

using namespace std;

void interactiveSudokuFill(int grid1[9][9]){

for(int y=0;y&lt;9;y++){
    for(int x=0;x&lt;9;x++){
        string theString;
        cout&lt;&lt;""Write the value to prace in Sudoku[""&lt;&lt;y&lt;&lt;""][""&lt;&lt;x&lt;&lt;""] :""&lt;&lt;endl;
        std::getline(cin,theString);
        int nr=atoi(theString.c_str());
        grid1[y][x]=nr;
    }

}
}

void printSudoku(int grid[9][9]){
for(int y=0;y&lt;9;y++){
        for(int x=0;x&lt;9;x++){
            cout&lt;&lt;""[""&lt;&lt;grid[y][x]&lt;&lt;""]"";
        }
        cout&lt;&lt;endl;

    }
}
int main()
{
int grid1[9][9];
interactiveSudokuFill(grid1);

printSudoku(grid1);
}
</code></pre>

<p>There are other more safe/elegant ways of doing this(for example user input should have been checked before delievering it to atoi()), but this way is the simpler I can think of.</p>
",1
15867304,15866904,0,"<p>Firstly, you're taking in an int where you expect an array:</p>

<pre><code>void fillGrid1(int grid1, int sizeOfArray)
//             ^^^^^^^^^
</code></pre>

<p>This should be something of the form,</p>

<pre><code>void fillGrid1(int grid1[9][9], int sizeOfArray)
</code></pre>

<p>Next is that you should use a nested loop to access the elements of the multidimensional array:</p>

<pre><code>void fillGrid1(int grid1[9][9], int sizeOfArray)
{
    for (int i = 0; i &lt; sizeOfArray; ++i)
    {
        for (int k = 0; k &lt; sizeOfArray; ++k)
        {
            grid1[i][k] = x; // shouldn't x be the number the user entered?
        }
    }
}
</code></pre>

<p>You should also zero-fill your array:</p>

<pre><code>int grid1[9][9] = {0};
</code></pre>
",0
15550236,15550172,5,"<p>The error is reporting bytes <code>\342</code>, <code>\200</code>, and <code>\223</code> (represented in octal) in your code. These bytes make up the UTF-8 encoding of <a href=""http://www.fileformat.info/info/unicode/char/2013/index.htm"" rel=""nofollow"">EN DASH</a>. This is a character used in ranges (e.g. June¨CAugust) or relationships (e.g. Sydney¨CLos Angeles flight) in English text. The minus character typically accepted by C++ compilers is the ASCII compatible <a href=""http://www.fileformat.info/info/unicode/char/2d/index.htm"" rel=""nofollow"">HYPHEN-MINUS</a>, which is the character available on a QWERTY keyboard.</p>

<p>Looks like you've copy and pasted this code from somewhere and have the wrong character for subtraction in this line:</p>

<pre><code>Y = year ¨C (14 ¨C )month)/12;
</code></pre>

<p>Also note the extra parenthesis that shouldn't be there. Perhaps you want:</p>

<pre><code>Y = year - (14 - month) / 12;
</code></pre>
",5
15550257,15550172,1,"<p>I think that you have an extra <code>)</code> after the 2nd <code>-</code> in that line:</p>

<pre><code>Y = year ¨C (14 ¨C )month)/12;
</code></pre>

<p>should be:</p>

<pre><code>Y = year ¨C (14 ¨C month)/12;
</code></pre>
",1
14846358,14846323,1,"<p>For an array of N elements, take an N-bit number and use it as a counter. For each N-bit value, create an array with one of the bits from the counter in each element of the array. This will generate 2<sup>N</sup> unique arrays (i.e., the maximum possible for that number of <code>0</code>s and <code>1</code>s).</p>
",2
14846635,14846323,0,"<p>You can leverage <a href=""http://en.cppreference.com/w/cpp/algorithm/next_permutation"" rel=""nofollow""><code>next_permutation</code></a> for this. The following gets you every combination of an n sized array of 0's and 1's:</p>

<pre><code>std::vector&lt;int&gt; root(4, 1);
std::vector&lt;std::vector&lt;int&gt;&gt; vec(1, root);

for(auto i = root.begin(); i != root.end(); ++i)
{
    *i = 0;
    do {
        vec.push_back(root);
    } while(std::next_permutation(root.begin(), root.end()));
}
</code></pre>

<p>Here, <code>n</code> is 4. But you could make it anything. The combinations are contained in <code>vec</code>.</p>
",0
14846714,14846323,0,"<p>If your matrices are large (n >= 12), then you can simply generate a random matrix and with <em>overwhelming</em> probability (assuming your PRNG is good), you will get unique matrices. (The odds of two random 12x12 matrices being identical is less than one in 2^70, or about 1 in 10^21).</p>

<p>In C++11, you can use the <code>mt19937</code> random-number generator to produce a large number of high-quality random numbers:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;

main() {
    std::mt19937 generator;
    std::uniform_int_distribution&lt;int&gt; distribution(0,1);
    int n = 12;

    for(int i=0; i&lt;n; i++) {
        for(int j=0; j&lt;n; j++) {
            std::cout &lt;&lt; distribution(generator);
        }
        std::cout &lt;&lt; std::endl;
    }
}
</code></pre>

<p>Example output:</p>

<pre><code>101101101001
001111110111
100110000011
111111001011
101110001000
110001000111
100110010000
101000000011
111101101101
000111011100
110111101011
100100011100
</code></pre>
",0
16446601,16446386,0,"<blockquote>
  <p>Are static members inherited?</p>
</blockquote>

<p>In the sense that static members of the base class are also static members of any derived class, yes.</p>

<blockquote>
  <p>How is it that instead of <code>A::a</code> i can also access <code>objA.a</code>. Static variables shouldnt be accessible through objects of that class.</p>
</blockquote>

<p>That's just how the language is defined. Both are equivalent, and the object style can be more convenient if you can't easily write the type of the object.</p>

<blockquote>
  <p>If for derived class also a new static variable is made (specific to class B) then why is it not necessary to initialize the static variable for class B?</p>
</blockquote>

<p>There isn't a new static variable specific to class <code>B</code>; there's just one for class <code>A</code>. The inheritance means that it is also scoped within class <code>B</code>; but <code>A::a</code> and <code>B::a</code> both refer to the same variable.</p>

<blockquote>
  <p>Why does the output of following shown as [3,4] when it is expected to show 3 for Before and after?</p>
</blockquote>

<p>As described above, there is only one variable, and the constructor of <code>B</code> sets it to <code>4</code>.</p>
",1
16446421,16446386,4,"<p>The access to the static variable is what is inherited. Do note that static members with private access will not be accessible, as that is what the <code>protected</code> keyword is for.</p>
",3
16446471,16446386,2,"<p>Your fundamental problem is that you have mis-interpreted the answers in the question to which you linked. When you derive the class <code>B</code> you <strong>do not</strong> make a new static variable <code>a</code>. </p>

<p>So, <code>A::a</code> and <code>B::a</code> are the same variable. Once you correct this mis-understanding everything else will be obvious and clear.</p>

<p>Looking at your code:</p>

<pre><code>A objA; //A() executes which sets A::a to 3
cout &lt;&lt; ""Before:"" &lt;&lt; A::a; //outputs 3
B obj; //now B() executes and sets B::a to 4
cout &lt;&lt; endl &lt;&lt; ""After:"" &lt;&lt; A::a; //outputs 4 since A::a is same variable as B::a
</code></pre>

<hr>

<blockquote>
  <p>How is it that instead of A::a I can also access objA.a?</p>
</blockquote>

<p>Because the language specification says that you can. The language specification says that <code>A::a</code> and <code>objA.a</code> are the same variable. This is covered in any good guide to the language. For example, online you can read <a href=""http://en.cppreference.com/w/cpp/language/static"" rel=""nofollow"">cppreference.com</a> which says it like this:</p>

<blockquote>
  <p>To refer to a static member n of class T, two forms may be used: qualified name T::m or member access expression e.m or e->m, where e is an expression that evaluates to T or T* respectively. When in the same class scope, the qualification is unnecessary.</p>
</blockquote>
",5
16446500,16446386,0,"<ol>
<li>Static variables are accessible through objects of that class.  Why wouldn't they be?</li>
<li>There is only one copy of any static variable.  If another class inherits it, it only gets access to the same static variable, not another copy.</li>
<li>Because <code>B::B()</code> changed <code>A::a</code> to 4.  Both <code>B</code> and <code>A</code> share access to <code>A::a</code>.</li>
</ol>
",0
16446509,16446386,3,"<ol>
<li><p>There's not objA.a, there's access to a inside B() constructor where A::a is visible and thus can be accessed as just ""a"".</p></li>
<li><p>B::a refer to the same address in memory, there's no new static variable for B::a, it's same which you can check via &amp;B::a.</p></li>
<li><p>It is not expected to be 3 and 3, it is expected to be 3 and 4 because line ""B obj;"" changes A::a value, and because of (2) it's same variable as B::a (i.e. B() constructor changes A::a).</p></li>
</ol>
",1
15845921,15845872,1,"<p>That doesn't match the specified behavior, which is to increase the frequency of the object <code>operator++</code> is called on.</p>
",2
15846281,15845872,1,"<p><code>operator++()</code> is the <strong>pre-increment</strong> operator.  It is meant to modify the original object and then return a <em>reference to</em> the object after it has been incremented.  The reference allows code to continue accessing the original object from the return value directly, eg:</p>

<pre><code>Seti s;
(++s).something // something applies to s itself, not a copy of s
</code></pre>

<p><code>operator++(int)</code> is the <strong>post-increment</strong> operator.  It is meant to modify the original object and then return a <em>copy of</em> the object before it was incremented.  Since it is returning the object's previous state, it does not return a <em>reference to</em> the original object.</p>

<p>The declaration shown in your assignment suggests the <strong>pre-increment</strong> operator, since there is no input parameter.  However, the return value is supposed to be a reference.  The <em>correct</em> implementation would be:</p>

<pre><code>Seti&amp; Seti::operator++()
{
    if (this-&gt;freq &lt; 9)
        this-&gt;freq += 1;
    return *this;
}
</code></pre>

<p>On the other hand, if you want to implement the <strong>post-increment</strong> operator, the <em>correct</em> implementation would be:</p>

<pre><code>Seti Seti::operator++(int)
{
    Seti temp(*this);
    if (this-&gt;freq &lt; 9)
        this-&gt;freq += 1;
    return temp;
}
</code></pre>

<p>When using the operators:</p>

<pre><code>Seti s;
++s; // calls operator++()
s++; // calls operator++(int)
</code></pre>

<p>Section 13.5.7 of the C++ standard shows the official declaration of these operators:</p>

<pre><code>class X {
public:
    X&amp; operator++(); // prefix ++a
    X operator++(int); // postfix a++
};

class Y { };
Y&amp; operator++(Y&amp;); // prefix ++b
Y operator++(Y&amp;, int); // postfix b++
</code></pre>
",7
15893221,15893190,4,"<p>Your confusion about how <code>operator &lt;</code> should work is pretty common.  You want it to look like this:</p>

<pre><code>bool operator &lt; (const FConfig &amp;rhs) const
{
   int product_comparision = strcmp(product,rhs.product);
   if (product_comparision&lt;0) return true;
   if (product_comparision&gt;0) return false;
   return strcmp(exchange,rhs.exchange)&lt;0;
}
</code></pre>

<p>Since <code>product</code> is your primary key,  the only time you even consider the secondary key is if the primary key values are equal.</p>
",2
15831350,15830072,2,"<p>Your problem is  </p>

<pre><code>T *array[];
</code></pre>

<p>You define an array of pointers with no elements. Then you try to access its (nonexistent) elements which results in undefined behavior.</p>

<p>Another undefined behavior is in destructor</p>

<pre><code>delete[] array;
</code></pre>

<p>You should only <code>delete[]</code> things that were <code>new[]</code>-ed. <code>array</code> wasn't. Instead you should loop over all <code>array</code> elements (if there were any) and delete each of them.</p>

<p>The best solution is to use <code>std::vector</code> instead of array. If you insist on using array, change <code>T* array[]</code> to <code>T **array</code>, in constructor allocate memory for it</p>

<pre><code>array = new T*[size];
</code></pre>

<p>and in destructor delete all array elements before deleting array itself.</p>
",0
15830498,15830072,1,"<p>The problem was that you are including the cpp file in the main and implementing there, template implementations should be done in the h files.
Your h file should be:</p>

<pre><code> #ifndef POINTARRAY_H_INCLUDED
#define POINTARRAY_H_INCLUDED

template &lt;typename T&gt;
class PointArray
{
private:
    int nSize;
    T *array[];
public:
    PointArray()
    {
        nSize=0;
    }
    PointArray(const T *points[],const int size)
    {
        nSize=size;
        for (int i=0;i&lt;size;i++)
        {
            array[i]=new T;
            *array[i]=*points[i];
        }
    }
    PointArray(const PointArray &amp;pv)
    {
        nSize=pv.getSize();
        for (int i=0;i&lt;nSize;i++)
        {
            array[i]=new T;
            *array[i]=*(pv.get(i));
        }
    }
    ~PointArray()
    {
        delete[] array;
        nSize=0;
    }
    int * get(const int position)
    {
        assert(position&gt;-1 &amp;&amp; position&lt;nSize);
        return array[position];
    }
    const int * get(const int position) const
    {
        return array[position];
    }
    const int getSize() const { return nSize;}
};

#endif // POINTARRAY_H_INCLUDED
</code></pre>

<p>Code is still kind of hard and the allocations are bad(notice you get heap assert at the end of the process).. but it worked for me:
0
2
2
is printed...
Cheers.</p>

<p>(Notice that:)</p>

<pre><code>delete[] array;
</code></pre>

<p>is a memory leak, since your object is not an array per say but you try to define pointers to arrays, you should change it to </p>

<pre><code>T** array
</code></pre>

<p>and then at the destructor loop on the array first dimension and then do <code>delete[] array</code></p>
",11
15511594,15511541,3,"<p>I'm guessing it is because you forgot to <code>return</code> something in your function. A seg fault can happen because of this. Also, make sure you have your warning level on high, a good compiler will usually let you know about this.</p>

<p>Here is the C++ standard 6.6.3:</p>

<blockquote>
  <p>Flowing off the end of a function is equivalent to a return with no
  value; this results in undefined behavior in a value-returning
  function.</p>
</blockquote>
",4
15511628,15511541,0,"<p>If you don't return anything in the function <code>rna_complement</code>, it should be <code>void</code>.
The segmentation fault comes from the call of the destructor of <code>std::string</code>.
Alternatively, you can return <code>line</code> since it is a copy. If you want in-place modification of the string, you can pass a reference to it (<code>string &amp;line</code>), and it will modify the string passed in argument.</p>
",2
15560842,15560631,2,"<p>Here, take this much less gross function:</p>

<pre><code>int percentages(string line)
{
    map&lt;string, int&gt; words;
    double count = line.length() / 3;
    for (int i = 0; i + 3 &lt; line.length(); i += 3)
        ++words[line.substr(i, 3)];

    string find[10] = {""Phe"", ""Leu"", ""Ile"", ""STA"", ""Val"", ""Ser"", ""Pro"", ""Thr"", ""Ala"", ""Tyr""};
    for (int i = 0; i &lt; 10; ++i) 
        cout &lt;&lt; ""Percentage of "" &lt;&lt; find[i] &lt;&lt; "": "" &lt;&lt; words[find[i]] / count &lt;&lt; endl;
    return 0;
}
</code></pre>
",3
16386472,16386414,0,"<p>string is an array and you will have to treat each bit (stored as a char in your case) individually.  The best option for you will be to iterate over it converting the bits and as a final step, iterate using the addition with carry bit.  Think about how you will do it manually on paper and translate that to code using a string of chars.</p>
",0
16386526,16386414,1,"<p>1) <code>%</code> doesn't work on a string</p>

<p>2) What your code does is find the one's complement. The two's complement is that plus one.</p>

<pre><code>std::bitset &lt;MYSIZE&gt; bset(number);
bset.flip(); // one's complement
for (int i = 0; i &lt; bset.size(); i ++) {
    if (bset[i])
        bset[i] = 0;
    else {
        bset[i] = true;
        break;
    }
}
return bset.to_string();
</code></pre>
",0
16386585,16386414,1,"<pre><code>std::string twos_complement(std::string&amp; number)
{
    for (auto it = number.begin(); it != number.end(); ++it)
    {
        auto&amp; bit = *it;

        bit = (bit == '0') ? '1' : '0';
    }

    //  do adding logic here

    return number;
}
</code></pre>
",1
16386743,16386414,0,"<pre><code>std::string twos_complement(std::string number) {
    bool carry = true;
    for (int i = 0; i &lt; number.size(); ++i) {
        if (!carry)
            number[i] = number[i] == '0' ? '1' : '0';
        else if (number[i] == '0') {
            number[i] = '1';
            carry = false;
        }
    return number;
}
</code></pre>
",1
16386808,16386414,1,"<p>Here's one way of doing it using bit manipulation to avoid conditionals.</p>

<pre><code>string twosComp(string number) {
  for (int i = number.length(), carry = 1; i-- &gt; 0;) {
    number[i] = (number[i]^1)+carry; // flip the bit and add the previous carry
    carry = (number[i]&amp;2)&gt;&gt;1;        // save the overflow in the carry variable
    number[i] &amp;= ~2;                 // mask out the overflow 
  }
  return number;
} 
</code></pre>
",8
15500208,15499934,1,"<p>Take a look at <a href=""https://stackoverflow.com/questions/4850473/pretty-print-c-stl-containers"">this question</a>. It contains a generic pretty-printer for C++ with support for STL containers.</p>

<p>So you'll just <code>#include</code> it and your</p>

<pre><code>    list&lt;vector&lt;int&gt;&gt; data;
    cout &lt;&lt; data;
</code></pre>

<p>will work like a bliss.</p>
",0
15499995,15499934,2,"<p>Nested iterations, This will print each vector's data in a line:</p>

<pre><code>list&lt;vector&lt;int&gt;&gt;  data;

// ...

for (auto &amp;v : data)
{
    for (auto &amp;i : v)
    {
      cout &lt;&lt; i &lt;&lt; "" "";
    }
    cout &lt;&lt; endl;
}
</code></pre>

<p>A bit older:</p>

<pre><code>for (list&lt;vector&lt;int&gt; &gt;::const_iterator v = data.begin(); v != data.end(); v++)
{
    for (vector&lt;int&gt;::const_iterator i = v-&gt;begin(); i != v-&gt;end(); i++)
    {
        cout &lt;&lt; *i &lt;&lt; "" "";
    }
    cout &lt;&lt; endl;
}
</code></pre>
",5
17393943,17393842,10,"<p>The reason is pretty simple: the language rules do not mandate your form and the implementation you use do not support it through its own choice.</p>

<p>Quoting the standard  3.6.1p2</p>

<blockquote>
  <p>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:</p>
</blockquote>

<pre><code>int main() { /* ... */ }
</code></pre>

<blockquote>
  <p>and</p>
</blockquote>

<pre><code>int main(int argc, char* argv[]) { /* ... */ }
</code></pre>

<blockquote>
  <p>In the latter form argc shall be the number of arguments passed to the program from the environment in which the program is run. If argc is nonzero these arguments shall be supplied in argv[0] through argv[argc-1] as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.3.2.1.3.2) and argv[0] shall be the pointer to the initial character of a NTMBS that represents the name used to invoke the program or """". The value of argc shall be nonnegative. The value of argv[argc] shall be 0. [Note: it is recommended that any further (optional) parameters be added after argv. ]</p>
</blockquote>

<p>EDIT: to cover additional question:</p>

<p>There is no need to ""hack"" anything, as nothing stops to use a function or a class that takes the original argc and argv and processes it to a vector literally, or better yet parse it and map processed data to internal variables.  We have a plenty of those floating around, and those who create more than a handful of main()-s per year probably already use one of those or their own. </p>
",9
17394128,17393842,8,"<p>Workaround:</p>

<pre><code> vector&lt;string&gt; args(argv, argv + argc);

 for (auto s: args) 
      cout &lt;&lt; s &lt;&lt; endl;
</code></pre>

<p><code>std::string</code> and <code>std::vector</code> are heavy weight objects.  Dynamic memory allocation is used during their construction. </p>

<p>2nd way to do it is to use <a href=""http://volnitsky.com/project/ro/"" rel=""nofollow"">my RO library</a>.  Below code will create light weight <strong>iterator range</strong> object around <code>argv</code> array: </p>

<pre><code> auto args = ro::range(argv,argv+argc);

 for (auto s: args) 
      cout &lt;&lt; s &lt;&lt; endl;
</code></pre>
",5
17394258,17393842,1,"<p>You've been given the reason why your implementation <em>need</em> not support it. However there's also a reason why your implementation would not <em>want</em> to support it:</p>

<p>The (usually precompiled) code calling <code>main</code> passes an <code>int</code> and a <code>char**</code> (and in some implementations as extension a second <code>char**</code>; indeed, on many platforms it gets exactly that data already provided by the operating system and just passes it on). It is easy to support to ignore trailing arguments (usually they are pushed to the stack in reverse order, so ignoring the additional arguments just means not accessing them, no additional logic required). However, you cannot just read out a <code>char**</code> as <code>std::string*</code>, therefore the compiler would have to generate extra code to support this interface. Given that any source code using that interface would be non-portable anyway and few people would use it, and given that the original interface works just fine, it would just be a waste of resources to implement that alternative interface.</p>
",0
17097575,17097537,36,"<p>Here is your answer from the standard:</p>
<blockquote>
<p>3.9.1 Fundamental types [basic.fundamental]</p>
<p>1 Objects declared as characters char) shall be large enough to store any member of the implementation's basic character set. If a character from this set is stored in a character object, the integral value of that character object is equal to the value of the single character literal form of that character. It is implementation-defined whether a char object can hold negative values. Characters can be explicitly declared unsigned or signed. Plain char, signed char, and unsigned char are three distinct types. A char, a signed char, and an unsigned char occupy the same amount of storage and have the same alignment requirements (basic.types); that is, they have the same object representation. For character types, all bits of the object representation participate in the value representation. For unsigned character types, all possible bit patterns of the value representation represent numbers. These requirements do not hold for other types. <strong>In any particular implementation, a plain char object can take on either the same values as a signed char or an unsigned char; which one is implementation-defined.</strong></p>
</blockquote>
",0
17097580,17097537,55,"<p>It isn't.</p>

<p>The signedness of a <code>char</code> that isn't either a <code>signed char</code> or <code>unsigned char</code> is implementation-defined. Many systems make it signed to match other types that <em>are</em> signed by default (like <code>int</code>), but it may be unsigned on some systems. (Say, if you pass <code>-funsigned-char</code> to GCC.)</p>
",2
15562293,15562176,0,"<p>First, you are not initializing string s before passing it to fill function.
Next, you are trying to insert a string into an int. C++ doesn't let you do that directly.</p>

<p>Are you trying to split a string such as ""123456"" into [1,2,3,4,5,6; 1,2,3,4,5,6;...] etc?
Is this what you want your program to do?</p>
",3
15562499,15562176,0,"<p>Here you are storing the input in an integer array and trying to display the character values. </p>

<p>The statement cout&lt;&lt;(char)M[r][c] will give you the ASCII value corresponding to the integer value of M[r][c].</p>

<p>That might be the random characters you are seeing.
You can directly use a character array instead and try outputing by directly calling:cout&lt;&lt; M[r][c]</p>
",5
15564363,15562176,0,"<p>Try this,</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

    using namespace std;

    #define N 6

    void fill(string s, char (&amp;arr)[N][N])
    {
        int char_index =0;
        for (int i=0; i &lt; N; i++)
        {
            for (int j=0; j &lt; N; j++)
            {
                arr[i][j] = s.at(char_index);           
                if (char_index+1 == s.size()){
                    char_index =0;
                }else{
                    char_index++;
                }               
            }
        }   
    }

    void print(char arr[][N])
    {
        cout &lt;&lt; ""--------------"" &lt;&lt; endl;
        int char_index =0;
        for (int i=0; i &lt; N; i++)
        {
            for (int j=0; j &lt; N; j++)
            {
                cout &lt;&lt; arr[i][j] &lt;&lt; "" "";
            }
            cout &lt;&lt; endl;
        }
        cout &lt;&lt; ""--------------"" &lt;&lt; endl;

    }

    int main()
    {
        string s ="""";
        cout &lt;&lt; ""Enter your string:"";
        getline(cin,s); 
        char M[N][N];
        fill(s,M);
        print(M);
        system(""pause"");
        return 0;
    }
</code></pre>
",0
15861935,15861913,3,"<p>What is the expected output you think? You have couple of system messages and nothing else. This is because <code>i</code> is greater than <code>g</code> and your <code>while</code> loop condition never trues.</p>
",0
15862012,15861913,1,"<p>in addition to what boris strandjev has posted, <code>letter++</code> and <code>counter++</code> should be inside the <code>while</code> loop.</p>
",0
16449143,16449109,3,"<p>Use <a href=""http://en.cppreference.com/w/cpp/algorithm/reverse"" rel=""nofollow""><code>std::reverse</code></a> to reverse each string in the <code>vector</code>.</p>

<pre><code>void asci_art::display_backwards(vector&lt;string&gt; art)
{
  for( auto&amp;&amp; a : art ) {
    std::reverse(a.begin(), a.end()); // reverses each string
    std::cout &lt;&lt; a &lt;&lt; std::endl;
  }
}
</code></pre>

<p>Or if you want to reverse the order of the strings in the vector, a slightly different call to reverse will do the trick.</p>

<pre><code>void asci_art::display_backwards(vector&lt;string&gt; art)
{
  std::reverse( art.begin(), art.end() );  // reverses order of strings in vector
  for( auto const&amp; a : art ) {
    std::cout &lt;&lt; a &lt;&lt; std::endl;
  }
}
</code></pre>
",6
16449211,16449109,0,"<p>The problem is with : 
art[i].begin()+j=swap[j]
what are you trying to do? assigning 'swap[j]' which is a character to an integer?</p>
",1
16449443,16449109,0,"<p>Within your code you are mixing the usage of direct array access and iterators.
To make your code work as wanted, you would need to decide for one of those.</p>

<p>A second thing is, you try to store the reversed array. Since you do not return the result of that, you would not need to do that. You can just directly output the data in reversed order.</p>

<p>Examples:</p>

<pre><code>// using direct access
void asci_art::display_backwards_direct(std::vector&lt;std::string&gt; art) {
  std::cout &lt;&lt; ""Your Artwork in mirrored image"" &lt;&lt; std::endl;
  std::cout &lt;&lt; ""============================="" &lt;&lt;std::endl;

  for (signed int i = art.size() - 1; i &gt;= 0; --i) {
    std::cout &lt;&lt; art[i]; // depending on your data you might need endl here
  }
  std::cout &lt;&lt; std::endl;
}

// using iterators
void asci_art::display_backwards_iterators(std::vector&lt;std::string&gt; art) {
  std::cout &lt;&lt; ""Your Artwork in mirrored image"" &lt;&lt; std::endl;
  std::cout &lt;&lt; ""============================="" &lt;&lt;std::endl;

  for (std::vector&lt;std::string&gt;::iterator it = art.rbegin(); it != art.rend(); ++it) {
    std::cout &lt;&lt; *it; // depending on your data you might need endl here
  }
  std::cout &lt;&lt; std::endl;
}

// using direct access
void asci_art::display_backwards_direct_horizontal(std::vector&lt;std::string&gt; art) {
  std::cout &lt;&lt; ""Your Artwork in mirrored image"" &lt;&lt; std::endl;
  std::cout &lt;&lt; ""============================="" &lt;&lt;std::endl;

  for (signed int i = 0; i &lt; art.size(); ++i) {
    std::cout &lt;&lt; std::reverse(art[i].begin(), art[i].end()); // depending on your data you might need endl here
  }
  std::cout &lt;&lt; std::endl;
}

// using iterators
void asci_art::display_backwards_iterators_horizontal(std::vector&lt;std::string&gt; art) {
  std::cout &lt;&lt; ""Your Artwork in mirrored image"" &lt;&lt; std::endl;
  std::cout &lt;&lt; ""============================="" &lt;&lt;std::endl;

  for (std::vector&lt;std::string&gt;::iterator it = art.begin(); it != art.end(); ++it) {
    std::cout &lt;&lt; std::reverse(it-&gt;begin(), it-&gt;end()); // depending on your data you might need endl here
  }
  std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>C++11 syntax would shorten the second version.</p>

<p>Unrelated: using references for passing arguments may speed up the application, when you deal with really vectors, so the vector would not be copied every time.</p>

<pre><code>void some_function(std::vector&lt;std::string&gt; const &amp; const_reference_to_my_string_vector) {
  std::cout &lt;&lt; const_reference_to_my_string_vector.size() &lt;&lt; std:endl;
}
</code></pre>
",2
15536756,15533133,0,"<p>Take a look here <a href=""http://www.skyfree.org/linux/references/ELF_Format.pdf"" rel=""nofollow noreferrer"">http://www.skyfree.org/linux/references/ELF_Format.pdf</a> at page 1-8. The symbol table (<code>.symtab</code> section) will contain all the symbols which is basically an address and a name which is an offset into the <code>.strtab</code> section. You can find the exact structures in that ELF_Format.pdf. Also take a look at this question for some of the differences between the sections: <a href=""https://stackoverflow.com/questions/11289843/string-table-in-elf"">String table in ELF</a></p>

<p>A nice tool to play around with the elf format is <code>readelf</code>: <a href=""http://linux.die.net/man/1/readelf"" rel=""nofollow noreferrer"">http://linux.die.net/man/1/readelf</a> . I know that an executable of it is distributed with MinGW</p>
",0
15806262,15790196,0,"<p>You can also try to add static function in your class. But I'm not sure if this what you 
are looking for.</p>

<pre><code>class B: public C
{
public:
    static int GetA(void) {return a;}
private:
    static int a;
};
int B::a = 4;

class A: public C
{
public:
    void Init()
    {
    std::cout&lt;&lt;""Val of A ""&lt;&lt;B::GetA()&lt;&lt;std::endl;
    }

private:
    int b;
};
</code></pre>
",0
15876144,15876119,1,"<p>Well <code>x</code> is not the value that the user is entering. You should be checking <code>nr</code>:</p>

<pre><code>if(nr &gt;= 1 &amp;&amp; nr &lt;= 9) {
  grid1[y][x] = nr;
}
</code></pre>

<p>Typically, extraction of an <code>int</code> from <code>std::cin</code> is done like this:</p>

<pre><code>int nr;
std::cin &gt;&gt; nr;
</code></pre>

<p>If you want to keep asking the user for a new value until they enter one that is both an integer and a correct integer:</p>

<pre><code>int nr = 0;
do {
  std::cin &gt;&gt; nr;
  std::cin.clear();
} while(nr &lt; 1 || nr &gt; 9);
grid[y][x] = nr;
</code></pre>
",7
15876268,15876119,0,"<p>Try this:</p>

<pre><code>void interactiveSudokuFill(int grid1[9][9]){

for(int y=0;y&lt;9;y++){
 for(int x=0;x&lt;9;x++){
string theString;
cout&lt;&lt;""Write the value to place in Sudoku[""&lt;&lt;y&lt;&lt;""][""&lt;&lt;x&lt;&lt;""] :""&lt;&lt;endl;
std::getline(cin,theString);
int nr=atoi(theString.c_str());
if(nr&gt;=1 &amp;&amp; nr&lt;=9){
     grid1[y][x]=nr;
}
else{
 cout&lt;&lt;""Invalid number.""&lt;&lt;endl;
 x--;
}
system(""cls"");

}

}
}

x-- and surely aren't the most correct way of doing things but it works...
</code></pre>
",3
16952576,16952527,4,"<p><code>std::cout &lt;&lt; f() &lt;&lt; g();</code></p>

<p>The order of evaluation of the two function calls is unspecified; the compiler can call <code>g()</code> then <code>f()</code>, or it can call <code>f()</code> then <code>g()</code>.</p>

<p>Same thing in your code; the compiler can squirrel away the value of <code>a.a[0]</code> the call <code>a.b()</code>, or it can call <code>a.b()</code> then grab the value of <code>a.a[0]</code>.</p>
",7
16389553,16389447,0,"<p>If this is a read only variable (constant) you cannot do <code>Probes++</code> (which is similar to <code>Probes = Probes + 1</code>) because constants cannot be updated. What you can do is to declare it as a variable (which you can modify while the program is executed) or just declare <code>Probes</code> as <code>mutable</code>.</p>
",2
15802046,15802006,5,"<p>Question 1:</p>

<pre><code>   vectorOfGamers.push_back(Player)
</code></pre>

<p>This is problematic because you cannot directly push a class name into a vector.
You can either push an object of class into the vector or push reference or pointer to class type into the vector. For example:</p>

<pre><code>vectorOfGamers.push_back(Player(name, id)) 
  //^^assuming name and id are parameters to the vector, call Player constructor
  //^^In other words, push `instance`  of Player class into vector
</code></pre>

<p>Question 2:</p>

<p><code>These 3 classes derives from Gamer. Can I create vector to hold objects of Dealer, Bot and Player at the same time? How do I do that?</code></p>

<p>Yes you can. You can create a vector of pointers that points to the base class <code>Gamer</code>.
A good choice is to use a vector of <code>smart_pointer</code>, therefore, you do not need to manage pointer memory by yourself. Since the other three classes are derived from <code>Gamer</code>, based on polymorphism, you can assign derived class objects to base class pointers. You may find more information from this post: <a href=""https://stackoverflow.com/questions/15731670/stdvector-of-objects-pointers-smart-pointers-to-pass-objects-buss-error"">std::vector of objects / pointers / smart pointers to pass objects (buss error: 10)?</a></p>
",0
15802051,15802006,76,"<p>To answer the first part of your question, you must create an object of type Player before you can use it. When you say <code>push_back(Player)</code>, it means ""add the Player <em>class</em> to the vector"", not ""add an object of type Player to the vector"" (which is what you meant).</p>

<p>You can create the object on the stack like this:</p>

<pre><code>Player player;
vectorOfGamers.push_back(player);    // &lt;-- name of variable, not type
</code></pre>

<p>Or you can even create a temporary object inline and push that (it gets copied when it's put in the vector):</p>

<pre><code>vectorOfGamers.push_back(Player());    // &lt;-- parentheses create a ""temporary""
</code></pre>

<p>To answer the second part, you can create a vector of the base type, which will allow you to push back objects of any subtype; however, this won't work as expected:</p>

<pre><code>vector&lt;Gamer&gt; gamers;
gamers.push_back(Dealer());    // Doesn't work properly!
</code></pre>

<p>since when the dealer object is put into the vector, it gets copied <em>as a Gamer object</em> -- this means only the Gamer part is copied effectively ""slicing"" the object. You can use pointers, however, since then only the pointer would get copied, and the object is never sliced:</p>

<pre><code>vector&lt;Gamer*&gt; gamers;
gamers.push_back(new Dealer());    // &lt;-- Allocate on heap with `new`, since we
                                   // want the object to persist while it's
                                   // pointed to
</code></pre>
",6
15802060,15802006,1,"<p>You cannot insert a <em>class</em> into a vector, you can insert an <em>object</em> (provided that it is of the proper type or convertible) of a class though.</p>

<p>If the type <code>Player</code> has a default constructor, you can create a temporary object by doing <code>Player()</code>, and that should work for your case:</p>

<pre><code>vectorOfGamers.push_back(Player());
</code></pre>
",0
15802105,15802006,0,"<pre><code>// create a vector of unknown players.
std::vector&lt;player&gt; players;

// resize said vector to only contain 6 players.
players.resize(6);
</code></pre>

<p>Values are always initialized, so a vector of 6 players is a vector of 6 valid player objects.</p>

<p>As for the second part, you need to use pointers.
<a href=""https://stackoverflow.com/questions/15591821/instantiating-c-interface-as-a-child-class/"">Instantiating c++ interface as a child class</a></p>
",0
15574689,15574648,4,"<p><code>d</code> is always and forever false. No code ever sets it to <code>true</code>.</p>

<p>Also, you need to start <code>e</code> at 10 (2 + 3 + 5).</p>
",0
15574963,15574648,1,"<p>Try this :)</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main(){
    bool prime;
    int num = 200000;
    int sum = 0;
    for (int i=3; i&lt;=num; i++){
        prime = true;
        for(int j=2; j&lt;=i/2; j++){
            if(i%j == 0) prime = false;
        }
        if(prime) sum+=i;
    }
    cout &lt;&lt; sum;
}
</code></pre>
",1
15584486,15574648,0,"<p>In my opinion the most effective way to find if number is prime is to:</p>

<ul>
<li>Check if number is less than 4 (<code>&lt;=3</code>), then it is prime number. Assuming only positive-integers participate.</li>
<li>Otherwise, check if it is even number - then it is not a prime number.</li>
<li>If more than 3, and is not even - check it against all number from 3 to square-root of given number, skipping all evens in check. If it is multiple of any number, then it is not prime. Otherwise it is prime.</li>
</ul>

<p>In C++ words:</p>

<pre><code>bool IsPrime(unsigned int nCheck)
{
   assert(nCheck&gt;0);

   if(nCheck&lt;=3)
     return true;

   if(nCheck%2==0)
     return false;

   for(int nCounter = 3; nCounter &lt;= sqrt(nCheck); nCounter += 2) // Skip evens
   {
       if(nCheck % nCounter == 0)
          return false;
   }
   return true;
}
</code></pre>

<p>Any number is by 1 to square-root of that number. For example, 100, is divisible by max 10. Even it is divisible by, say 50, it is also divisible by 5. So, just check from 1 to 10.</p>
",0
15576713,15576595,0,"<p>If you don't really need of the matrix you can simply:</p>

<pre><code>void print(string s, int limit, char endl = '\n') {
    if (limit == 0) return;
    if (s.length &gt; limit) {
        for (int i = 0; i &lt; s.length; i++) {
            std::cout &lt;&lt; s[i];
            if (i % limit == 0)
                std::cout &lt;&lt; endl;
    } else {
        std::cout &lt;&lt; s;
    }
}
</code></pre>

<p>which will take the string and print it, in case it below the limit, or split it into different lines with the <code>endl</code> char.</p>
",0
15827537,15827446,1,"<p>You have a bug in your push_back method. You need something like this</p>

<pre><code>if (applied+1 == my_capacity)
{
    int newCapacity = my_capacity * CAPACITY;
    daArray = new T[newCapacity];
    for (int i = 0; i &lt; my_size; i++)
    {
        daArray[i] = buffer[i];  
    }
    my_capacity = newCapacity;  
    delete buffer;
    buffer = daArray; // new line here
    my_size++;
    applied++;
    buffer[applied] = i;
}
</code></pre>

<p>See where I've put the comment <code>// new line here</code></p>
",3
15876954,15876953,10,"<p>You initiate the <code>std::bitset</code> with a <strong>numbers</strong> <code>01100100</code> and <code>11111111</code>. Simply look in the output:</p>

<pre><code>01000000
11000111
</code></pre>

<p>Both are wrong. You are initiating <code>std::bitset</code> with a decimal number <code>11111111</code> which is <code>101010011000101011000111</code> in binary representation. And first is the number <code>01100100</code> are in octal representation: <code>1001000000001000000</code> in binary. And <code>std::bitset</code> take the  least significant eight bits of that.</p>

<p>Here is the correct <a href=""http://liveworkspace.org/code/eGjEp$0"" rel=""noreferrer"">code</a>:</p>

<pre><code>#include &lt;bitset&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::bitset&lt;8&gt; b1(std::string(""01100100"")); std::cout&lt;&lt;b1&lt;&lt;std::endl;
    std::bitset&lt;8&gt; b2(std::string(""11111111"")); std::cout&lt;&lt;b2&lt;&lt;std::endl;
    std::cout &lt;&lt; ""b1 &amp; b2: "" &lt;&lt; (b1 &amp; b2) &lt;&lt; '\n';
    std::cout &lt;&lt; ""b1 | b2: "" &lt;&lt; (b1 | b2) &lt;&lt; '\n';
    std::cout &lt;&lt; ""b1 ^ b2: "" &lt;&lt; (b1 ^ b2) &lt;&lt; '\n';
    return 0;
}
</code></pre>

<p>And the correct output:</p>

<pre><code>01100100
11111111
b1 &amp; b2: 01100100
b1 | b2: 11111111
b1 ^ b2: 10011011
</code></pre>
",1
16408261,16408006,0,"<p>Try</p>

<pre><code>(dest[1] &lt;&lt; 8) &amp; dest[0]
</code></pre>

<p>IMHO the hByte and lByte is swapped... And what is more 123123 is not a two byte value. Int is signed, so on two bytes the max value is 32767, but <code>int</code> (usually) is 4 bytes.</p>

<p>I might suggest to use a <code>union</code> in this case, because you can spare all the arithmetics and you do not need to use explicit conversion at all.</p>

<p>An example code to use union:</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::hex;
using std::dec;
using std::endl;

int main() {
   union int2bytes {
       unsigned char byte[sizeof(int)];
       int val;
   };

   int2bytes i;
   // Convert int to byte
   i.val = 123123;
   cout &lt;&lt; i.val &lt;&lt; "" : "" &lt;&lt; hex &lt;&lt; i.val &lt;&lt; dec &lt;&lt; endl;
   for (int j = 0; j &lt; sizeof(int); ++j)
       cout &lt;&lt; ""Byte#"" &lt;&lt; j &lt;&lt; "" : "" &lt;&lt; hex &lt;&lt; (int)i.byte[j] &lt;&lt; dec &lt;&lt; endl;

   // Convert byte to int
    i.byte[1]--;
    cout &lt;&lt; i.val &lt;&lt; "" : "" &lt;&lt; hex &lt;&lt; i.val &lt;&lt; dec &lt;&lt; endl;
}
</code></pre>

<p>The output:</p>

<pre><code>123123 : 1e0f3
Byte#0 : f3
Byte#1 : e0
Byte#2 : 1
Byte#3 : 0
122867 : 1dff3
</code></pre>

<p>Union can be improved a little bit</p>

<pre><code>union int2bytes {
    unsigned char byte[sizeof(int)];
    int val;
    int2bytes (const int2bytes&amp; i = 0) : val(i.val) {};
    int2bytes (int i) : val(i) {};
};
</code></pre>

<p>Now these work</p>

<pre><code>int2bytes i = 123123;
int2bytes j; // j.val == 0
int2bytes k = i;
j = i;
</code></pre>
",0
16408082,16408006,3,"<p>To perform the reverse of your function <code>int2bytes</code> you simply do this:</p>

<pre><code>int val = (lByte &lt;&lt; 8) | hByte;
</code></pre>

<p>Although, I think you have the names of your variables back-to-front. I'd call <code>val&amp;0xff</code> the low byte, and <code>val &gt;&gt; 8</code> the high byte.</p>

<hr>

<p>You are also mistaken in supposing that you can fit <code>123123</code> into 2 bytes. Remember that 2^16 is <code>65536</code>.</p>

<blockquote>
  <p>I have a function that allows me to separate a int value into 2 bytes (e.g: int ""123123"" results in E0F3; highByte= 0xF3 and lowByte=0xE0)</p>
</blockquote>

<p>Well, E0F3 represented in decimal is equal to 57587. Which is the value you report in the comment you made to my answer.</p>

<p>Now, <code>123123</code> represented in hexadecimal is <code>0x1E0F3</code> and you need at least three bytes to store that value.</p>
",4
15838748,15838683,2,"<pre><code> myObject[i] = objectPointer;
</code></pre>

<p>It should be inside the loop because you are storing a new reference in the array of the pointers. If it is outside the loop, then all the array of pointers point to the same reference. In such scenario, you should be careful while deallocation as all the array of pointers point to the same memory location.</p>
",1
16437460,16437416,2,"<p>It's just the reverse of the above macro</p>

<pre><code>char first = c&amp;0xFF;
char second = (c &gt;&gt; 8)&amp;0xFF;
</code></pre>

<p>You might want to lookup <em>bitwise operators</em>.</p>
",0
15879615,15879303,0,"<p>Since the implicit multiplication for integral types is <em>binary multiplication</em>, you can utilize that directly to treat the digits as base 2<sup>8</sup>, 2<sup>16</sup> or higher, instead of base 2<sup>1</sup>.</p>

<p>If you assume 8-bit digits (multiplying <code>unsigned char</code>s) the 24-bit example below is less complex than the posted 4-bit multiply in your question.</p>

<pre><code>           a1 a2 a3   (this is a 3 byte value)      
       x   b1 b2 b3   (this is another 3 byte value)      
           ======        
       xx xx xx xx    (this is a x b3)       
    xx xx xx xx       (this is a x b2, shifted 8 bits to the left)      
 xx xx xx xx          (this is a x b1, shifted 16 bits to the left)
 =================    
 xx xx xx xx xx xx    (this is the result). 
</code></pre>

<p>You can replace ""byte"" in the above with <code>short</code> or <code>long</code>, with the shifts adjusted accordingly.</p>

<p>Just be sure the multiplicands are converted to a type large enough to hold the carry <em>before</em> multiplying.</p>
",3
15879980,15879303,0,"<p>Yes, you can by using loop to accomplish this.
Assume that the type <code>long</code> is 32 bits, so the result of long*long is 64 bits.</p>

<p>For example, if you have a <code>long A</code> ant a <code>long B</code>,and you want to compute <code>a*b</code></p>

<p>First, you define the result as <code>long long result = 0;</code>.
Then check every bit of B,and if bit is 1, add <code>A &lt;&lt; X</code> to result.Where X is the index of bit.
One loop can accomplish this.</p>

<pre><code>long long AA = A;// convernt A to AA to avoid overflow
for( int index=0;i&lt;32;++index )
{
    if( B &amp; 0x1 )
        result += AA;
    AA &lt;&lt;= 1;
    B &gt;&gt;= 1;
}
</code></pre>

<p>I hope i didn't make mistake and this idea can help you.</p>
",0
15879440,15879303,0,"<p>You could use Booth's multiplication algorithm. There is more information on wikipedia: <a href=""http://en.wikipedia.org/wiki/Booth%27s_multiplication_algorithm"" rel=""nofollow"">http://en.wikipedia.org/wiki/Booth%27s_multiplication_algorithm</a></p>
",0
15880942,15879303,0,"<p>Well, the (correct and efficient) implementation of arbitrary precision and big numbers <strong>is</strong> cumbersome and for use in production code it's generally good advise to rather use a tested framework for that (e.g., <a href=""http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html"" rel=""nofollow"">boost</a>, <a href=""http://gmplib.org/"" rel=""nofollow"">gmp</a>, etc).</p>

<p>However, if you implement it yourself, I would not store the number as a sequence of bits but as a sequence of machine words like <code>unsigned int</code> to make full use of your hardware ALU capabilities. So each word already represents a number of bits and your ALU knows how to multiply those.</p>

<p>Note, that when you multiply a number with <code>n</code> digits (the base is irrelevant), you will get a number with <code>2n</code> digits, e.g. 99 * 99 = 9801 (base 10), 0xFF * 0xFF = 0xFE01 (base 16).
So, if <code>std::uintmax_t</code> is <code>std::uint64_t</code> on your system you can store your number as a squence of <code>std::uint32_t</code>. When multiplying two digits convert them into <code>std::uint64_t</code> and multiply those. The upper 32 bits will be the part to carry to the multiplication for the next higher digits. (Actually, you can also multiply <code>std::uintmax_t</code> variables directly, but getting the high part of the result is normally a bit tricky and involves inline assembly in order to access the according <code>EDX\RDX</code> register.)</p>

<p>With this knowledge the implementation of the <a href=""http://en.wikipedia.org/wiki/Multiplication_algorithm"" rel=""nofollow"">school multiplication method</a> should be straightforward: Just iterate over all digits <code>a[i]</code> of number <code>a</code> and multiply every digit with number <code>b</code> (don't forget to propagate the carry). Shift the result up by <code>i</code> digits and add everything to your final result.</p>

<p>Note, that this algorithm has quadratic complexity regarding the number of primitive multiplications. If you have (very, very) large numbers you can also switch to more sophisticated methods like Karatsuba or even FFT and Sch?nhage¨CStrassen. But in this case, I would really recommend using a library instead.</p>
",0
15499192,15499146,3,"<p>Your <code>foo(int)</code> <em>hides</em> the base class name. Fix it like this:</p>

<pre><code>class Derived: public Base {
public:
    using Base::foo;
    void foo(int i) {
    }
    void test() {
        foo();
        foo(1);
    }
};
</code></pre>
",2
15499195,15499146,3,"<p>Your declaration of <code>foo</code> taking a single <code>int</code> argument will hide any functions named <code>foo</code> in <code>Base</code>. You can bring a hidden name from <code>Base</code> like so:</p>

<pre><code>class Derived: public Base {
public:
    using Base::foo; // Pulls foo from Base
    void foo(int i) {
    }
    void test() {
        foo();
        foo(1);
    }
};
</code></pre>
",1
15499687,15499146,1,"<p>The answer, as others have already said, is that the <code>foo</code> in the derived type <em>hides</em> the <code>foo</code> in the base type. To extend a bit on what that means the problem is that lookup has a set of rules, and the compiler must apply those rules until it finds the identifier. Once it finds the name, it won't continue looking for better matches, it will try to use what it sees.</p>

<p>When inside <code>Derived::test</code> you type <code>foo()</code>, the compiler must resolve <code>foo</code>, which might be anything (type, [member] variable, [member] function...). To do so it starts looking what is available inside <code>Derived::test</code>, and there is no <code>foo</code> declared there. It then widens the search to the full type <code>Derived</code> and it finds that there is a member function <code>foo</code>. At this point it stops <sup>*</sup>. If it had not find <code>Derived::foo(int)</code> it would keep expanding the search to the bases, then the namespace, then other namespaces...</p>

<p><sup>*</sup> In this particular case, because the identifier resolves to a function an extra step is taken as ADL kicks in (or rather would kick in if there were arguments of non-fundamental types passed to the function).</p>
",1
16459644,16459412,2,"<p>One reason your program doesn't run is because you likely destroy or corrupt what <code>this</code> points to by casting it to a <code>char*</code> and then reading data into it. This is almost certainly wrong and not what you want to do. </p>

<p>Also, please use C++ style includes. <code>&lt;iostream.h&gt;</code> went the way of the dodo before the dodo did. And don't <code>fflush</code> the <code>stdin</code> handle or mix C and C++ style IO.</p>
",3
15843248,15843222,5,"<p><code>Inner</code> is just a class defined at a different scope. It's no different than saying</p>

<pre><code>class Inner
{
public:
    int i;
    int retOuter(Outer *obj)
    {
        return obj-&gt;o;
    }
};
</code></pre>

<p>and then</p>

<pre><code>Inner::i =50
</code></pre>

<p>which obviously isn't possible because <code>i</code> isn't <code>static</code>. </p>

<p>Declaring an inner class doesn't automagically declare a member of that type for the outer class which you can access using that syntax.</p>

<p>Now, something like:</p>

<pre><code>class Outer
{
    int o;
public:
    void setOuter(int o)
    {
        this-&gt;o=o;
    }
    class Inner
    {
    public:
        int i;
        int retOuter(Outer *obj)
        {
            return obj-&gt;o;
        }
    } innerMember;
    //    ^^^
    // declare a member
};

int main(int argc, char **argv) {
    Outer *obj1=new Outer;
    obj1-&gt;innerMember.i =50; //Access the inner class members by Outer class object!
}
</code></pre>

<p>would work.</p>
",3
17770837,17770777,2,"<p>Of course it ends, after the <code>switch</code> statement there is nothing to continue the program.</p>

<p>You probably want a loop around the output and <code>switch</code>:</p>

<pre><code>bool go_on = true;

while (go_on)
{
    // Output menu...
    // Get choice

    switch (choice)
    {
        // All other cases...

    case 5:
        go_on = false;  // Tell loop to end
        break;
    }
}
</code></pre>

<hr>

<p>Oh, it seems that your problem is that you get an empty line... This is because after you get the <code>choice</code>, the stream leaves the newline in the input buffer, so when you do <code>std::getline</code> it reads that newline and not the input you want.</p>

<p>You can remove the trailing newline like this:</p>

<pre><code>std::cin &gt;&gt; choice;

// Skip trailing text, up to and including the newline
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n')
</code></pre>
",3
16443382,16443316,0,"<p>write a println function that takes a floating point and use it instead of cout, internally calling cout with precision</p>
",0
16443403,16443316,10,"<p>You are looking for <a href=""http://en.cppreference.com/w/cpp/io/manip/fixed""><strong><code>std::fixed</code></strong></a> together with <a href=""http://en.cppreference.com/w/cpp/io/manip/setprecision""><strong><code>std::setprecision</code></strong></a>.</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;
double f =1.1;
std::cout &lt;&lt; std::fixed;
std::cout &lt;&lt; std::setprecision(5) &lt;&lt; f &lt;&lt; std::endl;
</code></pre>

<p>stdout</p>

<pre><code>1.10000
</code></pre>
",0
16443433,16443316,3,"<p>try:</p>

<pre><code>std::cout.precision(5);
std::cout &lt;&lt; std::fixed;
std::cout &lt;&lt; a &lt;&lt; std::endl; //output a with fixed precision 5
</code></pre>

<p>see here :<a href=""http://www.cplusplus.com/reference/ios/fixed/"" rel=""nofollow"">std::fixed</a> for some example.</p>
",1
16443503,16443316,0,"<p>It is convenient to do:</p>

<pre><code>std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
std::cout.precision(x);
</code></pre>
",0
15514271,15513725,0,"<p>You could do this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

string commify(unsigned long long n)
{
  string s;
  int cnt = 0;
  do
  {
    s.insert(0, 1, char('0' + n % 10));
    n /= 10;
    if (++cnt == 3 &amp;&amp; n)
    {
      s.insert(0, 1, ',');
      cnt = 0;
    }
  } while (n);
  return s;
}

int main()
{
  cout &lt;&lt; commify(0) &lt;&lt; endl;
  cout &lt;&lt; commify(1) &lt;&lt; endl;
  cout &lt;&lt; commify(999) &lt;&lt; endl;
  cout &lt;&lt; commify(1000) &lt;&lt; endl;
  cout &lt;&lt; commify(1000000) &lt;&lt; endl;
  cout &lt;&lt; commify(1234567890ULL) &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>Output (<a href=""http://ideone.com/kVHRQh"" rel=""nofollow"">ideone</a>):</p>

<pre><code>0
1
999
1,000
1,000,000
1,234,567,890
</code></pre>
",0
15513809,15513725,1,"<p>EDIT:
I have two solutions. first without playing with numbers (<strong>recommended</strong>) and second (division).
first solution is:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;
using namespace std;

struct my_facet : public std::numpunct&lt;char&gt;{
        explicit my_facet(size_t refs = 0) : std::numpunct&lt;char&gt;(refs) {}
        virtual char do_thousands_sep() const { return ','; }
        virtual std::string do_grouping() const { return ""\003""; }
};

/*
 * 
 */
int main(int argc, char** argv) {

    cout&lt;&lt;""before. number 5000000: ""&lt;&lt;5000000&lt;&lt;endl;

    std::locale global;
    std::locale withgroupings(global, new my_facet);
    std::locale was = std::cout.imbue(withgroupings);

    cout&lt;&lt;""after. number 5000000: ""&lt;&lt;5000000&lt;&lt;endl;

    std::cout.imbue(was);

    cout&lt;&lt;""and again as before. number 5000000: ""&lt;&lt;5000000&lt;&lt;endl;

    return 0;
}
</code></pre>

<blockquote>
  <blockquote>
    <p>before. number 5000000: 5000000<br>
    after. number 5000000: 5,000,000 </p>
  </blockquote>
  
  <p>and again as before. number 5000000: 5000000 </p>
  
  <p>RUN SUCCESSFUL (total time: 54ms)</p>
</blockquote>

<p>and second (not recommended) is :</p>

<pre><code>double f = 23.43;
std::string f_str = std::to_string(f);
</code></pre>

<p>or this</p>

<pre><code>int a = 1;
stringstream ss;
ss &lt;&lt; a;
string str = ss.str();
</code></pre>

<p>Then you can use <code>string::substr()</code> <code>string::find()</code> <code>string::find_first_of()</code> and similar methods to modify and format your string.<br>
<a href=""https://stackoverflow.com/questions/5590381/easiest-way-to-convert-int-to-string-in-c"">a similar topic</a></p>

<hr>

<p>If you really want (have to) divide: (I think my version is cleaner &amp; more efficient than the others)</p>

<pre><code>unsigned long long userInput;
    std::stringstream ss,s0;
    std::string nr;
        std::cout &lt;&lt; ""Enter a long long number: "" &lt;&lt; std::endl;
        std::cin &gt;&gt; userInput;
        int input=userInput;
        int digits;

        while(input&gt;999){
            input=input/1000;
            digits=userInput-input*1000;
            int mdigits=digits;
            while(mdigits&lt;100){s0&lt;&lt;""0"";mdigits*=10;}
            std::string s=ss.str();
            ss.str("""");
            ss&lt;&lt;"",""&lt;&lt;s0.str()&lt;&lt;digits&lt;&lt;s;
            userInput=input;
            s0.str("""");
        }

        std::string sf=ss.str();
        ss.str("""");
        ss&lt;&lt;input&lt;&lt;sf;

        std::cout &lt;&lt; ""Your Number: "" &lt;&lt; userInput &lt;&lt; "";"" &lt;&lt; digits &lt;&lt;"";""&lt;&lt;ss.str()&lt;&lt;std::endl;
</code></pre>

<blockquote>
  <p>Enter a long long number:  12345678 Your Number: 12;345;12,345,678</p>
</blockquote>
",0
15513823,15513725,9,"<p>Is this what you need?  The locale will do this for you correctly.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main ( int argc, char * argv[] ) 
{
  unsigned long long userInput;
  int fthreeDigit;
  cout &lt;&lt; ""Enter a long long number: "" &lt;&lt; endl;
  cin &gt;&gt; userInput;
  std::cout.imbue(std::locale(""""));
  std::cout &lt;&lt; userInput &lt;&lt; std::endl;

  return 0;
}
</code></pre>
",2
15514014,15513725,0,"<p>Here is the brute force but may be easiest to understand way to get every thousand digits with the help of a vector.</p>

<pre><code>#include&lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
int main ( int argc, char * argv[] ) 
{
    long long userInput;
    int fthreeDigit;

   cout &lt;&lt; ""Enter a long long number: "" &lt;&lt; endl;
   cin &gt;&gt; userInput;
   vector &lt;int&gt; res;  //use vector to store every 3 digits
   while (userInput !=0)
   {
     fthreeDigit = userInput %1000;
     res.push_back(fthreeDigit);
     userInput = userInput / 1000 ;
   }

   std::reverse(res.begin(), res.end());
   for (size_t i = 0; i &lt; res.size()-1; ++i)
   {
     if (res[i] ==0)
     {
        cout &lt;&lt; ""000""&lt;&lt;"","";
     }
     else
     {
       cout &lt;&lt; res[i] &lt;&lt; "","";
     }
   }

   if (res[res.size()-1] == 0)
   {
       cout &lt;&lt; ""000"";
   }
   else{
       cout &lt;&lt; res[res.size()-1];
   }
   cout &lt;&lt;endl;
   cin.get();
   return 0;
}
</code></pre>

<p>I tested this code with the following case:</p>

<pre><code>Input: 123456 Output: 123,456
Input: 12     Output: 12
Input: 12345  Output: 12,345
Input: 1234567 Output: 1,234,567
Input: 123456789 Output: 123,456,789
Input: 12345678 Output: 12,345,678
</code></pre>

<p>I guess this is what you want according to your response to comments.</p>
",7
18305299,18305206,2,"<p>It is a legal way of doing it, but using <code>i--</code> as a condition in a for loop is a terrible idea in terms of readability.</p>

<p>The for loop is meant to consist of 3 parts - why make people lives harder?</p>

<p>People who read your code will be happy if you stick to the traditional <code>for</code> loop:</p>

<pre><code>for (int i = v.size() - 1; i &gt;= 0; i--) {
    ///Stuff.
}
</code></pre>
",0
18305313,18305206,4,"<p>One could think of a <code>for</code> loop</p>

<pre><code>for (&lt;decl-init&gt; ; &lt;condition&gt; ; &lt;post-adjust&gt;) &lt;body&gt;
</code></pre>

<p>as a rough equivalent to this <code>while</code> loop:</p>

<pre><code>&lt;decl-init&gt;;
while (condition) {
    &lt;body&gt;;
    &lt;post-adjust&gt;;
}
</code></pre>

<p>The biggest difference between the <code>for</code> and the rewrite above is the scope of variables declared in the <code>&lt;decl-init&gt;</code> block, but this is not important for the analysis below.</p>

<p>Rewriting both loops as a <code>while</code> loop gives you this:</p>

<pre><code>int i = v.size() - 1;
while ( i &gt;= 0 ) {
    &lt;body&gt;;
    i--;
}
</code></pre>

<p>vs.</p>

<pre><code>int i = v.size(); 
while (i--) {
    &lt;body&gt;;
}
</code></pre>

<p>As you can see, the only difference is that <code>i</code> is decremented before entering the iteration, and the condition is started with <code>i</code> greater by <code>1</code> than in the first loop. These two adjustments ""cancel each other"", making your loops equivalent from the technical point of view. Aesthetics is a different thing, though: conditions with side effects are harder to understand than ""pure"" ones, so the first loop is more readable.</p>
",0
18141590,18141521,2,"<p>This is the question of data hiding. Whether you want to unveil internal class fields or not. If you are shipping a classes library and want to hide the implementation details then it is better to show in the interface as few entities as possible, then even a declaration of the private field <code>member</code> is too much.</p>

<p>I would just declare this value as a static variable inside a <code>.cpp</code> file.</p>
",0
18141899,18141521,6,"<p>If, as it was before the question was changed to make it static, it's a non-static member, then it can only be initialised in the constructor's initialiser list or (since 2011) in the member's declaration. Your second example was ill-formed.</p>

<p>If it's static, then you need a definition if it's <em>odr-used</em>: roughly speaking, if you do anything that requires its address rather than just its value. If you only use the value, then the first example is fine. But note that the comment is wrong - it's just a declaration, not a definition.</p>

<p>If you do need a definition, then it's up to you whether you specify the value in the declaration or the definition. Specifying it in the declaration allows better scope for optimisation, since the value is always available when the variable is used. Specifying it in the definition gives better encapsulation, only requiring one translation unit to be recompiled if it changes.</p>

<blockquote>
  <p>What happens for example with an inline method defined in the header that access member? Will it simply be not inlined?</p>
</blockquote>

<p>There's no reason why accessing a data object defined in another translation unit should prevent a function from being inlined.</p>
",2
15846409,15835968,0,"<p>This is how it was supposed to be done.</p>
<pre><code>#define G15_DEVICE_G510 32
#define G510_STANDARD_KEYBOARD_INTERFACE    0x0
</code></pre>
<p>then at a later point in the code</p>
<pre><code>  int setG510LEDColor(unsigned char r, unsigned char g, unsigned char b);
</code></pre>
<p>i managed to find a file with it from <a href=""http://g15tools.svn.sourceforge.net/viewvc/g15tools/trunk/libg15/libg15.h?view=markup&amp;pathrev=324"" rel=""nofollow noreferrer"">here</a></p>
<p>then i'd need to edit a line i had to this.
DEVICE(&quot;Logitech G510&quot;,0x46d,0xc22d, <code>G15_LCD|G15_KEYS|G15_DEVICE_5BYTE_RETURN|G15_DEVICE_IS_SHARED|G15_DEVICE_G510),</code>
the code for it was originally written by a guy who calls himself &quot;multitude&quot;</p>
<p>So thanks multitude :)</p>
",0
18123208,18123121,3,"<p>The constructors doesn't return a value, they are simply called as part of the object construction, and the actual ""returning an object"" is the job of the compiler and its generated code.</p>

<p>For example, lets say you have a class <code>Foo</code>, then when declaring a variable of that class</p>

<pre><code>Foo myFoo;
</code></pre>

<p>the compiler creates the object for you, and calls the appropriate constructor</p>
",6
18123326,18123121,2,"<p>The default constructor doesn't return a value. It is simply called at the object construction.</p>

<p>From the standard :</p>

<blockquote>
  <p><strong>12.1 Constructors [class.ctor]</strong></p>
  
  <p>A default constructor for a class X is a constructor of class X that can be called without an argument. If there is no user-declared constructor for class X, a constructor having no parameters is implicitly declared as defaulted (8.4). An implicitly-declared default constructor is an inline public member of its class.</p>
  
  <p><strong>[....]</strong></p>
  
  <p>No return type (not even void) shall be specified for a constructor. A return statement in the body of a constructor shall not specify a return value. The address of a constructor shall not be taken.</p>
</blockquote>

<p>Here is an example of use :</p>

<pre><code>class Foo
{
public:
    Foo() {} // User defined default constructor
};
Foo myFoo;
</code></pre>
",0
16470092,16470044,3,"<p>Remove the semi-colon on the first error line :)</p>

<p>Instead of a function definition, the semi colon makes it an attempted function call followed by braces which doesn't make sense - its confusing the compiler.</p>

<pre><code>inSyllable(char isSyllableStarting);{ //This one here.
</code></pre>

<p>Also note that it should have a return type.  Its looking for a constructor because your function definition has none.</p>

<hr>

<p><strong>More Errors:</strong> You have more wrong here than just that.  For example, if you space your current code well at the error location, you get this mess:</p>

<pre><code>inSyllable(char isSyllableStarting);
{
    if (numSyllables = 'a','e', 'i', 'o', 'u'){
        return true;
    }
    inSyllable( char isSyllableEnding);
    {
        else{
            return false;
        }
</code></pre>

<p><strong>So, here's a list of problems:</strong></p>

<ol>
<li>Semi colon shouldn't be there on top line before function brace open.</li>
<li>Your if is followed by a recursive call to your function instead of the else which is mistakenly further down.</li>
<li>Your braces don't add up - this function never ends from the code above.</li>
</ol>
",6
15576287,15576255,5,"<p>I think your first <code>if</code> condition should be checking if it is greater than 1225 AND less than 27225:</p>

<pre><code>if ((pow(X, 2))+(pow(Y, 2)) &lt;= 27225 &amp;&amp; ((pow(X, 2))+(pow(Y, 2)) &gt;= 1225))
//                              Here ^^
</code></pre>

<p>As you have it, the condition will be met for every possible value of <code>X</code> and <code>Y</code>; every number is either less than 27225 or greater than 1225.</p>

<p>For the second condition, just do <code>else</code> instead:</p>

<pre><code>if ((pow(X, 2))+(pow(Y, 2)) &lt;= 27225 &amp;&amp; ((pow(X, 2))+(pow(Y, 2)) &gt;= 1225)) {
  // Distance from origin is within range
} else {
  // Distance from origin is outside range
}
</code></pre>

<p>Note that <code>or</code> and <code>and</code> are not commonly used, as they are alternative tokens for <code>||</code> and <code>&amp;&amp;</code>. I would recommend sticking to <code>||</code> and <code>&amp;&amp;</code> for consistency with most other developers.</p>
",9
15576414,15576255,0,"<p>From your coding, it doesn't look like you have defined the data type of X, Y. 
Instead of </p>

<pre><code>X = x * 10;
Y = y * 10;
</code></pre>

<p>Instead, try </p>

<pre><code> int X = x * 10;
 intY = y * 10;


if (((pow(X, 2))+(pow(Y, 2)) &gt; 27225)) {
  cout&lt;&lt;""\n\nThe values you have chosen for the centre points are to not  compatible   with our program. Please choose smaller values."";//new
}
else if( ((pow(X, 2))+(pow(Y, 2)) &lt;1225))
{
        cout&lt;&lt;""\n\nIf you do not understand, please ask the programmer for further  explanation."";
}
</code></pre>

<p>This would give you the two different results as expected</p>
",3
15576748,15576061,1,"<p>This issue is that your program is using a different encoding than the one the console expects. Windows is configured this way by default; programs use encodings like cp1252 or cp1254 and the console expects something else like cp437.</p>

<p><a href=""http://www.siao2.com/2005/02/08/369197.aspx"" rel=""nofollow"">Here's</a> an article from a Microsoft developer that explains why this is.</p>

<p>There's already a lot of information online covering the numerous ways you can fix the encoding mismatch.</p>
",1
16421933,16421895,2,"<p>It depends on the function. If they are inlined you pay nothing. If they are not you pay one jump. The costs of it you can not easily predict. it depends on the address you are jumping to as it may occur as TLB miss.</p>

<p>Obviously you have to take into account things like optimization levels etc. 
General rule is that if you dont call it in the loop you should aim rather for code readablity than such small optimizations.</p>
",0
16421947,16421895,2,"<p>The second option results in clearer code. It will easier to maintain your code and better for you to test them separately. Though there will be some cost for function calls,  modern compilers may optimize the cost away.</p>
",0
16421951,16421895,6,"<p>It depends:</p>

<ul>
<li>On the overall overhead for function calls on the target architecture.</li>
<li>On the overhead of passing any arguments.</li>
<li>On the overhead of handling any return values.</li>
<li>On whether or not the compiler decides to inline the calls.</li>
</ul>

<p>The version with the separate steps broken out into their own functions (which, crucially, provides them with <em>a name</em>) is much much better and should be preferred in all cases, and only removed if serious profiling and testing proves that the manually inlined version is really better.</p>

<p>This of course can only happen if the code in question is on a performance-critical path to begin with.</p>
",1
16421958,16421895,1,"<p>It depends on the hardware and how often you'll be making calls. But in general, unless your target audience has something absurdly ancient, it should not harm performance significantly.</p>

<p>In general, it's far better to have code readable and maintainable than to worry about performance.</p>
",0
16421967,16421895,6,"<p>If the code is ""known"" in the compile unit, and the function is not overly complex, most modern compilers will inline the code anyway. If the function is also declared <code>static</code>, then it will not generate a ""real function"". </p>

<p>Edit 3:</p>

<p>Explanation on <code>static</code>: When a free function (not a member of a class) is available to make inline, if the compiler isn't sure that all places this function is called are inlined, it produces an out-of-line function (aka ""real function"") as well. </p>

<p>If a free function is declared <code>static</code> it tells the compiler that this function is ""local to this compile unit"", so nothing else will ever call this function. If the compiler then inlines all calls in this compile unit, then it doesn't need to produce an ""out-of-line"" function as well, since the compiler can know all the calls to the function. </p>

<p>Note also that taking the address of a function will also force the compiler to make an out-of-line function, since the function pointer must point somewhere [although under very special circumstances, I've seen compilers inline functions called through function pointers too]</p>

<p>As with all performance matters, if it's really critical in your application, then benchmarking the actual code (and different variants of it), and profiling, is key to getting things right. There is no such thing as ""this is the right answer"", different compilers (on different platforms) with different settings will do different things. </p>

<p>Edit: Unless there is evidence that the code is worthwhile the penalty of being less readable, don't sacrifice readability for optimisation. Very little of the overall code is typically important for performance anyway. </p>

<p>Edit2: If you can also REUSE some of the code in other functions, that's an extra bonus. But making code readable is the key goal of splitting into functions in the first place, typically. </p>
",1
16422089,16421895,2,"<p>In your first example I assume you are coding each task inline. This will be faster in general.</p>

<p>As I understand it: 
The penalty you pay in the second example is a small one. You'll be allocating any memory you need for the parameters onto the stack (assuming you'll be passing by value here). You might find <a href=""http://www-ee.eng.hawaii.edu/~tep/EE160/Book/chap14/subsection2.1.1.8.html"" rel=""nofollow"">this link a nice read</a>.
Depending on the number of function calls within each of those sub tasks, the depth of your stack will get larger and larger. If you plan on calling hugely recursive functions within any of those you'll be getting down to a recursive limit and your program might run out of memory if you're not careful. 
If you wanted to, you could generate the assembly for the code you have and look at how it's actually calling the functions. A JMP in the assembly or some other type of GoTo operation will probably need to resolve whatever label its going to and that might add a small amount of time depending on the size of your program. Really though, you're not incurring much overhead by using the functions. And if you declared them inline, they'd be written inline by the compiler for code execution and would run just as fast as if you'd written them that way in the first place. <a href=""http://www.parashift.com/c++-faq/inline-functions.html"" rel=""nofollow"">You can check out more on inline functions here</a></p>

<p>My personal opinion is that the second way is the way to go if each of those sub tasks are fairly independent from each other and/or large blocks of code. It will be easier to maintain and track down any errors if you run into them. Hope that helps!</p>
",0
16422097,16421895,0,"<p>In general no.</p>

<p>Calls are very fast and do not influence the overall performance that much. If your tasks are very havy you cannot measure the performance loss. If the task is very small the compiler will probably inline it, which means the call is removed by optimization automatically.</p>

<p>Calls become more expensive if:</p>

<ol>
<li>There are lots of parameters</li>
<li>The parameters are non-elementary types as std::string and get copied. You can avoid this by using references (const std::string&amp;)</li>
<li>The call is virtual (only possible in classes where you used polymorphy)</li>
</ol>

<p>To check the performance for a special case (your program) you can use a porfiler. Such programs will tell you were the most performance is lost. Start to optimize there.</p>
",0
18160890,18160290,0,"<p>I believe the applicable part of the standard in this case is ¡ì3.3.7/1:2 and 3:</p>

<blockquote>
  <p>2) A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S. No diagnostic is required for a violation of this rule.</p>
  
  <p>3) If reordering member declarations in a class yields an alternate valid program under (1) and (2), the program is ill-formed, no diagnostic is required.</p>
</blockquote>

<p>The name <code>Money</code> used in the definition of <code>Person</code> in the context of the definition of the return type of <code>Person::get</code> refers to <code>::Money</code>, but when reevaluated in the completed scope of <code>Person</code> refers to <code>::Person::Money</code>. </p>

<p>Likewise, reordering the member declarations so the <code>typedef</code> of <code>Person::Money</code> precedes that of <code>Person::get</code> yields a an alternate valid program.</p>

<p>As such, it appears that your code is ill-formed, but since no diagnostic is required both VC++ and gcc are equally conforming in this regard. I certainly prefer that the violation be diagnosed (as gcc does) rather than accepted silently (as VC++ does).</p>
",0
17392369,17392218,8,"<p>Assuming you want your data stored as floating point numbers (not strings) you probably want to do something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;

int main() { 
    std::ifstream in(""Qi.txt"");

    // initialize the vector from the values in the file:
    std::vector&lt;double&gt; lines{ std::istream_iterator&lt;double&gt;(in),
                               std::istream_iterator&lt;double&gt;() };

    // Display the values:
    for (int i=0; i&lt;lines.size(); i++)
         std::cout &lt;&lt; ""lines["" &lt;&lt; i &lt;&lt; ""] = "" &lt;&lt; lines[i] &lt;&lt; '\n';
}
</code></pre>

<p>Just a quick note on style: I prefer to see variables fully initialized right when you create them, so <code>std::ifstream in(""Qi.txt"");</code> is preferable to <code>std::ifstream in; in.open(""Qi.txt"");</code>. Likewise, it's preferable to initialize the vector of lines directly from istream iterators rather than create an empty vector, then fill it in an explicit loop.</p>

<p>Finally, note that if you insist on writing an explicit loop anyway, you <em>never</em> want to use something like <code>while (somestream.good())</code> or <code>while (!somestream.eof())</code> to control your loop -- these are mostly broken, so they don't (dependably) read a file correctly. Depending on the type of data involved, they'll frequently appear to read the last item from the file twice. Usually, you want something like <code>while (file &gt;&gt; value)</code> or <code>while (std::getline(file, somestring))</code>. These check the state of the file immediately after reading, so as soon as reading fails they fall out of the loop, avoiding the problems of the <code>while (good())</code> style.</p>

<p>Oh, as a side note: this is written expecting a compiler that (at lest sort of) conforms with C++11. For an older compiler you'd want to change this:</p>

<pre><code>    // initialize the vector from the values in the file:
    std::vector&lt;double&gt; lines{ std::istream_iterator&lt;double&gt;(in),
                               std::istream_iterator&lt;double&gt;() };
</code></pre>

<p>...to something like this:</p>

<pre><code>    // initialize the vector from the values in the file:
    std::vector&lt;double&gt; lines(( std::istream_iterator&lt;double&gt;(in)),
                                std::istream_iterator&lt;double&gt;() );
</code></pre>
",6
17392270,17392218,5,"<p>First you'll need a vector:</p>

<pre><code>std::vector&lt;std::string&gt; lines; // requires #include &lt;vector&gt;
</code></pre>

<p>Then you'll need to take a string taken from the <code>getline</code> operation, and push it back into the vector. It's very simple:</p>

<pre><code>for (std::string line; std::getline(myReadFile, line);) 
{
    lines.push_back(line);
}
</code></pre>

<p>For an output operation, all you need is:</p>

<pre><code>{
    int i = 0;

    for (auto a : lines)
    {
        std::cout &lt;&lt; ""lines["" &lt;&lt; i++ &lt;&lt; ""] = "" &lt;&lt; a &lt;&lt; std::endl;
    }
}
</code></pre>
",4
15503785,15503679,1,"<p>Use <a href=""http://www.cplusplus.com/doc/tutorial/templates/"" rel=""nofollow"">templates</a> and move the code you had in <code>f()</code> that would use <code>b</code> inside <code>DoStuff()</code>.</p>

<pre><code>template &lt;class Type&gt;
void DoStuff()
{
  Type b;  //use type 'Type' to define b      
}

void f(){

  if(a==1){
    DoStuff&lt;T&gt;();
  } else{
    DoStuff&lt;TT&gt;();
  }

}
</code></pre>
",7
15851319,15850972,0,"<p>A variable <code>counter</code> for each range is not really what you want to be doing, you just want one array:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {

  // count array for brackets 0 to 10
  int *count = new int[11];
  // variable to store each mark read
  int mark;

  // Read in marks
  while (cin &gt;&gt; mark) {
    // Increment the count for the bracket the mark falls in 
    count[mark/10]++;
  }

  for (int i=0;i&lt;11;i++) {
    cout &lt;&lt; i &lt;&lt; ""\t| "" &lt;&lt; string(count[i],'*') &lt;&lt; endl;
  }

}
</code></pre>

<p>This plots a horizontal histograms but shows the much simple way it should be done.</p>

<pre><code>$ ./histogram.out &lt; marks
0   | ******
1   | *********
2   | **********
3   | ************
4   | *********
5   | *****************
6   | ********
7   | *********
8   | ***
9   | ****
10  | *
</code></pre>

<p>You will have less headaches modifying this code, try increasing the number of brackets to 1000 in original code! </p>
",3
15883225,15883214,5,"<p>The correct header is <code>&lt;string&gt;</code>. Change the include directive to:</p>

<pre><code>#include &lt;string&gt;
</code></pre>

<p>The C++ standard library headers <em>do not</em> end with <code>.h</code>.</p>

<p>It's considered very bad practice to do <code>using namespace std;</code>, especially in a header file. This pollutes the global namespace with names from the <code>std</code> namespace and propagates said pollution to any file that includes it.</p>
",0
15883336,15883214,2,"<p>In C,</p>

<pre><code>#include &lt;string.h&gt;
</code></pre>

<p>gives you the C string header (<code>strlen()</code>, <code>strcmp()</code> et al.).</p>

<p>In C++,</p>

<pre><code>#include &lt;string.h&gt;
</code></pre>

<p>is deprecated, but gives you the same C string header. You are encouraged to use</p>

<pre><code>#include &lt;cstring&gt;
</code></pre>

<p>instead, which gives you the same functions but in the <code>std::</code> namespace (where they belong).</p>

<p>If you want <code>std::string</code>, the object-oriented auto-allocating auto-expanding C++ niceness, you would have to:</p>

<pre><code>#include &lt;string&gt;
</code></pre>

<p>And please, don't use <code>using namespace</code>, <em>especially</em> not in combination with <code>std::</code>. The idea is to be <em>explicit</em> about which namespace a given identifier comes from.</p>

<p><strong>Edit:</strong> Seconding sftrabbit, who typed quicker than me. While <code>using namespace</code> might be pardonable in your .cpp files, in headers it's a capital offense, because including your header could make perfectly valid C++ code invalid all of a sudden, because you changed the namespace.</p>
",1
16452331,16451842,0,"<p>It looks like your <code>Name_pairs::read_ages()</code> method reads from <code>cin</code> until the stream is closed.  When you call <code>fill</code> the first time, it reads until the stream is closed.  When you call <code>fill</code> for your second <code>Name_pairs</code> instance, <code>cin</code> has already been closed, so nothing is able to be read, leaving your vectors empty for <code>test1</code>.</p>
",3
16440925,16440792,1,"<p>Just continue with the nesting:</p>

<pre><code>int array[4][3][2] = {
    { {  1,  2 }, {  3,  4 }, {  5,  6 } },
    { {  7,  8 }, {  9, 10 }, { 11, 12 } },
    { { 13, 14 }, { 15, 16 }, { 17, 18 } },
    { { 19, 20 }, { 21, 22 }, { 23, 24 } }
};
</code></pre>

<p>And so on</p>
",1
15808625,15808494,0,"<p>You can't sleep precisly under Windows (maybe the Windows Performance counter functions help, see <a href=""https://stackoverflow.com/questions/7827062/is-there-a-windows-equivalent-of-nanosleep"">Is there a Windows equivalent of nanosleep?</a>).</p>

<p>You said that you run many simulated CPU's concurrently in threads, so one possible solution is to throw the threads away and do the Schedueling for the different CPU's yourself (round robin).</p>
",0
15808691,15808494,0,"<p>You don't need any special sleep resolution. At the end of each loop, just compute whether you need to sleep or not. If not, run the next loop. If so, sleep for the calculated amount. It won't matter if you sleep a little extra on one loop because this logic will make you sleep less on the next loop.</p>
",8
15809725,15808494,0,"<p>If you are using a C++11 compiler, have a look at <code>&lt;chrono&gt;</code>. There you can find high precision timers. But be aware, that in a windows environment, these still have low accuracy, which Microsoft will hopefully fix in the next release.</p>
",0
15534249,15533872,3,"<p><code>System::String^ j;</code> is a C++/CLI String which is Microsoft's implementation of C++ on top of the .NET framework, so you can communicate from it with .NET languages (C#, VB.NET) and still use C++.  The <code>^</code> is a garbage collected pointer used by C++/CLI.  This means that you do not have to care about cleaning up after yourself when having used <code>gcnew</code></p>

<p><code>std::string</code> is the C++ Standard Library's version of a string.  It's <em>native C++</em> as some may call it. </p>

<p>In C++ each time you use <code>new</code> with a pointer, yuck, you must not forget to call <code>delete</code>.  </p>

<p><code>System::Convert::ToString</code> is also C++/CLI from Microsoft.</p>

<p><code>std::to_string</code> would be the C++11 equivalent of that.</p>

<p>The implementations are quite different, so you cannot expect to get the same results with these different types. </p>
",0
15534265,15533872,0,"<p>The source of your confusion is probably that you are using C++/CLI, so you have access to many different string types. C++/CLI was developed to give you access to both worlds:</p>

<ol>
<li>Unmanaged: this is basically native, standard C++ code. While C++/CLI in no way conforms to the C++ standard, it does allow you to mix C++ code in: you can use most C++ libraries (through the ""it just works paradigm""). This code is called ""unmanaged"" because you have to do your own memory management.</li>
<li>Managed: This is the .NET side of things. Using .net classes, you have access to the useful libraries that microsoft puts out, as well as can work with the garbage collector.</li>
</ol>

<p>System::String is the managed, .NET string type. This is the type of string that all .NET languages use (C#, VBA, ect). This is a class that will only be able to use with C++/CLI &amp; .NET. Use this type if you are writing pure Windows code, or if want to write a .NET library. In these languages, the ""to string"" function is actually a member of all classes, and the cast is often implicit. You can use </p>

<pre><code>j = valor1+"",""+valor2;
</code></pre>

<p>If you want to get explicit, look into the Int::ToString function:</p>

<pre><code>System::String^ j= Int32(1).ToString();
</code></pre>

<p>std::string is the unmanaged, stl string. This is the standard C++ class, and is available to both C++ and C++/CLI. You will have to marshal this class if you want to use it with other .NET classes. Use this class if you are trying to stay completely in the unmanaged code.</p>

<p>If you are trying to learn C++, I'd suggest turning off C++/CLI for now, and sticking with the standard library string.</p>
",2
16427646,16427550,3,"<p>Your incrementing f twice - once in the for loop and once at the end of your block statement. Get rid of the last <code>f++;</code> in your statement.</p>
",1
16427724,16427550,5,"<p>The <code>e</code> starts off one value too high, and you're incrementing <code>f</code> too many times.</p>

<pre><code>            for (e--; e &gt;= f; f++)
            {
                if (d[f] != d[e-f])
                    g = false;
            }
</code></pre>
",1
16379230,16379205,6,"<p>Your computer has plenty of memory, but only so much of it can be allocated on the stack. Try allocating it on the heap instead:</p>

<pre><code>Bacon **bacs = new Bacon*[objs];
</code></pre>

<p>and later:</p>

<pre><code>delete[] bacs;
</code></pre>
",2
16379231,16379205,1,"<p>You're probably out of stack space.</p>

<p>You allocate huge array of pointers right on stack. Stack is limited resource (usually 8 megabytes per process). Size of pointer is usually 4 or 8 bytes; multiply it by one million and you overrun that limit.</p>
",2
16379307,16379205,0,"<p>As I learned, when you request for space from memory, if the operation system, which you use(Windows in this case, I think), lets you to take it, you can take and use that space. </p>

<p>For some reason, Windows may not be letting you to take that memory for this situation. But I'm not that much expert in this field. I am stating this as a thought.</p>
",1
16379318,16379205,0,"<p>The default stack size (windows visual studio 2005, probably others keep the same number) is 1MB, check out <a href=""http://msdn.microsoft.com/en-us/library/tdkhxaks%28v=vs.80%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/tdkhxaks%28v=vs.80%29.aspx</a> to change it</p>

<p>ulimit in linux to change it.</p>

<p>The heap solution is valid too, but in your example you don't need heap. Requesting heap memory to the OS for something that won't escape the current function is not a good practice. In assembler the stack is translated just to a bigger subtraction, heap is requested thru other methods that require more processing.</p>
",2
15861550,15861525,2,"<p>Assuming your files is 999 chars or less, this should work (no error checks added).
There is no need to use strcat. As a matter of fact, it's stupid to use strcat here.</p>

<pre><code>ifstream infile;
infile.open( ""Gmv.txt"", ifstream::in);

char result[1000]; 
int i = 0;
while (infile.good())
{       
    result[i] = infile.get();
    ++i;
}

result[i] = 0; // Add the '\0' at the end of the char array read.

infile.close();
</code></pre>

<p>strcat takes a char array terminated by 0 ('\0') as the 2nd param. your char isn't terminated by 0. Hence you get the bad pointer error.</p>

<p>BTW, you can shorter the while to this</p>

<pre><code>while (infile)
    result[i++] = infile.get();
</code></pre>
",3
15861566,15861525,1,"<p>Why use an array as a string, when C++ have <code>std::string</code>:</p>

<pre><code>std::string result;
char ch;

while (infile &gt;&gt; ch)
    result += ch;
</code></pre>
",2
17387201,17387118,11,"<p>This primarily applies to the portions of the standard C++ library that have been ""inherited"" from C. In pre-C89 standards of the C language the significant portion of external identifiers has been limited to 6 characters; linkers were allowed to ignore the remaining characters. That is why the standard C library limited identifier length to 6 characters. C++ incorporated that library ""wholesale"", along with somewhat cryptic identifiers.</p>
",2
17387244,17387118,0,"<p>C++ inherits from C which was built long-long ago by programmers who were used to working in assembler.</p>

<p>But I think it goes deeper into the mathematical background of programmers. There were early attempts to make languages easier to understand by using English terms, COBOL and SQL are probably the only survivors. But since words in programming languages have a very precise meaning, using 'SELECT' rather than a colon only helps a small amount, you still need to know all the details of SQL to write the rest of the query.</p>

<p>Short identifiers make the code easier to understand for experienced programmers, you can see and parse more of the structure in a single glance. If you ever have to read scientific papers from the C17-C18 where they use a page of prose to describe what we would write in a single equation - you will understand.</p>
",0
17387303,17387118,1,"<p>There are parts of the C++ Standard libraries that are derived from the older C Standard Library.  The older C Standard Library in turn was derived from the older K&amp;R library that provided some of the basic functionality through functions which in other languages are built into the language such as Input/Output.</p>

<p>This section of the book <a href=""http://books.google.com/books?id=yxLISD0TAbEC&amp;lpg=PA20&amp;ots=tDUzoDW4jE&amp;dq=length%20of%20external%20identifiers%20in%20C&amp;pg=PA20#v=onepage&amp;q=length%20of%20external%20identifiers%20in%20C&amp;f=false"" rel=""nofollow"">Rationale for the ANSI C Programming Language</a> provides a description of the naming conventions for C identifiers.</p>

<p>The C programming language is compiled and the machine code output of the compiler is linked together into the actual applications.  The software that does the linking is typically part of the standard tools offered by an operating system vendor.  A survey of the available linker applications offered by various vendors found that the most basic provided six characters for the external identifiers that could be processed by the linkers.  Some linkers allowed more however by specifying a limit of six characters, the list of available target computers for C compilers was much larger.</p>

<p>By staying with the limits of the linkers, it allowed C programmers to write C programs and function libraries that could be used with software written in other languages as well as allowed the use of libraries written in other languages to be used by C programmers.</p>
",0
16380721,16380577,-1,"<p>I solved the problem. I had a broken compiler (or something like that). My suggestion for other people with this problem is to experiment with different versions of the minGW compiler. Also, change the version of code blocks you are using, or even uninstall everything and restart. The problem with mine was I downloaded a bad compiler. [The truth is, codeblocks isn't the best ide.]</p>
",2
15859310,15859288,7,"<p>You should not use one-letter, meaningless variable names. Otherwise you would have noticed the error:</p>

<pre><code>if ( a &gt; 40 )
</code></pre>

<p>You wanted to compare the number of hours, but you did compare the salary.</p>
",0
16386160,16386083,1,"<p>The error message is pretty clear.</p>

<pre><code>if(comp(*it, *hayStackIterator))
</code></pre>

<p><code>*it</code> has type <code>const std::pair&lt;int, std::string&gt;&amp;</code>, but <code>*hayStackIterator</code> has type <code>const char&amp;</code>. You can't compare them.</p>
",0
15562418,15561097,0,"<p><code>vector&lt;int&gt; s[10];</code>Means ""s"" is a array, and it have 10 elements, each of its element's type is <code>vector&lt;int&gt;</code>.</p>

<p><code>vector&lt;int&gt; s(10);</code>Means ""s"" is a <code>vector&lt;int&gt;</code>, and this vector's size is 10, but this is not a declaration.</p>

<p>There can be much more complex declarations, when declare a function pointer which point to the kind function who have a lot of parameters and complex return value.</p>

<p>For example:</p>

<p><code>vector&lt;int&gt; (*func[10])(int *);</code>
This declare the pointer point to a function who receive <code>int *</code> parameter, and return a<code>vector&lt;int&gt;</code> value, plus it is an array of this kind pointer, the size of the array is 10.</p>
",0
15561113,15561097,10,"<p>The first one is an array of 10 empty vectors.</p>

<p>The second one is a single vector initialised with 10 elements.</p>
",0
15561128,15561097,2,"<p>It is a mix of std::vector and built-in array types. Specifically an array of <code>std::vector</code>;</p>

<pre><code>vector&lt;int&gt; s[10];
</code></pre>

<p>means create 10 vector objects. You can think of it like:</p>

<pre><code>vector&lt;int&gt; s0;
vector&lt;int&gt; s1;
...
vector&lt;int&gt; s10;
</code></pre>

<p>The number of vector objects is fixed. The number of items in each vector can vary.</p>
",1
15561197,15561097,0,"<p>Vector has a constructor like this:</p>

<pre><code>vector (size_type n);
</code></pre>

<p>So the second is just declare a vector of int with size of 10.</p>
",0
17080009,17079989,5,"<p>Yes, it's normal, you cannot call constructor manually. It's not a function. It makes no sense to call c-tor on an already constructed object.
<Blockquote><P>
Because constructors do not have names, they are
never found during name lookup; however an explicit type conversion using the functional notation (5.2.3)
will cause a constructor to be called to initialize an object. [ Note: For initialization of objects of class type
see 12.6. ¡ª end note ]</P></Blockquote></p>
",0
17080022,17079989,2,"<p>It doesn't really make sense to construct an object and then call its constructor again. </p>

<p>The line </p>

<pre><code>box box1;
</code></pre>

<p>creates an instance and calls its default constructor.</p>

<p>You cannot create the same instance again after it's been created. What you're probably looking for is an assignment operator, not a construtor.</p>
",1
17080116,17079989,3,"<p>First note that your code does not even compile. We'll get to that in a minute.</p>

<p>This line:</p>

<pre><code>box box1;
</code></pre>

<p>attempts to create a box object. After the ; box1 is a fully fledged box object. Well, it would be if the code could compile. But it can't because box doesn't have a default constructor. You can't create a box instance with no arguments - you must give it a double. In the next line you try to do that, but it's too late - a constructor is only called at object creation.</p>

<p>So you must do this instead:</p>

<pre><code>box box1(10.0);
</code></pre>
",0
16403807,16403733,0,"<p>In your current model, you actually can't access any of the fields of car, because by default in C++ when using the <code>class</code> keyword, all fields are <code>private</code>.  They need to be <code>protected</code> or <code>public</code> in order for a sub-class to access them.</p>
",0
16403832,16403733,1,"<p>You need to define constructors and subsequently use them properly. During initialization of a derived class, you should always call the appropriate constructor of the base class:</p>

<pre><code>Derived::Derived(...):Base(...),&lt;optional initizaliation of Derived members&gt;{...}
</code></pre>

<p>For example:</p>

<pre><code>class car
{
    string carID;
    string carName;
public:
    car(string carid, string carname):carID(carid),carName(carname){}
};

class electric : public car
{
    string battery;
    string model;
public:
    electric(string carid, string carname, string battery, string model)
    :car(carid,carname),battery(battery),model(model){}
};
</code></pre>
",3
16403847,16403733,0,"<p>You should initialize base class members by calling the base class constructor at the derived class's constructor initialization list.</p>

<pre><code> class car
 {
    string carID
    string carName
    public:
       car (string id, string name): carID(id), carName(name) {}
 };

 class electric : public car
 {
   string battery
   string model
   public:
      electric (string id, string name, string b, string m): car(id, name), 
                                                battery(b), model(m){}
 };
</code></pre>
",0
16388471,16388439,6,"<p>The problem is that you don't have a copy constructor and you have a dynamically allocated member data.</p>

<pre><code>void SomeFunc(Sample x)
</code></pre>

<p>creates a new copy of <code>s1</code>. And <code>x</code> and <code>s1</code> 's <code>ptr</code>s will <strong>be pointing to the same location</strong>. Once the function <code>SomeFunc</code> returns that memory is deleted (<strong>when x is destroyed</strong>.)</p>

<p>And when main returns <code>s1</code> is destroyed. Now your destructor tries to <code>delete</code> a memory location which is <strong>already deleted</strong> and you have <code>double free or corruption</code> error.</p>

<hr>

<p>A simple copy constructor for your case</p>

<pre><code>Sample(const Sample&amp; s)
{
    ptr = new int(*(s.ptr));
}
</code></pre>

<hr>

<p>You don't really seem to use pointers and dynamic allocation here. However if you have to use dynamic allocation consider taking a look at <a href=""https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three""><strong>Rule of three</strong></a> and <a href=""https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one""><strong>smart pointers</strong></a>. </p>
",2
16388609,16388439,0,"<p>For any class that inludes resources that need to be released in the destructor, it's best practice to create a copy constructor for that class as well as an assignment operator to avoid problems like these.</p>

<p>That said, there would have been no need for the copy to occur in the first place, if you had declared the <em>SomeFunc</em> function to take a const reference, which would also be far more effecient.</p>

<pre><code>void SomeFunc(const Sample &amp;x) {
   ...
}
</code></pre>
",0
15517643,15517550,0,"<p>Maybe your problem isnt even language specific. From what i understand you need a tool like <a href=""http://winmerge.org/"" rel=""nofollow"">this</a> maybe.</p>
",3
15517649,15517550,1,"<ol>
<li>You may use <code>Beyond Compare</code> This is commercial but 30 day trial.</li>
<li>You can use <a href=""http://sourceforge.net/projects/npp-compare/"" rel=""nofollow"">compare plugin</a> with notepad++.</li>
<li>If you use <code>TortoiseSVN</code> client There is a option <code>Diff with previous version</code>.</li>
</ol>

<p>If you need more details read <a href=""http://smashinghub.com/10-best-file-and-documents-comparison-tools.htm"" rel=""nofollow"">this</a> article.</p>
",4
15517655,15517550,0,"<p>It sounds like you're looking for <a href=""http://en.wikipedia.org/wiki/Revision_control"" rel=""nofollow"">version control</a>. <a href=""http://subversion.apache.org/"" rel=""nofollow"">Subversion</a> and <a href=""http://git-scm.com/"" rel=""nofollow"">Git</a> are both great for your needs.</p>

<p><a href=""http://learn.github.com/p/diff.html"" rel=""nofollow""><code>git diff</code></a> will show you the differences introduced by commits.</p>
",4
15518037,15517550,0,"<p>I haven't tried it, but <a href=""http://www.devart.com/codecompare/"" rel=""nofollow"">CodeCompare</a> claims to be a diff tool aimed at comparing code, not just text.<br>
There's a free version, but I think you can try the full version for a few days.  </p>
",0
16456855,16456791,8,"<p>foo1 is a macro.  Macros perform strict find and replace, so foo1(3+2) is replaced with 3+2*3+2.
Following order of operations, 3+2*3+2 = 3+6+2 = 11.</p>
",1
16456862,16456791,2,"<p>you have</p>

<pre><code>#define foo1( a )  a * a
</code></pre>

<p>So when you say<code>foo1( 3 + 2 )</code>, compiler sees <code>3 + 2 * 3 + 2</code>. obviously <code>11</code> </p>

<p>If you want the macro <code>foo1</code> to do multiplication, you should</p>

<pre><code>#define foo1(a) ((a)*(a))
</code></pre>
",0
16456869,16456791,2,"<p>Because the macro gets pounded out to be this:</p>

<pre><code>cout &lt;&lt; ""foo1 = "" &lt;&lt; 3 + 2 * 3 + 2 &lt;&lt; ""\n"";
</code></pre>

<p>And simple BODMAS tells me that that is equal to 11 :) i.e.
<code>3 + (2 * 3) + 2</code></p>
",0
16456970,16456791,0,"<p>foo1 is a macro defined as  <code>foo1(a) a * a</code>. </p>

<p>all <code>#define</code> statements are C-preprocessor macro statements. They are literally expanded into the code BEFORE any compilation takes place.</p>

<p>So </p>

<pre><code>#define foo1(a) a * a
</code></pre>

<p>changes</p>

<pre><code>cout &lt;&lt; ""foo1 = "" &lt;&lt; foo1( 3 + 2 ) &lt;&lt; ""\n"";
</code></pre>

<p>to </p>

<pre><code>cout &lt;&lt; ""foo1 = "" &lt;&lt; 3 + 2 * 3 + 2 &lt;&lt; ""\n"";
</code></pre>

<p>Since there are no parentheses around a in the expansion the evaluation is 11</p>

<p>If you want to see it work the way you expected it to (i.e. end up being 25) you can experiment with the define as under:</p>

<pre><code>#define foo1(a) (a) * (a) 
</code></pre>

<p>and you will see it ends up being 25 </p>

<p>Also you should be able to just see the preprocessor output by using the correct compiler options. For gcc or g++ it's  -E  ... </p>

<p>Hope you have fun with it</p>
",0
16457033,16456791,0,"<p>Function-like macros work by  <a href=""http://www.cprogramming.com/tutorial/cpreprocessor.html"" rel=""nofollow"">direct text substitution</a></p>

<p>So <code>foo1(3+2)</code> becomes <code>(3 + 2*3 + 2)</code> which is 11</p>
",0
17849922,17849826,4,"<p>This is an edited answer. I was proven wrong by Igor Tandetnik, and since my answer was (incorrectly) accepted and highest voted, I decided to rewrite it to make it correct.</p>

<p>In our case </p>

<p><code>foo() = ostream&amp; ostream::operator&lt;&lt;(const char*)</code></p>

<p>The order of execution in a sequence of:</p>

<p><code>obj.foo(""str"").foo(fun())</code></p>

<p>may be either:</p>

<pre><code>obj.foo(""str"");
fun();
obj.foo(fun_res);
</code></pre>

<p>or</p>

<pre><code>fun();
obj.foo(""str"");
obj.foo(fun_res);
</code></pre>

<p>In your case the latter happened, but the former is also a valid execution order.</p>

<p>The order guarantees are as follows:</p>

<ul>
<li><code>fun()</code> will happen before <code>obj.foo(fun_res)</code>, because the result of foo is required for that call, </li>
<li><code>obj.foo(""str"")</code> will happen before <code>obj.foo(fun_res)</code>.</li>
</ul>

<p>Hence the abovementioned two cases are possible.</p>
",6
17849949,17849826,2,"<p>The order of evaluation of subexpressions within an expression is, in general, unspecified. <code>tryout.main()</code> may be legally called before or after <code>std::cout&lt;&lt;""In Main function: ""</code> is executed. In your case, it happens to be called before.</p>
",0
17852454,17849826,0,"<p>""&lt;&lt;"" in C++ is actually syntactic sugar, when you do</p>

<pre><code>cout &lt;&lt; ""Hello""
</code></pre>

<p>you're actually calling either</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp;, const char*)
</code></pre>

<p>or</p>

<p>ostream&amp; ostream::operator&lt;&lt;(const char*)</p>

<p>For convenience, I'm going to assume the latter. When you write</p>

<pre><code>std::cout&lt;&lt;""In Main function: ""&lt;&lt;tryout.main()&lt;&lt;std::endl;
</code></pre>

<p>this would compile to</p>

<pre><code>cout.operator&lt;&lt;(""In Main function: "").operator&lt;&lt;(tryout.main()).operator&lt;&lt;(std::endl);
</code></pre>

<p>So the code you wrote as</p>

<pre><code>&lt;&lt;tryout.main()&lt;&lt;
</code></pre>

<p>says: ""call tryout.main(), capture the return value, and pass that to ""ostream::operator&lt;&lt;(int)"", using the ostream returned by the previous &lt;&lt;.</p>

<p>So - now tryout.main() is called and executed, which does it's own output, quite independently, and then returns 0.</p>

<p>Now your main function is able to finish it's call chain with the return value of 0 as an argument.</p>

<p>Was there a reason you were not able to step through this with a debugger?</p>
",2
13750835,13750828,1,"<p>It should be</p>

<pre><code> delete pending;
 pending = NULL;
</code></pre>

<p>(<strong>your version is the other way around</strong>). Notice you're first setting the pointer to <code>NULL</code>, and after that deleting it, so you're effectively calling <code>delete</code> on a null pointer. Which is a no-op - memory is not released.</p>
",2
16376669,16376659,5,"<p>C++ does not support variable length arrays (VLAs), which is what you have here:</p>

<pre><code>Person m_Data[m_Capacity];
</code></pre>

<p>For this to work, <code>m_Capacity</code> must be a compile time constant.</p>

<p>Besides that, you have a syntax error in your default constructor, where a <code>:</code> is required to indicate an initialization list:</p>

<pre><code>PersonList::PersonList() : m_Capacity(10), m_Empty(Person()) { .... }
//                       ^ Here!
</code></pre>
",3
16376716,16376659,0,"<p>The constructor and the initialization list has to be separated by a colon. Like this</p>

<pre><code>PersonList::PersonList() : m_Capacity(10), m_Empty(Person())
</code></pre>
",0
17869076,17869049,6,"<p>You should add <code>out.close()</code> to the end of your program.  This will flush the write buffer to ensure that it was properly written to.</p>

<p>Also, confirm that you actually have (rather, that your program has) permission to create and write files in that directory.</p>

<p>Finally, make sure the path you're writing to is actually correct.  As @Adam pointed out in a comment, you probably meant to use <code>/home/...</code> and not <code>/Home/...</code></p>
",2
17869126,17869049,2,"<p>I copied and pasted the script, but changed the path, and the code executed successfully. I recommend using <code>out.close()</code> after you are done with the file to close the stream.</p>

<p>You could also use stream operators on the file to write it:</p>

<pre><code>for( int i = 0; i &lt; 100; i++ )
  out &lt;&lt; s;
</code></pre>
",0
17869200,17869049,1,"<p>Change <code>out.put(s);</code> to <code>out &lt;&lt; s;</code></p>

<p>Secondly once you are done working with files and streams, it is a good practice to close them. It prevents unwanted memory leaks. so put <code>out.close()</code> before return or when you are done working with file.</p>
",0
16454202,16453991,2,"<p>While briefly looking over your code, nothing stood out that was exceptionally odd. That being said, if I run your code through a compiler, the following warning comes out:</p>

<pre><code>[11:04pm][wlynch@watermelon /tmp] g++ -Wall foo.cc 
foo.cc: In function ¡®int search(int*, int, int, int)¡¯:
foo.cc:76: warning: control reaches end of non-void function
</code></pre>

<p>And so we look at the search function. It looks like you intended for the function to be recursive, and so I believe you should have written it with more return statements:</p>

<pre><code>int search(int data[], int target, int first, int last) {
    int middle;
    if (first &gt; last) 
        return -1;
    else {
        middle=(first + last)/2;
        if (target == data[middle])
            return middle;    
        else if ( target &lt; data[middle])
            return search(data, target, first, middle-1);
        else if (target &gt; data[middle])
            return search(data, target, middle +1, last);
    }
}
</code></pre>
",1
16391634,16391566,0,"<p>Right-click your project, and select properties. Under <strong>C/C++</strong>, select <strong>Code Generation</strong>.  In there you'll see an option for ""Runtime Library"".  Select <strong>Multi-threaded [Debug]</strong> instead of <strong>Mutli-threaded [Debug] DLL</strong>.</p>

<p><img src=""https://i.stack.imgur.com/h8Ick.png"" alt=""enter image description here""></p>
",2
16473369,16473346,2,"<p>I'm not sure I followed your explanation, but it <em>sounds</em> like what you really want is a vector of structures:</p>

<pre><code>struct whatever { 
    std::string first; // The first column will be a string
    int second;        // ...the second would be ints
    double third;      // ...and the third would be doubles.
};

std::vector&lt;whatever&gt; data;
</code></pre>

<p>As far as your output goes, you'd define an <code>operator&lt;&lt;</code> to handle that:</p>

<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, whatever const &amp;w) { 
     os &lt;&lt; std::setw(10) &lt;&lt; w.first 
        &lt;&lt; std::setw(5) &lt;&lt; w.second 
        &lt;&lt; std::setw(9) &lt;&lt; w.third;
     return os;
}
</code></pre>
",0
16473372,16473346,2,"<p>If your compiler supports C++11, you can use a <code>vector</code> of <code>tuple</code>s:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;

int main()
{
    std::vector&lt;std::tuple&lt;std::string, int, double&gt;&gt; var;

    var.emplace_back(""One"", 200, 5.1);
    var.emplace_back(""Three"", 10, 1.4);
    var.emplace_back(""Nine"", 5000, 10.8);
}
</code></pre>

<p>Use <strong><a href=""http://en.cppreference.com/w/cpp/utility/tuple/get"" rel=""nofollow""><code>std::get&lt;N&gt;</code></a></strong> for compile-time indexing.</p>
",0
16473374,16473346,2,"<p>I would suggest encapsulating the data into a class and than jsut using a vector of that class.</p>

<p>(probably won't compile as is)</p>

<pre><code>class MyData 
{
public:
    std::string col1;
    int col2;
    double col3;
};

...
std::vector&lt;MyData&gt; myData;
MyData data1;
data1.col1 = ""One"";
data1.col2 = 10;
data1.col3 = 5.1
myData.push_back(data1);
</code></pre>

<p>This is much more convenient to work with since now when you need to print out your collection you are only iterating over one set of objects and you don't need to worry about indexing or accessing into a complex vector of vectors or tuples.</p>
",0
16953060,16953034,2,"<p>Since <code>dollar</code> is a <code>double</code>, the <code>E</code> or <code>e</code> gets interpreted as part of the exponent of the number (as in <code>2e-2</code>) when you extract it. Since there are no digits after it, the extraction does not complete and <code>cin</code> goes into the <code>fail</code> state. The read of <code>currency</code> is then skipped, never changing it from the initial value of <code>' '</code>. When you enter a space, the extraction of <code>dollar</code> ends at the space and <code>currency</code> is read as expected.</p>

<p>To fix it, you could try several things. You could <em>require</em> a space between the amount and the currency indicator. You could read it in as a string and attempt to parse it yourself. You could pick a different symbol for euros.</p>

<p>In any case, you should check the state of the <code>cin</code> after you're done reading from it.</p>
",1
16393521,16393488,7,"<p>Since you use C++ and not C, use <code>std::string</code> or <code>std::vector</code>, they'll make your life a lot easier, as they are designed especially for tasks you describe.</p>

<p>If you really want to stick to <code>char *</code>, then check the C-style <a href=""http://msdn.microsoft.com/en-us/library/xbebcx7d.aspx"" rel=""nofollow""><code>realloc</code></a> function.</p>
",0
16393536,16393488,0,"<p>you can use <code>std::string</code> <code>push_back</code> method for this purpose. It directly appends a new char to the end of the string. std library handles memory issues itself</p>
",0
16393584,16393488,0,"<p>You need to create your array dynamically and get memory from heap. You can use <code>new</code> command or <code>malloc</code>.
It will allocate memory on the heap, but making array in normal definition will use stack memory.</p>
",0
15893554,15893522,3,"<p>There are a few issues with your code:</p>

<pre><code>if (sentence="""") return 0; 
</code></pre>

<p>should be</p>

<pre><code>if (strcmp(sentence,"""")==0) return 0;
</code></pre>

<hr>

<pre><code>char *begin; char *end;
</code></pre>

<p>should be</p>

<pre><code>const char *begin; const char *end;
</code></pre>

<hr>

<pre><code>*begin= &amp;sentence(0); 
</code></pre>

<p>should be</p>

<pre><code>begin = &amp;sentence[0];
</code></pre>

<hr>

<pre><code>*end=&amp;sentence[i-1];
</code></pre>

<p>should be</p>

<pre><code>end = &amp;sentence[i-1];
</code></pre>
",1
15893556,15893522,0,"<p>There are a bunch of problems in your code, but the one causing that error message is that you're dereferencing when you don't need to be.  You want:</p>

<pre><code>begin = &amp;sentence[0];
end = &amp;sentence[i-1];
</code></pre>
",0
15893673,15893522,0,"<pre><code>begin = &amp;sentence[0];
end = &amp;sentence[i - 1];
</code></pre>

<p>This will solve your problem..</p>
",0
15893841,15893522,-1,"<p>You should write <code>[]</code> insted of <code>()</code> in  </p>

<pre><code> *begin= &amp;sentence(0); 
</code></pre>

<p>you should caste sentence to (char*) before assigning it to begin and end.</p>

<pre><code>*begin =  ((char*)sentence)[0];

*end =  ((char*)sentence)[i -1];
</code></pre>
",1
16922007,16921778,2,"<p>You probably want to implement <code>bool operator==(const Object &amp;lhs, const Object &amp;rhs)</code> and <code>operator!=</code> as well for convenience, which in the implementation will return the opposite of <code>operator==</code>. </p>

<p>When you provide one, I think it is better to provide both, otherwise clients of your code (the other developers) may be confused where there is no need to be. Writing one operator calling the other one allows you an easier maintenance.</p>
",0
16922016,16921778,4,"<p>The operator == of vector actually compares if the content is equal, in that comparison the operator == of ""Object"" will be called and that is the operator that you want to define depending of the logic you want to achieve.</p>
",0
16390932,16390808,0,"<p>Nothing is wrong with that code, but you should instead use this, it will save time.</p>

<pre><code>cout&lt;&lt;setprecision(decimalValue)&lt;&lt;answer&lt;&lt;endl;
</code></pre>
",1
16390964,16390808,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main()
{ 
    double whatever = 3.13;
    // using IOManip header:
    std::cout &lt;&lt; std::setprecision(100) &lt;&lt; std::fixed &lt;&lt; whatever &lt;&lt; std::endl; 
}
</code></pre>

<p><strong>setprecision</strong> is part of the standard namespace, so if you don't call <em>use std::setprecision and std::fixed</em> or <strong>using namespace std;</strong> you will have to use <em>std::setprecision</em> and <em>std::fixed</em> instead of <em>setprecision</em> or <em>fixed</em>. </p>

<p>You didn't show us what your header declarations look like, so judging from what you posted you probably need to include the header file or use the scope resolution operator.</p>
",3
17092903,17092817,6,"<p>As an alternative to RichieHindle's answer, this works too. Just have the stringstream scope local to the for loop and it will reset properly.</p>

<pre><code>int countWords(vector&lt;string&gt; v)
{
    string word;
    int count = 0;
    for(int i = 0; i &lt; v.size(); i++) {
      stringstream ss(v[i]);
            while (ss &gt;&gt; word)
                count++;
    }
    return count;
}
</code></pre>
",0
17092907,17092817,1,"<p>I bet <code>ss</code> goes into an error state when you've exhausted it for the first time and doesn't reset just because you call <code>str</code>.</p>

<p>Declare <code>ss</code> inside the for loop and pass the string directly to the constructor. This avoids such problems.</p>

<p>In general, you have the bad habit of declaring your variables in a bunch instead of closest to where you need them, and not using constructors. For example, you could pass the filename to <code>fstream</code>'s constructor instead of calling <code>open</code>. And you could use <code>ifstream</code> so you don't need the second argument.</p>
",0
17092924,17092817,4,"<p>Before you reuse stringstream you must do</p>

<pre><code> ss.clear();
</code></pre>

<p>after your while loop.</p>

<p>You could also declare it inside the <code>for()</code> loop, but then it would be reinitialized again. For readabillity, this might be better. Performancewise it could make a difference.</p>
",1
16922463,16922416,3,"<p>It is created before <code>main</code> starts. In C++, some ""program execution"" can occur before <code>main</code>.</p>
",0
16922472,16922416,6,"<p>Since <code>object</code> is a static (i.e. global) variable, its constructor is executed when the global constructors are run, i.e. before <code>main()</code> starts executing.</p>
",2
16922480,16922416,1,"<p>YOUR program starts with your code in main, but ""things"" happen before that. Some compilers/environments will add some extra code just at the beginning of main to create global objects, in other cases, the creation of global is code that runs just before main. All you need to really care about is that ""it happens before any of your code"". </p>

<p>However, you can't rely on global objects being initialized before some OTHER global objects.... </p>
",2
16922539,16922416,1,"<p>In C++, global objects are created as static data before main is called.  This means that memory is allocated on neither the stack nor the heap, but instead is placed in memory in a data segment.  A data segment is an area of memory laid out in a manner similar to how a program's execution code is stored.  The memory is allocated when the program is loaded into memory before any code runs.</p>

<p>C++ does not require that global objects be created in any particular order.  The only guarantee is that they will be created before <code>main</code> is called.  That is, assume global constructors are called essentially at random. </p>
",0
15867830,15867803,1,"<p><code>cin</code> is the standard input stream, it usually takes input from the keyboard. You need to read your input from the file instead.</p>

<p>The loop never terminates because the file read position is never getting advanced.</p>
",0
15867856,15867803,2,"<p>Assuming <code>huffmanFile</code> is an <code>istream</code> object type, you may try using this variant:</p>

<pre><code>while (huffmanFile &gt;&gt; letters[c] &gt;&gt; numbers[c]) {
    ++c;
}
</code></pre>

<p>Explanation:
The <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt"" rel=""nofollow""><code>istream::operator &gt;&gt;</code></a> sets its internal flag called <code>eofbit</code> if the end of a stream has been reached. It also returns <code>*this</code>, allowing us to perform sequence of readings like <code>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c</code>.
After that, an <code>istream</code> object is being tested by <code>while</code> clause, i.e. the internal <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/operator_bool"" rel=""nofollow""><code>bool operator()</code></a> is called, which in turn returns <code>true</code> if the <code>eofbit</code> flag has been set, <code>false</code> otherwise.</p>
",0
16428253,16428234,18,"<p>This is <strong>undefined behavior</strong>. Undefined behavior means that <em>anything</em> can happen, including:</p>

<ul>
<li>segmentation fault</li>
<li>no error at all</li>
<li>inconsistent output</li>
<li>formatting of hard drive</li>
<li>... (whatever)</li>
</ul>

<p>To get a bit more formal, this is how the C++11 Standard defines undefined behavior:</p>

<blockquote>
  <p>behavior for which this International Standard imposes no requirements
  [ <em>Note</em>: Undefined behavior may be expected when this International Standard omits any explicit definition of
  behavior or when a program uses an erroneous construct or erroneous data. <strong>Permissible undefined behavior
  ranges from ignoring the situation completely with unpredictable results, to behaving during translation or
  program execution in a documented manner characteristic of the environment</strong> (with or without the issuance of
  a diagnostic message), <strong>to terminating a translation or execution</strong> (with the issuance of a diagnostic message).
  Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed.
  ¡ªend note ]</p>
</blockquote>

<p>Concerning the reason why doing <code>x[5]</code> is indeed undefined behavior, that's because <code>x[5]</code> is equivalent to <code>*(x + 5)</code> (see paragraph 8.3.4/6), and paragraph 5.3.1/1 about the unary operator <code>*</code> specifies:</p>

<blockquote>
  <p>The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an
  object type, or a pointer to a function type and <strong>the result is an lvalue referring to the object or function
  to which the expression points</strong>. If the type of the expression is ¡°pointer to T,¡± the type of the result is
  ¡°T.¡± [...]</p>
</blockquote>

<p>But since <code>x + 5</code> does not point to any object, and the above paragraph does not specify what the result of dereferencing such a pointer should be, the previously quoted sentence applies:</p>

<blockquote>
  <p>[...] Undefined behavior may be expected when this International Standard omits any explicit definition of behavior [...]</p>
</blockquote>

<p>Which means that <code>x[5]</code> is undefined behavior.</p>
",12
16428332,16428234,3,"<p>A segmentation fault occurs when a user program attempts to do one of :</p>

<ul>
<li>Access a part of the memory it is not allowed to, such as system memory</li>
<li>Access a part of the memory which does not exist (aka out of bounds)</li>
</ul>

<p>So you are correct in realizing that you are reaching out of bounds in your array, and on the last loop iteration you are accessing something outside of your program's allocated memory. It just so happens that the piece of memory is not system memory and it exists, so it lets you read it.</p>

<p>If you ran this bit of code enough times you should eventually get a segmentation fault because it will happen to be placed right up against system memory or at the end of memory.</p>
",2
16428358,16428234,1,"<p>I think Andy Prowl has already answered best in saying that it's undefined behaviour.</p>

<p>But if you're interested in the specifics of why it doesn't crash, on my compiler at least, the variable <code>x</code> is allocated in the position on the stack immediately following the array. When you assign <code>x</code> to <code>arr[5]</code>, you're really just assigning <code>x</code> back to itself.</p>

<p>Obviously this may be different from one compiler to the next. Just thought you might be interested to know at least what one particular compiler is doing.</p>
",0
13740293,13740258,4,"<p>It is not a compilation error but the problem (undefined behaviour) will manifest itself at runtime. If you choose to call <code>free</code> on unallocated memory the compiler will not stop you.</p>
",2
13740295,13740258,4,"<p>Such logical errors cannot be detected by a compiler! Instead, the program has undefined behavior, which can include running seemingly OK, crashing, or producing all sorts of garbage. There are a lot of (and I can't stress that enough, like, a LOT) situations that result in undefined behavior </p>
",2
13741388,13740258,1,"<p>Your program <strong>can work fine</strong> since <code>free()</code> only marks some memory as free, but it does not actually overwrite it. Owing to this, the chances are <strong>your solution will run correctly most of the time</strong> as in your function you are not using any new memory. (At least in single threaded environment.)</p>

<p>On the other hand, I would go and <strong>fundamentally change</strong> the function like this:</p>

<pre><code>template&lt;typename _Tp&gt;
void unique(forward_list&lt;_Tp&gt;&amp; list)
{
  unordered_map&lt;_Tp, bool&gt; record;
  auto la=list.before_begin();
  for(auto it=list.begin(); it!=list.end(); ++it) 
  {
    if(record.find(*it)==record.end())
      record[*++la] = true;
    else
      list.erase_after(la);
  }
}
</code></pre>

<p>You can even go as far as writing this:</p>

<pre><code>template&lt;typename _Tp&gt;
void unique(forward_list&lt;_Tp&gt;&amp; list)
{
  unordered_map&lt;_Tp, bool&gt; record;
  auto la=list.before_begin();
  for(auto e: list) 
  {
    if(record.find(e)==record.end())
      record[*++la] = true;
    else
      list.erase_after(la);
  }
}
</code></pre>

<p>But I think that can be a bit too much, as it does not reflect that we need to go one element after an other.</p>

<hr>

<p><strong>My reasons for the fundamental change:</strong></p>

<ol>
<li><p>In C++ <code>free()</code> is called <code>delete</code>. It is used in pair with <code>new</code> (which is used in c++ instead of <code>malloc()</code> or <code>calloc()</code>). <code>delete</code> is used like this:</p>

<p>delete runner;<br>
// and new is used like this:<br>
Some_type *p = new Some_type();</p></li>
<li><p>STL has already a LinkedList, so it makes sense to use that. It is called <a href=""http://en.cppreference.com/w/cpp/container/forward_list"" rel=""nofollow noreferrer"">std::forward_list</a>. You want to use <a href=""http://en.cppreference.com/w/cpp/container/forward_list/erase_after"" rel=""nofollow noreferrer""><code>erase_after</code>, with a nice example</a>.</p></li>
<li><p>You want to use std::unsorted_map instead of hash_map (again, since it is in STL). The best is always the std solution.  </p></li>
<li><p>One of the main purpose of classes is to hide away necessary pointer activity, so in function headers I would rather use references instead of pointers, so at least your function should be</p>

<p><code>void removeDuplicateWithHashtable(LinkedListElement&lt;char&gt;&amp; head)</code></p></li>
</ol>
",7
16925028,16924710,2,"<p>It does sort of work. For instance if you introduce the following sequence:</p>

<pre><code>3 &lt;enter&gt;
+ &lt;enter&gt;
3 &lt;enter&gt;
d &lt;enter&gt;
3 &lt;enter&gt;
</code></pre>

<p>It produces:</p>

<pre><code>Result: 6
</code></pre>

<p>The reason is cin always expects an enter to finish. There is also an error in the logic and even when you want to stop the execution you have to introduce an extra dummy value. To solve that you must check the operator <em>before</em> asking for the rval.</p>

<p>EDIT:</p>

<p>Probably this would be close to what you want:</p>

<pre><code>#include ""iostream""
#include &lt;cstdio&gt;

 using namespace std;

 int main()
 {
     cout &lt;&lt; ""Please enter an expression (we can handle """"+"""",""""-"""",""""*"""",""""/    """")"" &lt;&lt; endl;
     int lval = 0;
     int rval;
     char op;
     /*int res;*/
     cin &gt;&gt; lval; //read left most number
     if (!cin) printf(""No first operand"");

     while (cin &gt;&gt; op) //Repeatedly read operand and right value
     {
         if(op != '+' &amp;&amp; op != '-' &amp;&amp; op != '*' &amp;&amp; op != '/')
         {
             cout &lt;&lt; ""Result: "" &lt;&lt; lval &lt;&lt; endl;
             //keep_window_open();
             getchar();
             return 0;
         }

         cin &gt;&gt; rval;
         if (!cin) printf(""No second operand"");
         switch(op)
         {
             case '+':
                 lval += rval; //add: lval = lval + rval
                 break;
             case '-':
                 lval -=rval;//subtract: lval = lval - rval
                 break;
             case '*':
                 lval *= rval; //Multiply: lval = lval * rval
                 break;
             case '/':
                 lval /= rval; //Divide: lval = lval / rval
                 break;
         }
     }
     printf(""Bad expression"");
 }
</code></pre>
",6
16925077,16924710,1,"<p>The problem comes with your first outputted line. Instead of two sets of quotes, you need to <strong>escape</strong> one set with a backslash, telling C++ to treat the quotes as a character rather than the start or end of a string. Also, your while loop seems to test a very odd condition. I don't know what has gone wrong, but it just continually takes in the operator and (presumably) the code in the while loop never gets executed. A better code solution is below.</p>

<pre><code>#include ""std_lib_facilities.h""

int main()
{
    cout &lt;&lt; ""Please enter an expression (we can handle \""+\"",\""-\"",\""*\"",\""/\"")"" &lt;&lt; endl;
    int lval = 0;
    int rval;
    int loop = 1;
    char op;
    /*int res;*/
    while (loop == 1) //Repeatedly calculate
    {
    cout&lt;&lt;""Please enter the first number""&lt;&lt;endl;
    cin &gt;&gt; lval; //read left most number
    if (!cin) error(""No first operand"");
    cout&lt;&lt;""Please enter operator""&lt;&lt;endl;
    cin &gt;&gt; op;
    cout&lt;&lt;""Please enter second number""&lt;&lt;endl;
    cin &gt;&gt; rval;
    if (!cin) error(""No second operand"");
    switch(op)
        {
        case '+':
            lval += rval; //add: lval = lval + rval
            break;
        case '-':
            lval -=rval;//subtract: lval = lval - rval
            break;
        case '*':
            lval *= rval; //Multiply: lval = lval * rval
            break;
        case '/':
            lval /= rval; //Divide: lval = lval / rval
            break;
        default:
            cout &lt;&lt; ""Result: "" &lt;&lt; lval &lt;&lt; endl;
            keep_window_open();
            return 0;
        }
    cout&lt;&lt;""Enter 1 to calculate a new expression, or 0 to exit.""&lt;&lt;endl;
    cin&gt;&gt;loop;
    }
    error(""Bad expression"");
}
</code></pre>
",3
16925118,16924710,1,"<p>Dismiss the default statement, maybe you should not use <code>default</code> for displaying the result.
Try this:</p>

<pre><code>#include ""std_lib_facilities.h""

int main()
{
    cout &lt;&lt; ""Please enter an expression (we can handle """"+"""",""""-"""",""""*"""",""""/"""")"" &lt;&lt; endl;
    int lval = 0;
    int rval;
    char op;
    /*int res;*/
    cin &gt;&gt; lval; //read left most number
    if (!cin) error(""No first operand"");

    while (cin &gt;&gt; op) //Repeatedly read operand and right value
    {
        cin &gt;&gt; rval;
        if (!cin) error(""No second operand"");
        switch(op)
        {
        case '+':
            lval += rval; //add: lval = lval + rval
            break;
        case '-':
            lval -=rval;//subtract: lval = lval - rval
            break;
        case '*':
            lval *= rval; //Multiply: lval = lval * rval
            break;
        case '/':
            lval /= rval; //Divide: lval = lval / rval
            break;
        }
        cout &lt;&lt; ""Result: "" &lt;&lt; lval &lt;&lt; endl;
        keep_window_open();
        return 0;
    }
    error(""Bad expression"");
}
</code></pre>

<p>this should work.</p>
",10
17389251,17389220,8,"<pre><code>if (answer == t3) 
</code></pre>

<p>Didn't you mean this:</p>

<pre><code>if (answer == temp) 
</code></pre>

<p>(you want the user to guess the root, not the cube, right?) :-)</p>
",0
15845980,15845835,0,"<p>There's a bug in isprime function.</p>

<p>In your function, you check all 2310 * j + d[k] where j &lt; int (sqrt(n) / 2310)) to ensure the target n is a prime number. However, an additional condition that l &lt; sqrt(n) is also required, or you will over-exclude some prime numbers.</p>

<p>For example, when a = 1, b = 41 and n = 0, your function will check whether 41 is a prime number starting from j = 0. So whether 41 can be divisible by 2310 * 0 + d[7] = 41 is also verified, which leads to a false return.</p>

<pre><code>This version should be correct:
bool isprime(unsigned int n, int d[])
{
    int j = 0, l;
    if ((n == 2) || (n == 3) || (n == 5) || (n == 7) || (n == 11))
        return 1;
    if ((n % 2 == 0) || (n % 3 == 0) || (n % 5 == 0) || (n % 7 == 0) || (n % 11 == 0))
        return 0;
    double root = sqrt(n);
    while (j &lt;= int (root / 2310))
    {
        for (int k = 0; k &lt; 339; k++)
        {
            l = 2310 * j + d[k];
            if (l &lt; root &amp;&amp; n % l == 0)
                return 0;
        }
        j++;
    }
    return 1;
}
</code></pre>
",1
16930676,16930550,0,"<p>you have to pass more argument in your program argc and argv[] as argc is just a parameter for main function and hence is not visible in other function.</p>

<p>Here is your modified code.</p>

<pre><code>void findAndShift(vector&lt;string&gt;&amp; ngram, string source[],int sourceLength, int argc, char argv[0], argv[1],argv[i]){
    if (argc == 2)///default command prompt...not declared?
    {
        ifstream infile;
        infile.open(argv[1], ios::in);
        if (infile.fail())
        {
            cout &lt;&lt; argv[0] &lt;&lt; "": ""&lt;&lt; argv[i] &lt;&lt; ""I'm afraid I can't let you do that, Dave."" &lt;&lt; endl;
        }
        else
        {
            //get length of n
            infile.seekg(0, ios::end);
            const int sourceLength = infile.tellg();

            int n = 0;
            string word;
            ngram = rand() % sourceLength;
            while (!infile.eof())
            {
            infile &gt;&gt; source;
            ++n;
            if(counter == ngram);
             word = n;
            }
        }
    }
    return;
}
</code></pre>

<p>your main code</p>

<pre><code>string source[250000];
 vector&lt;string&gt; ngram;
 int main(int argc, char* argv[]) {
   int n, outputN, sl;
   n = 3;
   outputN = 100;
   for (int i = 0; i &lt; argc; i++) {
     if (string(argv[i]) == ""--seed"") {
       srand(atoi(argv[i+1]));
     } else if (string(argv[i]) == ""--ngram"") {
       n = 1 + atoi(argv[i+1]);
     } else if (string(argv[i]) == ""--out"") {
       outputN = atoi(argv[i+1]);
     } else if (string(argv[i]) == ""--help"") {
       help(argv[0]);
 return 0; }
   }
   fillWordList(source,sl);
   cout &lt;&lt; sl &lt;&lt; "" words found."" &lt;&lt; endl;
   cout &lt;&lt; ""First word: "" &lt;&lt; source[0] &lt;&lt; endl;
   cout &lt;&lt; ""Last word:  "" &lt;&lt; source[sl-1] &lt;&lt; endl;
   for (int i = 0; i &lt; n; i++) {
     ngram.push_back(source[i]);
   }
   cout &lt;&lt; ""Initial ngram: "";
   put(ngram);
   cout &lt;&lt; endl;
   for (int i = 0; i &lt; outputN; i++) {
if (i % 10 == 0) {
  cout &lt;&lt; endl;
}
//put(ngram);
//cout &lt;&lt; endl;
cout &lt;&lt; ngram[0] &lt;&lt; "" "";
findAndShift(ngram, source, sl, argc,argv[0],argv[1],argv[i]);
 } }
</code></pre>

<p>I haven''t tested it.
If it still not work try to use char * in argument list of findAndShift</p>

<p>Hope it helps....</p>
",0
18286877,18286852,4,"<p>You need to include the header file for the vector type:</p>

<pre><code>#include &lt;vector&gt;
</code></pre>

<p>In C++, everything must be declared before it is used in your code and declarations for the standard library are in the <a href=""http://en.cppreference.com/w/cpp/header"" rel=""nofollow"">standard library header files</a>.</p>
",3
16951911,16951895,1,"<p>You forgot one more step:</p>

<pre><code>  time (&amp;SystemTime); //^^Should first do this
  struct tm *OSTime;
  OSTime=localtime(&amp;SystemTime);
</code></pre>

<p>You can find an example usage here: <a href=""http://en.cppreference.com/w/cpp/chrono/c/localtime"" rel=""nofollow"">localtime</a>, call <code>time</code> before call <code>localtime</code>.</p>
",4
16408564,16404836,0,"<p>The best way to do this is to use WinDbg. Visual Studio is not very good on breaking on data writes or data reads. You can get WinDbg for free from <a href=""http://msdn.microsoft.com/en-us/windows/hardware/gg463009.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/windows/hardware/gg463009.aspx</a> You can find extensive help online for WinDbg, including how to use it to break on data point reads, read/writes, or just writes. Microsoft provides links from the URL I listed, and <a href=""http://windbg.info"" rel=""nofollow"">http://windbg.info</a> has a lot of information on using WinDbg.</p>

<p>However, if you insist on using Visual Studio 2008, the way to do this is to start the program under your the Visual Studio debugger. Set a break point in the code where the variable you are interested in is active. Once the debugger breaks the execution at your breakpoint, you can add a new breakpoint on the variable read or write using the ""new breakpoint"" menu. You may need to select the variable you are interested in and then use the context select to start the ""new breakpoint"". Select ""Datapoint access"", and select whether it is for read or write or read/write access.</p>

<p>For more details, consult: <a href=""http://msdn.microsoft.com/en-us/library/350dyxd0(v=VS.90).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/350dyxd0(v=VS.90).aspx</a></p>
",0
16408896,16404836,1,"<p>It would have been more practical if you gave a code snippet.  I'm forced to make my own:</p>

<pre><code>void foo() {
    int ix = 0x42;
    int jx;
    long long* p = (long long*)&amp;ix;
    *p = 0x100000042LL;
}
</code></pre>

<p>This intentional stack corruption attempt will break the debugger:</p>

<p><img src=""https://i.stack.imgur.com/MvsnS.png"" alt=""enter image description here""></p>

<p>So I set a breakpoint at function entry and set a data breakpoint after the address of variable ""ix"" with Debug + New Breakpoint + New Data Breakpoint:</p>

<p><img src=""https://i.stack.imgur.com/NSH8f.png"" alt=""enter image description here""></p>

<p>And press F5 to continue running.  The data breakpoint triggers:</p>

<p><img src=""https://i.stack.imgur.com/G7JYh.png"" alt=""enter image description here""></p>
",3
17409314,17404729,0,"<p>If you want to output doubles, ints etc to a filestream, the function you are looking for is fprintf. <a href=""http://www.cplusplus.com/reference/cstdio/fprintf/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/fprintf/</a></p>

<p>Example:</p>

<p>fprintf(pOutputFile,""%d %d %f"",myint1,myint2,mydouble)</p>
",0
18247406,18247241,2,"<p>I think what your ""sir"" was trying to tell you is that with your approach something like following wont be possible</p>

<pre><code>Distance d1,d2,d3,d4;

d4 = d1 + d2 + d3;
</code></pre>

<p>I would prefer to overload ""+"" operator rather than defining an Add function. Doing</p>

<pre><code>d4 = d1 + d2 + d3
</code></pre>

<p>is so much intuitive.</p>

<p>Regarding your second question, when you rename distances to distance it conflicts with STL distance function. This function is unside std namepspace but since you have wirtten</p>

<pre><code>using namespace std
</code></pre>

<p>it has become visible and hence the conflicy</p>
",0
18247425,18247241,1,"<p>0xc0de answered the reason for the Visual Studio error and provided a good tip to simplify the calculation of feet and inches.</p>

<p>What others have pointed out is that the way you did it limits you to always adding exactly two distances into the existing distance. It's cleaner and you can chain additions limitlessly by providing operator+, operator+= and operator= on your distances class. This is a very common method for extending classes. It is true that you are only adding the internal values of the object, but that is very often the case.</p>
",0
18247428,18247241,1,"<p>You may overload the <code>+</code> operator as:</p>

<pre><code>distances&amp; operator+(const distances&amp; obj1)
{
inches+=(obj1.inches)%12;
feet+=obj1.feet + (obj1.inches)/12;
return *this;
}
</code></pre>

<p>The specific use of returning a reference to <code>this</code> pointer may help you to achieve </p>

<pre><code>distances a = b + c + d;
</code></pre>
",0
18247344,18247241,3,"<p>You are getting the error as there is already a class defined with the name 'distance' in <code>visual studio</code>'s <code>xutility</code> (don't know what this is, just got this from the error message).</p>

<p>Also you are re-inventing the division :), in instead of a while loop you can just do</p>

<pre><code>carry = int(inches / 12);
inches = int(inches) % 12;
feet += carry;
</code></pre>

<p>Also as you have been 'told' that this is wrong approach I can see 2 suggestions here. One, As this only works for 2 objects, you can make it work for multiple objects' addition, by adding in a loop. Instead of passing 2 objects as parameters, pass an array.
Two, as other answers pointed out, overloading the <code>+</code> operator is more intuitive.</p>
",3
16908119,16908063,3,"<p>I don't really know how to push you in the right direction without just giving you the answer, since it is so simple.</p>

<pre><code>template &lt;typename Iter&gt;
Iter // change 1
function(Iter first, Iter last, const int x)
{
  for (auto it = first; it!=last; ++it)
  {
    if (*it == x)
    {
      return it; // change 2
    }
  }
  return last; // change 3
}
</code></pre>

<p>By the way, this is exactly what <code>std::find</code> does.</p>
",1
17776866,17776850,2,"<p><code>greater()</code> should be replaced with <code>isGreater()</code> on line 9 within if.</p>
",0
17776883,17776850,1,"<p>Aside from fixing the <code>greater</code> call to make a call to  <code>isGreater</code> on line 9, you probably want to make sure that you pad the string with zero's until both strings are the same length, instead of just returning <code>true</code> or <code>false</code> in the first couple of lines in <code>isGreater</code>. </p>
",1
17776888,17776850,5,"<p>This is a good example why <code>using namespace std</code> is not always a good idea.</p>

<p>You've typo'd</p>

<pre><code>if(greater(""11"", ""00""))
</code></pre>

<p>which should really be </p>

<pre><code>if(isGreater(""11"", ""00""))
</code></pre>

<p>...and manage to hit the name of <a href=""http://www.cplusplus.com/reference/functional/greater/"" rel=""nofollow"">a class template defined in the <code>std</code> namespace</a> you've just imported whole-sale. Thereby the confusing error message.</p>
",0
14819731,14819618,6,"<p>You seem to write and read just one struct, but print 3. Last two are therefore garbage from stack.</p>

<p>Additionally, it would be prudent to zero out at least <code>ID</code>, preferably entire struct, to avoid undefined bytes in disk file (uninitialised bytes of <code>ID</code> in this case), for example for your particular code in question:</p>

<pre><code>memset (dailytrans, 0, sizeof(dailytrans)); // this depends on dailytrans size being known at compile time
</code></pre>
",1
15841186,15841027,0,"<p>Wild guess this one. Maybe you could use the GetForegroundWindow function and check the handle against your test window handle. Possibly a better method is for your test window to handle the WM_KEYDOWN message. My understanding is that this message is only posted if the window has focus.</p>
",0
16428016,16427907,3,"<p>The problem is two fold.  First your use of srand and your use of time.  When you seed a random number generator using time(), time is the number of seconds from some date in 1973, I forget the exact date, but it's known as linux time.  Since you seed every time, you're resetting the random number generator, this is a good practice, however, since you're seeding it with something returning a number in seconds, it is likely your program is taking less than a second to run.  Either do as someone else suggest, and seed the random number generator only once, or seed in something with a finer granularity... ms is probably acceptable.  </p>
",4
16427932,16427907,8,"<pre><code>int maior_sequencia()
{
    int random;
    srand(time(NULL)); 
    //^^This will reset random seed every time you call this function
    int maior_sequencia = rand() % 6+1;
    printf(""%i"", maior_sequencia);
    return 1;
}
</code></pre>

<p>Since you reset the random seed every time you call the <code>maior_sequencia</code>function, therefore, it will give you same value.</p>

<p>Try to put</p>

<pre><code>srand(time(NULL));
</code></pre>

<p>inside <code>main</code> before the for loop instead.</p>
",2
15839125,15834041,0,"<p>Expanding on an earlier comment:</p>

<p>Many compilers will but the debug and release versions of the executable in different directories. If <code>file.open(""templog.txt"");</code> works in release mode but not in debug mode, that's likely because the input file is located in the same directory as that version of the executable.</p>

<p>To make sure that you always find the file, use a full path name when calling the <code>open()</code> function.</p>
",0
18287149,18287129,5,"<pre><code>else if(i=4);
</code></pre>

<p>should be</p>

<pre><code>else if(i==3)
</code></pre>

<p>So there were three problems on this line:</p>

<ul>
<li>Using <code>=</code> instead of <code>==</code>. <code>=</code> sets the value of something, so <code>i</code> will be set to <code>4</code> which will end the loop. Use <code>==</code> to <em>compare</em> values.</li>
<li>The value you want to compare against is <code>3</code>, not <code>4</code> because the vector is only 4 long, and the loop index will only reach <code>4 - 1</code>.</li>
<li>The <code>;</code> after the <code>else</code> is the body of the <code>else</code>, so the else will actually do nothing.</li>
</ul>
",1
15890026,15889973,1,"<p>From what you have shown, I think this might be what you want.</p>

<pre><code>int main()
{
    string comment;
    int nr1,nr2;
    // Read the first number. It should be the first one always. No comment before number!
    cin &gt;&gt; nr1;            

    // See if we can read the second number Successfully. Which means it is an integer.
    if(cin &gt;&gt; nr2) {
    } 
    // Otherwise clear cin and read the rest of the comment line                        
    else {
        cin.clear();           
        getline(cin,comment);
        // Now read the second number from the second line
        cin &gt;&gt; nr2;           
    }
    // Read the rest of second the line.
    getline(cin,comment);   

    cout &lt;&lt; ""result: "" &lt;&lt; nr1 + nr2 &lt;&lt; endl;
    return 0;
}
</code></pre>
",2
15890556,15889973,0,"<p>Will any number of numbers based on the value you give <code>reqd</code>.
Will also work if the first character in a line itself is <code>#</code> - will ask again for that line. Will also read another line if there is no number before the `#.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;ctype.h&gt;

using namespace std;

int main ()
{
    const int reqd = 2;
    string sno[reqd];
    int no[reqd];
    int got = 0;
    size_t pos;
    istringstream is;

    cout&lt;&lt; ""Enter ""&lt;&lt;reqd&lt;&lt;"" numbers to be added:\n"";
    while(got &lt; reqd)
    {
        getline(cin, sno[got]);
        if((pos = sno[got].find('#')) &amp;&amp; isdigit(sno[got][0]))
        {
            is.str(sno[got]);
            is&gt;&gt;no[got];
            ++got;
        }
    }

    int sum = 0;
    for(int i = 0; i &lt; reqd; ++i)
        sum+=no[i];

    cout&lt;&lt;""Result : ""&lt;&lt;sum;
    return 0;
}
</code></pre>
",5
17087016,17084394,0,"<p><code>tklist</code> is an array of pointers. On line </p>

<pre><code>tklist[tknIndex] = (char *) malloc(tknLength +1);
</code></pre>

<p>you are assigning a pointer to an element of the array <code>tklist[]</code>. The <code>tklist</code> itself is not changed! only its elements are assigned value.
Therefore, when you do <code>cout&lt;&lt;tklist&lt;&lt;endl;</code> the <code>tklist</code> always prints the address it is pointing.</p>

<p>Another thing on your main program <code>*tokenList</code> is not initialized, so it is pointing an arbitrary address (0x7fffd3762c70).</p>

<p>I suggest you should allocate memory for <code>*tokenList</code> once in your main() before calling <code>parseCommandLine(line, tokenList);</code> and only print <code>cout&lt;&lt;tklist+tknIndex&lt;&lt;endl;</code> in <code>parseCommandLine()</code>.</p>
",0
16378426,16378401,4,"<p>Use <code>==</code> rather than <code>=</code>. <code>=</code> assigns the right-hand side to the left-hand side and then evaluates the new value. In C++, any value other than 0 will evaluate to <code>true</code>, so your first if-statement always executes.</p>

<pre><code>if(friendsex == 'm'){
    cout &lt;&lt; ""If you have, could you please tell him to call me?"";
}
else if(friendsex == 'f'){
    cout &lt;&lt; ""If you have, could you please tell her to call me?"";
}
</code></pre>
",6
16378444,16378401,1,"<p>The first one gets run because you set <code>friendsex</code> to 'm'. <code>friendsex = 'm'</code> should be <code>friendsex == 'm'</code>. Same for 'f'.</p>
",3
16378458,16378401,-1,"<p>Use == instead of = 
Don't use  'm; as I believe you are trying to use local variables.</p>

<p>if(friendsex == m){
    .............
}
else if(friendsex == f){
   .................
}</p>
",3
16379013,16378401,0,"<p>if statements cant be executed by using ""="" which is assignment operator. 
Use "" == "" for comparing</p>
",0
15893026,15893003,4,"<p>You should define your functions in a namespace, and use the namespace when calling them.</p>

<pre><code>namespace myNamespace
{
    int myFunc(etc) { ... }
}

int main() {
    cout &lt;&lt; myNamespace::myFunc();
}
</code></pre>

<p>To avoid having to specify your namespace all the time, you could do something like this:</p>

<pre><code>namespace myNamespace
{
    int myFunc(etc) { ... }

    int main() 
    {
        // Call your own myFunc:
        myFunc();

        // Call their myFunc:
        ::myFunc();
    }
}
</code></pre>
",4
18134676,18134065,2,"<pre><code>if(r+1 != 9 &amp;&amp; c+1 != 9 &amp;&amp; realmap[r+1][c=1] ==10
</code></pre>

<p>I have no clue what any part of your code actually does or checks, but this will reset c to 1 every pass that the first two conditions are satisfied and thus cause an infinite loop.</p>
",0
16449914,16449889,124,"<pre><code>const T&amp; get_data() const { return data_; }
^^^^^
</code></pre>
<p>means it will return a <code>const</code> reference to <code>T</code> (here <code>data_</code>)</p>
<pre><code>Class c;
T&amp; t = c.get_data()             // Not allowed.
const T&amp; tc = c.get_data()      // OK.
</code></pre>
<hr />
<hr />
<pre><code>const T&amp; get_data() const { return data_; }
                    ^^^^^
</code></pre>
<p>means the method will not modify any member variables of the class (unless the member is <code>mutable</code>).</p>
<pre><code>void Class::get_data() const {
   this-&gt;data_ = ...;  // is not allowed here since get_data() is const (unless 'data_' is mutable)
   this-&gt;anything = ... // Not allowed unless the thing is 'mutable'
}
</code></pre>
",4
16449923,16449889,3,"<pre><code>const T&amp; data() const { return data_; }
</code></pre>

<p>const after member function indicates that data is a constant member function and in this member function no data members are modified.</p>

<p>const return type indicates returning a constant ref to T</p>
",0
16449937,16449889,5,"<p>The first <code>const</code> means the function is returning a <code>const T</code> reference.</p>

<p>The second one says that the method is not changing the state of the object. I.e. the method does not change any member variables.</p>
",0
16449976,16449889,27,"<p>The <code>const</code> (and <code>volatile</code>) qualifier <strong>binds to the left</strong>. This means that any time you see <code>const</code>, it is being applied to the token to the left of it. There is one exception, however; if there's nothing to the left of the <code>const</code>, it binds to the right, instead. It's important to remember these rules.</p>

<p>In your example, the first <code>const</code> has nothing to the left of it, so it's binding to the right, which is <code>T</code>. This means that the return type is a reference to a <code>const T</code>.</p>

<p>The second const does have something to the left of it; the function <code>data()</code>. This means that the <code>const</code> will bind to the function, making it a <code>const</code> function.</p>

<p>In the end, we have a <em>const function returning a reference to a const T</em>.</p>
",0
17389640,17389630,2,"<p>In C++ the operator = is assignment and if you want to compare two values you must use ==, so the if should be <code>if (y == 9)</code> and also you don't want the semicolon right after the if statement.</p>
",0
17389641,17389630,4,"<p>It should be:</p>

<pre><code>if (y == 9) {
  cout &lt;&lt; ""notgood"";
 }         
</code></pre>

<p><code>=</code> is for assignment, <code>==</code> is for comparison. And the <code>;</code> immediately after the <code>if</code> was terminating the statement.</p>

<p>You need to bone up on your basic syntax, SO is not a tutoring service.</p>
",0
17389643,17389630,1,"<p>you need to use  == <code>(y == 9)</code></p>

<p>a single = means assignment</p>
",0
17389665,17389630,2,"<p>A good way to avoid making the mistake others have already pointed out, you can switch the places of the two operands, e.g.:</p>

<pre><code>if (9 == y)...
</code></pre>

<p>This way, if you accidentally mistake the <code>==</code> operator for the <code>=</code> operator, you will get an error for trying to assign no a non lvalue.</p>
",2
17389680,17389630,1,"<p>You'll get both out as written.  Try it like this: </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;windows.h&gt;

using namespace std;

int main() {
    int y;
    cin&gt;&gt; y;
    if (y == 9) {
        cout&lt;&lt; ""notgood"";
    } else {
        cout&lt;&lt; ""good"";
    }
    system(""pause&gt;nul"");
    return 0;
}
</code></pre>

<p>Don't know what the number 9 did to be considered ""not good""...</p>

<p>If you're learning, start thinking about developing a consistent style for brace placement, use of whitespace, etc.  It'll make your code easier to read, understand, and debug.  Randomness makes you look sloppy and your code harder to understand.</p>
",3
16396165,16396130,18,"<p>First variant - use <code>inline</code> specifier</p>

<pre><code>#ifndef UTIL_H_
#define UTIL_H_

inline int aplusb(int a, int b) {
    return a + b;
}

#endif /* UTIL_H_ */
</code></pre>

<p>Second variant - write definition in <code>.cpp</code> file.</p>
",3
16396170,16396130,0,"<p>Header files are not intended to have actual functions in them (certain C++ aspects such as templates not withstanding). General practice in your case would have you changing your UTIL.H to just prototyping the function (<code>int aplusb(int a, int b);</code>) and moving its implementation to a source file.</p>
",3
16396202,16396130,5,"<p>You created the function aplusb in your include file. This means that for every file you include it to, a public function aplusb will be created, resulting in a name clash.</p>

<p>If the function should be inline, then mark it so. If the function should be a template, then mark it so. If the function should be as you wrote it, put it in a cpp file and just keep the protoype in the h file.</p>

<pre><code>.h
#ifndef UTIL_H_
#define UTIL_H_

int aplusb(int a, int b);

#endif

.cpp
int aplusb(int a, int b)
{
    return a+b;
}
</code></pre>
",0
16396301,16396130,2,"<p>You should declare your aplusb function in the header file, and provide the definition in a cpp file. Something like</p>

<p>util.h:</p>

<pre><code>#ifndef UTIL_H_
#define UTIL_H_

int aplusb(int, int);

#endif /* UTIL_H_ */
</code></pre>

<p>The error message is telling you that each time that you include the util.h file, you are re-defining the function, which is exactly what you are doing :-) This is a violation of the <a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow"">ODR</a> (one-definition-rule), which states that the definition (of a function, in this case) must be unique. Otherwise the compiler would be unable to choose between the alternatives (even if, like in this case, they happen to be equal).</p>

<p>Note that templates complicate the matter a bit (in short, because a template is not a definition until instatiated).</p>
",0
16370448,16349780,3,"<p>This can be done fairly easily using a <code>std::tuple</code> to specify your list of types.  All we need to do is declare the primary template to take two parameters, then create a partial specialization where those type parameters are tuples.  In the partial specialization, we can use the argument deduction to capture the template parameters of the tuple and re-use them for our purposes.  We could create a new template for the purposes of specifying the list of types (i.e. <code>Types&lt;int,double&gt;</code>), but a tuple is especially nice in this case because you need to have a way to access the the individual rows anyway, and a <code>std::tuple</code> provides a built-in way to do this through <code>std::get&lt;i&gt;</code>.  Using the tuple for the template parameters may make it more obvious that you use <code>std::get</code> to access the rows.</p>

<p>Here's a complete example:</p>

<pre><code>#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

// primary template
template &lt;typename RowTuple,typename RowInfoTuple&gt; struct Rows;

// variadic partial specialization 
template &lt;typename... RowTypes,typename... RowInfoTypes&gt;
struct Rows&lt;std::tuple&lt;RowTypes...&gt;,std::tuple&lt;RowInfoTypes...&gt;&gt;
{
  // use variadic expansion to make a tuple of vectors
  std::tuple&lt;std::vector&lt;RowTypes&gt;...&gt; rows;
  std::tuple&lt;RowInfoTypes...&gt; rowinfos;
};

struct rss_feed { };

int main(int,char**)
{
  Rows&lt;
    std::tuple&lt;double,int&gt;,
    std::tuple&lt;std::string,rss_feed&gt;
  &gt; data;

  std::get&lt;0&gt;(data.rows).push_back(1.5);
  std::get&lt;1&gt;(data.rows).push_back(2);
  std::get&lt;0&gt;(data.rowinfos) = ""info"";
  std::get&lt;1&gt;(data.rowinfos) = rss_feed();
  return 0;
}
</code></pre>
",3
15802107,15802084,1,"<p>Change the code to as follows:</p>

<pre><code>while(ss &gt;&gt; parm)
{
   cout &lt;&lt; parm &lt;&lt; endl;

   if(parm.compare(""value"") == 0)
        cout &lt;&lt; ""Got value."" &lt;&lt; endl;
}
</code></pre>

<p>The problem I suspect is with <code>while(!ss.eof())</code>. See <a href=""https://stackoverflow.com/questions/5605125/why-is-iostreameof-inside-a-loop-condition-considered-wrong"">Why is iostream::eof inside a loop condition considered wrong?</a> for a detailed explanation.</p>

<pre><code>//string parm;   final string won't get double output if declare here
</code></pre>

<p>If you declare <code>string parm</code> inside the loop, you get an empty string every time it loops. When <code>ss &gt;&gt; parm</code> fails, nothing will be read into the string and it outputs an empty string.</p>
",0
17868196,17867997,5,"<p>This is almost certianly a typo:</p>

<pre><code>Fuzzy* fuzzy = new fuzzy();
</code></pre>

<p>Should be:</p>

<pre><code>Fuzzy* fuzzy = new Fuzzy();
                   ^
                Note Case!
</code></pre>
",3
17869121,17867997,1,"<p>This looks like a capitalization error, this:</p>

<pre><code>Fuzzy* fuzzy = new fuzzy();
</code></pre>

<p>should be:</p>

<pre><code>Fuzzy* fuzzy = new Fuzzy();
</code></pre>

<p>although, I don't think that it accounts for all the errors but without more code for context it is hard to know.</p>
",0
18296874,18296767,3,"<p>You need to compile both source files into <code>main.o</code> and <code>dictionary.o</code> and then link these object file together into the final executable:</p>

<pre><code>$ g++ -c main.cpp
$ g++ -c dictionary.cpp
$ g++ -o myexe main.o dictionary.o
</code></pre>

<p>Or you can build and link in one go:</p>

<pre><code>$ g++ -o myexe main.cpp dictionary.cpp 
</code></pre>

<p>You'd normally create a <code>Makefile</code> to take the drudgery out of this process, which might be as little as (untested):</p>

<pre><code>myexe: main.o dictionary.o
</code></pre>

<p>Then it's simply:</p>

<pre><code>$ make
</code></pre>
",1
18296821,18296767,1,"<p>Are you sure that your <code>dictionary.cpp</code> is included to your project and built without errors?
Linker can't find those functions in object-files after compilation, check out full log for compilation error or success of your <code>dictionary.cpp</code> file.</p>
",0
15582864,15582851,4,"<p>The type is named <code>uint64_t</code>. Same goes for <code>uint32_t</code>, <code>uint16_t</code>, <code>uint8_t</code>, etc.</p>

<p><code>uint</code> doesn't exist. You might have intended simply <code>unsigned int</code>.</p>
",1
15583235,15583173,1,"<p>For listing files in a directory on Windows, refer to this link:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa365200(v=vs.85).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa365200(v=vs.85).aspx</a></p>

<p>Notes about your code:</p>

<ol>
<li><p>don't use <code>fin.eof()</code> to test the end of input, see why: <a href=""https://stackoverflow.com/questions/8815679/eof-of-istream-in-c"">eof of istream in C++</a></p></li>
<li><p>to read multiple files, remember <code>fin.clear()</code> before <code>fin.close</code> if you use the same <code>fin</code> to read multiple files.</p></li>
</ol>

<p>UPDATE:</p>

<p>The following code prints out the files name in a directory <code>D:\\Test</code>.  If you need absolute path for every file or files in subfolders, change <code>GetFiles</code> to do that.  This is pretty straightforward according to the link I provided. The code is test on VS2012 Win7 Pro.</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;Shlwapi.h&gt;

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

#pragma comment(lib, ""Shlwapi.lib"")

int GetFiles(const string &amp;path, vector&lt;string&gt; &amp;files, const string &amp;wildcard = ""\\*"")
{
    wstring basepath(path.begin(), path.end());
    wstring wpath = basepath + wstring(wildcard.begin(), wildcard.end());

    WIN32_FIND_DATA ffd;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    DWORD dwError = 0;

    hFind = FindFirstFile(wpath.c_str(), &amp;ffd);

    if (INVALID_HANDLE_VALUE == hFind) {
        // display error messages
        return dwError;
    }

    TCHAR buf[MAX_PATH];
    do {
        if (ffd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
            // directory
        } else {
            PathCombine(buf, basepath.c_str(), ffd.cFileName);
            wstring tmp(buf);
            files.push_back(string(tmp.begin(), tmp.end()));
        }
    } while (FindNextFile(hFind, &amp;ffd));

    dwError = GetLastError();
    if (ERROR_NO_MORE_FILES != dwError) {
        // some errors
    }
    FindClose(hFind);
    return dwError;
}

int main()
{
    string path(""D:\\Documents\\Visual Studio 2012\\Projects\\SigSpatial2013"");
    vector&lt;string&gt; files;
    GetFiles(path, files);
    string line;
    ifstream fin;
    for (int i = 0; i &lt; files.size(); ++i) {
        cout &lt;&lt; files[i] &lt;&lt; endl;

        fin.open(files[i].c_str());
        if (!fin.is_open()) {
            // error occurs!!
            // break or exit according to your needs
        }

        while (getline(fin, line)) {
            // now process every line
        }

        fin.clear();
        fin.close();
    }
}
</code></pre>
",6
15583241,15583173,1,"<p>I think it's easier:</p>

<p>1- if you factor out the code that reads a file and process its content into its own function: <br/><code>void process_file( char* filename );</code><br/>
2- add a new function to list a directory's content: <code>char** list_dir( char* dir );</code><br/>
3- combine the 2 functions in your main()<br/><br/></p>

<p>this makes for cleaner and more testable code</p>
",0
15583283,15583173,1,"<p>I agree with the suggestions to encapsulate this.
On Windows the code looks like this</p>

<pre><code>HANDLE h;
WIN32_FIND_DATA find_data;
h = FindFirstFile( ""*.dat"", &amp; find_data );
if( h == INVALID_HANDLE_VALUE ) {
    // Error
    return;
}
do {
    char * s = find_data.cFileName;
            // Your code here
} while( FindNextFile( h, &amp; find_data ) );
FindClose( h );
</code></pre>
",5
17093191,17093171,3,"<p>You need to declare <code>meridiem</code> <em>outside</em> the if block. You also need to use <code>=</code> to assign to <code>meridiem</code> after it's declared:</p>

<pre><code>string meridiem;                                                               /*
^^^^^^^^^^^^^^^^                                                               */

if (midHour &lt;= 12)
{
    midHour12 = midHour;
    meridiem = ""AM"";                                                           /*
    ^^^^^^^^^^^^^^^^                                                           */
}
else
{
    midHour12 -= 12;
    meridiem = ""PM"";                                                           /*
    ^^^^^^^^^^^^^^^^                                                           */
}
</code></pre>

<p>Otherwise the variable will go out of scope by the ending bracket.</p>
",1
17093192,17093171,2,"<p>You should declare <code>meridiem</code> first:</p>

<pre><code>   int midHour12;
    string meridiem;
    if(midHour &lt;= 12)
    {
        midHour12 = midHour;
        meridiem = ""AM"";
    }
    else
    {
        midHour12 = midHour - 12;
        meridiem = ""PM"";
    }
    cout &lt;&lt; meridiem;
</code></pre>

<hr>

<p>Or if You don't need <code>meridiem</code> later, just print <code>midHour12</code>, and in the if-else print ""AM"" or ""PM""</p>
",1
17093231,17093171,2,"<p>You have to declare <code>meridiem</code> before the if-else block because variables declared inside the <em>{...}</em> can be only seen from inside the block.</p>

<pre><code>string meridiem;

int midHour = 15;
int midHour12 = midHour - 12;
if(midHour &lt;= 12)
{
    midHour12 = midHour;
    meridiem = ""AM"";
}
else
{
    midHour12 = midHour - 12;
    meridiem = ""PM"";
}
cout &lt;&lt; midHour12 &lt;&lt; meridiem;
</code></pre>
",0
17093539,17093171,2,"<p>c++11 lambda answer just for fun:</p>

<pre><code>#include &lt;string&gt;

 auto currentTime = [](int midHour)
 {
    return (midHour &lt;= 12) ? std::to_string(midHour) + ""AM"" : std::to_string(midHour - 12) + ""PM"";
 }

 cout &lt;&lt; currentTime(15);
</code></pre>
",1
17099099,17079146,0,"<p>Not sure if this is why you are getting an error, but I know I've had issues when using templates inside of templates like this because you end up with "">>"" somewhere in the code which means something very different than likely intended.</p>

<p>"">>"" is the bitwise right shift operator in C++</p>

<p>To fix it you just have to put a space between them. For example:
instead of this:</p>

<pre><code>vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt;::const_iterator
</code></pre>

<p>do this:</p>

<pre><code>vector&lt;vector&lt;vector&lt;string&gt; &gt; &gt;::const_iterator
</code></pre>

<p>Of course, I haven't tried compiling your code, this is just an observation looking at the example code.</p>
",0
17080937,17079146,2,"<p>Using Boost Spirit karma:</p>

<pre><code>std::cout &lt;&lt; format_delimited(auto_, ' ', v) &lt;&lt; ""\n"";
</code></pre>

<p>Prints</p>

<pre><code>a0 a1 a2 a1 a2 a3 a2 a3 a4 a3 a4 a5 b0 b1 b2 b1 b2 b3 b2 b3 b4 b3 b4 b5
</code></pre>

<hr>

<pre><code>std::cout &lt;&lt; format(auto_ % ',' % ' ' % eol , v) &lt;&lt; ""\n"";
</code></pre>

<p>Prints</p>

<pre><code>a0,a1,a2 a1,a2,a3
a2,a3,a4 a3,a4,a5
b0,b1,b2 b1,b2,b3
b2,b3,b4 b3,b4,b5
</code></pre>

<hr>

<pre><code>std::cout &lt;&lt; format_delimited( (""{\n"" &lt;&lt; (""\t{"" &lt;&lt; *auto_ &lt;&lt; '}') % eol &lt;&lt; ""\n}\n"") % eol, ' ', v) &lt;&lt; ""\n"";
</code></pre>

<p>Prints</p>

<pre><code>{
    { a0 a1 a2 } 
    { a1 a2 a3 } 
}

 {
    { a2 a3 a4 } 
    { a3 a4 a5 } 
}

 {
    { b0 b1 b2 } 
    { b1 b2 b3 } 
}

 {
    { b2 b3 b4 } 
    { b3 b4 b5 } 
}
</code></pre>

<p>Or you could use old fashioned range-based for:</p>

<pre><code>for (auto&amp; d1 : v) {
    for (auto&amp; d2 : d1) {
        for (auto&amp; d3: d2)
            std::cout &lt;&lt; d3 &lt;&lt; "" "";
        std::cout &lt;&lt; ""\n"";
    }
    std::cout &lt;&lt; ""\n"";
}
</code></pre>

<p>Full demo:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;boost/spirit/include/karma.hpp&gt;

namespace karma = boost::spirit::karma;

int main()
{
    const std::vector&lt;std::vector&lt;std::vector&lt;std::string&gt;&gt;&gt; v { { 
                { ""a0"", ""a1"", ""a2"" },
                { ""a1"", ""a2"", ""a3"" },
            }, {
                { ""a2"", ""a3"", ""a4"" },
                { ""a3"", ""a4"", ""a5"" },
            },
            {
                { ""b0"", ""b1"", ""b2"" },
                { ""b1"", ""b2"", ""b3"" },
            },
            {
                { ""b2"", ""b3"", ""b4"" },
                { ""b3"", ""b4"", ""b5"" },
     } };

    for (auto&amp; d1 : v) {
        for (auto&amp; d2 : d1) {
            for (auto&amp; d3: d2)
                std::cout &lt;&lt; d3 &lt;&lt; "" "";
            std::cout &lt;&lt; ""\n"";
        }
        std::cout &lt;&lt; ""\n"";
    }

    using namespace boost::spirit::karma;
    std::cout &lt;&lt; format_delimited(auto_, ' ', v) &lt;&lt; ""\n"";
    std::cout &lt;&lt; format(auto_ % ',' % ' ' % eol , v) &lt;&lt; ""\n"";
    std::cout &lt;&lt; format_delimited( (""{"" &lt;&lt; *auto_ &lt;&lt; ""}""), ' ', v) &lt;&lt; ""\n"";
    std::cout &lt;&lt; format_delimited( (""{\n"" &lt;&lt; (""\t{"" &lt;&lt; *auto_ &lt;&lt; '}') % eol &lt;&lt; ""\n}\n"") % eol, ' ', v) &lt;&lt; ""\n"";
}
</code></pre>
",0
17079483,17079146,4,"<p>It just doesn't know how to print <code>*i</code> element (which has type <code>vector&lt;vector&lt;string&gt;&gt;</code>). You need two more internal loops to print each string element.</p>
",0
17079870,17079146,2,"<p>You can do:</p>

<pre><code>for( vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt;::const_iterator i = masterList.begin(); i != masterList.end(); ++i)
{
   for( vector&lt;vector&lt;string&gt;&gt;::const_iterator j = i-&gt;begin(); j != i-&gt;end(); ++j)
   {
        for( &lt;vector&lt;string&gt;::const_iterator k = j-&gt;begin(); k != j-&gt;end(); ++k)
        { 
                 cout&lt;&lt;*k&lt;&lt;' ';
        }
   }
}
</code></pre>
",1
15803185,15802221,1,"<blockquote>
  <p>How safe is it to assume that all the x, y, z in bigBunch will be
  contiguous?</p>
</blockquote>

<p>Not safe. Compiler has freedom to pad. Depends on <code>T</code></p>

<blockquote>
  <p>a pointer to bigBunch[0].a.x would point to the same place as just
  saying `bigBunch[0].a.</p>
</blockquote>

<p>This is safe assumption.</p>

<blockquote>
  <p>Would it matter if Pair.a and Pair.b were the same or different type,
  such as mixing ints and float rather than both being the same type
  (float in this example)?</p>
</blockquote>

<p>It is not safe to assume. For <code>int</code> and <code>float</code>, we may be lucky, but may not be the case for <code>short</code> and <code>int</code></p>

<p>The padding story changes between a 32-bit machine and a 64-bit machine. If you want your code to work on all architectures, you cannot make assumptions about padding and alignment. </p>

<p>For a general discussion, see <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">http://en.wikipedia.org/wiki/Data_structure_alignment</a></p>

<p>In summary, never assume anything about padding in your program :-)</p>
",0
15802304,15802221,1,"<blockquote>
  <p>However, I thought padding is only a risk if your struct elements are different types.</p>
</blockquote>

<p>That isn't quite accurate, it is mainly related to how much space everything takes in memory.</p>

<p>Your example uses <code>float</code> which is 4 bytes and thus won't cause padding. The entire purpose of padding is to speed up memory access, 4 byte objects on 4 byte boundaries are fine.</p>

<p>So you should be able to assume you have a stream of <code>float</code>, but you probably wouldn't if <code>Pair</code> where on <code>bool</code>. The reason I say that is because it may decide that <code>b</code> would work best on a 4 byte boundary, which would introduce a byte of padding.</p>
",0
15802899,15802221,1,"<p>AFAIK, nothing in the standard precludes the compiler from adding padding if it thinks it's a good idea. The compiler really has a lot of leeway in this matter. Which means the best thing to do is to be defensive and explicitly instruct your compiler to pack the data, even if eg, 4 byte float on 4 byte boundaries <em>shouldn't</em> cause padding.</p>

<p>My other recommendation is to use <code>static_assert</code> to verify everything is the size you want. Eg,</p>

<pre><code>template &lt;typename T&gt;
struct A{
  //...many public member functions...
  T x;
  T y;
  T z;
} __attribute__ ((__packed__));
static_assert(sizeof(A) == 3*sizeof(T), ""struct A shouldn't be padded"");
</code></pre>

<p>If you don't have C++ 11, you can use <a href=""http://www.boost.org/doc/libs/1_53_0/doc/html/boost_staticassert.html"" rel=""nofollow""><code>BOOST_STATIC_ASSERT</code></a> instead. EDIT: the <code>__attribute__ ((__packed__))</code> bit after struct's closing brace is GCC-specific way of ensuring tightly packed struct.</p>

<p>Another thing you should consider is if you really get a benefit out of being able to treat your <code>vector&lt;Pair&gt;</code> as a big <code>float</code> array with no gaps. I understand that may make some algorithms more convenient to write if you have to iterate over everything, or if you have to pass the data to some other library that expects contiguous data. But I'm guessing you are doing a lot of math with these structs, and your compiler may be able to auto-vectorize some of it, eg by using SSE if <code>struct A</code> was 128-bit aligned. There is a lot of guesswork on my part in this part of my answer, so ignore it if it doesn't apply to you.</p>

<p>PS: don't forget the semicolon after the closing brace of your structs.</p>
",20
15827474,15827444,1,"<p>You should use <a href=""http://www.boost.org/doc/libs/release/libs/ptr_container/doc/ptr_vector.html"" rel=""nofollow noreferrer""><code>boost::ptr_vector</code></a> instead. The interface is the same, but it handles memory management for you. <a href=""https://stackoverflow.com/q/3822612/160206"">See this question</a> for some guidelines about whether to use <code>ptr_vector</code> or <code>vector&lt;shared_ptr&lt;&gt;&gt;</code>.</p>
",2
15827476,15827444,3,"<p>This works (with a few caveats) but is not considered idiomatic C++, for good reason.</p>

<p>You should strongly consider using a vector of smart pointers (or a smart vector like <code>boost::ptr_vector</code>) instead, in order to avoid having to do manual memory management.</p>

<p>This would also give you exception safety for free, and would also avoid nasty ownership issues that occur if your outer class is copyable.</p>
",3
15827511,15827444,2,"<p>As no one gave you straight forward answer yet - yes, it is acceptable and this is the only way to free this memory, having this declaration of the <code>vector</code>.</p>

<p>This can and should be avoided, using smart pointers, as @OliCharlesworth suggested or using some other container, ponited by @Bj?rnPollex.</p>
",1
15555946,15555524,0,"<p>Difficult to tell without seeing the code. You can have a look at how the linker works in <a href=""https://stackoverflow.com/a/12573818/401200"">this post</a>. In your case, the error most likely comes from one of:</p>

<ul>
<li>you are trying to use a function or method you declared in the header file, but forgot to define in the source file.</li>
<li>you are calling the linker with only the object file for <code>testdice</code> and forgot the object file for <code>dice</code>.</li>
<li>is the undefined function yours? if not, you most likely need to add external libraries to the linker.</li>
</ul>

<p>To narrow it down, try to use other functions defined in <code>testdice.cpp</code>. If that results in more linker errors, you are most likely not linking everything together. If it doesn't add more errors, you most likely forgot to define the function, or the prototype is slightly different in the source file and the header file. </p>
",0
15556166,15555524,0,"<p>For your code to be linkable as an executable it must have either a <code>main()</code> (or <code>WinMain()</code> for GUI programs) entry point.  A class on its own is not a complete program in C++ - execution starts from the <code>main()</code> function.</p>

<p>For some reason, even for non-GUI apps the MinGW linker will complain about absence of <code>WinMain()</code> rather than <code>main()</code> but either will resolve the link.</p>

<p>You must normally provide the <code>main()</code> or <code>WinMain()</code> function, the exception being when you are using an application framework (usually GUI) that provides it internally.</p>

<p>In most cases to use a class you must instantiate an object of that class and invoke its member functions through that instance.  Static member functions do not need an object instance.</p>

<p>Example:</p>

<pre><code>// main.cpp
#include &lt;iostream&gt;
#include ""dice.h""

int main()
{
    cDice myDie ;
    std::cout &lt;&lt; ""Throw = "" &lt;&lt; myDie.roll() ; 
}
</code></pre>
",3
15904017,15903914,3,"<p>Python's <code>exec</code>, and similar features in other languages (i.e. <code>eval</code> in JavaScript) only work because those are <em>interpreted</em> languages where variables are defined at <em>run time</em>.</p>

<p>You can't do what you're asking in directly C++ because it's a compiled language that requires that all variables and their names are known at <em>compile time</em>.</p>
",7
18183189,18182527,1,"<p>There's a <a href=""http://www.siao2.com/2006/06/25/646701.aspx"" rel=""nofollow"">pretty good description by Michael Kaplan</a>. In short, you can't and shouldn't copy files there because it is a virtual view. Instead, use the appropriate method: Call <code>AddFontResourceEx</code>, pass the appropriate flags. If the font is system-wide available,  broadcast <code>WM_FONTCHANGE</code>. To install the font permanently, you require admin rights (ie. UAC elevation), because you need to list the font filename under <code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</code>. </p>

<p>You might want to consider doing these steps from your installer instead, since that usually runs with the necessary permissions.</p>
",1
16429856,16429784,1,"<p>The innermost cycle reuses i, which is the variable of the outermost cycle. Use another letter for that.</p>

<p>It is also strange that if you want to read 10 elements, why you have an array and corresponding loops of 11.
Moreover, you can limit your loops with &lt; count instead of &lt;= 10.</p>
",0
16430111,16429784,3,"<p>Since the question is tagged as C++, you may as well make use of C++ idioms in the code. Let <code>sort</code> and <code>unique</code> do the heavy lifting.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main(int argc, const char * argv[])
{
   vector&lt;int&gt; v;

   cout &lt;&lt; ""Please input 10 integers, hitting return after each one \n"";
   for( int i = 0; i &lt; 10; i++ ) {
      int num;
      cin &gt;&gt; num;
      v.push_back(num);
   }

   sort( v.begin(), v.end() );
   v.erase( unique( v.begin(), v.end() ), v.end() );

   cout &lt;&lt; endl &lt;&lt; "" You entered "" &lt;&lt; v.size() &lt;&lt; "" unique numbers: "" &lt;&lt;  endl;
   copy( v.begin(), v.end(), ostream_iterator&lt;int&gt;( cout, "" "" ) );
}
</code></pre>
",2
16430630,16429784,2,"<p>Here is the solution with set I mentioned in @chr's solution:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

using namespace std;

int main(int argc, const char* argv[])
{
   set&lt;int&gt; s;

   cout &lt;&lt; ""Please input 10 integers, hitting return after each one \n"";
   for( int i = 0; i &lt; 10; i++ ) {
      int num;
      cin &gt;&gt; num;
      s.insert(num);
   }
   cout &lt;&lt; endl &lt;&lt; "" You entered "" &lt;&lt; s.size() &lt;&lt; "" unique numbers: "" &lt;&lt;  endl;
   copy( s.begin(), s.end(), ostream_iterator&lt;int&gt;( cout, "" "" ) );
}
</code></pre>
",0
16401627,16401219,4,"<p>Looking at your code</p>

<pre><code>while(getline(read_file, fname))   
{
    if (fname == """")
        continue;

    cout &lt;&lt; ""You had ""&lt;&lt; fname &lt;&lt; "" health left\n"";
    cout &lt;&lt; ""You delt "" &lt;&lt; fname  &lt;&lt; "" damage\n"";
    cout &lt;&lt; ""There were "" &lt;&lt; fname &lt;&lt; "" enemies left\n"";
    system(""pause"");
}
</code></pre>

<p>it's fairly obvious that you're reading only one line, and printing it three times - you're not doing anything to <code>fname</code> between those outputs.</p>

<p>I recommend you stop reusing the same variable for multiple purposes, it's a source of many bugs.<br>
(The following assumes that there are no blank lines.)</p>

<pre><code>string health;
string damage;
string enemies;
while(getline(read_file, health) &amp;&amp; getline(read_file, damage) &amp;&amp; getline(read_file, enemies))   
{
    cout &lt;&lt; ""You had ""&lt;&lt; health &lt;&lt; "" health left\n"";
    cout &lt;&lt; ""You delt "" &lt;&lt; damage  &lt;&lt; "" damage\n"";
    cout &lt;&lt; ""There were "" &lt;&lt; enemies &lt;&lt; "" enemies left\n"";
}
</code></pre>

<p>If there are blank lines in the file, consider writing your own <code>getnonemptyline</code> function that skips blank lines.</p>
",0
16402076,16401219,0,"<p>Like molbdnilo said, you're only reading one line from the file and then trying to do three things with it.  If you wanted to keep re-using the same (oddly named) variable, you could do it like </p>

<pre><code>while(getline(read_file, fname)){
    if (fname == """")continue;
    cout &lt;&lt; ""You had ""&lt;&lt; fname &lt;&lt; "" health left\n"";
}

while(getline(read_file, fname)){
    if (fname == """")continue;
    cout &lt;&lt; ""You delt "" &lt;&lt; fname  &lt;&lt; "" damage\n"";
}

while(getline(read_file, fname)){
    if (fname == """")continue;
    cout &lt;&lt; ""There were "" &lt;&lt; fname &lt;&lt; "" enemies left\n"";
}

system(""pause"");
</code></pre>
",0
16954117,16954073,5,"<p>For:</p>

<pre><code>void functionA() {
    ClassA *a = new ClassA();
}
</code></pre>

<p>You must place <code>delete a;</code> inside the function to clean it:</p>

<pre><code>void functionA() {
    ClassA *a = new ClassA();
    // your other code here
    delete a;
}
</code></pre>

<p>Otherwise you will face a memory leak. This is unless you return the <code>a</code> variable somehow or pass it to some other place that frees it.</p>

<p>For:</p>

<pre><code>void functionA(){
    ClassA a = ClassA();
}
</code></pre>

<p><code>a</code> will get 'released' automatically if you define its destructor properly. It is still possible that some field inside <code>a</code> leak if  you do not properly clean up in the <code>ClassA</code> destructor.</p>
",1
16954156,16954073,3,"<blockquote>
  <p>Do I need to use the following code to release it?</p>
</blockquote>

<p>Yes, you have to release every <code>new</code> ed object.</p>

<blockquote>
  <p>Can c++ auto release the ClassA object's memory? </p>
</blockquote>

<p>You could use <em>smart pointers</em>:</p>

<pre><code>#include &lt;memory&gt;

void functionA(){
    std::unique_ptr&lt;ClassA&gt; a_ptr(new ClassA);
}
</code></pre>

<p>Memory allocated for <code>a_ptr</code> will be automatically realeased once <code>a_ptr</code> goes out of scope.</p>

<blockquote>
  <p>If I write codes like this</p>

<pre><code>void functionA(){
    ClassA a = ClassA();
}
</code></pre>
  
  <p>Does a automatically be released?</p>
</blockquote>

<p>Yes, it does.</p>
",0
16954161,16954073,1,"<p>You can use <a href=""http://www.cplusplus.com/reference/memory/unique_ptr/"" rel=""nofollow""><code>std::unique_ptr</code></a> to do this automatically:</p>

<pre><code>void functionA() {
    std::unique_ptr&lt;ClassA&gt; a(new ClassA());
    // don't release
}
</code></pre>
",0
16954164,16954073,1,"<p>Yes, you need to delete any dynamically allocated raw pointer. If you want to destroy it automatically when going out of scope, you can use some smartpointer included in C++11 standard like [<code>shared_ptr</code>][1] or [<code>unique_ptr</code>][2] or [<code>scoped_ptr</code>][3] in boost library:</p>

<pre><code> [1]: http://www.cplusplus.com/reference/memory/unique_ptr/
 [2]: http://www.cplusplus.com/reference/memory/shared_ptr/
 [3]: http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/scoped_ptr.htm
</code></pre>
",0
16954178,16954073,3,"<pre><code>void functionA(){
    ClassA a = ClassA();
}
</code></pre>

<p>Uhm, why write that? It's inefficient, confusing and completely unnecessary. What's wrong with:</p>

<pre><code>void functionA() {
    ClassA a;
}
</code></pre>

<p>Generally speaking, if you use <code>new</code> you must use <code>delete</code> when you no longer need the instance that you allocates with <code>new</code>. There are exceptions to that, of course, but you don't need to worry about them now. For now just remember: if you allocated it, with <code>new</code> you own it and must deallocate it with <code>delete</code>.</p>
",0
16426864,16426016,4,"<pre><code>struct car {};
car car;         // not a good variable name, but legal
struct car car1; // no error
</code></pre>

<p>Coming up with a better variable name would be good no matter what you name the type. This depends on what you're actually using the variable for.</p>

<pre><code>void shoot(Car target) {                     // in a game involving shooting at cars
void register(Car patient) {                 // in a program having something to with fixing cars
for (Car &amp;potential_winner : participants) { // in a racing game
</code></pre>

<hr>

<p>On upper-case type names; The types you define don't have to match the style of the standard library. Personally I prefer to have specialized, domain specific components be stylistically distinct from the generic components.</p>

<p>I like capitalizing application specific types. Whether I use <code>PascalCase</code> or <code>Caps_and_underscores</code> depends on the language.</p>
",0
16459056,16459006,5,"<p>What you need is a struct</p>

<pre><code>struct mydata
{
    int i;
    int j;
};
</code></pre>

<p>You can then do in your main:</p>

<pre><code>mydata x[5];

x[0].i = 1;
x[0].j = x[0].i++;
</code></pre>

<p>And so on</p>
",4
16459076,16459006,4,"<p>This can be accomplished in many ways.  You can use <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow""><strong><code>std::vector</code></strong></a> to create the array, and use <a href=""http://www.cplusplus.com/reference/utility/pair/?kw=pair"" rel=""nofollow""><code>std::pair&lt;T, U&gt;</code></a> as the element type, where <code>T</code> and <code>U</code> are whatever type you want.  </p>

<pre><code>std::vector&lt;std::pair&lt;T, U&gt;&gt; vec;
</code></pre>

<p>In C++11, you can use <a href=""http://www.cplusplus.com/reference/tuple/"" rel=""nofollow""><code>std::tuple</code></a> as well (if you want more than 2 elements per cell), </p>

<pre><code>std::vector&lt;std::tuple&lt;T, U, Z&gt;&gt; vec;
</code></pre>

<p>or you can use a custom struct/class if you want ""named"" elements:</p>

<pre><code>struct Foo {
  T i;
  U j;
};

std::vector&lt;Foo&gt; vec;
</code></pre>
",0
16459092,16459006,5,"<p>You should use a vector of pairs:</p>

<pre><code>std::vector&lt;std::pair&lt;TI, TJ&gt;&gt; v;
</code></pre>

<p>Where <code>TI</code> and <code>TJ</code> are respectively the types of your first and second cell elements.</p>

<p>Then add elements like this:</p>

<pre><code>v.push_back(std::make_pair(i, j));
</code></pre>

<p>And access them through:</p>

<pre><code>v[0].first // first cell
v[0].second // second cell
v[1].first // and so on
...
</code></pre>
",0
15891868,15891543,0,"<p>If you want to read in chunks of 20 characters from a file then you can try something like this, </p>

<pre><code>void readFromFile(char *input)  //Parameter is your filename
{
  ifstream file_input;
  file_input.open(input, ios::in);
  vector&lt;string&gt; vec;         // Optional in case you want to store these
   while (file_input.good()) {
    char arr[21] = """";
    file_input.read (arr,20);
    vec.push_back(arr);        //if you want to store these chunks into vector
 }
 file_input.close();
}
</code></pre>
",0
15892402,15891543,1,"<pre><code>#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main()
{
    std::string str;
    std::ifstream file(""test.txt"");

    std::copy_n(
        std::istreambuf_iterator&lt;char&gt;(file),
        20,
        std::back_inserter(str)
    );
}
</code></pre>

<p>Note that this isn't safe if the file in question has less than 20 chars.</p>
",0
15871079,15870897,1,"<p>First you have to read the csv file and store the lines in a vector, You can use this function to do that.</p>

<pre><code>vector&lt;string&gt; readCsvFileContent(const string file)
{
        vector&lt;string&gt; buffer;
        ifstream configFile;
        configFile.exceptions(ifstream::badbit);
        try
        {
            configFile.open(file.c_str(),ifstream::in);
            if(configFile.is_open())
            {
                string line;                
                while (getline(configFile,line))
                {
                    buffer.push_back(line);
                }
                configFile.close();
            }           
        }
        catch (ifstream::failure e){            
            throw e;
        }
        return buffer;
}
</code></pre>

<p>Then split the each line entry to 2D vector. for that you can use this function</p>

<pre><code>vector&lt;vector&lt;string&gt;&gt; processCsvList(vector&lt;string&gt; csvList)
{
    #define SINGER_CONFIG_COUNT 3 //number of comma separated data suppose to be in one line.
    #define DELIMITED_CHAR "",""
    #define EMPTY_STRING """";

    vector&lt;vector&lt;string&gt;&gt; tempList;
    string configCell ="""";
    for(vector&lt;string&gt;::iterator it = csvList.begin(); it != csvList.end(); ++it)
    {
        if(*it == EMPTY_STRING)
        {
            continue;
        }
        stringstream  configLine(*it);
        vector&lt;string&gt; tempDevice;
        for(int i=0; i&lt;SINGER_CONFIG_COUNT; i++)
        {
            if(getline(configLine,configCell,DELIMITED_CHAR))
            {               
                tempDevice.push_back(configCell);
            }else
            {
            tempDevice.push_back(EMPTY_STRING);
            }
        }
        tempList.push_back(tempDevice);
    }
    return tempList;
}
</code></pre>

<p><strong>I haven't try to compile any of these function</strong>, because I do not have environment to do so here. But I think this will help to to think about the direction. </p>

<p>now your data in a 2D vector like excell sheet. So you can access by the index of the inner vector.</p>
",0
15871294,15870897,0,"<p>You could create a <code>std::map&lt;string,vector&lt;string&gt;&gt;</code> so that you could then store each column of the CSV file from line 2 onwards in the map as a vector of strings, keyed by the text that appears in the column on line 1 of the CSV file.</p>

<p>Then you could present the names of the fields by iterating through the keys of the <code>std::map</code>, which are conveniently stored in alphabetical order.</p>

<p>The task of reading in the first line of the CSV file could be performed by the code you already have, or something more sophisticated that takes into account the quoted fields, etc. that are found in fully-featured CSV files. </p>
",0
15868109,15868022,1,"<p>You've most likely stumbled into a conflict between your structure and the <code>std::count</code> algorithm, defined in the <code>&lt;algorithm&gt;</code> header. Namespaces were designed to avoid these kinds of clashes, so use them for that purpose. A <code>using namespace std;</code> after including that header brings <code>std::count</code>, and a whole lot else into the scope you put that statement in, which allows for easy conflicts. Just prefix things in <code>std</code> with <code>std::</code> instead of bringing in the whole thing.</p>
",2
16442804,16440893,2,"<p>An ordinary user <strong>cannot</strong> create file mappings in the Global Namespace since <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb756986.aspx"" rel=""nofollow"">Session 0</a> separation (and XP SP2 it looks like) without the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb530716%28v=vs.85%29.aspx"" rel=""nofollow""><code>SeCreateGlobalPrivilege</code></a> privilege.</p>

<p>Please read the documentation for the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa366537%28v=vs.85%29.aspx"" rel=""nofollow""><code>CreateFileMapping</code></a> function which mentions this explicitly:</p>

<blockquote>
  <p>Creating a file mapping object in the global namespace from a session other than session zero requires the SeCreateGlobalPrivilege privilege. For more information, see Kernel Object Namespaces.</p>
</blockquote>

<p>Your process is not running as a system service in session 0, and so cannot create a global file mapping without obtaining this privilege. The easiest way to obtain this privilege is to run the process with elevated privileges.</p>

<p>A possible alternative (untested, guesstimation based on information from a wide variety of unconfirmed sources) is to try to find the file mapping in the session's namespace by using the <code>Session\(number)\(name)</code>. If you open up the permissions on the mapping enough, it should be accessible by the other process.</p>
",0
16465644,16465573,5,"<pre><code>DataStream::DataStream();
</code></pre>

<p>Is a declaration of constructor for class <code>DataStream</code>, it must be declared within the class not outside.</p>

<pre><code>class DataStream
{
    public:
        DataStream();
};
</code></pre>

<p>Further, You can define this constructor inline inside the class or outside, like</p>

<pre><code>DataStream::DataStream()
{}
</code></pre>
",1
16388530,16388510,19,"<p>A <code>switch</code> statement can only be used for integral values, not for values of user-defined type. (And even if it could, your input operation doesn't work, either. The <code>&gt;&gt;</code> operation extracts single tokens, separated by whitespace, so it can never retrieve a value <code>&quot;Option 1&quot;</code>.)</p>
<p>You might want this:</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;


std::string input;

if (!std::getline(std::cin, input)) { /* error, abort! */ }

if (input == &quot;Option 1&quot;)
{
    // ... 
}
else if (input == &quot;Option 2&quot;)
{ 
   // ...
}

// etc.
</code></pre>
",0
16388535,16388510,4,"<p>You can't. Full stop.</p>

<p><code>switch</code> is only for integral types, if you want to branch depending on a string you need to use <code>if/else</code>.</p>
",0
16388580,16388510,3,"<p>what about just have the option number:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
    string s;
    int op;

    cin &gt;&gt; s &gt;&gt; op;
    switch (op) {
    case 1: break;
    case 2: break;
    default:
    }

    return 0;
}  
</code></pre>
",0
16388594,16388510,34,"<p>You can map the strings to enum values, then switch on the enum:</p>
<pre><code>enum Options {
    Option_Invalid,
    Option1,
    Option2,
    //others...
};

Options resolveOption(string input);

//  ...later...

switch( resolveOption(input) )
{
    case Option1: {
        //...
        break;
    }
    case Option2: {
        //...
        break;
    }
    // handles Option_Invalid and any other missing/unmapped cases
    default: {
        //...
        break;
    }
}
</code></pre>
<p>Resolving the enum can be implemented as a series of <code>if</code> checks:</p>
<pre><code> Options resolveOption(std::string input) {
    if( input == &quot;option1&quot; ) return Option1;
    if( input == &quot;option2&quot; ) return Option2;
    //...
    return Option_Invalid;
 }
</code></pre>
<p>Or a map lookup:</p>
<pre><code> Options resolveOption(std::string input) {
    static const std::map&lt;std::string, Option&gt; optionStrings {
        { &quot;option1&quot;, Option1 },
        { &quot;option2&quot;, Option2 },
        //...
    };

    auto itr = optionStrings.find(input);
    if( itr != optionStrings.end() ) {
        return itr-&gt;second;
    }
    return Option_Invalid; 
}
</code></pre>
",7
16388604,16388510,1,"<p>Switch value must have an Integral type. Also, since you know that differenciating character is in position <code>7</code>, you could switch on <code>a.at(7)</code>. But you are not sure the user entered 8 characters. He may as well have done some typing mistake. So you are to surround your switch statement within a Try Catch. Something with this flavour</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
int main() {
    string a;
    cin&gt;&gt;a;

    try
    {
    switch (a.at(7)) {
    case '1':
        cout&lt;&lt;""It pressed number 1""&lt;&lt;endl;
        break;
    case '2':
        cout&lt;&lt;""It pressed number 2""&lt;&lt;endl;
        break;
    case '3':
        cout&lt;&lt;""It pressed number 3""&lt;&lt;endl;
        break;
    default:
        cout&lt;&lt;""She put no choice""&lt;&lt;endl;
        break;
    }
    catch(...)
    {

    }
    }
    return 0;
}
</code></pre>

<p>The default clause in switch statement captures cases when users input is at least 8 characters, but not in {1,2,3}. </p>

<p>Alternatively, you can switch on values in an <code>enum</code>. </p>

<p><em>EDIT</em></p>

<p>Fetching 7th character with <code>operator[]()</code> does not perform bounds check, so that behavior would be undefined. we use <code>at()</code> from <code>std::string</code>, which is bounds-checked, <a href=""http://www.cplusplus.com/reference/string/string/at/"" rel=""nofollow"">as explained here.</a> </p>
",0
16388610,16388510,93,"<p>As said before, switch can be used only with integer values. So, you just need to convert your ""case"" values to integer. You can achieve it by using <a href=""http://en.cppreference.com/w/cpp/language/constexpr"" rel=""noreferrer"">constexpr</a> from c++11, thus some calls of constexpr functions can be calculated in compile time.</p>

<p>something like that...</p>

<pre><code>switch (str2int(s))
{
  case str2int(""Value1""):
    break;
  case str2int(""Value2""):
    break;
}
</code></pre>

<p>where str2int is like (implementation from <a href=""https://stackoverflow.com/questions/2111667/compile-time-string-hashing"">here</a>):</p>

<pre><code>constexpr unsigned int str2int(const char* str, int h = 0)
{
    return !str[h] ? 5381 : (str2int(str, h+1) * 33) ^ str[h];
}
</code></pre>

<p>Another example, the next function can be calculated in compile time:</p>

<pre><code>constexpr int factorial(int n)
{
    return n &lt;= 1 ? 1 : (n * factorial(n-1));
}  

int f5{factorial(5)};
// Compiler will run factorial(5) 
// and f5 will be initialized by this value. 
// so programm instead of wasting time for running function, 
// just will put the precalculated constant to f5 
</code></pre>
",10
16388762,16388510,15,"<p>You can only use switch-case on types castable to an int.</p>

<p>You could, however, define a <code>std::map&lt;std::string, std::function&gt; dispatcher</code> and use it like <code>dispatcher[str]()</code> to achieve same effect.</p>
",1
18107129,18107077,8,"<blockquote>
  <p>This code does't compile</p>
</blockquote>

<p>The code does not <em>link</em>, it does compile.
The <code>static const</code> member requires a <em>definition</em> if its address is to be used, so just add a definition similar to the second code snippet:</p>

<pre><code>const int A::a;
</code></pre>

<p>Taking the address of <code>A::a</code> means <code>A::a</code> is <a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow"">odr</a>-used, and from section <em>9.4.2 Static data members</em> of the C++11 standard (draft n3337), clause 3:</p>

<blockquote>
  <p><strong>If a non-volatile const static data member is of integral or enumeration type</strong>, its declaration in the class
  definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment expression
  is a constant expression (5.19). A static data member of literal type can be declared in the
  class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer
  in which every initializer-clause that is an assignment-expression is a constant expression. [ Note: In both
  these cases, the member may appear in constant expressions. ¡ªend note ] <strong>The member shall still be defined
  in a namespace scope if it is odr-used</strong> (3.2) in the program and the namespace scope definition shall not
  contain an initializer.</p>
</blockquote>
",0
18107132,18107077,11,"<p>Put</p>

<pre><code>const int A::a;
</code></pre>

<p>In the source file, otherwise the compiler doesn't generate an address for a. Note the value is not repeated here.</p>
",2
16933007,16932949,1,"<p>You cannot work with objects of <code>string</code> class this way.</p>

<pre><code>memcpy(arr , &amp;temp1 , temp1.size());
</code></pre>

<p>should be</p>

<pre><code>temp1.copy(arr, temp1.size());
</code></pre>

<p>And</p>

<pre><code>memcpy(&amp;temp2 , arr , temp1.size());
</code></pre>

<p>should be</p>

<pre><code>std::string temp2(arr, temp1.size());
</code></pre>
",0
16933025,16932949,0,"<p><code>std::string</code> is a dynamically allocated container. You should rarely use it as a destination for <code>memcpy</code>. In your code, there is no memory allocated for <code>temp2</code>. The workaround is to use <code>string::reserve</code> to preallocate memory.</p>

<p>However, there is usually no need to mix C-code (<code>memcpy</code>, <code>char[]</code>) with C++-code (<code>std::string</code>, <code>std::cout</code>). Apparently, you're doing something wrong.</p>
",0
16933080,16932949,0,"<p>If you copy from the location of the string(it also contains functions, other data etc.), and copy 16 bytes, you end up with alot of unusable data.</p>

<p>You want the first character in the string, so you would do this:
<code>memcpy(arr, &amp;temp1[0], temp1.size());</code></p>

<p>This would effectively copy it.
When you want to do the opposite(copy to the string), why not just do this?
<code>std::string temp2(arr, temp1.size());</code> or <code>std::string temp2((const char*) arr);</code></p>
",0
15869206,15869179,2,"<blockquote>
  <p>I only needed to overload an operator if I was setting ""sortedListClass"" equal to another declared ""sortedListClass"" or if I was asking if they were less than, equal to, not equal to, etc</p>
</blockquote>

<p>You're doing those things with <code>listItemType</code>, and never created any operators for it.</p>

<p>See how it's complaining about expressions such as <code>¡®cur-&gt;Node::data == city¡¯</code>? The left-hand side has type <code>listItemType</code>, and the right-hand side has type <code>std::string</code>. The compiler has no idea what you want it to do with those two things.</p>

<p>Similarly:</p>

<blockquote>
<pre><code>error: no match for ¡®operator&gt;¡¯ in ¡®newNode-&gt;Node::data &gt; curr-&gt;Node::data¡¯
</code></pre>
</blockquote>

<p>Both sides of that expression have type <code>listItemType</code>. You need to define <code>operator&gt;</code> for that type.</p>

<p>I realise that the error output is verbose and complex, but all the information you need <em>is</em> in there somewhere!</p>
",0
16955136,16954567,1,"<p>I would assume that <code>client</code> is not initialized or has an invalid pointer.</p>
",2
18217010,18216986,4,"<p>Change</p>

<pre><code>ned() {
  myfile* pSrc = new myfile();
  myfile* pTgt = new myfile();
}
</code></pre>

<p>to </p>

<pre><code>ned()
: pSrc(new myfile),
  pTgt(new myfile) {
}
</code></pre>

<p>Currently, your code does not initialize <code>nedObj</code>. Instead, <code>ned</code>'s constructor creates two local variables called <code>pSrc</code> and <code>pTgt</code>. The variables promptly go out of scope, leaking resources.</p>
",0
18217018,18216986,3,"<pre><code>class ned {
  public:
    myfile *pSrc;*pTgt;

  ned() {
   myfile* pSrc = new myfile();
   myfile* pTgt = new myfile();
  }
};
</code></pre>

<p>should be:</p>

<pre><code>class ned {
  public:
    myfile *pSrc;*pTgt;

  ned() {
   this-&gt;pSrc = new myfile();
   this-&gt;pTgt = new myfile();
  }
};
</code></pre>
",1
18217105,18216986,-1,"<p>Change the constructor to this:</p>

<pre><code>ned() {
 pSrc = new myfile(); // pSrc is an already defined member.
 pTgt = new myfile(); // Same for pTgt.
}
</code></pre>

<p>If you use <code>myfile* pSrc</code>, you are a declaring a new variable that is not the same as the <code>pSrc</code> member variable.
Also remember to free the memory:</p>

<pre><code>~ned()
{
delete pSrc; 
delete pTgt;
}
</code></pre>
",1
18217238,18216986,0,"<p>I went ahead and fixed it for you</p>

<pre><code>class myfile {
public:
  int nData;
  int nHeaderSize;

myfile() {
  nData=0;
  nHeaderSize=0;
  }
}; **//missing semicolon here**

class ned {
public:
  myfile *pSrc, *pTgt; **//was myfile *pSrc;*pTgt, needed a coma instead**

ned() {
 myfile* pSrc = new myfile();
 myfile* pTgt = new myfile();
  }
}; //missing semicolon here

int main(int argc, char* argv[]) {
   ned* nedObj = new ned();
   nedObj-&gt;pSrc-&gt;nData=5; **//Access violation error here**
}
</code></pre>
",0
18286710,18284645,0,"<p>Sure, this is all possible. I am a bit biased, so I would suggest a QtCore based solution, but this would work very nicely cross-platform, or you could even log a lot more than just this. See the three main classes that could help, below.</p>

<p>QFileInfo</p>

<ul>
<li>file name: <a href=""http://qt-project.org/doc/qt-5.0/qtcore/qfileinfo.html#fileName"" rel=""nofollow"">http://qt-project.org/doc/qt-5.0/qtcore/qfileinfo.html#fileName</a></li>
<li>size: <a href=""http://qt-project.org/doc/qt-5.0/qtcore/qfileinfo.html#size"" rel=""nofollow"">http://qt-project.org/doc/qt-5.0/qtcore/qfileinfo.html#size</a></li>
<li>last modified: <a href=""http://qt-project.org/doc/qt-5.0/qtcore/qfileinfo.html#lastModified"" rel=""nofollow"">http://qt-project.org/doc/qt-5.0/qtcore/qfileinfo.html#lastModified</a></li>
</ul>

<p>QFile (inheriting QIODevice)</p>

<ul>
<li>read all: <a href=""http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html#readAll"" rel=""nofollow"">http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html#readAll</a></li>
</ul>

<p>QDir</p>

<ul>
<li>info entry list: <a href=""http://qt-project.org/doc/qt-5.0/qtcore/qdir.html#entryInfoList"" rel=""nofollow"">http://qt-project.org/doc/qt-5.0/qtcore/qdir.html#entryInfoList</a></li>
</ul>

<p>If for some reason, you would not like to use QtCore, you can probably also copy and paste the relevant methods out with their source code dependencies from this directory:</p>

<p><a href=""http://qt.gitorious.org/qt/qtbase/trees/stable/src/corelib/io"" rel=""nofollow"">http://qt.gitorious.org/qt/qtbase/trees/stable/src/corelib/io</a></p>
",0
17076751,17076517,2,"<p>You say you entered a ""huge value"".  If that value exceeds the upper bound of <code>unsigned long long</code>, then <code>cin &gt;&gt; p;</code> will fail.</p>

<p>A quick experiment indicates that once that happens, <code>cin &gt;&gt; q;</code> doesn't do anything, and no value is stored in <code>q</code>.  The value of <code>p</code> will probably be <code>18446744073709551615</code>, or 2<sup>64</sup>-1.</p>

<p>You need to check whether each input operation succeeded or failed, and decide how to handle any errors.</p>

<p>You also need to update your question to indicate exactly what input you provided to your program.</p>
",3
16930714,16930248,1,"<p>At the cost/risk of being more confusing, you can avoid repeating the <em>type</em> in your code in the question ala:</p>

<pre><code>Var v(""name"", 1), *p = &amp;v;
</code></pre>

<p>You could also potentially use <code>alloca</code>, which is provided by most systems and returns a pointer to stack-allocated memory, but then you have to go through a separate painful step to placement <code>new</code> an object into that memory and do your own object destruction.  <code>alloca</code> needs to be called inside the function so it's the function stack on which the object is created, and not during the preparation of function arguments (as the variable's memory may be embedded in the stack area the compiler's using to prepare function arguments), which makes it tricky to wrap into some easily reused facility.  You could use macros, but they're evil (see Marshall Cline's C++ FAQ for an explanation of that).  Overall - not worth the pain....</p>

<p>Anyway, I recommend sticking with the code in your question and not over-thinking this: using <code>&amp;v</code> a few times tends to be easier, and when it's not it's normally not a big deal if there's an unnecessary identifier for the stack-based variable.</p>
",2
16931694,16930248,-2,"<p>Yes, it's possible to return an address to a temporary (i.e. stack) object and assign it to a pointer. However, the compiler might actually discard the object (i.e. cause that section in memory to be overwritten) before the end of the current scope. <strong>(TO CLARIFY: THIS MEANS <em>DON'T DO THIS.</em> EVER.)</strong> See the discussion in the comments below about the behavior observed in different versions of GCC on different operating systems. (I don't know whether or not the fact that version 4.5.3 only gives a warning instead of an error indicates that this will always be ""safe"" in the sense that the pointer will be valid everywhere within the current scope if you compile with that particular version of GCC, but I wouldn't count on it.)</p>

<p>Here's the code I used (modified as per Jonathan Leffler's suggestion):</p>

<pre><code>#include &lt;stdio.h&gt;

class Class {
public:
    int a;
    int b;
    Class(int va, int vb){a = va; b = vb;}
};

int main(){ 
    Class *p = &amp;Class(1, 2);
    Class *q = &amp;Class(3, 4);
    printf(""%p: %d,%d\n"", (void *)p, p-&gt;a, p-&gt;b);
    printf(""%p: %d,%d\n"", (void *)q, q-&gt;a, q-&gt;b);
}
</code></pre>

<p>When compiled using GCC 4.5.3 and run (on Windows 7 SP1), this code printed:</p>

<pre><code>0x28ac28: 1,2
0x28ac30: 3,4
</code></pre>

<p>When compiled using GCC 4.7.1 and run (on Mac OS X 10.8.3), it printed:</p>

<pre><code>0x7fff51cd04c0: 0,0
0x7fff51cd04d0: 1372390648,32767
</code></pre>

<hr>

<p>In any case, I'm not sure why you wouldn't just declare the variable normally and use <code>&amp;v</code> everywhere you need something ""pointer-like"" (for instance, in functions that require a pointer as an argument).</p>
",10
16930276,16930248,2,"<p>There's no way to do this by allocating on the stack. However, you can use <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared"" rel=""nofollow""><code>std::make_shared</code></a> for the heap:</p>

<pre><code>#include &lt;memory&gt;

std::shared_ptr&lt;Var&gt; p = std::make_shared&lt;Var&gt;();
</code></pre>
",10
16934834,16930248,0,"<p>I don't think there is a way to overcome it without some overhead (like the shared_ptr). so the shortest way to write it will be:</p>

<pre><code>Var v(""name"", 1), *p = &amp;v;
</code></pre>
",0
16934586,16930248,10,"<p>There's two questions hidden in here. The first one is:</p>

<blockquote>
<pre><code>Var *p = new Var(""name"", 1);
</code></pre>
  
  <p>But I have to clear the variable pointed to by p with delete p later
  on in the program.</p>
  
  <p>I want to declare a stack variable so it is automatically cleared
  after function exits</p>
</blockquote>

<p>So here, you're asking how to allocate memory without having to explicitly clean it up afterwards. The solution is to use <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""noreferrer""><code>std::unique_ptr</code></a>:</p>

<pre><code>std::unique_ptr&lt;Var&gt; p(new Var(""name"", 1));
</code></pre>

<p>Voila! unique_ptr will automatically clean itself up, it has virtually no overhead compared to a raw pointer, and it's overloaded the * and -> operators so you can use it just like a raw pointer. Search for ""C++11 smart pointers"" if you want to know more.</p>

<p>The second question is:</p>

<blockquote>
  <p>I only want to get the pointer, and the following:</p>

<pre><code>Var v(""name"", 1);
Var *p = &amp;v;
</code></pre>
  
  <p>is quite tedious, and specifier v will never be referenced.</p>
</blockquote>

<p>The important point here is that <code>Var *p = &amp;v</code> is completely unnecessary. If you have a function that requires a pointer, you can use <code>&amp;v</code> on the spot:</p>

<pre><code>void SomeFunc(const Var* p);
// ...
Var v(""name"", 1);
SomeFunc(&amp;v);
</code></pre>

<p>There's no need to put &amp;v in a separate variable before passing it into a function that requires a pointer.</p>

<p>The exception is if the function takes a <em>reference</em> to a pointer (or a pointer to a pointer):</p>

<pre><code>void SomeFunc2(Var*&amp; p);
void SomeFunc3(Var** p);
</code></pre>

<p>These types of functions are rare in modern C++, and when you see them, you should read the documentation for that function very carefully. More often than not, those functions will allocate memory, and you'll have to free it explicitly with some other function.</p>
",6
17797412,17797354,4,"<p><code>#define main</code> is making your program look like:</p>

<pre><code>int () {
  return 0;
}
</code></pre>

<p>to the compiler, which, as you can see, is wrong.  Remove that line.</p>
",0
17786585,17786551,6,"<p>You are trying to bind a temporary, returned by <code>std::string::substr</code>, to a non-const reference. You cannot do that, but you can bind to a const reference:</p>

<pre><code>void Object::actionsFace(const std::string &amp;line, int &amp;iteration_face);
</code></pre>

<p>This will pass a reference to the temporary string, but you cannot modify it inside of the function.</p>

<p>Alternatively, you can explicitly make a copy, as with <code>test</code> in your example. Alternatively, if you need a local copy of the string inside your function only, you can pass by value:</p>

<pre><code>void Object::actionsFace(std::string line, int &amp;iteration_face);
</code></pre>
",0
17824822,17824683,0,"<p>Don't <code>#include ""convertion.cpp""</code> in any file. By including it, you are replacing that include line with the contents of the file, so you have declared <code>non10num</code> twice in the same program: once in ""converter.cpp"" (because of the include line) and once in ""convertion.cpp"". I hope this helps.</p>
",2
17824987,17824683,1,"<p><em>Define</em> each one like this in <em>one</em> of your cpp files:</p>

<p><code>int bIn = 0;</code></p>

<p>and then <em>declare</em> it like this in all your others:</p>

<p><code>extern int bIn;</code></p>

<p>As it currently stands, you're violating the One Definition Rule.</p>

<p>Also, right now, you're declaring variables of the same names in <code>main()</code> which is going to hide all your global variables in that function, which is probably not what you want.</p>
",7
17800885,17800870,0,"<p>Arrays of characters don't have methods, but you're trying to call <code>assign</code> on one. Perhaps use <code>strcpy</code>, <code>strncpy</code>, the non-standard <code>strlcpy</code>, or an idiomatic C++ equivalent instead.</p>
",1
17801742,17800870,0,"<p>password is only a char array.
so you can't all password.assign() function.
try strcpy!</p>
",0
17831052,17830990,2,"<p>I dont know how you happen to miss out on <a href=""http://en.wikipedia.org/wiki/Sizeof"" rel=""nofollow""><code>sizeof</code></a>. </p>

<p>In the programming languages C and C++, the unary operator sizeof is used to calculate the size of any datatype.
The sizeof operator yields the size of its operand with respect to the size of type char.</p>

<pre><code>sizeof ( type-name )
</code></pre>

<p>Refer to know more here : <a href=""http://msdn.microsoft.com/en-us/library/4s7x1k91%28v=vs.71%29.aspx"" rel=""nofollow"">MSDN</a> </p>

<p>Following is the example from MSDN :</p>

<pre><code>size_t getPtrSize( char *ptr )
{
   return sizeof( ptr );
}

using namespace std;
int main()
{
   char szHello[] = ""Hello, world!"";

   cout  &lt;&lt; ""The size of a char is: ""
         &lt;&lt; sizeof( char )
         &lt;&lt; ""\nThe length of "" &lt;&lt; szHello &lt;&lt; "" is: ""
         &lt;&lt; sizeof szHello
         &lt;&lt; ""\nThe size of the pointer is ""
         &lt;&lt; getPtrSize( szHello ) &lt;&lt; endl;
}
</code></pre>
",0
17831131,17830990,1,"<p>Use sizeof operator</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
    cout &lt;&lt; ""bool:\t\t"" &lt;&lt; sizeof(bool) &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""char:\t\t"" &lt;&lt; sizeof(char) &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""wchar_t:\t"" &lt;&lt; sizeof(wchar_t) &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""short:\t\t"" &lt;&lt; sizeof(short) &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""int:\t\t"" &lt;&lt; sizeof(int) &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""long:\t\t"" &lt;&lt; sizeof(long) &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""float:\t\t"" &lt;&lt; sizeof(float) &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""double:\t\t"" &lt;&lt; sizeof(double) &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""long double:\t"" &lt;&lt; sizeof(long double) &lt;&lt; "" bytes"" &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>bool:       1 bytes
char:       1 bytes
wchar_t:    2 bytes
short:      2 bytes
int:        4 bytes
long:       4 bytes
float:      4 bytes
double:     8 bytes
long double:    12 bytes
</code></pre>

<p>Used MinGW g++ 4.7.2 Windows</p>
",0
16912748,16912704,2,"<p>According to <a href=""http://www.cplusplus.com/reference/vector/vector/operators/"" rel=""nofollow"">this page</a>, they <em>do</em> take const references as arguments. According to ¡ì&nbsp;23.3.6.1 of the C++&nbsp;11 standard and ¡ì&nbsp;23.2.4 of the C++&nbsp;03 standard, they do as well.</p>
",4
16912797,16912704,5,"<p>That <strike>looks like an</strike> was an oversight on that page. From section <em>23.3.6.1 Class template vector overview</em> of the c++11 standard they all take <code>const&amp;</code>s:</p>

<pre><code>template &lt;class T, class Allocator&gt;
bool operator==(const vector&lt;T,Allocator&gt;&amp; x,
                const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool operator&lt; (const vector&lt;T,Allocator&gt;&amp; x,
                const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool operator!=(const vector&lt;T,Allocator&gt;&amp; x,
                const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool operator&gt; (const vector&lt;T,Allocator&gt;&amp; x,
                const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool operator&gt;=(const vector&lt;T,Allocator&gt;&amp; x,
                const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool operator&lt;=(const vector&lt;T,Allocator&gt;&amp; x,
                const vector&lt;T,Allocator&gt;&amp; y);
</code></pre>
",0
16913121,16912981,3,"<p>Yes, that's a perfectly reasonable use of overloading. I question the use of <code>at</code>, however. It would be better to have both <code>at</code> and <code>operator[]</code>, which pass through to their <code>std::vector</code> counterparts. This way, you give the caller the choice between safety and performance (which is why the two versions exist in the first place).</p>
",3
16372049,16372004,2,"<p>Here:</p>

<pre><code>Crectangle::Crectangle()
{
  *height=3; // height could point anywhere
  *width=5;  // width could point anywhere
}
</code></pre>

<p>you are dereferencing pointers that are not initialized. This is undefined behaviour, so the result could be anything.</p>

<p>The solution is to not use pointers for <code>height</code> and <code>width</code>. There seems to be no reason whatsoever to use them.</p>

<pre><code>class Crectangle
{
    int height;
    int width;
 ....
};
</code></pre>
",2
16372052,16372004,1,"<p>Only one of your constructors allocates memory for width and height. The other one has undefined behaviour.</p>
",1
16425123,16372004,0,"<pre><code>#include &lt;iostream&gt; 
#include &lt;conio.h&gt;

using namespace std;

class Crectangle {
int * height, * width;
public: 
Crectangle();
Crectangle(int, int);
Crectangle();
int area() {
               return (*height * *width);
           }
};

Crectangle::Crectangle() {

   height = new int;
   width = new int;
  *height = 3;
  *width = 5;
}

Crectangle::Crectangle(int a, int b) {
  height = new int;
  width = new int;
  *height = a;
  *width = b;
}

Crectangle::~Crectangle() {
  delete height;
  delete width;
}

int main()
{
    Crectangle rect(1, 2);
    Crectangle rectb;
    cout &lt;&lt; ""rect = "" &lt;&lt; rect.area() &lt;&lt; ""\n"";
    cout &lt;&lt; ""rectb = "" &lt;&lt; rectb.area();

    getch();
}
</code></pre>
",0
16932932,16932832,0,"<p>Because it's a dependent name, that is, it depends on the template parameter <code>T</code>. You need to explicitly specify either <code>this-&gt;v[0]</code> or <code>Vector&lt;Vector234&lt;T, N&gt;,T,N&gt;::v[0]</code>. </p>
",0
18108298,18108255,8,"<pre><code>#define charbits 8*sizeof(char);
</code></pre>

<p>shouldn't end with <code>;</code>, it will be expanded as;</p>

<pre><code>string str2(str.length()*8*sizeof(char);, '0');
</code></pre>

<p>Since sizeof(char) is defined to be 1, you could change the definition to simply;</p>

<pre><code>#define charbits 8
</code></pre>

<p>...or as a simple constant;</p>

<pre><code>#include &lt;stddef.h&gt;

const size_t charbits = 8;
</code></pre>

<p>EDIT: As @keiththompson points out below, <code>CHAR_BIT</code> in <code>&lt;climits&gt;</code> defines the actual number of bits per char, and is obviously more portable than hard coding to 8.</p>
",2
18108304,18108255,2,"<p>You are inserted a suprious semi-colon due to your definition</p>

<pre><code>#define charbits 8*sizeof(char);
</code></pre>

<p>Remove it and you'll get rid of the error.</p>

<p>Event better change it to a static const rather than a #define, which is discouraged for this very reason.</p>

<pre><code>static const size_t charbits = 8 * sizeof(char);
</code></pre>
",0
15847937,15847921,3,"<p>If you don't provide a copy constructor, the compiler generates one for you, which gets used when you pass by value (in C++11 there is also the possibility that a move copy constructor gets called in certain circumstances.) To really disable it, you should declare it private, or <code>delete</code> it in C++11:</p>

<pre><code>class Foo
{
 private:
  Foo(const Foo&amp;);
};

class Foo11
{
 public:
  Foo(const Foo&amp;) = delete;
};
</code></pre>
",0
15847938,15847921,0,"<p>If there are no constructors specified, C++ creates a parameterless and a copy constructor by itself. It simply performs a copy of the object.</p>
",9
15898403,15898350,4,"<p>Yes, you can. It's C++11 feature. Really it's equal to</p>

<pre><code>struct ColorProperties {
   ColorProperties()
      : colorRed(true), colorBlue(false), isRectangle(true)
   {}

   //
};
</code></pre>

<p>You can read about this proposal <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2628.html"" rel=""nofollow"">here</a></p>

<p>Quotes from standard.</p>

<p>n3376 12.6.2/8</p>

<p><Blockquote><P>
In a non-delegating constructor, if a given non-static data member or base class is not designated by a
mem-initializer-id (including the case where there is no mem-initializer-list because the constructor has no
ctor-initializer) and the entity is not a virtual base class of an abstract class (10.4), then</p>

<p><strong>¡ª if the entity is a non-static data member that has a brace-or-equal-initializer, the entity is initialized
as specified in 8.5;</strong></P></Blockquote></p>

<pre><code>struct A {
   A();
};

struct B {
   B(int);
};

struct C {
   C() { }

   A a;
   const B b; // error: B has no default constructor
   int i;     // OK: i has indeterminate value
   int j = 5; // OK: j has the value 5
};
</code></pre>
",0
17813682,17813423,2,"<p><code>cout</code> is overloaded so that when you give it a <code>char*</code>, it will print as a pointer to a C-style string. So, it prints out the characters until it hits a null terminating character.</p>

<p>If you used <code>printf</code> instead of <code>cout</code>, you would see the address. You could also cast the pointer to another type, say <code>(void*)</code> and you would also get the address.</p>
",1
17813459,17813423,12,"<p>You should change your code to this:</p>

<pre><code>cout &lt;&lt; static_cast&lt;const void*&gt;(terry);
</code></pre>

<p>The problem is that <code>&lt;&lt;</code> operator is overloaded for pointers to C-style strings for printing the content of the string. If you cast it to the raw pointer instead, you will have  the default behaviour of printing pointer using iostreams as you want.</p>
",0
17813466,17813423,-2,"<p>""hello"" is a string, i.e. the char array. <code>const char*</code> is a pointer to this array, so when you dereference this pointer, you get the value of the first element.</p>

<p>It is like if you have</p>

<pre><code>int a[] = {1, 2, 3};
int *b = a;
cout &lt;&lt; *b &lt;&lt; endl;
</code></pre>

<p>you get just <code>1</code> printed.</p>
",2
17813521,17813423,101,"<p>The reason for that is that <code>std::cout</code> will treat a <code>char *</code> as a pointer to (the first character of) a C-style string and print it as such. If you want the <em>address</em> instead, you can just cast it to a pointer that <em>isn't</em> treated that way, something like:</p>

<pre><code>cout &lt;&lt; (void *) terry;
</code></pre>

<p>(or use the <code>const void *</code> cast if you're worried about casting away constness, something that's not an issue in this particular case).</p>

<hr>

<p>If you're more of a purist than pragmatist, you can also use the C++ <code>static_cast</code>, along the lines of:</p>

<pre><code>cout &lt;&lt; static_cast &lt;const void *&gt; (terry);
</code></pre>

<p>though it's unnecessary in this particular case, the cast to a <code>void *</code> will work fine. The following sample code shows all these options in action:</p>

<pre><code>#include &lt;iostream&gt;
int main (void) {
    const char *terry = ""hello"";
    std::cout &lt;&lt; terry &lt;&lt; '\n';
    std::cout &lt;&lt; (void *) terry &lt;&lt; '\n';
    std::cout &lt;&lt; (const void *) terry &lt;&lt; '\n';
    std::cout &lt;&lt; static_cast&lt;const void *&gt; (terry) &lt;&lt; '\n';
    return 0;
}
</code></pre>

<p>outputting (the address may be different in your environment):</p>

<pre><code>hello
0x8048870
0x8048870
0x8048870
</code></pre>

<p>Note that, when using the <code>static_cast</code>, you should ensure you don't try to cast away the constness with <code>static_cast &lt;void *&gt;</code> (that's what <code>const_cast</code> is for). This is one of the checks done by the newer C++ casts and the old-style cast does not have this limitation.</p>
",12
17813845,17813423,27,"<p>The <code>&lt;&lt;</code> operator on <code>std::cout</code> is overloaded. Its behavior depends on the type of the right operand. (It's actually several different functions, all named <code>operator&lt;&lt;</code>; the compiler decides which one to call.)</p>

<p>If you give it a <code>char*</code> or <code>const char*</code>, it treats the operand as a pointer to (the first character of) a C-style string, and prints the contents of that string:</p>

<pre><code>const char * terry = ""hello"";
cout &lt;&lt; terry; // prints ""hello""
</code></pre>

<p>If you give it a <code>char</code> value, it prints that value as a character:</p>

<pre><code>cout &lt;&lt; *terry;   // prints ""h""
cout &lt;&lt; terry[0]; // the same
</code></pre>

<p>If you give it a pointer of type <code>void*</code>, it prints that pointer value (in some implementation-defined way, typically hexadecimal):</p>

<pre><code>cout &lt;&lt; static_cast&lt;const void*&gt;(terry); // prints something like 0x4008e4
</code></pre>

<p>Treating a <code>char*</code> or <code>const char*</code> as a pointer to a C-style string is a special case, and the only one (that I can think of) that causes <code>operator&lt;&lt;</code> to print something other than the value of the operand. The reason for this goes back to C++'s roots in C, which doesn't have a ""string"" type and manipulates strings via <code>char*</code> pointers.</p>

<p>There are numerous other overloads for <code>operator&lt;&lt;</code>, for various integer and floating-point numeric types, for <code>std::string</code>, and so forth.</p>
",2
17385973,17379816,0,"<p>inside Form1.cpp. Try</p>

<pre><code>#include ""Form1.h""
namespace mach_plugin{
BOOL B1 = TRUE ;
}
</code></pre>

<p>You need to post more codes so that we may see it clearly.</p>
",0
18110260,18110056,1,"<p>Do you know about the <code>&gt;&gt;</code> and <code>&lt;&lt;</code> operators.  These operators, when applied to an int will shift the bit 1 position right or left.  It would probably be more reliable than using <code>(int)exp2(charbits-j-1);</code></p>
",1
16391078,16391060,0,"<p><code>converterc</code> and <code>converterf</code> are member function of the class <code>Thermometer</code> but you're calling them without a <code>Thermometer</code> instance. </p>

<p>How about creating a <code>Thermometer</code> instance in your main?</p>

<pre><code>Thermometer tm;
tm.converterc(degree, weehoo);
</code></pre>
",0
16391128,16391060,0,"<p><code>converterc</code> and <code>converterf</code> are functions in your class. This means they are there to be called on an <strong>object being an instance of this class</strong> or class derived from this.</p>

<pre><code>class Thermometer
{
private:
float degreeC;   //celcius
float degreeF;   //farenheit
//...
public:
float converterc(int degree,int weehoo);
float converterf(int degree,int weehoo);
};

    int degree = 1;
    int weehoo = 2;
    Thermometer t; //initialize it properly if this is needed before calling functions
    float f = t.converterc(degree,weehooo);
</code></pre>

<p>using these functions in the way you did this:</p>

<pre><code>float f = converterc(degree,weehooo);
</code></pre>

<p>is possible as: </p>

<pre><code>float f = Thermometer::converterc(degree,weehooo);
</code></pre>

<p>but then they have to be <strong>static</strong> what means they don't have <code>this</code> pointer and are common to whole class (still you can call them using an instance of class but it is not necessary):</p>

<pre><code>class Thermometer
{
private:
float degreeC;   //celcius
float degreeF;   //farenheit
//...
public:
static float converterc(int degree,int weehoo);
static float converterf(int degree,int weehoo);
};
</code></pre>
",0
8801828,8801784,1,"<p>Possibilities:</p>

<ul>
<li>You didn't recompile <em>all</em> your source, so your headers got out of sync;</li>
<li>You have some <em>epic</em> Undefined Behaviour somewhere that's ruining everything.</li>
</ul>

<p>Steps to debug:</p>

<ul>
<li>Run through a static analysis tool</li>
<li>Full rebuild in debug mode</li>
<li>Run through a debugger</li>
<li>Run through a dynamic analysis tool</li>
</ul>
",6
8801958,8801784,4,"<p>Base classes and member objects are initialized in declaration order, not the order of the initializer list.</p>

<p>If one of the bases receives a pointer to another base object and does anything more than just store the pointer for later use in its constructor, then the ctor will access an object that has not yet been constructed.</p>

<p>Using <code>/W3</code> warning level under MSVC/VS should give warnings both when <code>this</code> is passed to a base ctor pointing to a part of the object that is not initialized yet, and when the initializer list was shuffled to match declaration order.</p>
",1
16948795,16948758,15,"<p>To manipulate wide character strings, use <code>std::wstring</code> which is a wide character string.</p>
",1
16391353,16391331,11,"<blockquote>
  <p>However, the object lives on in the vector, right?</p>
</blockquote>

<p>No, a copy of it does.  You want to return the address of the copy.</p>

<pre><code>return &amp;m_children.back();
</code></pre>

<p>However, it is not a good idea to store a pointer to an object that resides in a vector.  Because when the vector needs to reallocate, the pointer will be invalidated.  Perhaps you should store pointers (preferably smart pointers) in your vector instead.</p>

<p>For example:</p>

<pre><code>// in your class
std::vector&lt;std::unique_ptr&lt;SceneGraphNode&gt;&gt; m_children;

SceneGraphNode* addChild(std::string name)
{
    std::unique_ptr&lt;SceneGraphNode&gt; child(new SceneGraphNode(this,name));
    m_children.push_back(std::move(child));
    return m_children.back().get();
}
</code></pre>
",4
16391355,16391331,0,"<blockquote>
  <p>However, the object lives on in the vector, right?</p>
</blockquote>

<p>When you push into vector, it actually push <code>copies</code> of the objects, not the object itself, into the vector. STL containers does <code>copy in, copy out</code>. However, as indicated by the compiler, you should not <code>return the address of an object created on the stack</code>.</p>
",0
16391358,16391331,0,"<p>When adding it to the std::vector, you're essentially doing a copy. You should return the reference to the object stored in the vector.</p>

<pre><code>return &amp;(m_children.back());
</code></pre>
",1
16391359,16391331,0,"<p>The object doesn't exactly live on in the vector, since when you are <code>push_back</code>ing it, you are making a <em>copy</em> of this element.</p>

<p>This code could work if you changed the return by something like that (Ryan's form would actually be more straightforward):</p>

<pre><code>return &amp;m_children[m_children.size() - 1];
</code></pre>

<p>That way, you are effectively returning a pointer to an element living in your vector.</p>
",0
16440085,16440000,3,"<p>For a <code>std::vector</code>, you can use the <a href=""http://en.cppreference.com/w/cpp/container/vector/reserve"" rel=""nofollow""><code>reserve</code></a> member function to ensure that a contiguous block of memory is preallocated for the maximum number of elements you require. This means that the elements are not copied around unless you exceed the reserved capacity.</p>

<p>All pointers to elements in a <code>std::deque</code> are also invalidated when inserting or erasing elements. However, a <code>std::list</code> is guaranteed not to invalidate any pointers in these situations other than the pointer to the element you are erasing.</p>
",5
16440189,16440000,0,"<p>Lists are sequence containers that allow you to insert and erase anywhere and iterate in both directions. The main drawback of lists compared to the vectors is that they lack direct access to the elements by their position.</p>

<p>Deques are sequence containers as well. They come with dynamic sizes that can be expanded or contracted on both ends. They are quite similar to vector and provide you direct access to the elements by their position.</p>

<p>You need to ask yourself: what kind of operations do I need to do on the container ?</p>

<p>Note that list and forward_list preserves validity of the container when manipulated, whereas deque invalidates it.</p>

<p>Visit <a href=""http://www.cplusplus.com/"" rel=""nofollow"">http://www.cplusplus.com/</a> for more information about containers in c++.</p>
",0
16444143,16440000,0,"<p>The solution is to have the vector hold pointers to the objects rather than having it directly contain the objects.  Then you don't have to be concerned about the vector resizing because when it resizes, the objects will remain at their original location in memory.</p>
",0
16415532,16415134,0,"<p>Fixed a little, I didn't wanted to spend time to understand your <code>for(j=i,m=0;j&gt;=0,m&lt;=i;m++)</code> cycle so fully rewrited it.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;conio.h&gt;
#include&lt;string&gt;

using namespace std;

int main()
{
    string word[100];
    string arr[100];
    int wordCount = 0;

    while(1)
    {
        cout&lt;&lt;""enter word: \n"";
        cin&gt;&gt;word[wordCount];
        if(word[wordCount] == ""quit"")
        {  
            break;
        }
        ++wordCount;
    } 

    int arrCount = 0;
    for(int i = 0; i &lt; wordCount; ++i)
    {                  
        bool found = false;   
        for (int j = 0; j &lt; arrCount; ++j)
        {
            if (arr[j] == word[i])
            {
                found = true;
                break;
            }
        }
        if (!found)
        {
            arr[arrCount] = word;
            ++arrCount;
        }
    }                                                 

    for(int i = 0; i &lt; arrCount; ++i)
    {
        cout&lt;&lt;arr[n]&lt;&lt;""\n"";
    }

    getch();
}
</code></pre>

<p>And <strong>never use goto</strong>, your teatcher will be very angry if he see it.</p>
",1
16473529,16473516,2,"<p>Yes, that will work fine, though it can probably (very seldom not) be shortened to this:</p>

<pre><code>cdata.lastAnimation = &amp;animations.back();
</code></pre>

<p>That seems a little bit better to me at least.</p>
",0
17088100,17087904,4,"<p>Make sure that there is no empty space after the last integer in each line in the data file.
In the code currently you are not adding the last integer to the dummy vector. Modify it like this:</p>

<pre><code>while (Lin &gt;&gt; d) 
{
       dummy.push_back(d);   // Add the number first
       if (Lin.peek() == '\n')  // Then check if it is end of line
       {
             A.push_back(dummy);
             dummy.clear();
       }
}
</code></pre>
",1
17088103,17087904,0,"<p>There could be other whitespace characters after the number at the end of line, other than <code>\n</code>. Like spaces: </p>

<pre><code>1234  445  445    \n
              ^^^^
</code></pre>

<p>So your approach is not safe. Better would be to read entire line (<code>getline</code>) to some string, then construct <code>istringstream</code> on this <code>string</code> containing line, then just parse this <code>istringstream</code> to your <code>vector</code> for one line.</p>

<p>Like this:</p>

<pre><code>   for (string line; getline(filein, line); ) {
        vector&lt;double&gt; dd;
        istringstream is(line);
        for (double d; is &gt;&gt; d; )
            dd.push_back(d);
        if (not dd.empty())
           A.push_back(dd);
    }
</code></pre>
",0
17088220,17087904,2,"<p>Consider using getline.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    std::string line;
    std::vector&lt;std::vector&lt;double&gt; &gt; v;
    while(std::getline(cin, line)) {
        std::stringstream ss(line);
        double value;
        std::vector&lt;double&gt; numbers;
        while(ss &gt;&gt; value) {
            numbers.push_back(value);
            std::cout &lt;&lt; value &lt;&lt; std::endl;
        }
        v.push_back(numbers);
    }
    return 0;
}
</code></pre>
",1
17088547,17087904,2,"<p>Less is more. This replaces your entire loop. Note: You <em>don't</em> need to check <code>is_open</code> or call <code>close</code> for this to work safely.</p>

<pre><code>for(std::string s; std::getline(Lin, s);)
{
    A.emplace_back(std::istream_iterator&lt;double&gt;(std::istringstream(s)), 
                   std::istream_iterator&lt;double&gt;());
}
</code></pre>
",2
17099004,17098923,0,"<p>you have to use WinMain instead of main.</p>

<p>im not sure what WinMain should look like, but if you create a new 'Windows application', or 'Windows Forms' project from the templates, hopefully one of them will have it in it and you can copy the WinMain function deceleration. </p>

<p>you could try this?</p>

<pre><code>void __stdcall WinMain(HINSTANCE hInstance,
             HINSTANCE hPrevInstance,
          long lpCmdLine,
          int nCmdShow)
</code></pre>
",1
17097298,17097251,1,"<p>It's probably a leak within your constructors.  My suggestion is to make destructors for each of the classes you define to ensure that you delete any objects created in the constructor.</p>
",0
17097337,17097251,1,"<p>What you can do is add </p>

<pre><code>#define _CRTDBG_MAP_ALLOC
#include &lt;Crtdbg.h&gt;
</code></pre>

<p>With the memory leaks output, it should give you file and line where the left over block was allocated.</p>

<p>Also, put a <code>printf(""Destructor of xxxx\n"");</code> etc. in each of the destructors (Boat, Sailboat, Motoroboat).  These should be called/printed on delete.  </p>

<p>But they will only be called, if the destructor of the base calls (Baot) is marked virtual.  Otherwise you'll only get Boat-destructors called (and are probably losing memory that was allocated in Sailboat and Motorboat)</p>
",2
17097391,17097251,2,"<p>The leak is here:</p>

<pre><code>for(int i=0; i&lt;4; i++) {
        delete test[i];
    }
</code></pre>

<p>It is deleting the elements as if they were of the same type as the base class. I.E. if you have any 'extra' information in your derived class, it will be leaked.</p>

<p>For example:</p>

<pre><code>delete (Sailboat*)test[i]
</code></pre>

<p>is different than</p>

<pre><code>delete (Boat*)test[i]
</code></pre>

<p>You need to cast test[i] to the appropriate type before deleting it. Reclaiming the type you instantiated to may be difficult, so I would recommend you simply use smart pointers instead, and not worry about the delete.</p>

<p>Edit: Also, virtual destructors will solve this issue. I'm still all for smart pointers ;)</p>
",5
17097607,17097251,1,"<p>Adding this after seeing the definitions:</p>

<pre><code>class Boat {
    public:
        Boat() 
            { }
        virtual ~Boat()  // &lt;--- this is the real catch!
                  {?} 

        ...
};
</code></pre>
",0
17087286,17087057,1,"<p>As far as I can see, you never use <code>angle</code> for anything after having loaded the image.<br>
You need to rotate the image when the angle has changed.</p>
",0
15838620,15837197,0,"<p>Basically you create a new array with an entry for each decade. Then iterate over the exam grades and increase the according decade in the histogram:</p>

<pre><code>vector&lt;int&gt; calculateHistogram(vector&lt;int&gt; grades) 
{
    vector&lt;int&gt; histogram(10, 0);
    for (int i=0; i&lt;grades.size(); i++) {
        int decade = grades[i]/10;
        histogram[decade] += 1;
    }
    return histogram;
}
</code></pre>
",0
15838116,15837197,0,"<blockquote>
  <p>How can I edit my code to only allow the <code>readExamResults</code> to store ones
  in the range of 0 -100</p>
</blockquote>

<p>I guess you meant <code>readExamMarks</code> rather than <code>readExamResults</code>. If so, you would just need to add an <code>if</code> statement to check that the input value is actuall in the range [0..100]. I have also changed your loop statement <code>for</code> to a <code>while</code> because you just want to increase <code>idx</code> when a valid number is entered. </p>

<pre><code>void readExamMarks(int examMarks[], int sizeOfArray)
{
     cout &lt;&lt; ""Please enter a set of exam marks to see a histogram for:"" &lt;&lt; endl;
     int x = 0;
     int idx = 0;
     while(idx &lt; sizeOfarray)
          cin &gt;&gt; x;
          if((x &gt;=0) &amp;&amp; (x &lt;= 100)){
               examMarks[idx] = x;
               idx++;
          }
          else
               cout &lt;&lt; ""ERROR: Value must be in range [0...100], please enter a valid value\n""; 
     }
}
</code></pre>
",0
16405832,16405802,4,"<blockquote>
  <p>Q1 - can anyone confirm - if this is the correct way to store the pointer to table class object in the map?</p>
</blockquote>

<p>Yes, that is the correct way of storing a <code>unique_ptr</code> in a container. Unique pointers are non-copyable, so you need to <code>std::move()</code> it when passing it to a function - and you are doing that.</p>

<blockquote>
  <p>Q 2 - How to output the contents on the entire record in the map?</p>
</blockquote>

<p>Unless I am missing something obvious, you actually did the hardest part of the job. Just do:</p>

<pre><code>for (const auto &amp;i : mapTable)
{
    std::cout &lt;&lt; i.first &lt;&lt; "" "" &lt;&lt; std::endl;

    std::cout &lt;&lt; i.second-&gt;c1 &lt;&lt; std::endl;
    std::cout &lt;&lt; i.second-&gt;c2 &lt;&lt; std::endl;
    std::cout &lt;&lt; i.second-&gt;c3 &lt;&lt; std::endl;
}
</code></pre>

<p>The iterator is an iterator to a <code>std::pair&lt;const int, std::unique_ptr&lt;Table&gt;&gt;</code> (which is the value type of the map), so <code>i.first</code> provides access to the key, and <code>i.second</code> provides access to the mapped value (the unique pointer, in your case).</p>
",0
16418098,16416841,1,"<p>Try this instead:</p>

<pre><code>Vector&lt;Medicine*&gt; Controller::getMedicinesSortedByStockAsc() {
    Vector&lt;Medicine*&gt; all = repo-&gt;getAll();
    std::sort(all.begin(), all.end(), compareNA);
    return all;
}
</code></pre>

<p>Notes:</p>

<ul>
<li>You didn't provide a definition of <code>Vector</code> so I assume it is STL-compatible.  Judging by the rest of the code this may be an incorrect assumption.</li>
<li>You didn't provide a description of <code>compareNA</code> but I've chosen to assume that it can be made compatible with STL-style algorithms.</li>
</ul>
",3
15538436,15538382,1,"<p>Indexing a <code>std::string</code> with the <code>[]</code> operator yields a <code>char</code>, for which there just happens to be an overloaded <code>operator=</code> for strings.</p>

<p>Even if you were looping as I believe you intended (which, as the comments on the question mention, you probably aren't) because acids (which takes the value of a single character) will never be equal to the three character string you're comparing it to.  Thus, no replacements will be performed.</p>

<p>To do what you want, try something like this:</p>

<pre><code>for (int i = 0; i + 3 &lt; line.length(); i += 3) // counting by 3 until end of line
{
    if (line.substr(i, 3) == ""GUU"")            // if the substring matches
    {
        line.assign(""ZAP"", i, 3);              // overwrite it with new substring
    }
}
return line;
</code></pre>
",1
15538460,15538382,1,"<pre><code>for( int i= 0; i &lt; line.length(); i++)
    acid = line[i];
</code></pre>

<p>Say line contains ""abcd"", this loop is going to do:</p>

<pre><code>acid = 'a';
acid = 'b';
acid = 'c';
acid = 'd';
</code></pre>

<p>Only the last assignment has any lasting affect.  If you need to actually get three characters from line into acid - you probably want to use <code>+=</code> to add characters into <code>acid</code>, rather than <code>=</code>.  But, if you loop over all of line like this, you'll end up doing <code>acid = line;</code>.  I assume you want something more like <code>acid = line.substr(0, 3)</code>?</p>

<pre><code>for (int i = 0; i &lt; 3; i++)
{
     acids = acid[i];
</code></pre>

<p>This is going to crash.  <code>acid</code> is definitely a single character string, and you're indexing into <code>acid[1]</code> and <code>acid[2]</code> on the 2nd and 3rd iterations.  While you're learning C++, you should probably use <code>.at(i)</code> which will throw an exception when you attempt to use an invalid index - you can catch the exception and at least have some indication of the problem.  As is, it's undefined behaviour.</p>

<p>To use at, you need a <code>try</code> / <code>catch</code> block... the basic form is:</p>

<pre><code>int main()
try
{
    ...your code in here...
    some_string.at(i);
}
catch (const std::exception&amp; e)
{
    std::cerr &lt;&lt; ""caught exception: "" &lt;&lt; e.what() &lt;&lt; '\n';
}
</code></pre>

<p>More generally, try putting some <code>std::cout</code> statements throughout your code so you know what values your variables actually have... you would easily have seen that they weren't what you expected.  Alternatively, use an interactive debugger and watch the affect of each statement's execution.</p>
",0
15538528,15538382,0,"<p>Reading from your description, you want something like so</p>

<pre><code>//note below does not compile, its just psuedo-code

string amino_acid(const string&amp; sequence){
  string result = sequence; //make copy of original sequence
  For i = 0 to sequence.length - 3 
    string next3Seq = sequence(i,3); //grab next 3 character from current index
    If next3Seq == 'GUU' //if the next next three sequence is 'GUU'
      then result.replace(i,3,'ZAP'); //replace 'GUU' with 'ZAP'
    EndIf
  EndFor
  return result;   
}
</code></pre>

<p>You can use that as a start to code. Good Luck.</p>
",0
15538546,15538382,0,"<p>According to my understanding of your question. I have written some code. Please look below</p>

<pre><code>string acids;
string newLine;
int limit=1;
for(int i=0;i&lt;line.length();i++)
{
    acids=acids+line[i];
    if(limit==3)//Every 3 characters
    {
      if(acids == ""GUU"")
        {
            acids = ""ZAP"";  
        }       
        limit=1;
        acids=""""
        newline=newline+acids;
    }
limit++;
    return newline;
}
</code></pre>
",0
15510150,15510099,1,"<p>In your <code>RNA_complement</code> function you wrote:</p>

<pre><code>ofstream genesacidnew;
</code></pre>

<p>You never specified which file to write to. Use like this</p>

<pre><code>ofstream genesacidnew(""Myfilename.ext"");
</code></pre>
",1
15510351,15510099,2,"<p>First off, let¡¯s get clear on what an RNA complement is: it consists of replacing the letters of the RNA bases with the complementary base codes, i.e. <code>A</code> ? <code>U</code> and <code>C</code> ? <code>G</code> (I¡¯m ignoring IUPAC ambiguity codes here since they¡¯re rarely used).</p>

<p>Secondly, let¡¯s specify the scope of your function. At the moment it (unsuccessfully) attempts to do two things:</p>

<ol>
<li>Change the string itself, and</li>
<li>Write the changed bases to a file.</li>
</ol>

<p>It also returns something (<code>char</code>) but it¡¯s unclear what.</p>

<p>Let¡¯s start from scratch and specify the semantics properly:</p>

<ul>
<li>The function <code>rna_complement</code> (note C++ naming conventions) takes an RNA fragment as a <code>std::string</code> (in all uppercase letters) and returns a complemented version of the fragment.</li>
</ul>

<p>This is straightforward and unambiguous. <strong>Now</strong> we can implement it:</p>

<pre><code>std::string rna_complement(std::string fragment) {
    for (unsigned pos = 0; pos &lt; fragment.length(); ++pos) {
        switch (fragment[pos]) {
            case 'A': fragment[pos] = 'U'; break;
            case 'C': fragment[pos] = 'G'; break;
            case 'G': fragment[pos] = 'C'; break;
            case 'U': fragment[pos] = 'A'; break;
            default: assert(false); // This should never happen.
        }
    }

    return fragment;
}
</code></pre>
",4
16409826,16409800,1,"<p>increment j in the second cycle, not i ;)</p>
",0
16409827,16409800,3,"<pre><code> for(int j = 0; j &lt; 26; i++)
</code></pre>

<p>I'd replace that <code>i++</code> with a <code>j++</code>.</p>
",1
16409865,16409800,1,"<p>While probably not strictly related to this particular segfault, I'd also check to make sure that the read is good for safety.</p>

<pre><code>if(file.good())
{
    gamemap[i][j] = file.get();
    //etc etc
}
</code></pre>
",1
15538188,15538169,2,"<p>The <code>--</code> operator is an ""decrement and return"" operator. Since it is used as postdecrement, it returns <code>t</code> and then decrement the value.</p>

<p>In C++ everything that is different from 0 is <code>true</code> and viceversa so basically it's equivalent to </p>

<pre><code>t == 0
</code></pre>

<p>Of course things would be different in case of <code>--t</code>, since it would decrement the value before and then return it (it would end the loop one iteration earlier).</p>
",6
15538218,15538169,0,"<p><code>for ( init; condition; increment )</code> is just the recommended way to use for loops. The real way for loops work is:</p>

<pre><code>for(
    &lt;runs once before loop&gt;;
    &lt;check before every iteration, loop if true/non-zero&gt;;
    &lt;run after every iteration&gt;)
</code></pre>
",0
17099467,17099439,2,"<p><code>getwheels</code> returns <code>void</code>, but you're printing it out as if it has a return value. If a function returns nothing, you can't print the result of calling it.</p>

<p>To solve, just call the function without printing:</p>

<pre><code>getwheels( my_car );
</code></pre>

<p>Or if what you meant to do was print out the <code>wheels</code> value, print the value inside the function:</p>

<pre><code>void getwheels(car&amp; i_car)
{
    cout &lt;&lt; i_car.wheels &lt;&lt; endl;
}
</code></pre>
",1
17099471,17099439,1,"<p>Try to return <strong>wheels</strong> from getwheels instead of <strong>void</strong></p>

<pre><code>int getwheels(const car&amp; i_car)
{
  return i_car.wheels;
}
</code></pre>

<p>Or pass <strong>std::ostream</strong> into getwheels:</p>

<pre><code>std::ostream&amp; getwheels(std::ostream&amp; out, const car&amp; i_car)
{
  //do something here
  out &lt;&lt; i_car.wheels &lt;&lt; std::endl;;
  return out;
}

int main()
{
  car mycar;

  mycar.wheels = 6;

  getwheels(std::cout, mycar);
}
</code></pre>
",0
16950810,16950793,2,"<p>You need to remove the definition of the default constructor from your <code>.cpp</code> file, since you have a single parameter constructor with a default parameter:</p>

<pre><code>czlowiek(const string&amp; ulubioneKsiazki=""Brak informacji"")
{
    this-&gt;ulubioneKsiazki=ulubioneKsiazki;
};
</code></pre>

<p>This acts as a default constructor, since it can be invoked without arguments.</p>

<p>Another alternative is to remove the default parameter in the single parameter constructor, and add a declaration for the default constructor. For example:</p>

<pre><code>czlowiek() : ulubioneKsiazki=""Brak informacji"" {}
czlowiek(const string&amp; ulubioneKsiazki) : ulubioneKsiazki(ulubioneKsiazki) {}
</code></pre>

<p>Bear in mind that your class has quite a few other data members that should probably be initialized.</p>
",1
17814793,17814507,4,"<ol>
<li><p>Use epsilon value just like you mentioned in question #2.</p></li>
<li><p>Use an absolute value of cos(x) like abs(cos(x)) in your if statement. .</p></li>
</ol>

<p>You can also represent infinity with double or float. Check this link. 
<a href=""http://www.gnu.org/software/libc/manual/html_node/Infinity-and-NaN.html"" rel=""nofollow"">http://www.gnu.org/software/libc/manual/html_node/Infinity-and-NaN.html</a></p>

<p>More importantly, you might want to read this article called ""What Every Computer Scientist Should Know About Floating-Point Arithmetic""
<a href=""http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html"" rel=""nofollow"">http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a></p>

<p>You will notice that each step of your floating point operations will accumulate errors in calculation. </p>
",1
17399015,17398959,3,"<p>The type of s.length() is <code>size_t</code> with a value of 2, therefore s.length() - 3 is also an unsigned type <code>size_t</code> and it has a value of <code>SIZE_MAX</code> which is implementation defined (which is 18446744073709551615 if its size is 64 bit). It is at least 32 bit type (can be 64 bit in 64 bit platforms) and this high number means an indefinite loop. In order to prevent this problem you can simply cast <code>s.length()</code> to <code>int</code>:</p>

<pre><code>for (int i = 0; i &lt; (int)s.length() - 3; i++)
{
          //..some code causing crash
}
</code></pre>

<p>In the second case <code>len</code> is -1 because it is a <code>signed integer</code> and it does not enter the loop.</p>

<p>When it comes to crashing, this ""infinite"" loop is not the direct cause of the crash. If you share the code within the loop you can get further explanation.</p>
",1
17399027,17398959,12,"<p>Actually, in the first version you loop for a very long time, as you compare <code>i</code> to an <em>unsigned</em>  integer containing a very large number. The size of a string is (in effect) the same as <code>size_t</code> which is an unsigned integer. When you subtract the <code>3</code> from that value it underflows and goes on to be a big value.</p>

<p>In the second version of the code, you assign this unsigned value to a signed variable, and so you get the correct value.</p>

<p>And it's not actually the condition or the value that causes the crash, it's most likely that you index the string out of bounds, a case of undefined behavior.</p>
",5
17399047,17398959,85,"<p><code>s.length()</code> is unsigned integer type. When you subtract 3, you make it negative. For an <code>unsigned</code>, it means <em>very big</em>.</p>

<p>A workaround (valid as long the string is long up to INT_MAX) would be to do like this:</p>

<pre><code>#include &lt;string&gt;

using namespace std;

int main() {

    string s = ""aa"";

    for (int i = 0; i &lt; static_cast&lt;int&gt; (s.length() ) - 3; i++) {

    }
}
</code></pre>

<p>Which would never enter the loop.</p>

<p>A very important detail is that you have probably received a warning ""comparing signed and unsigned value"". The problem is that if you ignore those warnings, you enter the very dangerous field of <em>implicit</em> <a href=""http://en.cppreference.com/w/cpp/language/implicit_cast"">""integer conversion""</a><sup>(*)</sup>, which has a defined behaviour, but it is difficult to follow: the best is to never ignore those compiler warnings.</p>

<p><hr>
<sub>(*) You might also be interested to know about <a href=""http://msdn.microsoft.com/en-us/library/a170dhzf.aspx"">""integer promotion""</a>.</sub></p>
",20
17400210,17398959,28,"<p>First of all: <em>why</em> does it crash? Let's step through your program like a debugger would.</p>

<p>Note: I'll assume that your loop body isn't empty, but accesses the string. If this isn't the case, the cause of the crash is <em>undefined behaviour</em> through integer overflow. See Richard Hansens answer for that.</p>

<pre><code>std::string s = ""aa"";//assign the two-character string ""aa"" to variable s of type std::string
for ( int i = 0; // create a variable i of type int with initial value 0 
i &lt; s.length() - 3 // call s.length(), subtract 3, compare the result with i. OK!
{...} // execute loop body
i++ // do the incrementing part of the loop, i now holds value 1!
i &lt; s.length() - 3 // call s.length(), subtract 3, compare the result with i. OK!
{...} // execute loop body
i++ // do the incrementing part of the loop, i now holds value 2!
i &lt; s.length() - 3 // call s.length(), subtract 3, compare the result with i. OK!
{...} // execute loop body
i++ // do the incrementing part of the loop, i now holds value 3!
.
.
</code></pre>

<p>We would expect the check <code>i &lt; s.length() - 3</code> to fail right away, since the length of <code>s</code> is two (we only every given it a length at the beginning and never changed it) and <code>2 - 3</code> is <code>-1</code>, <code>0 &lt; -1</code> is false. However we do get an ""OK"" here.</p>

<p>This is because <code>s.length()</code> isn't <code>2</code>. It's <code>2u</code>. <code>std::string::length()</code> has return type <code>size_t</code> which is an unsigned integer. So going back to the loop condition, we first get the value of <code>s.length()</code>, so <code>2u</code>, now subtract <code>3</code>. <code>3</code> is an integer literal and interpreted by the compiler as type <code>int</code>. So the compiler has to calculate <code>2u - 3</code>, two values of different types. Operations on primitive types only work for same types, so one has to be converted into the other. There are some strict rules, in this case, <code>unsigned</code> ""wins"", so <code>3</code> get's converted to <code>3u</code>. In unsigned integers, <code>2u - 3u</code> can't be <code>-1u</code> as such a number does not exists (well, because it has a sign of course!). Instead it calculates every operation <code>modulo 2^(n_bits)</code>, where <code>n_bits</code> is the number of bits in this type (usually 8, 16, 32 or 64). So instead of <code>-1</code> we get <code>4294967295u</code> (assuming 32bit).</p>

<p>So now the compiler is done with <code>s.length() - 3</code> (of course it's much much faster than me ;-) ), now let's go for the comparison: <code>i &lt; s.length() - 3</code>. Putting in the values: <code>0 &lt; 4294967295u</code>. Again, different types, <code>0</code> becomes <code>0u</code>, the comparison <code>0u &lt; 4294967295u</code> is obviously true, the loop condition is positively checked, we can now execute the loop body.</p>

<p>After incrementing, the only thing that changes in the above is the value of <code>i</code>. The value of <code>i</code> will again be converted into an unsigned int, as the comparison needs it.</p>

<p>So we have </p>

<pre><code>(0u &lt; 4294967295u) == true, let's do the loop body!
(1u &lt; 4294967295u) == true, let's do the loop body!
(2u &lt; 4294967295u) == true, let's do the loop body!
</code></pre>

<p>Here's the problem: What do you do in the loop body? Presumably you <em>access</em> the <code>i^th</code> character of your string, don't you? Even though it wasn't your intention, you didn't only accessed the zeroth and first, but also the second! The second doesn't exists (as your string only has two characters, the zeroth and first), you access memory you shouldn't, the program does whatever it wants (undefined behaviour). Note that the program isn't required to crash immediately. It can seem to work fine for another half an hour, so these mistakes are hard to catch. But it's always dangerous to access memory beyond the bounds, this is where most crashes come from.</p>

<p>So in summary, you get a different value from <code>s.length() - 3</code> from that what you'd expect, this results in a positive loop condition check, that leads to repetitive execution of the loop body, which in itself accesses memory it shouldn't.</p>

<p>Now let's see how to avoid that, i.e. how to tell the compiler what you actually meant in your loop condition.</p>

<hr>

<p>Lengths of strings and sizes of containers are inherently <em>unsigned</em> so you should use an unsigned integer in for loops.</p>

<p>Since <code>unsigned int</code> is fairly long and therefore undesirable to write over and over again in loops, just use <code>size_t</code>. This is the type every container in the STL uses for storing length or size. You may need to include <code>cstddef</code> to assert platform independence.</p>

<pre><code>#include &lt;cstddef&gt;
#include &lt;string&gt;

using namespace std;

int main() {

    string s = ""aa"";

    for ( size_t i = 0; i + 3 &lt; s.length(); i++) {
    //    ^^^^^^         ^^^^
    }
}
</code></pre>

<p>Since <code>a &lt; b - 3</code> is mathematically equivalent to <code>a + 3 &lt; b</code>, we can interchange them. However, <code>a + 3 &lt; b</code> prevents <code>b - 3</code> to be a huge value. Recall that <code>s.length()</code> returns an unsigned integer and unsigned integers perform operations module <code>2^(bits)</code> where bits is the number of bits in the type (usually 8, 16, 32 or 64). Therefore with <code>s.length() == 2</code>, <code>s.length() - 3 == -1 == 2^(bits) - 1</code>. </p>

<hr>

<p>Alternatively, if you want to use <code>i &lt; s.length() - 3</code> for personal preference, you have to add a condition:</p>

<pre><code>for ( size_t i = 0; (s.length() &gt; 3) &amp;&amp; (i &lt; s.length() - 3); ++i )
//    ^             ^                    ^- your actual condition
//    ^             ^- check if the string is long enough
//    ^- still prefer unsigned types!
</code></pre>
",10
17404016,17398959,1,"<p>Since s.length() is unsigned type quantity, when you do s.length()-3, it becomes negative and negative values are stored as large positive values (due to unsigned conversion specifications) and the loop goes infinite and hence it crashes.</p>

<p>To make it work, you must typecast the s.length() as :</p>

<p>static_cast &lt; int > (s.length())</p>
",3
17405499,17398959,1,"<p>The problem you are having arises from the following statement:</p>

<pre><code>i &lt; s.length() - 3
</code></pre>

<p>The result of s.length() is of the <strong>unsigned</strong> size_t type.
If you imagine the binary representation of two:</p>

<blockquote>
  <p>0...010</p>
</blockquote>

<p>And you then substitute three from this, you are effectively taking off 1 three times, that is:</p>

<blockquote>
  <p>0...001</p>
  
  <p>0...000 </p>
</blockquote>

<p>But then you have a problem, removing the third digit it underflows, as it attempts to get another digit from the left:</p>

<blockquote>
  <p>1...111</p>
</blockquote>

<p>This is what happens no matter if you have an <strong>unsigned</strong> or <strong>signed</strong> type, however the difference is the <strong>signed</strong> type uses the Most Significant Bit (or MSB) to represent if the number is negative or not. When the undeflow occurs it simply represents a negative for the <strong>signed</strong> type.</p>

<p>On the other hand, size_t is <strong>unsigned</strong>. When it underflows it will now represent the highest number size_t can possibly represent. Thus the loop is <em>practically</em> infinite (Depending on your computer, as this effects the maximum of size_t).</p>

<p>In order to fix this problem, you can manipulate the code you have in a few different ways:</p>

<pre><code>int main() {
    string s = ""aa"";
    for (size_t i = 3; i &lt; s.length(); i++) {

    }
}
</code></pre>

<p>or</p>

<pre><code>int main() {
    string s = ""aa"";
    for (size_t i = 0; i + 3 &lt; s.length(); i++) {

    }
}
</code></pre>

<p>or even:</p>

<pre><code>int main() {
    string s = ""aa"";
    for(size_t i = s.length(); i &gt; 3; --i) {

    }
}
</code></pre>

<p>The important things to note is that the substitution has been omitted and instead addition has been used elsewhere with the same logical evaluations.
Both the first and last ones change the value of <code>i</code> that is available inside the <code>for</code> loop whereas the second will keep it the same.</p>

<p>I was tempted to provide this as an example of code:</p>

<pre><code>int main() {
    string s = ""aa"";
    for(size_t i = s.length(); --i &gt; 2;) {

    }
}
</code></pre>

<p>After some thought I realised this was a bad idea. Readers' exercise is to work out why!</p>
",6
18164333,18164297,2,"<p>You can't use the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators to write/read unformatted data (they are dealing only with textual input and output), but you can use the <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/write"" rel=""nofollow""><code>write</code></a> method of output streams and the <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/read"" rel=""nofollow""><code>read</code></a> method of input streams.</p>

<p>And as <code>std::string</code> actually don't really care about the data it holds you should be able to use <code>stringstream</code> (and its output/input variants).</p>
",1
17790684,17790600,0,"<p>You are dividing the denominator by the numerator, swap the two in <code>operator double() const</code> :)</p>

<pre><code>operator double() const
{
    cout&lt;&lt; ""()""&lt;&lt;endl;
    return ((double)this-&gt;numerator)/this-&gt;denominator;
};
</code></pre>

<p>The ctor won't call the <code>operator double()</code> function, it is only called when you try casting your <code>Rational</code> to a <code>double</code>. i.e.:</p>

<pre><code>Rational frac(5, 7);
double result = (double)frac;
</code></pre>

<h1>Edit</h1>

<p>If you want more control over your output then you can overload the `operator&lt;&lt;' so you could feed your own data into cout.  Here is how I've implemented it:</p>

<p>Inside your class definition:</p>

<pre><code>friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; stream, const Rational&amp; ra);
</code></pre>

<p>and somewhere in your source file:</p>

<pre><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; stream, const Rational&amp; ra)
{
    return stream &lt;&lt; ra.numerator &lt;&lt; "", "" &lt;&lt; ra.denominator;
    // or: return stream &lt;&lt; (int)ra;
    // or: return stream &lt;&lt; (double)ra;
}
</code></pre>

<p>then you can call:</p>

<pre><code>cout &lt;&lt; ra &lt;&lt; endl;
</code></pre>
",6
18286784,18286613,2,"<p>Okay got it ... @chris : you were right..When I did this:</p>

<pre><code>int p = fun();
p++;
std::cout &lt;&lt; p &lt;&lt; endl &lt;&lt; a;
</code></pre>

<p>It showed the results to be 11 and 10. Hence only a's value is copied into p and p doesn't became the alias of a.
But when I tried the same with second code, it showed values of both a and p to be 11. Hence p became the alias of a.</p>
",2
11892645,11892591,9,"<p>The destructor of your base class isn't <code>virtual</code>. It's simply a rule of the language that if you delete an object through a pointer to a base subobject, the corresponding base class must have a virtual des&shy;truc&shy;tor, or otherwise it is undefined behaviour.</p>

<p>(In practice, if your base class doesn't have a virtual destructor, the compiler may not emit the necessary code to perform all the necessary clean-up for the derived object. It will just assume that your object is of the same type as the pointer and not bother to look further, as indeed the polymorphic lookup of the most derived object comes at a cost that you don't want to impose needlessly.)</p>

<p><strong>¡ì5.3.5/3:</strong></p>

<blockquote>
  <p>In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand¡¯s dynamic type and the static type shall have a virtual destructor or the behavior is undefined</p>
</blockquote>
",4
11892663,11892591,2,"<p>You should make your destructor virtual in a base class. The problem with the code as it is now is that <code>delete p_base</code> will cause a destructor of base class to be called. The one from the derived class won't be called and the memory allocated for the array of integers won't be freed. </p>

<p>This happens because if a method isn't virtual in a base class, compiler simply looks at a pointer type and calls a method located in this type (in this case - it's a base class) i.e. a decision what method to call is made during compilation time based on the type of the pointer and not the real type of the object the pointer is referring to.</p>
",0
11892672,11892591,-3,"<p>I guess compiler is allowed to optimize this code and hence the assignment of p_derived to p_base never happens.</p>

<p>To be more specific the compiler may optimize the code to one line. </p>

<p>delete new derived();</p>

<p>Hence it is viewed that the behavior as undefined as this can change how the compiler really optimizes the code. </p>
",1
11893154,11892591,0,"<p>Out of curiousity I check the C++ specs. The answer to the question is item 3 in section 5.3.5: </p>

<blockquote>
  <p>In the ?rst alternative (delete object), if the static type of the
  object to be deleted is di?erent from its dynamic type, the static
  type shall be a base class of the dynamic type of the object to be
  deleted and the static type shall have a virtual destructor or <em>the
  behavior is unde?ned.</em></p>
</blockquote>

<p>Personally, I would have answered the same way you did. If you ignore the compiler's warning, the most likely outcome is that the destructor of the derived class won't get called. </p>
",0
17862364,17862265,0,"<p>You can pass a pointer to the array within a vector by passing the address of the first element within the vector.</p>

<p>insertion_sort(&amp;crew[0], crew.size());</p>
",2
17862385,17862265,2,"<p>Your function <code>insertion_sort</code> is implemented to sort arrays of <code>int</code> and the function will not work for sorting of your vector of <code>Person</code> objects.</p>

<p>If you want to sort your vector of <code>Person</code> objects I suggest you use <code>std::sort</code> from the standard library. To use it you must implement the <code>&lt;</code> operator for <code>Person</code> objects.</p>

<p><strong>Example:</strong></p>

<pre><code>// Only to demonstrate.
struct Person {
    std::string name;
    int age;
};

// Implement according to your needs.
bool operator&lt; (const Person&amp; lhs, const Person&amp; rhs) {
    return lhs.name &lt; rhs.name;
}
</code></pre>

<p>&nbsp;</p>

<pre><code>int main() {
    vector&lt;Person&gt; crew = ucitaj_osobe(""osobe.txt"");

    std::sort(begin(crew), end(crew));

    ispisi_osobe(popis);

    // return 0; Unnecessary in main function.
}
</code></pre>

<p><strong>Live example:</strong> <a href=""http://ideone.com/YEL7IV"" rel=""nofollow"">http://ideone.com/YEL7IV</a></p>

<p>Note that <code>std::sort</code> is not guaranteed to use insertion sort.</p>
",2
17863251,17862265,0,"<p>Your <code>insertion_sort</code> is designed to sort arrays of <code>int</code>, and
only arrays of <code>int</code>.  You cannot use it on arrays of <code>Person</code>.</p>

<p>You don't say why you want to use this insertion sort, instead
of <code>std::sort</code>.  But if you want to use it on vector of
<code>Person</code>, you'll have to change its first argument to <code>Person*</code>,
and pass it <code>&amp;crew[0], crew.size()</code>.  A better solution would be
to convert it to take an <code>std::vector&lt;Person&gt;</code> directly, rather
than a pointer and a size.  An even better solution would be
a template taking two bidirectional iterators, and invoke it
with <code>crew.begin(), crew.end()</code>. </p>
",3
18178700,18178671,4,"<p>You have a few choices:</p>

<ol>
<li>Write each sim result to a separate file and collate later;</li>
<li>Hold all results in memory until finished;</li>
<li>After each simulation, read the existing file, and output it again with the new results added in;</li>
<li>Knowing the number of simulations you intend to produce, write results in binary and leave padding for those that are not yet done.</li>
</ol>

<p>I would probably go with 1.</p>
",1
18178715,18178671,0,"<p>By ""goes back to the top of the file"", do you actually mean <a href=""http://beej.us/guide/bgc/output/html/multipage/fseek.html"" rel=""nofollow"">rewind</a> the <a href=""http://www.cplusplus.com/doc/tutorial/files/"" rel=""nofollow"">file pointer</a> to access memory starting at the beginning of the file? I will assume that's what you meant. Since you want the first input after the last output, then you can run your simulations and print them in reverse order, or simply call the appropriate library functions as you need them.</p>
",3
18247098,18247000,5,"<p>The variable <code>charDecision</code> is declared as an <code>int</code>.</p>

<p>The C++ standard I/O streams classes (including <code>cin</code> and <code>cout</code>, among other things) are relatively intelligent, and ""do the Right Thing"" based on the type of the variable you give it.</p>

<p>When the expression <code>cin &gt;&gt; charDecision</code> is executed, <code>cin</code> reads everything that looks like a number <em>and converts it into the native representation of the number.</em> So, when you type <code>1</code> on that menu, what gets stored is the literal number 1. Your switch is testing the literal <em>character</em> <code>'1'</code>, which has the integer value of 49, so it will not match, since 49 != 1.</p>

<p>You will want to either change the type of <code>charDecision</code> to <code>char</code> <strong>or</strong> test the number <code>1</code> instead of the character <code>'1'</code>.</p>
",1
18247105,18247000,6,"<p>Your switch statement compares an <code>int charDecision</code> with <code>'1'</code> which is a <code>char</code>.</p>

<p>You read from standard input into an <code>int</code> which means <code>charDecision</code> will contain 1. You then compare this 1 against <code>'1'</code> which translates to 49 when casted to <code>int</code>. Thus your input will never match (unless you input 49).</p>

<p>Fix: Compare against <code>1</code> or make <code>charDecision</code> a <code>char</code>.</p>
",1
18206142,18206056,0,"<pre><code>    #include &lt;iostream&gt;

    void language() {
    std::cout &lt;&lt; ""1.English\n2.ÖÐÎÄ"";
    }

    int main() {
        language();
        return 0;
    }
</code></pre>
",0
18206146,18206056,1,"<p>If you want the user to select a language then your code needs to be more like this:</p>

<pre><code>#include &lt;iostream&gt;

int language() {
    int choice;

    std::cout &lt;&lt; ""1.English\n2.ÖÐÎÄ"";  // print menu of language choices
    std::cin &gt;&gt; choice;               // get selection from user
    // NB: real code would have error checking here to make sure that `choice` is valid
    return choice;                    // return selection
}

int main() {
    std::cout &lt;&lt; language();
}
</code></pre>
",3
18206161,18206056,3,"<p>In your program, you print your string first and after you print the return value of the function... That's why you have a number after the string.</p>

<p>Just try :</p>

<pre><code>// I don't think your language function need to return something
// So make it void
void language() {
    std::cout &lt;&lt; ""1.English\n2.ÖÐÎÄ"";
}

int main() {
    language(); // Here no need to print the value returned by the language function
    return 0;   // Main return an int, 0 is for success
}
</code></pre>

<hr>

<p>Just to explain a bit more :</p>

<p>The fact that your <code>language()</code> function return an <code>int</code> value and that you are not returning anything leads to <strong>Undefined behaviour</strong>. That's why you get a value like <code>4683872</code>. And it is also why you have a warning at the compilation.</p>
",2
18206171,18206056,2,"<p>You have two problems in your code: The first is that you declare <code>language</code> as returning an <code>int</code> but then not actually returning anything. This is what the warning is about. The other problem is based on the first one, and that you actually use this ""returned value"" even though there is none, which leads to undefined behavior.</p>

<p>You can solve it in two ways: Either return a valid value from the function, or declare it as returning <code>void</code> and don't use the function in an expression.</p>
",0
18206100,18206056,0,"<p>The <code>std::cout &lt;&lt; language();</code> is printing an integer for you since <code>language()</code> returns an <code>int</code>. If you don't want anything to print after your text, then remove the <code>std::cout &lt;&lt;</code> in your <code>main</code>.</p>
",2
18211952,18211800,0,"<p>You REALLY do not want to call <code>main</code> from another function. In C it is technically allowed, in C++ it is ""undefined behaviour"" and thus something you should avoid doing. </p>

<p>The solution is instead to put a loop around the call to language in main:</p>

<pre><code>int main()
{
    int result = 0;
    do
    {
       result = language();
    } while(result != 0); 
}
</code></pre>

<p>Then let your <code>language</code> function return 0 when it's time to ""quit"", and non-zero when it should continue. </p>
",2
18211825,18211800,5,"<p>You need to declare function before first usage.</p>

<p>Also, as noted, per standard, you must not use main within the program:</p>

<blockquote>
  <p>The function main shall not be used within a program.</p>
</blockquote>

<p>So, create another function and encapsulate the current work inside it!</p>

<pre><code>int language(); // DECLARATION

// You could also just define function before first usage:
void do_work()
{
    language();
}


int main() {
    do_work();                     // The main function redirect user to the language function
}

int language() {                    // The language() function DEFINITION
    std::cout &lt;&lt; ""1 for cookie!"";        
    std::cin &gt;&gt; choice;             // Ask user for choice

    // If you enter the invalid input in cin (character for example)
    // you need to reset cin in order to allow user to enter new choice

    std::cin.clear(); 
    // don't forget to include &lt;limits&gt;
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');


    if (choice == 1) {
        choice1();                  // If the choice is 1, user will be redirected to choice1() function
    } else {
        do_work();                      // Otherwise user will be redirected to do_work and of course, redirect to language() function again
    }
}
</code></pre>

<p><strong>NOTE:</strong> Looping (especially potentially infinite) using recursion (you have an indirect one here: do_work -> language -> do_work) can be dangerous! Please see other answers to get an idea how to solve this with loop statements!</p>

<p><strong>EDIT</strong> In case you want to check entire line, and not just the first character, you can read the whole line into a string, check if string has lenght 1 (user entered only one character), and than you can switch using the first character:</p>

<pre><code>include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;

int language(); // DECLARATION

// You could also just define function before first usage:
void do_work()
{
    language();
}


int main() {
    do_work();                     // The main function redirect user to the language function
}

int language() {                    // The language() function DEFINITION
    std::string choice;
    std::cout &lt;&lt; ""1 for cookie!"";

    std::getline(std::cin, choice);

    if (choice.length() == 1 &amp;&amp; choice.at(0) == '1') {
       choice1();                 // If the choice is 1, user will be redirected to choice1() function
    } else {
        do_work();                      // Otherwise user will be redirected to do_work and of course, redirect to language() function again
    }
}
</code></pre>
",12
18212011,18211800,0,"<p>use function prototypes, somewhere before main, write code similar to this:</p>

<pre><code>void language();
</code></pre>

<p>then, you can write the code for the function anywhere within the compiled files.</p>
",0
18211869,18211800,1,"<p>You have to put the prototype of your function before the call :</p>

<pre><code>int language(); // Declare the function, it is the prototype of the function here

int main() {
    language();                     // The main function redirect user to the language function
}

int language() {                    // The language() function 
    std::cout &lt;&lt; ""1 for cookie!"";        
    std::cin &gt;&gt; choice;             // Ask user for choice
    if (choice == 1) {
        choice1();                  // If the choice is 1, user will be redirected to choice1() function
    } else {
        // main(); // &lt;- You cannot do this !!
        language(); // Use recursive code
    }
}
</code></pre>

<p>Note that in the code below :</p>

<ul>
<li>I added the prototype of the function <code>language();</code> before the <code>main</code>.</li>
<li>I changed the call to the <code>main</code> who is forbidden by the standard and make your function recursive.</li>
</ul>
",0
15566885,15566511,1,"<p>I'm not implementing your Pseudo code, I'm just showing you how it can be in C++.
One possibility is:</p>

<pre><code>// ...
// Declarations, prototypes, header file inclusions, ...
// ...
for (int i=1; i&lt;=n; i++)
{
    m[i] = max(m[i-1], 1+ binarySearch(f, s[i]));

    if (activity_is_in_optimal_selection(i))
        P[i] = 1;
    else
        P[i] = 0;

    i = n;

    while (i&gt;0)
    {
        if (m[i]==m[i-1])
        {
            P[i] = 0;
            i--;
        }
        else
        {
            i = binarySearch(f, s[i]);
            P[i] = 1;
        }
    }
}
</code></pre>

<p>I'm not sure that I understood your algorithm or not, but open your IDE and start to write the program.</p>
",0
18113029,18113008,11,"<p>You need to inherit publicly:</p>

<pre><code>//""public"" keyword
class VideoInput : public AbstractInput

//""public"" keyword
class ImageInput : public AbstractInput
</code></pre>
",0
18113038,18113008,6,"<p>The base class is inaccessible because you are privately inheriting. Change:</p>

<pre><code>class VideoInput : AbstractInput // private inheritance
</code></pre>

<p>to</p>

<pre><code>class VideoInput : public AbstractInput // public inheritance
</code></pre>

<p>and same for <code>ImageInput</code></p>
",0
18109072,18108643,0,"<p>I would simply comment on Michael Goldshteyn's post, but I guess I don't have enough reputation to do that (lol) so consider this an comment on his post:</p>

<p>If you need the + operator to access private data of your CMatrix class (as it will need to do in this case), you can declare this function a friend inside of you CMatrix class by inserting the line:</p>

<pre><code>friend CMatrix operator+(const CMatrix &amp;, const CMatrix &amp;);
</code></pre>

<p>anywhere inside of your CMatrix class definition.  This allows the overloaded operator function that you define elsewhere to access private and protected members of your class (like your pData member).</p>
",1
18222082,18221795,2,"<p>Would the following make sense for the first line, or am I missing something:</p>

<pre><code>string input;
std::getline(datafile, input)
for (int i = 0; i &lt; input.size(); i++)
    if (input[i] == '+' || ...)
    {
        operations[a] = input[i];
        a++;
    }
</code></pre>

<p>If you don't want to use getline, you could simply read the entire file stream (note that the bool is a rather naive way to handle the problem, I'd recommend something more elegant in your actual code):</p>

<pre><code>bool first = true;
string nums;
int lines = 0;
vector&lt;vector&lt;int&gt;&gt; numlines;
vector&lt;int&gt; topush;
while (!datafile.eof())
{
char ch = datafile.get()
if (ch == 12 &amp;&amp; first) //I don't know if '\n' is valid, I'd assume it is but here's the sure bet
    first = false;
else if (first &amp;&amp; (ch == '+' || ...))
{
    operator[a] = ch;
    a++;
}
else if (!first &amp;&amp; (ch &gt;= '0' &amp;&amp; ch &lt;= '9'))
{
    if (!(datafile.peek() &gt;= '0' &amp;&amp; datafile.peek() &lt;= '0'))
    {
         numlines[lines].push_back(atoi(nums.c_str());
         nums.clear();
         if (datafile.peek() == 12)
         {
             numlines.push_back(topush);
             lines++;
         }
    }
    else
        nums = nums + ch;
}
</code></pre>

<p>Honestly, I can't be sure the above will work exactly right, I'd recommend you just modify your code to use getline exclusively.  You'll need to add #include  to get atoi.</p>
",0
18221970,18221795,0,"<p>Add this to your code:</p>

<pre><code>while(!datafile.eof()){
    string s;
    getline(datafile, s);
    istringstream in(s);
    string tmp;
        while(in &gt;&gt; tmp){
            int i = stoi(tmp) 
            //Do something with i....
        }
}
</code></pre>
",0
15552593,15552557,4,"<p>The object originally pointed to by <code>newBse</code> will be leaked.  When you assigned the address of <code>newDrvd</code> to <code>newBse</code> you are losing the pointer to the heap-allocated object, and you will not be able to <code>delete</code> it.  This memory will be unusable until the process terminates.</p>

<p>Additionally, you are returning the address of a stack-allocated object as a pointer, which is bad for two reasons:</p>

<ol>
<li>The object's destructor will have been called before the function returns, meaning you would be using a pointer to a destructed object.</li>
<li>The memory allocated for the object lives on the stack and will almost certainly be clobbered by future function calls.  At that point, your pointer will be point at something that is not a <code>bseCls</code>, but you will be using it as though it were.</li>
</ol>

<p>If you use the pointer returned by this function, you are invoking undefined behavior and your program has license to do <em>anything</em>.</p>
",0
15552597,15552557,1,"<p>No, it won't be automatically deallocated. Every call to <code>new</code> must be matched by a call to <code>delete</code>. But that's not the only problem with your code, you're also returning the address of a local variable from the function.</p>

<pre><code>newBse = &amp;newDrvd; // memory leak, pointer to previously allocated object is lost
return newBse;     // newDrvd is destroyed when function exits, so returned
                   // pointer points to invalid memory
</code></pre>

<p>What you probably want to do is</p>

<pre><code>bseCls* Test()
{
    return new drvdCls();
}
</code></pre>

<p>Now the caller must call <code>delete</code> on the returned pointer after using it. What you should do is</p>

<pre><code>std::unique_ptr&lt;bseCls&gt; Test()
{
    return new drvdCls();
}
</code></pre>

<p>Now the allocated object will automatically be <code>delete</code>d when the returned <code>unique_ptr</code> goes out of scope.</p>
",1
15559017,15558987,2,"<p>It is undefined because it the <code>location</code> exists only in the context of an <strong>object</strong> of type <code>MessagePiece</code></p>

<pre><code>MessagePiece mp;
in &gt;&gt; mp.location;
</code></pre>
",4
15559165,15558987,0,"<p>You should use &amp;&amp; instead of ',' in your if statement for checking the condition.
Also, these lines:</p>

<pre><code>MessagePiece;
message[256];
Message message;
</code></pre>

<p>should be written like this:</p>

<pre><code>MessagePiece messages[256]; //declaring an array of struct MessagePiece
char message; // a char for storing input read from the user. 
</code></pre>

<p>One more thing, either take message as an argument or declare it in the function itself.</p>

<p>Please consider reading a good book on programming in C++.</p>
",2
15560308,15560208,1,"<p>You need this bit in the erase function:</p>

<pre><code> if (remove == first)
    first = after;
  else
    before-&gt;next = after;
</code></pre>
",0
15877987,15877945,0,"<p><code>int array[][1]</code> declares an array with only one element in its second dimension. You can't then initialize each of the elements in the first dimension with <code>{1,2}</code> or <code>{5,6}</code>, because that would require <em>two</em> elements.</p>

<p>You would, for example, be able to initialize it like so:</p>

<pre><code>int array[][1] = {{1}, {2}, {3}};
</code></pre>
",4
15807475,15807431,6,"<p>This is not <em>assignment</em>:</p>

<pre><code>count == count +1;
</code></pre>

<p>but is an equality check meaning <code>count</code>'s value is never changed. Change to:</p>

<pre><code>count++;
</code></pre>

<p>or:</p>

<pre><code>// See comment from rhalbersma.
++count;
</code></pre>

<p>There is also a trailing semi-colon after (not to mention missing parenthesis):</p>

<pre><code>if count &gt; 8;
</code></pre>

<p>Change to:</p>

<pre><code>if (count &gt; 8)
{
    istringstream buffer(line);
    int x, y; 
    if (buffer &gt;&gt; x &gt;&gt; y) // Correction here also.
    {
        Station objName = {x, y};
        data_station.push_back(objName);
    }
}
</code></pre>
",16
15807491,15807431,0,"<p>change this :<code>count == count +1;</code> to <code>count = count +1;</code></p>

<p>better would be <code>count++;</code></p>
",0
15807526,15807431,1,"<p>First of all, you need to use assignment rather than test for equality:</p>

<pre><code>count = count + 1;
//    ^ here
</code></pre>

<p>However, this can be written more concisely as:</p>

<pre><code>count++;
</code></pre>

<p>Also, note that the syntax of an <code>if</code> statement requires parentheses around the condition. To group many statements together as part of the <code>if</code>, introduce a block with <code>{</code> and <code>}</code>:</p>

<pre><code>if (condition) {
  block of statements
}
</code></pre>

<p>So your code should look like this:</p>

<pre><code>if (count &gt; 8) {
  istringstream buffer(line);
  int x, y; 
  if (!(buffer &gt;&gt; x &gt;&gt; y)) {
    Station objName = {x, y};
    data_station.push_back(objName);
  }
}
</code></pre>

<p>It also seems that you have that inner <code>if</code> condition backwards. You want the block to be executed when the extractions succeed:</p>

<pre><code>if (buffer &gt;&gt; x &gt;&gt; y)
</code></pre>
",0
15589693,15589636,7,"<p><code>stdafx.h</code> must come as first include file if you are using precompiled headers and Microsoft compiler.
And you must not include it in other include files.
And <code>#pragma once</code> is useless in <code>.cpp</code> files</p>
",1
17848221,17848192,13,"<p>Because inside <code>print()</code>, the variable <code>ia</code> is a pointer, not an array.  It doesn't make sense to call <code>begin()</code> on a pointer.</p>
",2
17848526,17848192,7,"<p>You are using the <code>begin</code> and <code>end</code> free functions on a pointer, that's not allowed.</p>

<p>You can do something similar with C++11's <code>intializer_list</code></p>

<pre><code>//g++ -std=c++0x test.cpp -o test
#include &lt;iostream&gt;
#include &lt;iterator&gt;
using namespace std;
void print(initializer_list&lt;int&gt; ia)
{
    auto p = begin(ia);
    while(p != end(ia))
        cout&lt;&lt;*p++&lt;&lt;'\t';
}

int main()
{
    print({1,2,3,4});   
    return 0;
}
</code></pre>
",1
17848645,17848192,6,"<p>As others pointed out, your array is decaying to a pointer. Decaying is historical artifact from C. To do what you want, pass array as reference and deduce array size: </p>

<pre><code>template&lt;size_t X&gt;
void print(int (&amp;ia)[X])
{
    int *p = begin(ia);
    while(p != end(ia))
        cout&lt;&lt;*p++&lt;&lt;'\t';
}

print(ia);
</code></pre>
",0
17861180,17861129,3,"<p>This overloads the function-call operator for the type, for the case where one argument compatible with <code>Point*</code> is passed.  For example, if this was declared on type <code>Foo</code>:</p>

<pre><code>Foo foo;
Point point;

// This calls the operator() method.
bool returnValue = foo(&amp;point);
</code></pre>

<p>There is nothing magical about the body of this method; it will simply call function <code>f</code>, passing in <code>p-&gt;pt</code>, and return the result of that expression as a bool.  (What is actually happening within the method depends on the type of <code>f</code>.)</p>
",0
17861183,17861129,0,"<p>it overloads the ""function-call"" operator, namely <code>operator()</code>, which allows you to use the object as a functor taking a parameter of type <code>TypeName*</code> (or which can be converted to it) and returning a bool.</p>
",0
17861243,17861129,0,"<p>This is basically a overload of function call operator which takes a Point object and returns a boolean value</p>
",0
15844185,15844154,1,"<p>Use</p>

<pre><code>cout &lt;&lt; ""Okt\xF3\x62\x65r"";
</code></pre>

<p>A hexadecimal escape sequence extends as far as possible, so the <code>'b'</code> and <code>'e'</code>, which are valid hexadecimal digits are included in the escape sequence.</p>
",0
15844227,15844154,1,"<p>You can use compile-time string concatenation to prevent the escape sequence going further than you wanted:</p>

<pre><code>cout &lt;&lt; ""Okt\xF3"" ""ber"";
</code></pre>
",1
15890437,15890427,8,"<pre><code>void do_something(int el, std::vector&lt;int&gt; **arr)
</code></pre>

<p>should be</p>

<pre><code>void do_something(int el, std::vector&lt;int&gt;&amp; arr)
{
    arr.push_back(el);
}
</code></pre>

<p>Pass by reference has been simplified to use the <code>&amp;</code> in C++.</p>
",3
15890462,15890427,20,"<p>If you define your function to take argument of  <code>std::vector&lt;int&gt;&amp; arr</code> and integer value, then you can use  <code>push_back</code> inside that function:</p>

<pre><code>void do_something(int el, std::vector&lt;int&gt;&amp; arr)
{
    arr.push_back(el);
    //....
}
</code></pre>

<p>usage:</p>

<pre><code>std::vector&lt;int&gt; arr;
do_something(1, arr); 
</code></pre>
",0
15890466,15890427,1,"<p>You don't need to use **arr, you can either use:</p>

<pre><code>void do_something(int el, std::vector&lt;int&gt; *arr){
    arr-&gt;push_back(el);
}
</code></pre>

<p>or:</p>

<pre><code> void do_something(int el, std::vector&lt;int&gt; &amp;arr){
    arr.push_back(el);
}
</code></pre>

<p>**arr makes no sense but if you insist using it, do it this way:</p>

<pre><code>void do_something(int el, std::vector&lt;int&gt; **arr){
    (*arr)-&gt;push_back(el);
}
</code></pre>

<p>but again there is no reason to do so...</p>
",0
15890709,15890427,3,"<p>You can <strong>pass vector by reference</strong> just like this:</p>

<pre><code>void do_something(int el, std::vector&lt;int&gt; &amp;arr){
    arr.push_back(el);
}
</code></pre>

<p>However, note that this function would always <strong>add a new element at the back</strong> of the vector, whereas your <em>array function</em> actually <strong>modifies the first element (or initializes it value)</strong>.</p>

<p>In order to achieve exactly the same result you should write:</p>

<pre><code>void do_something(int el, std::vector&lt;int&gt; &amp;arr){
    if (arr.size() == 0) { // can't modify value of non-existent element
        arr.push_back(el);
    } else {
        arr[0] = el;
    }
}
</code></pre>

<p>In this way you either add the first element (if the vector is empty) or modify its value (if there first element already exists).</p>
",0
15890794,15890427,35,"<p>You can pass the container by reference in order to modify it in the function. What other answers haven¡¯t addressed is that <code>std::vector</code> does not have a <code>push_front</code> member function. You can use the <code>insert()</code> member function on <code>vector</code> for O(n) insertion:</p>

<pre><code>void do_something(int el, std::vector&lt;int&gt; &amp;arr){
    arr.insert(arr.begin(), el);
}
</code></pre>

<p>Or use <code>std::deque</code> instead for amortised O(1) insertion:</p>

<pre><code>void do_something(int el, std::deque&lt;int&gt; &amp;arr){
    arr.push_front(el);
}
</code></pre>
",0
15854695,15854667,0,"<p>You need to initialize each of the pointers in the array to NULL. Change your constructor to this:</p>

<pre><code>Class::Class()
{
ptrStudents = new Student*[40];
for(int i = 0; i &lt; 40; i++)
    ptrStudents[i] = 0;    //NULL
}
</code></pre>

<p>When you create a pointer, it is not NULL-initialized automatically. So what's happening is you have a bunch of random pointers to garbage data, and when you reach the line </p>

<pre><code>if (ptrStudents[i] != 0)
</code></pre>

<p>they all pass because they're not NULL, even though they are unusable.</p>

<p>Whoops, I missed a big one, even when I copied your code (thank you, John). You should not re-declare the ptrStudents array; that creates a local array in your constructor, instead of initializing the member array.</p>
",5
15854737,15854667,0,"<p>The array declared in the class header is never initialized.</p>

<blockquote>
  <p><code>Student **ptrStudents = new Student*[40];</code></p>
</blockquote>

<p>This declares a local variable and initialize it with the new array.</p>

<p>Change it to:</p>

<p><code>ptrStudents = new Student*[40];</code></p>
",0
15854746,15854667,0,"<p>At least two errors</p>

<p>Firstly you should initalise your array values to NULL (as Parker Kemp says)</p>

<p>Secondly you have declared a local variable in your constructor called ptrStudents which <em>hides</em> the class variable also called ptrStudents. You should remove that declaration. So like this</p>

<pre><code>Class::Class()
{
    ptrStudents = new Student*[40];
    for(int i = 0; i &lt; 40; i++)
        ptrStudents[i] = 0;
}
</code></pre>
",0
15854752,15854667,0,"<p>Guessing from what you have shown</p>

<pre><code>Class::Class()
{
    Student **ptrStudents = new Student*[40];
}
</code></pre>

<p>declares a new <code>Student **ptrStudents</code>. To initialize the member <code>ptrStudents</code> you don't have to declare it. It is already declared.</p>

<p>What you want is </p>

<pre><code>Class::Class()
{
    ptrStudents = new Student*[40];
}
</code></pre>
",0
15854896,15854871,1,"<p>You have to pass by reference. You are passing by value. You are getting</p>

<pre><code>&amp;*Data                                              = Data
The value of the address of what is pointed to Data = Data
</code></pre>

<p>Then you pass it by value to Surname. Anything <code>Surname</code> does to it won't affect <code>Data</code> in <code>main</code>.</p>

<pre><code>int Surname(string *MyData)  // This will take a copy of whatever you passed in to MyData
</code></pre>

<p>should be (The reference operator should be on the function definition.)</p>

<pre><code>int Surname(string*&amp; MyData)
                  ^^
</code></pre>

<p>And the call will be </p>

<pre><code>void main()
{ 
     string *Data = new string[1];
     Surname(Data);  // The function will take a reference of data.
</code></pre>

<p>Buy may I ask why you are allocating in a loop? </p>
",2
15854922,15854871,0,"<ol>
<li>Looks like std::vector is best solution for your case.</li>
<li>If you really need to reallocate manually, think about old school malloc(), free(), realloc() interface. Main thing to remember is to not intermix it with C++ new/delete interface despite usually new / delete is implemented using malloc() / free().</li>
<li>If you need array you should pass not array but pointer (or reference) to array (double pointer). In case of std::vector it is enough to pass reference to it.</li>
<li>Yet another argument to use reference to std::vector - in case of pointer to array caller should be notified somehow what is new array size.</li>
</ol>
",0
15855142,15854871,0,"<p>I decided to try and go through your code line by line and point out some of the issues and highlight what's going on. I will start from your <code>main</code> function:</p>

<pre><code>void main()
{ 
    string *Data = new string[1]; // inizializza l'array 
    Surname(&amp;*Data);

    for (int iii=0; iii&lt;10; iii++)
        cout &lt;&lt; Data[iii] &lt;&lt; endl;
}
</code></pre>

<p>OK, so what this code does is allocate one string and save the pointer to it in a variable called <code>Data</code>.</p>

<p>Then it <em>dereferences</em> <code>Data</code>, thus, getting back a <code>string</code> and then gets the <em>address of</em> of that string (i.e. gets back the same thing as <code>Data</code>).</p>

<p>In other words this code: </p>

<pre><code>    Surname(&amp;*Data);
</code></pre>

<p>does exactly the same as this code:</p>

<pre><code>    Surname(Data);
</code></pre>

<p>So, now let's take a look at <code>Surname</code>:</p>

<pre><code>int Surname(string *MyData)
{
    for (int i=0; i&lt;10 ; i++)
    {
        NumLast++;
        string *Temp = new string[NumLast+1];   // temporary array 
        for (int jjj=0; jjj&lt;NumLast; jjj++)
            Temp[jjj]=MyData[jjj];
        delete[] MyData;
        MyData=Temp;
        MyData[NumLast]=""John"";
    }
    return 0;
}
</code></pre>

<p>This weird function accepts a pointer to a string and loops 10 times doing stuff. Let's see what happens in the first iteration of the loop...</p>

<p>First, it increments <code>NumLast</code> (which goes from <code>-1</code> to <code>0</code>). Then it allocate an array of strings, of length <code>NumLast + 1</code> (i.e. of length <code>1</code>). So far so good.</p>

<p>Now you might think the function would enter the <code>for</code> loop. But it won't: remember that at that point <code>NumLast</code> and <code>jjj</code> are both <code>0</code> and therefore, <code>jjj &lt; NumLast</code> is false.</p>

<p>The code will then <code>delete[] MyData</code> (that is, it will delete whatever <code>MyData</code> points to), set <code>MyData</code> to point to the temporary array allocated earlier in the loop, and then set the first element (at index <code>0</code>) to the string <code>""John""</code>.</p>

<p>In the second iteration of the loop, the function again increments <code>NumLast</code> (which will now be 1). It will again allocate an array of strings, this time of length <code>2</code>.</p>

<p>The loop will be entered this time. It will copy the first entry from <code>MyData</code> into the first entry from <code>Temp</code>. And it will exit.</p>

<p>Again, <code>MyData</code> will be deleted, and the pointer will be made to point to the newly allocated array.</p>

<p>Rinse. Lather. Repeat.</p>

<p>Finally, the function will exit. We go back to main, which will now execute this bit of code:</p>

<pre><code>for (int iii=0; iii&lt;10; iii++)
    cout &lt;&lt; Data[iii] &lt;&lt; endl;
</code></pre>

<p>Wait a second though. Where does <code>Data</code> point to? Well... it points to data that has already been deleted long ago. Why?</p>

<p>Well, <code>Surname</code> received a <em>copy</em> of the <code>Data</code> pointer. When it called <code>delete[] MyData</code> it deleted the array that it <code>MyData</code> pointed to (which was the same array that <code>Data</code> pointed to). When <code>Surname</code> later did <code>MyData=Temp</code> all that changed was <code>MyData</code> (the copy of the pointer <em>local</em> to the function <code>Surname</code>) and <code>Data</code> (the pointer in <code>main</code>) was unaffected and continued to point to the now deleted memory.</p>

<p>Others have explained how you can get the effect you want and I won't repeat what they wrote. But I would urge you to sit down and think about what <code>Surname</code> does and how the code is unclear and confusing and how it can be rewritten so that it's easier to understand and less prone to error.</p>
",2
15887693,15854871,0,"<p>For those who in the future will need the solution to the same problem here is the amended code:                               </p>

<pre><code>#include ""stdafx.h""
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

int NumLast=-1;
int Surname(string *&amp;MyData)
{       
     for (int i=0; i&lt;10 ; i++)
     {
           NumLast++;
           string *Temp = new string[NumLast+1];   
           for (int jjj=0; jjj&lt;NumLast; jjj++)
                Temp[jjj]=MyData[jjj];
           delete[] MyData;
           MyData=Temp;
           MyData[NumLast]=""franci"";
      }
      return 0;
}


void main()
{ 
      string *Data = new string[1]; // inizializza l'array 
      Surname(Data);  
      for (int iii=0; iii&lt;10; iii++)
           cout &lt;&lt; Data[iii] &lt;&lt; endl;    
      system(""pause"");
} 
</code></pre>
",0
15859685,15859665,2,"<p>This is entirely implementation dependent. An interface documentation will usually document what the <code>1</code> or the <code>0</code> stands for. Typically, they will stand for status of whether the operation for which function was called was a success or a failure.<br>
The C language standard defines two macros for indication failure and success:     </p>

<pre><code>EXIT_SUCCESS    
EXIT_FAILURE  
</code></pre>

<p>Reference:    </p>

<p><strong>C99 Standard:    7.20.4.3 The <code>exit</code> function</strong><br>
<strong>Para 5</strong>    </p>

<blockquote>
  <p>Finally, control is returned to the host environment. If the value of status is <code>zero</code> or
  <code>EXIT_SUCCESS</code>, an implementation-de?ned form of the status successful termination is
  returned. If the value of status is <code>EXIT_FAILURE</code> , an implementation-de?ned form
  of the status unsuccessful termination is returned. Otherwise the status returned is
  implementation-de?ned.</p>
</blockquote>
",0
15901350,15901289,5,"<p>It's because your structure contains constant arrays. They have to be explicitly initialized in a constructor initializer list.</p>

<p>Because of those constant member variables the compiler can't generated a default constructor for you, you have to make one yourself.</p>

<p>Actually, I think you make the arrays constant by mistake as you later in the code try to assign to them, something which can't be done as they are constant.</p>

<p>Remove the <code>const</code> part of the member array declarations and it should all work better.</p>
",0
16400334,16400092,1,"<p>Use an std::string. With it you can use  <a href=""http://www.cplusplus.com/reference/string/string/find/"" rel=""nofollow"">find()</a> to find the next newline character. Then you can use <a href=""http://www.cplusplus.com/reference/string/string/substr/"" rel=""nofollow"">substr()</a> to split the string.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main(){
    std::string str = ""aasdasdasda\nasdasdasd\nasdasdasd"";

    int index = str.find('\n'); // Find position of newline
    std::cout &lt;&lt; str.substr(0, index) &lt;&lt; std::endl; // Print string until newline
    std::cout &lt;&lt; str.substr(0, 10 ) &lt;&lt; std::endl; // Print the first 80 charcters
}
</code></pre>
",1
16400772,16400092,1,"<p>I prefer <code>char array</code> and <code>stdio</code>:</p>

<pre><code>#include &lt;cstdio&gt;
// #include &lt;cstdlib&gt;
#define SCREEN_SIZE_STR ""80""

int main(){
    const char s1[] =
        ""12345678901234567890123456789012345678901234567890123456789012345678901234567890""
        ""12345678901234567890123456789012345678901234567890123456789012345678901234567890""
        ""12345678901234567890123456789012345678901234567890123456789012345678901234567890""
        ""12345678901234567890123456789012345678901234567890123456789012345678901234567890""
        ""12345678901234567890123456789012345678901234567890123456789012345678901234567890"";
    const char s2[] = 
        ""abcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnop""
        ""abcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnop""
        ""abcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnop""
        ""abcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnop""
        ""abcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmnop"";

    int i1 = 0, i2 = 0;
    while(s1[i1] != '\0' &amp;&amp; s2[i2] != '\0'){ // print both string
        i1 += printf(""%.""SCREEN_SIZE_STR""s"", s1 + i1);
        i2 += printf(""%.""SCREEN_SIZE_STR""s"", s2 + i2);
    }
    while(s1[i1] != '\0') // print the remaining of s1
        i1 += printf(""%.""SCREEN_SIZE_STR""s"", s1 + i1);
    while(s2[i2] != '\0') // print the remaining of s2
        i2 += printf(""%.""SCREEN_SIZE_STR""s"", s2 + i2);
    // system(""pause"");
    return 0;
}
</code></pre>

<p>If you're using <code>std::string</code>:</p>

<pre><code>const char *s1 = string1.c_str();
const char *s2 = string2.c_str();
</code></pre>
",2
15869917,15869902,1,"<blockquote>
<p>Is there any chance that my compiler will reorder these two?</p>
</blockquote>
<p>Nope. It is guaranteed that <code>&amp;&amp;</code> evaluates the second expression only if the first one is <code>true</code> (incidentally, it also introduces a sequence point into the whole expression).</p>
<blockquote>
<p>The &amp;&amp; operator groups left-to-right. The operands are both contextually converted to type bool (Clause 4). The result is true if both operands are true and false otherwise. <b>Unlike <code>&amp;</code>, <code>&amp;&amp;</code> guarantees left-to-right evaluation: the second operand is not evaluated if the first operand is false.</b></p>
<p>The result is a bool. If the second expression is evaluated, every value computation and side effect associated with the first expression is sequenced before every value computation and side effect associated with the second expression.</p>
</blockquote>
<p>(C++11, [expr.log.and]; emphasis added)</p>
",2
15856367,15856339,3,"<p>Ok, let's make this code a lot easier. I think what you intended to do was something like this:</p>

<pre><code>char selection;
cout &lt;&lt; (as before)
cin &gt;&gt; selection;

selection = tolower(selection);

switch(selection) {
case 'd':
   // stuff for dogs here
   break;
case 'c':
   // stuff for cats
   break;
// etc.
default:
   // error case
}
</code></pre>

<p>Right?</p>
",1
15856378,15856339,2,"<p>I think it's pretty clear that instead of</p>

<pre><code>if (a == d || ...
</code></pre>

<p>you actually want</p>

<pre><code>if (a == 'd' || ...
</code></pre>

<p>i.e. you want to compare the variable <code>a</code> with the character <code>'d'</code>. You've made the same mistake many, many times, so fix them all and see what errors are left.</p>

<p>Also you've wrongly declared <code>a</code> as an <code>int</code> when is should be a <code>char</code>. You got that right for <code>f</code> but not for <code>a</code> for some reason.</p>
",0
15895622,15895455,1,"<ul>
<li><p><code>counts</code> is an array.</p></li>
<li><p><code>s[i]</code> is a character which contains numbers in ASCII. <code>'0'</code>, <code>'1'</code>,
<code>'2'</code>, ...</p></li>
<li><p><code>s[i] - '0'</code> converts them into integer numbers. <code>1</code>, <code>2</code>, <code>3</code>, ...</p></li>
<li><p>Above number indicates the index of n'th item in the array --> <code>X</code></p></li>
<li><p><code>counts[X] ++</code> increments one the X'th item of the array.</p></li>
</ul>
",0
15895492,15895455,5,"<p><code>counts</code> is a ten-element array, which is being used to count how many times each digit appears in <code>s</code>.</p>

<p>Specifically:</p>

<ul>
<li><code>s[i] - '0'</code> turns <code>'0'</code> into <code>0</code>, <code>'1'</code> into <code>1</code> etc.</li>
<li><code>counts[...]++</code> increments the corresponding element of the array.</li>
</ul>
",0
15895494,15895455,1,"<p>The code is counting how many times a digit <code>(1-9)</code> is appearing in string <code>s</code>.</p>

<p>Note. <code>'i' - '0'</code> is the same as <code>i - 0</code> if <code>i</code> is a <code>digit</code>. 
The reason is that characters <code>'0' -'9'</code> have consecutive ASCII values. So the difference in ASCII value between <code>'i'</code> and <code>'0'</code> is <code>i</code>;  </p>

<p>Now let's say </p>

<pre><code>string s = ""1b21cc55"";
</code></pre>

<p>and</p>

<pre><code>int count[10] is all zeros
</code></pre>

<p>in the loop </p>

<p>we check <code>s[i]</code>, </p>

<pre><code>s[0] = 1 ---&gt; isdigit(1) = yes ----&gt; count[1-0] += 1  ---&gt; count[1] is 1;    
s[1] = b ---&gt; isdigit(b) = no ;
s[2] = 2 ---&gt; isdigit(2) = yes ----&gt; count[2-0] += 1; ---&gt; count[2] is 1;        
s[3] = 1 ---&gt; isdigit(1) = yes ----&gt; count[1-0] += 1; ---&gt; count[1] is 2; 
</code></pre>

<p>and so on ...  </p>

<p>At the end <code>count[i]</code> will tell you how many <code>i</code>s are in the string.</p>
",0
15895596,15895455,1,"<p>Hope this helps.</p>

<p>1) Ascii value of '0' is 48</p>

<p>2) Whenever s[i] is a digit (between 0-9 inclusive)</p>

<p>3) s[i] - '0' evaluates to an index (between 0..9 inclusive); </p>

<p>Example: 
Ascii value of '1' is 49
Say s[i] is '1'
then s[i] - '0' is 49-48 = 1</p>

<p>4) counts[s[i]-'0']++  would count the number of times a particular digit has been found in s[i].</p>
",2
15844892,15844788,0,"<p>Typically, when dealing with data bigger than what you can store in one integer unit, the solution is one of two things:</p>

<ol>
<li>Use a character array/string to store the value as ""ASCII"" (in this one bit per char)</li>
<li>Use multiple integers in an array to store the values, using <code>X</code> bits per element. </li>
</ol>

<p>There is nothing particularly different about the conversion, just that once you have done <code>X</code> bits, you shift to the next element. </p>

<p>By the way:</p>

<pre><code>int bin2dec(char *bin)
 {
    int  k, n;
    int len;
    __int64  sum = 0;

    len = strlen(bin);
    for(k = 0; k &lt; len; k++)
    {
            n = (bin[k] - '0'); // char to numeric value
            if ((n &gt; 1) || (n &lt; 0))
            {
                    puts(""\n\n ERROR! BINARY has only 1 and 0!\n"");
                    return (0);
            }
            // sum it up
            sum &lt;&lt;= 1;
            sub += n;
    }
    return(sum);
 }
</code></pre>

<p>is a bit simpler. </p>
",0
15844926,15844788,-1,"<p>manually:</p>

<pre><code>int binaryToDec(char *bin)
 {
    int  k, n;
    int len=strlen(bin);
    int  dec = 0;

    for(k = 0; k &lt; len; k++)
    {
            n = (bin[k] - '0');
            dec &lt;&lt;= 1;
            dec += n;
    }
    return(dec);
 }
</code></pre>

<p>you can also consider a bitset:</p>

<pre><code>std::bitset&lt;64&gt; input(*bin);
std::cout&lt;&lt;input.u_long();
</code></pre>
",0
15845038,15844788,0,"<p>The algorithm is simple: keep dividing by powers of 10 in order to get each 10s place of the value. The trick is being able to store and divide by powers of 10 for numbers bigger than 64 bit. The algorithms for storing big numbers exist and you should find one, though they are not hard to right, they are bigger than is appropriate to type into an answer here at Stackoverflow. </p>

<p>But basically, you create an accumulator bignum, set it to 1 and start multiplying it by 10 until it is bigger in value than your target bignum. Then you divide it by 10 and start the algorithm:</p>

<pre><code>while accum &gt;= 1
divide source/accum place the dividend in your output string. 
substract that number time accum from your source.
divide accum by 10 and loop
</code></pre>

<p>Do you recognize that algorithm? It is probably how you were taught to do long division in grade school. Well, that's how you ""print"" a binary number in decimal.</p>

<p>There are lots of ways to improve the performance of this. (Hint, you don't have to work in base 10. Work in base 10^8 for 32-bit ints or base 10^17 for 64-bit ints.) But first you need a library that will subtract, add, multiple, divide and compare bignums.</p>

<p>Of course a bignum library probably already has a toString function.</p>
",0
15845481,15844788,0,"<p>You can readily store big numbers (in any base) as a <code>std::deque</code> of digits -- using a deque makes it easy to add digits on either end.  You can implement basic arithmetic operations on them, which makes it easy to convert binary to decimal using the standard multiply and add digits algorithm:</p>

<pre><code>std::deque&lt;char&gt; &amp;operator *=(std::deque&lt;char&gt; &amp;a, unsigned b)
{
    unsigned carry = 0;
    for (auto d = a.rbegin(); d != a.rend(); d++) {
        carry += (*d - '0') * b;
        *d = (carry % 10) + '0';
        carry /= 10; }
    while (carry &gt; 0) {
        a.push_front((carry % 10) + '0');
        carry /= 10; }
    return a;
}

std::deque&lt;char&gt; &amp;operator +=(std::deque&lt;char&gt; &amp;a, unsigned b)
{
    for (auto d = a.rbegin(); b &gt; 0 &amp;&amp; d != a.rend(); d++) {
        b += (*d - '0');
        *d = (b % 10) + '0';
        b /= 10; }
    while (b &gt; 0) {
        a.push_front((b % 10) + '0');
        b /= 10; }
    return a;
}

std::string bin2dec(char *bin) {
    std::deque&lt;char&gt; tmp{'0'};
    while (*bin) {
        if (*bin != '0' &amp;&amp; *bin != '1') {
            puts(""\n\n ERROR! BINARY has only 1 and 0!\n"");
            return """"; }
        tmp *= 2;
        if (*bin++ == '1')
            tmp += 1; }
    return std::string(tmp.begin(), tmp.end());
}
</code></pre>
",0
15864370,15864309,1,"<p>In the <code>product</code> function, you don't set <code>temp</code> if <code>p</code> equals <code>0</code>. This leads to <code>temp</code> being uninitialized and contain a seemingly random value when you later calculate <code>result</code>.</p>

<p>If you forgot the braces around the indented code after the <code>else</code>, you instead leave <code>result</code> uninitialized and it will still contain a seemingly random value.</p>

<p>These random values of course includes <code>NaN</code>.</p>
",0
15864383,15864309,0,"<p>From your indentation, I expect you meant to write this:</p>

<pre><code>float product (float p)
{
    float temp;
    float result;
    if (p==0)
        answer = 1;
    else
    {
        temp=200*product(p-1);
        result=temp/(temp+p);
    }
    return result;
}
</code></pre>

<p>Note that I added <code>{</code> and <code>}</code> around the <code>else</code> condition.</p>
",0
15864603,15864309,0,"<ol>
<li><p>add braces around the two statements after else</p>

<p><code>else
{
    temp=200*product(p-1);
    result=temp/(temp+p);
}</code></p></li>
<li><p><code>if(p == 0)
      result = 1</code>
Assigning answer = 1 and then returning result, which is uninitialized in this case will give you NaN value when p = 0. Although p will never be zero in the current situation because the argument <code>c</code> passed to <code>product</code> ranges between 1 and 220.</p></li>
<li><p>remove the declaration of global variable <code>answer</code>. Most likely, you do not need it.</p></li>
</ol>
",0
15869991,15869959,0,"<p>This is a problem:</p>

<pre><code>    while (convfil.good()) {
        getline(convfil,search); //Fetch line from text file
</code></pre>

<p>You test for failure before you do the operation that can fail.  When <code>getline</code> does fail, you're already inside the loop.</p>

<p>As a result, your code tries to process an invalid record at the end.</p>

<p>Instead try</p>

<pre><code>    while (getline(convfil,search)) {   //Fetch line from text file
</code></pre>

<p>or even</p>

<pre><code>    while (getline(convfil,search) &amp;&amp; search.length() &gt; 9) {
</code></pre>

<p>which will also stop without error if there's a blank line at the end of the file.</p>
",2
15870006,15869959,0,"<p>It's possible you are reading a blank line at the end of the file and trying to process it.</p>

<p>Test for an empty string before processing it.</p>
",0
16463643,16463525,12,"<p>I believe this is what you mean.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
int main()
{
   std::cout &lt;&lt; std::setw(5) &lt;&lt; std::setfill('0') &lt;&lt; 3 &lt;&lt; '\n';
   return 0;
}
</code></pre>

<p>Output</p>

<pre><code>00003
</code></pre>

<p>Links
<a href=""http://en.cppreference.com/w/cpp/io/manip/setw"" rel=""nofollow noreferrer""><code>setw</code></a>, <a href=""http://en.cppreference.com/w/cpp/io/manip/setfill"" rel=""nofollow noreferrer""><code>setfill</code></a>.</p>

<p>Edit: Also, see <a href=""http://en.cppreference.com/w/cpp/io/manip/left"" rel=""nofollow noreferrer""><code>std::internal</code></a> <a href=""https://stackoverflow.com/q/17543883/1171191"">at this question</a>.</p>
",0
16463657,16463525,4,"<p>Use</p>

<pre><code>file &lt;&lt; setfill('0') &lt;&lt; setw(5) &lt;&lt; 3;
</code></pre>

<p>to get <code>00003</code> instead of <code>3</code> </p>
",0
16463708,16463525,2,"<p>iomanip is what you need to search for.</p>

<pre><code>#include &lt;iomanip&gt;
</code></pre>

<p>then </p>

<pre><code>file &lt;&lt; someFunction(5) &lt;&lt; hex &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; 3 &lt;&lt; endl;
</code></pre>
",0
16410710,16410682,7,"<pre><code>r = ( ( 4 / 3 ) * PI * Cube(num) ); 
</code></pre>

<p>should be</p>

<pre><code>r = ( ( 4.0f / 3.0f ) * PI * Cube(num) ); 
</code></pre>

<p>Otherwise, integer division will truncate to 1 instead.
Your function calls look OK. You can remove those temporary variables:</p>

<pre><code>float SphereVol(float num)
{
    return (( 4.0f / 3.0f ) * PI * Cube(num));
}  

float Cube(float radius)
{
   return (radius * radius * radius );       
}
</code></pre>
",2
18297440,18297247,2,"<p>I agree with other answers that you probably don't need this but you could do it. See sample code below, just allocate the memory ahead of time and pass it into placement new. You might want to do this if you are using the array new[] form where you might do something like </p>

<p>void *rawMemory = operator new[](25*sizeof(std::stack));</p>

<p>if you had an array of stacks that you had a factory method that managed the resources or something. Either way it depends on your application and use cases. Below shows a simple example</p>

<pre><code>  #include &lt;iostream&gt;
#include &lt;stack&gt;

int main ( int argc, char *argv[])
{
  void *rawMemory = operator new(sizeof(std::stack&lt;unsigned int&gt;));
  std::stack&lt;unsigned int&gt; *s = new (rawMemory) std::stack&lt;unsigned int&gt;;

  s-&gt;push(10);

  std::cout &lt;&lt; s-&gt;top() &lt;&lt; std::endl;

  return 0;
}
</code></pre>

<p>Second example using the array version, which seems more useful where you may be managing 25 different stacks and handing them to clients. Also, answering your comment. See that the container is defined in the stack definition this time, in this case I am using a vector for the container. Stack is a container but it has an underlying container that defaults to deque </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;

int main ( int argc, char *argv[])
{
  typedef std::stack&lt;unsigned int,std::vector&lt;unsigned int&gt; &gt; StackType;

  void *rawMemory = operator new[](25*sizeof(StackType));

  StackType *stacks = static_cast&lt;StackType*&gt; (rawMemory);

  // allocate
  for ( unsigned int i = 0; i &lt; 25; ++i )
  {
    new (stacks+i) StackType;
  }

  stacks[1].push(10);
  std::cout &lt;&lt; stacks[1].top() &lt;&lt; std::endl;

  // don't forget to delete or smart resize
  for ( int i = 24; i &gt;= 0; --i )
  {
    StackType x;
    std::swap ( x, stacks[i] );
  }

  return 0;
}
</code></pre>
",2
18297487,18297247,1,"<p>You can define a macro like this:</p>

<pre><code>#define STACK_NEW(T) new (alloca(sizeof(T))) T
</code></pre>

<p>that uses <em>placement new</em> and <code>alloca()</code> to allocate a block on the stack and construct an object of type <code>T</code> on top of it. You can also define an array version:</p>

<pre><code>#define STACK_NEW_ARRAY(T, n) new (alloca(n * sizeof(T))) T
</code></pre>

<p>You'd use this macro in the following ways:</p>

<pre><code>int * p = STACK_NEW(int);
MyObj * q = STACK_NEW(MyObj) (my, constructor, parameters);
int * r = STACK_NEW_ARRAY(int, 42);
</code></pre>

<p>You'll have destruct these objects manually: </p>

<pre><code>q-&gt;~MyObj();
</code></pre>

<p>Deleting them will have undefined behavior.</p>

<p><em><strong>WARNING</em></strong>: This whole facility is very unsafe. I'd strongly recommend against having such systematically dangerous tools in your codebase. As far as I can see, there is no safe way to use it and it <em>will</em> cause you pain!</p>
",0
16381401,16381387,3,"<p>You should only need to test up to <code>775,147</code> (the square root) to find all the factors. If you have a factor <code>a</code>, you can get its counterpart <code>b</code> by dividing your original number by <code>a</code>.</p>

<p>If you show us your code, we may be able to suggest other optimizations.</p>
",5
16388087,16387993,9,"<pre><code>00 00 00 00
ff ff ff 00
</code></pre>

<p>These bytes are the color palette. Since your bits per pixel are set to 1, there can be only two colors in the palette. The first color is black (<code>00 00 00 00</code>) and the second is white (<code>ff ff ff 00</code>). The last byte of each color is just filler and is always set to <code>00</code>.</p>

<pre><code>c0 00 00 00
00 00 00 00
</code></pre>

<p>This is the actual pixel data. Each row of pixels must be padded to the nearest 4 bytes that can contain the data. So here, the first row is the bottom row of pixels and the second row is the top row of pixels (since BMP pixel order is bottom-up). Since we are using 1 bit per pixel, we should look at it at the byte level. Specifically, the first row of pixels is given by:</p>

<pre><code>1100 0000  0000 0000  0000 0000  0000 0000
</code></pre>

<p>Since we only have two pixels in each row of pixels and only 1 bit per pixel, only the first two bits matter. In this case, <code>11</code> specifies that the first two pixels are the second color in the palette (<code>1</code>). Now for the second row, we have:</p>

<pre><code>0000 0000  0000 0000  0000 0000  0000 0000
</code></pre>

<p>and again we only need look at the first two pixels, <code>00</code>. This means the next pixels are the first color in the palette (<code>0</code>).</p>
",5
16388215,16387993,3,"<p><code>c0 00 00 00</code></p>

<p>The last 3 Bytes of this block are for padding</p>

<blockquote>
  <p>Padding bytes (not necessarily 0) must be appended to the end of the rows in order to bring up the length of the rows to a multiple of four bytes. When the pixel array is loaded into memory, each row must begin at a memory address that is a multiple of 4.</p>
</blockquote>
",1
16403760,16403392,0,"<p>If you store data as pointers only (using BST logic) and then want to search, you can not. Pointer holds no additional information about content of object. Two objects can be the same, but their pointers are different.
You will have to change BST inserting mechanic. Best way would be to comute some kind of hash from your object. But for that case, BST is not really a good structure.. HashMaps are imho way better.</p>
",1
16466302,16466259,3,"<p><code>Undefined reference to</code> means that you're trying to refer to something that cannot be linked.  Are you linking your two cpp files together?</p>
",2
16397091,16394959,0,"<p>I recommend you never use</p>

<p><code>if ( is_active == false )</code></p>

<p>Instead you could use:</p>

<p><code>if ( false == is_active )</code> or <code>if ( !is_active )</code></p>

<p>but not for efficiency reason.</p>

<p>A common mistake for beginners is write <code>==</code> as <code>=</code>. (Sometimes I also have such typo too). In the former case, this mistake results in a legal assignment. In the latter, the compiler will complain about the mistake, because you can never assign anything to <code>false</code></p>

<p>Hope this also helps :)</p>
",0
16394987,16394959,8,"<p>When compiled, they'll produce the same machine code. It's just a matter of syntax.</p>

<p>From the standard (5.3.1):</p>

<blockquote>
  <p>The operand of the logical negation operator ! is implicitly converted
  to bool (clause 4); its value is true if the converted operand is
  false and false otherwise. The type of the result is bool.</p>
</blockquote>
",4
16394995,16394959,0,"<p>When your compiler does not optimize it to be exaclty the same you have a really dumb compiler.</p>

<p>But if one of them is faster, then <code>if(!is_active)</code>, because it only needs one ASM <code>INV</code> command instead of <code>LOAD</code> and <code>CMP</code>.</p>
",0
16395006,16394959,0,"<p>There is no easier way, than try for yourself :) Write simple program tha uses both and measure time. I think, that It can be compiler and optimalization specific . </p>

<p>However... trying to optimize this piece of code is useless... you are focusing on wrong optimalization :)</p>
",0
16395023,16394959,0,"<p>Unoptimized, the first is a negation followed by a comparison to zero; the second is a comparison followed by a comparison to zero.</p>

<p>Optimized they are almost certainly the same.</p>
",0
16395029,16394959,0,"<p>The answer to this question is highly dependent on the compiler's ability to understand code - compilation templates.
Basically, you are asking the same binary question - is the variable is_active equal 0; yet you are asking it in two different manners:</p>

<ol>
<li>is it equal the fixed value of 0</li>
<li>is it anything other than 0</li>
</ol>

<p>A smart compiler (and a supporting Assembly ISA) will not perform the logical not and then compare to 0, rather it will compare to the value not equaling 0 in the first place.</p>

<p>To make a long story short, assuming your compiler is even semi-intelligent and the ISA supports comparing to a value not being 0; it should be the exact same</p>
",0
16395032,16394959,4,"<p>Both are equivalent. You can test this yourself by using the <code>-S</code> option, which produces assembler output into <code>file.s</code>. With gcc on amd64 you get for example </p>

<p>file.cpp:</p>

<pre><code>void f()
{
    bool is_active = false;
    if(!is_active) { dosomething(); }

    if(is_active == false) { dosomething(); }
}
</code></pre>

<p>file.s:</p>

<pre><code>...
    movzbl  -1(%rbp), %eax
    xorl    $1, %eax
    testb   %al, %al
    je  .L3
    call    _Z11dosomethingv
.L3:
    movzbl  -1(%rbp), %eax
    xorl    $1, %eax
    testb   %al, %al
    je  .L2
    call    _Z11dosomethingv
.L2:
...
</code></pre>

<p>You can easily see that the code is the same for both instances.</p>

<p><strong>Update</strong> to Charles Bailey's comment including compiler optimization <code>-O2</code> </p>

<p>file.cpp:</p>

<pre><code>extern bool is_active;

void f()
{
    if(!is_active) { dosomething(); }
}

void g()
{
    if(is_active == false) { dosomething(); }
}
</code></pre>

<p>file.s:</p>

<pre><code>    cmpb    $0, is_active(%rip)
    je    .L4
    rep
    ret
    .p2align 4,,10
    .p2align 3
.L4:
    jmp    _Z11dosomethingv
...
    cmpb    $0, is_active(%rip)
    je    .L7
    rep
    ret
    .p2align 4,,10
    .p2align 3
.L7:
    jmp    _Z11dosomethingv
</code></pre>

<p>The produced assembler code is different this time, but as expected it's same for both <code>if</code> statements.</p>
",5
16395063,16394959,-1,"<p>It's a bad practice to write like this:</p>

<p><code>if(is_active == false)</code></p>

<p>Don't do this.</p>

<p>And about speed of <strong>such</strong> operation... We're in 2013. ;-)</p>
",0
16405422,16404190,0,"<p>The problem with initial BST and Linked List implementations is that they either force you to use a specific data type or inherit from that data type (such as yours).  If I want a BST for fruit, I can't use your tree, because your tree is dedicated to cars.  </p>

<p>I suggest an abstract node class and deriving your data classes from the node class:</p>

<pre><code>struct Node
{
    boost::shared_ptr&lt;Node&gt;  left;
    boost::shared_ptr&lt;Node&gt;  right;

    // Interface functions for descendants
    virtual bool  is_less_than(boost::shared_ptr&lt;Node&gt; other_node) const = 0;
    virtual bool  is_equal_to(boost::shared_ptr&lt;Node&gt; other_node) const = 0;
};
</code></pre>

<p>I still believe the best design is to use a template:</p>

<pre><code>template &lt;class User_Data_Type&gt;
class Node
{
  public:
    boost::shared_ptr&lt;Node&gt;  left;
    boost::shared_ptr&lt;Node&gt;  right;
    User_Data_Type           m_data;
};
</code></pre>
",1
16952674,16950445,0,"<p>In the case of windows, it is</p>

<pre><code>POINT      pt;
COLORREF   cr;
HDC        hdcScreen;

hdcScreen = CreateDC(TEXT(""DISPLAY""), NULL, NULL, NULL);
cr = GetPixel(hdcScreen, pt.x, pt.y);
DeleteDC(hdcScreen);
</code></pre>
",6
17399214,17396746,1,"<p>I'm not going to write code for this, as I'm sure this is some form of homework (or you are being paid to do this, or something else like that, meaning it's your task to solve the actual problem). </p>

<p>C (and thus C++) has a set of functions in <a href=""http://www.cplusplus.com/reference/ctime/"" rel=""nofollow""><code>&lt;ctime&gt;</code></a>, which allow you to work with time. </p>

<p>Given these, one can take an arbitrary date, make the a <code>time_t</code> using <code>mktime</code>, and subtract one from the other with <code>difftime</code>, giving you a ""number of seconds between two <code>time_t</code> values. If you convert a <code>time_t</code> back to struct <code>tm</code>, it will have a ""weekday"" entry, so you can tell that, for example, 1-July-2013 is a Monday. </p>

<p>Given all this, it should be quite possible to calculate the absolute number of days between two dates, and if you know what day you start on, find out how many Saturdays and Sundays there are in the period. </p>
",0
17400694,17396746,1,"<p>Sorry it isn't commented and I'm also not a professional programmer but here you go:
It compiles and when I run it and type in 1/1/2013/3 and 12/31/2013/3 I get 261 work days for the year. Which if you multiply 365*(5/7) you get 260.7 so it seems to work. When I do 1/1/2013/3 and  12/31/2015/5 I get 783. I also programmed leap year into it all in less than 90 lines.  Also my naming conventions might not be so consistent.  Also I know it's probably bad style to use nested if statements but whatever this was just a quick and dirty thing.</p>

<p>Edit: I decided to make this more ellaborate to practice my own c++ skills, I've provided more functionality to it.</p>

<pre><code>#include &lt;iostream&gt;  
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;
using namespace std;
class date{
public:
unsigned days_per_month[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
unsigned month;
unsigned day;
int year;
unsigned week_day;
constexpr static int week_day_callibrator[4] = {1,1,2013,3};
unsigned get_days(){return days_per_month[(month - 1)];};
unsigned get_days(unsigned n){return days_per_month[(n - 1)];};
void leap_year(){
bool temp = false;
if(year%4 == 0)
temp = true;
if(year%100 == 0)
temp = false;
if(year%400 == 0)
temp = true;
if(temp == true)
days_per_month[1] = 29;
else days_per_month[1] = 28;
};
void truncate()
{
if(month &gt; 12)
month = 12;
if(month &lt; 1)
month = 1;
if(day &gt; get_days())
day = get_days();
if(day &lt; 1)
day = 1;
}
date(unsigned m, unsigned d, int y, unsigned wd) : month(m), day(d), year(y), week_day(wd) {leap_year();truncate();}
date(unsigned m, unsigned d, int y) : month(m), day(d), year(y)
{
leap_year();
truncate();
int wdc[4] = {week_day_callibrator[0], week_day_callibrator[1], week_day_callibrator[2], week_day_callibrator[3]};
while(wdc[0] &lt; month || wdc[1] &lt; day || wdc[2] &lt; year)
{ 
wdc[3] == 7? wdc[3] = 1: ++wdc[3];
if(wdc[1] == get_days(wdc[0]))
{
wdc[1] = 1;
if(wdc[0] == 12)
{
wdc[0] = 1;
++wdc[2];
leap_year();
}
else{++wdc[0];}
}
else{++wdc[1];}
}
while(wdc[0] &gt; month || wdc[1] &gt; day || wdc[2] &gt; year)
{
wdc[3] == 1? wdc[3] = 7: --wdc[3];
if(wdc[1] == 1)
{
if(wdc[0] == 1)
{
wdc[0] = 12;
--wdc[2];
leap_year();
}
else{--wdc[0];}
wdc[1] = get_days(wdc[0] - 1);
}
else{--wdc[1];}
}
week_day = wdc[3];
}

date&amp; operator++(){
week_day == 7? week_day = 1: ++week_day;
if(day == get_days())
{
day = 1;
if(month == 12)
{
month = 1;
++year;
leap_year();
}
else{++month;}
}
else{++day;}
}

date&amp; operator--()
{
week_day == 1? week_day = 7: --week_day;
if(day == 1)
{
if(month == 1)
{
month = 12;
--year;
leap_year();
}
else{--month;}
day = get_days(month - 1);
}
else{--day;}
}
inline bool operator==(const date&amp; rhs)
{
if(year == rhs.year &amp;&amp; month == rhs.month &amp;&amp; day == rhs.day)
return true;
else 
return false;
}
inline bool operator!=(const date&amp; rhs){return !operator==(rhs);}
inline bool operator&lt; (const date&amp; rhs)
{
if(year &lt; rhs.year)
return true;
else if(month &lt; rhs.month)
return true;
else if(day &lt; rhs.day)
return true;
else
return false;
}
inline bool operator&gt; (const date&amp; rhs){return operator&lt; (rhs);}
inline bool operator&lt;=(const date&amp; rhs){return !operator&gt; (rhs);}
inline bool operator&gt;=(const date&amp; rhs){return !operator&lt; (rhs);}
};

unsigned count_work_days(date &amp; a, date &amp; b)
{
unsigned counter = 0;
while(a &lt; b)
{
if(a.week_day != 1 &amp;&amp; a.week_day != 7)
{
++counter;
} 
++a;
}
// makes it inclusive
if(b.week_day != 1 &amp;&amp; b.week_day != 7)
++counter;
return counter;
}

int main() {
// initializes variables, calls cin to ask the user to input them, varifies the validity of the values and calls the compare function
string temp;
char temp2;
unsigned beginmonth, begindayofmonth, beginyear;
unsigned endmonth, enddayofmonth, endyear;
cout &lt;&lt; ""enter start date: mm/dd/yyyy"" &lt;&lt; endl;
cin &gt;&gt; temp;
stringstream stemp(temp);
stemp &gt;&gt; beginmonth &gt;&gt; temp2 &gt;&gt; begindayofmonth &gt;&gt; temp2 &gt;&gt; beginyear;
cout &lt;&lt; ""enter end date: mm/dd/yyyy"" &lt;&lt; endl;
cin &gt;&gt; temp;
stemp.clear();
stemp.str(temp);
stemp &gt;&gt; endmonth &gt;&gt; temp2 &gt;&gt; enddayofmonth &gt;&gt; temp2 &gt;&gt; endyear;
date b(beginmonth,begindayofmonth,beginyear);
date e(endmonth,enddayofmonth,endyear);
cout &lt;&lt; count_work_days(b,e) &lt;&lt; endl;
return 0;}
</code></pre>
",1
17098486,17097957,0,"<p>C++ prior to  C++11 does not offer any (simple) solution for that problem. In C++11, you may declare the enum scoped, using the following syntax:</p>

<pre><code>enum struct a { /* .... */ };  // the class keyword may also be used
</code></pre>

<p>The effect is to make  <em>enumerators</em> (the constants) scoped within the enum type itself, ie. the notation to access the constants of <code>a</code> becomes <code>a::One</code> for instance. Because these now belong to the enum type, and not the namespace, you may easily import them along with the enum into another namespace with a typedef. Note however that scoped enum values may not be promoted to <code>int</code> as easily as with regular enums.</p>

<pre><code>namespace A {
    enum class a { One = 1, Two = 2 };
}

namespace B {
    typedef  A::a b;
}

A::a a_value = A::One;
B::b b_value = B::One;  // Now this works
B::b c_value = A::One;   // Clearly B is still a typedef for A

int main (int argc, const char *argv[]) {
   return 0;
}
</code></pre>
",0
17098038,17097957,7,"<p>While the enum type is accessible in <code>B</code> through <code>b</code>, the values are not and must be brought in explicitly:</p>

<pre><code>namespace B {
    typedef A::a b;
    using A::One;
}
</code></pre>

<p>I don't think there's a way to bring them all in without separate <code>using</code> statements for each unless you do <code>using namespace A;</code> or put the enum in an inline namespace and have a using statement for that. The latter might be preferable if you're worried about bringing in all of <code>A</code> and would still like to use the enum values with just <code>A::value</code>. Here's an example:</p>

<pre><code>namespace A
{
    inline namespace en {
        enum a { One = 1, Two = 2 };
    }

    enum c {Three};
}

namespace B
{
    using namespace A::en;
    typedef A::a b;
}

A::a a_value = A::One; // works; things in en are still visible in A
B::b b_value = B::One; // works; en was brought into B
B::b c_value = A::One; // works
A::c meh = B::Three; //fails; only en was brought into B
</code></pre>

<p>Be aware that inline namespaces were introduced in C++11, which GCC 4.1.2 has no support for. If you can, I would strongly recommend upgrading. The latest stable release is 4.8.1.</p>
",0
17868034,17868004,2,"<p><code>Swap</code> is used to check if algorithm is still sorting or not. If <code>swap</code> is false, it means that array is already sorted and algorithm can be finished.</p>

<p>By default (in the beginning of each iteration of <code>do-while</code> loop) <code>swap</code> is set to false and it's change to <code>true</code> only if swap was made (it means that array elements weren't in correct order).</p>
",0
17868056,17868004,1,"<p><code>Swap</code> variable is used to determine end of algorithm.If array is sorted, no swap occurs and <code>swap</code> variable will be false, hence end of sorting.</p>

<p>Default value of <code>swap</code> variable is undefined, but it doesnt matter, since you assign it as false in each iteration before processing array from beggining</p>
",0
17868064,17868004,0,"<p>while-do is used to execute for loop until no elements in the array should be swapped. If no swaps occurred during the for loop, than all elements are sorted. But, if during the execution of the inner loop two elements were swapped, the array is scanned again to check if the result array is sorted.</p>
",0
18286955,18286935,0,"<p>According to C++ standard:</p>

<blockquote>
  <p>A similar member function, vector::at, has the same behavior as this operator [] function, except that vector::at is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
</blockquote>
",1
18286956,18286935,5,"<p>.at(...) is doing bound checking, meanwhile the [] operator does not, i.e. for out of range.</p>

<p>See the documentation from here:</p>

<p><a href=""http://www.cplusplus.com/reference/vector/vector/at/"" rel=""nofollow"">http://www.cplusplus.com/reference/vector/vector/at/</a></p>

<p>""The function automatically checks whether n is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not check against bounds.""</p>

<p>or:</p>

<p><a href=""http://www.cplusplus.com/reference/vector/vector/operator%5B%5D/"" rel=""nofollow"">http://www.cplusplus.com/reference/vector/vector/operator[]/</a></p>

<p>""A similar member function, vector::at, has the same behavior as this operator function, except that vector::at is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.""</p>

<p>Slightly off-topic, but you should not use ""vectorlist"" term for a vector. At first, I thought you would be having a list data for some reason.</p>

<p>So, to give you a real world example: you could use the non-bound-checking variant when you are sure the index inside the range because that will result a slightly faster code.</p>
",4
16411212,16410874,3,"<p>The definition of entropy is:</p>

<p><img src=""https://i.stack.imgur.com/IMr6Q.gif"" alt=""Entropy""></p>

<p>Where:</p>

<ul>
<li><code>a</code> denotes every possible character in a file and</li>
<li><code>P(A)</code> - probability of this char (equal to count of its occurrences divided by file size)</li>
</ul>

<p>The base of logarithm defines unit of entropy. If it is equal to 2, entropy is measured in bits.</p>

<p>Entropy is a measure of uncertainty. Imagine a file consisting of the same letters. Then P(a) = 1 (as there is only one character) and entropy equals to:</p>

<p><img src=""https://i.stack.imgur.com/v1hkJ.gif"" alt=""Entropy equal to 0""></p>

<p>Entropy of 0 bits means: no uncertainty, full predictability. On the other hand, imagine a file with each character different. There are 256 values of P, each equal to 1/256. Entropy then equals to:</p>

<p><img src=""https://i.stack.imgur.com/OGubo.gif"" alt=""Entropy equal to 8""></p>

<p>Entropy of 8 bits means: full uncertainty, no predictability.</p>

<p>Entropy is correlated to compression ratio of entropy-based algorithms. As duskwuff said, entropy of 6.46 bits means, that the file may be compressed by entropy-based algorithms roughly to 4/5 of its original size.</p>
",0
16410889,16410874,3,"<p>In this context, entropy is probably being measured in bits of entropy per byte of data. 8 is completely random, 0 is completely predictable.</p>

<p>In practical terms, this means that your DLL file can probably be compressed to about 80% (6.46 / 8) of its initial size.</p>
",0
18314983,18314939,11,"<p>I use a shorter form:</p>

<pre><code>if (lpClassName == NULL || lpClassName[0] == 0)
</code></pre>

<p>There's no need to get the whole length of the string if all you need is to test for empty. The short circuit rules will prevent the second half of the statement from causing an error if the pointer is null.</p>

<p>Beyond that I expect the code in your question would work as well.</p>

<p><strong>Edit:</strong> In this case the pointer appears to be coming from CreateWindowEx, which means it might not be an actual string pointer but an ATOM value instead. The way to tell the difference is to check that the upper bits are all zero. Microsoft uses the same convention for resource IDs and provides the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms648028%28v=vs.85%29.aspx"" rel=""noreferrer""><code>IS_INTRESOURCE</code> macro</a> to test for this condition.</p>
",16
17076311,17076198,2,"<p>Because of the <code>return</code> statements, the first <code>for</code> loop will print at most 1 element, that is, if the head element has the isVip flag set, it will print it. Then, it will return.</p>
",3
18314969,18314911,3,"<p>It can choose whichever, or neither, depending on how smart it is and how well it can detect. The rule is <strong>polymorphism must work</strong>. How this is achieved is an implementation detail.</p>

<p>If the same end-result can be achieved with both dynamic or static binding, as is the case here, both are valid options for the compiler.</p>

<p>In your case, the function doesn't have to be called at all - the generated code could be just as well identical to code generated by</p>

<pre><code>int main()
{
    cout &lt;&lt; ""base class"";
}
</code></pre>
",7
18314982,18314911,2,"<p>I guess it depends on compiler optimization. Compiler might be clever enough to figure out that <code>Base::show</code> is always the one called or it might not. You can look at the disassembly to find out. You can force static-binding with <code>b-&gt;Base::show()</code></p>
",0
18315077,18314911,2,"<p>Short answer: No. At least in theory not. Because in theory, the compiler does not know wether the pointer points to a <code>Base</code>, a <code>Derived</code> or to <code>YetAnotherDerived</code> object. Therefore it has to apply the same mechanism regardless of the dynamic type of the object.</p>

<p><strong>But:</strong> In practise, compilers have optimizers, capable of identifying some use cases where the dynamic type is known. I your case it can detect the aliasing, meaning it knows that <code>pb</code> points to <code>b</code> and that it is a local variable and cannot be changed concurrently, so it knows that in fact you are calling <code>b.show()</code> and will abbreviate the output to reflect that fact and get rid of the virtual dispatch. Similar optimizations are possible e.g. in this code:</p>

<pre><code>auto pb = make_unique&lt;Base&gt;();
pb-&gt;show();
</code></pre>

<p>But as any optimization it is up to the compiler if it applies them - the standard says virtual dispatch happens even if the pointer points to a Base object, and that's it.</p>
",1
16425195,16343264,0,"<pre><code>#include&lt;iostream&gt;
#include&lt;conio.h&gt;
#include&lt;string&gt;


using namespace std;

int stringlength (char* numptr);

int main()
{
    char *mystring;


    cout&lt;&lt;""enter the string \n"";
    cin&gt;&gt;mystring;

    cout&lt;&lt;""length is ""&lt;&lt;stringlength(mystring);

    getch();
}

int stringlength (char* numptr)
{

    int count=0;

    for(;*numptr&lt;0;*numptr++)
    {
               count++;
    }
    return(count);
 }
</code></pre>
",0
14172360,14172280,1,"<p>No, it isn't, which is rather fortunate because the behaviour of C arrays is abominable. If you find yourself looking for it, I would suggest instead looking for some new learning material w.r.t. C++.</p>
",4
14172420,14172280,1,"<p>The other answers are correct, but I'd like to add that it works the other way around:</p>

<pre><code>void RenderingEngine::Render(Visual *visuals, size_t n_visuals);
</code></pre>

<p>Can be called like this:</p>

<pre><code>vector&lt;Visual&gt; visuals;
m_renderingEngine-&gt;Render(&amp;visuals[0], visuals.size());
</code></pre>

<p>You just take the address of the first element and pass it as if it was an array. This works because the elements of a vector are laid out sequentially in memory. (As pointed out in the comments, shouldn't use this in new code, of course. It's safer and easier to define you method to take a vector. However, if you already have a legacy function that takes a pointer, this allows you to use vectors in your own code.)</p>

<hr>

<p>The reason it works this way around, but not the way in your question (pass a pointer, to a function that takes a vector), is that in your case it can't determine the size of the array at runtime. But it has to know the size to construct the vector:</p>

<pre><code>// (wrong code)
// Passing one element:
Visual visual;
m_renderingEngine-&gt;Render(&amp;visual);

// Passing two elements, how does Render know that
// there are two elements at that address?
Visual[2] visuals;
m_renderingEngine-&gt;Render(&amp;visuals[0]); 
</code></pre>

<p>As Nawaz pointed out, you can do something similar in C++11:</p>

<pre><code>Visual visual;
m_renderingEngine-&gt;Render( {visual} ); // C++11
</code></pre>

<p>You can also put more elements in the <code>{}</code>. This only works because the compiler can tell at compile-time how many elements there will be. It's just syntactic sugar for:</p>

<pre><code>vector&lt;Visual&gt; myVec = {visual};  // C++11
m_renderingEngine-&gt;Render(myVec);
</code></pre>

<p>which in turn works like the classic:</p>

<pre><code>vector&lt;Visual&gt; myVec;
myVec.push_back(visual);
m_renderingEngine-&gt;Render(myVec);
</code></pre>

<p>(although the C++11 version might be slightly optimized, I don't know for sure).</p>
",4
14172298,14172280,2,"<blockquote>
  <p>Is the name of a vector simply a pointer, just like a vanilla C array?</p>
</blockquote>

<p>No.  It's a fully-formed class.<sup>*</sup></p>

<p><hr>
<sub>* What's more, a vanilla C array is not a pointer either (it just get turns into one in most situations).</sub></p>
",2
14172310,14172280,1,"<p>No. That doesn't make sense. There is no implicit conversion from <code>T*</code> to <code>std::vector&lt;T&gt;</code>.</p>

<p>But in C++11, you can do something which is very close<sup>1</sup> to what you're doing. You could create the vector on the fly while passing the argument as:</p>

<pre><code>m_renderingEngine-&gt;Render( {visual} );  //note the curly braces!
</code></pre>

<p>With that you create a vector object out of the expression <code>{visual}</code> which then gets passed to the function.</p>

<hr>

<p><sup>1. <em>very close</em> in the sense that you just have to type <em>one more</em> character to make your code work. Instead of typying <code>&amp;</code>, just type <code>{</code>, and one more <code>}</code> at the end. That is it. Life is so easy with C++11. </sup></p>
",1
15824079,15824047,0,"<p>Yes, as far as the vector is concerned, the <code>generate()</code> function is pointless; the changes to <code>v</code> won't be visible to the caller.</p>

<p>I have a feeling that the author of <code>generate()</code> missed to pass by reference as a overlook, not as a plan :-)</p>
",0
15824198,15824047,0,"<p>Well, considering std containers do not do implicit data sharing, that means you will pass a new deep copy into the function, push_back the float into that new copy that will then be discarded after the function is over. So, to me it would appear you are correct.</p>
",0
15826517,15824047,0,"<p>In this function std::vector v will not change because you did not give the vector as a reference. It is just copied within the function and copy is changed but not the original one. You can use:</p>

<pre><code>void generate(std::vector&lt;float&gt; &amp;v) //input given as reference
{
  float f = generate_next_float();
  v.push_back(f);
}
</code></pre>
",0
16444310,16444108,2,"<p>Use <a href=""http://www.doxygen.nl/"" rel=""nofollow noreferrer"">doxygen</a> with <a href=""http://www.graphviz.org/"" rel=""nofollow noreferrer"">graphviz</a> support to generate a hierachy graph diagram for you. </p>

<p>The procedure is simple: </p>

<ol>
<li>Install graphviz.</li>
<li>Install doxygen.</li>
<li>Use the Doxywizard to configure the desired outputs to you.</li>
</ol>

<p>Here is a screenshot of the doxygen diagrams tab so you have a clue on how's the interface.</p>

<p><img src=""https://i.stack.imgur.com/TNaJx.jpg"" alt=""Doxygen diagrams tab""></p>

<p>And finally, here is a <a href=""http://www.dumux.org/doxygen-stable/html-2.2/a00040.php"" rel=""nofollow noreferrer"">link</a> with an output example to you.</p>
",0
18122188,18122061,1,"<p>What you are doing is not at all what you are wanting to do. </p>

<p><code>isdigit</code> returns true if the value passed in is digit. That is true if the input, interpreted as a character is a digit. This is UNLIKELY what you want, because if we assume traditional European language and ASCII character encoding, the <code>isdigit</code> will be true if the value in <code>a</code> or <code>b</code> is in the range 48..57.</p>

<p>What you, I presume, want to do is check if <code>a</code> and <code>b</code> are valid integer values. In which case:</p>

<pre><code> if (cin &gt;&gt; a &gt;&gt; b)
 {
    cout &lt;&lt; a + b &lt;&lt; endl;
 }
 else
 {
    cout &lt;&lt; ""Invalid digit"" &lt;&lt; endl; 
 }
</code></pre>

<p>would be the right thing to do. </p>
",13
18122120,18122061,3,"<p>Since you're reading into <code>int</code> variables, anything you enter has to be integers or the input operator will fail. If you want to read <em>characters</em> and check if they are digits, you should read into <code>char</code> variables, and then you need to convert them to the proper integer values before operating on them.</p>

<p>Try something like:</p>

<pre><code>inline int to_int(const char ch)
{
    return ch - '0';
}

// ...

char a, b;
if (std::cin &gt;&gt; a &gt;&gt; b)
{
    if (std::isdigit(a) &amp;&amp; std::isdigit(b))
        std::cout &lt;&lt; to_int(a) + to_int(b) &lt;&lt; '\n';
    else
        std::cout &lt;&lt; ""One is not a digit\n"";
}
else
    std::cout &lt;&lt; ""Error in input\n"";
</code></pre>

<hr>

<p>If you just want to input two generic <em>integer</em> values, then you're already on the right track, you just need to make sure the input is okay:</p>

<pre><code>int a, b;
if (std::cin &gt;&gt; a &gt;&gt; b)
    std::cout &lt;&lt; a + b &lt;&lt; '\n';
else
    std::cout &lt;&lt; ""Error in input (most likely not integers in input)\n"";
</code></pre>
",2
18315610,18315427,0,"<p>C++ supports partial specialization. The simplest way to solve your problem (I think this is your problem) is to partially specialize struct test for int or char, ala:</p>

<pre><code>template &lt;typename T&gt; struct test
{
    // For arbitrary type T...
};

template &lt;&gt;
struct test&lt;int&gt;
{
    // definition for when T = int
};

template &lt;&gt;
struct test&lt;char&gt;
{
    // definition for when T = char
};
</code></pre>
",1
18315621,18315427,2,"<p>You can use C++11 type traits for this (or, if you don't have C++11 yet, use type traits from Boost):</p>

<pre><code>#include &lt;type_traits&gt;

template &lt;typename K, bool special = std::is_same&lt;K, char&gt;::value || std::is_same&lt;K, int&gt;::value&gt;
struct A
{
  // general case
};

template &lt;typename K&gt;
srtuct A&lt;K, true&gt;
{
  //int-or-char case
};
</code></pre>
",5
18315527,18315427,0,"<p>your question is too vague, but i think you talk about smth like this?</p>

<pre><code>template &lt;typename T&gt;
struct A
{
    //...
}

template&lt;B&gt;
struct A
{
    //...
}
</code></pre>

<p>in this case you specify how should template struct behave its of templated of some specific type</p>
",0
17823932,17823860,5,"<p>Simple example of <code>std::vector</code>:</p>

<pre><code>class MyClass
{
public:
    int A;
    int B;

    MyClass(int a, int b) : A(a), B(b) { }
};

std::vector&lt;MyClass&gt; temp;
temp.push_back(MyClass(1, 2));
temp.push_back(MyClass(3, 4));
// temp vector now contains two items
</code></pre>
",0
17858126,17858033,-1,"<p><a href=""http://www.boost.org/doc/libs/1_39_0/doc/html/thread/synchronization.html#thread.synchronization.mutex_types.shared_mutex"" rel=""nofollow"">shared_mutex</a> from Boost implements read/write locking.</p>
",1
17858291,17858033,3,"<p>Many programs simply use a <em>lock file</em> to signify that a certain file is currently in use for writing.</p>

<p>The lock file is later removed when done writing.</p>

<p>For example, when process #1 is about to start writing to file <code>example</code>, it creates file <code>example.lock</code>. Later when done writing, it simply removes <code>example.lock</code>.</p>

<p>When process #2 want to read from file <code>example</code> it first checks if file <code>example.lock</code> exists. If it does then the file is locked for write operations and process #2 will have to wait.</p>
",0
17784263,17784231,0,"<p>It is a C++11 range-based <code>for</code> loop syntax described here: <a href=""http://www.cprogramming.com/c++11/c++11-ranged-for-loop.html"" rel=""nofollow"">http://www.cprogramming.com/c++11/c++11-ranged-for-loop.html</a></p>

<p>Here <code>m</code> should be a container, like std::vector. The code will iterate the container and put every element (accessed as <code>x</code> inside the loop) into the <code>std::cout</code> stream. Elements will be separated by space.</p>
",2
17784279,17784231,0,"<p><code>m</code> is any type that follows the ranged concept (i.e. <a href=""http://en.cppreference.com/w/cpp/concept/Container"" rel=""nofollow"">Container concept</a>). </p>

<p>The loop iterates over all elements of <code>m</code> where <code>x</code> represents the currently iterated value.</p>
",2
16373568,16343807,0,"<p>It seems the problem was indeed in the vec file.</p>

<p>Can't find a reasoning about the fix, but changing the Vec struct to a class fixed all the problems.</p>

<p>Thanks for the help.</p>
",0
17790957,17790927,1,"<p>Same as </p>

<pre><code>x = x | y;
</code></pre>

<p>bitwise or operand.</p>
",0
17790963,17790927,5,"<p><code>x |= y</code> is equivalent to <code>x = x|y</code> if they're not overloaded to do something different.</p>

<p>This is called <em>compound assignment</em>: <code>e1 op= e2</code> form behaves as <code>e1 = e1 op e2</code> by default. (<a href=""http://msdn.microsoft.com/en-us/library/aa245297(v=vs.60).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/aa245297(v=vs.60).aspx</a>)</p>
",3
17790968,17790927,3,"<p><code>foo |= bar;</code> is logically equivalent to <code>foo = foo | bar;</code> where <code>|</code> is the bitwise <code>or</code> operator or its overload.</p>
",2
17790976,17790927,1,"<p><code>|</code> is bitwise OR operation.  <code>|=</code> just assigns the bitwise OR of a variable with another to the one on the LHS.</p>
",0
17790978,17790927,3,"<p>This operator is a shorthand for <code>x = x | RHS</code>. Where the bar operator is bitwise inclusive or.</p>
",0
16915715,16915510,1,"<p>If <code>ShortBuffer</code> is <a href=""http://developer.bada.com/help/index.jsp?topic=/com.osp.cppapireference.help/classOsp_1_1Base_1_1ByteBuffer.html"" rel=""nofollow"">what I think it is</a>, this should work:</p>

<pre><code>// Allocate enough space to avoid push_back
std::vector&lt;short&gt; input(BUFFER_SIZE, 0);
// Let the GetArray method do the copying
pBuffer1-&gt;GetArray(&amp;input[0], 0, BUFFER_SIZE);
</code></pre>
",0
16950081,16950034,0,"<p>You question is fairly open, but one thing you might want to look into is the C++ system command. See more info about it <a href=""http://www.cplusplus.com/reference/cstdlib/system/"" rel=""nofollow"">here</a>.</p>
",0
16950091,16950034,3,"<p>I'd advise you not to invent the wheel and use something like <a href=""http://www.sphere-research.com/en/"" rel=""nofollow"">SPOJ Engine</a>, <a href=""http://www.spoj.com/info/"" rel=""nofollow"">see also</a> which already has all necessary features as: secure sandboxing, providing faked user input and so on.</p>

<p>By the way, I just recalled <a href=""https://github.com/edx/xserver"" rel=""nofollow"">one more thing for automatic submission testing</a></p>
",0
16953307,16950034,0,"<p>Assuming you're going to be doing this on a POSIX-y OS like Linux or MacOS/X, forkpty() will do this pretty easily... see the example below which runs a ""ping 127.0.0.1"" in a child process and prints out the ping process's stdout output as it read()'s it.  You could write to the child process's stdin using write() on the same file descriptor.</p>

<p>A similar technique is also possible under Windows, but as per tradition it's about 10 times more difficult and awkward there.  Let me know if that's something you need to do.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

#if defined(__linux__)
# include &lt;pty.h&gt;     // for forkpty() on Linux
#else
# include &lt;util.h&gt;    // for forkpty() on MacOS/X
#endif

int main(int argc, char ** argv)
{
   int fd;
   pid_t pid = forkpty(&amp;fd, NULL, NULL, NULL);
   if (pid &gt; 0)
   {
      // We're running in the parent process.  We can now write to the child process
      // (and read from it) via (fd).
      while(1)
      {
         char buf[4096];
         int numBytesRead = read(fd, buf, sizeof(buf)-1);
         if (numBytesRead &gt; 0)
         {
            buf[numBytesRead] = '\0';  // ensure termination
            printf(""Read from child process's stdout: [%s]\n"", buf);
         }
         else if (numBytesRead == 0)
         {
            printf(""Child process exited\n"");
            break;
         }
         else {perror(""read""); break;}
      }
   }
   else if (pid == 0)
   {
      // We're running in the child process.

      // Turn off the echo, we don't want to see that back on stdout
      struct termios tios;
      if (tcgetattr(STDIN_FILENO, &amp;tios) &gt;= 0)
      {
         tios.c_lflag &amp;= ~(ECHO | ECHOE | ECHOK | ECHONL);
         tios.c_oflag &amp;= ~(ONLCR); /* also turn off NL to CR/NL mapping on output */
         (void) tcsetattr(STDIN_FILENO, TCSANOW, &amp;tios);
      }

      char * const argv[] = {""/sbin/ping"", ""-c"", ""5"", ""127.0.0.1"", NULL};  // Replace /sbin/ping with your favorite program to run instead
      if (execvp(argv[0], argv) &lt; 0) perror(""execvp"");
   }
   else if (pid &lt; 0) perror(""forkpty"");

   return 0;
}
</code></pre>
",0
16953462,16950034,0,"<p>This seems like a good use for unit testing. Write some headers, write unit tests for the function the headers define, then give the headers and unit tests to the students and refuse to grade their work until the tests pass. To further reduce any wasting of your time, make them compile everything with <code>-Wall -Werror</code>.</p>

<p>Once the tests do pass, I'd look through the code to make sure they're not doing anything evil just to make the tests pass.</p>

<p>The best unit testing framework I've seen for C++ is <a href=""http://code.google.com/p/googletest/"" rel=""nofollow"">Google Test</a>. It's easy to write and easy to run.</p>

<p>On the other hand, if all you care about is input and output, just use bash and pipes:</p>

<pre><code>#!/bin/bash

for executable in * ; do
    if cat input.txt | $executable | diff - expected-output.txt &gt; /dev/null ; then
        echo $executable passes
    else
        echo $executable fails
    fi
done
</code></pre>
",0
16921572,16921056,3,"<p>One solution is to use <em>ofstream</em> (in ""fstream.h"", very similar to <em>std::cout</em>):</p>

<pre><code>ofstream out(""num.txt"");
if (out.is_open() == false)
{
    cout &lt;&lt; ""Error! Couldn't open file!"" &lt;&lt; endl;
}
else
{
    out &lt;&lt; ""\n"";
    for (int i = 1; i &lt; 21; i++)
    {
        out &lt;&lt; i &lt;&lt; "": "";
        out &lt;&lt; x[i] &lt;&lt; ""\t"";
        if (i % 5 == 0)
        {
            out &lt;&lt; ""\n"";
        }
    }
    out.close();
}
</code></pre>
",3
16921744,16921056,5,"<p>To output the numbers to a file you can use <a href=""http://en.cppreference.com/w/cpp/io/basic_ofstream"" rel=""nofollow""><code>std::ofstream</code></a> for the output stream and replace <code>cout</code> with the variable name you use for the stream.</p>

<pre><code>std::ofstream outfile;
outfile.open(""num.txt"");
for (int i = 1; i &lt; 21; i++)
{
    outfile &lt;&lt; i &lt;&lt; "": "";
    outfile &lt;&lt; x[i] &lt;&lt; ""\t"";
    if (i % 5 == 0)
    {
        outfile &lt;&lt; std::endl;
    }
}
outfile.close();
</code></pre>

<p>You can also take it a step further and add input validation and use components from the Standard Library to handle most of what you are trying to accomplish. For instance instead of storing the numbers in an array I suggest using <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a> instead. You can also use <a href=""http://en.cppreference.com/w/cpp/algorithm/sort"" rel=""nofollow""><code>std::sort</code></a> to sort the data instead of implementing it yourself. </p>

<pre><code>#include &lt;vector&gt;       // vector
#include &lt;fstream&gt;      // fstream
#include &lt;algorithm&gt;    // sort
#include &lt;iostream&gt;

int main()
{
    std::vector&lt;int&gt;    numbers;

    while(numbers.size() != 20)
    {
        int value;

        if(!(std::cin &gt;&gt; value))
        {
            std::cout &lt;&lt; ""you must enter a number"" &lt;&lt; std::endl;
        }
        else
        {
            numbers.push_back(value);
        }
    }

    // Do the sort. Pretty easy huh!
    std::sort(numbers.begin(), numbers.end());

    std::ofstream outfile;
    outfile.open(""num.txt"");
    if(outfile.is_open() == false)
    {
        std::cout &lt;&lt; ""Unable to open num.txt"" &lt;&lt; std::endl;
    }
    else
    {
        for(size_t i = 0; i &lt; numbers.size(); i++)
        {
            outfile &lt;&lt; i &lt;&lt; "": "";
            outfile &lt;&lt; numbers[i] &lt;&lt; ""\t"";
            if (i % 5 == 0)
            {
                outfile &lt;&lt; std::endl;
            }
        }
        outfile.close();
    }
}
</code></pre>
",3
16921119,16921056,2,"<p>If you're running your program from the command line, type the following(when you run it) to forward the output to a file:</p>

<pre><code>myApp &gt; num.txt
</code></pre>

<p>you can also use the <code>&lt;</code> switch to specify a file to get input from too</p>

<p><a href=""http://www.mathinfo.u-picardie.fr/asch/f/MeCS/courseware/users/help/general/unix/redirection.html"" rel=""nofollow"">You can find more information here.</a></p>
",2
16921170,16921056,4,"<p>Use this in your code </p>

<pre><code>#include &lt;fstream&gt;

ofstream outputFile;
outputFile.open(""outputfile.txt"");
outputFile &lt;&lt; value &lt;&lt; endl;
outputFile.close();
</code></pre>
",0
16922967,16921056,2,"<p>here is your code with all the changes 
now you just need to copy paste (i have made a comment on line i added )</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;conio.h&gt; 
#include &lt;fstream&gt;//file stream 

using namespace std;   

int main() {   

    int x[21], s;
    int j,i;

    for (int i = 1; i &lt; 21; i++)
    {
        cout &lt;&lt; setw(11) &lt;&lt; i &lt;&lt; "": "";
        cin &gt;&gt; x[i];
    }
    for (int i = 1; i &lt; 21; i++)
    {
        for (int j = i+1; j &lt; 21; j++)
        {
            if (x[j] &lt; x[i])
            {
                s = x[j];
                x[j] = x[i];
                x[i] = s;
            }
        }
    }

    ofstream out; //output file stream
    out.open(""num.txt""); //opening (and creating output file named out


    //cout &lt;&lt; endl;
    for (int i = 1; i &lt; 21; i++)
    {
        //cout &lt;&lt; i &lt;&lt; "": "";
        out &lt;&lt; i &lt;&lt; "": ""; //printing in output file
      //  cout &lt;&lt; x[i] &lt;&lt; ""\t"";
        out &lt;&lt; x[i] &lt;&lt; ""\t""; //printing in output file
        if (i % 5 == 0)
        {
            //cout &lt;&lt; endl;
            out &lt;&lt; endl; //printing in output file
        }
    }
    //getch();
    out.close(); //closing output file
    return 0; 
}
</code></pre>
",0
16945232,16943921,0,"<p>There are two issues.  First of all, <code>a</code> and <code>b</code> are the test region's size.</p>

<pre><code>     for (r=p;r&lt;a;r++)
       for (s=q;s&lt;b;s++) 
          sumArray[p][q]+=peanut[r][s];
</code></pre>

<p>Here, <code>p</code> and <code>q</code> represent initial indecies, however you are checking the index against the subreigion dimension limits.  Instead, it should be:</p>

<pre><code>     for (r=p;r&lt;p+a;r++)
       for (s=q;s&lt;q+b;s++) 
          sumArray[p][q]+=peanut[r][s];
</code></pre>

<p>The second issue is that 38 <em>is</em> the answer; the topleft-most region contains the maximum of all the subrectangles.  Here is my solution that prints all of the values.  It should be noted that I'm not familiar with this <code>int arr[X][Y]</code> business when <code>X</code> and <code>Y</code> are not const (couldn't get it to compile), so I changed it to something I'm familiar with.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int L,W,a,b,i,j,x,y,p,q,r,s;

int main()
{
    cin&gt;&gt;L&gt;&gt;W;
    int** peanut=new int*[L]; //a new row pointer for each column element
    for (i=0;i&lt;L;i++){ 
     peanut[i]=new int[W]; //the actual row for each column element
        for (j=0;j&lt;W;j++)
            cin&gt;&gt;peanut[i][j];
    }
    cin&gt;&gt;a&gt;&gt;b;

    //don't need to remember results; just compare maximum after each evaluation.
    //int sumArray[L-a+1][W-b+1];
    //memset(sumArray,0,(L-a+1)*(W-b+1)*sizeof(int));

    int max = 0;
    for (p=0;p&lt;L-a+1;++p){
        for (q=0;q&lt;W-b+1;++q){

           int sum=0;
           for (r=p;r&lt;p+a;++r) //r&lt;p ==&gt; r&lt;p+a, prefix increment is always better
               for (s=q;s&lt;q+b;++s){ //s&lt;q ==&gt; s&lt;q+b, prefix increment is always better
                   cout &lt;&lt; ""("" &lt;&lt; r &lt;&lt; "","" &lt;&lt; s &lt;&lt; "","" &lt;&lt; peanut[r][s] &lt;&lt; "") "";
                   sum+=peanut[r][s]; 
               }
           cout &lt;&lt; sum &lt;&lt; endl;
           if(sum&gt;max) max=sum;

        }
    }

    /*  Merged in previous loop
    int max = 0;
    for (x=0;x&lt;L-a+1;x++)
     for (y=0;y&lt;W-b+1;y++) 
       if (sumArray[x][y]&gt;max) max=sumArray[x][y];
    */

    cout &lt;&lt; ""Answer: "" &lt;&lt; max;

    //Since I'm in Visual Studio, I need to pause and see the result before quitting...
    int s;
    cin &gt;&gt; s;

    return 0;
}
</code></pre>
",5
16945272,16943921,0,"<p>The problem is this part:</p>

<pre><code>for (r=p;r&lt;a;r++)
         for (s=q;s&lt;b;s++) sumArray[p][q]+=peanut[r][s];
</code></pre>

<p>You are not iterating <code>a</code> and <code>b</code> times.  Change it to:</p>

<pre><code>for (r=p;r&lt;p+a;r++)
         for (s=q;s&lt;q+b;s++) sumArray[p][q]+=peanut[r][s];
</code></pre>
",0
16945280,16943921,1,"<p>The problem is that you did not index elements carefully to calculate the <code>sumArray</code>. I only changed two lines of your code to make it work.</p>

<pre><code>for (r=0;r&lt;a;r++)
  for (s=0;s&lt;b;s++) sumArray[p][q]+=peanut[p+r][q+s]; 
</code></pre>

<p>The following is the full code. Please fix it if there are other problems.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int L,W,a,b,i,j,x,y,p,q,r,s;

int main()
{
    cin&gt;&gt;L&gt;&gt;W;
    int peanut[L][W];
    for (i=0;i&lt;L;i++) 
     for (j=0;j&lt;W;j++) 
       cin&gt;&gt;peanut[i][j];
    cin&gt;&gt;a&gt;&gt;b;

    int sumArray[L-a+1][W-b+1];
    memset(sumArray,0,(L-a+1)*(W-b+1)*sizeof(int));

    for (p=0;p&lt;L-a+1;p++)
     for (q=0;q&lt;W-b+1;q++) 
       {
        for (r=0;r&lt;a;r++)
         for (s=0;s&lt;b;s++) sumArray[p][q]+=peanut[p+r][q+s]; 
       }

    int max = 0;
    for (x=0;x&lt;L-a+1;x++)
     for (y=0;y&lt;W-b+1;y++) 
       if (sumArray[x][y]&gt;max) max=sumArray[x][y];
    cout &lt;&lt; max;
    return 0;
}
</code></pre>
",0
17075944,17075900,0,"<p>In c++ you can declare an array like so:</p>

<pre><code>int numbers[11] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
</code></pre>

<p>The size is specified in the square brackets.</p>

<p>If you had a function that gave you the size, then you would need a dynamically sized array. <code>std::vector</code> is commonly used for this purpose.</p>

<pre><code>void createTable(int table[11])
{
  std::vector&lt;int&gt; numbers (table, table + 11 * sizeof(int));
}
</code></pre>
",5
18103328,18103305,6,"<p>It is straightforward : <code>fun</code> returns the <em>reference</em> to the <code>static</code> variable inside the function, which is assigned to <code>30</code> by this line:</p>

<pre><code>fun() = 30;
</code></pre>

<p>this means, <code>x</code> inside the function is changed to <code>30</code>. What is more? It is 30!  You print it by calling again <code>fun()</code> in the next line.</p>

<p>Note that a static variable lives till the end of the program: it is not destroyed even if the function returns!</p>
",0
17406924,17406859,7,"<p>It's not a compilation error, it's linker errors. It tells you that it can't find the Windows socket function, because you don't link with the wsock32 library.</p>

<p>Edit your project settings to add it.</p>
",2
17407038,17406859,0,"<p>You missing <strong>ws2_32.lib</strong> in your linker option. To do so </p>

<p>Go to project properties-->Linker-->inputs-->Additional Dependencies (Add ws2_32.lib in text box)</p>
",0
17773457,17773318,0,"<p>You should use </p>

<pre><code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
</code></pre>

<p>For remove <code>\n</code>, remained after inputting <code>option</code>.</p>
",2
17775215,17773318,-1,"<p>you can do:
<strong>std:cin>>itemName</strong></p>

<p>instead of doing:
<strong>std::getline(std::cin,itemName)</strong></p>

<p><strong>This would be the easiest approach for the strings without spaces!</strong></p>
",1
17775269,17773318,1,"<p>Frsitly, you are using <code>getline</code> and haven't included <code>&lt;string&gt;</code> header file. </p>

<p>2ndly, you may be facing issue because of <code>cin</code> buffer. you should use <code>cin.ignore()</code> after taking input for <code>option</code> for extracting the characters and discarding or other option may be clearing <code>cin</code> buffer.</p>

<p><code>cin.ignore()</code> will work for ignoring 1 character in stream.<br>
you can try <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code> 
This will extract as many characters till ``\n''</p>

<hr>

<p><em><strong>I tried following code on VS2012, and it worked properly.</em></strong> </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;


int main() {
int total;

std::cout &lt;&lt; ""Item name:"";
std::string itemName;
std::getline(std::cin,itemName);

std::cout &lt;&lt; ""Cost(in cents):"";
int cost;
std::cin &gt;&gt; cost;

std::cout &lt;&lt; ""Quantity:"";
int quantity;
std::cin &gt;&gt; quantity;

std::cout &lt;&lt; ""Do you want to add more items? (Y/N)"";
char option;
std::cin &gt;&gt; option;
std::cin.ignore();

if (option == 'y') {
std::cout &lt;&lt; ""Item name:"";
std::string itemName2;
std::getline(std::cin,itemName2);

std::cout &lt;&lt; ""Cost(in cents):"";
int cost2;
std::cin &gt;&gt; cost2;

std::cout &lt;&lt; ""Quantity:"";
int quantity2;
std::cin &gt;&gt; quantity2;

std::cout &lt;&lt; ""Do you want to add more items? (Y/N)"";
char option2;
std::cin &gt;&gt; option2;
  std::cin.ignore();

if (option2 == 'y') {
  std::cout &lt;&lt; ""Item name:"";
  std::string itemName3;
  std::getline(std::cin,itemName3);

  std::cout &lt;&lt; ""Cost(in cents):"";
  int cost3;
  std::cin &gt;&gt; cost3;
  std::cout &lt;&lt; ""Quantity:"";
  int quantity3;
  std::cin &gt;&gt; quantity3;

  total = cost*quantity + cost2*quantity2 + cost3*quantity3;

  std::cout &lt;&lt; ""Total value:"" &lt;&lt; total;
}
  else {
  total = cost*quantity + cost2*quantity2;
  std::cout &lt;&lt; ""Total value:"" &lt;&lt; total;
}
}
else {
total = cost*quantity;
std::cout &lt;&lt; ""Total value:"" &lt;&lt; total;
}

system(""pause"");
return 0;
}
</code></pre>

<hr>

<p>For details on <code>cin.ignore()</code> <a href=""http://www.cplusplus.com/reference/istream/istream/ignore/"" rel=""nofollow"">see this link.</a></p>
",0
17789853,17789608,2,"<pre><code>    Rational(int numerator = 2, int denominator = 1)
{
    numerator = 2;
    denominator = 1;
};
</code></pre>

<p>I would change this to </p>

<pre><code>    Rational(int numerator, int denominator)
{
    this-&gt;numerator = numerator;
    this-&gt;denominator = denominator;
};
</code></pre>

<p>I don't know exactly if this is causing your problem, but I think it's contributing to it. Your call to Rational(int,int) will still work fine and add your specified values into the Object you're creating. </p>

<p>The issue with your code, is scope. I believe you were just re-assigning the arguments/parameters instead of actually re-assigning your instance variables, which I'm assuming was your goal.</p>
",2
17789867,17789608,2,"<p>First, this line is <em>very</em> wrong:</p>

<pre><code>Rational(int numerator = 2, int denominator = 1){ numerator = 2; denominator = 1;};
</code></pre>

<p>The arguments <code>numerator</code> and <code>denominator</code> are in the stack frame of your ctor thus hiding your class's members <code>Rational::numerator</code> and <code>Rational::denominator</code> and secondly, you are completely ignoring what the caller actually sends as its arguments (not because you specify the default values, but because you explicitly set <code>numerator=2; denominator=1</code>.  This line should actually be:</p>

<pre><code>Rational(int numerator = 2, int denominator = 1){ this-&gt;numerator = numerator; this-&gt;denominator = denominator;};
</code></pre>

<p><em>OR</em> you could use an initializer list (and overloaded constructors):</p>

<pre><code>Rational() : numerator(2), denominator(1) {};
Rational(int numerator, int denominator) : numerator(numerator), denominator(denominator) {};
</code></pre>

<p>Now, the second problem is that <code>int/int =&gt; int</code> :: dividing an integer by another integer yields integer division, you need to cast one of your int's to double so that both int's are upconverted to double before calculating the division, like so:</p>

<pre><code>operator double() const{ return ((double)this-&gt;denominator)/this-&gt;numerator;};
</code></pre>
",0
17803217,17803193,5,"<p>It's on the stack typically, before the pointer for the function call or the stack frame of the function.  I don't know if this is required by the standard, but it's probably universally done.</p>

<p>So take this example:</p>

<pre><code>int f(myClass byVal)
{
    int b;
    ...
};

...

myClass myInst;
int val = f(myInst)
</code></pre>

<p>I'd expect the stack to look like at the point of the ellipsis inside of f:</p>

<pre><code>&lt;top&gt; b (stack frame inside of f)
pointer to f
temp copy of myInst
myInst (stack frame of outer function).
...
</code></pre>

<p>When f returns, the stack is cleaned up to the frame of the enclosing function.</p>

<p>It's worth noting jogojapan's comment that optimization can cause changes, including putting some data in the machines internal registers.  You'd never want to count on internal details like this, but it's good to understand the mechanisms in common use.</p>
",8
17805406,17803193,1,"<p>Like Codie CodeMonkey said, on most current computers, the copy will be on the stack. However, there are notable exceptions:</p>

<p>On platforms with a decent amount of registers (the old PowerPC and the entire Power series are an example, another one is the Sparc, I would define ""decent amount"" to mean at least 32 registers), the copies are actually made from one register to another register. On these platforms, there are strict rules, which registers a function may change and which not. Local variables are typically held in the registers which may not be changed by any called functions, so no memory access is necessary for them. Only, when the called function decides that it needs to use some of the registers it must not change, will it save the contents of those registers onto the stack before it overwrites them.</p>

<p>So the typical life of a value on such platforms is this:</p>

<ul>
<li><p>Function a writes it into a register (r31) that may not be changed by function calls.</p></li>
<li><p>Function a copies the value into a register that is used for register passing (r3). Both copies reside in registers.</p></li>
<li><p>Function a calls function b.</p></li>
<li><p>Function b needs to call function c, after which call it still needs the value. So it takes a number of registers and saves them on the stack (including register r31 that originally held our value). Now there are three copies of the value: two in registers and one on the stack.</p></li>
<li><p>Function b copies the value into its old register (r3 -> r31), not knowing that it was there already. It calls function c. After this call, there is still one saved copy on the stack and one in register r31.</p></li>
<li><p>Function b does whatever it needs to do with our value. Finally, it restores the registers which it was not supposed to modify by loading their old value from the stack. From Function b's perspective, this destroys its working copy of the value in register r31, however, we still have one copy of the value in a register and one on the stack.</p></li>
<li><p>Function b returns, destroying its stack allocation, the stack copy of the value fades into oblivience. Only the original copy of the value within function a remains where it should be: in register r31.</p></li>
</ul>

<p>Even though this approach seems complicated, it entails significantly fewer stack memory accesses than the X86-approach. Especially leaf routines that do not need to call any other functions, do not need to access the stack at all.</p>
",0
16938572,16938480,30,"<p>It's valid and safe C++ to omit the template parameters inside the class definition. In fact it's good practice, since you might add other template parameters with default values later on. You might forget to change <code>A&lt;T&gt;</code> to <code>A&lt;T,SomeOtherParameter&gt;</code> and get strange compile-time errors. Then just returning <code>A</code> will do it. </p>
",0
16938744,16938480,20,"<p>You can say either <code>A&lt;T&gt;</code> or just <code>A</code>, and <code>A</code> means the same as <code>A&lt;T&gt;</code>. This is because of 14.6.1/1:</p>

<blockquote>
  <p>Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected-class-name [...] is equivalent to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</p>
</blockquote>
",0
18175090,18174731,0,"<p>Your code does this:</p>

<pre><code>StartGame::StartGame(EntitySystem&amp; ES)
    : ES(ES)
</code></pre>

<p>Let's break this down:</p>

<pre><code>"":""       &lt;-  means ""Memberwise initialization""
""ES(""     &lt;-  means ""call the constructor for member 'ES'""
""(ES)""    &lt;-  these are the arguments to pass to the constructor
""{ ... }"" &lt;-  here is the constructor body itself.
</code></pre>

<p>The trouble is, your class does not have a member called ""ES"".</p>

<p>But you also have a secondary problem.</p>

<pre><code>""ES(ES)""
</code></pre>

<p>If you had a member variable called ""ES"", there would be a conflict here.</p>

<p>There are several widely used practices that you might want to employ to avoid problems like this in future.</p>

<ol>
<li>Use upper-camelcase (""SomeClass"") for class, struct, type definitions.</li>
<li>Use prefixes for non-local variables: ""m_"" for members, ""s_"" for statics, ""g_"" for globals, (some people also use ""u_"" for unions, ""um_"" for union members, etc).</li>
<li>Use a '_' suffix for function arguments, e.g. <code>void myFunction(int arg1_, int arg2_) { ...</code></li>
<li>Use upper-case for functions and choose a convention for naming convention for ""getter"" and ""setter"" functions.</li>
</ol>

<p>e.g.</p>

<pre><code>static size_t s_counter = 0; // count of how many things we've done.
extern size_t g_nowServing;  // imported from another module.

class Customer {
    size_t m_ticketNo;       // which ticket number I pulled
    std::string m_licensePlate;
public:
    Customer(size_t ticketNo_, const char* licensePlate_)
        : m_ticketNo(ticketNo_)
        , m_licensePlate("""")
    {
        // somewhat artificial implementation for demonstrative purposes.
        char licensePlate[8] = ""\0\0\0\0\0\0\0"";
        for (size_t i = 0; i &lt; sizeof(licensePlate); ++i) {
            if (!isalnum(licensePlate_[i]))
                throw CustomerException(""invalid character in license plate"");
            licensePlate[i] = licensePlate_[i];
        }
        if (licensePlate[sizeof(licensePlate) - 1] != '\0')
            throw CustomerException(""invalid license plate -- too long"");

        m_licensePlate = licensePlate;
    }
};
</code></pre>

<p>This makes it much easier to immediately diagnose the problem in your code:</p>

<pre><code>StartGame::StartGame(EntitySystem&amp; es_)
    : m_es(es_)
{
}
</code></pre>

<p>This would have produced the compiler error <code>error: class StartGame does not have any field named m_es</code> and bingo - you would have been able to home in on the problem immediately.</p>
",0
18234412,18234111,0,"<p>You need to put that dll in the executable folder. The dll would be in the Qt folder i assume, check it. </p>

<p>Also please note that is a debug dll (the last D in the name), you¡®d want to ship a release build instead of a debug one.</p>
",0
18234443,18234111,0,"<p>You can find necessary QT dll's in:  QT Directory \mingw48_32\bin
and windows runtime dll's in:  QT Directory \mingw48_32\plugins\platforms
path is for mingw compiler</p>
",1
17850536,17850504,4,"<p>You're missing a colon in <code>std::string</code>. You wrote:</p>

<pre><code>std:string
</code></pre>

<p>and it should be:</p>

<pre><code>std::string
</code></pre>

<p>You can see that this:</p>

<pre><code>#include &lt;map&gt;
#include &lt;string&gt;

class myclass
{
public:

    myclass() {}
    myclass(const myclass &amp;m):y(m.y){}
    ~myclass() {}
    int y;

};

int main()
{
    std::map&lt;std::string, myclass&gt; funcmap;

    return 0;
}
</code></pre>

<p><a href=""https://ideone.com/Qdgoso"" rel=""nofollow"">Compiles</a></p>
",1
17771502,17771456,3,"<p>I guess your issue is in the second line here:</p>

<pre><code>typedef NslObject::KeyK NewKeyPair1; 
NewKeyPair1(RSA::GenerateKeyPair(keyLength));
</code></pre>

<p>Resolving the typedef you've essentially written the following:</p>

<pre><code>NslObject::KeyK(RSA::GenerateKeyPair(keyLength));
</code></pre>

<p>So you can clearly see you're missing the variable name for this line.</p>

<p>To fix this, name the variable/object:</p>

<pre><code>NewKeyPair1 somekeypair(RSA::GenerateKeyPair(keyLength));
</code></pre>

<p>However, I guess you misused the <code>typedef</code> anyway? Did you try to name that <code>NewKeyPair1</code>? Something like this:</p>

<pre><code>NslObject::KeyK NewKeyPair1(RSA::GenerateKeyPair(keyLength));
</code></pre>
",0
17391734,17391681,3,"<ol>
<li>You shouldn't have two data types with exactly identical members but different names. It's just redundant code, try to get rid of the redundant types. </li>
<li>If for some reason you cannot(<em>really hard to believe you cannot</em>) simply use <code>reinterpret_cast</code> to cast one type to another.</li>
</ol>

<p>Note that the class/structure need to be exactly identical w.r.t its composition and not not have any virtual members.</p>
",2
17392071,17391681,5,"<p>The best thing to do is to solve the issue by not having this redundancy at all. This is not <a href=""http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"" rel=""nofollow"">DRY</a>.</p>

<p>A trivial solution which I am sure you cannot apply (otherwise you had already done that), would be to move the common syntax of the two types to a base class and separate the semantic differences into two derived (probably empty) classes.</p>

<p>If this is not achievable, you could use an adapter class to encapsulate any of the two Types that you have and access them both with the same interface.</p>

<pre><code>Obj2 o2;
Adapter&lt;Obj2&gt; a(o2);
a.getFirstMember();
</code></pre>

<p>Reinterpreting a pointer to one object as a pointer to the the other one is also possible:</p>

<pre><code>Obj1 *p = reinterpret_cast&lt;Obj1 *&gt;(&amp;obj2);
</code></pre>

<p>but the two objects really need to have the same memory footprint e.g., for any possible value of any member, replicated in both the types, the following must always be true:</p>

<pre><code>memcmp(&amp;obj1, &amp;obj2, sizeof(Obj1)) == 0 &amp;&amp; sizeof(obj1) == sizeof(obj2)
</code></pre>

<p>This is generally hard to guarantee and it can become even more non-trivial if the compiler will add something for you in one of the two classes (an innocent refactoring in a couple of months time may easily bring this problem in).</p>

<p>Think for example to a virtual destructor.
If you have it in one class (as the only virtual member) and not in the other, then that one class will have a <code>vptr</code> as its first member and the other one will not, so accessing that offset in both classes will yield different results.</p>
",3
17392118,17391681,0,"<p>No there is no other way then to create a function from one to the other, and this is the most logical thing to do anyways. Perhaps you could write a macro that would iterate over the fields somehow... but what would be the point? This will just make the code more unstable and hard to understand. If each field is exactly the same type and they are in the same order, then perhaps you could just cast from one to the other, but I'd still avoid that.</p>
",0
17404439,17404192,4,"<p>When <code>cin</code> (or any other <code>std::stream</code>) hits an end of file, it sets a status to indicate that this has happened. </p>

<p>To reset this status, you need to call <code>cin.clear();</code>, which will clear any ""bad"" state, and make sure the stream is ""ok"" to use again. This also applies if you are reading from a file, and want to restart from the beginning.</p>

<p>Edit: I just took the code posted above, and ran it on my machine, adding at the top</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;
</code></pre>

<p>This following is the compile and run:</p>

<pre><code>$ g++ -Wall words.cpp 
words.cpp: In function ¡®int main()¡¯:
words.cpp:40:20: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
$ ./a.out
Enter the complete search text, followed by end-of-file: aa bb cc [CTRL-D]
Please enter your target word: aa
The target word [aa] was in the search text 1 times.
</code></pre>

<p>which is what I expected to see... </p>

<p>Edit2: For completeness: The ""success rate"" of using <code>cin.clear()</code> will depend on the implementation. A more reliable solution is to use a different way to mark the end of the stream of words in the first phase of the program. One could use a single <code>"".""</code> or ""!"" or some other thing that isn't supposed to be in a ""word"" - or something longer, such as <code>""&amp;&amp;@&amp;&amp;""</code>, but that makes it hard to type and remember when one is 15 pages into the input.</p>
",16
17404502,17404192,2,"<p>When execution leaves the loop</p>

<pre><code>while (cin &gt;&gt; x){
    searchText.push_back(x);
}
</code></pre>

<p>it does so because the ""testing"" of <code>cin</code> has returned false, in other words, <code>failbit</code> and/or <code>badbit</code> has been set on the stream. When that is the case, any further attempt to read from the stream will fail, i.e. <code>targetWord</code> will be left empty.</p>

<p>To make the stream usable again, you have to reset the error flags by calling <code>cin.clear();</code></p>
",1
17406097,17404192,2,"<p>It would be somewhat helpful if we knew the type of <code>x</code> in the
first loop, but basically: you read all of the available input,
then try to read some more, and you're surprised that it's
failing.  The contrary would surprise me. </p>

<p>The real question is: what are you trying to do?  Basically,
what is the type of <code>x</code>, and&mdash;I'm assuming that you're
supposing that <code>cin</code> is an interactive device because of the
prompt&mdash;how do you determine that the first input has
finished?  If the first loop ends because of ""end of file"" (user
entered control-D under Unix, or control-Z under Windows), then
there's no way you can reliably expect to read more.  Resetting
the error status with <code>cin.clear()</code> <em>might</em> work; it will cause
the <code>istream</code> to try to read more from the <code>streambuf</code>.  But it
might not; there are any number of layers below the <code>istream</code>
which, for whatever reason, may have memorized the end of file.
So you'll have to find some different way of recognizing the
end.</p>

<p>Just guessing from the names of the variables: if you're trying
to read a list of words, I'd use <code>std::getline</code>, with an empty
line for the end of the list.  So the first loop would become:</p>

<pre><code>while ( std::getline( std::cin, x ) &amp;&amp; x != """" ) {
    searchText.push_back( x );
}
if ( ! std::cin ) {
    //  Something really bad has happened...
}
</code></pre>

<p>Alternatively, you might want to break up the line on white
space, to allow more than one word per line (and to ignore any
extra white space in the line:</p>

<pre><code>std::string line;
while ( std::getline( std::cin, x ) &amp;&amp; x != """" ) {
    std::istringstream l( line );
    while ( l &gt;&gt; x ) {
        searchText.push_back( x );
    }
}
if ( ! std::cin ) //  ...
</code></pre>

<p>Even if <code>x</code> has some other type, you might want to consider
something along these lines.</p>
",1
17409941,17404192,0,"<p>I used cin.clear() and on my mac set-up it did not seem to clear the EOF but on a ubuntu set-up it did clear the stream </p>

<p>Apple:</p>

<pre><code>(Canopy 32bit) joes-imac:chap3 joe$ g++ --version
i686-apple-darwin11-llvm-g++-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
</code></pre>

<p>Ubuntu:</p>

<pre><code>joe@joe-HPlaptop:~$ g++ --version
g++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3
Copyright (C) 2011 Free Software Foundation, Inc.
</code></pre>

<p>I am happy to accept it is just compiler differences and finish/ close the issue (was a silly little one really!)</p>

<p>Thanks for all the help though (my first stackoverflow question actually!)</p>
",1
17867073,17867049,0,"<p>The <code>static</code> function usage is correct - it lets you use functions from classes without having an instance of the class. The FFT example you gave probably creates an instance within the static function. So in your case, you would instantiate <code>Dog</code> within the <code>GetDog</code> function (just be careful with returning references to local variables!).</p>
",8
17867133,17867049,0,"<p>You say that you can't use <code>this</code> if you make it <code>static</code>, which is true. But why would you want to access it without using an Object instance if you're going to need to use <code>this</code> at some point in the future? If it has a default value, or something like that, you could declare that elsewhere outside of the function as <code>public static</code> and then access it that way. If you clarify a little bit more as to what you're doing, I'll edit/remove this answer accordingly.</p>
",3
17867887,17867049,0,"<p>It seems that it is an implementation of the <em>Meyers singleton</em>.</p>
<p>I explain :</p>
<p>In the example given, the class <code>EXOFastFourierTransformFFTW</code> does not seem to have a constructor but return a reference to a <code>EXOFastFourierTransformFFTW</code> object.</p>
<p>And it looks like this implementation :</p>
<pre><code>class Singleton
{
public:
    static Singleton&amp; Instance()
    {
        static Singleton obj;
        return obj;
    }

private:
    Singleton();
};
</code></pre>
<p>From <a href=""http://en.wikipedia.org/wiki/Modern_C%2B%2B_Design"" rel=""nofollow noreferrer"">this book from <strong>Andrei Alexandrescu</strong></a>, it is said :</p>
<blockquote>
<p>This simple and elegant implementation was first published by <strong>Scott Meyers</strong>; therefore, we'll refer to it as the <em>Meyers Singleton</em>.</p>
<p>The Meyers singleton relies on some compiler magic. A function-static object is initialized when the control flow is first passing its definition. Don't confuse static variables that are initialized at runtime[...]</p>
<p>[...]</p>
<p>In addition, the compiler generates code so that after initialization, the runtime support registers the variable for destruction.</p>
</blockquote>
<p>So it good to use static to call a method from a class <strong>not instantiated</strong> but don't do it if it is not necessary... Here to represent a <em>Singleton Pattern</em> you have to.</p>
<p>But now if you want your class <code>Dog</code> look like that :</p>
<pre><code>class Dog
{
public:
    static Dog&amp; GetDog(int k)
    {
        static Dog obj( k );
        return obj;
    }
    int bark()
    {
        return a*a;
    }
private:
    int a;
    Dog( int iA ) : a( iA ) {}
};
</code></pre>
",4
18280267,18280014,1,"<p>This must be an assignment as 3 other people seem to be doing the same thing.</p>

<p>You don't need your card listing to be a <code>std::string[]</code>.  You can use <code>std::array</code> which will give you the standard STL iterator methods while still being a simple array.  Either way, you can load them into a vector using the <code>std::vector</code>'s iterator constructor:</p>

<pre><code>// assuming data is loading into myarray and myarray_size is the size of the array
std::vector&lt;std::string&gt; cards(myarray, myarray + myarray_size);
</code></pre>

<p>You can access the vector's data directly (if needed) by using <code>&amp;cards[0]</code> which will give you a pointer to the first element in the array.</p>

<p>That said, if you use the STL templates, you will improve your code and learn the language much more efficiently.</p>
",4
17814465,17814140,2,"<p>Caveat: This uses ""unedfined behaviour"", as described below - it is known to work on MOST platforms (I have enough understanding to say this works on ARM and x86 in Windows, Linux and Symbian OS's, and should be fine for most OS's that use a ""flat"" memory model).  </p>

<p>If you ""limit"" yourself to a particular system, it could be possible to compare <code>this</code> to a known range of ""where the stack is"" (and if need be) where static data is). [It would be possible to figure out where the stack is for an arbitrary thread too, but it makes the challenge a little harder]. </p>

<p>With the knowledge of where static data, and stack is located, we can compare </p>

<pre><code>char *this_addr = static_cast&lt;char*&gt;(this);
if (this_addr &gt;= globa_start &amp;&amp; this_addr &lt;= global_end) 
   globals++;
else if (this_addr &gt;= stacK_top &amp;&amp; this_addr &gt;= stack_base)
   stacked++;
else heaped++; 
</code></pre>

<p>Note that this will only work if you can actually somehow figure out where the stack is - and of course, it's undefined behaviour to compare <code>this</code> with anything outside the block it was allocated in, so technically, the whole concept is undefined. However, it's POSSIBLE to do this in most OS/Processor architectures. [Of course, you also need to do the same but in reverse in the destructor]. (It also gets ""fun"" if you destroy the object from a different thread than the one that created it!)</p>

<p><strong>Edit:</strong> Finding the stack for a given thread isn't that hard: Store [per thread if there are more than one thread] the address of a local variable in the ""first function"" (the one passed into the thread create call). Then take the address of a variable in the current thread. Anything between those values is in that threads stack, as the stack is one contiguous lump of memory. </p>
",1
17814470,17814140,0,"<p>The easiest solution to track the number of active objects is to create an object manager (with a GetSize() function or whatever)</p>

<p>In the class you want to trace, you can also add a static property which will be increased and decreased in constructors and destructors respectively.</p>

<p>With the size of the <strong>object manager (dynamic allocation)</strong> and <strong>the static property (all allocations)</strong> you will be able to retrieve those numbers separately.</p>
",2
17814682,17814140,0,"<p>As an option, you can globally overload new and delete to increment/decrement some static counter, that would give global count of dynamically allocated objects...</p>
",7
17814161,17814140,9,"<p>Sadly you just can't. There's a whole section in one of the books by Scott Meyer's where he goes on about the challenges of trying to achieve this and the short of it is it's not possible.</p>

<p>More Effective C++ - Item #27: Requiring or prohibiting heap-based objects.</p>

<p>Ok here's one of the problems that is easily demonstrated (the item in question is several pages long so I won't summarize all of it but here's at least one challenge):</p>

<p>Many (but not all) systems arrange their memory in the following fashion:</p>

<pre><code>----------------
|     Stack    |
| (Grows Down) |
|              |
----------------
|              |
|              |
|              |
|              |
|              |
|              |
----------------
|     Heap     |
|  (Grows Up)  |
|              |
----------------
</code></pre>

<p>Now you might think with a memory arrangement like this you could do something clever with operator new/new operator to figure out if you're on the heap or not right (by checking if you're above or below a certain memory location)? Here's the problem. Where static objects go is system dependent, so the following thing could happen:</p>

<pre><code>----------------
|     Stack    |
| (Grows Down) |
|              |
----------------
|              |
|              |
|              |
|              |
|              |
|              |
----------------
|     Heap     |
|  (Grows Up)  |
|              |
----------------
|    Static    | 
|    Objects   |
----------------
</code></pre>

<p>You now fail to distinguish between static objects and heap object. Oops! Also you may have noticed I said this is system dependent, which means even if you were to figure out a way to distinguish between them, well your code would not be portable.</p>
",3
17815185,17814140,1,"<p>You could simply tell the class by passing an argument about its location:</p>

<pre><code>class LocationAware {
public:
    enum Location { STATIC, STACK, HEAP };
    explicit LocationAware(Location location) : my_location(location) {
        switch(location) {
            case STATIC: ++static_instaces; break;
            case STACK: ++stack_instances; break;
            case HEAP: ++heap_instances; break;
        }
    }

    ~LocationAware() {
        switch(my_location) {
            case STATIC: --static_instaces; break;
            case STACK: --stack_instances; break;
            case HEAP: --heap_instances; break;
        }
    }

private:
    const Location my_location;

public:
    static unsigned static_instaces;
    static unsigned heap_instances;
    static unsigned stack_instances;
};

unsigned LocationAware::static_instaces = 0;
unsigned LocationAware::heap_instances = 0;
unsigned LocationAware::stack_instances = 0;

LocationAware stat(LocationAware::STATIC);

int main() {
    LocationAware stack(LocationAware::STACK);

    LocationAware * heap = new LocationAware(LocationAware::HEAP);
}
</code></pre>

<p>Of course you can lie to this class. Don't.</p>

<p>Also, if you would like to make it less intrusive you could make it a template and use inheritance or encapsulation and use it from your class. Just give it a parameter:</p>

<pre><code>template&lt;class Tag&gt;
LocationAware;
</code></pre>

<p>Then either inherit or hold a location in your class and initialize it. You can see the instances using <code>LocationAware&lt;YourClassOrTag&gt;::xy_instances</code>.</p>
",0
17855687,17855646,1,"<p>C++ doesn't have reflection, so you need to recompile the whole thing.</p>
",1
17856198,17855646,0,"<p>C++ is a statically compiled language. That means that every type checking is done at compile time, so <strong>if you modify a type, every line of code that depends on the modification must be recompiled</strong>. It includes base class modification and subclases, as in your case.</p>

<p>Note that it could be a problem, because if you are writting an API, and you modify the API implementation, the API and every code that uses the code you have modified (The user code) must be recompiled.</p>

<p>The classic thechnique to reduce recompilation is the <a href=""http://c2.com/cgi/wiki?PimplIdiom"" rel=""nofollow"">PIMPL idiom</a>. 
<strong>PIMPL</strong> hides the implementation of the class through a pointer to a implementation class stored as member of the original class. Note that the original class acts only as a interface. So if the implementation is modified, the interface not, so users of the class not need to recompile.</p>
",2
17856675,17855646,1,"<p>This isn't well-defined by the language (since it doesn't address dynamic linking), but we can lay out some cases that may work, and some that almost certainly won't.</p>

<h2>Should work:</h2>

<ol>
<li>changing a non-inlined function body in base.cpp
<ul>
<li>so long as cross-module/link-time inlining isn't enabled</li>
<li>assuming the derived class doesn't depends only on the interface and not on changed <em>behaviour</em> </li>
</ul></li>
<li>adding static or non-virtual methods
<ul>
<li>beware of changing overload resolution though</li>
</ul></li>
</ol>

<h2>Likely to fail horribly:</h2>

<ol>
<li>changing the prototype of any method <em>or constructor</em> used in the derived class
<ul>
<li>this includes changes that wouldn't normally be visible in calling code (such as adding defaulted arguments) or changing the type of an argument even where there is an implicit conversion, etc.</li>
</ul></li>
<li>adding, removing or re-ordering virtual methods</li>
<li>adding, removing or re-ordering data members or base classes</li>
</ol>

<hr>

<p>There are several assumptions underlying these:</p>

<ol>
<li>your base class and derived class are in separate dynamic libs (eg. base.so and derived.so). This isn't clear from your question</li>
<li>the only reasons for runtime compatibility to break are
<ul>
<li>because the layout in memory changed (ie, you modified the base-class instance size, or the vtable size, or the size or order of members)</li>
<li>because the code that <em>would</em> be generated at a call site changed (ie, because you added arguments with default values, or changed an argument to an implicitly-convertible type)</li>
</ul></li>
</ol>

<p>If the first assumption isn't true, the question seems pointless, since you'll have to rebuild the whole lib anyway.</p>

<p>The second assumption could be broken if you change or upgrade your compiler, or change the compiler flags, or the version of any other library you link against.</p>

<p>With respect to inlining, you can get horribly subtle bugs if different dynamic libs have inlined different versions of the code. You really won't enjoy trying to debug those.</p>
",0
17867189,17867151,4,"<p>You are using single <code>=</code> in comparison statement: <code>while(number = x)</code> which is wrong. use <code>==</code> in comparison</p>

<p>Do it like:</p>

<pre><code>while(number == x)  //note ==
             ^^
</code></pre>

<p>Other thing to note is that you are using <code>while</code> 2 times that's logically not good and using <code>!infile.eof()</code> is also not good as you may not get expected results (1 more than original)</p>

<p>Try this code:</p>

<pre><code>int number;

while (true) {

    infile &gt;&gt; number;
    if( infile.eof() )      //This line will help in avoiding processing last value twice 
      break;

    if (number == x)
    {
        sum1++;
        cout &lt;&lt; sum1++ &lt;&lt; "" "" ;
    }
}
</code></pre>
",6
17867195,17867151,3,"<p>Do this:</p>

<pre><code>// ...
int number;
infile &gt;&gt; number;
while(!infile.eof())
{
    if (number == x)
    {
        sum1++;
    }
    infile &gt;&gt; number;
}
cout &lt;&lt; sum1;
</code></pre>
",2
18106462,18105523,5,"<p><strong>Giving virtual functions default argument initializers tends to defeat polymorphism and introduce unnecessary complexity into a class hierarchy.</strong></p>

<p>consider the following non compliant code</p>

<pre><code>class Thing {
  public:
    virtual ~Thing();
    virtual void doItNTimes( int numTimes = 10 );
    virtual void doItThisHigh( double howHigh = 1.0 );
    // ...
};
class MyThing : public Thing {
  public:
    void doItNTimes( int numTimes );
    void doItThisHigh( double howHigh = 2.2 );
    // ...
};
</code></pre>

<p>A default initializer is not part of the type of a function signature and <em>does not participate in overriding or hiding.</em> Therefore both of the base class virtual functions shown in this Non-Compliant Code Example are overridden in the derived class. However, the differences in the status of default argument initializers in the base class and derived class interfaces causes differences in behavior <strong>depending on which interface is used to access an object.</strong></p>

<pre><code>MyThing *mt = new MyThing;
Thing *t = mt;
t-&gt;doItNTimes(); // default of 10
mt-&gt;doItNTimes();  // compile time error!
t-&gt;doItThisHigh(); // default of 1.0!
mt-&gt;doItThisHigh(); // default of 2.2
</code></pre>

<p>In this piece of code, the intention of the designer of the MyThing class is not clear. Presumably, it is important that the default value to doItThisHigh for an object of type MyThing be 2.2. <strong><em>However, it is not clear whether that value should also be used by default when a MyThing is manipulated through its Thing interface.</em></strong></p>

<p>For more details Please refer the below link <a href=""https://www.securecoding.cert.org/confluence/display/cplusplus/OOP04-CPP.+Prefer+not+to+give+virtual+functions+default+argument+initializers"" rel=""noreferrer"">https://www.securecoding.cert.org/confluence/display/cplusplus/OOP04-CPP.+Prefer+not+to+give+virtual+functions+default+argument+initializers</a></p>
",0
18192053,18192012,9,"<p>Make the <code>Create</code> method a template?</p>

<pre><code>template&lt;typename T&gt;
T* Create(const std::string&amp; name) const
{
    return new T;  // Or what you want to do
}
</code></pre>

<p>Then you can do e.g</p>

<pre><code>auto o = Factory-&gt;Create&lt;MyObject&gt;(""MyObject"");
</code></pre>
",3
18192142,18192012,2,"<p>You can.</p>

<pre><code>struct sInstantiationProxy
{
private:
    void* Obj;
    sInstantiationProxy( void* O ): Obj( O ) {};
public:
    template&lt;typename T&gt; operator T()
    {
        return reinterpret_cast&lt;T&gt;( Obj );
    }
};
</code></pre>

<p>And later:</p>

<pre><code>sInstantiationProxy Create( const std::string&amp; ClassName ) const
{
    return sInstantiationProxy( Factory-&gt;Create( ClassName ) );
};
</code></pre>

<p>Now you can use global <code>Create()</code> function without <code>dynamic_cast</code>:</p>

<pre><code>MyObject* O = Create( ""MyObject"" );
</code></pre>
",4
18192270,18192012,2,"<p>Make it return a helper object with a templatized type conversion operator.</p>

<pre><code>class Helper
{
  void* obj;
public:
  template &lt;class T&gt; operator T()
  {
    return reinterpret_cast&lt;T&gt;(obj);
  }
  .... Constructors etc
};
</code></pre>

<p>For added bonus, make it contain the typeid of the object, and check that it matches that of T.</p>
",0
13787209,13787087,2,"<pre><code>struct SomeName* SomeOtherName();
</code></pre>

<p>This is a function <code>SomeOtherName()</code> returning a pointer <code>*</code> to a <code>struct SomeName</code>.</p>

<p>See also <a href=""http://www.codeproject.com/Articles/7042/How-to-interpret-complex-C-C-declarations"" rel=""nofollow"">How to interpret complex C/C++ declarations</a> or <a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow"">The ``Clockwise/Spiral Rule''</a>.</p>
",0
13787096,13787087,8,"<blockquote>
  <p>or is this a function declaration that is going to return a struct? (Rather, return a pointer to a struct)</p>
</blockquote>

<p>Yep, this one.</p>
",0
18304809,18301753,1,"<p>I would suggest moving the static variable out of the global namespace and into the class as a static class member.  Here is an example:</p>

<pre><code>// test.hpp

#ifndef TEST_HPP
#define TEST_HPP

class Test
{
public:
    // Constructor: Assign this to TestPointer
    Test(void) { TestPointer = this; }

    // This is just a definition
    static Test* TestPointer;

private:
    unsigned m_unNormalMemberVariable;
};

#endif /* #ifndef TEST_HPP */
</code></pre>

<p>The above code will not work by itself, you need to declare the actual memory of the static member variable (just like you would for a member function).</p>

<pre><code>// test.cpp

#include ""test.hpp""

#include &lt;iostream&gt;

// The actual pointer is declared here
Test* Test::TestPointer = NULL;

int main(int argc, char** argv)
{
    Test myTest;

    std::cout &lt;&lt; ""Created Test Instance"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""myTest Pointer:  "" &lt;&lt; &amp;myTest &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Static Member:   "" &lt;&lt; Test::TestPointer &lt;&lt; std::endl;

    Test myTest2;

    std::cout &lt;&lt; ""Created Second Test Instance"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""myTest2 Pointer: "" &lt;&lt; &amp;myTest2 &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Static Member:   "" &lt;&lt; Test::TestPointer &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>The static member can be access from any file, not just the file containing the line <code>Test* Test::TestPointer = NULL;</code>.  To access the contents of the static pointer, use <code>Test::TestPointer</code>.</p>
",0
18241161,18240927,3,"<p>Try to rename your </p>

<blockquote>
  <p>string insert</p>
</blockquote>

<p>To something like</p>

<blockquote>
  <p>string strInsert</p>
</blockquote>

<p>This is because you shouldn't use the same name for both a variable and a function!</p>
",2
