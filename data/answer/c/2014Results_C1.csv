24644150,24643844,4,"<p>This version of <code>std::move</code> is: </p>

<pre><code>template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator move(InputIterator first, InputIterator last,
    OutputIterator result);
</code></pre>

<p><code>OutputIterator</code> properties are defined by [output.iterators], in particular the following expression must be valid:</p>

<pre><code>*r = o
</code></pre>

<p>where <code>r</code> is the output iterator. </p>

<p>Based on the error messages shown by Coliru, it appears as if the library is checking <code>std::is_copy_assignable&lt;element&gt;</code>, which is of course false.   </p>

<p>This appears to be a bug; the move ought to work using the move-assignment operator.</p>

<p>Compare the following in the same Coliru:</p>

<pre><code>int main() {
    std::vector&lt;element&gt; e(1);
    std::vector&lt;element&gt; d(1);

    *e.begin() = std::move( *d.begin() );       // A=1 OK   A=0 OK
    std::move(d.begin(), d.end(), e.begin());   // A=1 OK   A=0 errors
}
</code></pre>

<p>The definition of <code>std::move</code> (3 arguments) includes that for each index it performs <code>*(result + n) = std::move( *(first + n) );</code> . So if my first line is valid then my second line should also be valid.</p>
",2
22445314,22445281,1,"<p>The asterisk after a name of a type produces a name of a pointer type based on the type in front of the asterisk.</p>

<p>In your case, <code>CanonEOS*</code> is the name of a pointer to <code>CanonEOS</code> type.</p>

<p>Overall, the expression that you posted</p>

<ul>
<li>Takes <code>ptp</code> pointer, and re-interprets it as a pointer to <code>CanonEOS</code></li>
<li>Calls a method <code>SwitchLiveView</code> on the <code>CanonEOS</code> instance pointed to by <code>ptp</code>, passing it <code>true</code> as the parameter.</li>
</ul>
",0
25464903,25464788,2,"<p>They are not equivalent. The first one leaves <code>t</code> <strong>uninitialized</strong> if it's a POD type, whereas the latter two will value-initialize the object no matter what. Example:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    int a = int();

    cout &lt;&lt; a &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>results in:</p>

<pre><code>$ clang++ -O2 -o init init.cpp
$ ./init
0
</code></pre>

<p>whereas this:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    int a;

    cout &lt;&lt; a &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>will output some garbage (or crash, or make demons fly out of your nose) since it has undefined behavior arising out of the uninitialized object:</p>

<pre><code>$ clang++ -O2 -o init init.cpp
$ ./init
1348959264
</code></pre>

<hr>

<p>As to the question of copy constructors and assignment operators: the second and third snippets may invoke one of them (or may not, thanks to copy elision), so either of them (or both) need to be available.</p>
",17
31250348,31250090,1,"<ol>
<li><p>If you are using Visual Studio - right click at the nameoffile - Find All References.</p></li>
<li><p>You can also search for the ""#include ""nameoffile.cpp"""" string at your solution</p></li>
</ol>

<p>I think that the best soultion might be to remove the library and then compile and fix the error</p>
",1
24125125,24119741,6,"<p><a href=""http://refspecs.linuxbase.org/abi-eh-1.21.html#base-data"" rel=""noreferrer"">Section 1.2 in chapter 4</a> says:</p>

<blockquote>
  <p>The unwind interface uses a pointer to an exception header object as its representation of an exception being thrown. In general, the full representation of an exception object is language- and implementation-specific, but it will be prefixed by a header understood by the unwind interface, defined as follows:</p>
</blockquote>

<p>followed by a definition of <code>struct _Unwind_Exception</code>, followed by:</p>

<blockquote>
  <p>An <code>_Unwind_Exception</code> object must be double-word aligned.</p>
</blockquote>

<p>As this is a <em>prefix</em> to the exception object at large, the entire block of memory must be double-word aligned.</p>

<p>Arguably this text does not prohibit arbitrary padding found <em>before</em> the <code>_Unwind_Exception</code>, but if this is taken to be the case then the answer is that there is no alignment guarantee whatsoever; I choose to interpret this as a minor wording defect instead.</p>
",0
26792114,26792002,3,"<p>You need to call <code>va_start</code> in your variadic function. Same for <code>va_end</code>:</p>

<pre><code>void foo (const char * str, va_list args )
{
    /* ... */
}

void foo (const char * str, ... )
{
    va_list args;

    va_start( args, str );
    foo( str, args );
    va_end( args );
}
</code></pre>
",0
26792120,26792002,1,"<p>This code causes undefined behaviour as you have used <code>args</code> uninitialized in <code>foo</code>. The correct way is:</p>

<pre><code>void foo(const char *str, va_list args) {
  //do something
}

void foo(const char *str, ...) {
  va_list args;
  va_start(args, str);
  foo(str, args);
  va_end(args);
}
</code></pre>
",0
30404631,30404587,3,"<blockquote>
  <p>before passing it to a function as a void* it is 12. Once it gets in the function it is 4</p>
</blockquote>

<p>Because sizeof pointer in case of your program is 4 bytes, you cant read sizeof struct if you cast instance of your struct to void*. You might fix it by passing to your function also size of your struct ie <code>foo(static_cast&lt;void*&gt;(&amp;myStructObj), sizeof(TypeOfMyStruct))</code>.</p>

<p>[edit]</p>

<p>also as Lightness Races in Orbit pointed out in his answer, serializing std::list is wrong, you will only write pointers to your file/</p>
",0
30404664,30404587,0,"<p>This is correct.</p>

<p>A pointer always contains an address, which is 4 bytes on your machine.</p>

<p>Therefore a sizeof any pointer will be 4 bytes on a 32-bit addressing architecture.</p>
",0
30404667,30404587,2,"<p>The size of a pointer is 4 bytes (or 8 if you were using an x64 compiler). If <code>writeData</code> needs to know the size of the pointed-to object, that information will need to be passed to it somehow; a common idiom is to pass the size as a second argument. With that done, you could use a helper function template to simplify things:</p>

<pre><code>template&lt;typename T&gt;
void writeData(Client&amp; client, const T&amp; obj)
{
   client.writeData((void*)&amp;obj, sizeof(obj));
}
</code></pre>

<p>Although as molbdnilo noted in the question comments, <code>client.writeData()</code> probably still won't be able to do what you want it to due to the presence of a <code>list</code> in <code>dataPacketDef</code>.</p>
",1
30404668,30404587,0,"<p>sizeof(void*) is 4 bytes on a 32bit machine.</p>
",0
30404931,30404587,3,"<p>In the function you are taking the size of a <code>void*</code>, not of a <code>dataPacketDef</code>. And, apparently, on your system <code>sizeof(void*)</code> is 4 bytes. The <code>sizeof</code> operator is simply type-driven: it does not do magical inspection of pointees. In fact, since you have performed type erasure with that antiquated cast, it <em>can't</em>.</p>

<p>You cannot serialise your object in this way. The list isn't flat data; its elements aren't actually part of the <code>dataPacketDef</code>, but dynamically allocated. The list holds pointers to those elements. All you're doing is serialising pointers, which become immediately meaningless on the target system.</p>

<p>Drop this approach entirely and look into how to properly serialise objects in modern C++.</p>
",0
27132945,27132831,2,"<p>'+' operation is only provided for <em>Random access iterators</em>. And <code>std::set</code> doesn't use <em>Random access iterators</em>.</p>
",0
27132951,27132831,3,"<p><code>std::set</code>'s iterators are <a href=""http://en.cppreference.com/w/cpp/concept/BidirectionalIterator"" rel=""nofollow"">bidirectional iterators</a>, because internally sets are node-base structures. Applying an offset with <code>+</code> would be O(N) for this kind of structure, so its iterators don't directly support that. This operation is supported for random access iterators, for which it is O(1).</p>
",18
34181752,34181616,5,"<p>Is ""because the standard says so"" a valid answer for you?</p>

<p><code>static_cast&lt;T&gt;(e)</code> has the same effect as <code>T t(e);</code> with <code>t</code> being the result of the cast. This follows the rules for <em>direct-initialization</em>, which considers applicable constructors through overload resolution before it considers user-defined conversion sequences.</p>

<p>I can provide the relevant standards quotes if that would put your mind at ease.</p>
",0
23061913,23051600,0,"<p>This implementation of <code>remove</code> seems to work</p>

<pre><code>template&lt;class T&gt;
void remove(std::vector&lt;T&gt;&amp; v, size_t i) {
    uint8_t d[sizeof T];
    memcpy(d, &amp;v[i], sizeof T);
    v[i] = v.back();
    memcpy(&amp;v.back(), d, sizeof T);
    v.pop_back();
}
</code></pre>

<p>Comments on this code will be very appreciated.</p>
",0
28528813,28528784,4,"<p>If <code>Parent</code> has any <strong>instances</strong> of <code>Child</code>, yes you must include the header to <code>Child.hpp</code>.</p>
<pre><code>class Parent {
    public:
        Parent();
        Parent(Child child);     // Need full include, complete type used
        Child c;                 // Need full include, complete type used
};
</code></pre>
<p>If <code>Parent</code> only had <strong>pointers</strong> or <strong>references</strong> to <code>Child</code> you could get away with simply <a href=""https://stackoverflow.com/questions/4757565/c-forward-declaration"">forward-declaring</a> <code>Child</code>, then doing the include in <code>Parent.cpp</code>.</p>
<pre><code>class Child;                     // Forward declaration
class Parent {
    public:
        Parent();
        Parent(Child* child);    
        Child* pc;               // Incomplete type ok if pointer or reference
};
</code></pre>
<p>In general, you should avoid including headers inside other headers unless absolutely necessary. At best, it increases build times unnecessarily. At worst, it can lead to circular dependencies.</p>
",4
26446483,26446306,1,"<p>You only need to re-declare static variables. If you make a variable in the class definition without making them static, you can just leave them there. Example:</p>

<p>foo.h</p>

<pre><code>#ifndef _FOO_H_
#define _FOO_H_

class Foo{
private:
  static int i; //Static variable shared among all instances
  int o; //Non-static variable remains unique among all instances
public:
  Foo(); //Consructor
};

#endif
</code></pre>

<p>foo.cpp</p>

<pre><code>int Foo::i = 0; //Only static variables can be initialized when in a class
//No definition required for non-statics

Foo::Foo(){
  //Constructor code here
  i = 0;
};
</code></pre>

<p>The #ifndef block prevents the header from accidentally being included multiple times by the same source file. This is in case a header is included in another header, which, if these blocks are not present, could result in an infinite include loop and force the compiler to quit when it counts an include depth that's too high.</p>
",1
22112663,22112626,3,"<p>Take a closer look at the following two statements:</p>

<pre><code>char aChar = path.at(n);
tempo.append(&amp;aChar);
</code></pre>

<p>Apparently, you are trying to append a <code>char</code> to a <code>std::string</code>. However, you are actually append a NUL terminated string to <code>tempo</code>.</p>

<p>Replace the code with:</p>

<pre><code>char aChar = path.at(n);
tempo += aChar;
</code></pre>

<p>or:</p>

<pre><code>char aChar = path.at(n);
tempo.push_back(aChar);
</code></pre>
",1
23059114,23058973,6,"<p>You declared <code>Product  products[4]</code> on the stack, so it will be released when outscoping (leaving the function)</p>

<pre><code>Product  products[4] = { *product1, * product2,  *product3, *product4};
AllInput* all = new AllInput(4, products);
</code></pre>

<p>When constructing the dymamicly allocated <code>AllInput</code>, if you don't copy the products into internal members of <code>AllInputs</code>, when leaving the function <code>in1</code>, <code>products</code> will be freed and the pointer saved in <code>AllInput</code> will point to junk.</p>

<p>So create a dynamic allocation for <code>products</code> too, or copy all the data (the array of pointers) in <code>AllInput</code>.</p>
",0
28161401,28161133,2,"<p>First, the answer to the underlying question is very simple: C++ implements dynamic dispatching via <code>virtual</code> functions.</p>

<p>To go over your examples:</p>

<p><code>Unvirtual</code> and <code>UnvirtualUnoverride</code> are a case of <a href=""http://en.wikipedia.org/wiki/Variable_shadowing"" rel=""nofollow noreferrer"">shadowing</a>, where <code>UnvirtualUnoverride::greet</code> shadows <code>Unvirtual::greet</code> and thus is chosen if the type of the object it is being called on is <code>UnvirtualUnoverride</code>. As you have correctly concluded from your tests, the dispatch is not dynamic at all.</p>

<p><code>VirtualUnoverride</code> and <code>VirtualOverride</code> do not actually do anything different from one another w.r.t. <code>greet</code>. The reason for this is that <code>override</code> is only an assistance to the programmer that is intended to ensure that a base function is being overriden instead of introducing a new function. For example, if <code>Virtual::greet</code> was changed to <code>string greet() const</code>, the <code>override</code> keyword would make your day: <code>VirtualOverride</code> will stop compilation with an error - <code>VirtualUnoverride</code> will silently add another <em>overload</em> (not <em>override</em>) to that function.</p>

<p>The combination of the previous two paragraphs also explain why you do not have a <code>UnvirtualOverride</code>: It is impossible to override a non-<code>virtual</code> function and thus compilation will be aborted.</p>

<p>To explain why it seems to you as if the object on which the function is called must be a pointer, we have to delve a tiny bit deeper into how your test framework actually works:</p>

<p>The previous should have explained all test cases for the <code>Unvirtual</code> and <code>UnvirtualUnoverride</code> cases. The <code>Virtual</code> cases are also trivial, since all objects, pointers and references only refer to the base class. Since <code>UnvirtualUnoverride</code> and <code>UnvirtualOverride</code> are basically the same, let us just go over one of them:</p>

<pre><code>VirtualOverride vo, &amp;vor = vo, *vop = &amp;vo;
DEBUG(greet(vo));
DEBUG(greet(vor));
DEBUG(greet(vop));
</code></pre>

<p>To understand what really happens, consider that only four of your <code>greet(T)</code> functions exist of which only two could be applicable:</p>

<pre><code>GREETER(Unvirtual, .) // obviously not applicable
GREETER(Unvirtual*, -&gt;) // obviously not applicable
GREETER(Virtual, .)
GREETER(Virtual*, -&gt;)
</code></pre>

<p>Now, to resolve the relevant macros:</p>

<pre><code>string greet(Virtual t) {
    return string(""Virtual"") + t.greet();
}

string greet(Virtual* t) {
    return string(""Virtual*"") + t-&gt;greet();
}
</code></pre>

<p>The pointer version will perform a standard pointer to base type conversion and thus behave as expected.</p>

<p>The other version, however, will make <strong>a copy of your argument</strong>. This means, that you now have a <code>Virtual</code> object that has been constructed from a <code>VirtualOverride</code> object. Since no data members exist, this construction is boring to say the least, but it also means that your actual dispatch happens on an object that has the static <em>and dynamic</em> type of <code>Virtual</code> - no matter which of the objects you pass to the function!</p>

<p>This problem is called <a href=""https://stackoverflow.com/questions/274626/what-is-object-slicing"">object slicing</a> and can be very confusing to people not intimately familiar with C++. In general, you should always ensure that you do not pass polymorphic objects by reference. The easiest way would be to make the <code>Virtual::greet</code> function <a href=""https://stackoverflow.com/questions/1306778/c-virtual-pure-virtual-explained"">pure virtual</a>, thus transforming <code>Virtual</code> into an abstract class.</p>
",2
28161408,28161133,1,"<p>Dynamic dispatch occurs regardless of whether you're using a pointer or a reference. references too. In fact, don't forget that unless <code>operator-&gt;</code> is overloaded, <code>o-&gt;m()</code> is identical to <code>(*o).m()</code>. Therefore if dynamic dispatch occurs in one case, it must occur in the other.</p>

<p>As far as I know, dynamic dispatch when calling a virtual function is only disabled in the following two cases:</p>

<ol>
<li>You <strong>explicitly qualify</strong> the function to be called using the class in which it is defined. <code>o-&gt;Base::m()</code> is guaranteed to dispatch statically and call <code>Base::m</code> and not <code>Derived::m</code>, as opposed to <code>o-&gt;m()</code> which dispatches dynamically.</li>
<li>An object is currently in the process of <strong>construction</strong> or <strong>destruction</strong> and the virtual function is called <strong>on that object itself</strong> (not another object of the same class, or an object of a different class). In this case the function that will be called is the final overrider in the class to which the constructor or destructor belongs, not the final overrider in the class of the complete object under construction or destruction.</li>
</ol>

<p>These are the only exceptions I'm aware of, but there are also cases where dynamic dispatch occurs but you might not realize it. There's the slicing problem, as pointed out by others. There are also cases in which the function in the derived class has the same name as one in the base class, but different parameter types; in this case, the former doesn't overload the latter, so dynamic dispatch on that function is trivial.</p>
",0
32472379,32472265,2,"<p>It looks like <code>OneWire</code> doesn't have non-parametric constructor, which is tried to be called at <code>TempLogger</code> initialization step. You can either write a non-parametric constructor or even better call the parametric one in initialization list:</p>

<pre><code>TempLogger::TempLogger(int x):pin(x),thermo(x){}
</code></pre>

<p>In your code, you are declaring another variable called <code>thermo</code> thus hiding your class-member variable.</p>
",2
32472484,32472265,-1,"<p>One thing you are definitely doing wrong is in the constructor </p>

<pre><code>TempLogger::TempLogger(int x) {
    pin = x;
    OneWire thermo(pin);      //This creates a local object inside the constructor which gets deleted directly after this statement  
}
</code></pre>

<p>You might want to do this instead :-</p>

<pre><code>class TempLogger {
private:
    int pin;
    OneWire *thermo;

public:
    TempLogger(int);
    float read();
};

TempLogger::TempLogger(int x) {
    pin = x;
    thermo = new OneWire(pin);
}
</code></pre>
",4
34274922,34274861,8,"<p>The reason this is the case is because <code>arr[n]</code> == <code>*(arr + n)</code>.</p>

<p>However, because addition is commutative, <code>*(arr + n)</code> == <code>*(n + arr)</code>. Thus, <code>*(n + arr)</code> == <code>n[arr]</code> == <code>*(arr + n)</code> == <code>arr[n]</code>.</p>

<p>It might be worth mentioning that <code>*(arr + n)</code> is still a little misleading. In assembly it actually means <code>*(arr + (n * s))</code> where <code>s</code> is <code>sizeof arr[0]</code>, but this is under the covers so you don't need to worry about it.</p>
",1
34274996,34274861,3,"<p>I don't think this particular [ab-]use of the rules for pointer arithmetic has any particular name. It is simply falling out of the way pointer arithmetic is defined in C and C++. Neither of the two language standards makes any special attempt to prevent the reversal of the subscript and the pointer. For example, the relevant C++ rule is in 5.2.1 [expr.sub] paragraph 1:</p>

<blockquote>
  <p>A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type ¡°array of T¡± or ¡°pointer to T¡± and the other shall have unscoped enumeration or integral type. The result is of type ¡°T.¡± The type ¡°T¡± shall be a completely-defined object type. The expression E1[E2] is identical (by definition) to *((E1)+(E2)) [ Note: see 5.3 and 5.7 for details of * and + and 8.3.4 for details of arrays. ¡ªend note ], except that in the case of an array operand, the result is an lvalue if that operand is an lvalue and an xvalue otherwise.</p>
</blockquote>

<p>It <em>may</em> work to look for ""C++ 5.2.1"" or ""C++ [expr.sub]"" but the use of the reversal isn't that large beyond confusing people who haven't look long enough at C or C++.</p>
",0
29498437,29498259,1,"<p>The definition of LPCTSTR depends on whether UTF-16 unicode is enabled as default character type or not.  </p>

<p>THis has an impact on litterals:  </p>

<ul>
<li><code>""xxx""</code>  can be used if no unicode is used.  </li>
<li><code>L""xxx""</code> is to be used if unicode is used</li>
</ul>

<p>You can find more on the types to be used <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407%28v=vs.85%29.aspx"" rel=""nofollow"">here</a>. </p>
",1
31840786,31840651,6,"<p>In this declaration</p>

<pre><code>int *arr = new int[10];
</code></pre>

<p>pointer arr is initialized by the address of the first element of the dynamically allocated array.</p>

<p>In the while loop</p>

<pre><code>while (i &lt; 10){
    *arr = i;  // assign the value of arr to i
    arr++;     // increment the pointer by 1
    i++;       // increment i
}
</code></pre>

<p>the pointer is incremented. </p>

<pre><code>arr++;
</code></pre>

<p>So after the loop it points beyond the allocated array and this statement</p>

<pre><code>delete[] arr;
</code></pre>

<p>is wrong because pointer <code>arr</code> does not now store the original addres of the allocated array.</p>

<p>I think you mean the following</p>

<pre><code>const int N = 10;
int *arr = new int[N];

int i = 0;
for ( int *p = arr; p != arr + N; ++p ){
    *p = i++;  // assign the value of i to *p
}

for ( int *p = arr; p != arr + N; ++p ) std::cout &lt;&lt; *p &lt;&lt; ' ';
std::cout &lt;&lt; std::endl;

delete[] arr; 
</code></pre>
",4
24092207,24091979,6,"<p>It is so-called the new placement operator. it constructs an object at address specified by the expression in parentheses. For example the copy assignment operator can be defined the following way</p>

<pre><code>const C&amp; C::operator=( const C&amp; other) {
   if ( this != &amp;other ) {
      this-&gt;~C(); // lifetime of *this ends
      new (this) C(other); // new object of type C created
   }
   return *this;
}
</code></pre>

<p>In this example at first the current object is destroyed using an explicit call of the destructor and then at this address a new object is created using the copy constructor.</p>

<p>That is this new operator does not allocate a new extent of memory. It uses the memory that was already allocated. </p>

<p>This example is taken from the C++ Standard. As for me I would not return a const object. It would be more correctly to declare the operator as</p>

<pre><code>C&amp; C::operator=( const C&amp; other);
</code></pre>
",0
24601895,24601803,3,"<p>If you would like to switch to <code>std::vector</code> that can be constructed on the fly as you have mentioned in the comment to the question, this should work (works with gcc):</p>

<pre><code>void foo(const std::vector&lt;std::string&gt; &amp;stringVec)
{
}

int main()
{
    foo( std::vector&lt;std::string&gt;({""abc"",""def"",""ghi""}));
}
</code></pre>
",1
24602035,24601803,1,"<p>One way to pass multiple values like this {x0,x1,x2,...} would be to use std::initializer_list which was introduced in c++11. Although this way it is not possible to force a constant number of values.</p>

<pre><code>void foo(const std::initializer_list&lt;std::string&gt;&amp; input) {

}

int main() {
    foo({""abc"",""def"",""ghi""});
}
</code></pre>
",0
29532365,29525279,0,"<p>You can use something like this:</p>

<pre><code>std::wstring s2ws(const std::string&amp; s) {
    int slength = (int)s.length() + 1;
    int len = MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, 0, 0); 
    std::wstring r(len, L'\0');
    MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, &amp;r[0], len);
    r.resize(r.size() - 1);
    return r;
}
</code></pre>
",0
29532467,29525279,0,"<p>Use <code>mbstowcs</code></p>

<pre><code>size_t mbstowcs (wchar_t* dest, const char* src, size_t max);
</code></pre>

<p>Converts multibyte string to wide-character string. It translates the multibyte sequence pointed by src to the equivalent sequence of wide-characters (which is stored in the array pointed by dest), up until either max wide characters have been translated or until a null character is encountered in the multibyte sequence src (which is also translated and stored, but not counted in the length returned by the function).</p>

<p>If max characters are successfully translated, the resulting string stored in dest is not null-terminated.</p>

<p>The behavior of this function depends on the LC_CTYPE category of the selected C locale.</p>
",0
26248133,26248120,5,"<p>Dereferencing the iterator gives you a key-value pair, <code>std::pair&lt;key_type, mapped_type&gt;</code>.</p>

<p>So to get the key from the iterator, get the first element of the pair:</p>

<pre><code>key_type key = it-&gt;first;
</code></pre>
",0
24110890,24110859,1,"<p>Use <a href=""http://en.cppreference.com/w/cpp/io/manip/fixed"" rel=""nofollow"">std::fixed</a></p>

<pre><code>std::cout &lt;&lt; std::fixed &lt;&lt; sss[j]-&gt;stocks &lt;&lt; std::endl;
</code></pre>

<p>And btw the ""<em>e</em>"" comes from the so called <em>scientific</em>-notation.</p>
",0
22853949,22852578,1,"<p><code>Poop</code> does not derive from <code>Foo</code>, so you cannot pass a <code>Poop*</code> where a <code>Foo*</code> is expected, and vice versa.  <code>Poop</code> and <code>Foo</code> both derive from <code>IFoo</code> so you need to instead change <code>setFoo()</code> to accept an <code>IFoo*</code> instead of a <code>Foo*</code>:</p>

<pre><code>void setFoo(IFoo* foo){/*impl*/}
</code></pre>
",0
33824054,33823356,1,"<p>The ""freak out"" option is simple: <code>throw std::invalid_argument</code>. It doesn't matter that throwing is a bit slow; you're not getting an answer anyway. The upside is that not throwing is fast as the optimizer can assume the non-exception paths are far more likely.</p>

<p>Performance-wise it might be beneficial to have a <code>IntermediateResult</code> class such that only the final assignment back to <code>Probability</code> is range-checked. This sidesteps the <code>0.75+0.5-0.6</code> example.</p>
",0
33824060,33823356,2,"<p>You can use the class <code>Probability</code> to enforce the bounds, storing a double internally. If you want operations such as <code>P(0.75) + P(0.5) - P(0.6)</code> to work, you can have the operators return a proxy object, which doesn't do the bounds checking. This proxy object would have a conversion operator to <code>Probability</code>, and the <code>Probability</code> constructor would check the bounds. If you only ever use the <code>Probability</code> type directly, and allow temporaries of the form <code>ProbabilityResultProxy</code>, you'll get the desired behaviour.</p>

<p>The example below outlines this approach. Obviously there's quite a lot missing that you'd want in a real implementation, but I wanted to focus on a specific solution, rather than providing a complete class.</p>

<p><a href=""http://coliru.stacked-crooked.com/a/bebb708d70493720"" rel=""nofollow"">Live example</a>:</p>

<pre><code>#include &lt;iostream&gt;

class Probability {
  public:

    Probability(double value) {
        if (value &lt; 0 || value &gt; 1) throw std::runtime_error(""Invalid probability"");
        value_ = value;
    }

    double value() const { return value_; }

  private:
    double value_;
};

class ProbabilityResultProxy {
  public:
    explicit ProbabilityResultProxy(double p) : value_(p) {}

    double value() const { return value_; }

    operator Probability() {
        return Probability(value_);
    }

  private:
    double value_;
};

ProbabilityResultProxy operator+(const Probability&amp; lhs, const Probability&amp; rhs) {
    return ProbabilityResultProxy(lhs.value() + rhs.value());
}
ProbabilityResultProxy operator+(const ProbabilityResultProxy&amp; lhs, const Probability&amp; rhs) {
    return ProbabilityResultProxy(lhs.value() + rhs.value());
}
ProbabilityResultProxy operator+(const Probability&amp; lhs, const ProbabilityResultProxy&amp; rhs) {
    return ProbabilityResultProxy(lhs.value() + rhs.value());
}
ProbabilityResultProxy operator+(const ProbabilityResultProxy&amp; lhs, const ProbabilityResultProxy&amp; rhs) {
    return ProbabilityResultProxy(lhs.value() + rhs.value());
}

ProbabilityResultProxy operator-(const Probability&amp; lhs, const Probability&amp; rhs) {
    return ProbabilityResultProxy(lhs.value() - rhs.value());
}
ProbabilityResultProxy operator-(const ProbabilityResultProxy&amp; lhs, const Probability&amp; rhs) {
    return ProbabilityResultProxy(lhs.value() - rhs.value());
}
ProbabilityResultProxy operator-(const Probability&amp; lhs, const ProbabilityResultProxy&amp; rhs) {
    return ProbabilityResultProxy(lhs.value() - rhs.value());
}
ProbabilityResultProxy operator-(const ProbabilityResultProxy&amp; lhs, const ProbabilityResultProxy&amp; rhs) {
    return ProbabilityResultProxy(lhs.value() - rhs.value());
}

int main() {
    Probability p1(0.75);
    Probability p2(0.5);
    Probability p3(0.6);

    Probability result = p1 + p2 - p3;
    std::cout &lt;&lt; result.value() &lt;&lt; ""\n"";

    try {
        Probability result2 = p1 + p2;
        std::cout &lt;&lt; result2.value();
    } catch (const std::runtime_error&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; ""\n"";
    }

    return 0;
}
</code></pre>

<p>Here, the mathematical operators are defined for each combination of <code>Probability</code> and <code>ProbabilityResultProxy</code>. Each operation returns a proxy object, and the final assignment causes the bounds check to be performed.</p>

<hr>

<p>If you want, you could make the <code>ProbabilityResultProxy</code> a private member class of <code>Probability</code>, and make the operators friends of <code>Probability</code>. This prevents anyone from instantiating the proxy class directly.</p>
",1
22494710,22494665,1,"<p>That is a bad way to use the ternary operator (there are worse ways, but that one is bad). You should use:</p>

<pre><code>a = (a == 4) ? b : 5;
</code></pre>

<p>The difference is that this is clearly an assignment to <code>a</code> and the ternary operator determines the value to assign.  In your version, you have to look at the insides of the ternary operator to see that it is assigning to <code>a</code> in both branches.  (One of the worse ways of using the ternary operator would be <code>(a == 4) ? a = b : b = 5;</code> assigning to two different variables.)</p>

<p>If you feel the need to write nested ternary operators, then you're probably using it inappropriately, too.  Occasionally it will be OK, but not very often.</p>
",0
22494719,22494665,3,"<p>Actually you should write</p>

<pre><code>a = (a == 4) ? b : 5;
</code></pre>

<p>And that discussion about ternary ops has always seemed quite sterile to me - a couple of good insights can be found <a href=""https://softwareengineering.stackexchange.com/questions/28314/ternary-operator-considered-harmful"">here</a> (TL;DR OP's example:</p>

<pre><code>return (a&lt;b) ? (b&lt;c) ? b : (a&lt;c) ? c : a : (a&lt;c) ? a : (b&lt;c) ? c : b;
</code></pre>

<p>is probably a case where using the ternary operation is not a good idea, in cases like yours it contributes to readability if you ask me).</p>
",0
22494721,22494665,6,"<p>The conditional operators is useful for forming <em>expressions</em>. Use it when you need an expression which depends, well, on a condition. Don't use it to make <em>statements</em>. For example, your code could be a statement:</p>

<pre><code>if (a == 4) { a = b; }
else        { a = 5; }
</code></pre>

<p>Or you could write it with a conditional expression, but idiomatically like this:</p>

<pre><code>a = (a == 4 ? b : 5);
</code></pre>
",0
22494947,22494665,0,"<p>The ?: operator can be used as a shortcut for an if...else statement. It is typically used as part of a larger expression where an if...else statement would be awkward. </p>

<p>For example: </p>

<pre><code>time_t t = time(0);
now = localtime( &amp; t );
greeting = ""Good"" + ((now-&gt;tm_hour &gt; 17) ? "" evening."" : "" day."");
</code></pre>

<p>copied from: <a href=""http://msdn.microsoft.com/en-us/library/be21c7hw%28v=vs.94%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/be21c7hw%28v=vs.94%29.aspx</a></p>
",0
22435938,22435707,0,"<p>Use always double, it is recommended everywhere, if you don't have huge arrays in your program. This is a thing that I learned in programming competitions and because of which I failed many times previously because of precision problems.</p>
",4
22436057,22435707,0,"<p>It is not clear what you want to do. As @thecoder suggested the simplest option is to just use double. To convert it to float you just assign it:</p>

<pre><code>double d = 0.1;
float f = d;
</code></pre>

<p>However, if you need to write code that must work both for float and double, use a template:</p>

<pre><code>template&lt;NumberT&gt;
NumberT sum(NumberT first, NumberT second) {
  return first + second;
}
</code></pre>
",0
23603575,23603330,1,"<p>You are using a C++11 feature, so you have to either use the compile flag</p>

<pre><code>-std=c++11
</code></pre>

<p>or</p>

<pre><code>-std=c++0x
</code></pre>

<p>for the second problem you are probably missing some header or do have an issue with the code.</p>

<p>edit: issorted does probably refer to <a href=""http://www.cplusplus.com/reference/algorithm/is_sorted/"" rel=""nofollow""><code>std::is_sorted</code></a>. It is to be found in the include <code>#include &lt;algorithm&gt;</code></p>
",0
23605107,23603330,0,"<p>Replace <code>issorted</code> by <code>std::is_sorted</code>.<br>
(Add <code>#include &lt;algorithm&gt;</code> if not present)<br>
(Compile with C++11)</p>
",0
25545372,25545148,3,"<p>Using virtual functions is better solution to this problem:</p>

<pre><code>#include &lt;cassert&gt;

class PureVirtual {
    int m_count;
public:
    virtual int max() = 0;
    void register_() {
        assert(m_count + 1 &lt;= max());
        m_count++;
    };
};

class A : public PureVirtual {
public:
    int max() {
        return 42;
    }
};

int main() {
    A a;
    for (int i = 0; i &lt; 43; ++i) {
        a.register_();
    }
}
</code></pre>

<p><code>max</code> can be made protected if it is meant to be hidden. To change the value of max, just override it in the derived class. The advantage of this solution is that max will never have a nonsense solution, and you avoid templates.</p>
",4
25545221,25545148,8,"<p>Define <code>m_max</code> member in <code>PureVirtual</code>:</p>

<pre><code>const unsigned m_max;
</code></pre>

<p>initialise it in <code>PureVirtual</code> constructor:</p>

<pre><code>PureVirtual(unsigned max) : m_max(max) {}
</code></pre>

<p>and pass the value you want from the constructor of inherited class:</p>

<pre><code>A() : PureVirtual(42) {}
</code></pre>
",0
25545228,25545148,4,"<p>Your design is broken, because the base class requires information stored in the descendant class. Try using policies or containment instead:</p>

<pre><code>template &lt;typename Policy&gt;
class PureVirtual 
{
    enum { MAX = Policy::MAX };
    unsigned m_count;  // = 0 in constructor
    void register() {assert(m_count + 1 &lt;= MAX); m_count++;};
};
</code></pre>
",1
21597645,21597628,12,"<p>You are passing the <code>intHolder</code> by value. This means the function acts on a local copy, so there is no effect on the caller side. You need to pass a reference:</p>

<pre><code>void addToOtherInt(intHolder&amp; other) { other.addToInt(i); }
                            ^
</code></pre>

<p>Note that usually when you have types that hold other types that support arithmetic operations, you provide overloaded operators so you can do things like</p>

<pre><code>intHolder a = 5;
intHolder b = 10;
intHolder c = a + b;
c += 42;
a = 42 - b;
</code></pre>

<p>and so on. See <a href=""https://stackoverflow.com/questions/4421706/operator-overloading"">this extensive discussion on operator overloading</a> for more information.</p>

<p>Also, for ""printing"", it is customary to overload <code>ostream&amp; operator&lt;&lt;</code>, which then allows you to stream to all kinds of streams, <em>including</em> but not limited to <code>std::cout</code>. For example:</p>

<pre><code>struct Foo
{
  int i;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const Foo&amp; f)
{
  return o &lt;&lt; f.i;
}
</code></pre>

<p>allows you to say</p>

<pre><code>Foo f;
std::cout &lt;&lt; f;
std::cerr &lt;&lt; f;
std::ofstream tmp(""foo.txt"");
tmp &lt;&lt; f;
</code></pre>
",6
33009821,33009146,2,"<p>It's because you do an actual type conversion of <code>myZ</code>. By doing this the compiler will create a temporary object <code>(Y)myZ</code> of type <code>Y</code> and will use that to call it's <code>test</code> method.</p>

<p>A longer equivalent of your your code would be something like:</p>

<pre><code>Z myZ;

Y tmp = Y(myZ);

tmp.test();
</code></pre>

<p>You can see that this happens if your <code>test</code> method modifies the object in any way. Then <code>((Y)myZ).test()</code> should not modify <code>myZ</code>.</p>

<p>As pointed out dynamic dispatch is only required to happen on pointer or reference.</p>

<p>In fact you cannot draw the distinction between pointer and no pointer, you could for example have have a trampoline method in <code>X</code> something like this, and it would still call <code>Y::test</code> despite you're using a pointer:</p>

<pre><code>class X {
public:
    void call_test() {
        this-&gt;test();
    }
}
</code></pre>

<p>The fact that dynamic dispatch doesn't happen could be seen as more of a optimization technique. The compiler knows that <code>((Y)myZ)</code> will have the virtual table of <code>Y</code> and can therefore immediately call <code>Y::test</code>.</p>
",0
33009233,33009146,2,"<pre><code>((Y)myZ)
</code></pre>

<p>since <code>myZ</code> is not pointer it is slicing. So, <code>Y::test</code> will be called, since there is no information about <code>Z</code> here.</p>

<p>But you can use pointers (or references):</p>

<pre><code>   Z* z = new Z();
   z-&gt;test();
   Y* y = z;
   y-&gt;test();
   delete z;
</code></pre>

<p><code>z</code> will be printed twice.</p>
",2
21026358,21026264,8,"<p>Your confusion stems from the fact that <code>extern</code> and <code>extern ""C""</code> do two different things.</p>

<hr>

<h2>About <code>extern</code></h2>

<p><code>extern</code> on its own is a <em>storage class specifier</em>:</p>

<blockquote>
  <p><code>[C++11: 7.1.1/6]:</code> The <code>extern</code> specifier can be applied only to the names of variables and functions. The <code>extern</code> specifier cannot be used in the declaration of class members or function parameters. For the linkage of a name declared with an <code>extern</code> specifier, see 3.5. <em>[ Note:</em> <strong>The <code>extern</code> keyword can also be used in <em>explicit-instantiations</em> and <em>linkage-specifications</em>, but it is not a <em>storage-class-specifier</em> in such contexts.</strong> <em>¡ªend note ]</em></p>
</blockquote>

<hr>

<h2>About <code>extern ""C""</code></h2>

<p>As that trailing note alludes to, there is another context in which you may use the <code>extern</code> keyword and that is as a <em>linkage specifier</em>:</p>

<blockquote>
  <p><code>[C++11: 7.5/2]:</code> Linkage (3.5) between C++ and non-C++ code fragments can be achieved using a <em>linkage-specification</em>:</p>
  
  <p><em>linkage-specification:</em><br>
  &nbsp; &nbsp; <code>extern</code> <em>string-literal</em> <code>{</code> <em>declaration-seq</em><sub>opt</sub> <code>}</code><br>
  &nbsp; &nbsp; <code>extern</code> <em>string-literal declaration</em></p>
</blockquote>

<p>C++ likes to re-use keywords.</p>

<hr>

<h2>Declarations vs definitions</h2>

<p>Now, by default, a variable marked with a linkage specifier is a <em>declaration</em> rather than a <em>definition</em>, so in that sense it is as if you had also used the other meaning of <code>extern</code>:</p>

<blockquote>
  <p><code>[C++11: 7.5/7]:</code> A declaration directly contained in a <em>linkage-specification</em> is treated as if it contains the <code>extern</code> specifier (7.1.1) for the purpose of determining the linkage of the declared name and whether it is a definition. Such a declaration shall not specify a storage class. <em>[ Example:</em></p>

<pre><code>extern ""C"" double f();
static double f(); // error
extern ""C"" int i; // declaration
extern ""C"" {
   int i; // definition
}
extern ""C"" static void g(); // error
</code></pre>
  
  <p><em>&mdash; end example ]</em></p>
</blockquote>

<p>As you can see in the above example, it is still possible to <em>either</em> a declaration or a definition when you use a linkage specifier.</p>

<p>Here's another example of that:</p>

<pre><code>// Everything in this block has C linkage
extern ""C"" {

   // Declaration of g_myVal
   extern int g_myVal;

   // Definition of g_myVal2
   int g_myVal2;
}

int main()
{
    g_myVal2 = 5;  // ok
    g_myVal  = 6;  // not okay - linker error, symbol not found
}
</code></pre>

<h3><a href=""http://coliru.stacked-crooked.com/a/523620a6a0599ce2"" rel=""nofollow"">Live demo</a></h3>

<hr>

<h2>When you add an initialiser...</h2>

<p>That all being said, the treatment of <code>g_myVal</code> as a <em>declaration</em> is <strong>overruled</strong> by your use of an initialiser, which forces the statement to be a definition:</p>

<blockquote>
  <p><code>[C++11: 7/8]:</code> Syntactic components beyond those found in the general form of declaration are added to a function declaration to make a function-definition. <strong>An object declaration, however, is also a definition unless it contains the <code>extern</code> specifier and has no initializer (3.1).</strong> A definition causes the appropriate amount of storage to be reserved and any appropriate initialization (8.5) to be done.</p>
</blockquote>

<p>I hope that this clarifies what is going on in your code with these differing meanings of <code>extern</code>.</p>
",4
21026574,21026264,1,"<p>In this case, putting the initializer <code>= 0</code> changed the declaration to a definition, which is why storage is allocated here. (The same would have happened even with just plain <code>extern</code>.)</p>
",0
25545040,25544819,6,"<p>The <code>std::min</code> signature forces the same type of arguments:</p>

<pre><code> template &lt;class T&gt; const T&amp; min (const T&amp; a, const T&amp; b);
</code></pre>

<p>The call is ambiguous in case the types of arguments differ.</p>

<p>However, it is fine to use temporaries (resulting e.g. from a cast expression) in place of arguments, because <code>std::min</code> takes <code>const</code> lvalue references.</p>

<p>Alternatively, you can force the type used to instantiate <code>std::min</code>:</p>

<pre><code>std::min&lt;std::size_t&gt;(PySequence_Fast_GET_SIZE(__transforms), N);
</code></pre>
",1
25545072,25544819,0,"<p>Yes, you can. Yet it is equivalent to the variant you specified. You are free to use the form:</p>

<pre><code>size_t Ntransforms = std::min(static_cast&lt;size_t&gt;(PySequence_Fast_GET_SIZE(__transforms)), N);
</code></pre>
",0
21022565,21022436,1,"<p>code:
<code>printf(""%s(%d)--:"",__FILE__,__LINE__);</code></p>

<p>reference:
<a href=""http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html</a></p>
",0
21022576,21022436,14,"<p>In general you can do this automatically by hiding your function behind a macro call which passes allong the <code>__FILE__</code> and <code>__LINE__</code> values</p>

<pre><code>void _B(const char* file, int line) { ... } 
#define B() _B(__FILE__, __LINE__)
</code></pre>

<p>This is by no means a foolproof solution though.  It's possible for developers to call <code>_B</code> directly or for <code>_B</code> to be called from generated code, assembly, etc .... where there may be no meaningful file / line number</p>

<p>OP asked for an example with arguments</p>

<pre><code>void _C(int p1, char p2, const char* file, int line) { ... } 
#define C(p1, p2) _C(p1, p2, __FILE__, __LINE__)
</code></pre>
",8
21586636,21586422,1,"<p>In my experience with C++, the main difference between having private mutators and giving friendship and having public mutators not giving friendship is that the second option allows you to not give anything and everything access to the information but only certain. Let's say you create a class called Student which has 2 child classes. Regular Student and Teachers Assistant. A lot of times there's so many students that it's hard for the teacher to take care of everything so he takes the best students as TA's. When the program is looking at these students, they should probably have more access to the Student's information than the regular student. With private mutators and giving friendship, you are saying some information (like a grade on a test) is private but can be changed by a TA possibly. On the other hand, if you have public mutators and no friendship, it is possible that a regular student can access the information and change the grades.</p>

<p>Hope this was helpful. </p>
",0
21586581,21586422,1,"<p>I'll start with two general statements:</p>

<ul>
<li><p><code>const</code>-correctness is a very good thing</p></li>
<li><p>firendship forms extremely close coupling between the two classes, which is generally a bad thing</p></li>
</ul>

<p>Is your <code>Context</code> so tied in to the manager that <em>only</em> the manager would ever want to modify it (both now and as your program evolves through the years)? And is <code>Context</code> happy to have the manager modify it as it pleases (accessing all its private data)? If any of the answers is ""no,"" you shouldn't go the friendship route.</p>

<p>Friendship should be used sparingly. When class <code>X</code> grants friendship to class or function <code>Y</code>, you now have two separate places in code which must maintain <code>X</code>'s internal invariants: <code>X</code> itself, and <code>Y</code>. This requires more maintenance and is more error-prone.</p>

<p>In short, reserve friendship for very special cases. What you describe seems like a clear-cut use for normal measures - <code>const</code> observers, non-<code>const</code> modifiers.</p>
",0
28161712,28161419,1,"<p>So you have the following classes:</p>

<pre><code>class Network
{
  virtual void connect() {...}
  void readPacket() = 0;
}

class NetworkClient : public Network
{
  virtual void connect(int ip, int port) {super::connect() ...}
}

class AppClient : public NetworkClient
{
   ... custom functionality needed by the app client ...
   void sendAppData(...)
}

class ProtocolAClient : public NetworkClient
{
  void readPacket() {...}
}

class ProtocolBClient : public NetworkClient
{
  void readPacket() {...}
}
</code></pre>

<p>The problem is that you want an <code>AppClient</code> object, but the <code>ProtocolAClient</code> is of type <code>NetworkClient</code> and not type <code>AppClient</code>.</p>

<p>Your inheritance looks like this:</p>

<pre><code>Network ---- NetworkClient ---- ProtocolAClient
                          |---- ProtocolBClient
                          |---- AppClient
</code></pre>

<p>As you can see, neither <code>ProtocolAClient</code> nor <code>ProtocolBClient</code> is of type <code>AppClient</code>, but all of them are of type <code>NetworkClient</code>.</p>

<p>So, if you want this code to work:</p>

<pre><code>AppClient *client;
if(useProtocalA)
  client = new ProtocolAClient;
else
  client = new ProtocolBClient;
client-&gt;sendAppData();
</code></pre>

<p>you will have to do the one of the following changes:</p>

<p>A) change your <code>ProtocolAClient</code> and <code>ProtocolBClient</code> to inherit the <code>AppClient</code> class:</p>

<pre><code>class ProtocolAClient : public AppClient
{
  void readPacket() {...}
}

class ProtocolBClient : public AppClient
{
  void readPacket() {...}
}
</code></pre>

<p>Now your inheritance looks like this:</p>

<pre><code>Network ---- NetworkClient ---- AppClient ---- ProtocolAClient
                                         |---- ProtocolBClient
</code></pre>

<p>or B) - Recommended: don't use AppClient as you already have NetworkClient:</p>

<pre><code>NetworkClient*client;
if(useProtocalA)
  client = new ProtocolAClient;
else
  client = new ProtocolBClient;
client-&gt;sendAppData();
</code></pre>
",0
28161952,28161419,1,"<p>I think I'd stop right at:</p>

<pre><code>class Network {};
class NetworkClient : public Network {};
class NetworkServer : public Network {};
</code></pre>

<p>At first glance, this already looks like a serious problem. Public inheritance implies the Liskov Substitution Principle--you should be able to substitute an instance of the derived class anywhere an instance of the base class is needed.</p>

<p>A NetworkClient (or a NetworkServer) is not a network, and I doubt there's even <em>one</em> circumstance in which either can be substituted for a network (not to mention all possible circumstances). As such, it seems to me that your basic design is problematic from the beginning.</p>

<p>My immediate reaction would be that you probably want something like:</p>

<pre><code>class ProtocolA {};
class ProtocolB {};

template &lt;class Protocol&gt;
class Client {};

template &lt;class Protocol&gt;
class Server {};
</code></pre>

<p>With this, you can fairly easily instantiate a client or server using either protocol. This does <em>not</em>, however, support run-time substitution. That is to say, you don't get anything like a base class that lets you deal completely transparently (at runtime) with an object that may be any of two or more different types.</p>

<p>If you really need that, you probably want something more like:</p>

<pre><code>class Protocol {};

class ProtocolA : public Protocol {};

class ProtocolB : public Protocol {};

class Client {
    Protocol *p;
public:
    Client(Protocol *p) : p(p) {}
};

class Server {
    Protocol *p;
public:
    Server(Protocol *p) : p(p) {}
};
</code></pre>

<p>[aside: despite following the syntax reasonably closely, this is really pseudo-code not C++. You clearly need to add a number of other things like virtual destructors before the code can actually be used at all.]</p>

<p>Then you instantiate an instance of the correct Protocol, and pass (a pointer to) that instance to create a Client or Server object.</p>

<p>With either of these, the Client/Server <em>uses</em> the Protocol to do communication, but (unlike with public inheritance) we have not made nonsensical assertions about being able to substitute a Client/Server for a network (or network protocol).</p>
",0
28170102,28161419,0,"<p>For me, your class hierarchy isn't precisely defined. In particular: what exactly is the <code>NetworkClient</code> class and what are you going to use it for? If this is to be used so that <code>client-&gt;sendAppData()</code> has to be called, then <code>ProtocolAClient</code> class should not derive from it. This solution you gave seems the best:</p>

<pre><code>AppClient *client; &lt;--- Uh oh... missing template argument!
if(useProtocalA)
  client = new AppClient&lt;ProtocolAClient&gt;;
else
  client = new AppClient&lt;ProtocolBClient&gt;;
client-&gt;sendAppData();
</code></pre>

<p>But you say you lack the ability to have this <code>AppClient</code> without specifying the protocol client class.</p>

<p>You can solve this problem by using virtual-template-pair idiom (or whatever name is used for it):</p>

<pre><code>class AppClient { /* ... */ virtual void sendAppData() = 0; };

template &lt;class ProtocolClientClass&gt;
class AppClientSpec: public AppClient
{
     /* ... */
     ProtocolClientClass* inproto; // or whatever...
     virtual void sendAppData() { return inproto-&gt;sendAppData(); }
};
</code></pre>

<p>And now your example can be fixed as:</p>

<pre><code>AppClient *client; &lt;--- Uh oh... missing template argument!
if(useProtocalA)
  client = new AppClientSpec&lt;ProtocolAClient&gt;;
else
  client = new AppClientSpec&lt;ProtocolBClient&gt;;
client-&gt;sendAppData();
</code></pre>
",0
29171592,29171214,4,"<p>Most likley NRVO will trigger. Lets give an example</p>

<pre><code>std::string foo()
{
    std::string s1;
    // fill up s1 with content
    return s1;
}

void bar()
{
    std::string s2 = foo();
    std::cout &lt;&lt; s2;
}
</code></pre>

<p>This will neither do a copy, nor a move, but rather the return value (s1) will be constructed at s2 directly. This is called return value optimization, and it means you should not return by const reference, or capture by const reference as some sort of performance hack, it will either not work, or slow thing down, depending.</p>
",0
23112339,23112267,1,"<p>If you don't insist on inheritance, beginning with an A would work.<br>
There's no change in memory-layout.</p>

<p>With inheritance, do it in two steps:</p>

<ol>
<li>Create derived: <code>B b;</code>
<ul>
<li>Instead with 0-init: <code>B b = {0};</code></li>
</ul></li>
<li>Copy all members: <code>(A&amp;)b = a</code>.</li>
</ol>

<p>The compiler should be able to optimize that.</p>

<p>Anyway, if possible start with the derived instead of copying.</p>
",3
23112391,23112267,1,"<p>(edit: removed the suggestion to add a constructor <code>B(A const &amp;)</code>, OP's update suggests that the given structs should not be modified.)</p>

<p>You can create a <code>B</code> and then use the compiler-generated <code>A::operator=(A&amp;)</code>:</p>

<pre><code>A a = { whatever };
B b = { whatever };
static_cast&lt;A &amp;&gt;(b) = a;
</code></pre>
",5
23112423,23112267,0,"<p>Make struct B contain a member of type A.</p>
",0
23112556,23112267,-1,"<p>Try this:</p>

<pre><code>b = dynamic_cast&lt;B*&gt;(a);
</code></pre>
",1
32970464,32969899,2,"<p>GCC with -O3 doesn't seem to optimize virtual call away.</p>

<p><a href=""https://goo.gl/TwZD6T"" rel=""nofollow"">https://goo.gl/TwZD6T</a></p>

<pre><code>.L5  
    movq    (%rdx), %rdx
    cmpq    Derived::Func(), %rdx
    je  .L3
    movq    %rbp, %rdi
    call    *%rdx
    subl    $1, %ebx
    jne .L11
</code></pre>

<p>This does a function pointer comparison and if not equal goes ahead and do an indirect function call.</p>
",0
32970751,32969899,1,"<p>VC++ like GCC doesn't Optimize the call away .
built with Visual Studio 2013 on release mode with /O2 flag:</p>

<pre><code>    base-&gt;Func();
010B12D2  mov         eax,dword ptr [esi] //load V-Table 
010B12D4  mov         ecx,esi //load this pointer into ecx  
010B12D6  call        dword ptr [eax]  //call the first function in the V-Table.
</code></pre>

<p><strong><em>EDIT:</em></strong>
your question actually demonstrated something very nice. <code>esi</code> holds <code>this</code>. how can dereferencing <code>this</code> gives the V-Table? well, because the V-Table is the first ""variable"" a polymorphic object have in it's memory. so assembly-wise , <code>*this()</code> actually produces a call to the first function, <code>*(this+sizeof(void*))()</code> calls the second function in the V-Table and so on.  <br/>
it's pretty much like declaring your class as</p>

<pre><code>class A{
   VTABLE vtable;
   //rest of the variables.
}
</code></pre>
",0
32970772,32969899,1,"<p>It depends on the smartness of your compiler; perhaps it can optimise, perhaps not. It's also an implementation detail -- you care more about the overall performance of your code rather than specific details like this. Measure your performance and decide whether optimisation is necessary, and if so, your approach.</p>

<p>If you really care with code like this you have options like using the C++11 keyword <code>final</code>, and doing a test for the type outside the loop instead of just using vtable dispatch inside the loop.</p>
",0
32970825,32969899,2,"<p>It's quite hard to optimize away virtualness of a function. You cannot know at proper compile time that the virtual will not have any effect. It's only at link time you can figure that out.</p>

<p>What's more problematic is that you even then might not be able to know since you could possibly dynamically load shared libraries that implement yet another subclass which might override the virtual function.</p>

<p>Basically such optimization requires quite smart link-time optimizations, for what is probably quite small gain.</p>
",0
32971403,32969899,0,"<p>The compiler cannot optimize this virtual call away, because the symbol for the vtable for <code>Derived</code> is externally visible, and can be overridden at runtime using a shared object and the <code>LD_PRELOAD</code> environment variable.</p>

<p>I think it should be able to optimize the call if you use the <code>-fvisibility=hidden</code> parameter.</p>
",6
33590062,33587458,2,"<p>Your iterator has state (i.e. whether or not underlying data is available yet), and the ""get"" function alters that state. So that makes it just like any other iterator. The ""get"" function shouldn't be const. By the way, instead of calling your function ""get"", it would be better to make the iterator have the same interface as Standard Library iterators - then you can use standard algorithms on it. So use the operator*() and operator++() functions among others.</p>
",3
30146581,30146562,24,"<p>By returning a non-const reference to a member of your class, you are giving the caller access to the object as if it's non const. But <code>GetTitle</code>, being a const function, does not have the right to grant that access.</p>

<p>For example:</p>

<pre><code>A a;
string&amp; b = a.GetTitle(); // Allows control over original variable
</code></pre>
",4
31179797,31179669,6,"<p>Remove the semicolon inside the enum. </p>

<pre><code>MAX_ARRAY_SIZE = 5;
   //             ^
</code></pre>

<p>If you do have more names inside the enum, separate them with a comma <code>,</code></p>

<pre><code>enum COLOR
{
    RED,
    BLUE,
    GREEN
};
</code></pre>
",2
31179935,31179669,-3,"<p>replace enum ArrayElements block with following code
int  MAX_ARRAY_SIZE = 5;</p>
",4
28217503,28217373,1,"<p>what about changing this:</p>

<pre><code>struct Bar
{
    Bar(Foo f) {}
};
</code></pre>

<p>to</p>

<pre><code>struct Bar
{
    Bar(Foo f) {}
    Bar(std::string f) {}
};
</code></pre>

<p>using polymorphism...</p>
",2
28217511,28217373,8,"<p>If c++11 is acceptable, you could add a delegating constructor to <code>Foo</code> which takes a <code>const char*</code> and just calls the other constructor:</p>

<pre><code>struct Foo
{
    Foo(std::string str) {}
    Foo(const char* str) : Foo(std::string(str)) {}
};
</code></pre>

<p>Alternatively, you could use c++14's <code>std::string</code> literal:</p>

<pre><code>using namespace::std::string_literals;
Bar b3(""test""s);
</code></pre>

<p>You could also emulate a delegating constructor by having both constructors call a separate function:</p>

<pre><code>struct Foo
{
    Foo(std::string str) { init(str); }
    Foo(const char* str) { init(str); }
    void init(std::string str) {}
};
</code></pre>

<p>The downside of the above is that you'll need to think carefully about anything you were doing in initialization lists that you now need to do in the body of <code>init</code>.</p>
",6
22864073,22863804,3,"<p>It depends on the container. For example the effect of applying resize to vectors is the following</p>

<pre><code>12 Effects: If sz &lt;= size(), equivalent to calling pop_back() size() - sz times
</code></pre>

<p>So for vectors the order of destroying of elemeents starts from the last element.</p>

<p>For lists the approach is other</p>

<blockquote>
  <p>Effects: If size() &lt; sz, appends sz - size() default-inserted elements
  to the sequence. If sz &lt;= size(), equivalent to list::iterator it =
  begin(); advance(it, sz); erase(it, end());</p>
</blockquote>

<p>But there is nothing said in which order the elements are erased.</p>
",13
22863899,22863804,14,"<h2>Based on the January 2012 working draft</h2>

<blockquote>
  <p>The January 2012 working draft contains the C++11 standard plus minor editorial changes.  </p>
</blockquote>

<p><a href=""http://isocpp.org/std/the-standard"" rel=""nofollow"">Source</a>, <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf"" rel=""nofollow"">working draft</a></p>

<p>For <code>vector</code>:</p>

<blockquote>
  <p><code>void resize(size_type sz);</code><br>
  E?ects: If <code>sz &lt;= size()</code>, equivalent to <code>erase(begin() + sz, end());</code>. If <code>size() &lt; sz</code>, appends
  <code>sz - size()</code> value-initialized elements to the sequence.</p>
</blockquote>

<p><code>vector::erase</code> does not specify the order of removal. I would expect it to be in order from <code>begin() + sz</code> to <code>end()</code>, because that makes sense to me, but that is just my expectation. I can't find anything about it in the standard.</p>

<p>The implementation of <code>vector</code> distributed with Visual Studio 2013 does appear to indeed erase in that order, as does MinGW's g++ 4.8.1 as well as g++ 4.7.3 (not MinGW). These are the compilers I happen to have easy access to.</p>

<p>In the same standard, for <code>list</code>:</p>

<blockquote>
  <p><code>void resize(size_type sz);</code><br>
  1 E?ects: If <code>size() &lt; sz</code>, appends <code>sz - size()</code> value-initialized elements to the sequence. If <code>sz &lt;= size()</code>, equivalent to</p>
</blockquote>

<pre><code>list&lt;T&gt;::iterator it = begin();
advance(it, sz);
erase(it, end());
</code></pre>

<p>and</p>

<blockquote>
  <p><code>void resize(size_type sz, const T&amp; c);</code><br>
  E?ects:</p>
</blockquote>

<pre><code>if (sz &gt; size())
    insert(end(), sz-size(), c);
else if (sz &lt; size()) {
    iterator i = begin();
    advance(i, sz);
    erase(i, end());
}
else
    ; // do nothing
</code></pre>

<p>It then goes on to specify absolutely nothing useful about ordering for <code>list::erase</code>.</p>

<p>The implementation of <code>list</code> distributed with Visual Studio 2013 does appear to erase in reverse order, while MinGW's g++ 4.8.1 and g++ 4.7.3 (not MinGW) do not.</p>

<h2>Based on the latest working draft at the time of writing</h2>

<p><a href=""http://isocpp.org/files/papers/N3797.pdf"" rel=""nofollow"">Working draft</a></p>

<p>For <code>vector</code></p>

<blockquote>
  <p><code>void resize(size_type sz);</code><br>
  E?ects: If <code>sz &lt;= size()</code>, equivalent to calling <code>pop_back()</code> <code>size() - sz</code> times. If <code>size() &lt; sz</code>,
  appends <code>sz - size()</code> default-inserted elements to the sequence.</p>
</blockquote>

<p>This indicates that elements are removed in reverse order.</p>

<p>For <code>list</code>:</p>

<blockquote>
  <p><code>void resize(size_type sz);</code><br>
  1 E?ects: If <code>size() &lt; sz</code>, appends <code>sz - size()</code> value-initialized elements to the sequence. If <code>sz &lt;= size()</code>, equivalent to</p>
</blockquote>

<pre><code>list&lt;T&gt;::iterator it = begin();
advance(it, sz);
erase(it, end());
</code></pre>

<p>and</p>

<blockquote>
  <p><code>void resize(size_type sz, const T&amp; c);</code><br>
  E?ects:</p>
</blockquote>

<pre><code>if (sz &gt; size())
    insert(end(), sz-size(), c);
else if (sz &lt; size()) {
    iterator i = begin();
    advance(i, sz);
    erase(i, end());
}
else
    ; // do nothing
</code></pre>

<p>It then goes on to specify absolutely nothing useful about ordering for <code>list::erase</code>.</p>

<p>For <code>deque</code> the standard specifies the same behavior as for <code>vector</code>.</p>
",10
22865268,22863804,5,"<p>With the exception of <code>std::basic_string</code> and
<code>std::forward_list</code>, the standard defines <code>resize</code> in terms of
<code>erase</code> (in cases where the new size is smaller than the
original size), so the question is really: does <code>erase(?begin, end?)</code> specify any order of destruction.  And all that I can
find here is in Table 100, which says that <code>erase( q1, q2 )</code>
""Erases the elements in the range <code>[q1, q2)</code>"".  Which (to me, at
least) still leaves the question open: when the standard uses
the notation <code>[q1, q2)</code> (where <code>q1</code> and <code>q2</code> are iterators),
does it imply in order, or not?  A priori, I would think not.
At least in the <code>&lt;algorithms&gt;</code> section, it explicitly states
when the operations must be in order (and the fact that it
explicitly states it in some specific cases sort of suggests
that it isn't required in cases where it isn't specified).</p>

<p>For what it's worth: for <code>std::list&lt;&gt;::resize()</code>, g++ calls
delete in ascending order; VS in descending order.  In the case
of VS, this is different than the order of destruction of
<code>std::list&lt;&gt;::erase</code> (which may be legal, if the order of
destruction is unspecified, and allowed to vary from one call to
the next).</p>
",2
23075732,23075640,4,"<p>You can define <code>bad_name</code> to be something that would cause a compile time error. For example, nothing:</p>
<pre><code>#define bad_name
</code></pre>
<p>gives on GCC</p>
<blockquote>
<p>error: declaration does not declare anything [-fpermissive]</p>
<p>int bad_name;</p>
</blockquote>
",0
23075831,23075640,4,"<p>You can simulate static assertions in C like this:</p>

<pre><code>#define bad_name xxx; char static_assertion_bad_name_used[-1];

struct example {
  int okay_name;
  int bad_name;
};
</code></pre>

<p>which in GCC gives:</p>

<pre><code>main.c:6: error: size of array ¡®static_assertion_bad_name_used¡¯ is negative
</code></pre>

<p>The advantage of this technique is that the error message gives you a reminder of what the problem is (even if slightly obscurely).</p>

<p><strong>Update</strong> After reading <a href=""https://stackoverflow.com/questions/3385515/static-assert-in-c"">this</a> I found out that MS Visual Studio does not include the actual variable name in the error message if the array size is negative. Here is an alternative:</p>

<pre><code>#define bad_name xxx; int static_assertion_bad_name_used : 0;
</code></pre>

<p>The error message in GCC is then:</p>

<pre><code>main.c:5: error: zero width for bit-field ¡®static_assertion_bad_name_used¡¯
</code></pre>

<p>and apparently something similar in VS.</p>

<p>Also if using a more up to date compiler you can use <a href=""http://pic.dhe.ibm.com/infocenter/comphelp/v121v141/index.jsp?topic=/com.ibm.xlc121.aix.doc/language_ref/sadecc1x.html"" rel=""nofollow noreferrer"">_Static_assert</a>, which would be a lot cleaner.</p>
",0
23076142,23075640,0,"<blockquote>
  <p>Suppose bad_name is a restricted identifier for example that I do not
  want to be part of the struct. I am looking for a mechanism to force a
  compilation failure in that case.</p>
</blockquote>

<p>This is not fully portable, but at least in VC++ and GCC you can mark the identifier as <a href=""https://stackoverflow.com/questions/295120/c-mark-as-deprecated"">deprecated</a> and, if you want, elevate the warning it gives to an error.</p>
",0
23077216,23075640,1,"<p>You may use the following:</p>

<pre><code>#include &lt;cstdint&gt;

#define DEFINE_HAS_SIGNATURE(traitsName, funcName, signature)               \
    template &lt;typename U&gt;                                                   \
    class traitsName                                                        \
    {                                                                       \
    private:                                                                \
        template&lt;typename T, T&gt; struct helper;                              \
        template&lt;typename T&gt;                                                \
        static std::uint8_t check(helper&lt;signature, &amp;funcName&gt;*);           \
        template&lt;typename T&gt; static std::uint16_t check(...);               \
    public:                                                                 \
        static                                                              \
        constexpr bool value = sizeof(check&lt;U&gt;(0)) == sizeof(std::uint8_t); \
    }

DEFINE_HAS_SIGNATURE(has_bad_name, T::bad_name, decltype(&amp;T::bad_name));
</code></pre>

<p>Then check with a <code>static_assert</code> (need C++11):</p>

<pre><code>static_assert(!has_bad_name&lt;example&gt;::value, """");
</code></pre>
",0
22107744,22107413,0,"<p>What you are looking is for PIMPL idiom where-in your header is just an interface with redirection to private implementation in your compilation units.</p>
",0
22107846,22107413,6,"<p>I believe the solution to your problem is the <a href=""http://en.wikibooks.org/wiki/C%2B%2B_Programming/Idioms#Pointer_To_Implementation_.28pImpl.29"">PIMPL</a> idiom.</p>

<p>In your case it would look something like:</p>

<pre><code>// .h
class SecretType; // forward decl

class Foo {
 public:
  int bar;
  SecretType* secret_field;
};
</code></pre>

<p>and in the .cpp you would have the include the header  which contains <code>SecretType</code>'s declaration. This in effect hides the details of <code>SecretType</code> from the users of your library.</p>

<p>P.S: I changed the type from int to a class to make the explanation a bit more complete.</p>
",2
31145721,31145650,1,"<p>If you just want to create a variable to pass to the function you can use a <a href=""http://en.cppreference.com/w/cpp/language/aggregate_initialization"" rel=""nofollow"">aggregate initialization</a> / <a href=""http://en.cppreference.com/w/cpp/language/list_initialization"" rel=""nofollow"">list initialization</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

class A{ /*... snip ...*/ };

void myFunc(A a){ }

int main(){
    myFunc(A{});
    return 0;
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/7699f394894746ac"" rel=""nofollow"">Live Example</a></p>

<p>You can also use this with classes that have constructors that take multiple parameters</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

class A
{ 
private:
    int foo;
    int bar;
    double foobar;
public:
    A(int a, int b, double c) : foo(a), bar(b), foobar(c) {}

};

void myFunc(A a){ }

int main(){
    myFunc(A{1,2,3.0});
    return 0;
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/7e8ade93450a7fff"" rel=""nofollow"">Live Example</a></p>
",3
31145817,31145650,1,"<p>C++ supports this with the <code>myFunc(A());</code> syntax you posed in your question.</p>

<pre><code>#include &lt;stdio.h&gt;

char lazybuff[500];

class Point
{
  public:
    Point (double x, double y) : m_x(x), m_y(y) { }
    char * ToString (void) { sprintf (lazybuff, ""%f, %f"", m_x, m_y); return lazybuff; }

  private:
    double m_x, m_y;
};

void print_point (Point print_me)
{
  printf (""%s\n"", print_me.ToString());
}

int main (void)
{
  print_point (Point(5, 3));

  return 0;
}
</code></pre>
",1
32449826,32449802,3,"<p>You forgot braces for the second parameter.</p>

<pre><code>this-&gt;m_values.end()
</code></pre>

<p>Also you might want to adjust your lambda a little bit. You search for a value, no need to copy each one of the vector.</p>

<pre><code>[&amp;name](const std::pair&lt;std::string, INIValue&gt; &amp;v)-&gt;bool { return v.first == name;}
</code></pre>
",3
28471179,28471067,9,"<p><code>0</code> is <code>int</code> ¡ú <code>~0</code> is <code>int</code> and equal <code>-1</code> ¡ú <code>false</code> gets promoted to <code>int</code>, which results in zero ¡ú your expression is calculated as <code>(0 - (-1))</code> which equals <code>1</code>.</p>
",0
28471180,28471067,9,"<p><code>~0</code> evaluates to -1 in 2s-complement representation. So 0 - -1 does equal 1.</p>

<p><strong>Edit:</strong>
To be slightly more precise. The unary <code>~</code> operator applied to the literal <code>0</code>, which is an <code>int</code>, is a bit-wise one's complement operator. The memory representation of <code>0</code> then becomes <code>0xffffffff</code> in 32-bit architectures. However, the result is still type <code>int</code>. Since all popular compilers interpret memory representation of <code>int</code> in two's complement, <code>~0</code> evaluates to <code>-1</code>.</p>
",5
26142342,26142100,19,"<p>Pointers are ""POD types""...a.k.a. ""Plain Old Data"".  The rules for when and where they are default-initialized are summarized here:</p>

<p><a href=""https://stackoverflow.com/questions/15212261/default-initialization-of-pod-types-in-c"">Default initialization of POD types in C++</a></p>

<p>So no.  It doesn't matter what your constructor for a class is, if it's a raw pointer as a member of the class.  You aren't actually instantiating the class.  So members like <code>Foo *</code> or <code>std::vector&lt;Foo&gt; *</code> or anything ending in * will not be initialized to nullptr.</p>

<p>The smart pointer classes are not POD.  So if you use a <code>unique_ptr&lt;Foo&gt;</code> or a <code>shared_ptr&lt;Foo&gt;</code> that is creating instances of classes, that do have a constructor that makes them effectively null if you do not initialize them.</p>

<blockquote>
  <p>Does it matter if I do MyCLass* o = new MyCLass; or I do  MyCLass* o = new MyCLass(); in C++11?</p>
</blockquote>

<p>One question per question, please.</p>

<p><a href=""https://stackoverflow.com/questions/620137/do-the-parentheses-after-the-type-name-make-a-difference-with-new"">Do the parentheses after the type name make a difference with new?</a></p>
",3
26142484,26142100,3,"<p>The default constructor, if compiler-generated or defaulted, will default-initialize all members. Any user-defined constructor will similarly default-initialize all members that don't have an explicit initializer in the initializer-list.</p>

<p>To default-initialize means ""call the default constructor for classes, leave everything else uninitialized"".</p>
",0
27551459,27550468,1,"<p>The issue is more than likely that you're using your debugger to debug code that has been optimized.  As your comment suggested, you are debugging code that has been compiled with the <code>-O3</code> flag, denoting optimization.</p>

<p>Even though you're using <code>gdb</code>, the Visual Studio and other debuggers also have the same issue, and that issue is debugging optimized code and having the debugger ""work"" in the sense that the debugger follows along with the lines in the source code, along with the variables that have been declared.</p>

<p>A debugger assumes that the lines of the source code match up with the generated assembly code.  With optimizations turned on, this can no longer be the case.  Code and variables are eliminated, moved, etc.  Therefore the lines in the code (including variable declarations) you believe should be there at a certain location may not be there in the final optimized build.</p>

<p>The debugger cannot discern these changes, thus you get erroneous values used for variables, or in some cases, you get ""variable doesn't exist"" errors reported by your debugger.</p>

<p>Also, it may also serve as a good check to do a simple <code>cout</code> or log of the values in question if there is a problem with the debugging environment.  There are situations where even debuggers may get things wrong, so a backup verification system (i.e. logging, printf() or <code>cout</code> statements, etc.) should be used.</p>
",0
34214845,34214331,1,"<p>I don't think there's a shorthand for it, but assuming you can use C++11 it is relatively straightforward to define a template class that does what you want:</p>

<pre><code>// Recursive case.
template &lt;typename T, typename ... TS&gt;
class Output {
 public:
  Output(T&amp; first, TS&amp; ... rest)
      : first_(first), rest_(rest...) {}

  template &lt;typename X&gt;
  Output&lt;T, TS...&gt;&amp; operator&lt;&lt;(X&amp;&amp; x) {
    // Output to each stream in the order that they were specified.
    first_ &lt;&lt; x;
    rest_ &lt;&lt; x;
    return *this;
  }
 private:
  T&amp; first_;
  Output&lt;TS...&gt; rest_;
};

// Base case.
template &lt;typename T&gt;
class Output&lt;T&gt; {
 public:
  Output(T&amp; output)
      : output_(output) {}

  template &lt;typename X&gt;
  Output&lt;T&gt;&amp; operator&lt;&lt;(X&amp;&amp; x) {
    output_ &lt;&lt; x;
    return *this;
  }
 private:
  T&amp; output_;
};

// Function so that types can be inferred.
template &lt;typename ... TS&gt;
Output&lt;TS...&gt; tee(TS&amp;&amp;... outputs) {
  return Output&lt;TS...&gt;(outputs...);
}
</code></pre>

<p>This lets you decide on the fly which ones to output to:</p>

<pre><code>tee(std::cout, std::cerr, std::ofstream(""my_file.txt""))
    &lt;&lt; ""Hello, World!\n"";
</code></pre>
",0
29209852,29209731,4,"<p>At work, I did a class with template methods to serialize (into a char array) basic types and some std types, like vector and string.</p>

<pre><code>class MySerializer{
public:
    // serialize operator
    template&lt;typename T&gt;
    friend MySerializer&amp; operator&lt;&lt;( MySerializer&amp;, const T&amp;);

    // deserialize operator
    template&lt;typename T&gt;
    friend MySerializer&amp; operator&gt;&gt;( MySerializer&amp;, T&amp; );
private:
    std::vector&lt;unsigned char&gt; v;
};
</code></pre>

<p>Then, if you need to serialize custom types, you can add specializations as needed. For basic types, you can just <code>copy</code> them byte to byte into <code>v</code>. Custom types need a few more work. Fore example, let's see how to serialize an <code>std::string</code>.</p>

<p>For this use case, you can look at <code>std::string</code> as a pair of a<code>size_t</code> where is stored the size of the <code>string</code> and a <code>char*</code> that points to string's chars. When you serialize a string, you could put its <a href=""http://www.cplusplus.com/reference/string/string/size/"" rel=""nofollow noreferrer""><code>string::size()</code></a>, casted for example to an <code>uint32_t</code> or <code>uint64_t</code>, into the serializer and then copy into the serializer <code>string::size()</code> characters starting from <a href=""http://www.cplusplus.com/reference/string/string/c_str/"" rel=""nofollow noreferrer""><code>string::c_str()</code></a>. When you will deserialize, first you need to read string's size from the serializer, and then put the proper number of chars into your output <code>string</code>.</p>

<p>You may be interested also in <a href=""https://stackoverflow.com/questions/28500822/serialization-member-by-member"">this question</a> of mine.</p>
",1
23091782,23091601,2,"<p>Split the cpp file into various smaller cpp files. If this cannot be done in a way that reduces the number of included files that each resulting cpp file needs to include, refactor your application. When refactoring, pay special attention to the <a href=""http://en.wikipedia.org/wiki/Single_responsibility_principle"" rel=""nofollow"">S</a>-part of the <a href=""http://en.wikipedia.org/wiki/Solid_%28object-oriented_design%29"" rel=""nofollow"">SOLID</a> principle: ""... every class should have a single responsibility"".</p>
",0
23091887,23091601,1,"<p>Go through your header list and remove all those not needed in that compilation unit. If you only need a pointer to a class, that is no reason to include the full header of the class.</p>

<p>If there are still so many headers after the cleanup, it <em>might</em> be appropriate to break up you <code>.cpp</code>-file, especially if you can make out different clusters of classes and/or functions doing different work (and probably needing the same subset of headers).</p>

<p>No need to go to extremes, but putting thousands of lines into your only source file is a sign of bad modularisation.</p>
",3
23091974,23091601,5,"<p><strong>1) Limit the scope of each file to one class, or to a small group of related classes with related behavior.</strong></p>

<p>If your cpp file is only 400 to 1000 lines of code, it'll be pretty hard to require dozens of includes.</p>

<p>Also, as you move things around and make modifications, re-evaluate headers included in each file.  If you originally implemented something using a vector, but then switched to set, consider removing the #include &lt; vector ></p>

<p><strong>2) In header files, use forward declarations, move those includes to the cpp file.</strong></p>

<p>This doesn't address your question directly, but it is related in managing compile time.  If you can get away with a forward declaration in a header file, do that.</p>

<p>If a.h includes b.h and b.h includes c.h, whenever c.h changes, anything including a.h has to recompile as well.  Moving these includes to the .cpp file (which isn't typically #included) will limit these cascading changes.</p>

<p>Let's re-evaluate what happens if a.h forward-declares classes defined in b.h, and a.cpp includes b.h, and if b.h forward-declares classes defined in c.h, and b.cpp includes c.h.</p>

<p>When c.h changes, b.cpp needs to recompile, but a.cpp is fine.</p>

<p><strong>3) Re-organize as you extend functionality.</strong></p>

<p>Writing code can happen like this:</p>

<ol>
<li>Plan to implement a feature.</li>
<li>Write code to support that plan. (If doing unit testing, consider writing the test first)</li>
<li>Debug and ensure the code meets your requirements.</li>
</ol>

<p>But this is missing a few steps that make a huge difference.</p>

<ol>
<li><strong>Refactor your code, and remove extraneous includes. (Here's where unit testing helps.)</strong></li>
<li><strong>Debug again.</strong></li>
</ol>

<p>These last two steps can involve splitting up large functions into several smaller ones, breaking classes up, and (relevant to this question) <strong>creating new files for functionality which has out-grown its current compilation unit.</strong></p>

<p>If you move on the moment your code seems to work and do not take a moment to tidy up it is the equivalent of a carpenter hammering legs onto a table, but never taking a moment to sand and polish the result.  Sometimes it's okay to have a slab of plywood with some legs, but if you want a nice dining room table, you'll find this approach is not up to the task.</p>

<hr>

<p>There is no simple way of reducing includes for cpp files, ultimately those includes need to exist somewhere (provided the original code relying on those includes is still present, if it is not, then simply delete the extraneous include), and the .cpp file is way better than the .h file.  But with careful management and organization you can maintain smaller, more modular source code.  This is ultimately how you keep things from becoming unworkable.</p>
",1
29146194,29145634,0,"<p>The <code>for</code> loop suggests that <code>cData</code> is a UDT; it has a member variable called <code>Map</code> which could be a <code>std::map</code>.</p>

<p>So <code>m_Cache</code> is a container. It contains some sort of object (we can't tell from this code), but that object can have <code>*</code> applied to yield an object of type <code>cData</code>. The contained objects could be of type <code>cData *</code>, but it could equally be some smart pointer or other class.</p>

<p>So the line:</p>

<pre><code>cData&amp; acData = *(*CacheVectorIter);
</code></pre>

<p>binds <code>acData</code> as a name for an object which is yielded by applying <code>*</code> to the object in the container. (It doesn't copy the object out of the container or anything).  Note, the parentheses are redundant.</p>

<p>The line:</p>

<pre><code>delete &amp;acData;
</code></pre>

<p>will free the <code>cData</code> object. If the elements of <code>m_Cache</code> are actually pointers then this is the same as calling <code>delete</code> on one of those pointers.</p>

<p>This code is doubtful because it will leave the container containing a dangling pointer (which runs the risk of causing undefined behaviour); hopefully it's part of a larger code block which also clears out the whole vector.</p>

<p>It'd be interesting if you could post the class definition of whatever <code>m_Cache</code> is an object of; and also the class definition of <code>cData</code>. That would enable a more precise answer to be given.</p>
",2
29145856,29145634,0,"<pre><code> cData&amp; acData = *(*CacheVectorIter); //WHAT IS IT ?
</code></pre>

<p>m_cache is a container storing pointers so the previous line will get the pointer and derefence it to assign it to a reference. </p>

<pre><code>cData&amp; acData = data;
</code></pre>

<p>That line would be completely valid but not this</p>

<pre><code>cData&amp; acData = &amp;data;
</code></pre>

<p>Now maybe the most shocking part</p>

<pre><code>delete &amp;acData; // DOES IT DELETE THE OBJECT OR THE POINTER?
</code></pre>

<p>Even if I don't agree with this kind of syntax, is correct as that reference is against an object in the heap and you can delete it. </p>

<p>Remember references don't call the destructor!</p>
",7
29146376,29145634,0,"<p>Okay so first let's examine <code>*CacheVectorIter</code></p>

<p>The type of <code>*CacheVectorIter</code> is <code>CacheVector</code> and it's a way to get the current item (nothing new).</p>

<p>Now you have <code>*(CacheVector)</code> which is wierd. Basically without the CacheVector object I'll not be able do more than just guessing.</p>

<p>My guess is that <code>CacheVector</code> contains the adress of another object. Using <code>*(CacheVector)</code> you can access this other object (probably of type cData).</p>

<p>It gives :</p>

<pre><code>*(*CacheVectorIter) = *(CurrentCacheVector) = cData
</code></pre>

<p>Then this object is stored into a reference variable <code>acData</code>. In C++ you can think of a reference as a pointer that you don't need to dereference. So deleting acData would really call the destructor of the object.</p>
",0
28498403,28498289,16,"<p>How about the <a href=""http://en.wikipedia.org/wiki/Non-virtual_interface_pattern"">NVI pattern</a>?</p>

<pre><code>class A
{
public:
    void func(int a)
    {
        cout &lt;&lt; ""System is initiated correctly."" &lt;&lt; a;
        do_func(a);
    }

private:
    virtual void do_func(int a) {}
};

class B : public A
{
private:
    virtual void do_func(int a) override
    {
        cout &lt;&lt; ""This particular system is initiated correctly too"" &lt;&lt; a;
    }
};
</code></pre>
",4
29451491,29451446,2,"<p>You should use <code>#ifndef CIRCLE_H</code> instead of <code>#ifdef CIRCLE_H</code>. It means ""if not defined"".</p>
",1
29451525,29451446,0,"<p>The problem is, that you used wrong preprocessor construct:</p>

<pre><code>#ifdef CIRCLE_H //#ifdef is not the right one!
#define CIRCLE_H

//...

#endif
</code></pre>

<p>You should use <strong>#ifndef</strong> instead. Why?</p>

<p><code>#ifdef</code> means <code>if token with name, placed after this instruction is already defined, then...</code>. Do you think this will work? When you include this file, <code>CIRCLE_H</code> is not defined anywhere, so <code>#ifdef CIRCLE_H</code> will always evaluate to false and content between <code>#ifdef</code> and <code>#endif</code> will be always discarded.</p>

<p>But when you write this:</p>

<pre><code>#ifndef CIRCLE_H
#define CIRCLE_H

//...

#endif
</code></pre>

<p>You say: <code>if CIRCLE_H has not yet been defined</code> (which is true, when file is included for the first time), <code>then define CIRCLE_H and proceed</code>. <code>CIRCLE_H</code> is then defined and every next include will not pass this <code>#ifndef</code> because <code>CIRCLE_H</code> will be already there.</p>
",0
27522861,27522672,5,"<p>Overridden member functions are virtual if they are declared virtual in the parent class.
Which means that in your case</p>

<pre><code>class C : public B
{
  //...something...
  void doSomething() {}
};
</code></pre>

<p>is equivalent to</p>

<pre><code>class C : public B
{
  //...something...
  virtual void doSomething() {}
};
</code></pre>

<p>But the second option is more explicit and has less hidden meaning.</p>

<hr>

<p>Since <em>c++11</em> a better option is:</p>

<pre><code>class C : public B
{
  //...something...
  void doSomething() override {}
};
</code></pre>

<p>Additionally to showing your intent clearly, compilers will not compile code where the function signatures of the base class and the derived class do not match.</p>

<hr>

<p><strong>Be sure to use virtual destructors in all inherited classes though.</strong></p>
",6
21023167,21023012,3,"<p>What you're suggesting is basically <a href=""http://en.wikipedia.org/wiki/Fixed-point_arithmetic"" rel=""nofollow"">fixed point arithmetic</a>. It's a way of achieving decimal fraction calculations using only integer operations. It can have some speed advantages (on some systems), and if it's done correctly can avoid some of the errors introduced through floating point.</p>

<p>There will be libraries which can help, although the maths involved is quite simple. You might find it's easy enough to read up on the subject and implement it yourself.</p>
",2
28225818,28225655,5,"<p>Function overloading can catch that</p>

<pre><code>public: void Foo(bool arg1 = false, int arg2 = 10, int arg3 = 20);

private: void Foo(int&amp;, ...); // can't omit leading arguments, dummy!
</code></pre>

<p>Or in C++11 and later, use <code>= delete</code> (some so-called C++11 compilers don't support this yet, though)</p>
",0
28225824,28225655,7,"<p>You may provide deleted overloads:</p>

<pre><code>class Bar
{
public:
   void Foo(bool arg1 = false, int arg2 = 10, int arg3 = 20)
   {
      [...]
   }

    template &lt;typename T&gt;
    void Foo(T&amp;&amp;, int = 10, int = 20) = delete;
};
</code></pre>

<p>As the template method would be an exact match for non bool parameter.</p>
",2
28225896,28225655,4,"<p>As you noted <code>explicit bool</code> does not work in this context - but we can instead manage to make <code>Explicit&lt;bool&gt;</code> work, which looks almost exactly the same.</p>

<p>First, a bit of <a href=""http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error"" rel=""nofollow"">SFINAE</a> trait magic helps provide a class which has a constructor that only works for real <code>bool</code>s:</p>

<pre><code>#include &lt;type_traits&gt;
template&lt;typename U&gt;
struct Explicit
{
    bool value;
    template&lt;typename T = U, typename = std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, U&gt;::value&gt;&gt;
    Explicit(T&amp;&amp; value) : value(value) { }
    operator U() { return value; }
};
</code></pre>

<p>With this helper available you can simply say:</p>

<pre><code>void Foo(Explicit&lt;bool&gt; arg1 = false, int arg2 = 10, int arg3 = 20) { }
</code></pre>

<p>See the <a href=""https://ideone.com/r66aBZ"" rel=""nofollow"">success</a> and the <a href=""https://ideone.com/3CJvqt"" rel=""nofollow"">failure</a> and pay special attention to the error message:</p>

<blockquote>
  <p>prog.cpp:22:11: error: could not convert 'x' from 'int' to 'Explicit&lt;bool>'</p>
</blockquote>
",0
28225937,28225655,1,"<p>You can try using this trick with a template:</p>

<pre><code>template &lt;class T&gt;
void foo(T param);

template &lt;&gt;
void foo&lt;bool&gt;(bool param)
{

}


foo(true); // OK
foo(9); // Won't c?o?m?p?i?l?e?  link
</code></pre>
",0
21022475,21022449,13,"<p>By providing an implicit conversion from <code>iterator</code> to <code>const_iterator</code>. You can do this by giving <code>const_iterator</code> a constructor that takes an <code>iterator</code>, or by providing <code>iterator</code> with a <code>const_iterator</code> conversion operator.</p>

<p>This approach is used in the standard library when you do this kind of thing:</p>

<pre><code>std::vector&lt;int&gt; v;
std::vector&lt;int&gt;::const_iterator it = v.begin();
</code></pre>

<p>In C++11, you have methods that return <code>const_iterators</code> directly, even for non-const instances. But these need a different name, because you cannot overload by return type:</p>

<pre><code>std::vector&lt;int&gt; v;
std::vector&lt;int&gt;::const_iterator it = v.cbegin();
</code></pre>
",3
21022583,21022449,2,"<p>You may also create <code>cbegin()</code> and <code>cend()</code> member functions that will return const iterators.</p>
",3
21022599,21022449,2,"<p>You have several options to avoid this problem.</p>

<ol>
<li>Use iterator instead of const_iterator in ""for"" loop</li>
<li><p>Define object like the following:</p>

<pre><code>const Map&lt;string, int&gt; msi;
</code></pre></li>
<li><p>Define operator at your iterator class to convert Map::const_iterator into Map::iterator</p></li>
</ol>
",0
31876401,31876378,2,"<h3>About <code>char*</code></h3>
<p>As of C++11 all of that code is illegal. String literals can only be binded to <code>char const*</code> or in general a <code>[char] const</code> array.</p>
<p>Notice that a <code>char[]</code> can be initialized with a string literal as per ¡ì8.5.2/1:</p>
<blockquote>
<p>An array of narrow character type (3.9.1), <code>char16_t</code> array, <code>char32_t</code> array, or <code>wchar_t</code> array can be initialized by a narrow string literal, <code>char16_t</code> string literal, <code>char32_t</code> string literal, or wide string literal, respectively, or by an appropriately-typed string literal enclosed in braces (2.13.5). Successive characters of the value of the string literal initialize the elements of the array.</p>
<p>[Example:</p>
<pre><code>char msg[] = &quot;Syntax error on line %s\n&quot;;
</code></pre>
<p>shows a character array whose members are initialized with a string-literal. [...]</p>
</blockquote>
<p>Previously <code>char*</code> was supported but considered deprecated. And anyway, modifications to the string via that <code>char*</code> were considered undefined behaviour.</p>
<p>As per ¡ì4.2/2 (pre-C++11):</p>
<blockquote>
<p>A string literal (2.13.4) that is not a wide string literal can be converted to an rvalue of type ¡°pointer to <code>char</code>¡±; a wide string literal can be converted to an rvalue of type ¡°pointer to <code>wchar_t</code>¡±. In either case, the result is a pointer to the first element of the array. This conversion is considered only when there is an explicit appropriate pointer target type, and not when there is a general need to convert from an lvalue to an rvalue. [Note: this conversion is deprecated. See Annex D. ] For the purpose of ranking in overload resolution (13.3.3.1.1), this conversion is considered an array-to-pointer conversion followed by a qualification conversion (4.4). [Example: <code>&quot;abc&quot;</code> is converted to ¡°pointer to <code>const char</code>¡± as an array-to-pointer conversion, and then to ¡°pointer to <code>char</code>¡± as a qualification conversion. ]</p>
</blockquote>
<h2>About reassigning the pointer</h2>
<p>Reassinging a <code>char*</code> or a <code>char const*</code> is perfectly fine. The <code>const</code> there refers to the character, not the pointer. To avoid reassigning you would need <code>char* const</code> and <code>char const* const</code> respectively.</p>
",1
31876451,31876378,3,"<p>Let's repose your question as being assignment and reassignment to a <code>const char*</code>. This is because a string literal is a read-only array of characters terminated will <code>\0</code>, and compilers are lapse in allowing assignment of a string literal to a <code>char*</code>. C++11 explicitly forbids this.</p>

<p>Reassignment of a <code>const char*</code> to a different literal is permissible: there is no danger of a memory leak here since the strings will be stored in a read-only section of your compiled binary.</p>
",4
31876568,31876378,1,"<p>First of all it would be correctly to write</p>

<pre><code>const char *str = ""some text"";
^^^^^
</code></pre>

<p>because string literals in C++ have types of constant character arrays. For example string literal ""some text"" has type <code>const char [10]</code>.</p>

<p>An array name used in expressions is implicitly converted to a pointer to its first element.</p>

<p>For example in this declaration</p>

<pre><code>const char *str = ""some text"";
</code></pre>

<p>the string literal is implicitly converted to an object of type <code>const char *</code> and has value of the address of the first character of the string literal.</p>

<p>Pointers may be reassigned. The assignment operator may be used with pointers.</p>

<p>So you may write</p>

<pre><code>const char *str = ""some text"";
str = ""some other text"";
</code></pre>

<p>Now pointer str is reassigned and points to to the first character of string literal ""some other text"".</p>

<p>However if you declare the pointer itself as a constant object as for example</p>

<pre><code>const char * const str = ""some text"";
             ^^^^^
</code></pre>

<p>then in this case you may not reassigned it. The compiler will issue an error for statement</p>

<pre><code>str = ""some other text"";
</code></pre>
",0
27761459,27759385,1,"<p>Use initializer list in constructor:</p>

<pre><code>// .h
class C
{
public:
    C();
private:
    unsigned long arr[256];
};

// .cpp
C::C() : arr{0x00000000L, 0x01020304L, 0x21223212L, ...} {}
</code></pre>

<p>Note that <code>std::array</code> may be an alternative which has more intuitive syntax and is assignable.</p>
",0
27761523,27759385,0,"<p>This is standard C++ code:</p>

<pre><code>class C
{
private:
    unsigned long arr[256] = {0x00000000L,0x01020304L,0x21223212L};
};

auto main() -&gt; int
{
    C c; (void) c;
}
</code></pre>

<p>Unfortunately it doesn't compile with Visual C++ 19.00.22310.1. Workaround:</p>

<pre><code>#include &lt;array&gt;

class C
{
private:
    std::array&lt;unsigned long, 256&gt; arr;

public:
    C(): arr( {0x00000000L,0x01020304L,0x21223212L} ) {}
};

auto main() -&gt; int
{
    C c; (void) c;
}
</code></pre>
",0
32965022,32964894,5,"<p>If the typical use of this version of <code>new</code> were to call it as <code>new(nothrow_t()) T</code>, you would have a good point. But that isn't the typical use, the typical use is <code>new(nothrow) T</code>, where <code>nothrow</code> is declared as <code>extern const std::nothrow_t nothrow;</code>. Even though there is no actual data in a <code>nothrow_t</code> type, it still takes up (at least) a byte, and in many ABIs that would mean that that (again, at least) one byte would need to be read from the <code>nothrow</code> object in order to pass it to <code>operator new</code>. Taking it by reference merely requires loading the object's address. So no, if the performance difference is measurable at all, I wouldn't expect the by-value version to be faster here.</p>
",2
25660916,25660520,5,"<blockquote>
  <p>I find the class name cannot be hidden in the shared library if this class is polymorphic.</p>
</blockquote>

<p>Not clear what kind of hiding you refer to.</p>

<p>From linker symbol visibility perspective all names with internal linkage are hidden. Classes do not have linkage at all, functions and variables do:</p>

<pre><code>$ nm -C libexample.so
nm: libexample.so: no symbols

$ nm -D -C libexample.so
0000000000201030 B __bss_start
                 w __cxa_finalize
0000000000201030 D _edata
00000000002010a0 B _end
0000000000000944 T _fini
                 w __gmon_start__
0000000000000728 T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
                 U sprintf
0000000000000899 T TheAPI(int)
                 U vtable for __cxxabiv1::__class_type_info
                 U vtable for __cxxabiv1::__si_class_type_info


$ strings libexample.so | c++filt 
__gmon_start__
_init
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
TheAPI(int)
sprintf
vtable for __cxxabiv1::__si_class_type_info
vtable for __cxxabiv1::__class_type_info
libstdc++.so.6
libm.so.6
libgcc_s.so.1
libc.so.6
_edata
__bss_start
_end
CXXABI_1.3
GLIBC_2.2.5
fffff.
Papa
I'm %s.
5Child
4Base
;*3$""
</code></pre>

<p>Those strings <code>5Child</code> and <code>4Base</code> are typeinfo returned by <code>typeid()</code>:</p>

<pre><code>typeinfo name for Child:
    .string ""5Child""
    .hidden typeinfo for Child
    .weak   typeinfo for Child
    .section    .data.rel.ro._ZTI5Child,""awG"",@progbits,typeinfo for Child,comdat
    .align 16
    .type   typeinfo for Child, @object
    .size   typeinfo for Child, 24
typeinfo name for Base:
    .string ""4Base""
    .hidden typeinfo for Base
    .weak   typeinfo for Base
    .section    .data.rel.ro._ZTI4Base,""awG"",@progbits,typeinfo for Base,comdat
    .align 16
    .type   typeinfo for Base, @object
    .size   typeinfo for Base, 16
</code></pre>

<p>You can disable typeinfo with <code>-fno-rtti</code> compiler switch:</p>

<pre><code>       -fno-rtti
           Disable generation of information about every class with virtual
           functions for use by the C++ run-time type identification features
           (dynamic_cast and typeid).  If you don't use those parts of the
           language, you can save some space by using this flag.  Note that
           exception handling uses the same information, but G++ generates it
           as needed. The dynamic_cast operator can still be used for casts
           that do not require run-time type information, i.e. casts to ""void
           *"" or to unambiguous base classes.
</code></pre>
",7
28524697,28524398,3,"<p>[class.virtual]/8:</p>

<blockquote>
  <p>If the class type in the covariant return type of <code>D::f</code> differs from
  that of <code>B::f</code>, the class type in the return  type of <code>D::f</code> shall be
  complete at the point of declaration of <code>D::f</code> or shall be the class
  type <code>D</code>.</p>
</blockquote>

<p>So CRTP cannot work perfectly, since the template argument which refers to the derived class would be an incomplete type, and thus covariant return types are difficult to simulate.</p>

<p>However, here's a try:</p>

<pre><code>class A
{
public:
    virtual A* clone() = 0;
};

namespace detail {
    template &lt;typename T&gt;
    struct Cloner : A {
        using A::A; // For constructors
        virtual A* clone() override {return new T;}
    };
}

template &lt;typename T&gt;
struct Cloner : detail::Cloner&lt;T&gt; {
    using detail::Cloner&lt;T&gt;::Cloner; // For constructors

    // For callers 
    template &lt;class=void&gt;
    T* clone() {return static_cast&lt;T*&gt;(detail::Cloner&lt;T&gt;::clone());}
};

class B : public Cloner&lt;B&gt;
{
};
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/4b795df8721877a8"" rel=""nofollow""><strong>Demo</strong></a>.</p>

<p>Note two things:</p>

<ul>
<li><p>The overload of <code>clone</code> returning a pointer to the derived class type is a function template. That's so we don't override the virtual function <code>clone</code>: If we would, the code would be ill-formed, because the return type is not covariant (see above).</p></li>
<li><p>Because <code>clone</code> is a function template, to ensure that it get's called at all, we can to let it hide the virtual <code>clone</code> function. That's achieved via inheritance: Names in derived classes hide names in base classes. Thus if we call through a <code>B</code>-pointer/reference, we get the appropriate return type (<code>B*</code>), since the name is looked up in <code>::Cloner</code> before <code>detail::Cloner</code>.</p></li>
</ul>
",4
29196325,29196292,0,"<p>On the first pass all the class interface is read and thus when the code for <code>function a</code> is compiled it knows that the function <code>b</code> exists in the class <code>Foo</code></p>
",0
29196371,29196292,1,"<p>There are things called forward references (different from forward declaration)</p>

<pre><code>class C
{
public:
   void mutator(int x) { myValue = x; }
   int accessor() const { return myValue; }
private:
   int myValue;
};
</code></pre>

<p>here myValue is accessed before it it declared. C++ does not usually allow forward references but for class members it allows them. It is the compilers job to remember the definition of mutator and accessor until it sees myValue</p>
",1
29197134,29196292,1,"<p>The definition of your class:  </p>

<pre><code>class Foo 
{
public:
  void a()  {  b(); }
  void b()  {  }
};
</code></pre>

<p>has the same meaning than:  </p>

<pre><code>class Foo 
{
public:
  void a();
  void b();
};
void Foo::a()  {  b(); }
void Foo::b()  {  }
</code></pre>

<p>This is why the function body sees all the members, as if the class was already completely defined.   This is by the ways stated in the C++ standard:  </p>

<blockquote>
  <p><strong>3.3.7/1</strong> The potential scope of a name declared in a class consists <strong>not only of the declarative region following the name¡¯s point of declaration</strong>, but also of all function bodies,
  brace-or-equal-initializers of non-static  data members, and default
  arguments in that class (including such things in nested classes).</p>
</blockquote>

<p>The compiler still parses the file in a single pass.  But the parsing the grammatical construct is only a part of the larger compilation process, in which applying the context to the parsed grammar production plays also a role (see also this <a href=""https://stackoverflow.com/questions/14589346/is-c-context-free-or-context-sensitive"">SO question</a>). </p>
",0
29197173,29196292,0,"<p>Section 3.3.7 of the C++ Standard includes, among other rules, the statement that</p>

<blockquote>
  <p>The potential scope of a name declared in a class consists not only of the declarative region following the name¡¯s point of declaration, but also of all function bodies, default arguments, exception-specifications, and brace-or-equal-initializers of non-static data members in that class (including such things in nested classes).</p>
</blockquote>

<p>Basically, this requires that analysis of the mentioned contexts, if they appear inline inside the class definition, is deferred until the entire class definition has been processed just as if you had used an out-of-line definition.</p>

<p>A related rule is found in section 9.2:</p>

<blockquote>
  <p>A class is considered a completely-defined object type (3.9) (or complete type) at the closing <code>}</code> of the <em>class-specifier</em>.  Within the class <em>member-specification</em>, the class is regarded as complete within function bodies,
  default arguments, <em>using-declarations</em> introducing inheriting constructors (12.9), <em>exception-specifications</em>, and <em>brace-or-equal-initializers</em> for non-static data members (including such things in nested classes).  Otherwise
  it is regarded as incomplete within its own class <em>member-specification</em>.</p>
</blockquote>
",0
28159822,28156381,5,"<p>The simple answer, is that C++ does not define the conversion you are attempting and thus your program is ill formed.</p>

<p>Consider <em>standard conversions</em> (C++11¡ì4/1):</p>

<blockquote>
  <p>Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such conversions.</p>
</blockquote>

<p>Since you are not performing any cast, nor do you have any custom conversions defined, you are indeed performing such a standard conversion. Without enumerating all possible such conversions, two are of explicit interest for your example: <em>pointer</em> conversions and <em>pointer to member</em> conversions. Note that C++ does not consider pointer to member types to be a subset of pointer types.</p>

<p>Pointer to member conversions are defined in C++11¡ì4.11 and consist of exactly two conversions:</p>

<p><ul>
<li>The null member pointer conversion which allows null pointer constants to be converted to pointer to member types (4.11/1).</li>
<li>The somewhat more contrived second conversion (4.11/2):</p>

<blockquote>
  <p>¡°pointer to member of B of type cv T¡±, where B is a class type, can be converted to a [...] ¡°pointer to member of D of type cv T¡±, where D is a derived class [...] of B</li>
  </ul>
  Contrast this with the previous section 4.10 which defines three pointer conversions:</p>
</blockquote>

<p><ul>
<li>The null pointer conversion (4.10/1) which allows null pointer constants to be converted to pointer types.</li>
<li>Conversion to pointers to <code>void</code> (4.10/2) which allows the conversion of any pointer type to pointer to <code>void</code>.</li>
<li>And finally why it works with pointers (but not pointers to member) (4.10/3):</p>

<blockquote>
  <p>A [...] ¡°pointer to cv D¡±, where D is a class type, can be converted to a [...] ¡°pointer to cv B¡±, where B is a base class [...] of D</li>
  </ul>
  Therefore, to wrap it all up: The standard conversion you are attempting is defined for your pointer example, but simply does not exist for the pointer to member variant.</p>
</blockquote>
",0
28177191,28156381,4,"<p>C++ does not allow this conversion, and many others like it, because it would complicate the implementation of virtual inheritance.</p>

<pre><code>struct A { int a; };
struct B : virtual A { int b; };
struct C : virtual A { int c; };
struct D : B, C { int d };
</code></pre>

<p>Here's how a compiler might try to lay out these classes:</p>

<pre><code>A:  [ A::a ]
B:  [ B::b ] [ A ]
C:  [ C::c ] [ A ]
D:  [ D::d ] [ B ] [ C ] [ A ]
</code></pre>

<p>If we have a pointer to B, it's not an easy task to get a pointer to its base class A, because it's not at a fixed offset from the beginning of the B object. A may be located right next to B::b, or it may be somewhere else, depending on whether our object is a standalone B or a B that is a base of D. There is no way to know which case we have!</p>

<p>To make a cast, the program needs to actually access the B object and get a <em>hidden base pointer</em> from it. So the real layout would be more like this:</p>

<pre><code>A:  [ A::a ]
B:  [ B::b | B::address-of-A ] [ A ]
C:  [ C::c | C::address-of-A ] [ A ]
D:  [ D::d | D::address-of-A ] [ B ] [ C ] [ A ]
</code></pre>

<p>where <code>address-of-A</code>s are hidden members added by the compiler.</p>

<p>That's all fine and dandy while we are talking about regular pointers. But when we have a pointer-to-member, we don't have any object to go and fetch the hidden base pointer from. So if we have only <code>B X::*</code>, there is absolutely no way to convert it to <code>A X::*</code> without having an actual X object.</p>

<p>While it is in theory possible to allow conversions like this, it would be hugely complicated. For example, a pointer-to member would need to hold variable amount of data (all the hidden pointer-to-base values the original object has).</p>

<p>In theory C++ could allow such conversions of pointers-to-members only to non-virtual base classes (in this example, <code>D X::*</code> to <code>B X::*</code> or <code>C X::*</code>, but not <code>A X::*</code>). Or at least I don't see why it could be an insurmountable problem for implementations. I guess this is not done because it would introduce additional complexity to the standard for very little benefit. Or maybe the standard doesn't want to preclude unusual implementations of inheritance. For instance an implementation may want to implement all inheritance with hidden pointer-to-base members, as if it's always virtual (for debugging purposes, or for compatibility with other languages, or whatever). Or perhaps it is just overlooked. Maybe in another revision of the standard (2020?)</p>
",3
24625339,24625296,1,"<p>Your <code>LEDGarden</code> has a pointer to a <code>ButtonState</code> which you never set.</p>

<p>The <code>init</code> method shadows the member variable with a local of the same name (so the member variable is not set when you go to use it). try</p>

<pre><code>void LEDGarden::init(void) {
  this-&gt;the_state = new ButtonState();
  the_state-&gt;analog_pin = 5;
  initButtons();

}
</code></pre>

<p>What you should probably do is get rid of <code>init()</code> and make it a constructor.</p>

<p>The different behaviors probably depends on what the member variable is set to null or random memory location (which may be ""good"" or ""bad"", but never ""right"" ;-)</p>
",0
25512757,25512673,1,"<p>Your code compiles with Clang.</p>

<p>Reading C++11 specifications you are not allowed to declare the variable after it is being used as function/constructor parameter.</p>
",4
25512865,25512673,-1,"<p>In many cases classes including function signatures will be defined in headers, but function bodies in cpp files. Since the header will have been read by the compiler at the start of reading the cpp file, this problem does usually not occur. But indeed, C++ compilers don't look ahead.</p>
",3
25512970,25512673,6,"<blockquote>
  <p><strong>3.3.7 Class scope</strong></p>
  
  <p><strong>1</strong> The following rules describe the scope of names declared in classes.</p>
  
  <p>1) The potential scope of a name declared in a class consists not only of the declarative region following
  the name¡¯s point of declaration, but also of all function bodies, brace-or-equal-initializers of non-static
  data members, and default arguments in that class (including such things in nested classes).</p>
  
  <p>...</p>
</blockquote>

<p>That means that you can use <code>v_</code> in function bodies, constructor initializer lists and default arguments. You are not allowed to use <code>v_</code> in parameter declarations the way you used it in your code.</p>

<p>For example, this shall compile</p>

<pre><code>class X
{
public:
    X(int a = decltype(v_)()) : v_(a)
    {}
private:
    int v_;
};
</code></pre>

<p>but not the second example in your original post.</p>
",3
31254604,31254252,3,"<p>There's no solving this, as there's no error(*).</p>

<p>You're allocating a block of memory for an instance of your class, setting some values there and then freeing that memory.</p>

<p>After you called <code>delete pt;</code>, the address pointed to by the pointer <code>pt</code> is no longer intended to be used by you, writing or even reading from there may cause undefined behaviour. In theory the programm could send ninjas to kill you. In practice most often you're just accessing that very same memory location, only that using it will lead to catastrophic failure.</p>

<p>What you see are most probably the changes internal bookkeeping of the memory allocator has performed after freeing.</p>

<p>As a final note: I really don't know where you've seen that, but your class is absolutely not how you should implement a linked list:</p>

<pre><code>struct listnode {
  // some data
  listnode * next;
  // better: std::unique_ptr&lt;listnode&gt; next;
  // or with sharing: std::shared_ptr&lt;listnode&gt; next;
};
</code></pre>

<p>There's a reason for pointers.</p>

<p>(*) <strong>to clarify:</strong> there's no error, as the programm is showing a form of undefined behaviour, which is exactly what it should do in this form (when dereferencing after delete).</p>
",0
29210020,29209910,4,"<p>Just write the default constructor normally but make it <code>constexpr</code>.</p>

<pre><code>struct List
{
  constexpr List() : head(nullptr), tail(nullptr) { }
  ...
};
</code></pre>

<p>When you define a <code>List</code> object with static storage duration (i.e. a global) the compiler ensures the object is not initialized dynamically, so it is guaranteed to happen before any other constructors need it during the dynamic initialization phase. </p>

<p>When you declare a variable with automatic or dynamic storage duration (i.e. as a local variable or on the heap) the constructor will run normally and set the two members.</p>

<p>This is exactly the reason why types such as <code>std::mutex</code> have constexpr constructors, to ensure they are initialized before anything can try to use them.</p>

<p>If you need a C++03 solution, either make the global a local static that can be accessed (and initialized) as needed via a function:</p>

<pre><code>inline List&amp; global_list()
{
  static List list;
  return list;
}
</code></pre>

<p>or you could resort to a klugey solution involving a second constructor:</p>

<pre><code>struct List
{
  struct no_init_t { };
  static no_init_t no_init;
  List() : head(0), tail(0) { }
  List(no_init_t) { }
  ...
};

List global_list(List::no_init);
</code></pre>

<p>This second constructor intentionally does no initialization, relying on the fact that the members of the global will initially be zero anyway. This means that if code in another translation unit accesses the list before its lifetime starts (which is technically undefined behaviour) it finds the members with zero values and can add to the list, and if the <code>no_init</code> list constructor runs later it won't zero out the variables and lose the previously added data. This is ugly, but should work. Obviously the <code>no_init</code> constructor should only be used for globals, so this solution is more error-prone.</p>
",7
33022341,33022229,6,"<p><code>std::fill_n</code> makes copies of the given object passed as third argument but the third argument is a future object which is not copyable, as it doesn't make sense to copy future. Hence the error.</p>

<p>It seems you need this:</p>

<pre><code>std::generate_n(std::back_inserter(futures), 
                10, 
               []{  return std::async([]{ std::cout &lt;&lt; ""yo\n""; }); });
</code></pre>
",0
33022358,33022229,5,"<p>The interface of <a href=""http://en.cppreference.com/w/cpp/algorithm/fill_n"" rel=""noreferrer""><code>std::fill_n</code></a> is:</p>

<pre><code>template&lt; class OutputIt, class Size, class T &gt;
OutputIt fill_n( OutputIt first, Size count, const T&amp; value );
</code></pre>

<p>It then copies <code>value</code> <code>count</code> times. That's why you're getting your error. Although, even if it moved, <code>fill_n</code> wouldn't make sense as a choice of function... you'd be moving from the same <code>future</code> 10 times, so you'd end up with one valid <code>future</code> and 9 empty ones? What would the point of that be?</p>
",0
22108873,22107838,3,"<p>The answer depends on the language (C vs C++), on the version of the language (C++98/03 vs C++11), on other standards (e.g., POSIX), and on the compiler.</p>

<p>In C99 and earlier, converting a function pointer to/from a <code>void*</code> pointer is undefined behavior. UB can be a huge negative, but in this case it means that an implementation is free to provide the ability to convert between function pointers and pointers with no diagnostic whatsoever.</p>

<p>In POSIX, converting a function pointer to/from a <code>void*</code> pointer is required behavior. This works nicely with C because no diagnostic is required for undefined behavior.</p>

<p>In C++98/03, converting a function pointer to/from a <code>void*</code> pointer is illegal behavior. A compliant implementation could generate the code that does what the author wants, but it also has to issue a diagnostic of some sort.</p>

<p>In C++11, converting a function pointer to/from a <code>void*</code> pointer is conditionally-supported behavior. An implementation that supports these conversions can do so without any diagnostic. An implementation that doesn't (for example, a compiler for a Harvard architecture machine) can reject it out of hand.</p>

<p><br>
Converting to/from an int? That's dubious. You should use a type that can handle a <code>void*</code> pointer rather than <code>int</code>.</p>
",1
22108026,22107838,0,"<p><strong>Short answer</strong>: It's well-defined if <code>int</code> is large enough to hold the value. If <code>int</code> isn't large enough to hold the value, then the compiler has to at least issue a warning.</p>

<p><strong>Details</strong>:</p>

<p>Section 5.4 discusses C-style cast notation.</p>

<p>¡ì5.4/4</p>

<blockquote>
  <p>The conversions performed by</p>
  
  <p>¡ª a <code>const_cast</code> (5.2.11),</p>
  
  <p>¡ª a <code>static_cast</code> (5.2.9),</p>
  
  <p>¡ª a <code>static_cast</code> followed by a const_cast,</p>
  
  <p>¡ª a <code>reinterpret_cast</code> (5.2.10), or</p>
  
  <p>¡ª a <code>reinterpret_cast</code> followed by a const_cast`,</p>
  
  <p>can be performed using the cast notation of explicit type conversion... If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears first in the list is used</p>
</blockquote>

<p>The conversion of a function pointer to an integral type requires <code>reinterpret_cast</code> because it cannot be performed by any other cast.</p>

<p>Section 5.2.10 of the standard discusses <code>reinterpret_cast</code>.</p>

<p>¡ì5.2.10/4</p>

<blockquote>
  <p>A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is
  implementation-defined. </p>
</blockquote>

<p>¡ì5.2.10/5</p>

<blockquote>
  <p>A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted
  to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type
   will have its original value; mappings between pointers and integers are otherwise implementation-defined. [ <em>Note:</em> Except as described in 3.7.4.3, the result of such a conversion will not be a safely-derived pointer
  value. ¡ª <em>end note</em> ]</p>
</blockquote>

<p>You can go read ¡ì3.7.4.3 if you want, but it doesn't apply to function pointers. AFAIK, its main purpose is to allow implementation of garbage collection, which applies only to objects and not functions.</p>

<p>If <code>int</code> is too small to hold the value, then there is nothing in the standard that allows the conversion. The compiler may still allow the conversion, but it must issue a diagnostic.</p>
",2
24102082,24101975,1,"<p>a mutex will do - thread 1 waits for the mutex, or timeout. If the 2nd thread resets the mutex the 1st thread will stop blocking before the timeout is up.</p>

<p>On Windows you'd typically use an Event to do this, but boost has <a href=""http://www.boost.org/doc/libs/1_55_0/doc/html/thread/synchronization.html#thread.synchronization.condvar_ref"" rel=""nofollow"">condition variables</a> that seem to do the same thing - communicate a waitable event to another thread.</p>
",2
24102097,24101975,0,"<p>That is a neat question, but I think the best solution depends on your application's needs and constraints. For example, can you use a busy wait sleep function that polls the condition, or do you need something that does not use as much of the CPU?</p>

<p>Here is a first stab at a solution that may work for you:</p>

<pre><code>#define SLEEP_RESOLUTION 1000 // A value in microseconds

void do_work_with_delay(int delay_time) { // Specify the delay in ms

    bool condition_reached = sleep_and_check(delay_time);

    if (condition_reached) {
        return;
    }

    do_work();
}


bool sleep_and_check(int delay_time) {
    int accumulated_delay = 0;

    while (accumulated_delay &lt; delay_time*1000) { // Loop until we have waited 
                                             // the whole delay_time
        if (someCondition) // Check the condition, return true if it has been met
            return true;

        usleep(SLEEP_RESOLUTION); // Condition not met, sleep and check again next time
        accumulated_delay += SLEEP_RESOLUTION;
    }
    return false; // Return false to show the whole time 
                  // went by without meeting the condition
}
</code></pre>
",0
24102136,24101975,2,"<p>You may use a combination of a variable indicating whether the work needs to be done combined with a timed condition variable: you'd wait for the sleep time and if the wait terminates you'd check if the work should be aborted, more sleeping is needed (condition variables can always stop waiting spuriously), or the work can be started:</p>

<pre><code>bool                    do_work(true);
std::mutex              mutex;
std::condition_variable condition;

std::chrono::time_point&lt;std::chrono::steady_clock&gt; abs_time(
     std::chrono::steady_clock::now() + std::chrono::milliseconds(1000));
std::unique_lock&lt;std::mutex&gt; kerberos;
if (condition.wait_until(kerberos, abs_time, [&amp;]{ return do_work; })) {
    // do the work
}
</code></pre>

<p>The other thread cancelling the work would acquire a lock for the mutex, set <code>do_work</code> to <code>false</code>, and <code>notify_one()</code> the condition variable.</p>
",0
26208737,26208645,2,"<p>Your <code>Element *newData</code> doesn't have an instance of Element class, so it will crash when you try to access the instance pointed by <code>newData</code>.</p>

<p>Try to change <code>Element *newData;</code> to <code>Element *newData = new Element;</code>.</p>

<ul>
<li>ps.: Don't forget to <code>delete</code> it when you don't need the instance any more.</li>
</ul>
",1
26208780,26208645,1,"<p>This method is writing to uninitialized memory:</p>

<pre><code>void ajoutListe(Item *data)
{
    Element *new;

    //set data
    new-&gt;setElement(data); // Right here, ""new"" is an uninitialized pointer

    //check if list is empty
    if( courant == NULL)
    {           
        //set current pointer
        courant = new;
    }
}
</code></pre>

<p>I'm surprised this compiles (does it?). This code should also crash.</p>

<p>The strange number you're getting is surely some random part of memory. You may want to think more about memory management -- there are numerous problems here. When ajoutListe is called, why does the courant member only get set if it's NULL? Do we just leak the new Element? How do we actually traverse this list?</p>
",1
32931454,32931420,4,"<p>No, <code>push_back</code> will do a copy to take ownership of the object.</p>

<p>As long as <code>vector</code> is declared to contain objects, regardless you can <code>push_back</code> with a reference, a const reference or an object, the <code>vector</code> will always store objects, never references.</p>
",0
29226055,29226008,3,"<blockquote>
  <p><em>""Is there any difference between these 2 ways of storing an integer?""</em></p>
</blockquote>

<p>Yes, there is a significant difference.</p>

<blockquote>
<pre><code> int X = 100;
</code></pre>
</blockquote>

<p>Initializes a variable <code>X</code> on the stack with the value <code>100</code>, while</p>

<blockquote>
<pre><code>int *pX = new int(100);
</code></pre>
</blockquote>

<p>allocates memory for an <code>int</code> on the heap, kept in pointer <code>pX</code>, and initializes the value to <code>100</code>.</p>

<p>For the latter you should notice, that it's necessary to deallocate that heap memory, when it's no longer needed:</p>

<pre><code> delete pX;
</code></pre>
",1
29226071,29226008,2,"<p>The first one is creating a variable on the stack while the second one is creating a variable on the heap and creating a pointer to point at it.</p>
",0
24594460,24594442,2,"<p>Iterate over the string. Check <code>isalpha</code> if string holding <code>char</code> else  find <code>.</code>, if found, it is <code>double</code> (if the last character is not <code>f</code>) else <code>int</code>.</p>
",6
24594634,24594442,1,"<p>Solution based on <code>C++11</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;stdexcept&gt;

int main (int argc, char * argv [])
{
    std::string x = argv [1];
    size_t pos = 0;
    bool isOk = true;

    try {
        stoi (x, &amp; pos);
    }
    catch (std::invalid_argument) {
        isOk = false;
    }

    if ( (pos == x.length () ) &amp;&amp; isOk) {
        std::cout &lt;&lt; ""Integer."" &lt;&lt; std::endl;
    }
    else {
        isOk = true;
        try {
            stod (x, &amp; pos);
        }
        catch (std::invalid_argument) {
            isOk = false;
        }
        if ( (pos == x.length () ) &amp;&amp; isOk) {
            std::cout &lt;&lt; ""Double."" &lt;&lt; std::endl;
        }
        else {
            std::cout &lt;&lt; ""String."" &lt;&lt; std::endl;
        }
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>Output: </p>

<pre><code>$ ./program 21  
Integer.  
$ ./program 21.22  
Double.  
$ ./program 21.22. 
String.  
$ ./program 21.22ddd  
String.  
$ ./program x21.22  
String.  
</code></pre>
",1
24595352,24594442,4,"<p>The biggest problem here is that your requirements are too vague, because <strong>there is no 1:1 mapping between data types and string representations</strong>.</p>

<p>What about <code>""2""</code>, for example? It could be a <code>double</code> as well as an <code>int</code> or even a <code>char</code>! What's worse, a <code>double</code> value of 2.0 may very well be represented as <code>""2""</code> rather than <code>""2.0""</code>.</p>

<p>And what about leading or trailing characters? Is <code>""2.0 ""</code> a valid <code>double</code> or not? And <code>""2.0x""</code>? <code>""2.0 x</code>""?</p>

<p>So one has to answer your question with a counterquestion: What are you going to do with the type information gathered from the string? Or more precisely, what is the real problem you are trying to solve?</p>

<p>At any rate, I don't think that regular expression play any role in it. <strong>String streams</strong> look like a promising approach. The pattern is always more or less <em>try to convert the string, and if it fails then the string did not have the correct format</em>. A string may represent more than one type, so you have to choose which one takes precedence.</p>

<p>In order to be a bit more restrictive, you can check if the entire input string was used for the conversion. Here is a complete toy example with descriptive names :</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;class T&gt;
bool CanBeUsedToCreate(std::string const &amp;string_representation)
{
    std::istringstream is(string_representation);
    T test_object;
    is &gt;&gt; test_object;
    bool const conversion_successful = !is.fail();
    bool const whole_string_used_for_conversion = is.rdbuf()-&gt;in_avail() == 0;
    return conversion_successful &amp;&amp; whole_string_used_for_conversion;
}

int main()
{
    std::vector&lt;std::string&gt; test_strings;
    test_strings.push_back(""x"");
    test_strings.push_back(""2"");
    test_strings.push_back(""2.0"");

    for (std::vector&lt;std::string&gt;::const_iterator iter = test_strings.begin();
        iter != test_strings.end(); ++iter)
    {
        std::cout &lt;&lt; ""\"""" &lt;&lt; *iter &lt;&lt; ""\"" as double? "" &lt;&lt; (CanBeUsedToCreate&lt;double&gt;(*iter) ? ""yes"" : ""no"") &lt;&lt; ""\n"";
        std::cout &lt;&lt; ""\"""" &lt;&lt; *iter &lt;&lt; ""\"" as int? "" &lt;&lt; (CanBeUsedToCreate&lt;int&gt;(*iter) ? ""yes"" : ""no"") &lt;&lt; ""\n"";
        std::cout &lt;&lt; ""\"""" &lt;&lt; *iter &lt;&lt; ""\"" as char? "" &lt;&lt; (CanBeUsedToCreate&lt;char&gt;(*iter) ? ""yes"" : ""no"") &lt;&lt; ""\n"";
    }
}
</code></pre>

<p>Output:</p>

<pre><code>""x"" as double? no
""x"" as int? no
""x"" as char? yes
""2"" as double? yes
""2"" as int? yes
""2"" as char? yes
""2.0"" as double? yes
""2.0"" as int? no
""2.0"" as char? no
</code></pre>
",0
24109926,24109817,2,"<p>You may try placing the <code>std::setw(7) &lt;&lt; std::setfill('.') &lt;&lt;</code> manipulators before the <code>std::fixed</code> manipulator</p>

<pre><code>std::cout &lt;&lt; std::setprecision(2) &lt;&lt; std::setw(7) &lt;&lt; std::setfill('.') 
          &lt;&lt; std::fixed &lt;&lt; price;
</code></pre>

<p>But as for the standard definitions this shouldn't really matter.<br>
Looks like this is a possible bug of your actual toolchain.</p>
",1
24109933,24109817,1,"<p>To incude whitespace when reading strings you can either change the definition of whitespace means (yes, this <em>can</em> be done by replacing the <code>std::ctype&lt;char&gt;</code> facet in a new <code>std::locale</code> and <code>imbue()</code>ing the stream with the thus constructed <code>std::locale</code>) or, a bit simpler, by using <code>std::getline()</code> to read the rest of the line. Assuming you want to ignore the leading whitespace in front of the trailing characters, you'd use <code>std::ws</code> when switching between formatted and unformatted input:</p>

<pre><code>if (std::getline(iss &gt;&gt; quantity &gt;&gt; price &gt;&gt; std::ws, name)) {
    // do something with the result
}
</code></pre>

<p>I can't write input statements like the above without checking as I firmly believe that input shall always be verified for success after it is done.</p>

<p>The purpose of <code>std::noskipws</code> is to disable automatic skipping of whitespace by formatted input operations: the formatted input operations skip leading whitespace by default. However, the flag has no effect at all on how strings are are parsed except for skipping leading whitespace. With the <code>std::noskipws</code> flag set I'd think you'll just read an empty string as the extraction immediately finds a character not matching the formatting and stops.</p>

<p>With respect to the <code>std::fixed</code> settings for output I'm pretty sure that the setting should work but right now I can't verify what's going on.</p>
",5
29199793,29199562,0,"<p>In visual studio, setting Linker -> Optimization -> Enable COMDAT Folding to No (/OPT:NOICF) worked.
<a href=""https://msdn.microsoft.com/en-us/library/bxwfs976.aspx"" rel=""nofollow"">Here</a> MSDN says:</p>

<p><code>Because /OPT:ICF can cause the same address to be assigned to different functions or read-only data members (const variables compiled by using /Gy), it can break a program that depends on unique addresses for functions or read-only data members. For more information, see /Gy (Enable Function-Level Linking).</code></p>

<p>Need to read more what this linker flag does exactly.</p>
",0
26806978,26806939,1,"<p>The vector stores a copy of local object b. So there is no problem with the code relative to this local variable</p>
",0
26806983,26806939,1,"<p><code>push_back</code> copied <code>b</code> into a new element created for <code>v</code>, then <code>b</code> was destroyed before <code>Do</code> returned.</p>
",0
24616793,24616643,2,"<pre><code>    std::string str(buffer);
</code></pre>

<p>Should be:</p>

<pre><code>    std::string str(buffer, buffer+length);
</code></pre>

<p>Otherwise, how can the constructor know how many bytes to allocate/copy?</p>

<p>By the way, your code is needlessly clumsy. Why not read directly into the string's buffer rather than using a separate buffer that you have to allocate and free just to hold the data before you allocate another buffer?</p>
",1
25505558,25505520,4,"<p>Dereferencing a null pointer is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a>, and undefined behavior is sneaky in that sometimes it <em>might</em> seem to work.</p>

<p>In your specific case, it most likely works because it's pure member function call, and the member function doesn't do anything with the objects internal state. If you add a member variable and try to access it in the member function, that would probably cause a crash.</p>
",3
30156448,30155850,3,"<p>This can become quite a design issue in a very complex system leaning heavily on signals and slots-type event/notification designs.</p>

<p>If you connect an object-bound function/method to a signal and the object is destroyed, there's no inherent, built-in kind of way to protect against the signal being invoked a second time and accessing a destroyed object through a dangling pointer if you forget to disconnect the slot when the object is destroyed.</p>

<p>One way to mitigate this issue is to bind shared_ptrs to objects rather than pointers. However, that can exchange a dangling pointer for a logical resource leak that may not only leak memory but also trigger unpredictable behaviors by preventing objects from being destroyed when they should. It also requires you to put all such objects on the heap.</p>

<p>Binding weak references to objects solves this without these issues, but can still leave a lot of destroyed slots in your signal unless you find times appropriate to clean up all the slots that have been destroyed. It also imposes a runtime check every time when invoking the callback to see if the weak reference is pointing to an object that has already been destroyed which can become a non-trivial overhead, especially since a weak reference validity check often involves converting it to a strong reference and doing some atomic CAS-type operations for thread safety. You also still have to put all such objects on the heap.</p>

<p>Another way to mitigate this is to have your signal design return a strong reference (<code>shared_ptr</code> or sometimes a <code>unique_ptr</code> is fine, e.g.) to a kind of proxy object, which, when destroyed, automatically disconnects the slot from the signal. Then clients connecting to the signal can capture those objects and store it somewhere in a way that is tied to their lifetime.</p>

<p>You do, unfortunately, have to kind of roll up your sleeves and settle on a higher-level design for these cases. Things like <code>std::function</code> won't prevent these safety issues on their own.</p>

<p>Another headache inducer just to give you a taste of the pain is in a very dynamic system that allows loading and even unloading plugins on the fly without restarting. In those cases, something like <code>std::function</code> may not merely be bound to point to resources that have already been destroyed in a way where even <code>shared_ptr/weak_ptr</code> can't protect you, but the function it's pointing to may not even be around in memory anymore, leading to a kind of <em>'dangling function pointer'</em>. As pointed out in the other answer, protecting against these issues often involves additional states and processing that may be overkill for a number of common scenarios. So <code>std::function</code> doesn't prevent them by default: you have to build those safety constructs on top if you need it. A lot of the C++ standard lib is useful as building blocks for higher-level constructs, but are not necessarily at that level on their own.</p>
",0
30156472,30155850,-1,"<p>As Bjarne Stroustrup said: ""C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off"". <a href=""http://www.stroustrup.com/bs_faq.html#really-say-that"" rel=""nofollow"">Look here</a></p>

<p>You can do this:</p>

<pre><code>class NotGonaMakeItToTheEnd
{
public:
    NotGonaMakeItToTheEnd ( )
    {
        delete this;
    }
};
</code></pre>

<p>And compiler will allow this.</p>

<p>All this things with pointers is done in C++ for C-compatiblity and for <strong>don't pay for what you don't use</strong> idiom. If you realy want to make a neat cabinet of pointers instead of garbage pile you should use <code>shared_ptr, unique_ptr</code>.</p>
",1
21586007,21585913,9,"<p>Mathematically, <code>str.size()-(3-vec.size())</code> is <code>1-(3-0)</code>, which is -2. However, since these are unsigned values, the result is also unsigned, and so has a large positive value.</p>

<p>Converting this to <code>int</code> to initialise <code>upper_bound</code> technically gives undefined behaviour, but in practise will give you -2; so the first test passes.</p>

<p>The second test compares with the large unsigned value rather than -2.</p>
",0
21586164,21585913,1,"<p>The problem is that expression str.size()-(3-vec.size()))  has some unsigned type. So it may not be negative. It is an unsigned type due to 1) str.size() and vec.size()  are of some unsigned types according to definitions of <code>std::string::size_type</code> and <code>std::vector&lt;int&gt;::size_type</code> 2) the usual arithmetic conversion.</p>

<p>In the first expression you explicitly assigned an unsigned expression to type int. So as  the sign bit is set then the value of this object is negative.</p>

<p>To understand this try for example to execute these statements</p>

<pre><code>std::cout &lt;&lt; -1 &lt;&lt; std::endl;
std::cout &lt;&lt; -1u &lt;&lt; std::endl;
</code></pre>

<p>or</p>

<pre><code>std::cout &lt;&lt; 0u -1 &lt;&lt; std::endl;
</code></pre>

<p>Here -1u and 0u - 1 have type unsigned int and the same bit combination as -1.</p>
",2
21586492,21585913,0,"<p>While comparing signed and unsigned types, compiler will convert the signed types to unsigned. That creates the weird result.</p>
",0
23829590,23829389,21,"<p>Yes, it must incur a branch, and it must also incur <em>at least</em> an atomic operation for safe concurrent initialization. The Standard requires that they are initialized on function entry, in a concurrency-safe way. </p>

<p>The implementation can only dodge this requirement if it can prove that the difference between lazy init and some earlier initialization like before main() is entered is equivalent. For example, simple PODs initialized from constants, the compiler may choose to initialize it earlier like a file-scope global since it's non-observable and saving the lazy initialization code, but that's a non-observable optimization.</p>
",7
23829671,23829389,19,"<p>Yes, there is a branch. Each time the function is entered, the code must check if the variable has already been initialized. But as will be explained below, you usually do not have to care about this branch.</p>
<h2>Example</h2>
<p>Check out this code:</p>
<pre><code>#include &lt;iostream&gt;

struct Foo { Foo(){ std::cout &lt;&lt; &quot;FOO&quot; &lt;&lt; std::endl;} };
void foo(){ static Foo foo; }
int main(){ foo();}
</code></pre>
<p>Now, here is the first part of assembly code that gcc4.8 generates for the <code>foo</code> function:</p>
<pre><code>_Z3foov:
.LFB974:
.cfi_startproc
.cfi_personality 0x3,__gxx_personality_v0
.cfi_lsda 0x3,.LLSDA974
pushq   %rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq    %rsp, %rbp
.cfi_def_cfa_register 6
pushq   %r12
pushq   %rbx
.cfi_offset 12, -24
.cfi_offset 3, -32
movl    $_ZGVZ3foovE3foo, %eax
movzbl  (%rax), %eax
testb   %al, %al
jne .L7                     &lt;------------------- FIRST CHECK
movl    $_ZGVZ3foovE3foo, %edi
call    __cxa_guard_acquire &lt;------------------- LOCK    
testl   %eax, %eax
setne   %al
testb   %al, %al
je  .L7                     &lt;------------------- SECOND CHECK
movl    $0, %r12d
movl    $_ZZ3foovE3foo, %edi
</code></pre>
<p>A you see, there is a <code>jne</code>! Then, a guard is aquired using <code>__cxa_guard_acquire</code>, followed by a <code>je</code>. Thus, it seems that the compiler is generating the famous <a href=""http://en.wikipedia.org/wiki/Double-checked_locking"" rel=""noreferrer"">double checked locking pattern</a> here.</p>
<h2>Will every compiler generate a branch?</h2>
<p>I am pretty sure the spec does NOT mandate that a branch or double checked locking must be used. It just mandates that the initialization must be thread safe. However, I do not see a way to perform a thread safe initialization without a branch. Thus, even though the spec does not mandate it, it is simply not possible with current CPU architectures to omit the branch here.</p>
<h2>Is the branch expensive?</h2>
<p>Considering whether you should care about this branch:
You should definitly <em>NOT</em> care about this branch, since it will be correctly predicted (as it once the object is initialized the branch always takes the same route). Thus, the branch is almost free. Trying to avoid a static local variable for optimization purposes should never yield any observable performance benefit.</p>
<h2>Is there really no way around the branch?</h2>
<p>If the constructor is not observable, like simply initialization with constant values, then it may be performed eagerly at program startup and the branch is omitted. If, however, it is observable, then things get pretty tricky:</p>
<p>The only possibility I see is stated in the answer of R. Martinho Fernandes (which has been deleted): The code could modify itself. I.e., simply remove the initialization code once the initialization is done. However, this is idea is impractical for the following reasons:</p>
<ol>
<li>Self-modifying code is very hard to get thread-safe.</li>
<li>Usually, memory flagged executable is write protected so code is not allowed to rewrite itself.</li>
<li>It is just not worth it, as the branch is not expensive (see above).</li>
</ol>
",4
23594677,23594608,1,"<p>Replace</p>

<pre><code>class Bar
</code></pre>

<p>with</p>

<pre><code>class Foo::Bar
</code></pre>

<hr>

<p>Addendum: and now that you've fixed the first error, also fix the next one in a reasonable, non-verbose way. Namely, replace</p>

<pre><code>PositionsEnum Foo::Bar::GetPosition() {}
</code></pre>

<p>which doesn't compile, with</p>

<pre><code>auto Foo::Bar::GetPosition() -&gt; PositionsEnum {}
</code></pre>

<p>which does compile.</p>

<p>The difference is which scope <code>PositionsEnum</code> is looked up in.</p>
",1
23594771,23594608,6,"<p>Prefix PositionsEnum with the class</p>

<pre><code>Foo::Bar::PositionsEnum Foo::Bar::GetPosition() {}
</code></pre>
",4
30146200,30146179,0,"<p>Even when you declare window as <code>unique_ptr&lt;Window&gt; window</code> you are declaring something on the stack. In this case an instance of <code>unique_ptr&lt;Window&gt;</code>. It is fine to declare ints and other small primitives or structs on the stack because even if you declare them on the heap you will need to declare the pointer to them on the stack. You will always need to hold a pointer to the location on the heap, in the stack so if your data type is smaller than a pointer (or close to the same size) than it is even more efficient to hold it on the stack rather than the heap. This is because it is quicker to access the stack than the heap, and memory wise you have to store two objects when storing on the heap (the pointer and the object itself) and only one when storing on the stack.</p>

<p>Take <code>std::string</code> for instance. It probably holds internally a pointer to a location on the heap where the raw data is stored. So on the stack you are holding a pointer and on the heap the raw data (string literals are a bit different put the general idea remains).</p>

<p>In general there is little point in storing an int in a <code>unique_ptr</code> unless it is the address of an array. It is more efficient and easier to maintain if you just declare it as a raw int.</p>
",15
30146231,30146179,5,"<p><code>Why would you ever want to declare stuff on the stack?</code></p>

<p>2 reasons I can think of:</p>

<ol>
<li><p>Performance: The stack is extremely fast. I remember hearing this somewhere but the best way to improve performance is to avoid a trip to the heap.</p></li>
<li><p>Complexity: Using dynamic memory creates more complexity as you have to think about memory management. Using the stack keeps it much more simple than using the heap. Using dynamic memory increases the complexity of your program.</p></li>
</ol>
",8
30147420,30146179,0,"<p>You are prematurely worrying about optimizing stack usage.</p>

<p>You indicated C++.  </p>

<p>For C++ on Linux, the default stack size for ubuntu 12.04 and 15.04 is 8 MegaBytes.</p>

<p>The sizeof() Height and Width are 4 bytes each.</p>

<p>If you are using std::string, and gcc 4.9 on Ubuntu 15.04, the 
    sizeof(an_empty_std_string_object) is 8 bytes (on the stack)</p>

<p>Additionally
    the sizeof(a_100_char_string_object) is only 8 bytes.
    I would guess that std::string is a simple wrapper around dynamic memory, but I have never checked.</p>

<p>So an 8 MByte stack will hold more than 10^6 of your 16 byte objects.  Maybe you could fill this stack using recursion.  </p>

<hr>

<p>Imagine you move all 16 bytes of your object to the heap (i.e. you new your object to the heap) </p>

<p>You would still use 8 bytes (on 64 byte linux) on the stack to point to your object.</p>

<p>I have not looked at how big a smart pointer is, but it will probably be 16 bytes, not sure yet.</p>

<hr>

<p>Perhaps you are worried enough to put each of your objects into a vector.  An empty vector is 24 bytes, and so is a 1000 element vector, and so is a 1 Million Element vector, ...</p>

<p>Anyway, if you are nearing stack limits (it is doable, I've done it with recursive algorithms), in Linux you can change the stack size ... I have tried a 1 GByte stack ... just to see how far that recursive program would get.  Not that much further.  (Sorry, I did not finish that experiment.)</p>

<hr>

<blockquote>
  <p>All of the int and string types inside my Window class are declared on
  the stack.</p>
</blockquote>

<p>No, not really.  Your int and string types are declared as data attributes of your class instances.  If your class instances are instantiated on the heap (i.e. using new), then that data will be in the heap, not on the stack.</p>
",0
30145981,30145950,10,"<p>It still could be either or even (as Thomas Matthews points out below) in a fixed memory block. In this case you can think of it as ""inside of A"". If you put A on the heap it's on the heap. If you allocate ""A"" at the top of a function, say, it's on the stack (but inside of A).</p>

<p>Written like this it is a part of A and its lifetime is tied to A. You only need to worry about managing A.</p>
",3
27517138,27516794,5,"<p>I will start with the core advice first.</p>

<pre><code>Foo* aligned_foo() {
  void* raw = 0;
  if(posix_memalign(&amp;raw, 8, sizeof(Foo)))
    return 0; // we could throw or somehow communicate the failure instead
  try{
    return new(raw) Foo();
  }catch(...){
    free(raw);
    throw;
  }
}
</code></pre>

<p>then when you are done with the <code>Foo* foo</code>, do a <code>foo-&gt;~Foo(); free(foo);</code> instead of <code>delete</code>.</p>

<p>Note the lack of <code>reinterpret_cast</code>s.</p>

<hr>

<p>Here is an attempt to make it generic:</p>

<pre><code>// note: stateless.  Deleting a derived with a base without virtual ~base a bad idea:
template&lt;class T&gt;
struct free_then_delete {
  void operator()(T*t)const{
    if(!t)return;
    t-&gt;~T();
    free(t);
  };
};
template&lt;class T&gt;
using aligned_ptr=std::unique_ptr&lt;T,free_then_delete&lt;T&gt;&gt;;

// the raw version.  Dangerous, because the `T*` requires special deletion:
template&lt;class T,class...Args&gt;
T* make_aligned_raw_ptr(size_t alignment, Args&amp;&amp;...args) {
  void* raw = 0;
  if(int err = posix_memalign(&amp;raw, alignment, sizeof(T)))
  {
    if (err==ENOMEM)
      throw std::bad_alloc{};
    return 0; // other possibility is bad alignment: not an exception, just an error
  }
  try {
    // returns a T*
    return new(raw) T(std::forward&lt;Args&gt;(args)...);
  } catch(...) { // the constructor threw, so clean up the memory:
    free(raw);
    throw;
  }
}
template&lt;class T,class...Args&gt; // ,class... Args optional
aligned_ptr&lt;T&gt; make_aligned_ptr(size_t alignment=8, Args&amp;&amp;...args){
  T* t = make_aligned_raw_ptr&lt;T&gt;(alignment, std::forward&lt;Args&gt;(args)...);
  if (t)
    return aligned_ptr&lt;T&gt;(t);
  else
    return nullptr;
}
</code></pre>

<p>The <code>unique_ptr</code> alias <code>aligned_ptr</code> bundles the destroyer along with the pointer -- as this data requires destruction and free, not delete, this makes it clear.  You can still <code>.release()</code> the pointer out, but you still have to do the steps.</p>
",8
27516888,27516794,3,"<p>Actually, you don't want to do a <code>reinterpret_cast</code> because then your <code>Foo</code> constructor isn't called.  If you need to allocate memory from a special place, you then call placement new to construct the object in that memory:</p>

<pre><code>void* alloc;
posix_memalign(&amp;alloc, 8, sizeof(Foo));
Foo* foo = new (foo) Foo();
</code></pre>

<p>The only other way (pre C++11) would be overriding the <code>new</code> operator for your class.  That works if you have a particular class that always requires this special allocation:</p>

<pre><code>class Foo {
    void* operator new(size_t size) {
        void* newobj;
        posix_memalign(&amp;newobj, 8, sizeof(Foo));
        return newobj;
    }
};
</code></pre>

<p>Then anytime you call <code>new Foo()</code> it will invoke this allocator.  See <a href=""http://en.cppreference.com/w/cpp/memory/new/operator_new"" rel=""nofollow"">http://en.cppreference.com/w/cpp/memory/new/operator_new</a> for more information.  Overriding <code>operator new</code> and <code>operator delete</code> can be done for individual classes or globally.</p>
",6
27517755,27516794,1,"<p>C++11 has added native language support for alignment declarations and aligned allocation.</p>

<p>You can specify <a href=""http://en.cppreference.com/w/cpp/language/alignas"" rel=""nofollow""><code>alignas(N)</code></a> on your type in C++11 to specify the minimum alignment for new objects, which the default <code>new</code> will respect.</p>

<p>Example from <a href=""http://en.cppreference.com/w/cpp/language/alignas"" rel=""nofollow"">cppreference</a>:</p>

<pre><code>struct alignas(16) sse_t { // SSE-safe struct aligned on 16-byte boundaries
    float v[4];
};
</code></pre>

<p>then you can simply do</p>

<pre><code>sse_t *ssevec = new sse_t;
</code></pre>

<p>For a replacement for <code>posix_memalign</code>, you can use <a href=""http://en.cppreference.com/w/cpp/types/aligned_storage"" rel=""nofollow""><code>std::aligned_storage&lt;sizeof(T), N&gt;</code></a>, also in C++11.</p>
",2
21039424,21039166,0,"<p>The <code>LsalCryptUnprotectData</code> function is undocumented, but from <a href=""http://www.rsdn.ru/forum/cpp.applied/4815136.hot"" rel=""nofollow"">this example</a>, you might try with similar parameters:</p>

<pre><code>cbSize = 0;
pLsaICryptUnprotectData ( buffer, dwSize, 0,0,0,0, 0x20000041, 0, 
    &amp;pDecrypted, &amp;cbSize);
</code></pre>
",2
32476418,32476240,6,"<p>You wrote your operator in such a way that forbids passing in <em>rvalues</em>; an example might be, as pointed out by <strong>@TartanLlama</strong>, taking non-const reference.</p>

<pre><code>bool operator&lt;= (Foo&amp; a, Foo&amp; b); // will err
bool operator&lt;= (const Foo&amp; a, const Foo&amp; b); // will work fine
</code></pre>

<p>The reason for that not working is that <a href=""https://stackoverflow.com/questions/1565600/how-come-a-non-const-reference-cannot-bind-to-a-temporary-object"">it's simply disallowed in C++</a>.</p>
",0
23114356,23114046,1,"<p>It is not standard behavior to instantiate templates with incomplete types, therefore it shouldn't work <code>boost::scoped_ptr</code>.</p>

<p>Having said that, <code>unique_ptr</code> has a special rule, allowing to take incomplete types. If you use it (instead of <code>boost::scoped_ptr</code>), then it is done like this :</p>

<pre><code>// forward declaration of PPP, assuming c++ header
struct PPP;

namespace X
{

    class ClassOne
    {
    ...

    private:
        std::unique_ptr&lt;PPP&gt; m_scpPPP;    
    };
}
</code></pre>
",0
23114261,23114046,0,"<p>Simply put: That won't work. Since you use PPP (and not PPP*) in side your ClassOne, the compiler needs to know the size at that point, so it <em>needs</em> to know the definition of PPP. To hide PPP from the public .h file, you'll have to do more. One possible solution is to hide your implementation class behind another class. Another would be only to refer to PPP* in your class declaration (although that would make the usage of scoped_ptr&lt;> a bit pointless). </p>

<p>The compiler expects a default constructor because he assumes there is one. He needs the definition of the class to call ""new"" as well. You can work around this problem by moving the implementation of the ctor to the .cpp file, where you <em>may</em> include thirdParty.h. </p>
",2
23571001,23570929,1,"<p>After your edits to the question, I think I can write a better answer than what I had before.</p>

<p>First, write a comparison function for <code>Tick</code>s that uses their timestamps:</p>

<pre><code>bool CompareTicks(const Tick&amp; l, const Tick&amp; r)
{
   return l.timestamp &lt; r.timestamp;
}
</code></pre>

<p>Now use the function with <code>std::upper_bound</code>:</p>

<pre><code>// Get an iterator pointing to the first element in ticks that is &gt; 214
// I'm assuming the second parameter to Tick's ctor is the timestamp
auto itAbove = std::upper_bound(ticks.begin(), ticks.end(), Tick(Vec3(0, 0, 0), 214), CompareTicks);
if(itAbove == ticks.end())
   ; // there is nothing in ticks &gt; 214. I don't know what you want to do in this case.
</code></pre>

<p>This will give you the first element in ticks that is > 214. Next, you can use <code>lower_bound</code> to find the first element that is >= 214:</p>

<pre><code>// get an iterator pointing to the first element in ticks that is &gt;= 214
// I'm assuming the second parameter to Tick's ctor is the timestamp
auto itBelow = std::lower_bound(ticks.begin(), ticks.end(), Tick(Vec3(0, 0, 0), 214), CompareTicks);
</code></pre>

<p>You have to do one extra step with <code>itBelow</code> now to get the first element before 214, taking care not to go past the beginning of the list:</p>

<pre><code>if(itBelow == ticks.begin())
   ; // there is nothing in ticks &lt; 214. I don't know what you want to do in this case.
else
   --itBelow;
</code></pre>

<p>Now, assuming you didn't hit any of the error cases, <code>itAbove</code> is pointing to the first element > 214, and <code>itBelow</code> is pointing to the last element &lt; 214.</p>

<p>This assumes your <code>Tick</code>s are in order by timestamp, which seems to be the case. Note also that this technique will work even if there are multiple 214s in the list. Finally, you said the list is short so it's not really worth worrying about time complexity, but this technique could get you logarithmic performance if you also replaced the <code>list</code> with a <code>vector</code>, as opposed to linear for iterative approaches.</p>
",15
23571458,23570929,1,"<p>The answer to your core question is simple. Don't increment if you are at the end. Don't decrement if you are at the start.</p>

<p>Before incrementing, check.</p>

<pre><code>if ( iter == ticks.end() )
</code></pre>

<p>Before decrementig, check.</p>

<pre><code>if ( iter == ticks.begin() )
</code></pre>

<p><strong>Your particular example</strong></p>

<p>Looking at what you are trying to accomplish, I suspect you meant to use:</p>

<pre><code>        if (iter != ticks.begin())
</code></pre>

<p>instead of</p>

<pre><code>        if (--iter != ticks.end())
</code></pre>

<p><strong>Update</strong></p>

<p>It seems you are relying on the contents of your list being sorted by timestamp. </p>

<p>After your comment, I think what you need is:</p>

<pre><code>    if (214&gt;= t.timestamp)
    {
        prior = t;
        if (++iter != ticks.end())
        {
            next = *iter;
            if ( 214 &lt;= next.timestep )
            {
               found = true;
               break;
            }
        }
    }
</code></pre>

<p><strong>Update 2</strong></p>

<p>I agree with the comment made by @crashmstr. Your logic can be:</p>

<pre><code>    if (214 &lt;= t.timestamp)
    {
        next = t;
        if ( iter != ticks.begin())
        {
            prior = *--(iter);
            found = true;
            break;
        }
    }
</code></pre>
",7
23572497,23570929,1,"<p>I think you can do what you want with <code>std::adjacent_find</code> from the standard library <code>&lt;algorithm&gt;</code>. By default <code>std::adjacent_find</code> looks for two consecutive <em>identical</em> elements but you can provide your own function to define the relationship you are interested in.</p>

<p>Here's a simplified example:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;

struct matcher
{
    matcher(int value) : target(value) {}
    bool operator()(int lo, int hi) const {
        return (lo &lt; target) &amp;&amp; (target &lt; hi);
    }
    int target;
};

int main()
{
    std::list&lt;int&gt; ticks = { 0, 100, 200, 300 };

    auto it = std::adjacent_find(ticks.begin(), ticks.end(), matcher(214));

    if (it != ticks.end()) {
        std::cout &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; *std::next(it) &lt;&lt; '\n';
    } else {
        std::cout &lt;&lt; ""not found\n"";
    }
}
</code></pre>

<p>This outputs <code>200 300</code>, the two ""surrounding"" values it found.</p>
",0
30168700,30168634,2,"<p>That is because you cannot bind a temporary to a non-const reference. Mark your reference as <code>const</code> and it will work.</p>

<p>Also, you are using a standard C++ keyword (<code>struct</code>) in the definition</p>

<pre><code>void myfunc(structazauras&amp; struct) { }
</code></pre>

<p>Change the name to something else. Or maybe you meant </p>

<pre><code>void myfunc(struct structazauras&amp;) { }
</code></pre>

<p>but the additional <code>struct</code> is superfluous in C++.</p>
",3
34232972,34232689,3,"<p>As others have already mentioned, in your line</p>

<pre><code>cout &lt;&lt; ""anyLarger(cat, dog)       =  "" &lt;&lt; anyLarger(""cat"", ""dog"") &lt;&lt; endl;
</code></pre>

<p>you are invoking <code>anyLarger&lt;const char &amp;[]&gt;</code>, i.e. you call <code>anyLarger</code> with string literal arguments, which indeed boils down to comparing pointers instead of strings. You can fix this by either calling your function with std::string arguments by one of the following lines:</p>

<pre><code>larger(""cat"", ""dog"");
anyLarger&lt;std::string&gt;(""cat"", ""dog"");
anyLarger(std::string(""cat""), std::string(""dog""));
anyLarger(""cat""s, ""dog""s); // C++14
</code></pre>

<p>or you could do a template specialization for string literals (or just any C-type strings, whatever you choose):</p>

<pre><code>template &lt;&gt;
elementType anyLarger&lt;char*&gt;(char* parameter1, char* parameter2)
{
    if (strcmp(parameter1, parameter2) &gt;= 0)
      return parameter1; 
    else
      return parameter2;
}
</code></pre>
",1
34232717,34232689,4,"<pre><code>""cat"" &gt;= ""dog""
</code></pre>

<p>You are comparing pointers but not the actual values. Use <code>strcmp</code>.</p>
",1
34232727,34232689,10,"<p>You are not lexicographically comparing strings in both cases.</p>

<pre><code>""cat"" &gt;= ""dog""
</code></pre>

<p>This is comparing <code>char</code> pointers because the type of the literals <code>""cat""</code> and <code>""dog""</code> is <code>const char*</code>. It could give either result, depending on how the compiler decided to materialize the literals.</p>

<p>To lexicographically compare C-style strings (including literals like these) the function <code>strcmp</code> must be used instead.</p>

<pre><code>strCat &gt;= strDog
</code></pre>

<p>This is comparing strings lexicographically because <code>std::string</code> provides comparison operators that explicitly implement this kind of comparison.</p>
",5
34232728,34232689,4,"<p>That's because string literal (e.g. <code>""cat""</code>) isn't of type <code>std::string</code>. You're doing a pointer comparison on two unrelated arrays of <code>const char</code>.</p>
",1
34232816,34232689,3,"<p>The literal string <code>""cat""</code> and <code>""dog""</code> are actually <em>pointers</em> to arrays of characters when you come to compare them, so the greatest will be the one that happens to be stored in memory at a higher location.</p>

<p>Your <code>string larger(string y, string z)</code> works because <code>std::string</code> can be constructed from a <code>char*</code> and so <code>""cat""</code> and <code>""dog""</code> get converted to <code>std::string</code> objects before being compared.</p>

<p>The <em>template</em> function, on the other hand, accepts them as their actual types which, when passed as parameters, become <code>const char*</code> and only their addresses get compared.</p>
",7
29502460,29502201,1,"<p>If you want to fill your matrix with zeros you may also consider:</p>

<pre><code>cv::Mat dst = Mat(1,1, CV_64F, cvScalar(0.));
</code></pre>

<p>OR</p>

<pre><code>cv::Mat dst;
dst= Mat::zeros(1, 1, CV_64F);
</code></pre>

<p>Hope that helps!</p>
",0
29502351,29502201,1,"<p>This is because the first syntax</p>

<pre><code>cv::Mat dst = cv::Scalar::all(0);
</code></pre>

<p>is actually calling a constructor and initializing (to be precise, it tries to call a copy-constructor). On the other hand, this syntax</p>

<pre><code>cv::Mat dst;
dst = cv::Scalar::all(0);
</code></pre>

<p>calls an assignment operator, which is <a href=""http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator"" rel=""nofollow"">perfectly defined when scalar is on the right side</a>.</p>
",0
29236114,29235970,1,"<p><strong>Option 1: Add <code>scanner.cpp</code> to the command line</strong></p>

<pre><code>clang++ -O3 -std=c++11 -stdlib=libc++  -I./includes/ -I./compiler/  compiler/program.cpp compiler/scanner.cpp -o hej
</code></pre>

<p><strong>Option 2: Separate the compilation steps from the link step</strong></p>

<pre><code>clang++ -c -O3 -std=c++11 -stdlib=libc++  -I./includes/ -I./compiler/  compiler/program.cpp -o compiler/program.o
clang++ -c -O3 -std=c++11 -stdlib=libc++  -I./includes/ -I./compiler/  compiler/scanner.cpp -o compiler/scanner.o
clang++ -O3 -std=c++11 -stdlib=libc++  compiler/program.o compiler/scanner.o -o hej
</code></pre>

<p><strong>Option 3: Use a Makefile</strong></p>

<p>Contents of <code>Makefile</code>:</p>

<pre><code>CXX=clang++
CXXFLAGS= -O3 -std=c++11 -stdlib=libc++ -Wall -I./includes/ -I./compiler/ 

hej: compiler/program.o compiler/scanner.o
    clang++ -O3 -std=c++11 -stdlib=libc++ -o $@ $^
</code></pre>

<p>Then just run:</p>

<pre><code>make
</code></pre>
",0
31156050,31155682,0,"<p>You can try defining such structure:</p>

<pre><code>typedef struct _VarLengthStr
{
    unsigned int    length;
    unsigned char   string[1];
} VarLengthStr, *PVarLengthStr;
</code></pre>

<p>You may need different type for length. Also you need allocate memory with <code>new</code> or <code>malloc</code> </p>

<hr>

<p>Also you may use safe functions like <a href=""https://msdn.microsoft.com/en-us/library/z50ty2zh.aspx"" rel=""nofollow""><code>strnlen_s</code></a> instead of <code>strlen</code> and etc.</p>
",4
23595154,23595054,1,"<p>When you write it like</p>

<pre><code>R();
</code></pre>

<p>it is a <strong>Declaration</strong> of the <code>constructor</code>. You have to give each method you use a <strong>Definition</strong> also by giving it a body (even if the body is empty like here). For class method, either you provide the body as you did here <em>inside</em> the class, or you can define it separately in a source (.cpp) file like</p>

<pre><code>R::R(){/*your code*/}
</code></pre>

<p>it is similar to the code for
 <code>CVector CVector::operator+</code> as you posted.</p>
",1
23595157,23595054,2,"<p>From your comments, I can surmise that the error is related to the missing definition of <code>R:: R ()</code>. </p>

<p>MSVC's <code>Error LNK2019</code> refers to an unresolved symbol. A symbol is any function, object, variable, or type which has been <strong>declared</strong> but not <strong>defined</strong>. </p>

<p>In this case, I'm guessing that you have never provided a definition for <code>R:: R ()</code>, but you wrote it in the class definition, which tells the compiler that it's there somewhere -- that's the declaration.  </p>

<p>But, apparently, you never defined it. 
Adding <code>{}</code> provides the body of the function, which is why it works with those braces. </p>

<p>You could also define <code>R:: R()</code> as you did <code>R:: display ()</code>, externally, or, if your compiler supports C++11, write explicitly <code>R:: () = default</code>.</p>

<p>Once you give the linker a body of the function, your code should link fine.</p>
",1
23595200,23595054,1,"<p>You NEED to have a default constructor.</p>
",1
27572852,27572463,3,"<p><code>rfind</code> is potentially inefficient since in the case where the string <em>doesn't</em> end with <code>Time</code> it will keep searching the string.</p>

<p><code>compare</code>, however, looks at exactly the part of the string you're interested in:</p>

<pre><code>if (s.size() &gt;= 4 &amp;&amp; s.compare(s.size()-4, 4, ""Time"") == 0) {
    s.resize(s.size() - 4);
}
</code></pre>

<p>As you see, I've used the number <code>4</code> four times in the code. Dubious style, but it gets the job done. I've decided that for a case with a fixed string so short, this is clearer than putting the length in a variable, but YMMV.</p>
",1
23303949,23303906,1,"<p>You're reading too much in to the word <code>char</code>.</p>

<p>At the end of the day, it is little more than a size.  In this case, 8 bits.  Shorts are 16 (and you can wear them on the beach), ints can be 32 or something else, and longs can be 64 (or ints, or a quick conversation with the relevant authorities on the beach as to why you lost both pairs of shorts).</p>

<p>The correct way to define a value in C++ is basically down to what the maximum value that can be held.  <code>char_traits::eof()</code> is indeed a good constant, but out of context - means very little.  </p>
",1
21790075,21789912,4,"<p>The short answer:  Undefined behavior is undefined.</p>
",0
27125779,27125656,0,"<p>When you return a local object from a function, a copy is created (with a copy costructor). In your example, <code>fooReturn</code> contains a copy of the <code>f</code> object (local to <code>bar</code>). After the <code>f</code> is copied, it is freed.</p>
",2
27125792,27125656,2,"<blockquote>
  <p>how come when <code>bar()</code> returns, <code>fooReturn</code> contains a valid object?</p>
</blockquote>

<p>Because the value of the return expression (<code>f</code>) is used to initialise <code>fooReturn</code> before it's destroyed. As long as the type has correct copy/move semantics, or the copy/move is elided, the resulting object will be valid.</p>

<blockquote>
  <p>is: <code>foo f</code> similar to <code>foo *f  = new foo();</code> are both objects on the heap?</p>
</blockquote>

<p>No, the first is an automatic variable, stored in the function's stack frame and destroyed when it goes out of scope. The second is a dynamic object, stored on the heap, and not destroyed without an explicit <code>delete</code>.</p>
",0
27125830,27125656,3,"<p>No, <code>foo f;</code> is very different from <code>foo * f = new foo();</code>, since the former <code>foo</code> is built on the stack, its destructor is automatically called when it goes out of scope, etc.<br>
Instead, the latter <code>foo</code> is built on the heap, requires manual destruction calling <code>delete</code>, etc.</p>

<p>But, in your sample code, the returned <code>foo f</code> is <em>copied</em> or <em>moved</em> (if <code>foo</code> provides move semantics, e.g. move constructor), out of the function <code>bar()</code>. So you have a valid object returned to the caller.</p>

<hr>

<p><strong>Note</strong><br>
The be more precise, there is an optimization that the C++ compiler may apply, i.e. the <a href=""http://en.wikipedia.org/wiki/Return_value_optimization"" rel=""nofollow""><strong>RVO</strong> <em>(Return Value Optimization)</em></a>, that could avoid the copy or move of the returned <code>foo</code>.</p>
",0
21588179,21588138,4,"<p>The problem is that >> at the and of your expression is parsed as a bit-shift operator instead of end of template. It was fixed in c++11 but in previous versions of c++ you need to add a space between angle brackets : <code>QThreadStorage&lt;QSharedPointer&lt;sqlite3&gt; &gt; database;</code></p>
",0
21588239,21588138,0,"<p><code>&gt;&gt;</code> is interpreted as an operator rather than nested generics in pre-C++11.</p>

<p>You'll need to upgrade your compiler, or just leave a space between them, like <code>&gt; &gt;</code>.</p>
",0
29898686,29897976,2,"<p>You could create a factory method registration system by making subclasses of <code>IAnimal</code> add themselves into the factory map with a string identifier and creation function. Something like this:</p>

<pre><code>struct IAnimal;
//I made this a Singleton for simplicity
struct AnimalFactory
{
    //the type of a factory method
    using FactoryFunction = std::function&lt;IAnimal*(const std::string&amp;)&gt;;
    //register a factory function
    bool RegisterFunction(const std::string &amp;name, FactoryFunction f)
    {
        factoryMap.insert(std::make_pair(name,f));
        //do some error handling to see if the class is already registered, etc.
        return true;
    }

    //do the actual construction
    std::unique_ptr&lt;IAnimal&gt; CreateAnimal(const std::string &amp;name, const std::string &amp;xml)
    {
        //retrieve the factory method from the map and call it
        return std::unique_ptr&lt;IAnimal&gt;(factoryMap.at(name)(xml));
    }

    //singleton implementation
    static AnimalFactory &amp;instance()
    {
        static AnimalFactory factory{};
        return factory;
    }

private:
    std::map&lt;std::string, FactoryFunction&gt; factoryMap;
};
</code></pre>

<p>Your subclasses then register themselves like this:</p>

<pre><code>struct Cat : IAnimal
{
    Cat (const std::string &amp;xml) {}
    static Cat* CreateAnimal(const std::string &amp;xml) { return new Cat(xml); }
    static bool registered;
};
bool Cat::registered = 
   AnimalFactory::instance().RegisterFunction(""cat"", Cat::CreateAnimal);

struct Elephant : IAnimal
{
    Elephant (const std::string &amp;xml) {}
    static Elephant* CreateAnimal(const std::string &amp;xml) { return new Elephant(xml); }
    static bool registered;
};
bool Elephant::registered = 
   AnimalFactory::instance().RegisterFunction(""elephant"", Elephant::CreateAnimal);
</code></pre>

<p>Then you call the factory methods like this:</p>

<pre><code>auto cat = AnimalFactory::instance().CreateAnimal(""cat"",""hi"");
auto elephant = AnimalFactory::instance().CreateAnimal(""elephant"",""hi"");
</code></pre>

<p>There are a number of different facets to this approach. I would highly recommend reading section 8 ""Object Factories"", from Andrei Alexandrescu's ""Modern C++ Design"" for suggestions and discussion on this.</p>

<p><a href=""https://ideone.com/SR3eKD"" rel=""nofollow"">Demo</a></p>
",0
29899035,29897976,0,"<p>Use the <a href=""http://en.wikipedia.org/wiki/Factory_method_pattern"" rel=""nofollow"">Factory method pattern</a>, instead of creating the map.</p>

<p>Disrigarding the concrete solution, you will anyway have the decision point somewhere to create the subclass instance depending on the animal name (or type).</p>

<p>Here is an example with Factory method:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using std::string;
using std::vector;

class XmlReader {}; // Somewhere XmlReader defined

class IAnimal
{
public:
    static IAnimal* CreateAnimal(const XmlReader* xml);

public:
    virtual ~IAnimal() {}
    virtual string GetSound() const = 0;
};

class Cat: public IAnimal
{
    string GetSound() const { return ""Miaow""; }
};

class Elephant: public IAnimal
{
    string GetSound() const { return ""Rouw""; }
};

IAnimal* IAnimal::CreateAnimal(const XmlReader* xml)
{
    string name = xml-&gt;getname();
    if(name == ""cat"")
        return new Cat(xml);
    else if (name == ""elephant"")
        return new Elephant(xml);
    else
        return NULL;
}

int main()
{
    XmlReader xml(""animal.xml"");
    vector&lt;IAnimal*&gt; zoo;
    while(!xml.eof())
    {
        IAnimal* animal = IAnimal::CreateAnimal(&amp;xml);
        std::cout &lt;&lt; animal-&gt;GetSound() &lt;&lt; std::endl;
        zoo.push_back(animal);
    }
}
</code></pre>
",0
26437148,26437075,5,"<p>You should use class scope when defining a class member outside its class.</p>

<pre><code>Test::Test(){
}

Test::Test(int aNumber){
    //...
}

int Test::getNumber(){
    //...
}
</code></pre>

<p>Also, don't forget to compile and link test.cpp. Compiling only main.cpp (or whatever is your driver source file called) could also lead to such linking error.</p>

<p>If you use GCC, use the following command to build:</p>

<pre><code>g++ -o test main.cpp test.cpp
</code></pre>
",6
31147038,31146854,6,"<p>You're using ""aggregate initialization"" but a class with a base class cannot be an aggregate, so you cannot use aggregate initialization.</p>

<p>As the comment above says, if you add a suitable constructor then you can use the same syntax:</p>

<pre><code>struct bStruct : aStruct {
    constexpr bStruct(int a, int b, int c) : aStruct{a, b}, c(c) { }
    int c;
};
</code></pre>

<p>(You don't need a constructor for <code>aStruct</code> because that is still an aggregate so can still be initialized directly using aggregate initialization).</p>
",3
31147071,31146854,2,"<p>You need to define a constructor in bStruct like this:</p>

<p><code>bStruct(int a, int b, int c) : aStruct{a, b}, c(c) {}</code></p>

<p>This will initialize aStruct and the c field.</p>

<p>Note: This is c++11 code.</p>
",0
31147167,31146854,-2,"<pre><code>#include &lt;iostream&gt;
using namespace std;

struct A
{
    int a; int b;
};
struct B : A
{
    //c++ 0x
    B(int a, int b, int c) : A{ a, b }, c(c) 
    {}
    int c;
};
int main()
{
    B b{ 1,2,3 };
    cout &lt;&lt; b.a &lt;&lt; b.b &lt;&lt; b.c &lt;&lt; endl;
}
</code></pre>
",1
29455339,29455259,1,"<p>Perhaps, I do not understand the idea of your program, but I think, it have to be like that:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

struct Base {
  Base(string name) {
    this-&gt;name = name;
  }
  string name;
};

struct Derived: Base {
    Derived(string name):Base(name)
    {
    }
    // string name2; // it is not needed
};

template &lt;typename T&gt;
T* createNode(string name) {
  T* node = new T(name);
  return node;
}

int main() {
  Derived* node = createNode&lt;Derived&gt;(""hej"");
  node-&gt;name = ""bajs"";
  cout &lt;&lt; node-&gt;name;
}
</code></pre>
",4
29455346,29455259,2,"<p>This bit of code:</p>

<pre><code>template &lt;typename T&gt;
T createNode(string name) {
  Base* node = new Base(name);
  return static_cast&lt;T&gt;(node);
}
</code></pre>

<p>creates an object of type <code>Base</code>. </p>

<p>This:</p>

<pre><code>  Derived* node = createNode&lt;Derived*&gt;(""hej"");
  node-&gt;name2 = ""najs"";    // No need to use rude words, even if you think most people can't read them.
</code></pre>

<p>Uses the created object as <code>Derived</code>. Since <code>Derived</code> requires more space than <code>Base</code>, when you use <code>name2</code>, you are overwriting something outside of the object created in <code>createNode</code>. <code>name2</code> also hasn't been constructed, meaning the assignment most likely uses random garbage values, which could well in itself cause a crash.</p>

<p>You will need to rearrange your code such that it creates the correct object first, and if you want to use a constructor, you need to have a constructor for <code>Derived</code> that takes the named object. [There are some other ways to achieve this too, but typically not what you want here]</p>
",3
26434267,26431613,1,"<p>It is impossible until <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2965.html"" rel=""nofollow"">N2965</a> is implemented.</p>
",0
29218168,29218032,4,"<p>In the first case, the compiler can tell, from just the class definition (not the definition of any members) that the variable won't be initialised. The class definition must be available in order to define the variable, so it's simple to state a rule to say that says the program is ill-formed if a <code>const</code> variable is left uninitialised in that case.</p>

<p>In the second, it would need the definition of the user-declared constructor to determine whether or not it's initialised. That's not necessarily available when the compiler is dealing with the variable definition, so in general it can't check whether or not the constructor initialises everything; the constructor definition isn't necessarily available. As is often the case, a diagnosis isn't required even in those cases like this, where the constructor's definition is available and the compiler could figure it out.</p>
",0
21173574,21173308,4,"<p>C++03 solutions:</p>

<p>Use vector constructor that takes a pair of iterators.</p>

<pre><code>char* arr[] = {""sds"", ""bsdf"", ""dsdfaf""};
vector&lt;string&gt; v(arr, arr + sizeof(arr)/sizeof(arr[0]));
</code></pre>

<hr>

<p>Use an array if the length doesn't need to change after initialization. To avoid hardcoding array length use this function template to deduce size</p>

<pre><code>template&lt;typename T, std::size_t N&gt;
std::size_t length_of( T const (&amp;)[N] ) { return N; }

char* v[] = {""sds"", ""bsdf"", ""dsdfaf""};
for (int i = 0; i &lt; length_of(v); ++i) do_something(v[i]);
</code></pre>

<p>Note that this won't work within a function to which you pass a <code>char **</code>.</p>

<hr>

<p>Use <a href=""http://www.boost.org/libs/assign/doc/index.html#list_of_ref"" rel=""nofollow""><code>boost::assign::list_of</code></a></p>

<pre><code>using boost::assign::list_of;
std::vector&lt;std::string&gt; v = list_of(""sds"")(""bsdf"")(""dsdfaf"");
</code></pre>
",5
21173675,21173308,0,"<blockquote>
  <p>Note that v remains unchanged after initialization. So an array might work too but the problem with array is that I need to also hardcode the length of the array in my code.</p>
</blockquote>

<p>That's not true.  You can get the <em>array</em> size the canonical way one does so like the following:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    char const * const v[] = {""sds"", ""bsdf"", ""dsdfaf""};

    // Only works when array length is known at compile-time.
    size_t const len = sizeof(v) /sizeof(v[0]);
    for (size_t i = 0; i &lt; len; ++i)
        std::cout &lt;&lt; v[i] &lt;&lt; '\n';
}
</code></pre>

<p>The output is:</p>

<pre><code>$ g++ -Wall foo.cpp ; ./a.out 
sds
bsdf
dsdfaf
</code></pre>
",0
21173344,21173308,4,"<p>In C++11 you can write:</p>

<pre><code>std::vector&lt;std::string&gt; v{""sds"", ""bsdf"", ""dsdfaf""};
</code></pre>
",0
21173347,21173308,2,"<blockquote>
  <p>Is there a better/cleaner way to do this?</p>
</blockquote>

<p>You can use the <em>brace initialization syntax</em>:</p>

<pre><code>std::vector&lt;std::string&gt; v { ""sds"", ""bsdf"", ""dsdfaf"" };
</code></pre>

<hr>

<blockquote>
  <p>Note that v remains unchanged after initialization.</p>
</blockquote>

<p>You can use an <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow""><code>std::array</code></a> (since C++11):</p>

<pre><code>std::array&lt;std::string, 3&gt; a {{ ""sds"", ""bsdf"", ""dsdfaf"" }};
</code></pre>

<p>You'll still have to ""hardcode"" the number of elements, but it's not dynamic anyway, so you don't lose much.</p>
",0
23554457,23504286,3,"<p><em>Warning: Most of the stuff below is of course implementation and platform dependent and simplified. I'll follow the way I see it is implemented in your examples -- probably GCC, 64-bits.</em></p>

<hr>

<p>First, what is the contract for instances of virtual classes? E.g. if you have a variable <code>IFace1* obj</code>:</p>

<ul>
<li>There is a pointer to virtual table at <strong>obj+0</strong>.</li>
<li>Any member data fields would continue at <strong>obj+8</strong> (<code>sizeof(void*)</code>).</li>
<li>The virtual table contains one record which points to <code>void fcn(int)</code> at <strong>vtbl+0</strong>.</li>
<li>In the table, there is also a pointer to <code>typeinfo</code> of the class at <strong>vtbl-8</strong> (used by <code>dynamic_cast</code> etc.) and ""<em>offset to base</em>"" at <strong>vtbl-16</strong>.</li>
</ul>

<p>Any function which sees a variable of type <code>IFace1*</code> can depend on this being true. Similarly for <code>IFace2*</code>.</p>

<ul>
<li>If they want to call the virtual function <code>void fcn(int)</code>, they look at <strong>obj+0</strong> to get the vtable, then at <strong>vtbl+0</strong> and call the address found there. <code>this</code> is set to <strong>obj</strong>.</li>
<li>If they want to access a member field (by themselves, e.g. if the field has public access, or if there is an inline accessor), they just read/write the member at its address <strong>obj+xxx</strong>.</li>
<li>If they want to see what type they really have, they subtract the value at <strong>vtbl-16</strong> from the address to their object, then look at the <code>typeinfo</code> pointer of the vtable referenced by the base object.</li>
</ul>

<hr>

<p>Now, how can you compiler satisfy these requirements for a class with multiple inheritance?</p>

<p><strong>1)</strong> First it needs to generate the structure for itself. The virtual table pointer must be at <strong>obj+0</strong>, so there it is. How will the table look like? Well, the <em>offset to base</em> is 0, obviously, the <code>typeinfo</code> data and pointer to it is generated easily, then the first virtual function and the second, nothing special. Anyone who knows the definition of <code>RealClass</code> can do the same calculations, so they know where to find the functions in the vtable etc.</p>

<p><strong>2)</strong> Then it goes to make it possible to let <code>RealClass</code> be passed around as <code>IFace1</code>. So it needs to have a pointer to virtual table in the <code>IFace1</code> format somewhere in the object, then the virtual table must have that one record for <code>void fcn(int)</code>.</p>

<p>The compiler is clever and sees that it can reuse the first virtual table it has generated, because it complies with these requirements. If there were any member fields, they would be stored after the first pointer to the virtual table, so even them could be accessed simply as if the derived class was the base one. So far so good.</p>

<p><strong>3)</strong> Finally, what to do with the object so others will be able to use it as <code>IFace2</code>? The one vtable already created cannot be used anymore, because <code>IFace2</code> needs its <code>void fcn1(int)</code> to be at <strong>vtbl+0</strong>.</p>

<p>So another virtual table is created, the one you see immediately following the first one in your dump, and a pointer to it is stored in <code>RealClass</code> at the next available place. This second table needs to have <em>offset to base</em> set to -8, because the real object starts at offset -8. And it contains just the pointer to that <code>IFace2</code> virtual function, <code>void fcn1(int)</code>.</p>

<p>The virtual pointer in the object (at offset <strong>obj+8</strong>) would be then followed by any member data fields of <code>IFace2</code>, so that any inherited or inline functions could again work when given the pointer to this interface.</p>

<hr>

<p>OK, now how can someone call the <code>fcn1()</code> from <code>IFace2</code>? What is that <code>non-virtual thunk to RealClass::fcn1(int)</code>?</p>

<p>If you pass your <code>RealClass*</code> pointer to a stranger function which takes <code>IFace2*</code>, the compiler will emit code to increase your pointer by 8 (or however large <code>sizeof(void*) + sizeof(IFace1)</code> is), so that the function gets the pointer which starts with the virtual table pointer of <code>IFace2</code>, then its member fields -- just as agreed in the contract I outlined earlier.</p>

<p>When that function wants to call <code>void IFace2::fcn1(int)</code>, it looks into the virtual table, goes to the record of this particular function (the first and only one) and calls it, with <code>this</code> set to the address being passed as pointer to <code>IFace2</code>.</p>

<p>And here arises a problem: If someone invokes this method implemented in <code>RealClass</code> on a <code>RealClass</code> pointer, <code>this</code> points to the base of <code>RealClass</code>. The same with <code>IFace1</code>. But if it is invoked by someone having a pointer to the <code>IFace2</code> interface, <code>this</code> points 8 (or however many) bytes into the object instead!</p>

<p>So the compiler would need to generate the function multiple times to accomodate this, otherwise it could not access member fields and other methods correctly, as it differs depending on who is calling the method.</p>

<p>Instead of having the code really twice, the compiler optimizes this by creating that hidden implicit small <strong>thunk</strong> function instead, which just</p>

<ol>
<li>decreases the <code>this</code> pointer by the proper amount,</li>
<li>calls the real method, which can now work fine regardless of who invoked it.</li>
</ol>
",0
34191371,34191331,2,"<p>Use <code>clang++ tutorial.cpp</code> - the <code>-x c++</code> is useful if you only want to compile the source file, using <code>-c</code>, but if you are also linking the application into an executable, you want <code>clang</code> to know that you are linking a C++ application, and add the c++ libraries to the link command (if you want to see what <code>clang</code> actually does, add the <code>-v</code> option. </p>
",0
29443605,29443533,2,"<p>The method reserve(..) only guarantees that the space is allocated. It does not guarantee the values in the elements of the vector. The only thing that will happen is that your counting will not crash. The resulting value is implementation/allocation/etc dependent.</p>

<p>The core idea that is necessary to understand about containers and iterators is that they are the same insecure as simple arrays:</p>

<pre><code>char b1[100];
vector&lt;char&gt; b2(100);

void f()
{
   char c1 = b1[200];
   char c2 = b2[300];
}
</code></pre>

<p>In both cases compiler will generate code that will pick up something outside of the array. Both examples trigger undefined behavior. Maybe the code will crash, maybe not. Both accesses are equally bad.</p>

<p>The main reason for such design is speed. Access to array should be fast. This is core idea of C/C++. The value of the index is the responsibility of the programmer. Compiler will not check. Like it or not, this is so.</p>
",3
32491550,32491452,1,"<p>First of all if you have a cycle your code will keep running forever since you are never excluding anything and you didn't specify that we are talking about acyclic graphs.</p>

<p>Second thing, doing <code>Node* node = new Node(*this)</code> already copies the <code>std::vector</code> of nodes, so re-adding them with <code>addChild</code> makes no sense.</p>

<p>This problem could be solved in multiple ways, the first one that comes into my mind is to use a support data structure to avoid cloning same nodes, something similar to:</p>

<pre><code>Graph(const Graph&amp;h) {
  std::unordered_map&lt;Node*,Node*&gt; alreadyCloned;
  root = h.root-&gt;clone();
}

Node* clone(std::unordered_map&lt;Node*,Node*&gt;&amp; alreadyCloned)
{
  auto it = alreadyCloned.find(this);

  // if we try to clone a node already cloned just return
  // the clone already created
  if (it != alreadyCloned.end())
    return it-&gt;second;

  Node* n = new Node();
  alreadyCloned.insert(this, n); // mark node as clone, so if by recursively visiting we find it, we skip it since we're still cloning

  for(int i = 0; i &lt; this-&gt;childs.size(); i++)
    n-&gt;childs.push_back(childs[i]-&gt;clone(alreadyCloned));

  return n;
}
</code></pre>

<p>This code is untested and may have problems, is just to give you the idea behind the approach.</p>
",0
28312586,28312552,3,"<p>In the constructor <code>circle(float)</code>, it needs to call the default constructor <code>ellipse()</code> with no arguments, because you did not provide any arguments in the ""initialization list.""  To fix it, do this (and remove your <code>ellipse()</code> default constructor):</p>

<pre><code>circle(float r)
  : ellipse(r, r)
{
}
</code></pre>

<p>This simply delegates the initialization of <code>a</code> and <code>b</code> to the two-argument <code>ellipse</code> constructor.  It offers better encapsulation and more concise code.</p>
",3
26784271,26784201,1,"<p>You can convert it forcefully by casting away constness using :- </p>

<pre><code>Params.pwchFileName = const_cast&lt;wchar_t*&gt;( wide.c_str() ); 
</code></pre>

<p>But use const_cast when you have no other choice.</p>

<p>Be careful, writing into that object invokes undefined behavior.</p>
",0
26784284,26784201,2,"<p>The only way of making a non-constant value from a constant one that would be safe in all contexts is to make a copy:</p>

<pre><code>Params.pwchFileName = new char[wide.size()+1];
strcpy(Params.pwchFileName, wide.c_str());
...
// when you are done with the copy, delete it:
delete[] Params.pwchFileName;
</code></pre>
",0
26784335,26784201,3,"<p>You could, with extreme caution, use a <code>const_cast</code>:</p>

<p><code>const_cast&lt;wchar_t*&gt;( wide.c_str());</code></p>

<p>But the are other issues here: if <code>wide</code> is a <code>std::string</code> then the results of <code>c_str()</code> are only valid for as long as <code>wide</code> is in scope and has not been changed in any way. Even if you conform to this, then a consumer of <code>PARAMS</code> <em>could</em> modify the string buffer which would give you <em>undefined behaviour</em>.</p>

<p>The best thing to do here is to use <code>strcpy</code> to take a deep copy of the string buffer, remembering to <code>delete</code> that buffer once you're done with it.</p>
",0
25543892,25543742,2,"<p>As user657267 pointed out in his comment, you may not concatenate a string literal and an int <code>string fileName = ""Delay"" + nodeNum;</code>. Here you are getting a pointer into the literal, that may even be out of range:</p>

<pre><code>string s = ""hello""+1; // leads to ""ello"" in s
</code></pre>

<p>The probably intended concatenation can be done using a <a href=""http://en.cppreference.com/w/cpp/io/basic_stringstream"" rel=""nofollow"">stringstream</a>:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;assert&gt;

void concat_check()
{
    std::stringstream ss;
    ss &lt;&lt; ""hello"" &lt;&lt; 1;
    assert(ss.str() == ""hello1"");
}
</code></pre>
",3
25544595,25543742,0,"<p>Wolf you are a little bit wrong</p>

<pre><code>string s = ""hello""+3;
</code></pre>

<p>gives ""lo"" in s data</p>

<p>and </p>

<pre><code>string si = string(""hello"")+3;
</code></pre>

<p>is incorrect you need to use stringstream instead</p>

<pre><code>std::stringstream ss;
ss &lt;&lt; ""hello"" &lt;&lt; 3;
std::string s = ss.str();
</code></pre>

<p>Dudi Reuveni how can you tell that nodeNum has wrong data?</p>
",4
22494504,22494238,1,"<p>One way to avoid this is to use a static function with a static variable in it.
So for example:</p>

<pre><code>class Collector
{
public:
  static std::vector&lt;int&gt; &amp; GetInts(){ static std::vector&lt;int&gt; Ints; return Ints; }
};
</code></pre>

<p>This way you are guaranteed the static variable is initialized when you use it regardless of which cpp file you're using it in.</p>

<p>I should stress though that this is not a great idea as you'll have issues with threading. Is there a good reason to make this static?</p>
",1
22491045,22491004,5,"<p>Yes, you can use an <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector&lt;char&gt;</code></a>:</p>

<pre><code>if (type == type1) {
    std::vector&lt;char&gt; x(A_NUMBER);
} else if (type == type2) {
    std::vector&lt;char&gt; x(ANOTHER_NUMBER);
} 
</code></pre>

<p>Remember to include the header with:</p>

<pre><code>#include &lt;vector&gt;
</code></pre>

<hr>

<blockquote>
  <p>While your example code matches the ""pseudo code"" in the question, I think part of the question is how to decide the size via type and then use the resulting storage unconditionally, i.e. outside the conditional blocks.</p>
</blockquote>

<p>Then it gets as simple as:</p>

<pre><code>std::vector&lt;char&gt; x;
if (type == type1) {
    x.resize(A_NUMBER);
} else if (type == type2) {
    x.resize(ANOTHER_NUMBER);
} 
</code></pre>
",3
22491076,22491004,-1,"<p>The raw C++ way is <code>new</code> and <code>delete</code></p>

<pre><code>char * command = new char[A_NUMBER];
// and later delete it like this
delete[] command;
</code></pre>

<p>Of course you'll have to manage the memory, and it is not recommended to use this approach because of many reasons you should be able to find online. So in conclusion... <strong>don't use this method if vector is an option</strong></p>

<p>If using a big array the best way would be to use C++ <code>vector</code>, you could even consider other data structures like <code>list</code> based on your needs (for example a lot of insert, deletions operations on your array).</p>
",21
22491090,22491004,0,"<p>Yes and no. In standard C++, you cannot keep the array on the stack and have its size determined in runtime.</p>

<p>However, you can turn the array into a dynamically-allocated one (i.e. on the heap). In C++, the standard way to do this is to use <code>std::vector</code>:</p>

<pre><code>std::vector&lt;char&gt; command(A_NUMBER); // or ANOTHER_NUMBER
</code></pre>

<p>Indexing will work just as before: <code>command[5]</code></p>

<p>However, if you need to pass the array to something which expects a C-style array (i.e. a <code>char *</code>), you'll have to use one of these:</p>

<pre><code>command.data();  // if your compiler supports C++11

&amp;command[0];  // if it does not
</code></pre>

<p>And of course, to use <code>std::vector</code>, you'll have to <code>#include &lt;vector&gt;</code>.</p>
",0
22491139,22491004,1,"<p>I believe this is what you want</p>

<pre><code>std::vector&lt;char&gt; x; // x is empty, with size 0

if (type == type1) {
    x.resize(A_NUMBER); // change size to A_NUMBER
} else if (type == type2) {
    x.resize(ANOTHER_NUMBER); // change size to ANOTHER_NUMBER
} 
</code></pre>
",0
22491888,22491004,0,"<p>Here's an example that works in C and C++:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int
main(int argc, char *argv[])
{
    char *opt;
    if(argc == 2) {
        opt = *++argv;
    }
    else {
        printf(""Usage: %s [small|large]\n"", *argv);
        return EXIT_FAILURE;
    }

    int *arr;
    int arrlen = 0;
    if (strcmp(opt, ""small"") == 0) {
        arrlen = 3;
        arr = (int *) malloc(arrlen*sizeof(int));
        int i;
        for(i = 0; i &lt; arrlen; i++)
            arr[i] = i+1; 
    }
    else if (strcmp(opt, ""large"") == 0) {
        arrlen = 5;
        arr = (int *) malloc(arrlen*sizeof(int));
        int i;
        for(i = 0; i &lt; arrlen; i++)
            arr[i] = i+1; 
    }
    if (arrlen &gt; 0) {
        int i;
        for(i = 0; arr[i]; i++)
            printf(""%i, "", arr[i]);
        printf(""\n"");
        free(arr);
    }
    return EXIT_SUCCESS;
}
</code></pre>

<p>Example:</p>

<pre><code>[gyeh@gyeh stackoverflow]$ ./dynarr
Usage: ./dynarr [small|large]
[gyeh@gyeh stackoverflow]$ ./dynarr small
1, 2, 3, 
[gyeh@gyeh stackoverflow]$ ./dynarr large
1, 2, 3, 4, 5, 
</code></pre>
",0
30173899,30173857,3,"<p>No, no leaks here because the memory is not dynamically allocated.</p>
",0
24768911,24768825,2,"<p>""extern globals"" are not objects (unless they include an initializer): They are forward-declarations.</p>

<p>Global objects are initialized in two phases:</p>

<ul>
<li>All those with compile-time constant initializers are done, the rest is zeroed.</li>
<li>The run-time initializers are run in order of object definition. (No ordering guarantees for objects in different compilation units!).</li>
</ul>

<p>Seems like UB got you there.</p>

<p>To solve the error, do one of these:</p>

<ul>
<li>Put the definition of the object before its first use in the same compilation unit (The most efficient method).</li>
<li><p>Put the object as a static in an accessor function. Init will be on first use (thread-safe!).</p>

<pre><code>Type&amp; getTypeSingleton() {
    static Type x/*optional initializer*/;
    return x;
}
</code></pre></li>
<li>(Implementation dependent) The compilation unit first mentioned on the command-line will be initialized first in all current implementations (As effifient as the first, but fragile).</li>
</ul>
",4
31866504,31866450,2,"<p>You need to use the <a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow noreferrer"">Clockwise/Spiral Rule</a>.</p>

<pre><code>int (*arr)[]={...};  // pointer to array of int
int *(arr[])={...};  // array of int pointers
int (&amp;arr)[]={...};  // a reference to an array of int
int &amp;(arr[])={...};  // an array of int references
</code></pre>

<p>The last one though is illegal: <a href=""https://stackoverflow.com/questions/1164266/why-arrays-of-references-are-illegal"">Why arrays of references are illegal?</a></p>
",0
31866575,31866450,6,"<ul>
<li><p><code>int (*arr)[] = { ... };</code></p>

<p>This is not an array at all. This is a <em>pointer</em> to an array of unknown size. Note that this a scalar type. It is just a data pointer, no different in nature from any other data pointer. Which means that the only way to use <code>{ ... }</code> initializer with it is to specify a single value of proper type inside the <code>{ ... }</code>. E.g.</p>

<pre><code>int (*arr)[] = { nullptr };
</code></pre>

<p>which is the same as</p>

<pre><code>int (*arr)[] = nullptr;
</code></pre></li>
<li><p><code>int *(arr[]) = { ... };</code></p>

<p>This is indeed an array. The same thing can be expressed as </p>

<pre><code>int *arr[] = { ... };
</code></pre>

<p>This is an array of <code>int *</code> pointers. It size will depend on how many initializers are supplied in <code>{ ... }</code>. E.g.</p>

<pre><code>int *arr[] = { nullptr, &amp;some_int, &amp;some_other_int };
</code></pre>

<p>declares <code>arr</code> as an array of 3 pointers of type <code>int *</code>.</p></li>
<li><p><code>int (&amp;arr)[] = { ... };</code></p>

<p>This is not an array per se. This is a <em>reference</em> to an array of unknown size. Again, the only legal <code>{ ... }</code> initializer in this case would be just one lvalue of type <code>int []</code> inside the <code>{ ... }</code>. If the array was declared <code>const</code>, you'd be able to attach it to a temporary array of <code>int</code>s using this syntax, e.g.</p>

<pre><code>const int (&amp;arr)[] = { 1, 2, 3 };
</code></pre>

<p>But without <code>const</code> it is not possible. (I have my doubts about the legality of this even with <code>const</code> though. GCC accepts it.)</p></li>
<li><p><code>int &amp;(arr[]) = { ... };</code></p>

<p>This is an attempt to declare an array of references. Not allowed.</p></li>
</ul>
",0
26797607,26797565,2,"<p>Change it to:</p>

<pre><code>void Date::showShortDate()
{
  std::cout &lt;&lt; month &lt;&lt; ""/"" &lt;&lt; day &lt;&lt; ""/"" &lt;&lt; year;
}
void Date::showLongDate()
{
   std::cout &lt;&lt; month &lt;&lt; "" "" &lt;&lt; day &lt;&lt; "", "" &lt;&lt; year;

}
void Date::showEuroDate()
{
   std::cout &lt;&lt; day &lt;&lt; "" "" &lt;&lt; month &lt;&lt; "" "" &lt;&lt; year;
}
</code></pre>

<p>Or do <code>using namespace std;</code> which i don't recommend.</p>

<p>include also in case you don't have already: <code>#include &lt;iostream&gt;</code></p>

<p>Basically there are standard functions in C++ which are defined within a namespace.
That namespace is <code>std</code> if you want to access these functions you need to tell the compiler where these functions come from. You do that by adding <code>std::</code> in front of the function. Or by telling it to use the std namespace ( again not recommended ).</p>

<hr>

<p>Read <a href=""http://www.cplusplus.com/doc/tutorial/namespaces/"" rel=""nofollow"">this</a> to understand the basic idea behind a namespace.</p>
",2
28515579,28515551,2,"<p>It's <em>""crashing""</em> because you have made a copy of that pointer unintentionally, and the <code>delete</code> is called on an already deleted pointer.</p>

<p>You need to provide a copy constructor (different from the automatically created one), that does handle this correctly (create a new pointer for the copy).</p>
",0
32484060,32484026,1,"<p>Your line of code: <code>*node._parent = this;</code> has two issues:</p>

<ol>
<li>operator precedence</li>
<li>assignment to <code>shared_ptr</code></li>
</ol>

<p>First operator precedence. Operator <code>.</code> is evaluated before operator <code>*</code>. So  currently your code is similar to doing this:</p>

<pre><code>*(node._parent)
</code></pre>

<p><code>node</code> doesn't have a <code>_parent</code> member, but <code>*node</code> does. So, fix it by either:</p>

<pre><code>(*node)._parent
</code></pre>

<p>Or even better:</p>

<pre><code>node-&gt;_parent
</code></pre>

<p>Then, you have another issue that you can't just assign to <code>shared_ptr</code> with <code>operator =()</code> like this. You need to change</p>

<pre><code>= this;
</code></pre>

<p>To:</p>

<pre><code>.reset(this);
</code></pre>

<p>So in total,</p>

<pre><code>node-&gt;_parent.reset(this);
</code></pre>
",2
32969484,32969083,0,"<p>I think an example of what you want is the openCV Mat object.
It is a container of an image.  The actual data is stored in a heap (<code>ucahr* data</code>).</p>

<p>So when you are about to delete a Mat object the Data will be deleted but the mat itself will still alive.  The Mat itself could be created in the stack and the data inside it would created in the heap.</p>

<hr>

<p>Tiny untested example:</p>

<pre><code>class my_container {
    my_container() {
        data = new your_class();
    }

    your_class* get_data() {
        if (data == nullptr) {
            //throw catchable exception or what ever you want
        }
        return data;
    }

    void delete() {
        delete data;
        data = nullptr;
    }
private:
    your_class* data;
}
</code></pre>

<p>of course this will result in memory leek if you do not free the data before destroying the <code>my_container</code> object that is the stack. So you may add to this class the smart pointer design pattern</p>
",0
32969779,32969083,2,"<p>This is what a <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow""><code>std::shared_ptr</code></a> is for.  When you create a <code>shared_ptr</code> as long as one reference exist the memory will still be valid.  Here is a little example of using a shared pointer:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

void use_shared_ptr(std::shared_ptr&lt;int&gt; sp)
{
    std::cout &lt;&lt; ""in use_shared_ptr() count is: "" &lt;&lt; sp.use_count() &lt;&lt; std::endl;
}

std::shared_ptr&lt;int&gt; function_that_returns_a_local_object()
{
    auto foo = std::make_shared&lt;int&gt;(42);
    std::cout &lt;&lt; ""just created shared_ptr.  count is: "" &lt;&lt; foo.use_count() &lt;&lt; std::endl;
    use_shared_ptr(foo);
    std::cout &lt;&lt; ""after use_shared_ptr(foo) count is "" &lt;&lt; foo.use_count() &lt;&lt; std::endl;
    return foo;
} // oh no.  foo gets destroyed here.  what is going to happen?

int main() 
{
    auto bar = function_that_returns_a_local_object();
    std::cout &lt;&lt; ""back in main count is: "" &lt;&lt; bar.use_count() &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>

<pre><code>just created shared_ptr.  count is: 1
in use_shared_ptr() count is: 2
after use_shared_ptr(foo) count is 1
back in main count is: 1
</code></pre>

<p>The plus side to this is there is no manual memory management and then when are completely done with the <code>shared_ptr</code> it destroys itself cleaning up the memory that was allocated with <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared"" rel=""nofollow""><code>make_shared</code></a></p>

<p>You could also hand out a <a href=""http://en.cppreference.com/w/cpp/memory/weak_ptr"" rel=""nofollow""><code>std::weak_ptr</code></a>.  A <code>weak_ptr</code> allows the underlying pointer to be deleted unless you call <code>lock</code> which creates a shared pointer that will extend the life of the underlying pointer until the <code>shared_ptr</code> is deleted.  You would normally use this when you want to give the caller an object but you don't want to give them any guarantee that it will still be alive when they want to use it.  <code>weak_ptr</code> does have a way to check if the underlying pointer was deleted and it also has the ability to convert it to a <code>shared_ptr</code> if the objects exist you so can extend the lifetime of the pointer while you are using it.</p>

<p>EDIT:</p>

<p>In response to the addition on your question in the <code>smurfClass</code> all of the of the <code>smurfAttributes</code> would be stored as <code>std::shared_ptr&lt;smurfAttributes&gt;</code>.  Then in the function that passes out the attribute to others you would return a <code>std::weak_ptr</code>.  This way the receiver of the attribute has to try and lock the <code>weak_ptr</code> in order to use it and if it can't then it knows it no longer has a valid attribute.</p>
",8
31143250,31143199,7,"<p>It's because you have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a> in your code.</p>

<p>You allocate memory for <code>chromosome</code>, push the <em>pointer</em> into the vector, and then delete (free) the memory pointed to by <code>chromosome</code>. That freeing of memory make <em>all</em> pointers to the memory invalid, including the ones in the vector.</p>

<hr>

<p>It might be easier to understand pointers with some illustrations.</p>

<p>When you allocate the memory, it looks something like this</p>

<pre>
+------------+      +---------------------------+
| chromosome | ---> | memory you have allocated |
+------------+      +---------------------------+
</pre>

<p>After you push the pointer into the vector, you now have to pointer to the vector:</p>

<pre>
+------------+     
| chromosome | ---------\
+------------+           \     +---------------------------+
                          >--> | memory you have allocated |
+-------------------+    /     +---------------------------+
| pointer in vector | --/
+-------------------+
</pre>

<p>And finally, when you free the memory, it looks something like this</p>

<pre>
+------------+     
| chromosome | ---------\
+------------+           \     +-----+
                          >--> | ??? |
+-------------------+    /     +-----+
| pointer in vector | --/
+-------------------+
</pre>

<p>Where <code>???</code> represents the now unallocated memory.</p>

<p>What <em>probably</em> happens in reality, is that the system reuses the same memory for the next allocation you make, and so the next pointer assigned to <code>chromosome</code> is actually pointing to the same memory, and you overwrite the previous memory with the new data.</p>

<p>After the creation loop ends, the memory doesn't actually cease to exist, and its contents will be the last data you wrote into that memory, leading to the behavior you see.</p>

<p>The solution to this is very simple: <strong><em>Don't</em></strong> use pointers. In modern C++ there is seldom a need for pointers any more. Instead store <em>values</em> in the vector, actual object instances, e.g.</p>

<pre><code>vector&lt;GAChromosome&gt; chromosomes;
</code></pre>

<p>Note: If <code>GAChromosome</code> contains comples data, then you should also learn about the <a href=""http://en.cppreference.com/w/cpp/language/rule_of_three"" rel=""nofollow"">rule of three/five/zero</a>.</p>
",3
31143299,31143199,0,"<p>Joachim Pileborg is right; you have undefined behavior. Be sure to understand why this is, as these mistakes tend to plague new C++ programmers.</p>

<p>Another thing that might mess you up: that <code>generateRandomGenes(int)</code> function. If it is creating a new random number generator each time, and that generator is seeded with system time (probably in milliseconds), then it is possible that this loop iterates quickly enough that for consecutive times that <code>generateRandomGenes(int)</code> is called, the system clock reads the same time down to the millisecond, and the random number generator is seeded with the same seed each time, thus returning the same ""random"" number. To fix this, make the random number generator a static variable so it stays in memory, as opposed to getting re-seeded with each use.</p>
",0
26797487,26797404,0,"<p>You are supposed to pass to test a <code>value_type</code> not the whole map.
A value_type corresponds to a pair(key, value) and is define like so in stdlib : <code>typedef pair&lt;const Key, Type&gt; value_type;</code></p>

<p>therefore this <code>data[0]</code>makes no sense. Should be <code>data.first</code></p>
",0
26797516,26797404,1,"<p>You have to declare the function the following way</p>

<pre><code>void test( const std::map&lt;std::string, std::string&gt;::value_type data[] )
{
    cout&lt;&lt;data[0].first&lt;&lt;endl;
}
</code></pre>

<p>because originally data is defined as an array that you are going to pass to the function. Otherwise you may not use the subscript operator.</p>

<p>Also you need to use qualifier <code>const</code> for the parameter because array data also is defined as a constant array.</p>

<p>As for this type</p>

<pre><code>m_Type::value_type 
</code></pre>

<p>then it is equivalent to <code>std::pair&lt;const std::string, std::string&gt;</code> So this declaration</p>

<pre><code>static const m_Type::value_type data[] = { /*...*/ };
</code></pre>

<p>is equivalent to</p>

<pre><code>static const std::pair&lt;const std::string, std::string&gt; data[] = { /*...*/ };
</code></pre>
",4
28164197,28164148,1,"<p>Every <code>Triangle</code> constructor must - explicitly or implicitly - invoke one of the <code>Shape</code> constructors, so in <code>Triforce</code> it's reasonable to pick which <code>Triangle</code> instructor to invoke and let it coordinate the <code>Shape</code> construction, but not reasonable to interfere with <code>Shape</code> construction as you're trying to do - how's the <code>Triangle</code> constructor supposed to know about having had its base <code>Shape</code> object already constructed?  You should keep a <code>Triforce::Triforce(const std::string&amp; name) : Triangle(name) { }</code> constructor and remove the one attempting to call the <code>Shape</code> constructor.</p>
",5
21790622,21790236,3,"<p>You're not using a regular function pointer for your callback. You're using a non-static <em>member</em> function pointer, so the regular function pointer syntax and calling mechanics aren't going to work. There is a significant difference both in the pointer declaration syntax and the mechanism used for invoking non-static members. </p>

<p>To declare a pointer-to-member function for a member of the <code>Image</code> class taking no parameters and returning <code>void</code>, the syntax would be:</p>

<pre><code>void (Image::*function)(). 
</code></pre>

<p>Invoking a member function is done using one of two special operators, <code>-&gt;*</code> when using an object pointer, or <code>.*</code> when using an object reference. For example:</p>

<pre><code>// declare a pointer to Image member function
void (Image::*function)();

// assign address of member function
function = &amp;Image::ImageClicked;

// uses -&gt;* for access
Image *pObj = new Image();
(pObj-&gt;*function)();

// uses .* for access
Image image;
(image.*function)();
</code></pre>

<p>Hope that helps</p>
",7
33026906,33026823,0,"<p>In most cases, if you don't need a local variable to be modified, the latter method of the first example is faster, because the entire object will not have to be copied on the stack for the function to use it. Instead, a pointer will be pushed onto the stack, which takes less time. (Although some calling conventions allow passing small arguments in registers, which is even faster.)</p>

<p>For small objects, the time spent in copying may not be an issue, but may be more evident for large classes/structs.</p>

<p>The second examples have identical operation (disregarding the <code>const</code>ness), since the array would not be passed by value in any case. It would be passed as a simple pointer, or passed ""by reference.""</p>
",0
33027125,33026823,0,"<p>From an optimisation point of view, the compiler can not rely on <code>const</code> actually meaning ""won't change"". <code>const_cast</code> allows a function to alter the const-ness of something, such that it can be altered. It is useful for the programmer to know that ""I get an error if I accidentally modify this"" (in particular mistyping <code>if (a = b)</code> instead of <code>if (a == b)</code>). </p>

<p>If the source code of a function is available to the compiler, it can itself prove that a value isn't being changed, or is being changed, regardless of whether you mark it <code>const</code> or not. </p>

<p>In a video with Chandler Carruth (one of the currently most active developers of Clang and LLVM), he actually promotes using non-reference calls for any type that is reasonably small. Often, the compiler will optimise away the copy of the argument anyways, because the reference MAY be modified [so if the compiler doesn't have the source code available, it won't know if the value is being changed or not]</p>

<p>Whether you use <code>Card board[]</code> or <code>Card *board</code> will not change things, the compiler will generate exactly the same code either way - if you want others reading the code to understand if the function is expected to modify the value or not, then add <code>const</code> for values that aren't being changed.</p>
",0
33027259,33026823,0,"<p>This</p>

<pre><code>Hand::Hand(const Card &amp;one, const Card &amp;two)
</code></pre>

<p>is more efficient than this</p>

<pre><code>Hand::Hand(Card one, Card two)
</code></pre>

<p>For 2 reasons</p>

<ol>
<li>it avoids making a copy of the <code>Cards</code></li>
<li>If you wanted to maintain a Deck of cards, it is possibe with the first method but not possible with the second method for reasons explained by my first point</li>
</ol>

<p>This</p>

<pre><code>bool Hand::hasFourKind(Card board[])
</code></pre>

<p>is equivalent to this</p>

<pre><code>bool Hand::hasFourKind(const Card *board)
</code></pre>

<p>because they both represent array of cards, but the first one is just syntatic sugar for pointer to cards, so they both actually represent pointer to cards.</p>

<p>The second is better because it implies that the board cannot be modified by anyone else. This is not really much of a guard because of <code>const_cast</code> which can be used to remove the <code>constness</code> of an object.
If you really wanted to ensure that the cards cannot be modified by anybody in that method, then I would suggest you change design a bit to enable this:</p>

<pre><code>bool Hand::hasFourKind() const;
</code></pre>

<p>Where the cards are part of the <code>Hand</code> class and cannot be modified by anyone</p>
",0
31875799,31875520,1,"<p>You have three choices:</p>

<ol>
<li>Implicit conversion as you stated with <code>operator std::size_t()</code></li>
<li>Explicit conversion with <code>explicit operator std::size_t()</code>, which would allow <code>std::size_t(id)</code> and <code>static_cast&lt;std::size_t&gt;(id)</code></li>
<li>Custom specialized method</li>
<li>Have a custom function <code>access</code>, which is friend with <code>Id</code> and is able to call <code>operator[]</code> on any container that supports it with the <code>std::size_t</code> version</li>
</ol>

<p>In the first three cases you'll have that <code>Id</code> will be always convertible to <code>std::size_t</code> either implicitly or explicitly. In the last case you have that that conversion is only allowed within the function(s) you specify.</p>

<p>An example for the last one would be:</p>

<pre><code>class Id {
public:
    Id(std::size_t id) : inner(id) {}

    template&lt;typename Container&gt;
    friend typename Container::value_type&amp; access(Container&amp; container, Id index) {
        return container[index.inner];
    }
private:
    std::size_t inner;
};
</code></pre>

<p>then used as:</p>

<pre><code>auto ix = Id(2);
std::vector&lt;int&gt; vector{1, 2, 3, 4};
std::cout &lt;&lt; access(vector, ix);
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/2198a42ae4dac03b"" rel=""nofollow""><kbd>Live demo</kbd></a></p>
",1
31875891,31875520,0,"<p>Using something like <code>toIndex()</code> seems good. From a design perspective, do you really want to use vector? <code>std::map</code> is what you actually want to use here. Something like</p>

<pre><code>std::map&lt;Id, int&gt; myData;
</code></pre>

<p>You will need to implement comparison operator(less than operator) in Id class to get this working nicely.</p>

<p>I cannot say how that fits in with your requirements.</p>
",3
25521095,25520874,3,"<p>Characters are essentially one byte integers (although the representation may vary between compilers). While there are many  encodings which map integer values to characters, almost all of them map <code>'a'</code> to <code>'z'</code> characters in successive numerical order. So, if you wanted to change the string <code>""aaab""</code> to <code>""aaaa""</code> you could do something like the following:</p>

<pre><code>char letters [4] = {'a','a','a','b'};
letters[3]--;
</code></pre>
",2
25523024,25520874,0,"<p>Alphabet characters are part of the ASCII character table.  65 is uppercase letter A, and 32 bits later, which is 97, is lowercase letter A.  Letters B through Z and b through z are 66 through 90 and 98 through 122, respectively)  The original computer programmers made it 32 bits apart in the ASCII chart rather than 26 (letters in the alphabet) because bit manipulation can be done to either easily change from lowercase to uppercase (and vice-versa), as well as ignoring the case (by ignoring the 32 bit - 0010 0000).</p>

<p>This way, for example, the 84th character on the ASCII chart, which represents the letter T, is represented with the bits 0101 0100.  Lowercase t is 116 which is 0111 0100.  When ignoring the case, the 1 in the 32 bit (6th position from the right) is ignored.  You can see all the other bits are exactly the same for uppercase and lowercase.  This makes it more convenient for everyone and more optimal for the computer.</p>

<p>To decrement just convert the character to its ASCII character value, decrement by 1, then take that integer and convert it back into ASCII value.  Be careful when you have an 'A' though (or 'a'), as that's a special case.</p>
",1
31897634,31897620,0,"<p>The header file has to include the Bar header file.
The full thing is like this :</p>

<pre><code>include ""Bar.h""

class Foo {
   const Bar mBar; 
   //because it is Bar and not Bar&amp; or Bar* forward declarations are not possible

public:
   Foo(const Bar &amp;bar);
};
</code></pre>

<p>You can and should use forward declarations in following situation</p>

<pre><code>class Foo {
   const Bar&amp; mBar; 

public:
   Foo(const Bar &amp;bar);
};
</code></pre>

<p>but then the Bar include has to be present in the implementation file.<br>
The same reasoning can be applied here instead of this :</p>

<pre><code>include ""BarParams.h""

class Bar{
public:
   Bar(const BarParams &amp;barParams);
};
</code></pre>

<p>do this :</p>

<pre><code>class BarParams;

class Bar{
public:
   Bar(const BarParams &amp;barParams);
};
</code></pre>

<p>Doing that avoids unneeded includes all over your header files, and makes the life of your compiler a lot easier. In large projects the compilation times can be reduced significantly.</p>
",3
31898820,31898777,3,"<p>Include in file <code>Foo.cpp</code> header <code>Bar.h</code></p>

<p>Foo.cpp:</p>

<pre><code>#include ""Foo.h""
#include ""Bar.h""

Foo::Foo(const Bar &amp;bar) : mBar(bar) {}

int Foo::getVal() const {
    return mBar.getVal();
}
</code></pre>

<p>Or include header <code>Bar.h</code> in header <code>Foo.h</code></p>

<p>Foo.h:</p>

<pre><code>#pragma once
#include ""Bar.h""

class Foo {
    const Bar &amp;mBar;

public:
    Foo(const Bar &amp;bar);

    int getVal() const;
};
</code></pre>

<p>Take into account that function <code>Bar::getVal</code> must have qualifier const</p>

<pre><code>int getVal() const;
</code></pre>

<p>Otherwise you will get one more compilation error because this non-const function is called from a const function of class Foo.</p>

<pre><code>int Foo::getVal() const {
    return mBar.getVal();
    //     ^^^^^^^^^^^ 
}
</code></pre>
",0
31898885,31898777,2,"<p>Think from the perspective of the compiler. When it is compiling the source file <code>Foo.cpp</code>  and comes to the statement <code>mBar.getVal()</code>, it has no idea about the members of mBar! All it knows is that mBar is a reference to a const Bar object. But without making the Bar class definition visible to the compiler you cannot access it's members.</p>

<p>Typically, you do forward declarations in header files to avoid pulling in too many header files( which is important if the header file is part of externally visible API). In the source file you should include the header files that contain the class definition; in this case <code>Bar.h</code> </p>
",0
27151819,27151630,0,"<p>The condition in the middle of a for loop is just a normal condition so you can check more than just the value of the integer.  i.e.</p>

<pre><code>var breakTheLoop = false;

for (i = 0; i &lt;= 3 &amp;&amp; !breakTheLoop; i++)
{
    for (z = 0; z &lt;= 6 &amp;&amp; !breakTheLoop; z++)
    {
       //extra code here...   
       if (specificValue) 
       {
           breakTheLoop = true;
           break;
       }
    }
}
</code></pre>
",2
27151852,27151630,3,"<p>You may choose from a lot of variants.</p>

<ol>
<li><p>Use special flag variable:</p>

<pre><code>bool success = false;
for (i = 0; i &lt;= 3; i++)
{
    for (z = 0; z &lt;= 6; i++)
    {
        //extra code here...   
        success = true;
        break;
    }
    if (success) {
        break;
    }
}
</code></pre></li>
<li><p>Use a return statement (but you may also need to rewrite your code appropriately):</p>

<pre><code>for (i = 0; i &lt;= 3; i++)
{
    for (z = 0; z &lt;= 6; i++)
    {
       //extra code here...
       return; //or return &lt;something&gt;;   
    }
}
</code></pre></li>
<li><p>Use a <code>throw</code> but in my opinion this is not really a good practice:</p>

<pre><code>try {
    for (i = 0; i &lt;= 3; i++)
    {
        for (z = 0; z &lt;= 6; i++)
        {
           //extra code here...   
           throw &lt;something&gt;
        }
    }
} catch (const excpttype&amp; e) {
    // ...
}
</code></pre></li>
<li><p>Use a <code>stop</code>-condition in loops:</p>

<pre><code>bool breakFor = false;        
for (i = 0; i &lt;= 3 &amp;&amp; !breakFor; i++)
{
    for (z = 0; z &lt;= 6; i++)
    {
       //extra code here...   
       breakFor = true;
       break;
    }
}
</code></pre></li>
<li><p>Use explicit assignment to break the loops:</p>

<pre><code>for (i = 0; i &lt;= 3; i++)
{
    for (z = 0; z &lt;= 6; i++)
    {
       //extra code here...   
       i = 4;
       break;
    }
}
</code></pre></li>
<li><p>Use <code>goto</code> statement:    </p>

<pre><code>for (i = 0; i &lt;= 3; i++)
{
    for (z = 0; z &lt;= 6; i++)
    {
       //extra code here...   
       goto afterLoop;
    }
}

afterLoop:
// code
</code></pre></li>
</ol>

<p>The best practice in my opinion is to use flag-variable or refactor this loops to be inside a separated function.</p>
",7
27151891,27151630,1,"<pre><code>for (i = 0; i &lt;= 3; i++)
{
    for (z = 0; z &lt;= 6; z++)
    {
       //extra code here...   
       if (specificValue) 
       {
           break;
       }
    }
}
</code></pre>
",0
27151910,27151630,0,"<p>I think the answer is quite easy: Just set a if-statement and breat if the value is 2(or some value...)</p>

<p>for example:</p>

<p><strong>CODE</strong></p>

<pre><code>for (i = 0; i &lt;= 3; i++)
{
    for (z = 0; z &lt;= 6; i++)
    {
       if(z == 2)
        break;
    }
}
</code></pre>

<p>I hope this will solve your problem! If not just write a comment and tell me your error. Then I will try to write some code example for you! Have a nice day!</p>
",0
27151932,27151630,1,"<pre><code>    boolean condition=false;

    for (i = 0; i &lt;= 3; i++)
    {
        for (z = 0; z &lt;= 6; i++)
        {
           //extra code here...   

            if(z==2){

                condition=true;
                break;
            }

        }

        if(condition){

            break;
        }
    }
</code></pre>
",0
27151997,27151630,0,"<p>You forgot to increment <code>z</code> in your second loop, it keeps running ""forever"".</p>

<p>Here is one approach:</p>

<pre><code>bool break_loop = 0;
for (int i = 0; i &lt;= 3 &amp;&amp; !break_loop; ++i)
{
  for (int z = 0; z &lt;= 6 &amp;&amp; !break_loop; ++z)
  {
    //extra code here...
    if (z == 2)
      break_loop = 1;
  }
}
</code></pre>

<p>Or you can do if statements in both loops and then <code>break</code> which I prefer.</p>

<pre><code>bool break_loop = 0;
for (int i = 0; i &lt;= 3; ++i)
{
  for (int z = 0; z &lt;= 6; ++z)
  {
    //extra code here...
    if (z == 2)
      break_loop = 1;
  }
  if (break_loop)
    break;
}
</code></pre>
",1
27152181,27151630,2,"<p>No need of additional variable.</p>

<pre><code>for (i = 0; i &lt;= 3; i++)
{
   for (z = 0; z &lt;= 6; z++)
   {
      //extra code here...   
      if (z == 2) {
            i = 4;
            break;
      }
   }
}
</code></pre>

<p>Although breaking the loop in this way does not make any sense. Probably you need some additional condition.</p>
",0
27555755,27555492,1,"<p>A <code>static const int</code> defines a compile-time constant; I'm afraid I can't refer to a specific part of the standard. The only time you need a definition for it is if you try to take the address of it or create a reference. If you use an enum instead, the compiler will create a temporary variable for you when you need a reference.</p>

<pre><code>struct test
{
    static const int one = 1;
    enum { two = 2 };
};

void printint(const int &amp; i)
{
    cout &lt;&lt; i &lt;&lt; endl;
}

int main() {
    printint(test::one);  // error
    printint(test::two);  // no error
    return 0;
}
</code></pre>
",3
26438802,26438783,3,"<p>What you wrote is equivalent to</p>

<pre><code>*((a).kCreateThread());
</code></pre>

<p>You should use</p>

<pre><code>a-&gt;kCreateThread();
</code></pre>

<p>or</p>

<pre><code>(*a).kCreateThread();
</code></pre>

<p>These last two are equivalent.</p>
",0
26438827,26438783,1,"<p>Do it like this:
a->kCreateThread();</p>
",0
27544387,27544274,3,"<p>First of all in this statement</p>

<pre><code>cout &lt;&lt; ""The root of the function is  "", root);
                                       ^^^^ ^^^
</code></pre>

<p>there is invalid expression.</p>

<p>As for other errors then you have to use an object name that to call non-static member functions of a class.</p>

<p>For example</p>

<pre><code>n.f(root)
</code></pre>

<p>or</p>

<pre><code>n.df(root)
</code></pre>

<p>Take into account that this declaration</p>

<pre><code>double NewtonRaphson(double x0, double epsilon, double f(double), double df(double));
</code></pre>

<p>is invalid because you are going to use as arguments non-static member functions <code>f</code> and <code>df</code> while the corresponding parameters are declared as non-member functions.</p>

<p>There is no need to define these two parameters of the function because you could simply call these member functions within the body of NewtonRaphson.</p>
",3
30404538,30404518,3,"<p>You used a <code>&amp;</code> when you should not have done.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;
int main()
{
    ifstream ifs(""foo.txt"");
}
</code></pre>
",6
30404896,30404518,1,"<p>Passing values by reference isn't done in the variable declaration, but instead in the parameter list of the function using the ifstream object. For example, your function main might look like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;
int main()
{
    ifstream ifs(""foo.txt"");
    myFunction(ifs);
}
</code></pre>

<p>and your called function should look like this:</p>

<pre><code>void myFunction(std::ifstream&amp; in_stream)
{
    // ...
}
</code></pre>

<p>If you need the C++11 reference type (which I doubt, but maybe), try this:</p>

<pre><code>ifstream ifs(""foo.txt."");
std::ref&lt;std::ifstream&gt; ifs_ref(ifs);
</code></pre>

<p>That works in a lot of cases where doing a regular by-ref wouldn't.</p>
",0
30406620,30404518,0,"<p>semantically, a reference is a pointer. so your code doesn't compile for the same reason this code doesn't:</p>

<pre><code>main()
{
  ifstream* ifs(""foo.txt"");
}
</code></pre>

<p>as others have said, you want to create an object of type ifstream. not a reference (nor a pointer) to it.</p>
",0
29451079,29451044,2,"<p>You missing one &lt; symbol here</p>

<pre><code> cout &lt;&lt; pd3[i] &lt; "" at "" &lt;&lt; &amp;pd3[i] &lt;&lt; ""; "";
 cout &lt;&lt; pd4[i] &lt; "" at "" &lt;&lt; &amp;pd4[i] &lt;&lt; endl;
</code></pre>

<p>Try</p>

<pre><code> cout &lt;&lt; pd3[i] &lt;&lt; "" at "" &lt;&lt; &amp;pd3[i] &lt;&lt; ""; "";
 cout &lt;&lt; pd4[i] &lt;&lt; "" at "" &lt;&lt; &amp;pd4[i] &lt;&lt; endl;
</code></pre>
",0
29451099,29451044,1,"<p>You only put one <code>&lt;</code> in the stream where you are trying to print out the buffer contents.</p>

<pre><code>cout &lt;&lt; pd3[i] &lt; "" at "" &lt;&lt; &amp;pd3[i] &lt;&lt; ""; ""; // there is only one &lt;
cout &lt;&lt; pd4[i] &lt; "" at "" &lt;&lt; &amp;pd4[i] &lt;&lt; endl; // ^
</code></pre>

<p>Make sure you have two <code>&lt;'s</code> in the stream insertion operator.</p>

<pre><code>cout &lt;&lt; pd3[i] &lt;&lt; "" at "" &lt;&lt; &amp;pd3[i] &lt;&lt; ""; "";
cout &lt;&lt; pd4[i] &lt;&lt; "" at "" &lt;&lt; &amp;pd4[i] &lt;&lt; endl;
</code></pre>
",0
25478394,25477833,1,"<p>Just for the sake of adding to the existing craziness....</p>

<p>Eventual usage supported:</p>

<pre><code>xstream xs(std::cout) &lt;&lt; If(argc &lt;= 1) &lt;&lt; argc - 1 &lt;&lt; _else &lt;&lt; ""none"" &lt;&lt; _endif &lt;&lt; '\n';
</code></pre>

<p>Note that this does <strong><em>not</em></strong> short-circuit evaluation of the ""if"" or ""else"" branches the way <code>?</code>, <code>:</code> and <code>;</code> does, but it doesn't require a conversion to a common type either....</p>

<p>Implementation (also at <a href=""http://ideone.com/bw9L6i"" rel=""nofollow"">ideone.com</a>.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct If { If(bool active) : active_(active) { } bool active_; };
struct Else { } _else;
struct Endif { } _endif;

class xstream
{
  public:
    xstream(std::ostream&amp; os) : os_(os) { }

    template &lt;typename T&gt;
    friend xstream&amp; operator&lt;&lt;(xstream&amp; s, const T&amp; t)
    {
        if (s.active_) s.os_ &lt;&lt; t;
        return s;
    }

  private:
    bool active_;
    std::ostream&amp; os_;
};

template &lt;&gt;
xstream&amp; operator&lt;&lt; &lt;If&gt;(xstream&amp; s, const If&amp; _if)
{
    s.active_ = _if.active_;
    return s;
}

template &lt;&gt;
xstream&amp; operator&lt;&lt;&lt;Else&gt;(xstream&amp; s, const Else&amp; _else)
{
    s.active_ ^= true;
    return s;
}

template &lt;&gt;
xstream&amp; operator&lt;&lt;&lt;Endif&gt;(xstream&amp; s, const Endif&amp; _endif)
{
    s.active_ = true;
    return s;
}


int main(int argc, const char* argv[])
{
    xstream xs(std::cout);
    xs &lt;&lt; If(argc &lt;= 1) &lt;&lt; argc - 1 &lt;&lt; _else &lt;&lt; ""none"" &lt;&lt; _endif &lt;&lt; '\n';
}
</code></pre>

<p>(Note that the <code>xstream</code> constructor only keeps a reference to the stream it's controlling, so the latter's lifetime must outlive the former's use under penalty of undefined behaviour).</p>
",0
25477879,25477833,5,"<p>The simple way. Handle with a string.</p>

<pre><code>std::cout &lt;&lt; ""number of args: ""
          &lt;&lt; (argc &gt; 1 ? std::to_string(argc - 1) : ""none"")
          &lt;&lt; std::endl;
</code></pre>

<p>It has some superfluous cost to change the string. But it is easy to read and maintain if it is used once. And the reason the parentheses are required is that the shift operator(&lt;&lt;) has higher precedence than ternary conditional operator(?:) or relational operators (>).</p>
",8
25477897,25477833,4,"<p>You can make your own class to do the limit printing:</p>

<pre><code>class limit {
    int lim;
    int k;
public:
    limit(int lim_, int k_) : lim(lim_), k(k_) {}
    friend ostream&amp; operator&lt;&lt;(ostream&amp; ostr, const limit&amp; lim);
};

ostream&amp; operator&lt;&lt;(ostream&amp; ostr, const limit&amp; lim) {
    if (lim.k &lt; lim.lim) {
        ostr &lt;&lt; ""none"";
    } else {
        ostr &lt;&lt; lim.k - lim.lim;
    }
    return ostr;
}

int main() {
    cout &lt;&lt; ""Hello "" &lt;&lt; limit(1, 15) &lt;&lt; endl;
    cout &lt;&lt; ""World "" &lt;&lt; limit(1, -1) &lt;&lt; endl;
    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/zkjMsT"" rel=""nofollow"">Demo.</a></p>

<p>The <code>limit</code> class holds two numbers - the limit (1 in the demo) and the number to be printed. It provides an operator <code>&lt;&lt;</code> for printing, which uses your conditional statement to print either the value over the limit, or <code>""none""</code>. This lets you write <code>cout &lt;&lt; limit(1, argc)</code>, and produce the desired printout.</p>
",0
25477951,25477833,3,"<p>If you place the <code>&lt;&lt;</code> within the ternary expressions, it unifies the types for both the true and false cases.</p>

<pre><code>argc &gt; 1 ? std::cout &lt;&lt; argc - 1 : std::cout &lt;&lt; ""none"";
</code></pre>

<p>You can use a helper template function to make things a bit more seamless:</p>

<pre><code>template &lt;typename T&gt;
std::ostream &amp; argp (const T &amp;x) {
    return std::cout &lt;&lt; ""number of args: "" &lt;&lt; x;
}

(argc &gt; 1 ? argp(argc - 1) : argp(""none"")) &lt;&lt; std::endl;
</code></pre>
",0
25478022,25477833,2,"<p>If you want a more general solution, you could create a (template) class that stores references to two objects and a bool. Then overload <code>operator&lt;&lt;</code> to choose which member to print based on the bool.</p>

<pre><code>template&lt;typename T, typename U&gt;
class be_careful_this_class_holds_references_to_its_constructor_arguments
{
public:
    be_careful_this_class_holds_references_to_its_constructor_arguments(
        bool b, T const&amp; t, U const&amp; u)
        :choose_first(b), first(t), second(u)
    {}

    friend std::ostream&amp; operator&lt;&lt;(
        std::ostream&amp; os,
        be_careful_this_class_holds_references_to_its_constructor_arguments const&amp; p)
    {
        if (p.choose_first)
        os &lt;&lt; p.first;
        else
            os &lt;&lt; p.second;
        return os;
    }
private:
    bool choose_first;
    T const&amp; first;
    U const&amp; second;
};
</code></pre>

<p>Using this class is a bit cumbersome though, you have to name the types. You can fix that with a helper function:</p>

<pre><code>template&lt;typename T, typename U&gt;
be_careful_this_class_holds_references_to_its_constructor_arguments&lt;T,U&gt;
pick(bool choice, T const&amp; first, U const&amp; second)
{
    return be_careful_this_class_holds_references_to_its_constructor_arguments&lt;T,U&gt;(choice,first,second);
}
</code></pre>

<p>Then you can just call this function, passing a condition to the first parameter, and your two options of what to print to the second and third parameters:</p>

<pre><code>std::cout &lt;&lt; pick(argc &gt; 1, argc - 1, ""none"") &lt;&lt; std::endl;
</code></pre>
",2
24393517,24393489,4,"<p>The standard does not mandate that <code>a</code> must be initialized before <code>b</code>. Hence, it is undefined behavior.</p>
",7
24393520,24393489,5,"<p>It's because you've no guarantee about the order of evaluation of the parameters. </p>

<p>Iso standard section 8.3.6 specifies clearly why:  </p>

<blockquote>
  <p>The order of evaluation of function arguments is unspecified.
  Consequently, parameters of a function shall not be used in a default
  argument, even if they are not evaluated. Parameters of a function
  declared before a default argument are in scope and can hide 
  namespace and class member names.</p>
</blockquote>

<p>However if you could in some cases opt for a function overloading for getting the desired result:  </p>

<pre><code>void foo(int a, int b);
void foo(int a);

void foo(int a, int b) {
    cout &lt;&lt; ""foo with 2 arguments"" &lt;&lt; a &lt;&lt; "","" &lt;&lt; b&lt;&lt;endl;
}

void foo(int a) {
    cout &lt;&lt; ""wrapper foo with 1 argument =&gt;"";
    foo(a, a);
}
</code></pre>
",2
24656310,24656266,3,"<p>If, as you say, ""Only <code>MyClass</code> is going to use this method"" then it logically belongs in <code>MyClass</code> as a static member function.</p>
",1
24656484,24656266,3,"<blockquote>
  <p>3.Help method that is not a member of any class, only definition in the cpp file.</p>
</blockquote>

<p>So you can change the definition of the helper method if you need, without worrying about the recompilation of the <code>MyClass</code>'s clients in the case of making it a static member function.</p>

<p><strong>EDIT:</strong>
As @¦Ð?¦Í¦Ó¦Á?¦Å? said, you could put the helper method in an unnamed namespace to restrict its usage within the <code>MyClass</code> cpp file (and translation units including it).</p>
",4
25697527,25697439,3,"<p>You should zero out <code>mbs</code> before attempting to use it.</p>

<pre><code>#include &lt;cstring&gt;
memset(&amp;mbs, 0, sizeof(mbs));
</code></pre>

<p>Or initialize it (more C++-like):</p>

<pre><code>mbstate_t mbs{};
</code></pre>
",1
27546408,26434658,0,"<p>I don't think C++ placement new is strictly required to place the beginning of the object that client code can see, at the beginning of the buffer that you passed to new.</p>

<p>It's only required to place it somewhere inside it.  It's completely cool for the compiler to do anything it wants to with the space, provided it doesn't have allocate any buffers anywhere else.</p>

<p>So you should not be depending on ptr1 and ptr2 having the same value, for any use of placement new, not just this one.</p>

<p>I'm not dead certain of this though.  I could be wrong.</p>
",0
32995869,32995757,4,"<p>This is because there is still input in the input stream.  the first call to <code>getchar()</code> will see this input, grab it and then return.  When you add the second <code>getchar()</code> there is no more input so it blocks until you press enter.  If you want to make sure there is nothing left in the input buffer than you can use:</p>

<pre><code>std::cin.ignore(std::numeric_limits&lt;streamsize&gt;::max(), '\n');
</code></pre>

<p>This consumes up to <code>streamsize::max</code> characters from the stream until it reaches a newline and then consumes the newline as long as it didn't read <code>streamsize::max</code> characters.  this should leave an empty buffer for <code>getchar()</code>.</p>
",0
31186616,31186180,2,"<p>Make <code>PropertyAccess</code> itself a template:</p>

<pre><code>template &lt;typename TClass, typename TType&gt;
class PropertyAccess
{
public:
    using SetterPointer = void (TClass::*)(const TType&amp;);
    using GetterPointer = TType(TClass::*)();

    PropertyAccess(TClass* object, SetterPointer setter, GetterPointer getter)
        : m_object(object), m_setter(setter), m_getter(getter)
    {
    }

    void Set(const TType&amp; value) {
        (m_object-&gt;*m_setter)(value);
    }

    TType Get() {
        return (m_object-&gt;*m_getter)();
    }

private:

    TClass* m_object;
    SetterPointer m_setter;
    GetterPointer m_getter;
};
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/e90738982c515ef7"" rel=""nofollow"">Demo</a></p>

<p>Your current implementation is not only slow, it's unsafe. See what happens if you do</p>

<pre><code>ClassA a;
PropertyAccess p(&amp;a, &amp;ClassA::SetSomeProperty, &amp;ClassA::GetSomeProperty);
p.Set&lt;double&gt;(10); // but property is int
</code></pre>
",4
31187534,31186180,1,"<p>You can take Anton Slavin's solution and introduce an interface to erase object type. It will make lifetime management of accessors more complicated (you'll have to use references/pointers/smart pointers and manage lifetime because you won't be able to copy accessors) and will cost at runtime as virtual method calls will not inline so I would measure if it is quicker than your original solution.</p>

<pre><code>template&lt;typename TType&gt;
struct PropertyAccess
{
    virtual void Set(const TType&amp; value) = 0;
    virtual TType Get() = 0;
};

template &lt;typename TClass, typename TType&gt;
class PropertyAccessT : public PropertyAccess&lt;TType&gt;
{
public:
    using SetterPointer = void (TClass::*)(const TType&amp;);
    using GetterPointer = TType(TClass::*)();

    PropertyAccessT(TClass* object, SetterPointer setter, GetterPointer getter)
        : m_object(object), m_setter(setter), m_getter(getter)
    {
    }

    void Set(const TType&amp; value) {
        (m_object-&gt;*m_setter)(value);
    }

    TType Get() {
        return (m_object-&gt;*m_getter)();
    }

private:

    TClass* m_object;
    SetterPointer m_setter;
    GetterPointer m_getter;
};
</code></pre>
",3
21033639,21030865,1,"<p><strong>In your first <code>main</code> function:</strong>  </p>

<p>You use an array <code>x</code> without declaring it.  </p>

<p>You are using <code>scanf</code> function which is evil.  Use <code>std::cin</code> since you tagged this as C++.  </p>

<p>The variable or limit of the <code>for</code> loop, <code>k</code>, is never initialized.  </p>

<p><strong>In the second <code>main</code> function:</strong>  </p>

<p>The array <code>eleman</code> is not declared nor initialized.  </p>

<p>You have a statement group declared after the <code>if</code> statement, don't know if this is intentional:</p>

<pre><code>if (eleman[i]==0)
    break;
{ // Is this part of the ""if"" statement?
    printf(""%d"", eleman[i]);
}
printf(""en k¨¹c¨¹k:%d"", ek);
</code></pre>

<p>You are using <code>&lt;conio&gt;</code> which means you are using an old compiler.<br>
Try this:</p>

<pre><code>std::cout &lt;&lt; ""Press ENTER to continue.\n"";
std::cin.ignore(100000, '\n');
</code></pre>

<p>For code reviews, please post on CodeReview.StackExchange.com</p>
",0
24649589,24649022,0,"<p>You are right, all values of deck are 0 at the beginning and the loop works because the <code>do{}while(condition);</code> is executing at least once before checking <code>condition</code>. The loop is looking here for the first uninitialized card.</p>

<p>Duplicate output is just what the loop is currently checking, it finds an initialized card so it keeps looking for an uninitialized one (this is the first cout).</p>
",2
25669343,25669247,1,"<p>The second overload misses <code>const</code>, this may be the reason for ambiguity. </p>

<p>Try making <code>stdN</code> a const object if you intend to invoke the first overload.</p>
",0
29502424,29502246,0,"<p>How about fixing the <code>IterateTest</code> to</p>

<pre><code>class IterateTest{

public:
//Default Constructor
IterateTest(int id): m_ID(id) {};

private:
    int m_ID; //Specific ID
};
</code></pre>

<p>and then write</p>

<pre><code>vector&lt;IterateTest*&gt; iterations;
for ( int i = 0; i &lt; 10; i++ )
  iterations.push_back( new IterateTest(i+1) );
</code></pre>
",0
29502443,29502246,2,"<p>Since <code>static</code> variables are shared across all instances of the class, you can create a <code>static</code> variable that is incremented in the constructor:</p>

<pre><code>class A
{
private:
    int _id;
    static int CurrentID;

public:
    A() : _id( ++CurrentID ) {}

    int getID() const { return _id; }
};

int A::CurrentID = 0;

int main() {

    std::vector&lt;A*&gt; vec;
    for( int i = 0; i &lt; 5; ++i )
        vec.push_back( new A() );

    for( auto a : vec )
        std::cout &lt;&lt; a-&gt;getID() &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>There are a couple of things to note:</p>

<ul>
<li>Each time the program is run, the ID will start at 1 again</li>
<li>This is not thread-safe</li>
</ul>
",1
24102380,24102353,2,"<p>You are storing the reference to a local variable outside the scope in which the local variable is declared.</p>

<p>Every iteration <code>solution</code> is not valid anymore, then the address to it shouldn't be considered valid. To obtain what you need you should assign the variable by value, so that you actually copy the contained value, eg:</p>

<pre><code>pair&lt;Point, double&gt; p = std::make_pair(whatever, std::numeric_limits&lt;double&gt;::max());

for (...)
{
   if (solution[0].second &lt; p.second)
     p = solution[0];
}
</code></pre>

<p>The fact that the address changes can be caused by multiple reasons, but you shouldn't bother understanding why, just avoid this kind of situation. Your misconception comes from the fact that C# has a garbage collection which prevents <code>solution[0]</code> from becoming invalid, which is not true for C++, when variable are declared on stack.</p>
",3
24102381,24102353,2,"<p>When you assign to p it points to the adresss of &amp;solution[0] but on the next iteration of the loop that variable goes poof and a new one gets created and p points to either random stuff or something else.</p>

<p>It might be better to just store a copy in p, so make p a regular variable and copy over the solution[0] by assigning. You can have another bool variable to determine if a solution was found.</p>

<pre><code>pair&lt;Point,double&gt; p;
Sphere sphere;
bool solutionFound = false;

for (int i=0;i&lt;spheres.size();i++)
{
    vector&lt;pair&lt;Point,double&gt;&gt; solution=findIntersection(Point(ray.origin),Point(ray.direction.x,ray.direction.y,ray.direction.z),spheres[i]);

    if(solution.size()==0)
        continue;


    if(!solutionFound || solution[0].second &lt; p.second)
    {
        p=solution[0];
        sphere=spheres[i];
        solutionFound = true;
    }
}


if(!solutionFound)
    return backgroundColor;
else
{
    Color c=localIlluminate(p.first, sphere);
    return c;
}
</code></pre>
",0
33560821,33560647,1,"<p>This is the case, most Java and C# programmers face with c++. You need to dynamically create an object along with a virtual keyword.</p>

<p>So, the correct way to create an object should be</p>

<pre><code>int main
{
  Mammal *mammal = new Cat(""CatName"", Blue, 9);
  mammal-&gt;speak();
}
</code></pre>
",0
33560883,33560647,2,"<p>Polymorphism only works with pointers or references: You declare <code>mammal</code> to actually <strong>be</strong> an instance of class <code>Mammal</code>.</p>

<p>Changing that to a pointer or a reference changes the semantics in that the pointer or reference refers to something that <em>is a</em> <code>Mammal</code>.</p>

<pre><code>Mammal const &amp; mammal = Cat();
// or
Mammal * mammal = new Cat();
// don't forget the delete, better:
std::unique_ptr&lt;Mammal&gt; mammal = std::make_unique&lt;Cat&gt;();
</code></pre>

<p>In this context you'll probably also quickly come to know <a href=""https://stackoverflow.com/q/274626/1116364"">object slicing</a>.</p>
",0
34204508,34204234,2,"<p>Your insert should use iterator directly:</p>

<pre><code>out.insert(out.end(), in.begin() + start, in.begin() + (start + length));
</code></pre>
",0
34204670,34204234,1,"<p>The correct function will look like</p>

<pre><code>#include &lt;iterator&gt;
#include &lt;vector&gt;

//...

void copyVec( const std::vector&lt;double&gt; &amp;in, 
              std::vector&lt;double&gt; &amp;out, 
              std::vector&lt;double&gt;::size_type start, 
              std::vector&lt;double&gt;::size_type length ) 
{
    assert( in.size() &gt;= start + length );

    out.reserve( out.size() + length );

    out.insert( out.end(), std::next( in.begin(), start ), 
                           std::next( in.begin(), start + length ) );
}
</code></pre>

<p>The first parameter is declared as constant reference. You should reserve memory for the destination vector taking into account its current size.
It is better to use own iterators of the vector instead of the raw pointers.
<code>start</code> and <code>start + length</code> specify a range like <code>[start, start + length )</code></p>

<p>For example to copy the entire vector you can write</p>

<pre><code>copyVec2b(vec1, vec2, 0, vec1.size() );
</code></pre>

<p>In general you may not write in the function like</p>

<pre><code>cout &lt;&lt; in.at( start + length ) &lt;&lt; endl;
</code></pre>

<p>because index <code>start + length</code> is not included in the range of copied elements.</p>

<p>You may write</p>

<pre><code>if ( length != 0 ) cout &lt;&lt; in.at( start + length - 1 ) &lt;&lt; endl;
</code></pre>
",0
25448762,25448635,7,"<p>Yes, you are creating a single <code>GLFloat</code> on the heap initialized to 1024.0. You can initialize primitives with the same syntax as classes. e.g.</p>

<pre><code>int i(10);
</code></pre>

<p>Would create an int on the stack initialized to 10.</p>
",0
25448763,25448635,8,"<p><code>GLfloat</code> is an OpenGL alias for <code>float</code> (i.e., <code>typedef float GLfloat;</code>). Consequently the code:</p>

<pre><code>GLfloat* points = new GLfloat(1024);
</code></pre>

<p>Is equivalent to:</p>

<pre><code>float* points = new float(1024);
</code></pre>

<p>Which allocates a floating point number and initializes it to <code>1024.0</code> and assigns its address to pointer <code>points</code>.</p>
",3
25448765,25448635,4,"<blockquote>
  <blockquote>
    <p>what does the line I originally had do?</p>
  </blockquote>
</blockquote>

<pre><code> GLfloat* points = new GLfloat(1024);
</code></pre>

<p>Let us try to replace <code>GLfloat</code> with <code>int</code>, you will see that if <code>GLFloat</code> is a type similar to <code>int</code> or <code>float</code>, then you will have the following:</p>

<pre><code>int * points = new int(1024);
</code></pre>

<p>The above statement means that you are creating a pointer to an <code>int</code> with initial value being <code>1024</code>. So in your case, it means creating a pointer <code>points</code> to a variable with type being <code>GLfloat</code> and initial value as <code>1024</code>. </p>

<p>It is equivalent to write the following in a condensed version:</p>

<pre><code>int * points = new int;
*points = 1024;
</code></pre>

<p>See <a href=""http://www.dcs.bbk.ac.uk/~roger/cpp/week9.htm"" rel=""nofollow"">here</a> for more explanation.</p>
",0
25444764,25444696,0,"<p>Get rid of the pointers for <em>great good</em>?. And while we're at it, move as much as you can to the constructor.</p>

<pre><code>AnotherClass classB::setupData()
{
    AnotherClass a(/* setup data */);
    return a;
}
</code></pre>

<p>Should get yourself rid of more than one problem at once.</p>
",0
25523120,25444696,0,"<p><em>sigh</em></p>

<p>It turns out that the member vanishing from the object when it was returned to a function outside of its class but not when returned to a function inside its class was due to Visual Studio's intellisense getting confused somehow.  a colleague with Visual Studio 2013 (as opposed to 2012 Express) does not get this issue.</p>
",0
31225453,31225434,0,"<p>Yes.</p>

<p>You use arrays if you want your calculations faster. However the size of your binary tree (or the depth, or order whatever) can not be changed if you use arrays.</p>
",5
31225460,31225434,7,"<p>The answer is, ""yes you can - and it's desirable from a performance standpoint to do so"". An implementation has handily been written for you in the boost library.</p>

<p><a href=""http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.flat_xxx"" rel=""noreferrer"">http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.flat_xxx</a></p>
",0
31225633,31225434,1,"<p>In C++, there are:</p>

<ul>
<li><p>statically defined arrays - <code>T[constant]</code> - for which the dimension must be a compile-time constant,</p></li>
<li><p>dynamically allocated arrays a la <code>new T[variable]</code>, where the size can vary at run-time</p></li>
<li><p>the Standard library class <code>std::array&lt;T, constant&gt;</code> that wraps a compile-time-sized array</p></li>
<li><p>the Standard library class <code>std::vector&lt;T&gt;</code>, which uses dynamically allocated memory and can vary its size at runtime as data is inserted, copying elements from the old to a larger newly dynamically allocated memory area when necessary</p></li>
</ul>

<p>The latter library offerings are generally preferable to using <code>T[constant]</code> or <code>new T[variable]</code>, as they add Object Oriented features such as member functions for <code>.size()</code>, iterators, and for <code>vector</code> - a destructor performing automatic destruction of elements and deletion of memory.</p>

<p>If your tree will have a compile-time constant upper bound to size, you could use a <code>std::array</code>, but <code>std::vector</code> would allow dynamic sizing which is a more flexible and robust solution.</p>

<p>More generally, your question may surprise or confuse C++ programmers as our common practice is to store binary trees having nodes linked by pointers, rather than contiguous storage.  What you ask for is still considered a binary tree in Computing Science - see e.g. <a href=""https://en.wikipedia.org/wiki/Binary_tree#Arrays"" rel=""nofollow"">here</a> - but most of us normally use the Standard library's <code>std::set&lt;&gt;</code> for this that happens to use nodes linked by pointers.</p>
",0
28243667,28243632,7,"<p>It is not an ""assignment"". It is the <em>definition</em> of the static data member <code>sysType</code> of your class. In your case the syntax contains quite a bit of template-related stuff, but the immediate matter in question has nothing to do with templates at all. A minimalistic example of the same thing might look as follows</p>

<pre><code>class SomeClass { 
  ...
  static int i; // declaration of `SomeClass::i`
  ...
};

int SomeClass::i = 42; // definition of `SomeClass::i` 
</code></pre>

<p>All static members of the class have to be <em>defined</em> somewhere (with some exceptions for constant integral members). What you have inside the class is a mere <em>declaration</em>.</p>

<p>So, one more time: every time you <em>declare</em> a static data member in your class, you will have to <em>define</em> it somewhere outside of the class, following the general One Definition Rule for data objects with external linkage, i.e. you have to define in your program once and only once. </p>

<p>In your case the definition includes an initializer. The <code>=</code> is a part of the initialization syntax. It has nothing to do with assignment.</p>

<p>The access protection does not come into play here at all. In this case you are not <em>accessing</em> a class member, you are <em>defining</em> it. Just like you <em>define</em> private member functions outside of the class, you <em>define</em> private static members outside of the class. </p>
",0
22493994,22493930,0,"<p>No, a char of value 10 is a newline. Take a look at an <a href=""http://www.asciitable.com/"" rel=""nofollow"">ascii table</a>. You'll see that the  number 10 would be two different chars (49 and 48, respectively).</p>
",2
22494038,22493930,1,"<p>There is no way. You write the same byte, and preserve no other information. </p>

<p>You need to think of other way of encoding you values, or reserve one value for your sentinel (like 255 or 0). Of course, you need to be sure, that this value is not present in your input.</p>

<p>Other possibility it to use one byte-value as 'special' character to escape your control codes. Similar as '\' is used to give special meaning to 'n' in '\n'. But it makes all parsing more complicated, as your values may be now one- or two-byte long. Unless you are under tight pressure memory-wise, I would advice to store values as their string representation, this is usually more readable.</p>
",1
24596204,24596143,2,"<p>It's already illegal to call <code>Class::mySpecialCase.B()</code>, since <code>mySpecialCase</code> is <code>const</code> and <code>B()</code> is not a <code>const</code> member.  You just need to make it possible to call <code>A()</code>, by making <code>A()</code> a <code>const</code> member function:</p>

<pre><code>class Class
{
    int x;
public:
    Class(int x) : x(x) { }

    static const Class mySpecialCase;

    int A() const { return x; /* info about x */ }
    void B() { x++; /* updates x! */ }
};

// In class.cpp:
const Class Class::mySpecialCase{3};
</code></pre>
",0
24596217,24596143,2,"<blockquote>
  <p>The problem however, is that I need to call A() on this object, to fetch some information, but do not want B() to be called on this object, since it would modify x, </p>
</blockquote>

<p>Declare the object and <code>B()</code> as <code>const</code> but not <code>A()</code>:</p>

<pre><code> class Class {
     public:
          [...]
          int A();
          void B() const;
 };

 // Initialize const object.
 const Class specialCase(3);
</code></pre>

<p>Calling <code>specialCase.A()</code> will be a compile error, but <code>specialCase.B()</code> is still okay because the <code>const</code> modifier indicates to the compiler this method does not alter the object.</p>
",0
24596317,24596143,0,"<blockquote>
  <p>So far so good.</p>
</blockquote>

<p>Not really. <code>A</code> should be <code>const</code>:</p>

<pre><code>int A() const { return x; /* info about x */ }
</code></pre>

<blockquote>
  <p>But now I want to have some special version of this class</p>
</blockquote>

<p>By <em>version</em>, you mean <em>instance</em>, right?</p>

<p>Add a static member function returning a reference to a static local instance of <code>Class</code>:</p>

<pre><code>#include &lt;iostream&gt;

class Class
{
public:
    int x;
    Class(int x) : x(x) { }

    int A() const { return x; /* info about x */ }
    void B() { x++; /* updates x! */ }

    static Class &amp;SpecialInstance()
    {
        static Class instance(3);
        return instance;
    }
};

int main()
{
    Class a(1);
    Class b(2);
    Class c = Class::SpecialInstance();

    std::cout &lt;&lt; c.A() &lt;&lt; ""\n"";
}
</code></pre>
",0
26212077,26211958,6,"<p>The compiler will do an implicit conversion from <code>2</code> to the equivalent ASCII char: ""<code>start of text</code>"" (therefore you can't see anything).</p>

<p>Maybe you have disabled the warning of your compiler. Try to turn them on.</p>
",0
26212184,26211958,4,"<blockquote>
  <p>GCC:</p>
</blockquote>

<p>compile in gcc with option <code>[-Wconversion]</code>, then you'll see that the compiler will issue the warning:</p>

<p><code>warning: conversion to 'char' alters 'double' constant value [-Wfloat-conversion]</code></p>

<p><a href=""http://coliru.stacked-crooked.com/a/cc8d6d592c74c116"" rel=""nofollow""><strong>LIVE DEMO</strong></a></p>

<blockquote>
  <p><em>MSVC don't seem to be concerned about this at all:</em></p>
</blockquote>

<p>VS2013 produces the following warning:</p>

<p><code>warning C4244: 'argument' : conversion from 'double' to 'char', possible loss of data</code></p>

<blockquote>
  <p>even though it is clearly wrong and doesn't actually work anyway!</p>
</blockquote>

<p>It's not wrong, it's just an implicit conversion from the truncated <code>double</code> 2.3 to a <code>char</code> with ASCII code 2 <a href=""http://www.asciitable.com/"" rel=""nofollow"">(start of text)</a>.</p>
",3
26212221,26211958,12,"<p><code>std::string</code> has an overload for <a href=""http://en.cppreference.com/w/cpp/string/basic_string/operator%3D"" rel=""nofollow""><code>operator=</code></a> that takes a character. When you pass an argument to a function by value (i.e, an operator), <a href=""http://en.cppreference.com/w/cpp/language/copy_initialization"" rel=""nofollow"">copy initialization</a> occurs. In copy initialization, <a href=""http://en.cppreference.com/w/cpp/language/implicit_cast"" rel=""nofollow"">standard conversions</a>, also known as an ""implicit conversion"", may be used to the convert the value. In this case, your double is being silently converted to a char so that it may be used in <code>operator=</code>.</p>

<p>For GCC, <code>-Wall -Wextra -pedantic</code> will not make a diagnostic appear. You can try <code>-Wfloat-conversion</code>, which is enabled by <code>-Wconversion</code>. Example:</p>

<pre><code>main.cpp:11:10: warning: conversion to 'char' alters 'double' constant value 
[-Wfloat-conversion]
        a = 3.2;
</code></pre>

<p>Alternatively, use braces to force a narrowing conversion error.</p>

<pre><code>s = {4.3};
// warning: narrowing conversion of '4.2e+1' from 'double' to 'char' inside { } 
// [-Wnarrowing]
</code></pre>
",4
32983612,32983601,2,"<blockquote>
  <p>What do I do if I want to end up with just a card object? </p>
</blockquote>

<p>Use:</p>

<pre><code>int cardIndex = &lt;some card index&gt;
cards[cardIndex] = Card(RANKS[i],SUITS[j]);;
</code></pre>
",1
25505931,25505647,0,"<p>Do you mean the following?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;


int main( int argc, char **argv )
{
   std::vector&lt;int&gt; v;
   v.reserve( std::max( 0, argc - 1 ) );

   for ( int i = 1; i &lt; argc; i++ ) v.push_back( std::atoi( argv[i] ) );

   //...
}   
</code></pre>
",0
21778815,21778523,12,"<p>As tomislav-maric points out in a comment, the reason is exactly
that given on the page you cite: some older widespread encodings
didn't contain the characters which are replaced.  This is
probably not very relevant today, since those encodings have
pretty much disappeared, being replaced by some of the ISO?8859
encodings or UTF-8.  I don't think you can use this as an
argument for your manager. </p>

<p>On the other hand, at least some C++ experts prefer <code>and</code>, <code>or</code>
and <code>not</code> to <code>&amp;&amp;</code>, <code>||</code> and <code>!</code>.  I'm not one of them, but there
are arguments either way.  My feeling is simply that it's C/C++,
and lots of strange character sequences rule.  (If I were
designing a language from scratch, however...)</p>

<p>With regards to the trigraphs lower down on the page: that can
be considered an experiment that didn't really work.  As far as
I know, no one ever really used them; the resulting code would
be just as unreadable as if the replacement characters were
used.  Consider the alternatives if you were using the German
ISO?646:</p>

<pre><code>int array? 10 ¨¹;      //  native
int array??( 10 ??);  //  tri-graphs
int array&lt;: 10 :&gt;;    //  digraph
</code></pre>

<p>Only the last is even slightly readable, but by the time the
last was specified, the problem had pretty much disappeared.</p>

<p>EDIT:</p>

<p>One additional point.  Regardless of personal preferences, you
should make the decision <code>and</code>/<code>or</code>/<code>not</code> vs. <code>&amp;&amp;</code>/<code>||</code>/<code>!</code> at
a team level, and everyone in the team should use the same
conventions.</p>

<p>EDIT:</p>

<p>FWIW: trigraphs were first introduced in C90 (K&amp;R C didn't have
them); digraphs and alternate tokens in C++98 and C99.  (I'm not
sure offhand whether the earlier versions of CFront supported
them or not.)</p>
",0
21778817,21778523,6,"<p>The C Committee explained why C introduced these alternative operators in <code>iso646.h</code> in <em>C99 Rationale</em>, I think it can be used for C++ as well, since C++ inherit them from C.</p>

<p>In short, digraphs and trigraphs are introduced in C to solve the problem of using C in the old EBCDIC machines (which support ASCII only partly, so some missing ASCII tokens need to be represented in EBCDIC characters). While the alternative operators are used to keep the use of digraphs and trigraphs to a minimum.</p>

<blockquote>
  <h3><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf"" rel=""noreferrer"">Rationale for International Standard ¡ª Programming Languages ¡ª C</a> ¡ìMSE.4 <em>Support for invariant ISO/IEC 646</em></h3>
  
  <p>The added digraphs were intentionally kept to a minimum. Wherever possible, the Committee
  instead provided alternate spellings for operators in the form of macros defined in the new
  header <code>&lt;iso646.h&gt;</code>. Alternate spellings are provided for the preprocessing operators <code>#</code> and <code>##</code> because they cannot be replaced by macro names. Digraphs are also provided for the
  punctuators <code>[</code>, <code>]</code>, <code>{</code>, and <code>}</code> because macro names proved to be a less readable alternative. The Committee recognizes that the solution offered in this header is incomplete and involves a mixture of approaches, but nevertheless believes that it can help make Standard C programs more readable.</p>
</blockquote>

<p>For example, the character <code>|</code> is not in the old machine, so the trigraph <code>??!</code> is used to represent it, but this would make code hard to read is much <code>||</code> is used. C solved the problem by letting the alternative operator <code>or</code> to be used representing <code>||</code>.</p>
",1
23557624,23557419,3,"<p>Original code:</p>

<pre><code>struct Temp
{
    Temp&amp; op1() { ...; return *this; }
    Temp&amp; op2() { ...; return *this; }
    // more op...
}
</code></pre>

<p>Due to the lack of a final semicolon this code is not standard-compliant and will not compile.</p>

<p>It illustrates the importance of posting real code.</p>

<hr>

<p>That said, yes, member functions, even non-<code>const</code> member funcitons, can be called on temporary class type objects, and that includes the assignment operator.</p>

<p>And yes, the lifetime of a temporary extends to the end of the full expression (unless extended by binding to a reference).</p>
",1
23557641,23557419,7,"<p>Totally safe.</p>

<p>It's in paragraph 3 (of &sect;12.2, <code>[class.temporary]</code>):</p>

<blockquote>
  <p>Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</p>
</blockquote>

<p>&sect;1.9/10 (<code>[intro.execution]</code>) defines full-expression:</p>

<blockquote>
  <p>A full-expression is an expression that is not a subexpression of another expression.</p>
</blockquote>

<p>and includes an example somewhat similar to your question:</p>

<pre><code>void f() {
  if (S(3).v()) // full-expression includes lvalue-to-rvalue and
                // int to bool conversions, performed before
                // temporary is deleted at end of full-expression
  { }
}
</code></pre>

<p>The quotes and paragraph numbering come from N3691, the mid-2013 c++-draft, but they haven't changed in a few years and they will probably continue to be valid in C++1x and quite possibly even in C++1y (x&cong;4; y&cong;7)</p>
",5
29169639,29169084,1,"<p>Here is some sample code that replace the two bits in a position given by the indicated bits.</p>

<p>Probably need also to check that <code>positionStart</code> is valid position for value type (in this case <code>unsigned int</code>).</p>

<p>Code:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;iostream&gt;

void changeTwoConsecutiveBits(unsigned int&amp; n, int twoBitsValue,
                              int positionStart) {
    assert(twoBitsValue == 0 || twoBitsValue == 1 || twoBitsValue == 2);

    // 0b11 or 3 if binary literal are not supported in compiler
    const unsigned int inverse_mask = ~(0b11 &lt;&lt; positionStart);
    n = (n &amp; inverse_mask) | (twoBitsValue &lt;&lt; positionStart);
}

int main() {
    unsigned int n = 165; // 1010 0101
    std::cout &lt;&lt; ""n1 pre: "" &lt;&lt; n &lt;&lt; std::endl;
    changeTwoConsecutiveBits(n, 2, 2);
    // n == 1010 [10]01 // [1 0] is the value of twoBitsValue: 2
    assert(n == 169);
    std::cout &lt;&lt; ""n1 post: "" &lt;&lt; n &lt;&lt; std::endl;

    n = 196; // 1100 0100
    std::cout &lt;&lt; ""n2 pre: "" &lt;&lt; n &lt;&lt; std::endl;
    changeTwoConsecutiveBits(n, 1, 3);
    // n == 110[0 1]100 // [0 1] is the value of twoBitsValue: 1
    assert(n == 204);
    std::cout &lt;&lt; ""n2 post: "" &lt;&lt; n &lt;&lt; std::endl;
}
</code></pre>
",0
31167188,31167008,11,"<p>You can simply make your base class a <a href=""https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"">CRTP</a> (as you've mentioned it's already a templated class anyway):</p>

<pre><code>#include &lt;iostream&gt;

template&lt;class Derived&gt;
class A {
public:
    void g() {std::cout &lt;&lt; ""Call from A"" &lt;&lt; std::endl;}
    void f() { static_cast&lt;Derived*&gt;(this)-&gt;g();}
            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Call g() from Derived
};

class B : public A&lt;B&gt; {
public:
    void g() {std::cout &lt;&lt; ""Call from B"" &lt;&lt; std::endl;}
};

int main() {
    B b;
    b.f(); // ""Call from B"" 
}
</code></pre>
",2
23555133,23554671,2,"<p>As I'm writing this one answer has already been selected as &ldquo;the&rdquo; solution.</p>

<p>The problem, a self-assignment <code>b = b;</code>, stems from using the same name <code>b</code> for two different things &ndash;, so that the two meanings were confused.</p>

<p>The selected-as-solution answer does include as a possibility to <em>use different names for different things</em>, but it restricts that to renaming the parameter, and it recommends to keep the proven-as-confusing identical names.</p>

<hr>

<p>Since the problem stems directly from using identical names for different things, the most direct solution is to use different names for different things.</p>

<p>In the case at hand the easiest way to achieve that, is to remove the constructor, so that there is only the data member left &ndash; with its now unique name.</p>

<p>Then the original code &hellip;</p>

<pre><code>class A {
    public:
            A(B *b) {
                    b = b;
            }
            B *b;
};
</code></pre>

<p>becomes, for example, just &hellip;</p>

<pre><code>struct A { B* b; };
</code></pre>

<p>and an original instantiation <code>A a( p );</code> becomes <code>A a{ p };</code>.</p>

<p>Much simpler.</p>

<hr>

<p>Having a constructor implies at least the possibility of class invariant, in which case it's prudent to limit access to the data members.</p>

<p>The almost universal convention is to use some prefix or suffix for non-<code>public</code> member variables. E.g. Microsoft uses an <code>m</code> prefix, while many other use an underscore suffix. (An underscore as a prefix is reserved for the implementation in the global namespace.)</p>

<p>Using the underscore suffix convention for data members, and replacing assignment with the more generally applicable memory initializer, the original becomes something like this:</p>

<pre><code>class A
{
private:
    B* b_;

public:
    auto b() const
        -&gt; B*
    { return b_; }

    A( B* b_value )
        : b_( b_value )
    {}
};
</code></pre>

<p>The simple <code>struct</code> shown earlier suffices if there is no class invariant, while this more verbose &amp; complicated code (or equivalent) is what's needed for safely maintaining a class invariant. The original code was in-between. Not simple enough for the simple data struct case, but not safe enough for the has-invariant case.</p>

<hr>

<p><sup>Renaming the parameter so that it doesn't hide the member is problematic because it keeps the halfway between simple and safe abstraction level. That's also a problem with the idea of referring to the member as <code>this-&gt;b</code>. And using an initializer list <code>A(B *b) : b(b) {}</code> is problematic because it relies on a subtlety of the language, so that most ordinary C++ programmers probably will have to at least think twice to ensure themselves about correctness, and so that at least some will think that it must be erroneous.</sup></p>
",0
23554693,23554671,2,"<p>change the constructor of A to </p>

<pre><code>A(B *b) : b(b) {}
</code></pre>
",0
23554699,23554671,7,"<p>In <code>b = b</code>, both occurences of <code>b</code> refer to the constructor parameter. The member is left uninitialised.</p>

<p>Solutions:</p>

<ul>
<li>use an initialiser list, <code>A(B *b) : b(b) {}</code></li>
<li>rename the parameter so it doesn't hide the member</li>
<li>refer to the member as <code>this-&gt;b</code></li>
</ul>
",5
23554706,23554671,3,"<p>Rewrite <code>A::A()</code> as</p>

<pre><code>A(B *b) {
    this-&gt;b = b;
}
</code></pre>

<p>Otherwise, both <code>b</code>s in <code>b = b;</code> refer to the same variable: the parameter.</p>
",0
27154543,27154478,4,"<p>1) An implicit conversion from <code>bool</code> to <code>const char*</code> is allowed. Unfortunately that is a feature of the language.</p>

<p>2) Because there is an implicit conversion from <code>bool</code> to <code>const char*</code> and <code>std::string</code> has a constructor that takes <code>const char*</code> as parameter. It assumes it points to a valid null-terminated string, which is why you see a runtime error.</p>

<p>3) Because the language does not allow to bind temporaries to non-const lvalue references. Id does, however, allow to bind const lvalue references to temporaries.</p>

<p>4) The compiler already thinks it is right, for all the above reasons.</p>
",7
34240128,34240043,2,"<p>The comparison is delegated to another templated type, for convenience often left defaulted to <code>std::greater&lt;T&gt;</code> which does exactly what it seems to do; it's already available in the standard library, along with many other operations like <code>less</code>, <code>greater_equal</code> and so on, so no need to rewrite them. They're called <em>operator wrappers</em> and are available in 
<code>&lt;functional&gt;</code>.</p>

<p>Therefore, have</p>

<pre><code>template&lt;typename T, typename Compare&gt;
//                   ^^^^^^^^^^^^^^^^
class MyContainer {

    vector&lt;T*&gt; items;
    /* public: */Compare compare;

    // ...
    { 
       if ( compare(T1, T2) )

    }
};
</code></pre>

<p>The signature for <code>Compare</code> must be</p>

<pre><code>template &lt;class T&gt; bool cmp(const T&amp;, const T&amp;);
</code></pre>

<p>or similar in order to keep a standard design, where <code>cmp(a, b)</code> is expected to be a valid expression; of course, yours may different. More info about it <a href=""http://en.cppreference.com/w/cpp/concept/Compare"" rel=""nofollow"">here</a>. </p>

<p>Containers generally allow you to use the comparator object they received, so you may want to make it <code>public</code> as well.</p>

<hr>

<p>Tips, if I may: </p>

<ul>
<li>Keep a <code>vector&lt;T&gt;</code>: pointers are bad; if you have to use them, prefer smart pointers.</li>
<li>You don't need <code>std::function</code>, just a callable object (plain functions, lambda ecc.)</li>
</ul>
",3
26249583,26249543,3,"<p>First case is OK because ""hi"" is a static string - a global constant. It will live at least as long as obj1 (even if obj1 were a global or were allocated on the heap).</p>

<p>The second case is potentially not OK because ""hi is copied into str[] on the stack.</p>

<p>In this particular case, obj2 is destroyed before str, so it is fine. If you were to return a copy of obj2 or it was itself allocated on the heap, then it would be a problem because it could outlive str.</p>

<p>The data of str ([ 'h', 'i', '\0']) is on the stack - the same as a local variable.
This memory is only valid as long as it stays in scope - in this case, until main() returns.
Since obj2 is also on the stack, it essentially has the same lifetime as str, so there is no problem in this instance.
More generally though, you might create an instance of this object with a different lifetime, perhaps like ""MyString *s = new MyString(str); return s;"". Now that MyString object will outlive str, and will continue point at the memory where str used to be causing undefined behavior. 
This is a common source of often difficult to find bugs.</p>
",1
26249607,26249543,4,"<p>In the first case, it is not safe, but not because of where the memory is allocated, but because <code>""hi""</code> is of type <code>const char*</code> (might be on .text or .data who knows), and the contructor for <code>MyString</code> is assigning it to a variable of type <code>char*</code>. If something tried to modify the string through <code>str</code>, undefined behavior would happen.</p>

<p>The problem with the second case is that your object <code>obj2</code> points to a string to which it has no ownership, doesn't matter if it is stack or heap. It is not a terrible thing to do, I've seen legitimate uses for this, but it must be done with care. This particular example will work fine because both object and string live in the stack, and because it is very simple.</p>
",3
21585589,21585433,2,"<p>As it is, your header file is indeed invalid (and even if it weren't, it woudln't be doing what you though it were). A period is not a valid identifier character, so the macro name is just <code>FILE_VER_1</code>.</p>

<p>When using include guard macros, you have to devise a scheme of ""translating"" filename characters which are not legal identifier characters. You could, for example, use <code>_P_</code> to represent a period. So your include guard would then be:</p>

<pre><code>#ifndef FILE_VER_1_P_1_H_
#define FILE_VER_1_P_1_H_

//...

#endif
</code></pre>

<p>How exactly you do that is up to you (any other convention is OK), as long as it produces a legal identifier. And you should be consistent.</p>
",0
29193474,29193454,5,"<p>Typo: that's <code>std::mt19937</code>, not <code>std::mt19337</code>!</p>
",5
31171654,31171614,4,"<p>C++ cannot deduce the enclosing type from its nested type. It is an example of <em>non-deduced context</em>.</p>

<p>A simplest example would be something like</p>

<pre><code>struct S { typedef int T; };

template &lt;typename C&gt; void foo(typename C::T i) {}

int main()  {
   int x = 0;
   foo(x); // ERROR: non-deduced context
}
</code></pre>

<p>or, closer to what you have in your code</p>

<pre><code>template &lt;typename X&gt; struct S { typedef X T; };

template &lt;typename X&gt; void foo(typename S&lt;X&gt;::T i) {}

int main()  {
   int x = 0;
   foo(x); // ERROR: non-deduced context
}
</code></pre>

<p>The same thing happens in your case as well, in a slightly more convoluted form. For template method <code>Assign</code> it is not possible to deduce template parameters <code>TClass</code> and <code>TType</code> through a function parameter like <code>typename SetterPointer&lt;TClass, TType&gt;::Type setter</code>. In your case template parameter <code>TClass</code> is deducible from the first argument of <code>Assign</code>, but <code>TType</code> is not deducible from any argument. Hence the error.</p>

<p>When you change declaration of the last parametr of <code>Assign</code> to <code>TType(TClass::*getter)()</code> you immediately make the context deducible, i.e. the compiler uses the getter argument as an opportunity to deduce <code>TType</code>.</p>

<p>In C++11 you can use alias templates to achieve the same <code>typedef</code> effect and still keep the context deducible</p>

<pre><code>class PropertyAccess
{
public:
    template &lt;typename TClass, typename TType&gt;
    using SetterPointer = void (TClass::*)(const TType&amp;);

    template &lt;typename TClass, typename TType&gt;
    using GetterPointer = TType(TClass::*)();

    template &lt;typename TClass, typename TType&gt;
    void Assign(
        TClass* object,
        SetterPointer&lt;TClass, TType&gt; setter,
        GetterPointer&lt;TClass, TType&gt; getter)
    {
       ... 
    }
};
</code></pre>
",7
21779523,21779372,2,"<p>Union isn't like class or struct as the two ""attributes"" reference the same memory unit.
You can only initialize this memory once you are giving two initializations for the same memory area.</p>

<p>If you change</p>

<pre><code>union valuesUnion
</code></pre>

<p>for</p>

<pre><code>struct valuesUnion
</code></pre>

<p>Then you can check that your initialization list is right for different memory areas.</p>
",2
29236898,29236714,3,"<p>This is impossible; you can't modify a class without modifying it, as it were.</p>

<p>Your best option is probably to publicly inherit from <code>FooFoo</code> and override in the derived class.</p>
",0
29236918,29236714,1,"<p>In C++ language no. In particular implementation it is technically possible to manually modify vtable for class <code>FooFoo</code> and replace pointer to <code>Foo::bar()</code> to something else. Of course this would be an ugly hack and neither recommended practice in any sense nor guaranteed to work even when something changes (for example compilation flags).</p>
",0
29237250,29236714,2,"<blockquote>
  <p>Is it then at all possible to override the default implementation of
  bar() in FooFoo?</p>
</blockquote>

<p>No, but you could derive another class, and use that class ""polymorphically"" via the base. This should have the same effect, given that the original client of Foo does his work through the interface of Foo, as he should</p>

<p>Therefore:</p>

<pre><code>//In Foo.h - may not be modified
struct Foo
{
  virtual bool bar(){ return true;}
};

//In FooFoo.h - may not be modified, hence no override...
struct FooFoo: public Foo
{
  virtual bool bar(){/**/}
};

//FooFoo_2 - The new class - may be implemented in terms of FooFoo
struct FooFoo_2: public Foo
{
  virtual bool bar() override{/*new implementation*/}
};

void fooUser( Foo&amp; foo )
{
  bool result = foo.bar();
  if (result ){} //etc
}

int main()
{
  FooFoo_2 theNewImplementation;
  fooUser( theNewImplementation );
  return 0;
}
</code></pre>

<p>Note also that ""override"" is not required, but if added, one would get a compiler error if the signature of bar changes in base (which would cause derived to not be virtual anymore) - something that one would want to be aware of.</p>

<p>Regards</p>
",1
29236823,29236714,1,"<p>No. You can only override a function by declaring the override within the derived class's definition.</p>
",0
29236877,29236714,1,"<p>No. You'll need to declare the override in the <code>FooFoo</code> class definition, which you said you cannot do. If you tried to define the overriden function in <code>FooFoo</code>, outside of the class, you'd run into errors, since it was not previously declared to be overriden in <code>FooFoo</code>.</p>

<p>Also note, in C++11 and later, you should use the <code>override</code> attribute. Example:</p>

<pre><code>struct FooFoo : Foo
{
    bool bar() override { return true; }
};
</code></pre>
",0
29469071,29468653,2,"<p>Use <code>-Wno-unused-result</code> option.</p>

<p>Alternatively you may temporarily disable and then re-enable a particular warning if you're absolutely sure that it doesn't cause any harm. <a href=""https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html"" rel=""nofollow"">Here's the corresponding GCC documentation</a></p>
",1
24087368,24087301,2,"<p>Yes, you can define it inline in the header.  You can then #include all of the code</p>

<pre><code>class A
{
    void increment()
    {
        i++;
    }
};
</code></pre>

<p>However, this comes with a consequence.  If you make a change to the implementation, every file which included that header (to use the file) must be completely recompiled.</p>

<p>This is one of those cases where one should not assume that language A is just language B with some minor changes.  The header/implementation pattern using two files is a very important part of C++, and you will have a lot of trouble trying to pretend it is Java and using Java's one-file methodology.</p>
",1
24087647,24087301,0,"<p>Although it is not very DRYish I suppose the separated definition and implementation is how it is usually done in C++. </p>

<p>Anyway you could move all your classes code to your header file, but you'd end up with an increased compile time, for every cpp file that uses A would compile the whole code. This would also increase your binaries' size. If you had many classes using many other classes you might end up with a blown-up compilation time and size, many many times it would be if you did it the C++ way. (If your linker is not very clever, but I suppose all of the optimization is done while compilation) </p>

<p>You could also move all your class definition to the cpp file, but I guess this would mess things up even more in virtually every nontrivial case.</p>
",0
28171785,28171708,8,"<p><code>AttrNode::</code> is qualifying the name <code>make</code>, to explicitly call <code>AttrNode::make</code> and not any other function called <code>make</code>.</p>

<p>In this case, that's redundant; <code>AttrNode().make()</code> would do exactly the same thing: create a temporary object, call the function, then destroy the object. Since it's a static function, you would usually call it without making an object, <code>AttrNode::make()</code>.</p>

<p>It makes a difference if it's a virtual function, causing a non-virtual call to the function in the specified class, rather than a virtual call the final override. The syntax can also be used to access a name in the base class that's been hidden in a derived class.</p>
",2
31130613,31130148,1,"<p><code>std::vector&lt;bool&gt;</code> is space efficient in most implementations (g++, MSVC): every item may be stored as a single bit, not as bool. You can read more here: <a href=""http://en.cppreference.com/w/cpp/container/vector_bool"" rel=""nofollow"">en.cppreference.com</a></p>

<p>You have 2 options:</p>

<ol>
<li>Use <code>std::vector&lt;unsigned char&gt;</code> (or other integer type) instead of <code>std::vector&lt;bool&gt;</code>.</li>
<li><p>Use <code>std::vector&lt;bool&gt;::reference</code> as return type for <code>operator[]</code> as follows:</p>

<pre><code>class ReqAtts
{
public:
    std::vector&lt;bool&gt;::const_reference operator[](size_t ii) const
    {
        return _atts[ii];
    }

    std::vector&lt;bool&gt;::reference operator[](size_t ii)
    {
        return _atts[ii];
    }

private:
    std::vector&lt;bool&gt; _atts;

};
</code></pre></li>
</ol>
",1
31130266,31130148,-1,"<p>Change Parameter att to ii , it will work </p>

<pre><code>class ReqAtts
    {
    public:
        const bool&amp; operator[](size_t ii) const
        {
            return _atts[ii];
        }

        bool&amp; operator[](size_t ii)
        {
            return _atts[ii];
        }

    private:
        std::vector&lt;bool&gt; _atts;

    };
</code></pre>
",0
25520636,25520572,2,"<p>It's because you create a temporary <code>std::string</code> object (whose initial content is the content of the array <code>mystr</code>), and pass that temporary object by reference to the function. This temporary object is then destructed when the call id done.</p>
",1
25520656,25520572,1,"<p>Did you read some documentation of <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow"">std::string</a> and of <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow"">printf</a>?</p>

<p>You need</p>

<pre><code>std::string mystr = ""ThisIsSample&amp;String"";
ConvertString(mystr);
printf(mystr.c_str());
</code></pre>

<p>You obviously want to pass by <em>reference</em> a string <em>variable</em> (technically an <a href=""http://en.wikipedia.org/wiki/L-value"" rel=""nofollow"">l-value</a>) to your <code>ConvertString</code></p>
",0
25520679,25520572,1,"<p>I believe your problem is that you cast char array to string. </p>

<pre><code>ConvertString((std::string)mystr);
</code></pre>

<p>this line creates a new variable of type std::string and passes it by reference. What you want is to convert it this way:</p>

<pre><code>std::string convertedStr = (std::string)mystr;
ConvertString(convertedStr);
printf(convertedStr.c_str());
</code></pre>

<p>I am not very well aware of C++ pointer and reference syntax, but it's similar to this</p>
",3
25520683,25520572,0,"<p>what your are doing is not correct! you <s>cannot</s> should not convert a <code>char*</code> to a <code>std::string</code> with a cstyle-cast. what you should do is more like:</p>

<pre><code>std::string mystr( ""ThisIsSample&amp;String"" );
ConvertString(mystr);
</code></pre>

<p>edit:
thx for -reputation... this code isn't even compiling... 
<a href=""http://ideone.com/bCsmgf"" rel=""nofollow"">http://ideone.com/bCsmgf</a></p>
",4
25520792,25520572,4,"<p>This code:</p>

<pre><code>char mystr[80] = ""ThisIsSample&amp;String"";
ConvertString((std::string)mystr);
printf(mystr);
</code></pre>

<p>&hellip; creates a temporary string object and passes that as argument.</p>

<p>Since the formal argument type is by reference to non-<code>const</code>, this should not compile, but Visual C++ supports it as a language extension (for class types only, IIRC).</p>

<p>Instead do like</p>

<pre><code>string s = ""Blah &amp; blah"";
ConvertString( s );
cout &lt;&lt; s &lt;&lt; endl;
</code></pre>

<p>By the way, C style casts are in general an invitation to bugs, because the basic nature of such a cast can change very silently from e.g. <code>const_cast</code> to <code>reinterpret_cast</code> when the code is maintained.</p>

<p>It's safe enough in the hands of an experienced programmer, like a power tool such as a chain saw can be safe in the hands of an experienced woodsman, but it's not a thing that a novice should use just to save a little work.</p>
",0
28486768,28486686,2,"<p>Normally this kind of computation can stop when the next iteration doesn't change the value by much; for example</p>

<pre><code>for(;;) {
    double next_v = (v + (n / v)) / 2;
    if (fabs(v - next_v) &lt; eps) break; // We got there
    v = next_v;
}
</code></pre>

<p>where <code>eps</code> is the accuracy you want in the result.</p>
",0
28486931,28486686,1,"<p>In while (and every loop) there is condition which tells program when to stop it. This conditions must be some expression which return true or false value. Simpler, it's just an equation, or something which gives as clear answer: true or false. In your example expression like : <code>((guess - lastGuess) / lastGuess)</code> isn't returning either true nor false. It returns some numbers etc.
Expression like <code>((guess - lastGuess) / lastGuess) == 4</code> will return true if <code>((guess - lastGuess) / lastGuess)</code> will be equal to 4 and false if not. This example will work: <code>while(x + y !=2)</code>. Program will call loop until x+y is equal 2.</p>
",0
28486833,28486686,1,"<p>You need to compare your error to your determined error limit, instead of zero as your attempts do.</p>

<p>You would use </p>

<pre><code> while (abs((guess - lastGuess) / lastGuess) &gt; .01)
</code></pre>

<p>for a relative error of .01, and</p>

<pre><code>while(abs(guess - lastGuess) &gt; .01)
</code></pre>

<p>for an absolute one.</p>
",4
24081130,24080950,3,"<p>I think you mean the following</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;


int main() 
{
    class A
    {
    public: 
        virtual ~A() = default;
        virtual void print() const 
        { 
            std::cout &lt;&lt; ""Hi from A!"" &lt;&lt; std::endl; 
        }
    };

    class B : public A
    {  
    public: 
        void print() const
        { 
            std::cout &lt;&lt; ""Hi from B!"" &lt;&lt; std::endl;
        }
    };

    class C : public B
    {
    public:
        void print() const 
        { 
            std::cout &lt;&lt; ""Hi from C!"" &lt;&lt; std::endl; 
        }
    };

    std::vector&lt;A *&gt; v = { new A(), new B(), new C() };

    for ( A *p : v ) p-&gt;print();

    return 0;
}
</code></pre>

<p>The output is</p>

<pre><code>Hi from A!
Hi from B!
Hi from C!
</code></pre>
",0
24081149,24080950,2,"<p>1 won't work, since <code>*x</code> has type <code>A*</code>, and <code>A</code> doesn't have a <code>printC</code> member. It should be:</p>

<pre><code>if (C * c = dynamic_cast&lt;C *&gt;(*x)) {
    c-&gt;printC();
}
</code></pre>

<p>2 is fine, but doesn't match your description; you say you want to ""only call objects that have the <code>printC()</code> method"", while this calls <code>printA()</code> on the other objects.</p>

<p>This does seem like an odd design though; you'd usually define a single virtual function, implemented by each class to do the right thing for that class, then call that unconditionally for everything.</p>
",0
27143986,27143968,2,"<p>That should be:</p>

<pre><code>template &lt;std::size_t N&gt;
std::size_t getSize(const int (&amp;)[N]){ return N; }
</code></pre>
",1
21029502,21029391,0,"<p>If your compiler supports it, you can use lambdas:</p>

<pre><code>    for_each(tokens.begin(), tokens.end(), [&amp;li] (Token * val)
    {
        li.add_string(val-&gt;get_name());
    } );
</code></pre>
",0
21044978,21029391,0,"<p>The error comes from the fact you are trying to bind a function as the second parameter for the <code>add_string</code> method of <code>MyList</code>. <code>bind1st</code> and <code>bind2nd</code> requires the value to be constant and are not geared to receive functions as value to bind.</p>

<p><code>for_each</code> requires a function which takes iterator as first its parameter. What you want to accomplish can't be done without an external function(which is the equivalent of a lambda but not nearly as elegant) if you really insist on using <code>for_each</code>. This function would need to receive the list and token iterator as parameter. You can then bind the list to the function with either <code>bind1st</code> or <code>bind2nd</code> depending on the order in which you declare the parameter.</p>

<p>Let's you have this function:</p>

<pre><code>void AddTokenNameToList(MyList&amp; li, Token* token)
{
    li.add_string(token-&gt;get_name());
}
</code></pre>

<p>You could have this <code>for_each</code>:</p>

<pre><code>for_each(tokens.begin(), tokens.end(), std::bind1st(AddTokenNameToList, li));
</code></pre>

<p>If list parameter were inverted, you would use bind2nd instead to bind the list value.</p>

<p>You could argue that this function is custom for this particular case and not as elegant as using only std methods. I guess you could get crazy and template that function to receive method to apply to first parameter and the one for the second but what you really want here is a lambda and since you can't use them, this is as close as you gonna get.</p>

<p>At this point however, you have to wonder if it really saves code. That's one of the reason bind1st and bind2nd have bad rep and considered almost useless. However it lets you use some other nice algorithm so they still have some advantages.</p>
",0
23575632,23575605,2,"<p>No, any pointer returned via a call to <code>new</code> or <code>new[]</code> must be free'd with a corresponding call to <code>delete</code> or <code>delete[]</code>. </p>

<pre><code>int* x = new int;
x = new int; // Memory leak!
</code></pre>

<p>In C++ <code>new</code> is an operator which returns an object allocated on the heap.  It doesn't care what you assign it to.  The only thing that matters is that the object returned via <code>new</code> is eventually passed to the <code>delete</code> operator.</p>
",0
23575643,23575605,1,"<p>The constructor is called before any other member function. Therefore it is not possible that  <code>nstring</code> already points to some allocated memory. </p>

<p>As you say, <code>x = new int;</code> does not <code>delete</code> whatever <code>x</code> was pointing to before (if anything).</p>

<p>The line: <code>myString = MyString(""test2"");</code> calls <code>myString.operator=( MyString(""test2"") );</code>. You speak as if you thought it destroyed <code>MyString</code> and then constructed a new one, but that is not happening. It is just a function which we call the copy-assignment operator, and you should implement this function.</p>

<p>There is a construction and destruction involved in the expression <code>MyString(""test2"")</code>, but that does not affect <code>myString</code>.</p>
",0
23575665,23575605,1,"<p><code>In C++, does calling new on a pointer that holds new'd data delete the old data?</code>  </p>

<p>No.  You must <code>delete</code> the allocated memory.</p>

<p><code>If the destructor is invoked upon reassigning myString then it all makes sense to me.</code></p>

<pre><code>MyString myString(""test"");
myString = MyString(""test2""); //is the destructor invoked here?
</code></pre>

<p>The code you posted is interesting.  There is an assignment done, in addition to a construction.  The issue with your class is that it lacks a user-defined assignment operator (at least it wasn't shown), so there <em>is</em> a memory leak.  </p>
",0
23575679,23575605,0,"<p><code>new</code> does not deallocate pre-allocated memory. You <em>will</em> get a memory leak if you use <code>new</code> before deallocating the resource. In your example, doing <code>myString = MyString(""test2"")</code> does indeed cause a memory leak as the copy-assignment operator (or move-asssignment depending on the compiler version) doesn't go to lengths to clean up the memory already held by <code>nstring</code>. Both of these functions are provided by the compiler as you haven't created them yourself, and their job (by default) is simply to copy (or move) member-wise, without regard to memory management.</p>
",0
23575710,23575605,2,"<p>You are right about the pointer behavior: the memory will not be released when the pointer is reassigned.</p>

<p>The issue with your code (I changed the name of the variable to avoid confusion):</p>

<pre><code>MyString x(""test"");
x = MyString(""test2"");
</code></pre>

<p>is that the second line does not call the constructor or destructor of <code>x</code> again. In C++, constructors and destructors are called just once per object. This code calls <strong>the assignment operator</strong>.</p>

<p>The sequence call would be:</p>

<ol>
<li>Call the constructor of <code>x</code> with <code>""test""</code>.</li>
<li>Call the constructor of the unnamed temporary with <code>""test2""</code>.</li>
<li>Call the assignment operator of <code>x</code> with the temporary object.</li>
<li>Call the destructor of the temporary object.</li>
<li>At the end of the current scope, call the destructor of <code>x</code>.</li>
</ol>

<p>The assignment operator should be defined more or less this way:</p>

<pre><code>const MyString &amp;MyString::operator=(const MyString&amp;o)
{
    nlength = S.nlength;  // we know this is correct!
    delete []nstring;
    nstring = new char[ nlength ];
    strcpy( nstring, S.nstring );
    return *this;
}
</code></pre>

<p>Naturally this code is not exception safe. What will happen if this <code>new</code> fails? The object will be broken! So do instead:</p>

<pre><code>const MyString &amp;MyString::operator=(MyString o)
{
    swap(*this, o);
    return *this;
}
</code></pre>

<p>This is called the copy-n-swap idiom, or something like that. The sequence of calls with this <code>operator=</code> when running the point 3 above would be:</p>

<ol>
<li>Call the copy constructor of <code>o</code> passing in the temporary.</li>
<li>Swap the values of <code>o</code> and <code>this</code>.</li>
<li>Calling the destructor of <code>o</code>, that will delete the first allocation (<code>""test1""</code>).</li>
</ol>
",1
28234809,28234714,1,"<p>Use:</p>

<pre><code>static_cast&lt;A const*&gt;(this)-&gt;saySomething();
</code></pre>

<p>You can also use a pointer-to-member-function:</p>

<pre><code>(this-&gt;*(&amp;A::saySomething))();
</code></pre>
",3
28234842,28234714,2,"<p>As a preface to this answer, what you are doing is rarely a good idea as those functions have different semantics and should not have the same name.</p>

<p>That said, the issue you are having as that the function names in the base classes are being covered by those in the derived classes. In order to fix this, you need to expose them like so:</p>

<pre><code>class B : public A
{
public:
    using A::saySomething; //HERE expose the function
    virtual void saySomething(const std::string&amp; username) const;
    {
        //the compiler now knows to look in the base class for this function
        saySomething(); 
    }
};

class C : public B
{
public:
    using B::saySomething; //and HERE
    void saySomething() const;
};
</code></pre>

<p>Now all versions of <code>saySomething</code> are available to call on instances of <code>C</code>. Furthermore, casting a <code>C*</code> to a <code>B*</code> will correctly call <code>C::saySomething</code> from <code>B::saySomething</code> because you aren't explicitly telling <code>B</code> which version to use, so it follows the virtual function correctly.</p>
",0
25696969,25696946,0,"<p>Q: in the second version, the variable name breed does not resolve. Why is that?</p>

<p>A: Because it's wrong.</p>

<p>You <em>declare</em> your class <em>once</em>, e.g. in the header.</p>

<p>You may <em>define</em> your method implementations either in-line (in the header itself, when you declare the class), or in a separate .cpp (as you did in example 1).
Thess links might help explain further:</p>

<ul>
<li><p><a href=""http://www.cplusplus.com/doc/tutorial/classes/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/classes/</a></p></li>
<li><p><a href=""http://www.cprogramming.com/declare_vs_define.html"" rel=""nofollow"">http://www.cprogramming.com/declare_vs_define.html</a></p></li>
</ul>
",0
23089853,23089734,1,"<p>You probably meant to write something like</p>

<pre><code>void testSqState() {
    SqState sq('-', 4, 0);
    sq.print(std::cout);
}

void testSquare() {
    Square s(4, 0);
    s.print(std::cout);
}
</code></pre>
",2
23089861,23089734,0,"<pre><code>**sq.print(ostream s);**
**s.print(ostream st);**
</code></pre>

<p>You don't need to put ostream there, assuming s and st are already defined.</p>
",0
23090215,23089734,2,"<p>Considering this code:</p>

<blockquote>
<pre><code>SqState sq('-', 4, 0);
sq.print(ostream s);
</code></pre>
</blockquote>

<p>You can note that <code>SqState</code> has a method named <code>print()</code>, that is defined here:</p>

<blockquote>
<pre><code>ostream&amp;
SqState :: print(ostream&amp; sq)
{

    return sq &lt;&lt; ""value: "" &lt;&lt; sq_value;
}
</code></pre>
</blockquote>

<p>So, the parameter to this <code>print()</code> method is a <em>reference</em> (<code>&amp;</code>) to an instance of <code>ostream</code> (actually, <code>std::ostream</code>).<br>
You should provide that instance at the call site, and an option is <code>std::cout</code> to print text on the standard console output:</p>

<pre><code>sq.print(std::cout);
</code></pre>

<p>Similarly, for the other code in the <code>testSquare()</code> function.</p>
",0
21182861,21182296,1,"<p>You're attempting to modify a string literal. You are not allowed to do that.<br>
Your compiler should have warned you about the line</p>

<pre><code>char * ch = ""acbcccdc"";
</code></pre>

<p>If it didn't, you need to increase the warning level</p>

<p>Replace that line with</p>

<pre><code>char ch[] = ""acbcccdc"";
</code></pre>

<p>so you work on a mutable copy of the string instead.</p>
",1
21183844,21182296,1,"<p>You have a C-style string declared here:</p>

<pre><code>char * ch = ""acbcccdc"";
</code></pre>

<p>that is passed as an argument to the <code>replace</code> function. In it you are trying to modify a character from the string at the line:</p>

<pre><code>*str = c2;
</code></pre>

<p>which is also where your program stops. </p>

<p>The Standard, at section ¡ì2.14.5/12, clearly specifies:</p>

<blockquote>
  <p>The effect of attempting to modify a string literal is undefined.</p>
</blockquote>

<p>Therefore your program's behavior is <em>undefined</em>.</p>

<p>Since you are using C++, and not C, I recommend to use <code>std::string</code> instead. With it you would have avoided this, and many other problems. Not to mention that most of your code will look cleaner. Just look at the <code>std::string</code> counterpart for your <code>replace</code> function:</p>

<pre><code>int replace(std::string&amp; str, char c1, char c2) {
    int cc = std::count(str.begin(), str.end(), c1);
    std::replace(str.begin(), str.end(), c1, c2);
    return cc;
}
</code></pre>
",0
24635477,24635198,1,"<p>use template specialization:</p>

<pre><code>template&lt;&gt;
int f&lt;int&gt;(int x ) { return 1; } // a)
</code></pre>
",2
27161420,27161407,0,"<p>The <code>const</code> after the method name signifies that the method does not modify any field of the object.  Therefore, it can be invoked on a <code>const</code> instance of the object.</p>
",1
27161444,27161407,3,"<pre><code>const T&amp; value() const {...}
</code></pre>
<p>This means the function <code>value()</code> will return a <code>const T&amp;</code> type and in between (in the function) won't modify the class itself.
Say I write:</p>
<pre><code>class Cfoo
{
    void foo() const
    {
        //Cfoo will not be modified here
    }
}
</code></pre>
<p>If I directly quote from <a href=""https://docs.microsoft.com/en-us/cpp/cpp/const-cpp"" rel=""nofollow noreferrer"">MS Docs</a>: <br><br>
<strong>Declaring a member function with the const keyword specifies that the function is a &quot;read-only&quot; function that does not modify the object for which it is called. A constant member function cannot modify any non-static data members or call any member functions that aren't constant.</strong></p>
",2
22436873,22436856,5,"<p>It is valid code, because <code>a</code> is  not <code>const</code>. A <code>const</code> reference means you cannot modify the refered-to object via the reference.</p>
",0
22436886,22436856,1,"<p>As a reference is just <em>another name</em> to a variable and not the object itself, yes in the snippet you show it can be thought as a read-only reference. The code provided with the reference can only access it but it does not guarantee that the object itself won't be changed in another place of your program.</p>
",0
22436920,22436856,2,"<p>In this particular case, all you are doing is creating a REFERENCE that is <code>const</code> - meaning that <code>ca</code> can't modify the value it refers to (<code>a</code> in this case). </p>

<p>A common usage is to pass a const reference to a function:</p>

<pre><code>void foo(const int&amp; cr)
{
   ... use cr ... 
}
</code></pre>

<p>This indicates that although the value is a reference, the function <code>foo</code> does not alter the value in <code>cr</code>. It is perfectly valid to call this function with a modifiable <code>int</code> variable, or even something that can't be referenced (for example <code>foo(4);</code> - the value 4 is just a constant, so can't really be used as a reference - the compiler will ""fix"" this by creating a temporary int variable, and pass the reference to that). </p>

<p>Of course, this is more commonly used with more complex types than <code>int</code> - for example <code>std::string</code> or <code>std::vector</code>. The main reason in this case is to avoid the value being copied, rather than ""I want a reference"". </p>
",5
28175014,28174972,5,"<p>It's identical. But in C++, <code>this</code> is a <em>pointer</em> to the object instance, whereas in Java, it's a <em>reference</em>.</p>

<p>In C++, <code>this</code> will be a <code>const</code> pointer to the object if called from a member function marked <code>const</code>. That helps achieve program stability.</p>
",1
30406047,30405177,1,"<p>Use <code>std::tuple&lt; std::pair&lt; DataType, std::function&lt; void() &gt;  &gt; &gt; myMap;</code></p>

<p>Then implement get by type see example with a factory using this technique here:
<a href=""https://github.com/alekstheod/tnnlib/blob/master/src/Utilities/Utilities/Design/Factory.h"" rel=""nofollow"">https://github.com/alekstheod/tnnlib/blob/master/src/Utilities/Utilities/Design/Factory.h</a></p>

<p>for get by type look here:
<a href=""https://github.com/alekstheod/tnnlib/blob/master/src/Utilities/Utilities/MPL/Tuple.h"" rel=""nofollow"">https://github.com/alekstheod/tnnlib/blob/master/src/Utilities/Utilities/MPL/Tuple.h</a></p>

<p>Starting from here:</p>

<pre><code>    int retInt(){
  return 1;
}

float retFloat(){
  return 1.f;
}

char retChar(){
  return 'a';
}

int main(int, char *[])
{

  std::tuple&lt; std::pair&lt; int, std::function&lt; int () &gt; &gt;,
             std::pair&lt; float, std::function&lt; float() &gt; &gt;,
             std::pair&lt; char, std::function&lt; char () &gt; &gt; &gt; map;

  std::get&lt;0&gt;(map).second = retInt;
  int result = std::get&lt;0&gt;(map).second();
  return 0;
}
</code></pre>

<p>This is a simple example when I take a first element from a tuple and execute the function. Now instead of getting the first element we need to find an element by using a type. A bit of metaprogramming:</p>

<pre><code>namespace detail{

template &lt;class T, std::size_t N, class... Args&gt;
struct get
{
  static const auto value = N;
};

template &lt;class T, std::size_t N, class... Args&gt;
struct get&lt;T, N, T, Args...&gt;
{
  static const auto value = N;
};

template &lt;class T, std::size_t N, class U, class... Args&gt;
struct get&lt;T, N, U, Args...&gt;
{
  static const auto value = get&lt;T, N + 1, Args...&gt;::value;
};

}

template &lt;class T, class... Args&gt;
std::pair&lt; T, std::function&lt; T() &gt; &gt;&amp; get(std::tuple&lt;Args...&gt;&amp; t)
{
    using Entry = std::pair&lt;T, std::function&lt;T()&gt; &gt;;
    return std::get&lt;detail::get&lt;Entry, 0, Args...&gt;::value&gt;(t);
}
</code></pre>

<p>Then call to it will look like:</p>

<pre><code>int main(int, char *[])
{

  std::tuple&lt; std::pair&lt; int, std::function&lt; int () &gt; &gt;,
             std::pair&lt; float, std::function&lt; float() &gt; &gt;,
             std::pair&lt; char, std::function&lt; char () &gt; &gt; &gt; map;

  get&lt; int &gt;(map).second = retInt;
  int result = get&lt;int&gt;(map).second();

  get&lt; float &gt;(map).second = retFloat;
  float result2 = get&lt; float &gt;(map).second();

  return 0;
}
</code></pre>

<p>You can replace a return type of the function or the function itself. Or you can keep it as it is and do a bind in case some more arguments are needed.</p>
",2
30702554,30702506,2,"<p>According to your code, <code>Token</code> need to have a default ctor but it doesn't have. <code>data</code> in class <code>Node</code> will be initialized by its default ctor first, and then assigned by <code>operator=</code> in the ctor of <code>Node::Node</code>. You can use ctor initialization list to solve it, the copy ctor of <code>Token</code> will be called instead.</p>

<pre><code>Node::Node(const Token &amp;v) : data(v) {}
</code></pre>
",1
30702557,30702506,3,"<p>You need to change implementation like this:</p>

<pre><code>Node::Node(const Token &amp;v) : data(v){
}
</code></pre>

<p>to invoke the right constructor, otherwise the compiler will call default constructor first (which is missing, hence the message), then the assignment operator. </p>
",1
22880199,22880106,0,"<p>This is a platform question (or a terminal question, if your terminal isn't part of your platform), not a C++ question. It's not even guaranteed that every terminal has this capability -- what if the terminal only sends characters when the user hits enter?</p>
",0
22880142,22880106,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;conio.h&gt;
#include &lt;ctype.h&gt;
using namespace std;

int main(){
  _cputs( ""Type 'Y' when finished typing keys: "" );
    char ch;
   do{
      ch = _getch();
      cout&lt;&lt;ch;
   } while( ch != '.' );

    return 0;
}
</code></pre>
",1
24615931,24615565,4,"<pre><code>int main()
{
    C c(""Hello"", ""to"", ""you"");

    A* a = &amp;c;
    a-&gt;printInfo();  // ""C class""
}
</code></pre>

<p>This, due to the keyword <code>virtual</code>, performs <em>virtual dispatch</em>, invoking the most-derived <code>printInfo</code>.</p>

<p>You can disable the virtual dispatch and invoke a specific function:</p>

<pre><code>a-&gt;A::printInfo();   // ""A class""
</code></pre>

<p>because <code>a</code> is a <code>A*</code> so the usual function call rules apply.</p>

<p>The left-out sheep here is <code>B::printInfo()</code>:</p>

<pre><code>a-&gt;B::printInfo();  // error: 'B' is not a base of 'A'
</code></pre>

<p><code>B::printInfo</code> is neither the most-derived overrider, nor a member of <code>A</code>. So, for this, you must make a promise to the compiler that <code>a</code> really points to a <code>C</code> (or, at least, a <code>B</code>):</p>

<pre><code>static_cast&lt;B*&gt;(a)-&gt;B::printInfo();
                    // ""B class""
</code></pre>

<p>Yuck.</p>

<p>Generally you should question your approach whenever this ""need"" arises, as it smells of bad design.</p>
",1
22503895,22503851,4,"<p>You can simply use:</p>

<pre><code>fabs(a-b) &lt; eps  // eps is the precision you want to achieve
</code></pre>
",0
22503935,22503851,-1,"<p>I use this function :</p>

<pre><code>template &lt;typename T&gt;
bool approx(const T&amp; x, const T&amp; y, const T&amp; eps = 1.0e-10)
{
  if(x == y)
    return true;
  if(x == 0.0)
    return (y &lt; 0.0 ? -y : y) &lt; eps;
  if(y == 0.0)
    return (x &lt; 0.0 ? -x : x) &lt; eps;
  return (x &lt; y ? y - x : x - y) &lt; eps * ((x &lt; 0.0 ? -x : x) + (y &lt; 0.0 ? -y : y)) / 2.0;
}
</code></pre>
",1
22504012,22503851,5,"<p>the technique to compare floats or doubles is to use <a href=""http://www.cplusplus.com/reference/cmath/fabs/"" rel=""nofollow""><code>fabs</code></a></p>

<pre><code>bool isEqual(const float a,const float b)
{
    return fabs(a - b) &lt; std::numeric_limits&lt;float&gt;::epsilon();
}
</code></pre>

<p>You can use epsilon for the floats or doubles from <a href=""http://www.cplusplus.com/reference/limits/numeric_limits/"" rel=""nofollow""><code>std::numeric_limits</code></a></p>
",0
29159569,29155219,3,"<p>Ah, so this is a misunderstanding of the operations being performed.  Notice the constant <code>p=2</code>.  I have the text <code>All computations are modulo 2.</code>.  Perhaps also stating <code>All inputs are modulo 2</code> would help hammer the point home.  Lets look at some of our computations:</p>

<pre><code>0 + 0 mod 2 = 0
2 + 3 mod 2 = 1
4 + 6 mod 2 = 0
6 + 9 mod 2 = 1
</code></pre>

<p>All looks good - addition ring 2 is just exclusive OR.  How about multiplication?  In ring 2 (binary) that's just AND:</p>

<pre><code>0 * 0 = 0
2 * 3 = 6 mod 2 = 0
4 * 6 = 24 mod 2 = 0
6 * 9 = 54 mod 2 = 0
</code></pre>

<p>So that all checks out as well.  Finally, look back at the blog and see that I called this out again and give you a way to operate on something you might consider more pleasing:</p>

<blockquote>
  <p>In this case, I am building for GF(2) - so my homormorphic addition
  is XOR and multiplication is AND. Changing this is as easy as changing
  the value of p. Folks wanting to see 2+2=4 should set p to something
  that matches their desired domain, such as 257 to obtain 8 bit Ints.</p>
</blockquote>

<p>However, HELib has regressed in this aspect - setting <code>p</code> equal to anything larger than <code>2</code> did not work last time I tried it.  Shai confirmed this is a known regression.</p>
",0
21783091,21782391,6,"<p>Sometimes there is a sense to redeclare a function inside a block scope. For example if you want to set a default argument. Consider the following code</p>

<pre><code>#include &lt;typeinfo&gt;

using namespace std;

int sum(int a, int b){
    return a + b;
}

int main()
{
    int sum(int, int = -1 ); // redeclaring sum???
    int a = -1;
    auto result = sum(a, a);
    cout &lt;&lt; result &lt;&lt; typeid(result).name() &lt;&lt; endl;

    result = sum(a);
    cout &lt;&lt; result &lt;&lt; typeid(result).name() &lt;&lt; endl;
}
</code></pre>

<p>Another case is when you want to call a concrete function from a set of overloaded functions. Consider the following example</p>

<pre><code>#include &lt;iostream&gt;

void g( int ) { std::cout &lt;&lt; ""g( int )"" &lt;&lt; std::endl; }
void g( short ) { std::cout &lt;&lt; ""g( short )"" &lt;&lt; std::endl; }

int main()
{
   char c = 'c';
   g( c );

   {
      void g( short );
      g( c );
   }
}
</code></pre>
",4
21782513,21782391,2,"<p>If that's the actual code, there's no reason to do it.</p>

<p>If the function <code>sum</code> is defined somewhere else though, the declaration inside <code>main</code> makes it accessible only inside <code>main</code>. You can't use it anywhere else in that translation unit (unless of course you declare it). So it's a sort of limiting visibility to where it's needed, but, granted, it's not very readable.</p>

<p>Regarding changing the return type - that's illegal. You're not seeing any issues with <code>unsigned int</code>, but if you try </p>

<pre><code>char sum(int, int); // redeclaring sum???
</code></pre>

<p>you'll see there's a problem there. </p>
",3
23597162,23597112,0,"<p>Yes that is correct.  I think you mean in the first case that it is a reference to <code>f</code> not a reference to <code>foo</code>.  Same with in the second case it is that you're passing a copy to <code>f</code> not the <code>f</code> itself.</p>
",4
23597186,23597112,3,"<p>Yes, but IMO you are wording is quite strange or maybe you are over-complicating things a bit. </p>

<p>The second signature uses a ""pass by value"" method. As opposed to the first example, where a ""pass by reference"" is used. The idea is that you operate on the value of the argument, and not the argument itself.</p>

<p>This means a temporary copy of the passed parameter is made, with the lifetime limited by the scope of the function.</p>
",0
27764081,27764050,3,"<p>Just use std::string. It handles UTF-8 strings just fine. </p>

<p>Obviously you need to be aware that a codepoint can be 1 to 4 chars, and that a character can actually be any number of codepoints, but that rarely matters to you, and when it matters, std::wstring would have the same problems. </p>

<p>Big advantage is that std::string works the same everywhere. With std::wstring, different implementations use 16 bit or 32 bit numbers with very different meanings, there are problems with byte ordering and so on. </p>
",1
22434725,22434717,6,"<p>Sure, see <code>std::sqrt</code> in header <a href=""http://en.cppreference.com/w/cpp/numeric/math/sqrt""><code>&lt;cmath&gt;</code></a>.</p>
",0
22434749,22434717,3,"<p><a href=""http://msdn.microsoft.com/en-us/library/f1xa99e6.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/f1xa99e6.aspx</a>  explains the difference .<br>
In C++  <code>sqrt()</code> accepts either a <code>double</code>, a <code>float</code> or a <code>long double</code> while <code>sqrtf()</code> accepts only a float.<br>
The only reason why there's two different versions is because C did not support overloading, so there had to be two functions.<br>
<code>C++</code> allows overloading, so there are actually three different versions of <code>sqrt()</code> taking floating point arguments of various sizes.<br>
In <code>C++</code>, the overloaded <code>sqrt</code> (defined in <code>cmath</code>, in <code>namespace std</code>) should be used.</p>
",0
33570776,33570733,5,"<p>Why not this?</p>

<pre><code>return new classobj;
</code></pre>

<p>Or this:</p>

<pre><code>return new decltype(*this);
</code></pre>

<p>But please don't do this at all. The pointer returned by your function has unclear ownership semantics. We generally don't need raw pointers nowadays.</p>
",3
33570916,33570733,1,"<p>Implement a copy constructor first</p>

<pre><code> classobj(const classobj&amp; obj);
</code></pre>

<p>then</p>

<pre><code> return new classobj(*this) 
</code></pre>
",0
28469963,28469869,2,"<p>Use this API</p>

<p><code>template &lt;class InputIterator&gt;
    void insert (iterator position, InputIterator first, InputIterator last);</code></p>

<p>So in your case, replace the second loop with:</p>

<p><code>insert(itr,v2.begin(),v2.end())</code></p>
",1
28469998,28469869,2,"<p>Your current code crashes because <code>itr</code> is invalidated when <code>insert()</code> reallocates <code>v2</code> after it exceeds its max capacity.</p>

<p>Change the following:</p>

<pre><code>v2.insert(itr, *ri);
</code></pre>

<p>to</p>

<pre><code>itr = v2.insert(itr, *ri);
</code></pre>
",0
28470003,28469869,2,"<blockquote>
  <p>what is wrong of the above code?</p>
</blockquote>

<p>The iterator <code>itr</code> became invalid after <code>insert</code>, so program crashed at the 2nd execution of the for loop. You can use the return value of <code>insert</code> (iterator pointing to the inserted value) to get a valid iterator for insert position.</p>

<p>Change</p>

<pre><code>v2.insert(itr, *ri);
</code></pre>

<p>to</p>

<pre><code>itr = v2.insert(itr, *ri);
</code></pre>

<p><code>insert</code> causes reallocation if the new size() is greater than the old capacity(). If the new size() is greater than capacity(), all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated. </p>

<p>Reference: <a href=""http://en.cppreference.com/w/cpp/container/vector/insert"" rel=""nofollow"">http://en.cppreference.com/w/cpp/container/vector/insert</a></p>

<p>PS: Please see @Kam's answer, it's a better solution than hand-written loops in general cases.</p>
",0
22464048,22463985,0,"<p>If you plan to have only one loggin for the whole process then use a static object and no need to copy and delete the objects</p>

<p>If you plan to have a limited number of objects (one per logging level for example) and that these objects are heavy (large buffer, odbc connection) then it is worth having a movable and copyable class.</p>

<p>However, you cannot have a mutex in a copyable class because the mutex are not copyable.</p>
",0
22465255,22463985,0,"<p>Short answer: a logger is kind of like an output stream, so do the same as for streams. Movable but not copyable.</p>

<p>Long answer: this breaks into two decisions, each in two parts:</p>

<ul>
<li>Should I make the logger interface that this type satisfies, guarantee copyable and movable?</li>
</ul>

<p>Future logger types predictably will contain streams or mutexes, which means the interface should not guarantee copyable because those things are not copyable. A <code>vector</code> of loggers might make some sense, so it's not completely pointless to make loggers movable provided you don't see a specific reason not to.</p>

<ul>
<li>Should I make this class copyable and movable?</li>
</ul>

<p>It probably doesn't matter, except that you say you're planning to add data members in future. That is to say, you're going to modify this logger class instead of writing new logger classes that satisfy the same basic interface with a different sink for the log messages. <em>If you're certain that's wise</em>, then for that reason the same considerations apply to this class as to the interface: don't make it copyable. Movable probably won't do any harm and does some slight good.</p>
",0
30147661,30147647,4,"<p>Your function </p>

<pre><code>std::string reverse_words(const std::string&amp; in)
</code></pre>

<p>takes a const reference, but you pass an address. Remove the <code>&amp;</code> when passing the argument</p>

<pre><code>std::string reverse_words = s.reverse_words(&amp;in);
                             ^change to-&gt;   ^ remove this
</code></pre>

<p>Next, <code>s</code> is a pointer, so you have to call the member function via the <code>-&gt;</code> operator, like </p>

<pre><code>s-&gt;reverse_words(in);
</code></pre>

<p>Side note: even if internally references are usually implemented as pointers, you should not use pointer syntax when passing an argument by reference. In other words, the <code>&amp;</code> address-of operator should never be present when passing by reference.</p>
",5
22519052,22518983,5,"<p>See <a href=""https://stackoverflow.com/questions/358342/canonical-vs-non-canonical-terminal-input/358381#358381"">Canonical vs Non-canonical Terminal Input</a> for a lot of details.</p>

<p>Yes, by default you have to enter return before any data is made available.</p>

<p>Yes, there are ways to use non-canonical input so that characters are available as soon as they are entered.  However, the mechanisms for obtaining that behaviour are radically different between Windows and Unix-based systems.</p>
",0
29216005,29215944,1,"<p>This loop</p>

<pre><code>  for(int e=0, myArray; e&lt;=i; e++){
      std::cout &lt;&lt; ""Number to put in:"";
      int a;
      std::cin &gt;&gt; a;
      myArray[&amp;e] = a;
  }
</code></pre>

<p>is wrong.</p>

<p>The valid loop could like like</p>

<pre><code>  for ( int e = 0; e &lt; i; e++ ){
      std::cout &lt;&lt; ""Number to put in:"";
      int a;
      std::cin &gt;&gt; a;
      myArray[e] = a;
  }
</code></pre>

<p>I suppose that the pointer is defined like</p>

<pre><code>int* myArray = new int[i];
</code></pre>

<p>instead of</p>

<pre><code>int* myAarray = new int[i];
</code></pre>

<p>that is it has name myArray.</p>
",2
27180611,27180566,1,"<p>Would a <code>std::vector&lt;std::function&lt;void(int)&gt;&gt;</code> work?</p>

<p>If you want to order your functions it seems like you'd be the only one who knew the order anyway.</p>

<p>Perhaps creating an <code>enum</code> to index the <code>std::vector</code> would also be helpful for ordering?</p>
",0
27180627,27180566,3,"<p>A <code>set</code> has the requirement that its elements may be <em>ordered</em> using <code>&lt;</code>. So to put functions in a set, you have to define an ordering for functions first. For example, this comparison considers all functions with the same type as equal:</p>

<pre><code>#include &lt;set&gt;
#include &lt;functional&gt;

using namespace std;

typedef function&lt;void(int)&gt; fun;

bool operator&lt;(const fun&amp; f1, const fun&amp; f2) {
    return f2.target_type().name() &lt; f2.target_type().name();
}

int main() {
    set&lt;fun&gt; fset;
}
</code></pre>

<p>Likewise, for an <code>unordered_set</code>, you'd have to define a specialization of <code>std::hash&lt;fun&gt;</code>.</p>

<p>Edit: I've borrowed the <code>target</code> idea from another solution to make the comparison well-defined.</p>

<p>Edit2: The most meaningful comparison for arbitrary functions would probably look like this:</p>

<pre><code>struct fun_comp {
    template&lt;typename Fun1, typename Fun2&gt;
    bool operator()(const Fun1&amp; f1, const Fun2&amp; f2) {
        const char* c1 = f1._M_functor._M_pod_data;
        const char* c2 = f2._M_functor._M_pod_data;
        size_t sz = sizeof(f1._M_functor._M_pod_data);
        return lexicographical_compare(c1, c1+sz, c2, c2+sz);
    }
};
</code></pre>

<p>This is, obviously, completely unportable, depends on <code>libstdc++</code>-internals and will only compile with <code>-fno-access-control</code>, so you probably shouldn't <em>actually</em> do it like this.</p>
",5
29953086,29952941,3,"<p>Vectors <em>are</em> like arrays that resize themselves once you reach a certain capacity, if you use <code>insert</code> and <code>push_back</code> and other such functions.</p>

<p>You complain about <code>vec.reserve(100);</code> because it calls all of the constructors, and then imply you want it to work like <code>int[] arr = new int[100];</code>, but you seem to be overlooking the fact that <code>new int</code> <em>also</em> calls all of the destructors.  They do the same thing here.</p>

<blockquote>
  <p>you can't resize a vector with default values like this more than once other than initially through the constructor</p>
</blockquote>

<p>There's <code>vector::resize</code> which resizes the array and default constructs any new ones.  If you want to ""reset"" existing ones, simply use <code>std::fill</code>.</p>

<p>The purpose of <code>vector::reserve</code> is to make <code>insert</code> and <code>push_back</code> not do unnecessary reallocations.  Which is a neat trick that raw arrays can't easily duplicate.  This is <em>extra</em> functionality, not <em>missing</em> functionality.</p>
",0
29953105,29952941,8,"<p>You should not mix up <code>resize</code> and <code>reserve</code></p>

<ul>
<li><code>reserve</code> allocates space (if needed) but doesn't initialize it, that way when you insert new elements only the construction is called and no realocation is done (until you used all the reserved space)</li>
<li><code>resize</code> allocates space (if needed) and initialize it by calling the constructor.</li>
</ul>

<p>Therefore when you <code>reserve</code> space, the new values are not accessible until they have been initialized/constructed by doing an operation like <code>push_back</code> or <code>resize</code></p>
",0
29953303,29952941,3,"<p>C++ is an abstraction, and in that abstraction those elements aren't ""null"" or ""empty"": they simply do not exist. Only space for them exists.</p>

<p>Now, in the case of <code>int</code> on many practical implementations, if you look at the memory then you can't really tell the difference. You <em>could</em> access that memory. But then you're violating the contract of <code>vector</code>, and this is going to hit you as soon as you perform mutating operations on the container: it's going to take your memory away from you and it's not going to carry your ""data"" along with it.</p>

<p>You don't gain anything by refusing to properly construct actual elements.</p>
",1
21045216,21044947,0,"<p>Your immediate problem is these lines.</p>

<pre><code>void *vp = static_cast&lt;void*&gt;(new std::string(input));
temp-&gt;data = &amp;vp;
</code></pre>

<p>You are storing the address of a local variable somewhere and use it later.</p>

<p>But this code has several other serious problems.</p>

<p>e.g </p>

<pre><code>cout &lt;&lt; ""\n\tSelect a value to enter: "";
cin &gt;&gt; val;
</code></pre>

<p>Please refer some good books on C++ and try to avoid pointers as much as possible. Use modern smart pointers, if at all that is necessary.</p>
",2
21323919,21323901,4,"<p>This is how they work and this is for a performance reason. Iterators are modeled after pointers, pointer don't check for boundaries on increment.</p>

<p>You will get undefined behavior though if you increment past <code>end()</code>.</p>
",8
21324006,21323901,0,"<p>yep. </p>

<pre><code>    while(++itr!=container.end()) 
    {
       do something here
    }
if itr==end() ,++itr can be anything!
so,you must write :
    if(it != xxx.end())
    {
        while(++it != xxx.end())
        {
             do sth
        }
    }
</code></pre>
",0
24126311,24126205,3,"<p>With standard C++? Yes, if you write a custom element iterator.  Then, your code is easily simplified to:</p>

<pre><code>auto element = find_if(col.begin(), col.end(), predicate);
</code></pre>

<p><hr>
It's not possible to do something closer to what you had in mind with the standard library, but it is with Boost, which is an incredible C++ library that you really ought to have.  Boost has a counting iterator: <a href=""http://www.boost.org/doc/libs/1_55_0/libs/iterator/doc/counting_iterator.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_55_0/libs/iterator/doc/counting_iterator.html</a></p>

<blockquote>
  <p>How would you fill up a vector with the numbers zero through one hundred using std::copy()? The only iterator operation missing from builtin integer types is an operator*() that returns the current value of the integer. The counting iterator adaptor adds this crucial piece of functionality to whatever type it wraps. One can use the counting iterator adaptor not only with integer types, but with any incrementable type.</p>
</blockquote>

<pre><code>#include &lt;boost\counting_iterator.hpp&gt; //or something, not sure of exact header

int main() {
    boost::counting_iterator&lt;int&gt; first(0);
    boost::counting_iterator&lt;int&gt; last(col.Size());
    auto element = find_if(first, last, [&amp;col](int i) {return predicate(col.GetElement(i);});
}
</code></pre>

<p>Additionally, boost also has ranges.  They don't really help you much in this <em>exact</em> situation, but it's related, so I'll mention it:</p>

<pre><code>#include &lt;boost\range\irange.hpp&gt;

int main() {
    for (int index: boost::range::irange&lt;int&gt;(0, col.Size()) ) 
    {
        std::cout &lt;&lt; element; //counts from 0 to col.Size()
    }
}
</code></pre>
",3
34256060,34255368,4,"<p>What <code>std::terminate</code> does can be approximately emulated with:</p>

<pre><code>std::set_terminate([](){
  puts(""exception thrown""); 
  //^skip the demangling of the typeid that's normaly done
  try { throw; } 
    catch(const std::exception&amp; e){ puts(e.what()); }
    catch(...){}
  //^rethrow and catch
});
</code></pre>

<hr>

<p>Thanks to <a href=""https://stackoverflow.com/users/3410396/revolver-ocelot"">revolver-ocelot</a> for pointing me in the right direction.</p>
",7
34255514,34255368,5,"<p>Most likely because it simply tries to <code>dynamic_cast</code> it to a <code>std::exception</code>, and invokes the virtual <code>what()</code> method, if the dynamic cast succeeds.</p>
",2
23555210,23555155,1,"<p>As with many things in C++ it's definitely possible to do in many ways.
Sometimes it just isn't a good idea though.</p>

<p>This is what the switch statement would look like:</p>

<pre><code>switch(y)
{
    case 100:
        return ""Perfect Score!"";
    break;
    case 99:
    case 98:
    case 97:
    case 96:
    case 95:
    case 94:
    case 93:
    case 92:
    case 91:
        return ""A"";
    break;
    case 90:
    case 89:
    case 88:
    case 87:
    case 86:
    case 85:
    case 84:
    case 83:
    case 82:
    case 81:
        return ""B"";
    break;
    case 80:
    case 79:
    case 78:
    case 77:
    case 76:
    case 75:
    case 74:
    case 73:
    case 72:
    case 71:
        return ""C"";
    break;
    case 70:
    case 69:
    case 68:
    case 67:
    case 66:
    case 65:
    case 64:
    case 63:
    case 62:
    case 61:
        return ""C"";
    break;
    default:
        return ""F"";
    break;

}
</code></pre>

<p>It would also restrict you to ONLY using integers since switch statements only work with them</p>
",2
23555572,23555155,3,"<pre><code>switch ((y - 1) / 10)
{
    case 9:  return y == 100 ? &quot;Perfect score!&quot; : &quot;A&quot;;
    case 8:  return &quot;B&quot;;
    case 7:  return &quot;C&quot;;
    case 6:  return &quot;D&quot;;
    default: return &quot;F&quot;;
}
</code></pre>
<p>It'd be less ugly if the comparisons were <code>&gt;=</code> - you could just:</p>
<pre><code>switch (y / 10)
{
  case 10: return &quot;Perfect score!&quot;;
  case 9:  return &quot;A&quot;;
  case 8:  return &quot;B&quot;;
  ...etc...
</code></pre>
<p>Are you sure they're not meant to be like that?  90 being an 'A' was more common in my schools than having to hit 91....</p>
<p>Update: looking at your link (there's an earlier step for 100 = &quot;Perfect score!&quot; - fine by me if you want that hanging around for the next step too)</p>
<blockquote>
<p>¡ï¡ï Modify the program so that it will notify the user of their letter grade</p>
<p>0-59 F 60-69 D 70-79 C 80-89 B 90-100 A</p>
</blockquote>
<p>So y / 10 is indeed appropriate....</p>
",1
31542187,31529789,1,"<p>I'm not sure I fully understand your use case but it is an interesting question nonetheless.</p>

<p>Tony D's suggestion to use a <code>std::vector</code> seemed like a good one. I've put the inserted value at the end and then swapped with a random element:</p>

<pre><code>template&lt;typename T&gt;
class RandomList {
  std::vector&lt;T&gt; list;
  RandomIndex    randomIndex;
public:
  using iterator = typename std::vector&lt;T&gt;::const_iterator;
  iterator begin() { return list.begin(); }
  iterator end() { return list.end(); }

  void insert(const T&amp; t) {
    list.push_back(t);

    auto i = randomIndex(list.size());

    using std::swap;
    swap(list[i], list.back());
  }
};
</code></pre>

<p>Where <code>RandomIndex</code> is a (non-templated) helper functor to get a random index:</p>

<pre><code>class RandomIndex {
  std::mt19937 eng;
public:
  RandomIndex() : eng(std::random_device{}()) {}

  size_t operator()(size_t size) {
    auto dist = std::uniform_int_distribution&lt;size_t&gt;{0, size - 1};
    return dist(eng);    
  }
};
</code></pre>

<p>I'm not sure about the quality of the randomness but it should be enough to ensure a client can't make any assumptions about the order of the elements.</p>
",1
31544789,31529789,0,"<p>I'm not sure if I understand all aspects of your problem. I think what qualifies as a good solution largely depends on the application and what the type <code>T</code> is going to be in practice. In any case, I suggest that you alter the interface of <code>RandomList</code> (see below).</p>

<p>First, your idea to use <code>std::list</code> internally and randomly insert at front or back seems to be a possible solution.</p>

<p>I do not think that it is a good idea to use <code>std::vector</code> if you aim for a broad range of applications. The reason is that <code>std::vector</code> implementations usually do a lot of extra stuff internally that may harm the performance/memory requirements of your container type. Usually <code>std::vector</code> uses a memory buffer that is larger than the actual size of the vector to avoid allocations on subsequent calls of insertion operations like <code>push_back</code>. Therefore, the performance of insertions may vary on subsequent calls (suddenly the vector buffer has to be increased again...), and your container may use much more memory than is really necessary. Again: this might not be a problem, it depends on your application and what <code>T</code> actually is. But as a user of your <code>RandomList</code> interface, I would be bothered to hear that it uses <code>std::vector</code> internally...</p>

<p>So if you are just asking for ""another idea"" and also want to allow for multiple insertions of the same value into the container - here is one: in essence, make <code>RandomList</code> into a <code>std::map</code> wrapper. The randomization should be implemented by properly employing the map key. To iterate the container you simply use the iterator of <code>std::map</code>. This actually gives you references to (key,value) pairs. You could use the <code>std::map</code> key to implement additional features that might be interesting. First of all, you can hide the key type - and therefore hide details of your implementation - by introducing a typedef <code>RandomList::handle</code>. I recommend that the method <code>insert</code> actually returns a <code>RandomList::handle</code>. In this way, you allow users to directly access specific container values by adding a method <code>access</code> to your interface. <code>access</code> takes <code>RandomList::handle</code> as argument and returns a reference to the corresponding map value. If you alter the interface in this way, it is consistent that your <code>RandomList</code> iterator (which is just the map iterator) refers to pairs of <code>RandomList::handle</code> and <code>T</code>. Whether this is useful or not largely depends on what <code>T</code> is going to be.</p>

<p><code>erase</code> should take <code>RandomList::handle</code> as argument. Again: if multiple insertions are not welcome, the idea to base your implementation on <code>std::map</code> is problematic, or at least should be approached in a different manner.</p>

<p>This approach allows for a neat control of the ""randomization implementation"". For example, if you use <code>std::list</code> with random insertions at front or back, the implementation of the randomization is very closely tied to your internal storage/container implementation. An implementation on the basis of <code>std::map</code> could keep the details of the randomization more seperate from the rest of the implementation, as the randomization is fully controlled in terms of the map key selection. For example, if you use an <code>int</code> as key, you could hold a counter internally which is incremented on subsequent insertions. The current value of the counter is used as key for the next map insertion. As this would lead to a completely unbalanced tree structure, <code>RandomList</code> would behave like an ordinary <code>std::list</code> on iterations. I would suggest to choose new key values in such a manner that the tree is perfectly balanced. In this way, the direct access feature is implemented most efficiently (cause search operations are fast), and a straightforward iteration of the <code>RandomList</code>/<code>std::map</code> via <code>begin()</code>/<code>end()</code> should lead to a sufficiently ""random"" result.</p>

<p>Finally, regarding the interface: I suggest that you use perfect forwarding for the <code>insert</code> operation instead of a direct copy. In this way, you avoid unneccessary copy operations when inserting elements into <code>std::map</code> (same story for <code>std::list</code> of course), and you additionally allow for move operations. If you do not want to use perfect forwarding, at least change <code>T</code> to <code>const T&amp;</code>, as another copy operation is required to insert the object into the <code>std::list</code>/<code>std::map</code> container.</p>
",1
30171650,30171378,1,"<p>For automatic condensing, check out creduce for C and C++ <a href=""http://embed.cs.utah.edu/creduce/"" rel=""nofollow"">here</a> </p>

<p>I'm not sure how smart it is but having a good design in your code, managing class explosion, etc. helps far more since I doubt any automatic whitespace trimmer would be as effective as rethinking and refactoring out poorly written code.</p>
",0
22432143,22432111,0,"<p>You want something like:</p>

<pre><code>test.a = 4;
test.b = 2;
test.c = 2;
</code></pre>
",3
22432394,22432111,3,"<p>CTRL+C then CTRL+V afterwards seems to work for me</p>
",0
21778212,21777644,0,"<p><code>div</code> is <code>NTag</code>, i.e. <code>NTagBase&lt;NTag&gt;</code>. <code>button</code> is <code>NTagInput</code>, i.e. <code>NTagBase&lt;NTagInput&gt;</code>, while <code>div</code>'s <code>append()</code> expects a <code>NTagBase&lt;NTag&gt;</code> which is unrelated. You should change <code>append</code> to something like</p>

<pre><code>template &lt;typename D&gt;
NTagBase* append(NTagBase&lt;D&gt; item) { ... }
</code></pre>

<p>However, you still cannot store items of different types in a single vector. Better make a non-template e.g. <code>Base</code> of <code>NTagBase</code> and let your vector contain pointers (or <code>std::unique_ptr</code>) to <code>Base</code>.</p>
",2
30131209,30131163,2,"<p>I would wrap this in an <code>if(offset % 10 &lt;= 5) { ... } else { ... }</code> and use your existing ideas.</p>

<p>Regardless you're going to want to work <code>% 10</code> since that's how long your cycle is.</p>
",0
30131244,30131163,2,"<p><strong>Hint</strong> These sequences are very closely related:</p>

<pre><code>0 1 2 3 4 5 4 3 2 1 0 1 2 3 4 5 4 ...
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 ...
</code></pre>
",0
30131378,30131163,2,"<pre><code>#include &lt;iostream&gt;

int main()
{
  int i = 0;
  bool plus = true;
  while(true) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
    if (plus) i++; else i--;
    if (i == 5 || i == 0) plus = !plus;
  }
}
</code></pre>
",1
30131389,30131163,2,"<p>Is there a requirement to generate the numbers in a single statement with variables and operators?</p>

<p>If not, then use an bool variable which switches its value (true means increasing, false means decreasing) from true to false and vice versa.</p>

<p>i.e.</p>

<pre><code>int start = 0 ;
bool which_way = true ;
int loop_times = 100 ;
while(--loop_times) {
    std::cout &lt;&lt; start ;
    start += which_way ? 1 : -1 ;
    if(start % 5 == 0)
        which_way = !which_way ;
}
</code></pre>
",0
30131780,30131163,1,"<p>I'd probably do something like this:</p>

<pre><code>// If you want in the range -val to val
//#define PONG(val, i) (abs(val%(i*4)-i*2) - i)
// If you want the range 0 to val
#define PONG(val, i) (abs(val%(i*2)-i))

int main() {
    for(int i = 0; i &lt; 100; i++) {
        cout &lt;&lt; PONG(i, 5) &lt;&lt; endl;
    }
}
</code></pre>

<p>Prints:</p>

<pre><code>5 4 3 2 1 0 1 2 3 4 5 4 3 2 1 0 1 2 ...
</code></pre>
",11
30131297,30131163,1,"<p>Here is a crazy way of outputting the number pong (with set limit)</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    bool bFlip = false; //Decides if number will increase or decrease
    int nLimit = 5; //How far up the number will count.

    //Start at 0, keep going as long as number never reaches past the limit
    //And increase/decrease depending on bFlip
    for(int nNum = 0; nNum  &lt;= nLimit; (bFlip ? nNum++ : nNum--))
    {
        printf(""%d "", nNum);

        //When number reaches either end, do a barrel roll!
        if (nNum  % nLimit == 0)
        {
            bFlip = !bFlip;
        }
    }

    return 0;
}
</code></pre>

<p>Be warned that this loop will go on forever so if you are going to go with this approach then you will need to set a limit on how many numbers you want to display.</p>
",0
30131663,30131163,1,"<p>Yet another crack at generating the sequence you're after: </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;iterator&gt;

int main() {
    std::list&lt;int&gt; nums = {{0, 1, 2, 3, 4, 5}};
    auto begin = nums.begin();
    auto iterator = nums.begin();
    auto end = nums.end();
    auto loop_times = 100;

    while (--loop_times) {
      while (iterator != end) {
        std::cout &lt;&lt; *iterator++;
      }
      iterator--;
      while (iterator != begin) {
        std::cout&lt;&lt; *--iterator;
      }
      iterator++;
    }
}
</code></pre>
",0
30132196,30131163,1,"<p>Thanks for the tips. I got it working with a single statement.</p>

<pre><code>int count = 0;
int num = 0;
int out = 0;

while (count++ &lt; 100) {

    cout &lt;&lt; abs( (num%10) - 5 ) &lt;&lt; endl;
    num++;

}

// Output: 5 4 3 2 1 0 1 2 3 4 5 4 etc
</code></pre>
",1
22505390,22505333,2,"<p>Because otherwise <code>IsEqual</code> has multiple definitions, one for each time you include it.</p>
",0
22505650,22505333,3,"<p>The same function symbol <code>IsEqual</code> will be defined multiple times, if you include the header file in multiple source files.</p>

<p>Traditionally and in your particular case, it is OK when you make the function <code>inline</code> because the function is not actually defined, and the function body is substituted on each call site. </p>

<p>Alternatively, you can define the function body in a classA.cpp, and declare the <code>classA.h</code></p>

<pre><code>#ifndef __CLASS_HEADER_
#define __CLASS_HEADER_
bool IsEqual(const float a, const float b);
#endif
</code></pre>

<p>Still another possibility is to declare <code>IsEqual</code> as a static member of some class in <code>classA.h</code>.</p>
",2
22505867,22505333,3,"<p>When this function definition is found in multiple translation units (which is usually the case with headers, because you generally include headers in multiple translation units, otherwise what's the point of them?) you get multiple definition errors from the linker.</p>

<p>Only <em>one</em> definition per function is allowed.</p>

<p>But marking a function <code>inline</code> is a special case that allows you to have this definition in multiple translation units, as long as the definitions are identical. The language <em>had</em> to provide this, because inlining functions is most effective when the definitions are immediately available (i.e. in the same translation unit, i.e. probably in a header); that <code>inline</code> doesn't really inherently cause actual inlining in this modern age of super-intelligent optimisers doesn't change that fact of the language.</p>
",2
34244675,34244436,1,"<p>Something like that:</p>

<pre><code>struct complex_comparison
{
    bool operator()(const MyStruct&amp; lhs, const MyStruct&amp; rhs)
    {
        return lhs.B1 &amp;&amp; lhs.B2 != rhs.B1 &amp;&amp; rhs.B2 ? lhs.B1 &amp;&amp; lhs.B2 &gt; rhs.B1 &amp;&amp; rhs.B2 :
                                   lhs.B1 != rhs.B1 ? lhs.B1 &gt; rhs.B1 :
                                   lhs.N1 &lt; rhs.N1;
    }
};
</code></pre>

<p>Example: <a href=""http://coliru.stacked-crooked.com/a/b4888ac34d2ca6bb"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/b4888ac34d2ca6bb</a></p>
",0
24603891,24603756,1,"<p>Inside <code>class B_interface</code> have:</p>

<pre><code>void i_am_a()
{
     // throws if the object does not actually have A as a base
     dynamic_cast&lt;A &amp;&gt;(*this).i_am_a();
}
</code></pre>
",0
24618012,24603756,0,"<p>OK, I was wrong, again :(.  So here is the answer code can be like this:</p>

<pre><code>class A_Interface {
 public:
    virtual void i_am_a() = 0;
};

class A : virtual public A_Interface {
 public:
    void i_am_a() {printf(""This is A\n"");}
};

class B_Interface : virtual public A_Interface {
 public:
    virtual void i_am_b() = 0;
    // would like to run i_am_a()
};

class B : public A, public B_interface {
 public:
    void i_am_b() {printf(""This is B\n"");}
};
</code></pre>

<p>GMock can be like this:</p>

<pre><code>class MockB : public B_Interface, public MockA {
    MOCK_METHOD0(foo, int(int));
}
</code></pre>

<p>This works for me in real application, but seems a little messy.</p>
",0
26199188,26198970,0,"<p>Solved</p>

<pre><code>class Event
{
    list&lt;function&lt;void()&gt;&gt; functions;
public:
    Event()
    {
    } //Event

    template&lt;typename T, typename... Args&gt;
    void reg(T&amp; func, Args... args)
    {
        functions.push_back(bind(func, args...));
    } //reg

    void execute()
    {
        for (auto&amp; func : functions)
        {
            func();
        } //for
    } //execute
};
</code></pre>

<p>=)</p>

<pre><code>Event event;

event.reg(test, 2, 2.5);
event.reg(*[](int n, const char* foo){ cout &lt;&lt; n &lt;&lt; "" "" &lt;&lt; foo &lt;&lt; endl; }, 5, ""rawr"");
event.execute();
</code></pre>
",1
21024343,21024248,2,"<p>There should be a reason you want to put them in one class.
If it's just for grouping, <strong>namespace</strong> better suits for this role.</p>

<pre><code>file1.h
   namespace Operation
   {
      void Fun1();
      void Fun2();
    };
file1.cpp
   namespace Operation
   {
      void Fun1(){};
      void Fun2(){};
   };
</code></pre>

<p>P.S. If for some reason you would still prefer to use class, make functions static at least, so you wouldn't need to create an instance of this class.</p>

<pre><code>file1.h
   class Operation
   {  
   public:    
      static void Fun1();
      static void Fun2();
    };
file1.cpp
    void Operation::Fun1() {};
    void Operation::Fun2() {};
</code></pre>
",0
21024383,21024248,2,"<p>You should use a dedicated namespace</p>

<p>file1.h:</p>

<pre><code>namespace MyDedicatedNameSpace
{
   void Fun1();
   void Fun2();
}
</code></pre>

<p>file1.cpp:</p>

<pre><code>void MyDedicatedNameSpace::Fun1() {}
void MyDedicatedNameSpace::Fun2() {}
</code></pre>

<p>Or if you want to use a class, you should set these functions as static:</p>

<p>file1.h:</p>

<pre><code>   class Operation
   {
public:
      static void Fun1();
      static void Fun2();
    };
</code></pre>

<p>file1.cpp:</p>

<pre><code>void Operation::Fun1() {};
void Operation::Fun2() {};
</code></pre>
",0
21024387,21024248,2,"<p>You don't ""have to"" put them in a class, you can go for both implementations. It's mostly a design preference. Java coders are used to putting those functions as static functions of a utility class, but in C++ you don't have to, although some people do.</p>

<p>If your concern is just encapsulation of those functions in a specific context, you might also consider putting them in <a href=""http://www.cplusplus.com/doc/tutorial/namespaces/"" rel=""nofollow"">namespaces</a>.</p>
",0
21025006,21024248,1,"<p>Since you asked specifically about C++, the most correct answer would be to namespace them:</p>

<p>file1.h:</p>

<pre><code>namespace MyNamespace
{
    void Fun1();
    void Fun2();
}
</code></pre>

<p>file1.cpp:</p>

<pre><code>namespace MyNamespace
{
    void Fun1() {}
    void Fun2() {}
}
</code></pre>

<p>Then to use them you would simply call <code>MyNamespace::Fun1()</code> etc.</p>

<p>As I started out saying, this is most correct for C++.</p>

<p>If you were writing this for C, or mixed C/C++ it should be noted that C does not support namespaces. So in that case making them static functions of a class would be a better organizational route.</p>

<p>file1.h</p>

<pre><code>class MyClass
{
public:
    static void Fun1();
    static void Fun2();
};
</code></pre>

<p>file1.c</p>

<pre><code>void MyClass::Fun1() { }
void MyClass::Fun2() { }
</code></pre>

<p>NOTE: if you are doing mixed programming you should consider making it easier to <a href=""http://www.parashift.com/c++-faq/include-c-hdrs-personal.html"" rel=""nofollow"">include</a>, but that's beyond the scope of this question. </p>
",0
22878712,22878399,1,"<blockquote>
  <p>Is it good to declare this into A.h and B.h at the same time since it can be considered as belong to both A and B?</p>
</blockquote>

<p>It is possible to declare it like that since it is just the declaration, and not definition. Other than that, it is probably just personal taste whether to do it so, or put it into a common header, and so on.</p>
",0
33020051,33019827,3,"<p>Just a wild guess based on the symptoms only.</p>

<p>A c++ string is a much more complex object than is a mere C <code>char *</code>. In this particular use case, it has a true length and can contain NULL characters, whereas <em>by convention</em> a C string (char *) is ended with a NULL. That means that every C string can be converted to a C++ std::string, but the opposite is only true if the std::string does not contain any NULL.</p>

<p>If you need to process the std::string as a char array, you need to use <code>Image_Content.data()</code> or <code>Image_Content.c_str()</code> (*) and use first <code>Image_Content.size()</code> characters from it. That just means that a <code>printf</code> on it will be truncated at first NULL, even if other characters exist after it.</p>

<p>(*) as noticed by @atkins both methods are synonyms for C++11. For C++98, both gave access to the full buffer, by only <code>c_str</code> was guaranteed to be null terminated.</p>
",6
27170462,27170368,3,"<p>The address you pass to <code>_mm_load_pd</code> must be 16 byte aligned. You'll need to take steps to ensure that is so.</p>
",0
27170504,27170368,2,"<p><code>a</code> must be 16-bit aligned; depending from the compiler, you have to mark it as <code>__declspec(align(16))</code> (VC++) or <code>__attribute__((aligned(16)))</code> (gcc). </p>
",0
21169635,21169419,3,"<p>The simplest answer:</p>

<pre><code>bool
isNullOrWhiteSpace( std::string const&amp; str )
{
    return std::find_if(
            str.begin(),
            str.end(),
            []( unsigned char ch ) { return !isspace( ch ); } )
        == str.end();
}
</code></pre>

<p>But it's probably not very useful; it depends on the global
locale, and won't handle some of the most frequent encodings
(like UTF-8).</p>
",4
21169505,21169419,0,"<p>I don't believe there is a standard one but it's fairly easy to write </p>

<pre><code>bool isNullOrWhiteSpace(const char* c) {
   if (!c) { 
     return true;
   }
   while (*c) {
     if (!isspace(static_cast&lt;unsigned char&gt;(*c))) {
       return false;
     }
     c++;
   }
   return true;
}
</code></pre>
",11
21569132,21568867,0,"<p>if you have an instance of class A, say x</p>

<pre><code>A x;

//Equal operation

x = x;
</code></pre>

<p>In this case you just want to assign the same object to itself again, So you don't need to do all the copying for the attributes of the object, to avoid these unwanted assignment operations, there is always used to be an if condition at the very start to check whether you are assigning the same object to itself, there you just need to check whether the addresses are same.</p>

<pre><code>   `(this == &amp;instance)`
</code></pre>

<p>here <code>this</code> is pointing to x now (i.e holding the address of the object instance x) and when you do the assignment operation (<code>x=x</code>), instance is the x object and &amp;instance is address of the x object and <code>this</code> also hold the address of the x, so the if condition evaluates to true and what you want to do is just assign the same address again to &amp;x (no need of deep copying of the attributes of the object)</p>
",0
21570083,21568867,1,"<p>You are right, 'this' is a pointer. And the pointer is the address! So pointer and address is the same and I will use these terms in the same meaning below. 
I guess you are a bit confused with &amp; and * as they mean different things when applied to the type and to the variable.</p>

<pre><code>ClassA &amp; refVar; //this way you declare a reference
ClassA* pVar;  //this way you declare a pointer
refvar; //this is a reference
pVar; // this is a pointer

//To get pointer from the reference you need to get an address.
&amp;refVar; //this is a pointer (an address)

// To get a reference from pointer you need to derefecence it
*pVar; // this is a reference!
</code></pre>

<p>So now it should be clear why 'instance' is a reference and 'this' is a pointer (address) in your example. To verify if it is the same object we need to get address of the reference 'instance' and compare it to the pointer 'this'. That is why the correct comparison is</p>

<pre><code>if(this == &amp;instance) {}
</code></pre>
",0
21570803,21568867,1,"<p>First you have to know clearly what a pointer is. A pointer contains address of the data type being pointed.</p>

<p>In this case, the ""this"" pointer points to the object instantiated from ClassA, which means ""this"" equals to the address of the object.Having a pointer, you use an asterisk(*) in front of a pointer to access the object being pointed to.</p>

<p>Thus, ""*this"" IS the current instance, not its address.</p>

<p>(this == &amp;instance) is a comparison of equalness between a pointer(which is the address of current instance) and address of ""instance"".</p>

<p>This is to check if the parameter passed(by reference) into the function is the current instance itself. This extra check can avoid some unwanted situation/exception.</p>

<p>Instance is not the same thing as instance address.</p>

<pre><code>ClassA myObject; //myObject is an instance
ClassA * ptr;    //ptr is a pointer that only points to objects of ClassA 
ptr = &amp;myObject; //&amp;myObject is instance address, assign address of myObject to ptr
                 //in other words, make ptr point to myObject
(*ptr).someFunction(); //use asterisk to access object members
</code></pre>
",0
21569030,21568867,1,"<p>The test <code>this == &amp;instance</code> tests for <em>self-assignment</em>, i.e. the case where the operand is the object itself:</p>

<pre><code>Foo x;
x = x;   // or: x.operator=(x)
</code></pre>

<p>The ""problem"" is that C++ has very poor aliasing control, and you can't know, or restrict, whether any two pointers or references denote the same object. So you have to test.</p>

<p>For something simple ans integers, self assignment wouldn't be a huge deal, but imagine a basic, naive ""smart pointer"" (it wouldn't be very smart, though):</p>

<pre><code> struct TPtr
 {
     T * ptr;
     TPtr(T * p) : ptr(p) {}
     TPtr(TPtr const &amp; rhs)  : ptr(new T(*rhs.ptr)) {}
     ~TPtr() { delete ptr; }

     TPtr &amp; operator=(TPtr const &amp; rhs)
     {
         delete ptr;
         ptr = new T(*rhs.ptr);   // uh-oh
     }
 };
</code></pre>

<p>Can you spot the problem?</p>
",2
23062368,23061995,0,"<p>The traits NonCopyable and NonMovable are orthogonal to each other and to polymorphic use.<br>
So why shouldn't someone want to mix-and-match in any combination?</p>

<p>Anyway, the proper way to avoid the issue is declaring those classes destructor protected, and only inherit them private. Neil Kirk is right about that.</p>

<p>Also, since C++11, you can explicitly declare any function you want deleted, which is the preferred way.</p>
",0
23062062,23061995,2,"<p>No non copyable base won't require a virtual destructor. But yes the class that extends this non-copyable may required virtual destructor.</p>

<p>If you are using boost, you can inherit from <a href=""http://www.boost.org/doc/libs/1%5f41%5f0/boost/noncopyable.hpp"" rel=""nofollow"">noncopyable.hpp</a></p>
",2
23062083,23061995,1,"<p>With C++11, you can delete constructors and destructors, rendering many NonCopyable / NonMovable idioms obsolete:</p>

<pre><code>YourClass() = delete; /*deletion of default constructor*/
YourClass(const YourClass&amp;) = delete; /*deletion of copy constructor*/
~YourClass() = delete; /*deletion of the destructor of YourClass*/
</code></pre>

<p>etc. You'll get a compile time failure if any code requires these.</p>
",4
31888006,31884993,0,"<p>If you really must use <code>something</code> outside the try/catch block (and no, you really mustn't, but if you insist...) then it's a good idea to make it impossible to give yourself a segfault.</p>

<p>calling a method on a null unique_ptr is a sure way to disaster, plus the initialisation of the unique_ptr requires an un-necessary memory allocation.</p>

<p>Another way is to use boost::optional :</p>

<pre><code>#include &lt;iostream&gt;

#include &lt;boost/optional.hpp&gt;

using namespace std;

int main()
{
    class SomeClass { public: int a; void callSomeMethod() const {} };

    boost::optional&lt;SomeClass&gt; something{};

    try {
        something = SomeClass();

        // operation that might throw other_exception
    }
    catch (const std::exception&amp; e) {
        std::cout &lt;&lt; ""bad"" &lt;&lt; std::endl;
    }
    // ... lots of code I don't want to include in the try/catch-scope.
    if (something) {
        something.get().callSomeMethod();
    }
    return 0;
}
</code></pre>
",0
31885069,31884993,2,"<p>There is a specific reason why what you are doing <em>shouldn't</em> work.  If the code you wrote worked the way you wrote it, then you would be calling <code>callSomeMethod()</code> on a null object.  The right way to do it as Benjamin Lindley said, is to put that code in your try block.  That way the variable is in-scope but the method call will only happen if there was not a bad alloc that threw an exception.</p>
",4
31885181,31884993,2,"<p>For posterity, and in case you needed to do something else in your <code>try</code> block that would <em>not</em> result in an invalid pointer (because, as has been mentioned there is a reason what you're trying to do doesn't work). If you're trying to do something else and still want to execute your operations on <code>something</code> afterward, the following code will do what you want:</p>

<pre><code>#include &lt;iostream&gt;

#include &lt;memory&gt;
#include &lt;utility&gt;

using namespace std;

int main()
{
    class SomeClass { public: int a; void callSomeMethod() const {} };

    std::unique_ptr&lt;SomeClass&gt; something{};

    try {
        something = std::move(std::make_unique&lt;SomeClass&gt;());

        // operation that might throw other_exception
    }
    catch (const other_exception&amp; e) {
        std::cout &lt;&lt; ""bad"" &lt;&lt; std::endl;
    }
    // ... lots of code I don't want to include in the try/catch-scope.
    something-&gt;callSomeMethod();

    return 0;
}
</code></pre>
",5
31885815,31884993,1,"<p>As other answers have mentioned, your code should generally be within the <code>try/catch</code> block, since it doesn't have any meaning if the exception is caught.  I'm not sure what your reason is for not wanting to include the code in the <code>try/catch</code>, since you're implying <code>something.callSomeMethod()</code> depends on <code>lots of code</code>, and <code>lots of code</code> depends on <code>std::make_unique</code>.  If <code>lots of code</code> isn't dependent, you can delay <code>std::make_unique</code> until after <code>lots of code</code>.</p>

<p>I think it might be worth clarifying, the purpose of exceptions is to abort and handle an exceptional situation.  The exceptional situation is that execution of following code can be impacted.  So, any code that would be impacted, or transitively code that depends on it, should be included in the <code>try/catch</code> block.  This is the minimal scope, by definition, and it's the scope you should use.  Nothing more, nothing less.</p>

<p>Sometimes the code to handle an exception can be shared across functions that throw exceptions, but it's still generally best to narrow the scope and write the necessary specific handling code for each one.</p>

<p>It might be worth noting that almost nothing can be done for <code>std::bad_alloc</code>, so it's generally not an exception worth catching.  Also, you should generally catch exceptions by reference unless you have a reason to do otherwise.  So, your code should look something like this...</p>

<pre><code>try {

    auto something = std::make_unique&lt;SomeClass&gt;;    

    // ... lots of code I don't want to include in the try/catch-scope.

    something.callSomeMethod();
}

catch (std::exception&amp; e) {

    // you dun goofed...
}
</code></pre>
",4
26800444,26795079,0,"<p>Based on your description, the <code>if</code> should be something like this:</p>

<pre><code>if (line[n] == '""')
{
    if (n == i) {
        cout &lt;&lt; ""hit end"" &lt;&lt; endl;
        line.insert(i, formEnd);
    } else {
        cout &lt;&lt; ""hit start"" &lt;&lt; endl;
        line.insert(i, formStart);
    }
}
</code></pre>
",1
26135355,26135067,2,"<p>You can pass only <strong>trivially-copyable</strong> PODs to <code>...</code>.</p>

<p>You could do</p>

<pre><code>struct wrapper { const char * it; };

wrapper it{""hello""};
printf(""%s"", it);
</code></pre>

<p>But the problem is, you cannot manage memory. Once you try to add constructor and destructor to alloc/free the memory, you will be faced with an error.</p>

<p><strong>error: cannot pass objects of non-trivially-copyable type ¡®class mystr¡¯ through ¡®...¡¯</strong></p>

<p>You can help yourself with:</p>

<pre><code>const char * c_str(const char * it) { return it; }
const char * c_str(const std::string&amp; it) { return it.c_str(); }

const char * cstr = ""hello"";
std::string cppstr = ""world"";

printf(""%s %s!"", c_str(cstr), c_str(cppstr));
</code></pre>

<p>Or use <a href=""http://www.boost.org/doc/libs/1_56_0/libs/format/index.html"" rel=""nofollow""><code>boost::format</code></a> (or similar for <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream"" rel=""nofollow""><code>ostream</code></a>). And you should use ostream/format for C++ (type-safe).</p>
",3
26135374,26135067,1,"<p>You said:</p>

<blockquote>
  <p>The problem is with this:</p>
  
  <p>sprintf(c, ""%s"", ms);</p>
  
  <p>The C ""arg_list"" functions will not use the
  char* cast.</p>
</blockquote>

<p>There is no cast here. <code>sprintf(..., ""%s"")</code> is not casting <code>ms</code> to anything, so it will never call your conversion operator. A cast would be: <code>sprintf(c, ""%s"", (const char *)ms)</code>. Unlike strcpy, va_list doesn't cause a coercion as there is no parameter type.</p>

<p>You can pass objects to va_list functions, but it you need to either explicitly cast the arguments to call the correct type conversion, or use .c_str()</p>

<p>If printf() could implicitly handle C++ objects per its format specifiers, it would certainly already be in the language, since it is probably one of the most desired library functions that didn't map over from C.</p>

<p>If you are set on using printf() and family, simply write:</p>

<pre><code>printf(""%s"", foo.c_str());
</code></pre>

<p>Or try something like this (as suggested by @firda in a comment):</p>

<pre><code>const char * c_str(const std:string &amp;s) { return s.c_str(); }
const char * c_str(const char * s) { return s; }
</code></pre>

<p>Then you consistently write:</p>

<pre><code>printf(""%s%s"", c_str(foo), c_str(bar));
</code></pre>
",5
26135482,26135067,1,"<p>Normal C++ variadic functions cannot work with object instances because the values must be bit-copiable (the called function will not know the types of the objects passed at compile time).</p>

<p>With C++11 you can however write a variadic template that takes care of doing the trick of using the call-site type knowledge to unpack the parameters:</p>

<pre><code>#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int mysprintf(char *buf, const char *fmt) {
    return sprintf(buf, ""%s"", fmt);
}

template&lt;typename T, typename... Args&gt;
int mysprintf(char *buf, const char *fmt, const T&amp; x, Args... args) {
    const char *sp = strchr(fmt, '%');
    if (sp) {
        while (fmt &lt; sp) *buf++ = *fmt++;
        std::string fmt1(fmt, fmt+2);
        int sz = sprintf(buf, fmt1.c_str(), x);
        return sz + mysprintf(buf+sz, fmt+2, args...);
    } else {
        fputs(""Invalid format string\n"", stderr);
        std::abort();
        return 0;
    }
}

template&lt;typename... Args&gt;
int mysprintf(char *buf, const char *fmt, const std::string&amp; x, Args... args) {
    const char *sp = strchr(fmt, '%');
    if (sp) {
        if (sp[1] != 's') {
            fputs(""Invalid format string (%s expected)\n"", stderr);
            std::abort();
        }
        while (fmt &lt; sp) *buf++ = *fmt++;
        std::string fmt1(fmt, fmt+2);
        int sz = sprintf(buf, fmt1.c_str(), x.c_str());
        return sz + mysprintf(buf+sz, fmt+2, args...);
    } else {
        fputs(""Invalid format string\n"", stderr);
        std::abort();
        return 0;
    }
}

int main() {
    char buf[200];
    std::string foo = ""foo"";
    const char *bar = ""bar"";
    int x = 42;

    mysprintf(buf, ""foo='%s', bar='%s', x=%i"", foo, bar, x);
    printf(""buf = \""%s\""\n"", buf);

    return 0;
}
</code></pre>

<p>NOTE: to keep things simple this code doesn't handle any formatting options or <code>%</code> escaping, but allows using <code>%s</code> for both naked <code>char *</code> and <code>std::string</code>.</p>

<p>NOTE2: I'm not saying this is a good idea... just that's possible</p>
",1
25495502,25495442,3,"<p>Quick research:
At least on some compilers <a href=""http://coliru.stacked-crooked.com/a/5e409d7079cfe4b3"" rel=""nofollow"">the value is reset to default in case of non-empty input string</a>, and <a href=""http://coliru.stacked-crooked.com/a/77023acff6fd4cbe"" rel=""nofollow"">unmodified in case of empty input string</a>, so there is really no guarantee on the <code>istream</code> behaviour.</p>
",0
25495834,25495442,1,"<p>In C++03 failed input was UB, due to definition in terms of scanf-family (and UB meant that you could not rely on the error reporting either, e.g. hex input with too many digits).</p>

<p>There was an apparent guarantee, but it was voided by the UB.</p>

<p>This was fixed in C++11, using e.g. strtoll.</p>
",0
23558947,23558888,-1,"<p><code>long long</code> is an integer type. So, your +0.5 is lost in truncation.</p>
",6
23558952,23558888,0,"<p>You could use a range for your return boolean, although it may lead to unprecise outputs depending on how stringent your requirements are:</p>

<pre><code>double threshold = 0.01;

return (squareRootN*squareRootN &gt; n-threshold) &amp;&amp; (squareRootN*squareRootN &lt; n+threshold);
</code></pre>
",2
23559019,23558888,1,"<p>You could use the result of the floating point square root as a hint only. Convert it to an integer. Check if the square is equal. If it is higher or lower, decrement or increment it, then recheck for the square, and continue until you have bound the parameter with:
c1*c1 &lt;= n &lt;= (c1+1)*(c1+1)</p>
",0
23559028,23558888,0,"<p>mmmm don't use float/double for your true/false outcome (you'll end up having approximation problems)
Much better the integer apporach:</p>

<pre><code>   boolean is_square(long long n)
   {
      long long a=n;
      while (a*a&gt;n)
      {
         a=div(a+div(n,a),2);
      }
      return a*a==n;
   }
</code></pre>

<p>div() is the integer division without remainder (you can use GCD() in some ways)</p>

<p>I know, I know... care must be taken for overflow issues</p>
",1
23559054,23558888,1,"<p>You might use std::sqrt as a guess and test with multiplication:</p>

<pre><code>#include &lt;cmath&gt;
#include &lt;limits&gt;
#include &lt;iostream&gt;

bool isPerfectSquare(long long n){
    double guess = sqrt(n);
    long long r = std::floor(guess);
    if(r*r == n) return true;
    else {
        r = std::ceil(guess);
        return r*r == n;
    }
}

int main() {
    const long long Limit = std::pow(10, std::numeric_limits&lt;long long&gt;::digits10 / 2);
    std::cout &lt;&lt; "" Limit: "" &lt;&lt; Limit &lt;&lt; '\n';
    for (long long i = 0; i &lt; Limit; ++i) {
        if( ! isPerfectSquare(i*i)) {
            std::cout &lt;&lt; ""Failure: "" &lt;&lt; i &lt;&lt; '\n';
            return 0;
        }
    }
    std::cout &lt;&lt; ""Success\n"";
}
</code></pre>
",0
23559355,23558888,2,"<p>You use <code>round</code>.</p>

<pre><code>bool isPerfectSquare(long long n){
    long long squareRootN=(long long)round((sqrt(n)));

    if(squareRootN*squareRootN == n) {
        return true; 
    }
     else {
        return false; 
     }
</code></pre>

<p><code>round</code> rounds the number to the nearest rounding. The function will be true only if n is a perfect square. </p>
",0
23560593,23558888,0,"<blockquote>
  <p>Sqrt(4) could return 1.9999</p>
</blockquote>

<p>No, 4 and 2 are exactly representable as binary floating point numbers. No precision problems there.</p>

<p>The problem is that <code>long long</code> has 64 bits of precision, but <code>double</code> has only 52, so all solutions that rely on calling <code>sqrt(double)</code> will start failing when you hit that limit. Here is a simple test program:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

bool isPerfectSquare(long long n)
{
    double root = sqrt(n);
    return floor(root) == root;
}

void check(long long x)
{
    if (!isPerfectSquare(x))
        std::cerr &lt;&lt; x &lt;&lt; "" should be perfect\n"", exit(1);
    if (isPerfectSquare(x-1))
        std::cerr &lt;&lt; x-1 &lt;&lt; "" should NOT be perfect\n"", exit(1);
    if (isPerfectSquare(x+1))
        std::cerr &lt;&lt; x+1 &lt;&lt; "" should NOT be perfect\n"", exit(1);
}

int main()
{
    for (long long i = 2; i &lt; 3037000499; ++i)
        check(i * i);
    std::cout &lt;&lt; ""all tests passed\n"";
}
</code></pre>

<p>And here is the output on my computer:</p>

<pre><code>4503599627370497 should NOT be perfect
</code></pre>

<p>Note that <code>log(4503599627370497)/log(2) = 52</code>. In case you don't care about numbers that large, you can use the simple solution that merely checks whether <code>sqrt</code> returns an integral result.</p>
",0
23559741,23558888,0,"<p>The code is fine!</p>

<p>I have taken the time to write a small test.
As the input range is limited, we can simply validate the function for every input.</p>

<p>Not that I did have to add an explicit cast to double for the sqrt function for it to compile. (using MS VC++ 10)</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;

bool isPerfectSquare(long long n){
    long long squareRootN=(long long)(sqrt((double)n)+0.5);

    return squareRootN*squareRootN == n;
}


int main()
{
    // for the input range,
    // generate a set with numbers that are known to be perfect squares.
    // all the rest are not.
    std::set&lt;long long&gt; perfectSquares;
    for(long long i = 1ll; i &lt;= 100000ll; ++i) {
        perfectSquares.insert(i*i);
    }
    std::cout &lt;&lt; ""Created lookup."" &lt;&lt; std::endl;

    // now test the function for all the numbers in the input range   
    int progress = -1;
    for(long long i = 1ll; i &lt;= 10000000000ll; ++i) {
        bool expected = (perfectSquares.count(i) == 1);
        bool actual = isPerfectSquare(i);

        if(expected != actual) {
            std::cout &lt;&lt; ""Failed for "" &lt;&lt; i &lt;&lt; std::endl;
        }

        int newprogress = i / 100000000ll;
        if(newprogress != progress) {
            progress = newprogress;
            std::cout &lt;&lt; ""Progress "" &lt;&lt; progress &lt;&lt; ""%"" &lt;&lt; std::endl;
        }
    }
    std::cout &lt;&lt; ""Test finished."" &lt;&lt; std::endl;
}
</code></pre>

<p>Results? Pass for all values!
The problem must be in the code that uses the function.
Maybe add input range validation to the function.</p>
",0
34274447,34274382,4,"<p>There is no difference between <code>allocateArray</code> and <code>allocateArrayVar</code>.
<code>doubleValue</code> returns a pointer to a local variable, which will be destroyed when the function returns (ie, it goes out of scope), and so the pointer becomes invalid. However, when you use the <code>new</code> operator, you are allocating memory on the heap, which ends up meaning that the memory stays valid until you call <code>delete</code> on it (which you really should be doing to avoid memory leaks).</p>
",0
34274467,34274382,4,"<p>There is no difference between the two functions. </p>

<p>However, the comment in your code is a little misleading:</p>

<blockquote>
  <p>I expected memory for <code>var</code> would be deallocated here</p>
</blockquote>

<p>The point of using <code>new</code> is so your memory isn't deallocated once it goes out of scope. While true that <code>var</code> is ""deallocated"", it is not the case that the data that is pointed at (i.e., <code>*var</code>) is deallocated.</p>

<p>The programmer, in this case <em>you</em>, needs to manually deallocate the memory that was allocated by use of <code>new</code>. This is how you can do that:</p>

<pre><code>void dellocateArray(int* arr) {
  delete[] arr;
}
</code></pre>

<p>The reason <code>allocateArrayVar</code> works but <code>doubleValue</code> does not comes from this distinction between who manages the memory:</p>

<ul>
<li><p>When something is allocated with <code>new</code> (or <code>malloc</code>, etc.), it is created on the <strong>heap</strong>, and is thus allocated until the programmer deallocates it with <code>delete</code> (or <code>free</code>, etc).</p></li>
<li><p>All other instantiations are done on the <strong>stack</strong> and will be deallocated once it goes out of scope. Because the memory can be reclaimed, there's no guarantee that that memory address will contain what you expect.</p></li>
</ul>
",3
34274482,34274382,3,"<p>Your confusion stems from your definition of ""local variable"".</p>

<p>When you write the following code:</p>

<pre><code>int* allocateArrayVar(int size)
{
    int* var = new int[size];
    return var;
}
</code></pre>

<p>Yes, you're returning a copy of a local variable <code>var</code>, but the value of <code>var</code> is the memory address to which the array was allocated. When memory is allocated with <code>new</code>, it is stored on the heap, which is not deallocated until you manually call <code>delete</code>.</p>

<p>So when the caller of <code>allocateArrayVar</code> receives a return value, it is still getting a valid memory address, even though <code>int* var</code> itself no longer exists.</p>

<p>Contrast this approach with</p>

<pre><code>int* doubleValue(int x)
{
    int value = x * 2;
    return &amp;value; // return nValue by address here
} // value destroyed here
</code></pre>

<p>Where <code>int value</code> is allocated on <strong>the stack</strong>. Stack memory does get deallocated after the function call completes, so the return value here is invalid (it's referring to a memory address on the stack, not the heap).</p>
",0
34274512,34274382,3,"<p>First of all, there is no difference between <code>allocateArray</code> and <code>allocateArrayVar</code> in case of the result. If you want to know if there are differences in program's way of working, try to compile the version with first and then with the second function without optimization and with option that produces assembly code. And compare them ;)</p>

<p>If you are using <code>new</code> operator, the OS is allocating memory on the so called heap - the place which does not belong to any of the functions.
There is only one way to deallocate such kind of memory: to use <code>delete</code> operator.</p>
",0
34274555,34274382,1,"<p>Regarding returning references, returning reference to local variables is a bad idea (won't work) because local variables go out of scope when the function terminates.</p>

<p>In such situations it is better to return objects (pointers included) as memory allocated using <code>new</code> is stored in heap store, which has its lifetime as long as it is manually deleted using <code>delete</code> operator.</p>

<p>Reference: C++ Primer. Simply love that book :)</p>
",0
25469621,25469388,1,"<p>As the comments pointed out... you should save some time and energy and try to use the <strong>Standard Template Library (STL)</strong>.</p>

<p>If you insist on fixing this code, I think you should try referencing objectlist after the delete to see if it's still there... maybe this assignment...</p>

<pre><code>objectList = tmpObjectList;
</code></pre>

<p>...is not tolerated. </p>

<p><strong>Instead...</strong> try to build a copy constructor <em>""public Object(Object copiedObject){}""</em>, make a new Object*[] of the 2X size, populate it, then get rid of the old and... without deleting objectList assign your new Object*[] to it...</p>

<p>The rest seems fine to me... hope this helps.</p>
",0
25469497,25469388,0,"<pre><code>delete [] objectList;
</code></pre>

<p>This only frees the array which <code>objectList</code> points to. It does not free any of the objects in that array.</p>
",1
21788683,21788408,0,"<p>Memory footprint of data structure is size on stack + size in free store. You can redefine operator new/delete to add allocated size accounting and then do simple arithmetics. You also might need to do it for malloc/free.</p>
",0
26243666,26243640,0,"<p>No, they're not automatically deleted.  Objects and POD allocated with automatic storage are.  Objects or POD allocated with <code>new</code> are not.</p>

<blockquote>
  <p>we are still left with the anonymous pointer pointing to garbage. Are anonymous pointers like this cleared when it goes out of scope?</p>
</blockquote>

<p>It's anonymous, so there's no defined behavior for what the value could contain.  Pointers are a C++ and C concept, so the intermediates used by the compiler aren't described by any standard.  But if you want to know what happens with your compiler, you can disassemble the object code.  It's likely that the value that represented the pointer may have been stored on the stack and will get reaped (the pointer itself, not the <code>int</code> pointed to) when <code>main</code> returns.</p>
",2
26243760,26243640,0,"<p>No. A pointer is not a shared pointer and is not automatically deleted by default in C++. </p>

<pre><code>void fn()
{
    YourClass LocalObject;
    ... 
} // LocalObject goes out of scope here and is destroyed automatically

void fn2()
{
    YourClass *PointedObject = new YourClass();
} // Object pointed to by the pointer is not destroyed. 
</code></pre>

<p>In reality <code>PointedObject</code> would need deleting at some point. You'd probably return the pointer or something and call <code>delete</code> when you're done with it.</p>
",0
26244096,26243640,2,"<p>I think I smell a misconception in your question. However, I might be wrong about that; if so disregard.</p>

<p>You ask this:</p>

<blockquote>
  <p>Even if we do end up using delete in foo to delete the data and set
  the pointer to nullptr, we are still left with the anonymous pointer
  pointing to garbage. Are anonymous pointers like this cleared when it
  goes out of scope?</p>
  
  <p>The situation is similar to using the shared_ptr's constructor form
  that also takes raw anonymous pointer from the caller to some data to
  construct a shared pointer where the pointer value is copied to the
  constructor. Are such anonymous pointers set to NULL when they go out
  of scope?</p>
</blockquote>

<p>From those questions, it seems like you might be under the impression that setting a pointer to null (""clearing"" it) is an essential part of freeing whatever it points to. In C++, this is not the case. To free the object <code>p</code> points to, you do <code>delete p;</code>, end of story. You <em>may</em> also say <code>p = nullptr;</code> afterwards if you want to ensure anyone who looks at <code>p</code> later realizes it's invalid, but whether you do or not, the object it pointed to before is gone.</p>

<p>So in this hypothetical code:</p>

<pre><code>int foo(int* p)
{
   //some content
   delete p;
}

int main()
{
  foo(new int); // anonymous pointer?
}
</code></pre>

<p>no memory is leaked, and everything is fine. The question of whether the temporary, anonymous pointer passed to <code>foo</code> is referencing garbage after <code>foo</code> returns is meaningless, since the temporary is effectively invisible at that point and does not further participate in anything the program does (raw pointers don't have destructors).</p>

<p>But in <em>this</em> hypothetical code:</p>

<pre><code>int foo(int* p)
{
   //some content, but no delete p
}

int main()
{
  foo(new int); // anonymous pointer?
}
</code></pre>

<p>Nothing will delete the anonymous <code>new int</code>, so you have a memory leak.</p>
",4
21325693,21201150,0,"<p>... actually the Inheritance &amp; typedef experiment works now.
What I wanted to see was if it is possible to write a class inherited from string and then use string in the code ( replacing the class name using typedef )
This is the version with inheritance &amp; typedef ( perfectly working ):</p>

<pre><code>// superString.cpp :  superString with inheritance &amp; typedef

#include ""stdafx.h""
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;Windows.h&gt;
using namespace std;

class superString : public string
{
public:
    string m_frase;
    superString(string frase){ m_frase=frase; }
    operator string() { return m_frase; }
    int length() {return static_cast&lt;int&gt;(m_frase.length());}
    string chr(int posizione)
    {
        if (posizione &lt; static_cast&lt;int&gt;(m_frase.length()))
        {
           string result(m_frase,posizione,1);
           return result;
        }
        else return ""xx"";
    }
    string read(){ return m_frase;}
    void replace_chr(string a, string b)
    {
        string *cArray=new string[static_cast&lt;int&gt;(m_frase.length())];
        string risultato="""";
        for (int j=0; j&lt;static_cast&lt;int&gt;(m_frase.length()); j++)
        {
           cArray[j]=this-&gt;chr(j);
           if (this-&gt;chr(j)==a)
                cArray[j]=b;
           risultato += cArray[j];
        }
        delete [] cArray;
        m_frase=risultato;  
    }
};


void main()
{
    typedef superString string;
    string prova=""yellow"";
    cout &lt;&lt; prova.read() &lt;&lt; endl;
    for (int I=0; I&lt;prova.length(); I++)
        cout &lt;&lt; prova.chr(I) &lt;&lt; endl;
    cout &lt;&lt; ""\n"" &lt;&lt; prova.length() &lt;&lt; endl;
    string successo=prova; // success ! the class automatically converts itself 
                          into string !
    cout &lt;&lt; successo &lt;&lt; ""***"" &lt;&lt; endl;

    prova.replace_chr(""y"",""b"");  
    string fine=prova; 
    cout &lt;&lt; fine &lt;&lt; ""***"" &lt;&lt; endl;
    cout &lt;&lt; prova.read() &lt;&lt; endl;

    system(""pause"");
}
</code></pre>

<p>The only problem left is that I write :</p>

<pre><code>string successo=prova;
cout &lt;&lt; successo &lt;&lt; ""***"" &lt;&lt; endl;
</code></pre>

<p>and this fails to work while the normal prova.read() works as in texbooks.
( I have some C++ books and that's why I attempt difficult exercises, I want to learn more :-)  )
In the normal class ( without inheritance ) the 2 lines above work perfectly.
In reality in textbooks I did not find something like string successo=prova to read a property of the class and prova.read() should be all that is needed but now I wonder why above fails and below works.
This is the normal class without Inheritance &amp; typedef, those 2 lines do the job and print m_frase ( why above they do not ?):</p>

<pre><code>// superString.cpp : superString without Inheritance and typedef
#include ""stdafx.h""
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;Windows.h&gt;
using namespace std;

class superString 
{ 
private:
    string m_frase;
public:
    superString(string frase){ m_frase=frase; }
    operator string() { return m_frase; }
    int length() {return static_cast&lt;int&gt;(m_frase.length());}
    string chr(int posizione)
    {
        if (posizione &lt; static_cast&lt;int&gt;(m_frase.length()))
        {
            string result(m_frase,posizione,1);
            return result;
        }
        else return ""xx"";
    }
    string read(){ return m_frase;}
    void replace_chr(string a, string b)
    {
        string *cArray=new string[static_cast&lt;int&gt;(m_frase.length())];
        string risultato="""";
        for (int j=0; j&lt;static_cast&lt;int&gt;(m_frase.length()); j++)
        {
            cArray[j]=this-&gt;chr(j);
            if (this-&gt;chr(j)==a)
                cArray[j]=b;
            risultato += cArray[j];
        }
        delete [] cArray;
        m_frase=risultato;  
    }
};



void main()
{
    superString prova=""yellow"";
    cout &lt;&lt; prova.read() &lt;&lt; endl;
    for (int I=0; I&lt;prova.length(); I++)
            cout &lt;&lt; prova.chr(I) &lt;&lt; endl;
    cout &lt;&lt; ""\n"" &lt;&lt; prova.length() &lt;&lt; endl;
    string successo=prova; // failure ! successo cannot be printed
    cout &lt;&lt; successo &lt;&lt; ""***"" &lt;&lt; endl;

    prova.replace_chr(""y"",""b"");  
    string fine=prova;
    cout &lt;&lt; fine &lt;&lt; ""***"" &lt;&lt; endl;  // failure ! fine cannot be printed !
    cout &lt;&lt; prova.read() &lt;&lt; endl; 

    system(""pause"");
}
</code></pre>

<p>I hope I have deleted/replaced all comments in italian. If you read something in Italian it is clear it is not for you to read. I apologize but I did not believe leaving those comments was a so big issue :-)
Can anyone give me a constructive comment about why in the latter version </p>

<pre><code>string successo=prova;
cout &lt;&lt; successo &lt;&lt; ""***"" &lt;&lt; endl;
</code></pre>

<p>prints the string and in the former it does not ? The same problem happens with the string fine, of course.</p>
",0
29467105,29464875,1,"<p>It's kind of unclear for your question.</p>

<p>You can use something like:</p>

<pre><code>Class_1 a; // a is an instance of Class_1
Class_1&amp; b = a; // b is a reference to an instance of Class_1 (a)
</code></pre>

<p>so that a and b are exactly the same object.</p>

<p>If you need arguments for constructor:</p>

<pre><code>Class_1 c(2, 3); // c is an instance of Class_1.
                 // this will initialize c with nRows = 2 and nCols = 3
Class_1&amp; d = c;  // d is a reference to an instance of Class_1 (c)
</code></pre>

<p>As for your sample code:</p>

<pre><code>Class_1&amp; class_1();
</code></pre>

<p>It means class_1 is a function which returns a reference to an instance of Class_1. So maybe you want to implement something like:</p>

<pre><code>Class_2 {
public:
    Class_1&amp; class_1() {
        return a; // return a reference to an instance of Class_1 (a)
    }
private:
    Class_1 a; // an instance of Class_1
}
</code></pre>

<p>I suggest you to post more complete code so that we can help.
Otherwise we are just guessing what's your problem.</p>

<p><strong>Edit</strong>
Remove the example of reference to a temporary because it's not permitted.</p>
",2
25680852,25680653,0,"<p>At the first place you just copied the pointer, at the second place you try to access the memory adress the pointer shows to.
Please make sure that the pointer itself is valid ( for instance ina debugger and take a look if the memory address which the infor points to is a valid null-terminated string ).
Maybe your input nsString is just empty? The get()-method can also return just 0, if nothing is in?</p>
",0
25681145,25680653,3,"<p>Your <code>info</code> pointer is being set to an address for a buffer that is literally only valid long enough to save the assignment. This:</p>

<pre><code>const char *info_first = NS_ConvertUTF16toUTF8(needUsbinfo).get();
</code></pre>

<p>constructs a temporary <code>NS_ConvertUTF16toUTF8</code> object with the given value, retrieves its conversion buffer address, assigns said-address to <code>info_first</code>, then the temporary object (and its buffer) are destroyed, leaving <code>info_first</code> with an indeterminate (and thus illegal to eval or dereference) address. </p>

<p><strong>Possible Solution</strong></p>

<p>Make a member variable <code>mInfo</code> of type <code>std::string</code> and pass the result of the <code>get()</code> directly to the constructor of <code>UsbRunnable2</code> as a third parameter. The temporary will live long enough to make a copy in the constructor, and thereby tout your own copy of <code>info</code> around. (Note: i have no idea what you're doing with the first and second, but this should get you close):</p>

<pre><code>bool UsbThreadImpl::RecvEnableUsbInfo(const nsString&amp; needUsbinfo)
{

    class UsbRunnable2 MOZ_FINAL : public nsRunnable
    {
    public:
        UsbRunnable2(UsbThreadImpl* UsbPointer,
                     const char* UsbInfo,
                     const char* Info)
            : mUsbPointer(UsbPointer)
            , mUsbInfo(UsbInfo)
            , mInfo(Info)
        {
        }

        NS_IMETHOD Run()
        {
            printf(""\n===In Runnable2 UsbInfo: %s\n"", mInfo.c_str());
            return NS_OK;
        }

    private:
        UsbThreadImpl* mUsbPointer;
        std::string mUsbInfo, mInfo;
    };

    nsCOMPtr&lt;nsIRunnable&gt; runnable =
        new UsbRunnable2(this, mUsbInfo, NS_ConvertUTF16toUTF8(needUsbinfo).get());

    return true;    
}
</code></pre>

<p>There other other ways to do this, but this was the first one that popped into my head. </p>

<p>Best of luck</p>
",2
28250845,28250809,1,"<p>The compiler looks for matches by applying permitted conversions to parameters in order to find a match (i.e. a function that can be called).   That is true for all functions, not just templates.</p>

<p>If T is a type that can be implicitly converted to a double, then it will be so the ""non template"" function can be called.</p>

<p>If T cannot be implicitly converted to double, then the compiler will report it cannot find a match in some way.</p>
",0
28250908,28250809,1,"<blockquote>
  <p>I am not sure why this can be allowed without any compilation errors; If my var1 is int, will it be wrong?</p>
</blockquote>

<p>Template classes and functions work slightly differently from non-templated ones: checking for validity is done in 2 passes - once at definition time, the other at instantiation (when the method is first called) time.</p>

<p>When processing the template function, it checks things like syntax, and type not dependent on the template arguments. If these succeed, it will not complain and store the definition of the template in it's state.</p>

<p>When you try to call (instantiate) the template with a particular set of arguments, it will go back to the definition stored and recheck thing that are dependent on the type of parameters passed in.</p>

<p>So, if I try to call your function with an int, double and a float like:</p>

<pre><code> test_calls.method(5.0); // Works as expected
 test_calls.method(5); // Works, because int can be converted to double implicitly.
 test_calls.method(""Hello""); // Doesn't work, because ""non-templated"" cannot be call with a char const* argument.
</code></pre>
",0
30177309,30177232,1,"<p>Some context require complete types. E.g: when you'd like to store object by value in a vector:</p>

<pre><code>std::vector&lt;Person&gt; persons; // Person must be complete
</code></pre>

<p>You can't use a reference here, and suppose you'd like to avoid having empty persons (= nullptr).</p>

<p>Please note, as far as I can tell, nowadays the pimpl idiom is avoided because of the added complexity, performance and storage penalty.</p>
",5
30186095,30186015,2,"<p>This is a <a href=""https://isocpp.org/wiki/faq/newbie#numeric-literal-suffixes"" rel=""nofollow"">cpp FAQ</a></p>

<blockquote>
  <p>You should use these suffixes when you need to force the compiler to treat the numeric literal as if it were the specified type</p>
</blockquote>

<p>There's also a good example:</p>

<p>If <code>x</code> is of type float, the expression <code>x + 5.7</code> is of type <code>double</code>: it first promotes the value of <code>x</code> to a <code>double</code>, then performs the arithmetic using double-precision instructions. If that is what you want, fine; but if you really wanted it to do the arithmetic using single-precision instructions, you can change that code to <code>x + 5.7f</code>. </p>

<p>There are also readability reasons</p>

<blockquote>
  <p>If you end up using unsigned variables, it is generally a good idea to force your numeric literals to also be unsigned. That makes it easier to see that the compiler will generate ¡°unsigned arithmetic¡± instructions.</p>
</blockquote>
",4
22119400,22119049,1,"<p>Using gcc explorer:</p>

<p>Case 1 (-O3):</p>

<pre><code>main:                                   # @main
    xorl    %eax, %eax
    ret

global_constant:
    .quad   reference temporary for global_constant

reference temporary for global_constant:
    .long   2048                    # 0x800
</code></pre>

<p>Case 2 (-O3):</p>

<pre><code>main:                                   # @main
    xorl    %eax, %eax
    ret
</code></pre>

<p>Using Mingw 4.8.1 g++ Windows 8 (it is the same result just looks more messy)..</p>

<p>Case 1 (-O3):</p>

<pre><code>    .file   ""TestConstantsAsm.cpp""
    .def    __main; .scl    2;  .type   32; .endef
    .section    .text.startup,""x""
    .p2align 4,,15
    .globl  main
    .def    main;   .scl    2;  .type   32; .endef
    .seh_proc   main
main:
    subq    $40, %rsp
    .seh_stackalloc 40
    .seh_endprologue
    call    __main
    xorl    %eax, %eax
    addq    $40, %rsp
    ret
    .seh_endproc
    .p2align 4,,15
    .def    _GLOBAL__sub_I_global_constant; .scl    3;  .type   32; .endef
    .seh_proc   _GLOBAL__sub_I_global_constant
_GLOBAL__sub_I_global_constant:
    .seh_endprologue
    leaq    _ZGR15global_constant0(%rip), %rax
    movq    %rax, global_constant(%rip)
    ret
    .seh_endproc
    .section    .ctors,""w""
    .align 8
    .quad   _GLOBAL__sub_I_global_constant
    .globl  global_constant
    .bss
    .align 16
global_constant:
    .space 8
    .data
    .align 4
_ZGR15global_constant0:
    .long   2048
    .ident  ""GCC: (rev5, Built by MinGW-W64 project) 4.8.1""
</code></pre>

<p>Case 2 (-O3):</p>

<pre><code>    .file   ""TestConstantsAsm.cpp""
    .def    __main; .scl    2;  .type   32; .endef
    .section    .text.startup,""x""
    .p2align 4,,15
    .globl  main
    .def    main;   .scl    2;  .type   32; .endef
    .seh_proc   main
main:
    subq    $40, %rsp
    .seh_stackalloc 40
    .seh_endprologue
    call    __main
    xorl    %eax, %eax
    addq    $40, %rsp
    ret
    .seh_endproc
    .ident  ""GCC: (rev5, Built by MinGW-W64 project) 4.8.1""
</code></pre>

<p>Without (-O3), the 2nd case is still better than the first case. It always is..</p>

<p>The commands I used were:</p>

<pre><code>g++ -S -O3 TestConstantsAsm.cpp
g++ -S -O2 TestConstantsAsm.cpp
g++ -S -O TestConstantsAsm.cpp
</code></pre>

<p>and the program was:</p>

<pre><code>const int&amp; global_constant = 2048;

int main()
{
}
</code></pre>

<p>and </p>

<pre><code>const int global_constant = 2048;

int main()
{
}
</code></pre>

<p>Even if you <code>std::cout&lt;&lt;global_constant&lt;&lt;""\n"";</code> within main (in both cases), the assembly for case 2 is still cleaner than case 1.</p>
",0
22119971,22119049,0,"<p><em>Using Visual C++ 2013, compiled in debug mode.</em></p>

<h2>Case 1</h2>

<p>The following code:</p>

<pre class=""lang-c++ prettyprint-override""><code>const int&amp; VALUE = 2048;

int main() {
    int A = VALUE;
    return 0;
}
</code></pre>

<p>...produces this assembly output:</p>

<pre class=""lang-none prettyprint-override""><code>     1: const int&amp; VALUE = 2048;
013F1380 55                   push        ebp  
013F1381 8B EC                mov         ebp,esp  
013F1383 81 EC C0 00 00 00    sub         esp,0C0h  
013F1389 53                   push        ebx  
013F138A 56                   push        esi  
013F138B 57                   push        edi  
013F138C 8D BD 40 FF FF FF    lea         edi,[ebp-0C0h]  
013F1392 B9 30 00 00 00       mov         ecx,30h  
013F1397 B8 CC CC CC CC       mov         eax,0CCCCCCCCh  
013F139C F3 AB                rep stos    dword ptr es:[edi]  
013F139E C7 05 34 91 3F 01 00 08 00 00 mov         dword ptr ds:[13F9134h],800h  
013F13A8 C7 05 30 91 3F 01 34 91 3F 01 mov         dword ptr ds:[13F9130h],13F9134h  
013F13B2 5F                   pop         edi  
013F13B3 5E                   pop         esi  
013F13B4 5B                   pop         ebx  
013F13B5 8B E5                mov         esp,ebp  
013F13B7 5D                   pop         ebp  
013F13B8 C3                   ret  

(...)

     2: 
     3: int main() {
00C42280 55                   push        ebp  
00C42281 8B EC                mov         ebp,esp  
00C42283 81 EC CC 00 00 00    sub         esp,0CCh  
00C42289 53                   push        ebx  
00C4228A 56                   push        esi  
00C4228B 57                   push        edi  
00C4228C 8D BD 34 FF FF FF    lea         edi,[ebp-0CCh]  
00C42292 B9 33 00 00 00       mov         ecx,33h  
00C42297 B8 CC CC CC CC       mov         eax,0CCCCCCCCh  
00C4229C F3 AB                rep stos    dword ptr es:[edi]  
     4:     int A = VALUE;
00C4229E A1 30 91 C4 00       mov         eax,dword ptr ds:[00C49130h]  
00C422A3 8B 08                mov         ecx,dword ptr [eax]  
00C422A5 89 4D F8             mov         dword ptr [A],ecx  
     5:     return 0;
00C422A8 33 C0                xor         eax,eax  
     6: }
00C422AA 5F                   pop         edi  
     6: }
00C422AB 5E                   pop         esi  
00C422AC 5B                   pop         ebx  
00C422AD 8B E5                mov         esp,ebp  
00C422AF 5D                   pop         ebp  
00C422B0 C3                   ret  
</code></pre>

<p>In case 1, the value 2048 (0x800) is stored in memory, which is accessed when the constant is referenced in the main code.</p>

<h2>Case 2</h2>

<p>The following code:</p>

<pre class=""lang-c++ prettyprint-override""><code>const int VALUE = 2048;

int main() {
    int A = VALUE;
    return 0;
}
</code></pre>

<p>...produces this assembly output:</p>

<pre class=""lang-none prettyprint-override""><code>     1: const int VALUE = 2048;
     2: 
     3: int main() {
00F02280 55                   push        ebp  
00F02281 8B EC                mov         ebp,esp  
00F02283 81 EC CC 00 00 00    sub         esp,0CCh  
00F02289 53                   push        ebx  
00F0228A 56                   push        esi  
00F0228B 57                   push        edi  
00F0228C 8D BD 34 FF FF FF    lea         edi,[ebp-0CCh]  
00F02292 B9 33 00 00 00       mov         ecx,33h  
00F02297 B8 CC CC CC CC       mov         eax,0CCCCCCCCh  
00F0229C F3 AB                rep stos    dword ptr es:[edi]  
     4:     int A = VALUE;
00F0229E C7 45 F8 00 08 00 00 mov         dword ptr [A],800h  
     5:     return 0;
00F022A5 33 C0                xor         eax,eax  
     6: }
00F022A7 5F                   pop         edi  
00F022A8 5E                   pop         esi  
00F022A9 5B                   pop         ebx  
00F022AA 8B E5                mov         esp,ebp  
00F022AC 5D                   pop         ebp  
00F022AD C3                   ret
</code></pre>

<p>In case 2, no code is generated for the global constant declaration itself. When the constant is used, it is simply a ""move immediate"" instruction which inserts the value 2048 (0x800) directly into the variable. If the constant is not used, it will not appear in the assembly at all.</p>
",0
21590632,21590203,1,"<p>Your question is confuse, i decipher you want for each key in map1 to sum the value of each pair in the vector found in the map2 to a single value, and store the result with the map1 key. Not really what your code do¡­</p>

<p>Example result : <a href=""http://coliru.stacked-crooked.com/a/a4d77c77fa6896c1"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/a4d77c77fa6896c1</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;map&gt;
#include &lt;utility&gt;

using Map1 = std::map&lt; int, std::vector&lt;std::pair&lt;int,int&gt;&gt;&gt;;
using Map2 = std::map&lt; std::pair&lt;int,int&gt;, int &gt;;
using Map3 = std::map&lt; int, int &gt;;

Map3 foo( Map1 const &amp; m1, Map2 const &amp; m2 ) {
    auto m2end = m2.end(); // a constant call is move outside the loop
    Map3 result;
    for( auto &amp; v1 : m1 ) { // each entry in m1 is made of the key as first and the value as second
        for( auto &amp; p1 : v1.second ) { // iterate over the vector of pair
            auto v2it = m2.find( p1 ); // search for the pair
            if ( v2it != m2end ) {
                result[v1.first] += v2it-&gt;second; // if the pair was found, add the value for it to the result, using the map1 key as key
            }
        }
    }
    return result;
}

template&lt;typename T,typename S&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::pair&lt;T,S&gt;&amp; pair )
{
    os &lt;&lt; ""{ "" &lt;&lt; pair.first &lt;&lt; "", "" &lt;&lt; pair.second &lt;&lt; "" }"";
    return os;
}
template&lt;typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; vec)
{
    os &lt;&lt; ""( "";
    for (auto&amp; el : vec)
    {
        os &lt;&lt; el &lt;&lt; "", "";
    }
    os &lt;&lt; "" )"";
    return os;
}

template&lt;typename T,typename S&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::map&lt;T,S&gt;&amp; map)
{
    for (auto&amp; el : map)
    {
        os &lt;&lt; el.first &lt;&lt; "" : "" &lt;&lt; el.second &lt;&lt; ""\n"";
    }
    return os;
}

int main()
{
    Map1 m1 { { 0, { {1,3}, {1,5}} }, { 1, { {2,1}, {2,4}} }, };
    Map2 m2 { { {1,3}, 4 }, { {1,5}, 3 }, { {2,1}, 1 }, { {2,4}, 5 }, };

    auto m3 = foo( m1, m2);

    std::cout &lt;&lt; ""m1 :\n"" &lt;&lt; m1 &lt;&lt; std::endl;
    std::cout &lt;&lt; ""m2 :\n"" &lt;&lt; m2 &lt;&lt; std::endl;
    std::cout &lt;&lt; ""m3 :\n"" &lt;&lt; m3 &lt;&lt; std::endl;
}
</code></pre>
",9
26228082,26227965,2,"<p>I'm not sure that strictly speaking the standard does allow you to <code>memcpy</code> into an array of <code>char</code> and back again, although you'd certainly get away with it with PODs.</p>

<p>But things get murkier when you start looking at all the complicated things C++ can do. Consider the following:</p>

<pre><code>struct ex1;

struct ex2
{
    ex2(std::unique_ptr&lt;ex1&gt; ptr) : member{ptr} {}
private:
    std::unique_ptr&lt;ex1&gt; member;
};
</code></pre>

<p>The struct <code>ex2</code> is move-only because it has a move-only member variable. So what happens if we use <code>memcpy</code> to construct a bit-for-bit identical copy of an <code>ex2</code> instance? We end up with two objects which both think they own the member pointer. What happens when the second one of these gets deleted? You get the idea.</p>
",1
26228217,26227965,2,"<p>A particular case where this kind of serialization fails is on types with virtual members.  If a type has a virtual member then it has a vtable.  This table will contain pointers to the implementation for each of the virtual members.</p>

<p>If the serialized data in the char array crosses a process boundary (you send it over the network, or you write it to disk and read it back in from a different process) then the vtable pointers you wrote out may no longer be valid, and invoking any virtual member would cause undefined behavior.</p>
",1
26228269,26227965,4,"<p>The reason a <em>trivially copyable class</em> (C++11 mostly uses the concepts <em>trivial class</em> and <em>standard-layout class</em> instead of <em>POD</em>) can be memcpy'ed is not related to dynamic allocation as other answers/comments suggest. Granted, if you do try a shallow copy of a type that has dynamic allocation, you are inviting trouble. But you could very well have a type with a pointer that does dynamic allocation in a user provided constructor (as long as it has a default constructor) and qualify as <em>trivial class</em>.</p>

<p>The actual reason a memcpy can be guaranteed is that <em>trivially copyable</em> (and also <em>standard-layout</em>) types are required to occupy contiguous bytes of storage whereas other objects are not.</p>

<p>N3690</p>

<blockquote>
  <p>1.8.5 Unless it is a bit-field (9.6), a most derived object shall have a non-zero size and shall occupy one or more
  bytes of storage. Base class subobjects may have zero size. An object of trivially copyable or standard-layout
  type (3.9) shall occupy contiguous bytes of storage.</p>
</blockquote>
",7
22515760,22515646,2,"<p>You're passing a type name to static_assert. You need a <code>bool</code> <em>expression</em> or something that convers to it. These are your options:</p>

<pre><code>std::is_base_of&lt;Initable&lt;CTX&gt;, OBJECT&gt;::value
std::is_base_of&lt;Initable&lt;CTX&gt;, OBJECT&gt;{}
std::is_base_of&lt;Initable&lt;CTX&gt;, OBJECT&gt;()
</code></pre>
",0
25470677,25470655,3,"<p>You are missing <code>c_str()</code> after <code>name</code></p>

<pre><code>sprintf(path, ""data/%s/f%i%s"", name.c_str(), k, ext);
</code></pre>
",0
33819502,33819415,5,"<p>Because if you don't return a reference of the object it makes a copy.
As @M.M said about the final test() call, the copy does not appears because of the copy elision <a href=""https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization][1]"">What are copy elision and return value optimization?</a></p>
",2
23842222,23842213,8,"<p>Change to <code>char const *args[]</code>.  If you do not intend to change which strings are in this table, then use </p>

<pre><code>char const *const args[] = { ....
</code></pre>

<p>The <code>write-strings</code> error means to give an error for your code. Your code is legal  but bad practice. It's bad practice because string literals contain <code>const char</code>s , so it would be undefined behaviour to write to them. Making the pointer point to <code>const char</code>s means you get a compiler message if you try to write to them.</p>
",0
21586597,21583510,0,"<p>Just spitballing but people have a tendency to const float pi or kPI or whatever notation you like in a basic math header instead of this. Is pi gonna be different anywhere else?</p>
",0
21586536,21583510,1,"<p>First, a static member function cannot access a non-static member variable without an instance of the class.</p>

<pre><code>const float pi = 3.1415;           // Non-static. Created upon instantiation
static float _pi() { return pi; }; // Error. No access to instance.
</code></pre>

<p>If you want to statically call the function <code>_pi</code> then you should also make the constant <code>pi</code> static.</p>

<p>Secondly, when calling the function <code>pi</code> you must call it with <code>()</code>, e.g.</p>

<pre><code>float x = myClass::_pi();
</code></pre>

<p>Finally you could use C++11 <code>constexpr</code> to make <code>pi</code> and the return value of <code>_pi</code> compile time constants. This will cause the compiler to insert the constant at compile time at every call site. Also you can use the expression <code>_pi()</code> in static asserts etc.</p>

<pre><code>static constexpr float pi = 3.1415f;       // Use 'f' postfix for float literals.
static constexpr float _pi() { return pi; }
</code></pre>

<p>Works:</p>

<pre><code>static_assert(myClass::_pi() == 3.1415f, ""Uh-oh, wrong value."");
</code></pre>
",0
26190115,26190008,3,"<p>It has to do with where the data is stored.  Here's a breakdown:</p>

<ul>
<li>int: member variable, stored wherever the class instance is stored</li>
<li>const int: same as int</li>
<li>static const int: doesn't need to be stored, it can simply be ""inlined"" where used</li>
<li>static int: this must have a single storage location in the program...where?</li>
</ul>

<p>Since the static int is mutable, it must be stored in an actual location somewhere, so that one part of the program can modify it and another part can see that modification.  But it can't be stored in a class instance, so it must be more like a global variable.  So why not just make it a global variable?  Well, class declarations are usually in header files, and a header file may be #included in multiple translation units (.cpp files).  So effectively the header file says ""there is an int...somewhere.""  But the storage needs to be put into the corresponding .cpp file (like a global variable).</p>

<p>In the end, this is not really about initialization, but rather the storage.  You could leave off the initializer and you'd still not have a valid program until you add this to your .cpp file:</p>

<pre><code>int A::d; // initialize if you want to, default is zero
</code></pre>

<p>Without this, references to the static int will be undefined and linking will fail.</p>
",2
26190159,26190008,1,"<p>Initialization of static const member variables is available for integral and enum types. This feature existed in C++ since the first language standard (C++98). It is needed to facilitate usage of static const members in <em>integral constant expressions</em> (i.e. as compile-time constants), which is an important feature of the language. The reason integral and enum types were singled out and treated in this exceptional fashion is that integral constants are often used in compile-time contexts, which require no storage (no definition) for the constant.</p>

<p>The ability to supply initializers for non-static members is a new (for C++11) feature. It is a completely different feature, even though it looks similar at syntax level. Such initializers are used as construction-time initializers for those class members that were not explicitly initialized by the user.</p>

<p>In other words, it is not correct to lump these two features (initializers for static and non-static members) together. These two features are completely different. They are based on completely unrelated internal mechanics. Your question essentially applies the first feature: how come non-const static members cannot be initialized in-class? It is basically a C++98 question and the most likely answer to it is that there was never any reason to treat non-const static members in such an exceptional way. Non-const static members are treated in accordance with the general rules: they require a separate definition and the initializer should be provided at the point of definition.</p>
",0
26247245,26247176,1,"<p><code>FileDeleter(""tmpfile.txt"")</code> creates a deleter object to pass to the shared pointer.</p>

<p>The shared pointer's implementation stores a copy this somewhere as a variable, as well as the managed object, along the lines of</p>

<pre><code>std::ofstream * object;
FileDeleter deleter;
</code></pre>

<p>The shared pointer's destructor will invoke this as</p>

<pre><code>deleter(object);
</code></pre>

<p>which will call the deleter's overloaded <code>operator()</code>, deleting the object and removing the file.</p>
",2
28466421,28466271,0,"<p>You will never have a problem with object life span if you don't use pointers or references. It simply isn't possible for that to occur. The whole concept of ""RAII"" is that if the variable is accessible in code, it is valid.</p>

<p>To test this, also print out the coordinates and size of your vehicle. If that prints a valid result, you know that your issue lies in the paint function itself.</p>

<p>So just don't pass a pointer of the object unless you need to modify it, and even then return a reference instead of a pointer. Just make sure not to return a reference of a temporary, as that CAN lead to life span issues.</p>
",1
28466435,28466271,2,"<p>I think your main problem is you have defined an empty copy constructor:</p>

<pre><code>Vehicle::Vehicle(const Vehicle&amp; orig)
{
}
</code></pre>

<p>This means that when you add a <code>Vehicle</code> to a container, a copy is made that doesn't actually copy anything. You should delete your own constructor and let the compiler do the work for you.</p>
",1
34185587,34185408,2,"<p>If that is your only change, then your issue is that you're calling <code>fun()</code> on a invalid instance of <code>ExClass</code>. Or you forgot to new the class or it already is deleted/went out of scope.</p>

<p>F.e. this <a href=""http://ideone.com/H5zJ3j"" rel=""nofollow"">Ideone</a> example works perfectly, because <code>A a</code> is created on stack inside <code>fun()</code>. But once you move the declaration of <code>a</code> to class level, you will get an exception because <code>*b</code> is not instantiated.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct A {
    int data;
    A() : data(123) { }
};

class B {
public:
    void fun() {
        A a;
        cout &lt;&lt; a.data;
    }
};

int main() {
    B* b; // b points to random memory, thus is an invalid instance
    b-&gt;fun(); // this still works because fun doesn't access any member of B
    return 0;
}
</code></pre>
",5
22449322,22449282,6,"<p>Constructors are meant to create objects. Hence they are used once. You should create a method to do initialization and call that from constructors.</p>
",0
22449345,22449282,1,"<p>You could provide a copy and/or move assignment operations in <code>class A</code>.</p>

<pre><code>class A
{
public:
    int a, b;

    // Copy assignment operator
    A&amp; operator=(const A&amp; rhs) {
        if(this == &amp;rhs) return *this;
        a = rhs.a; b = rhs.b;
        return *this;
    }

    // ...
};
</code></pre>

<p>After the above you could reinitialize it using the pattern</p>

<pre><code>BaseClass::operator=(BaseClass(a,b));
</code></pre>

<p>which, in your case is</p>

<pre><code>A::operator=(A(a,b));
</code></pre>

<p>If your class is an aggregate, or has an implicitly defined copy constructor, you should use those (you don't have to define your own), and use the same reinitialization pattern as above.</p>
",0
22449382,22449282,0,"<p>You cannot call the constructor of your superclass except in your initializer list. You have to use composition instead of inheritance if you want to use operations on a differrently constructed A object. If a method changes an already constructed object, it is not a contructor. So either replace the object with a newly constructed one (instead of changing it) or use non constructor methods.</p>
",0
22451140,22449282,0,"<p>Put the code to compute a and b into a method and use it in the initializer list:</p>

<pre><code>class A {
public:
    A(int a, int b): a_(a), b_(b) {}
};

class B : public A
{
public:
    B(): A(B::computeA(), B::computeB()) {}

private:
    static int computeA();
    static int computeB();
};
</code></pre>

<p>I have made the methods static to prevent using a partially initialized object.</p>

<p>Although I have to say that the question and the example sound like you are using inheritance to re-use an implementation. In this case, you should not use inheritance but composition and replace the inheritance with a member object.</p>
",0
21167048,21166888,2,"<p>I'd just consider Solution 1 the default choice, i.e. use a data member which is an instance of <code>DEF</code>, instead of a <code>unique_ptr&lt;DEF&gt;</code>.</p>

<p>First, code of solution #1 is the simplest. It is also more efficient, since you don't have a useless heap allocation (required by <code>unique_ptr</code>). An heap allocation means going down to the memory manager, and this is an unnecessary cost in this case.</p>

<p>Moreover, if your data member is a pointer, you have worse locality (i.e. less cache-friendly memory layout, and worse performance).</p>

<p>Just consider solution #1, unless you ave some very good reason for #2.
(An example with a <em>private</em> data member that uses a <code>unique_ptr&lt;SomePrivateState&gt;</code> is the PIMPL idiom, but it seems not your case, since you are exposing <code>DEF</code> as a <em>public</em> element of your class.) </p>
",0
27130713,27130124,2,"<p>You will have to specify in your executable projects that they reference the static lib. May be <a href=""http://msdn.microsoft.com/en-us/library/vstudio/ms235627%28v=vs.110%29.aspx#uselibinapp"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/vstudio/ms235627%28v=vs.110%29.aspx#uselibinapp</a> helps (lower third of the article).</p>

<blockquote>
  <p>Before you can use the math routines in the static library, you must
  reference it. To do this, open the shortcut menu for the MyExecRefsLib
  project in Solution Explorer, and then choose References. In the
  MyExecRefsLib Property Pages dialog box, expand the Common Properties
  node, select Framework and References, and then choose the Add New
  Reference button. </p>
</blockquote>
",1
27130814,27130124,0,"<p>The linker cannot 'see' your function and as such thinks that it does not have an <code>external symbol</code> referencing it, hence the error.</p>

<p>You must <code>#pragma comment(lib, [library here])</code> to reference the external function.</p>

<p>The following code can be used to reproduce this error:</p>

<p>[header file- test.h]:</p>

<pre><code>#include ""StdAfx.h""

void someOtherFunction();
void someFunction(string thisVar);
</code></pre>

<p>[code file- test.cpp]:</p>

<pre><code>#include ""StdAfx.h""
#include ""test.h""

void someOtherFunction()
{
    printf(""Hello World!"");
}
</code></pre>

<p>[function body for <code>someFunction(string thisVar)</code> is missing!]</p>
",0
27177008,27176614,0,"<p>With variadic templates, you could try the following approach (wrap the getPointer):</p>

<pre><code>void * C_API_CallMethod(void *h1, void *h2, ...);

struct FancyHandler
{
    void* getPointer() const { return nullptr; }
};

void* getPointer(const FancyHandler&amp;first) {
    return first.getPointer();
}

template&lt;typename... Args&gt; 
void pass(Args&amp;&amp;... args) {
    C_API_CallMethod(args...);
}

template&lt;typename... Args&gt; 
void CallMethod(const FancyHandler&amp; h1, const FancyHandler&amp; h2, Args&amp;&amp;... args) {
    pass(getPointer(h1), getPointer(h2), getPointer(args)...);
}
</code></pre>
",0
28513292,28513110,1,"<p>You can replace your plain old data type with a class type to do what you want:</p>

<pre><code>class Damage
{
public:
    Damage&amp; operator=(float x) { value = x; /* add code here*/ }
    operator float() const { return value; }

private:
    float value;
};
</code></pre>

<p>Then just replace your <code>float</code> with <code>Damage</code> and you can make it behave how you want.</p>
",2
26200039,26199741,5,"<p>Here's one way:</p>

<pre><code>{
    std::cout &lt;&lt; ""unique_ptr&lt;Bar, void(void*)&gt;:\n"";
    std::unique_ptr&lt;Foo, void(*)(void*)&gt; p(
        new Bar(), [](void*p) -&gt; void { delete static_cast&lt;Bar*&gt;( p ); }
        ); // prints Bar Foo
}
</code></pre>

<p>A main problem with this approach is that <code>unique_ptr</code> supports conversion to logical ""pointer to base class"", but that the standard does not guarantee that conversion to <code>void*</code> will then yield the same address. In practice that's only a problem if the base class is non-polymorphic while the derived class is polymorphic, introducing a vtable ptr and thus possibly changing the memory layout a bit. But in that possible-but-not-likely situation the cast back in the deleter would yield an incorrect pointer value, and bang.</p>

<p>So, the above is not formally safe with respect to such conversions.</p>

<hr>

<p>To do roughly the same as a <code>shared_ptr</code> does (<code>shared_ptr</code> supports conversions to logical pointer-to-base), you would need to store also the original <code>void*</code> pointer, along with the deleter.</p>

<hr>

<p>In general, when you control the the topmost base class, make its destructor virtual.</p>

<p>That takes care of everything.</p>
",3
26200041,26199741,7,"<p>You should make the destructor of <code>Foo</code> <code>virtual</code>. That is good practice regardless of whether you use <code>unique_ptr</code> or not. That will also take care the problem that you are dealing with.</p>
",1
26251210,18998425,1,"<p>I suggest that you check template usage against new template rules in ISO C++ 2003 standard.</p>

<p>Thanks</p>
",0
26138301,26138262,0,"<p>I suggest you to use fixed size integers, so you prevent overflowing. If it is not available on some platform, the compiler will complain (and a compilation error is much better than a runtime error).</p>
",4
26138387,26138262,0,"<p>If you're just targeting one platform and you're not planning to interop with anything then I wouldn't worry about things.</p>

<p>However, if you want your code to compile on a variety of platforms (OSX, Linux, Windows) then I'd go with the types defined in <code>cstdint</code>. Also, if you're planning to interop with other languages that have well defined sizes (eg <code>int</code> is 32-bit in Java/C#) then I'd go with the types like <code>int32_t</code> as your code will be portable and it's much more explicit what you are doing.</p>
",1
28226716,28226607,0,"<p>It looks like you aren't using the right parameters for std::copy.</p>

<p>From <a href=""http://www.cplusplus.com/reference/algorithm/copy/"" rel=""nofollow"">http://www.cplusplus.com/reference/algorithm/copy/</a>:</p>

<pre><code>template &lt;class InputIterator, class OutputIterator&gt;  
  OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result);
</code></pre>

<p>From their example:</p>

<pre><code>int myints[]={10,20,30,40,50,60,70};
std::vector&lt;int&gt; myvector (7);

std::copy ( myints, myints+7, myvector.begin() );
</code></pre>

<p>So the first two parameters are the start and end of the range you want to copy, and the third parameter is where you want to copy to.</p>

<p>In your case, this would look something like this (disclaimer: didn't test this):</p>

<pre><code>std::copy(arg.elem, arg.elem + arg.sz, elem);
</code></pre>
",0
28524090,28524008,1,"<p><code>psArray</code> is just a pointer. <code>std::begin</code> and <code>std::end</code> cannot possibly know the length of the array the pointer points to. They work for plain arrays, not for pointers to arrays.</p>

<p>You can do this instead:</p>

<pre><code>std::copy(psArray_, psArray_ + instSize, std::back_inserter(psContainer_));
</code></pre>

<p>assuming <code>psContainer_</code> is a container holding pointers to <code>PositionSummary</code>.</p>

<p>Depending on the details of your application, you may be better off using an <code>std::vector</code>, either of smart pointers or values:</p>

<pre><code>std::vector&lt;some_smart_pointer&lt;PositionSummary&gt;&gt; psArray_;
</code></pre>

<p>or</p>

<pre><code>std::vector&lt;PositionSummary&gt; psArray_;
</code></pre>

<p>where the second option may be the better one if you don't need referential semantics.</p>
",0
28524173,28524008,1,"<p>That doesn't work because psArray_ is not an array at all, it is a pointer. <em>You</em> may know that it points to an array of a specific size, but the compiler has no (general) way of knowing this. If you were to make it an array it would work fine. Try to declare psArray_ like this:</p>

<pre><code>PositionSummary* psArray_ [instSize];
</code></pre>

<p>This will work, but presumably not for you because I'm guessing instSize is not a compile time constant. You can fix that by using a vector instead of doing your own memory allocation:</p>

<pre><code>std::vector&lt;PositionSummary*&gt; psArray_;
for (int k = 0; k &lt; instSize; k++) 
    psArray_.push_back (new PositionSummary());

std::copy(psArray_.begin()),psArray_.end(),std::back_inserter(psContainer_));
</code></pre>

<p>For further improvement, you could consider using a smartpointer in the vector (so you don't have to worry about freeing later). And while I have no idea of the greater context of your code, I'm still wondering why the copy is necessary at all - why not just construct your vector directly in the data structure that is ultimately supposed to hold it?</p>
",0
24349574,24342965,1,"<p>I was searching to solution of this problem but couldn't find anything..
So I came up to this solution, I know it's not the best but unless it's working it fine.</p>

<pre><code>class MTBGameObject {
    ...
    virtual CCNodeRGBA* self() = 0;
}
</code></pre>

<p>and then in child classes I have to override self function:</p>

<pre><code>class MTBGamePlayer : public MTBGameObject, public CCNodeRGBA {
    ...
    CCNodeRGBA* MTBGameObstacle::self() {
        CCNodeRGBA* node = dynamic_cast&lt;CCNodeRGBA*&gt;(this);
        return node;
    }
}

class MTBGameObstacle : public CCSprite, public MTBGameObject {
    ...
    CCNodeRGBA* MTBGamePlayer::self() {
        CCNodeRGBA* node = dynamic_cast&lt;CCNodeRGBA*&gt;(this);
        return node;
    }   
}
</code></pre>
",0
29471897,29471789,1,"<p><code>foo.GetLock();</code> is an <em>expression statement</em>, so any valid expression can be used in that way. You cannot prohibit that at compile time: the best you can get is a warning.</p>

<p>Assuming that your object releases the lock on destruction, the call that does not store the result in a variable shouldn't be a big problem, because the lock would be acquired and released right away.</p>

<p>Creating a <em>guard object</em>, similar to what you describe in your solution, is the proper way to go. In fact, the Standard Library of C++ does it in a similar way with <a href=""http://en.cppreference.com/w/cpp/thread/lock_guard"" rel=""nofollow""><code>std::lock_guard</code></a>.</p>
",0
21714156,21713988,1,"<p>You were almost correct. The issue is not that <code>balance</code> is not reset (it is set inside the inner loop before it is used) but that <code>time</code> is not being reset. Instead of</p>

<pre><code>//...
rate = rate + rate_increment;
time = time + time_increment; 
</code></pre>

<p>You want to reset the time to the initial value:</p>

<pre><code>//...
rate = rate + rate_increment;
time = time_increment; 
// or maybe
// time = 0;
</code></pre>
",0
21714431,21713988,1,"<p>You might find that it is easier to maintain these loops in the for-loop syntax:</p>

<pre><code>unsigned int starting_rate = 500;
unsigned int ending_rate = 1050;
unsigned int rate_increment = 50;

unsigned int starting_time = 5;
unsigned int ending_time = 30;
unsigned int time_increment = 5;

for (unsigned int i = starting_rate; i &lt;= ending_rate; i += rate_increment)
{
    double rate = i / 100.0;
    double balance = 0.0;
    std::cout &lt;&lt; rate;
    for (unsigned int time = starting_time; time &lt;= ending_time; time += time_increment)
    {
        balance = investment * std::pow((1 + rate / 100), time);
        std::cout &lt;&lt; ""\t\t"" &lt;&lt; std::setw(10) &lt;&lt; balance;
    }
    std::cout &lt;&lt; std::endl; 
}
</code></pre>

<p>Functionally, it is the same, but it puts all the loop maintenance together (separate from the logic you are doing in the loop).</p>
",0
22443875,22443720,3,"<p><code>fgets</code> is defined to stop reading whenever a <em>new-line</em> is found, and it's doing exactly what it is supposed to.</p>

<p>The problem with your snippet is that <code>scanf</code> invoked with <em>""%d""</em> as the format-specifier won't read anything that appears after the digits read.</p>

<hr>

<p>Imagine our input being the below, where <code>&lt;new-line&gt;</code> denotes a <em>new-line</em> character:</p>

<pre class=""lang-none prettyprint-override""><code>123&lt;new-line&gt;
hello world&lt;new-line&gt;
olleh dlrow
</code></pre>

<p>After <code>scanf</code> has done it's work the input stream will consist of the following</p>

<pre class=""lang-none prettyprint-override""><code>&lt;new-line&gt;
hello world&lt;new-line&gt;
olleh world
</code></pre>

<p>Notice that the <em>new-line</em> after <code>123</code> hasn't been read, this means that your first call to <code>fgets</code> will read that single character (ie. the <em>new-line</em>) and return.</p>
",0
27690280,27690253,3,"<p>The number of elements of the array, the array bound, must be a constant expression.</p>

<p>You have to use</p>

<pre><code>const int n = 5;
</code></pre>

<p>or</p>

<pre><code>constexpr int n = 5;
</code></pre>

<p>else it is a non standard  extension : variable length array (VLA).</p>
",6
27690415,27690253,3,"<p>The error message actually describes rather well what¡¯s going on: C++ does not support arrays with a non-constant size (more precisely, the size needs to be known <em>at compile time</em>).</p>

<p>There are two solutions for this:</p>

<ol>
<li><p>If the size is actually a constant, declare it as <code>constexpr</code> (if you can¡¯t use C++11, you can also use <code>const</code>):</p>

<pre><code>constexpr int n = 5;
std::array&lt;int, n&gt; arr;
</code></pre>

<p>Which requires the standard header <code>&lt;array&gt;</code>. Or, if you cannot use C++11, change the second line to</p>

<pre><code>int arr[n];
</code></pre></li>
<li><p>If the size isn¡¯t known at compile time, don¡¯t use a static array, use a dynamic container instead:</p>

<pre><code>int n = 5;
std::vector&lt;int&gt; arr(n);
</code></pre>

<p>This requires the <code>&lt;vector&gt;</code> standard header.</p></li>
</ol>
",3
22124167,22124157,2,"<p>In your <code>main()</code> you are not calling productfz correctly the line:</p>

<pre><code>  unsigned productfz(unsigned first, unsigned b); 
</code></pre>

<p>is a function decleration not a function call. </p>

<p>If you want to call the function simply write:</p>

<pre><code> productfz(first,b);
</code></pre>
",0
22124169,22124157,1,"<p>You're not actually calling your function, you're just declaring a prototype within <code>main</code> - change:</p>

<pre><code>unsigned productfz(unsigned first, unsigned b);
</code></pre>

<p>to:</p>

<pre><code>productfz(first, b);
</code></pre>
",0
22124170,22124157,1,"<p>You don't need to specify a variable's datatype when you pass it to a function. You also don't need to specify the method's return datatype when you call it.</p>

<p>This code should work:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
unsigned productfz();

unsigned productfz(unsigned a, unsigned b)
{
  //nothing for now
  cout &lt;&lt; ""this is a tester"" &lt;&lt; endl;
  return a;
}

int main()
{
  unsigned int first = 7;
  unsigned b = 4;
  productfz(first, b);

  return 0;
}
</code></pre>
",4
22124179,22124157,1,"<p>Make following changes (also, formatted/aligned code is easier to understand and debug):</p>

<pre><code>unsigned productfz(unsigned a, unsigned b)
{
    //nothing for now
    int a; // you are returning this variable but you have not defined/used it
    cout &lt;&lt; ""this is a tester"" &lt;&lt; endl;
    return a; 
}

int main()
{

    unsigned int first = 7;
    unsigned b = 4;
    productfz(first, b); //just write the variable names

    return 0;
}
</code></pre>
",0
22124335,22124157,1,"<p>Originally posted code:</p>

<pre><code> #include &lt;iostream&gt;
 using namespace std;
 unsigned productfz();

 unsigned productfz(unsigned a, unsigned b)
 {
//nothing for now
    cout &lt;&lt; ""this is a tester"" &lt;&lt; endl;
return a;
 }

int main()
{

unsigned int first = 7;
unsigned b = 4;
unsigned productfz(unsigned first, unsigned b);

return 0;
}
</code></pre>

<p>Fixed &amp; cleaned code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int productfz( int const a, int const b)
{
    //nothing for now
    cout &lt;&lt; ""this is a tester"" &lt;&lt; endl;
    return a;
}

int main()
{
    productfz( 7, 4 );
}
</code></pre>

<p>where</p>

<ul>
<li><p>The forward declaration of <code>productfz</code> has been removed.<br>
Forward declarations
just mean that two places have to be updated instead of one when a change is
made, and they can introduce subtle errors when forward declaration and
implementation get out fo synch.</p></li>
<li><p>The type <code>unsigned</code> has been replaced with <code>int</code>.<br>
C++ guarantees modular arithmetic for unsigned types, <em>and</em> provides
implicit conversions up from signed types to corresponding unsigned, when
the two kinds are mixed in an expression. This means that if unsigned types
are used <strong>for numbers</strong>, then you risk inadvertent use of modular
arithmetic. For example, <code>string(""haha"").length() &lt; -5</code> is always <code>true</code>,
due to an ill-fated decision long ago (when it made sense) to have sizes
represented with an unsigned integer type.</p></li>
<li><p>The formal arguments have been <code>const</code>ified.<br>
Most everybody agree that it's a good idea to liberally sprinkle <code>const</code>
everywhere that it's practical to do so, because that constrains the
possible data interaction pathways and make the code easier to reason
about and understand. However, few put <code>const</code> on ordinary value arguments.
I do, because the same rationale applies to them as for e.g. local variables.</p></li>
<li><p>The variables used as argument names, in <code>main</code>, have been removed.<br>
For a simple function with few arguments it doesn't really clarify
anything to name the actual arguments. On the contrary, the added
verbosity might have the opposite effect, of obscuring. Still, as a
general rule it's a good idea to name just about everything in sight,
so when in doubt, do name things.</p></li>
<li><p>The redeclaration of the function in <code>main</code>, has been replaced with a <strong>call</strong>.<br>
A function <code>f</code> is called like <code>f( argument1, argument2, ... )</code>.</p></li>
<li><p>The <code>return</code> statement in <code>main</code> has been removged.<br>
<code>main</code> is a very special function, with a default return value (namely 0).</p></li>
</ul>

<p>Personally I would prefer to also use C++ <code>auto</code> syntax for the function declarations, because that makes it easier to scan the code and is <em>one</em> universal function declaration
syntax. However, that's still not very common practice, so I didn't do that here.</p>
",0
31850351,31850314,2,"<p>This is bitfield declaration, Declares a class data member with explicit size, in bits.</p>
",1
31850358,31850314,13,"<p>That line is a <a href=""http://en.cppreference.com/w/cpp/language/bit_field"" rel=""noreferrer"">bit field declaration</a> and it declares a data member with an explicit bit-level size</p>

<p>Example from cppreference:</p>

<pre><code>#include &lt;iostream&gt;
struct S {
 // three-bit unsigned field,
 // allowed values are 0...7
 unsigned int b : 3;
};
int main()
{
    S s = {7};
    ++s.b; // unsigned overflow
    std::cout &lt;&lt; s.b &lt;&lt; '\n'; // output: 0
}
</code></pre>

<p>Notice that in the example above the unsigned overflow is <a href=""https://stackoverflow.com/questions/18195715/why-is-unsigned-integer-overflow-defined-behavior-but-signed-integer-overflow-is"">defined behavior</a> (same doesn't apply if <code>b</code> were declared as a signed type)</p>

<p>The documentation you links also states that</p>

<blockquote>
  <p>Boolean types can be represented either with the C++ bool keyword or as a bitfield</p>
</blockquote>

<p>Regarding <em>why should I care</em> I recommend reading <a href=""https://stackoverflow.com/q/4240974/1938163"">this other question</a></p>
",2
31850444,31850314,2,"<p>It is not initialization, it is a fragment of a declaration.</p>

<pre><code>struct {
    // ...
    uint32 bIsHungry : 1;
    // ...
};
</code></pre>

<p>declares a <code>bIsHungry</code> as a bitfield member of the <code>struct</code>. It says that <code>bIsHungry</code> is an <code>unsigned int</code> whose length is <code>1</code> bit. Its possible values are <code>0</code> and <code>1</code>.</p>

<p>Read more about bitfields: <a href=""http://en.cppreference.com/w/c/language/bit_field"" rel=""nofollow"">http://en.cppreference.com/w/c/language/bit_field</a></p>
",0
26163118,26157120,2,"<p>I think you should avoid using a data-structure that can hold multiple types of data if you can and consider a different design.</p>

<p>For example you could consider using something a bit like the <a href=""http://en.wikipedia.org/wiki/Flyweight_pattern"" rel=""nofollow"">Flyweight pattern</a> and pull the ""extrinsic"" state out of the <code>ItemData</code> class leaving only the ""intrinsic"" state. It feels a bit non object-oriented to me but it might meet your needs. For example you could keep separate maps from item index to data. Whether this will help with your memory usage depends on how sparse your data is.</p>

<pre><code>#include &lt;unordered_map&gt;
#include &lt;iostream&gt;

class Item {
 private:
  std::string type_;  // ""intrinsic"" state
 public:
  Item(const std::string &amp;type) : type_(type) {} 

  // pass in ""extrinsic"" state
  void someOperation(std::string color, double speed) {

    // do something using both ""intrinsic"" and ""extrinsic"" state...
    std::cout &lt;&lt; color &lt;&lt; "" "" &lt;&lt; type_ &lt;&lt; "" moving at "" &lt;&lt; speed &lt;&lt; ""mph\n"";
  }
};

class AnimalSim {
 private:
  std::unordered_map&lt;int, std::string&gt; duck_colors_;   // Store extrinsic
  std::unordered_map&lt;int, std::string&gt; sheep_colors_;  // state separately
  std::unordered_map&lt;int, double&gt;      duck_speeds_;   // in a more
  std::unordered_map&lt;int, double&gt;      sheep_speeds_;  // efficent way.
 public:
  void run();
  std::string getDuckColor(int duck_index) const;
  std::string getSheepColor(int sheep_index) const;
  double      getDuckSpeed(int duck_index) const;
  double      getSheepSpeed(int sheep_index) const;
};

void
AnimalSim::run() {
  auto duck = Item{""duck""};    // Create `Flyweight` objects that can be shared.
  auto sheep = Item{""sheep""};  // Should probably be done by a factory with a cache.

  // Create duck 0
  duck_colors_.emplace(0, ""red"");
  duck_speeds_.emplace(0, 150.0);

  // Create duck 1 - has no speed
  duck_colors_.emplace(1, ""green"");
  size_t num_ducks = 2;

  // Create sheep 0 - has no color
  sheep_speeds_.emplace(0, 100.0);
  size_t num_sheep = 1;

  // Do something with all the ducks
  for(size_t i = 0; i != num_ducks; ++i)
    duck.someOperation(getDuckColor(i), getDuckSpeed(i));

  // Do something with all the sheep
  for(size_t i = 0; i != num_sheep; ++i)
    sheep.someOperation(getSheepColor(i), getSheepSpeed(i));    
}

std::string
AnimalSim::getDuckColor(int duck_index) const {
  auto color_itr = duck_colors_.find(duck_index);
  return color_itr != duck_colors_.end() ? color_itr-&gt;second : ""black""; 
}

std::string
AnimalSim::getSheepColor(int sheep_index) const {
  auto color_itr = sheep_colors_.find(sheep_index);
  return color_itr != sheep_colors_.end() ? color_itr-&gt;second : ""white""; 
}

double
AnimalSim::getDuckSpeed(int duck_index) const {
  auto speed_itr = duck_speeds_.find(duck_index);
  return speed_itr != duck_speeds_.end() ? speed_itr-&gt;second : 0.0; 
}

double
AnimalSim::getSheepSpeed(int sheep_index) const {
  auto speed_itr = sheep_speeds_.find(sheep_index);
  return speed_itr != sheep_speeds_.end() ? speed_itr-&gt;second : 0.0; 
}

int main() {
  AnimalSim animal_sim;
  animal_sim.run();
}
</code></pre>

<p><kbd><a href=""http://coliru.stacked-crooked.com/a/8169fd44a57daba5"" rel=""nofollow"">Live demo.</a></kbd></p>

<p><strong>Edit</strong>: I see you are loading data from a database. In which case I wonder why you are not just loading-on-demand from the database when you need to? </p>
",2
26163372,26157120,1,"<p>One possible solution to your problem is to defer the decision about the actual composition of the record until you need to process it. For instance, if you are parsing a text string fron the file, do not parse it while reading; pass around or store the actual text line instead. Parse it on-demand, when you need the process the fields. This is known as ""lazy parsing"", and it avoids the problem of storing indeterminate type by...not determining the type. </p>
",0
26166790,26157120,1,"<p>You have a company ID and a set of company descriptors of various types, wherein each kind of descriptor has a unique tag (the ""column""), and some kind of mapping between the ID and the set. So you have something like <code>map&lt;company_id_t, set&lt;company_detail_t&gt;&gt;</code>. Note the set doesn't have to be <code>std::set</code>, you can easily build your own e.g. <code>vector</code>-based solution, but conceptually it is a set.</p>

<p><code>company_detail_t</code> could be a pair of <code>detail_tag_t</code> and <code>detail_value_t</code>. The set is keyed on the tag only, so no two details have the same tag. The value could be</p>

<ol>
<li>a union</li>
<li>a <code>boost::variant</code></li>
<li>a <code>boost_any</code></li>
<li>a pointer to a <code>detail_value_base</code> class object that has different subclasses. In this case <code>detail_tag_t</code> could actually be a result of virtual <code>detail_tag_t detail_value_base::getTag()</code> function.</li>
</ol>
",0
21022186,21022018,4,"<p>You can use a pointer to the struct. However, you cannot use a value of type MyStruct, because the compiler doesn't know the size/layout of the struct without the struct definition.  Since the struct definition is hidden in the .cpp file (and is thus not ""visible"" when the compiler is processing main.cpp):</p>

<pre><code>MyStruct* structTest;
</code></pre>

<p>is allowed in your main.cpp, whereas </p>

<pre><code> MyStruct structTest;
</code></pre>

<p>is not.  Additionally, something like:</p>

<pre><code>void foo() {
    MyStruct* test;
    test-&gt;someFunc();
}
</code></pre>

<p>won't compile if it's put in main.cpp, for the same reason.  You should put the struct definition in the header, or use PIMPL, as one of the other commenters noted.</p>
",0
24754075,24753946,1,"<p>If you want those four elements to have those four values, set those four elements to those values. There's no mystery here, other than why you would expect some other way to work.</p>
",0
24754104,24753946,4,"<p>The reason your code didn't work is that c++ converts the values to <code>uint8_t</code>, the type that your vector holds:</p>

<pre><code>v[0] = (uint8_t)cafe; // conceptually
</code></pre>

<p>or</p>

<pre><code>v[0] = (uint8_t)(cafe &amp; 0xff); // conceptually
</code></pre>

<p>The following will do what you want:</p>

<pre><code>v[0] = (uint8_t)((cafe &gt;&gt; 8) &amp; 0xff);
v[1] = (uint8_t)((cafe &gt;&gt; 0) &amp; 0xff);
v[2] = (uint8_t)((babe &gt;&gt; 8) &amp; 0xff);
v[3] = (uint8_t)((babe &gt;&gt; 0) &amp; 0xff);
</code></pre>

<p>If you have a big-endian machine, do not mind your code being unportable, and want to do some extreme performance optimization, do this:</p>

<pre><code>*(uint16_t)&amp;v[0] = cafe;
*(uint16_t)&amp;v[2] = babe;
</code></pre>
",3
25545503,25545452,0,"<p>You get your respond <a href=""https://stackoverflow.com/questions/11719538/how-to-use-stringstream-to-separate-comma-separated-strings"">Here</a></p>

<p>From @jrok</p>

<pre><code>std::string input = ""abc,def,ghi"";
std::istringstream ss(input);
std::string token;

while(std::getline(ss, token, ',')) {
    std::cout &lt;&lt; token &lt;&lt; '\n';
}
</code></pre>
",0
25688852,25688830,1,"<p>Yes you can do it. Value will be copied.</p>

<p><em>Edited.</em>
Modern clever compilers can also use move semantics, you can read about this in other answers :)</p>
",2
25688856,25688830,1,"<p>Yes you can, it won't be destroyed it would be either be copied or moved. As to what of the two will happen it depends on the context that <code>ggg()</code> is being evoked.</p>

<p>For example if you call it like below:</p>

<pre><code>std:string h = ggg();
</code></pre>

<p>The returned <code>std::string</code> from <code>ggg()</code> is going to be elided/moved.</p>

<p>If you call it like below:</p>

<pre><code>std::string h;
...
h = ggg();
</code></pre>

<p>The returned value is going to be copied to <code>h</code>.</p>
",0
25688904,25688830,1,"<p>You could returned without any problem, it's correct code.</p>

<p>In <code>C++98</code> the recommendation was <strong>not do this with complex or big object</strong> because would be copied and have performance hit (the extra copy). In the specific case in question the copy almost sure would be elided by the compiler (see <a href=""http://en.wikipedia.org/wiki/Return_value_optimization"" rel=""nofollow"">RVO</a> to understand why, <em>note:</em> really old compiler don't have this optimization). But in more complex code (eg: more complex function body, more return statement, etc...), even returning the same type (<code>std::string</code>) the optimization could not be apply (this in performance sensitive code is a kill).</p>

<p>In <code>C++11</code> is much better if the compiler could be sure that the value would not be used anymore (eg: would be destroyed by out of scope, like this case and many other cases), would optimized and the value is moved (<em>normally more performant that copy</em>, <strong>note:</strong> sometimes copy is as performant as move, <em>eg:</em> a class with only POD members). In the specific case in question of returning a <code>std::string</code>, the move would be (in most implementations of STL) a copy of a couple of pointers.</p>

<p>In the specific case in question most probably would be the same code generated in <code>C++98</code> and <code>C++11</code>.</p>

<p>In <code>C++11</code> this case if perfect example of <a href=""http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html"" rel=""nofollow"">Move Semantic</a>.</p>
",5
24607083,24606773,0,"<p>Yes it is. You can allocate the memory flat and then do the copying (from an existing object) by hand. Or you use placement new operator to allocate/construct at a given location.</p>

<p>see: <a href=""https://stackoverflow.com/questions/222557/what-uses-are-there-for-placement-new"">using placement new</a></p>
",2
24607213,24606773,0,"<blockquote>
  <p>I need to move a lot of the class variables to be physically located in a memory mapped file. I could of course just have them as pointers and dereference them every time i need to use them but thats a lot of dereferencing and with all the brackets and other stuff just makes the code really hard to read. If there is any way around that I'll take it.</p>
</blockquote>

<pre><code>class ClassA
{
  public:
    ClassA(int* p_a, double* p_d) : a_(*p_a), d_(*p_d) { }

    int&amp; a_;
    double&amp; d_;
};
</code></pre>

<p>Then you can create an instance like this:</p>

<pre><code>ClassA my_a(ptr_to_a_in_shmem, ptr_to_d_in_shmem);
</code></pre>

<p>And write code (member functions or otherwise) that opererates on <code>a_</code> and <code>d_</code> thereby accessing/modifying shared memory.</p>
",0
24607851,24606773,0,"<p>If I understand your question correctly you just want to use <code>pineapple</code> as an alias for <code>*replacementPineapple</code>. You can do this by first creating the latter, and defining <code>pineapple</code> to be of reference type (marked by <code>&amp;</code>)</p>

<pre><code>ClassA* replacementPineapple = new ClassA();
ClassA&amp; pineapple = *replacementPineapple;
</code></pre>

<p>Now every (read or write) access to a member of <code>pineapple</code> will actually access the corresponding member of <code>*replacementPineapple</code>. Only if you should  at some time modify the pointer <code>replacementPineapple</code> to point elsewhere (or become null) then <code>pineapple</code> will still refer to the object it originally pointed to, and there is no way you can make it follow.</p>
",1
21185242,21185020,1,"<p>I can't answer for your compilation errors, since you've not posted them, but if you've got access to C++11 then you could use the <a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow"">std::function</a> class to simplify dealing with the callbacks/listeners:  </p>

<pre><code>class EventArgs
{
public:
    void* m_object; 
public:
    EventArgs(void* obj)
    {
        m_object = obj;
    }
};

template&lt;typename T&gt;
class Event
{
  std::vector&lt;std::function&lt;void(T&amp;)&gt; m_EventHandlers;

public:

  void addListener(std::function&lt;void(T&amp;)&gt; handler)
  {
    m_EventHandlers.push_back(handler)
  }

  void removeListener(std::function&lt;void(T&amp;)&gt; handler)
  {
    // etc etc
  }

  virtual void fire(EventArg &amp;args)
  {
    for(auto handler : m_EventHandlers)
    {
      handler(args);
    }
  }
};
</code></pre>

<p>Now you can say:</p>

<pre><code>Event event;
event.addListener([](Event &amp;e){std::cout &lt;&lt; ""got an event"";})
</code></pre>

<p>NOTE: I've changed the event argument to a reference to indicate that there's always and event object. If it's valid for there not to be (which seems unlikely) then turn it back to a pointer. I've left it as non-const to allow the handlers to modify the data in the event, which is more in line with how C# events work.</p>
",2
24763939,24763854,1,"<p><code>option::Option options[stats.options_max], buffer[stats.buffer_max];</code></p>

<p>Arrays must have size known at compile time. Use vectors intsead.</p>

<p><code>vector&lt;option::Option&gt; options(stats.options_max), buffer(stats.buffer_max);</code></p>
",2
26204193,26204171,0,"<blockquote>
  <p><em>""According to my understanding this code will result in a memory leak, am I wrong?""</em></p>
</blockquote>

<p>No you're right, there should be a <code>delete</code>. Though the memory leak usually doesn't matter, since the OS will reclaim all memory allocated from the process after <code>return 0;</code>.</p>
",0
26204194,26204171,1,"<p>There is indeed a memory leak. It lasts from the return of <code>main</code> to the exit of the program, which in this case is very, very short.</p>
",0
21324552,21323163,0,"<p>It looks suspicious to me that you declare <code>srcFan</code> (and <code>destFan</code>) as <code>shared_ptr</code> and you get its value by </p>

<pre><code>srcFan = connectedFans[sourceFan];
</code></pre>

<p>What is in <code>connectedFans</code>? Array/vector of <code>shared_ptr</code>? or simply array/vector of ordinary pointer (I bet this is the case).</p>

<p>If it is the latter case, it is going to cause problem: because <code>srcFan</code> think it has ownership of the referred object, and when it goes out of scope, it delete that.  Then the next time you access <code>connectedFans[sourceFan]</code>, you are accessing some freed piece of memory which will cause seg fault.</p>
",1
31302086,31301965,12,"<p>You should not <code>#include</code> cpp's into the main <code>hashtableimp.cpp</code>, if you want to list them on <code>g++</code> command line.</p>

<p>Actually you have two options here:</p>

<ul>
<li>Include <em>all</em> your code into one file (or split the code into several files and <code>#include</code> it one into another, so that it is effectively one file) ¡ª in such a case you need to list only this main file in <code>g++</code> command line</li>
<li>Really split code across several files ¡ª then you list all these files on a <code>g++</code> command line, but you do not need to <code>#include</code> files with definitions (usually cpp) into other files.</li>
</ul>

<p>The reason is <a href=""https://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""noreferrer"">One Definition Rule</a>: any function (with some exceptions) should be defined in one place in the whole program. If you <code>#include</code> one cpps into anothers, and then compile all of them, you repeat definitions.</p>

<p>Usually the former approach is used for small programs, and the latter for lager projects. Even more commonly, in latter approach you usually compile each file one by one, and then link them together.</p>

<p>Also note that you do not usually need to list <code>.h</code> files in the command line, they should not be compiled by themself, they are just to be <code>#include</code>d into other <code>.cpp</code> files so that the compiler knows the declaration of functions/objects/etc used there.</p>
",2
21314674,21314596,2,"<p>Yes, the built-in <code>=</code> operator must have an lvalue as its left operand. However, this isn't the built-in <code>=</code> operator, as much as it looks like it. Instead it's a call to the function <code>operator=</code> and is equivalent to:</p>

<pre><code>std::tie(iter, inserted).operator=(set_of_s.insert(value));
</code></pre>

<p>The class member access operator <code>.</code> does not need its left operand to be an lvalue, so everything is okay.</p>

<p>Side note: don't confuse the value category of expressions with the lvalue/rvalue reference types. The assignment operator could very well have the name of an rvalue reference as its left operand, because the expression that is its name is an lvalue.</p>
",7
21315176,21314596,2,"<blockquote>
  <p>What functions can be applied to rvalues?</p>
</blockquote>

<p>An <em>rvalue</em> can be</p>

<ul>
<li>passed as the <code>this</code> argument of a member function</li>
<li>passed by value</li>
<li>passed by <code>const</code> <em>lvalue</em> reference</li>
<li>passed by <em>rvalue</em> reference.</li>
</ul>

<p>It can't be passed by non-const <em>lvalue</em> reference.</p>

<blockquote>
  <p>How this works?</p>
</blockquote>

<p>The overloaded assignment operator is a member function, so can be called on an <em>rvalue</em>.</p>

<blockquote>
  <p>I thought assignment operators can only apply to lvalue?</p>
</blockquote>

<p>That's the case with built-in assignment operators. Overloaded operators are functions, and follow the same rules as functions.</p>
",0
24584544,24584493,3,"<p>Simply use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string"" rel=""nofollow""><em><code>std::to_string</code></em></a> <sup><strong><em>C++11</em></strong></sup></p>

<pre><code>throw std::invalid_argument(""The key "" + 
                             std::to_string( key ) + 
                            "" is not set."");
</code></pre>
",2
24585865,24584493,1,"<p>An alternative solution is to create your own exception class with a constructor that takes a <code>uint64_t</code> and creates the error message by itself:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;stdexcept&gt;
#include &lt;exception&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class MyException : public std::invalid_argument
{
private:
    static std::string GetMessage(uint64_t key)
    {
        std::ostringstream err;
        err &lt;&lt; ""The key "" &lt;&lt; key &lt;&lt; "" is not set."";
        return err.str();
    }
public:
    MyException(uint64_t key) :
        std::invalid_argument(GetMessage(key).c_str()) {}
    virtual ~MyException() throw() {}
};

int main()
{
    try
    {
        throw MyException(123);
    }
    catch (std::exception const &amp;exc)
    {
        std::cout &lt;&lt; exc.what() &lt;&lt; ""\n"";
    }
}
</code></pre>
",3
23082744,23082631,4,"<p>You are returning a reference to a local variable in <code>foo1</code> and <code>foo2</code>(<code>s1</code> and <code>s2</code> respectively) this is not allowed and using the reference will invoke undefined behavior. </p>
",9
23082778,23082631,2,"<p>You are returning references to local variables in both foo1 and foo2. These variable are limited in scope to the body of the functions in which they are defined. They disappear as soon as the function returns, so attempts to reference them after this cause your program to crash.</p>
",1
25470343,25470312,0,"<p>And easier and more readable construct would be like this:</p>

<pre><code>int maximum(int a, int b, int c) {
    int max = a; 

    if (b &gt; max) { 
        max = b;
    }

    if (c &gt; max) { 
        max = c;
    } 

    return max; 
}
</code></pre>

<p>or even shorter</p>

<pre><code>    if (a&gt;= b&amp;&amp; a&gt;= c)
            cout &lt;&lt; ""The largest number is£º"" &lt;&lt; a&lt;&lt; endl;
    else if (b&gt; =a&amp;&amp; b&gt; =c)
            cout &lt;&lt; ""The largest number is£º"" &lt;&lt; b&lt;&lt; endl;
    else if (c&gt;= a&amp;&amp; c&gt; =b)
            cout &lt;&lt; ""The largest number is£º"" &lt;&lt; c&lt;&lt; endl;
</code></pre>
",5
25470355,25470312,0,"<p>it's a simple matter of formatting your code properly, including:</p>

<ul>
<li>aligning <code>{</code> and <code>}</code> properly</li>
<li>being consistent with indentation</li>
</ul>

<hr>

<pre><code>int a,b,c,max;

cout&lt;&lt;""Please enter value 1: \t"";
cin&gt;&gt;a;

cout&lt;&lt;""Please enter value 2: \t"";
cin&gt;&gt;b;

cout&lt;&lt;""Please enter value 3: \t"";
cin&gt;&gt;c;

if(a&gt;b) {
    if(a&gt;c)
        max=a;
} else if(b&gt;a) {
    if(b&gt;c)
        max=b;
} else if(c&gt;a) {
    if(c&gt;b)
        max=c;
}

cout&lt;&lt;""The Max value among the given value is:\t""&lt;&lt;max;
</code></pre>
",0
28436931,28436820,3,"<p>Member variables are initialized in constructor's initialization list (before body) so you need to do that:</p>

<pre><code>B::B(A &amp;a)
    : c(a) // Calls constructor C(a) on member c
{}
</code></pre>
",1
28436958,28436820,1,"<blockquote>
  <p><em>""How do I get the injected A to B's member C?""</em></p>
</blockquote>

<p>You can do so using <code>B</code>'s constructor member initializer list</p>

<pre><code>class B {
public:
    B(A &amp;a) : c(a) {
           // ^^^^
    }

    C c; // &lt;&lt;&lt; It's not possible to initialize members in their
         //     declaration.
};
</code></pre>
",1
28437027,28436820,3,"<p>You almost have it:</p>

<pre><code>class B {
public:
    B(A &amp;a);

    C c(a); //see note 1
};

B::B(A &amp;a) : a(a) { //see note 2
}
</code></pre>

<h2>Note 1:</h2>

<p>There are two problems with <code>C c(a);</code> here:</p>

<ol>
<li><code>a</code> is not in scope. <code>a</code> only exists within the scope of the constructor, so <code>c</code> needs to be initialized from there.</li>
<li>Until C++11, non-static data member initializers (NSDMIs) were prohibited. Even in C++11, though, you must use an equals sign (<code>C c = value;</code>) or braces (<code>C c{value};</code>) when initializing an NSDMI.</li>
</ol>

<h2>Note 2:</h2>

<p>You've almost got this right:</p>

<pre><code>B::B(A &amp;a) : a(a)
</code></pre>

<p>You're trying to initialize a data member called <code>a</code> with the argument given to the constructor. You actually want to initialize <code>c</code> like this, not a non-existent <code>a</code>:</p>

<pre><code>B::B(A &amp;a) : c(a)
</code></pre>

<hr>

<p>The lifetime of <code>c</code> will be that of the instance of the <code>B</code> class. Using dynamic memory management is certainly not necessary.</p>
",1
28437081,28436820,1,"<p>The following:</p>

<pre><code>C(A &amp;a) : a(a) {}
</code></pre>

<p>will not compile since <code>a</code> (the first <code>a</code> in the initialization list) is not a member variable of <code>C</code>.</p>

<p>Same applies to the constructor of <code>B</code>.</p>
",1
23825477,23825358,4,"<pre><code>m_mean = (m_cntr * m_mean + valIn) / ++m_cntr;
        ^^^^^^^^^                   ^^^^^^^^^^
         READING                     WRITING
</code></pre>

<p>You are reading and writing a variable without a <a href=""http://en.wikipedia.org/wiki/Sequence_point"" rel=""nofollow noreferrer"">sequence point</a> between the operations. This can be rearranged by your compiler and thus it is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">Undefined Behaviour</a> :D</p>

<p><strong>EDIT</strong>:
complementing a little bit, you'll have less floating point error accumulation if you use:</p>

<pre><code>m_mean += (valIn - m_mean) / ++m_cntr;
</code></pre>

<p>(see <a href=""https://math.stackexchange.com/questions/106700/incremental-averageing"">here</a>) <strong>AND</strong> you'll avoid the Undefined Behaviour.</p>
",1
23825483,23825358,2,"<p>The GNU compiler collection (GCC) since 4.6.3 warns when the sequence order of operations is ambiguous.</p>

<p>Since you are modifying m_cntr in denominator and using this value in calculations in numerator, it is not obvious what will be done (i.e. which part of this fraction will be calculated earlier). So, it is better to avoid such constructions.</p>
",0
23825532,23825358,3,"<p>Let us simplify your code to identify the problem:</p>

<pre><code>a = 0;
b = a / ++a;
</code></pre>

<p>What division is performed exactly in line 2? You are probably thinking that it must be:</p>

<pre><code>b = 0 / 1;
</code></pre>

<p>When in fact the compiler is free to evaluate <code>++a</code> first and <code>a</code> second, giving you:</p>

<pre><code>b = 1 / 1;
</code></pre>

<p>So what does the code do? The technical term is ""undefined behavior"", but all you need to remember is ""don't increment a variable and use it again in the same expression"".</p>

<p>Regarding your design, it would probably make much more sense to have two data members <code>counter</code> and <code>sum</code> and defer the division to a member function called <code>calculateMean</code> or something. Then you don't have to multiply and divide (I smell precision problems!) every time <code>addValue</code> is called.</p>
",7
26801924,26801023,1,"<pre><code>(find_bit((k-3)/2)&amp;1)
</code></pre>

<p>is either 0 or 1.</p>

<p>I think you misplaced your parentheses and that you're looking for</p>

<pre><code>(marks[find_container((k-3)/2)] &gt;&gt; find_bit((k-3)/2)) &amp; 1
</code></pre>

<p>I would recommend that you add abstracting functions for manipulating bits, it makes the code much more readable and less error-prone.<br>
Something like this.</p>

<pre><code>// No safety, for clarity
void set(unsigned long int* bits, size_t which)
{
   bits[find_container(which)] |= 1 &lt;&lt; find_bit(which);
}

bool get(unsigned long int* bits, size_t which)
{
   return (bits[find_container(which)] &gt;&gt; find_bit(which)) &amp; 1;
}

// example
if (!get(marks, k))
{
    set(marks, k);
}
</code></pre>
",0
26801334,26801023,0,"<p>Well, yes, you can use any value in an if and values not equal to zero are considered true.</p>

<p>But how you can tell what all that code is doing is beyond me. The chances of that having a bug are high.</p>

<p>I'd suggest writing some individual functions to read/clear/set a particular bit in your array. Then it should become clearer what you are doing.</p>

<p>Incidentally, if this is c code, you shouldn't be casting the result of calloc. If on the other hand, it is C++ code, you shouldn't be using C-style casts.</p>
",0
22505529,22491506,1,"<p>I found the culprit.<br>
What happens if the vector grows? It can reallocate its contents so <code>el</code> will no longer point to the i-th element of the vector, it will point to some location in memory whose meaning is unknown.</p>

<p>The instruction</p>

<pre><code>pair&lt;int, int&gt;* el = &amp;(*multigraph)[i];
</code></pre>

<p>is dangerous. It takes the address of an element in a vector.<br>
The <code>push_back</code> instruction triggered a reallocation so calling <code>el-&gt;first</code> <em>after</em> it was no longer correct.<br>
Reading the values from under <code>el</code> <em>before</em> making changes to the vector fixed the issue.</p>
",0
32414467,32414448,6,"<p>As per ¡ì5.18/1:</p>

<blockquote>
  <p>The assignment operator (=) and the compound assignment operators all group right-to-left. All require a modifiable lvalue as their left operand and return an lvalue referring to the left operand. [...]</p>
</blockquote>

<p>So, in</p>

<pre><code>g(i = ci)
</code></pre>

<p>the left operand, <code>i</code>, is returned and therefore <code>T</code> is deduced to <code>int&amp;</code>.</p>

<p>You can check this via this snippet:</p>

<pre><code>#include &lt;type_traits&gt;

template &lt;typename T&gt; 
void g(T &amp;&amp;val) {
    static_assert(std::is_same&lt;T, int&amp;&gt;::value, ""Nope"");
}

int main() {
    int i = 0; const int ci = i;
    g(i = ci);
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/bb8d006d78558c19""><kbd>Live demo</kbd></a></p>
",0
23834027,23833860,0,"<p>In your read function, the parameter <code>_data</code> is not used, so it won't modify anything. It should be:</p>

<pre><code>void Read(void* _data, size_t _size, int _position) 
{
  memcpy(_data, m_data + _position - _size, _size);
}
</code></pre>

<p>Also, the code to output variable <code>result</code> doesn't make sense, should just be:</p>

<pre><code>cout &lt;&lt; result &lt;&lt; endl;
</code></pre>

<p>As the program is not the complete program, I don't know if there're still other errors</p>
",0
23834110,23833860,3,"<p>""What am I doing wrong?"" - Pretty much everything:</p>

<p>To begin with, both <code>Read</code> and <code>Write</code> functions end with a memory leak, as the allocated-memory pointed by the <code>data</code> local variable is ""lost"" (no one ""knows"" the address after the function returns).</p>

<p>In addition, what exactly are you expecting to get by casting <code>(int*)result</code>? It is most certainly not going to be a valid memory address which you can then safely dereference using <code>*((int*)result)</code>.</p>
",3
21161606,21161581,2,"<p>It's more likely to be an <code>enum</code>, but okay.</p>

<p>Inside <code>Fight</code> will be:</p>

<pre><code>enum Something
{
   CLOSE, RANGE
};
</code></pre>

<p>Then <code>Fight::CLOSE</code> and <code>Fight::RANGE</code> are integral constants with distinct values.</p>

<p><strong>Read about <em>enums</em> (""enumerated types"") in your C++ book.</strong></p>

<p>The <code>::</code> syntax is (in this context) the way you access static members of the class. For example, you invoke static member functions like <code>Fight::someFunc()</code>.</p>
",0
21161609,21161581,1,"<p>It is a static member of the class <code>Fight</code>.</p>
",0
21161635,21161581,3,"<p><code>Fight</code> must be a <code>class</code> or a <code>struct</code> (probably a struct), so <code>CLOSE</code> is either a public constant or a value from an <code>enum</code> declared inside that class. That is:</p>

<pre><code>class Fight {
public:
    const bool CLOSE = false;
    //...
};
</code></pre>

<p>or</p>

<pre><code>class Fight {
public:
    enum Status {
        CLOSE
    }
    //...
};
</code></pre>

<p>Since you said that ""c.type is a bool or an int"", I think the first one is more likely to be the definition of your <code>Fight</code> class.</p>
",0
21161718,21161581,0,"<p>It's a name that is declared in the scope of the <code>Fight</code> class. It probably should be declared as an enum.</p>

<pre><code>struct Fight {
    enum Status {
        CLOSE,
        RANGE
    }

    Status type;
    //...
}
</code></pre>

<p>Enums export their names (<code>CLOSE</code>, <code>RANGE</code>) to the enclosing scope, i.e. the scope of the class in this case. When converted to <code>int</code>, <code>CLOSE</code> will yield 0 and <code>RANGE</code> will yield 1. (With this order of declaration)</p>
",0
21161825,21161581,0,"<p>It could be one of the following
<br><br></p>

<blockquote>
  <ol>
  <li>enum nested in a class . <br></li>
  <li>static data member under public. <br></li>
  <li>int/bool public data member.   <br></li>
  </ol>
</blockquote>
",0
29173644,29173610,1,"<p>You need to call your function</p>

<pre><code>myAirport.getCode()
</code></pre>

<p>instead of</p>

<pre><code>myAirport.getCode
</code></pre>
",0
29173650,29173610,3,"<pre><code>cout &lt;&lt; myAirport.getCode() &lt;&lt; endl;
</code></pre>

<p>Note the parenthesis needed to call the function. The reason for requiring the () to be there is that a function named without them actually has a valid meaning and it is quite different to calling the function.</p>
",0
29173658,29173610,1,"<p>You're missing the () in the </p>

<pre><code>cout &lt;&lt; myAirport.getCode &lt;&lt; endl;
</code></pre>

<p>after getCode ,should be getCode()</p>
",0
31843278,31843161,0,"<p>I did not check the quote but I think this example will be relevant</p>

<pre><code>#include &lt;iostream&gt;

namespace N1
{    
struct A
{
    static int x;
};
}    

using N1::A;

int x = 10;
int N1::A::x = 20;

int A = 30;

int main()
{

    std::cout &lt;&lt; A::x &lt;&lt; std::endl;
}    
</code></pre>

<p>The program output is</p>

<pre><code>20
</code></pre>

<p>The words <strong>within the same scope</strong>  are ambiguous. So you can consider a modified example</p>

<pre><code>#include &lt;iostream&gt;

namespace N1
{    
struct A
{
    static int x;
};

int A = 30;
}    

using N1::A;

int x = 10;
int N1::A::x = 20;

int main()
{

    std::cout &lt;&lt; A::x &lt;&lt; std::endl;
}    
</code></pre>

<p>In the both programs the declaration of the object A of type int </p>

<pre><code>int A = 30;
</code></pre>

<p>hides the declaration of <code>struct A</code>.</p>
",2
31862004,31843161,1,"<p>This is a resolution of <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#400"" rel=""nofollow"">CWG 400</a> (which references <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1996/N0905.pdf"" rel=""nofollow"">N0905</a>) which questions if the following code was well-formed:</p>

<pre><code>struct A { int i; struct i {}; };
struct B { int i; struct i {}; };
struct D : public A, public B { using A::i; void f (); };
void D::f () { struct i x; }
</code></pre>

<p>The bullet point was added to the standard to make it clear that <code>using A::i</code> brings in <em>both</em> <code>struct i { }</code> <em>and</em> <code>int i</code> into <code>D</code>, such that <code>struct i x</code> is well-formed. </p>
",0
25670666,25670595,8,"<p>A template function would probably serve you well. The method:</p>

<pre><code>template&lt; typename T &gt; void Buffer::setData(T data)
{
    //Bind the buffer
    bind();

    //Input the data into the buffer based on the type
    glBufferData(type, sizeof(T) * size, data, GL_DYNAMIC_DRAW);
}
</code></pre>

<p>defines a family of methods, one for every type <code>T</code>. Of course, it might not actually <em>work</em> for all types <code>T</code>, but fortunately C++ will only complain when you call it with an incompatible type.</p>
",4
26210409,26210250,0,"<p>Whoops, I just realized that this actually <em>is</em> expected. After my main function (where the object is being instantiated and inserted into) exits, the deconstructor gets called automatically. This does not happen when object is created on the heap, unless I explicitly call delete.
It happened only during insert because of a function that checks if the root is not NULL before going through with deconstructing the object. If there is no insert, the root is NULL, and function just exits.</p>

<p>Thanks a lot.</p>
",0
26210448,26210250,1,"<p>This is how destructors work in C++</p>

<p>Automatic objects' destructors are called automatically. Dynamically allocated objects require you to <code>delete</code> them.</p>
",0
21584977,21583892,0,"<p>You may create class:</p>

<pre><code>class PrefixLog
{
public:
    explicit PrefixLog(const char* prefix) : prefix(prefix) {}
    template &lt;typename T&gt;
    log&amp; operator &lt;&lt; (const T&amp; t) const { return l &lt;&lt; prefix &lt;&lt; t &lt;&lt; &amp;log::end; }
private:
    const char* prefix;
};

PrefixLog error(""ERROR "");
PrefixLog warning(""WARN "");
</code></pre>

<p>And then</p>

<pre><code>warning &lt;&lt; y;
error &lt;&lt; y;
</code></pre>
",0
21584028,21583892,0,"<p>What about:</p>

<pre><code>#define LOG(Msg) do { l &lt;&lt; Msg &lt;&lt; ::std::endl; } while(0)

Log(""Hello"" &lt;&lt; ""World"");
</code></pre>

<p>Note: I use a macro like this in debug builds and make it ((void)0) in release builds.</p>

<p>For common logging you should not use a macro and may consider stream manipulators.</p>
",0
21584238,21583892,1,"<p>Look like you are reinventing the square wheel to me ! Indeed, there are a lot of logger library out there (<a href=""http://www.boost.org/doc/libs/1_54_0/libs/log/doc/html/log/detailed/sources.html"" rel=""nofollow noreferrer"">boost.log</a> is a good one). Another solution is to have the user write the standard syntax including the call to <code>std::endl</code>:</p>

<pre><code>error &lt;&lt; x &lt;&lt; std::endl; 
warn &lt;&lt; y &lt;&lt; std::endl;
</code></pre>

<p>You can do that by passing a string <code>""warn""</code> or <code>""error""</code> to the construtor of class <code>log</code>. 
You have to intercept the <code>std::endl</code> parameter as described in  <a href=""https://stackoverflow.com/questions/2212776/overload-handling-of-stdendl"">Overload handling of std::endl?</a>.</p>
",0
21584713,21583892,0,"<p>One option would be to remove your global variable and use your destructor to write the newline by having the macros create a scope so the object is destroyed:</p>

<pre><code>#define error( z )      {log l; l &lt;&lt; ""ERROR "" z; }
#define warn( z )       {log l; l &lt;&lt; ""WARN "" z; }
</code></pre>

<p>That would yield code close to what it appears you want without your end macro:</p>

<pre><code>int y = 20, z = 40;
error ( &lt;&lt; y &lt;&lt; "" "" &lt;&lt; z);
</code></pre>

<p>If you like that approach you might want to look into improving the macro so log levels are enforced in the macro itself so objects are not created with every log message that have nothing to do, if performance at that level matters to you.</p>

<p>Don't see a plug for POCO logging anywhere in here, that's what I use.  Not saying that would work for you, it's just what I like for my particular needs.</p>
",0
25504707,25504050,-3,"<p>If you want to allocate and zero-initialize in one step, only <code>calloc()</code> or <code>new T[n]()</code> will do.  The others leave uninitialized ""garbage"" in the array, which of course may happen to be zero sometimes.  Please don't ask why it's zero in one build and non-zero in another, it's just undefined, it could be anything, including the beginning of the bible or a state secret.</p>

<p>You can also use <code>memset()</code> to zero all the bytes at once.  Don't use <code>memcpy()</code> to copy single bytes in a loop--that's a massive pessimization.</p>
",3
25506866,25504050,1,"<p>Based on the comments it appears the problem is somewhere else in the code.  One thing you may want to check for is to see if byte packing is used anywhere (see <a href=""https://stackoverflow.com/questions/3318410/pragma-pack-effect"">#pragma pack effect</a>)</p>

<p>If byte packing is used make sure that all <code>#pragma pack(push,1)</code> have a matching <code>#pragma pack(pop)</code>.  If not (i.e. there is a dangling <code>#pragma pack(push,1)</code>) then, depending on which header files are included for a given source file, you could end up with the same data structure having a different size in different source files.</p>

<p>I spent days on some legacy code before figuring this out; if this helps, great.  If it is not useful I'll gladly remove it from this post.</p>
",2
28167803,28167604,2,"<p><code>friend int main(int,char**);</code> declares <code>main</code> in <code>namespace MyNamespace</code>. To declare a friend function from another namespace you have to fully specify the namespace, and that in turn requires <code>main</code> to be forward-declared:</p>

<pre><code>int main(int argc, char *argv[]);

namespace MyNamespace
{
    class MyClass: public QObject
    {
        friend int ::main(int,char**);
        //         ^^^^^^
    private:
        MyClass(QObject *parent = 0);  
    };
}

int main(int argc, char *argv[])
{
     MyNamespace::MyClass* mc = new MyNamespace::MyClass;
}
</code></pre>
",0
34233144,34233103,2,"<p>It is calling the default constructor using <a href=""https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization"" rel=""nofollow"">Uniform Initialization</a> introduced in C++11. </p>
",1
34233187,34233103,4,"<p>It is creating a (temporary) object of type <code>std::sregex_iterator</code> by calling its default constructor (using uniform syntax). Since C++14, the standard requires that all types that model the <code>ForwardIterator</code> concept be <code>DefaultConstructible</code> and that a default-constructed iterator represents a past-the-end iterator.</p>

<p>From <a href=""http://en.cppreference.com/w/cpp/concept/ForwardIterator"" rel=""nofollow"">cppreference</a>:</p>

<blockquote>
  <p><strong>Singular iterators <em>(since C++14)</em></strong></p>
  
  <p>A value-initialized <code>ForwardIterator</code> behaves like the past-the-end iterator of some unspecified empty container: it compares equal to all value-initialized <code>ForwardIterators</code> of the same type.</p>
</blockquote>

<p>So the complete <code>p!=sregex_iterator{};</code> statement checks whether the iterator <code>p</code> is not yet exhausted.</p>
",0
27140901,27140833,2,"<p>You are printing out the local variable <code>resultado</code> which is uninitialised in function <code>main()</code></p>

<p>What you might want to do is to print out the <strong>member variable</strong> in <code>Calculadora</code> using a member function.</p>

<p>The result from <code>cal.Sumar(a,b);</code> is being discarded, in this case you must assign the result to a local variable in your main function if you want to store the result.</p>
",1
27140903,27140833,0,"<pre><code>float Calculadora::Sumar(float a, float b) { ...
</code></pre>

<p>indicates that the function returns a value, yet you call it with:</p>

<pre><code>cal.Sumar(a,b);
</code></pre>

<p>effectively (assuming your <code>C+-</code> language is like C) throwing away the result.</p>

<p>You shoulkd be <em>storing</em> the result to print it out:</p>

<pre><code>resultado = cal.Sumar(a,b);
</code></pre>
",0
27140965,27140833,0,"<p>Of course, the solution was obvious (only when someone pointed out the silly mistake present in the code).</p>

<p>resultado = calc.Sumar(a,b);</p>

<p>Thanks!</p>
",0
23838225,23838194,8,"<p>You should only seed the random number generator once. Right now you are seeding it in the loop and using <code>time(NULL)</code> just means the seed changes once per second which gives you the bad output you have described.</p>

<p>DO this instead:</p>

<pre><code>int main()
{
    bool x = true;
    int num = 1;
    srand(time(NULL));
    while(x == true)
    {
        num = rand();
        cout&lt;&lt;num%10&lt;&lt;endl;
    }
}
</code></pre>

<p>And if you really care about the random numbers generated you might want to use something other than <code>rand()</code>. The reason is that <code>rand()</code> has poor statistical properties for pseudo random number generation, it is often implemented as a <a href=""http://en.wikipedia.org/wiki/Linear_congruential_generator"" rel=""nofollow"">Linear congruential generator</a>. If you need high quality randomness then you should prefer something else such as the new c++ random number generators <a href=""http://en.cppreference.com/w/cpp/numeric/random"" rel=""nofollow"">http://en.cppreference.com/w/cpp/numeric/random</a>.
In fact there's even a <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3924.pdf"" rel=""nofollow"">report on depreciating</a> the old <code>rand()</code> to try to push people to use the newer c++ standard library random functions.</p>

<p>In this particular case you take a modulus which causes a few subtle problems:</p>

<pre><code>num = rand();
cout&lt;&lt;num%10&lt;&lt;endl;
</code></pre>

<p>Even if <code>rand()</code> was perfect if the modulus here isn't a divisor of the maximum value returned by <code>rand()</code> you will get a non-uniform distribution as a result. Here's a quick explanation, say <code>rand()</code> returned values in the range of [0,25] then taking the modulus would do the following.</p>

<pre><code>before    after modulus 
[0-9]         [0-9]
[10-19]       [0-9]
[20-25]       [0-5]
</code></pre>

<p>You'll see that you are more likely to get [0-5] than [6-9] which means you now no longer have a uniform number being generated. Note that this small range is for educational purposes only, the maximum value of <code>rand()</code> is mandated by the standard to be at least 32767. However it illustrates an important point, the larger the maximum generated number the better.</p>

<p>This uniformity of distribution problem aside the modulus has the particularly insidious effect of decreasing the quality of the pseudo-randomness even further for some implementations.</p>

<p>Using <a href=""http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution"" rel=""nofollow""><code>std::uniform_int_distribution</code></a> avoids many problems so I would recommend changing your existing code to use the new library. Doing so would look like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;
using namespace std;

int main()
{
    std::default_random_engine generator;
    generator.seed( /* your seed for the RNG goes here */ );
    std::uniform_int_distribution&lt;int&gt; distribution(0,9);//note the min and max parameters are inclusive here
    while(true)
    {
        cout &lt;&lt; distribution(generator) &lt;&lt; endl;
    }

}
</code></pre>
",0
23838367,23838194,4,"<p>A function <code>f()</code> that would generate random numbers in range <strong>[low,high]</strong> can be easily, robustly and safely defined with c++11 library facilities : </p>

<pre><code>#include &lt;random&gt;
#include &lt;iostream&gt;

int f(int low, int high)
{
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; dis(low, high);

    return dis(gen);
}
</code></pre>

<p><code>std::uniform_int_distribution</code> will give you a random number in your range (eg (0,9) ) this way</p>

<p>On the rationale behind refraining from using the old <code>rand</code> you can check <a href=""https://stackoverflow.com/a/21519186/2567683"">this</a> </p>
",0
28172664,28171930,0,"<p>Let's rename some of your variables:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int i1;

void inc(int i2)
{
  i2++;
}

int main()
{
  for(int i3=0;i3&lt;10;inc(i3))
  {
    cout&lt;&lt;i3;
  }
  return 0;
}
</code></pre>

<p>Does that make it clear what's happening?</p>

<p>Nothing ever uses <code>i1</code>, it's completely pointless.</p>

<p>You increment <code>i2</code> but that's a local variable, completely separate from <code>i3</code>. Each time the loop runs you call <code>inc(i3)</code> which creates a new local variable called <code>i2</code> and copies the value of <code>i3</code> (which is always zero), increments the local variable then that variable goes out of scope and its lifetime ends. So your <code>inc</code> function has no side-effects and <code>i3</code> is never changed.</p>

<p>Your function should be <code>inc(int&amp; i)</code> so that it takes its argument by reference and can modify it.</p>
",0
28171999,28171930,2,"<p>You are passing <code>i</code> (declared in the loop) by value in <code>inc</code>, so <code>i</code> is not actually being incremented. You need to pass <code>i</code> by reference.</p>

<p>To do this, change</p>

<pre><code>void inc(int i) { 
   i++; 
}
</code></pre>

<p>to:</p>

<pre><code>void inc(int&amp; i) { 
   i++; 
}
</code></pre>

<p>This will pass the address of <code>i</code> (reference) to <code>inc</code>, which will increment the value stored at that address. </p>

<p>Here is your final code  </p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
int i;//no use of this variale
void inc(int&amp; i) { 
   i++; 
}

int main()
{
    for(int i=0;i&lt;10;inc(i))
    {
        cout&lt;&lt;i;
    }
    return 0;
}
</code></pre>
",10
28172422,28171930,1,"<p>You can do it simple way like this</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int main()
{
   for(int i=0;i&lt;10;i++)
   {
      cout&lt;&lt;i;
   }
  return 0;
}
</code></pre>
",0
26117237,26115748,0,"<p>As far as I can see only the first element of the first array element would be set to the value, so only because it is set to zero here would it be correct. If it had been '= {1}' and you expected all elements to be 1, it would fail as the elements would be {1,0,0,0 ... etc. }</p>

<p>I don't like the '=' because it looks like it would call an assignment operator (which is irrelevant for this structure but may be a problem in other cases).</p>

<p>If the array was a global its memory would be zeroed but that is accidental that the wanted values are zero. If the array was on the stack random values (whatever is on the stack) would populate the array.</p>

<p>Initialization in the age of C++14 its a bit more complicated.</p>

<pre><code>INPUT newline_input[4] {}; // empty value initialization
</code></pre>

<p>So use empty <a href=""http://en.cppreference.com/w/cpp/language/value_initialization"" rel=""nofollow"">value initialization</a> for your data which include a <code>union</code> syntax 4 is used</p>

<pre><code>T object {};
</code></pre>

<p>and then effect 3 followed by 2(C++14)</p>

<pre><code>3) If T is an array type, each element of the array is value-initialized
2) If T is a class type without a user-provided or deleted default constructor (that is, it may be a class with a defaulted default constructor or with an implicitly-defined one) then the object is zero-initialized and then it is default-initialized if it has a non-trivial default constructor   (since C++14)
</code></pre>

<p>Which should then call <a href=""http://en.cppreference.com/w/cpp/language/zero_initialization"" rel=""nofollow"">zero-initialization</a>.</p>

<p>These unions with unknown content is a problem when they are provided without constructors as the programmer would have to know how to put them into a well defined state.</p>

<p>Using list initialization looks too much like assignment and </p>

<pre><code>INPUT newline_input[4] = {0};
or
INPUT newline_input[4] = {};
</code></pre>

<p>It will use syntax 10 in <a href=""http://en.cppreference.com/w/cpp/language/list_initialization"" rel=""nofollow"">List initialization</a> followed by <a href=""http://en.cppreference.com/w/cpp/language/aggregate_initialization"" rel=""nofollow"">aggregate initialization</a> as INPUT is an array/struct/union. And since the number of initializer clauses is less than the array length, this effect will be used</p>

<blockquote>
  <p>If the number of initializer clauses is less than the number of
  members or initializer clauses is completely empty, the remaining
  members are initialized by their brace-or-equal initializers, if
  provided in the class definition, and otherwise (since C++14) by empty
  lists, which performs value-initialization. If a member of a reference
  type is one of these remaining members, the program is ill-formed
  (references cannot be value-initialized)</p>
</blockquote>

<p>But members of the standard comity has moved away from this form [link to where Bjarne S. says so] to the value initializing.</p>
",9
26115814,26115748,3,"<p>Your code will work, even better is this:</p>

<pre><code>INPUT newline_input[4] = {};
</code></pre>
",1
24091295,24091222,1,"<p>I have to agree with you and juanchopanza: accessing objects via a single singleton object throughout an entire project is a poor practice since modules are supposed to have few and well-stated dependencies among them (ideally: <strong>interfaces</strong> or means of communication).</p>

<p>Also: it's easy to violate the <a href=""https://en.wikipedia.org/wiki/Single_responsibility_principle"" rel=""nofollow"">single responsibility principle</a>.</p>

<p>There's no ""do X instead of the singleton approach"" solution, or no silver bullet: sometimes a singleton can really be useful but if possible: avoid it and design a clear interface instead.</p>

<p>Also: there isn't enough information in your question to state something more specific.</p>
",2
28182565,28180120,0,"<p>I suggest you use <code>toupper()</code> or <code>tolower()</code> to convert the character to upper case or lower case so you only do one compare.</p>

<p>Secondly, if the file is not extremely huge, read the words into a vector of strings, e.g. <code>std::vector&lt;string&gt;</code>.  </p>

<p>Input the player string.
Iterate through the vector, using <code>==</code> or <code>!=</code> to compare the player's text to the words from the file.  </p>

<p>An option is to sort the words in the vector and use something like <code>std::lower_bound</code> to find the words.  If the vector is sorted, you don't have to search the entire contents.</p>
",0
21301986,21301939,2,"<p>A function prototype in C++ is simply a function declaration. So in your case it could be</p>

<pre><code> int difference(int n1, int n2);
</code></pre>
",0
21302047,21301939,1,"<p>function prototype:</p>

<pre><code>int difference(int,int);
</code></pre>

<p>function definition:</p>

<pre><code>int difference(int a,int b)
{
 return abs(a-b);
}
</code></pre>
",0
25684566,25684085,0,"<p>You can try something similar to the code below</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;


int main() 
{
    std::vector&lt;std::vector&lt;std::string&gt;&gt; v = 
    {
        { ""1"", ""a"", ""aa"" },
        { ""2"", ""b"", ""bb"" },
        { ""3"", ""c"", ""cc"" },
        { ""4"", ""d"", ""dd"" }
    };

    std::vector&lt;std::string&gt;::iterator second;
    std::string s = ""c"";

    auto first = std::find_if( v.begin(), v.end(),
        [&amp;]( std::vector&lt;std::string&gt; &amp;v1 )
        {
            return (( second = std::find( v1.begin(), v1.end(), s ) ) != v1.end() ); 
        } );

    if ( first != v.end() )
    {
        size_t i = std::distance( v.begin(), first );
        size_t j = std::distance( v[i].begin(), second );

        std::cout &lt;&lt; v[i][j] &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>

<p>The output is</p>

<pre><code>c
</code></pre>
",2
25685253,25684085,1,"<p>If you specificially want to search the 2nd column of the inner vector you can use a <code>transform_iterator</code> and regular <code>find</code>.</p>

<p><code>transform_iterator</code> is in <code>boost</code> would look something like:</p>

<pre><code>std::vector&lt; std::vector&lt; std::string &gt; &gt; v;
auto lambda = [] ( std::vector&lt; std::string &gt; const&amp; v ) { return v[1]; };

auto transform_end = boost::make_transform_iterator ( v.end() ); 
return std::find( boost::make_transform_iterator( v.begin(), lambda ), 
          transform_end, ""c"" ) != transform_end;
</code></pre>

<p>If your inner lambda is to find <code>""c""</code> in any position I wouldn't use transform iterator here as we want to return a true/false on each inner vector, not just some transformed value, and we would use find_if on the outer-vector and find on the inner one</p>

<pre><code>std::string val = ""c"";
auto lambda = [ const &amp; ]( std::vector&lt; std::string &gt; const&amp; vInner )
       { return std::find( vInner.begin(), vInner.end(), val ) != v.end(); } ;

return std::find_if( v.begin(), v.end(), lambda );
</code></pre>
",2
25686924,25684085,0,"<p>You can do this:</p>

<pre><code>int column = 1; // Set this to the column you need to search;
string target( ""c"" ); // Set this to the value you need to find
auto found = find_if( myvect.begin(), myvect.end(), [=]( vector&lt; string &gt; row ){ return row[column] == target; } );

cout &lt;&lt; ( found == myvect.end() ? ""not found"" : ( *found2 )[column] ) &lt;&lt; endl;
</code></pre>

<p>C++11 wont let you define <code>column</code> or <code>target</code> in the capture, if you want to avoid intermediate variables in C++11 though, you can do this, it's just ugly cause of the <code>static_cast</code>. You'd just have to set the <code>""c""</code> and <code>1</code> to the <code>target</code> and <code>column</code>:</p>

<pre><code>auto found = find_if( myvect.begin(), myvect.end(), bind( equal_to&lt; string &gt;(), ""c"", bind( static_cast&lt; const string&amp;( vector&lt;string&gt;::* )( size_t ) const &gt;( &amp;vector&lt; string &gt;::operator[] ), placeholders::_1, 1 ) ) );
</code></pre>

<p>I personally would suggest that if your row size is always the same that you put it in a single <code>std::vector</code> like this: <code>vector&lt;string&gt; myvect = { ""1"", ""a"", ""aa"", ""2"", ""b"", ""bb"", ""3"", ""c"", ""cc"", ""4"", ""d"", ""dd"" };</code> if you do that you can write a template to search for you which will have significantly more flexibility:</p>

<pre><code>template&lt; typename T, int stride &gt;
T* templateFind( const vector&lt; T &gt;&amp; myvect, const T&amp; target, int column )
{
    typedef array&lt; T, stride &gt; rowSize;

    rowSize* end = ( rowSize* )( &amp;*( myvect.begin() ) ) + ( myvect.size() / stride );
    rowSize* result = find_if( ( rowSize* )( &amp;*( myvect.begin() ) ), end, [&amp;]( rowSize row ){ return row[column] == target; } );

    return result == end ? nullptr : ( ( T* )result ) + column;
}
</code></pre>

<p>And use it like this:</p>

<pre><code>string* found = templateFind&lt; string, 3 &gt;( myvect, ""c"", 1 );

cout &lt;&lt; ( found == nullptr ? ""not found"" : *found ) &lt;&lt; endl;
</code></pre>
",0
23070443,23067857,0,"<p>The issue is more than likely you're assuming that float** has data that is one contiguous chunk of memory.  If so, here is one way of accomplishing this.  First, I show the wrong way (but used often):</p>

<pre><code>float** createFloat2D(int nRows, int nCols)
{
    float** p1 = new float*[nRows];
    for (int i = 0; i &lt; nCols; ++i )
       p1[i] =  new float[nCols];
    return p1;
}

void destroyFloat2D(float**f, int nRows, int nCols)
{
   for (int i = 0; i &lt; nCols; ++i )
       delete [] f[i];
   delete [] f;
}
</code></pre>

<p>Looks simple, and works for most purposes, but will fail if the assumption is made that the data is in a contiguous chunk of memory.  </p>

<p>The other way to create a 2D array is to make the data contiguous.</p>

<pre><code>float** createFloat2D(int nRows, int nCols)
{
    float** p1 = new float*[nRows];  // allocate row pointers
    float* p2 = new float[nRows * nCols];  // allocate data in one chunk
    for (int i = 0; i &lt; nCols; ++i, p2 += nCols )
       p1[i] = p2;  // point the row pointers into the pool of memory
    return p1;
}

void destroyFloat2D(float**f)
{
   delete [] f[0];
   delete [] f;
}
</code></pre>

<p>Note above that the data is created in one contiguous ""pool"".  Now, using <code>yourArray[0]</code> actually points to the beginning of this memory.  Also note that destruction is done without having to know the number of rows or columns, since f[0] points to the pool of memory.</p>

<p>So now, code like this should work</p>

<pre><code>float** mGridB = createFloat2D(nThetaCells, nPhiCells);
//...
memcpy(mGridB[0], cur-&gt;mGridB[0], sizeof(float)*nThetaCells*nPhiCells);
</code></pre>

<p>The code above now works correctly, if we use the second method of creating the 2d array.  </p>

<p>I would still stick with the vector for 1-d float arrays, as you have the pointer to the data (see my earlier comment).  For the code above, I would wrap it in a class that handles creation and destruction easily.</p>

<p>The last thing is the copy constructor.  A copy constructor in C++ has the following possible signatures:</p>

<pre><code>DGCPM(const DGCPM&amp;);
DGCPM(DGCPM&amp;);
DGCPM(volatile DBCPM&amp;);
</code></pre>

<p>I may have missed one, but the signature should be one of those above, more than likely, the first one (you can also have additional arguments after the reference argument, but they all must have default values).  </p>

<p>Note that a <code>DBCPM*</code> is not a valid argument for a copy constructor as your code stated -- remember that a copy constructor is not only for use, but also the compiler will use it to make copies.  So to signal the compiler that ""yes, this function is used to make copies"", your function must match one of the signatures above.</p>

<p>In addition, you need an assignment operator, in other words, the class needs to implement the ""rule of 3"".</p>
",8
23069678,23067857,0,"<p>From your comment <code>/* [nPhiCells][nThetaCells] */</code> in your class definition, I take it that you intent the <code>float**</code> to be 2D arrays. However, if you can use them like 2D arrays, they are actually arrays of <em>pointers</em> to arrays. That is a huge difference: it means, you have to copy <code>nPhiCells</code> individual arrays of <code>nThetaCells</code> elements <em>and</em> you have to setup the pointer array itself. Now, when you do</p>

<pre><code>memcpy(mGridHalf[0], cur-&gt;mGridHalf[0],sizeof(float)*nThetaCells*nPhiCells);
</code></pre>

<p>in your copy constructor, you assume that there is no pointer array, and that all line arrays are sequential in memory. Either this copy exceeds the bounds of the pointer array (segfaulting), or accessing you array via <code>mGridHalf[i][j]</code> simply does the wrong thing, reinterpreting <code>float</code> data as pointers (and segfaulting).</p>

<hr>

<p>Unfortunately, C++ is a horrible language for interacting with fortran multidimensional arrays because it has no notion of variable sized arrays. So the following is C code, not C++ code. In C, you can tackle the issue like this:</p>

<pre><code>float (*mGridHalf)[nThetaCells] = malloc(nPhiCells*sizeof(*mGridHalf));
</code></pre>

<p>will correctly allocate and type a 2D array (i. e. an array of <em>arrays</em>) that can be accessed with</p>

<pre><code>mGridHalf[phi][theta] = 7.3;
</code></pre>

<p>Since all elements are consecutive in memory, the entire thing can correctly be copied with</p>

<pre><code>memcpy(mGridHalf, cur-&gt;mGridHalf, nPhiCells*sizeof(*mGridHalf));
</code></pre>

<p>and freed with</p>

<pre><code>free(mGridHalf);
</code></pre>

<p>Technically, <code>mGridHalf</code> is now a pointer to an array, the pointer arithmetic that is invoked by the array access effectively does the same computation as if you had written:</p>

<pre><code>float* foo = malloc(nPhiCells*nThetaCells*sizeof(*foo));
foo[phi*nThetaCells + theta] = 7.3;
</code></pre>

<p>However, using the correct pointer type <code>float (*)[nThetaCells]</code> allows you to avoid doing the index computation yourself.</p>
",1
23069242,23067857,1,"<pre><code>class DGCPM
{
public:
    DGCPM(int nThetaCells, int nPhiCells)
    : nThetaCells(nThetaCells)
    , nPhiCells(nPhiCells)
    , mGridB(nThetaCells, vector&lt;float&gt;(nPhiCells)) // first Y then X
    {
    }

private:
    int nThetaCells, nPhiCells;
    vector&lt;vector&lt;float&gt;&gt; mGridB;
};
</code></pre>

<p>Deep copies for free. Deletes memory for free.</p>

<p>By free I mean you don't have to write the code..</p>
",7
23114776,23067857,0,"<p>This going to sound so stupid (elementary programming error): my index ""i"" was going beyond (number of models - 1), so I was getting a segmentation fault from accessing memory that didn't exist.</p>
",0
22879676,22879499,0,"<p>It's up to you. There are conventions for scripting, but in essence, exit codes are just an int, and <strong>you</strong> assign it meanings.</p>

<p>See e.g. <a href=""https://superuser.com/questions/280425/getting-robocopy-to-return-a-proper-exit-code"">https://superuser.com/questions/280425/getting-robocopy-to-return-a-proper-exit-code</a> </p>

<p><a href=""http://support.microsoft.com/kb/954404"" rel=""nofollow noreferrer"">MSDN</a> says:</p>

<p><img src=""https://i.stack.imgur.com/dvUEG.png"" alt=""enter image description here""></p>

<p>Devise your own exit code scheme, and take the <a href=""http://en.wikipedia.org/wiki/Principle_of_least_astonishment"" rel=""nofollow noreferrer"">good lessons shown by RoboCopy to heart</a></p>
",2
22879858,22879499,0,"<p>From the C++ &amp; C specification, the value of <code>zero</code> or <code>EXIT_SUCCESS</code> is proposed to tell the host environment (like a bash etc.) that the program <code>successfully terminated</code>, and <code>EXIT_FAILURE</code> is proposed to tell the host environment that the program <code>unsuccessfully terminated</code>, you can also set the return value or exit status to other integer values.</p>

<p>Thus, if you wanna to tell the host environment that your program runs okay, please return <code>EXIT_SUCCESS</code>, or return <code>EXIT_FAILURE</code> to tell the host environment that the program fails to run, and return other values for program specific status.</p>
",3
22879540,22879499,3,"<p>The return values of these programs are so that they can be executed in a script (or a sequence), and the error condition can be caught by the script (since the script won't be monitoring stdout/stderr for textual output), and action can be taken to either carry on, abort or attempt to rectify the situation.</p>

<p>For this reason, <em>anything</em> which is abnormal termination is a failure condition. If you haven't passed the correct arguments, so the program emits the help text, it's terminating abnormally, since the program has hit an error condition (it doesn't know what to do). If the config is incorrect, it's an error and therefore an abnormal termination.</p>

<p>Basically, if the program hasn't fulfilled its actual purpose, it hasn't been successful.</p>
",3
22879568,22879499,0,"<p>This depends on your application. Return failure in cases where a script could take a different action. If you cannot conceive anyone wanting to even log faults, then it does not really matter.</p>
",0
21713900,21713841,0,"<p>You should include a <code>continue;</code> at the end of each of your <code>if(found != string::npos)</code> blocks.</p>

<p>That way, if it executes the block, it skips the other if blocks and restarts the <code>while</code> loop.</p>
",2
21713914,21713841,2,"<p>If your input is </p>

<pre><code>&gt; run converter
</code></pre>

<p>Then the way you are getting your input</p>

<pre><code>cin &gt;&gt; run;
</code></pre>

<p>will not work for you (<code>operator&gt;&gt;</code> breaks on whitespace).  The first time it goes through the loop, it is going to try to find a ""run"" string, then it will go again and try to find a ""converter"" string.  If you want to deal with the whole line, you should do</p>

<pre><code>std::getline(std::cin, run);
</code></pre>
",1
29180322,29180291,3,"<p><code>pthread_create</code> expects a pointer to a non-member function, but <code>void *ball_thread</code> is a member of <code>Ball</code>. That means it needs a <code>Ball</code> object to be called on an so has a fundamentally different structure to a non-member.</p>

<p>You can use <a href=""http://en.cppreference.com/w/cpp/thread/thread"" rel=""nofollow""><code>std::thread</code></a> instead, which makes it easy to bind an object to a member function.</p>

<p>Alternatively, you can the <code>ball_thread</code> function a non-member, and pass a <code>Ball*</code> first parameter if required.</p>
",5
24129962,24129952,1,"<p>It means to take the expression after it from <strong>global</strong> scope. See <a href=""https://stackoverflow.com/a/10269044/391161"">this answer</a> for more details.</p>
",0
22852836,22852776,3,"<p>Without copying the exact line that worries you I might be off target, but if your concern is code like:</p>

<pre><code>T f() {
   return T();
}
</code></pre>

<p>That is not a call to the constructor, but rather the creation of a temporary which in this case is <em>value-initialized</em>. The memory is allocated locally in the stack (if at all, Return Value Optimization should avoid it).</p>
",6
22114966,22114947,5,"<p><code>equal</code> is in the <code>std</code> namespace. What you are seeing is <a href=""http://en.cppreference.com/w/cpp/language/adl"" rel=""nofollow""><em>argument dependent lookup</em></a> (ADL). Because the arguments are in the <code>std</code>, the name lookup for <code>equal</code> considers that namespace too.</p>

<p>Here's a simplified example:</p>

<pre><code>namespace foo
{
  struct Bar {};
}

namespace foo
{
  void bar(const Bar&amp;) {}
  void bar(int) {}
}

int main()
{
  foo::Bar b;
  foo::bar(b);  // OK
  bar(b);       // ADL, OK
  foo::bar(42); // OK
  bar(42);      // No ADL: error: 'bar' was not declared in this scope
}
</code></pre>
",7
23578640,23578062,2,"<p>I'm almost certain that <code>line_cf-&gt;size()</code> returns an object of type <code>size_t</code>. If you write, </p>

<pre><code>size_t lsize = line_cf-&gt;size();
double r2 = abs(36-lsize);
</code></pre>

<p>You will get the same large number.</p>

<p>The reason for that is <code>(36-lsize)</code> will evaluate to a value that is of type <code>size_t</code>, and a very large one when <code>lsize</code> is <code>39</code>.</p>

<p>When you store the returned value of <code>line_cf-&gt;size()</code> in an <code>int</code> and use that variable in <code>(36-lsize)</code>, you get a signed integer subtraction result, which works in a more sensible manner.</p>
",1
23578651,23578062,2,"<p><code>size()</code> is returning a 64-bit unsigned integer, so the subtraction <code>36 - (line_cf-&gt;size())</code> is occurring in the 64-bit unsigned integer type, resulting in arithmetic wraparound to <code>2^64</code>.</p>

<p>For example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;

int main() {
    std::cout &lt;&lt; static_cast&lt;double&gt;(std::fabs(36 - 39ull));
}
</code></pre>

<p>prints <code>1.84467e+19</code>.</p>

<p>To ensure signed arithmetic occurs, replace the constant <code>36</code> with <code>36ll</code>, or cast <code>line_cf-&gt;size()</code> to <code>int</code> (this is what happens in your second code excerpt):</p>

<pre><code>    double r2 = abs(36-static_cast&lt;int&gt;(line_cf-&gt;size()));   
                       ^^^^^^^^^^^^^^^^       
</code></pre>
",0
31907830,31907734,-1,"<p>Clearly, the compiler is using default parameter values in the mangling of the function name. </p>

<p>The duplicate in the comment above gives another reason. The compiler resolves default parameters at compile time.  </p>
",5
28242011,28241967,2,"<p>According to <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx"" rel=""nofollow"">Windows data types page</a> it is simple <code>typedef BYTE *PBYTE,*LPBYTE;</code></p>

<p>Also you may found useful this page: <a href=""https://www.cygwin.com/ml/cygwin/2003-06/msg00470/windef.h"" rel=""nofollow"">windef.h</a>.</p>
",0
28242069,28241967,0,"<p>There is no difference between PBYTE and BYTE*. The LPBYTE is BYTE far*.<br>
What's <a href=""http://en.wikipedia.org/wiki/Far_pointer"" rel=""nofollow"">far pointer</a></p>
",2
28245019,28241967,5,"<p>In naming conventions where PBYTE and BYTE are typedefs, PBYTE is a pointer to BYTE.   So there is no meaningful difference between PBYTE and BYTE * (unless you declare more than one variable at a time.</p>

<p>So</p>

<pre><code>PBYTE x, y;
</code></pre>

<p>declares two pointers but</p>

<pre><code>BYTE *x, y;
</code></pre>

<p>declares x as a pointer, and y as a BYTE (it would be necessary to use an addition asterisk to make y a pointer.).   This sort of thing is a common source of errors - albeit errors that are often quickly detected by a compiler when the variables are used as intended.</p>

<p>With implementations that support multiple pointer sizes (e.g. near, far, huge), LPBYTE sometimes means a far pointer.      This is meaningless in standard C++ (one memory model).  However, some older architectures (e.g. older IBM compatible PC) which had a segmented memory architecture, with different types memory provided by distinct types of chips, and different pointer types were needed to address them.   Modern operating systems that do virtualisation abstract this sort of thing away.</p>
",0
28495626,28495119,5,"<p>The reason you can't do:</p>

<pre><code>std::array&lt;struct {int v}, 10&gt; arr;
</code></pre>

<p>is because of the following rule from N4140:</p>

<blockquote>
  <p>¡ì7.1.6/3 [...] A <em>type-specifier-seq</em> shall not define a class or
  enumeration unless it appears in the <em>type-id</em> of an <em>alias-declaration</em>
  (7.1.3) that is not the <em>declaration</em> of a
  <em>template-declaration</em>.</p>
</blockquote>

<p>Since a template type argument is specified using a <em>type-id</em>, and a <em>type-id</em> contains a <em>type-specifier-seq</em>, it can't be the definition of a class.</p>

<p>You could use a typedef, but:</p>

<blockquote>
  <p>¡ì9.1/5 A <em>typedef-name</em> (7.1.3) that names a class type, or a
  cv-qualified version thereof, is also a <em>class-name</em>. [...]</p>
</blockquote>

<p>I would go with the suggestion by <a href=""https://stackoverflow.com/questions/28495119/is-it-possible-to-initialize-an-stdarray-of-unnamed-structs/28495626#comment45310348_28495119"">T.C.</a>:</p>

<pre><code>struct { int v; } foo; std::array&lt;decltype(foo), 10&gt; bar = {{{1},{2}}};
</code></pre>
",1
25546050,25545507,2,"<p>First. You should allocate memory for each raw in array</p>

<pre><code>int ii;
typedef FILE * FILE_PTR;
FILE_PTR ** lossArr = (FILE_PTR**)malloc( sizeof( FILE_PTR* ) * i );
for ( ii = 0; ii &lt; i; ii++ ) {
    lossArr[ ii ] = (FILE_PTR*)malloc( sizeof( FILE_PTR ) * j );
}
// now you can use lossArr[ x ][ y ], where x = 0..i-1, y = 0..j-1
</code></pre>

<p>Second. This is C, but not C++. If you can use C++, then use <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow"">std::vector</a></p>
",1
25546073,25545507,0,"<p>Your approach is similar to that presented <a href=""http://www.eskimo.com/~scs/cclass/int/sx9b.html"" rel=""nofollow"">here</a>, which uses an array of pointer-to-pointers, and your code is crashing as you haven't allocated the second dimension of pointers.</p>

<p>You could continue your approach by calculating the index into <code>lossArr</code> yourself,  treating a single-dimension array as two-dimensional using a macro:</p>

<pre><code>#define INDEX_FOR(r, c) r * i + c

FILE** lossArr = (FILE**)malloc(sizeof(FILE*) * i * j);
lossArr[INDEX_FOR(0, 0)] = pFile;
</code></pre>

<p>However using <code>std::array</code> is better including using <code>fstream</code> instead of <code>FILE*</code>:</p>

<pre><code>std::array&lt;std::array&lt;std::fstream, j&gt;, i&gt; lossArr;
lossArr[0][0] =  file;
</code></pre>
",9
25546076,25545507,0,"<p>Please look at this in reference to your problem:</p>

<pre><code>int a[5] = {1,2,3,4,5};
a[1] = a[4];
</code></pre>

<p>is equal to</p>

<pre><code>int b[5] = {1,2,3,4,5};
int *a = b;
a[1] = a[4];
</code></pre>

<p>but </p>

<pre><code>int a[2][2] = { {1,2}, {3,4} };
a[0][0] = a[1][1];
</code></pre>

<p>is not equal to</p>

<pre><code>int b[2][2] = { {1,2}, {3,4} };
int **a = b;  // compilation error
a[0][0] = a[1][1]; // runtime error
</code></pre>

<p>but </p>

<pre><code>int b[2][2] = { {1,2}, {3,4} };
int *a = b;
a[0] = a[3];
</code></pre>

<p>will work</p>

<p>Pointers can't point to multidimensional arrays insted they point to arryas of pointers. If you point a pointer to multidimensional array it will flatten an array.</p>

<pre><code>int **a;
</code></pre>

<p>mean pointer to int pointer not pointer to 2d int array</p>
",0
25546087,25545507,0,"<p>Doing this:</p>

<pre><code>FILE **lossArr  =   (FILE**)malloc(sizeof(FILE*) * i * j);
</code></pre>

<p>Only gets you a pointer to a space of <code>i*j FILE</code> pointers.</p>

<p>This:</p>

<pre><code>FILE ***lossArr =   (FILE**)malloc(sizeof(FILE*) * i * j);
</code></pre>

<p>is even worse - you convert a <code>FILE**</code> to a <code>FILE***</code>.</p>

<p>Do this instead:</p>

<pre><code>int k;
FILE ***lossArr  =   (FILE***)malloc(sizeof(FILE**) * i);
for (k = 0; k &lt; i; k++) {
    lossArr[i] = (FILE**)malloc(sizeof(FILE*) * j);
}
</code></pre>

<p>Note: don't forget to <code>free</code> memory afterwards</p>

<pre><code>for (k = 0; k &lt; i; k++) {
    free(lossArr[i]);
}
free(lossArr);
</code></pre>

<p>Note2: If in <code>C++</code> as the tag suggests, you may consider using <code>std::vector</code> to avoid all this pointer wizardry</p>
",1
25546109,25545507,0,"<p><code>FILE*** lossArr</code> is an array of array of file pointers. To initialize it, you first have to allocate an array of array pointers as in </p>

<pre><code>lossArr = (FILE***) malloc( sizeof(FILE**) * i);
</code></pre>

<p>Then, you have to initialize each second-level array</p>

<pre><code>for (int ii = 0; ii &lt; i; ii++) lossArr[ii] = (FILE**) malloc( sizeof(FILE*) * j);
</code></pre>

<p>Only now is <code>lossArr</code> ready to be used. </p>

<p>My tip: Use 1D arrays and index them with <code>i*ii + jj</code>. They are easier to initialize and destroy, and more efficient!</p>
",0
23564719,23553723,16,"<p>It depends. In my own super-secret and private freestanding implementation you can make the main function be a template if all the following conditions apply.</p>

<ul>
<li>The function is named <code>m§Ñin</code> (note that the second letter is a Cyrillic letter, not a Latin letter).</li>
<li>There are either 2, 17, or 23 non-pack template arguments, or a lone variadic pack.</li>
<li>If the template arguments consist of a variadic pack, it is introduced with <code>class</code>, not <code>typename</code>, there is no space between <code>class</code> and dot-dot-dot, and there is a single space between dot-dot-dot and the pack name.</li>
<li>It's a full moon and you're in the Northern hemisphere, or you're in the Southern hemisphere and Mars is above the horizon. (Compilation without GPS or ASCOM is not supported.)</li>
</ul>

<p>All of this information is obviously completely useless in face of the question presented, but who cares? At least it mentions freestanding implementations and language extensions.</p>
",3
26123948,26123829,5,"<p>Just overload the function for pointers and non-pointers, there's no need to use SFINAE or type traits:</p>

<pre><code>template&lt;typename T&gt;
  T&amp; deref(T* val) 
  { return *val; }

template&lt;typename T&gt;
  T&amp; deref(T&amp; val) 
  { return val; }
</code></pre>

<p>For perfect forwarding just use a forwarding reference and <code>std::forward</code> instead of the second overload:</p>

<pre><code>template&lt;typename T&gt;
  T&amp;&amp; deref(T&amp;&amp; val) 
  { return std::forward&lt;T&gt;(val); }
</code></pre>
",9
23584946,23584934,4,"<blockquote>
  <p>I wonder why we can't free memory by delete operator?</p>
</blockquote>

<p>You don't need to in this case!</p>

<blockquote>
  <p><code>char *str = ""hi"";</code> automatically allocates memory and writes string in it.</p>
</blockquote>

<p>No it doesn't! This all happens at compile time (and should even leave you a warning).<br>
You didn't allocate <code>str</code>, you assigned a pointer to a <code>const char*</code> literal (the compiler is allowed to place wherever the implementation wants to), thus you can't delete it.</p>

<p>Dynamic allocation as managed with <code>new()</code> and <code>delete</code> would mean something like</p>

<pre><code>char* str = new char[3];
strncpy(str,""hi"",3);

// ...
delete [] str;
</code></pre>
",0
23584974,23584934,0,"<p>That is a fair question. But there's more to the business of constant strings than meets the eye: the compiler and linker are free to maintain pools of read-only literals wherever they want.</p>

<p>In fact, if the <code>str</code> in your example is in automatic (function-local, stack) storage and you have a high-speed memory pool handler, you may be able to make a catastrophic mess by trying to free it and then reuse it.  (Don't try this at home  :-)</p>
",0
23584988,23584934,1,"<p>The key thing to note from your question is</p>

<blockquote>
  <blockquote>
    <p><code>char *str = ""hi"";</code> <strong>automatically allocates memory</strong> and writes string in it</p>
  </blockquote>
</blockquote>

<p>String literals are automatically allocated <strong>and</strong> automatically deallocated. You can't free the memory yourself.</p>

<p>Note that they will last for the lifetime of the program, not just the scope of the variable. See <a href=""https://stackoverflow.com/a/9505236/1313439"">this SO answer</a>.</p>
",0
23585007,23584934,1,"<p><code>delete</code> is used to de-allocate objects originally allocated with <code>new</code>. <code>delete[]</code> is used to de-allocate arrays originally allocated with <code>new[]</code>.</p>

<p>You didn't use <code>new</code> in your first line, so shouldn't use <code>delete</code> in the second.</p>

<p>Specifically,</p>

<pre><code>char *str = ""hi"";
</code></pre>

<p>allocates memory for a <em>pointer</em> called <code>str</code>, which has automatic lifetime. Automatic here means the compiler takes care of it for you.</p>

<p>The pointer points to a string literal, <code>""hi""</code>, which was statically allocated once, at compile time, and can never be changed. In fact, your pointer should be const.</p>

<p>Now, if we change your code to</p>

<pre><code>std::string str = ""hi"";
</code></pre>

<p>a dynamic allocation <em>does</em> happen since <code>std::string</code> makes a copy of your string literal, but it also takes care of releasing that copy for you. It may well use <code>new[]</code> and <code>delete[]</code> internally.</p>
",0
24137585,24137142,1,"<p>Setting an object of an integral type to zero means setting all its used bits to zero.</p>

<p>You could write two functions. one will set a specified bit (starting from 0) and other will reset a specified bit. For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdint&gt;

inline uint16_t &amp; set( uint16_t &amp;bitNum, size_t n )
{
    return ( bitNum |= 1 &lt;&lt; n );
}

inline uint16_t &amp; reset( uint16_t &amp;bitNum, size_t n )
{
    return ( bitNum &amp;= ~( 1 &lt;&lt; n ) );
}

int main()
{
    uint16_t bitNum = 0;

    for ( size_t i = 0; i &lt; 16; i++ )
    {
        std::cout &lt;&lt; set( bitNum, i ) &lt;&lt; std::endl;
        reset( bitNum, i );
    }

    return 0;
} 
</code></pre>

<p>The output is</p>

<pre><code>1
2
4
8
16
32
64
128
256
512
1024
2048
4096
8192
16384
32768
</code></pre>

<p>The other way is to use standard class <code>std::bitset</code> declared in header <code>&lt;bitset&gt;</code> It already has the corresponding functions.</p>

<p>For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;bitset&gt;

int main()
{
    std::bitset&lt;16&gt; bitNum;

    for ( size_t i = 0; i &lt; 16; i++ )
    {
        std::cout &lt;&lt; bitNum.set( i ) &lt;&lt; std::endl;
        bitNum.reset( i );
    }

    return 0;
} 
</code></pre>

<p>The output is</p>

<pre><code>0000000000000001
0000000000000010
0000000000000100
0000000000001000
0000000000010000
0000000000100000
0000000001000000
0000000010000000
0000000100000000
0000001000000000
0000010000000000
0000100000000000
0001000000000000
0010000000000000
0100000000000000
1000000000000000
</code></pre>

<p>Enjoy!:)</p>
",4
24137259,24137142,4,"<blockquote>
  <p>Is this the same as 0000000000000000?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>And how do I access the values of the individual bits?</p>
</blockquote>

<p>You cannot access real individual bit as the smaller variable computer can address and allocate is a <code>char</code> (a char variable is of the natural size to hold a character on a given machine). But you can manipulate each bit using bit masks ( and bitwise operations)</p>

<pre><code>temp &amp; (1 &lt;&lt; N) // this will test N-th bit
</code></pre>

<p>or in C++ you can use <code>std::bitset</code> to represent a sequence of bits.</p>

<pre><code>#include &lt;bitset&gt;
#include &lt;iostream&gt;
#include &lt;stdint.h&gt;

int main()
{
    uint16_t temp = 0x0;
    std::bitset&lt; 16&gt;   bits( temp);

    // 0 -&gt; bit 1
    // 2 -&gt; bit 3
    std::cout &lt;&lt; bits[2] &lt;&lt; std::endl;
}
</code></pre>

<p>This is what Bjarne Stroustrup says about operations on bits in ""C++ Prog... 3d edition"" 17.5.3 Bitset:</p>

<blockquote>
  <p>C++ supports the notion of small sets of flags efficiently through
  bitwise operations on integers (¡ì6.2.4). These operations include <strong>&amp;</strong>
  (and), <strong>|</strong> (or), <strong>^</strong> (exclusive or), <strong>&lt;&lt;</strong> (shift left), and <strong>>></strong> (shift
  right). </p>
</blockquote>

<p>Well, also <strong>~</strong>, bitwise complement operator, the tilde, that flips every bit.</p>

<blockquote>
  <p>Class bitset generalizes this notion and offers greater
  convenience by providing operations on a set of N bits indexed from 0
  through N-1, where N is known at compile time. For sets of bits that
  don¡¯t fit into long int using a bitset is much more convenient than
  using integers directly. For smaller sets, there may be an efficiency
  tradeoff. If you want to name the bits, rather than numbering them,
  using a <strong>set</strong> (¡ì17.4.3), an <strong>enumeration</strong> (¡ì4.8), or a <strong>bitfield</strong> (¡ìC.8.1)
  are alternatives. (...) A key idea in the design of bitset is that an optimized implementation can be provided for bitsets that fit in a single word. The interface reflects this assumption.</p>
</blockquote>

<p>So there are alternatives, i.e another option is to use a <em>bitfields</em>. They are binary variables bundled together as fields in a struct. You can then access each individual ""bit"" using access operator: . for references or -> for pointers.</p>

<pre><code>struct BitPack {
    bool b1 :  0;
    bool b2 :  0;
    //...
    bool b15 : 0;
};

void f( BitPack&amp; b)
{
  if( b.b1) // if b1 is set
      g();
}
</code></pre>

<p>links:</p>

<p><a href=""http://en.cppreference.com/w/cpp/utility/bitset"" rel=""nofollow"">http://en.cppreference.com/w/cpp/utility/bitset</a></p>

<p><a href=""http://en.cppreference.com/w/cpp/language/bit_field"" rel=""nofollow"">http://en.cppreference.com/w/cpp/language/bit_field</a></p>
",1
34218440,34218040,6,"<p>Try this,</p>

<pre><code>void Core::parseCSV()
{
    std::ifstream  data(""test.csv"");
    std::string line;
    std::vector&lt;std::vector&lt;std::string&gt; &gt; parsedCsv;
    while(std::getline(data,line))
    {
        std::stringstream lineStream(line);
        std::string cell;
        std::vector&lt;std::string&gt; parsedRow;
        while(std::getline(lineStream,cell,','))
        {
            parsedRow.push_back(cell);
        }

        parsedCsv.push_back(parsedRow);
    }
};
</code></pre>
",0
34218498,34218040,2,"<p>Following code is working. hope it can help you. It has a CSV file istream_iterator-like class. It is a template so that it can read strings, ints, doubles, etc. Its constructors accept a char delimiter, so that it may be used for more than strictly comma-delimited files. It also has a specialization for strings so that white space characters could be retained. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;

using namespace std;

template &lt;class T&gt;
class csv_istream_iterator: public iterator&lt;input_iterator_tag, T&gt;
{
    istream * _input;
    char _delim;
    string _value;
public:
    csv_istream_iterator( char delim = ',' ): _input( 0 ), _delim( delim ) {}
    csv_istream_iterator( istream &amp; in, char delim = ',' ): _input( &amp;in ), _delim( delim ) { ++*this; }

    const T operator *() const {
        istringstream ss( _value ); 
        T value;
        ss &gt;&gt; value;
        return value;
    }

    istream &amp; operator ++() {
        if( !( getline( *_input, _value, _delim ) ) )
        {
            _input = 0;
        }
        return *_input;
    }

    bool operator !=( const csv_istream_iterator &amp; rhs ) const {
        return _input != rhs._input;
    }
};

    template &lt;&gt;
    const string csv_istream_iterator&lt;string&gt;::operator *() const {
        return _value;
    }

    int main( int argc, char * args[] )
    {
        { // test for integers
            ifstream fin( ""data.csv"" );
            if( fin )
            {
                copy( csv_istream_iterator&lt;int&gt;( fin ),
                      csv_istream_iterator&lt;int&gt;(),
                      ostream_iterator&lt;int&gt;( cout, "" "" ) );

                fin.close();
            }
        }

        cout &lt;&lt; endl &lt;&lt; ""----"" &lt;&lt; endl;

        { // test for strings
            ifstream fin( ""data.csv"" );
            if( fin )
            {
                copy( csv_istream_iterator&lt;string&gt;( fin ),
                      csv_istream_iterator&lt;string&gt;(),
                      ostream_iterator&lt;string&gt;( cout, ""|"" ) );

                fin.close();
            }
        }

        return 0;
    }
</code></pre>
",1
34218813,34218040,-1,"<p>I would go for something like this (untested, incomplete) and eventually refine operator <code>&gt;&gt;</code>, if you have strings instead of chars, or floats instead of ints.</p>

<pre><code>struct data_t
{
  int a ;
  int b ;
  char c ;
  int d ; 
  int e ;
  char f ;
} ;

std::istream &amp;operator&gt;&gt;(std::istream &amp;ist, data_t &amp;data)
{
    char comma ;
    ist &gt;&gt; data.a &gt;&gt; comma 
        &gt;&gt; data.b &gt;&gt; comma
        &gt;&gt; data.c &gt;&gt; comma
        &gt;&gt; data.d &gt;&gt; comma
        &gt;&gt; data.e &gt;&gt; comma
        &gt;&gt; data.f 
    ;
    return ist ;
}
void Core::parseCSV(){
  std::ifstream  data(""test.csv"");
  std::string line;
  std::vector&lt;data_t&gt; datavect ;
  while(std::getline(data,line))
  {
    data_t data ;
    std::stringstream lineStream(line);
    lineStream &gt;&gt; data ;
    datavect.push_back(data) ;
  }
};
</code></pre>
",0
28491226,28133180,2,"<p>The previous answer has some bugs, so here's a working solution:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;Windows.h&gt;

int main( )
{    
    STARTUPINFO lpStartupInfo;
    PROCESS_INFORMATION lpProcessInfo;

    ZeroMemory( &amp;lpStartupInfo, sizeof( lpStartupInfo ) );
    lpStartupInfo.cb = sizeof( lpStartupInfo );
    ZeroMemory( &amp;lpProcessInfo, sizeof( lpProcessInfo ) );

    CreateProcess( ""Program.exe"",
                   NULL, NULL, NULL,
                   NULL, NULL, NULL, NULL,
                   &amp;lpStartupInfo,
                   &amp;lpProcessInfo
                   );

    return 0;
}
</code></pre>
",1
26794499,26794464,0,"<p>Yes  there is a sure shot memory leak in case of plain delete.</p>

<p>Matching combination must always be:-</p>

<pre><code>new;    
delete;

new[];
delete[];
</code></pre>
",0
26794502,26794464,0,"<p>Memory allocated with <code>new[]</code> should be deleted with <code>delete[]</code> - otherwise you leak memory.
i.e.</p>

<pre><code>int main () {
    char *str = new char[3];
    delete[] str;  // OK
    char *str2 = new char;
    delete str2;  // OK
    char *str3 = new char[3];
    delete str3;  // Not OK
    char *str4 = new char;
    delete[] str4;  // Not OK
    return 0;
}
</code></pre>
",0
26794503,26794464,0,"<p>For this example there may not be much difference on most of the systems but it is UB. Deleting buffers using <code>delete</code> which were allocated with <code>new</code> invokes UB.</p>

<p>But if <code>char</code> is replaced with some class, <code>delete[]</code> is guaranteed to call destructors of all objects, while <code>delete</code> may call destructor of <code>obj[0]</code> only which may cause resource leak or some other unwanted issue.</p>

<p><strong>Conclusion:</strong> This is UB, so never do this.</p>

<p><a href=""http://ideone.com/ilhVRM"" rel=""nofollow"">Live code here</a></p>
",4
22492784,22492490,0,"<p>You allocate memory for the single int, store the pointer to it to <code>ptr</code>, and then overwrite the same pointer with class_inst's pointer. When destructed both objects try to deallocate the same memory block. </p>

<p>I assume you wanted to copy the contents.</p>

<pre><code>myclass (const myclass &amp;class_inst){
    ptr = new int;
    *ptr = *class_inst.ptr;
}
</code></pre>
",1
22493076,22492490,0,"<p>Echoing Mooing Duck's comment about the rule of three, I will try and walk through what happens at each step of your main (apologies for any mangled indentation):</p>

<pre><code>int main(){
     myclass test1; //myclass default ctor called.
                    //ptr assigned a new int (uninitialised)
     test1 = dosomething (test1); //make a copy of test1
                                  //a.ptr is assigned a new int and then assigned class_inst.ptr, losing the original ¡°new int¡± which will be leaked
                                  //return a copy (call it result) constructed my class of argument a (which is a copy of test 1)
                                  //result.ptr is assigned a new int and then assigned class_inst.ptr, 
                                  //losing the original ¡°new int¡± which will be leaked
                                  //a goes out of scope, and calls its door which deletes it¡¯s a.ptr, which is pointed to by result.ptr (which in turn is class_inst.ptr) 
 return 0;                        //test1 (which is the same as result above) goes out of scope and tries to delete its ptr member, which is != NULL
                                  //and then you get the seg fault
</code></pre>

<p>}</p>

<p>So what you should do is look up the rule of three (aka the big three), think about what happens in the default and copy constructors really hard, and equally so about the destructor.</p>
",0
24354210,24354182,3,"<p>Names in derived classes do indeed hide identical names in base classes. This is deliberate. If the base class changes, you don't suddenly and silently want to see a different overload set in your derived class.</p>

<p>To unhide base names explicitly, add <code>using X::stream;</code> into your derived class.</p>
",0
24612711,24612607,5,"<p>In C++11 or later, you can do that with a lambda:</p>

<pre><code>print([](int r){std::cout &lt;&lt; r;});
</code></pre>

<p>Since <code>print</code> takes a plain function pointer, you're restricted to simple stateless lambdas like this one; you can't capture anything. You might like to give it more flexibility through polymorphism, either using a template:</p>

<pre><code>template &lt;typename Function&gt;
void print(Function func) {
    func(6);
}
</code></pre>

<p>or type erasure:</p>

<pre><code>void print(std::function&lt;void(int)&gt; func) {
    func(6);
}
</code></pre>
",2
24612748,24612607,3,"<p>This is very easy with two new new features in C++11: <a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow""><code>std::function</code></a> and <a href=""http://en.cppreference.com/w/cpp/language/lambda"" rel=""nofollow"">lambda expressions</a>:</p>

<pre><code>void print(std::function&lt;void(int)&gt; func)
{
    func(6);
}

int main()
{
    print([](int r){ std::cout &lt;&lt; r; });
}
</code></pre>

<hr>

<p>With <code>std::function</code> you can use <em>any</em> callable object, not only lambda expressions.</p>

<p>For example:</p>

<pre><code>// The `print` function as above

void print_num(int r)
{
    std::cout &lt;&lt; r;
}

int main()
{
    print(print_num);
}
</code></pre>

<p>Or</p>

<pre><code>// The `print` function as above

struct printer
{
    void operator()(int r)
    {
        std::cout &lt;&lt; r;
    }
};

int main()
{
    print(printer());  // Creates a temporary object
}
</code></pre>
",3
26250627,26249861,2,"<p>I think your code should look like the following:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;

using namespace std;

int main()
{
    ifstream inputFile; // File stream object
    int number;

    // Open the input file
    inputFile.open(""People.txt"");


    cout &lt;&lt; ""PRAIRIEVILLE POPULATION GROWTH\n"" &lt;&lt; ""(each * represents 1000 people)\n"";

    for(int y = 1910; y &lt;= 2010; y += 20)
    {
        cout &lt;&lt; y &lt;&lt; ' ';
        inputFile &gt;&gt; number;
        for (int i = 1; i &lt; number; i+=1000)
        {
            cout &lt;&lt; '*';
        }
        cout &lt;&lt; endl;
    }

    // Close the file
    inputFile.close();

    return 0;
}
</code></pre>

<p>Also note that quotation marks (string literal) have been changed to single quotes (character literal) for the asterisk. Operator &lt;&lt; will be more efficient this way because it does not need to dereference the pointer a string literal in fact means, but it gets a mere character which fits in a register.</p>
",1
26250635,26249861,1,"<p>Something off the top of my head:</p>

<pre><code>// Without error checking, something like this:
// Assuming it starts at year 1910, at 20 year intervals

int number = 0;
int year = 1910;

while (inputFile &gt;&gt; number) {
    cout &lt;&lt; year &lt;&lt; "" "";

    for (int i = 0; i &lt; number; i += 1000) {
       cout &lt;&lt; ""*"";
    }

    cout &lt;&lt; ""\n"";

    year += 2000;          
}
</code></pre>
",0
25446857,25446581,1,"<p>As I understood of comment </p>

<blockquote>
  <p>Yes it can even hold 400 values</p>
</blockquote>

<p>And in question </p>

<blockquote>
  <p>0b is important</p>
</blockquote>

<p>You need to have <code>string</code>, not <code>int</code>.</p>

<pre><code>std::string convert2bin(const std::vector&lt;bool&gt;&amp; v)
{
    std::string out(""0b"");
    out.reserve(v.size() + 2);
    for (bool b : v)
    {
        out += b ? '1' : '0';
    }  
    return i;
}
</code></pre>
",3
25446711,25446581,1,"<pre><code>std::vector&lt;bool&gt; a = { 0, 1, 1, 1, 1, 0, 1, 1, 1, 0 };
std::string s = """";
for (bool b : a)
{
    s += std::to_string(b);
}
int result = std::stoi(s);
</code></pre>
",2
25447012,25446581,0,"<p>Your <code>x</code> is just an integer form from <code>a</code>, so can use <code>std::accumulate</code> like following</p>

<pre><code>long long x = accumulate(a.begin(), a.end(), 0, 
                   [](long long p, long long q) 
                   { return (p &lt;&lt; 1) + q; }
                  );
</code></pre>

<p>For a 400 size, you need a <code>std::string</code> though</p>
",0
25446780,25446581,0,"<p>If you really want to do this, you start from the end. Although I support Marius Bancila and advise to use a bitset instead.</p>

<pre><code>int mValue = 0
for(int i=a.size()-1, pos=0; i&gt;=0; i--, pos++)
    {
        // Here we create the bitmask for this value
        if(a[i] == 1)
        {
            mask = 1;
            mask &lt;&lt; pos;
            myValue |= mask;
        }
    }
</code></pre>
",3
25447176,25446581,0,"<p>First of all the result of the conversion is not a literal. So you may not use prefix 0b applied to variable x.</p>

<p>Here is an example </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;limits&gt;

int main() 
{
    std::vector&lt;bool&gt; v = { 0, 1, 1, 1, 1, 0, 1, 1, 1, 0 };

    typedef std::vector&lt;bool&gt;::size_type size_type;
    size_type n = std::min&lt;size_type&gt;( v.size(), 
                                       std::numeric_limits&lt;long long&gt;::digits + 1 );

    long long x = std::accumulate( v.begin(), std::next( v.begin(), n ), 0ll,
                                   []( long long acc, int value )
                                   {
                                     return acc &lt;&lt; 1 | value;
                                   } );

    for ( int i : v ) std::cout &lt;&lt; i;
    std::cout &lt;&lt; std::endl;

    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>The output is</p>

<pre><code>0111101110
1ee
</code></pre>
",0
25448129,25446581,0,"<p><code>vector&lt;bool&gt;</code> is already a ""binary"" type. </p>

<p>Converting to an <code>int</code> is not possible for more bits than available in an <code>int</code>. However if you want to be able to print in that format, you can use a <code>facet</code> and attach it to the locale then <code>imbue()</code> before you print your <code>vector&lt;bool&gt;</code>. Ideally you will ""store"" the locale once. </p>

<p>I don't know the GNU extension for printing an <code>int</code> with <code>0b</code> prefix but you can get your print facet to do that.</p>

<p>A simpler way is to create a ""wrapper"" for your <code>vector&lt;bool&gt;</code> and print that. </p>

<p>Although <code>vector&lt;bool&gt;</code> is always internally implemented as a ""bitset"" there is no public method to extract the raw data out nor necessarily a standard representation for it. </p>

<p>You can of course convert it to a different type by iterating through it, although I guess you may have been looking for something else?</p>
",0
21585705,21585644,2,"<p>There's just an improvement, but basically it's the same: you could store <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""nofollow""><strong><code>unique_ptr</code></strong></a>s instead of raw pointers.</p>

<p>But conceptually, you'll have to use pointers, as it's the only way to deal with polymorphism in this case.</p>

<p>Then </p>

<blockquote>
  <p>I want to have a vector that can store MyInterface objects, which I intend to store objects of MyImplemented class.</p>
</blockquote>

<p>If you know you'll store only objects of type <code>MyImplemented</code>, you could also just use an <code>std::vector&lt;MyImplemented&gt;</code> directly.</p>
",6
21585707,21585644,3,"<p>You can use smart pointer instead of built-in pointer (std::unique_ptr) or you can use boost::any and then cast to real type</p>
",2
21585842,21585644,0,"<p>If you are going to have only MyImplemented , then there is no reason why you can't do</p>

<p>std::vector myVector;</p>

<p>The memory allocation is WAY easier with that layout, and you may get some performance boosts as well, as the memory layout (can be) more cache friendly.</p>

<p>This (however) implies a one-to-one relationship between interface and implementation. In that case, there is very little need to use polymorphism: it makes your code more complicated. You also take a (small) performance hit with virtual function calls.</p>

<p>What would NOT work is this:</p>

<p>std::vector myVector;//SO BAD</p>

<p>Because of narrowing: you need to use references of some type.</p>
",0
22485290,22485188,5,"<pre><code>#define VER = 1.0
</code></pre>

<p>remove the assignment operator from the above line and you should be fine. Preprocesser definitions have the form:</p>

<pre><code>#define NAME VALUE
</code></pre>
",0
21035647,21035580,0,"<p>Among a bunch of other issues, your <code>operator+()</code> is returning a non-<code>const</code> l-value reference, not a temporary r-value ... thus it's going to bind to the <code>const</code> l-value reference in the copy assignment operator.</p>
",0
21035694,21035580,1,"<p>Your <code>operator+</code> not only is leaking memory, but is also returning a <code>Mat::Matrix</code> <em>by reference</em>. Therefore the expression <code>mat1 + mat2</code> can only bind to:</p>

<pre><code>Matrix &amp;operator=(const Matrix&amp;);
</code></pre>

<p>What you want to do is to return a <code>Matrix</code> by value, instead. Finally, I see you are using <code>new</code> all over the place. You don't need dynamic allocation, especially with <code>std::vector</code>.</p>
",0
26815767,26814835,0,"<p>A declaration of a function only says how this function <em>may be called</em>. It need not to match, and in some cases it may not match. Consider a case:</p>

<pre><code>class T
{
   static int GetDefault();
};

int T::GetDefault()
{
   return 0;
}
</code></pre>

<p>Here, it not <em>not</em> required to use <code>static</code> keyword in implementation. Some compiler may render a warning, or some static analyses tool me render warning (although it doesn't harm). Also, note that parameter name may not match (or may be omitted in either declaration or implementation), since only base prototype is needed <em>for the callers</em>.</p>

<pre><code>int Compute(int,int);
int Compute(int a, int b) 
{
    return a*b;
}
</code></pre>

<p>In case of default argument, you give default argument <em>for the callers</em>, and not for the implementation of function itself (unless implemented inline in class).</p>
",0
26814897,26814835,1,"<p>The declaration you are showing is not sufficient to produce this error, but it can arise if you separate the function declaration and implementation and accidentally have the default in both. Be sure to only specify the default parameter in one of them.</p>

<p>I.e. instead of</p>

<pre><code>// declaration, usually in .h
void print_vector(vector&lt;int&gt;&amp;c, const char *title="""");

// implementation, usually in .cpp
void print_vector(vector&lt;int&gt;&amp;c, const char *title="""") {
    // code
}
</code></pre>

<p>do</p>

<pre><code>// declaration, usually in .h
void print_vector(vector&lt;int&gt;&amp;c, const char *title="""");

// implementation, usually in .cpp
void print_vector(vector&lt;int&gt;&amp;c, const char *title) {
    // code
}
</code></pre>

<p>or the other way round, i.e. with the default value in the implementation (though the way shown above is usually preferred, because it makes the behavior and usage clear to a reader of your header file). Also notice the const char* to avoid warnings (or even errors as pointed out by AndreyT, thanks!).</p>
",10
25690529,18408761,1,"<p>Given the format you are specifying, here is what I would do.</p>

<pre><code>for (int n; std::cin &gt;&gt; n; )
{
    if (n == 0)     // Test for end of input
        break;

    for (int i = 0; i != n; ++i)
    {
        int x;
        std::cin &gt;&gt; x;
        if (!std::cin)
            break;

        // Valid input x. Now do something with x like
        // v.push_back(x) where v is some vector of ints
    }
}

// Did we succeed?
if (!std::cin)
{
    // Something went bad.
    std::cerr &lt;&lt; ""Error reading input"" &lt;&lt; std::endl;

    return EXIT_FAILURE;
}
</code></pre>
",0
28531386,28531304,4,"<p><code>using T1 = T2;</code> is new (as of C++11) syntax that provides an alternative to <code>typedef</code>. <code>using Type = typename X::Type;</code> means exactly the same thing as <code>typedef typename X::Type Type;</code>.</p>

<p><code>using typename X::Type;</code> is older syntax, specifically intended for inheriting members from base classes. Normally, the <code>typename</code> would be redundant, normally you would be able to write <code>using X::Type;</code> instead, but in the case of template base classes, you may need <code>typename</code> to prevent <code>X::Type</code> from being parsed as a non-type member.</p>

<p>An example where they differ is</p>

<pre><code>struct A {
  typedef int i;
};

struct B {
  using i = typename A::i; // valid
  using typename A::i; // invalid, A is not a base class of B
};
</code></pre>
",0
28531445,28531304,1,"<p>The first form introduces a new name for a type, it's alternative syntax for <code>typedef</code>.</p>

<p>The second form redeclares a name for use in the current scope. i.e. it makes a name from another scope usable in the current scope qualifying it, e.g. <code>using std::swap</code> means you can just say <code>swap</code> instead of <code>std::swap</code>.</p>
",3
29514072,29513969,10,"<p>Write an additional function that takes just one argument and calls the original function:</p>

<pre><code>inline void function(int a)
{
    function(a, a);
}
</code></pre>
",5
29514215,29513969,1,"<p>Default argument must be <code>global variable</code> or <code>global constant</code>, even <code>function</code>. But it can not be <code>local variable</code>, because <code>local var</code> can not ensure in build.</p>
",0
31905963,31905898,31,"<p><code>a |= b;</code> is just syntactic sugar for <code>a = a | b;</code>. Same syntax is valid for almost every operator in C++. </p>

<p>But <code>int i |= 5;</code> is an error, because in the definition line you must have an initialisation, that is an expression that does not use the variable being declared.</p>

<pre><code>int i=3;
i |= 5;
</code></pre>

<p>is valid and will give value 7 (3 | 5) to <code>i</code>.</p>
",3
31905981,31905898,9,"<p>It's the operator for assignment by bitwise OR.</p>

<p><a href=""http://en.cppreference.com/w/cpp/language/operator_assignment"" rel=""noreferrer"">http://en.cppreference.com/w/cpp/language/operator_assignment</a></p>

<blockquote>
<pre><code>int result |= 5;
</code></pre>
</blockquote>

<p>You cannot initialize an <code>int</code> and assign something to it at the same time. Initialization and assignment are different things. You'd have to write:</p>

<pre><code>int result = 0;
result |= 5;
</code></pre>

<p>If this is what you intend, of course. Since <code>int result |= 5;</code> is not C++, we can only guess about your intention.</p>
",0
24083636,24083379,4,"<p>Here's the example of an explicit initialization list in Lipmann's book.</p>

<pre><code>Point1 local1 = { 1.0, 1.0, 1.0 };
</code></pre>

<p>I <em>think</em> the point he's trying to make is that you must remember to use the explicit initialization! In other words they're not a replacement for constructors. If you forget to use the list...</p>

<pre><code>Point local2;
</code></pre>

<p>... then you have ""failed to initialize the object"". It's not that the initialization list can fail in any way, simply that you can fail to remember to use it.</p>

<p>Compare with a constructor</p>

<pre><code>Point::Point (int x=0, int y=0, int z=0) : x(x), y(y) z(z) {};
</code></pre>

<p>You can now do both, and still get well defined results.</p>

<pre><code> Point local3(1.0, 1.0, 1.0);
 Point local4; // uses default values of 0,0,0
</code></pre>
",4
22127069,22126986,0,"<p>You probably mean what kind of conversions are not checked at compile-time.</p>

<p><code>reinterpret_cast</code> conversions happen at run-time, which is why they are dangerous and may crash your program:</p>

<pre><code>struct CustomClass {};

int main()
{
    CustomClass c = {};
    int x = 0;
    x = *(reinterpret_cast&lt;int *&gt;(&amp;c)); // undefined behaviour, may e.g. crash
}
</code></pre>

<p>In contrast, the compiler would not allow you to convert a <code>CustomClass</code> to an <code>int</code> with a <code>static_cast</code>:</p>

<pre><code>struct CustomClass {};

int main()
{
    CustomClass c = {};
    int x = 0;
    x = static_cast&lt;int&gt;(c); // compiler error
}
</code></pre>
",0
31283389,31282902,0,"<p>First thing first, those two Widget3 implementations are not the same. The first implementaiton of Widget3 with shared_ptr will simply move pointers( will not copy Widget1 or Widget2 ). However, the second implementation will copy Widget1 and Widget2 into member variable.</p>

<p>Here is the proof:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

namespace
{
    std::ostream&amp; os = std::cout;
}

struct Widget1
{
    Widget1()
    {
        os &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;
    }
    Widget1( const Widget1&amp; rhs )
    {
        os &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;
    }
    Widget1( Widget1&amp;&amp; rhs )
    {
        os &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl; 
    }
};

struct Widget2
{
    Widget2()
    {
        os &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;
    }
    Widget2( const Widget2&amp; rhs )
    {
        os &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;
    }
    Widget2( Widget2&amp;&amp; rhs )
    {
        os &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;
    }
};

struct Widget3_1 {
    Widget3_1(std::shared_ptr&lt;Widget1&gt; widget1, std::shared_ptr&lt;Widget2&gt; widget2)
    : _widget1(std::move(widget1))
    , _widget2(std::move(widget2))
    {
    }
private:
    std::shared_ptr&lt;Widget1&gt; _widget1;
    std::shared_ptr&lt;Widget2&gt; _widget2;
};


struct Widget3_2 {
    Widget3_2(const Widget1 &amp; widget1, const Widget2 &amp; widget2)
    : _widget1(widget1)
    , _widget2(widget2)
    {
    }
private:
    Widget1 _widget1;
    Widget2 _widget2;
};


int main()
{
    const int repeatCount = 1;
    {
        os &lt;&lt; "" Widget3_1 : "" &lt;&lt; std::endl;
        std::shared_ptr&lt;Widget1&gt; widget1( new Widget1 );
        std::shared_ptr&lt;Widget2&gt; widget2( new Widget2 );

        Widget3_1(widget1, widget2);
    }
    {
        os &lt;&lt; "" Widget3_2 : "" &lt;&lt; std::endl;
        Widget1 widget1;
        Widget2 widget2;

        Widget3_2(widget1, widget2);
    }

} // int main
</code></pre>

<p>output:</p>

<pre><code> Widget3_1 :
__thiscall Widget1::Widget1(void)
__thiscall Widget2::Widget2(void)
 Widget3_2 :
__thiscall Widget1::Widget1(void)
__thiscall Widget2::Widget2(void)
__thiscall Widget1::Widget1(const struct Widget1 &amp;)
__thiscall Widget2::Widget2(const struct Widget2 &amp;)
</code></pre>

<p>Not only you have other things to worry about, I don't think there will be any difference between them. The difference may grow as the project grows big, but there is no way other than testing to prove what is exactly going on. Just to convince you, let's give you some test result. This was tested on VisualC, windows 8.1</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;intrin.h&gt;

namespace
{
    std::ostream&amp; os = std::cout;
    typedef decltype(__rdtsc()) ClockType;
    ClockType clock;

    void MeasureBegin()
    {
        clock = __rdtsc();
    }

    ClockType MeasureEnd()
    {
        return __rdtsc() - clock;
    }
}

struct Widget1
{
    Widget1()
        : a(0),b(1),c(2),d(3)
    {
    }
    int a,b,c,d;
};

struct Widget2
{
    Widget2()
        :j (""Hello, World"")
    {
    }
    std::string j;
};

struct Widget3 {
    Widget3(const Widget1 &amp; widget1, const Widget2 &amp; widget2)
    : _widget1(widget1)
    , _widget2(widget2)
    {
    }
private:
    Widget1 _widget1;
    Widget2 _widget2;
};

int main()
{
    const int testCount = 10;
    const int repeatCount = 100000;
    ClockType c = 0;

    for( int j = 0; j &lt; testCount; ++j )
    {
        Widget1 widget1;
        Widget2 widget2;

        MeasureBegin();
        for (int i = 0; i &lt; repeatCount; ++i)
        {
            Widget3(widget1, widget2);
        }
        c = MeasureEnd();
        std::cout &lt;&lt; "" 1 : "" &lt;&lt; c &lt;&lt; std::endl;

        Widget1* pwidget1 = new Widget1();
        Widget2* pwidget2 = new Widget2();

        MeasureBegin();
        for (int i = 0; i &lt; repeatCount; ++i)
        {
            Widget3(*pwidget1, *pwidget2);
        }
        c = MeasureEnd();
        std::cout &lt;&lt; "" 2 : "" &lt;&lt;  c &lt;&lt; std::endl;

        delete pwidget1;
        delete pwidget2;
    }
} // int main
</code></pre>

<p>output:</p>

<pre><code>1 : 5030133
2 : 5726116
1 : 4898262
2 : 5915359
1 : 4805982
2 : 4988638
1 : 4758595
2 : 5065566
1 : 5470122
2 : 5312685
1 : 5133652
2 : 5753500
1 : 5475479
2 : 5196111
1 : 5153481
2 : 5678220
1 : 4790526
2 : 4820254
1 : 4836252
2 : 5231158
</code></pre>

<p>No difference.</p>
",0
31283273,31282902,0,"<p>Your second way is better because there is no chance of memory leaks, in case you chose not to use a smart pointer.</p>

<p>There is no guarantee that it will all be done on the stack, though.</p>

<p>What if I wrote:</p>

<pre><code>Widget1 widget1;
Widget2 widget2;
Widget3 *widget3 = new Widget3(widget1, widget2);

int main(){
    // do something with 'widget3'
    delete widget3;
}
</code></pre>

<p>What about then?</p>

<p>You should prefer not using pointers whenever possible, it's just safer. But if there will be multiple handles to your data and you can't pass by reference (for whatever crazy reason) then by all means, go with example 1.</p>

<p>It's all about which method is better in the situation. No method will <strong>always</strong> be better than another.</p>
",0
28532592,28532535,4,"<blockquote>
  <p><code>typedef struct Foo Foo;</code></p>
  
  <p>as the compiler does have to report a clash between a typedef-name and
  a function name. However this does not appear to be common practice -
  why not?</p>
</blockquote>

<p>I hold this truth to be self-evident: cumbersome code is cumbersome. You can actually rather easily fix this by working in a namespace of your own (which, assuming the header file is C++, too, the <code>other_library</code> should also do.</p>
",0
28532616,28532535,3,"<p>Unfortunately, you cannot avoid this. From C++11 standard (3.3.10):</p>

<blockquote>
  <p>A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member, function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data member, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is visible.</p>
</blockquote>

<p>The only way to guard against it is the typedef trick you pointed out (thanks for that!), using namespaces, or adhering to naming conventions (the latter not helping when dealing with 3rd party code). You could also try to wrap the include in a namespace (shown bellow), but as the comments pointed out, this could cause link errors in certain situations.</p>

<pre><code>namespace otherlib {
#include ""other_library.h""
}
</code></pre>

<p>Then:</p>

<pre><code>otherlib::Foo();
</code></pre>
",3
28532995,28532535,1,"<p>current best practises protect against this already</p>

<ul>
<li><p>Naming Conventions, such as<br>
<code>void camelCase()</code> vs <code>class PascalCase</code><br></p></li>
<li><p>namespaces</p></li>
<li><p>wrapper libs for everything not modern C++</p></li>
</ul>
",3
24112690,24112555,2,"<p>No, the program will break if the initialization is failed. You cannot catch the exception and handle it because the global variables(static member data) is initialized before <code>main()</code>.</p>

<p>It's better to call <code>init_API()</code> and <code>deinit_API()</code> in <code>main()</code>.</p>
",0
24112694,24112555,1,"<p>This is covered by ¡ì3.6.2 [basic.start.init]/p4-6 of the standard:</p>

<blockquote>
  <p>It is implementation-defined whether the dynamic initialization of a
  non-local variable with static storage duration is done before the
  first statement of <code>main</code>. If the initialization is deferred to some
  point in time after the first statement of main, it shall occur before
  the first odr-use of any function or variable defined in the same
  translation unit as the variable to be initialized.<sup>35</sup></p>
  
  <p>[...]</p>
  
  <p>If the initialization of a non-local variable with static or thread storage duration exits via an exception, <code>std::terminate</code> is called.</p>
  
  <p><sup>35</sup> A non-local variable with static storage duration having initialization with side-effects must be initialized even if it is not odr-used.</p>
</blockquote>

<p>As there's no way your static object can be in the same translation unit as a function in the C library you are wrapping, the only way to guarantee initialization would be to define it in the same translation unit as <code>main()</code>, which doesn't strike me as adding any kind of convenience to the end user.</p>

<p>In any event, it's probably not a good idea to cause <code>std::terminate</code> to be called by throwing an exception if initialization fails. The end user probably want to do better error handling than that.</p>
",3
24112712,24112555,3,"<p>In my experience it is a bad idea to try and rely on static initialization order. </p>

<p>A better idea would be to get rid of the holder, and just go:</p>

<pre><code>int main()
{
    API_initializer foo;

    // rest of program
}
</code></pre>

<p>If you really want it to throw on failure then include a try..catch block.</p>

<p>NB. Make the class non-copyable to prevent accidents.</p>
",2
24117096,24112555,0,"<p>The answer is: it depends.  If the external API is implemented
in C (so that it will have no dynamic initialization), and it is
not used in any of your static initializers (which should be the
case, since there is no way that they can safely do <code>init_API</code>),
then the idiom is more or less safe (except that you shouldn't
allow an exception to escape from a static initializer.  Whether
it is a good idea or not is another question; if the
initialization can fail, you may not want to execute it before
you can catch and handle the error, which means that you're in
<code>main</code>. </p>
",0
25465746,25465630,1,"<p>C++ forbids the definition of non-const static data members in the body of a class (""inline definition"").  It becomes more obvious if you try to use an explicit constructor: for example,</p>

<pre><code>class turbo
{
public:
    static string m;
    static string s = string(""my_str""); // doesn't work
}
</code></pre>

<p>Hence, when you write <code>static string m</code> in the body of a class, it is merely a declaration, not a definition.  You will have to define it later:</p>

<pre><code>static string turbo::s = string(""my_str"");
</code></pre>

<p>In your case, you are simply invoking the default constructor in the definition:</p>

<pre><code>static string turbo::m; // calls the default constructor
</code></pre>

<p>(Like any static variable, initialization occurs at the very start of your program, before <code>main</code>.)</p>

<p>Note that the definition must also occur only once (to avoid multiple definitions), so it must not appear in a header file.</p>
",0
25465660,25465630,0,"<p>In the class definition you only declare the static variable</p>

<pre><code>class turbo
 {
 public:
 static string m;
 }
</code></pre>

<p>but it is not yet defined. To define the corresponding object you have to write</p>

<pre><code>string turbo::m;
</code></pre>

<p>Now it will exist regardless of whether instances of the class were created.</p>
",0
25465664,25465630,1,"<p>It's the difference between declaration and definition, very much like declaring a function with a forward reference, e.g.;</p>

<pre><code>int MyFuncion();
</code></pre>

<p>and actually defining it with its function body, e.g.,</p>

<pre><code>int MyFunction()
{
    return 1;
}
</code></pre>

<p>I know you have an object and not a function, but conceptually, the declaration/definition idea is the same.</p>
",0
25465688,25465630,4,"<p>To be honest, I was surprised by this too the first time,<br>
but found the very reasonable reason for it.</p>

<p>while member variables are stored within the object allocated space,
static members are not placed within the object memory space (either heap or stack)<br>
but have a private shared space. just like functions do.</p>

<p>Therefore, declaring the <code>static string m</code> within the class.
is just like saying: there is a shared definition of this somewhere
and the name is  <code>turbo::m</code>.</p>

<p>Hope this clears things up.</p>
",0
27162565,27162314,4,"<p>Do not use <code>malloc</code> to construct non-POD objects.  Use <code>new</code> instead.</p>

<p>All <code>malloc</code> does is allocate bytes -- it does <em>not</em> construct objects.  Your <code>sphere</code> object has virtual functions, is derived from a base class, etc.  These types must be properly constructed, and malloc doesn't do the job.</p>

<p>In addition, if you have calls to <code>free()</code>, they must also be changed to call <code>delete</code>.</p>

<p>The only time to use <code>malloc</code> in terms of object construction is if you're using <code>placement-new</code>, which your code is not doing.</p>
",2
30176274,30176204,4,"<p>Declare your Department class before it's called in College. (Move your Department declaration above your College declaration):</p>

<pre><code>class Department
{
 public:
 string name;
 int numOfStudents;
 Department* next;
 Department(){name[0] ; numOfStudents=0 ; next=NULL ;}
 Department( string n , int numS){ name ="" ""; n ;numOfStudents = numS  ; next=NULL;}
 void Print(){cout&lt;&lt;name&lt;&lt;"" ""&lt;&lt;numOfStudents;}
 };

class College{
public :
string name; //for name of the college
int numOfColleges;
int numDepartments; //number of departments in this college
Department * dep; //this will point to the department in this college
College * next; //the next pointer to point to the next college
College(){
    name ="" "";
    numDepartments=0 ;
    dep = NULL;
    next=NULL;}
College (string n, int numD ){name=n ;next=NULL;}
void Print(){
    cout&lt;&lt;name&lt;&lt;""\n"";
}
};
</code></pre>
",2
22109995,22109905,1,"<p>I think this is because <code>underflow</code> gets called twice. </p>

<p>This could be <a href=""https://stackoverflow.com/questions/11037818/c-stdistream-read-and-its-calls-to-stdstreambuf-underflow"">a bug</a>.</p>
",6
22110217,22109905,2,"<p>You initialize the buffer with (maybe 4) zeros </p>

<pre><code>buffer(std::max(buf_size, 1))
</code></pre>

<p>and append the content to the buffer without clearing the buffer.</p>

<p>You may change it to:</p>

<pre><code>int_type underflow()
{
    if (gptr() &lt; egptr())
        return traits_type::to_int_type(*gptr());

    if (is_)
    {
        char* beg = buffer.data();
        char* end = std::copy_n(
            std::istreambuf_iterator&lt;char&gt;(is_),
            size, beg);
        setg(beg, beg, end);
        return traits_type::to_int_type(*gptr());
    }
    return traits_type::eof();
}
</code></pre>

<p>You still have a bug here: std::copy_n might ask for too many characters.</p>

<p>Make it:</p>

<pre><code>int_type underflow()
{
    if (gptr() &lt; egptr())
        return traits_type::to_int_type(*gptr());

    if (is_)
    {
        char* beg = buffer.data();
        char* end = beg;
        char* limit = beg + buffer.size();
        std::istreambuf_iterator&lt;char&gt; in(is_);
        std::istreambuf_iterator&lt;char&gt; eos;
        for( ; end &lt; limit &amp;&amp; in != eos; ++end, ++in)
            *end = *in;
        setg(beg, beg, end);
        if(beg &lt; end)
            return traits_type::to_int_type(*gptr());
    }
    return traits_type::eof();
}
</code></pre>

<p>And eliminate the member size.</p>
",0
22116751,22116158,2,"<p>You need to flush also a <code>std::vector</code> (buffer), i.e:</p>

<pre><code>int_type overflow(int_type c)
    {
        if (os_ &amp;&amp; !traits_type::eq_int_type(c, traits_type::eof()))
        {
            *pptr() = traits_type::to_char_type(c);
            pbump(1);

            if (flush())
            {
                buffer.clear();  // &lt;-
                setp(buffer.data(), buffer.data() + buffer.size());
                return c;
            } else
                return traits_type::eof();
        }

        return traits_type::not_eof(c);
    }
</code></pre>

<p>Even better, as  <a href=""https://stackoverflow.com/users/701092/0x499602d2"">0x499602D2</a> address suggested use <code>pbump(-buffer.size())</code> to avoid multiple calls to <code>overflow()</code>.</p>
",1
22116766,22116158,0,"<p>The problem is that you use:</p>

<pre><code>setp(beg, beg + buffer.size());
</code></pre>

<p>and in overflow() you add new element with no reallocation, the end pointer should be accessible (if you dont want to reallocate), otherwise you need to reallocate your buffer in overflow(). So change it to:</p>

<pre><code>setp(beg, beg + buffer.size() - 1);
</code></pre>

<p>in io_buffer constructor</p>

<p>and later in overflow change setp to:</p>

<pre><code>pbump(-(pptr() - pbase()));
</code></pre>

<p>also to flush your buffer add endl:</p>

<pre><code>os &lt;&lt; str &lt;&lt; endl;
</code></pre>

<p>working example:
<a href=""http://coliru.stacked-crooked.com/a/7c72ecfe78bb2aee"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/7c72ecfe78bb2aee</a></p>
",0
27163381,27163339,5,"<pre><code>undefined reference to `vtable for object'
</code></pre>

<p>You are getting this error because you have not provided definition of virtual method in object. <code>Basically vtable stores function pointers</code> i.e address of virtual function is required. So if you miss the definition of single virtual function, compiler won't be able to generate complete vtable for that class.</p>

<p>For your object class <code>vtable</code> would be like something:-</p>

<pre><code>&amp;object::intersect
&amp;object::normal
</code></pre>

<p>EDIT:-</p>

<p>That means corresponding to these:-</p>

<pre><code>virtual float intersect(Point, Vector, object*, Point*);
virtual Vector normal(Point, object*);
</code></pre>

<p>You should have :- </p>

<pre><code>float object::intersect(Point, Vector, object*, Point*)
{
}

Vector object::normal(Point, object*)
{
}
</code></pre>
",5
27163598,27163339,1,"<p>If there's no definition for object::intersect &amp; object::normal, you should make them pure virtual functions as below:</p>

<pre><code>#ifndef OBJECT_H_      
#define OBJECT_H_
#include &lt;stdio.h&gt;
#include ""vector.h""

struct object{
public:
    int index;               // identifies a object; must be greater than 0
    float mat_ambient[3];    // material property used in Phong model
    float mat_diffuse[3];
    float mat_specular[3];
    float mat_shineness;
    float reflectance;       // this number [0,1] determines how much reflected light contributes to the color of a pixel
    virtual float intersect(Point, Vector, object*, Point*) = 0;
    virtual Vector normal(Point, object*) = 0;
};
#endif /* OBJECT_H_ */
</code></pre>

<p>Try it and I think it would figure out your problem.</p>
",0
27749864,27749816,1,"<p>Look at <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow noreferrer"">vector</a>.</p>

<pre><code>string sArray[3] = {""aaa"", ""bbb"", ""ccc""};
vector&lt;string&gt; sVector;
sVector.assign(sArray, sArray+3);
</code></pre>

<p>Source from <a href=""https://stackoverflow.com/questions/5839499/c-copying-a-string-array-to-a-vector-string"">here</a></p>
",0
27750062,27749816,1,"<p>Sane C++ code would use <code>vector</code> or <code>array</code>, and also <code>string</code>.  However, without those, pure C would often use a dynamic array of dynamic strings:</p>

<pre><code>char** strs = new char*[LEN];  //a dynamic array of dynamic strings
//Alternatively, char* (*strs)[LEN]
for(int i=0; i&lt;LEN; ++i) {
    strs[i] = new char[strlen(s[i])];
    strcpy(strs[i], s[i]);
}
//code goes here
for(int i=0; i&lt;LEN; ++i) 
    delete[] strs[i];
delete[] strs;
strs = NULL;
</code></pre>

<p>However, your code is closer to a dynamic array of fixed length strings:</p>

<pre><code>char **strs = new char[n][LEN];  //a dynamic array of dynamic strings
//Alternatively, char(*strs)[LEN][n], or is it char(*strs)[n][LEN]?
for(int i=0; i&lt;LEN; ++i) 
    strcpy(strs[i], s[i]);
//code goes here
delete[] strs;
strs = NULL;
</code></pre>
",0
27750214,27749816,1,"<p>You invert the dimension of <code>str</code>, try:</p>

<pre><code>const int LEN = 3;
const int n = 15;
const char *s[LEN] = {""music"", ""disc"", ""soft""};
char (*str)[n] = new char[LEN][n];

for(int i = 0; i &lt; LEN ; i++) {
    strncpy(str[i], s[i], n);
}
for(int i = 0; i &lt; LEN ; i++)
    std::cout &lt;&lt; str[i] &lt;&lt; std::endl;

delete []str;
</code></pre>

<p><a href=""http://ideone.com/f99aba"" rel=""nofollow"">Live example</a></p>
",0
29455368,29455313,1,"<p>To check if a stream has failed you can use the <code>fail()</code> member function or just conversion to <code>bool</code>. The conversion yields <code>true</code> iff. <code>not fail()</code>.</p>

<p>Do note that <code>good()</code> is not the opposite of <code>fail()</code>. <code>good()</code> yields <code>true</code> if none of the error flags are set, and this includes in particular the EOF flag. <code>fail()</code> checks only <code>badbit</code>. I.e., conversion to <code>bool</code> is not the same as <code>good()</code>.</p>

<p>The usual idiom for formatted readin, <code>while( stream &gt;&gt; variable )</code>, uses conversion to <code>bool</code>, i.e. it's checking <code>fail()</code>.</p>

<hr>

<p>For an academic exercise you may (or may not) be expected to deal with the case where the stream has been configured to throw exceptions on failures. In that case you also need a <code>try ... catch</code> construction.</p>

<p>That's only for the academic because the design of iostream exception throwing is wholly impractical and thus never used: it's not an in-practice consideration. Instead of adjusting your code when encountering such a beast, one would instead identify the responsible programmer and adjust that person. So, it's wholly academical, but dealing with it may (or may not) be required for an academic exercise.</p>

<hr>

<p>Regarding accessing a private variable that the compiler tells you is inaccessible, there are technical solutions (in particular Johannes Schaub's trick, working entirely within the ordinary type checking rules), but the chance of you needing such a solutions is about the same as three elephants dropping down from the sky and performing Abba's ""Money money money"". Or something. Much more likely you're intended to do this in a member function of the relevant class, or else use appropriate member functions of that class, about which you have provided no information at all.</p>
",4
29455476,29455313,0,"<p>For an input stream , if the specified file does not exist, it will <strong>not</strong> be created by the operating system, and the input stream variable will contain an error flag. This can be checked using the member function <code>fail()</code>.</p>

<blockquote>
  <p><strong>fail()</strong> provides a way to check the status of the last operation on the
  input stream .</p>
  
  <p><strong>fail()</strong> returns true if the last operation failed and returns false if
  the operation was successful.</p>
</blockquote>

<pre><code> std::istream&amp; read(std::istream&amp; istr){
  if (istr.fail()){
      Date::_readErrorCode = CIN_FAILED;
      /*_readErrorCode is the private variable*/
  }
}
</code></pre>

<p>Hope I Helped.</p>
",5
29467196,29455313,0,"<p>Completely my fault on making it impossible for others to answer, however I figured out that all I was missing was a scoop;</p>

<pre><code>  std::istream&amp; Date::read(std::istream&amp; istr){
  if (istr.fail){
      _readErrorCode = CIN_FAILED;
  }
}
</code></pre>

<p>read wasn't getting scooped to the Date class which is why I _readErrorCode wasn't being defined and scoping directly to a private variable wouldn't work obviously. Thanks to everyone that answered! </p>
",0
22492612,22492502,1,"<p>Getting rid of repeating letters is easy: just insert into a <code>&lt;set&gt;</code> or delete the letters after you see them. Inserting into a set is more efficient however:</p>

<pre><code>set&lt;char&gt; letters;
for(int i=0; i&lt;sentence.length(); i++)
    for(int j=i+1; j&lt;sentence.length(); j++)
        if((!isspace(sentence[i]))&amp;&amp;(sentence[i] == sentence[j])){
            letters.insert(sentence(i));
        }
for(auto &amp;i : letters)
    cout &lt;&lt; i &lt;&lt; endl;
</code></pre>
",0
22492626,22492502,3,"<p>The problem is your inner loop.  It displays the letter once every time it's encountered.  Also, you do not break out of the loop after seeing a duplicate, so you get an exponential mess.</p>

<p>A better way is to just record how many times you've seen a letter.  That requires just one loop and an array:</p>

<pre><code>int count[256] = {0};
for( int i = 0; i &lt; sentence.length(); i++ ) {
    char c = sentence[i];
    if( isalpha(c) &amp;&amp; count[c]++ == 1 ) cout &lt;&lt; c;
}
</code></pre>

<p>Instead of the array, you can use <code>std::set</code>.  That would be more appropriate if you were handling Unicode.  However, we're just dealing with a <code>char</code> here, which is 8 bits on almost every architecture you're likely to be practising on.</p>

<hr>

<p>A little bonus of doing it this way is that you compute the letter frequencies.  You can output these as follows:</p>

<pre><code>for( int c = 0; c &lt; 256; c++ ) {
    if( count[c] ) cout &lt;&lt; (char)c &lt;&lt; "" : "" &lt;&lt; count[c] &lt;&lt; endl;
}
</code></pre>

<p>If you want to output case-insensitive counts, one way to do it is like this:</p>

<pre><code>for( int c = 'a'; c &lt;= 'z'; c++ ) {
    int total = count[c] + count[toupper(c)];
    if( total ) cout &lt;&lt; (char)c &lt;&lt; "" : "" &lt;&lt; total &lt;&lt; endl;
}
</code></pre>
",2
22887778,22887731,1,"<p>You could build a map containing the letters ""car"" with the values set to 0. Cycle through the array with all the letters and if it is a letter in the word ""car"" change the value to 1. If all the keys in the map have a value greater than 0, than the word can be constructed. Try implementing this.</p>
",1
22887786,22887731,0,"<p>A very primitive code would be something like this:</p>

<pre><code>for ( std::string::iterator it=str.begin(); it!=str.end(); ++it)
    for ( std::string::iterator it2=str2.begin(); it2!=str2.end(); ++it2) {
        if (*it == *it2) {
            str2.erase(it);
            break;
        }
    }

if (str2.empty())
    found = true;
</code></pre>
",1
22887973,22887731,1,"<p>An anagram is a type of word play, the result of rearranging the letters of a word or phrase to produce a new word or phrase, using all the original letters exactly once;</p>

<p>So, actually what you are looking for is an algorithm to check if two words are ""Anagrams"" are not.</p>

<p>Following thread provides psuedocode that might be helpful
<a href=""https://stackoverflow.com/questions/12477339/finding-anagrams-for-a-given-word"">Finding anagrams for a given word</a></p>
",0
22888225,22887731,0,"<p>You could build up a table of count of characters of each letter in the <code>word</code> you are searching for, then decrement those counts as you work through the search <code>str</code>ing.</p>

<pre><code>bool IsWordInString(const char* word, const char* str)
{
    // build up table of characters in word to match
    std::array&lt;int, 256&gt; cword = {0};
    for(;*word;++word) {
        cword[*word]++;
    }
    // work through str matching characters in word
    for(;*str; ++str) {
        if (cword[*str] &gt; 0) {
            cword[*str]--;
        }
    }
    return std::accumulate(cword.begin(), cword.end(), 0) == 0;
}
</code></pre>

<p>It's also possible to return as soon as you find a match, but the code isn't as simple.</p>

<pre><code>bool IsWordInString(const char* word, const char* str)
{
    // empty string
    if (*word == 0)
        return true;
    // build up table of characters in word to match
    int unmatched = 0;
    char cword[256] = {0};
    for(;*word;++word) {
        cword[*word]++;
        unmatched++;
    }
    // work through str matching characters in word
    for(;*str; ++str) {
        if (cword[*str] &gt; 0) {
            cword[*str]--;
            unmatched--;
            if (unmatched == 0)
                return true;
        }
    }
    return false;
}
</code></pre>

<p>Some test cases</p>

<pre><code>"""" in ""crqijfnsa"" =&gt; 1
""car"" in ""crqijfnsa"" =&gt; 1
""ccar"" in ""crqijfnsa"" =&gt; 0
""ccar"" in ""crqijfnsac"" =&gt; 1
</code></pre>
",0
22888383,22887731,0,"<p>I think the easiest (and probably fastest, test that youself :) ) implementation would be done with <code>std::includes</code>:</p>

<pre><code>std::string testword {""car""};
std::string testarray {""crqijfnsa""};

std::sort(testword.begin(),testword.end());
std::sort(testarray.begin(),testarray.end());

bool is_in_array = std::includes(testarray.begin(),testarray.end(),
    testword.begin(),testword.end());
</code></pre>

<p>This also handles all cases of duplicate letters correctly.
The complexity of this approach should be <code>O(n * log n)</code> where <code>n</code> is the length of <code>testarray</code>. (<code>sort</code> is <code>O(n log n)</code> and <code>includes</code> has linear complexity.</p>
",0
23599679,23599562,1,"<p>AbsTree is an abstract class, like you said. This means that you need to create a <strong>derived</strong> class in order to provider an implementation.</p>

<pre><code>// ConcreteTree.h

#include ""AbsTree.h""

class ConcreteTree : public AbsTree {
   public:
       ConcreteTree();
       virtual ~ConcreteTree();
       virtual void accept(Visitor &amp;visitor) const;
       virtual void execute(Env &amp;ctxt) const throw (InappropriateFunction);
}
</code></pre>

<p>Then:</p>

<pre><code>// ConcreteTree.cpp

#include ""ConcreteTree.h""

ConcreteTree::ConcreteTree() {}
ConcreteTree::~ConcreteTree() {}
ConcreteTree::accept(Visitor &amp;visitor) const{}
ConcreteTree::execute(Env &amp;ctxt) const {}
</code></pre>
",5
23600194,23599562,3,"<p>Here's a compilable/runnable version of your code (runnable at <a href=""https://ideone.com/Ef22JU"" rel=""nofollow"">ideone here</a>)</p>

<pre><code>struct Visitor { };
struct Env { };
struct InappropriateFunction { };

class AbsTree { 
   public:
       AbsTree();
       virtual ~AbsTree() =0;
       virtual void accept(Visitor &amp;visitor) const = 0;
       virtual void execute(Env &amp;ctxt) const throw (InappropriateFunction);
};

class Operation: public AbsTree{
   public:
      Operation(char oper);
      virtual ~Operation();
      virtual void accept (Visitor &amp;visitor) const;
      char getOperator() const;
   private:
      char operator_;
};

AbsTree::AbsTree() {}
AbsTree::~AbsTree() {}
void AbsTree::accept(Visitor &amp;visitor) const{}
void AbsTree::execute(Env &amp;ctxt) const throw (InappropriateFunction) {}

Operation::Operation(char oper): operator_(oper) {}
Operation::~Operation(){}
void Operation::accept(Visitor &amp;visitor) const{}
char Operation::getOperator() const {
   return operator_;
}

int main()
{
    Operation o('x');
    Visitor my_visitor;
    o.accept(my_visitor);
    o.getOperator();
}
</code></pre>

<p>Basically, you've got to take more care to make sure the functions you define match your declarations - that includes <code>const</code> and <code>throw</code> specifications and return type.  Further, <code>operator</code> is a reserved keyword and you can not use it to name your own variables.</p>

<p>Separately, exception specifications are deprecated... best to leave them out as they never proved useful.  (C++11 has a <code>noexcept</code> keyword that's occasionally useful if you want to make it clear that a function can be used in code making exception guarantees - might get a little extra optimisation too, but if an exception is raised in/under the function your program will call <code>std::terminate</code>).</p>
",0
21593433,21592713,1,"<p>Yes, you seem to understand this correctly.</p>

<p>One use case of this is to write generic code but still get the benefits of a compile-time constant (such as better compiler optimizations).</p>

<p>One example is <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow"">std::array</a>, which takes such a template <code>size_t</code> parameter for its length. Another example is <a href=""http://en.cppreference.com/w/cpp/types/enable_if"" rel=""nofollow"">std::enable_if</a>, which uses a <code>bool</code>.</p>
",0
26419805,26419786,32,"<p>It is by design. In C++ every kind of failure is notified by throwing an exception by default &mdash; streams, however, are exception, which does <strong>not</strong> throw exception (pun intended) <em>by default</em>.</p>

<p>You can use nothrow version as:</p>

<pre><code>T *p = new (std::nothrow) T(args);

if ( p == nullptr ) //must check for nullity
{
     std::cout &lt;&lt; ""memory allocation failed"" &lt;&lt; std::endl;
}
</code></pre>
",1
26419860,26419786,2,"<p>you can specify that you want new to return 0 instead of throwing <code>std::bad_alloc</code> using the <code>std::nothrow parameter:</code></p>

<pre><code>SomeType *p = new(std::nothrow) SomeType;
</code></pre>
",0
26420073,26419786,16,"<p>Just a historical note, not an answer to this question (there are plenty of good answers)... a long long time ago when dinosaurs roamed the earth and Turbo C++ was ruling the world of C++ programmers, <code>new</code> actually returned <code>NULL</code>. Quote from a book of those days (0bj3ct-0r13nt3d Pr0gr4mm1ng with ANSI and Turbo C++ - title intentionally obfuscated so that <strong>no one by mistake reads it anymore</strong>) page 115.</p>

<blockquote>
  <p>If the new operator fails to allocate memory it returns NULL which can be used to detect failure or success of new operator.</p>
</blockquote>

<p>because of this legacy code is full with a lot of NULL checking ... a real nightmare to bring them up to the current standard...</p>

<p>However, here is a tiny piece of the C++ standard 5.3.4/13:</p>

<blockquote>
  <p>[ Note: unless an allocation function is declared with a non-throwing exception-specification (15.4), it indicates
  failure to allocate storage by throwing a std::bad_alloc exception (Clause 15, 18.6.2.1); it returns a
  non-null pointer otherwise. If the allocation function is declared with a non-throwing exception-specification,
  it returns null to indicate failure to allocate storage and a non-null pointer otherwise. ¡ªend note ] If the
  allocation function returns null, initialization shall not be done, the deallocation function shall not be called,
  and the value of the new-expression shall be null.</p>
</blockquote>

<p>which tells you that in some special cases, <code>new</code> can return <code>NULL</code></p>
",3
26419989,26419786,2,"<p>By default, when the new operator is used to attempt to allocate memory and the handling function is unable to do so, a bad_alloc exception is thrown. But when nothrow is used as argument for new, it returns a null pointer instead.</p>

<p>The nothrow constant is a value of type nothrow_t, with the only purpose of triggering an overloaded version of the function operator new (or operator new[]) that takes an argument of this type. The value itself is not used, but that version of operator new shall return a null pointer in case of failure instead of throwing an exception.</p>
",0
26420011,26419786,64,"<p>Before exceptions were introduced in C++:</p>

<ul>
<li><p>A failing <code>new</code>-expression produced a nullpointer.</p></li>
<li><p>In a failing constructor one assigned a nullpointer to <code>this</code>.</p></li>
</ul>

<p>After exceptions were introduced:</p>

<ul>
<li><p>A failing ordinary <code>new</code>-expression throws an exception.</p></li>
<li><p>In a failing constructor one throws an exception.</p></li>
</ul>

<p>One difference is that failure reporting for constructors now works also for creation of objects without dynamic allocation.</p>

<p>Another difference is that code using <code>new</code>-expressions now can be simpler since the error handling can be moved out of each such code place, and centralized.</p>

<p>The old nullpointer-result behavior is still available via <code>std::nothrow</code> (include the <code>&lt;new&gt;</code> header). This implies checking at each place using <code>new</code>. Thus nullpointer results are in conflict with the DRY principle, <em>don't repeat yourself</em> (the redundancy offers an endless stream of opportunities to introduce errors).</p>
",1
26422143,26419786,10,"<p>in C++, operator <code>new</code> is not only to allocate a chunk of memory, it is also class construction. thus, in semantic, operator <code>new</code> is much richer than function <code>malloc</code>. via exceptions, we get better informations and we can handle construction failures better.</p>
",0
26430938,26419786,7,"<p>In the comments, you emphasized that you wanted to know <em>why</em> <code>new</code> is designed this way.  In my mind, it's all about object composition.</p>

<p>Consider a class Foo which contains (among other things) a std::vector.</p>

<pre><code>class Foo {
  public:
    explicit Foo(std::size_t n) : m_vec(n, 'A') {}
    ...
  private:
    std::vector&lt;char&gt; m_vec;
    ...
};
</code></pre>

<p>When you construct a Foo in dynamic memory, there are two memory allocations:  one of the Foo itself, and one for the contents of its vector.  If either one fails, you need to be assured that there are no leaks and that the problem is reported to the caller.</p>

<pre><code>Foo * pfoo = new Foo(desired_size);
</code></pre>

<p>Suppose <code>new</code> did return a null pointer upon failure.  If the allocation for the Foo fails, <code>pfoo</code> will be set to a null pointer, and you could rely on that to do your error detection.  Terrific.  You then have some error handling code like:</p>

<pre><code>if (pfoo == nullptr) { ... }
</code></pre>

<p>Now consider the nested object.  If the allocation for the contents of <code>m_vec</code> fails, you'd have to detect that and report it to the calling code, but there's no way for you to get a null pointer to propagate out to the assignment to <code>pfoo</code>.  The only way to do that is to have std::vector throw an exception (for <em>any</em> kind of construction problem), so the error handling code we just added would be useless because it's looking for null pointer instead of exceptions.</p>

<p>Having <code>new</code> throw a <code>std::bad_alloc</code> allows you to treat nested dynamic memory allocation failures the same way you treat outer ones.  That's a powerful way to avoid code duplication and errors.</p>

<p>The C++ committee could have let <code>new</code> return a null pointer on an allocation failure, but every constructor that used <code>new</code> for internal memory would have to detect the failure and turn it into an exception anyway.  So having <code>new</code> throw by default simplifies everyone's code.</p>

<p>For those cases where your constructor can do something reasonable even in the face of an allocation failure, you can explicitly ask for the null pointer with <code>std::nothrow</code> and then handle the error (or you can catch the <code>std::bad_alloc</code>).</p>

<h2>Aside</h2>

<p>Also consider what happens if we stack allocate a Foo.</p>

<pre><code>Foo foo(desired_size, 'B');
</code></pre>

<p>If we had somehow managed to make construction problems return a null pointer, how would the calling code detect it?</p>
",6
26432264,26419786,4,"<p>In C, all requests for dynamic memory are made by function calls; it's necessary that code check any allocation requests to see if they return <code>null</code>, but there is a well-defined place where such checks can be made (i.e. right after the call).  In C++, while it is possible for code to construct objects by calling <code>new</code>, most objects are created by creating an object in which they play a part.</p>

<p>Given:</p>

<pre><code>class Story
{
  Potter harry;
  Weasley ron,ginny,george,fred;
  Grainger hermione;
  Longbottom neville;
  Creevy colin;
  Story()
  {
  }
}
</code></pre>

<p>If the constructor for <code>harry</code> tries to create a <code>new</code> object and fails, the only way to prevent the system from trying uselessly to create objects for all the other fields would be to have the constructor throw an exception.  Even though the constructor for <code>harry</code> failed, the other constructors might <em>succeed</em> in creating those objects if they require less memory than a <code>Potter</code> object; since the failure to create <code>harry</code> would render the <code>Story</code> object useless, however, any effort spent creating objects for the remaining fields would not only be wasted, but would require the system to expend even more effort destroying those uselessly-created objects.</p>

<p>Since in most cases the only thing the system would be able to do when <code>new</code> fails is to throw an exception, it's easier to have <code>new</code> throw the exception itself and have code catch the exception if necessary, than to require that all code which calls <code>new</code> must check whether it succeeded and throw an exception if it didn't.</p>
",0
21323511,21323417,0,"<p>No, you simply use a <code>vector</code> to a <code>vector</code> (or <code>std::array</code> if size is fixed):</p>

<pre><code>vector&lt;vector&lt;T&gt;&gt; data;
</code></pre>
",3
21323601,21323417,0,"<p>A more normal approach would be along these lines:</p>

<pre><code>    int colSize = 10;
    int rowSize = 12;
    typedef int T;

    std::vector&lt;std::vector&lt;T&gt; &gt; data(colSize);
    std::for_each ( data.begin(), data.end(), 
        [rowSize] (std::vector&lt;T&gt;&amp; row)
    {
        row.resize(rowSize);
    });
</code></pre>

<p>However, as commented usually by ""matrix"" we do always mean a fixed row size (as in the example), and use a single 1D underlying array or <code>vector</code> and provide an interface to provide a <code>2D</code> ( or <code>3D</code> or whatever) look up.</p>
",0
24768503,24768456,1,"<p>You'll have to move one of them outside of its constructor and pass it in after creation:</p>

<pre><code>Console C;
Logger L(&amp;C);
C.set(&amp;L);
</code></pre>
",2
24768510,24768456,-1,"<p>You'll have to dynamically create one of the two objects to avoid issues with initialization order.</p>
",2
24768515,24768456,-1,"<p>With such constructors as you require this is not possible. You have to allow one of the objects to have default constructor and set the pointer later.</p>
",1
24768526,24768456,0,"<pre><code>Console(){} 
Logger(Console * C): C(C) {C-&gt;L=this;}

Console C();
Logger L(&amp;C);
</code></pre>
",0
24768566,24768456,0,"<p>Unfortunately no, what I suggest is that you move the the ""binding"" of them to a separate function. </p>

<p>For this particular use case I recommend creating a <code>bindLogger</code> method in both classes:</p>

<pre><code>void Console::bindLogger( Logger * logger ) {
     if (logger != L) {
         L = logger;
         logger-&gt;bindConsole( this );
     }
}
</code></pre>
",2
24768621,24768456,3,"<p>The answer is, it depends.</p>

<p>Do both objects require the other being up and running?<br>
You are SOL, they cannot both be constructed last. Reconsider your design. Maybe you can get basic service set up without referring to the other object for one of them, think multi-stage init.</p>

<p>Do both only need to save that reference for later use?<br>
The order does not matter, use a forward declaration for at least one of them. You might even define them in separate compilation units.</p>

<p>Does exactly one of them potentially use the other in its ctor / dtor (including indirectly)?<br>
Define that object <strong>later in the same compilation unit</strong> and you are ok.</p>

<pre><code>extern Type name; // This is a forward declaration, like in headers
</code></pre>
",0
24768753,24768456,0,"<p>The only solution I can think of, which might not be good design, is:</p>

<pre><code>class Logger;
class Console;

class Console
{
public:
    Console(Logger *l) : l(l) {}

private:
    Logger *l;
};

class Logger
{
public:
    Logger(Console *c) : c(c) {}

private:
    Console *c;
};

class Together
{
public:
    Together()
        : c(&amp;l)
        , l(&amp;c)
    {
    }

private:
    Console c;
    Logger l;
};
</code></pre>
",1
22114536,22114503,2,"<p>You declared <code>validateLogin</code> in <code>View</code> class, but defined it in <code>Model</code> class. Simplest fix is to remove the </p>

<pre><code>void validateLogin(string u, string p); 
</code></pre>

<p>line from the <code>View</code>'s header.</p>

<p>Or move the definition from <code>Model</code> to <code>View</code>.</p>
",2
22114537,22114503,1,"<p>You should define <code>validateLogin</code> in View and not in Model.</p>

<pre><code>class Model // see you are defining validateLogin in Model
{
    void showHome();  
    public:
        // class constructor
        Model();
        // class destructor
        ~Model();

    public:
           void validateLogin(string u, string p){

                if(u==""admin"" &amp;&amp; p==""1234""){
                     showHome();
                     }
</code></pre>
",3
22114639,22114503,1,"<p>The problem is that you promised the compiler that there would be <code>validateLogin</code> function in the <code>View</code> class, but you failed to define. Instead, you defined one in the <code>Model</code> class, which is the correct place for such function to be. Now you need to add a reference to <code>Model</code> to your <code>View</code> class, so that you could call <code>model.validateLogin()</code> in your implementation file:</p>

<pre><code>class View {
    string username,password;
    Model &amp;model;
    // validateLogin is removed
public:
    // class constructor
    View(Model&amp; m) : model(m) {};
    ...
};
</code></pre>

<p>You will need to move the code of <code>showLogin</code> into cpp file, because you cannot call <code>validateLogin</code> until <code>Model</code>'s interface is fully declared.</p>

<p>Now change your <code>main</code> to make a <code>Model</code> before the view, and give that model to the <code>View</code>'s constructor:</p>

<pre><code>int main()
{
    Model m;
    View v(m);
    v.showLogin();
}
</code></pre>
",0
29182284,29182008,0,"<p>No, you cannot pass a 1d array (or a pointer to one) to a function that's declared to take a 2d array.</p>

<p>If you need to allocate a 2d array dynamically, what you can do is:</p>

<pre><code>// ny can be runtime variable in c99, but must be compile time constant in c++
constexpr int ny = 10;
int nx = 10;
double (*p)[ny]  = new double[nx][ny];
fun(nx, ny, p);
</code></pre>

<p>If you want to use your 1d array as is, you'll need to modify <code>fun</code> to accept a 1d array instead:</p>

<pre><code>// note that double a[] or double* a param would be identical, nx*ny is just for documentation
void fun(int nx, int ny, double a[nx*ny])
     // access indices [i][j] like this: a[nx*j + i]
</code></pre>

<p>In c++ however, I would recommend you to hide any dynamic allocation behind an abstraction that will manage the memory. Say, a <code>Matrix</code> class in this case.</p>
",0
29182430,29182008,2,"<p>What you want is not possible in C++ because C++ requires the sizes of array types to be compile time constants. C99 does not have this limitation, so the function declaration</p>

<pre><code>void fun(int nx, int ny, double a[nx][ny]);
</code></pre>

<p>is valid C99, but not valid C++. Btw, in C99, the correct call of this function would look like this:</p>

<pre><code>int nx = ..., ny = ...;
double (*matrix)[ny] = malloc(nx*sizeof(*matrix));
fun(nx, ny, matrix);
</code></pre>

<p>Now, you have two possibilities:</p>

<ol>
<li><p>Use C for your multidimensional array stuff.</p></li>
<li><p>Use a C++ workaround for this.</p></li>
</ol>

<hr>

<p>The easiest C++ workaround would be a <code>vector&lt;vector&lt;double&gt; &gt;</code>. With that you avoid the hassle of allocating the memory yourself, however, the rows in your 2D matrix are not consecutive.</p>

<hr>

<p>You can also use a two layer indirection like this:</p>

<pre><code>double **matrix = new double*[nx];
for(int i = 0; i &lt; ny; i++) matrix[i] = new double[ny];
</code></pre>

<p>and declare your function as</p>

<pre><code>void fun(int nx, int ny, double** a);
</code></pre>

<p>Note that you need one additional index array in addition to the arrays that hold the data. However, you are free to use a single large array to hold the data:</p>

<pre><code>double** matrix = new double*[nx];
double* storage = new double[nx*ny];
for(int i = 0; i &lt; ny; i++) matrix[i] = &amp;storage[ny*i];
</code></pre>

<hr>

<p>The final possible workaround is, to do the index calculation yourself:</p>

<pre><code>void fun(int nx, int ny, double* twoDArray) {
    //access the array with
    twoDArray[x*ny + y];
}

//somewhere else
double* matrix = new double[nx*ny];
fun(nx, ny, matrix);
</code></pre>

<p>This is exactly what C99 does under the hood with the code at the top, but with significantly less type checking.</p>
",0
29182078,29182008,0,"<p>Try this:</p>

<pre><code>void fun(int nx, int ny, double** a){
// some code here
// Get the element in this way: double myD = a[i][j];
}
</code></pre>

<p>And in Main:</p>

<pre><code>double** a = new double*[nx];
for (int i = 0; i &lt; nx; i++)
{
   a[i] = new double[ny];
}
</code></pre>

<p>And call the function:</p>

<pre><code>fun(nx, ny, a);
</code></pre>

<p>or if you want to pass an array:</p>

<pre><code>void fun(int nx, int ny, double* a){
int dim = nx*ny;
double myD = a[i];
}
</code></pre>
",0
24355011,24354768,1,"<p>@user2040251 has the right answer, your multiplication causes an overflow in your int values. To be a little more general, you can expect that for an initial instantiation with <code>Value = v</code> and <code>Count=n</code>, you will reach numbers up to v^(2^n). If you change your code to stop at <code>Count=1</code>, then you instead reach v^(2^(n-1)).</p>
",0
24354858,24354768,3,"<p>In instantiation, <code>Value</code> is multiplied 5 times by itself<br/>
2 * 2 -> 4, 4 * 4 -> 16, 16 * 16 -> 256, 256 * 256 -> 65536 and 65536 * 65536 -> overflow.<br/> 
If you want to stop at the 4th step then you need to either use <code>multiply_n_times&lt;2, 4&gt;</code> or provide specialization for <code>Count = 1</code>, not <code>Count = 0</code>. </p>
",0
24355205,24354768,3,"<p>The last recursion where the first argument gets discarded has an overflow.</p>

<p>So skip it:</p>

<pre><code>template&lt;int Value, int... Is&gt;
struct multiply_n_times&lt;Value, 1, Is...&gt; :
  pack&lt;Is..., Value&gt;
{ };
</code></pre>

<p>now we never calculate a <code>Value*Value</code> that we won't use.</p>

<p>Leave the <code>0</code> specialization if you need the <code>0</code> length list of squares.</p>
",1
29191102,29191085,2,"<p>You've swapped the assignment around.</p>

<p>Instead of</p>

<pre><code>pValue = pData;
</code></pre>

<p>You want to do </p>

<pre><code>pData = pValue;
</code></pre>
",2
22420863,22419852,0,"<p>Instead of enumerating all cases consider instead using a custom language for the format specification:</p>

<pre><code>Date x = parseDate(user_input, ""dd-mm-yyyy"");
</code></pre>

<p>it will make the function shorter, easier to document and easier to use also improving the readability of the code that uses it. The idea is using codes like</p>

<pre><code>yyyy ............. 4-digits year
yy ............... 2-digits year with automatic century computation
mm ............... 2-digits month
m ................ 1 or 2 digits month
dd ............... 2-digits day
d ................ 1 or 2 digits day
anything else .... mandatory character
</code></pre>

<p>A simple implementation could be</p>

<pre><code>Date parseDate(const std::string&amp; input, const std::string&amp; format) {
    const char *src = input.c_str();
    const char *fmt = format.c_str();
    int year=-1, month=-1, day=-1;
    while (*fmt) {
        if (!*src) throw invalid_date(input, format);
        if (strncmp(fmt, ""yyyy"", 4) == 0) {
            fmt += 4;
            year = getInt(src, 4);
        } else if (strncmp(fmt, ""yy"", 2) == 0) {
            fmt += 2;
            year = guess_century(getInt(src, 2));
        } else if (strncmp(fmt, ""mm"", 2) == 0) {
            fmt += 2;
            month = getInt(src, 2);
        } else if (fmt[0] == 'm') {
            fmt += 1;
            month = getInt(src, -1);
        } else if (strncmp(fmt, ""dd"", 2) == 0) {
            fmt += 2;
            day = getInt(src, 2);
        } else if (fmt[0] == 'd') {
            fmt += 1;
            day = getInt(src, -1);
        } else {
            if (src[0] != fmt[0]) throw invalid_date(input, format);
            src++; fmt++;
        }
   }
   if (*src || year == -1 || month == -1 || day == -1)
     throw invalid_date(input, format);
   return Date(year, month, day);
}
</code></pre>

<p>NOTE: untested</p>
",1
28170869,28169614,1,"<p>Against better judgement regarding the quality of your question, here's what I glimpsed in my crystal ball.</p>

<p>I turned your non-compilable code into a proper <a href=""https://stackoverflow.com/help/mcve"">MCVE</a>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void convert( char * input )
{
    double result = atof( input );
    printf( ""%16.16f\n"", result );
}

int main()
{
    convert( ""123.1"" );
    convert( ""123.12"" );
    return 0;
}
</code></pre>

<p>Observed output:</p>

<pre><code>123.0999999999999943
123.1200000000000045
</code></pre>

<p>This is expected, given the <a href=""http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems"" rel=""nofollow noreferrer"">accuracy problems</a> inherent in floating point representation.</p>

<p>I can only <em>assume</em> that the FTGL functions you are using do some internal rounding (off) or truncating of the output, turning the result of converting <code>""123.1""</code> to <code>double</code> (<code>123.0999999999999943</code>) into <code>123.0</code>.</p>
",0
31159896,31159076,5,"<p>The thing is, when you have your function containing a few lines on code, each one of them is treated as a ""step"" to achieve some goal. When you read such a function you read each line and think what it does and why. In your example,</p>

<pre><code>cout &lt;&lt; *iter &lt;&lt; endl;
++iter;
</code></pre>

<p>logically could be one step: ""when iterating over the container, write each element to <code>cout</code>"". It's because when you forget either of these lines, the whole step is incorrect. Of course, this very example is not particularly great, because it's not hard to come up with a code, in which the two lines are two different logic steps. However, I assume the author meant, that by writing</p>

<pre><code>cout &lt;&lt; *iter++ &lt;&lt; endl;
</code></pre>

<p>you protect yourself from forgetting one part of a logic step as well as you make a signal for a reader that this is one logic step.</p>
",3
31159224,31159076,4,"<p>I can think about the lines being reordered for some reason (maybe they became separated by some other code and it was later modified), or an if/for/while being added, either without braces or with them wrongly placed:</p>

<pre><code>++iter;
cout &lt;&lt; *iter &lt;&lt; endl;

if (some_condition)
cout &lt;&lt; *iter &lt;&lt; endl;
++iter;

while (something_happens)
{
cout &lt;&lt; *iter &lt;&lt; endl;
}
++iter;
</code></pre>

<p>In this small example, the bugs are quite obvious, but that may not be the case when you have a lot more lines.</p>

<p>(And yes, I know the indentation in the 2nd and 3rd examples should be corrected, but sadly I've seen lots of examples like these).</p>
",2
31159251,31159076,22,"<p>I also do not agree with the author.</p>

<p>Usually each code snippet has a tendency to be changed in the future.</p>

<p>For example this statement</p>

<pre><code>cout &lt;&lt; *iter++ &lt;&lt; endl;
</code></pre>

<p>can be changed the following way</p>

<pre><code>cout &lt;&lt; *iter++ &lt;&lt; ... &lt;&lt; SomeFunction( *iter ) &lt;&lt; endl;
</code></pre>

<p>In this case the code will have undefined behaviour because the order of evaluation of function arguments is unspecified.</p>

<p>So in my opinion this code snippet</p>

<pre><code>cout &lt;&lt; *iter &lt;&lt; endl;
++iter;
</code></pre>

<p>is less error-prone.:)</p>

<p>Introducing side-effects in a code snippet does not make it less error-prone.</p>

<p>Moreover in the code snippet you showed there is no logical relation between the increment of the iterator and outputting its value. </p>

<pre><code>cout &lt;&lt; *iter++ &lt;&lt; endl;
</code></pre>

<p>So it is unclear why the iterator is incremented in this statement.</p>

<p>Separating this statement into two statements makes the code snippet more clear because it seems that the incrementing is related to some other parts of the code. </p>

<p>The brevity makes the code more expressive. But it does not mean that it necessarily makes also the code less error-prone.:)</p>
",5
31159768,31159076,4,"<p>I couldn't disagree with the author more.</p>

<p>The expression <code>*iter++</code> does two different things to <code>iter</code> - it dereferences it and increments it.    Yes, the order is defined, but understanding the results of two actions on a single variable in a single expression requires inherently more brainpower than something which has only one effect on a single variable.</p>

<p>One of the most reliable ways to increase errors from a developer is to unnecessarily increase the brainpower needed to understand what their code actually does.</p>

<p>The virtue of breaking the effects into two distinct statements is that it is easier to understand.</p>

<p>The other phenomenon is that programmers who are taught to include two effects on a single variable in a single statement are more likely to craft expressions with even more effects on some poor variable.    Apart from making their code even less comprehensible, it also increases the likelihood of undefined behaviour (since any expression that modifies any variable more than once in a single expression has undefined behaviour).</p>
",4
31164644,31159076,2,"<p>Not a good example, because you shouldn't use while without braces, but it could lead to errors like this: In this case you would have an infinite loop when adding the while.</p>

<pre><code>while (*iter)
  cout &lt;&lt; *iter &lt;&lt; endl;
  ++iter;
</code></pre>

<p>I think it is a bad example! Much better would be an example, where you have multiple dependent steps. Then someone copies some steps to another function, but misses some lines, which don't look they are semantically needed.</p>
",3
31166221,31159076,3,"<p>It might be worth comparing to similar constructs in other languages.</p>

<p>In python, to iterate over a sequence, we use a generator. There is essentially only one operation you can do with a generator: call <code>next</code> which obtains an element and advance the generator. Iteration, when done manually, is done by repeatedly calling <code>next</code>  to get the terms of the sequence until it raises <code>StopIteration</code> to signal the end of the sequence.</p>

<p>In java, to iterate over a sequence, we us an <code>Iterator</code>. There is essentially only one operation you can do with an iterator: call <code>next</code> which obtains an element and advances the iterator. Iteration, when done manually, is done by repeatedly calling <code>next</code>  to get the terms of the sequence until <code>hasNext</code> returns <code>false</code> to signal the end of the sequence.</p>

<p>In C/C++... we often want to get an element and advance through the sequence. It has been long established (AFAIK before C++ even existed) that this operation is <code>*p++</code>.</p>

<p>The only reason we are even contemplating the idea of breaking this into two steps -- one step being to get the current element and the other step being to advance to the next term -- is an artifact of an <em>implementation detail</em>.</p>

<p>In a situation where one is <em>truly</em> thinking of these two steps as being separate, independent things, then it would be best to keep them as separate expressions.</p>

<p>But it is relatively well established that that is <em>not</em> how people are thinking -- people are thinking in terms of ""getting an element and advancing the iterator"". Iteration, when done manually, is done by repeatedly invoking <code>*iter++</code> to get the terms of the sequence, until <code>iter == end_iter</code> returns true to signify the end of the sequence.</p>

<p>When thinking this way, splitting the one conceptual step into two syntactically separate elements (<code>*iter</code> and <code>++iter</code>) is more error prone than keeping it as a single step.</p>
",0
27508950,27508872,6,"<blockquote>
  <p>If <code>std::list</code> is a linked list then why is there a limit on how many elements you can have?</p>
</blockquote>

<p>Because the <code>max_size()</code> function is a requirement for all standard containers.</p>

<blockquote>
  <p>Each element is a link to a new node and there's no limit on how many pointers you can have.</p>
</blockquote>

<p>Yes there is: the size must be representable by <code>size_type</code>, so a limit is that type's maximum value. There's probably no reason for it to be less than that.</p>
",3
27509080,27508872,3,"<blockquote>
  <p>there's no limit on how many pointers you can have</p>
</blockquote>

<p>There's a limit on how many distinct pointer values there can possibly be, based on the size of a pointer. For example, if a pointer occupies 64 bits in a particular implementation, then <code>max_size()</code> could safely return 2<sup>64</sup>-1. In fact it could be rather less than this, since each linked list node will be bigger than 1 byte.</p>
",0
27509330,27508872,1,"<p>The simple answer is because the standard says so:</p>

<p>23.2.1 Requirements for containers <code>Table 96 ¡ª Container requirements</code> p. 747 for <strong><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf"" rel=""nofollow"">N4296</a></strong>:</p>

<blockquote>
  <p><code>a.max_size()</code>; <code>size_type</code>; <code>distance(begin(),end())</code> for the largest possible container</p>
</blockquote>

<p>This, most probably, comes from the fact that in c++ algorithms separated from the containers. Algorithms are written as templates, so they basically duck type code, they expect some contracts to be fulfilled (i.e. providing some API). There are algorithms written for all containers so they expect whatever is passed as a container to implement full API, even if sometimes a particular method does not have much <em>theoretical</em> sense it must be implemented.</p>

<p>That said, <em>technically</em> there is an upper bound anyway so it's good idea to use it in such cases. Funnily enough, it is practically impossible to hit the limit you get from <code>std::list::max_size()</code> (i.e. you would run OOM), yet alone the theoretical infinity.</p>
",0
27747934,27747853,11,"<p>The rules were specifically written to cover</p>

<pre><code>struct S {
  int i;
  std::string s;
};
</code></pre>

<p>where without any user-provided constructor, even though the implicitly generated default constructor is non-trivial, <code>S().i</code> would be zero-initialised. This cannot depend on the constructor of <code>int</code>, since <code>int</code> doesn't have any constructor. The decision was made to let it depend on whether the class <code>S</code> has a user-provided constructor. There's not much else it could depend on.</p>

<p>What you're seeing is a simple consequence of that. Your class <code>derived</code> also has no user-provided constructor, so it gets zero initialisation too.</p>
",1
30210135,30209962,5,"<p>I could not think of a way to create a temporary without using it in some call, like you did with the function.</p>

<p>Why don't you want to create a named variable instead? It's lifecycle will be exactly the same as your ""temporary"", given how you try to declare it.</p>

<p>If you really want to control the destruction of your object, you could always encapsulate it in a block: <code>{ A tmp(a); } // temporary A object</code></p>

<hr>

<p>The thing is... I don't see the point of doing that. Why would you want to create a temporary object without using it? It usually means that your object creation or destruction has some side effects that you want to trigger. This is a really bad idea! You should move the side effects to a function and simply call it.</p>
",2
30210182,30209962,20,"<p>This is another instance of the ""everything that can be a declaration is a declaration"" rule. [stmt.ambig]/p1:</p>

<blockquote>
  <p>There is an ambiguity in the grammar involving <em>expression-statement</em>s
  and declarations: An <em>expression-statement</em> with a function-style
  explicit type conversion (5.2.3) as its leftmost subexpression can be
  indistinguishable from a <em>declaration</em> where the first <em>declarator</em>
  starts with a <code>(</code>. In those cases the <em>statement</em> is a <em>declaration</em>.</p>
</blockquote>

<p>The standard provides the following examples:</p>

<blockquote>
  <p>Assuming T is a <em>simple-type-specifier</em>,</p>

<pre><code>T(a)-&gt;m = 7;       // expression-statement
T(a)++;            // expression-statement
T(a,5)&lt;&lt;c;         // expression-statement
T(*d)(int);        // declaration
T(e)[5];           // declaration
T(f) = { 1, 2 };   // declaration
T(*g)(double(3));  // declaration
</code></pre>
  
  <p>In the last example above, <code>g</code>, which is a pointer to <code>T</code>, is initialized
  to <code>double(3)</code>. This is of course ill-formed for semantic reasons, but
  that does not affect the syntactic analysis.</p>
</blockquote>

<p>and also:</p>

<blockquote>
<pre><code>class T {
// ...
public:
    T();
    T(int);
    T(int, int);
};

T(a);          // declaration
T(*b)();       // declaration
T(c)=7;        // declaration
T(d),e,f=3;    // declaration
extern int h;
T(g)(h,2);     // declaration
</code></pre>
</blockquote>

<p>The simplest way to disambiguate is probably an extra set of parentheses. <code>(A(a));</code> is unambiguously an <em>expression-statement</em>.</p>
",2
21581125,21581095,3,"<p>A <code>char</code> array cannot contain strings! You should initialize it with individual <code>char</code>s!</p>

<p>For example: <code>char b[] = { 'I', 'O', 'U' };</code></p>

<p>When you desire string literals, you can use the following:</p>

<pre><code>const char* b[] = { ""II"", ""OO"", ""UU"" };
</code></pre>
",0
21581136,21581095,10,"<p>You have said that <code>b</code> is an array of <code>char</code>. But you are supplying string literals rather than individual characters. It's impossible to know what you really mean to do. Perhaps you actually want <code>b</code> to be an array of strings:</p>

<pre><code>const char* b[] = {"".-"", "".-"", ""-..."", ""-..."", ...};
</code></pre>
",6
21581140,21581095,2,"<p>Either <code>b</code> should be an array of <code>const char*</code> or you should put char in the initializer list instead of string literals.</p>

<pre><code>const char* b[]={"".-"","".-"", ...}
</code></pre>

<p>or</p>

<pre><code>char b[] = {'a', 'b', ...};
</code></pre>
",1
21581155,21581095,1,"<p>You are not trying to store <code>char</code>s in <code>b</code>, but strings. Declare <code>b</code> as <code>const char *b[72] = ...</code> instead.</p>
",1
29516755,19346353,0,"<p>Due to a target system where I cannot / don't want to exchange libraries, my solution was to use compiler options.</p>

<p>A very simple way was <code>-static-libstdc++</code>, but that gave me a huge executable.</p>

<p>My final solution is to utilize <code>ar</code> on ""libstdc++.a"" to extract ""list.o"" (which contains the 2 functions in question and 2 others) and instruct <code>ld</code> to include this whole object (8kB). I expect very few side effects, since in total just 4 functions are statically included (and ELF etc. provide that one implementation is used at runtime). Details:</p>

<pre><code>ar x ""${TARGET}/x86/lib/gcc/4.6.3/libstdc++.a"" list.o
g++ source.cpp -Wl,--whole-archive ""./list.o"" -Wl,--no-whole-archive # more options...
rm ./list.o
</code></pre>
",0
25665399,25665375,1,"<p>Exactly same way</p>

<pre><code>int zeroarray[1024] = {0};
</code></pre>
",0
25665404,25665375,2,"<p>It's similar:</p>

<pre><code>int ZEROARRAY[1024] = {0};
</code></pre>

<p>or even simpler:</p>

<pre><code>int ZEROARRAY[1024] = {};
</code></pre>
",0
32423425,32423337,5,"<blockquote>
  <p>What the syntax is called, and what does it do?</p>
</blockquote>

<p>This syntax is called <em>uniform initialization</em> or <em>list initialization</em>. It does many different things <a href=""http://en.cppreference.com/w/cpp/language/list_initialization"" rel=""nofollow"">explained here</a>. In this particular case the construct initializes the shared pointer with a plain pointer to an integer, and sets the newly allocated integer to ten (<a href=""http://ideone.com/nencgE"" rel=""nofollow"">demo</a>).</p>

<p>The effect is the same as in the code snippet below:</p>

<pre><code>int *tmp = new int;
*tmp = 10;
shared_ptr p(tmp);
</code></pre>

<blockquote>
  <p>For which c++ standard it is?</p>
</blockquote>

<p>This syntax was introduced in C++11.</p>
",2
25498467,25497183,4,"<p>There is no way to disable SFINAE. C++ has no features to enable and disable at will. There is a way to make the SF part never happen, so that the E is triggered elsewhere.</p>

<pre><code>struct A
{
  template &lt;typename T&gt;
  static auto fun() -&gt; typename get_type&lt;T&gt;::type { 
    static_assert(has_type&lt;T&gt;::value, ""Template parameter has no type member named 'type'"");
  }
};
</code></pre>

<p><code>get_type</code> (that never fails) and <code>has_type</code> (using SFINAE) are standard exercises described everywhere.</p>
",2
29250356,29250305,2,"<p>1) It is an instance of an anonymous union indeed, the author was wrong. If you prepend the union with a <code>typedef</code> keyword like</p>

<pre><code>typedef union
{
   float dollars;
   int yens;
} price;
</code></pre>

<p>, then <code>price</code> will be a typename referring to the union.</p>

<p>2) Nope, <code>book1.price.dollars</code> you want to use instead.</p>

<p><strong>UPDATE:</strong>
An union type can be declared in the following way either:</p>

<pre><code>union price
{
   float dollars;
   int yens;
}; // here you see, there is no instance.
</code></pre>

<p>If there was an identifier between the closing brace and the semicolon, that would be the name of the instance.</p>
",11
26194962,26194938,0,"<p>Iterate through the vector moving your pointer along by the string length each time.</p>
",0
26194970,26194938,0,"<pre><code>int currentIndex = 0;
for(int i = 0; i &lt; v.length(); i++) {
    memcpy(b + currentIndex, v[i], strlen(v[i]));
    currentIndex += strlen(v[i]);
}
</code></pre>

<p>Something like that, may not work I didn't test it.</p>

<p>And if you want to use <code>b</code> as a string, you need to put a <code>0</code> on the end.</p>
",0
26194978,26194938,3,"<p>You can use the range based for statement. For example</p>

<pre><code>void *p = b;
for ( const char *s : v )
{
   size_t n = std::strlen( s );
   std::memcpy( p, s, n );
   p = ( char * )p + n;
}
</code></pre>

<p>The same can be done with standard algorithm <code>std::accumulate</code> declared in header <code>&lt;numeric&gt;</code></p>

<p>For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;
#include &lt;cstring&gt;

int main() 
{
    std::vector&lt;const char*&gt; v;

    v.push_back( ""abc"" );
    v.push_back( ""def"" ); 
    void *b = new char[6];  

    auto p = std::accumulate( v.begin(), v.end(), b,
                              []( void *acc, const char *s ) -&gt; void *
                              {
                                  size_t n = std::strlen( s );
                                  return ( ( char * )std::memcpy( acc, s, n ) + n );
                              } );

    std::cout.write( (const char * )b , ( const char * )p - ( const char * )b );
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>The output is</p>

<pre><code>abcdef
</code></pre>

<p>Take into account that it would be better to write</p>

<pre><code>void* b = new char[6];
</code></pre>
",2
26194985,26194938,0,"<p>try this :</p>

<pre><code> std::vector&lt;const char*&gt; v;
 v.push_back(""abc"");
 v.push_back(""def""); 
 void* b = malloc(6);
int l = strlen(v[0]);
memcpy(b, v[0], l);
l = strlen(v[1]);
memcpy(b+l, v[1], l); 
</code></pre>
",0
26195135,26194938,0,"

<p>This is the most C++-like way I can think of.  It doesn't use any C-style string manipulation or memory management functions and it is as safe as can be.  Downside is that a temporary buffer is allocated and released without actual need.</p>

<p>The following headers are used in this example.</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
</code></pre>

<p>Now, the first version (which I prefer) allocates a buffer of the correct size and returns it wrapped in a <code>std::unique_ptr&lt;char[]&gt;</code> from which the caller can then extract the buffer and implicitly cast it to <code>void *</code> if needed.</p>

<pre class=""lang-cpp prettyprint-override""><code>std::unique_ptr&lt;char[]&gt;
concatenate(const std::vector&lt;const char *&gt;&amp; words)
{
  std::string buffer {};
  std::unique_ptr&lt;char[]&gt; dup_uptr {};
  for (const auto word : words)
    buffer += word;
  dup_uptr.reset(new char[buffer.size() + 1]);
  buffer.copy(dup_uptr.get(), buffer.size());
  dup_uptr.get()[buffer.size()] = '\0';
  return dup_uptr;
}
</code></pre>

<p>The second version takes the destination buffer and its size as parameters and copies the concatenated string there.  This can obviously fail if the buffer happens to be too small and it is also less safe since we might make a mistake and pass the wrong buffer size.  For convenience, it returns a <code>char *</code> pointer to the string or a <code>nullptr</code> if the buffer was too small.</p>

<pre class=""lang-cpp prettyprint-override""><code>char *
concatenate(const std::vector&lt;const char *&gt;&amp; words,
            void *const dest,
            const std::size_t size)
{
  char * dest_chars = static_cast&lt;char *&gt;(dest);
  std::string buffer {};
  for (const auto word : words)
    buffer += word;
  // If we cannot copy the whole thing, copy nothing at all.
  if (buffer.size() &gt;= size)
    return nullptr;
  buffer.copy(dest_chars, buffer.size());
  dest_chars[buffer.size()] = '\0';
  return dest_chars;
}
</code></pre>

<p>The two functions can be used like this:</p>

<pre class=""lang-cpp prettyprint-override""><code>int
main()
{
  const std::vector&lt;const char*&gt; vec {""abc"", ""def""};
  // first version
  {
    auto concat = concatenate(vec);
    std::cout &lt;&lt; concat.get() &lt;&lt; std::endl;
  }
  // second version
  {
    auto tempbuff = std::get_temporary_buffer&lt;void&gt;(100);
    if (auto concat = concatenate(vec, tempbuff.first, tempbuff.second))
      std::cout &lt;&lt; concat &lt;&lt; std::endl;
    std::return_temporary_buffer(tempbuff.first);
  }
  return 0;
}
</code></pre>
",0
23070037,23069960,2,"<p>You may want to consider <a href=""http://www.boost.org/doc/libs/1_55_0/libs/optional/doc/html/index.html"" rel=""nofollow""><code>boost::optional&lt;&gt;</code></a>.</p>

<pre><code>boost::optional&lt;T&amp;&gt; frontWait(const std::chrono::milliseconds&amp; timeout);
</code></pre>

<p>At the call site:</p>

<pre><code>boost::optional&lt;T&amp;&gt; result = frontWait(500);
if (result) {
    // Note the syntax similar to pointers, but boost::optional is not a pointer,
    // as you can read from its documentation.
    // Assume that doSomething has a prototype something like this:
    //   void doSomething(const T&amp; x);
    // or:
    //   void doSomething(T&amp; x);
    //
    doSomething(*result);
}
</code></pre>

<p>If, for some reason, you don't want to use <code>boost::optional</code>, I think another good option can be the simple bool-returning one, when the result value is returned to the caller via reference parameter:</p>

<pre><code>bool frontWait(const std::chrono::milliseconds&amp; timeout, T&amp; result);
</code></pre>
",2
23070042,23069960,1,"<p>Check out Boost Optional. You don't need to use it. You could implement your own if you needed to.</p>

<p>As I recall, it'd work something like:</p>

<pre><code>optional&lt;T&amp;&gt; frontWait(const std::chrono::milliseconds &amp;timeout)

auto response = frontWait(1000);
if(response) dosomething(response.get());
</code></pre>
",0
23070619,23069960,1,"<p>You're missing the obvious solution: return a pointer instead of a reference. A null pointer means the operation didn't succeed.</p>

<p>I'm not advocating this over other techniques, but that's the way things were done back in the old days.</p>
",0
28173778,28173712,4,"<pre><code>int mapSize = (sizeof mapArray / sizeof mapArray[0]);
</code></pre>

<p>This line only works in very few situations. It's easier to just say that you should not do this. Pass the length of the array as extra parameter and you are safe:</p>

<pre><code>std::vector&lt;Map&gt; sortAndFilterMap(Map mapArray[], int mapSize)
</code></pre>

<p>Alternatively, you could use <code>std::vector&lt;Map&gt;</code> everywhere and remove the raw arrays alltogether.</p>
",5
28174249,28173712,1,"<p>I don't want to encourage use of raw C arrays, which should basically never be used except in <em>very</em> special situations. But, if one really must, you could use this:</p>

<pre><code>template&lt;size_t mapSize&gt;
vector&lt;Map&gt; sortAndFilterMap(Map (&amp;mapArray)[mapSize]) {
</code></pre>

<p>A reference to an array <code>(&amp;mapArray)</code> can use template deduction to deduce the size of the array. In this <code>mapSize</code> will have the correct size.</p>

<p>Anyway, just use <code>vector</code>s instead of C arrays by default.</p>
",1
28173956,28173712,2,"<p>The results of <code>int mapSize = (sizeof mapArray / sizeof mapArray[0]);</code> are different in the two cases:</p>

<ol>
<li>When it's in main: the result is 10, which is what you expect.</li>
<li>When it's in <code>vector&lt;Map&gt; sortAndFilterMap(Map mapArray[])</code>: the array decays into a pointer to a Map object (the function doesn't know the size of the mapArray anymore); <code>sizeof mapArray</code> returns the size of such pointer (4 or 8 bytes depending on whether you're on a 32 or 64-bit system). Thus the result is <code>(4 or 8) / (sizeof float * 3) = 0</code>. The for loop will break immediately on the first iteration and the function returns an empty vector.</li>
</ol>
",1
26245698,26245622,0,"<p>Surround the switch with an if statement</p>

<pre><code>if (operNum==1||operNum==2||operNum==3||operNum==4){
  ...
}
</code></pre>
",1
26245988,26245622,0,"<p>My organization has the following code for this sole purpose.</p>

<pre><code>#include &lt;cctype&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;

/**
 * @brief function returns the integer value of the string entered, negative
       numbers in the input string are not allowed. First non-digit character
       (including minus sign (-)) terminates parsing of the input string
 * @exception throws no exception, return value for every input
 * @param[in] input string containing the response of the user
 * @return &lt;int&gt; errorValue = -1, non-negative value is the response of the user
 */
int menuResponse(std::string input)
{
    int response = 0;
    int length = 0;
    response = atoi(input.c_str());   // &lt;--- magic happens here
    // check for an error in the 1st character itself, only source of false 0 
    // as a response value
    if (isdigit(input[0]))
    {
        return response;
    }
    else
    {
        return -1;
    }
}
</code></pre>
",0
26245845,26245622,1,"<p>Once a stream state heads south due to invalid extraction, format error, etc, there's very little you can do with it besides detect it, determine if clearing the failure state is applicable, do so if it is, and move on. There are times when it is <em>not</em> applicable (such as arriving at EOF; not much good there).</p>

<p>Something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;

int main()
{
    int firstNum,
    secondNum,
    subFirstNum,
    subSecNum,
    operNum,
    num;               // User's input answer for operations
    bool temBool = true;   // Temporary boolean used in the while loop

    // Use the time function to get a ""seed"" value for srand
    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));

    //Start of the loop
    while (temBool)
    {
        //Random generated operands
        firstNum = rand() % 40 + 10;
        secondNum = rand() % 40 + 10;

        // Set of randoms numbers for substraction where the denominator is always
        // lower than the numerator.
        subFirstNum = rand() % 30 + 20;
        subSecNum = rand() % 10 + 10;

        // Menu of Math Tutor
        cout &lt;&lt; ""Math Tutor - Main Menu"";
        cout &lt;&lt; endl &lt;&lt; endl;
        cout &lt;&lt; ""1. Adittion\n"";
        cout &lt;&lt; ""2. Subtraction\n"";
        cout &lt;&lt; ""3. Multiplication\n"";
        cout &lt;&lt; ""4. Exit Program\n"";
        cout &lt;&lt; endl &lt;&lt; endl;
        cout &lt;&lt; ""Choose your operation to practice (1-4) "";

        // test for successful extraction
        if (!(std::cin &gt;&gt; operNum))
        {
            // yes there are times when you actually use .eof()
            if (std::cin.eof())
                break;

            // flush out the stream through the pending newline
            std::cin.clear();
            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
            continue;
        }

        cout &lt;&lt; endl &lt;&lt; endl;

        // Switch for the menu's options
        switch (operNum)
        {
            case 1:
                cout &lt;&lt; ""Working with addition\n"";
                cout &lt;&lt; setw(3) &lt;&lt; firstNum &lt;&lt; ""\n""
                &lt;&lt; ""+"" &lt;&lt; secondNum &lt;&lt; ""\n""
                &lt;&lt; ""---\n"";
                cout &lt;&lt; ""Your answer: "";
                cin  &gt;&gt; num;
                if(num == firstNum + secondNum)
                {
                    cout &lt;&lt; ""Correct answer: ""
                    &lt;&lt; firstNum + secondNum &lt;&lt; "" Congratulations!\n"";
                }
                else
                {
                    cout &lt;&lt; ""Correct answer: ""
                    &lt;&lt; firstNum + secondNum &lt;&lt; "" Sorry!\n"";
                }
                cout &lt;&lt; endl &lt;&lt; endl;
                break;
            case 2:
                cout &lt;&lt; ""Working with subtraction\n"";
                cout &lt;&lt; setw(3) &lt;&lt; subFirstNum &lt;&lt; ""\n""
                &lt;&lt; ""-"" &lt;&lt; subSecNum &lt;&lt; ""\n""
                &lt;&lt; ""---\n"";
                cout &lt;&lt; ""Your answer: "";
                cin  &gt;&gt; num;
                if(num == subFirstNum - subSecNum)
                {
                    cout &lt;&lt; ""Correct answer: ""
                    &lt;&lt; subFirstNum - subSecNum &lt;&lt; "" Congratulations!\n"";
                }
                else
                {
                    cout &lt;&lt; ""Correct answer: ""
                    &lt;&lt; subFirstNum + subSecNum &lt;&lt; "" Sorry!\n"";
                }
                cout &lt;&lt; endl &lt;&lt; endl;
                break;
            case 3:
                cout &lt;&lt; ""Working with multiplication\n"";
                cout &lt;&lt; setw(3) &lt;&lt; firstNum &lt;&lt; ""\n""
                &lt;&lt; ""*"" &lt;&lt; secondNum &lt;&lt; ""\n""
                &lt;&lt; ""---\n"";
                cout &lt;&lt; ""Your answer: "";
                cin  &gt;&gt; num;
                if(num == firstNum * secondNum)
                {
                    cout &lt;&lt; ""Correct answer: ""
                    &lt;&lt; firstNum * secondNum &lt;&lt; "" Congratulations!\n"";
                }
                else
                {
                    cout &lt;&lt; ""Correct answer: ""
                    &lt;&lt; firstNum * secondNum &lt;&lt; "" Sorry!\n"";
                }
                cout &lt;&lt; endl &lt;&lt; endl;
                break;
            case 4:
                cout &lt;&lt; ""Thank you for using Math Tutor.\n\n"";
                temBool =  false;
                break;
            default:  
                cout &lt;&lt; ""Incorrect menu seletion. Please choose between 1 and 4.\n\n"";
                break;
                return 0;
        }
    }
}
</code></pre>
",1
25547879,25547736,1,"<p>If i understand your question correctly, you don't really have other choice.<br>
It would be terrible if you would write something like:</p>

<pre><code>public:
 method ();
 private:
 method (/*some parameter*/);
 public:
 //other public methods
 private:
 //other private methods
</code></pre>

<p>It's unreadable, i think the standard practice is to separate them.</p>

<p>Mostly there is 2 kind of user:<br>
- Who want to use your class, in that case, he only care about public methods, not about the hidden private versions<br>
- Who develope it. He will mostly work in the .cpp, where you can put these implementations together.</p>
",4
25548201,25547736,0,"<p>I think in .cpp (implementation) functions should be grouped by ""what they do"" and not ""who can call them"" (like in the header). </p>

<p>In your case, I'd prefer to move the private one near his similar, in the public ""section"" of the cpp (even if it is private), adding a comment ""private overload"" or something similar before the function.</p>
",0
29190306,29190145,2,"<p>It's because you are using some sort of IDE and usually in IDEs they display a console box that has your output, and that console box disappears when the program is done.</p>

<p>It <strong><em>is</em></strong> being shown, but the console window is exiting too fast for you to see it.</p>

<p>What you can do is add a few lines at the end, such as:  </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using std::cout;
using std::endl;
using namespace std;
int main()
{
    int a = 0;
    int b = 10;
    cout &lt;&lt; ""Enter first number \n"";
    cin &gt;&gt; a;
    if (a &lt; 10)
    {
        cout &lt;&lt; ""Less"";
    }

    std::string pause;
    cin &gt;&gt; pause;
}
</code></pre>
",0
26440830,26440228,1,"<p>You have two bugs in your program:</p>

<ol>
<li><p>The loops in constructors of <code>sharedptr_testB</code> and <code>sharedptr_testC</code> use <code>size</code> instead of <code>i</code> for indexing. It should be:</p>

<pre><code>sharedptr_testB(int size)
{
  m_size = size;
  bytes = new char[size];
  for(int i = 0 ; i &lt; size ; i++)
    bytes[i]= 'B';
}
</code></pre>

<p>(DTTO) for <code>sharedptr_testC</code>)</p></li>
<li><p>You start with a vector of size 5, which means it stores five null pointers. Then you append two elements to it (size 7, five nulls + two valid pointers). The you iterate over it, dereferencing each pointer. This of course crashes, since there are nulls at the beginning. Simply initialise the vector as empty.</p>

<pre><code>sharedptr_testA* A = new sharedptr_testA(0);
</code></pre></li>
</ol>

<p>With these two fixes, the code <a href=""http://ideone.com/mDKbgn"" rel=""nofollow"">works</a>.</p>

<hr>

<p>Side notes 1 (C++):</p>

<ul>
<li><p>The code is next to impossible to read. I strongly suggest you use a better naming scheme.</p></li>
<li><p><code>sharedptr_testB</code> and <code>sharedptr_testC</code> leak memory. I understand it's just a learning excercise, I'd just like to point it out. You'd be better off with <code>std::vector&lt;char&gt;</code> in them instead of <code>char*</code>.</p></li>
</ul>

<hr>

<p>Side notes 2 (Stack Overflow):</p>

<p>If you have a crashing program, you should generally try to debug it yourself before asking an SO question. Stepping through the program through a debugger would easily have uncovered both the issues.</p>
",2
25702660,25702627,1,"<p>Because <code>0</code> in Boolean context is interpreted as <code>false</code>.</p>
",0
25702671,25702627,2,"<p>This code won't do what the comment says that it would do:</p>

<pre><code>//while data is int
while (selection)
</code></pre>

<p>The data will always be an <code>int</code>, it's not possible to store anything else in an <code>int</code> variable.</p>

<p>What the code actually does is to loop while the value is non-zero.</p>
",1
25702676,25702627,0,"<p><code>false</code> is interpreted as <code>0</code> in C++. Similarly, <code>0</code> is interpreted as <code>false</code> .
Hence, when <code>selection</code> is <code>0</code>, the loop effectively becomes:</p>

<pre><code>while ( false )
{
...
}
</code></pre>

<p>which does not run.</p>

<p>On the other hand, when <code>selection</code> is not <code>0</code>, C++ treats it as <code>true</code> and the loop will run. </p>

<p>EDIT:
If you want to loop while the input is an integer, try</p>

<pre><code>while (std::cin &gt;&gt; selection)
{
...
}
</code></pre>
",7
25703073,25702627,0,"<p>This is how the code stands now and it works. Thank you guys for all your help </p>

<pre><code>int main()
{
  //data to be entered
  int selection;

  //array size
  int const array_size = 100;

  //array
  int integers[array_size];

  //array index
  int index = 0;

  //prompt
  std::cout &lt;&lt; ""Enter integer ('x' to quit): "" &lt;&lt; std::endl;

  //while data is int
  while (std::cin &gt;&gt; selection)
  {
    //put it in the array
    integers[index] = selection;

    //increment index
    index += 1;

  }

  return 0;

}
</code></pre>
",2
25703090,25702627,0,"<p><code>while (selection)</code> doesn't stop when <code>selection</code> is no longer an <code>int</code>; <code>selection</code> is <em>always</em> an <code>int</code>.</p>

<p><code>while (selection)</code> stops when <code>selection</code> is not equal to <code>0</code>.</p>

<p>You should instead test the result of the <code>&gt;&gt;</code> operation.</p>
",0
23599288,23599196,2,"<p>There are a few problems with your code.</p>

<pre><code>class Top{
    Top();
    virtual ~Top() = 0;
}
</code></pre>

<p><code>class</code> access control defaults to <code>private</code>. This means that this class has a private constructor and thus cannot be constructed, nor can subclasses be constructed. A fixed version would probably look like:</p>

<pre><code>class Top {
protected:
    Top();
    virtual ~Top() = 0;
}
</code></pre>

<p>The <code>virtual</code> destructor means you can't create a <code>Top</code>, but you could still create a subclass.</p>

<p>And as @Deduplicator pointed out, you still need a definition for <code>Top::~Top()</code> because subclasses' destructors will call it:</p>

<pre><code>Top::~Top() {}
</code></pre>

<p>The declaration of <code>class Bottom</code> looks fine, though you don't need to repeat <code>public:</code>.</p>

<p>And one minor problem with both class definitions: you forgot the semicolon after the closing brace.</p>

<p>As for the implementation:</p>

<pre><code>Top::Top(): Top() {}
</code></pre>

<p>The third <code>Top</code> is incorrect. That syntax is used to pass things to a superclass's constructor, or delegate to another constructor (of which you have none). <code>Top</code> is not its own superclass. The correct code is simply:</p>

<pre><code>Top::Top() {}
</code></pre>

<p>Moving on...</p>

<pre><code>Bottom::Bottom(char core){
    core = core;
}
</code></pre>

<p>This has a problem because the parameter <code>core</code> hides the class member <code>core</code>. They need to be different names (though there is no requirement that the parameter name in a class declaration match the one in the method definition). I usually fix this by adding a trailing underscore to the parameter name:</p>

<pre><code>Bottom::Bottom(char core_) {
    core = core_;
}
</code></pre>

<p>Finally:</p>

<pre><code>char Bottom::getCore(){
    return core;
}
</code></pre>

<p>This is wrong because you declared it as a <code>const</code> method but this definition is not <code>const</code>. Fixed:</p>

<pre><code>char Bottom::getCore() const {
    return core;
}
</code></pre>

<p>BTW, you can have <code>const</code> and non-<code>const</code> versions of a method. Which one runs depends on if <code>this</code> is <code>const</code> or not.</p>

<p>One last thing: you forgot to define <code>Bottom::~Bottom()</code>. Add this:</p>

<pre><code>Bottom::~Bottom() {
}
</code></pre>

<p>I've got a fixed version of this code, plus some token test code, <a href=""http://codepad.org/7tpN0hsg"" rel=""nofollow"">posted online.</a></p>
",8
24649672,24649568,-1,"<blockquote>
  <p>The cstring <code>myvar</code> is passed by reference as is the case for any array passed in a C++ function, right?    </p>
</blockquote>

<p>No. It is passed by value in this case.  </p>

<blockquote>
  <p>But how to make a local copy of the myvar variable, that my me modified within the function?  </p>
</blockquote>

<pre><code>void functionname (char * myvar) {

   std::string::size_type len = strlen(myvar);
   char *temp = new char[len+1];
   strcpy(temp, myvar);
   temp = strtok(temp, ""="");
   //....
}
</code></pre>
",7
24649746,24649568,1,"<p>You first need to clear up what you mean.</p>

<p>When you say <code>myvar</code> is passed ""by reference"", you're using the C terminology. You are using <em>reference semantics</em> for the array of characters, yes, but you're not passing by reference. In C++, we have reference types for which we use the phrase ""passing by reference"". Here you have a pointer type. You are passing the pointer by value.</p>

<p>Now you ask ""How do I make a local copy of <code>myvar</code>?"" If I interpret your question literally, then it's as simple as doing:</p>

<pre><code>char* anothervar = myvar;
</code></pre>

<p>I have copied the value of <code>myvar</code> to <code>anothervar</code>. They still, however, point at at the same array of characters.</p>

<p>If instead you wanted to copy the contents of the string to another array, you would need to use something like <code>strcpy</code> and perform some dynamic allocation, but this is very poor C++ style. Instead, you should be using <code>std::string</code> throughout. Your function becomes a lot simpler when it is this:</p>

<pre><code>void functionname(std::string myvar) {
  std::string anothervar = myvar;
}
</code></pre>

<p>(Although there's no good reason for copying from <code>myvar</code> to <code>anothervar</code> since <code>myvar</code> is already a copy of the string being passed to it)</p>

<p>I wrote an article recently on <a href=""http://josephmansfield.uk/articles/avoiding-ambiguity-raw-pointers.html"" rel=""nofollow"">avoiding raw pointers</a> and one of the sections covers C-style strings and why <code>std::string</code> is so much better.</p>
",3
22883914,22883840,1,"<p>Use your own PRNG that meets your requirements rather than the one provided with <code>rand</code> that seems not to and was never guaranteed to.</p>
",0
22883928,22883840,0,"<p>The most reasonable solution would be to use C++11's <a href=""http://en.cppreference.com/w/cpp/numeric/random"" rel=""nofollow""><code>&lt;random&gt;</code></a>, <code>mt19937_64</code> would do.  </p>

<p>Alternativelly you might try:</p>

<pre><code>return ((double)rand() / ((double)RAND_MAX + 1.0)) * (end - begin + 1) + begin;
</code></pre>

<p>to produce numbers in more reasonable way. However note that just like your first attempt, this will still not be producing uniformly distributed numbers (although it might be good enough).</p>
",0
22883945,22883840,1,"<p>Given that ULLONG_MAX and LLONG_MAX are both way bigger than the RAND_MAX value, you will certainly get ""less precision than you want"". </p>

<p>Other than that, there's 50% chance that your value is below the LLONG_MAX, as it is halfway throuogh the range of 64-bit values. </p>

<p>I would suggest using the Mersenne-Twister from the C++11, which has a 64-bit variant
<a href=""http://www.cplusplus.com/reference/random/mt19937_64/"" rel=""nofollow"">http://www.cplusplus.com/reference/random/mt19937_64/</a></p>

<p>That should give you a value that fits in a 64-bit number. </p>

<p>If you ""always get the same value"", then it's because you haven't seeded the random number generator, using for example <code>srand(time(0))</code> - you should normally only seed once, because this sets the ""sequence"". If the seed is very similar, e.g. you run the same program twice in short succession, you will still get the same sequence, because ""time"" only ticks once a second, and even then, doesn't change that much. There are various other ways to seed a random number, but for most purposes, <code>time(0)</code> is reasonably good. </p>
",2
22883968,22883840,26,"<p><strong>What is <code>rand()</code>?</strong></p>

<p>According to <a href=""http://www.cplusplus.com/reference/cstdlib/rand/"" rel=""noreferrer"">this</a> the <code>rand()</code> function returns a value in the range <code>[0,RAND_MAX]</code>.</p>

<p><strong>What is <code>RAND_MAX</code>?</strong></p>

<p>According to <a href=""http://www.cplusplus.com/reference/cstdlib/RAND_MAX/"" rel=""noreferrer"">this</a>, <code>RAND_MAX</code> is ""an integral constant expression whose value is the maximum value returned by the rand function. This value is library-dependent, but is guaranteed to be at least 32767 on any standard library implementation.""</p>

<p><strong>Precision Is An Issue</strong></p>

<p>You take <code>rand()/(double)RAND_MAX</code>, but you have perhaps only 32767 discrete values to work with. Thus, although you have big numbers, you don't really have <em>more</em> numbers. That could be an issue.</p>

<p><strong>Seeding May Be An Issue</strong></p>

<p>Also, you don't talk about how you are calling the function. Do you run the program once with <code>LLONG_MAX</code> and another time with <code>ULLONG_MAX</code>? In that case, the behaviour you are seeing is because you are implicitly using the same random seed each time. Put another way, each time you run the program it will generate the <em>exact same</em> sequence of random numbers.</p>

<p><strong>How can I seed?</strong></p>

<p>You can use the <a href=""http://www.cplusplus.com/reference/cstdlib/srand/"" rel=""noreferrer""><code>srand()</code></a> function like so:</p>

<pre><code>#include &lt;stdlib.h&gt;     /* srand, rand */
#include &lt;time.h&gt;       /* time */

int main (){
  srand (time(NULL));
  //The rest of your program goes here
}
</code></pre>

<p>Now you will get a new sequence of random numbers each time you run your program.</p>

<p><strong>Overflow Is An Issue</strong></p>

<p>Consider this part <code>((end - begin)*rand()/(double)RAND_MAX)</code>.</p>

<p>What is <code>(end-begin)</code>? It is <code>LLONG_MAX</code> or <code>ULLONG_MAX</code> these are, by definition, the largest possible values those data types can hold. Therefore, it would be <em>bad</em> to multiply them by anything. Yet you do! You multiply them by <code>rand()</code>, which is non-zero. This will cause an overflow. But we can fix that...</p>

<p><strong>Order of Operations Is An Issue</strong></p>

<p>You then divide them by <code>RAND_MAX</code>. I think you've got your <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""noreferrer"">order of operations</a> wrong here. You really meant to say: </p>

<pre><code>((end - begin) * (rand()/(double)RAND_MAX) )
</code></pre>

<p>Note the new parantheses! <strong>(</strong><code>rand()/(double)RAND_MAX</code><strong>)</strong></p>

<p>Now you are multiplying an integer by a fraction, so you are guaranteed not to overflow. But that introduces a new problem...</p>

<p><strong>Promotion Is An Issue</strong></p>

<p>But there's an even deeper problem. <strong>You divide an int by a double.</strong> When you do that the <code>int</code> is <a href=""http://www.learncpp.com/cpp-tutorial/44-type-conversion-and-casting/"" rel=""noreferrer"">promoted</a> to a <code>double</code>. A double is a <a href=""https://en.wikipedia.org/wiki/Floating_point"" rel=""noreferrer"">floating-point number</a> which basically means that it sacrifices precision in order to have a <em>big</em> range. That's probably what's biting you. As you get to bigger and bigger numbers both your <code>ullong</code> and your <code>llong</code> end up getting cast to the same value. This could be especially true if you overflowed your data type first (see above).</p>

<p><strong>Uh oh</strong></p>

<p>So, basically, everything about the PRNG you have presented is wrong.</p>

<p>Perhaps this is why <a href=""https://en.wikipedia.org/wiki/John_von_Neumann"" rel=""noreferrer"">John von Neumann</a> said</p>

<blockquote>
  <p>Anyone who attempts to generate random numbers by deterministic means
  is, of course, living in a state of sin.</p>
</blockquote>

<p>And, sometimes, we pay for those sins.</p>

<p><strong>How can I absolve myself?</strong></p>

<p>C++11 provides some nice functionality. You can use it as follows</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;limits&gt;
int main(){
  std::random_device rd;     //Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd()); //Use the 64-bit Mersenne Twister 19937 generator
                             //and seed it with entropy.

  //Define the distribution, by default it goes from 0 to MAX(unsigned long long)
  //or what have you.
  std::uniform_int_distribution&lt;unsigned long long&gt; distr;

  //Generate random numbers
  for(int n=0; n&lt;40; n++)
    std::cout &lt;&lt; distr(eng) &lt;&lt; ' ';
  std::cout &lt;&lt; std::endl;
}
</code></pre>

<p><strong>(Note that appropriately seeding the generator is difficult. <a href=""https://stackoverflow.com/questions/45069219/how-to-succinctly-portably-and-thoroughly-seed-the-mt19937-prng/"">This question</a> addresses that.)</strong></p>
",3
22884112,22883840,4,"<pre><code>typedef unsigned long long int UINT64;

UINT64 getRandom(UINT64 const&amp; min = 0, UINT64 const&amp; max = 0)
{
    return (((UINT64)(unsigned int)rand() &lt;&lt; 32) + (UINT64)(unsigned int)rand()) % (max - min) + min;
}
</code></pre>

<p>Using shift operation is unsafe since unsigned long long might be less than 64 bits on some machines. You can use <code>unsigned __int64</code> instead, but keep in mind it's compiler dependant, therefore is available only in certain compilers.</p>

<pre><code>unsigned __int64 getRandom(unsigned __int64 const&amp; min, unsigned __int64 const&amp; max)
{
    return (((unsigned __int64)(unsigned int)rand() &lt;&lt; 32) + (unsigned __int64)(unsigned int)rand()) % (max - min) + min;
}
</code></pre>
",8
22884168,22883840,0,"<p>The term <code>(end - begin)*rand()</code> seems produce an overflow. You can alleviate that problem by using <code>(end - begin) * (rand()/(double)RAND_MAX)</code>. Using the second way, I get the following results:</p>

<pre>
15498727792227194880
7275080918072332288
14445630964995612672
14728618955737210880
</pre>

<p>with the following calls:</p>

<pre><code>std::cout &lt;&lt; getRandom(0, ULLONG_MAX) &lt;&lt; std::endl;
std::cout &lt;&lt; getRandom(0, ULLONG_MAX) &lt;&lt; std::endl;
std::cout &lt;&lt; getRandom(0, ULLONG_MAX) &lt;&lt; std::endl;
std::cout &lt;&lt; getRandom(0, ULLONG_MAX) &lt;&lt; std::endl;
</code></pre>
",0
22884190,22883840,1,"<p>You are overflowing the computation, in the expression</p>

<pre><code>((end - begin)*rand()/(double)RAND_MAX)
</code></pre>

<p>you are telling the compiler to multiply (ULLONG_MAX - 0) * rand() and then divide by RAND_MAX, you should divide by RAND_MAX first, then multiply by rand().</p>

<pre><code>// http://stackoverflow.com/questions/22883840/c-get-random-number-from-0-to-max-long-long-integer
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;     /* srand, rand */
#include &lt;limits.h&gt;
using std::cout;
using std::endl;

typedef unsigned long long int UINT64;
UINT64 getRandom(const UINT64 &amp;begin = 0, const UINT64 &amp;end = 100) {
    //return begin &gt;= end ? 0 : begin + (UINT64) ((end - begin)*rand()/(double)RAND_MAX);
    return begin &gt;= end ? 0 : begin + (UINT64) rand()*((end - begin)/RAND_MAX);
};

int main( int argc, char *argv[] )
{
    cout &lt;&lt; getRandom(0, ULLONG_MAX) &lt;&lt; endl;
    cout &lt;&lt; getRandom(0, ULLONG_MAX) &lt;&lt; endl;
    cout &lt;&lt; getRandom(0, ULLONG_MAX) &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>See it live in <a href=""http://coliru.stacked-crooked.com/a/0c480ed9ec402bc6"" rel=""nofollow"">Coliru</a></p>
",0
22884608,22883840,1,"<pre><code>union bigRand {
    uint64_t ll;
    uint32_t ii[2];   
};

uint64_t rand64() {
    bigRand b;
    b.ii[0] =  rand();
    b.ii[1] =  rand();
    return b.ll;
}
</code></pre>

<p>I am not sure how portable it is. But you could easily modify it depending on how wide RAND_MAX is on the particular platform. As an upside, it is brutally simple. I mean the compiler will likely optimize it to be quite efficient, without extra arithmetic whatsoever. Just the cost of calling rand twice.</p>
",0
29233507,29233316,7,"<p>Wrap the <code>unique_ptr</code> members in another type which does the special behaviour (i.e. cloning the pointee, or whatever is appropriate). Or use a <code>clone_ptr</code> instead of <code>unique_ptr</code>.</p>

<p>Then just declare you class' copy constructor and copy assignment operator as defaulted.</p>

<p>This is a general pattern that is useful when you want non-default behaviour for some members only: Don't implement the entire copy constructor manually and have to specify behaviour for every member, use a wrapper to add the special behaviour to the members that need special behaviour, and then the containing class just relies on defaults.</p>

<p>In fact this is just a generalization of using an RAII type like <code>unique_ptr</code> or even <code>std::string</code> as a member. Instead of having to write a destructor for the containing class which remembers to <code>delete</code> the pointer member, or <code>free</code> every <code>char*</code>, you make each member do the right thing, and the containing class becomes foolproof.</p>

<blockquote>
  <p>This is perhaps better but it is useful only when those objects can be initialized independently of the other parent class members.</p>
</blockquote>

<p>It's still possible, but the wrapper might need a pointer back to the parent class, so it can reach the other members, and that does complicate things slightly.</p>

<p>In the case where you have related members that can't be initialized independently the related members can be grouped into another type which does the right thing for all of them together. That still makes it easier to compose them into a parent class if there are other members that can be initialized independently.</p>

<p>Again, you're making each sub-object independent and foolproof, so they can be composed like simple building blocks. If there are members that are not independent, they should be part of the same building block.</p>
",0
22430899,22430877,4,"<p>When you use a type as member, the type must complete. In your case, you want to use B,A inside each other which is not possible. </p>

<p>But you could use pointer to resolve the issue:</p>

<pre><code>class B;

class A {
public:
  B* b;  // now b is a pointer which points to B type, incomplete type B is OK
};
</code></pre>

<p><strong>¡ì 3.9.5 Types</strong></p>

<blockquote>
  <p>A class that has been declared but not defined, or an array of unknown size or of incomplete element type, is an incompletely-defined object type.43 Incompletely-defined object types and the void types are incomplete types (3.9.1). <strong>Objects shall not be defined to have an incomplete type.</strong></p>
</blockquote>
",0
22430906,22430877,1,"<p>You cannot do this. This is an infinite recursion: an instance of A has to include an instance (not a pointer!) of B, and an instance of B has to include an instance of A.</p>
",0
26814654,26814609,4,"<p>If you have a C++11 compiler, then explicitly delete the copy constructor (and optionally the copy assignment operator) for <code>Foo</code></p>

<pre><code>Foo(Foo const&amp;) = delete;
Foo&amp; operator=(Foo const&amp;) = delete;
</code></pre>

<p>For a pre-C++11 compiler, declare the two <code>private</code> and leave them undefined</p>

<pre><code>private:
  Foo(Foo const&amp;);
  Foo&amp; operator=(Foo const&amp;);
</code></pre>
",2
23581903,23581732,3,"<p>By the comments on your OP, it seems that you have a circular reference problem.</p>

<p><code>Snake</code> class is not used on your <code>GameBase</code> header.</p>

<p>You need to declare <code>#include ""Snake.h""</code> statement on your <strong>GameBase.cpp</strong> file instead.</p>
",0
26802194,26802090,9,"<p>You're creating a temporary object here:</p>

<pre><code>m_foos.push_back(Foo(a));
//               ^^^^^^
</code></pre>

<p>That object's destructor will be called when the full expression has ended, but it will have been copied (or moved) by <code>push_back()</code> into the vector.</p>

<p>To prevent the creation of a temporary you can construct in-place using <code>emplace_back()</code>:</p>

<pre><code>m_foos.emplace_back(a);
</code></pre>
",2
26802227,26802090,1,"<pre><code>m_foos.push_back(Foo(a));
</code></pre>

<p>This would result in two constructor call ( <strong>but it entirely depends on the compiler it can optimize away</strong>).</p>

<pre><code>Foo(a)
</code></pre>

<p>is a temporary which would be constructed ( one constructor call )and then copied to vector ( copy constructor called ). As usual temporaries are alive till the end of expression where they are used. So when push_back ends it would call destructor for this temporary ( that's why you are seeing a call to destructor). </p>
",1
29462782,29461310,6,"<p>The sample is a little muddled with that ""SampleImage"" name. The confusing part is that Win32 resources may be identified with either strings or (16-bit) integers. The sample leads you to use strings (e.g. L""SampleImage""), but the Visual Studio IDE (and, frankly, most code I've come across) prefers integers. To allow both kinds, the Win32 resource functions take parameters of type LPCWSTR and callers are supposed to use a macro, MAKEINTRESOURCE, to convert an integer ID into a ""pseudo string"". The same applies for resource types. There are some built-in types (ICON, CURSOR, BITMAP, et al), but you can always define your own types using strings.</p>

<p>If you look around in your code, you should be able to find a header file (Resource.h, probably) with the definition for IDB_PNG1. It's most likely a small integer, so you need to use the MAKEINTRESOURCE macro. PNG was probably not defined anywhere, and it's not one of the built-in resource types, so the resource compiler treated it as a string and so should you.</p>

<p>e.g.</p>

<pre><code>FindResource(
    NULL, // This component
    MAKEINTRESOURCE(IDB_PNG1), // Resource name
    L""PNG"",                    // Resource type
    );
</code></pre>

<p>Try that and let us know if it works.</p>
",0
32407345,32406892,13,"<p>It is undefined behaviour to erase from a set within a ranged-based for loop (even if it appears to work). Ranged-based for loops use an iterator internally and erasing the element invalidates the iterator.</p>

<p>But <code>std::set::erase</code> returns a valid iterator to the next element in the <code>std::set</code> so you can use an explicit iterator loop instead:</p>

<pre><code>for(auto itr = files.cbegin(); itr != files.cend();) {
  if (exists(*itr)) {
    std::cout &lt;&lt; ""Found file: "" &lt;&lt; *itr &lt;&lt; ""\n"";
    itr = files.erase(itr);
  } else
    ++itr;
}
</code></pre>

<p><a href=""http://melpon.org/wandbox/permlink/PaniSyvoU08TmqcO"" rel=""noreferrer"">Live demo.</a></p>
",3
32407402,32406892,1,"<p>Your first two examples look suboptimal because they both involve iterating through the <em>set</em> twice. Your third example is unstable because you continue to use the iterator after you invalidate it by changing the set using <code>std::set::erase</code>.</p>

<p>I would imagine the following should be reasonably efficient. However as others mentioned it may be worth replacing the <code>std::set&lt;std::string&gt; found_files</code> with a <code>std::vector</code>.</p>

<pre><code>#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

/**
 * Return true for every other call
 */
bool Exists(std::string const&amp;)
{
    static int i = 0;
    return ++i % 2;
}

std::set&lt;std::string&gt; find_existing_files(std::set&lt;std::string&gt;&amp; files)
{
    std::set&lt;std::string&gt; found_files;

    for(auto file = files.begin(); file != files.end();)
    {
        if(!Exists(*file))
            ++file; // not erasing, keep going
        else
        {
            found_files.insert(*file);
            // replacing iterator with result of erase()
            // keeps the iterator valid
            file = files.erase(file);
        }
    }
    return found_files;
}

int main()
{
    std::set&lt;std::string&gt; files {""a"", ""b"", ""c"", ""d"", ""e""};

    for(auto const&amp; file: find_existing_files(files))
        std::cout &lt;&lt; ""exists : "" &lt;&lt; file &lt;&lt; '\n';

    for(auto const&amp; file: files)
        std::cout &lt;&lt; ""missing: "" &lt;&lt; file &lt;&lt; '\n';
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>exists : a
exists : c
exists : e
missing: b
missing: d
</code></pre>
",2
32408455,32406892,4,"<p>With <a href=""http://en.cppreference.com/w/cpp/experimental/set/erase_if"" rel=""nofollow""><code>std::experimental::erase_if</code></a> from v2 of the library fundamentals TS:</p>

<pre><code>std::experimental::erase_if(files, Exists);
</code></pre>

<p>If <code>Exists</code> is overloaded or is a function template, use a lambda:</p>

<pre><code>std::experimental::erase_if(files, [](const auto&amp; f) { return Exists(f); });
</code></pre>

<p>This is already implemented in VS2015.</p>
",1
29186202,29185903,0,"<p>Yes, I got it. But I don't know the correct way to declare my member function</p>
",0
29185939,29185903,0,"<p>The member function declared like</p>

<pre><code>void solveSudoku(int);
</code></pre>

<p>that is it has one parameter of type <code>int</code>.</p>

<p>You call this function </p>

<pre><code>S.solveSudoku(grid);
</code></pre>

<p>passing to it a two-dimensional array</p>

<pre><code>int grid[9][9]
</code></pre>

<p>The compiler is unable to convert pointer to the first element of the array that has type <code>int ( * )[9]</code> to an object of type <code>int</code>.</p>

<p>It seems there is a typo because after the member function declaration you defined it like</p>

<pre><code>void sudoku::solveSudoku(int grid[N][N]){
//...
</code></pre>

<p>So update the function declaration in the class definition.</p>

<p>Also this constructor </p>

<pre><code>sudoku::sudoku() {
    N = 9;
    UNASSIGNED = 0;
}
</code></pre>

<p>is invalid because N and UNASSIGNED are declared as constant static members</p>

<pre><code>static const int N;
static const int UNASSIGNED;
</code></pre>
",14
26779774,26779628,3,"<p>If-statements don't make compile-time decisions; the compiler will always check both branches.</p>

<p>You need to create an overloaded <code>write()</code> function, where the default version streams to cout, and which you can overload for specific types (such as <code>char</code>).</p>
",5
26779861,26779628,2,"<h1>The problem:</h1>
<p>Like your compiler said:</p>
<pre><code>error: invalid static_cast from type ¡®std::basic_string&lt;char, std::char_traits&lt;char&gt;,  
std::allocator&lt;char&gt; &gt;¡¯ to type ¡®int16_t¡¯
</code></pre>
<p>I suppose your calling your log function like this:</p>
<pre><code>log(&quot;my % thing %....&quot;, /*my std::string*/ stringToto, 5,/*....*/);
</code></pre>
<p>And there is the problem!</p>
<p>When the compiler see you want to <code>static_cast</code> a <code>std::string</code> to a <code>int16_t</code>  it generate an error!</p>
<h1>What you've done wrong</h1>
<p>This part:</p>
<pre><code>    if ( std::is_same&lt;T, uint8_t&gt;::value || std::is_same&lt;T, int8_t&gt;::value )
    {
        int16_t x = value1;
        int16_t x = static_cast&lt;int16_t&gt;(value1);
        std::cout &lt;&lt; x;
    }
    else
    {
       std::cout &lt;&lt; value1;
    }
</code></pre>
<p>Why? In fact, even if your condition (<code>std::is_same&lt;T, uint8_t&gt;::value || std::is_same&lt;T, int8_t&gt;::value</code>) is false, your compiler will interpret your <code>static_cast</code></p>
<h1>What should you do</h1>
<p>Use a function that get an argument (whatever is its type) and generate an std::string, like this:</p>
<pre><code>template&lt;typename T&gt;
std::string
my_to_string(T) { return (&quot;what is this type?&quot;); }

template&lt;&gt;
std::string
my_to_string(std::string s) { return (s); }

template&lt;&gt;
std::string
my_to_string(int integer) { return (std::to_string(integer)); }
</code></pre>
<p>and then call it in your log function like this:
std::cout &lt;&lt; my_to_string(value1);</p>
<h1>Good Luck improving your work!</h1>
",1
26779867,26779628,1,"<p>You seem to call your function with a <code>std::string</code>, which cannot be converted to <code>int16_t</code>. Instead of the <code>static_cast</code>, you could use the following function template which is overloaded for strings:</p>

<pre><code>template&lt;typename T&gt;
auto cast_to_int(T const&amp; t) -&gt; int16_t
{
    return static_cast&lt;int16_t&gt;(t);
}

auto cast_to_int(std::string const&amp; t) -&gt; int16_t
{
     std::istringstream ss(Text);
     int16_t result;
     ss &gt;&gt; result;
     return result;
}
</code></pre>

<p>Eventually, you have to overload it for further types.</p>

<p><br>
Call the above via</p>

<pre><code>std::cout&lt;&lt; cast_to_int(value1);
</code></pre>

<p>instead of the whole block</p>

<pre><code>    if ( std::is_same&lt;T, uint8_t&gt;::value || std::is_same&lt;T, int8_t&gt;::value )
    {
        int16_t x = value1;
        int16_t x = static_cast&lt;int16_t&gt;(value1);
        std::cout &lt;&lt; x;
    }
    else
    {
       std::cout &lt;&lt; value1;
    }
</code></pre>
",0
25531866,25531731,1,"<p><code>a</code> is used as an output buffer. For example, <a href=""http://en.cppreference.com/w/cpp/io/strstreambuf/strstreambuf"" rel=""nofollow"">cppreference</a> gives us this example:</p>

<pre><code>char buf[10];
std::strstreambuf user(buf, 10, buf); // user-provided output buffer
std::ostrstream user_s(buf, 10); // equivalent stream
user_s &lt;&lt; 1.23 &lt;&lt; std::ends;
std::cout &lt;&lt; buf &lt;&lt; '\n';
</code></pre>

<p>Similarly, without using <code>ostrstream</code>, you can see the following example:</p>

<pre><code>char a[20];
std::strstreambuf sb0(a, 10, a);
sb0.sputc('a');
a[1] = '\0';
std::cout&lt;&lt;a&lt;&lt;std::endl;
</code></pre>

<p>outputs <code>a</code>.</p>
",0
31538386,31537997,1,"<p>I think you are a bit confused with the short-circuit operators :)</p>
<ul>
<li>For <strong>&amp;&amp;</strong>,  if the left-hand side expression is <strong>false</strong>, the combined result is <strong>false</strong> (the right-hand side expression is never evaluated).</li>
<li>For <strong>||</strong>,  if the left-hand side expression is <strong>true</strong>, the combined result is <strong>true</strong> (the right-hand side expression is never evaluated).</li>
</ul>
<p>This is mostly important when the right-hand expression has <em><strong>side effects</strong></em>, such as altering values(or calling some functions with side-effects), for example:</p>
<blockquote>
<p>if ( (itr &lt; 10) &amp;&amp; (++itr &lt; n) ) {</p>
<p>//do stuff</p>
<p>}</p>
</blockquote>
<p>Note that the combined conditional expression would increment <code>itr</code> by <code>1</code>, only if the conditional expression on the left of <code>&amp;&amp;</code> is <strong>true</strong>, because otherwise, the conditional expression on the right-hand side i.e. <code>(++itr &lt; n)</code> is never evaluated.</p>
",0
31538056,31537997,8,"<blockquote>
  <p>However with short circuit evaluation C++ only tests to see if the first condition is true, and if so, then it never checks whether the second condition is true. </p>
</blockquote>

<p>That is the case for <code>||</code>, but not <code>&amp;&amp;</code>. <code>&amp;&amp;</code> short circuits if the first condition is <code>false</code>. Your two snippets are equivalent.</p>
",0
31538623,31537997,0,"<p>Yes of-course!</p>

<p>With a Boolean AND, if a is false, and b is true, then (a AND b) is false. Similarly, if a is false and b is false, then (a AND b) is false.</p>

<p>With an AND condition if C++ determines that the left hand operand is false then there is no need to check the second operand since the entire condition is false.
Hence, the benefit of short-circuit evaluation.</p>
",0
31538654,31537997,2,"<p>The flaw here is in your understanding of the short-circuit rules, not with the rules themselves.   For any valid expressions <code>a</code> and <code>b</code></p>

<pre><code>  if (a &amp;&amp; b) ...
</code></pre>

<p>will always evaluate <code>a</code>.   If <code>a</code> is true, then <code>b</code> will always be evaluated.  The short-circuiting only occurs if <code>a</code> is <code>false</code> .... since that guarantees <code>a &amp;&amp; b</code> is <code>false</code>, without the need to evaluate <code>b</code>.</p>
",0
31538278,31537997,2,"<p>Just to be sure that there is no misunderstanding here:</p>

<pre><code>(a AND b)
</code></pre>

<p>will be FALSE for any value of <code>b</code> as long as <code>a</code> is FALSE. Similarly,</p>

<pre><code>(a OR b)
</code></pre>

<p>will be true for any value of <code>b</code> as long as <code>a</code> is TRUE.</p>

<p>So, in C++, <code>(a &amp;&amp; b)</code> is short-circuited <strong>when <code>a</code> is false</strong>, and <code>(a || b)</code> is short-circuited <strong>when <code>a</code> is true</strong>.</p>

<p>Conditions usually don't have side effects. If they do, you can be ""clever"" and do:</p>

<pre><code>if (a &amp;&amp; do_stuff()) {}
</code></pre>

<p>instead of</p>

<pre><code>if (a) { do_stuff(); }
</code></pre>

<p>or be really silly and do</p>

<pre><code>if (a &amp;&amp; do_stuff()) { do_more_stuff(); }
</code></pre>

<p>when you actually meant to do:</p>

<pre><code>if (do_stuff() &amp;&amp; a) { do_more_stuff(); }
</code></pre>

<p>which is why you don't <em>usually</em> have conditions with side effects. They are of course useful and used. And since both the <a href=""https://stackoverflow.com/questions/628526/is-short-circuiting-boolean-operators-mandated-in-c-c-and-evaluation-order?rq=1"">evaluation order and the short-circuiting are part of the standard</a>, you can safely use them.</p>
",0
25466250,25466221,2,"<p>Looks like the code you presented if the header file. And it contains the <em>definition</em> of <code>operator&lt;&lt;</code>, so any file including your header has its own copy of this definition, hence ""multiple definitions"" error. Add the keyword <code>inline</code> to your function, or move the function to .cpp file.</p>
",0
25466254,25466221,7,"<p>It seems you defined the operator in a header file and include this header in multiple cpp modules. or you include one cpp module with the function definition in other cpp module.
Usually the error mesage shows where a function is multiple defined. So reread all lines of the error message</p>

<p>Take into account that it would be better to declare the operator as</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; out, const Sphere &amp;fSphere);
</code></pre>
",0
26146258,26146217,4,"<p>The behavior is undefined.</p>

<pre><code>const char* testString = getString().c_str();
</code></pre>

<p><code>getString</code> returns a temporary object which is destroyed when the evaluation completes. As the result. <code>testString</code> points at internals of a destroyed object, causing undefined behavior.</p>

<p>In practice, it may happen that the data is still at that address for some time, that's why the first <code>cout</code> gives illusion of correctness.</p>
",1
26146266,26146217,1,"<p>You set pointer to a temporary object that will be deleted after this declaration</p>

<pre><code>const char* testString = getString().c_str();
</code></pre>

<p>So the program has undefined behaviour.</p>

<p>The correct code could look like</p>

<pre><code>const char * getString() {
  return ""test"";
}

int main(){
  const char* testString = getString();
//...
</code></pre>

<p>because string literals have static storage duration.</p>
",2
26146380,26146217,0,"<p>When you get a low level character pointer from a string object that manages the memory for that string, the pointer is only good for as long as <em>that specific</em> object is alive.</p>

<p>It's more narrow than that, actually.  If you call any non-const members on the string object,  it means you can't trust any values you got from previous calls to <code>c_str()</code> to still be good--even if the object destructor has not run.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

string getString() {
    return ""test"";
}

int main(){
    string testString = getString();
    const char * testCstring = testString.c_str();
    cout &lt;&lt; ""string 1:"" &lt;&lt; testCstring &lt;&lt; endl;
    string dummy[] = {""1"",""2"",""0""};
    cout &lt;&lt; ""string 2:"" &lt;&lt; testCString &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>That's legal, but do not rely upon the pointer from c_str() after you have made any modifying change to the string you got it from -or- that string having been destroyed.</p>

<p>Also note there's no need to get a char * from a string in order to output it.  Start thinking in terms of using string objects and don't go to char * unless you have a good reason.</p>
",0
22880393,22880259,4,"<p>I believe this is what you want</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
using namespace std;

int main() {

    std::string input = ""0|X|X|1|x|2|3|X"";
    std::istringstream ss(input);
    std::string token;

    while(std::getline(ss, token, '|')) {
       std::cout &lt;&lt; token &lt;&lt; '\n';
    }

    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/ODVumC"" rel=""nofollow"">http://ideone.com/ODVumC</a></p>

<p><a href=""http://www.cplusplus.com/reference/string/string/getline/"" rel=""nofollow"">getline</a> can work with any string stream and accepts an arbitrary separator</p>
",0
27153877,27153769,0,"<p>In multiple inheritance, there are multiple <code>vptr's</code> stored in the object i.e one per base class. Also, special vtbls must be generated for base classes in addition to the stand-alone vtbls.     </p>

<p>One more important thing:-</p>

<p>You should never assume that position of vptr is at object's beginning. It could even be at the end OR say in the middle. It's completely dependant on compiler vendors how they choose to implement it.</p>
",1
27153972,27153769,0,"<p>The table for a derived class can be implemented as an extension of the table for a base class, adding any new virtual functions to the end. The resulting table can be used for either class - for the base class, any extra functions at the end are simply ignored.</p>

<p>This means that the <code>Derive</code> object can share tables with one of the three base sub-objects, so only three tables are needed in total.</p>
",0
29446449,29446423,1,"<p>Your loop is written in such a way, that <code>m</code> and <code>n</code> are always the same. Write</p>

<pre><code>void fibbo(double a)
{
    double n = 1;
    double m = 0;
    while (n&lt;a){
        double t = n + m;
        m = n;
        n = t;
        cout &lt;&lt; n &lt;&lt; ""&lt;"" &lt;&lt; a &lt;&lt; endl;
    }
}
</code></pre>

<p>instead.</p>
",0
22472106,22472055,0,"<p>The type is <code>Object&amp;</code>, which is a reference. <code>p</code> then is a reference, which, when initilized, will cause it to bind to the initializer.</p>

<p>You could test for it by comparing their addresses. Remember that two different objects cannot have the same address, but references, which are only aliases have the same address as the object it is referring to.</p>

<pre><code>assert(&amp;p == &amp;o);   // p should refer to o
</code></pre>

<p>The initialization is the same as</p>

<pre><code>Object&amp; p = o;   // Still binds `o` to `p`
</code></pre>
",0
22472120,22472055,0,"<p>When you do this:</p>

<pre><code>Object &amp; p (o);
</code></pre>

<p>You're not constructing a new object, you just initialize a reference (i.e. you set the address of object it points to).</p>
",0
22472545,22472055,2,"<blockquote>
  <p>What is actually happening when we construct a reference with the parenthesis <code>()</code> syntax?</p>
</blockquote>

<p>The reference is initialised to refer to the result of the expression in parentheses.</p>

<blockquote>
  <p>Is there any difference (neglible or not) between <code>Object &amp; p (o);</code> and <code>Object &amp; p = o;</code>?</p>
</blockquote>

<p>No. Quoting the standard (C++11 8.5/13):</p>

<blockquote>
  <p>The form of initialization (using parentheses or =) is generally insignificant, but does matter when the initializer or the entity being initialized has a class type</p>
</blockquote>

<p>So it doesn't matter for a reference type. (For a class type, parentheses give <em>direct initialisation</em> via a constructor, while <code>=</code> gives <em>copy initialisation</em> via user-defined conversions).</p>
",0
21771469,21771361,1,"<p>As pointed out in the comments, you are assigning in your if statement in <code>(carSize = 'C') and (carSize = 'M')</code>. Out of interest, why not opt for a <code>switch</code> on the char here? It seems the branches are mutually exclusive, and you aren't mutating <code>carSize</code> in the branches? This might help avoid this kind issue in future:</p>

<pre><code>switch (carSize)
{
    case 'C':
       if (daysRented &lt; WEEK)
        ...
       break;
    case 'M':
       // ...
 }
</code></pre>

<p><strong>Edit</strong> </p>

<p>There is a second bug in your code, in that you are assigning:</p>

<pre><code>userCarTypeChosen = validateCarChoice();
</code></pre>

<p>But then you are passing the uninitialized variable <code>carSize</code> to the <code>calculateTotalCarCharge</code> function:</p>

<pre><code>carCharge = calculateTotalCarCharge(carSize, daysRented);
</code></pre>

<p>You should change the assignment to carSize</p>

<pre><code>carSize = validateCarChoice();
</code></pre>

<p>and then remove the <code>userCarTypeChosen</code> variable entirely.</p>
",5
21771536,21771361,1,"<p>For checking condition you have to use:</p>

<p><code>if (carSize == 'M')</code><br>
and<br>
<code>if (carSize == 'C')</code>.</p>

<p>Because when you use the statement:</p>

<p><code>if (carSize = 'M')</code> will just assign value <code>carSize</code> to <code>'M'</code>  </p>

<p>and will execute code inside the if statement. 
This condition is same for <code>if (carSize = 'C')</code> too.</p>

<p>OR use switch statement:</p>

<pre><code>switch (carSize)
{
    case 'C':
       if (daysRented &lt; WEEK)
        ...
       break;
    case 'M':
       // ...
 }
</code></pre>
",0
21772259,21771361,0,"<p>In these comparisons to literals, a good idea can be to reverse the operands, which will throw a compiler error if you use single equal instead of double equal.</p>

<pre><code>if (var == 'C')  // compiles, runs correctly
if (var = 'C')   // compiles, runs incorrectly, results in stackoverflow question
if ('C' == var)  // compiles, runs correctly
if ('C' = var)   // does not compile, fix this problem immediately
</code></pre>
",1
34208403,34208227,1,"<p>The below code will work you have problem with the scope of the variable</p>

<pre><code>#include&lt;iostream&gt;

using namespace std;

main (){

int c [100];
int i, z;
i = 0;
do {
  cout &lt;&lt; ""Enter value the number (-1 to end input): "";
  cin &gt;&gt; z;

    if (z != -1) {
      c[i] = z;  
    }
    i++;
} while (z != -1 &amp;&amp; i &lt; 100);
cout &lt;&lt;""Total number if positive integer entered by user is: "" &lt;&lt; i-1;
}
</code></pre>
",0
34208317,34208227,2,"<p>The variables <code>z</code> and <code>i</code> are declared outside the <code>do-while</code> loop</p>

<pre><code>int i, z;
</code></pre>

<p>but identically named, new variables are declared inside the loop.</p>

<pre><code>do {
  int z, i=0;
</code></pre>

<p>The <a href=""http://en.cppreference.com/w/cpp/language/do"" rel=""nofollow noreferrer""><code>do-while</code></a> loop has a <a href=""http://en.cppreference.com/w/cpp/language/scope"" rel=""nofollow noreferrer"">Block scope</a>. This causes that the 2nd declaration of the variables is valid and no redefinition, because they have their own scope. The operations on <code>z</code> and <code>i</code>, inside the loop, manipulate the variables which are declared inside the loop.</p>

<p>Since the control expression of the loop is not inside the block scope of the loop, the expression access the variables which are declared before the loop.<br/>
So the ""outer"" <code>z</code> and <code>i</code> variables are ""untouched"", the loop never terminates and is ""endless"".</p>

<p>The issue can simply be solved, by deleting the declaration of the variables <code>i</code> and <code>z</code> inside the loop and initializing the ""first"" <code>i</code> by 0:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

main (){
    int c [100];
    int z;
    int i=0;

    do {
      cout &lt;&lt; ""Enter value the number (-1 to end input): "";
      cin &gt;&gt; z;

        if (z != -1) {
          c[i] = z;  
        }
        i++;
    } while (z != -1 &amp;&amp; i &lt; 100);

    cout &lt;&lt;""Total number if positive integer entered by user is: "" &lt;&lt; i-1;
}
</code></pre>
",1
31238311,31237736,3,"<p>If you are allocating memory with <code>new</code> you need to release it with <code>delete</code> and that's going to be a problem if the caller is in another language.</p>

<p>So you will need to provide a second function to release the memory.</p>

<pre><code>int __stdcall postsbinv(char** retstring)
{
    *retstring = new char[outputSize];
}

void __stdcall free_sbinv(char** retstring)
{
    if (*retstring)
        delete[] *retstring;
}
</code></pre>
",0
31237992,31237736,0,"<p>You can do something like this to improve your code:</p>

<pre><code>char *retinvnumtemp = new char[outputSize];

if(retinvnumtemp==NULL) {
    // enter code here
} else {
    // enter code here
}
</code></pre>

<p>And also to prevent from memory leaks you should use </p>

<p>delete []  retinvnumtemp;</p>
",0
22422349,22422322,1,"<p>Because <code>x = 1</code> is an assignment setting <code>x</code> to <code>1</code>, not a comparison for equality. Comparison is done via <code>x == 1</code>.</p>

<p>It is a common mistake. Often people write <code>1 == x</code> to catch these errors, since assignment to a constant triggers a compile-time error.</p>
",0
22422350,22422322,3,"<p>The result of assignment is its left operand, so the value of <code>x = 1</code> is its left operand <code>x</code>, which has the value of <code>1</code> now. And any non-zero integer is treated as true in the condition.</p>
",0
22422387,22422322,1,"<p>Besides the assignment result for <code>x</code> as mentioned in the other answers the </p>

<pre><code> if (std::cout &lt;&lt; ""Is it true?"")
</code></pre>

<p>evaluates to <code>true</code>, because the statement is equivalent to </p>

<pre><code> if ((std::cout &lt;&lt; ""Is it true?"").good())
</code></pre>

<p>which checks for the stream state of <code>std::cout</code>.</p>
",0
22422392,22422322,4,"<p>The <code>if (x = 1)</code> is essentially the same as <code>tmp = (x = 1); if (tmp) ...</code></p>

<p>The ""result"" of <code>operator &lt;&lt; (const char *)</code> is an <code>ostream&amp;</code>, which has an <code>operator bool</code> that the compiler calls to make it ""comparable"". <code>operator bool</code> will return ""false if there was an error, otherwise true"". Before C++11, it would return a <code>void*</code>, but the meaning was the same (""false (= 0) if there is an error, true otherwise"". </p>
",0
22422399,22422322,-1,"<p>In the first one, you're assigning the value of <code>1</code> to <code>x</code>.  A non-zero value will always evaluate to true in a condition.</p>

<p>For the second one, when <code>std::cout &lt;&lt; ""Is it true?""</code> is called, operator&lt;&lt; will return a reference to <code>std::cout</code>.  At that point, the condition is simply reduced to:</p>

<pre><code>if (std::cout)
    //
</code></pre>

<p>This is now evaluating whether or not <code>std::cout</code> is in a <a href=""http://www.cplusplus.com/reference/ios/ios/good/"" rel=""nofollow"">good</a> state.</p>
",0
22422410,22422322,0,"<p>Both statements return a value other than <code>0</code> and are thus considered to be ""true"".</p>

<p>If you assign a value to a variable, the result of that statement is the assigned value so you can assign multiple variables at once. For example, <code>foo = bar = baz = 1</code>. This works because <code>baz = 1</code> yields <code>1</code>, which is then assigned to <code>bar</code>, then to <code>foo</code>. So <code>x = 1</code> has the value <code>1</code> and is thus true.</p>

<p>Next, the <code>std::cout &lt;&lt; ""foo""</code>: the <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt"" rel=""nofollow""><code>operator&lt;&lt;</code></a> on a ostream returns the ostream so you can do things like <code>std::cout &lt;&lt; ""foo"" &lt;&lt; ""bar"";</code>. Again, there is a value returned that is not <code>0</code> and thus true.</p>
",0
22422431,22422322,0,"<p>In this condition <code>x = 1</code> you firstly assign <code>1</code> to your <code>x</code> variable, and then test x, so it is exactly the same with:</p>

<pre><code>x = 1;
if( x ) // which is 1, so true
</code></pre>

<p>About the output operator <code>&lt;&lt;</code>, the compiler will return <code>true</code> if the output-stream's state <code>cout</code> is ok. So it is not going to be a valid stream if some error occurs.</p>
",0
30177498,30177385,0,"<pre><code>class UserClass
{
    ...
    vector&lt;C*&gt; v;
}

void UserClass::callFonEveryCmember(void)
{
    for (unsigned i = 0; i &lt; v.size(); ++i) {
        v.at[i]-&gt;f();
    }
}
</code></pre>
",0
30177501,30177385,2,"<p>C++ doesn't have reflection like e.g. C# if that's what you're after. What I've done in the past is to generate C++ code from a class description and then also generate reflection code with it. I.e. your users would be making class descriptions rather than classes.</p>

<p>The short-term solutions I see are 
1) Have a function like you describe above
2) Rather than separate member, use one member with a vector of c's.</p>
",0
32467810,32466157,2,"<p>This does nothing to solve the OP's bizarro number problem (which I can't seem to reproduce), but just to get this out there. C++11 and better provide a number of different ways to resolve the <code>rand</code> sucks issue.</p>

<p>I, for one, welcome our <a href=""http://en.cppreference.com/w/cpp/header/random"" rel=""nofollow"">new random number generating overlords</a>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;

int main()
{
    std::random_device device;
    // build a random number generator for seeding
    std::default_random_engine engine(device()); 
    // nothing fancy. Assuming the compiler implementors know what they are doing
    // seeding it with a nice random number from above.
    std::uniform_int_distribution&lt;int&gt; distribution(-30, 30);
    // generate uniformly distributed numbers from -30 to 30

    int randomas;
    for(int i=0; i&lt;10; i++) {
        randomas = distribution(engine); // Bless me with a number, divine masters!
        std::cout &lt;&lt; randomas &lt;&lt; ""\n""; // Witness the number all shiny and chrome!
    }
    return 0;
}
</code></pre>
",4
32466256,32466157,2,"<p>Try this:</p>

<pre><code>srand (time(NULL));
for(int i = 0;  i &lt; 10; i++)
{
    int rnd;
    rnd = rand() % (60) - 30;

    cout &lt;&lt; rnd &lt;&lt; std::endl;
}
</code></pre>

<p>Working example <a href=""http://ideone.com/0dXm3G"" rel=""nofollow"">here</a></p>
",4
32466394,32466157,1,"<p>Try this code. It is an application of a linear congruence generator to your problem. The generator has very good properties.</p>

<pre><code>#include &lt;iostream&gt;

int main( int argc,char** argv )
{
//the seed, an arbitrary initial value
int seed = 338;

//these constants define a linear congruence generator
int modulus = 2147483399;
int multiplicator = 40692;
int m = 52774;
int l = 3791;

//additional variables
double max = static_cast&lt;double&gt;( modulus );
double value;

//number of random numbers
int N = 20;

//random number generation
int lcg_value = seed;

int k1;
int z;

for( int i = 0; i &lt; N; ++i )
{
    k1 = lcg_value / m;
    z = multiplicator * ( lcg_value - k1 * m ) - k1 * l;

    if( z &lt; 0 )
    {
        z = z + modulus;
    }

    lcg_value = z;

    //random number, lies between 0.0 and 1.0
    value = static_cast&lt;double&gt;( lcg_value ) / max;

    //print random number, lies between -30.0 and 30.0
    std::cout &lt;&lt; ( 60.0 * value - 30.0 ) &lt;&lt; std::endl;
}

return( 0 );
}
</code></pre>
",6
34272795,34272717,81,"<p><code>void*</code> is at least necessary as the result of <code>::operator new</code> (also every <a href=""http://en.cppreference.com/w/cpp/memory/new/operator_new"" rel=""noreferrer""><code>operator new</code></a>...) and of <code>malloc</code> and as the argument of the placement <code>new</code> operator.</p>

<p><code>void*</code> can be thought as the common supertype of every pointer type. So it is not exactly meaning pointer to <code>void</code>, but pointer to anything.</p>

<p>BTW, if you wanted to keep some data for several unrelated global variables, you might use some <code>std::map&lt;void*,int&gt; score;</code>  then, after having declared global <code>int x;</code> and <code>double y;</code> and <code>std::string s;</code> do <code>score[&amp;x]=1;</code> and <code>score[&amp;y]=2;</code> and <code>score[&amp;z]=3;</code> </p>

<p><a href=""http://en.cppreference.com/w/cpp/string/byte/memset"" rel=""noreferrer""><code>memset</code></a>  wants a <code>void*</code> address (the most generic ones)</p>

<p>Also, POSIX systems have <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html"" rel=""noreferrer"">dlsym</a> and its return type evidently should be <code>void*</code></p>
",6
34272818,34272717,16,"<p>Oh yes. Even in C++ sometimes we go with <code>void &#42;</code> rather than <code>template&lt;class T&#42;&gt;</code> because sometimes the extra code from the template expansion weighs too much.</p>

<p>Commonly I would use it as the actual implementation of the type, and the template type would inherit from it and wrap the casts.</p>

<p>Also, custom slab allocators (operator new implementations) must use <code>void *</code>. This is one of the reasons why g++ added an extension of permitting pointer arithmatic on <code>void *</code> as though it were of size 1.</p>
",5
34272999,34272717,10,"<blockquote>
  <p>Input: If we want to allow multiple input types we can overload
  functions and methods</p>
</blockquote>

<p>True.</p>

<blockquote>
  <p>alternatively we can define a common base
  class.</p>
</blockquote>

<p>This is partially true: what if you <em>can't</em> define a common base class, an interface or similar? To define those you need to have access to the source code, which is often not possible.</p>

<p>You didn't mention templates. However, templates cannot help you with polymorphism: they work with static types i.e. known at compile time.</p>

<p><code>void*</code> may be consider as the lowest common denominator. In C++, you typically <em>don't</em> need it because (i) you can't inherently do much with it and (ii) there are almost always better solutions. </p>

<p>Even further, you will typically end up on converting it to other concrete types. That's why <code>char *</code> is usually better, although it may indicate that you're expecting a C-style string, rather than a pure block of data. That's why<code>void*</code> is better than <code>char*</code> for that, because it allows implicit cast from other pointer types.</p>

<p>You're supposed to receive some data, work with it and produce an output; to achieve that, you need to know the data you're working with, otherwise you have a different problem which is not the one you were originally solving. Many languages don't have <code>void*</code> and have no problem with that, for instance. </p>

<h2>Another legitimate use</h2>

<p>When printing pointer addresses with functions like <code>printf</code> the pointer shall have <code>void*</code> type and, therefore, you may need a cast to <code>void</code>*</p>
",0
34274446,34272717,28,"<p>There are multiple reasons to use <code>void*</code>, the 3 most common being:</p>

<ol>
<li>interacting with a C library using <code>void*</code> in its interface</li>
<li>type-erasure</li>
<li>denoting un-typed memory</li>
</ol>

<p>In reverse order, denoting un-typed memory with <code>void*</code> (3) instead of <code>char*</code> (or variants) helps preventing accidental pointer arithmetic; there are very few operations available on <code>void*</code> so it usually require casting before being useful. And of course, much like with <code>char*</code> there is no issue with aliasing.</p>

<p>Type-erasure (2) is still used in C++, in conjunction with templates or not:</p>

<ul>
<li>non-generic code helps reducing binary bloat, it's useful in cold paths even in generic code</li>
<li>non-generic code is necessary for storage sometimes, even in generic container such as <code>std::function</code></li>
</ul>

<p>And obviously, when the interface you deal with uses <code>void*</code> (1), you have little choice.</p>
",0
34273145,34272717,7,"<p>Yes, it is as useful as any other thing in the language.<br/>
As an example, you can use it to erase the type of a class that you are able to statically cast to the right type when needed, in order to have a minimal and flexible interface.</p>

<p>In <a href=""https://stackoverflow.com/questions/34154202/simple-event-system-in-c/34154876#34154876"">that</a> response there is an example of use that should give you an idea.<br/>
I copy and paste it below for the sake of clarity:</p>

<pre><code>class Dispatcher {
    Dispatcher() { }

    template&lt;class C, void(C::*M)() = C::receive&gt;
    static void invoke(void *instance) {
        (static_cast&lt;C*&gt;(instance)-&gt;*M)();
    }

public:
    template&lt;class C, void(C::*M)() = &amp;C::receive&gt;
    static Dispatcher create(C *instance) {
        Dispatcher d;
        d.fn = &amp;invoke&lt;C, M&gt;;
        d.instance = instance;
        return d;
    }

    void operator()() {
        (fn)(instance);
    }

private:
    using Fn = void(*)(void *);
    Fn fn;
    void *instance;
};
</code></pre>

<p>Obviously, this is only one of the bunch of uses of <code>void*</code>.</p>
",0
34276111,34272717,2,"<p>In short, C++ as a strict language (not taking into account C relics like <em>malloc()</em>) requires void* since it has no common parent of all possible types. Unlike ObjC, for example, which has <em>object</em>. </p>
",5
29173950,29173881,0,"<p>n &lt;&lt; 16 to shift bits would do it, to move lower bits to upper? (edited) And after that, copying just the lower 16 bits into it</p>
",1
29173989,29173881,2,"<p>You want to copy the bits in 0-15 to 16-31. You should understand that multiplying by 2 is equivalent to shifting the bits of the number once to the left (moving to higher bits).</p>

<p>If your number is <code>n</code>, <code>n &lt;&lt; 16</code> would be shifting your number 16 bits to the left. This is equivalent to multiplying n with the 16th power of 2, which happens to be 65536.</p>

<p>To copy the bits, and keep the original bits in 0-15, the command <code>n = n + (n &lt;&lt; 16);</code> should work. However, the issue with this is (as pointed out in the comments), that the upper 16-31 bits are still set in <code>n +</code> term. We also need to clear these bits. Note that 65535 corresponds to 2^16 - 1, and would have the first 0-15 bits as 1, and others as 0. So the correct command would be <code>n = (n &amp;&amp; 65535) + (n &lt;&lt; 16);</code></p>
",4
29174023,29173881,1,"<p>This will do it:</p>

<pre><code>void copyFromTo(unsigned int&amp; n)
{
    n = (n &amp; 0xffff) * 0x00010001;
}
</code></pre>
",3
21321037,21320857,1,"<p>The streams implementing both <code>std::istream</code> and <code>std::ostream</code>, e.g., <code>std::stringstream</code> and <code>std::fstream</code> derive from <code>std::iostream</code> (since they are all class templates, you'd look for <code>basic_...</code> in the standard). That is, if you really need a stream which is used for both input and output, you'd pass an <code>std::iostream&amp;</code>.</p>

<p>The class <code>std::iostream</code> derives from both <code>std::istream</code> and <code>std::ostream</code>. The appropriate types are straight forward:</p>

<ul>
<li>for reading only use <code>std::istream&amp;</code></li>
<li>for writing only use <code>std::ostream&amp;</code></li>
<li>for reading and writing use <code>std::iostream&amp;</code> (I don't think I ever used this in production code)</li>
</ul>

<p>Note that you need to seek when switching between reading and writing in case the stream may be a file stream: switching between reading and writing without intervening seek, even if the seek is to the current position, results in undefined behavior.</p>
",0
21321091,21320857,0,"<p>Both the string stream classes and file stream classes publically-derive from the general stream bases classes <code>std::basic_istream&lt;...&gt;</code> and <code>std::basic_ostream&lt;...&gt;</code>. This means that you can pass (for instance) <code>std::ostringstream</code> objects to functions that take <code>std::ostream</code>:</p>

<blockquote>
<pre><code>void test(std::ostream&amp; os);

std::ostringstream buf;
test(buf); // Good!
</code></pre>
</blockquote>

<p>Unless of course, you need additional functionality specific to the derived stream classes. For example, string streams provide an <code>str()</code> method and file streams provide <code>open()</code>/<code>close()</code> member functions. In the case where you need these, you can have <code>test()</code> take string streams or file streams as parameters.</p>

<blockquote>
<pre><code>void test(std::istringstream&amp; iss)
{
     std::cout &lt;&lt; iss.str(); // Works because the type is a stringstream
}
</code></pre>
</blockquote>
",0
24587303,24587180,4,"<p>In your code:</p>

<pre><code>int n;
ans = (n*(n + 1) / 2) + 1;
</code></pre>

<p>All values in the calculation are ints: <code>n</code> is declared as int, and plain integer constants are ints as well. Therefore the result of this calculation will also be an int. The fact that you later assign this result to a long long variable doesn't change this.</p>

<p>Now the result of the multiplication 65535*65536 does not fit in a 32-bit signed int, so you get a nonsense answer. Fix your program by making <code>n</code> a 64-bit long long.</p>
",0
24587308,24587180,4,"<p>As @Dithermaster suggests, the problem here is probably one of integer overflow.</p>

<p>As it stands right now, your code doesn't actually make much sense. In particular, since you've defined <code>n</code> as an <code>int</code>, and all the integer literals in the expression: <code>(n*(n + 1) / 2) + 1</code> are also small enough to fit in an <code>int</code>, the calculation will be carried out on <code>int</code>s, and then (<em>after</em> the calculation is complete) the result will be converted to <code>long long</code> and assigned to <code>ans</code> (because you've defined <code>ans</code> as a <code>long long</code>).</p>

<p>What you almost certainly <em>want</em> is to carry out the entire calculation on <code>long long</code> to avoid overflow. The most obvious way to do this would be to define <code>n</code> as a <code>long long</code> instead of an <code>int</code>.</p>

<p>Your friend has avoided this by defining <code>n</code> as a <code>double</code>. This works up to a point--a typical implementation of <code>double</code> has a 53-bit significand, so it can be used as (essentially) a 53-bit integer type. That's obviously quite a bit more than the 16 bits that's mandated for an <code>int</code>, but equally obviously less than the 64 bits mandated for a <code>long long</code>.</p>

<p>There's also no point in supporting <code>n</code> being negative, so you could consider defining <code>n</code> and <code>ans</code> as <code>unsigned long long</code> instead.</p>
",0
24074411,24074392,2,"<p>Without <code>return</code> statement in function this code invoked <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behavior</strong></a>. A non <code>void</code> function must have a return statement.</p>
<h3>C++11 ¡ì 6.6.3 The return statement:</h3>
<blockquote>
<p>3 ...Flowing off the end of a function is equivalent to a return with no value; this results in <strong>undefined behavior</strong> in a value-returning function.</p>
</blockquote>
<p>As <a href=""https://stackoverflow.com/users/1322972/whozcraig"">WhozCraig</a> stated in comment,  there is one standard-defined exception to the non-void return value requiring a <code>return</code>: <code>int main()</code></p>
<h3>C++11 ¡ì 3.6.1p5 [basic.start.main]</h3>
<blockquote>
<p>If control reaches the end of main without encountering a return statement, the effect is that of executing <code>return 0;</code></p>
</blockquote>
<p>In case of UB you may get either expected or unexpected result.<br />
The printed value could be the value stored in the stack.</p>
",5
24074427,24074392,1,"<p>It's undefined behavior if a function that returns non-void doesn't return anything. The compiler should give you at least a warning. </p>

<p>What probably happens is, the value of <code>product</code> is still in the stack after the function exits, and <code>std::cout</code> prints that value. But again, don't rely on undefined behavior.</p>
",1
24074445,24074392,1,"<p>It's undefined behavior, so there's no guarantee that it will work.</p>

<p>When it does work correctly, it's because the result happens to be computed in the same CPU register that is used to return integer values from functions. This is dependent on a many factors (e.g. compiler version, system ABI, compiler options, surrounding code), so you can't rely on it.  </p>
",0
24583633,24583561,1,"<p>If your primary concern is being able to ""easily change the types of the parameters"", it's straightforward to write them as templates so that you never have to change the types of the parameters:</p>

<pre><code>template &lt;typename T1, typename T2&gt;
auto add (const T1 &amp;a, const T2 &amp;b) -&gt; decltype(a + b) {
    return (a + b);
}
</code></pre>

<p>This also handles cases where <code>a</code> and <code>b</code> are not of the same type, or where <code>a + b</code> is not the same type as <code>a</code> or <code>b</code>.</p>
",6
24584724,24583561,1,"<p>If these were member functions you could declare their common type (<code>typedef const int Fn(int, int)</code>), declare the member functions inside the class using that type:</p>

<pre><code>Fn add, subtract;
</code></pre>

<p>Then you define them outside the class in the normal way. Doesn't save boilerplate, but at least means it won't compile if you make a typo in the definitions.</p>

<p>Alternatively for non member functions see the question I linked to which has some clever ways to define function pointers rather than functions.</p>
",0
24584758,24583561,3,"<p>A function <strong>signature</strong> cannot be <code>typedef</code>ed. Only a function's type. So it's valid to say :</p>

<pre><code>typedef int INT_OPERATION(int a, int b);
</code></pre>

<p>and then forward declare a function having this type : </p>

<pre><code>INT_OPERATION Add;
</code></pre>

<p><strong>but</strong> when it comes to <strong>defining</strong> the function you'd have to specify arguments, so the follwing is <strong>invalid</strong></p>

<pre><code>INT_OPERATION Add { /* No can do */ }
</code></pre>

<p>(as soon as you place a set of <code>()</code> after <code>Add</code> you'll be declaring a function returning a plain function which is not valid C++)</p>

<h2>On generic types</h2>

<p>The same procedure has similar limitations when using the tools for generic programming. You <strong>can</strong> declare the following typedef :</p>

<pre><code>template&lt;typename T&gt;
using INT_OPERATION = const T(T const, T const);
</code></pre>

<p>And then use it for a function (forward) declaration </p>

<pre><code>INT_OPERATION&lt;int&gt; add;

int main() {
    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>but when it comes to defining it, you'd have to be mandane </p>

<pre><code>const int add(int const a, int const b) {
    return a + b;
}
</code></pre>

<p><a href=""http://ideone.com/6dICTI"" rel=""nofollow"">Demo</a></p>
",0
24584815,24583561,2,"<p>Maybe something like that:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;

typedef std::function&lt;int(int, int)&gt; IntFunction;

IntFunction add = [](int a, int b) {return a + b;};
IntFunction substract = [](int a, int b) {return a - b;};

int main(int, char**) {
    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;
    std::cout &lt;&lt; substract(1, 2) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Still boilerplate code, but worth a try ;)</p>
",0
21300340,21300274,1,"<p>When using class templates in C++ you have to explicitly define the members of those classes with the declaration, in the header file, otherwise you won't be able to compile it.</p>

<p>(see <a href=""https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file"">Why can templates only be implemented in the header file?</a>)</p>
",0
28460799,28460759,0,"<p>All member functions of a class have access to the data members of the class.  This also applies to different objects of the same type.</p>

<pre><code>class Foo()
{
private: 
    int bar;
public:
    void foobar(Foo &amp; different) { bar = different.bar; }
};
</code></pre>
",1
28460808,28460759,3,"<p>Since you define a copy constructor for an iterator inside the implementation of the iterator itself, there is no need to make the hidden pointer accessible, with or without an accessor: the copy constructor will have access to it even if it is private, so there's nothing to worry about:</p>

<pre><code>template &lt;class T&gt;
class MyIter {
    T *private_ptr;
public:
    MyIter(const MyIter&lt;T&gt; &amp;other) : private_ptr(other.private_ptr) {}
    ... // More constructors and member functions
};
</code></pre>
",0
25502221,25502120,0,"<p>I think problem is not in <code>const</code>. Problem is, that <code>strRelativePath[i]</code> is <code>wchar_t</code>, not <code>wchar_t*</code>.
You should use</p>

<pre><code>wcscat(strResultAbsolutePath, &amp;strRelativePath[i]);
</code></pre>

<p>that means copy from <code>strRelativePath</code> beginning from symbol by index <code>i</code> to <code>strResultAbsolutePath</code>.</p>
",0
23105797,23105588,1,"<p>The return type of static member function <code>getSublistAccess</code> is</p>

<pre><code>iplist&lt;Instruction&gt; BasicBlock::*
</code></pre>

<p>that is, a pointer to a non-static data member of class <code>BasicBlock</code>, where the data type is <code>iplist&lt;Instruction&gt;</code>.</p>

<p>What <code>getSublistAccess</code> actually returns is <code>&amp;BasicBlock::InstList</code>, that is exactly a non-static data member of class <code>BasicBlock</code>, where the data type is <code>InstListType</code>. i.e., <code>iplist&lt;Instruction&gt;</code>.</p>
",2
23105816,23105588,0,"<p>Is a function pointer.<br>
You can read <strong><a href=""http://www.newty.de/fpt/fpt.html#defi"" rel=""nofollow"">this article</a></strong> for detail.</p>
",1
23106369,23105588,0,"<p>Thanks to <strong>iavr</strong> for the answer. I'm awarding the answer to him but I'd like to add some details here which will hopefully help someone reading this post.</p>

<p>What I asked and as iavr explained to me, might be understood with the following code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct customType {
    int b;
    };
struct Instruction {};

class BasicBlock {
public:

 BasicBlock(int a) { InstList.b = a; }
 customType InstList;

  static customType BasicBlock::*getSublistAccess(Instruction*) {
    return &amp;BasicBlock::InstList;
  }
};

int main() {

    BasicBlock bb(90);

    Instruction justForSignature;
    // Get a pointer to a member of type customType through the static function
    customType BasicBlock::* ptrToMember = BasicBlock::getSublistAccess(&amp;justForSignature);

    cout &lt;&lt; (bb.*ptrToMember).b; // Parenthesis are necessary, '.' has higher precedence on *
    // Output: 90

    return 0;
}
</code></pre>

<p>Try it out: <a href=""http://ideone.com/hYgfh8"" rel=""nofollow"">http://ideone.com/hYgfh8</a></p>
",1
26171343,26169405,1,"<p>It sounds like you want to validate the Yes or No response.  That requires a loop that exits only when you have an acceptable input.  It's separate from the loop that decides if the calculation should be run again.</p>

<pre><code>int main() {
  // ...
  do {
    // ...

    do {
      cout &lt;&lt; ""Would you like to recalculate? Either enter Y to run or N to not."" &lt;&lt; endl;
      cin &gt;&gt; c;
    } while (c != 'Y' &amp;&amp; c != 'y' &amp;&amp; c != 'N' &amp;&amp; c != 'n');
  } while (c == 'Y'|| c=='y');

  system(""pause"");
  return 0;
}
</code></pre>
",0
23854772,23854750,1,"<p>You code has <strong>undefined behavior</strong> because you are accessing them beyond the size. In <code>v1</code> there will be 7 items, while in <code>v2</code>, there will be 3. But you are accessing both upto index 20. So the output can be <em>anything</em>.</p>

<p>To avoid this, you can <code>resize</code> your vectors and then assign <code>1</code> to specified indexes.</p>

<pre><code>v1.resize(N); // keep enough space
v2.resize(N);


for(int i = 0; i &lt; N; i+=3) {
 v1[i]=1;
}
for(int i = 0; i &lt; N; i+=7) {
 v2[i]=1;
}
for(int i = 0; i &lt; N; ++i) {
 if(v1[i] == 1 &amp;&amp; v2[i] == 1) count++;
}
</code></pre>

<p>Another problem is your loop conditions are <code>i&lt;=N</code>, which should be <code>i&lt;N</code>. <code>vector</code> has zero based index.</p>
",0
23854775,23854750,0,"<p>The vector is not an array, that means there are no gaps between the pushed entries.</p>

<p>In the first vector, you have 6 entries, in the second, you have 3 entries, the first 3 entries match, so you get 3.</p>

<p>I would expect that v1[i] and v2[i] would give an error when i becomes more than the number of elements in the vector though.</p>
",1
23854788,23854750,0,"<p>Your code throws an exception as <code>v1</code> has 7 items after the push_back loop - while <code>v2</code> has 3.</p>

<p>you can't access <code>v1[8]...v1[20]</code></p>
",2
33027303,33026886,1,"<p>For the first one, if you input 1 digit number, your function returns before <code>iterationcount</code> get any value. To fix it, set <code>iterationcount</code> to 0 in the beginning of your function:</p>

<pre><code>int counter = 0;
iterationcount = counter;
</code></pre>

<p>Actually you may use <code>iterationcount</code> as counter and not create a separate variable for it.</p>

<p>For second problem use <code>std::numeric_limits&lt;int&gt;::max()</code>. So new function would look like that:</p>

<pre><code>bool isLychrel(int checknumber, int &amp;iterationcount) {
    const int iterCount = 50;
    int reversed = rev(checknumber);
    int counter = 0;
    iterationcount = counter;
    if (checknumber == reversed) { //makes sure that a number that starts out as a palindrome gets value ""0"" for iterations
        return false;
    }
    while (counter &lt; iterCount) { //loop that keeps going until it finds a palindrome or reaches 50 iterations
        if (std::numeric_limits&lt;int&gt;::max() - reversed &lt; checknumber)
            return true;
        ++counter;
        iterationcount = counter;
        if (Palindromecheck(reversed + checknumber))
            return false;
        checknumber += reversed;
        reversed = rev(checknumber);
    }
    return true;
}
</code></pre>
",3
29249558,29249344,-1,"<p>I would use ATL Server classes to do the same. Here is the example:</p>

<pre><code>CAtlHttpClient client; 
AtlNavigateData navData; 
LPCSTR lpData = ""data=toto""; 
navData.SetMethod(ATL_HTTP_METHOD_POST); 
navData.SetPostData((BYTE*)lpData, lstrlenA(lpData), _T(""application/x-www-form-urlencoded"")); 
client.Navigate(_T(""mysite.net""),      _T(""myscript.php""),    &amp;navData);     
const char* pszBody = (const char*)client.GetBody(); 
</code></pre>
",2
22478593,22476782,1,"<p>Would it be acceptable for you to enforce the user of the class to use <a href=""http://www.parashift.com/c++-faq-lite/static-init-order-on-first-use.html"" rel=""nofollow"">Construct On First Use Idiom</a> for all static instances of <code>Object</code>? Then, they should always be constructed after the container which should be constructed before <code>main</code>. Static objects are destructed in reverse order of construction. Therefore all static <code>Object</code> that are constructed after the container will be destroyed first.</p>

<p>Quote from standard ¡ì3.6.3 / 1:</p>

<blockquote>
  <p>... If the completion of the constructor or dynamic initialization of an object with static storage
   duration is sequenced before that of another, the completion of the destructor of the second is sequenced
  before the initiation of the destructor of the first.</p>
</blockquote>

<p>If that's not acceptable, how about adding a flag to the <code>Object</code> class:</p>

<pre><code>class Object {
public:
    bool registered; // init to false, set to true on registration
    ~Object() { if(registered) reg.erase(this);  }
</code></pre>

<p>Then modify the destructor  of the container (use a custom delegating container or subclass if you cannot modify the current container) to set the flag <code>false</code> for each pointed object before clearing contents. This may also be possible if you wrap the container into a <code>unique_ptr</code> with a custom deleter.</p>
",4
27167373,27167333,7,"<p>Why should this not happen? Once you've deleted memory at a particular address, the memory manager is perfectly at liberty to re-use that address the next time you ask for new memory. Indeed this is a very common optimisation used by memory managers. They keep track of recently freed blocks and hand them back to the next client that requests a block of that size.</p>

<p>Another way to look at this would be to consider what would happen if freed addresses were never re-used. If that were to happen then eventually, after enough allocation/deallocation cycles, there would be no address space left. Indeed, if re-use never happened then there would be no point at all in deallocating memory. So yes, do expect that when you deallocate memory, that memory address will be re-used. </p>
",7
27167393,27167333,2,"<pre><code>abc *A = new abc ;
</code></pre>

<p>This will allocate enough memory to hold abc object and make A point to that address( Let's say address is 0x1234). So, A contains value 0x1234.</p>

<p>delete A;</p>

<p>will deallocate that memory( that means memory is returned to free store). But A still contains the value of that memory address i.e 0x1234.</p>

<p>Deleting same pointer two times makes for undefined behavior is a conseqeunce of this thing only as second time you would be deleting the memory which is not yours.</p>

<p>That's why you do</p>

<pre><code>A= NULL;
</code></pre>

<p>after deleting the memory.</p>
",1
27167396,27167333,1,"<p>Memory you freed is not used anymore. Memory manager can use the heap as it wants - allocating next free space - the one you actually freed just before.</p>
",0
27167423,27167333,3,"<p>it is because you are deleting the pointers.do not delete them you will see the difference.</p>

<pre><code>abc *A = new abc ;
abc *B = new abc ;
</code></pre>
",1
27167435,27167333,0,"<pre><code>abc *A = new abc ;
cout&lt;&lt; static_cast&lt;void*&gt;(A) &lt;&lt; endl ;
</code></pre>

<p>This is the first output.</p>

<pre><code>delete A ;
cout&lt;&lt; static_cast&lt;void*&gt;(A) &lt;&lt; endl ;
</code></pre>

<p>Though it is after <code>delete</code> the value of <code>A</code> remains the same. What <code>delete</code> did was: 1. call the destructor (in this case trivial) of <code>A</code> and 2. Inform the memory allocator that the memory allocated for <code>A</code> is now free and can be used for other purposes.</p>

<pre><code>abc *B = new abc ;
cout&lt;&lt; static_cast&lt;void*&gt;(B) &lt;&lt; endl ;
</code></pre>

<p>It may be that in this step output will be still the same - since allocator has the memory previously allocated for <code>A</code> for use now, it may use it for <code>B</code>.</p>

<pre><code>delete B ;
cout&lt;&lt; static_cast&lt;void*&gt;(B) &lt;&lt; endl ;
</code></pre>

<p>The same as before with <code>A</code>.</p>
",0
28530314,28530278,4,"<p>The definition needs to go outside the class, while the initializer belongs inside the class.</p>

<pre><code>constexpr char A::dict[][3];
</code></pre>
",0
29950427,29948044,1,"<p>Why not have a do-nothing default constructor?</p>

<pre><code>public:
  SpecialReader(){};
</code></pre>
",1
21302417,21206914,0,"<p>The correct answer was: </p>

<pre><code>Test _testStr = {.x = 100, .y = 100} 
</code></pre>
",0
28500388,28500299,2,"<p>You have not defined the constructor for <code>templateDynamic</code> and <code>Holder</code></p>
",2
23848114,23848100,3,"<blockquote>
  <p>But what if the element I am looking for IS at the end?</p>
</blockquote>

<p>It cannot be. The end, (i.e. the iterator returned by <code>end()</code>) does not point to a valid element.  The last element (if there are more than zero elements) in the container is the one pointed at by the iterator <em>preceding</em> <code>end()</code>.</p>

<blockquote>
  <p>Or maybe it is a list, containing ONLY the element I am looking for?</p>
</blockquote>

<p>Then <code>find</code> will not return <code>end</code>. It will return <code>begin</code>.  Which, in that case, directly precedes <code>end</code>.</p>
",0
23848116,23848100,4,"<p>If the searching item is at the end of the list (container) then the iterator is not referring to the <code>end()</code>. The iterator <code>end()</code> is a reserved (placeholder) iterator, the next one after your last item. However it doesn't apply for <code>begin()</code> which is really refers to the first item inside the container. Generally in C++ ranges are in this form [begin, end).</p>

<p><img src=""https://i.stack.imgur.com/BB2P0.png"" alt=""enter image description here""></p>

<blockquote>
  <p>Returns an iterator to the element following the last element of the
  container. This element acts as a placeholder; attempting to access it
  results in undefined behavior. <a href=""http://en.cppreference.com/w/cpp/container/vector/end"" rel=""nofollow noreferrer"">?</a></p>
</blockquote>
",0
23848117,23848100,3,"<p><code>end()</code> does not point to a valid element (it points to one past the last element). Therefore there is no ambiguity.</p>
",0
31298367,31298326,2,"<p>Here's a nutshell explanation.</p>

<p>In the same way that this expression:</p>

<pre><code>i;
</code></pre>

<p>is just referring to the variable <code>i</code> without actually doing anything with it, this expression:</p>

<pre><code>clearDisplay;
</code></pre>

<p>simply refers to the <code>clearDisplay</code> function without actually calling it.</p>
",4
31298375,31298326,8,"<p>You can regard <code>clearDisplay</code> as the address of the function. Crucually, it will have a non-zero numerical value, and a statement consisting of a single variable is grammatically correct.</p>
",2
31298399,31298326,4,"<p>It's the same reason this is not a compiler error:</p>

<pre><code>for(int i = 0; i &lt; 2; i++){
</code></pre>

<p>Look at <code>i++</code>. That's an expression whose result you've completely ignored. But that's perfectly legal. Why? Because you are allowed to ignore the results of expressions.</p>

<p>To be helpful, your compiler warns you when you ignore the results of expressions with no side-effects. But if there was a language rule that it was illegal to ignore expressions with no side-effects, that would require compilers to perfectly tell whether expressions have side-effects or not, and that's basically impossible.</p>
",10
22124231,22124216,4,"<p>Using <code>*this</code> returns the actual reference to the object through what is known as <strong>dereferencing</strong>. Before the dereference, <code>this</code> is a <strong>pointer</strong>. Using <code>*this</code> gives you the <strong>""content of""</strong> this current object</p>

<p><a href=""http://cslibrary.stanford.edu/106/"" rel=""nofollow"">Pointers/Dereference Link</a></p>

<p><strong>FYI:</strong> Just to add some clarity to the <code>*</code> and <code>&amp;</code> operators for your future reference on other problems</p>

<blockquote>
  <p>*<strong>var</strong> ...Means ""content of"" var</p>
  
  <p><strong>int*</strong> ...Means int pointer</p>
  
  <p><strong>&amp;int</strong> ...Means address of int</p>
  
  <p><strong>int&amp;</strong> ...Means int address</p>
</blockquote>
",0
22124234,22124216,0,"<p>You are accessing current object. <code>this</code> is pointer to current object. <code>*this</code> will be current object.</p>
",0
22124240,22124216,1,"<p><code>this</code> is a pointer to the object. Using an <code>*</code> deferences the pointer, resulting in the actual object instead of a memory address.</p>
",1
22124259,22124216,1,"<p><code>*this</code> gives the current object. In your case, <code>!( *this == rhs );</code> inturn invokes <code>bool operator==( const String &amp;rhs )</code> that you have defined in your <code>String</code> class.</p>

<p>If it were through pointer (<code>this</code>) you would have to invoke <code>operator==</code> manually <code>this-&gt;operator==(rhs)</code>. By putting <code>*this</code> in your example, you help the compiler to know that it actually needs to call <code>operator==</code></p>
",0
29175077,29175026,1,"<p>You forgot to implement 2 virtual methods, the clone and the calculerInteret.
That is why your linker is complaining. Your linker is not complaining about the destructor but he has trouble creating the virtual method table because 2 methods that are marked virtual, are missing. 
Only a linker can find issues like that because in theory these methods can even be spread over multiple source files.</p>

<p>If it is your intent to create abstract methods do this :</p>

<pre><code>virtual Compte* clone() const=0;
virtual const double calculerInteret()=0;
</code></pre>

<p>of course you realise you cannot instantiate classes that have abstract methods right ?</p>
",4
29175102,29175026,1,"<p>Not the problem in this case but may be the problem for anyone viewing this post:</p>

<p>Forgetting a body on a virtual destructor generates the following: </p>

<blockquote>
  <p>undefined reference to `vtable for CYourClass'.  </p>
</blockquote>

<p>I am adding a note because the error message is deceptive.  (This was with gcc version 4.6.3.)</p>

<p>So add:</p>

<pre><code>Compte::~Compte()
{
}
</code></pre>

<p>To your <code>cpp</code> file.</p>

<p>EDIT 1: As pointed out by  Philip Stuyck: If the destructor were missing , then you would have had a similar error, but you can have it for any missing virtual method. If the virtual is inline yes or no does not matter, you just need one if its virtual.</p>
",5
27572401,27572304,0,"<blockquote>
  <p><em>""so what could be the problem can any one tell?""</em> </p>
</blockquote>

<p>If such a situation occurs, the most probable reason is, you have hit <strong><a href=""https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior"">undefined behavior</a></strong> in your code somewhere else.<br>
I can't tell any more from the context and code you have posted. But using a tool like <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">valgrind</a> is likely to do this right on your service.</p>
",3
27574521,27572304,2,"<p>You're using pointers more heavily than you should for these simple types.  Pointers and dynamic allocation are the likely sources of your undefined behavior.  So a simple first step is to refactor and clean up your code, preferring stack variables and pass-by-reference for simple types.  In all likelihood, the undefined behavior will go away, or the error will be easier to spot.</p>

<p>[Caveat: I can't get to pastebin, so I can't see your full code.  Prefer simple examples right here on the site]</p>

<p>For example, your function signature should probably be this (I'm guessing about which parameter is the output)</p>

<pre><code>static inline point FindPoint(const Line &amp;First, const AABB &amp;Second,int direction)
</code></pre>

<p>And</p>

<pre><code>Line *objvec = new Line;
</code></pre>

<p>should just be</p>

<pre><code>Line objvec;
</code></pre>

<p>etc, etc.</p>

<pre><code>std::vector&lt;point&gt; pntvec;
</code></pre>

<p>is probably the most important.  A vector of pointers is ok, but should be avoided if possible.  One of the nice parts about standard containers is the auto-cleanup when the variable goes out of scope.  You don't get that with a vector of pointers, since the vector doesn't know to call <code>delete</code> on every element.  You have to do it yourself.</p>
",0
24097407,24097309,0,"<ol>
<li>What you want to assign to is not a reference but a pointer.</li>
<li><code>B</code> is derived from <code>A</code>, so <code>B</code> <em>is an</em> <code>A</code>. But <code>A</code> is not a <code>B</code>.</li>
<li>Thus <code>A*ptr=new B;</code> is allowed, but not what you want. </li>
<li>Suppose <code>B*ptr=new A;</code> was possible. If <code>B</code> contains data members which <code>A</code> doesn't have,
interpreting <code>A</code> as <code>B</code> makes no sense and trying to access those members will at best cause a crash.</li>
</ol>

<p>Btw, this is not a C++ tutorial site. I recommend to read a beginner's book.</p>
",0
24383820,24383771,4,"<p>This is because of the Packing and byte alignment. Check <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">structure alignment</a></p>

<p>Check <a href=""http://www.c-faq.com/struct/align.html"" rel=""nofollow"">C-FAQ</a> for details</p>

<p>It's for ``alignment''. Many processors can't access 2- and 4-byte quantities (e.g. ints and long ints) if they're crammed in every-which-way.</p>

<p>Suppose you have this structure:</p>

<pre><code>struct  {
    char a[3];
    short int b;
    long int c;
    char d[3];
    };
</code></pre>

<p>Now, you might think that it ought to be possible to pack this structure into memory like this:</p>

<pre><code>+-------+-------+-------+-------+
|           a           |   b   |
+-------+-------+-------+-------+
|   b   |           c           |
+-------+-------+-------+-------+
|   c   |           d           |
+-------+-------+-------+-------+
</code></pre>

<p>But it's much, much easier on the processor if the compiler arranges it like this:</p>

<pre><code>+-------+-------+-------+
|           a           |
+-------+-------+-------+
|       b       |
+-------+-------+-------+-------+
|               c               |
+-------+-------+-------+-------+
|           d           |
+-------+-------+-------+
</code></pre>

<p>In the <code>packed'' version, notice how it's at least a little bit hard for you and me to see how the b and c fields wrap around? In a nutshell, it's hard for the processor, too. Therefore, most compilers will</code>pad'' the structure (as if with extra, invisible fields) like this:</p>

<pre><code>+-------+-------+-------+-------+
|           a           | pad1  |
+-------+-------+-------+-------+
|       b       |     pad2      |
+-------+-------+-------+-------+
|               c               |
+-------+-------+-------+-------+
|           d           | pad3  |
+-------+-------+-------+-------+
</code></pre>

<p>Also check this <strong><a href=""http://c-faq.com/struct/align.esr.html"" rel=""nofollow"">C-Faq</a></strong></p>
",5
24389002,24383771,0,"<p>The answer is: it depends. The standard imposes no requirements on the layout of bit fields. Specifically, </p>

<blockquote>
  <p>Allocation of bit-fields within a class
  object is implementation-defined. Alignment of bit-fields is implementation-defined. Bit-fields are packed
  into some addressable allocation unit. [ Note: Bit-fields straddle allocation units on some machines and not
  on others. Bit-fields are assigned right-to-left on some machines, left-to-right on others. ¡ªend note ]</p>
</blockquote>

<ul>
<li>Assuming 32-bit integers the maximum space requirement for each is <code>3*sizeof(int)</code>, or 12, 12, 12 bytes. </li>
<li>With maximal packing the minimum sizes are respectively 3, 3, 4 bytes, depending perhaps on <code>#pragma pack</code>. </li>
<li>A typical result might well be 4, 4, 8 but that could easily vary from one compiler to another.</li>
</ul>

<p>So the answer is: it all depends. This is one reason I strongly advise against the use of bit fields anytime the layout or size requirements are important. Shift and mask is much more predictable.</p>
",0
30412708,30412656,2,"<p>There are two problems with your code:</p>

<ul>
<li>Your definitions of <code>static</code> members lack a type, and</li>
<li>Your definitions of <code>static</code> members are in the header file.</li>
</ul>

<p>Although one could argue that C++ compiler has enough information to figure out the types of <code>HolderClass::customer</code> and <code>HolderClass::employee</code>, the syntax of the language requires you to repeat the type anyway.</p>

<p>You should do two things to fix this:</p>

<ul>
<li>Remove both definitions from the header. Keeping them there would result in duplicate definition errors on linking</li>
<li>Add the lines below to the CPP file with implementations of <code>HolderClass</code> member functions (or any other CPP file if there is no <code>HolderClass.cpp</code> in your design).</li>
</ul>

<p>Code:</p>

<pre><code>Customer* HolderClass::customer = nullptr;
Employee* HolderClass::employee = nullptr;
</code></pre>
",0
30412737,30412656,0,"<p>The only things that can be at file scope are declarations.</p>

<p>But these lines are statements (or expressions), not declarations.</p>

<pre><code>HolderClass::customer = nullptr;
HolderClass::employee = nullptr;
</code></pre>

<p>Definitions are a particular type of declaration.   In this case, what you need is;</p>

<pre><code>Customer *HolderClass::customer = nullptr;
Employee *HolderClass::employee = nullptr;
</code></pre>

<p>which are the definitions (including initialisations) required corresponding to the declarations within the class definition.   These definitions need to appear in a single source file (.cpp), not in a header file.</p>
",0
25535149,25535038,5,"<p>From the <a href=""http://en.cppreference.com/w/cpp/numeric/random/rand"" rel=""nofollow noreferrer"">documentation</a> of <code>rand()</code>: </p>

<blockquote>
  <p>Returns a pseudo-random integral value between ?0? and RAND_MAX <strong>(0 and RAND_MAX included)</strong>.</p>
</blockquote>

<p>Emphasis mine.</p>

<p>However, as <a href=""https://stackoverflow.com/users/440119/benjamin-lindley"">Benjamin Lindley</a> correctly points out in the comments, <code>rand()</code> is irrelevant to the result in this question. The key to the question is the modulus operator <code>%</code>.</p>

<p>Because the modulus operator results in the remainder of the division of the left operand by the right operand, the value of anything <code>rand()</code> could produce, <code>% 10</code>, will be between <code>0</code> and <code>9</code>. Because <code>1</code> is added to the result of that operation, the final output will be between <code>1</code> and <code>10</code>.</p>

<p>I would like to add that <a href=""https://stackoverflow.com/users/1339987/djechlin"">djechlin</a> is correct both in his comment to this answer and in his answer, that the answer to questions like ""<em>what does this function do?</em>"" is generally best and quickest found by searching for the name of the language and the name of the function with a search engine such a <a href=""https://encrypted.google.com/"" rel=""nofollow noreferrer"">Google</a> or <a href=""http://www.bing.com/"" rel=""nofollow noreferrer"">Bing</a> or alternatively the documentation for the language, such as <a href=""http://en.cppreference.com/w/"" rel=""nofollow noreferrer"">cppreference</a> for c++.</p>
",3
25535059,25535038,0,"<p>I think it would be a disservice to the community to answer your question directly. Therefore I'm leaving you with a method that if you choose to understand and run yourself, should give you the answer:</p>

<pre><code>int main() {
    for(int i = 0; i &lt; 20; i++) {
        std::cout &lt;&lt; rand() % 10 + 1 &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

<p>More generally questions about how functions work are usually answered in the documentation for the said function. Without much trouble you should be able to find it yourself by googling something like ""c++ rand"". Again it would be a disservice to spoonfeed too much, but if you have a real problem with the documentation you can amend your question here.</p>
",7
30147390,30146931,2,"<p>I imagine that in the mass of code that you posted, that you are talking about this loop:</p>

<pre><code>while (size &gt; 0){
    if((board[line][col] == -1) &amp;&amp; (ori == 'H')){
        board[line][col] = 0;
        col++;
        cout &lt;&lt;  ""size "" &lt;&lt; size &lt;&lt; endl;

        return true;
    }
    else if ((board[line][col] == -1) &amp;&amp; (ori == 'V')){
        board[line][col] =  symbol;
        line++;
        return true;
    }

    else
        return false;
    size--;
}
</code></pre>

<p>Note that all paths of that conditional have a return statement. So that while loop will be executed either once or never at all.</p>
",0
32980271,32979980,5,"<p>It's because you are not instantiating an object using the following:</p>

<pre><code>Vector2 a();
</code></pre>

<p>This is actually a function declaration which is why it's complaining about the missing function at link time.  </p>

<p>To create an object using the default constructor it should be:</p>

<pre><code> Vector2 a;
</code></pre>
",1
24362625,24362576,1,"<p><code>WriteToFile</code> is expecting the second argument to be a function pointer, not the result of a function call. Change the call to look like this:</p>

<pre><code>WriteToFile(""test.txt"", Printer);
</code></pre>

<p>Still, it doesn't make much sense, because <code>&amp;f</code> is the address of the function, so it'll just print some hex value. You probably want to call the function pointer:</p>

<pre><code>FileProcessor &lt;&lt; (*f)(""exampleText"") &lt;&lt; endl;
</code></pre>

<p>For passing the argument, you have two options. Vinayak Garg listed one, which is to add a third argument to <code>WriteToFile</code>. The other one is to use <code>std::bind</code>.</p>

<pre><code>WriteToFile(""test.txt"", std::bind(&amp;Printer, ""exampleText""));
</code></pre>

<p>In the latter case it will not look like it takes an argument however. Your definition of <code>WriteToFile</code> should look like this (untested):</p>

<pre><code>void WriteToFile(string filename, const std::function&lt;string()&gt; &amp;f )
{
    ...
    FileProcessor &lt;&lt; f() &lt;&lt; endl;
}
</code></pre>
",3
24362633,24362576,1,"<p>AFAIK <code>Printer(""exampleText"")</code> is passed incorrectly. The second argument of function <code>WriteToFile</code> accepts a pointer to function. So just pass the function <code>Printer</code>.</p>

<p>The argument for the passed function pointer should be sent as different argument.</p>

<p>Something like-</p>

<pre><code>void WriteToFile(string filename, string (*f)(string), string mystring )
{
    ofstream FileProcessor;

    FileProcessor.open(filename, ios::app);

    FileProcessor &lt;&lt; f(mystring) &lt;&lt; endl;

}
</code></pre>

<p>and then called like </p>

<pre><code>WriteToFile(""test.txt"", Printer, ""exampleText"");
</code></pre>
",0
26442043,26416666,4,"<h2>Why it's not legal</h2>
<p>There are four <code>std::min</code> function templates in C++11 [algorithms.general]/2:</p>
<pre><code>template&lt;class T&gt;
const T&amp; min(const T&amp; a, const T&amp; b);

template&lt;class T, class Compare&gt;
const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);

template&lt;class T               &gt; T min(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare&gt; T min(initializer_list&lt;T&gt; t, Compare comp);
</code></pre>
<p>(I'm not sure if for the purpose of taking a pointer, there might be additional overloads.)</p>
<p>To simplify the notation, I'll use <a href=""http://kuhllib.com/2012/01/17/continental-const-placement/"" rel=""nofollow noreferrer"">&quot;continental const placement&quot;</a> from here on:</p>
<pre><code>template&lt;class T&gt;
T const&amp; min(T const&amp; a, T const&amp; b);
</code></pre>
<p>When explicitly providing the first template argument as in <code>std::min&lt;int&amp;&gt;(x,y)</code>,
all of those overloads are tried to be instantiated. For those where instantiation succeeds, overload resolution selects the viable candidates, then a single best match. If instantiation (substitution) for any of those overloads fails in a non-immediate context, an error occurs.</p>
<p>Since you pass <code>int&amp;</code> as the template argument, <code>T</code> in all the overloads above will be substituted for <code>int&amp;</code>. This can lead to instantiating <code>initializer_list&lt;T&gt;</code> (if the compiler can determine the correct overload without instantiating this class, it doesn't have to).</p>
<p>Overload resolution must check if the conversion from an lvalue of type <code>int</code> (the argument) to <code>initializer_list&lt;int&amp;&gt;</code> is valid. This requires instantiating the class, to check for converting constructors. (As I said, if the compiler is smart enough, it does not have to perform this instantiation.)</p>
<p>The compilers I've checked - including g++4.9 and clang++3.5, in both libstdc++ and libc++ - report an error for <code>std::min&lt;int&amp;&gt;(x,y)</code>. This error occurs due to trying to instantiate <code>initializer_list&lt;int&amp;&gt;</code>: there is a member defined as follows</p>
<pre><code>typedef E const* iterator;
</code></pre>
<p>where <code>E</code> is the template parameter of the <code>initializer_list</code>. Substituting <code>E</code> for <code>int&amp;</code> yields</p>
<pre><code>typedef int&amp; const* iterator;
</code></pre>
<p>which illegally forms a pointer to a reference.</p>
<p>The definition of the member is not in an immediate context of <code>std::min</code>, therefore an error occurs (the program is ill-formed).</p>
<hr />
<h2>Working around the problem</h2>
<p>We can however eliminate this problem by specifying explicitly which overload to call. This can be done by using a function pointer (which requires overload resolution to get a pointer to a single function):</p>
<pre><code>using ft = int&amp;(int&amp;,int&amp;);
constexpr auto f = static_cast&lt;ft*&gt;(&amp;std::min&lt;int&amp;&gt;);
auto const min = f(x,y);
</code></pre>
<p>This works fine in libstdc++, but fails in libc++. I cannot find any text that forbids explicitly providing the template argument to <code>std::min</code>, nor can I find any requirement that the template argument must not be a reference.</p>
<p>How does it work? The cast explicitly selects an overload. A special kind of overload resolution is performed, that selects only the overload(s) whose type is <em>identical</em> to <code>ft</code>. This might require an instantiation of the overload of <code>std::min</code> which takes a <code>initializer_list</code>, but it does not require an instantiation of <code>initializer_list&lt;int&amp;&gt;</code>. When comparing to the implicit overload resolution in a call-expression such as <code>std::min&lt;int&amp;&gt;(x,y)</code>, note that we do not need to convert from some type to <code>intializer_list&lt;int&amp;&gt;</code> here: we only need to check whether <code>initializer_list&lt;int&amp;&gt;</code> (the type of the first parameter of the function) is the same type as <code>int&amp;</code> (the type of the first parameter of <code>ft</code>).</p>
<p>I conclude therefore that the above code is well-formed and well-behaved. This implies that there's a bug in libc++. For those interested, <a href=""https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm#L2581"" rel=""nofollow noreferrer"">libc++ dispatches</a> the first <code>std::min</code> overload (with two parameter of the form <code>const&amp;</code>) to the form with a predicate/comparator:</p>
<pre><code>template &lt;class _Tp&gt;
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
const _Tp&amp;
min(const _Tp&amp; __a, const _Tp&amp; __b)
{
    return _VSTD::min(__a, __b, __less&lt;_Tp&gt;());
}
</code></pre>
<p>The problem here is that the template parameter is not explicitly passed to the other <code>std::min</code> function, but deduced. However, the deduced type is <code>int</code>, not <code>int&amp;</code>. This produces a mismatch between the function parameter types <code>int const&amp;</code> and the type expected by the comparator <code>int&amp;</code>:</p>
<pre><code>bool less(int&amp;, int&amp;);

int const&amp; min(int const&amp; x, int const&amp; y)
{
    return less(y, x) ? y : x; // cannot bind an lvalue of type `int const`
                               // to a parameter of type `int&amp;`
}
</code></pre>
<hr />
<h2>Assigning to <code>min(x,y)</code></h2>
<p>When we instantiate the first <code>std::min</code> overload via <code>std::min&lt;int&amp;&gt;</code> and <code>int&amp;</code> is substituted, <a href=""https://stackoverflow.com/a/3772234/420683""><em>reference collapsing</em></a> happens:</p>
<p>In the initial <code>T const&amp;</code> parameter type, <code>T</code> is substituted for <code>int&amp;</code>. This yields <code>int&amp; const&amp;</code>. The <code>const&amp;</code> is collapsed with the <code>int&amp;</code> to the type <code>int&amp;</code>. The signature of the instantiated function becomes:</p>
<pre><code>int&amp; min&lt;int&amp;&gt;(int&amp; a, int&amp; b);
</code></pre>
<p>Therefore, with the above definition of <code>f</code>, we can write:</p>
<pre><code>f(x, y) = 42;
</code></pre>
<hr />
<h2>Value category</h2>
<p>If the return type of a function is an lvalue-reference, the function call expression is an lvalue. Value category is not concerned with const-ness. <code>std::min</code> returns an lvalue in any case.</p>
",3
24365210,24365129,4,"<p>The compiler error with gcc:</p>

<pre><code>$ g++ test.cc
test.cc: In function 'int main()':
test.cc:3:23: error: array bound forbidden after parenthesized type-id
test.cc:3:23: note: try removing the parentheses around the type-id
</code></pre>

<p>So, you just need to remove the parentheses to remove the error:</p>

<pre><code>intptrs = new int*[10];
</code></pre>

<p>As you are working with C++, I would suggest to use <code>std::vector</code> instead of the raw array:</p>

<pre><code>#include &lt;vector&gt;
int main() {
  // create 10 pointers to int
  std::vector&lt;int*&gt; intptrs(10);
}
</code></pre>

<p>(Note that the pointed to objects will not be deleted when the vector is destroyed. You need to do this manually, when you need to. Or use smart pointers instead of raw pointers, e.g., <code>std::shared_ptr</code>.)</p>

<p>For reference:</p>

<ul>
<li><a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow"">http://en.cppreference.com/w/cpp/container/vector</a></li>
<li><a href=""http://de.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow"">http://de.cppreference.com/w/cpp/memory/shared_ptr</a></li>
</ul>
",4
24365244,24365129,0,"<p>intptrrs is a pointer to a pointer. So this should work</p>

<pre><code>*intptrs = new int[10];
</code></pre>
",1
32455649,32455071,1,"<p>This code works as expected for me:</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

int main() {
  const char* config = ""username 12345 google.com 225"";
  istringstream iss_str(config);
  string token;
  // storage for splitted config data
  vector&lt;string&gt; tokens;

  // port number is an integer value, hence it should
  // be type-cast back to integer
  int config_int_port = 0;

  while( getline(iss_str, token, ' ') )
    {
      cout &lt;&lt; ""token "" &lt;&lt; token &lt;&lt; ""\n"";
      tokens.push_back(token);
    }
  cout &lt;&lt;""tokens len ""&lt;&lt;tokens.size()&lt;&lt;""\n"";
}
</code></pre>

<p>the output is:</p>

<pre><code>token username
token 12345
token google.com
token 225
tokens len 4
</code></pre>
",1
24589924,24589895,2,"<p>Just use <code>std::not1(std::ptr_fun(space))</code>. <code>std::not1</code> is declared in <code>&lt;functional&gt;</code>.</p>

<p>(There is also a <code>std::not2</code> for use with binary predicates; <code>std::not1</code> is for unary predicates.)</p>
",1
24589996,24589895,0,"<p>You can also declare</p>

<pre><code>template &lt;bool find_space&gt; bool space(char c) {
    return find_space ^ (!isspace(c));
}
</code></pre>

<p>and then refer to it as <code>space&lt;true&gt;</code> and <code>space&lt;false&gt;</code> in the argument to <code>find_if()</code>. Much more versatile than <code>std::not1()</code>.</p>
",1
24590007,24589895,1,"<p>You cannot simply use <code>!space</code> instead of <code>not_space</code> because all you'll be doing in that case is passing <code>false</code> to <code>find_if</code>. That happens because <code>space</code> will decay to a pointer to function, and function pointers are implicitly convertible to <code>bool</code>. Applying <code>!</code> to the boolean value will always result in <code>false</code> (because the function pointer is never going to be <code>nullptr</code>).</p>

<p>You can reuse the function <code>space</code> by wrapping it in <a href=""http://en.cppreference.com/w/cpp/utility/functional/not1"" rel=""nofollow""><code>std::not1</code></a>, which will negate the result of the predicate passed to it. Unfortunately, it's not as simple as writing <code>std::not1(space)</code>, because <code>not1</code> requires that the predicate define a nested type named <code>argument_type</code>, which your predicate doesn't satisfy. </p>

<p>To convert your function into a predicate usable with <code>not1</code>, you must first wrap it in <a href=""http://en.cppreference.com/w/cpp/utility/functional/ptr_fun"" rel=""nofollow""><code>std::ptr_fun</code></a>. So the line in your <code>split</code> function becomes:</p>

<pre><code>i = find_if(i, str.end(), std::not1(std::ptr_fun(space)));
</code></pre>

<hr>

<p>With C++11, there's no need for the <code>not1</code> and <code>ptr_fun</code> shenanigans, just use a lambda expression:</p>

<pre><code>i = find_if(i, str.end(), [](char c) {return !space(c);});
</code></pre>
",6
21717085,21717059,5,"<p>You're misreading it, <code>1 &lt; 2 ? (void)0 : cout &lt;&lt; ""hi"" &lt;&lt; endl;</code> translates to :</p>

<pre><code>if(1 &lt; 2) {
    (void)0; //do nothing
} else {
    cout &lt;&lt; ""hi"" &lt;&lt; endl;
}
</code></pre>

<p><code>condition ? true-state : false-state;</code> is called a <a href=""http://en.wikipedia.org/wiki/%3F%3a"">ternary operator</a>, it absolutely has nothing to do with <code>&lt;&lt;</code>.</p>
",7
21717107,21717059,3,"<p><a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow""><code>&lt;&lt;</code> has higher precedence than <code>?:</code></a>, so:</p>

<pre><code> 1 &lt; 2 ? (void)0 : cout &lt;&lt; ""hi"" &lt;&lt; endl;
</code></pre>

<p>is actually equivalent to:</p>

<pre><code>(1 &lt; 2) ? (void)0 : (cout &lt;&lt; ""hi"" &lt;&lt; endl);
</code></pre>

<p><em>not</em> to:</p>

<pre><code> ((1 &lt; 2 ? (void)0 : cout)) &lt;&lt; ""hi"" &lt;&lt; endl;
</code></pre>

<p>(And, of course <code>condition ? then_expression : else_expresion</code> won't evaluate <code>else_expression</code> at all if <code>condition</code> is true.)</p>
",0
21717191,21717059,1,"<pre><code>1 &lt; 2 ? (void)0 : cout &lt;&lt; ""hi"" &lt;&lt; endl;
</code></pre>

<p>The other answers have pointed out that the operator precedence gives this a different meaning from what you assumed, so the above is equivalent to:</p>

<pre><code>(1 &lt; 2)
    ? (void)0
    : (cout &lt;&lt; ""hi"" &lt;&lt; endl);
</code></pre>

<p>But it's still illegal.</p>

<p>If the second or third operand of the <code>?:</code> conditional operator is of type <code>void</code>, then the other must also be of type <code>void</code> <em>or</em> must be a throw-expression.</p>

<p>Casting the third operand to <code>void</code> would address that:</p>

<pre><code>1 &lt; 2 ? (void)0 : (void)(cout &lt;&lt; ""hi"" &lt;&lt; endl);
</code></pre>

<p>If you can update your question to show the <em>exact</em> code you're asking about, we can probably explain it better.</p>

<p>It would also be interesting to see the context in which this appears. By itself, it would be much more legible as an <code>if</code> statement.</p>
",0
26445864,26445823,3,"<p>Your error is on the prototype:</p>

<pre><code>Word  Word::operator= (const Word&amp; RHS) const{
//  ^                                   ^^^^^ ???
</code></pre>

<p>An assignment-operator is useless on a constant object, so the last <code>const</code> is bad.<br>
Also, a flaw the compiler cannot diagnose (unless you use it somewhere an lvalue is neccessary), it should return by reference.</p>

<p>Anyway, as a member-by-member-copy is good enough, there is no sense in defining your own assignment-operator at all:<br>
Use the default one.</p>
",0
28179858,28179744,3,"<p>Better way of doing this</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;

class GameBoard {
    std::vector&lt;std::string&gt; players;
    int total_players;
public:
    GameBoard (const std::vector&lt;std::string&gt; &amp; p_players):
        players(p_players),
        total_players(p_players.size())
    {
    }
};
</code></pre>

<p>then </p>

<pre><code>int main()
{
    std::vector&lt;std::string&gt; players{""jill"", ""bill""}; //if C++11 is not available you can use push_back()
    GameBoard b{players};
    return 0;
 }
</code></pre>
",4
22876942,22876893,5,"<p>You can use a <code>std::ofstream</code> in place of <code>std::cout</code>.</p>

<p>Here's your code modified to write the output to a file.</p>

<pre><code>// ostream_iterator example
#include &lt;iostream&gt;     // std::cout
#include &lt;iterator&gt;     // std::ostream_iterator
#include &lt;vector&gt;       // std::vector
#include &lt;algorithm&gt;    // std::copy
#include &lt;fstream&gt;      // std::ofstream

int main () {
  std::vector&lt;int&gt; myvector;
  for (int i=1; i&lt;10; ++i) myvector.push_back(i*10);

  std::ofstream of(""myoutput.txt"");

  std::ostream_iterator&lt;int&gt; out_it (of,"", "");
  std::copy ( myvector.begin(), myvector.end(), out_it );
  return 0;
}
</code></pre>

<p>To copy the output to a <code>vector</code>, use a <code>back_inserter</code>.</p>

<pre><code>std::vector&lt;int&gt; foo;
std::copy (myvector.begin(), myvector.end(), std::back_inserter(foo));
</code></pre>

<p>You can also make direct copy:</p>

<pre><code>std::vector&lt;int&gt; foo = myvector;
</code></pre>
",2
23610959,23610438,1,"<p>One way to do it:</p>

<pre><code>// only allow digits and spaces
string removeNonNumbers(const string&amp; s) {
  stringstream ss;
  for(int i=0; i&lt;s.length(); ++i) {
    if(isdigit(s[i]) || ' ' == s[i])
      ss &lt;&lt; s[i];
  }
  return ss.str();
}

vector&lt;int&gt; splitToInts(const string&amp; s) {
  vector&lt;int&gt; ret;
  stringstream ssin(s);
  while (ssin.good()){
      string tmp;
      ssin &gt;&gt; tmp;
      ret.push_back(atoi(tmp.c_str()));
  }
  return ret;
}
</code></pre>

<p>To use it, do this when reading input in your getline loop:</p>

<pre><code>vector&lt;int&gt; numbers = splitToInts( removeNonNumbers(input) ); 
</code></pre>
",0
23611160,23610438,3,"<pre><code>string process(const string&amp; input)  // Removes all characters except &lt;space&gt; and digits [0-9]
{
    string ret;
    for(int i=0; i&lt;(int)input.size(); i++)
    {
        if(input[i]==' '||(input[i]&gt;='0'&amp;&amp;input[i]&lt;='9'))
            ret+=input[i];
    }
    return ret;
}

int main()
{
    int nrows;
    string input;
    cout&lt;&lt;""Enter number of rows - "";
    cin&gt;&gt;nrows;
    cin.get();  // Take the remaining &lt;Enter&gt;
    vector&lt;vector&lt;int&gt; &gt; matrix(nrows);  // A 2-D vector representing the matrix
    for(int i=0; i&lt;(int)matrix.size(); i++)
    {
        cout&lt;&lt;""Please enter line ""&lt;&lt;i+1&lt;&lt;""/""&lt;&lt;nrows&lt;&lt;"" -: \n"";
        getline(cin,input);
        stringstream ss(process(input));
        int num;
        while(ss&gt;&gt;num)
        {
            matrix[i].push_back(num);
        }
    }

    for(int i=0; i&lt;(int)matrix.size(); i++)  // Display the matrix
    {
        for(int j=0; j&lt;(int)matrix[i].size(); j++)
        {
            cout&lt;&lt;matrix[i][j]&lt;&lt;"" "";
        }
        cout&lt;&lt;""\n"";
    }
}
</code></pre>
",0
23611225,23610438,2,"<p>I would use a 2D vector. Also, ask the user for number of columns:</p>

<pre><code>vector&lt;vector&lt;int&gt;&gt; matrix;

int nrows, ncols;
cout &lt;&lt; ""Enter number of rows:"" &lt;&lt; endl;
cin &gt;&gt; nrows;
cout &lt;&lt; ""Enter number of columns:"" &lt;&lt; endl;
cin &gt;&gt; ncols;
matrix.resize(nrows);
for (int i = 0; i &lt; nrows; i++) {
    cout &lt;&lt; ""Enter line "" &lt;&lt; (i+1) &lt;&lt; ""/"" &lt;&lt; nrows &lt;&lt; endl;
    int tmp;
    while (matrix[i].size() &lt; ncols) {
        while (!(cin &gt;&gt; tmp)) { // Not a number. Clear cin
            cin.clear();
            cin.ignore(1);
        }
        matrix[i].push_back(tmp);
    }
}
</code></pre>
",0
30182010,30181923,1,"<p>The problem lies here:</p>

<pre><code>auto v = currPos == graph.size() ? &amp;graph.back() : &amp;graph.at(currPos);
</code></pre>

<p>You are taking the address of the <code>graph</code> elements, however if (when) your <code>graph</code> vector resizes during the <code>emplace_back</code>, you end up with dangling pointers. A solution is to fix the size of the vector and instead of <code>push_back</code>/<code>emplace_back</code>, to use directly <code>std::vector::operator[]</code>, or to reserve enough memory via <code>std::vector::reserve</code>.</p>

<p>Probably unrelated:</p>

<pre><code>graph.emplace_back(vertice{vertices.at(i)});
</code></pre>

<p>should just be</p>

<pre><code>graph.emplace_back(vertices.at(i));
</code></pre>

<p>as otherwise you are invoking a copy constructor, <a href=""http://en.cppreference.com/w/cpp/container/vector/emplace_back"" rel=""nofollow"">see the definition of <code>std::vector::emplace_back</code></a>.</p>
",1
30182246,30181923,2,"<p>Pointers to the content of a <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a> may be invalidated when you insert new elements, such as in <a href=""http://en.cppreference.com/w/cpp/container/vector/emplace_back"" rel=""nofollow""><code>std::vector::emplace_back</code></a>:</p>

<blockquote>
  <p>If the new size() is greater than capacity() then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</p>
</blockquote>

<p>Consider <a href=""http://en.cppreference.com/w/cpp/container/vector/reserve"" rel=""nofollow""><code>std::vector::reserve</code></a> to reserve a capacity before needing to reallocate the elements or use different container, one which does not invalidate references on insert, perhaps <a href=""http://en.cppreference.com/w/cpp/container/list"" rel=""nofollow""><code>std::list</code></a>.</p>
",0
30170299,30169596,5,"<p>This is called <a href=""http://en.wikipedia.org/wiki/Method_chaining"" rel=""noreferrer"">Method chaining</a> and is commonly seen in <a href=""http://en.wikipedia.org/wiki/Fluent_interface"" rel=""noreferrer"">Fluent Interface</a> pattern. </p>

<p>Each method call (<code>acc.add(5)</code>) returns a reference or pointer upon which successive method calls (<code>.add(7)</code>) can operate on. </p>
",0
30169684,30169596,8,"<p>Your code doesn't compile, but if it did, it would work left to right.  <code>Add</code> returns a reference to an <code>Accumulator</code> (it doesn't have a return value in your code, but it should probably return <code>*this</code>) so after you call</p>

<pre><code>acc.add(5)
</code></pre>

<p>the return value is a reference to <code>acc</code>, which you can call <code>add</code> on again.</p>

<p>Here is a modified example with <code>mult</code> added that shows order of operations:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Accumulator{
private:
    int value;
public:
    Accumulator(int value){ this-&gt;value = value; }
    Accumulator&amp; add(int n){ value += n; return *this; }
    Accumulator&amp; mult(int n){ value *= n; return *this; }
    int get(){ return value; };
};

int main(int argc, char* argv[]){
    Accumulator acc(10);
    acc.add(5).add(6).mult(7);
    cout &lt;&lt; acc.get();
    return 0;
}
</code></pre>

<p>If it was right to left, the result would be <code>81</code>, but it is left to right and the result is <code>147</code>.</p>
",0
23578960,23578935,0,"<p>You can create a struct as shown <a href=""http://gsamaras.wordpress.com/code/structs-c/"" rel=""nofollow noreferrer"">here</a>.</p>

<p>In the example, they have an array of structs. In order to access an element of the struct use the <code>.</code> operator.</p>

<p>In C++11, you can use a <a href=""http://www.cplusplus.com/reference/tuple/"" rel=""nofollow noreferrer""><code>tuple</code></a>, instead of a struct.</p>

<p><a href=""https://stackoverflow.com/questions/5852261/c-tuple-vs-struct"">Tuple vs Struct - Stackoverflow</a>.</p>

<p>The idea is that the first can provide more generic operations, while the second has far better readability and you do not have to remember the order of your data members, IMHO.</p>

<p>[EDIT]</p>

<p>AS R. Hasan states, the question is a duplicate of <a href=""https://stackoverflow.com/questions/23557071/how-to-read-data-from-a-line-in-a-txt-file-into-a-structure-in-c"">this</a> question.</p>
",2
23579184,23578935,0,"<p>I am not sure that's what you are looking for, but consider this (and don't forget to include vector)</p>

<p>First, we define custom structure</p>

<pre><code>struct Game //your structure
{
    int id;
    std::string title;
    int year;
    std::string developer;
    std::string publisher;
};
</code></pre>

<p>Now we overload operator>> (it's similar to using cin >> someVariable). Fstream already has methods to write in variables of standard types. </p>

<pre><code>bool operator&gt;&gt;(std::fstream&amp; fs, Game&amp; g) 
{
    if (fs &gt;&gt; g.id &gt;&gt; g.title &gt;&gt; g.year &gt;&gt; g.developer &gt;&gt; g.publisher)
        return true;
    return false;
}
/*
fs &gt;&gt; g.id &gt;&gt; g.title equals (fs.operator&gt;&gt;(g.id)).operator&gt;&gt;(g.title) ... 
*/
</code></pre>

<p>Standard operator>> returns reference to fstream, so we are able to write everything in just 1 line of code. If writing does fail (e.g. end of file reached) we return false.</p>

<pre><code>std::vector&lt;Game&gt; vec; 
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow"">STL vector</a>
- standard container, that contains your Game structs</p>

<pre><code>if (fout.is_open())
{
    for ( ; ; )
    {
        Game g; //creating instantiation of your struct Game
        if (fout &gt;&gt; g) //reading from your file
            vec.push_back(g); //1 of STL vector methods, check link to cppreference higher
        else //if reading fails, we break our infinite loop
            break;
    }
}
for (auto x : vec) //going through every element of our vector.
    cout &lt;&lt; x.id &lt;&lt; "" ""; //and printing first variable of your structure
</code></pre>
",3
23557118,23557071,2,"<p><strong>Solution 1</strong></p>

<ol>
<li>Read file line by line (you can use getline)</li>
<li>Split the string using <code>space</code> character as delimiter <a href=""https://stackoverflow.com/questions/236129/how-to-split-a-string-in-c"">here</a> is an example</li>
<li>Convert the split-ed tokens as required (like convert first token to int ). <a href=""http://www.cplusplus.com/forum/articles/9645/"" rel=""nofollow noreferrer"">here is an example</a> </li>
</ol>

<p><strong>Solution 2</strong></p>

<p>If you have same number of tokens in each line (here 5), then each can be read individually</p>

<pre><code>std::ifstream file(fileName);
struct Game game;
file &gt;&gt; game.id &gt;&gt; game.year&gt;&gt;game.title&gt;&gt;game.publisher&gt;&gt;game.developer;
</code></pre>
",0
23830717,23830292,7,"<p>No macro needed, you can simply use preprocessor conditionals inside the function body:</p>

<pre><code>template&lt;class to, class from&gt;
inline to debug_checked_static_cast(const from&amp; from_value) {
  to to_value{static_cast&lt;to&gt;(from_value)};
#if _DEBUG
  from round_trip{to_value};
  if (round_trip != from_value)
    throw std::runtime_error(""Naughty cast"");
#endif
  return to_value;
}
</code></pre>

<p>and</p>

<pre><code>template&lt;class to, class from&gt;
inline to debug_checked_coercion(const from&amp; from_value) {
  to to_value{from_value};
#if _DEBUG
  from round_trip{to_value};
  if (round_trip != from_value)
    throw std::runtime_error(""Naughty cast"");
#endif
  return to_value;
}
</code></pre>

<p>Then use</p>

<pre><code>long l = debug_checked_coercion&lt;long&gt;(ll);
</code></pre>

<p>Notice that I've minimized the use of <code>static_cast</code>, since it isn't needed for narrowing numeric conversions.</p>
",2
23831942,23830292,0,"<p>I would tend to agree with dlf in that if its important enough to throw an exception in Debug, then you should probably be doing it in Release also.</p>

<p>If I had the choice of efficient code that sometimes crashes, and slightly less efficient code that doesn't I know what I would choose.</p>

<p>Paul.</p>
",1
26169395,26169089,0,"<p>You probably want to use the STL, and include the std::list class.  You should look at the methods for that class.  I will show you how using the std::vector class.</p>

<p>Suppose you want to place the following into the list,</p>

<pre><code>struct roll_t {
    int dice1; //value of dice1
    int dice2; //value of dice2
    int total; //total of dice1+dice2
    roll_t() dice1(0), dice2(0), total(0) { }
    roll_t(int d1, int d2) : dice1(d1), dice2(d2), total(d1+d2) { };
};
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/list/list/"" rel=""nofollow noreferrer"">Here is a C++ list reference</a></p>

<p><a href=""http://www.yolinux.com/TUTORIALS/LinuxTutorialC++STL.html"" rel=""nofollow noreferrer"">Here is an example with explanation</a></p>

<p>But, let me also add an example here,</p>

<pre><code>#include &lt;vector&gt;

using namespace std;

int main(int argc, char* argv[])
{
    vector&lt;roll_t&gt; dv;
    roll_t rolls[13+1];

    //suppose you have initialized totals[] here...
    for( ndx=1; ndx&lt;=12; ++ndx ) {
        rolls[ndx] = roll_t.new(random(6),random(6));
    }

    //move totals to vector (convert to list left as exercise for poster)
    int ndx;
    for( ndx=1; ndx&lt;=12; ++ndx ) {
        dv.push_back(rolls[ndx]);
    }

    //traverse vector (convert to list, you will need iterator)
    cout &lt;&lt; ""Loop by index:"" &lt;&lt; endl;
    for(ndx=0; ndx &lt; dv.size(); dv++)
    {
        cout &lt;&lt; ""[""&lt;&lt;ndx&lt;&lt;""]""
             &lt;&lt; dv[ndx].dice1 &lt;&lt;','&lt;&lt; dv[ndx].dice2 &lt;&lt;','&lt;&lt; dv[ndx].total &lt;&lt; endl;
    }

}
</code></pre>

<p>The above uses the STL, but maybe this question is for a class?  And you need to roll your own linked list?  I have linked to some stackoverflow answers,</p>

<p>I built one of those,</p>

<p><a href=""https://stackoverflow.com/questions/19144891/trying-to-make-linkedlist-in-c/19153555#19153555"">Trying to make linkedlist in C</a></p>

<p>Here is a description of single-linked list,</p>

<p><a href=""https://stackoverflow.com/questions/19505891/singly-list-insert-to-end-of-list/19506993#19506993"">Singly-list insert to end of list</a></p>

<p>Here is a basic C++ dice game,</p>

<p><a href=""https://stackoverflow.com/questions/19224875/basic-c-dice-game/19230688#19230688"">Basic C++ Dice game</a></p>

<p>Here is an explanation of how to sort a linked list by moving pointers,</p>

<p><a href=""https://stackoverflow.com/questions/19577335/trying-to-sort-a-linked-list-only-by-manipulating-pointers/19578259#19578259"">Trying to Sort a Linked List only by Manipulating Pointers</a></p>

<p>Those should help.</p>
",1
24384086,24383965,1,"<p><strong>If the buffer length is constant</strong></p>

<p>Is thread-safety an issue? If so then go for putting it on the stack as a non-static local variable.</p>

<p>If thread safety is not an issue (and you are not using this function recursively) then I would recommend a static local variable. The static local will not pollute the class with a useless field and not be accessible outside of the scope you intended it for, plus you only have to allocate it once.</p>

<p><strong>If the buffer length is NOT constant</strong></p>

<p>See Frerich Raabe's answer. Again note that using it statically has some issues if you are using recursion or expect that your function might be used by more than one thread at a time.</p>
",0
24384150,24383965,2,"<p>There's a third option, which is to use <code>std::vector</code> with static storage:</p>

<pre><code>static std::vector&lt;double&gt; buf( len );
</code></pre>

<p>This doesn't require <code>len</code> to be a compile time constant and IIRC C++11 guarantees that the initialization of <code>buf</code> is thread-safe (in C++03 it wasn't guaranteed though). Of course, actually <em>using</em> the buffer won't be thread-safe: you'll either need some sort of synchronization mechanism (e.g. a mutex) or allocate the vector using thread-local storage (e.g. on the stack or via some TLS implementation).</p>
",0
24384233,24383965,4,"<p>What options you have depends on a few questions:</p>

<ol>
<li><p>Is the function (potentially indirectly) recursive?</p></li>
<li><p>Is <code>len</code> known at compile time?</p></li>
<li><p>Can the function be called by multiple threads concurrently? On the same object, on different objects, not at all?</p></li>
</ol>

<p>If the function is not recursive, you can use a <code>static</code> local variable. If <code>len</code> is a compile-time constant, <code>static double buf[len];</code> will do. For a run-time value of <code>len</code>, use <code>static std::vector&lt;double&gt; buf(len);</code> instead. If concurrent calls are possible, add <code>thread_local</code> to the declaration.</p>

<p>For a recursive function, you have to use a non-static local variable. If <code>len</code> is known at compile time, this will certainly be very fast (it's just stack manipulation). If it's a runtime value, you'll either have to accept dynamic allocation on each call (e.g. <code>std::vector&lt;double&gt; buf(len);</code>), or create a memory pool of some sort.</p>
",1
24384278,24383965,1,"<p>If you call this function from multiple threads / recurisvely / any other way then a singleton and these calls need an own buffer use a <code>vector</code> local variable:</p>

<pre><code>std::vector&lt;double&gt; vec(len);
</code></pre>

<p>Your local variable solution (<code>double buf[len];</code>) will cause a stack overflow if <code>len</code> is large enough. (And if <code>len</code> is not a compile-time constant, it is not even allowed by the standard, it is only a <code>g++</code> extension.)</p>

<p>If you need one buffer per object, use an <code>std::vector</code> member variable (This is effectively the same as your second solution but more C++ish and deallocates automatically.)</p>

<pre><code>struct X {
    std::vector&lt;double&gt; vec;
    X(int len) : vec(len) {}
}
</code></pre>

<p>If you are sure that your program will require one single instance of your buffer, use the static version, as int @Frerich's solution.</p>

<pre><code>static std::vector&lt;double&gt; buf( len );
</code></pre>
",0
23613156,23612986,2,"<p>If you only do <code>g++ main.cpp -o out.o</code> , you will only be building <code> main.cpp </code>. To include the other .cpp file, do <code> g++ main.cpp inoutfich.cpp -o out.o </code>.</p>

<p>Peace.</p>
",2
29165936,29165288,0,"<p>Looks as if you should decrement count as part of the delete operation.</p>

<pre><code>    delete[] sections;
    count--;                    // Decrease size
    sections = tempArray;
}
</code></pre>

<p>If you don't then you will read beyond array limits and things will fail (crash).</p>
",1
29165444,29165288,2,"<p>You clearly want to use dynamic array, thus go on and use one - <code>std::vector</code> </p>

<pre><code>std::vector&lt;int&gt; vec = {1,2,3,4,5,6,7};
vec.erase(vec.begin() + n); //removes n-th element
</code></pre>

<p>Otherwise you are recreating functionality that is already created and supplied in standard library.</p>

<p>Of-course your use-case may be very specific and you really NEED to use your plain old array, but then hey - do some debugging with breakpoints and such.</p>
",0
24103245,24103213,1,"<p>The error message in the category ""undefined reference to..."" generally means that the function, compiled or otherwise was not <em>linked</em> into your executable.</p>

<p>First, make sure that the object file for swimmingPool.cpp (swimmingPool.o or or windows, swimmingPool.obj) was linked into your program.</p>

<p>If you've confirmed that, then it's possible that your make tool forgot to recompile swimmingPool.cpp after you added timeNeeded, and therefor that object file is out of date. You should recompile swimmingPool.cpp if that's the case.</p>

<p>The specific commands necessary to do this depends on your toolchain.</p>

<p>Also, your functions are not ""const-correct"" and you should look that up soon as you learn.</p>
",2
24103257,24103213,1,"<p>Resolve multiple definitions of the constructor (one in header and other in cpp file)</p>

<pre><code>swimmingPool(int a,int b, int c, int d,int e){} // **this makes it a definition and not just declaration**

swimmingPool::swimmingPool(int a,int b, int c, int d,int e) //IT has five         parameters for length/breadth/height/water_initially/rate_out.Rate to be taken input from         user.
    {
            length = a;
            width = b;
            depth = c;
            rate_out = d;
            water_initially = e;
    }
</code></pre>

<p>Change <code>swimmingPool(int a,int b, int c, int d,int e){}</code> to <code>swimmingPool(int a,int b, int c, int d,int e);</code></p>
",3
22430301,22429610,2,"<p>The Intel CPUs have the ability to execute 16, 32 and 64-bit binaries. The question is: which were you testing?</p>

<p>Both Windows and Linux are available in 32 and 64-bit versions. The difference is that 32-bit cannot execute 64-bit binaries, whereas 64-bit can.</p>

<p>If (and only if) you have a 64-bit OS and a 64-bit-capable development system and you write a program and explicitly tell it to generate a 64-bit program then when you run it you will see 8 byte pointers.</p>
",0
22430699,22429610,0,"<p>You mentioned in the comments you're using Visual Studio.  To setup this compiler to build 64bit solutions the following will work for Visual Studio 2010, 2012, and 2013.  The steps below were taken from the <a href=""http://msdn.microsoft.com/en-us/library/9yb4317s%28v=vs.100%29.aspx"" rel=""nofollow"">Microsoft MSDN site</a>.</p>

<ol>
<li>Right click on your solution in the solution explorer.</li>
<li>Choose properties.</li>
<li>Click the <kbd>Configuration Manager...</kbd> in the upper right corner.</li>
<li>Click the drop down arrow under <code>Active solution configuration</code></li>
<li>Choose <code>New</code> and enter a name for this configuration.  i.e. Debug64 or Release64</li>
<li>Click the drop down arrow under <code>Copy settings from</code> and Choose Win32. Copying from Win32 will automatically update multiple settings to 64bit.</li>
<li>Click <kbd>Ok</kbd>.</li>
<li>Under <code>Active solution platform</code> choose <code>New</code></li>
<li>Under the platform should be an option for x64.  Select this and click <kbd>Ok</kbd>.</li>
<li>Click <kbd>Close</kbd>.</li>
</ol>

<p>You should now be building for the x64 platform and your pointers will be size 8.</p>

<p>To change back to 32bit, open the configuration manager again and choose the correct <code>Configuration</code> and <code>Platform</code>.</p>
",0
28441088,28440955,5,"<p>There are two problems, one that's not the cause of this particular problem.</p>

<p>First, using <code>while (!instream.eof()</code>will cause you to read one time too many, because <code>eof()</code> doesn't become true until after the first attempted read <em>after</em> the last successful one.</p>

<p>But the immediate cause is that you're incrementing <code>position</code> between the reading and the printing, so you're printing a value that hasn't been set yet.</p>

<p>Try this:</p>

<pre><code>while (position &lt; array_size &amp;&amp; in_stream &gt;&gt; numbers[position])
{
    cout &lt;&lt; position &lt;&lt; "" = ""
         &lt;&lt; numbers[position] &lt;&lt; endl;
    position++;
}
</code></pre>
",0
28441090,28440955,1,"<p>You are reading parts of your array that haven't been filled yet, so you should be getting junk, try this:</p>

<pre><code>    while(! in_stream.eof() &amp;&amp; position &lt; array_size)
    {
        in_stream &gt;&gt; numbers[position];
        cout &lt;&lt; position &lt;&lt; "" = ""
             &lt;&lt; numbers[position] &lt;&lt; endl;
        position++;
    }
</code></pre>
",0
28441235,28440955,1,"<p>as per the answers above , my issue was that i was incrementing my loop variable before printing, so it tried to print the next value in the array.</p>

<p>Thank you all for helping   </p>

<pre><code>while(! in_stream.eof() &amp;&amp; position &lt; array_size)
{
    in_stream &gt;&gt; numbers[position];
    cout &lt;&lt; position &lt;&lt; "" = ""
         &lt;&lt; numbers[position] &lt;&lt; endl;
    position++;
}
</code></pre>
",0
25530329,25529646,2,"<p>You should try:</p>

<pre><code>// for sorting first by Y descending and later by X ascending
bool compareYX(const Point2f&amp; p1, const Point2f&amp; p2) {
    return std::tie(p2.y, p1.x) &lt; std::tie(p1.y, p2.x);
}
</code></pre>

<p>In this case you would be sorting by <code>Y</code> first in descending order, see that <code>p2.y</code> is at the left and <code>p1.y</code> at the right and later by <code>X</code> in ascending orders</p>

<p>Input Points:</p>

<pre><code>{ {-2, 1}, {1,1}, {-1,-5}, {4,-2}, {5, 5} }
</code></pre>

<p>Output Order:</p>

<pre><code>(5,5)
(-2,1)
(1,1)
(4,-2)
(-1,-5)
</code></pre>
",0
29448911,29448699,1,"<p>(Moving from comment to answer)</p>

<p>It appears you intended to inherit virtually from <code>shape</code>, and then provide your own <code>draw</code> function in <code>shapes</code></p>

<p>Inherit virtually like so:</p>

<pre><code>class circle : public virtual shape //and same for class square
</code></pre>

<p>Then in <code>shapes</code>:</p>

<pre><code>class shapes : public  circle, public  square
{
public:
    shapes()
    {
        cout &lt;&lt; ""shapes created"" &lt;&lt; endl;
    }

    virtual void draw() //'virtual' is optional here
    {
        circle::draw();
        square::draw();
    }
};
</code></pre>

<p><a href=""http://ideone.com/lkIXIF"" rel=""nofollow"">Live Demo</a></p>

<p><strong>Edit</strong></p>

<p>Using virtual inheritance in your case is not strictly necessary per se, because your base is abstract (only pure virtual methods). However, if your use case is that the base class implements methods, then you will definitely want to use virtual inheritance. (Thanks @vsoftco) </p>

<p>This is because virtual inheritance guarantees that only one base class instance will be inherited into <code>shapes</code>, whereas in C++ by default in each derived class gets its own instance of a base, and so <code>shapes</code> would actually inherit TWO instances of <code>shape</code>, one through <code>circle</code> and one through <code>square</code>. At that point, calling any base class function from a <code>shapes</code> object becomes ambiguous because the compiler wouldn't be certain which instance you meant to call it from.</p>
",5
21781542,21776996,1,"<p>You need to link against libusb. You should add <code>-lusb</code> to the gcc call. You might need to add <code>-Lpath_to_libusb</code> before <code>-lusb</code>.</p>

<p>Maybe you better should start with a given sample program like <a href=""https://github.com/libusb/libusb/tree/master/examples"" rel=""nofollow"">that one</a>?</p>
",1
22421435,22421385,0,"<p>Frankly the part of the question you do not understand is not programming related and hence you need to go a bit into detail with regard to astrology for it. </p>

<p>Check these links out and see if you can then understand the question.</p>

<p><a href=""http://en.wikipedia.org/wiki/Cusp_%28astrology%29"" rel=""nofollow"">http://en.wikipedia.org/wiki/Cusp_%28astrology%29</a></p>

<p>It basically adds a simple condition that if the birth date is between two sun signs it lies on a cusp and you need to resolve that condition as well. </p>

<p>That done. I feel you need to code it yourself. That way you will learn. And also try to Google stuff before posting on SO. It is a great way to learn.</p>

<p>Hope this helped.</p>
",1
28431235,28430740,0,"<p>Construction always starts from the base class. If there are multiple base classes then, it starts from the left most base. (side note: If there is a virtual inheritance then it's given higher preference).</p>

<p>If you have not called your base class's constructor explicitly then default constructor of your base class will be called. </p>

<pre><code>DemoApplication::DemoApplication(myParam1)
</code></pre>

<p>If there is no default constructor in your base class, then it will give you error 'No appropriate default constructor available'.</p>
",0
22880090,22879664,1,"<p>You should <strong>not</strong> point to a member variable in another class. This either breaks encapsulation (making the <code>private</code> of the variable obsolete, a <em>lie</em> to the reader of your code if you want to put it radical) or means that the variable was not <code>private</code> to begin with, i.e. that there was no encapsulation to begin with.</p>

<p>Chances are that you don't need pointers at all. C++ is not Java. <strong>In Java, you deal with pointers much more than in C++.</strong> Java only calls them ""references"", except in the class name of <code>NullPointerException</code>, which gives the truth away. Java references are also slightly less powerful and dangerous than C++ pointers, but principally they are the same feature.</p>

<p>In C++, references and pointers are different things. That's very important to understand when you are new to C++ and are coming from Java.</p>

<p>Let's look at this piece of code:</p>

<pre><code>bool collision = &amp;EnemyFlower::returncollision;
</code></pre>

<p>This seems like an attempt at setting up a <a href=""http://www.parashift.com/c++-faq/pointers-to-members.html"" rel=""nofollow"">member function pointer</a>. I would not use function pointers here, they probably complicate issues.</p>

<p>A better design would be to move the entire collision-detection part outside of the classes. Colliding is neither a property of a player nor of a flower. Perhaps having coordinates or a position is a property of both. This would result in a function as follows:</p>

<pre><code>bool FindCollision(DemoBObject const &amp;player, Flower const &amp;flower)
{
    // calculate collision using player.GetX(), player.GetY(), flower.GetCoords()
    // or something like that
    //
    // ...

    return collision;
}
</code></pre>

<p>This <code>FindCollision</code> function has two interesting aspects. First, it does not take pointers but references (not possible in Java). Second, it does not need to be in a class. In C++, you often make such functions free-standing. Again, this is not possible in Java, where you often have to artifically invent a class and give it a single static method.</p>

<p>If you insist that the collision be a state inside of a flower (as I said, not a good idea IMO), then do as follows: Make the collision flag a private bool member variable of <code>Flower</code>, and give the class a public member function returning a <strong>copy</strong> of that variable:</p>

<p>Flower.h:</p>

<pre><code>class Flower
{
private:
    bool m_collision;
    // ...

public:
    bool GetCollision() const;
    // ...
};
</code></pre>

<p>Flower.cpp:</p>

<pre><code>bool Flower::GetCollision() const
{
    return m_collision;
}
</code></pre>

<p>Notice that I used another feature not available in Java: I made the member function <code>const</code>. In C++, when a member function doesn't change an object, you make it <code>const</code> (a little simplified, but it's a good rule to start with). Also note that this still doesn't need a pointer at all.</p>

<p>You can then call this member function from the player class. Of course, this means that the player class needs a reference to an object (again, not a pointer!) of type <code>Flower</code>.</p>

<p>Now if your member variable is <code>static</code>, then I'm afraid that the whole class design must be redone from scratch. It would not work like that in Java, either, because it would mean that there is only <em>one</em> collision state shared by <em>all</em> flowers. That certainly doesn't make sense.</p>
",12
26806181,26806100,2,"<p>Presumably, the compiler told you what's wrong, but you forgot to provide that information. My compiler says</p>

<pre><code>¡®strlen¡¯ was not declared in this scope
</code></pre>

<p>because you forgot to include the header <code>&lt;cstring&gt;</code> that defines it.</p>

<p>Then it says</p>

<pre><code>ISO C++ forbids comparison between pointer and integer
</code></pre>

<p>That's a bit trickier to interpret; it refers to this</p>

<pre><code>if (name[i]=="" "")
</code></pre>

<p>where you try to compare a character (which converts to an integer) with a string (which converts to a pointer). Instead, compare with another character:</p>

<pre><code>if (name[i]==' ')
             ^ ^
</code></pre>

<p>Once it compiles, get rid of <code>gets(name);</code>. It does the same thing as <code>cin &gt;&gt; name;</code>, but is (perhaps) even more dangerous. Then consider using <code>std::string</code> rather than a C-style <code>char</code> array; that way, your program won't explode if you enter more than 100 characters.</p>
",0
26806186,26806100,3,"<p>Since you declared:</p>

<pre><code>   char name[100];
</code></pre>

<p>then <code>name[i]</code> (if <code>i</code> is a valid index) is a <code>char</code>. But <code>"" ""</code> is <em>not</em> a character literal, but a string; you should code </p>

<pre><code>   if (name[j]==' ')
</code></pre>

<p>BTW, you should read more about C++ (and its <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow"">std::string</a>) and consider declaring</p>

<pre><code> std::string name;
</code></pre>

<p>and adapting the rest of your program to make that work. BTW, compile with all warnings &amp; debug info (<code>g++ -Wall -Wextra -g</code>) and learn how to use the debugger (<code>gdb</code>)</p>
",0
26806233,26806100,1,"<p>Apart from compiler errors you have done one more mistake :- </p>

<pre><code>   gets(name);
   char a,b,c;
   cin&gt;&gt;name;
</code></pre>

<p>second cin would overide first value you have entered using gets.</p>
",0
26191594,26191575,1,"<p>You are attempting to supply an implementation of a constructor that you have not declared as part of the class declaration.</p>

<p>You need to add this line to the <code>public:</code> section of your class:</p>

<pre><code>Parameters (int argc, char** argv);
</code></pre>

<p>This is the missing prototype about which the compiler is complaining. Adding this prototype will <em>declare</em> in the <code>main.h</code> the constructor that you are <em>defining</em> in your <code>main.cpp</code>.</p>
",1
26191596,26191575,1,"<p>You have to add a declaration of the constructor into <code>Parameters</code>:</p>

<pre><code>class Parameters
{
    private:
        // ...
    public:
        // ...
        Parameters(int argc, char** argv);
};
</code></pre>

<p>Otherwise, the compiler does not know that the constructor exists in other translation units where only the header is included. Your constructor must be declared <code>public</code> section, so that it can be called in <code>main</code>.</p>
",0
26227631,26227387,0,"<p>If you change the loop condition to ""i &lt;= back"" then it won't cause segmentation fault. It is because when size-1 is even , i &amp; back will never become equal. Thus loop will keep on going without breaking &amp; attempt to access string member outside the string.</p>
",0
26227404,26227387,3,"<p>Your index only needs to reach half of the length, and that way we ensure that the swap between a pair only happens once:</p>

<pre><code>for (int i = 0; i &lt; str.size() / 2 ; i ++)
{
    char c = str[str.size() - 1 - i];
    str[str.size() - 1 - i] = str[i];
    str[i] = c;
</code></pre>

<p>}</p>
",0
26229069,26227387,0,"<p>Just change your condition from <code>!=</code> to <code>&lt;=</code> and it will be solved.</p>
",0
25454082,25453983,4,"<p><code>string::find()</code> has an overload that specifies the position to start the search. So simply start a second search, starting at the end of <code>&lt;ID&gt;</code>, to look for <code>&lt;/ID&gt;</code>. You are after what comes in between the two. Pretty simple really.</p>

<p>However, as suggested elsewhere, there are a lot of XML parsers out there. Using a full XML parser would be recommended if the input file could have some variations.</p>
",0
29899636,29899604,2,"<p>It means that everything outside lambda scope will be catch by reference. In that case, <code>generator</code> and <code>list</code>.</p>
",0
29899661,29899604,1,"<p>The <code>[&amp;]</code> is a part of the lambda expression that means it will be able to access all the enclosing variables by reference. Example:</p>

<pre><code>int b = 0;
auto my_lambda = [&amp;](int a) { b = a; };
my_lambda(1);
std::cout &lt;&lt; b &lt;&lt; '\n'; // prints 1
</code></pre>
",0
29899690,29899604,0,"<pre><code>[&amp;]
</code></pre>

<p>means that all automatic variables will be captured into the scope of the lambda expressing. Essentially, the lambda expression will be able to use the variables that the program had access to at the time of invocation.</p>
",0
25464104,25464053,3,"<p>In your for range, you modify the container inside the loop, which involves UB.</p>

<p>creating a copy of the set should fix your issue:</p>

<pre><code>for(const auto &amp;workerPtr: std::set&lt;WorkerPtr&gt;(workers)) // create a copy of the set
{
    workerPtr-&gt;start(
        [this, workerPtr] ()
        {
            workers.erase(workerPtr);
            if(workers.size() == 0)
            {
                std::cout &lt;&lt; ""All workers done!"" &lt;&lt; std::endl;
            }
        }
    );
}
</code></pre>

<p><strong>Edit:</strong>
As noted by Dietmar K¨¹hl, if your method <code>start</code> launches a new thread, then you will have data race on the <code>set</code>.</p>
",0
25464136,25464053,3,"<p>According to 6.5.4 [stmt.ranged] the range-based for-loop behaves like this piece of code:</p>

<pre><code>{
    auto &amp;&amp; __range = workers;
    for (auto __begin = workers.begin(), __end = workers.end(); __begin != __end; ++__begin ) {
        const auto&amp; = *__begin;
        &lt;body-of-the loop&gt;
    }
 }
</code></pre>

<p>Since you happily blow away the objects currently being referred to, you actually invalidate the <code>__begin</code> iterator in each iteration of the loop: for associative containers all iterators and pointers/references to objects being erased are invalidated. Any invalidated iterators is a booby-trap waiting to be disarmed (by assignment or destruction) which will blow up in undefined behavior when used in any way other than disarming it.</p>

<p>Personally, I would fix the issue by iterating over the set and erasing its element in a more effective way anyway: your approach requires searching the elements in each iteration which is unnecessary cost. You can just keep an iterator:</p>

<pre><code>for (auto it = works.begin(), end = works.end(); it != end; ) {
    (*it)-&gt;start([this, it]() {
         workers.erase(it++);
         if (workers.empty()) {
             std::cout &lt;&lt; ""All workers done!\n"";
         }
     });
}
</code></pre>

<p>Of course, you should also use <code>container.empty()</code> to determine if the container is empty. ... and just don't use <a href=""http://kuhllib.com/2012/01/14/stop-excessive-use-of-stdendl/"" rel=""nofollow""><code>std::endl</code></a> as it doesn't do anybody any good. Use <code>std::flush</code> if you really mean to flush the stream.</p>

<p>Of course, if <code>start()</code> in the posted code is actually a simplification and actually starts a thread, the problem becomes a different one! In this case, the <code>erase()</code> statement isn't executed when the function object is being created to start the thread. The original issue, i.e., invaliding the iterators of the range-based <code>for</code> would only happen if the started thread executes and <code>erase()</code>d the object before the starting thread moved on!</p>

<p>Instead, there is an obvious data race: there are multiple thread <code>erase()</code>ing objects from <code>this-&gt;workers</code> without any synchronization at all! You can address the problem by guarding the access to the shared <code>std::set&lt;WorkerPtr&gt;</code> using a suitable mutex. For example, I think this code resolves the problem:</p>

<pre><code>struct Controler
{
    void start()
    {
        for(int i = 0; i &lt; 5; ++i)
        {
            auto workerPtr = boost::make_shared&lt;Worker&gt;();
            this-&gt;workers.insert(workerPtr);
        }

        std::lock_guard&lt;std::mutex&gt; kerberos(this-&gt;mutex);
        for(const auto &amp;workerPtr: this-&gt;workers)
        {
            workerPtr-&gt;start(
                [this, workerPtr] ()
                {
                    std::lock_guard&lt;std::mutex&gt; kerberos(this-&gt;mutex);
                    this-&gt;workers.erase(workerPtr);
                    if(this-&gt;workers.empty()) {
                        std::cout &lt;&lt; ""All workers done!\n"";
                    }
                }
            );
        }
    }

    std::set&lt;WorkerPtr&gt; workers;
    std::mutex          mutex;
};
</code></pre>

<p>Of course, the problem analysis and resolution assumes that <code>workerPtr-&gt;start(...)</code> actually starts a thread to do the work! If the work is executed on the same thread the iterators from the range-based <code>for</code> are, indeed, invalidated and adding a mutex as is done in the code above would cause a dead-lock.</p>
",4
27532034,27531885,0,"<p>Yes you can divide this into methods for better maintainence. What I would do is:-</p>

<pre><code>bool isProcessableCategory(std::string category);
</code></pre>

<p>This would return true for all category for which you want processing enabled. And false for all other categories.</p>

<pre><code>bool isProcessbleSubCategory(std::string category, std::string subCategory);
</code></pre>

<p>would then check for specifec sub-category.</p>

<p>This way you would localize all the changes to these functions only. </p>
",0
27559987,27531885,0,"<p>After digging around - here is my final code that works well, and it much more maintainable. 
If you have any more suggestions or improvements, let me know</p>

<p>Thanks for the comments and suggestions above - they got me thinking in different directions which ultimately led me to this solution.</p>

<p>-mleega</p>

<pre><code>#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using std::find;

...snip...

      std::string strCategoryName;
      std::string strSubCategoryName;

      std::map&lt;std::string, std::vector&lt;std::string&gt;&gt; mCategoryMap;

      mCategoryMap[""Category-A""];
      mCategoryMap[""Category-A""].push_back(""A1"");
      mCategoryMap[""Category-A""].push_back(""A2"");

      mCategoryMap[""Category-B""];
      mCategoryMap[""Category-B""].push_back(""B1"");
      mCategoryMap[""Category-B""].push_back(""B2"");
      mCategoryMap[""Category-B""].push_back(""B3"");

      mCategoryMap[""Category-C""];
      mCategoryMap[""Category-C""].push_back(""C1"");
      mCategoryMap[""Category-C""].push_back(""C2"");
      mCategoryMap[""Category-C""].push_back(""C3"");

      if ( mCategoryMap.find( strCategoryName ) != mCategoryMap.end() )  // If the current category is contained in mCategoryMap then Proceed
      {
           if ( std::find(mCategoryMap[strCategoryName].begin(),mCategoryMap[strCategoryName].end(), strSubCategory) == mCategoryMap[strCategoryName].end() )     // If the current Sub-Category is NOT contained in the map then Proceed
           {
               // EXECUTE CODE BLOCK
           }
      }
</code></pre>
",0
31261691,31261224,0,"<p>What you described can occur in case when within main you declared only one function with the parameter of type <code>int</code>. For example</p>

<pre><code>#include&lt;iostream.h&gt;
#include&lt;conio.h&gt;

void area(int);
void area(float);

int main()
{
  int a;
  float b;

  void area(int);

  clrscr();

  cout&lt;&lt;""enter the length or breadth of square"";
  cin&gt;&gt;a;
  area(a);
  cout&lt;&lt;""enter the radius of the circle"";
  cin&gt;&gt;b;
  area(b);
  getch();
}

void area(int x)
{
  cout&lt;&lt;""area of square ""&lt;&lt;x*x;
}
void area(float x)
{
  cout&lt;&lt;""\narea of circle ""&lt;&lt;3.14*x*x;
}
</code></pre>

<p>In  this case only the function with the parameter of type <code>int</code> will be called because the local function declaration hides the function declarations in the global namespace.</p>

<p>Otherwise if the both functions are declared in main and only the function with the parameter of type int is called then the compiler has a bug.</p>

<p>Take into account that function main shall have return type <code>int</code> though some compilers allows to use type void. But such declarations of main is not C++ compliant.</p>
",3
29455636,29455348,0,"<p>I have tested the code you have written. The correct way is:</p>

<pre><code>void graph::show()
{
    node *current = first;
    do 
    {
        std::cout &lt;&lt; ""///////////////\n"" &lt;&lt; current-&gt;n;
        current = current-&gt;next;
    }while (current != NULL);
}
</code></pre>

<p>if the while condition is like    </p>

<pre><code>current-&gt;next != NULL
</code></pre>

<p>then it will dump provided only one element present in the list or in some other scenario as well</p>
",1
34260719,34260454,0,"<p>Regarding the use of heap, new and pointer, see my comment in your question.</p>

<p>Regarding the issue object was destroyed, the <code>vector</code> maintains an internal buffer to store object. When you <code>push_back</code> new object to the <code>vector</code>, if its internal buffer is full, it will (the stuff which will be executed when exception occurs won't be mentioned here.):</p>

<ol>
<li>allocate new internal buffer which is big enough to store its new data.</li>
<li>move data from old internal buffer to new internal buffer.</li>
<li>destroy old buffer.</li>
</ol>

<p>Hence, your object will be destroyed and copied to new location in this case, hence copy constructor will make it clearer to you.</p>

<p>P/S: AFAIK, some compilers move its data by <code>memmove</code> or <code>std::move</code></p>
",0
34260618,34260454,2,"<p>First of all, it is a bad practice to allocate an object in heap without using smart pointers and forgetting to <code>delete</code> it. Especially, when you are creating it just to make a copy of it.</p>

<p><code>list.push_back(*a);</code> creates a copy of <code>*a</code> in vector. To create an item in vector without copying another item, you can do <code>list.emplace_back(/*constructor parameters*/);</code>, which is available from c++11. (see <a href=""http://en.cppreference.com/w/cpp/container/vector/emplace_back"" rel=""nofollow"">http://en.cppreference.com/w/cpp/container/vector/emplace_back</a>)</p>

<p>So, to make the result behavior match your expectations, you should go</p>

<pre><code>    vector &lt;Obje&gt; vec;
    vec.emplace_back(59565);
    vec.emplace_back(15485);

    for(const auto &amp; item : vec)
    {
        item.getId();
    }
</code></pre>

<p>By the way, it is also a quite bad practice to call a vector as a list, as a list is a different container type and reading such code may be confusing a bit. I guess, I am starting being annoying, but it is better to call method <code>getId</code> as <code>showId</code> as now it returns nothing.</p>
",3
28441489,28441312,2,"<p>At least you need to fix this. You defined variable <code>rows</code> as</p>

<pre><code>int a, b, width, rows;
</code></pre>

<p>But you did not initialize <code>rows</code> and you used it here,</p>

<pre><code>intMathOperations(rows, b, width); // int math demonstration
</code></pre>

<p>which used <code>rows</code> in a <code>for</code> loop as the ending condition.  This is a problem.</p>

<p>To fix this I would suggest you turn on all the warnings like this</p>

<pre><code>g++ -Wall your_code.cpp
</code></pre>

<p>And make sure you understand every warning you have and fix the necessary ones.</p>
",3
22853001,22852857,1,"<p>You declare and use this operator:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const iOrder&amp; order);
</code></pre>

<p>but you haven't written any code for it (or at leats it isn't in the shown code)</p>
",1
30151796,30151767,4,"<p>cout is a buffered output stream, and endl not only creates a new line, it also flushes the buffer. Without the flushing of the buffer it might happen that you do not see the output of a previous cout.</p>
",0
28163798,28163758,3,"<p>As you say, references are <em>not</em> reseatable. What's happening is that the reference (which refers to <code>a1</code>) is being assigned the value in <code>b</code>. After the assignment, both <code>intref</code> and <code>a1</code> will be equal to <code>b</code>.</p>
",2
24118439,24117997,6,"<h3>Introduction</h3>
<p>There's no problem using a stateful functor with functions such as <em>std::generate</em>, but one has to be careful not to run into issues where the underlying implementation makes a copy that will change the semantics of a program in a way that is different from what the developer have in mind.</p>
<blockquote>
<p><code>25.1p10</code> <strong>Algorithms library</strong> - <strong>General</strong> <code>[algorithms.general]</code></p>
<blockquote>
<p>[ <em>Note:</em> Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy those function obejcts freely. Programmers for whom object identity is imoprtant should consider using a wrapper class that points to a noncopied implementation object such as reference_wrapper, or some equivalent solution. -- <em>end note</em> ]</p>
</blockquote>
</blockquote>
<hr />
<h2>Order of assignment/evaluation</h2>
<p>The standard explicitly states that exactly <code>last - first</code> (N) assignments and invocations of the generator will be made, but it doesn't state in what order. More can be read in the following <em>Q&amp;A</em>:</p>
<ul>
<li><strong><a href=""https://stackoverflow.com/q/14823732/1090079"">C++ standard wording: Does ¡°through all iterators in the range¡± imply sequentiality?</a></strong></li>
</ul>
<hr />
<h2>Stateful <em>functors</em> + <code>std::generate</code>, unsafe?</h2>
<p>Generally no, but there are a few caveats.</p>
<p>Within <em>std::generate</em> the standard guarantees that the same instance of the functor type will be invoked for every element in the given range, but as can be hinted by the declaration of <em>std::generate</em> we might run into issues where we forget that the passed <em>functor</em> invoked <strong>inside</strong> the function will be a <strong>copy</strong> of the one passed as argument.</p>
<p>See the below snippet where we declare a <em>functor</em> to generate &quot;unique&quot; ids:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

template&lt;class id_type&gt;
struct id_generator {
  id_type operator() () {
    return ++idx;
  }

  id_type next_id () const {
    return idx + 1;
  }

  id_type idx {};
};
</code></pre>
<p><sup></sup></p>
<pre><code>int main () {
  id_generator&lt;int&gt; gen;

  std::vector&lt;int&gt;  vec1 (5);
  std::vector&lt;int&gt;  vec2 (5);

  std::generate (vec1.begin (), vec1.end (), gen);
  std::generate (vec2.begin (), vec2.end (), gen);

  std::cout &lt;&lt; gen.next_id () &lt;&lt; std::endl; // will print '1'
}
</code></pre>
<p>After running the above we might expect <code>gen.next_id ()</code> to yield <code>11</code>, since we have used it to <em>generate</em> 5 ids for <code>vec1</code>, and 5 ids for <code>vec2</code>.</p>
<p>This is not the case since upon invoking <em>std::generate</em> our instance of <em>id_generator</em> will be <strong>copied</strong>, and it is the <strong>copy</strong> that will be used inside the function.</p>
<hr />
<h2>What would be the solution?</h2>
<p>There are several solutions to this problem, all of which prevents a copy from being made when you pass your <em>functor</em> to some <em>algorithm</em> function related to <em>std::generated</em>.</p>
<br />
<p><em>Alternative #1</em></p>
<p>The recommended solution is to wrap your <em>functor</em> in a <a href=""http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"" rel=""nofollow noreferrer""><code>std::reference_wrapper</code></a> with the use of <a href=""http://en.cppreference.com/w/cpp/utility/functional/ref"" rel=""nofollow noreferrer""><code>std::ref</code></a> from <a href=""http://en.cppreference.com/w/cpp/header/functional"" rel=""nofollow noreferrer""><code>&lt;functional&gt;</code></a>. This will effectively copy the <em>reference_wrapper</em>, but the referred to instance of <em>generate_id</em> will stay the same.</p>
<pre><code>std::generate (vec1.begin (), vec1.end (), std::ref (gen));
std::generate (vec2.begin (), vec2.end (), std::ref (gen));

std::cout &lt;&lt; gen.next_id () &lt;&lt; std::endl; // will print '11'
</code></pre>
<br />
<p><em>Alternative #2</em></p>
<p>You could, of course, also make your fingers stronger by writing something as confusing as the below:</p>
<pre><code>std::generate&lt;decltype(vec1.begin()), id_generator&lt;int&gt;&amp;&gt;(vec1.begin(), vec1.end(), gen);
</code></pre>
",14
24119246,24117997,0,"<p>As far as the standard is concerned, you have no guaranteed.  An
implementation can copy a functional object any time it wants.
The idea is that an implementation could potentially divide the
range into sub-ranges, and process each sub-range in a separate
thread.  (At least, this was what was claimed at one point in
the standardization process.) </p>

<p>Globally, of course, for some algorithms, like <code>generate</code> or
<code>accumulate</code>, allowing multiple copies or reordering would make
the algorithm useless.  Usually, such algorithms guarantee
order; they seem to have forgotten <code>generate</code> in this.  And
while the standard does seem to have forgotten allowing copies,
pratically, if order is guaranteed, there is no need for
multiple copies in the processing, so I think we can safely
assume that there aren't, even in the absense of a strict
guarantee.</p>
",6
24118069,24117997,5,"<p>Almost every meaningful generator is stateful. Think about it: a generator invocation has no arguments. If the generator were stateless it would thus have to generate the same value every time. In other words, the only stateless generator is a <em>constant</em> generator:</p>

<pre><code>template &lt;typename T&gt;
struct constant {
    constant(T&amp;&amp; value) : value{value} {}

    T const&amp; operator ()() const { return value; }

private:
    T const value;
};
</code></pre>

<p>Or, alternatively, you could have a generator which has state external to the object itself, such as <a href=""http://en.cppreference.com/w/cpp/numeric/random/random_device""><code>std::random_device</code></a>. But these are really the only two applicable cases. This would be awfully restrictive. So yes ¨C?it is definitely possible to have a stateful generator.</p>

<p>The source for this statement that you refer to is <strong>not</strong> talking about generators ¨C instead, it is talking about <em>predicats</em>, which are a different class of functions, and have different requirements (a predicate is a function with a single argument which returns a <code>bool</code> value).</p>
",2
23106152,23106072,8,"<p>From here <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""noreferrer"">Operator precedence</a> you can see that <code>bitwise shift</code> has lower precedence than <code>type cast</code>. So that is equivalent to:</p>

<pre><code>((dword) (header[2])) &lt;&lt; 8
</code></pre>

<p>Always use parentheses for things that are not clear, even if you check that it is actually ok, because it improves code readability. (you might not want to enclose the subscript like I did to emphasis all the precedences here, but use the other parenthesis).</p>
",2
21578356,21578246,3,"<pre><code>char const* const tag = ""tag5"";
char const* const record = ""tag1{0}|tag2{0}|tag3{0}|tag4{0}|tag5{tag51{0};tag52{0};tag53{0};tag54{0};tag55{tag551{0}:tag552{0}:tag553{0}:tag554{0}:tag555{0}}}"";
char const delim = '|';

std::stringstream ss(record);
for (std::string token; std::getline(ss, token, delim); ) {
    // Handle token here.
}
</code></pre>

<p><a href=""http://ideone.com/Yc8HX1"" rel=""nofollow"">Example here</a>.</p>
",2
21578521,21578246,1,"<p>You're getting a segfault because you're using <code>strtok</code> on a <em>string literal</em>.  Remember that <code>strtok</code> modifies the input string (it replaces all instances of the delimiters with 0), and modifying a string literal results in undefined behavior; on some platforms (such as yours, apparently), string literals are stored in a read-only memory segment, hence the error.</p>

<p>Your code shouid work with the following change:</p>

<pre><code>char record[] = ""tag1{0}|tag2{0}|tag3{0}|tag4{0}|tag5{tag51{0};tag52{0};tag53{0};tag54{0};tag55{tag551{0}:tag552{0}:tag553{0}:tag554{0}:tag555{0}}}"";
</code></pre>

<p>Instead of <code>record</code> being a pointer to a string literal, it's now an array of <code>char</code> that can be modified by your code.  </p>

<p>Having said all that, if you're using C++, Simple's solution is probably a better way to go.  </p>
",0
26157351,26157285,6,"<p>When recursive call to function ends, line 9 will be reached. See this (shorter) example:</p>

<pre><code>int foo(int i) {
    if(i &gt; 0) {
        foo(i-1);
        return 0x7777;
    } else {
      return i;
    }
 }
</code></pre>

<p>So when calling foo(1) it will go through first if (because 1 > 0) and foo(0) will be called. Now inside this call (foo(0)) program will go into else barnch (because 0 is not > 0) and foo(0) will return 0. So now we will be back to our first call (foo(1)) and as foo(0) returned, foo(1) will return 0x7777.</p>
",1
26157363,26157285,2,"<p>This line </p>

<pre><code> strange_fact();
</code></pre>

<p>does the recursion and throws away the result.</p>

<p>The next next line</p>

<pre><code>return 0x7777;
</code></pre>

<p>will return that value finally.</p>

<p>If you remove that line and compiled with the warnings on it will inform you that all paths do not return a value</p>
",0
26157463,26157285,1,"<p>You need to understand how recursions work.</p>

<p>After calling <code>strange_fact()</code> you've put a return statement. Meaning once the function is executed, it's still going to return <code>0x7777</code>, which screws the answer up.</p>

<p>Check this out, this should work as expected:</p>

<pre><code>int strange_fact(int n=0)
{
    static int i=n;
    static int j=i;
    if(j&gt;1)     
    {       
        i *= --j;
        strange_fact();         
        // return 0x7777;    // We don't want to return a value yet
    }
    if(j&lt;=1)          // We need to check this condition after strange_fact is executed
        return i;

    // This line will never be executed
    return 0x7777;    //&lt;------ This line
}
</code></pre>

<p>If you eliminate the static variables, you'll get something like this:</p>

<pre><code>long fact(long i)
{
    if(i &gt; 0)
        return i * fact(i-1);
    if(i == 0)              // factorial(0) = 1
        return 1;

    throw exception(""Negative numbers cannot have factorials""); // Or you can handle it by returning a -ve error code
}
</code></pre>
",0
28216646,28216586,0,"<p>To get an individual letter, you want alphabet[9], not alphabet.substr(9,1)
because the former gets that letter
and the later constructs a new string and copies that letter into it.</p>
",5
28216825,28216586,3,"<blockquote>
  <p>What is the best way of doing this (and by best I mean fastest)?</p>
</blockquote>

<p>It's probably fastest to:</p>

<ul>
<li>reserve enough space for all the letters you want;</li>
<li>pick out individual characters (not substrings of length 1) and append these.</li>
</ul>

<p>which would look like</p>

<pre><code>string word;
word.reserve(7);
word += alpha[9];
// ...
word += alpha[1];
</code></pre>

<p>This will involve at most a single memory allocation. Your method creates several intermediate <code>string</code> objects which might, or might not, involve more allocations, depending on how <code>string</code> is implemented.</p>

<p>As always when optimising, measure to make sure what your doing is a worthwhile optimisation.</p>

<blockquote>
  <p>Or should I use <code>char[]</code>?</p>
</blockquote>

<p>If the size (or at least an upper bound) is known at compile time, then that would allow you to avoid dynamic allocation altogether. If it isn't, then you can't.</p>

<p>You can remove spaces in a similar way; since the array size is fixed, you'll need to keep track of the end of the valid data:</p>

<pre><code>char word[MAX_SIZE];       // enough space for MAX_SIZE
char * end = word + size;  // ""size"" is the actual number of valid characters

// Remove spaces from the range [word,end)
// and update end to point to the end of the remaining letters
end = remove_if(word, end, ::isspace);
</code></pre>
",6
28216868,28216586,2,"<p>In this case, the fastest is likely</p>

<pre><code>string alpha = "" abcdefghijklmnopqrstuvwxyz"";
string word {alpha[9], alpha[5], alpha[13], alpha[13], alpha[16], alpha[0], alpha[0]};
</code></pre>

<p>That is to say: construct word directly as a string of the right length, picking just the characters you need.</p>

<p>Fast ways to remove a certain char which can occur more than once are unfortunately not simple, you'll need to write code yourself:</p>

<pre><code>std::string copy;
copy.reserve(word.size()); // Somewhat too much, but OK
for (char c: word) if (c!= ' ') copy.append(c);
</code></pre>

<p>or</p>

<pre><code>int j = 0;
for (int i = 0; i != word.size(); ++i)
  if(word[i] != ' ') word[j++] = word[i];
word.resize(j);
</code></pre>
",2
24379073,24379030,4,"<p>This is a <a href=""http://en.wikipedia.org/wiki/C++11"">C++11</a> construct, called <a href=""http://en.wikipedia.org/wiki/Variadic_templates"">variadic templates</a> (follow the links)</p>
",0
24379137,24379030,2,"<p>Its called <a href=""http://en.wikipedia.org/wiki/Variadic_template"" rel=""nofollow"">variadic template</a>. It allows you to write templates with variable number of arguments. As far as I can tell here it allows you to define thread running function returning <code>_Fn</code> type with <code>_Args</code> arguments list by partial binding.</p>
",1
27119304,27117809,0,"<p>The name can be user inputted through <code>cin</code>, looks like you aready know how to do that, then stored to a <code>string[]</code>, where the index is for the <code>player-1</code> value. </p>

<pre><code>string names[2];
cout &lt;&lt; ""Player 1 choose name: ""; cin &gt;&gt; names[0];
cout &lt;&lt; ""Player 1 choose name: ""; cin &gt;&gt; names[1];
</code></pre>

<p>Also, you're checking if an <code>unsigned int</code> is negative. That should be a compiler error.  </p>

<p>Your <code>case 2</code> doesn't seem to change anything. </p>

<p>The end game outputs with these changes.</p>
",0
29447163,29446957,0,"<blockquote>
  <p>Now is there a way in C++ to use the name of a class object to refer to its first member?</p>
</blockquote>

<p>No, C++ doesn't have any reflection, so there's no way to actually determine what the ""first member"" is. </p>

<p>However, if what you really want is to get an ID for any object, you could just require that object to have that method:</p>

<pre><code>template &lt;typename T&gt;
void function(const T&amp; t) {
    int id = t.getID();
    // etc.
}
</code></pre>

<p>Without knowing more about your use-case, it's hard to know what to propose. </p>
",2
29447128,29446957,5,"<p>In C++, such behaviour would be a cataclysm. If I understand correctly, Java tries to convert object of type <code>A</code> to object of type <code>B</code> by searching for first member in <code>A</code>, that is of type <code>B</code> or is implicitly convertible to <code>B</code>.</p>

<p>C++ wasn't designed that way. We like to write code, that is always predictable. You <strong>can</strong> achieve what you want, but for a price.</p>

<p>The best solution in this case would be conversion operator - consider:</p>

<pre><code>class Program
{
public:
  int id;
  char *str;

  operator int()
  {
    return this-&gt;id;
  }

  //You can have more than one!
  operator const char*()
  {
    return this-&gt;str;
  }
};

void function_int(int p)
{
}

void function_str(const char* s)
{
}
</code></pre>

<p>Now it is possible to do the following:</p>

<pre><code>Program prog;
function_int(prog); //Equivalent of function_int(prog.id)
function_str(prog); //Equivalent of function_int(prog.str)
</code></pre>

<p>The price is, that if you add another <code>int</code> and place it before <code>id</code> it will not be used in conversion, because we stated in our operator explicitly, that ""<code>int</code> content"" of our class is represented by <code>id</code> and this member is considered when it comes to such conversion.</p>

<p>However, even this simple example shows some potential problems - overloading functions with integral and pointer types could result in very unpredictable behavior. When type contains conversion operators to both pointers and integers, it can get even worse.</p>

<p>Assume, that we have following function:</p>

<pre><code>void func(unsigned long)
{
}
</code></pre>

<p>And we call <code>func</code> with argument of type <code>Program</code>. Which conversion operator would you expect to be called? Compiler knows how to convert <code>Program</code> to either <code>int</code> or <code>const char*</code>, but not <code>unsigned long</code>. <a href=""http://en.cppreference.com/w/cpp/language/implicit_cast"" rel=""nofollow noreferrer"">This article on cppreference</a> should help you to understand how implicit conversions work.</p>

<hr>

<p>Also, as Barry pointed out, more meaningless constructs become available. Consider this one:</p>

<pre><code>int x = prog + 2
</code></pre>

<p>What does it mean? It is perfectly valid code, though. That is why conversion operators should be dosed extremely carefully (in pre-C++11 era, there was a general advise, that every class should have at most one such operator).</p>

<p>Quote from <a href=""https://msdn.microsoft.com/en-us/library/vstudio/5s5sk305%28v=vs.100%29.aspx"" rel=""nofollow noreferrer"">MSDN</a>:</p>

<blockquote>
  <p>If a conversion is required that causes an ambiguity, an error is generated. Ambiguities arise when more than one user-defined conversion is available or when a user-defined conversion and a built-in conversion exist.</p>
</blockquote>

<p>Sometimes, simple solution to this problem is to mark conversion operator with <strong>explicit</strong> keyword, so you would need to change above calls to:</p>

<pre><code>function_int((int)prog);
function_str((const char*)prog);
</code></pre>

<p>It is not as pretty as the previous form, but much safer. It basically means, that compiler is forbidden to perform any implicit conversion using operator marked as <strong>explicit</strong>. Very useful to avoid ambiguous calls, while still providing some flexibility in code - you can still very easily convert objects of one type to another, but you can be sure when and where these conversions are performed.</p>

<p>However, explicit conversion operators are still not supported by some compilers, as this is C++ 11 feature (for example, Visual C++ 11 doesn't support it).</p>

<p>You can read more about <strong>explicit</strong> keyword <a href=""http://en.cppreference.com/w/cpp/language/explicit"" rel=""nofollow noreferrer"">here</a>.</p>
",5
21164020,21163984,1,"<p>if you have pointer use <code>-&gt;</code> if you have object or reference use <code>.</code> e.g. Say I have:</p>

<pre><code>class foo{

public:
    int a;
}

int main()
{
    foo f;
    foo* f1 = new foo();
    cout&lt;&lt;f.a&lt;&lt;""\n""&lt;&lt;f1-&gt;a&lt;&lt;""\n"";
}
</code></pre>
",3
21164059,21163984,1,"<p><code>::</code> is the <em>scope resolution operator</em>, used for referencing static class members and namespace elements.</p>

<p><code>-&gt;</code> is the <strong><em>indirect</strong> reference operator</em>, used for referencing members methods and fields on an instance pointer.</p>

<p><code>.</code> is the <strong><em>direct</strong> reference operator</em>, used for referencing member methods and fields on an instance.</p>
",2
21164137,21163984,0,"<p>If you have a pointer type and you want to access a member object or member function you can use <code>(*ptr).anything</code> or <code>ptr-&gt;anything</code>. In most cases that's exactly the same (unless of course a specific <code>-&gt;</code> operator is overloaded). If you have a non pointer type you should use <code>.</code>.</p>
",0
21164143,21163984,0,"<p>This is simple, these both operators are used by an instance to access members or methods.</p>

<p><code>.</code> is used by <strong>instance</strong> or <strong>instance reference</strong></p>

<p><code>-&gt;</code> is used by <strong>instance pointer</strong></p>

<p>In Example:</p>

<pre><code>class MyClass
{
public:
    int a;
}

int main()
{
     // Instance, Reference, and Pointer declaration
     MyClass instance;
     MyClass&amp; instanceReference = instance;
     MyClass* instancePointer = new MyClass();

     // Usecases
     int a;
     a = instance.a;
     a = instanceReference.a;
     a = instancePointer-&gt;a;
}
</code></pre>
",0
22488404,22487035,1,"<p>""Why would std::sort require two compares for a two-element list?"" - Was this done in ""debug"" mode? I tested this with Visual Studio 2005 - which uses insertion sort for small arrays (size &lt; 32, otherwise it uses quick sort or heap sort). In ""release"" mode, it does one compare. In debug mode, it checks the caller supplied compare routine to make sure it's &lt; versus &lt;= , so there are two calls made:</p>

<pre><code>{   // test if _Pred(_Left, _Right) and _Pred is strict weak ordering
if (!_Pred(_Left, _Right))
    return (false);
else if (_Pred(_Right, _Left))
    _DEBUG_ERROR2(""invalid operator&lt;"", _Where, _Line);
return (true);
}
</code></pre>
",0
30144648,30144607,4,"<p>The problem is here:</p>

<pre><code>Derived* d2 = d-&gt;clone();
</code></pre>

<p>The compiler checks the types at compile type, and <code>d</code> has type <code>Base*</code> (even if at runtime the virtual dispatch kicks in and indeed a <code>Derived*</code> object is returned from <code>d-&gt;clone()</code>). In your case it is OK to use a <code>static_cast</code> (no need for <code>dynamic_cast</code> really), like</p>

<pre><code>Derived* d2 = static_cast&lt;Derived*&gt;(d)-&gt;clone();
</code></pre>

<p>I think all of us got confused by this issue at least once. Related: <a href=""https://stackoverflow.com/questions/29179208/covariant-clone-function-misunderstanding"">Covariant clone function misunderstanding</a>.</p>
",0
24091774,24091422,3,"<h2>Solution No.1</h2>

<ul>
<li>Declare them as <code>extern</code> in a header and define them in a '.cpp' file.</li>
<li>Don't define them as <code>static</code> in a header file as you would break the <a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow"">one definition rule</a>.</li>
</ul>

<h2>Solution No.2</h2>

<ul>
<li>Declare them as <code>static</code> constant member variables of a helper class. Put the <code>class</code> definition in a header file (e.g., <code>XML_constants.hpp</code>). Define them in a <code>.cpp</code> file (e.g., <code>XML_constants.cpp</code>):</li>
</ul>

<hr>

<pre><code>  // XML_constants.hpp
  struct XML {
    static const std::string POS_ID;
    static const std::string HEIGHT;
    static const std::string WIDTH;
    static const std::string RATIO;
  };

  // XML_constants.cpp
  const std::string XML::POS_ID = ""position-id-map"";
  const std::string XML::HEIGHT = ""height"";
  const std::string XML::WIDTH  = ""width"";
  const std::string XML::RATIO  = ""ratio"";
</code></pre>

<hr>

<h2>Solution No.3</h2>

<ul>
<li>If the usage of these constants is limited in your <code>main.cpp</code> then your current configuration looks fine.</li>
</ul>
",3
24092570,24091422,3,"<p>Well, since you are asking a question about header files, you program probably consists (or will eventually consist) of more than one implementation files, several (or all) of which include your header file.</p>

<p>If so, defining heavy <code>const</code> objects in header files is not a good idea. <code>const</code> objects in C++ have internal linkage by default, which will prevent any ""multiple definitions"" errors, but at the same time will create an independent copy of each such heavy object in each translation unit that includes that header file. Doing something like that without a good reason is a rather wasteful thing to do.</p>

<p>A better idea would be to provide non-defining declarations in the header file</p>

<pre><code>// Declarations
extern const std::string POS_ID;
extern const std::string HEIGHT;
extern const std::string WIDTH;
extern const std::string RATIO;
</code></pre>

<p>and place the definitions in one and only one implementation file</p>

<pre><code>// Definitions
extern const std::string POS_ID = ""position-id-map"";
extern const std::string HEIGHT = ""height"";
extern const std::string WIDTH = ""width"";
extern const std::string RATIO = ""ratio"";
</code></pre>

<p>Note that the keyword <code>extern</code> has to be specified explicitly in this approach, to override the ""static by default"" property of <code>const</code>. However, if the header declarations are visible at the point of definition, then <code>extern</code> can be omitted from the definitions.</p>
",2
21170296,21169985,2,"<p>This is much more likely to do what you want:</p>

<pre><code>for (int i=0; i&lt;10; i++)
{
    // ... whatever is setting 'addr' to something new

    strncat(zip, addr, sizeof(zip));
}
</code></pre>

<p>Now we're using the size of <code>zip</code> (100), not the size of a pointer, and the size will still be correct even as there's less 'empty' space left in the buffer.</p>
",0
21772264,21772218,0,"<p>Compilers do not store the member methods or static members with an instance of class.</p>

<p>That is why <code>memset</code> does not have any effect on address of method.</p>
",0
21772293,21772218,1,"<p>Take the address of the function <code>&amp;A::function1</code> and print it. Compare it to the address of the object <code>&amp;obj</code>.</p>

<p>In memory the object itself only contains its non static data members and possibly a single vtable pointer.</p>

<p>The actual methods are code not data. They are shared among all objects and you cannot change them. Behind the scenes class methods are simply ""special"" functions that transparently accept the this pointer in addition to the arguments specified by the programmer.</p>

<p>That said you can really mess some objects up if you write over their internal state with zeros.</p>
",0
34268865,34268606,2,"<p>You can't do what you want.</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd316718%28v=vs.85%29.aspx"" rel=""nofollow"">""<code>IDWriteTextLayout</code> interface"" article</a> on MSDN says:</p>

<blockquote>
  <p>The <code>IDWriteTextLayout</code> interface <strong>represents a block of text after it has been fully analyzed and formatted</strong>.</p>
</blockquote>

<p>And <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd742752%28v=vs.85%29.aspx"" rel=""nofollow"">""Text Formatting and Layout"" article</a>:</p>

<blockquote>
  <p>The text in an <code>IDWriteTextLayout</code> object <strong>cannot be changed once the object is created</strong>. To change the text you must delete the existing object and create a new <code>IDWriteTextLayout</code> object.</p>
</blockquote>
",6
29460915,29460623,1,"<p>OK I figured it out now. I forgot to provide a constructor implementation for my TwoDimensionalShapes and ThreeDimensionalShapes classes. Silly mistake. </p>
",0
23108279,23107609,0,"<p>The simple answer is no.  The mode is determined when the iostream object is constructed, and cannot be changed later.  Some implementations may provide a means of doing it later, but this isn't standardized.  On some implementations, doing an <code>freopen</code> on <code>stdout</code> might change the mode, although I think that formally, this is forbidden in C++.  (It is implementation defined in C.)  And apparently, it doesn't work on your implementation.</p>

<p>You're best bet is to find out how your system names the console device (<code>""/dev/tty""</code> under Unix; <code>""CONS""</code>, I think, under Windows), open it in the desired mode, and output to it.</p>
",2
29179478,29179463,2,"<p>In the constructors you are hiding the member variables (by declaring variables with the same name as the members) hence your member variables remain un-initialized</p>

<pre><code>HashList* hashlist = new HashList(); // hiding the member variable this-&gt;hashlist
Tree* tree = new Tree(); // hiding the member variable this-&gt;tree
</code></pre>

<p>Just use</p>

<pre><code>hashlist = new HashList();
tree = new Tree();
</code></pre>

<p>inside the constructors.</p>
",0
29185454,29185098,0,"<p>Just tossing an idea that seems to work.  Not sure if it is too radical or not.  Would anyone else do it this way?</p>

<pre><code>enum {Foo, Bar};

template &lt;int N&gt;
struct FooBar {
    void operator()(bool b) const {
        const int num = std::rand() % 5;  // Some random number
        // code block A
        check_bool(b);
        // code block D
        const int number = get_number(num);
        // code block E
    }
  private:  
    int get_number(int) const;
    void check_bool (bool b) const;
    void code_block_c() const {
        // code block C
    }
};

template&lt;&gt; void FooBar&lt;Foo&gt;::check_bool (bool b) const {
    if (b) {
        // code block B
    }
    else
        code_block_c();
}

template&lt;&gt; int FooBar&lt;Foo&gt;::get_number (int num) const {return num + 1;}

template&lt;&gt; void FooBar&lt;Bar&gt;::check_bool (bool) const {code_block_c();}

template&lt;&gt; int FooBar&lt;Bar&gt;::get_number (int num) const {return num &lt; 10 ? num + 1 : 0;}

void foo (bool b) {FooBar&lt;Foo&gt;()(b);}
void bar (bool b) {FooBar&lt;Bar&gt;()(b);}

int main() {
    for (int i = 0; i &lt; 100000000; i++) {
        foo(true);  bar(true);
        foo(false);  bar(false);
    }
}
// 5.548 seconds

// The following alternative results in no time difference really:
//FooBar&lt;Foo&gt; foo_;
//FooBar&lt;Bar&gt; bar_;
//void foo (bool b) {foo_(b);}
//void bar (bool b) {bar_(b);}
</code></pre>

<p>Following the suggestion of using another bool parameter:</p>

<pre><code>void foo_bar (bool b, bool q) {
    const int num = std::rand() % 5;
    // code block A
    if (q) {
        if (b) {
            // code block B
        }
        else {
            // code block C
        }
    }
    else
        // code block C
    // code block D
    const int number = q ? num + 1 : (num &lt; 10 ? num + 1 : 0);
    // code block E
}

void foo (bool b) {foo_bar(b, true);}

void bar (bool b) {foo_bar(b, false);}

int main() {
    for (int i = 0; i &lt; 100000000; i++) {
        foo(true);  bar(true);
        foo(false);  bar(false);
    }
}
// 4.724 seconds
</code></pre>

<p>Their suggested solution performs a bit faster, despite the constant if-checks.</p>
",0
29185465,29185098,3,"<p>Combine foo and bar into a single function which takes two arguments: <code>bool b</code>, <code>bool q</code>.  The value of <code>q</code> would determine whether this new function behaves like foo or bar.</p>
",0
29185221,29185098,2,"<p>If you have two identical pieces of code in two separate functions, the <em>only way</em> to get rid of the repetition is to put them inside a new function (or, of course, a macro).</p>

<p>It is both clean and elegant. And that's what you should do.</p>
",0
22421573,22421505,1,"<p>At least you should use</p>

<pre><code>name = new char[newname.size() + 1];
</code></pre>

<p>instead of</p>

<pre><code>name = new char[newname.size() - 1];
</code></pre>

<p>Anyway, I don't see the need to copy the string.
What will also fail is:</p>

<pre><code>myfiles[i-1]
</code></pre>

<p>in your second loop, because it starts from 0.</p>
",2
22422304,22421505,1,"<p>I think it's this loop:</p>

<pre><code> for (int i = 0; i &lt; myfiles.size(); i++)
                cout &lt;&lt; '[' &lt;&lt; i &lt;&lt; ']' &lt;&lt; ' ' &lt;&lt; myfiles[i-1] &lt;&lt; endl;
</code></pre>

<p>When <code>i</code> is 0, then you are trying to access <code>myfiles[-1]</code>. If <code>myfiles</code> is not an object of a <em>very</em> strange class which overloads <code>operator[]</code> in an unusual way, but is instead just a normal <code>std::vector</code> (99% more likely :)), then this is undefined behaviour, i.e. anything can happen (including the error message you see).</p>

<p>As a side note, you are performing <strong>pointer</strong> operations instead of using real C++ strings (i.e. <code>std::string</code> objects) consistently. Which is surprising, because you already seem to have a <code>std::string</code> there (<code>newname</code>), and you seem to know how to use it together with (old / legacy / C) functions requiring a <code>char const *</code>, namely with its <code>c_str()</code> member function. Why don't you just write <code>remove(newname.c_str())</code> ?</p>
",1
34212252,34211547,2,"<p>The problem is the seekp parameter:</p>

<pre><code>ss.seekp(0)
</code></pre>

<p>tells to the stream to position at 0 relative to beginning (ie absolute) but...the stream is empty, and there's no position 0.
Change it with</p>

<pre><code>ss.seekp(0, std::ios_base::end);
</code></pre>

<p>In this way it works.</p>
",1
21716440,21716357,4,"<p>What you're showing (<code>scanf(""%s"",&amp;string);</code>) doesn't work (and never could, by e.g. giving different format specifiers)!</p>

<p><code>scanf()</code> used with the <code>%s</code> format specifier requires a corresponding <code>char*</code> pointer referencing a raw <code>char[]</code> array to receive the read data in the parameter list. The <code>std::string</code> pointer you're passing in your example, doesn't provide automatic casting to the referred <code>std::string</code> instances internally managed <code>char[]</code> buffer that way though. </p>

<p>You could try to use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/front"" rel=""nofollow""><code>&amp;string.front()</code></a> instead, but I wouldn't really recommend that, unless you're very sure what you're doing.</p>

<p>For <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a> you should better use <code>std::cin</code> and<br>
<code>std::istream&amp; operator&gt;&gt;(std::istream&amp;, const std::string&amp;)</code>
instead:</p>

<pre><code>std::cout &lt;&lt; ""Put in string value:"" &lt;&lt; std::endl;
std::string input;
std::cin &gt;&gt; input;
</code></pre>

<p><sub>(<a href=""/questions/tagged/xcode"" class=""post-tag"" title=""show questions tagged &#39;xcode&#39;"" rel=""tag"">xcode</a> isn't relevant for your question BTW!)</sub></p>
",0
21716524,21716357,0,"<p>You shouldn't mix <code>std::cout</code> with <code>::printf</code>. Prefer to use the <a href=""http://en.cppreference.com/w/cpp/io"" rel=""nofollow"">C++ Standard IO library</a> over C functions from <code>stdio</code>.</p>

<p>Your code should look a little like this:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    std::string string2;
    std::string other_string;

    std::cout &lt;&lt; ""Hello, World!\n"";
    std::cout &lt;&lt; ""Hi my name is Josh "" &lt;&lt;  string2 &lt;&lt; '\n';
    std::cin &gt;&gt; other_string;
    std::cout &lt;&lt; ""hi "" &lt;&lt; other_string;
}
</code></pre>
",0
29148921,29148693,0,"<p>Assuming </p>

<pre><code>std::vector&lt;std::string&gt; inputText;
std::vector&lt;std::string&gt; keyWords;
</code></pre>

<p>Using C++11 you can also write the following</p>

<pre><code>for (const auto&amp; line : inputText)
    for (const auto&amp; word : keyWords)
        if (line.find(word) != std::string::npos)
        {
            cout &lt;&lt; ""Success"" &lt;&lt; word &lt;&lt; endl;
        }
</code></pre>
",0
29149006,29148693,1,"<p>Here is your code built into an application (VS) that does work.</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;

const int size = 5;
string keyWords[size] = {""one"", ""two"", ""three"", ""four"", ""six""};
string inputText[size] = 
{
    ""This is one test"",
    ""This is two test"",
    ""This is three test"",
    ""This is four test"",
    ""This is five test""
};

int _tmain(int argc, _TCHAR* argv[])
{
    int i = 0;

    string line;
    while (i &lt; size)
    {
        line = inputText[i];
        for (int k = 0; k &lt; size; k++)
        {
            if (line.find(keyWords[k]) != std::string::npos)
            {
                cout &lt;&lt; ""Success"" &lt;&lt; keyWords[k];
            }
        }
        i++;
    }

    char inchar;
    cin &gt;&gt;  inchar;
    return 0;
}
</code></pre>
",2
29148844,29148693,1,"<p>Assuming </p>

<pre><code>std::vector&lt;std::string&gt; inputText;
std::vector&lt;std::string&gt; keyWords;
</code></pre>

<p>Where you need to find any of the keyWords in any of the lines, this is the cleaner way to do it:</p>

<pre><code>for (auto line = inputText.begin(); line != inputText.end(); ++line)
    for (auto word = keyWords.begin(); word != keyWords.end(); ++word)
        if (line-&gt;find(*word) != std::string::npos)
        {
            cout &lt;&lt; ""Success"" &lt;&lt; *word;
        }
</code></pre>

<p>This shouldn't crash as long as the vectors aren't already corrupted in some way.</p>
",7
22465720,22464808,2,"<p>You are currently using stack, with an array of characters:</p>

<pre><code>char data[ MAX_SIZE ];
</code></pre>

<p>Instead, you would go for a struct, that holds both character and position in the input string</p>

<pre><code>struct info {
    char data;
    int pos;
};

info data[ MAX_SIZE ];
</code></pre>

<p>So at the end, you just check your stack, and in addition to invalid characters, you also have the position in the input string.</p>

<p>Hope that helps.</p>
",0
22465767,22464808,2,"<p>You can move your main to the bottom to avoid forward function declarations. You also don't need to use another stack for the errors (actually I think it's easier if you don't). You just need to hold both the bracket and its position on a single stack, i.e.</p>

<pre><code>struct Item
{
    char bracket;
    size_t position;
}

std::stack&lt;Item&gt; st;
</code></pre>

<p>As well as either an array or, better a string initialized to the same length as the input string with all spaces which you change to <code>'^'</code> upon encountering an error, i.e.</p>

<pre><code>std::string errorString(input.size(), ' ');

if ( /* brackets don't match */ )
{
    errorString[st.top().position] = '^';
}
</code></pre>

<p>In case you cannot use STL stack, you need to modify your own to hold <code>Item</code> objects instead of char (i.e. Item data[ MAX_SIZE ];). Your code looks very much like C thought and it would be better if you made use of <code>std::string</code> and <code>std::stack</code> instead.</p>
",2
27500594,27500035,0,"<p>You need to write to your file using the file stream you have defined once you have taken your inputs and you can do that using <code>fout</code> as follows. Additionally, there are different modes in which you could open a file for writing to it, which you can go through <a href=""http://www.cplusplus.com/reference/fstream/fstream/open/"" rel=""nofollow"">here</a>.</p>

<pre><code>    fout.open(""FootballTeam.txt"");

    cout &lt;&lt; ""Enter first name "";
    cin &gt;&gt; forename;
    fout &lt;&lt; forename &lt;&lt; "" "";
    cout &lt;&lt; endl;
    cout &lt;&lt; ""Enter surname "";
    cin &gt;&gt; surname;
    fout &lt;&lt; surname &lt;&lt; "" "";
    cout &lt;&lt; endl;
    cout &lt;&lt; ""Enter strike power  "";
    cin &gt;&gt; strike;
    fout &lt;&lt; strike &lt;&lt; "" "";
    cout &lt;&lt; ""Enter defence power  "";
    cin &gt;&gt; defence;
    fout &lt;&lt; defence &lt;&lt; "" "";
    cout &lt;&lt; ""Enter midfield power  "";
    cin &gt;&gt; midfield;
    fout &lt;&lt; midfield &lt;&lt; ""\n"";
</code></pre>

<p>Open and take a look at <code>FootballTeam.txt</code> to find what the above snippet does.</p>

<p>Hope that helps.</p>
",0
28182468,28182257,0,"<p>if your input is const char* as filename you can split it in severals ways. You wrote that you need to split it into some parts (first part). I have little snippet to split string by char in your case '_'</p>

<pre><code>void stringSplitBy(std::string str, const char *separator, std::vector&lt;std::string&gt; &amp;results)
{
    size_t found = str.find_first_of(separator);
    while (found != std::string::npos) {
        if (found &gt; 0) {
            results.push_back(str.substr(0, found));
        }
        str = str.substr(found + 1);
        found = str.find_first_of(separator);
    }
    if (str.length() &gt; 0) {
        results.push_back(str);
    }
}
</code></pre>

<p>Use it in this way:</p>

<pre><code>const char* inputfname = ""xxx.xxx.xxx.xxx_yyy.yyy.yyy.yyy.pcap"";
std::string fname = std::string(inputfname);
std::vector&lt;std::string&gt; results;
stringSplitBy(fname, '_', results);
</code></pre>

<p>You can print result:</p>

<pre><code> std::vector&lt;std::string&gt;::iterator it = results.begin();
 for (; it != results.end(); ++it)
 {
   std::cout&lt;&lt; (*it).c_str() &lt;&lt; std::endl;
 }
</code></pre>
",1
30152243,30152116,3,"<p>When you include a header file it will be inlined at compile time, meaning it probably has to have C++ content in it (unless the entire file be comments).  From this point of view, <code>.h</code> and <code>.cpp</code> files are the same in that they both contain C++ code.</p>

<p>However, best practices dictate that <code>.h</code> files be used for templating and class definitions, while <code>.cpp</code> files are used for implementations and source code.  It is bad practice to mix usage of the two although it is possible.</p>
",0
30152257,30152116,0,"<p>This is not a complete answer, but I provide some pointers. The C/C++ languages (or their preprocessors), strictly speaking, do not care for the most part -- the header files are there more for programmer convenience.</p>

<p>That said, the C/C++ Standards do specify the existence of the Standard library headers (not exactly ""header files"", though), e.g. <code>&lt;iostream&gt;</code> and <code>&lt;cstdio&gt;</code>.</p>

<p>What both languages do have firmly is the concept of ""translation units"", which are one or more units of compilation that are later linked together into the final program. In C++, there is also the <a href=""http://en.m.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow"">One Definition Rule</a> which affects what you can put in your header files vs. your .cpp files without them getting duplicated in your program.</p>
",0
30152603,30152116,0,"<p>I encountered the following case. Lets say you have two source file.</p>

<p>file1.cpp has <code>main()</code> and file2.cpp has some helper function <code>x()</code> and <code>y()</code>. and file1.cpp has declaration for <code>x()</code> and <code>y()</code> it will compile and program will run. In case you defined the function in file2.h instead of file2.cpp and you didn't <code>#include ""file2.h""</code> then there will be compile time error <code>undefiend reference to x(),y()</code> . For a declarations in <code>.h</code> file if there are no definition in the same file the compiler will look for definition in a <code>.cpp</code> file not a <code>.h</code> file. </p>
",0
22177685,22177572,0,"<p>An easy solution would be to pass a linked list (by reference) into the <code>choose</code> function.  An element that is chosen would be removed from the list and returned.  Subsequent calls to the function would have fewer and fewer elements to choose from.</p>

<p>You would have to take note of when the list is empty and handle it accordingly.</p>

<p>If <code>a</code> and <code>b</code> are allowed to be the same, then <code>choose</code> would not be the function you are using for determining <code>c</code>.  In that case, have a separate function <code>chooseC</code> that takes a list of chosen values (by constant reference) and a list of available values (by value).  Remove the chosen values from the available values, and pick from what is left.</p>
",5
24101012,24100997,2,"<p><code>tarkiz = tarkiz++;</code> is undefined behavior. To fix it write <code>tarkiz++;</code> instead.</p>

<p>See <a href=""https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points"">this explanation</a> for details.</p>
",0
23072525,23072494,0,"<p>It calls address 0, which is the address of the f function.</p>

<p>e8 is the call instruction in x86 according to this:</p>

<p><a href=""http://www.cs.cmu.edu/~fp/courses/15213-s07/misc/asm64-handout.pdf"" rel=""nofollow"">http://www.cs.cmu.edu/~fp/courses/15213-s07/misc/asm64-handout.pdf</a></p>

<p>call uses the displacement relative to the next instruction, at memory location 1e. That becomes memory location 0. So it's callq 1e when in reality it's calling address 0.</p>
",4
22875598,22875560,2,"<p>This would be correct:</p>

<pre><code>list&lt;int&gt; my_function()
{
    set&lt;int&gt; my_set;
    my_set.insert(1);
    my_set.insert(2);   
    return list&lt;int&gt;(my_set.begin(), my_set.end());
}
</code></pre>

<p>I am not sure what you mean with ""heap allocated"", but keep in mind, that <code>list</code> and <code>set</code> already store data on the heap.</p>
",8
28444752,28444625,4,"<p>The expression</p>

<pre><code>*(int*)(data+i)
</code></pre>

<p>casts the <code>char*</code> pointer formed by <code>data+i</code> to <code>int*</code>, and dereferences. This would access <code>sizeof(int)</code> <code>char</code>-values as an <code>int</code>, except that it's Undefined Behavior so it might really do anything. In particular at the end of the array.</p>

<p>If you're interested in outputting the numerical values, instead do</p>

<pre><code>+data[i]
</code></pre>

<p>which promotes the <code>char</code> value to <code>int</code>.</p>
",4
22515674,22515592,42,"<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main()
{
    double num1 = 3.12345678;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::showpoint;
    std::cout &lt;&lt; std::setprecision(2);
    std::cout &lt;&lt; num1 &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",6
25655773,25655738,0,"<pre><code>teams[i].matches[foundMatches] = thisMatch;
</code></pre>

<p>If <code>matches</code> is suppose to contain an array of pointers to matches, it should be declared:</p>

<pre><code>Match **matches;
</code></pre>

<p>You should then allocate it with:</p>

<pre><code>team[i].matches = new (Match*)[num];
</code></pre>

<p>Then the above assignment will work.</p>
",6
25655838,25655738,1,"<p>What you are trying to do is assign a variable to a constant value. The address of <code>teams[i].matches[foundMatches]</code> is predefined already (at the point when you declared the array) and can not be changed. </p>

<p>What are you trying to do is rather change the content of <code>teams[i].matches[foundMatches]</code> (in further I assume this is a <code>Match</code> object since you said <em>matches is an array of Match objects within the Team objects</em>). Changing the content may be done by: <code>teams[i].matches[foundMatches] = *thisMatch</code> i.e. assign the content of <code>thisMath</code> which is <code>*thisMath</code> to an array entry. </p>

<p>Unless you are not using <code>thisMath</code> before or after for any manipulations that can not be done to <code>teams[i].matches[foundMatches]</code> directly, you can go with <code>teams[i].matches[foundMatches] = Match()</code> and instantiate the object, rather then allocating memory and copying it to <code>teams[i].matches[foundMatches]</code> forcing afterwords a deallocation as well.</p>

<p>Note: make sure you have a CTOR/CCTOR implemented in the <code>Match</code> class as the copy will involve either of one. </p>
",3
21314723,21314611,1,"<p>The line with <code>void absent_days();</code> is a declaration, not a function call.</p>

<p>Remove void:</p>

<p><code>absent_days();</code></p>
",1
21314754,21314611,2,"<p>change this</p>

<pre><code>cout &lt;&lt; ""Absent days:- "";
void absent_days();  // function prototype
return 0;
</code></pre>

<p>to this</p>

<pre><code>cout &lt;&lt; ""Absent days:- "";
absent_days();  // function call
return 0;
</code></pre>
",0
21314821,21314611,3,"<p>You need two or three things to do to make it work:</p>

<ol>
<li><p>change </p>

<pre><code>void absent_days();
</code></pre>

<p>to</p>

<pre><code>absent_days();
</code></pre>

<p>to make it as a function call instead of a function declaration.</p></li>
<li><p>put the function declaration before the main body, i.e. you have to declare it before using it.</p>

<pre><code>void absent_days();
int main(int argc, const char * argv[])
{
    // ...
}
</code></pre></li>
<li><p><em>[optional]</em> if you still have compiler error in line <code>cin &gt;&gt; name;</code> (for me, yes), you also need to include string header:</p>

<pre><code>#include &lt;string&gt;
</code></pre></li>
</ol>
",1
33564740,33564191,3,"<p>For the pointer version: 'T' is a pointer then that needs to passed as a const ref - it's not the datum it points to that is to be const qualified here, but the pointer ref itself.</p>

<pre><code>template &lt;typename T&gt;
class Heap{
public:
    Heap(int size, bool (*comparator) (const T &amp; a, const T &amp; b)
                                 = [] (const T &amp; a, const T &amp; b){
        return a &lt; b;
    }) {}; 

    // other unimportant methods
};


int main()
{
    Heap&lt;int*&gt; heap2(3, [](int* const&amp; a, int* const&amp; b){
        return false;
    });

    // analogous to  
    Heap&lt;int&gt; heap(4, [](const int &amp; a, const int &amp; b){ 
         return false; 
    });
    // but it's the pointer to the datum in the first,
    // and the datum itself in the latter case
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/3fcc051f47fccfa5"" rel=""nofollow"">live at Coliru</a></p>
",0
31192698,31192139,1,"<p>I would propose you simply replace <code>\\</code> by <code>/</code>, they work the same (even better because they are valid on all platform):</p>

<pre><code>void printPathToFile( std::wstring myPath )
{
    std::wstring mySafePath = myPath;
    std::replace( mySafePath.begin(), mySafePath.end(), '\\', '/');

    // then use mySafePath in the rest of the function....
}
</code></pre>
",0
31192699,31192139,0,"<p>It does: boost filesystem. You use a <code>path</code> to pass, well, paths, around instead of strings. Here's the hello world for boost filesystem:</p>

<pre><code>int main(int argc, char* argv[])
{
  path p (argv[1]);   // p reads clearer than argv[1] in the following code

  if (exists(p))    // does p actually exist?
  {
    if (is_regular_file(p))        // is p a regular file?   
      cout &lt;&lt; p &lt;&lt; "" size is "" &lt;&lt; file_size(p) &lt;&lt; '\n';

    else if (is_directory(p))      // is p a directory?
      cout &lt;&lt; p &lt;&lt; ""is a directory\n"";

    else
      cout &lt;&lt; p &lt;&lt; ""exists, but is neither a regular file nor a       directory\n"";
  }
  else
    cout &lt;&lt; p &lt;&lt; ""does not exist\n"";

  return 0;
}
</code></pre>

<p><a href=""http://www.boost.org/doc/libs/1_58_0/libs/filesystem/doc/tutorial.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_58_0/libs/filesystem/doc/tutorial.html</a></p>

<p>Edit: note also that this library is being considered for addition to the standard, and can currently be used from the std::experimental namespace, depending on your compiler/standard library version: <a href=""http://en.cppreference.com/w/cpp/header/experimental/filesystem"" rel=""nofollow"">http://en.cppreference.com/w/cpp/header/experimental/filesystem</a></p>
",0
31256242,31256211,2,"<pre><code>cin &gt;&gt; name;
</code></pre>

<p>reads ""Rock"" from the input stream and safes it in <code>name</code>. The stream now contains "" Lee\n"". Now</p>

<pre><code>getline(cin, name, '\n');
</code></pre>

<p>reads the remaining "" Lee\n"" from the stream, discards the <code>\n</code> and then overwrites <code>name</code> with the result. <code>name</code> now contains "" Lee"".</p>

<p>To read the whole line into <code>name</code>, remove the <code>cin</code> line that ""steals"" the first word.</p>

<p>Btw, the <code>cout.flush();</code> is not necessary since <code>cout</code> and <code>cin</code> are tied by default, i.e. <code>cout</code> will always be flushed when control reaches a <code>cin</code>.</p>
",0
22488195,22488160,4,"<p>Yes,</p>

<p>if You don't want to place A before B, then forward declaration is the only solution in that case (if You don't want to change definition of B - see Zac Howland answer for other ideas that change B). There is nothing wrong with that. Somehow, methods from B needs to know what A is (in that case it is a class). Either, compiler will figure it out by finding A definition or You will help the compiler with forward declaration.</p>
",0
22488238,22488160,1,"<p>There are a few options, but without more information about your goals, it is hard to tell you which is the best.  Forward declaration, move the definition of <code>A</code>, and making <code>B</code> a template class are some of the options.  Presuming you are familiar with the 2 former, the latter would look something like:</p>

<pre><code>template&lt;typename T&gt;
class B
{
public:
    set_value(T&amp; t);
};
</code></pre>

<p>And you would declare it for use using:</p>

<pre><code>B&lt;A&gt; ba;
</code></pre>

<p>As jrok mentioned, you can also make the function itself a template - but the use would depend on how <code>B</code> is using the parameter (e.g. if the type is needed for other functions as well, it would probably be better to make the whole class utilize it).</p>
",1
22488299,22488160,2,"<p>Any name shall be declared before its using. If you do not like the following code</p>

<pre><code>class A;

class B
{
    public:
    void set_classA_val( A &amp;b);
};
</code></pre>

<p>then you can use elaborated type name in the parameter declaration of member function set_classA_val</p>

<pre><code>class B
{
    public:
    void set_classA_val( class A &amp;b);
};
</code></pre>
",0
31256597,31256504,2,"<p><code>cin &gt;&gt; num</code> reads until it sees whitespace, but it doesn't discard the whitespace, so it leaves <code>'\n'</code> in the input.  Your call to <code>getline</code> sees it and immediately returns, filling <code>name</code> with an empty string.  You need to call <code>cin.ignore</code> before <code>getline</code> to ignore the <code>'\n'</code> that <code>cin::operator&gt;&gt;</code> left laying around.</p>
",0
31810549,31810524,2,"<p>You cannot call <code>fun2</code> with <code>aptr</code> because that is a <code>A*</code>, you'd have to cast it first</p>

<pre><code>static_cast&lt;B*&gt;(aptr)-&gt;fun2();
</code></pre>

<p>The <code>virtual</code> function <code>fun1</code> will handle calling the overloaded <code>B::fun1</code> off of <code>aptr</code>, but that does not mean that you can access methods specific to <code>B</code> without casting.</p>
",1
31811577,31810524,2,"<p><code>A</code> does not define a function <code>fun2()</code>, so there is no way to access it via a pointer to an <code>A</code>. What you are expressing in code is:</p>

<p>I have an <code>A</code>, which can do <code>fun1()</code>. I have a <code>B</code> which is an <code>A</code>, but can do <code>fun2()</code> in addition to that. </p>

<p>But just because your <code>B</code> can do <code>fun2()</code>, no other <code>A</code> has to be able to do this.If what you are aiming for was actually possible, all <code>A</code>s would have to be able to do <code>fun2()</code>. Casting down is possible here, but you should probably reconsider your design. The fact that you try to use <code>A</code>, but some <code>A</code>s need different treatment than others violates the <a href=""https://en.wikipedia.org/wiki/Liskov_substitution_principle"" rel=""nofollow"">Liskov Substitution Principle</a>.</p>
",2
31225791,31225742,2,"<p><a href=""http://www.cplusplus.com/reference/cstdio/fopen/"" rel=""nofollow"">fopen</a> is a standard function - this means your code should compile also on other standard conformant platforms - linux, apple, ...</p>

<p>actually <code>fopen</code> under windows will internally call <code>CreateFile</code> so if you dont need any windows specific (non-standard) features, then use <code>fopen</code>.</p>

<p>And since you tagged this question as c++ then, I would suggest using more c++ aproach with <a href=""http://www.cplusplus.com/doc/tutorial/files/"" rel=""nofollow"">fstream</a>.</p>
",1
31226166,31225742,3,"<ol>
<li>There is no defined way for fopen() to return the system error code. There might be an undefined way to access errno, but this might or might not be identical with the system error code.</li>
<li>Also, I don't think that there is an defined way to access the real system handle (of type HANDLE) which in turn you might want to use to pass on to one of the many win64 system calls which expect such a system handle (e.g. memory mapped IO)</li>
<li>Using open() an integer represents the file handle, which is not the system handle (on windows).</li>
<li>fopen() does not throw an exception in case of error. In order to have some RAII you would need to wrap it into a class.</li>
<li>Wrapping CreateFile() into a class, is not more expensive than wrapping fopen() or open() into a class. </li>
<li>Using the C++ feature (std::ofstream, std::ifstream) to write/read to/from files suffers from the same problem as fopen(): 

<ul>
<li>It does not throw by default on error. In order to enable this feature you need to call some method instead of being able to use some constructor argument -- means for RAII you would need to derive this class (in order to use it as a member/base class which throws on error).</li>
<li>It is undefined if one is able to retrieve the system error code from the exception thrown or if the message returned from what() tells you anything about the system error.</li>
<li>Using this stream interface there is no real pluggable interface to define the source or destination of reading from or writing to. Overloading the stream interface is quite cumbersome and error prone.</li>
</ul></li>
<li>Using C like programming (paying attention to or ignoring return codes and manually writing cleanup code) is the source of much evil (remember heart-bleed?)...</li>
</ol>

<p>Conclusions:</p>

<ol>
<li>write a resource wrapper for CreateFile()/CloseHandle(). Resource wrapper is a class, which performs the do-action in the constructor and the undo-action in the destructor and throws an exception in case of error. There are many such pairs of system calls in every OS but especially in Win64.</li>
<li>Write a system error exception class (to be used for the above class in case of CreateFile() fails and for all the other system errors) or investigate, what the new system_exception class (in C++0x) is actually doing and if it is sufficient.</li>
<li>write a functional wrapper for ReadFile() and WriteFile() which converts a system error into a system exception object thrown...</li>
<li>Potentially define your own interface to write to somewhere and read from somewhere so that you can implement other things independent from the type of source/destination to read from/write to.</li>
<li>Writing a cache class which allows you to cache reading from somewhere or writing to somewhere is also child play. Of course the cache class should not know nor care about the source/destination you're writing to/reading from.</li>
</ol>

<p>Don't be scared about these small tasks. You will actually know, what is happening in your code and these little pieces of code should be negligible (in amount of lines of code) compared to the code calling it. Also if you're using RAII for everything, the code calling into these utility classes, will be considerable less compared to when not using RAII and having to use two- or even more-step initialization and considerable less error prone. Replacing these utility classes with equivalent utility classes for other OS is also child play (using open()/close()/read()/write() on UNIXs).</p>

<p>And for the sake of the previous millennia don't read the google programming guidelines!</p>
",1
31226323,31225742,1,"<p>On Windows <code>CreateFile()</code>, in particular <code>CreateFileW()</code>, is better as it at least allows to open files with names containing non-ASCII characters. </p>

<p>Unfortunately <code>fopen()</code> on Windows does not allow you to use UNICODE in names so you are limited only by ASCII. Which is quite limiting as you can imagine.</p>

<p>You can use <code>_wfopen</code> on Windows but it is not standard in the same way as CreateFile.</p>
",0
21568747,21568727,5,"<p>Replace <code>return ""A"";</code> with <code>return 'A';</code></p>

<ul>
<li>Type of <code>'A'</code> ¡ª <code>char</code>, it¡¯s a single ASCII character</li>
<li>Type of <code>""B""</code> ¡ª <code>const char *</code>, it¡¯s a NULL-terminated ASCII string</li>
<li>Type of <code>L'C'</code> ¡ª <code>wchar_t</code>, it¡¯s a single Unicode character</li>
<li>Type of <code>L""D""</code> ¡ª <code>const wchar_t*</code>, it¡¯s a NULL-terminated Unicode string</li>
</ul>
",3
23101008,23100980,2,"<p>This line isn't doing what you think.</p>

<pre><code>if(5.919&lt;a&lt;=12.056 &amp;&amp; 2.340&lt;b&lt;=2.347 &amp;&amp; 2.380&lt;c&lt;=2.648)
</code></pre>

<p>to do what you seem to want, you would need to change it to:</p>

<pre><code>if(5.919&lt;a&amp;&amp; a&lt;=12.056 &amp;&amp; 2.340&lt;b&amp;&amp; b&lt;=2.347 &amp;&amp; 2.380&lt;c&amp;&amp; c&lt;=2.648)
</code></pre>

<p>same for this line:</p>

<pre><code>else if(a&lt;=5.662 &amp;&amp; 2.340&lt;b&lt;=2.438 &amp;&amp; c&lt;=2.16)
</code></pre>

<p>that needs to be changed to:</p>

<pre><code>else if(a&lt;=5.662 &amp;&amp; 2.340&lt;b &amp;&amp; b &lt;=2.438 &amp;&amp; c&lt;=2.16)
</code></pre>

<p>When you write this:</p>

<pre><code>2.340 &lt;b &lt;= 2.347
</code></pre>

<p>what C and C++ understand is <code>(2.30 &lt; b) &lt;= 2.347</code> and that is always true (1 in C) for all values of b because <code>(2.30 &lt; b)</code> is either 0 or 1, which is always less or equal than 2.347. This is arcane and backwards, but it is how C and C++ see the world. I'm sure that this will only bite you once, and this was your turn.</p>

<p>Also, it is bad practice to mix <code>printf</code> and <code>scanf</code> with <code>cin</code> and <code>cout</code>, make a choice about how you want to do your I/O and stick to it, mixing them brings other subtle bugs that are difficult to troubleshoot. </p>

<p>For the final part of your question, you can do:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    char answer[16];
    printf(""Yes or No\n"");
    scanf(""%s"",answer);
    if (strncmp(answer,""Yes"",3)==0){
        printf(""yes\n"");
    }else{
        printf(""no\n"");
    }
}
</code></pre>
",0
23101012,23100980,4,"<p>Unfortunately, while the following is valid syntactically, it does not do what you expect:</p>

<pre><code>5.919&lt;a&lt;=12.056
</code></pre>

<p>This is parsed as <code>(5.919 &lt; a) &lt;= 12.056</code> and works as follows: <code>a</code> is compared to <code>5.919</code>, and the result of that comparison (<code>0</code> or <code>1</code>) is compared to <code>12.056</code>. Since both <code>0</code> and <code>1</code> are less than <code>12.056</code>, the overall expression always evaluates to <code>1</code>.</p>

<p>To fix, rewrite it as:</p>

<pre><code>5.919 &lt; a &amp;&amp; a &lt;= 12.056
</code></pre>

<p>The same goes for all the other similar expressions.</p>
",1
23101130,23100980,0,"<p>For the second part question : 
Change the condition to Y/N instead of 1 and 0. Use character data type, or string or anything similar. And then you can compare the input with ""exit"".</p>
",0
23101147,23100980,2,"<p>For input yes/no, You can use this  way..</p>

<pre><code>char exit;
</code></pre>

<p>// in while loop waiting for user input</p>

<pre><code>exit = getch();
if(exit == 'y' || exit == 'Y' )
    break;
//else again go for input.
</code></pre>
",0
28247098,28247063,2,"<p>This is a typical symptom of the <code>while (!infile.fail())</code> anti-pattern.</p>

<p>I'd define a struct and overload <code>operator&gt;&gt;</code> for that type:</p>

<pre><code>struct item { 
    std::string name;
    std::string unit;
    int amount;
    int price;
};

std::istream &amp;std::operator&gt;&gt;(std::istream &amp;is, item &amp;i) { 
    getline(is, i.name, '-');
    getline(is, i.unit, '-');
    is &gt;&gt; i.amount;
    return is &gt;&gt; i.price;
}
</code></pre>

<p>With those defined, reading the data borders on trivial:</p>

<pre><code>std::ifstream inputFile(""fileNameHere"");

std::vector&lt;New_Item&gt; items { std::istream_iterator&lt;Item&gt;(inputFile),
                              std::istream_iterator&lt;Item&gt;() };
</code></pre>

<p>[I changed it from <code>list</code> to <code>vector</code>, because, well, you really don't want <code>list</code>. You can change it back, but probably shouldn't.]</p>
",0
28247134,28247063,1,"<p>The problem is that the ""fail"" flag is not set until you make an attempt at reading some more data from the file. Here is a quick way of fixing this:</p>

<pre><code>for (;;) {
    //Extract the line from the list
    getline(inputFile,item_name,'-');
    getline(inputFile,item_unit,'-');
    inputFile &gt;&gt; item_amount;
    inputFile &gt;&gt; item_price;
    if (inputFile.fail()) break;
    //Create an instance of the item object
    Item New_Item(item_name, item_unit, item_amount,item_price);
    //Push it to the list vector
    list.push_back(New_Item);
}
</code></pre>

<p>If this is for a learning exercise, and you have not learn the <code>&gt;&gt;</code> operator yet, this should do it. Otherwise, the <code>operator&gt;&gt;</code> approach is better.</p>
",0
26133052,26132985,-1,"<p>Read up on c++ templates. Templated classes.
The following is an example <a href=""http://www.cplusplus.com/doc/tutorial/templates/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/templates/</a></p>
",0
26133249,26132985,0,"<p>Yes, you could replace ItemType with phonebookContact.</p>

<p>Just replace each ItemType with phonebookContact, and #include a header like  phonebookContact.h instead of ItemType.h.  The header phonebookContact.h would need to contain the definition of the phonebookContact class as ItemType.h presumably contains a definition of the ItemType class.</p>
",0
32395841,32395166,0,"<p>Change</p>

<pre><code>const char path[] = ""C:\\*.dmp"";           // C-style string

hFind = FindFirstFile(path, &amp;dataFile);    // Pass the string directly
</code></pre>
",0
32395300,32395166,1,"<blockquote>
  <p>I get a compiler error</p>

<pre><code>Cannot convert const char[9] to std::basic_string
</code></pre>
</blockquote>

<p>You need a <a href=""http://en.cppreference.com/w/cpp/language/character_literal"" rel=""nofollow"">wide char literal</a> to initialize a <code>std::wstring</code> properly:</p>

<pre><code>wstring path = L""C:\\*.dmp"";
            // ^
</code></pre>

<hr>

<p>Also you have missed to put another <code>&lt;&lt;</code></p>

<pre><code>cout &lt;&lt; ""The name of the first found file is "" &lt;&lt; dataFile.cFileName &lt;&lt; endl;`
                                            // ^^
</code></pre>

<p>Also note that <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt"" rel=""nofollow"">output formatting with <code>std::ostream</code></a> is different from <code>printf()</code> format string styles. Note I removed the <code>%s</code> from the above sample.</p>
",4
24102189,24102167,3,"<p>The problems has nothing to do with operators or such: you cannot deduce template arguments for a class defining a nested type from the nested type. The trivial reason is that there is nothing which enforces that the nested type is uniquely nested in just one instantiation. You can call the operator explicitly specifying the non-deducable template argument(s), though.</p>
",0
21773987,21773977,4,"<p>It's <em>scope resolution operator</em> and it says, that the function (<code>open</code> in this case) is in the <em>global namespace</em>.</p>
",0
21773988,21773977,11,"<p>It means ""<code>open</code> from the global namespace"". It is a way to disambiguate with <code>MyClass::open</code>, which is a name that would be picked up if you said <code>open</code> without the leading <code>::</code>.</p>
",0
27763339,27763240,3,"<p>If an exception occurs during the second insertion, catch it, delete the first element inserted, then rethrow.</p>

<pre><code>// insert/emplace returns pair&lt;iterator, bool&gt;
auto insert_result = condition ? myMap.emplace(key, val)
                               : std::make_pair(myMap.end(), false);
try {
    myMap.emplace(anotherKey, anotherVal);
} catch (...) {
    if (insert_result.second) {
        myMap.erase(insert_result.first);
    }
    throw;
}
</code></pre>

<p>Note that this only works if <code>erase</code> doesn't throw. Luckily, the standard guarantees this under a rather mild assumption:</p>

<blockquote>
  <p>For associative containers, no <code>clear()</code> function throws an exception. <code>erase(k)</code> does not throw an exception unless that exception is thrown by the container¡¯s <code>Compare</code> object (if any).</p>
</blockquote>

<p>([associative.reqmts.except]/1 in C++11)</p>

<p>So just make sure your comparison can never throw, and this should work.</p>
",2
29480873,29480673,1,"<p>There are several problems with this code, and the only (correct) way to fix them is to ensure that you use the correct data types in the first place. </p>

<p>So, instead of <code>const char *password = ""password""</code>, use <code>unsigned char password[] = ""password"";</code> (of course, this will probably give you trouble with <code>strlen</code>, since it won't like <code>unsigned char</code>) - using <code>sizeof(password)-1</code> will work in THIS instance, but is ill advised as a general solution, since <code>password</code> may well be not be directly available as an array - not sure quite what you should do as an ""ideal"" solution, really. </p>

<p>Now, the question can be asked whether it is actually correct to have a non-const input to the function. If you have the source for <code>encrypt</code>, you may want to change the function to <code>encrypt(const unsigned char* keydata, size_t keydata_len, const unsigned char* plaintext, size_t plaintext_len, unsigned char* ciphertext)</code> - still doesn't fix the problem with <code>strlen</code> of <code>unsigned char</code> of course, but it's what I'd expect the prototype to be for a function like this.</p>

<p>An alternative would be to rewrite the <code>encrypt</code> function to make casts to <code>unsigned</code> only internally, and use <code>char *</code> inputs (with <code>const</code> where relevant).</p>

<p>Note that it's NOT valid to cast away constness EXCEPT for cases where you know that the original content is not <code>const</code> (which I think is NOT guaranteed to be the case for <code>std::string::c_str()</code>, but <code>std::string::data()</code> should work)</p>
",5
21172947,21172881,2,"<blockquote>
  <p>error C2057: expected constant expression</p>
</blockquote>

<p>You can't declare <code>randomTickets</code> like that because the dimensions of the array need to be known at compile time. <code>tickets</code> is not a compile time constant and therefore you have the error. Consider using <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector&lt;T&gt;</code></a>:</p>

<pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; randomTickets(tickets, std::vector&lt;int&gt;(SIZE));
</code></pre>

<p>Alternatively, you can nest a <code>std::array</code> since <code>SIZE</code> is constant and known at compile time:</p>

<pre><code>std::vector&lt;std::array&lt;int, SIZE&gt;&gt; randomTickets(tickets);
</code></pre>

<p>The other errors are resolved by fixing this one.</p>
",0
21172958,21172881,0,"<p>Variable <code>tickets</code> is not a constant expression, that's why.</p>

<p>Change <code>int randomTickets[tickets][SIZE]</code> as follows:</p>

<pre><code>Array* randomTickets = new Array[tickets];
</code></pre>

<p>Outside of function <code>main</code>, declare the following type:</p>

<pre><code>typedef int Array[SIZE];
</code></pre>

<p>You can use variable <code>randomTickets</code> as a ""normal"" 2-dimensional array from this point onwards, just don't forget to <code>delete[] randomTickets</code> when you're done...</p>
",0
25657484,25657328,0,"<p>I think putting getline() before the If test doesn't allow the latter to executed as the former results in a blocking I/O. Try this:</p>

<pre><code>while (input.empty()) {
    cout &lt;&lt; ""Enter Something"";
    if (GetAsyncKeyState(VK_ESCAPE)) {
        exit(EXIT_SUCCESS);        
    }
    getline(cin, input);
}
</code></pre>
",1
25657506,25657328,2,"<p><code>GetAsyncKeyState</code> is called after calling <code>getline</code>.  <code>getline</code> waits for the user to type some data and press enter (or rather it waits for a line of data ending in a newline to be read from standard input).  Only after <code>getline</code> is done does this code check whether the ESC key was pressed.</p>

<p>See this question for a way to do what you're trying to accomplish: <a href=""https://stackoverflow.com/questions/14214753/how-to-read-until-esc-button-is-pressed-from-cin-in-c"">How to read until ESC button is pressed from cin in C++</a> </p>
",0
26809219,26809175,3,"<p>First, exception is thrown from the constructor of <code>Foo</code>, i.e. before the object is created and assigned to <code>unique_ptr</code>.</p>

<p>Second, a destructor for an object is not going to be called anyway if a constructor did not succeed.</p>
",3
21302624,21302515,2,"<pre><code>#include &lt;iostream&gt;
int main(void) {
    std::cout &lt;&lt; ""11 12 13 14 15 16 17 18 19 20"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""22 24 26 28 30 32 34 36 38 40"" &lt;&lt; std::endl;
    //...
    std::cout &lt;&lt; ""110 120 130 140 150 160 170 180 190 200"" &lt;&lt; std::endl;
}
</code></pre>

<p>If you want to do it with some specific construct (like two nested <code>for</code>-loops looping over the interval 11:20 and 1:10), try and ask so.</p>
",3
21302840,21302515,0,"<p>I hope these will help you,</p>

<pre><code>int main() {
    int i, num;
    num = 11;
    while(num &lt;= 20){
        for(i=1; i&lt;=10; i++){
            std::cout&lt;&lt;num*i&lt;&lt;std::endl;
        }
        num ++;
    }
    return 0;
}
</code></pre>

<p>let me know if any queries?</p>
",2
21302939,21302515,1,"<p>Like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt; // setw

int main()
{
    using namespace std;
    for( int y = 1; y &lt;= 10; ++y )
    {
        cout &lt;&lt; setw(3) &lt;&lt; y &lt;&lt; "": "";
        for( int x = 11; x &lt;= 20; ++x )
            cout &lt;&lt; setw(4) &lt;&lt; x*y;
        cout &lt;&lt; endl;
    }
}
</code></pre>
",0
22133324,22133294,7,"<p>I see two mistakes:</p>

<ul>
<li><code>''''</code> should be <code>'\''</code>.</li>
<li><code>*it &gt; 'A' || *it &lt; 'Z'</code> should be <code>*it &lt; 'A' || *it &gt; 'Z'</code>.</li>
</ul>
",0
21034198,21034150,2,"<p>You're forgetting to reset <code>Duplicate</code> back to <code>false</code>. First time it is set to <code>true</code> it remains <code>true</code>, enabling an infinite <code>do...while</code> loop.</p>
",0
21034205,21034150,1,"<p>Start with an ordered array of 1 to 50, then shuffle it via a <a href=""http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"" rel=""nofollow"">Fisher-Yates shuffle</a>. Then just take the first 10 numbers.</p>
",1
21034290,21034150,1,"<p>Notice that you don't reinitialize Duplicate to false in the beginning of your do-while loop meaning that after you have one duplicate random number - Duplicate is set to true and remains true forever therefore - your do-while loop will run forever.</p>
",0
21181698,21181112,1,"<p>Basically, you're doing Fixed-Point arithmetic here. It looks like you've got a problem where the carry/borrow doesn't propagate from the fractional part to the integer part correctly. (e.g. 5.222 - 0.223) Have you considered this case at all?</p>

<p>Three hints for you: </p>

<ul>
<li>Add a constructor to your class which clears the two arrays. That will avoid you having to do it explictly in the '-' operator or anywhere else.</li>
<li>Consider having one array of digits rather than two, and just inserting/removing the decimal point at the time you input/output the number. This will make your algorithms simpler, and also make the code more maintainable.</li>
<li>don't use 'magic numbers' like <code>20</code> throughout your code. define <code>static const int IntDigits=20;</code> as a private class member, and use that. </li>
</ul>
",0
21181478,21181112,1,"<p>A few issues that I've spotted.
When you do the subtraction for <code>decimal[0]</code> you subtract <code>1</code> from <code>M1</code> while for the other decimals you use <code>this</code>. Likely they both should be the same (probably <code>M1</code> since you don't want to modify the number stored in <code>this</code> when you subtract something from it). Take care that you don't lose the <code>-1</code> later on when you overwrite it with the new digit.</p>

<p>Another thing that you're doing is not handling negative numbers correctly. If you subtract 1 from 0 you code would fill the <code>integer</code> part 9's. This format is called 9's complement and basically to get the negative number you need to extract 9-integer[x] for each digit (including the decimal part). Another way to handle it would be to first compare the two numbers and if the result would be negative swap the operand (the result will be positive now) and change the sign.</p>

<p>The are probably other issues as well. Take a bunch of very simple examples and debug the code.</p>
",0
26225399,26224991,1,"<p>Here's a simple solution, how to split your filename strings by the criteria you specified:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

int main() {
    istringstream filename(""lights042.rgbe"");
    string Name;
    int Num;
    string File;

    while(filename &amp;&amp; !isdigit(filename.peek())) {
        char c;
        filename &gt;&gt; c;
        Name += c;
    }

    filename &gt;&gt; Num;
    filename &gt;&gt; File;

    cout &lt;&lt; ""Name = '"" &lt;&lt; Name &lt;&lt; ""'"" &lt;&lt; endl;
    cout &lt;&lt; ""Num = "" &lt;&lt; Num &lt;&lt; endl;
    cout &lt;&lt; ""File = '"" &lt;&lt; File &lt;&lt; ""'"" &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Output </p>

<pre><code>Name = 'lights'
Num = 42
File = '.rgbe'
</code></pre>

<p>See the <a href=""http://ideone.com/0jvJ1E"" rel=""nofollow"">live demo</a> please.</p>
",0
26449309,26449303,0,"<p>That's a language extension, it's not standard C++.</p>
",0
26449311,26449303,1,"<p>This is a language extension. See <a href=""https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html"" rel=""nofollow""><em>Statement Exprs</em></a>. Don't use it.</p>
",0
28456123,28456075,6,"<p><code>p</code> doesn't point anywhere and you tell it to store value <code>123.0</code>. Where should it go? This is undefined behaviour.</p>

<p>If you want it to point to a constant value in a memory address that will stick around, try</p>

<pre><code>static const double d = 123.0;
const double* p = &amp;d;
</code></pre>

<p>I can't suggest anything more without context of what you are trying to do.</p>
",0
28457271,28456075,1,"<p>Your approach is wrong since <code>double* p;</code> only declares a pointer, but it is uninitialized so when you do <code>*p = 123.0;</code> it triggers an undefined behaviour.</p>

<p>You need to point p to a valid double location so you can modify it.</p>

<p>Neil's answer is partially correct. In his example, you cannot change <code>*p</code> anymore like you do in your question. You need to get rid of the const. In that answer, <code>p</code> points to memory on the stack.</p>

<p>If you want to create a heap-allocated double, you would use the <code>new</code> keyword.</p>

<pre><code>double* d = new double;
*d = 123.0;
</code></pre>

<p>However, you have to make sure to <code>delete</code> this memory after you are done using it.</p>

<pre><code>delete d;
</code></pre>

<p>Since you are using MSVC 2010, which includes some C++11 features, the better way to do the same would be to use <code>unique_ptr</code>. It acts the same as a raw pointer, but it will manage the memory allocated by the pointer ... i.e. it will automatically call delete once it goes out of scope.</p>

<pre><code>unique_ptr&lt;double&gt; d = unique_ptr&lt;double&gt;(new double);
*d = 123.0;
// when d goes out of scope, the memory will be deleted as well
</code></pre>
",0
21585301,21585192,2,"<p>Pretty much ""You can't"", if you mean add members to the class itself. C++ is not a language where you can add stuff to structs or classes at runtime. </p>

<p>I would use a <code>std::map&lt;int, int&gt;</code> (assuming your ""variable"" is storing an integer, and uses an integer as the identififation) to define storage for your variables. </p>

<p>(Of course, you could use <code>std::vector&lt;int&gt;</code> if the numbers are ""close together"" and start at zero or near zero). </p>
",0
22870600,22870503,1,"<p><em><strong>You have not specified OS</em></strong>, so here is a Windows specific answer...  </p>

<p><em><strong>Here</em></strong> are a few ways:</p>

<p>1) use a monitoring service application, that you write yourself to check status of PID/exenames.  When the first app is no longer running, the service application can start the next app. In this way, you can daisy chain as many apps as you like together end to end, or simply bounce back and forth between app 1 &amp; app 2.  <strong><em><a href=""http://code.msdn.microsoft.com/windowsdesktop/CppWindowsService-cacf4948"" rel=""nofollow"">Service App</a></em></strong></p>

<p>2) You can launch the second from a call in the first app just as it exits, and visa versa.</p>

<p>3) Use task scheduler. </p>

<p>There are many other ways,  I personally recommend the first one as I have used it several times, and it works reliably.</p>
",0
22870643,22870503,1,"<p>The <a href=""http://linux.die.net/man/3/exec"" rel=""nofollow""><code>exec</code></a> family of functions replace one running program image with another.  Open files and various other bits of state are preserved, which may or may not be what you want; write glue code as appropriate.</p>
",0
24111153,24111122,0,"<p>You need to change your prototype to this:</p>

<pre><code>std::string Exec(const char* cmd)
</code></pre>

<p>since you want to pass a <code>const char*</code> as an argument.</p>

<p>Otherwise, you can pass a <code>char*</code> as an argument.</p>

<p>That's why your's <code>cout&lt;&lt;Exec(""hello!"")</code> works, because the argument is passed as non-const!</p>
",0
24111187,24111122,3,"<p>Well that's because <a href=""http://www.cplusplus.com/reference/string/string/c_str/"" rel=""nofollow""><code>c_str()</code></a> returns a <code>const char *</code> and not a <code>char *</code></p>

<p>Just change the line to:</p>

<pre><code>const char * c = s.c_str();
</code></pre>

<p>and the function declaration to </p>

<pre><code>std::string Exec(const char* cmd)
</code></pre>

<p>Like noted before and you're good to go.
<a href=""http://ideone.com/mZhyNj"" rel=""nofollow"">See it live here.</a></p>
",0
24111203,24111122,0,"<p>The correct signature for what you're attempting to do would be</p>

<pre><code>std::string Exec(const char* cmd)
</code></pre>

<p>because in either cases you're passing a string constant to it. Even if the <code>Exec(""hello"")</code> case compiles, that doesn't mean it's safe to use:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

std::string Exec(char* cmd) {
    cout &lt;&lt; cmd;
    cmd[0] = 'S'; // Undefined behavior
    cout &lt;&lt; cmd;
    return std::string("""");
}

int main() {
    Exec(""hello"");
    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/ZY6Atr"" rel=""nofollow"">http://ideone.com/ZY6Atr</a></p>
",0
26796969,26796055,-1,"<pre><code>fruit f2 = fruit(fruit(fruit(f1))); 
</code></pre>

<p>I think this one is optimized by your compiler to
    fruit f2 = fruit(f1);
because the compiler notices that you make a copy of a (temporary) copy of a (temporary)copy and that that in the result is the same as just making one copy.</p>

<p>Edit: deleted the statement which was discussed in the comments</p>
",6
26414748,26414443,3,"<p>If you want to write your own <code>initializer_list</code>, that's not possible. By this I mean that you can't achieve the behavior where a line like this</p>
<pre><code>array&lt;int&gt; a = {1, 2, 3, 4};
</code></pre>
<p>would call a contructor like <code>array(my_custom_initializer_list)</code>.</p>
<p>This is because <code>std::initializer_list</code> is a special class which is explicitly mentioned in the C++ standard as the argument type for list-initialization.</p>
<p>The relevant quotes are spread all over the text, but the essential parts are:</p>
<h3>8.5.4/2 List-initialization:</h3>
<blockquote>
<p>A constructor is an <em>initializer-list constructor</em> if its first parameter is of type <code>std::initializer_list&lt;E&gt;</code> or reference to possibly cv-qualified <code>std::initializer_list&lt;E&gt;</code> for some type <code>E</code>, and either there are no other parameters or else all other parameters have default arguments</p>
</blockquote>
<h3>13.3.1.7 Initialization by list-initialization:</h3>
<blockquote>
<p>When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor in two phases:<br />
¡ª Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the argument list consists of the initializer list as a single argument.<br />
¡ª If no viable initializer-list constructor is found, overload resolution is performed again, where the
candidate functions are all the constructors of the class T and the argument list consists of the elements
of the initializer list.</p>
</blockquote>
",0
25499402,25499183,5,"<p>First of all, extra parentheses are not allowed in the functional cast notation. For example</p>

<pre><code>int i1 =  int ();  // compiles
int i2 = (int)();  // doesn't compile
</code></pre>

<p>But your example will not compile even if you omit the parentheses</p>

<pre><code>int* p = int*();   // doesn't compile
</code></pre>

<p>This is because the functional cast notation requires the type name to either be a <em>simple-type-specifier</em> or a <em>typename-specifier</em>.</p>

<p><em>¡ì5.2.3 [expr.type.conv]</em></p>

<blockquote>
  <p><em>1</em> &nbsp; A <em>simple-type-specifier</em> (7.1.6.2) or <em>typename-specifier</em> (14.6) followed by a parenthesized expression-list constructs a value of the specified type given the expression list. <code>...</code><br/>
  <em>2</em> &nbsp; The expression <code>T()</code>, where <code>T</code> is a <em>simple-type-specifier</em> or <em>typename-specifier</em> for a non-array complete object type or the (possibly cv-qualified) <code>void</code> type, creates a prvalue of the specified type, whose value is that produced by value-initializing (8.5) an object of type <code>T</code>; no initialization is done for the <code>void()</code> case.</p>
</blockquote>

<p><em>simple-type-specifier</em> basically means a type name consisting of a single word. The following line does not compile for the same reason</p>

<pre><code>unsigned int i = unsigned int(); // doesn't compile
</code></pre>
",0
33601825,33426892,1,"<p>The overload <code>operator&lt;&lt;(std::ostream&amp;, std::string)</code> is actually defined by <code>#include &lt;string&gt;</code>.</p>

<p>Although <code>std::string</code> is also defined by that header, it is still possible for <code>std::string</code> to be defined but not this operator overload, if you did not include that header.</p>

<p>The C++ standard requires that certain headers provide certain features, but it does not prohibit that feature also being provided by another header. In your case, the compiler/library writer has decided that implementing some other feature in another header was most easily done by defining <code>std::string</code>, but it would have done this by having a separate file defining <code>std::string</code> which is included both by <code>&lt;string&gt;</code> and by the other header.</p>
",0
21774318,21772948,2,"<p>You're missing <code>XLAPIENTRY</code> in your method declarations (before <code>load</code> and <code>save</code>). I suppose it's empty on Linux and expands to something important on Windows.</p>
",0
31292639,31292586,4,"<p>I believe in GCC at least, with <code>-std=c++11</code>, you can do this:</p>

<pre><code>MyClass::MyClass() : alpha{1, 2, 3}
{
    PrintLetters();
}
</code></pre>

<p>This is just an array initialization in the member initialization list. It's a standard C++ feature, but some compilers (<em>cough</em> VC++ <em>cough</em>) might not have implemented it yet.</p>
",5
22127214,22127099,4,"<p>From <a href=""http://msdn.microsoft.com/en-us/en-en/library/hh567368.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/en-en/library/hh567368.aspx</a></p>

<blockquote>
  <p>""Rvalue references v3.0"" adds new rules to automatically generate
  move constructors and move assignment operators under certain
  conditions. However, this is not implemented in Visual C++ in Visual
  Studio 2013, due to time and resource constraints.</p>
</blockquote>
",0
21596414,21596102,0,"<p>Use CONIO.H</p>

<p>You can use functions like:</p>

<p>getch() - reads a character from the console without buffer or echo</p>

<p>kbhit() which determines if a keyboard key was pressed.</p>

<p>to get what you're looking for.</p>

<p>Edit:
This is from user Falcom Momot, for Linux systems:</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;
char getch() {
    char buf = 0;
    struct termios old = {0};
    if (tcgetattr(0, &amp;old) &lt; 0)
            perror(""tcsetattr()"");
    old.c_lflag &amp;= ~ICANON;
    old.c_lflag &amp;= ~ECHO;
    old.c_cc[VMIN] = 1;
    old.c_cc[VTIME] = 0;
    if (tcsetattr(0, TCSANOW, &amp;old) &lt; 0)
            perror(""tcsetattr ICANON"");
    if (read(0, &amp;buf, 1) &lt; 0)
            perror (""read()"");
    old.c_lflag |= ICANON;
    old.c_lflag |= ECHO;
    if (tcsetattr(0, TCSADRAIN, &amp;old) &lt; 0)
            perror (""tcsetattr ~ICANON"");
    return (buf);
</code></pre>

<p>}</p>
",6
22489578,22489523,7,"<p>Since you've tagged this C++, use <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/write"">C++ I/O</a>:</p>

<pre><code>std::cout.write(response, 26);
</code></pre>
",2
33602312,33602266,2,"<p><strong>Problem 1: Loop conditions</strong></p>

<pre><code>for (int i = 0; i &lt;= x; i++)
</code></pre>

<p>It will make an extra <code>*</code>. Imagine, how many integers between 0 and 5, inclusively? There are 6 - 0, 1, 2, 3, 4, 5.</p>

<p>You need to either change your loop to:</p>

<pre><code>for (int i = 0; i &lt; x; i++) { // C++ good practice
</code></pre>

<p>or</p>

<pre><code>for (int i = 1; i &lt;= x; i++) { // not C++ practice
</code></pre>

<p>The first one is a C++ good practice and should be used in almost all cases.</p>

<p><strong>Problem 2: Wrong output</strong></p>

<p>You have the following output:</p>

<pre><code>cout &lt;&lt; ""*"" &lt;&lt; i;
</code></pre>

<p>which will produce something like</p>

<pre><code>*0*1*2*3*4*5
</code></pre>

<p>According to your task, you want to simply output <code>x</code> asterisks.<br>
Then, why do you output <code>i</code>?</p>

<p><strong>Problem 3: Wrong input</strong></p>

<p>You have a string in your <code>cin</code>. It is not a proper syntax. You need to split your output and input and use <code>cout</code> and <code>cin</code>, respectively.</p>

<p><strong>This code should work well:</strong></p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
    int x;
    cout &lt;&lt; ""Enter a number""; 
    cin &gt;&gt; x;

    for (int i = 0; i &lt; x; i++) {
        cout &lt;&lt; ""*"";
    }
    cout &lt;&lt; endl;
}
</code></pre>
",1
27517392,27517190,1,"<p>There are multiple things working even with the code you posted:</p>

<ol>
<li>You need to check if your input was successful before processing any input. Otherwise you could, e.g., end up with empty strings being inserted into your file, probably corrupting its content.</li>
<li>You almost certainly need to put a newline into the target file when appending the new content.</li>
</ol>

<p>That is, your input could, for example, look like this:</p>

<pre><code>std::string fName, lName;
if (std::cout &lt;&lt; ""Insert last name: ""
    &amp;&amp; std::cin &gt;&gt; lName
    &amp;&amp; std::cout &lt;&lt; ""Insert first Name: ""
    &amp;&amp; std::cin &gt;&gt; fName) {
    // now do something with the read values
}
else {
    // deal with the error
}
</code></pre>

<p>The next step is ""insert into a file"": that doesn't work. Sorting a file is bound to work even less! Instead, what you would copy the file to a new destination and insert the record at the opportune location</p>

<ol>
<li>Read each line of the existing file. If the record is smaller than the new record, write it and go to line 1.</li>
<li>Write new record.</li>
<li>Write the already read record.</li>
<li>Copy the remaining content of the original file.</li>
<li>Close both files.</li>
<li>Remove the original file and rename the new file to the name of the original file.</li>
</ol>

<p>I could type out the code but I don't really need exercise with reading/writing files.</p>
",0
23592461,23592368,3,"<p>Of course there is no greate sense to write</p>

<p>cout &lt;&lt; ""Hello""[0] &lt;&lt; endl;</p>

<p>instead of simple</p>

<p>cout &lt;&lt; 'H' &lt;&lt; endl;</p>

<p>However sometimes there is something as</p>

<pre><code>#define Hello ""Hello""
</code></pre>

<p>in some (especially C) programs.</p>

<p>In this case there is some sense to write</p>

<p>cout &lt;&lt; Hello[0] &lt;&lt; endl;</p>

<p>However it would be much better to define</p>

<pre><code>const char *Hello = ""Hello"";
</code></pre>

<p>or</p>

<pre><code>const char Hello[] = ""Hello"";
</code></pre>

<p>There is no difference between</p>

<pre><code>""Hello""[0]
</code></pre>

<p>and</p>

<pre><code>0[""Hello""]
</code></pre>

<p>because according to the C++ Standard</p>

<blockquote>
  <p>The expression E1[E2] is identical (by definition) to *((E1)+(E2))</p>
</blockquote>

<p>However the second record only confuses readers of the code.</p>

<p>As for the conversion then lvalue of string literal ""Hello"" that has type <code>const char[6]</code> is converted to type <code>const char *</code>. and then expression *((E1)+(E2)) is calculated using the pointer arithmetic.</p>
",2
23592468,23592368,0,"<p>It's certainly valid. Very little typecasting is involved.</p>

<p>Consider that the language element <code>""Hello""</code> actually means</p>

<pre><code>  const char * anonymousVariable = ""Hello"";
</code></pre>

<p>Then <code>anonymousVariable[1]</code> yields a char with value <code>'e'</code>, and <code>anonymousVariable[1123]</code> yields something unpredictable. </p>

<p>Is it a good idea to write code this way?  It may or may not be, depending on the pattern you're trying to use.</p>
",0
23592494,23592368,8,"<p>It's not particular common to index literal strings, but it has its uses, e.g.</p>

<pre><code>auto hex_digit( int const value )
    -&gt; char
{
    assert( 0 &lt; value &amp;&amp; value &lt; 0x10 );
    return ""0123456789ABCDEF""[value];
}
</code></pre>
",0
28447044,28447030,1,"<p>booleans are implicitly converted to ints in C++</p>
",0
28447047,28447030,2,"<p><code>true+1</code> is an integer arithmetic operation. <code>true</code> is converted to <code>1</code> and you get <code>2</code>.</p>
",0
28447049,28447030,3,"<p>From the standard:</p>

<p>According to 4.7 (Integral conversions), </p>

<blockquote>
  <p>4 If the destination type
  is bool, If the source type is bool, <strong>the value false is
  converted to zero and the value true is converted to one</strong>.</p>
</blockquote>

<p>In 4.12,</p>

<blockquote>
  <p>An rvalue of arithmetic, enumeration, pointer, or pointer to member
  type can be converted to an rvalue of type bool. A zero value, null
  pointer value, or null member pointer value is converted to false; any
  other value is converted to true.</p>
</blockquote>

<p>So <code>true + 1</code> means <code>1 + 1</code> and <code>false + 1</code> means <code>0 + 1</code>.</p>
",1
28447446,28447030,1,"<p>In the declaration</p>

<pre><code>bool x = true + 1;
</code></pre>

<p><code>true</code>is first promoted to <code>int</code>; then the addition produces 2; finally the 2 is converted to <code>true</code> by the rule that any basic type value <code>X</code> converts to <code>(X != 0)</code>.</p>

<p>The above also covers update expressions such as <code>x += 1</code> when <code>x</code> is of type <code>bool</code>, because <code>+=</code> is <em>defined</em> in terms of <code>=</code> and <code>+</code>.</p>

<p>However, the use of postfix or prefix <code>++</code> on <code>bool</code> is deprecated. And the use of postfix of prefix <code>--</code> is invalid. Quoting the <sup>1</sup>Holy Standard, &ldquo;the operand shall not be of type <code>bool</code>.&rdquo;.</p>

<p><hr>
<sup><sup>1</sup>) C++11 ¡ì5.3.2/2 in [expr.pre.incr] and ¡ì5.2.6/2 in [expr.post.incr].</sup></p>
",0
27120748,27120490,1,"<p>try with this => put </p>

<pre><code>int temp;
cin&gt;&gt;temp;
</code></pre>

<p>before <code>return 0;</code> to pause the program, because the execution finished (successfully) before the last output could be written to the console.</p>
",1
27120866,27120490,1,"<p>You should put <code>using namespace std;</code> outside of all function declarations, right under your <code>#include</code> directives.  Also, when you say it's not printing, is it that the console is closing before displaying your result?  In that case, I would advocate using a simple <code>cin</code> to ""pause"" the program.  You can do it  exactly as @Nihar says, though I might suggest using a <code>string</code> instead of an <code>int</code> so that it doesn't break if you accidentally type something other than an <code>int</code>.</p>

<p>Something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

double treble(double);

int main(){
    cout &lt;&lt; ""Enter a number:"" &lt;&lt; endl;

    double numways;
    cin &gt;&gt; numways;

    numways = treble(numways);

    cout &lt;&lt; ""Your number trebled is: "" &lt;&lt; numways &lt;&lt; endl;

    string foo;
    cin &gt;&gt; foo;
    return 0;
}

double treble(double n){
    return n * 3;
}
</code></pre>
",4
31885103,31884346,0,"<p>As commented in your question your code is wrong. First you are treating std::string object, returned by getline, as character array. Secondly your for loops never end if there is no <code>//</code> or <code>\n</code> found in input string. So obviously it will crash. Below is the modified code.</p>

<pre><code>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    string str;

    while(getline(cin,str))    {
    int i;
       // cout&lt;&lt;str;

    size_t len = str.length();
    const char *cstr = str.c_str();
    for(i=0; (cstr[i]!='/' &amp;&amp; cstr[i+1] !='/' &amp;&amp; i &lt; len); i++)
        //cout&lt;&lt;i;
    for(; cstr[i]!='\n' &amp;&amp; i &lt; len;i++) {
       // cout&lt;&lt;i;
        cout&lt;&lt;cstr[i];
    }
        cout&lt;&lt;endl;

    }
    return 0;
}
</code></pre>
",1
31885210,31884346,0,"<pre><code>int main() {
    while(getline(cin,str)) {
        int i, len = str.size();

        //always make sure that you are not accessing
        //contents after your string has ended
        for(i=0; i &lt; (len - 1) &amp;&amp; !(str[i] == '/' &amp;&amp; str[i+1] == '/'); i++);

        //note that i here might be the last alphabet
        //if there's no comment
        if(i &lt; len &amp;&amp; str[i] != '/')
            i++;


        //checking if str[i] != '\n' is not a good idea
        //as c++ stl strings are not temrinated by '\n'
        if(i &lt; len) {
            for(; i &lt; len; i++)
                cout &lt;&lt; str[i];
            cout &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>

<p>Also  note that both of the following codes won't terminate at the 4th character, c++ stl strings are not terminated by these characters.</p>

<pre><code>string str = ""hahahaha"";
str[4] = '\n';
cout &lt;&lt; str;

str[4] = '\0';
cout &lt;&lt; str;
</code></pre>
",2
31885970,31884346,0,"<p>This is much easier to write and probably much faster than the other solutions to date.</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    std::string str;

    while (std::getline(std::cin, str))
    {
        size_t loc = str.find(""//"");
        if (loc != str.npos)
        {
            std::cout &lt;&lt; str.substr(loc + 2)&lt;&lt; std::endl;
        }
    }
    return 0;
}
</code></pre>

<p>It is also wrong. </p>

<p>Here is a nice, clean, and simple state machine version. Also pretty close to worst-case for speed. Thing is it's closest to being right, even though it is also wrong. </p>

<pre><code>#include &lt;iostream&gt;
enum states
{
    seeking1,
    seeking2,
    comment
};

int main()
{
    std::string str;

    while (std::getline(std::cin, str))
    {
        states state = seeking1;
        for (char ch:str)
        {
            switch (state)
            {
                case seeking1:
                    if (ch == '/')
                    {
                        state = seeking2;
                    }
                    break;
                case seeking2:
                    if (ch == '/')
                    {
                        state = comment;
                    }
                    else
                    {
                        state = seeking1;
                    }
                    break;
                case comment:
                    std::cout &lt;&lt; ch;
                    break;
            }
        }
        if (state == comment)
        {
            std::cout &lt;&lt; std::endl;
        }
    }
    return 0;
}
</code></pre>

<p>Why are these approaches all wrong? Consider the line </p>

<pre><code>cout &lt;&lt; ""Hi there! I am \\Not A Comment!"" &lt;&lt; endl;`
</code></pre>

<p>You can't just look at the <code>\\</code>, you also need the context. This is why the state machine above is the better option. It can be modified to handle, at the very least, states for handling strings and block comments.   </p>
",0
28220064,28220018,9,"<p>Yes:</p>

<pre><code>my_list.emplace_back();
</code></pre>

<p>Will pass its arguments (none in this case) to the <code>heavy_struct</code> object being constructed in-place in the list.</p>
",0
28220080,28220018,1,"<p>You could use a list of pointers to your heavy struct, thus changing the heavy deep copy to a pointer asignment</p>

<pre><code>std::list&lt;heavy_struct*&gt; my_list;
</code></pre>

<p>If you don't want to handle memory management either, go with shared pointers instead of raw ones.</p>
",0
26432535,26432163,2,"<p>You can use <a href=""http://cdecl.org/"" rel=""nofollow"">cdecl</a> and substitute an arbitrary type for the ellipse, such as <code>int</code>:</p>

<pre><code>char (&amp;f(int)) [2]
</code></pre>

<p>Leads to</p>

<blockquote>
  <p>declare <code>f</code> as function (<code>int</code>) returning reference to array 2 of <code>char</code>  [¡­]</p>
</blockquote>

<p>Substitute back and you have your declaration in words.</p>
",0
26432376,26432163,3,"<p>It is a function declaration that has varying number of parameters and returns a reference to a character array of two elements.</p>

<p>It could be declared simpler by using a typedef. For example</p>

<pre><code>typedef char char_array[2];

char_array &amp; f( ... );
</code></pre>
",0
26432888,26432163,2,"<pre><code>char (&amp;f(...))[2];
</code></pre>

<p>This is the declaration of a function returning a reference to an array of two characters. The parenthesis are needed for this to be syntactically correct. Otherwise the <code>&amp;</code> will bind to <code>char</code> and there will be a syntax error because of <code>[2]</code> being meaningless.</p>

<p>The syntax can be decomposed with a type alias. For example:</p>

<pre><code>using array_ref = char (&amp;)[2];
array_ref f(...);
</code></pre>

<p>The reason for returning a reference to an array rather than an actual array is because of the fact that arrays cannot be returned from functions. It's impossible. You can only return references or pointers to arrays, just like functions.</p>

<p>In all examples, <code>...</code> is a C <a href=""http://en.cppreference.com/w/cpp/language/variadic_argments"" rel=""nofollow"">variadic argument pack</a>.</p>

<hr>

<p>The only places where I've seen this kind of syntax is where it's being used as part of function overload resolution for <a href=""http://en.cppreference.com/w/cpp/language/sfinae"" rel=""nofollow"">SFINAE</a>. Usually this function accompanies an overload of the same name that uses template substitution to check an attribute of a given type. If a substitution failure occurs the second overload (the one that takes a variadic pack) is chosen as the fallback. Its return type is what differentiates success or failure.</p>

<p>For example, here's trait class that checks if a type has a member function <code>f()</code>:</p>

<pre><code>template &lt;typename T&gt;
struct has_f
{
private:
    using true_type  = char (&amp;)[1];
    using false_type = char (&amp;)[2];

    template &lt;typename U&gt;
    static decltype(std::declval&lt;U&gt;().f(), true_type()) f(int);

    template &lt;typename&gt;
    static false_type f(...);
public:
    static constexpr bool value = sizeof(check&lt;T&gt;(0)) == 1;
};
</code></pre>

<p>As you can see, if <code>T</code> has a member function <code>f()</code>, then the size of the type returned will be <code>1</code>, otherwise <code>2</code>. <code>true_type</code> and <code>false_type</code> are largely superseded by the standard traits classes <code>std::true_type</code> and <code>std::false_type</code> these days, but this is simply an example to illustrate its use.</p>
",0
32465149,32465109,1,"<p>It depends what you men by breaking encapsulation. Generally all operations perfomed on class members outside of the class may be considered as breaking class encapsulation.</p>

<p>For example getters that return <code>non-const</code> reference may be considered as breaking encapsulation because they expose private class members in such way, that you can freely modify them and there is little controll over this process.</p>
",0
32465185,32465109,1,"<p>Yes, there are. If the class has a public template member function, you can specialize it for a type of yours, and do whatever you want inside it.</p>

<p>There is a book by Herb Sutter that discusses this and other possibilities. IIRC, this is the only one that has standard conformance.</p>
",0
32465331,32465109,0,"<p>Anything you can do in <code>C</code> is also possible in <code>C++</code>.</p>

<p>You can take a pointer to the class, cast it to <code>char *</code>, treat it as an array and start overwriting the memory with whatever you like, adjusting all the private member variables. You can do this even if someone is using the pImpl idiom to try to hide those variables from you.</p>

<p>Doing things like that is generally a sign of code smell and great evil... the road to hell is paved with good intentions, they say. :)</p>

<p>But in general, when you make a variable or a function private, you are really saying ""please don't touch this"". The next programmer to come along can always do more or less whatever they want, without modifying your class definition. The features ""private"" and ""public"" really are just statements of intent, and a way to inconvenience someone who wants to go against your intent, and a guide to someone who isn't sure where they should be looking for something. It's like the locks on the door to your house -- anyone who is determined can get in anyways.</p>
",1
32465419,32465109,3,"<p>I would say that <code>friend</code> does not break encapsulation. See <a href=""https://isocpp.org/wiki/faq/Friends#friends-and-encap"" rel=""nofollow"">https://isocpp.org/wiki/faq/Friends#friends-and-encap</a></p>

<p>Now let's ignore the issue of what ""encapsulation"" actually means. It is generally possible to access private members using a template specialization hack. The basic idea, for when the class has a member template, is explained in <a href=""http://www.gotw.ca/gotw/076.htm"" rel=""nofollow"">http://www.gotw.ca/gotw/076.htm</a>.</p>

<p>This approach can be extended to access any private data member or private member function of a class, even if the class contains no templates. See <a href=""http://bloglitb.blogspot.com/2010/07/access-to-private-members-thats-easy.html"" rel=""nofollow"">http://bloglitb.blogspot.com/2010/07/access-to-private-members-thats-easy.html</a> and <a href=""http://bloglitb.blogspot.com/2011/12/access-to-private-members-safer.html"" rel=""nofollow"">http://bloglitb.blogspot.com/2011/12/access-to-private-members-safer.html</a>.</p>
",0
25497574,25497551,0,"<p>That assertion will never fire given the two lines of code that you've shown.</p>
",0
25497579,25497551,1,"<p>Yes.</p>
<p>From <a href=""http://en.cppreference.com/w/cpp/container/map/operator_at"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/container/map/operator_at</a></p>
<blockquote>
<p>Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist.</p>
<p>If an insertion is performed, the mapped value is value-initialized (default-constructed for class types, zero-initialized otherwise) and a reference to it is returned.</p>
</blockquote>
",0
25497583,25497551,2,"<p>When inserting into a <a href=""http://en.cppreference.com/w/cpp/container/map"" rel=""nofollow""><code>std::map</code></a> using the <a href=""http://en.cppreference.com/w/cpp/container/map/operator_at"" rel=""nofollow""><code>operator[]</code></a> function, the data will be <a href=""http://en.cppreference.com/w/cpp/language/value_initialization"" rel=""nofollow"">value initialized</a>, and value initialization for pointers will make them zero (i.e. null pointers).</p>
",0
25500647,25497551,1,"<p>Two Answer could be answered:</p>

<p>If you want to verify that an key is empty without create it, it'would be better to check with a itterator: <code>map.find(KEY) != map.end()</code></p>

<p>If you want to create an empty row for a key in your map it would be like you specified it <code>map[KEY]</code></p>
",0
21596766,21596714,2,"<p>You can use union with type code or boost::variant</p>
",0
21596789,21596714,1,"<p>I would recommend for now that you should make a parent class and put as children all of the A,B,C,etc... Then in class use a list of the parent class, and put whatever subclass you need on it. But having this problem is actually due to wrong object oriented design. Learn the principles of OO design of a system in Java for example and then put them in use in C++.</p>
",0
21596972,21596714,0,"<p>Admitting you cannot rework your classes, and admitting you are using only one at time, you can use a union plus an ID or a ""dynamically typed void*"":</p>

<pre><code>unsigned gen_id()
{ static unsigned id=0; ++id; return id; }

template&lt;class T&gt;
unsigned id_of()
{ static id = gen_id(); return id; } 

class a
{
   void* m;
   unsigned type;

public:
   template&lt;class T&gt;
   a(T* p) :m(p), type(id_of&lt;T&gt;()) 
   {}

   template&lt;class T&gt;
   T* get() const
   { return (id_of&lt;T&gt;()==type)? static_cast&lt;T*&gt;(m): nullptr; }
};
</code></pre>

<p>You can access a data as</p>

<pre><code>A* pa = my_a.get();
if(pa) { /* what has to be done with A */ }
</code></pre>

<p>If you need more than one, consider a class b holding a vector of a.</p>

<p>For a more ""standardized"" implementation you can look at <a href=""http://www.boost.org/doc/libs/1_55_0/doc/html/any.html"" rel=""nofollow"">boost::any</a></p>
",1
32399552,32399500,1,"<p>Problem is, that you function receives reference to <code>FileName</code>, but you are trying to pass <code>rvalue</code> to it. It's incorrect, temporary value cannot be binded to <code>lvalue-reference</code>, change parameter to <code>const reference</code>, or create <code>FileName</code> object and pass it.</p>
",1
24128519,22366439,4,"<p>You can do:</p>

<pre><code>SQLCHAR c[256];
string str((const char*)c);
</code></pre>
",0
32411702,32410738,4,"<p>The point here is that if you write compiler test-code, you probably will want to test calling <code>main</code> with a few different parameter sets and that it is possible to do this, with the understanding of the compiler you are going to test on. </p>

<p>The standard forbids calls to <code>main</code> so that <code>main</code> can have magical code (e.g. the code to construct global objects or to initialize some data structure, zero out global uninitialized POD data, etc.). But if you are writing test code for a compiler, you probably will have an understanding of whether the compiler does this - and if so, what it actually does in such a step, and take that into account in your testing - you could for example ""dirty"" some global variable, and then call main again and see that this variable is indeed set to zero again. Or it could be that <code>main</code> is indeed not callable in this particular compiler.</p>

<p>Since Chandler is talking about LLVM (and in C terms, Clang), he knows how that compiler produces code for <code>main</code>. </p>

<p>This clearly doesn't apply to ""black box testing"" of compilers. In such a test-suite, you could not rely on the compiler doing anything in particular, or NOT doing something that would harm your test.</p>

<p>Like ALL undefined behaviour, it is not guaranteed to work in any particular way, but SOMETIMES, if you know the actual implementation of the compiler, it will be possible to exploit that behaviour - just don't consider it good programming, and don't expect it to work in a portable way. </p>

<p>As an example, on a PC, you can write to the text-screen (before the MMU has been configured at least) by doing this:</p>

<pre><code> char *ptr = (char *)0xA0000;
 ptr[0] = 'a';
 ptr[1] = 7;   // Determines the colour. 
</code></pre>

<p>This, by the standard, is undefined behaviour, because the standard does say that you can only use pointers to allocations made inside the C or C++ runtime. But clearly, you can't allocate memory in the graphics card... So technically, it's UB, but guess what Linux and Windows do during early boot? Write directly to the VGA memory... [Or at least they used to some time ago, when I last looked at it]. And if you know your hardware, this should work with every compiler I'm aware of - if it doesn't, you probably can't use it to write low-level driver code. But it is undefined by the standard, and ""UB sanitizer"" will probably moan at the code.</p>
",0
26248508,26248439,3,"<p>Get rid of your <code>temp</code> variable:  you should never return a pointer to a local variable within a function, because by the time the caller receives the returned pointer, the variable it points to has gone out of scope.  Instead, you should return a pointer to one of the elements in the the <code>a</code> array.</p>

<p>An overview of the algorithm to use:</p>

<ul>
<li>Initialize <code>ptr</code> to <code>NULL</code>.  This is the default value, until it's changed by checking at least one number in the array.</li>
<li>Iterate through the array with a loop.  (If the array is empty, i.e. <code>size</code> is 0, the loop will run zero times.)</li>
<li>Each time through the loop, if <code>ptr</code> is <code>NULL</code> <em>or</em> the value that it points to (i.e. <code>*ptr</code>) is less than the current array element, change <code>ptr</code> to point to the current array element.  This'll make it point to the first value initially, and then modify it to point to a different element whenever a greater one is found.</li>
<li>When the loop finishes, <code>ptr</code> points to the greatest element in the array that was found by the loop.  If the loop didn't run any iterations (because <code>size</code> is 0), <code>ptr</code> is still <code>NULL</code>.  Either way, this is the result you want, so return it.</li>
</ul>
",4
26248691,26248439,0,"<p>You need to initialize ptr to NULL to take care of the case when array contains no element. For all other cases, it iterates through the array, to find out pointer to the max element and returns that. Also, In the program snippet, if the last element in the array is the largest, it does not compute pointer to that. Because, when the loop ends at i == (size-1), a[i+1] will cause array index to go out of bounds, risky. Here's the corrected version:</p>

<pre><code>const double * pMax(const double a[], size_t size){
 const double * ptr = (size == 0) ? NULL : &amp;a[0];
 for(size_t i = 1; i &lt; size -1; i++){
  if (a[i] &gt; *ptr){
    ptr = &amp;a[i];
  }
 }      
 return ptr;
}
</code></pre>
",0
23067330,20165036,2,"<p><a href=""http://akrzemi1.wordpress.com/2011/06/10/using-noexcept/"" rel=""nofollow"">This article</a> seems to imply that <em>some</em> compilers can in <em>some cases</em> optimize based on this information. I imagine that the compiler can avoid some amount work but only in highly specific cases.</p>

<p>That same article seems to suggest that <em>not</em> explicitly using the keyword is a fine path to choose because of how specific the use case is.</p>
",0
22131998,22131922,0,"<p>Parse strings using a regex parser. As you are doing C++, include the <code>&lt;regex&gt;</code> header, and use the function <code>regex_search</code> to match results. The results go into a <code>smatch</code> object, which is iteratable.</p>

<p>Reference: <a href=""http://www.cplusplus.com/reference/regex/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/regex/</a></p>

<p>Also see: <a href=""https://stackoverflow.com/questions/12908534/retrieving-a-regex-search-in-c"">Retrieving a regex search in C++</a></p>
",0
22132093,22131922,0,"<p>If I were you, I'd use an XML library (if this is actually XML). This is one of the things you certainly don't want to reinvent but <em>reuse</em>! :)</p>

<p>In the past, I've successfully used <a href=""http://www.grinninglizard.com/tinyxml/"" rel=""nofollow"">TinyXML</a> for smaller projects. Or google ""c++ xml library"" for alternatives.</p>
",1
22132233,22131922,0,"<p>Using <a href=""http://www.boost.org/doc/libs/1_55_0/libs/regex/doc/html/index.html"" rel=""nofollow""><em><code>Boost-Regex</code></em></a>, you can use something like following in your function</p>

<pre><code>/* std::string line = ""&lt;image source= \
     \""tileset/grass-tiles-2-small.png\"" width=\""384\"" height=\""192\""/&gt;"";
*/

boost::regex expr (""width=\""(\\d+)\"""");
boost::smatch matches;

if (boost::regex_search(line, matches, expr)) 
{
    std::cout &lt;&lt; ""match: "" &lt;&lt; matches[1] &lt;&lt; std::endl;
}
</code></pre>
",2
22132515,22131922,1,"<p>This is your file:</p>

<pre class=""lang-none prettyprint-override""><code>&lt;image source=""tileset/grass-tiles-2-small.png"" width=""384"" height=""192""/&gt;
</code></pre>

<p>And since all you're interested in is the <code>width</code>, we should first get the entire line:</p>

<pre><code>if (std::getline(file, line))
{
</code></pre>

<p>Now we need to find <code>width</code>. We do that using the <code>find()</code> method:</p>

<pre class=""lang-c++ prettyprint-override""><code>    std::size_t pos = line.find(""width"");
</code></pre>

<p>The string inside <code>find()</code> is the value we want to look for. </p>

<p>Once we check if it found this position:</p>

<pre class=""lang-c++ prettyprint-override""><code>    if (pos != std::string::npos)
    {
</code></pre>

<p>We need to put it into a <code>std::stringstream</code> and parse out the data:</p>

<pre><code>        std::istringstream iss(line.substr(pos));
</code></pre>

<p>The <code>substr()</code> call is used to select a subsequence of the string. <code>pos</code> is the position where we found <code>""width""</code>. So far this is what is inside the stringstream:</p>

<pre class=""lang-none prettyprint-override""><code> width=""384"" height=""192""/&gt;
</code></pre>

<p>Since we don't actually care about <code>""width""</code> but rather with the number inside the quotes, we have to <code>ignore()</code> everything before the quotes. That is done like this:</p>

<pre><code>        iss.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '""');
</code></pre>

<p>Now we use the extractor to extract the integer:</p>

<pre class=""lang-c++ prettyprint-override""><code>        int width;

        if (iss &gt;&gt; width)
        {
            std::cout &lt;&lt; ""The width is "" &lt;&lt; width &lt;&lt; std::endl;
        }
</code></pre>

<p>I hope this helps. Here's a full example of the program:</p>

<pre class=""lang-c++ prettyprint-override""><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

void parseFile(const std::string&amp; mfName)
{
    std::ifstream file(mfName);
    std::string line;

    if (std::getline(file, line))
    {
        auto pos = line.find(""width"");
        if (pos != std::string::npos)
        {
            std::istringstream iss(line.substr(pos));
            int width;

            if (iss.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '""') &amp;&amp;
                iss &gt;&gt; width)
            {
                std::cout &lt;&lt; ""The width is "" &lt;&lt; width &lt;&lt; std::endl;
            }
        }
    }
}
</code></pre>
",3
22880202,22880087,2,"<p>This whole question comes down to ""Why would I use friends in C++?"". The answer is that when used properly, friends enhance encapsulation. This is an FAQ:</p>

<p><a href=""http://www.parashift.com/c++-faq/friends-and-encap.html"" rel=""nofollow"">Do friends violate encapsulation? </a></p>

<p>Your example is too short and too abstract, of course. Some better, real life examples I could think of from the top of my head involve iterators. You may have <em>many iterator objects</em> referring to only <em>one container object</em>, and you may want the iterator to be able to access private member variables of the container. At the same time, you don't want the container to expose those variables to the rest of the world.</p>

<p>Such a design could be perfectly implemented with the <code>friend</code> feature.</p>
",2
22880233,22880087,0,"<p>Many people defend that making accessor methods, you can in a later stage of development put barriers to the incorrect access to the member variables (or even change the member variables totally) without breaking your (correct) clients.</p>

<p>One classical case is of a</p>

<pre><code>class ComplexNumber {
  double real, imaginary;
public:
  double re() { return re; }
  double setRe(double v) { return re = v; }
// and so on ...
};
</code></pre>

<p>one day you discover, in some maintenance, that you need the polar coordinates for that number, so you add the methods</p>

<pre><code>  double rho() { /* calculate rho */ }
  double theta() { /* calculate theta */ }
  double setRho(double v) { /* calculate real, imaginary, based on the new rho */ }
</code></pre>

<p>and so on.</p>

<p>Later yet, you discover that the users of the class use far more often polar than Cartesian coordinates for complex numbers, and that <em>the conversions have been the bottleneck of a performance problem</em>, so you ditch <code>real</code> and <code>imaginary</code> and store <code>rho</code> and <code>theta</code>,  and change the getter and setter methods for the new -- more efficient -- storage for <code>rho</code>, <code>theta</code>, <code>re</code>, <code>im</code>, and so on. All the clients of your class will recompile without problems, because you changed your implementation but kept your interfaces stable.</p>
",3
22880163,22880087,3,"<p>As <a href=""http://www.parashift.com/c++-faq/member-vs-friend-fns.html"" rel=""nofollow"">the C++ FAQ says</a>: <strong>Use a member when you can, and a friend when you have to.</strong></p>

<p>There are situations where making <code>friend</code> a free function is preferable, most situations related to the fact that <strong>the first parameter of a member function is always of that class</strong> (Its the hidden <code>*this</code> parameter).</p>

<p>One example is arithmetic operators overloading:<br>
Suppose you write a <code>complex</code> class which represents complex numbers. Using a member <code>operator+()</code> you could write expressions like <code>complex + float</code>, but not  <code>float + complex</code>. But you could do it with the free form of the <code>operator+</code>:</p>

<pre><code>class complex
{
    ...
    friend complex operator+( float f , complex c );
};
</code></pre>
",0
26442554,26442529,1,"<p>It just declares and initializes a variable of type a pointer to an array of pointers to char.</p>
",0
26442563,26442529,1,"<p>The rule of thumb with C types is that the declaration of the variable resembles how the variable is used. In this instance, <code>*(*ptr)[0]</code> (that is, <code>*((*ptr)[0])</code>) is <code>M</code>.</p>
",0
22107245,22107163,1,"<p>Where you call <code>computeGPA</code>, you don't pass any parameters:</p>

<pre><code>double gpa = student.computeGPA();
</code></pre>

<p>...but in the header, where you've declared <code>Student::computeGPA()</code>, you specify it as taking a parameter:</p>

<pre><code>double computeGPA (const Student&amp; aStudent);
</code></pre>

<p>...therefore, the call and the function don't match, and the compiler tells you it can't find a function that matches a call passing no parameters.</p>

<p>Likewise, where you call <code>addGrade</code> you pass two parameters, but the declaration says it expects three.</p>

<p>At a guess, you probably want to eliminate the <code>Student &amp;</code> parameters--member functions will normally act on the object on which you invoked them.</p>
",0
22107300,22107163,0,"<p>Your definitions for your Student class' functions are strange, and this strangeness I believe caused you to implement them incorrectly as well as call them incorrectly.  When you have a member function, you don't need to pass it itself, so you can omit that part.  These lines in <code>student.h</code>:</p>

<pre><code>double computeGPA (const Student&amp; aStudent);
void addGrade(const Student&amp; aStudent, std::string grade, int credits);
</code></pre>

<p>Should likely be:</p>

<pre><code>double computeGPA ();
void addGrade(std::string grade, int credits);
</code></pre>

<p>Then, in the implementation of them, you should replace <code>aStudent.</code> with <code>this-&gt;</code>.  You have the following (note that addGrade is missing <code>const</code> on its <code>Student</code> parameter, but it doesn't matter cause we're gonna delete it):</p>

<pre><code>void Student::addGrade(Student&amp; aStudent, string grade, int credits) {
  aStudent.credits += credits;
  double v = findGradeValue(gradeValues, 11, grade);
  aStudent.qp += credits * v;
}
double Student::computeGPA(const Student&amp; student) {
  if (credits &gt; 0)
      return aStudent.qp / aStudent.credits;
  else
      return 0.0;
}
</code></pre>

<p>consider changing them to:</p>

<pre><code>void Student::addGrade(string grade, int credits) {
  this-&gt;credits += credits;
  double v = findGradeValue(gradeValues, 11, grade);
  this-&gt;qp += credits * v;
}
double Student::computeGPA() {
  if (credits &gt; 0)
      return this-&gt;qp / this-&gt;credits;
  else
      return 0.0;
}
</code></pre>
",2
28441646,28441633,6,"<p>Yes, there is:</p>

<pre><code>Foo(int x, int y) {
    this-&gt;x = x;
    this-&gt;y = y;
}
</code></pre>

<p>Here <code>x</code> and <code>y</code> hide the member variables, but you can use <code>this-&gt;x</code> and <code>this-&gt;y</code> to access them.</p>
",0
28441682,28441633,2,"<p>The idiomatic way is to use the initialization list:</p>

<pre><code>Foo(int x, int y) : x(x), y(y) {}
</code></pre>

<p>Of course, if for whatever reason you want to access the hidden data members in the body of the constructor, you can use the <code>this</code> pointer:</p>

<pre><code>Foo(int x, int y) {
    this-&gt;x = x;
    ....
</code></pre>
",0
28441683,28441633,1,"<p>In C++11, the preferred way to do this is</p>

<pre><code>class Foo{
    int x;
    int y;

public:
    Foo(int x, int y): x{x}, y{y}{}
};
</code></pre>

<p>Or the traditional way , </p>

<pre><code>class Foo{
    int x;
    int y;
public:

    Foo(int x, int y): x(x), y(y){}
};
</code></pre>
",4
28455628,28441633,1,"<p>If you are trying to observe scope rules and also maintain clarity, you can always use the class scope operator while assigning the variables</p>

<pre><code>class Foo{
public:
    int x;
    int y;
    Foo(int x, int y);
};

Foo(int x, int y) {
   Foo::x = x;
   Foo::y = y;
}
</code></pre>
",0
21038325,21038226,2,"<blockquote>
  <p>if(!x)</p>
</blockquote>

<p>is ""if x is not false"", that means that in order to evaluate that, you might have to cast x to a bool. </p>

<p><strong>>></strong> This can be harmful and if you wish to avoid it you should use something like the <a href=""http://en.wikibooks.org/wiki/More_C++_Idioms/Safe_bool"" rel=""nofollow noreferrer"">Safe Bool Idiom</a></p>

<hr>

<blockquote>
  <p>if(x!=0)</p>
</blockquote>

<p>means ""if x is not 0"", so that is evaluated comparing x to 0. That might also involve an implicit conversion.</p>

<p><strong>>></strong> Be careful when using pointers this way, C++11 introduces a <strong>nullptr</strong> to avoid the confusion of <em>NULL==0</em> (semantically different): <a href=""https://stackoverflow.com/questions/1282295/what-exactly-is-nullptr"">What exactly is nullptr?</a></p>
",0
21038529,21038226,1,"<p><strong>Take into account what are you going to process</strong></p>

<p>If it is a <em>boolean</em>, the results are pretty clear:</p>

<pre class=""lang-c prettyprint-override""><code>if (!false)   // If false TRUE
if (false==0) // If false TRUE
</code></pre>

<p>If it is an <em>integer</em>, pay attention to the <code>!</code> condition</p>

<pre><code>if (0==0) // Unexpected behaviors are missing..

if (!-1) // False
if (! 0) // True
if (! 1) // False
</code></pre>

<p>For <em>chars</em> both conditions give me the same results:</p>

<pre><code>if (! ' ')  // nothing
if (' '==0) // nothing

if (! 'z')  // nothing
if ('z'==0) // nothing
</code></pre>
",0
21038269,21038226,0,"<p>No this all depends on the type of x. For example,</p>

<p><code>if(cin)</code></p>

<p>is used in the stl to check if an iostream type hasn't had an error. There is no equivalent cin != 0.</p>

<p>Besides most operators are overloadable and conversions too.</p>
",6
21038311,21038226,0,"<p>Simply <strong>!x</strong> will return true for every ""false"" value (i.e, 0, null, false, etc.) whereas <strong>x!=0</strong> will return true, iff x is not equal to <strong>0</strong>.</p>
",2
21039569,21038226,3,"<p>Assuming there is a conversion from a type to something that supports <code>if (x)</code> or <code>if (!x)</code>, then as long as there isn't a DIFFERENT conversion for <code>operator int()</code> than <code>opterator bool()</code>, the result will be the same. </p>

<p><code>if (x == 0)</code> will use the ""best"" conversion, which includes a <code>bool</code> or <code>void *</code> converter. As long as there is any converter that can convert the type to some ""standard type"".</p>

<p><code>if(!x)</code> will do exactly the same, it will use any converter that converts to a standard type.</p>

<p>Both of these of course assume the converter function isn't a C++11 ""don't default convert"". </p>

<p>Of course, if you have a class like this:</p>

<pre><code>class
{
   int x;
  public:
   bool operator bool() { return x != 0; }
   int operator int() { return x == 0; } 
}; 
</code></pre>

<p>then <code>if (x == 0)</code> will do <code>if ( (x == 0) == 0)</code> and <code>if (!x)</code> will will do <code>if (! (x != 0)</code>, which isn't the same. But now we're really TRYING to make trouble, and this is VERY BADLY designed code. </p>

<p>Of course, the above example can be made to go wrong with any <code>operator int()</code> that doesn't result in <code>false</code> for <code>x == 0</code> and <code>true</code> for all other values. </p>
",0
24105228,24105205,10,"<p>It's because of the way you pass the array to the function. As written it decays to pointer. Try </p>

<pre><code>template&lt;int N&gt;
void increment(int (&amp;v)[N])
{
    for (int x : v) std::cout &lt;&lt; ""printing "" &lt;&lt; x &lt;&lt; ""\n"";
}

int main()
{
    int v[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 9 };
    increment(v);
}
</code></pre>

<p>This <a href=""http://ideone.com/JWRWNs"" rel=""noreferrer""><strong>runs</strong></a> because a reference to an array of N <code>int</code>s is passed in the function and (unlike pointers) range for loops can iterate on those.</p>
",2
24105233,24105205,3,"<p>The function parameter <code>int v[]</code> is adjasted to <code>int *</code> Pointers do not keep information whether they point a single object or the first object of a sequence of objects.</p>

<p>The range-based for statement in fact uses the same expressions as standard functions <code>std::begin</code> and <code>std::end</code> They cannot be defined for pointers without knowing the size of the array. They  can be defined for arrays, not pointers.</p>
",6
24105236,24105205,11,"<p>Despite appearances, <code>v</code> is a pointer not an array - as the error message says. Built-in arrays are weird things, which can't be copied or passed by value, and silently turn into pointers at awkward moments.</p>

<p>There is no way to know the size of the array it points to, so no way to generate a loop to iterate over it. Options include:</p>

<ul>
<li>use a proper range-style container, like <code>std::array</code> or <code>std::vector</code></li>
<li>pass the size of the array as an extra argument, and interate with an old-school loop</li>
</ul>
",2
21043540,21043303,1,"<p>Converting <code>memblock</code> to a string is not going to work if it has embedded null characters, which it almost certainly does, and you don't pass the length. I'm not sure why you're doing all that faffing about with <code>char*</code>s and <code>std::string</code>s, but once you have your <code>memblock</code> and <code>size</code>, use them for <code>send</code>. If you want to prefix the response string, just <code>send</code> it first.</p>
",0
21044444,21043303,2,"<p>OK, let's start with the equivalent PHP code to get rid of the mess it is to do the same thing in C++</p>

<pre><code>// send required headers as plain text
header(""Content-type: image/png"");

// read the image as a binary block
$img_data = file_get_contents(""xample.png"");

// send it
echo $img_data;
</code></pre>

<p>C++ equivalent:</p>

<pre><code>string headers = ""HTTP/1.0 200 OK\r\nContent-type: image/png\r\n\r\n"";
send (new_sd, headers.data(), headers.length(), 0);

ifstream f(""xampl.png"", ios::in|ios::binary|ios::ate);
if(!f.is_open()) error (""bloody file is nowhere to be found. Call the cops"");
streampos size = f.tellg();
char* image = new char [size];
f.seekg (0, ios::beg);
f.read (image, size);
f.close();

send (new_sd, image, size, 0);
</code></pre>
",3
22425177,22425159,1,"<p>It looks like you are trying to construct an object from  type <code>float3</code>. Without the details of that type, I can only speculate that the type has a constructor taking three floats, so the required syntax is</p>

<pre><code>float3 myValue(1.0f,2.0f,3.0f);
</code></pre>

<p>Otherwise, if you are after a size 3 array of <code>float</code>, you can define it like this:</p>

<pre><code>float myValue[3] = {1.0f, 2.0f, 3.0f};
</code></pre>

<p>Note that the C++ standard library gives you a handy array container, <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow""><code>std::array</code></a>, which is copyable, assignable, and altogether easier to use:</p>

<pre><code>std::array&lt;float, 3&gt; myValue{1.0f, 2.0f, 3.0f};
</code></pre>
",2
22425193,22425159,1,"<p>Most probably you want an array of 3 floats but you are trying to create this with three <code>float3</code>.</p>

<p>Either you create an <code>float3</code> using it's constructor (if it is defined):</p>

<pre><code>float3 myValue( 1.0f, 2.0f, 3.0f);   // assigns 3 floats to float3
</code></pre>

<p>or you create an array of 3 <code>float</code>s:</p>

<pre><code>float myValue[3] = { 1.0f, 2.0f, 3.0f};
</code></pre>

<p>Now you can use</p>

<pre><code>float output = myValue[0];  // to get first element of the container of 3 floats
</code></pre>

<hr>

<p>The definition</p>

<pre><code> float myValue = (1.0f,2.0f,3.0f);
</code></pre>

<p>assigns only the last expression to variable because in <strong>C++</strong> (and C) <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">the comma is a binary operator</a> that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type).</p>

<p>Note that you might consider using efficient, specialized standard containers that will ease handling memory</p>

<p><code>std::vector</code> or <code>std::array</code> </p>
",0
32430534,32430499,1,"<p>In C++, class member functions are implemented in essentially the same way as regular C-style functions. However, they have a ""secret"" first argument which is the <code>this</code> pointer, to the instance of the class on which the method was called. Thus, there is only one copy of the class member function instantiated either.</p>

<p>(There are some potential issues about multiple compilation units and linkage... but since you ignored them in the question we'll keep ignoring them now for convenience.)</p>

<p>If you want to see for yourself, you can take pointers to the member functions of various instances of a class, and compare them to see if they are equal or not.</p>
",1
29217447,29217156,1,"<p>Use std::reverse() to do that. For educational purposes take a look at the following pure C algorithms: <a href=""http://www.programmingsimplified.com/c-program-reverse-string"" rel=""nofollow"">http://www.programmingsimplified.com/c-program-reverse-string</a> </p>
",0
29217449,29217156,0,"<pre><code>for (int i=d.size()/2; i&gt; 0; i--) //5
  {

    temp = d[i+j-1]; // d[9] i.e.must be 9 not 10 for swapping with 'h'
    d[j+i-1] = d[j-i];
    d[j-i] = temp;
  }
</code></pre>
",0
29217455,29217156,3,"<p>When the size of a string is even then the code is wrong. For example if the size is equal to 2 then size() / 2 is equal to 1 and in the loop you will get thet d[i+j] is equivalent to d[size() / 2 + size() / 2] that is equal to d[2] while the valid range of indices is [0,1]
Also you should include header <code>&lt;string&gt;</code> and you could use standard function <code>std::swap</code></p>

<p>The simplest approach is the following</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string s = ""hello matt"";

    s = std::string( s.rbegin(), s.rend() );

    std::cout &lt;&lt; s &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>If you want to write the loop yourself then the code can look like</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string s = ""hello matt"";

    for ( std::string::size_type i = 0; i &lt; s.size() / 2; i++ )
    {
        char c = s[i];
        s[i] = s[s.size()-i-1];
        s[s.size()-i-1] = s[i];
    }

    std::cout &lt;&lt; s &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Or you can write some exotic solution.:) For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;

int main() 
{
    std:: string s = ""Jake Smith""; 

    std::cout &lt;&lt; s &lt;&lt; std::endl;

    for ( std::string::size_type i = 0, j = s.size(); j - i &gt; 1; i++  )
    {
        std::swap( s[i], s[--j] );
    }

    std::cout &lt;&lt; s &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>The program output is</p>

<pre><code>Jake Smith
htimS ekaJ
</code></pre>

<p>Or you can try to write a recursive function.</p>

<p>At last you could use standard algorithm <code>std::reverse</code> declared in header <code>&lt;algorithm&gt;</code>.</p>
",0
29217696,29217156,0,"<p>It's very easy to trip up with indices when reversing a string in place.</p>

<p>If your string is of length <code>LEN</code>, then the valid indices are <code>0</code> - <code>N-1</code>.</p>

<p>In your case, let's take a look at the middle and how you start swapping from there.</p>

<pre><code>hello matt
</code></pre>

<p>For reversing the string, you'll have to swap</p>

<pre><code>hello matt (swap 0-th and 9-th)
^        ^
hello matt (swap 1-st and 8-th)
 ^      ^
hello matt (swap 2-nd and 7-th)
  ^    ^
hello matt (swap 3-rd and 6-th)
   ^  ^
hello matt (swap 4-th and 5-th)
    ^^
</code></pre>

<p>The start value for <code>i</code> is <code>(N-1)/2</code>.</p>

<p>The end vale for <code>i</code> is <code>0</code>.</p>

<p>The index for swapping the value at <code>i</code> is <code>len - 1 - i</code>. (swap <code>d[0]</code> with <code>d[9]</code> in your case)</p>

<p>Putting that all together, the function should be something like:</p>

<pre><code>void reverse_string(string&amp; d)
{
   int len = d.length();
   for (int i=(len-1)/2; i &gt;= 0; i--)
   {
      int j = len - 1 - i;
      char temp = d[j];
      d[j] = d[i];
      d[i] = temp;
   }
}
</code></pre>

<p>Here's the <code>main</code> function to test it.</p>

<pre><code>int main()
{
   string d = ""hello matt""; 
   reverse_string(d);
   cout &lt;&lt; d &lt;&lt; endl;

   d = ""hello max""; 
   reverse_string(d);
   cout &lt;&lt; d &lt;&lt; endl;

   return 0;
}
</code></pre>
",0
21186224,21186183,2,"<p>Like this:</p>

<pre><code>Calc_ToF_low::Calc_ToF_low() // note no need to say void in C++
{
    telo[0]=0;
    telo[1]=1;
    telo[2]=2;
}
</code></pre>

<p>Or if you can use C++11, something like this might work:</p>

<pre><code>Calc_ToF_low::Calc_ToF_low()
  : telo{{0,1,2}} // initializer list, will not work in ""old"" C++98
{}
</code></pre>
",6
21186266,21186183,1,"<p>You could just assign values to it by typing:</p>

<pre><code>telo[0] = 0;
telo[1] = 1;
telo[2] = 2;
</code></pre>

<p>in your .cpp.</p>

<p>It may not be perfect for huge arrays but then you probably should assign the values from a file instead.</p>
",0
21186558,21186183,0,"<p>This is one way you could do it:</p>

<pre><code>#include &lt;array&gt;

class Calc_ToF_low
{
private: 
  std::array&lt;int, 3&gt; telo;
public:
  Calc_ToF_low();
};

Calc_ToF_low::Calc_ToF_low()
: telo()
{
  for(unsigned i = 0; i&lt;telo.size(); ++i)
    telo[i] = i;
}
</code></pre>
",0
21186560,21186183,0,"<p>If you're initializing large arrays with a constant value for all item, you can use this approach:</p>

<pre><code>Calc_ToF_low::Calc_ToF_low(){

    memset(telo, 0, sizeof(telo));  //0 is the constant value
}
</code></pre>

<p>If you want to initialize your large array to some set of values that has no patterns:</p>

<pre><code>int defaultTeloData[TELO_NUMITEM] = {2,4,1,5,6,1,7,82,41,6,134,88,1};

Calc_ToF_low::Calc_ToF_low(){

    memcpy(telo, defaultTeloData, sizeof(telo)); 
}
</code></pre>

<p>If your array values has pattern, use a loop and some formulas or constructors.</p>

<pre><code>Calc_ToF_low::Calc_ToF_low(){

    for(int a = 0; a sizeof(telo)/sizeof(telo[0]); a++){
          telo[a] = dataFormulaForTelo(a);  
    }
}
</code></pre>
",0
21785475,21785436,4,"<p>You shouldn't be dereferences the pointers when calling <code>swap</code>. You need to call:</p>

<pre><code>swap(str1, str2);
</code></pre>

<p>Or, better still, use <a href=""http://en.cppreference.com/w/cpp/algorithm/swap"" rel=""nofollow"">std::swap</a>.</p>

<p>Also, if you're trying to run the code you've written they you'll need to either prototype <code>swap</code> or swap the functions around:</p>

<pre><code>void swap(const char *&amp;str1, const char *&amp;str2) 
{ 
  const char *one = str1;
  str1 = str2;
  str2 = one;
}    

int main(void)
{
  const char *str1 = ""Apple"";
  const char *str2 = ""Potato"";
  swap(str1, str2);

  return 0;
}
</code></pre>

<p>Also, <code>main</code> returns an int, not a float</p>
",5
21785505,21785436,3,"<p>You should use <a href=""http://en.cppreference.com/w/cpp/algorithm/swap"" rel=""nofollow noreferrer""><code>std::swap</code></a> (located in either the <code>&lt;algorithm&gt;</code> or <code>&lt;utility&gt;</code> header) instead of rolling your own:</p>

<pre><code>std::swap(str1, str2);
</code></pre>

<p>Also, you should consider using <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow noreferrer""><code>std::string</code></a> instead of <code>const char*</code> in general:</p>

<pre><code>std::string str1 = ""Apple"";
std::string str2 = ""Potato"";
</code></pre>

<p>of course the <code>std::swap</code> algorithm will still work just fine.</p>

<p>And finally, neither <code>void</code> in the argument list of <code>main</code> nor <code>return 0.0</code> are necessary in C++.</p>

<p>Here's the code revisited with the advices above:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main() {
    std::string str1 = ""Apple"";
    std::string str2 = ""Potato"";
    std::swap(str1, str2);
}
</code></pre>

<p>and <a href=""http://coliru.stacked-crooked.com/a/c3c21c77328595b5"" rel=""nofollow noreferrer"">here</a>'s the live example.</p>

<hr>

<p>In response to Mr. <a href=""https://stackoverflow.com/users/2195721/cthulhu"">Cthulhu</a> down here, I'll try to answer the question more explicitly. </p>

<p>Your error is caused by the fact that by dereferencing the pointers of type <code>const char*</code> you are actually getting an expression of type <code>const char&amp;</code> which is obviously incompatible with the type expressed in your <code>swap</code> function. Here's the correct call to the function:</p>

<pre><code>swap(str1, str2);
</code></pre>

<p>But the again, why replicating the code of <code>std::swap</code>? (this is a rhetorical question, in case you were wondering wether to flag this as ""not an answer"")</p>
",12
21785582,21785436,0,"<p>You're defining <code>swap()</code> <em>after</em> you're calling it. In C++, functions should be defined before they are called. Move the definition of <code>swap()</code> to the top of the file, above <code>main()</code>. You will then get this error:</p>

<pre><code>test.cpp:11: warning: converting to ¡®int¡¯ from ¡®double¡¯
</code></pre>

<p>Your <code>main()</code> function should return <code>0</code> (an <code>int</code>), not <code>0.0</code> which is a <code>double</code>.</p>

<p>Fixing this, you'll finally get this error:</p>

<pre><code>test.cpp: In function ¡®int main()¡¯:
test.cpp:10: error: invalid initialization of reference of type ¡®const char*&amp;¡¯ from expression of type ¡®const char¡¯
test.cpp:1: error: in passing argument 1 of ¡®void swap(const char*&amp;, const char*&amp;)¡¯
</code></pre>

<p>This is because you're dereferencing your arguments to <code>swap()</code>. Remove the <code>*</code> and the program now works fine.</p>

<p><strong>However</strong>, you should simply remove your <code>swap()</code> function altogether, <code>#include &lt;utility&gt;</code>, and use <code>std::swap()</code>.</p>
",0
26248328,26248268,1,"<p><code>cin &gt;&gt;</code> and <code>getline</code> do not cooperate very well. They have different strategies for how to deal with whitespace. <code>getline</code> removes the newline character, but <code>cin &gt;&gt;</code> leaves it. This means that after you use <code>cin &gt;&gt;</code> to read something, there will be a newline character left waiting in the input stream for the next <code>getline</code> to ""use"". Which means it will read an empty line into the string.</p>
",4
26248396,26248268,1,"<p>2 things. First, you don't really need cin.ignore() in this case as your using </p>

<pre><code>getline(). 
</code></pre>

<p>before </p>

<pre><code>cin &gt;&gt; variable
</code></pre>

<p>Second, I don't know why your program doesn't run, but I would suggest using a </p>

<pre><code>getline() 
</code></pre>

<p>call and see if that works. But I see no reason why your code is not working.</p>
",0
26248459,26248268,4,"<p>I recommend removing <strong>all</strong> the <code>cin.ignore()</code> commands. </p>

<p>One of the problems with user input is that the <code>&gt;&gt;</code> operator does not take the RETURN character out of the stream so if you follow it with a <code>getline()</code> the <code>getline()</code> will read the RETURN character instead of what you want to type in.</p>

<p>So I would change <em>all</em> your <code>getline()</code> to this:</p>

<pre><code>// cin &gt;&gt; ws will skip any RETURN characters
// that may be left in the stream
getline(cin &gt;&gt; ws, lastname); 
</code></pre>

<p>Also remove <strong>all</strong> of your <code>cin.ignore()</code> commands. They are not doing anything useful when used after a <code>getline()</code> command and if you change your <code>getline()</code> commands as I showed they should not be necessary at all.</p>

<p><strong>So this should work:</strong></p>

<pre><code>int main()
{
    string getfirstname;
    string lastname;
    string address;
    char response;
    int contactnumber;
    int CurrentNumberOfContacts = 0;

    cout &lt;&lt; ""Enter First name : "";
    getline(cin &gt;&gt; ws, getfirstname);

    cout &lt;&lt; ""Enter Last name : "";
    getline(cin &gt;&gt; ws, lastname);

    cout &lt;&lt; ""Enter Address : "";
    getline(cin &gt;&gt; ws, address);

    cout &lt;&lt; ""Enter Contact number : "";
    cin &gt;&gt; contactnumber;

    CurrentNumberOfContacts += 1;
    cout &lt;&lt; ""Successfully added to contact list!"" &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; ""Would you like to add another contact ? [Y/N] "";
    cin &gt;&gt; response;

    //more lines of codes below
    return 0;
}
</code></pre>

<p>Strictly speaking not all of your <code>getline()</code> functions need to employ the <code>cin &gt;&gt; ws</code> trick. I suppose the (incomplete) rules are as follows:</p>

<p>If you use a <code>std::getline()</code> after a <code>&gt;&gt;</code> then use:</p>

<pre><code>std::getline(cin &gt;&gt; ws, line);
</code></pre>

<p>Otherwise just use:</p>

<pre><code>std::getline(cin, line);
</code></pre>
",3
22129146,22129067,1,"<p>Currently you pass <code>RedBlackTree&lt;int&gt; RBT</code> into <code>addElement()</code> and <code>peak()</code>. By C++'s pass-by-value nature, the instance are copied before passing into the functions. Thus, the functions work on a temporary copy.</p>

<p>To make the functions work on the instance passed in, you should pass the parameters by reference. In this case, pass <code>RedBlackTree&lt;int&gt;&amp;</code> into <code>addElement()</code> and <code>peak()</code>.</p>

<p>Also, since you said that your <code>peak()</code> didn't work, you should check whether your copy constructor is correct or not.</p>
",0
22129153,22129067,0,"<p>You have to pass by reference, because you're modifying an object by adding a new element.  </p>

<p>In your solution, in the end of the addElement, RBT is simply destroyed, because it acts like a local variable and goes out of scope.</p>
",0
22129167,22129067,1,"<p>You want to pass by reference:</p>

<pre><code>void addElement(RedBlackTree&lt;int&gt; &amp;RBT);
void peak(RedBlackTree&lt;int&gt; &amp;RBT);
</code></pre>

<p>This doesn't create a copy of the object.</p>
",0
24132754,24132653,4,"<p>Whats happening here is your compiler is going into <code>Player.h</code> marking it as ""don't go back in here for this parse tree"" and then encountering <code>Source.h</code>.</p>

<p>In <code>Source.h</code> you include <code>Player.h</code> <strong>but</strong> the compiler has already marked <code>Player.h</code> as ""do not come back here"" so it gets skipped.<br>
When the line <code>CPlayer* myplayer;</code> is hit, the compiler has no idea what <code>CPlayer</code> is and throws a type error because it assumes that it is a name with a default <code>int</code> type.</p>

<p>The parse tree would look like (simplified):</p>

<pre><code>CPlayer.h
 -- Source.h
  -- Cplayer.h -- Skipped, #pragma once
</code></pre>

<p>Resolving the circular dependency will fix the problem for you.</p>
",4
32957765,32957743,9,"<p>C++ distinguishes between <em>declaration</em> and <em>usage</em>. To <em>declare</em> a pointer, the size of the pointee type doesn¡¯t need to be known. However, the code that deferences the pointer does need to know its size.</p>
",0
32957809,32957743,7,"<p>In your second example you have a class contain an instance of the same class which will, recursively, contain an instance of the same class.</p>

<p>Since every object in C++ must be of size of at least 1 this means that any instance of class <code>abc</code> will be infinite (1+1+1+...).</p>

<p>The first example isn't a problem since the size of a pointer to any object is a constant therefore the size of <code>abc</code> is finite and creating such an object can be done without creating infinite objects (the pointer can point to <code>nullptr</code> or to an existing object).</p>
",2
32957812,32957743,0,"<p>Size of a variable is needed when using pointer arithmetic or deferencing using the [] operator. </p>

<p>At compile time you do not need the size of the referenced object when declaring a pointer to it.</p>
",0
32957869,32957743,1,"<p>The problem with Snippet B is that it doesn't just contain a pointer to another abc, it contains the memory allocation for an entire abc. Which, in turn, contains an entire abc. Which contains an entire abc. Which contains an entire abc. See where we're going with this?</p>

<p>Snippet A doesn't have this problem; it just stores a pointer of fixed size. That pointer may point to another valid abc, but it could just as well point to null, itself, a random point in memory, or whatever.</p>
",0
21729199,21729008,1,"<p>In this case, the compiler is complaining that <code>Dialog</code> isn't a base class identifier because it hasn't encountered its declaration (and thus can't subclass it, as it doesn't ""know"" it).</p>

<p>Include the header that contains <code>Dialog</code> and it'll be fine.</p>
",0
31223809,31223705,3,"<p>In both Unix-land and Windows a file is primarily just a sequence of bytes.</p>

<p>With the Windows NTFS file system (which is default) you can have more than one sequence of bytes in the same file, but there is always one main sequence which is the one that ordinary tools see. To ordinary tools every file appears as just a single sequence of bytes.</p>

<p><strong>Text mode</strong> and <strong>binary mode</strong> in C++ concern whether the basic i/o machinery should <em>translate</em> to and from an external convention. In Unix-land there is no difference. In Windows text mode translates newlines from internal single byte C convention (namely ASCII linefeed, <code>'\n'</code>), to external double byte Windows convention (namely ASCII carriage return <code>'\r'</code> + linefeed <code>'\n'</code>), and vice versa. Also, on input in Windows, encountering a single byte value 26, a ""control Z"", is or can be interpreted as end of file.</p>

<hr>

<p>Regarding the literal question,</p>

<blockquote>
  <p><strong>&rdquo;</strong> The question is in what format are they written in the binary file, shouldn't they be written in not-interpreted form, i.e raw bytes?</p>
</blockquote>

<p>the text is written as raw bytes in both cases. The difference is only about how newlines are translated to the external convention for newlines. <del>Since your text <sup>1)</sup>doesn't contain any newlines, there's no difference.</del> <strong>Edit:</strong> Not shown in your code except by scrolling it sideways, there's a <code>fb &lt;&lt;'\n'</code> that outputs a newline to the file opened in binary mode, and if this produces the same bytes as in the original text file, then there is no effective translation, which implies you're not doing this in Windows.</p>

<hr>

<p>About the extra streams for Windows files, they're used e.g. for Windows (file) Explorer's custom file properties, and they're accessible e.g. via a bug in the Windows command interpreter, like this:</p>

<pre>
C:\my\forums\so\0306&gt;<b><i>echo This is the main stream &gt;x.txt</b></i>

C:\my\forums\so\0306&gt;<b><i>dir | find ""x""</b></i>
04-Jul-15  08:36 PM                26 x.txt

C:\my\forums\so\0306&gt;<b><i>echo This is a second byte stream, he he &gt;x.txt:2nd</b></i>

C:\my\forums\so\0306&gt;<b><i>dir | find ""x""</b></i>
04-Jul-15  08:37 PM                26 x.txt

C:\my\forums\so\0306&gt;<b><i>type x.txt</b></i>
This is the main stream

C:\my\forums\so\0306&gt;<b><i>type x.txt:2nd</b></i>
The filename, directory name, or volume label syntax is incorrect.

C:\my\forums\so\0306&gt;<b><i>find /v """" &lt;x.txt:2nd</b></i>
This is a second byte stream, he he

C:\my\forums\so\0306&gt;_
</pre>

<p>I just couldn't resist posting an example. :)</p>

<hr>

<p><sup>
<sup>1)</sup> You state that &ldquo;My text file contains <em>Lorem Ipsum</em>, no digits or special punctuation&rdquo;, which indicates no newlines.</sup>
</p>
",0
21730719,21730689,3,"<p>You are missing the constructor parameter type, and have a spurious <code>;</code>. You need</p>

<pre><code>SetHinzufuegen::SetHinzufuegen(ListBox setWithVariablesListInput) 
: Dialog(DS_Window, ""GUI"")
{
    InputToEdit = setWithVariablesListInput;
    InitMsgMap();
}
</code></pre>

<p>Note that you don't necessarily want to copy the <code>ListBox</code>. If you don't, then use a <code>const</code> reference parameter.</p>
",4
30313732,30295565,0,"<p>When I compiled PACC the config.hpp file was created in the include/PACC folder of the solution directory. Just drag it to your PACC source Directory. </p>
",0
26813191,26811816,1,"<p>As mentioned in the comments, your concerns about code duplication is addressed by applying the <a href=""https://stackoverflow.com/a/3279550/315052"">copy-and-swap idiom</a>:</p>

<pre><code>class SomeClass{
    //member data, copy ctor, dtor
    SomeClass&amp; operator=(SomeClass rhs){
        swap(*this, rhs);
        return *this;
    }
    friend void swap(SomeClass&amp; first, SomeClass&amp; second) {
        using std::swap;     
        swap(first.data, second.data);
        //... etc. for other data members
    }
};
</code></pre>

<p>You have to implement the additional <code>swap</code> function, but your copy constructor and destructor code is reused in a natural way. The copy constructor is used when the source of the assignment is passed to the assignment operator, and the destructor is reused when the argument is destructed when the assignment operator returns.</p>
",2
22134714,22133814,0,"<p>I've tried your program.
I suspect it's just not opening the desired input file.
Try adding the following after in.open(...</p>

<pre><code>if(in.good())
{
cout &lt;&lt; ""file opened""&lt;&lt;endl;
}
else
{
cout &lt;&lt; ""file not opened""&lt;&lt;endl;
}
</code></pre>

<p>I compiled the following using msvc2008... and using the debugger, confirmed your expected program behaviour.</p>

<pre><code>// test1.cpp : Defines the entry point for the console application.
#include ""stdafx.h""
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;

using namespace std;

struct student
{
    string last;
    string first;
    double attgrade;
    double midgrade;
    double hwgrade;
    double projgrade;
    double fingrade;
    int attendpos;
    int attendgot;
    int midpos;
    int midgot;
    int finpos;
    int fingot;
    int hw[20];
    int proj[20];
    double average;
};

int main(int argc, char* argv[])
{

    int numStudents = 0;
    int projCount = 0;
    int hwCount = 0;
    student students[100];
    string command, filename;
    cout &lt;&lt; ""What do you want to do?"" &lt;&lt; endl;
    cin &gt;&gt; command;
    ifstream in ;
    cin &gt;&gt; filename;
    string Attendance, Midterm, Final, Homework, Projects;
    int A, M, F, H, P;
    while (! in .fail())
    {
        if (command == ""Load"" || command == ""load"" || command == ""l"")
        { in.open(filename.c_str()); 
        if(in.good())
        {
                cout &lt;&lt; ""file opened""&lt;&lt;endl;
        }
                    else 
                    {
                    cout &lt;&lt; ""file opened""&lt;&lt;endl;
                    }
          in &gt;&gt; Attendance ;
          in &gt;&gt; A ;
          in &gt;&gt; Midterm &gt;&gt; M &gt;&gt; Final &gt;&gt; F &gt;&gt; Homework &gt;&gt; H &gt;&gt; Projects &gt;&gt; P;
            string lname, fname; in .ignore(200, '\n');
            getline( in , lname, ',');
            getline( in , fname, '\n');
            while (! in .fail())
            {
                string cat;
                int score, possible; in &gt;&gt; cat; in &gt;&gt; score &gt;&gt; possible;
                while (cat != ""Final:"")
                {
                    students[numStudents].last = lname;
                    students[numStudents].first = fname;
                    if (cat == ""Attendance:"")
                    {
                        students[numStudents].attendpos = possible;
                        students[numStudents].attendgot = score;
                        students[numStudents].attgrade = (score * A) / possible;
                    }
                    else if (cat == ""Midterm:"")
                    {
                        students[numStudents].midpos = possible;
                        students[numStudents].midgot = score;
                        students[numStudents].midgrade = (score * M) / possible;
                    }
                    else if (cat == ""Homework:"")
                    {
                        students[numStudents].hw[hwCount] = score;
                        hwCount++;
                        students[numStudents].hwgrade = (score * H) / 100;
                    }
                    else if (cat == ""Project:"")
                    {
                        students[numStudents].proj[projCount] = score;
                        projCount++;
                        students[numStudents].projgrade = (score * P) / 100;
                    } in &gt;&gt; cat; in &gt;&gt; score &gt;&gt; possible;
                } in &gt;&gt; score &gt;&gt; possible;
                students[numStudents].finpos = possible;
                students[numStudents].fingot = score;
                students[numStudents].fingrade = (score * F) / possible;
                students[numStudents].average = students[numStudents].fingrade + students[numStudents].hwgrade + students[numStudents].projgrade + students[numStudents].attgrade + students[numStudents].midgrade;
                numStudents++; in .ignore(200, '\n');
                getline( in , lname, ',');
                getline( in , fname, '\n');
            }
            for (int i = 0; i &lt; numStudents; i++)
            {
                cout &lt;&lt; students[i].average &lt;&lt; endl;
            }
        }
        else if (command == ""Display"" || command == ""display"" || command == ""d"")
        {
            cout &lt;&lt; ""Displayed:  "" &lt;&lt; filename &lt;&lt; endl;
            cout &lt;&lt; ""#Students:"" &lt;&lt; numStudents &lt;&lt; endl;
            cout &lt;&lt; ""Last Name"" &lt;&lt; ""   First Name"" &lt;&lt; ""   Attendance"";
            for (int i = 0; i &lt; hwCount; i++)
            {
                cout &lt;&lt; ""HW"" &lt;&lt; i &lt;&lt; ""   "";
            }
            for (int i = 0; i &lt; projCount; i++)
            {
                cout &lt;&lt; ""Proj"" &lt;&lt; i &lt;&lt; ""   "";
            }
            cout &lt;&lt; ""   Midterm"";
            cout &lt;&lt; ""   Final"" &lt;&lt; endl;
            for (int i = 0; i &lt; numStudents; i++)
            {
                cout &lt;&lt; students[i].last &lt;&lt; "" "" &lt;&lt; students[i].first &lt;&lt; "" "" &lt;&lt; students[i].attendgot;
                int j = 0;
                while (j &lt; numStudents)
                {
                    for (int i = 0; i &lt; hwCount; i++)
                    {
                        cout &lt;&lt; students[j].hw[hwCount] &lt;&lt; ""   "";
                    }
                    for (int i = 0; i &lt; projCount; i++)
                    {
                        cout &lt;&lt; students[i].proj[projCount] &lt;&lt; ""   "";
                    }
                    j++;
                }
                cout &lt;&lt; students[i].midgot &lt;&lt; ""   "" &lt;&lt; students[i].fingot &lt;&lt; ""   "" &lt;&lt; students[i].average &lt;&lt; endl;

            }
        }
        else if (command == ""Sort"" || command == ""sort"" || command == ""s"")
        {
            cout &lt;&lt; ""A"" &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; ""I didn't recognize that"" &lt;&lt; endl; in &gt;&gt; command;
        }
    }
}
</code></pre>
",1
21316074,21314348,1,"<p>Here's a quick example of how you could do for this.<br>
I used a vector, but you can adjust this to your needs.<br>
Please note that this hasn't been tested or debugged.<br>
I also did this all in one .cpp file; you should probably break this up.</p>

<p>First, create a Picture struct:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;tchar.h&gt;
#include &lt;Windows.h&gt;

typedef std::basic_string &lt;TCHAR&gt; tstring ;
typedef std::basic_ostream &lt;TCHAR&gt; tstream ;

#ifdef _UNICODE
#define tcout std::wcout
#else
#define tcout std::cout
#endif

struct Picture
{
    Picture (const tstring &amp;name, const FILETIME &amp;ft) ;

    tstring name ;
    FILETIME creation_time ;

    friend bool operator== (const Picture &amp;lhs, const Picture &amp;rhs) ;
    friend bool operator!= (const Picture &amp;lhs, const Picture &amp;rhs) ;
    friend tstream&amp; operator&lt;&lt; (tstream&amp; ts, const Picture &amp;pic) ;
};

Picture::Picture (const tstring &amp;name, const FILETIME &amp;ft) : name (name), creation_time (ft)
{
}

bool operator== (const Picture &amp;lhs, const Picture &amp;rhs)
{
    return ((lhs.name == rhs.name) &amp;&amp; (::CompareFileTime (&amp;lhs.creation_time, &amp;rhs.creation_time) == 0)) ;
}

bool operator!= (const Picture &amp;lhs, const Picture &amp;rhs)
{
    return !(operator== (lhs, rhs)) ;
}

tstream&amp; operator&lt;&lt; (tstream&amp; ts, const Picture &amp;pic)
{
    ts  &lt;&lt; pic.name &lt;&lt; _T ("", FileTime (HI, LO): ("") 
        &lt;&lt; pic.creation_time.dwHighDateTime &lt;&lt; _T ("", "")
        &lt;&lt; pic.creation_time.dwLowDateTime &lt;&lt; _T ("")"") ;
    return ts ;
}
</code></pre>

<p>Then implement a function that prints out new files.</p>

<pre><code>void PrintNewPictures (std::vector &lt;Picture&gt; &amp;vecPicsOld, const tstring &amp;dir)
{
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA ffd ;

    std::vector &lt;Picture&gt; vecPics ;

    hFind = FindFirstFile(dir.data (), &amp;ffd) ;
    if (hFind == INVALID_HANDLE_VALUE) {
        // Return an error or throw an exception
        return ;
    }

    do {
        Picture pic (ffd.cFileName, ffd.ftCreationTime) ;
        if (std::find (vecPicsOld.begin (), vecPicsOld.end (), pic) == vecPicsOld.end ()) {
            // Print that this is a new Picture.
            tcout &lt;&lt; pic &lt;&lt; std::endl ;
        }

        vecPics.push_back (pic) ;

    } while (::FindNextFile (hFind, &amp;ffd) != NULL) ;
    ::FindClose (hFind) ;

    // This keeps the vector fresh so it won't build up old values.
    std::swap (vecPics, vecPicsOld) ;
}
</code></pre>

<p>Here's and example of how you would use this:</p>

<pre><code>int main (void) 
{
    std::vector &lt;Picture&gt; vecPics ;
    while (1) {
        ::Sleep (1000) ;
        PrintNewPictures (vecPics, _T (""C:\\temp\\*"")) ;
    }

    return 0 ;
}
</code></pre>
",4
31175485,31175399,0,"<p><code>ChunkManager</code> in the header is an object not a pointer, so <code>chunkManager = new ChunkManager(world);</code> is wrong.</p>

<p>You can leave it as an object and initialize like this:</p>

<pre><code>Universe::Universe() : chunkManager(world)
{
</code></pre>

<p>But you don't have <code>world</code> yet (unless you can pass it as a parameter). The easiest solution is to make the header have a pointer:</p>

<pre><code>private:
        ChunkManager* chunkManager;
</code></pre>

<p>And then your .cpp is ok.</p>

<p>Edit: I assume what Kenny Ostram is getting at in the comments is that since you've dynamically allocated <code>chunkManager</code> you need to be sure you <code>delete</code> it at some point (probably the destructor) to avoid a memory leak.</p>
",2
28207017,28206954,4,"<p>You are implementing <code>InsultGenerator</code>'s copy-constructor although you haven't declared it.</p>

<p>Add <code>InsultGenerator(const InsultGenerator&amp; );</code> to your <code>InsultGenerator</code> class.
Like so:</p>

<pre><code>class InsultGenerator
{
public:
    InsultGenerator(vector&lt;string&gt;); // also better remove that one since I don't
                                     // think you have implemented it

    InsultGenerator(const InsultGenerator &amp;); // here
    void initialize() const;
    string talkToMe() const;
    vector&lt;string&gt; generate(const int) const;
    int generateAndSave (const string, const int) const;
private:
    vector&lt;string&gt; colA;
    vector&lt;string&gt; colB;
    vector&lt;string&gt; colC;
};
</code></pre>
",3
28207127,28206954,0,"<p>Edit:</p>

<pre><code>   class InsultGenerator
    {
    public:
        InsultGenerator(vector&lt;string&gt;); // Remove this line.
        InsultGenerator(const InsultGenerator &amp;); // Add this line.
        void initialize() const;
        string talkToMe() const;
     ......
    }
</code></pre>
",0
22853223,22851030,0,"<p>Yes, in C++11 </p>

<pre><code>template&lt;typename T&gt; using createShapeFunction = Shape&lt;T&gt; (*)(void);
</code></pre>

<p>does work. That's the cleanest way to do it.</p>
",0
32399801,32399730,9,"<p>Overload <code>Bar</code>:</p>

<pre><code>int Bar()
{
    return x_ + y_;
}

int Bar(int x)
{
    return x + y_;
}

int Bar(int x, int y)
{
    return x + y;
}
</code></pre>

<p>Thanks to @Jarod42 for this improvement:</p>

<pre><code>int Bar(int a, int b)
{
    return a + b;
}

int Bar(int a)
{
    return Bar(a, y_);
}

int Bar()
{
    return Bar(x_, y_);
}
</code></pre>

<p>The real-world problem you're trying to solve is more likely to benefit from this refactoring than the original problem of summing two numbers. This behavior is more obviously identical to that you were hoping to achieve through default arguments.</p>
",1
32399835,32399730,5,"<p>A workaround would be to overload your <code>Bar</code> function as: </p>

<pre><code>int Bar()
{
    return x_ + y_;
}
int Bar(int a)
{
    return a + y_;
}
int Bar(int a, int b)
{
    return a + b;
}
</code></pre>
",2
23856316,23856294,1,"<p>those are line continuations necessary to interpret the whole <code>#define</code> thing as one line, as required by the preprocessor syntax. this way it's just more readable.</p>
",0
23856322,23856294,1,"<p>It means that the macro text is continued after the actual line breaks you have.</p>

<p><code>#define</code> reads its contents from one contigious line. The <code>\</code> character just <em>'escapes'</em> (i.e. skips) the following line break.</p>
",0
23856323,23856294,3,"<p>In macro definition, <code>\</code> means <em>continuation</em>.</p>

<p>The definition of a macro should be on ONE line, i.e without any break. Since in your definition, the macro definition is so big that it cannot conveniently accommodate on the same line without destroying the readability. So <code>\</code> is used to indicate to the preprocessor the definition <strong>continues</strong> to the next line so that the program's readability is maintained.</p>

<p>Note that <code>\</code> must be followed by a newline. Make sure that there is <strong>no</strong> space after <code>\</code>.</p>
",1
23856342,23856294,4,"<p>The definition of a macro only includes a logical single line. The <code>\</code> at the end of each line of the macro definition is used to allow the macro definition to be split into multiple physical source lines (presumably for readability reasons).</p>

<p>This works because a <code>\</code> followed by a new-line is deleted during phase two of translation, but the preprocessor is run later, in phase four. <code>[lex.phases]/2</code>:</p>

<blockquote>
  <p>Each instance of a backslash character (\) immediately followed by a new-line character is deleted, splicing physical source lines to form logical source lines.</p>
</blockquote>
",0
34247020,34246964,2,"<p>You create a third vector of int, which are the indexes into the original two vectors.  Initially populate the third vector with number 0 .. length of vector.  Then construct your compare function to take the index from the third vector and then do the compare against the second vector holding the keys.</p>

<p>The data in the first and second vector will not be modified (which is good) and the values in the the third vector will represent the sort order once done.</p>
",0
34247032,34246964,6,"<p>You can make a third vector of <em>indexes</em> and sort that indirectly. After it's sorted, you can access the original vector through the sorted indexes:</p>

<pre><code>std::vector&lt;Foo&gt; foo_vec = /* ... */;
std::vector&lt;int&gt; x_vec = /* ... */;
std::vector&lt;std::size_t&gt; index_vec;

assert(foo_vec.size() == x_vec.size());
for (std::size_t i = 0; i != foo_vec.size(); ++i) { index_vec.push_back(i); }

std::sort(
    index_vec.begin(), index_vec.end(),
    [&amp;](std::size_t a, std::size_t b) { return x_vec[a] &lt; x_vec[b]; });

for (std::size_t i = 0; i != index_vec.size(); ++i)
{
    std::cout &lt;&lt; ""Sorted element "" &lt;&lt; i &lt;&lt; "" is ""
              &lt;&lt; foo_vec[index_vec[i]] &lt;&lt; ""\n"";
}
</code></pre>

<p>Note that this operation is entirely non-invasive, since everything happens indirectly.</p>
",8
29954619,29954191,2,"<p>It is stated <a href=""http://www.oopweb.com/CPP/Documents/CPPAnnotations/Volume/cplusplus10.html"" rel=""nofollow"">here</a> that:  </p>

<blockquote>
  <p>Static <code>const</code> integral data members initialized in the class interface are not addressable variables. They are mere symbolic names for their associated values. Since they are not variables, it is not possible to determine their addresses. Note that this is not a compilation problem, but a linking problem. The static <code>const</code> variable that is initialized in the class interface does not exist as an addressable entity.   </p>
</blockquote>

<p>What ""addressable entity"" refers here is ""instance"" of static <code>const</code> data type. No instance, no address, i.e its only a declaration.<br>
Note that static variables that are explicitly defined in a source file can be linked correctly, though.   </p>

<pre><code>class X
{
    public:
        static int const s_x = 34;
        static int const s_y;
};

int const X::s_y = 12;

int main()
{
    int const *ip = &amp;X::s_x;    // compiles, but fails to link
    ip = &amp;X::s_y;               // compiles and links correctly
} 
</code></pre>

<blockquote>
  <p>... if you do take the address of a class constant, or if your .. part of the above quoted paragraph ?  </p>
</blockquote>

<p>It <a href=""http://en.cppreference.com/w/cpp/language/static"" rel=""nofollow"">means</a> if such a member is odr-used, a definition at namespace scope is still required, but it should not have an initializer.</p>

<pre><code>struct X {
    const static int n = 1;
};
const int* p = &amp;X::n; // X::n is odr-used
const int X::n;       // ... so a definition is necessary
</code></pre>
",6
29954631,29954191,8,"<p>Just as with functions, variables can have 'purely declarative' declarations, and actual definitions. You're confused because you probably didn't encounter many pure variable declarations before.</p>

<pre><code>int i; // Definition
extern int i, j; // (Re)declares i, and declares j
extern int j = 0; // Defines j (confusing, eh?)
</code></pre>

<p>As you're used to with functions, definitions are declarations, but not all declarations are definitions. ¡ì3.1/2 reads</p>

<blockquote>
  <p>A declaration is a <em>definition</em> unless [¡­] it declares a static data
  member in a class definition (9.2, 9.4),</p>
</blockquote>

<p>Thus in-class static data member declarations are never defining the variables they declare. However, sometimes, a variables definition doesn't have to be present. That is the case <strong>when you can use its value directly without necessitating the variables run-time existence.</strong></p>

<p>In technical terms, as long as a static data member (or any entity, for that matter) is not 'odr-used', it doesn't have to be defined. <em>Odr-use</em> for all entities is defined in ¡ì3.2/3:</p>

<blockquote>
  <p>A variable <code>x</code> whose name appears as a <em>potentially-evaluated</em> expression
  <code>ex</code> is <em>odr-used</em> by <code>ex</code> unless applying the lvalue-to-rvalue conversion
  (4.1) to <code>x</code> yields a constant expression (5.20) that does not invoke
  any non-trivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of
  the set of potential results of an expression <code>e</code>, where either the
  lvalue-to-rvalue conversion (4.1) is applied to <code>e</code>, or <code>e</code> is a
  discarded-value expression (Clause 5).</p>
</blockquote>

<p>This looks complicated, and it was simpler in earlier versions of the standard. However, it roughly says that the variable is not odr-used by some expression when that expression ""immediately"" accesses the variables value, and this access yields a constant expression. Meyers example of ""taking its address"" is only one of many for odr-use.</p>

<p>For some class <code>A</code> and its static data member <code>i</code>,</p>

<pre><code>class A {
    static const int i = 57; // Declaration, not definition
};

const int A::i; // Definition in namespace scope. Not required per se.
</code></pre>
",0
29954696,29954191,0,"<blockquote>
  <p><strong>Why now it is a definition and not a declaration ?</strong></p>
</blockquote>

<p>Because this statement causes the compiler to generate an address for the static variable. </p>

<blockquote>
  <p>Also, can someone expand on what the author means by ""if you do take
  the address of a class constant"":</p>
</blockquote>

<p>When you make a pointer point to a variable you take its address.</p>
",0
29955881,29954191,0,"<p>A short answer is: a declaration says ""this thing exists somewhere"", and a definition causes the space to be allocated.  In your case, you've declared it to be static and const.  The compiler may be smart enough to notice that if you only ever use it as a value, it can simply replace that usage with the literal 5.  It doesn't need to actually make space for a variable somewhere and fill it with the 5, it can use the 5 directly at compile-time.   However, if you take the address of it, the compiler can no longer make that assumption and now needs to put that 5 into somewhere addressable.  The compiler needs it to exist in one translation unit (roughly: one cpp file.  See also the One Definition Rule.), so now you have to explicitly declare it somewhere.</p>
",0
31134388,31134327,3,"<p>You are defining the iterators <strong>within</strong> a prior if-else scope: </p>

<pre><code>fs::recursive_directory_iterator it(root);
fs::recursive_directory_iterator endit;
</code></pre>

<p>Therefore when you reference them later in the while loop they no longer exist as the variables are destroyed as soon as your if-else block is finished.</p>

<p>As you have iterators that are of different types depending on the <code>bool</code> argument, you might have to actually place the while loop within each of your <code>if</code> and <code>else</code> blocks to ensure that the iterators still exist when you execute your <code>while</code> loop.</p>

<p>However you choose to proceed it is nothing to do with the <code>boolean</code> parameter to your function - pay attention to the compiler errors as they are telling you what is wrong.</p>
",2
31134392,31134327,1,"<p><code>it</code> is defined in another block, you can't use it in your while loop, unless you define it before</p>
",0
31134790,31134327,0,"<p>The problem is this bit of code...</p>

<pre><code>    ....
    while(it != endit)
    {
        if(fs::is_regular_file(*it) &amp;&amp; it-&gt;path().extension() == ext)
                names.push_back(it-&gt;path().filename());

        ++it;
    }
    ....
</code></pre>

<p>...is using two variables, 'it' and 'endit'. However in both cases where you declare these are inside {} blocks. This makes the declaration only local to these blocks.</p>

<p>Your problem is made slightly worse by each declaration of 'it' and 'endit' being of different types.</p>

<p>You can either move the declaration outside of the local blocks and make them of some common type (in this case InputIterators) or you can move the while loop at the end inside both local blocks like this...</p>

<pre><code>...
    if (recursiveflag)
    {
        fs::recursive_directory_iterator it(root);
        fs::recursive_directory_iterator endit;

        while(it != endit)
        {
            if(fs::is_regular_file(*it) &amp;&amp; it-&gt;path().extension() == ext)
                    names.push_back(it-&gt;path().filename());

            ++it;
        }
    }
    else
    {
        fs::directory_iterator it(root);
        fs::directory_iterator endit;

        while(it != endit)
        {
            if(fs::is_regular_file(*it) &amp;&amp; it-&gt;path().extension() == ext)
                    names.push_back(it-&gt;path().filename());

            ++it;
        }
    }
...
</code></pre>

<p>Although this leads to unnecessary code duplication and makes for maintenance nightmares further on.</p>
",0
27509488,27509403,2,"<p>Change your <code>animal</code> constructor definition as follows</p>

<pre><code>animal::animal(string nameofanimal) : name(nameofanimal) {
}
</code></pre>

<p>In your original definiton you have a local variable <code>name</code> that shadows the class member variable:</p>

<pre><code>animal::animal(string nameofanimal)
{    
    string name = nameofanimal; // &lt;&lt;&lt; This sets only the local variable
}
</code></pre>
",2
27509497,27509403,2,"<p>The problem is you are storing value in local variable</p>

<pre><code>string name = nameofanimal;
</code></pre>

<p>while the value is not stored in actual data member of the class.  To store it in data member use the following:</p>

<pre><code>name = nameofanimal;
</code></pre>
",0
21591274,21585462,0,"<p>Creating a standard container which contains iterators to itself is impossible. However, there are alternative approaches which behave the same.</p>

<h2>Solution 1</h2>

<p><code>unordered_map</code> requires unique keys. Therefore, simply use <code>std::string</code> as the value type, and look it up in the map when necessary. The average algorithmic complexity of the lookup is the same in both cases - O(1).</p>

<p>Example: let's say you want to represent this data:</p>

<pre><code>foo -&gt; bar
bar -&gt; baz
baz -&gt; barney
fred -&gt; (nothing)
barney -&gt; (nothing)
</code></pre>

<p>Then you would write this to construct the data structure:</p>

<pre><code>std::unordered_map&lt;std::string, std::string&gt; Map;
Map m;
m.insert(std::make_pair(std::string(""foo""), std::string(""bar"")));
m.insert(std::make_pair(std::string(""bar""), std::string(""baz"")));
m.insert(std::make_pair(std::string(""baz""), std::string(""barney"")));
m.insert(std::make_pair(std::string(""fred""), std::string("""")));
m.insert(std::make_pair(std::string(""barney""), std::string("""")));
</code></pre>

<p>To walk along the chains in this structure, you could use code like this:</p>

<pre><code>Map::iterator i = m.find(""foo"");
while (i != m.end() &amp;&amp; !i-&gt;second.empty()) {
    i = m.find(i-&gt;second);
}
</code></pre>

<p>Note that any string which does not appear as a key could be used to mark the end of the chain.</p>

<h2>Solution 2</h2>

<p>Use <code>boost::ptr_unordered_set</code> and store the pointer to the next value in the value itself. Add appropriate equality and comparison operators, so that the pointer is ignored in the set. Note that this adds an extra level of indirection, but this is unavoidable.</p>

<pre><code>struct ChainElement
    : boost::equality_comparable&lt;ChainElement&gt;
{
    std::string key;
    ChainElement *next;

    ChainElement(std::string const &amp;k, ChainElement *n = NULL)
        : key(k), next(n)
    {}

    bool operator==(ChainElement const &amp;other) const {
        return key == other.key;
    }
};

namespace std {
template &lt;&gt;
hash&lt;ChainElement&gt;::operator()(ChainElement const &amp;ce) const {
    return std::hash(ce.key);
};
}
</code></pre>

<p>Set up the structure e.g. like this:</p>

<pre><code>#include &lt;boost/ptr_container/ptr_unordered_set.hpp&gt;

// ...

boost::ptr_unordered_set&lt;ChainElement&gt; m;
m.insert(new ChainElement(""foo""));
m.insert(new ChainElement(""bar""));
m.insert(new ChainElement(""baz""));
m.insert(new ChainElement(""fred""));
m.insert(new ChainElement(""barney""));
m.find(""foo"")-&gt;next = &amp;*m.find(""bar"");
m.find(""bar"")-&gt;next = &amp;*m.find(""baz"");
m.find(""baz"")-&gt;next = &amp;*m.find(""barney"");
</code></pre>

<p>Then to walk the structure:</p>

<pre><code>ChainElement *elem = &amp;*m.find(""foo"");
while (elem != NULL) {
    // do something
    elem = elem-&gt;next;
}
</code></pre>

<p>Using <code>boost::ptr_unordered_set</code> rather than <code>std::unordered_set</code> guarantees that the objects will be deleted when the container holding them is deleted.</p>
",5
26426747,26426538,1,"<p>Assuming all your fields are of the same type (say, <code>float</code>), you are looking for <em>pointer-to-members</em>. The syntax is as follows :</p>

<pre><code>// An example class with two fields to choose from
class A {
    float f1;
    float f2;
};

int main(int, char**) {

    // Declaration of a pointer-to-member
    float A::*ptr;

    // Assignment, note that we don't have an instance yet
    ptr = &amp;A::f1;

    // Creating an actual instance
    A a;

    // Using the pointer on the instance
    a.*ptr = 3.14f;

    // Check that it worked. It did !
    std::cout &lt;&lt; a.f1 &lt;&lt; '\n';

    return 0;
}
</code></pre>

<p>You'd want to pass an array of these.</p>

<p>If they are <em>not</em> all of the same type, you'll need something way more involved, with template-flavored type erasure.</p>
",6
26426721,26426538,1,"<p>If you're trying to pass some kind of ""reference to <strike>field</strike> member name"" array and iterate over a class in that way, then you're not going to be able to do it in this way. You can't loop over the <em>members</em> of a type.</p>

<p>You could pass an array of pointers-to-member:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

// (all doubles for exposition)
struct Car
{
    double size;
    double weight;
    double color;
    double id;
};

typedef double Car::*ptrToCarMember;

double measureSim(const Car&amp; a, const Car&amp; b, std::vector&lt;ptrToCarMember&gt; feature)
{
    double value = 0;

    for (auto el : feature) {
        value += a.*el - b.*el;
    }

    return value;
}

int main()
{
    Car a = { 1.0, 2.0, 4.0, 8.0 };
    Car b = { 1.0, 2.0, 3.0, 4.0 };

    {
        std::vector&lt;ptrToCarMember&gt; features{&amp;Car::size};
        std::cout &lt;&lt; measureSim(a, b, features) &lt;&lt; '\n';
    }

    {
        std::vector&lt;ptrToCarMember&gt; features{&amp;Car::id};
        std::cout &lt;&lt; measureSim(a, b, features) &lt;&lt; '\n';
    }

    {
        std::vector&lt;ptrToCarMember&gt; features{&amp;Car::size, &amp;Car::weight, &amp;Car::color};
        std::cout &lt;&lt; measureSim(a, b, features) &lt;&lt; '\n';
    }
}

// $ g++ -std=c++11 -Wall main.cpp &amp;&amp; ./a.out
// 0
// 4
// 1
</code></pre>

<h3>(<a href=""http://coliru.stacked-crooked.com/a/faa8e2f004140697"" rel=""nofollow"">live demo</a>)</h3>

<p>But, yikes! It is very rare to find a need for pointers-to-members. Maybe you've found a good reason. Just be sure to well document your need and your code. Also note that all the members you want to use in this way will have to have the same type (here it's <code>double</code>); you can't mix and match.</p>

<p>It would probably be more idiomatic to use variadic templates, but I'm not going to go into that here as it is an advanced topic and likely overkill for this.</p>

<p>You could also look at simply replacing your member variables with a <code>std::map</code> and then you can do lots of stuff with the map's keys and values with no need for ""magic"".</p>
",6
31894252,31894217,0,"<p>Why don't you loop?</p>

<pre><code>for(int i = 0; i &lt; 5; i++) {
    double a,b,c;
    inf &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    // Do something with a,b,c
}

for(int i = 0; i &lt; 5; i++) {
    double a,b,c,d;
    inf &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    // Do something with a,b,c,d
}
</code></pre>
",2
31895299,31894217,1,"<p>yes use getline in a while loop and parse data using istringstream and istream_iterator and keep individual data in vector.</p>

<pre><code>int main()
{

 std::ifstream infile(&lt;absolute path to file&gt;);
 std::string input=""0 0 -1 0"";
 std::vector&lt;std::vector&lt;float&gt;&gt; data;
 while( getline(infile,input))
 {
    std::istringstream iss(input);
    std::vector&lt;float&gt; input_data{istream_iterator&lt;float&gt;{iss},
                      istream_iterator&lt;float&gt;{}};
    data.push_back(input_data);   
}

for( const auto &amp; x: input_data)
  std::cout&lt;&lt;x&lt;&lt;"" "";
}
</code></pre>
",0
31843236,31843003,4,"<p>Add this line:</p>

<pre><code>using A::Foo;
</code></pre>

<p>in class <code>B</code> (public part) and it will work. </p>

<p>In this case <code>Foo</code> from <code>B</code> <em>hides</em> <code>Foo</code> from <code>A</code>. One of the C++ strange behaviors.</p>
",2
26808186,26807473,1,"<p>You have declared <code>void uber_function(int)</code> in the <code>::PyMega</code> namespace, and then went on to define <code>void uber_function(int)</code> in the <code>::</code> namespace. These are two different functions from different namespaces with the same names and signatures, which results in a conflict. Probably not what you intended.</p>

<p>To define <code>::PyMega::uber_function</code> you <strong>must</strong> say</p>

<pre><code>namespace PyMega
{
   void uber_function(int) {
       ....
   }
}
</code></pre>
",0
30408973,30408920,5,"<p><code>HelloProtocol::sendScheduledInterest</code> is a <code>void</code> function. That means it returns <strong>no value</strong>. You can neither invoke the address of operator (&amp;) on the return value of a void function nor can you pass it as an argument to another function unless that type is also void, which could only happen if there are some templates involved.</p>

<p>It appears you actually intend to pass the function pointer as the argument like this:</p>

<pre><code>Simulator::Schedule(
    Seconds(seconds),
    &amp;HelloProtocol::sendScheduledInterest,
    this,
    seconds);
</code></pre>

<p>In both cases, the compiler is telling you exactly what the issue is.</p>

<p>In the first case, a void expression is <strong>not</strong> an lvalue. You can think of an lvalue as something that can be assigned to on the left hand side of an assignment statement. The address of operator (&amp;) can only be applied to lvalues.</p>

<p>In the second case, you are trying to use a void expression where it is not allowed, namely as the argument to a function whose formal argument type is non-void.</p>
",0
30408987,30408920,2,"<p>You are taking the address of the return value of <code>sendScheduledInterest</code> instead of the address of the method itself. Remove the <code>(seconds)</code> bit.</p>

<p>It seems like you may be intending to bind the <code>seconds</code> value to the call to <code>sendScheduledInterest</code></p>

<p>With the standard library this can be achieved like this:</p>

<p>change <code>Schedule</code> to</p>

<pre><code>EventId Schedule(const Time&amp;, std::function&lt;void()&gt;);
</code></pre>

<p>and then use it as</p>

<pre><code>Schedule(Seconds(seconds), bind(&amp;HelloProtocol::sendScheduledInterest, this, seconds));
</code></pre>
",1
22870134,22870004,7,"<p>This is not going to end well.  C++ itself provides no support for creating new operators, only providing custom per-type behavior for the existing ones.  And the preprocessor does nothing per-type, nor has any support for infix notation.</p>

<p>I sure wouldn't try to use single-letter operators, since they'll get replaced <em>everywhere</em> in your program.</p>

<p>To make something like <code>u cross v</code> work, you could</p>

<pre><code>#define cross * cross_product_helper() *
</code></pre>

<p>And then use some techniques from expression trees -- the <code>operator*(vec, cross_product_helper)</code> returns a helper type that holds the vector and knows it wants to do cross product, the second use of <code>*</code> actually does the multiply.</p>

<p>On the other hand, would it be so bad to have the code written like:</p>

<pre><code>u *cross* v
</code></pre>

<p>Where <code>cross</code> is a pre-defined, properly scoped variable of type <code>cross_product_helper</code>?  (And of course you could have similar <code>dot</code> and <code>element</code> defined with unique types to make <code>u *cross* v</code>, <code>u *dot* v</code>, and <code>u *element* v</code> (and <code>u /element/ v</code>) all work and return different types.</p>

<p>Note that I've chosen <code>operator*</code> as the foundation for <code>*cross*</code>, as opposed to <code>+cross+</code> or <code>^cross^</code>, because it has the precedence and other grammatical properties associated with products.</p>
",7
22870136,22870004,0,"<p>Do not use preprocessors. They are bad. Best to avoid. You should look into overloading operators. <a href=""http://www.functionx.com/cpp/Lesson25.htm"" rel=""nofollow"">http://www.functionx.com/cpp/Lesson25.htm</a></p>
",2
21782856,21782752,1,"<p>The simplest way to do that is</p>

<pre><code>rdata[p.getCode()] += amount;
</code></pre>

<p>If it wasn't already in the map, then <code>[]</code> will insert an element with value zero, so the value will end up being <code>amount</code>. If it was, then <code>amount</code> is added to the existing value.</p>
",2
21782875,21782752,3,"<p>Assuming your map is declared within the <code>Request</code> class as <code>std::map&lt;int, double&gt; rdata</code>, the code can be:</p>

<pre><code>void Request::addItem( Product p, double amount )
{
    if ( this-&gt;isItemRequest(p) )
    {
        int Code = int(p.getCode);
        this-&gt;rdata[ Code ] += amount;
    }

    this-&gt;rdata.insert( pair&lt;int, double&gt;(int(p.getCode), amount) );
}
</code></pre>

<p>However, if <code>isItemRequest()</code> is just a trivial check, your code can be simplified to just:</p>

<pre><code>void Request::addItem( Product p, double amount )
{
    int Code = int(p.getCode);
    this-&gt;rdata[ Code ] += amount;
}
</code></pre>

<p><strong>P.S.</strong> Maybe, it is a good idea (if you can change the interface) to pass <code>Product</code> by const reference.</p>
",7
21782954,21782752,1,"<p>If you call on:</p>

<pre><code>this-&gt;rdata[key] = value;
</code></pre>

<p>you create a value using default constructor (<code>int()</code> initializes to <code>0</code>), return reference to it, and call <code>operator=</code> on it. You can avoid that by checking if key exist first:</p>

<pre><code>this-&gt;rdata.count(key) != 0
</code></pre>

<p>or simplier</p>

<pre><code>this-&gt;rdata.count(key)
</code></pre>

<p>if it exists you can use operatror=, operator+= and so on on reference returned by <code>operator[]</code>:</p>

<pre><code>if (this-&gt;rdata.count(key) == 0)
    this-&gt;rdata.insert( pair&lt;int, double&gt;( key, value ) );
else
    this-&gt;rdata[key] += value;
</code></pre>

<p>but in this simple case</p>

<pre><code>this-&gt;rdata[key] += value;
</code></pre>

<p>should just do.</p>
",0
21783214,21782752,0,"<p>Easy: map.find :)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

typedef std::map&lt;std::string, int&gt; StringIntMap;

int main() {
    StringIntMap map;
    map[""coke""] = 10;
map[""fries""] = 25;
    map[""pizza""] = 50;
std::cout &lt;&lt; ""Before increase"" &lt;&lt; std::endl;
StringIntMap::const_iterator it;
for (it = map.begin(); it != map.end(); it++) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; "": "" &lt;&lt; it-&gt;second &lt;&lt; std::endl;
}
std::cout &lt;&lt; ""Now, increase pizza +50"" &lt;&lt; std::endl;
StringIntMap::iterator item = map.find(""pizza"");
if (item != map.end()) {
    // pizza exists increase 50
    item-&gt;second += 50;
} else {
    std::cout &lt;&lt; ""Sorry, no pizza here"" &lt;&lt; std::endl;
}
std::cout &lt;&lt; ""after increase"" &lt;&lt; std::endl;
for (it = map.begin(); it != map.end(); it++) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; "": "" &lt;&lt; it-&gt;second &lt;&lt; std::endl;
}
return 0;
</code></pre>

<p>}</p>
",1
31903486,31903360,2,"<p>One option is to use <a href=""https://en.wikipedia.org/wiki/Opaque_pointer"" rel=""nofollow"">PIMPL</a> idiom and never include the implementation class headers as part of your library.</p>

<pre><code>class A
{
    Aimpl* a_;
public:
    int getValue();
};
</code></pre>

<p>Now users can access but never know the internals of Aimpl to modify it.</p>
",2
31903540,31903360,0,"<p>You can't prevent anyone to write seemingly valid and working code as you're showing.</p>

<p>Seemingly because </p>

<pre><code> *p = 5678;
</code></pre>

<p>is actually undefined behaviour, and can't be relied on giving the same results as yours.</p>
",0
31903667,31903360,4,"<p>Well, no, it is not possible to prevent a determined programmer from doing an explicit type conversion, since there is an almost unlimited number of ways a determined enough programmer can exercise - particularly if willing to accept potential undefined behaviour.</p>

<p>Philosophically, the C++ type system is generally designed to make it harder to do things by accident.   However, it is not designed to prevent a programmer from deliberately subverting the type system.</p>

<p>It is possible to make things more difficult by using combinations of techniques;</p>

<ol>
<li>Employ the pimpl idiom (already mentioned in the answer by parapura rajkumar)</li>
<li>Introduce an offset to members (including of the pimpl).  It will not necessarily be obvious to a programmer that the implementation details might be offset by 18 bytes, for example.</li>
<li>Supply a private <code>operator&amp;()</code> for your class, which will have an effect of preventing the use of <code>&amp;object</code> to get the address of an object.</li>
<li>Don't provide member functions that return <code>this</code>, and don't return an address of (or reference to) any private or protected class data.   And don't have public data.</li>
</ol>

<p>The thing is, however, a determined enough programmer will find a way to work around all sorts of tricks like this, even without access to source code.    These sorts of tricks also have the unfortunate effect of making it harder for developers to use your class in more usual ways that you might intend.</p>
",3
28471842,28471681,3,"<p>I recommend using a structure.
For example:</p>

<pre><code>struct students
{
     int name;
     int scoremath;
     int scoreenglish;
     int scoreoverall;
     int lettergrade;
}
</code></pre>

<p>Then you could use ifstream to read the data from the text file and fill out your structure. (Hint: Make a function that does this)</p>
",6
25503229,25503149,8,"<p>There is no filesystem facilities in the C++ standard. There is a technical specification for it which may be included in a future version of C++.</p>

<p>Until then, you will have to use platform specific functions or a library that wraps them. Apparently the new proposal is almost the same as boost's API, so I recommend using boost even if it's ubiquitousness wasn't good enough reason already.</p>
",6
27494633,27493716,3,"<p>Neither C nor C++ provide a 'works everywhere' solution.</p>

<hr>

<p>I have used '\r' to place the cursor on top of the 1st char in a line.
But this seems insufficient for your needs.</p>

<p>(By the way, I think you mean to have a '\n' at the end of each of your current printf.)</p>

<p>Example of use of carriage-return for overwrite:</p>

<pre><code>std::cout &lt;&lt; ""\r "" &lt;&lt; showProgressW("" "") &lt;&lt; std::flush;
</code></pre>

<p>The 'showProgressW()' generates a string including ""% complete"" and a ""byte count"" and other progress info during an operation that can take multiple 10's of seconds. During this operation, no other thread can write to the std::cout (which has thread unsafe issues). </p>

<hr>

<p>For text output (when the user device supports this), I find
ANSI escape sequences straight forward.    Example:</p>

<pre><code>inline void gotoxy (int col = 1, int row = 1) { printf (""\e[%d;%dH"", row, col );   };
inline void gotoxy (char *col, char *row)     { printf (""\e[%s;%sH"", row,  col);   };
</code></pre>

<p>With these functions, you can place the cursor back on top of the first char of any output field, then output the new value.  (I usually use std::cout instead of printf.)  There are quite a few other escape sequences, and combinations, that might be useful in simple efforts i.e.   cursor up (down, left, right) n lines </p>

<hr>

<p>For text output where a minimal 'windowing' style might be helpful, I use curses, which is somewhat more involved.</p>

<hr>

<p>I think the next choices involve gui i/o.  </p>
",0
27518162,18698059,-1,"<p>Use this:
g++ fileName.cpp -o Filename
That will output the file to be run.
I hope this will help you.
Regards
Martin Z</p>
",0
27518276,18698059,8,"<p>If you use <code>gcc</code> instead of <code>g++</code>, the C++ library is not automatically linked. This is from <code>man g++</code>:</p>

<blockquote>
  <p>However, the use of gcc does not add the C++ library.  g++ is a
  program that calls GCC and automatically specifies linking against the
  C++ library.  It treats .c, .h and .i files as C++ source files
  instead of C source files unless -x is used.  This program is also
  useful when  precompiling a C header file with a .h extension for use
  in C++ compilations.  On many systems, g++ is also installed with the
  name c++.</p>
</blockquote>

<p>As others have stated, either use <code>g++</code> directly or link <code>-lstdc++</code> at the end of your invocation. Something like <code>gcc main.cpp -lstdc++</code>.</p>
",0
31903792,31903712,4,"<p>You need to consider what are the aims of both concepts and policies.</p>

<p>Concepts establish strong assumptions about the class, both syntactically and semantically. For example, <code>Comparable</code> implies presence of comparison operators for the type as well as that certain axioms hold, i.e. <code>a == b -&gt; a is equivalent to b</code>, rather than any other implementation of <code>operator==</code>. Strong assumptions make code more predictable.</p>

<p>Policies, on the other hand, establish the actual behaviour of the class, with an emphasis on interchangeability. Every individual implementation of a policy does encompass one or more concepts; however, the variations of a policy that you plug into a class only share constraints. For example (pseudocode):</p>

<pre><code>// constraint Lockable -&gt; has Lock() and Unlock() methods

// concept RealLockable -&gt; constrained by Lockable, Lock() blocks other threads
// concept FakeLockable -&gt; constrained by Lockable, Lock() does nothing

class FakeLock; // a policy that embodies the concept FakeLockable
class Lock; // a policy that embodies the concept RealLockable
class RecursiveLock; // a policy that can also embody the concept of RealLockable

template&lt;class T, Lockable Lock&gt; // constrained by Lockable
class Queue;
</code></pre>

<p>A policy is an implementation technique to alter the behaviour of a target class. A concept is an explicit tool for establishing assumptions:</p>

<pre><code>template&lt;Comparable T&gt;
class PriorityQueue;
</code></pre>

<p><code>Comparable T</code> would not be a policy, in my opinion, because when you specify <code>PriorityQueue&lt;int&gt;</code> or <code>PriorityQueue&lt;double&gt;</code> you don't aim to change the behaviour: on the conceptual level, all these queues do is allow you to access min or max element in constant time. However, with some future syntax you can claim that <code>T</code> embodies mathematically correct semantics, i.e. <code>a &lt; b -&gt; b &gt; a</code>, and then <code>Comparable T</code> will be a concept.</p>

<p>In the end, every class, policy or not, represents a concept or two. Classes introduce concepts implicitly, concepts document them explicitly.</p>
",3
31904419,31903712,1,"<p>As far as what I understood from that book, <em>policy based design</em> isn't absolutely precise about a distinction from <em>concepts</em>. Merely because the latter term came up later historically.</p>

<p>Alexandrescu's policies are an early predecessor of what's understood as concepts nowadays. </p>

<p>Though there's a line:</p>

<p>Concepts won't ever change instantiation layout, while policies as introduced in the book could.</p>

<p>Somewhat I think a concept describes an interface, while a policy might participate in an interfaces implementation.</p>
",0
34179503,34179344,1,"<p>quick fix:</p>

<pre><code>unsigned char val = 0xfe;
...
ss2 &lt;&lt; ""#645"" &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; 
        (int) val;
</code></pre>

<p>or (as proposed by @Kerrek SB):</p>

<pre><code>ss2 &lt;&lt; ""#645"" &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt;
        static_cast&lt;unsigned int&gt;(static_cast&lt;unsigned char&gt;(val));
</code></pre>

<p>Note that if (on your platform) <code>char</code> defaults to <code>signed char</code>, then
<code>0xfe</code> is a negative number (-2).</p>

<p>In other words, if <code>char</code> is a <code>signed char</code> and <code>sizeof(int)</code> is 4, then
<code>(int)val</code> is <code>0xfffffffe</code>. That is what you get.</p>

<ul>
<li>-2 as <code>signed char</code>: <code>0xfe</code></li>
<li>-2 as <code>int</code>: <code>0xfffffffe</code></li>
</ul>
",2
34180848,34179344,1,"<p>I wouldn't bother with streams manipulators when it's easier to do it yourself (exploiting the implicit conversion to unsigned char).</p>

<pre><code>std::string hexb(unsigned char b) {
    const char *s=""0123456789ABCDEF"";
    return std::string(s[b&gt;&gt;4]) + s[b&amp;0xf];
}
</code></pre>

<p>Usage:</p>

<pre><code>std::cout&lt;&lt;hexb(val);
</code></pre>
",0
22115619,22115601,0,"<p>Please use</p>

<pre><code>cout&lt;&lt;
cin&gt;&gt;
</code></pre>
",0
22115620,22115601,4,"<p><code>std::cout</code> is an output stream only, so it doesn't define an input stream operator <code>&gt;&gt;</code>. It defines <code>&lt;&lt;</code>, so you need</p>

<pre><code>cout &lt;&lt; ""hello world"";
</code></pre>

<p>and so on.</p>

<p>The inverse is true for <code>std::cin</code>, so you need</p>

<pre><code>cin &gt;&gt; year;
</code></pre>
",0
22115624,22115601,2,"<p>You probably meant to write:</p>

<pre><code>cout &lt;&lt; "" Please enter the day of your birthday\n"";
cin &gt;&gt; day;
</code></pre>

<p>As a crib for these operators you can think of their directions pointing to where the result should go.</p>
",0
21718054,21717980,3,"<p>You can just use</p>

<pre><code>cin &gt;&gt; foo.nameFirst &gt;&gt; foo.nameLast;
</code></pre>

<p><code>cin &gt;&gt;</code> will parse stops at white spaces, so you can just input the full name in one line split by space like <code>James Bond</code>.</p>

<p>To combine two strings into one:</p>

<pre><code>string fullName = foo.nameFirst + "" "" + foo.nameLast;
</code></pre>
",0
23303111,23303040,2,"<pre><code>newNodePtr-&gt;board = board;
</code></pre>

<p>You do not copy the board here. Instead, you copy a pointer to the board. So all your 'nodes' store pointer to the very same board (which is the current state of the game).</p>

<p>You need to copy the contents of the board by allocating and copying the whole array.</p>
",5
21030543,21030514,4,"<blockquote>
  <p>is it because the compiler only looks once at the first condition of the second for-loop when it's initialized and after that only increases student_index until the second condition is met?</p>
</blockquote>

<p>Yes.</p>

<hr>

<p>The <code>for</code> syntax is:</p>

<pre><code>for (init; condition; increment)
</code></pre>

<p>in this case, the <code>init</code> statement makes use of the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a></p>

<blockquote>
  <p>In the C and C++ programming languages, the comma operator (represented by the token ,) is a binary operator that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type).</p>
</blockquote>

<p>The result ends up being something like:</p>

<pre><code>init;
while (condition) {
    ...
    increment;
}
</code></pre>

<p>And in this case init has multiple instructions because of the comma operator. So multiple things happen before the loop body and don't repeat inside the loop.</p>
",1
21030571,21030514,4,"<p>It's because of how a for loop works</p>

<p><code>for (&lt;initial expression(s)&gt;; &lt;condition&gt;; &lt;iteration(s)&gt;)</code></p>

<p>Each of those parts can be a full expression (which includes a comma-separated list of expressions).</p>
",2
21030580,21030514,1,"<p>Both are equivalent. The first (initialiser) clause of a <code>for</code> statement is only executed before the first iteration; so both <code>student_index</code> and <code>sum</code> are set to zero then. Between iterations, it executes the third (iteration) clause, then checks the second (condition) clause; neither of these do anything with <code>sum</code>.</p>

<p>If the initialser were executed each time, then the canonical <code>for</code> statement</p>

<pre><code>for (i = 0; i &lt; n; ++i) whatever;
</code></pre>

<p>would loop forever, resetting <code>i</code> to zero each time, and the construct would be completely useless.</p>
",1
21030638,21030514,1,"<p>If we look at the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf"" rel=""nofollow"">draft C++ standard</a> section <code>6.5.3</code> <em>The for statement</em> we can see this how <code>for</code> is described as follows:</p>

<blockquote>
  <p>for ( for-init-statement condition<sub>opt</sub>; expression<sub>opt</sub>) statement</p>
  
  <p>is equivalent to</p>

<pre><code>{
   for-init-statement
   while ( condition ) {
    statement
    expression ;
   }
 }
</code></pre>
</blockquote>

<p>We can see from section <code>6.5</code> that the <em>for-init-statement</em> is allowed to include an <em>expression statement</em>:</p>

<pre><code>for-init-statement:
   expression-statement
   simple-declaration
</code></pre>

<p>which in this case uses the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a>, to initialize both <code>student_index</code> and <code>sum</code>:</p>

<pre><code>student_index = 0, sum = 0 
                 ^                 
</code></pre>
",0
22109722,22109555,0,"<p>Your intention is unclear. To expand on @JohnZwicnk's answer...</p>

<p>A function signature includes its return type, its class object type (if it is a class member function), and its parameters - which means there is no trivial way to make a common 'Function type'.</p>

<p>That doesnt mean you can't assign different types of functions to the same object type - boost::function and boost::mem_function are two examples on how you can 'assign' a generic function with parameters to an object and pass it around before it is called.</p>

<p>If your intention is to just sequentially call each function without caring about the type, look at <a href=""http://en.wikipedia.org/wiki/Function_object"" rel=""nofollow"">functors</a> or the aforementioned boost::mem_function. Both of these allow you to either bind or assign parameters to the function call and delay the evaluation of the function for later.</p>
",0
22109991,22109555,14,"<p>Your question is a bit vague, but if you already know the target object and the arguments to the call at the time you insert the functions into the queue, you can use a queue of parameterless lambdas:</p>

<pre><code>std::deque&lt;std::function&lt;void()&gt;&gt; q;
c x;
q.push_back( [&amp;x] { x.foo1(1); } );
q.push_back( [&amp;x] { x.foo2(2,3); } );
// ... some time later we might want to execute the functions in the queue ...
while (!q.empty())
{
    q.front()();
    q.pop_front();
}
</code></pre>
",1
22109603,22109555,0,"<p>The short answer is that you can't.  A semi-straightforward way around this would be to make all the functions take a list or vector of arguments, where each argument is an int, or if you need to support more argument types, a Boost Variant.  Then all the functions can have the same signature, and their implementations will need to unpack their arguments.</p>

<p>If all the methods are within a single class, you could store them in a list as plain pointers to member functions.  That would be more efficient than storing them in std::functions, and more clear if you can get away with it.</p>
",0
26245186,18783341,0,"<p>It is a KNOWN bug in odbccp.lib included with the PSDK 7.1. Simplest workaround, just add this code to one of your sources:</p>

<pre><code>//---------------------------------------------------//
#include &lt;stdio.h&gt;
#include &lt;wtypes.h&gt;

extern ""C"" int _imp___vsnprintf(
    char *buffer,
    size_t count,
    const char *format,
    va_list argptr
    )
{
    return vsnprintf( buffer, count, format, argptr );
}
//---------------------------------------------------//
</code></pre>

<p>It resolves the missing external, by creating a wrapper with the missing name and redirecting it to the correct statically linked symbol.</p>

<p>Worked for me. :-)</p>
",0
22134480,22134451,2,"<p>What happens if an entry with key <code>""string""</code> isn't in the map? You get an iterator to the <code>end()</code> element. You can't de-reference that.</p>

<p>So, check if your map contains the element before de-referencing:</p>

<pre><code>auto it = Objlib.find(""string"");
Object* newObject = it == Objlib.end() ? nullptr : it-&gt;second-&gt;create();
</code></pre>

<p>This calls the <code>create()</code> method only if the element exists in the map. Otherwise, newObject is set to <code>nullptr</code>.</p>
",0
22440270,22440067,5,"<p>The type of a string literal like <code>""file""</code> is <code>char const[N]</code> (with a suitable <code>N</code>) whic happily decays into a <code>char const*</code> upon the first chance it gets. Although there is no addition defeined between <code>T[N]</code> and <code>int</code>, there is an addition defined between <code>char const*</code> and <code>int</code>: it adds the <code>int</code> to the pointer. That isn't quite what you want.</p>

<p>You probably want to convert the <code>int</code> into a suitable <code>std::string</code>, combine this with the string literal you got, and get a <code>char const*</code> from that:</p>

<pre><code>load((""file"" + std::to_string(i)).c_str());
</code></pre>
",1
22440320,22440067,1,"<p>It depends on what version of C++ you are using. If it's C++11, the solution will involve <code>std::to_string</code>. If it's an older version of C++, you can convert an integer to a string like this:</p>

<pre><code>#include &lt;sstream&gt;

// ...

std::ostringstream converter;
converter &lt;&lt; i; // i is an int
std::string s(convert.str());
</code></pre>

<p>Now, the <code>load</code> function takes a <code>const char *</code>. Is it your own function? Then consider changing it so that it takes a <code>std::string const&amp;</code> instead, and you'll be able to pass the string directly. Otherwise, this is how can pass the string's contents to it:</p>

<pre><code>load(s.c_str());
</code></pre>
",2
30715985,30715932,1,"<p>You should initialize the Base in the member initializer list:</p>

<pre><code>class Derived:public Base{
    public:
        Derived()
        :  Base()
        {}
};
</code></pre>

<p>However, this one is pointless. You can omit it, since it is the default constructor of Base:</p>

<pre><code>class Derived:public Base{
    public:
        Derived()
        {}
};
</code></pre>

<p>In your example you create an unused temporary Base object (However, the syntax is not correct).</p>

<p>Having:</p>

<pre><code>#include &lt;iostream&gt;

class Base{
    public:
        Base(){
            std::cout &lt;&lt; ""A Constructor\n\n"";
        }
};

class Derived:public Base{
    public:
        Derived(){
            Base();
        }
};

int main() {
    Derived d;
    return 0;
}
</code></pre>

<p>Produces:</p>

<pre><code>A Constructor

A Constructor
</code></pre>
",0
30716021,30715932,3,"<p>The following code:</p>

<pre><code>    Derived(){
        Base::Base();
    }
</code></pre>

<p>constructs a temporary <code>Base</code> in the constructor of the class and discards it. The line <code>Base::Base();</code> does not initialize the <code>Base</code> part of <code>Derived</code>.</p>

<p>The above code is equivalent to:</p>

<pre><code>    Derived() : Base() {
             // ^^^ This initializes the Base part of Derived.
        Base::Base();
    }
</code></pre>

<p>What you need is just:</p>

<pre><code>    Derived() {}
</code></pre>

<p><strong>Further Reading</strong></p>

<p><a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow noreferrer"">Constructors and member initializer lists</a><br>
<a href=""https://stackoverflow.com/questions/25470791/understanding-class-object-construction"">Understanding class object construction</a></p>
",6
30716125,30715932,1,"<p>You are not allowed to call a constructor directly, that's just how C++ works. It must be called internally as an object is created, or through placement new.</p>

<p>When you call <code>Base()</code> by itself without the qualifier, you're not calling the constructor, you're creating a temporary object. This calls the constructor obviously, but for the temporary object, not the one doing the call. If you output the address of the object in the constructor you'll see that they're not the same.</p>
",4
27490273,27490244,8,"<p><code>unsigned long</code> is not always sufficiently large. With 32 bits it can occupy integers from 0 up to and including 2<sup>32</sup>-1, which is about four billions. <code>9'110'865'112</code> is nine billions and would thus not fit into <code>unsigned long</code>.</p>

<p>Try outputting <code>sizeof unsigned long</code> and see what you get.</p>

<p>Also, consider your output: <code>9110865112</code> mod 2<sup>32</sup> is <code>520930520</code>, which basically proves that <code>unsigned long</code> is 32 bit large on your machine.</p>
",5
27490309,27490244,3,"<p>The problem is that the numeric literal that you specify is too large to fit in an unsigned long.</p>

<p>When you use the literal directly, the compiler treats it as <code>long long</code>, and chooses the proper overload for <code>operator &lt;&lt;</code>.</p>

<p>To fix this problem, use <code>unsigned long long</code> in the signature of the <code>Print</code> function:</p>

<pre><code>void Print(unsigned long long num)
{
    cout&lt;&lt;dec&lt;&lt;num&lt;&lt;endl;
}
</code></pre>

<p><a href=""http://ideone.com/pmHAsl"" rel=""nofollow"">Demo.</a></p>
",0
27490546,27490244,1,"<p>Because 9,110,865,112 is greater than 32 bits, the method is only accepting 32 of the bits even though you're trying to pass it more.</p>

<p>To fix this, you should use an <code>unsigned long long</code> data type for you <code>num</code> parameter. When you print it directly written as a constant, the code prints out find because the compiler says that constant is an <code>unsigned long long</code>, but when you pass it as an <code>unsigned long</code>, the compiler says that constant should be an <code>unsigned long</code>. Because it's not an <code>unsigned long</code>, it drops some of the bits. (I'm suprised your compiler didn't print out a warning.)</p>

<p>As a reference, an <code>unsigned long</code> can hold values between 0 and 4,294,967,295 (inclusive). Any value great than this should be assigned a larger data type. An <code>unsigned long long</code> can hold values between 0 and 18,446,744,073,709,551,615 (inclusive).</p>

<p>It is worth noting that frequently the data types <code>uint32_t</code> and <code>uint64_t</code> are used in place of <code>unsigned long</code> and <code>unsigned long long</code> respectively. The <code>u</code> denotes that the number is unsigned (if the <code>u</code> is left out, the number is assumed to be signed). The number (<code>64</code> and <code>32</code> in this case) states how many bytes the number should have. And <code>_t</code> at the end just indicates that this is a data type. So <code>(u)int#_t</code> is a common way to write numeric data types; <code>#</code> can be 8, 16, 32, or 64 in standard C++ depending on the number of bits you need.</p>

<p>To summarize: You're throwing a number that's too large at the function. You need to change your function's parameters to support this number:</p>

<pre><code>void Print(uint64_t num){
    cout &lt;&lt; dec &lt;&lt; num &lt;&lt; endl;
}
</code></pre>
",0
24090515,24090458,3,"<ul>
<li>Static members are initialized before the main starts, so they are <strong>already</strong> initialized in your main. Non static members of the class are initalized in the constructor.</li>
<li>If you want to enforce the initialization order (which is the case because one variable refers to the other), you can use a function to initalize the function <a href=""https://stackoverflow.com/questions/1005685/c-static-initialization-order"">C++ static initialization order</a>.</li>
<li>boost::call_once (or its c++11 equivalent) can help you for that. <a href=""http://www.boost.org/doc/libs/1_31_0/libs/thread/doc/once.html"" rel=""nofollow noreferrer"">http://www.boost.org/doc/libs/1_31_0/libs/thread/doc/once.html</a></li>
<li>The standard tells you that it has to be initalized somewhere outside the class definition, so generally you do it on the cpp file</li>
<li>Once this is done you can access the variables with <strong>Class</strong>::<strong>static_member</strong></li>
</ul>
",0
22161405,22161374,6,"<p>You don't define an <code>operator=</code> for <code>ticket</code> that takes a double as its argument. As a consequence you can't assign doubles to <code>ticket</code> objects.</p>
",1
22161439,22161374,0,"<p>you might want to have member function </p>

<p><code>set_price(const&amp; double price)</code> </p>

<p>so you can change the error code like this,which would be better</p>

<pre><code> if (t1.price &gt; t2.price)
        t3.set_price(t1.price);
    else
        t3.set_price(t2.price);
</code></pre>
",0
22890057,22889930,1,"<p>The predicate used for making the initial max_heap should be the same as the predicate used during sorting. A general solution that works with all random-access containers below, demonstrated with both a vector and a deque.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;random&gt;

template&lt;class T, template&lt;class,class...&gt; class C, class P, class... Args&gt;
void construct_heap(C&lt;T,Args...&gt;&amp; v, const P&amp; pred)
{
    std::make_heap(std::begin(v), std::end(v), pred); // &lt;&lt;== same predicate
    std::sort_heap(std::begin(v), std::end(v), pred);
}

template&lt;class T, template&lt;class, class...&gt; class C, class... Args&gt;
void print_seq(std::ostream&amp; os, const C&lt;T,Args...&gt;&amp; v)
{
    for (auto x : v)
        os &lt;&lt; x &lt;&lt; ' ';
    os &lt;&lt; '\n';
}

int main()
{
    std::random_device rd;
    std::mt19937 rng(rd());
    std::uniform_int_distribution&lt;&gt; dist(1,99);

    std::vector&lt;int&gt; v1;
    v1.reserve(25);
    std::generate_n(std::back_inserter(v1), v1.capacity(),
                    [&amp;](){ return dist(rng);});
    print_seq(std::cout, v1);

    std::deque&lt;int&gt; d1(v1.begin(), v1.end());
    print_seq(std::cout, d1);

    construct_heap(v1, std::greater&lt;int&gt;());
    print_seq(std::cout, v1);

    construct_heap(d1, std::greater&lt;int&gt;());
    print_seq(std::cout, d1);

    return 0;

}
</code></pre>

<p><strong>Output</strong> (obviously varies)</p>

<pre><code>16 6 52 81 7 95 72 76 40 68 9 77 66 73 44 7 64 44 3 58 89 24 51 43 26 
16 6 52 81 7 95 72 76 40 68 9 77 66 73 44 7 64 44 3 58 89 24 51 43 26 
95 89 81 77 76 73 72 68 66 64 58 52 51 44 44 43 40 26 24 16 9 7 7 6 3 
95 89 81 77 76 73 72 68 66 64 58 52 51 44 44 43 40 26 24 16 9 7 7 6 3 
</code></pre>
",1
31143643,31143211,0,"<p>Because of this line according to the debugger : <code>const int  SIZE = 6</code>. </p>

<p>Increase the size  to <code>32</code> or some number larger than <code>6</code>.
Some  passwords are longer than 6 characters.</p>
",6
23079101,23078387,0,"<p>The main problem appears to be stated in comments: if indeed structure of type <code>Trans_t</code> (which is not POD) is allocated using malloc (as OP commented), then the whole program is malformed.</p>

<p>As constructors for the Trans_t::segment_list&lt;> were never run, trying to push anything into it will cause either crash or exception. Here, it is quite possible that the ""value size"" parameter passed to standard allocator exceeds <code>max_size()</code> of that allocator (because it's essentially garbage in), so it throws bad_alloc upon receiving it as argument.</p>
",1
26446374,26446187,0,"<p>Member comparators should (almost) always be <code>const</code> functions that take <code>const</code> parameters, </p>

<pre><code>bool Word::operator&lt;(Word const&amp;) const;
</code></pre>

<p>Any function called within a <code>const</code> function must also be <code>const</code> itself</p>

<pre><code>std::string Word::GetWord() const;
</code></pre>

<p>(As @NeilKirk correctly points out this should probably return <code>std::string const&amp;</code>).</p>

<p>You should learn about <code>const</code> correctness as it can stop you from making silly mistakes in your code.</p>

<p>Also using a non-member comparator is usually preferred as it allows both sides of the expression to use conversion operators</p>

<pre><code>bool operator&lt;(Word const&amp; lhs, Word const&amp; rhs)
{
  return lhs.GetWord() &lt; rhs.GetWord();
}
</code></pre>
",0
34178592,34178478,3,"<p>You could make an empty base class, say:</p>

<pre><code>struct HasDump {};
</code></pre>

<p>And make <code>HasDump</code> a base of all your classes, that is:</p>

<pre><code>struct A : HasDump ( ...
</code></pre>

<p>Then wrap your <code>operator&lt;&lt;</code> with <code>std::enable_if</code> and <code>std::is_base_of</code> so it only applies when <code>HasDump</code> is a base of <code>T</code>.</p>

<p>(I haven't focused on C++ for a year or two so this advice might be a little rusty)</p>
",1
34178651,34178478,9,"<pre><code>template &lt;typename T, typename charT&gt;
auto operator&lt;&lt; (std::basic_ostream&lt;charT&gt; &amp; str, const T &amp; t) -&gt; decltype(t.dump(str))
{
    static_assert(std::is_same
                   &lt;decltype(t.dump(str)), 
                    std::basic_ostream&lt;charT&gt; &amp;&gt;::value, 
                  "".dump(ostream&amp;) does not return ostream&amp; !"");

    return t.dump(str);
}
</code></pre>

<p>This overloads <code>operator&lt;&lt;</code> only for types that define an appropriate <code>dump</code> member.</p>

<p>Edit: added static_assert for better messages.</p>
",7
34178835,34178478,1,"<p>Generally this would be the advisable way, IMO:</p>

<pre><code>struct A {
    int x = 5;

    friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const A&amp; a){
        return (os &lt;&lt; a.x);
    }
};
</code></pre>

<p>Reason: <a href=""https://stackoverflow.com/questions/2828280/c-beginner-friend-functions-and-operator-overloading-what-is-the-prope"">&#39;friend&#39; functions and &lt;&lt; operator overloading: What is the proper way to overload an operator for a class?</a></p>

<p>If you really want to have a dedicated dump method, you could define a base class ""collecting"" <em>dumpable</em> objects.</p>
",3
34179733,34178478,1,"<p>Just added this for fun. In case you happen to have more than one method that prints/dumps on different classes:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;type_traits&gt;

namespace tests {

    // this is a utility class to help us figure out whether a class
    // has a member function called dump that takes a reference to 
    // an ostream
    struct has_dump
    {
        // We will only be checking the TYPE of the returned
        // value of these functions, so there is no need (in fact we
        // *must not*) to provide a definition
        template&lt;class T, class Char&gt;
        static auto test(const T* t, std::basic_ostream&lt;Char&gt;&amp; os)
        -&gt; decltype(t-&gt;dump(os), std::true_type());

        // the comma operator in decltype works in the same way as the
        // comma operator everywhere else. It simply evaluates each
        // expression and returns the result of the last one
        // so if t-&gt;dump(os) is valid, the expression is equivalent to
        // decltype(std::true_type()) which is the type yielded by default-
        // constructing a true_type... which is true_type!


        // The above decltype will fail to compile if t-&gt;dump(os) is not
        // a valid expression. In this case, the compiler will fall back
        // to selecting this next function. this is because the overload
        // that takes a const T* is *more specific* than the one that
        // takes (...) [any arguments] so the compiler will prefer it
        // if it's well formed.

        // this one could be written like this:
        // template&lt;class T, class Char&gt;
        // static std::false_type test(...);
        // I just happen to use the same syntax as the first one to
        // show that they are related.

        template&lt;class T, class Char&gt;
        static auto test(...) -&gt; decltype(std::false_type());
    };

    // ditto for T::print(ostream&amp;) const    
    struct has_print
    {
        template&lt;class T, class Char&gt;
        static auto test(const T* t, std::basic_ostream&lt;Char&gt;&amp; os)
        -&gt; decltype(t-&gt;print(os), std::true_type());

        template&lt;class T, class Char&gt;
        static auto test(...) -&gt; decltype(std::false_type());
    };
}

// constexpr means it's evaluated at compile time. This means we can
// use the result in a template expansion.
// depending on whether the expression t-&gt;dump(os) is well formed or not
// (see above) it will either return a std::true_type::value (true!) 
// or a std::false_type::value (false!)

template&lt;class T, class Char&gt;
static constexpr bool has_dump() {
    // the reinterpret cast stuff is so we can pass a reference without
    // actually constructing an object. remember we're being evaluated
    // during compile time, so we can't go creating ostream objects here - 
    // they don't have constexpr constructors.
    return decltype(tests::has_dump::test&lt;T, Char&gt;(nullptr,
                                                   *reinterpret_cast&lt;std::basic_ostream&lt;Char&gt;*&gt;(0)))::value;
}

template&lt;class T, class Char&gt;
static constexpr bool has_print() {
    return decltype(tests::has_print::test&lt;T, Char&gt;(nullptr,
                                                   *reinterpret_cast&lt;std::basic_ostream&lt;Char&gt;*&gt;(0)))::value;
}

// so now we can use our constexpr functions has_dump&lt;&gt; and has_print&lt;&gt;
// in a template expansion, because they are known at compile time.
// std::enable_if_t will ensure that the template function is only
// well formed if our condition is true, so we avoid duplicate
// definitions.
// the use of the alternative operator representations make this
// a little more readable IMHO: http://en.cppreference.com/w/cpp/language/operator_alternative

template&lt;class T, class Char&gt;
auto operator&lt;&lt; (std::basic_ostream&lt;Char&gt;&amp; os, const T&amp; t)
-&gt; std::enable_if_t&lt; has_dump&lt;T, Char&gt;() and not has_print&lt;T, Char&gt;(), std::basic_ostream&lt;Char&gt;&amp;&gt;
{
    t.dump(os);
    return os;
}

template&lt;class T, class Char&gt;
auto operator&lt;&lt; (std::basic_ostream&lt;Char&gt;&amp; os, const T&amp; t)
-&gt; std::enable_if_t&lt; has_print&lt;T, Char&gt;() and not has_dump&lt;T, Char&gt;(), std::basic_ostream&lt;Char&gt;&amp;&gt;
{
    t.print(os);
    return os;
}

template&lt;class T, class Char&gt;
auto operator&lt;&lt; (std::basic_ostream&lt;Char&gt;&amp; os, const T&amp; t)
-&gt; std::enable_if_t&lt; has_print&lt;T, Char&gt;() and has_dump&lt;T, Char&gt;(), std::basic_ostream&lt;Char&gt;&amp;&gt;
{
    // because of the above test, this function is only compiled
    // if T has both dump(ostream&amp;) and print(ostream&amp;) defined.

    t.dump(os);
    os &lt;&lt; "":"";
    t.print(os);
    return os;
}



struct base
{
    template&lt;class Char&gt;
    void dump(std::basic_ostream&lt;Char&gt;&amp; os) const
    {
        os &lt;&lt; x;
    }

    int x = 5;
};
namespace animals
{
    class donkey : public base
    {

    public:
        template&lt;class Char&gt;
        void dump(std::basic_ostream&lt;Char&gt;&amp; s) const {
            s &lt;&lt; ""donkey: "";
            base::dump(s);
        }
    };

    class horse // not dumpable, but is printable
    {
    public:
        template&lt;class Char&gt;
        void print(std::basic_ostream&lt;Char&gt;&amp; s) const {
            s &lt;&lt; ""horse"";
        }
    };

    // this class provides both dump() and print()        
    class banana : public base
    {
    public:

        void dump(std::ostream&amp; os) const {
            os &lt;&lt; ""banana!?!"";
            base::dump(os);
        }

        void print(std::ostream&amp; os) const {
            os &lt;&lt; "":printed"";
        }

    };
}


auto main() -&gt; int
{
    using namespace std;

    animals::donkey d;
    animals::horse h;

    cout &lt;&lt; d &lt;&lt; "", "" &lt;&lt; h &lt;&lt; "", "" &lt;&lt; animals::banana() &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>expected output:</p>

<pre><code>donkey: 5, horse, banana!?!5::printed
</code></pre>
",3
23112843,23112737,4,"<p>You are using C (which mostly compiles as C++ as well), not C++ and you made a mistake doing so. You can either learn C or use C++, where it's harder to make those mistakes:</p>

<pre><code>#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main()
{
    double a = std::sqrt(2.0);

    std::cout &lt;&lt; ""Square root from 2 is "" &lt;&lt; a &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Additional explanation:</p>

<pre><code>printf(""Square root from 2 is %d\n"",a);
</code></pre>

<p>This prints a string and expects an integer (%d) to be passed. You passed a double, wich comes out as garbage. You can use (%lf) for doubles. </p>
",1
23112969,23112737,1,"<p>If you still want to stick to our example, please consider using %f rather than %d:</p>
",0
22476186,22476104,3,"<p>Reverse the loop</p>

<pre><code>for (size_t i = word.size()-1; i &gt;= 0; i--) {
   ...
</code></pre>

<p>If not for learning about loops, using the standard functions proposed in other answers are the right way to go. </p>
",2
22476197,22476104,4,"<p>It's already implemented as <a href=""http://www.cplusplus.com/reference/string/string/find_last_of/"" rel=""nofollow noreferrer"">the <code>find_last_of</code></a> and <a href=""http://www.cplusplus.com/reference/string/string/rfind/"" rel=""nofollow noreferrer"">the <code>rfind</code></a> methods of <code>std::string</code>.</p>

<p>I recommend using one of these methods, but if you still want to implement yourself, you have to reverse the order to start from the end and not the begining, and I think you are looking for <a href=""http://www.tutorialspoint.com/cplusplus/cpp_break_statement.htm"" rel=""nofollow noreferrer"">the <code>break</code> statement</a> which stops the loop:</p>

<pre><code>for (size_t i = word.size() - 1; i &gt;= 0; --i)
{
  if (word[i] == 'a')
  {
    cout &lt;&lt; pad &lt;&lt; (i + 1);
    break;
  }
} 
</code></pre>

<p>Break works like this:</p>

<p><a href=""http://www.tutorialspoint.com/cplusplus/cpp_break_statement.htm"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jaTlw.jpg"" alt=""break workflow""></a></p>
",3
22476282,22476104,2,"<p>You can use <code>std::string::rfind</code> to get the index of the last occurrence of some character:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    std::string s = ""banana"";
    std::string::size_type pos = s.rfind( 'a' );
    if ( pos == std::string::npos ) {
        std::cout &lt;&lt; ""letter not found\n"";
    } else {
        std::cout &lt;&lt; ""letter found at position "" &lt;&lt; pos + 1 &lt;&lt; ""\n"";
    }
}
</code></pre>
",0
22476286,22476104,2,"<p>The simplest way I can think of is to use the stl string find_Last_of function.  Below is a small example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main()
{
string word=""banana"";
int pos = word.find_last_of(""a"");
cout &lt;&lt; ""Last occurrence of the letter a is at position "" &lt;&lt; pos+1 &lt;&lt; "" array position "" &lt;&lt; pos &lt;&lt;endl ;
return 0; }
</code></pre>
",1
29461168,29461091,2,"<blockquote>
  <p>I know that static members don't belong to objects. But why is it so?</p>
</blockquote>

<p>Because you use <code>static</code> members whenever you have some quantity that all objects 
""share"", say for example the number of instances class Foo has. Such a ""shared"" member cannot belong to a particular instance. When a new <code>Foo</code> object is being created, then the static variable <code>num_instances</code> is incremented. If the variable wasn't static, then each new Foo will start with a clean state, and couldn't possibly know about other Foo's. Example:</p>

<pre><code>#include &lt;iostream&gt;

class Foo
{
    static int num_instances; // all instances share this variable
public:    
    Foo()
    {
        ++num_instances; // increment the number of instances
    }
    static int get_num()
    {
        return num_instances;
    }
};

int Foo::num_instances = 0;

int main()
{
    Foo foo1, foo2;
    std::cout &lt;&lt; ""We have "" &lt;&lt; Foo::get_num() &lt;&lt; "" Foo's"" &lt;&lt; std::endl;
}
</code></pre>

<blockquote>
  <p>And when is the memory for static data members allocated?</p>
</blockquote>

<p>The memory for static objects is allocated before program startup.</p>
",3
23587994,23587844,0,"<p>This:</p>

<pre><code> if (( size[b] = 'h','o','w','s','p') || (size[b] = 'H','O','W','S','P'))
 { letters++; b++; }
 else ( size[b] != 'h','o','w','s','p') || (size[b] != 'H','O','W','S','P');
 {cout &lt;&lt; ""\nAcceptable batting record codes are: 'H','O','W','S','P'. Please try again.\n"";}}
</code></pre>

<p>This is not C++. You cannot compare <code>size[b]</code> with a group of elements like that, besides <code>=</code> is an assignment operator, as when you are assigning a value to the variable. If you were to compare both, you should use <code>==</code>.</p>

<p>In <code>else</code> you don't include new conditions. It works as <em>if [condition] do { this }, or <strong>else</strong> do { something else }</em>. If you ever need to be further specific in conditions use <code>else if</code>.</p>

<p>There are many ways to achieve what you seem to want here. You can compare <code>size[b]</code> with each element you want, for instance:</p>

<pre><code>if ((size[b] == 'H') || (size[b] == 'h')
 || (size[b] == 'O') || (size[b] == 'o')
 || (size[b] == 'W') || (size[b] == 'w')
 || (size[b] == 'S') || (size[b] == 's')
 || (size[b] == 'P') || (size[b] == 'p')) {
    letters++; b++;
} else {
    cout &lt;&lt; ""\nAcceptable batting record codes are: 'H','O','W','S','P'. Please try again.\n"";
}
</code></pre>

<p>Or with <code>switch</code> for clearer looks:</p>

<pre><code>switch (std::tolower(size[b]))
{
    case 'h':
    case 'o':
    case 'w':
    case 's':
    case 'p':
        letters++;
        b++;
        break;
    default:
        cout &lt;&lt; ""\nAcceptable batting record codes are: 'H','O','W','S','P'. Please try again.\n"";
}
</code></pre>

<p>Or even with a <code>std::set</code> of valid elements:</p>

<pre><code>// at some part of program beginning
const char _dictionary[] = { 'h', 'o', 'w', 's', 'p' };
const std::set&lt;char&gt; dictionary(_dictionary, _dictionary + 5);

if (dictionary.find(std::tolower(size[b])) != dictionary.end()) {
    letters++;
    b++;
}
else {
    cout &lt;&lt; ""\nAcceptable batting record codes are: 'H','O','W','S','P'. Please try again.\n"";
}
</code></pre>
",1
33577759,33577718,0,"<p>The first off thing off my mind: </p>

<ol>
<li>Read the entire line as a string.</li>
<li>Use <code>strtok</code> with whitespace as delimiter.</li>
<li><code>strtok</code> will return each number in string form, call <code>atoi</code> on each input.</li>
</ol>

<p>This might not be the most elegant solution, but it works and you don't need to enter ""-1"" or anything at the end. Just enter space separated numbers, hit enter and you are done (Intuitive way of giving input).</p>
",0
33577774,33577718,0,"<p>Try this:</p>

<pre><code>while (true)
{
  float curNum;
  cin &gt;&gt; curNum;
  if (!cin)
    break;
  // do your logic here
}
</code></pre>
",0
33577796,33577718,0,"<p>Read them one at a time, not in pairs. Otherwise, it will read the first number on the next line into the second variable.</p>

<pre><code>for (stringCount = 0; stringCount &lt; repeatCount; stringCount++) {
    while (true) {
        cin &gt;&gt; digit2;
        if (digit2 == -1) {
            break; // get out of while loop
        }
        cin &gt;&gt; digit1;
        // do stuff with digit1 and digit2
    }
}
</code></pre>
",0
24624823,24624645,1,"<p>The pointer should be initialized to point to a specific memory address before it is used. If this was not the case, it could be pointing to anything. This can lead to extremely unpleasant consequences to the program. For instance, the operating system will probably prevent you from accessing memory that it knows your program doesn't own: this will cause your program to crash. If it let you use the memory, you could mess with the memory of any running program--for instance, if you had a document opened in Word, you could change the text! Fortunately, Windows and other modern operating systems will stop you from accessing that memory and cause your program to crash. To avoid crashing your program, you should always initialize pointers before you use them.</p>

<p>It is also possible to initialize pointers using free memory. This allows dynamic allocation of memory. It is useful for setting up structures such as linked lists or data trees where you don't know exactly how much memory will be needed at compile time, so you have to get memory during the program's execution.</p>
",3
24624850,24624645,4,"<p>Unless you have a particular reason not to, best to allocate on the stack rather than on the heap:</p>

<pre><code>#include &lt;iostream&gt;

void foo (int *count)
  *count = 90; 
}

int main() {
  int t; 
  foo(&amp;t); 
  std::cout &lt;&lt; t &lt;&lt; ""\n"";
}
</code></pre>

<p>If you really must allocate on the heap, prefer smart-pointers (like <code>std::unique_ptr</code>) to owning raw-pointers:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

void foo (int *count) {
  *count = 90; 
}

int main() {
  auto t = std::make_unique&lt;int&gt;();             // C++14
  // auto t = std::unique_ptr&lt;int&gt;(new int());  // C++11
  foo(t.get()); 
  std::cout &lt;&lt; *t &lt;&lt; ""\n"";
}
</code></pre>

<p>then you don't need to call <code>delete</code> (or <code>new</code> in C++14).</p>
",1
27517123,27517111,4,"<p>If you want to pass a pointer to a member-function, you need to use a member-function-pointer, not a pointer for generic free functions and an object to invoke it on.</p>

<p>Neither is optional.</p>

<pre><code>double fptr_test(test&amp; t, double (test::*fptr)(double), double input){
    return t.*fptr(input);
}

// call like this:
fptr_test(&amp;test::tt, 3); // Your second try
</code></pre>
",0
27517212,27517111,0,"<p>Here is a code after modification.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class test{

public:
    test(){};

    double tt(double input){
        return input;
    };

};

double fptr_test(test* t, double (test::*fptr)(double), double input){
    return (t-&gt;*fptr)(input);
}

int main(){

    test t;
    cout &lt;&lt; t.tt(3) &lt;&lt; endl;
    cout &lt;&lt; fptr_test(&amp;t, &amp;test::tt, 3) &lt;&lt; endl;

    return 1;
}
</code></pre>
",0
27517256,27517111,3,"<p>A function pointer and a member function pointer have incompatible types. For example, the type of <code>&amp;test::tt</code> is</p>

<pre><code>double (test::*)(double)
</code></pre>

<p>rather than</p>

<pre><code>double (*)(double)
</code></pre>

<p>The reason for this difference is that a [non-<code>static</code>] member function has a hidden parameter: the pointer to the object the member function is applied, too, i.e., <code>this</code>. The way to a normal function pointer out of a member function is to delegate via a function which supplies the <code>this</code> pointer and, thus, takes an extra argument.</p>

<p>In C++ it is much more useful to <em>not</em> take function pointers as arguments to functions which can be customized by a function but rather to take a <em>function object</em>. This approach comes in two flavors:</p>

<ol>
<li><p>The fast approach is to make the function object type a template argument and to just pass whatever function object you got directly. For example, you <code>fptr_test()</code> would look like this:</p>

<pre><code>template &lt;typename Fun&gt;
double fptr_test(Fun fun, double input) {
    return fun(input);
}
</code></pre>

<p>The implicit <em>concept</em> used is a function callable with a <code>double</code> argument which yields are result convertible to <code>double</code>.</p></li>
<li><p>Especially when the functions being called need to be compiled separately, using a template for each kind of function object isn't viable. In that case it is much more reasonable to use a type-erased representation, i.e., <code>std::function&lt;...&gt;</code>, e.g.:</p>

<pre><code>double fptr_test(std::function&lt;double(double)&gt; fun, double input) {
    return fun(input);
}
</code></pre></li>
</ol>

<p>In both cases the function object takes just one argument while your member function takes two: the object to call the function on and the <code>double</code> argument. You'd <code>std::bind(...)</code> the first argument to an object and pass the resulting object to <code>fptr_test()</code>:</p>

<pre><code>  test object;
  std::cout &lt;&lt; fptr_test(std:bind(&amp;test::tt, &amp;object, std::placeholders::_1), 3) &lt;&lt; '\n';
  std::cout &lt;&lt; fptr_test([&amp;](double input){ return object.tt(input); }, 3) &lt;&lt; '\n';
</code></pre>

<p>The code uses two separate approaches to bind the object: the first uses <code>std::bind()</code> while the second uses a lambda function. Both of these calls should work with both of the implementation of <code>fptr_test()</code> provided.</p>
",0
27517302,27517111,1,"<p>What you probably want is this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;
using namespace std;

class test{

public:
    test(){};

    double tt(double input){
        return input;
    };

};

double fptr_test( std::function&lt;double(double)&gt; func, double input){
    return func(input);
}


int main(){
    using namespace std::placeholders;

    test t;
    cout &lt;&lt; t.tt(3) &lt;&lt; endl;
    cout &lt;&lt; fptr_test( std::bind( &amp;test::tt, t, _1 ), 3) &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Btw - when your program finishes correctly you suppose to return 0 from <code>main()</code></p>
",0
22435789,22435773,2,"<p>If you do not want to change the logic that you have already developed, an easy solution is to take the input from the user and convert it into lower case. Then process it.</p>
",2
23557463,23557410,1,"<p>To be able to use argv numbers need to be supplied as arguments, i.e. </p>

<p>./program  23 45 67</p>

<p>For ./program &lt; input.txt you need to read from cin (standard input).</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int n;
int main()
{
   cin &gt;&gt; n;
   cout &lt;&lt; n;
}
</code></pre>
",0
23557482,23557410,2,"<p>You can do this:</p>

<pre><code>./program $(cat input.txt)
</code></pre>

<p>This does the trick.</p>

<p>For example, if input.txt has numbers separated by spaces:</p>

<p>33 1212 1555</p>

<p>Running: </p>

<pre><code>./program $(cat input.txt)  
</code></pre>

<p>prints 33 to the terminal.</p>
",0
23557494,23557410,3,"<pre><code>cout &lt;&lt; argv[1];
</code></pre>

<p>is equivalent to:</p>

<pre><code>char* arg = argv[1];
cout &lt;&lt; arg;
</code></pre>

<p>It just prints the value of the first argument to the program</p>

<p>In your case, you didn't provide an argument to the program.</p>

<p>When you use,</p>

<pre><code>./program &lt; input.txt 
</code></pre>

<p>the contents of <code>input.ext</code> becomes <code>stdin</code> of your program. You can process that using:</p>

<pre><code>int c;
while ( (c = fgetc(stdin)) != EOF )
{
   fputc(c, stdout);
} 
</code></pre>

<p>If you want to stay with C++ streams, you can use:</p>

<pre><code>int c;
while ( (c = cin.get()) != EOF )
{
   cout.put(c);
} 
</code></pre>
",2
22441192,22441137,5,"<p>Here is a problem</p>

<pre><code>for (int count = 0; count &lt; numOfGrades; count++)
{
    cout &lt;&lt; endl &lt;&lt; ""Please input a grade"" &lt;&lt; endl;
    int i = 0;
    cin &gt;&gt; grades[i];
    i++;
}
</code></pre>

<p>Here you define (and redefine over and over again) the variable <code>i</code> <em>inside</em> the loop! That means <code>i</code> will always be zero. You probably want e.g.</p>

<pre><code>cin &gt;&gt; grades[count];
</code></pre>
",1
30194721,30194685,10,"<p><code>mat4 result();</code> declares a function. Change it to <code>mat4 result;</code> to declare (and default-initialise) a variable.</p>
",4
22509560,22509234,3,"<p>What you are asking for is only possible if the searched string and the replacement string are the same length, or if the searched string is at the very end of the file.  Only then are you able to modify the source file directly.  Otherwise, if the two strings are different lengths, or the searched string is in the front/middle of the file, then it is simply not possible to modify the source file, you must create a separate temp file and then replace the source file when ready.</p>
",1
21578639,18627529,0,"<p>I just stumbled upon your question. The answer seems obvious. Take a look at your last lines:`
    void calcAverage (int score1, int score2, int score3, int score4, int score5)</p>

<pre><code>{
int findLowest(int, int, int, int, int, int);
int lowest;
double average;
 findLowest(score1, score2, score3, score4, score5, lowest);


average = (((float)score1 + score2 + score3 + score4 + score5) - lowest) / 4.0;
//cout &lt;&lt; setw(4);
cout &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(2);
cout &lt;&lt;"" With the grade ""&lt;&lt;lowest&lt;&lt; "" dropped""&lt;&lt;""The average of test scores entered is: "" &lt;&lt; average &lt;&lt; endl;
} `
</code></pre>

<p>Here <code>int lowest</code> is not initialized.
Try to write <code>int lowest(0);</code> or a similar initial value that suits your needs.</p>
",0
23070681,23070022,0,"<p>You have not only to allocate memory for the <code>gradebook</code>, but also for the <code>courses</code> and the <code>students</code>. For example:</p>

<pre><code>gradebook *info = new gradebook;
info-&gt;courses = new course_info[10];
for(int i = 0; i &lt; 10; i++)
    info-&gt;courses[i]-&gt;students = new student_info[10];
</code></pre>

<p>Beware, this example limits the number of courses and students per course to 10.</p>

<p>P.S.: Your code might work for one or two iterations if you don't allocate memory for the <code>courses</code> and the <code>students</code>. But in this case you screw up your memory.</p>
",0
23070756,23070022,0,"<p>You need to allocate the pointers <code>students</code> and <code>course</code> using <code>new</code>. </p>

<p>After getting loop:</p>

<p><code>students = new student_info* [loop]</code>
and</p>

<p><code>courses= new course_info* [loop]</code></p>
",0
23845857,23828589,0,"<p>You have a basic mis-understanding of sockets. If the port is already occupied, you CAN'T receive data on it with your program. That doesn't make any sense, and would be a massive security problem if you could do it.</p>

<p>If you want to see the data that's going to another program, you'll need a network sniffer like Wireshark.</p>
",1
24124673,24124618,13,"<p><code>push_back()</code> invalidates your iterator. Using it in your loop like this is an error because <code>i</code> does not need to have anything to do with <code>v</code> after <code>push_back()</code>.</p>
",0
24124880,24124618,2,"<p>The reason for the error is as stated in the other answer.  If you really wanted to <code>push_back(5)</code> for every item in the vector that is equal to 1,  the following code would have worked:</p>

<pre><code>    #include &lt;vector&gt;
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;

    using namespace std;
    int main() 
    {
       vector&lt;int&gt; v;
       v.push_back(1);
       v.push_back(2);
       v.push_back(3);
       v.push_back(4);
       v.push_back(1);
       v.resize(v.size() + std::count(v.begin(), v.end(), 1), 5);
       std::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;(cout, "" ""));
    }
</code></pre>

<p>Output:</p>

<pre><code>1 2 3 4 1 5 5
</code></pre>

<p>Basically, it's all accomplished in a single line of code using the <code>resize()</code> member for <code>vector</code>.  The <code>std::count</code> counts up the number of entries in the vector equal to 1.  Then the original vector is resized, and have the new elements set to 5.</p>
",0
24126491,24124618,0,"<p><strong>Analysis:</strong><br>
<code>v.push_back(5)</code> <strong>might</strong> reallocate the storage place if the new vector size exceeds its  capacity (Refer to <a href=""http://www.cplusplus.com/reference/vector/vector/push_back/"" rel=""nofollow"">http://www.cplusplus.com/reference/vector/vector/push_back/</a>).  <strong>If</strong> this happens, all the iterators are invalidated.  This causes your exception. </p>

<p><strong>3 Solutions:</strong> </p>

<p>(1) If you do not need to continue the iterations (i.e. you have to add a single item after the first occurence), then you could just add a <code>break;</code> after the conditional pushback() in order  to interrupt the loop.  THe rest of your programme will run without crash. </p>

<p>(2) If you know in advance that you might have to pushback AT MAXIMUM n elements, then you could simply increase the vector capacity in advance, before your iteration, with <code>v.reserve(v.capacity()+n);</code> </p>

<p>(3) The last possibility, if you are in the dark about potential insertions, then you shoud check the iterator position BEFORE the insertion, and then reloop to that position after the insert. This is done at a proportional performance cost but it works.  The if clause would look like:</p>

<pre><code>if (*i == 1) {
    cout &lt;&lt; ""op...""; 
    int j=i-v.begin(); 
    v.push_back(5);
    cout&lt;&lt;""Break the iteration at position "" &lt;&lt; j &lt;&lt;endl; 
    i=v.begin(); 
    for (++j; j; j--) 
        i++;
    }
</code></pre>

<p>I've tested all three solutions with VC 2013 and they seem to work.    </p>
",1
21788717,21788636,2,"<p>The <code>find</code> function returns an iterator that points to the first entry in your <code>user_list</code> that matches. You do not post a lot of code but in case your code looks like this:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

std::vector&lt;std::string&gt; user_list;
</code></pre>

<p>Then you can use <code>find</code> as follows:</p>

<pre><code>std::vector&lt;std::string&gt;::iterator i = find(user_list.begin(),
    user_list.end(), name)
if (i == user_list.end()) {
    // Not found
} else {
    // Found, *i is your string
}
</code></pre>
",0
22868920,22868887,6,"<p><code>size()</code> returns an unsigned type. With unsigned types, <code>0 - 1</code> ""underflows"" to the maximum value. Since <code>i</code> is less than the maximum possible value of the type it is converted to, the for loop is entered.</p>
",0
22869159,22868887,3,"<p>Your question shows why it is usually better to avoid <code>unsigned</code> for numbers which ""cannot be negative"" and why it is unfortunate that standard library classes don't go with this guideline. See <a href=""http://www.aristeia.com/Papers/C++ReportColumns/sep95.pdf"" rel=""nofollow"">Signed and Unsigned Types in Interfaces</a> by Scott Meyers.</p>

<p>Since <code>myVec</code> is empty, its size is 0, and your <code>myVec.size() - 1</code> expression becomes 0 - 1, which would be -1 if the type was signed. However, it is unsigned, so it becomes a huge positive number instead.</p>

<p>In C++98/03, a better way to to iterate through a vector is to use iterators:</p>

<pre><code>for (std::vector&lt;int&gt;::const_iterator iter = myVec.begin(); iter != myVec.end(); ++iter)
{
    int i = *iter;
}
</code></pre>

<p>In C++11, this can be written more concisely:</p>

<pre><code>for (auto iter = myVec.begin(); iter != myVec.end(); ++iter)
{
    int i = *iter;
}
</code></pre>

<p>Or even better, use a range-based <code>for</code> loop:</p>

<pre><code>for (auto i : myVec)
{
}
</code></pre>
",1
21165559,21162801,0,"<p>You may have skipped a pre-build script <code>generate</code>. I am considering this from viewing the GSLWrap's file <a href=""https://github.com/lrse/exploration/blob/master/gslwrap/generate"" rel=""nofollow""><code>generate</code></a> on GitHub. It looks like it can translate <code>#typeext#</code> to something else using <code>sed</code>. However, I am not able to find any documentation for that file.</p>
",0
32948611,32948566,1,"<p>It appears to be used here:</p>

<pre><code>TestIt(R, p, r, d, c, k, w, L, m, gens, ords);
</code></pre>
",1
32948963,32948566,0,"<p>It is used in <code>std::cerr</code> to form error message.</p>

<p>There is no rule that forces programmer to do something with variable, maybe it is just a flag that specifies something useful in error message.</p>

<p>Also it might be some backward compatibility. So function can be used with old code which passes 11 parameters and to be compatible with new-one that strictly specifies only 10 (but passes 11 anyway).</p>

<p>And there is a thing related to potential future problems, so <code>k</code> may be <em>reserved</em> variable and may become meaningful just in future (so for now you can pass anything).</p>

<p>It is hard to say because there may be a lot of different reasons, if you want truly right answer, you should contact person who wrote that code.</p>
",0
32949213,32948566,0,"<p>My bad, it is used at line 349 to compute <code>m</code>:</p>

<pre><code>long m = FindM(k, L, c, p, d, s, chosen_m, true);
</code></pre>

<p>then <code>m</code> is used to build the context at line 79:</p>

<pre><code>FHEcontext context(m, p, r, gens1, ords1);
</code></pre>

<p>So everything is fine now. Sorry for the annoyance.</p>
",0
22890492,22890416,2,"<p>You might just read each line:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;deque&gt;

int main()
{
    std::deque&lt;std::string&gt; names;
    std::ifstream infile(""names.dat"");
    std::string name;
    while(getline(infile, name))
        names.push_back(name);
    return 0;
}
</code></pre>

<p>Testing for EOF is often not a test for a successful input. Here the <code>getline</code> returns the stream and the condition <code>while(stream)</code> is testing the stream state.</p>

<p>Regarding the comment:</p>

<p>Have a <code>#include&lt;algorithm&gt;</code> and <code>std::sort(names.begin(), names.end());</code></p>
",4
22890441,22890416,1,"<p>Just use a 2D dimensional array then as follows:</p>

<h3>main.cpp</h3>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;iomanip&gt;
#include&lt;fstream&gt;

using namespace std;

int main()
{
    string first, last, myarray[200][2];

    ifstream infile;
    infile.open(""names.dat"");

    int i = 0;
    while (!infile.eof()) {
        infile &gt;&gt; first;
        myarray[i][0] = first;
        cout &lt;&lt; myarray[i][0] &lt;&lt; "" "";

        if (infile.eof()) {
            cout &lt;&lt; endl;
            break;
        }

        infile &gt;&gt; last;
        myarray[i][1] = last;
        cout &lt;&lt; myarray[i][1] &lt;&lt; "" "" &lt;&lt; endl;
        ++i;
    }
    return 0;
}
</code></pre>

<h3>Output</h3>

<pre><code>Collins, Bill
Smith, Bart
Allen, Jim
</code></pre>

<p>That being said, I would personally use std::array or some more intelligent container type in C++, in general.</p>
",1
22890450,22890416,1,"<p>Just use one array of strings instead of two.</p>

<pre><code>int main()
{
   string first, last, NAME[200];

   ifstream infile;
   infile.open(""names.dat"");
   int i = 0;

   while (true)
   {
      infile &gt;&gt; first;
      infile &gt;&gt; last;

      if (!infile.eof() &amp;&amp; infile.good() )
      {
         NAME[i] = last + "", "" + first;
         cout &lt;&lt; NAME[i] &lt;&lt; std::endl;
      }
      else
      {
         break;
      }
      ++i;
   }
   return 0;
}
</code></pre>
",1
22447467,22447441,2,"<p>You are passing <code>herp x</code> as a value type.  In this case <code>x</code> is a copy of whatever you pass in.  If you want to directly access <code>x.derp</code>, you should pass <code>x</code> in as a reference:</p>

<pre><code>void mderp(herp&amp; x, string y) {x.derp = y;}
</code></pre>

<p>This should allow <code>x.derp</code> to be modified.</p>
",0
22447469,22447441,1,"<p>The argument <code>herp</code> to is passed by value, that means it is a copy of the original <code>object_0</code>.  The <code>mderp</code> function modifies the copy, but that copy is thrown away immediately.  Try a reference.  I might do: </p>

<pre><code>class herp  
{
    private:
    string derp;

    public:
    static void mderp(herp &amp;x, string y) {x.derp = y;}
}

herp object_0;
string temp = ""asdf"";
object_0.mderp(object0, temp); 
</code></pre>

<p>Here the important thing is the change <code>herp x -&gt; herp&amp; x</code> which means the argument is ""a reference to herp"" rather than an actual herp value.  </p>

<p>In this case I also made the method static, because it can be but that is not essential.</p>
",0
22447482,22447441,1,"<p>replace</p>

<pre><code>x.derp = y;
</code></pre>

<p>with</p>

<pre><code>this-&gt;derp = y;
</code></pre>
",1
22447489,22447441,0,"<p>What I get from your question, is that you want to initialize the private variable of your class. But there are a couple of things wrong here. You should read more about classes.</p>

<p>One way:</p>

<pre><code>class herp
{
   private:
     string derp;

   public:
      void mderp(string y) {derp = y;}
 };


    herp object_0;
    string temp = ""asdf"";
    object_0.mderp(temp); 
</code></pre>
",0
22449676,22447441,0,"<p>There are two things you should probably know. </p>

<p>First of all your object's member variable does not get changed because the way you wrote your code, your function <code>mdepr</code> creates a copy of the object <code>herp</code>. It then changes its member variable and destroys the object upon leaving the function. So if you want to keep your function the way it is you should use a reference or a pointer. Example:</p>

<pre><code>void mderp(herp&amp; x, string y) {x.derp = y;}
void mderp(herp* x, string y) {x-&gt;derp = y;} 
</code></pre>

<p>The second thing is, based on your example usage of the function, you probably don't want a function like that. Member functions are meant to be used on a object and are allowed to modify it (unless they are const functions). So you can just write the following:</p>

<pre><code>class herp
{
private:
string derp;

public:
void mderp(string y) {derp = y;}
}

herp object_0;
string temp = ""asdf"";
object_0.mderp(temp);
</code></pre>

<p>Hope this helps :)</p>
",0
31153271,19898895,0,"<p>Seems as a <a href=""http://codeforwin.blogspot.in/2015/07/square-star-pattern-in-c.html"" rel=""nofollow"">basic star patterns looping exercise</a>. Use nested loops to print the required pattern</p>

<pre><code>for(i=1; i&lt;=n; i++)  
{  
    for(j=1; j&lt;=m; j++)  
    {  
        cout&lt;&lt;""*"";  
    }  
    cout&lt;&lt;""\n"";  
}
</code></pre>

<p>Here <code>n</code> is the number of rows and <code>m</code> is number of columns each row. </p>
",0
29453663,29453593,0,"<p>Converting the comment by @IgorTandetnik to an answer.</p>

<p>Replace the lines:</p>

<pre><code>if(firsta != firstb) 
    return firsta &lt;= firstb;
else
    return seconda &lt;= secondb;
</code></pre>

<p>by</p>

<pre><code>if(firsta != firstb) 
    return firsta &lt; firstb;  // Use &lt; not &lt;=
else
    return seconda &lt; secondb;
</code></pre>
",0
22491231,22491002,0,"<p>Take into account that the valid range of indexes is [0, 4]. There is no element a[5] in string a.</p>

<p>You can do the task the following way</p>

<pre><code>std::cout &lt;&lt; a.back() - '0' + b.back() - '0' &lt;&lt; std::endl;
</code></pre>

<p>Or</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

int main()
{

    std::string a = ""12345"";

    std::string b = ""23456"";

    std::transform( a.begin(), a.end(), b.begin(),
                    std::ostream_iterator&lt;int&gt;( std::cout, "" "" ),
                    []( char c1, char c2 ) { return ( ( c1 -'0' ) + ( c2 - '0' ) ); } ); 
    std::cout &lt;&lt; std::endl;

    return 0;

}
</code></pre>

<p>Or</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

int main()
{
    std::string a = ""12345"";
    std::string b = ""23456"";

    std::string c;
    c.reserve( a.size() );

    int overflow = 0;
    std::transform( a.rbegin(), a.rend(), b.rbegin(),
                    std::back_inserter( c ),
                    [&amp;]( char c1, char c2 ) -&gt; char
                    {
                        int s = ( c1 -'0' ) + ( c2 - '0' ) + overflow;
                        return ( overflow = s / 10, s % 10 + '0' );
                    } );
    if ( overflow ) c.push_back( overflow );

    std::reverse( c.begin(), c.end() );

    std::cout &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
",0
23067922,23067784,1,"<p>Your <code>if (answer == ""QUIT"")</code> is inside <code>if (answer == ""START"")</code>.</p>
",0
23067933,23067784,3,"<p>Move the <code>if (answer == ""QUIT"")</code> out of the <code>if (answer == ""START"")</code> block.</p>

<p>As of right now, it looks like this:</p>

<pre><code>if (answer == ""HELP"") {
    ...
}
if (answer == ""START"") {
    ...
    if (answer == ""QUIT"") {
        ...
    }
}
</code></pre>

<p>and it needs to be</p>

<pre><code>if (answer == ""HELP"") {
    ...
}
if (answer == ""START"") {
    ...
}
if (answer == ""QUIT"") {
    ...
}
</code></pre>
",0
22469074,22468970,0,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/seekg"" rel=""nofollow""><code>seekg</code></a> to reposition to the beginning of the template file after processing a line from the names file. You'll need to restructure your code to have two loops though.</p>
",0
31889033,31889006,4,"<p>You are missing a return statement in the function <code>convert()</code>.  You either need to make it a void function or return a string from it.</p>
",1
22494730,22494697,3,"<p>After the loop <code>a</code> and <code>b</code> have changed, they then point to the end of the string. You need to make a copy of the pointers to step through so that as you iterate you're not changing the location of <code>a</code> and <code>b</code>.</p>
",0
22494731,22494697,3,"<p>The problem is that you're outputting your temporary variables that were used to iterate through the array.  They are now at the end of the copied data.  You should output the value of <code>arrayA</code> and <code>arrayB</code> instead.</p>
",1
22494823,22494697,0,"<p>Remember begin of array. In this moment you are incrementing pointers and printing something which is pointed by them at the end of arrays, after loop ends.</p>

<pre><code>char arrayA[15] = ""abcdef"";
char arrayB[15];

char *a_beg = arrayA;
char *b_beg = arrayB;
char *a;
char *b;

cout &lt;&lt; ""before loop:"" &lt;&lt; endl;
cout &lt;&lt; a_beg &lt;&lt; endl;
cout &lt;&lt; b_beg &lt;&lt; endl;

a = a_beg;
b = b_beg;
while (*a != '\0') {
    // copy contents of a into b and increment
    *b++ = *a++;
}
// assign null to the end of arrayB
*b = '\0';

cout &lt;&lt; ""after loop:"" &lt;&lt; endl;
cout &lt;&lt; a_beg &lt;&lt; endl;
cout &lt;&lt; b_beg &lt;&lt; endl;
</code></pre>
",0
30213030,30212987,1,"<p>You did not define your function</p>

<pre><code>Player player(int indWd, int indHi);
</code></pre>

<p>in your .cpp file.</p>

<p>Also you need to either make it static in your <code>Player</code> class, or use an object to call it.</p>

<pre><code>Player p = player(world.getIndexWd(), world.getIndexHi());
p.load();
</code></pre>

<p>Possible would also be</p>

<pre><code>player(world.getIndexWd(), world.getIndexHi()).load();
</code></pre>

<p>but I would not recommend using it, as your <code>Player</code> object will be destroyed afterwards.</p>
",0
30213036,30212987,2,"<p>Rewrite as:</p>

<pre><code>void Game::load()
{
    Player p = this-&gt;player(world.getIndexWd(), world.getIndexHi());
    p.load();
}
</code></pre>

<p><code>player</code> is a member function in current class and you can not apply <code>.load</code> on it.</p>
",0
30213066,30212987,4,"<p>You've declared a member function called <code>player</code>, and you're trying to use that as if it were a variable.</p>

<p>I'm guessing that it's supposed to be a data member:</p>

<pre><code>Player player;
</code></pre>

<p>initialised in the <code>load</code> function:</p>

<pre><code>player = Player(world.getIndexWd(), world.getIndexHi());
player.load();
</code></pre>

<p>Although this won't work since it doesn't have a default constructor, so must be initialised in the constructor:</p>

<pre><code>Game::Game() : player(world.getIndexWd(), world.getIndexHi()) {}
</code></pre>

<p>which will only work if <code>world</code> has been initialised at this point.</p>
",6
22851303,22851282,5,"<p>You are reading bar twice and referencing it once for a function call, which increments it. That function call is indeterminately-sequenced with respect to the reads, which are unsequenced to each other, so any ordering is allowed, and it is unspecified which you get.</p>

<p>You don't quite have Undefined Behavior (everything goes), but Unspecified Behavior is not much more fun. These are the four valid outputs:</p>



<pre class=""lang-none prettyprint-override""><code>5 a 6 b 5
</code></pre>



<pre class=""lang-none prettyprint-override""><code>5 a 6 b 6
</code></pre>



<pre class=""lang-none prettyprint-override""><code>6 a 6 b 5
</code></pre>



<pre class=""lang-none prettyprint-override""><code>6 a 6 b 6
</code></pre>
",7
22857785,22851282,3,"<p>The ""chained insertion operators"" are just function calls. C++ has a few simple rules about the function calls in that statement:</p>

<ol>
<li>Function calls in a single statement do not interleave - one is finished before the next one starts. (I.e. no multi-threading inside a statement)</li>
<li>When the return value of one function call is the argument to another, the first function call must happen before the second.</li>
</ol>

<p>There's no rule that multiple arguments to a single function must be evaluated consecutively or immediately before the call - the set of ordering rules is really short.</p>

<p>Now what we see in the chain is that the different <code>operator&lt;&lt;</code> calls are indeed chained: the second call uses the return value of the first. That's why these operators all return <code>std::ostream&amp;</code>. Thus, your output appears in the correct order.</p>

<p><code>foo(bar)</code> by the same logic must be called <em>before</em> its return value is printed. But it can be called at any prior time. Recall there's no rule that 2 arguments to a single function must be evaluated at the same time. The two arguments to the third <code>operator&lt;&lt;</code> call are the return value of <code>foo(bar)</code> and the return value of the second <code>operator&lt;&lt;</code>. So, both must have happened when the third value is printed. It follows that the number printed after <code>a</code> is 6.</p>

<p>If you state that the result should be <code>5 a 6 b 6</code>, you are assuming that the second argument to the fifth call is evaluated after the second argument to the third call. There simply is no rule about that.</p>
",0
30199769,18944451,2,"<p>try to give protected as the access specifier in base class and inherit the base class in private mode.....but for further using member functions of base class u may need few short inline functions as they will also be converted to private</p>
",0
33001391,33001304,0,"<p>In the <code>battle</code> function you are calling <code>sortValues(d,e,f)</code>, but in the first 3 if-cases <code>f</code> does not get a value (thus is not initialized).</p>

<p>Actually you should get a similar error (is it really an error or a warning?) for <code>d</code> and in some of the cases you do not give a value to <code>a</code>,<code>b</code> and <code>c</code>.</p>
",4
23576396,23576383,1,"<p>My guess is that you need</p>

<pre><code>#include &lt;string&gt; 
</code></pre>

<p>in your .h file and that you need to prefix string with std::string there.</p>
",1
24385163,24384955,3,"<p>Since you're using VC2013 under Windows 7, the size of <code>unsigned long</code> is 4 bytes (not 8 bytes).</p>

<p>And in any case, for your own safety, you should use <code>sizeof</code> instead of those constant values of 8 and 2.</p>

<p>Change this:</p>

<pre><code>memcpy(&amp;ptrmtd, &amp;block[pos], 8);
pos+=8;
memcpy(&amp;ptrdt, &amp;block[pos], 8);
pos+=8;
memcpy(&amp;ptrind, &amp;block[pos], 8);
pos+=8;
memcpy(&amp;indmtd, &amp;block[pos], 2);
pos+=2;
</code></pre>

<p>To this:</p>

<pre><code>memcpy(&amp;ptrmtd, &amp;block[pos], sizeof(ptrmtd));
pos+=sizeof(ptrmtd);
memcpy(&amp;ptrdt, &amp;block[pos], sizeof(ptrdt));
pos+=sizeof(ptrdt);
memcpy(&amp;ptrind, &amp;block[pos], sizeof(ptrind));
pos+=sizeof(ptrind);
memcpy(&amp;indmtd, &amp;block[pos], sizeof(indmtd));
pos+=sizeof(indmtd);
</code></pre>
",2
24385200,24384955,0,"<p>Since <code>sizeof(unsigned long) == 4</code> on your system, <code>memcpy(&amp;ptrmtd, &amp;block[pos], 8);</code> can modify memory that is not yours. It is very dangerous, so never do it.</p>
",0
25694116,25694061,1,"<p>Suppose <code>Parent</code> doesn't have a user-provided constructor, e.g. if it is an aggregate:</p>

<pre><code>struct Parent
{
    int x;
    int get_value() const { return x; }
};
</code></pre>

<p>Now there's a difference (cf. [dcl.init]/(8.1)), since value-initialization of <code>Parent</code> will zero-initialize the member <code>x</code>, whereas default-initialization will not:</p>

<pre><code>struct GoodChild : Parent { GoodChild() : Parent() {} };

struct BadChild : Parent { BadChild() {} };
</code></pre>

<p>Therefore:</p>

<pre><code>int n = GoodChild().get_value(); // OK, n == 0

int m = BadChild().get_value();  // Undefined behaviour
</code></pre>
",3
29951960,29951714,0,"<p>This is undefined behavour. You leave the range of the <code>int</code> you are allowed to point to by incrementing the pointer. The compiler is allowed to do everything it wants to do with your code.</p>
",0
29951813,29951714,-4,"<p>This happened to me once when I was writing an operating system.</p>

<p>The bug took forever to find.</p>

<p>The heap was corrupted because one of my string functions wrote into adjacent memory.</p>
",0
22440560,22440528,2,"<p>With the original code:</p>

<pre><code>int b=-999;
bool t;
for(a;a&lt;=1000;a++)
{
    for(b;b&lt;=1000;b++)
</code></pre>

<p>you initialize <code>b</code> <em>once</em> only. Once the inner loop is done, and the outer restarts, <code>b</code> is not re-initialized, and the condition in the loop will be false. That means the inner loop will run only once, no matter how many times you run the outer loop.</p>

<p>With the new code you initialize <code>b</code> every time the inner loop starts.</p>
",1
29908742,29908630,0,"<p>I appended the code for the <code>TreeNode</code> class posted here into the question - TonyD</p>
",1
32983326,32983035,1,"<blockquote>
  <ol>
  <li>when i create the object on heap for the same inside FooVtable::bar() , it complains about no appropriate default constructor found. Why?</li>
  </ol>
</blockquote>

<p>That's a poor error message for a situation where you're trying to use a class before it has been fully declared. On a different compiler the message could be more like ""error: invalid use of incomplete type 'class Foo'"".</p>

<p>One way to solve it would be to put the full <code>struct Foo</code> stuff above <code>FooVtable</code> and then use a forward declaration of <code>FooVtable</code> instead of <code>Foo</code>.</p>

<blockquote>
  <ol start=""2"">
  <li>I see that vptr points to some address(even though there is no new FooVTable done for vptr,i guess ctor by default does it. is it expected?), FooVtable::bar is getting called but cout doesnt print the statement. Why?</li>
  </ol>
</blockquote>

<p>That <code>vptr</code> is uninitialized. Primitive types like pointers aren't initialized to any kind of default value by just a <code>new</code>. So whatever is in there is garbage. That much is expected.</p>

<p>Whatever happens after you call a function via a pointer with a garbage value is Undefined Behavior. So just about anything could happen and there wouldn't be a guaranteed explanation.</p>

<p>However in this case there's also another problem: You've made a typo. <code>cout&lt;""FooVTable :  bar"";</code> has a single <code>&lt;</code> and thus would do a strange and useless comparison instead of outputting anything.</p>

<blockquote>
  <ol start=""3"">
  <li>foo->vptr->bar should actually call a pointer to member function Foo::bar() , which i guess isnt directly possible</li>
  </ol>
</blockquote>

<p>Pointers to member functions are possible. You could potentially use one in the situation you've created so far. However once you start bringing inheritance into the scenario (which is where virtual functions are finally useful), it could get interesting to try to make this work out between the different types. (I use member function pointers so rarely that I can't say offhand.)</p>

<blockquote>
  <p>Am i approaching it right, or is there a better way to approach this?</p>
</blockquote>

<p>It really depends on how much of a real implementation you're trying to ""simulate"" and what you're hoping to achieve by it.</p>
",0
25535004,25534679,3,"<p>if difference can be negative (e.g. on input <code>2 0 10000</code>) then <code>container[difference]</code> uses negative index (e.g. <code>container[-10000]</code>) and that will cause segfault </p>

<pre><code>  for(int i=0; i&lt;cap-1; i++){
      difference = list[i] - list[i+1];
      if(abs(difference) &lt; cap &amp;&amp; abs(difference) &gt;= 1 &amp;&amp; container[difference] == false){
</code></pre>

<p>rather use:</p>

<pre><code>  for(int i=0; i&lt;cap-1; i++){
      difference = abs(list[i] - list[i+1]);
      if(difference &lt; cap &amp;&amp; difference &gt;= 1 &amp;&amp; container[difference] == false) {
</code></pre>

<p>....if that is what you want (I don't know what is the purpose)</p>
",2
33512068,33510546,1,"<p><code>INVALID_HANDLE_VALUE</code> is defined as <code>-1</code>, while OpenProcess returns NULL if the function fails.  I don't know what <code>GetModuleFileNameEx</code> will do if given a NULL process handle, but if HMODULE is NULL the name of the current executable is returned so it might do that for other invalid input.</p>

<p>According to the MSDN documentation for <code>GetModuleFileNameEx</code>, the recommended way to get the name of the executable for a process is by calling <code>GetProcessImageFileName</code> and not <code>GetModuleFileNameEx</code>.  You'll have to resolve your issue with <code>OpenProcess</code> first.</p>
",2
21298536,21298508,2,"<p>Yes, not that it means much in C++. Tail call elimination isn't required by C++; compilers can do it sometimes, but they quite often won't. You can't rely on it like you would in Scheme.</p>
",2
31854523,31854284,2,"<p><a href=""https://isocpp.org/wiki/faq/cpp14-language"" rel=""nofollow"">C++14</a> is a version of the C++ standard. The standard specifies the types, syntax, semantics, etc that all C++ compilers must (try to) adhere to.</p>

<p><a href=""http://orwelldevcpp.blogspot.com/2012/02/dev-c-5110-released.html"" rel=""nofollow"">Dev-C++ 5.1</a> is a version of an IDE, of which there are many others. It uses GCC under the hood as the compiler. Depending on the GCC version, it may support different iterations of the C++ standard, which will affect which library features are available.</p>
",0
31854746,31854284,15,"<p><strong>C++14 is an international language standard</strong>, formally entitled ISO/IEC 14882:2014(E). The nomenclature indicates that this is the version of the C++ language published by ISO in 2014.</p>

<p><strong>C++ 5.1 does not exist</strong>. In the 1980s there were versions of pre-standard ""C++"" that Bjarne Stroustrup created for fun, variously called C++ 1.0 and C++ 2.0. However, this versioning system did not reach 5.1 by the time the language became standardised as ISO/IEC 14882:1998(E) in 1998.</p>

<p>It is possible that you are instead referring to the version number of some Integrated Development Environment (a piece of software for your computer, consisting of a text editor and wrapping a compiler/debugger). For example, you could be talking about version 5.1.0.0 of the IDE fork known as ""Orwell Dev-C++"", <a href=""http://orwelldevcpp.blogspot.co.uk/2011/12/dev-c-5100-released.html"">which dates back to 2011</a>.</p>

<p>On the other hand, if these are options presented to you as languages in some online tool, the tool is <em>wrong</em>. For example, <a href=""http://ideone.com"">ideone.com</a> offers <a href=""https://goo.gl/W6iPtK"">""c++ 5.1"" which is, apparently, GCC 5.1 in C++98 mode</a>.</p>
",8
26193190,26193136,5,"<p>You should put them in different namespaces:</p>

<pre><code>namespace Mode2
{
  class Draw{
    private:
        // private stuff
    public:
        Draw(int x, char y);
  };
}
</code></pre>

<p>In main you can then select the namespace you want to use:</p>

<pre><code>#include ""Mode_1.h""
#include ""Mode_2.h""

using namespace Mode2;

int main()
{
    Draw D;

    int x = 2;
    char y = 'x';

    D.Draw(x, y);

    return 0;
}
</code></pre>
",0
26193223,26193136,3,"<p>You may try like this:</p>

<pre><code>#ifdef MODE1
#include ""Mode_1.h""
#else
#include ""Mode_2.h""
#endif

int main(){
    Draw D;

    int x = 2;
    char y = 'x';

    Draw(x, y);
}
</code></pre>

<p>And compile this source file with -DMODE1 or none depending on you wish to include Mode_1.h or Mode_2.h</p>
",0
23592518,23592473,0,"<p><code>push_back</code> pushes to the back of the array, i.e appends after the <code>n</code> elements that you create in the constructor. You can use <code>[]</code> operator to set the elements individually. Or if you are setting them all to the same, I think there is a constructor for that.</p>
",0
23592532,23592473,0,"<p>no need to create the <code>a</code> Array with <code>n</code> objects..
simply get <code>n</code> numbers from the users and use the <code>set</code> method to push them into the vector</p>
",0
22519873,22519829,6,"<p>You could allow <code>data</code> to exist in the class, but default its value to <code>NULL</code>. When you <code>delete []</code> it, it will be a <code>nop</code> if it was not allocated. </p>

<p>If you're using C++11, use <code>nullptr</code> instead of <code>NULL</code>, as it is safer (because <code>nullptr</code> does not convert to integral type, and <code>NULL</code> is usually defined as <code>0</code>)</p>

<p>Alternatively, create <code>data</code> as a <code>vector&lt;float&gt; data</code> instead of a <code>float*</code>, and you don't need to do anything in the destructor. You're not really wasting any memory if you never add anything to the vector. (Thanks Manu343726 and Malloc)</p>
",4
22519921,22519829,0,"<p>You could also defer all this logic to vector.  When your class is destructed the vector destructor will take care of all cases. In general vector is an acceptable solution to buffers. </p>

<pre><code>class Class {
  public:
    void func()
    {
      if (A) {
        // do something
      } else if (B) {
        // need data buffer, which we will recycle
        MyVector.resize(1000000,0.0);
        // do something with the data
      } else {
        ...
      }
    }
   private: 
      vector&lt;float&gt; MyVecto_;

  }
}
</code></pre>
",0
22519962,22519829,1,"<p>Embrace <code>std::vector</code></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

class Class {
public:
  void func(bool test)
  {
    if (test) {
      data_.resize(1000000);
    }
  }

  ~Class() {
    std::cout &lt;&lt; ""Destroying data of size: "" &lt;&lt; data_.size() &lt;&lt; std::endl;
  }

private:
  std::vector&lt;float&gt; data_;
};

int main() {
  Class A;
  Class B;

  A.func(true);
  B.func(false);
}
</code></pre>

<p>This prints:</p>

<pre><code>Destroying data of size: 0
Destroying data of size: 1000000
</code></pre>

<p><a href=""http://ideone.com/U1JxPT"" rel=""nofollow"">Live Demo</a></p>
",0
22517877,22517763,0,"<p>There are at least two approaches</p>

<pre><code>( *getDataset().getProperties() )[""Key""]

getDataset().getProperties()-&gt;operator []( ""Key"" )
</code></pre>
",0
22517783,22517763,3,"<pre><code>getDataset().getProperties()-&gt;operator[](""Key"");
</code></pre>

<p>or</p>

<pre><code>(*getDataset().getProperties())[""Key""];
</code></pre>
",0
22517811,22517763,0,"<p>I would prefer:</p>

<pre><code>(*getDataset().getProperties())[""Key""];
</code></pre>
",1
22443359,22443321,0,"<p>In the constructor:</p>

<pre><code>Property(PropertyCollection * propertyCollection, std::string key, std::string value);
</code></pre>

<p>Your constructor:</p>

<pre><code>Property(Property * propertyCollection, std::string key, std::string value);
</code></pre>

<p>Pass an address of an object of <code>PropertyCollection</code>, or create new constructor.</p>
",3
22443376,22443321,1,"<p>You need to put the default parameter in the member function <em>declaration</em>, i.e. in the header file, not in its <em>definition</em>:</p>

<pre><code>class Property
{
  public:
    Property(PropertyCollection * propertyCollection, std::string key, 
      std::string value, uint32_t identifier = 0);
</code></pre>

<p>In the code you've shown, <code>main</code> can only see <code>Property::Property(PropertyCollection*, std::string, std::string, uint32_t)</code>.</p>
",1
22443402,22443321,4,"<p><strong>The why</strong></p>

<p>It seems as if you are including <code>properties.h</code> from your <em>main</em> source code and later link against what is inside <code>properties.cpp</code>, which is totally fine in trivial cases.</p>

<p>But when doing what you are doing there's no way for the compiler to know (at time of compiling <em>main</em>) that the constructor you are trying to invoke has a default parameter (this isn't know until you are linking against <code>properties.cpp</code>).</p>

<p>In <em>main</em>  the compiler only knows what you have told it, more specifically it only knows about </p>

<pre><code>Property::Property (PropertyCollection * propertyCollection, std::string key, 
  std::string value, uint32_t identifier);
</code></pre>

<hr>

<p><strong>The solution</strong></p>

<p>The simple, and recommended, solution is to move the <em>default-value specification</em> to the constructor declaration in <code>properties.h</code>, this way the compiler will have all the information required to make things work the way you intend.</p>

<hr>
",0
22443573,22443321,1,"<p>The solution has already provided in a the answer by juanchopanza. I'm going to present how the .h file and the .cpp file should look after the change.</p>

<p><strong>properties.h</strong></p>

<pre><code>class Property
{
  public:
    Property(PropertyCollection * propertyCollection, std::string key, 
      std::string value, uint32_t identifier = 0);
</code></pre>

<p><strong>properties.cpp</strong></p>

<pre><code>Property::Property(PropertyCollection * propertyCollection, 
  std::string key, std::string value, uint32_t identifier)
  : propertyCollection(propertyCollection), key(key), value(value), 
    identifier(identifier) {}
</code></pre>
",0
26188563,26188535,1,"<blockquote>
  <p>Is it possible that sizeof(SegmentParameterDataRecord) could be different from a 15-year old Borland compiler to today's MinGW?</p>
</blockquote>

<p>This is definitely possible. In fact, <code>sizeof(int)</code> can be different across compilers and across machines. For example, on a 32-bit machine, <code>sizeof(int)</code> is often 4 bytes, but on a 64-bit machine, <code>sizeof(int)</code> can be 8 bytes.</p>
",7
22852966,22852885,2,"<p>This is an error:</p>

<pre><code>this.myString = std::string(aString);
</code></pre>

<p>It should be <code>this-&gt;myString</code>.  (I have heard there is a compiler that implements using <code>.</code> on pointers as an extension... uggh)</p>

<p>Anyway, the effects of this line are:</p>

<ol>
<li>Create a temporary object of type <code>std::string</code>, initialized by passing <code>aString</code> to its constructor. That constructor copies from your <code>char *</code> into memory which the <code>std::string</code> constructor allocates within the temporary object. A <code>std::string</code> object internally contains a pointer to some allocated storage; it doesn't refer to your string literal any more after this step.</li>
<li>Call <code>this-&gt;myString::operator=(std::string const &amp;)</code>, where the temporary object binds to the const reference. The <code>std::string::operator=</code> function increases the memory allocation in the target string, and copies bytes over from the source string. (It doesn't ""share"" the allocation or anything).</li>
<li>Destruct the temporary object (and <code>std::string</code>'s destructor deletes the pointer to its storage for the string contents).</li>
</ol>

<p>The end result is that the string contents get copied by value into <code>myString</code> , there are no memory leaks. After Step 2, there are briefly two copies in memory of the string contents.</p>

<p>Note that the compiler may optimize all stages of this process, so if you inspect your generated assembly it may look different. But conceptually, this is the defined list of steps.</p>

<p>I guess you might be coming from Java... if so, C++ has <em>automatic allocation</em> for all data types (whereas Java only has it for primitive types). You can go <code>T(args)</code> anywhere you like, and create a temporary T which lives until the end of the full-expression in which it was created.</p>
",5
22854488,22852885,1,"<p>Answering your <strong>Edit</strong>, which is actually a completely separate question to the original.</p>

<p>In this code:</p>

<pre><code>void createMyStruct(MyStruct_t aStruct, char *text);

MyStruct_t example;
createMyStruct(example, ""Hi!"");
</code></pre>

<p>You pass <code>example</code> <strong>by value</strong> to <code>createMyStruct</code>. The <code>example</code> is copied (which has bogus semantics because you have not properly defined a copy-constructor etc. for <code>MyStruct_t</code>) and the changes in that function have no effect on <code>example</code>.</p>

<p>Let's say that instead you decided to pass by reference:</p>

<pre><code>void createMyStruct(MyStruct_t &amp;aStruct, char *text){
   char str[10];
   strcpy(str,text);
   aStruct-&gt;p = str;
}
</code></pre>

<p>In this code, <code>str</code> is a local char array in <code>createMyStruct</code>. It no longer exists once <code>createMyStruct</code> ends.</p>

<p>After this function exits, <code>aStruct-&gt;p</code> (i.e. <code>example.p</code>) is a wild pointer. </p>

<p>Nothing like this is happening in the <code>string</code> case, not even close. </p>

<p>If you wrote <code>char *str = malloc(10);</code> instead of <code>char str[10];</code> it would be slightly more resembling the original example.</p>

<p>The <code>std::string</code> class manages the storage of the string data. It doesn't point at some external char array.</p>
",1
22853656,22852885,0,"<p>I think you should understand <code>this</code> keyword in C++.</p>

<blockquote>
  <p>The keyword this identifies a special type of pointer. Suppose that
  you create an object named x of class A, and class A has a nonstatic
  member function f(). If you call the function x.f(), the keyword this
  in the body of f() stores the address of x. You cannot declare the
  this pointer or make assignments to it.</p>
</blockquote>

<p>So you should use </p>

<pre><code>MyClass(char *aString)
{
   this-&gt;myString = std::string(aString); // there is no need to use this
}
</code></pre>
",0
23606679,23606514,4,"<p>&lt;&lt; and >> are shift operators, that move the bits of the variable by arg2 positions...</p>

<p>So if you have:</p>

<pre><code>11001010 &lt;&lt; 2
</code></pre>

<p>you would move the entire bitstring two to the left. This actually pushes the first two (form the left) bits out of the variable, and from the right side some 0's are pushed in. So:</p>

<p>11001010 &lt;&lt; 2 = 00101000</p>

<p>In your question, you are making a rotate shift.</p>

<p>so lets assume arg1 = 11001010 (in binary) and arg2 = 2, and as we use a 8bit integer, we replace the 32 by an 8.</p>

<pre><code>((11001010 &lt;&lt; 2) | (11001010 &gt;&gt; (8 - 2)))
= (00101000 | 00000011)
</code></pre>

<p>And now the | connects the two bitstrings to one, so if a bit is set in one string, it will now be also set in the result:</p>

<pre><code>(00101000 | 00000011) == 00101011
</code></pre>

<p>So what is your piece of code actually doing? It is called a circular or rotate shift... The bits it pushes out on one side, it actually pushes in from the other side. So you can rotate the bitpattern around, instead of just shifting one side into nothing and adding zeros on the other side.</p>
",2
23607371,23606514,1,"<p>This will apply <a href=""http://en.wikipedia.org/wiki/Circular_shift"" rel=""nofollow"">circular shift</a>.</p>

<p>Let's take an example:</p>

<pre><code>uint32_t _arg1 = 0xc2034000;
uint32_t _arg2 = 2;
</code></pre>

<p>so binary</p>

<pre><code>_arg1 = 11000010000000110100000000000000

_arg2 = 00000000000000000000000000000010
</code></pre>

<h2>(_arg1 &lt;&lt; _arg2)</h2>

<p>shifts _arg1 to the left by _arg2 bits, in fact this means take a number created by dropping _arg2 number of bits from _arg1 (starting from left and adding 0 as added values)</p>

<pre><code>_arg1 = 11000010000000110100000000000000
        ^^

result is 00001000000011010000000000000000
</code></pre>

<h2>_arg1 >> (32 - _arg2)</h2>

<p>shifts _arg1 to the right by ( 32 - _arg2) bits, in fact this means take a number created by dropping (32 - _arg2) number of bits from _arg1 (starting from the right and adding 0 as added values), so <strong>take those _arg2 bits that were dropped previously</strong></p>

<pre><code>_arg1 = 11000010000000110100000000000000
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

result is 00000000000000000000000000000011
</code></pre>

<h2>((_arg1 &lt;&lt; _arg2) | (_arg1 >> (32 - _arg2)))</h2>

<p>This will concatenate both applying logical OR operation on each two corresponding bits in left and right hand side arguments. </p>

<pre><code>((_arg1 &lt;&lt; _arg2) | (_arg1 &gt;&gt; (32 - _arg2)))
 result is  00001000000011010000000000000011
</code></pre>

<hr>

<p>std::bitset can be really helpful for playing with bit sets as you can easily visualize what is going on in your code.</p>

<p><a href=""http://ideone.com/jgRvWo"" rel=""nofollow"">http://ideone.com/jgRvWo</a></p>
",0
23606907,23606514,0,"<p>break the statement into small parts, first take (_arg1 &lt;&lt; _arg2) which means
1 &lt;&lt; 20, now calculate the value if 1 shifted towards left by 20 positions then the binary values looks like 100000000000000000000 (each time 1 is shifted towards left 0 will be filled in the position of 1) which results into 1048576.</p>

<p>Now take the other part, (_arg1 >> (32 - _arg2))) which means
1 >> 12. since 1 is the least positive value so if we move 1 towards right by even one position it will become 0. </p>

<p>Our two parts are done now we will do a bitwise OR of the two results we have got i.e.
    100000000000000000000 | 0</p>

<p>which we will put like </p>

<pre><code>100000000000000000000
                    0
</code></pre>

<p>now we will do OR each bitwise(vertically) of the two values, which will give us 100000000000000000000 whose decimal value is 1048576.
You can refer following table for bitwise OR operations.</p>

<pre><code>0 0    = 0
0 1    = 1
1 0    = 1
1 1    = 1
</code></pre>
",0
33591038,33590982,0,"<p>Get out of the habit of explicitly calling destructors.  Such an act does not reinitialise the object or its (non-static) members - it logically destroys the object so it cannot be used.</p>

<p><code>this-&gt;~ClassB()</code> makes any attempt to access non-static members of the current object (i.e. <code>*this</code>) give undefined behaviour.</p>

<p>For example, in the copy constructor of <code>ClassB</code></p>

<pre><code>ClassB::ClassB(ClassB&amp; src)
{
    this-&gt;~ClassB();

    pA = new ClassA[1];
    pA[0] = src.pA[0];
}
</code></pre>

<p>the accesses of <code>pA</code> in the last two statements are (implicitly) <code>this-&gt;pA</code>.   So they both have undefined behaviour.</p>

<p>There are circumstances where explicitly calling a destructor is appropriate.   But assignment operators and copy constructors are generally not among those circumstances.</p>
",0
26780652,26780078,1,"<p>I can see 2 problems in your code.</p>

<ul>
<li>you print 5 characters without ensuring you recieved at least 5. You should display <code>recvBuffer</code> and/or limit the number of chars written to that.</li>
<li>if you received bytes with value 1, 6, 8, 9 they are <strong>not</strong> printable characters. The (ASCII) code of <code>0</code> is <code>0x30</code> or 48. So <code>ss2.str</code> could be weird as a printable string.</li>
</ul>
",0
24632412,24632370,6,"<p>Use <code>defaulted</code> special member functions:</p>

<pre><code>foo(foo&amp;&amp;) = default;
foo&amp; operator=(foo&amp;&amp;) = default;
</code></pre>
",4
22854823,22854724,-1,"<p>Both of your <code>operator+</code> and <code>operator=</code> return objects. They are copies of <code>*this</code>. Hence, the calls to the copy constructor.</p>

<p>If would like to avoid the call to the copy constructor, in order to avoid the cost of a copy, change those function to return a reference.</p>

<pre><code>three_d const&amp; three_d::operator+(three_d op2)
{
   x=x+op2.x;
   y=y+op2.y;
   z=z+op2.z;
   return *this; 
}

three_d const&amp; three_d::operator=(three_d op1)
{
   x=op1.x;
   y=op1.y;
   z=op1.z;
   return *this;
}
</code></pre>

<p><strong>P.S.</strong></p>

<p>Your <code>operator+</code> function modifies the LHS of the operand. That is uncommon. In an expression</p>

<pre><code>a = b + c;
</code></pre>

<p>you don't expect <code>b</code> to be changed. This is something to think about.</p>

<p>If you want to implement those functions in a well behaving way, you should change them to:</p>

<pre><code>three_d three_d::operator+(three_d const&amp; rhs) const
{
   three_d r(*this);
   r.x += rhs.x;
   r.y += rhs.y;
   r.z += rhs.z;
   return r; 
}

three_d&amp; three_d::operator=(three_d const&amp; rhs)
{
   if ( this != &amp;rhs )
   {
      x = rhs.x;
      y = rhs.y;
      z = rhs.z;
   }
   return *this;
}
</code></pre>
",4
22864077,22854724,0,"<p>Best way to understand the statement, i think you should see it as;</p>

<blockquote>
  <p>ob3.operator=(ob1.operator+(ob2));</p>
</blockquote>

<p><code>4. Copy Constructor</code> :
this is creating a temporary object from <code>ob2</code> because you calling <code>operator+</code> by value. Lets call this temporary <strong>tmp2</strong>.
<br /><br />
<code>5. Copy Constructor</code> :
this is creating a temporary object from <code>ob1</code> becasue you are returning from <code>operator+</code> by value.Lets call this temporary <strong>tmp1</strong>.
<br /><br />
<code>6. Destructor Working !!</code> :
when <code>operator+</code> finishes, temporary object <strong>tmp2</strong> destructed.
<br /><br />
<code>--&gt;Important note here</code> : <code>VC++</code> and <code>GCC</code> compilers interestingly passes temporary object <strong>tmp1</strong> returned from <code>operator+</code> to <code>operator=</code> by reference even <code>operator=</code> takes input by value(copy). this is why you dont see another copy constructor here. [This needs explanation by an expert]
<br /><br />
<code>7. Copy Constructor</code> :
this is creating another temporary from <code>ob3</code> because you return from <code>operator=</code> by value. Lets call this last temporary <strong>tmp3</strong>.
<br /><br />
<code>8. Destructor Working !!</code> :
when <code>operator+</code> finishes, <code>tmp1</code> is destructed.
<br /><br />
<code>9. Destructor Working !!</code> :
when <code>operator+</code> finishes, <code>tmp3</code> is destructed at the end of the assignment.
<br /><br />
When i see the result from <code>GCC</code> compiler, it is as following:</p>

<blockquote>
  <p>4.Copy Constructor<br />
  5.Copy Constructor<br />
  6.Copy Constructor<br />
  7.Destructor Working !!<br />
  8.Destructor Working !!<br />
  9.Destructor Working !!<br /></p>
</blockquote>

<p>And similar analysis that i have done as follows:</p>

<blockquote>
  <ol>
  <li><strong>tmp2</strong> creation</li>
  <li><strong>tmp1</strong> creation</li>
  <li><strong>tmp3</strong> creation</li>
  <li><strong>tmp3</strong> destruction</li>
  <li><strong>tmp1</strong> destruction</li>
  <li><strong>tmp2</strong> destruction</li>
  </ol>
</blockquote>

<p><strong>Note:</strong> We are assuming you know the true way of defining <code>operator+</code> and <code>operator=</code> with signatures.(one is friend function taking two constant paramers, other returning by reference etc.)</p>
",0
22879364,22879284,0,"<pre><code>Customer*CreatCustomer( const string &amp;name, const string &amp;id, const string &amp;pin )
{
   return new Customer { name, id, pin };
}
</code></pre>

<p>Or if the compiler does not support initializer lists then</p>

<pre><code>Customer*CreatCustomer( const string &amp;name, const string &amp;id, const string &amp;pin )
{
   Customer *c = new Customer;

   c.-&gt;CustomerName = name;
   c-&gt;UserID = id;
   c-&gt;Pin = pid;

   return c;
}
</code></pre>
",0
22879365,22879284,3,"<p>First of all in your case you don't even need that function, you can just do:</p>

<pre><code>Customer Mary { ""Mary Jones"", ""235718"", ""5074"" };
Customer John { ""John Smith"", ""375864"", ""3251"" };
</code></pre>

<p>But if you really need to, you should use a constructor:</p>

<pre><code>struct Customer
{
    std::string CustomerName;
    std::string UserID;
    std::string Pin;
    Customer(std::string a, std::string b, std::string c)
        : CustomerName(a)
        , UserID(b)
        , Pin(c)
        {}
};
</code></pre>

<p>The reason I'm not telling you how to do this directly is because the pointer in the return type suggests me that someone told you to use dynamic memory allocation inside the function and return a pointer to it. That's an <strong>awfully bad idea</strong>. </p>

<p>But since the foot is yours and I'm not here to babysit a shotgun, here's how you shoot:</p>

<pre><code>Customer* CreateCustomer(const string&amp;name, const string&amp;id, const string&amp;pin) {
    return new Customer { name, id, pin };
}
</code></pre>
",0
28226354,28226251,12,"<p>Assuming you're talking about a static <em>data</em> member, since a static function member is no problem, there are various techniques for different cases:</p>

<ul>
<li><p>Simple integral type, <code>const</code>, address not taken:<br>
Give it a value in the declaration in the class definition. Or you might use an <code>enum</code> type.</p></li>
<li><p>Other type, logically constant:<br>
Use a C++11 <code>constexpr</code>.</p></li>
<li><p>Not necessarily constant, or you can't use <code>constexpr</code>:<br>
Use the templated static trick, or a Meyers' singleton.</p></li>
</ul>

<p>Example of Meyers' singleton:</p>

<pre><code>class Foo
{
private:
    static
    auto n_instances()
        -&gt; int&amp;
    {
         static int the_value;
         return the_value;
    }
public:
    ~Foo() { --n_instances(); }
    Foo() { ++n_instances(); }
    Foo( Foo const&amp; ) { ++n_instances(); }
};
</code></pre>

<p>Example of the templated statics trick:</p>

<pre><code>template&lt; class Dummy &gt;
struct Foo_statics
{
    static int n_instances;
};

template&lt; class Dummy &gt;
int Foo_statics&lt;Dummy&gt;::n_instances;

class Foo
    : private Foo_statics&lt;void&gt;
{
public:
    ~Foo() { --n_instances; }
    Foo() { ++n_instances; }
    Foo( Foo const&amp; ) { ++n_instances; }
};
</code></pre>

<p>Disclaimer: no code touched by a compiler.</p>
",0
31223287,31223203,1,"<p>When calling fopen you must specify whether you are opening a file as text or binary:</p>

<pre><code>FILE *fp = fopen(""c:\\te_st.txt"", ""w+t""); // open text
FILE *fp = fopen(""c:\\te_st.txt"", ""w+b""); // open binary
</code></pre>

<p><code>fprintf</code>() and <code>fscanf</code>() functions are for text files.
<code>fwrite</code>() and <code>fread</code>() functions are for binary files.
When reading with <code>fread</code>() it is your responsibility to insert the terminating 0 into the buffer. <code>fread</code>() returns the number of elements read from the file, so if you call it with parameter <code>size=1</code>, and the value returned is positive, then that value can be used as the position to insert 0 at in the buffer.</p>

<p>Example for <code>fread()</code>:</p>

<pre><code>int nRead = fread(buf, 1, 2, fp);
if(nRead &gt; 0)
{
  buf[nRead] = 0;
  cout &lt;&lt; buf &lt;&lt; endl;
}
</code></pre>
",2
31223329,31223203,3,"<p>The question, I think, is simply whether <code>fprintf()</code> sends to the file the <code>NUL</code> (<code>\0</code> or zero) that all C strings end with. The answer is no, no terminating <code>NUL</code> is sent to the file.</p>

<p>Moreover, it is not possible to write a <code>NUL</code> to a file with <code>fprintf()</code> as the <code>NUL</code> will indicate the end of the string. To write a <code>NUL</code> you must use <code>fwrite()</code> (with buffered <code>FILE *</code> I/O) or <code>write</code> (with an fd).</p>
",0
31223361,31223203,6,"<blockquote>
  <p>does fprintf write '\0' in to the file if I write a string?</p>
</blockquote>

<p>No.<br>
The code below writes ""aa"" into the file.</p>

<pre><code>FILE *fp = fopen(""c:\\te_st.txt"", ""w+"");

    fprintf(fp, ""aa"");
</code></pre>

<p>When we look at the file in hex mode, we see that it has not printed any null terminator:</p>

<pre><code>6161
</code></pre>
",0
31279172,31279144,2,"<p>1) Simple answer: It does not work with virtual functions most of the time. See <a href=""https://stackoverflow.com/questions/733737/are-inline-virtual-functions-really-a-non-sense"">Are inline virtual functions really a non-sense?</a> for a more detailed answer.</p>

<p>2) Yes you can. Compilers normally do not perform any inlining for debug builds.</p>

<p>3) Of course the compiler does not put the ""ret"" assembly instruction in the calling code. Think abut it that way:</p>

<pre><code>// before inlining:
int MyFunc () { return 5; }
int i = MyFunc();

// after inlining:
int i = 5;
</code></pre>

<p>4) See here for an answer: <a href=""https://stackoverflow.com/questions/8381293/how-do-i-force-gcc-to-inline-a-function"">How do I force gcc to inline a function?</a></p>

<p>BTW: Using Google would have answered all your questions in less time ;-)</p>
",0
31279191,31279144,2,"<ol>
<li><p>A virtual function will not be inlined unless the type of the object is known at compile time (e.g., the call is made with an object, not a reference or pointer).</p></li>
<li><p>You can put a breakpoint in an inline function if you compile it in debug mode (which nearly every compiler supports). In debug builds, functions are not inlined.</p></li>
<li><p>The inline function is not simply copied, that would be wrong and stupid. The call is intelligently replaced with the appropriate code.</p></li>
</ol>
",0
31279847,31279144,1,"<p>1) Virtual functions will not get inlined, unless the compiler ""sees"" that the same code will be called in various cases (unlikely to happen).</p>

<p>2) Yes, it is possible, especially considering many IDE's use macro tricks (and other things) to not cut away code in ""debug"" modes.</p>

<p>3) If a function is inlined, it is actually the code being inserted in every call location instead of a pointer to the function being called.</p>

<p>4) Cannot answer this as I have little experience with GCC. ""Release"" mode is more likely to set inlining, though.</p>
",0
27180484,27180425,0,"<p>This method:</p>

<pre><code>my_int my_int::operator+(const my_int&amp; num1, const my_int&amp; num2);
</code></pre>

<p>is a member function. A member function operator implicitly takes as its left parameter the object pointed to by <code>this</code> (which will be a <code>my_int</code> object). That means that your overload's parameter declaration can't contain more than one object. Change your signature to:</p>

<pre><code>my_int my_int::operator+(const my_int&amp; num2);
</code></pre>

<p>Now what was <code>num1</code> previously is now <code>*this</code>.</p>
",11
27180486,27180425,1,"<pre><code>friend my_int operator+(const my_int&amp; num1, const my_int&amp; num2);
</code></pre>

<p>means 'declare a free function which takes 2 parameters. Make it a friend so it can see my private members'</p>

<pre><code>my_int my_int::operator+(const my_int&amp; num1, const my_int&amp; num2) {
</code></pre>

<p>means 'define the (illegal) member function operator+ which takes total 3 arguments.</p>

<p>EDIT: by request, adding some more info.</p>

<p>There are a number of ""correct"" ways to implement operators on your classes. The 'best practice' way is to implement all binary operators as free functions (operator+ as a free function is declared with 2 parameters). Operator+ should be implemented where possible in terms of operator+= (a unary operator, therefore define it in the class). It's best practice because it allows you to write overloads of operator+ that take different objects as arguments. For example:</p>

<pre><code>struct X {
  explicit X(int val) : _val (val) {}

  // getter
  int value() const { return _val; }

  // this helper += operator eases our journey later on
  X&amp; operator+=(int delta) {
    _val += delta;
    return *this;
  }

  X&amp; operator+=(const X&amp; r) {
    _value += r.value();
    return *this;
  }

private:
  int _val;
}

// implements X + X
X operator+(X l, const X&amp; r)
{
  return l += r;
}

// implements X + int
X operator+(X l, int r)
{

  return l += r;
}

// implement int + X (returns an X)
X operator+(int l, X r) {
  return r += l;
  return r;
}

// later, someone else defines a Y and wants it to be addable with X, returning a Z

struct Y {
  vector&lt;int&gt; get_numbers() const;
}

struct Z {
  Z(vector&lt;int&gt; v);
}

// implement Z = X + Y;
Z operator+(const X&amp; l, const Y&amp; r) {
  auto v = r.get_numbers(); // vector&lt;int&gt; instead of auto for c++03
  v.push_back(l.value());
  return Z { std::move(v) }; // c++11
// return Z(v); // c++03
}

// also implement Z = Y + X
Z operator+(const Y&amp;l , const X&amp;r) {
  auto v = l.get_numbers();
  v.push_back(r.value());
  return Z { std::move(v) };
}
</code></pre>

<p>Note that it's possible to declare the free-function forms of binary operators as friends:</p>

<pre><code>struct X {
  // this is a free function - not a class memeber, but it can see X::_value
  friend X operator+(X, const X&amp;);
private:
  int _value;
};

// implementation
X operator+(X l, const X&amp; r) {
  l._value += r._value;
  return l;
}
</code></pre>

<p>but I would argue that this style is less preferable to writing truly unbound free binary operators that are implemented in terms of unary operators (above).</p>

<p>It's also possible to implement binary operators as member functions - in which case they are declared and defined with one parameter (the other being implied as <code>this</code>):</p>

<pre><code>struct X {
  X operator+(X r);
private:
  int _value;
};

X X::operator+(const X&amp; r) {
  // l is implied as *this
  return X { _value + r._value };
}
</code></pre>

<p>but this is a mistake because while it allows the overload of (X + int), it does not allow overloading (int + X), for which you'd need a free function anyway.</p>
",2
23074093,23073973,0,"<pre><code>  cin &gt;&gt; input &gt;&gt; number &gt;&gt; position;

  if(input=='R') goto restart;
  else if(input=='X') exit(0);
  else if(input=='D') moveRight(edgeLength, board, score);
  else if(input=='S') moveDown(edgeLength,board, arrSize);
  else if(input=='A') moveLeft(edgeLength,board, arrSize);
  else if(input=='W') moveUp(edgeLength,arrSize,board);
  else 
  {
        //whatever statements for last condition;
  }
</code></pre>

<p>If you want to capture all three input at once, you can get the input first, then execute the respective actions according to the received inputs.</p>

<p><strong>Added:</strong> Using <code>if</code> or <code>else-if</code> depends on situation. From what I see here in your code snippet, <code>else-if</code> is better than <code>if</code> because you can only have one input type everytime. Once matching character is found, (example 'D'), it will stop reading the codes below (which should be the way as it is unnecessary to check the rest of the conditions whether input is 'S' or 'A' or 'W' anymore since you already got the input). Makes your code fun slightly faster too, by preventing unnecessary checking on the conditions.</p>

<p><strong>Proof Of Concept:</strong></p>

<pre><code>//Example

void fncOne()
{
    cout &lt;&lt; ""This is function one"" &lt;&lt; endl;
}

void fncTwo()
{
    cout &lt;&lt; ""This is function two"" &lt;&lt; endl;
}

int main()
{
    char input;
    int number, position;
    cin &gt;&gt; input &gt;&gt; number &gt;&gt; position;
    if (input == 'A') fncOne();
    else if (input == 'B') fncTwo();
}
</code></pre>

<p><strong>Input:</strong> <code>A 3 5</code></p>

<p><strong>Output:</strong> <code>This is function one</code></p>
",8
23074460,23073973,0,"<p>Well, first you're going to want to get user input as a string rather than individual types.</p>

<pre><code>std::string input;
std::cin &gt;&gt; input;
</code></pre>

<p>then you'll want to parse that string based on how many words for key words/characters.</p>

<p>e.g.</p>

<pre><code>std::vector&lt;std::string&gt; words;
std::stringstream stream(input); std::string temp;

while(stream &gt;&gt; temp)
    words.push_back(temp);

if(words.size() == 3){
    if(words[0][0] = 'p'){
        int number = std::stoi(words[1]);
        int position = std::stoi(words[2]);
        board[position] = number;
    }
    else
        ... get input again ...
}
else if(words.size() &gt; 1){
    ... get input again ...
}
else{
    char c = words[0][0];
    if(c == 'w')
        moveUp(edgeLength,arrSize,board);
    else if(c == 's')
        moveDown(edgeLength,board, arrSize);
    else if(c == 'a')
        moveLeft(edgeLength,board, arrSize);
    else if(c == 'd')
        moveRight(edgeLength, board, score);
    else if(c == 'x')
        exit(0);
    else if(c == 'r')
        goto restart;
    else
        ... get input again ...
}
</code></pre>

<p>Of course this is only one way if you want to type one string then press enter only once.</p>
",0
22504862,22504496,8,"<p>your code has <strong>undefined behavior</strong></p>

<p><strong>¡ì 5.2.10 Reinterpret cast</strong></p>

<blockquote>
  <p>7 Converting a prvalue of type ¡°pointer to T1¡± to the
  type ¡°pointer to T2¡± (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value. <strong>The result of any other such pointer conversion is unspecified.</strong></p>
</blockquote>
",10
22504676,22504496,5,"<p>Virtual functions are usually resolved by an implicit <code>vtable</code>. This is basically an array of function pointers for every virtual function in the class hierarchy. The compiler adds it as a ""hidden member"" to your class. When calling a virtual function, the corresponding entry in the vtable is called.</p>

<p>Now, when you create a class of type <code>B</code>, it implicitly has the B-vtable stored in the object. Casts do not affect this table.</p>

<p>Hence, when you cast your <code>void *</code> to <code>A</code>, the original vtable (of class <code>B</code>) is present, which points to <code>B::print</code>.</p>

<p>Note that this is implementation defined behaviour, and the standard does not guarantee anything about this. But most compilers will act like this</p>
",2
22507780,22504496,2,"<p>First of all your <code>reinterpret_cast</code> is undefined.
If you pass a <code>A*</code> to <code>w</code> it will be defined.</p>

<pre><code>A * p = new B;
A::w(p);
delete p;
</code></pre>

<p>I suggest to use <code>static_cast&lt;A*&gt;(p)</code> instead, if <code>w</code> is always called using <code>A*</code>.</p>

<p>If you have a defined cast to <code>void*</code> and back the memory address stays constant.
So <code>a</code> inside your <code>w</code> will be a valid <code>A*</code> if you pass a valid <code>A*</code> to <code>w</code> first.</p>

<p>The question why the program knows how to handle the call is related to a mechanic called ""Virtual Table"".</p>

<p><em>Note: This may be different for different compilers. I'll talk about how Visual Studio seems to handle it.</em></p>

<p>To give you a somewhat rough idea for simple inheritance:</p>

<p>The compiler will compile 2 <code>print</code> functions in your code: 
<code>A::print</code> (<strong>i.e. at address <code>X</code></strong>) and <code>B::print</code> (<strong>i.e. at address <code>Y</code></strong>). </p>

<p>The <em>real</em> memory footprint of a class containing virtual function (i.e.</p>

<pre><code>struct A
{
  void print (void);
  size_t x;
};
struct B : A
{
  void print (void);
  size_t y;
};
</code></pre>

<p>) will be somewhat like</p>

<pre><code>struct Real_A
{
  void * vtable;
  size_t x;
};
struct Real_B : Real_A
{
  size_t y;
};
</code></pre>

<p>Furthermore there will be two so called virtual tables, one for each class containing virtual functions or having a base class with virtual functions.</p>

<p>You can think of the vtable as a structure holding the ""real"" address for each function.</p>

<p>Upon compilation the compiler will create Vtables for each class (<code>A</code> and <code>B</code>):
Each instance of A will have <code>vtable = &lt;Address of A Vtable&gt;</code> while each instance of <code>B</code> will have <code>vtable = &lt;Address of B Vtable&gt;</code>.</p>

<p>At runtime if a virtual function is called the program will look up the ""real"" address for the function from the Vtable which is stored at the address which is first element to each object of <code>A</code> or <code>B</code></p>

<p><strong>The following code is non-standard and not sane</strong>
... but it may give you an idea though...</p>

<pre><code>#include &lt;iostream&gt;
struct A 
{
  virtual void print (void) { std::cout &lt;&lt; ""A called."" &lt;&lt; std::endl; }
  size_t x;
};

struct B : A 
{
  void print (void) { std::cout &lt;&lt; ""B called."" &lt;&lt; std::endl; }
};
// ""Real"" memory layout of A
struct Real_A
{
  void * vtable;
  size_t x_value;
};
// ""Real"" memory layout of B
struct Real_B : Real_A
{
  size_t y_value;
};
// ""Pseudo virtual table structure for classes with 1 virtual function""
struct VT
{
  void * func_addr;
};

int main (void) 
{
  A * pa = new A;
  pa-&gt;x = 15;
  B * pb = new B;
  pb-&gt;x = 20;
  A * pa_b = new B;
  pa_b-&gt;x = 25;
  // reinterpret addrress of A and B objects as Real_A and Real_B
  Real_A&amp; ra(*(Real_A*)pa);
  Real_B&amp; rb(*(Real_B*)pb);
  // reinterpret addrress of B object through pointer to A as Real_B
  Real_B&amp; rb_a(*(Real_B*)pa_b);
  // Print x_values to know whether we meet the class layout
  std::cout &lt;&lt; ""Value of ra.x_value = "" &lt;&lt; ra.x_value &lt;&lt; std::endl;
  std::cout &lt;&lt; ""Value of rb.x_value = "" &lt;&lt; rb.x_value &lt;&lt; std::endl;
  std::cout &lt;&lt; ""Value of rb.x_value = "" &lt;&lt; rb_a.x_value &lt;&lt; std::endl;
  // Print vtable addresses
  std::cout &lt;&lt; ""VT of A through A*: "" &lt;&lt; ra.vtable &lt;&lt; std::endl;
  std::cout &lt;&lt; ""VT of B through B*: "" &lt;&lt; rb.vtable &lt;&lt; std::endl;
  std::cout &lt;&lt; ""VT of B through A*: "" &lt;&lt; rb_a.vtable &lt;&lt; std::endl;
  // Reinterpret memory pointed to by the vtable address as VT objects
  VT&amp; va(*(VT*)ra.vtable);
  VT&amp; vb(*(VT*)rb.vtable);
  VT&amp; vb_a(*(VT*)rb_a.vtable);
  // Print addresses of functions in the vtable
  std::cout &lt;&lt; ""FA of A through A*: "" &lt;&lt; va.func_addr &lt;&lt; std::endl;
  std::cout &lt;&lt; ""FA of B through B*: "" &lt;&lt; vb.func_addr &lt;&lt; std::endl;
  std::cout &lt;&lt; ""FA of B through A*: "" &lt;&lt; vb_a.func_addr &lt;&lt; std::endl;

  delete pa;
  delete pb;
  delete pa_b;

  return 0;
}
</code></pre>

<p>Visual Studio 2013 output:</p>

<pre> Value of ra.x_value = 15
Value of rb.x_value = 20
Value of rb.x_value = 25
VT of A through A*: 00D9DC80
VT of B through B*: 00D9DCA0
VT of B through A*: 00D9DCA0
FA of A through A*: 00D914B0
FA of B through B*: 00D914AB
FA of B through A*: 00D914AB</pre>

<p>gcc-4.8.1 output:</p>

<pre>Value of ra.x_value = 15
Value of rb.x_value = 20
Value of rb.x_value = 25
VT of A through A*: 0x8048f38
VT of B through B*: 0x8048f48
VT of B through A*: 0x8048f48
FA of A through A*: 0x8048d40
FA of B through B*: 0x8048cc0
FA of B through A*: 0x8048cc0</pre>

<p><a href=""https://ideone.com/iKyBB3"" rel=""nofollow"">https://ideone.com/iKyBB3</a></p>

<p>Note: No matter whether you access a B object through <code>A*</code> or <code>B*</code>, you'll find the same vtable address first and you'll find the same address contained in the vtable as well.</p>
",0
22514078,22504496,0,"<p>reinterpret_cast cannot work, if you consider how multiple inheritance is implemented in C++.</p>

<p>Basically, when casting around between related types, with multiple inheritance, a cast might involve adding an offset. Hence without knowing the source and destination type, the compiler cannot emit the correct instructions.</p>

<p>So, reinterpret casts are undoable for at least this usecase, hence they are defined as undefined.</p>

<p>The dangerous part here, even if you do not do multiple inheritance, is that modern compilers start to interpret this ""undefined"" behaviour as meaning that they can optimize the thing, it's containing block and so on away. Which is almost certainly valid by the C++ standard (undefined means exactly that, anything is fine), but can be a surprise to the developer, who tended to understand ""undefined"" as ""the code output might not work in general"".</p>
",0
31238596,31238520,4,"<p><code>const int*&amp;</code> means ""reference to pointer to <code>const int</code>. You need the <code>const</code> to apply to the <em>pointer</em>, not to the <code>int</code>:</p>

<pre><code>void funct(int* const&amp; test){}
</code></pre>

<p>This is what the template version does. <code>T</code> is a pointer to <code>int</code>, so <code>T&amp;</code> is really a reference to pointer to <code>int</code>. The template does not perform a textual substitution of <code>T</code> for <code>int*</code>. It substitutes the <em>type</em>. You'd get the same if you used <code>typedef int* X</code> and <code>const X&amp;</code>.</p>
",1
30406935,30406880,0,"<p>The obvious method would be to move the definition of <code>foo</code> into a header as well:</p>

<p>foo.h:</p>

<pre><code>template&lt;typename B&gt;
class foo{

};
</code></pre>

<p>test.h:</p>

<pre><code>#include ""foo.h""

namespace sn {
struct A {
    void getint(foo&lt;int&gt;);
};
}
</code></pre>

<p>From the looks of things, <code>test.cpp</code> would remain unchanged, and <code>main.cpp</code> would just have its definition of <code>foo</code> deleted.</p>
",4
31127904,31127876,2,"<p>Template parameters are always compile-time entities evaluated strictly at compile time.</p>

<p>In your example with <code>foo(p)</code>, the template argument is deduced as <code>T == test</code>, which is done at compile time. Once it is known that <code>T == test</code>, the value of <code>T::value</code> is known as <code>test::value</code>, which exists and which is a constexpr (also known at compile time).</p>
",4
31127930,31127876,5,"<p>Everything is evaluated at compile time. When you call, <code>foo(p)</code>, the compiler will do name lookup to find what <code>foo</code> and <code>p</code> are. It'll find two names for <code>foo</code>:</p>

<pre><code>template&lt;class T, std::enable_if_t&lt;T::value == 1&gt;* = nullptr&gt;
void foo(T);

template&lt;class T, std::enable_if_t&lt;T::value != 1&gt;* = nullptr&gt;
void foo(T);
</code></pre>

<p>It will then attempt to perform template substitution. Note that template substitution failure is not an error (sfinae). <code>T</code> is deduced as <code>test</code>, so we have to then non-type template arguments. The first has type <code>std::enable_if_t&lt;T::value == 1&gt;*</code>. We have to at this point evalute what <code>test::value</code> is. In order for substitution to succeed, there has to be some constant named <code>value</code> that is equal to one. If there is nothing named <code>value</code>, or if it's a type, or a member variable, or unequal to <code>1</code>, substitution will fail. In this case, there is a <code>static constexpr</code> <code>value</code> that is 1, so it succeeds.</p>

<p>The second overload fails template deduction, because there is no <code>enable_if&lt;false&gt;::type</code>. </p>

<p>Since there is only one viable overload, it is the best viable overload, and we pick it. All of this is done at compile time.</p>

<p>Note that if you had something like:</p>

<pre><code>struct bad_test {
    int value = 1;
};

foo(bad_test{});
</code></pre>

<p>That will fail to compile with an error indicating that there is no matching function for <code>foo</code> - both of your overloads' template substitutions would fail as <code>T::value</code> would not be able to be evaluated in that context. </p>
",5
31156049,31155796,3,"<p>The issue is that adding <code>const</code> to <code>int&amp;</code> means a const reference, not a reference to const, i.e. <code>const B</code> where <code>B</code> is <code>int&amp;</code> is <em>not</em> <code>const int&amp;</code>. A const reference is just the same as a normal reference, so it can't bind to rvalues.</p>

<p>If you want a <code>const int&amp;</code> both when an lvalue or rvalue is passed in, you can do this:</p>

<pre><code>const std::remove_reference_t&lt;B&gt;&amp; woi; //c++14
const typename std::remove_reference&lt;B&gt;::type&amp; woi; //c++11
</code></pre>
",4
23101740,23101202,0,"<p>Issues that I see:</p>

<ol>
<li><p>You have:</p>

<pre><code>temp=studentlist;
</code></pre>

<p>I didn't see the type specifier for <code>temp</code>.</p></li>
<li><p>You have:</p>

<pre><code>else if (a==studentlist-&gt;student_number)
    studentlist=studentlist-&gt;next;
</code></pre>

<p>Here, you are leaving <code>temp</code> still in the list. <code>temp-&gt;next</code> still points to <code>studentlst</code> and <code>studentlist-&gt;prev</code> still points to <code>temp</code>.</p></li>
<li><p>You have:</p>

<pre><code>while(a != temp-&gt;student_number)
{
   temp-&gt;prev=temp;
   temp=temp-&gt;next;
}
</code></pre>

<p>Why do you need the line <code>temp-&gt;prev=temp;</code>? You are just looking for the node that contains the item. There is no need to modify the list yet. Plus I haven't clearly thought through the side effects of that statement. You certainly don't need it. In addition, you are not taking care of the case where the item is not found in your list. In other words, you are not checking whether you've reached the end of the list.</p></li>
<li><p>When you get out of the above <code>while</code> loop, you are assuming that you have found the item. That is a bad assumption. You have to check whether you found the item before you try to change links using <code>temp</code>.</p></li>
</ol>

<p>Here's a modified version of the function that I came up with. You will have to refine it since I don't know what type <code>temp</code> needs to be and whether you can use <code>delete temp;</code>.</p>

<pre><code> void delete_student()
 { 
    // What's the type of 'temp'? Node?
    temp=studentlist;
    printf(""Enter the number of student to delete\n"");
    fgets(student_number,20,stdin);
    a = atoi (student_number);

    if (studentlist == NULL)
       printf(""list is empty\n"");

    else if (a==studentlist-&gt;student_number)
    {
       studentlist=studentlist-&gt;next;
       studentlist-&gt;prev = NULL;

       // Need to deallocate temp.
       delete temp;
    }
    else
    {
       temp=studentlist;
       while( a != NULL &amp;&amp; a != temp-&gt;student_number)
       {
          // Why do you need to set temp-&gt;prev ???
          // temp-&gt;prev=temp;
          temp=temp-&gt;next;
       }

       // What if we did not find the item?
       // Delete the item only if we find it.
       if ( temp )
       {
          // Unlink the node from the rest of the list.
          Node* prev = temp-&gt;prev;
          Node* next = temp-&gt;next;
          temp-&gt;prev = NULL;
          temp-&gt;next = NULL;
          if ( prev )
          {
             prev-&gt;next = next;
          }
          if ( next )
          {
             next-&gt;prev = prev;
          }

          // Delete the node that contains the item.
          delete temp;
       }
    }
    printf(""Delete success\n"");
    printf(""Press any key to go back main menu\n"");
    getch();

 }
</code></pre>
",2
23113865,23113538,0,"<p>As the other answers point out, <code>vec</code> is a function pointer, not a vector.</p>

<p>You're being advised to change <code>vec</code> to a vector, but it's not clear that that's the right solution. There's no ambiguity in your declaration; <code>vec</code> is defined as a parameter of function pointer type.</p>

<p>If that's what you intended, you need to replace the reference to <code>vec</code> inside the function with a function call. For example, you might change</p>

<pre><code>if (vec[row][col] == num)
</code></pre>

<p>to</p>

<pre><code>if ((vec(42, something))[row][col] == num)
</code></pre>

<p>where <code>something</code> would itself have to be a function pointer, pointing to a function that takes an <code>int</code> argument and returns a <code>vector&lt;int&gt;</code> result.</p>

<p>The declaration of your <code>UsedInRow</code> function is quite complicated, and I can't tell how it's intended to be used.</p>

<p>If <code>vec</code> really should be just a vector, then you can make it one by deleting the <code>(int n, vector&lt;int&gt; (int n))</code> part of the parameter declaration -- but then I'd have to wonder why you wrote it in the first place.</p>

<p>For a definitive answer, you'd need to explain to us what your <code>UsedInRow</code> function is supposed to do.</p>
",0
23113586,23113538,4,"<p>Try this:</p>

<pre><code>bool UsedInRow(const vector&lt; vector&lt;int&gt; &gt;&amp; vec, int row, int num) { ... }
</code></pre>

<p>The expression you used <code>vector&lt; vector&lt;int&gt; &gt; vec(int n, vector&lt;int&gt; (int n))</code> is actually a function pointer.</p>
",3
23113619,23113538,1,"<p>The compiler thinks that you are passing a function pointer.</p>

<p>Instead, pass the <code>vector</code> by reference:</p>

<pre><code>bool UsedInRow(vector&lt; vector&lt;int&gt; &gt; &amp;vec, int row, int num)
</code></pre>
",2
28311509,28311451,3,"<p>You have:</p>

<pre><code>static int arrayO = 0;
static interact *obs = new interact[arrayO];
</code></pre>

<p>This will create a dynamic array of 0 length. As Ben stated, the pointer will never change.</p>

<p>The crash is probably caused by trying to access it after increasing the index (<code>arrayO++;</code>), after that it will just be accessing out of bounds memory.</p>
",2
28311513,28311451,2,"<p>Your <code>obs</code> points to an array with size zero:</p>

<pre><code>static int arrayO = 0;
static interact *obs = new interact[arrayO];
</code></pre>

<p>and never is changed to point to anything larger.</p>

<p>Therefore every attempt to subscript it is an array overrun.</p>
",1
21298404,21298357,3,"<p>You are testing it wrong, you compare the value to the previous one. So this string:</p>

<pre><code>1    0    0    0    0    0    0    0    1
</code></pre>

<p>Evaluates to this: (F = false, T = true)</p>

<pre><code>1    0    0    0    0    0    0    0    1
  F    T    T    T     T    T    T    F
</code></pre>

<p>Each <code>T</code> or <code>F</code> is the result of testing the two above characters.</p>

<p>Count the T's, there are 6. You need to rethink your test.</p>

<p>Some code like this might help:</p>

<pre><code>char current = 0;
int length = 1;
bool foundSeven = false;
for(int i = 0; i &lt; cad1.length(); i++) {
    if(current == cad1[i]) {
        length++;
    } else {
        length = 1;
    }
    current = cad1[i];
    if(length == 7) {
        foundSeven = true;
        break;
    }
}
</code></pre>
",4
21298788,21298357,1,"<p>Your code is not working for me with ""1000000001"". If you remove last 1 it works.
Put break, when counter reaches 7, and it will work.</p>
",0
21300979,21298357,0,"<p>Although Its already answered, here is another way using <code>strtok</code> (COMES IN HANDY WHEN DEALING WITH STRINGS MANIPULATIONS)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
{
    char str[] =""1000000001"";
    char * pch;
    int count =0;

    for(pch = strtok(str, ""1""); pch!=NULL; pch = strtok( NULL, ""1""))
    {
            //printf(""\n%s\n"",pch);
            count+=strlen(pch);
    }
    printf(""\ntimes -%d"", count);

return 0;
}
</code></pre>
",0
22524098,22524078,-1,"<p>If you got exception ,</p>

<pre><code>abc-&gt;Function();  //Here is CRASH
</code></pre>

<p>You will enter in <code>catch(...)</code> block.</p>

<p>If you are using Windows OS, for OS generated exceptions you also need to use <code>__try/__catch</code></p>
",5
22524196,22524078,0,"<p>Here us the meaning of try and catch</p>

<pre><code>try {
 //[if some ABC type exception occur inside this block,]              
}catch (ABC) {
 //[Then, Do the things inside this block.] 
}
</code></pre>

<p>So
after the exception occur in your  <code>abc-&gt;Function();</code> flow will directly jump in to <code>catch</code> block so write there what you need to do. as example.</p>

<pre><code>try {
  abc-&gt;Function();  //Here is CRASH
  throw x;
  cout &lt;&lt; ""After throw (Never executed) \n"";
}catch (Exception ex) {
  cout &lt;&lt; ""Exception Caught \n"";
  throw ex;
}
</code></pre>

<p>actually <code>throw x;</code> doesn't have any use here. because if your <code>abc-&gt;Function();</code> worked fine, then it will throw an exception. so just remove that line.</p>
",0
22524210,22524078,1,"<p>There's an aditional '}' in the <code>try</code> block in your code. Not sure whether that was an error in typing the code or from another higher level block.</p>

<p>The <code>catch(...){}</code> block will be executed when any unhandled exception is thrown inside the <code>try {}</code> block. It doesn't matter whether the exceptions are thrown directly under the block or somewhere deep down in other function calls in the block.</p>

<pre><code>cout &lt;&lt; ""Before try \n"";
try 
{
    abc-&gt;Function1();  //A potential for crash
    abc-&gt;Function2();  //Another potential for crash
    abc-&gt;Function3();  //Another potential for crash

    // Do some checks and throw an exception.
    throw x;
    cout &lt;&lt; ""After throw (Never executed) \n"";
}
catch (...) 
{
   // This will catch all unhandled exceptions
   // within the try{} block. Those can be from
   // abc-&gt;Function1(), abc-&gt;Function2(), abc-&gt;Function3(),
   // or the throw x within the block itself.
   cout &lt;&lt; ""Exception Caught \n"";
}

cout &lt;&lt; ""After catch (Will be executed) \n"";
</code></pre>

<p>Hope that is helpful.</p>
",0
22524543,22524078,0,"<p>the code you have written works exactly true . the compiler when see the throw command every where in the <code>try{}</code> it will go to the <code>catch(){}</code> so the <code>cout &lt;&lt; ""After throw (Never executed) \n"";</code> won't execute and then the code after the <code>catch(){}</code> will execute </p>

<p>for reading more about this case here is the link <a href=""http://www.cplusplus.com/doc/tutorial/exceptions/"" rel=""nofollow"">trycatch</a></p>
",0
22524674,22524078,3,"<p>A ""CRASH"" is not an exception. It is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behaviour</a>. Absolutely anything could have happened. You are lucky that the system detected it. It could have formatted your disk or summoned daemons out of your nose. Instead the system is only shutting down the process to prevent further damage.</p>

<p>The system <em>might</em> even be so kind as to let you define what to do instead of shutting down the process. The way to define it is system specific. In Unix, you need to <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html"" rel=""nofollow"">install signal handler</a> (the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaction.html"" rel=""nofollow"">advanced way</a>), in Windows you use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms680657%28v=vs.85%29.aspx"" rel=""nofollow"">structural exceptions</a>.</p>

<p>But the problem is that if the function crashed, there is no way to tell how big mess it left the memory of the process in. You really have to fix the crash. A crash is always a bug.</p>

<p>The fact that a crash is inside that function does not automatically mean the bug is in that function. Most crashes I've seen happened in standard library functions, but they were not bugs in standard library. They were caused by incorrect use of those functions, or sometimes incorrect use of something different much earlier in the program. Because when you invoke <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behaviour</a>, there's no telling <em>when</em> it will cause a crash. Especially buffer overruns and writes to uninitialized pointers tend to cause crashes <em>eventually</em> when some unrelated code wants to use the variable that was overwritten.</p>

<p>That said if the bug is indeed in that function and you can't modify it, you will have to get somebody who can or find an alternative that works better. Because there's no way the program is going to work correctly otherwise.</p>
",2
22436938,22436900,2,"<p>Sure, just read a single character at a time and check them:</p>

<pre><code>char x;
while (cin.get(x) &amp;&amp; x != '\n') {
  // ...
</code></pre>

<p>You need to use <code>cin.get(x)</code> instead of <code>cin &gt;&gt; x</code> because you actually want to read whitespace characters like newline, which <code>operator &gt;&gt;</code> skips by default.</p>
",5
22436955,22436900,0,"<p>Try to use getch, for example</p>

<pre><code>c = null
 while(c != 0x0D) //0x0D for Carriage Return
 {
    c = getch();
 }
</code></pre>

<p><a href=""http://www.programmingsimplified.com/c/conio.h/getch"" rel=""nofollow"">More detail</a></p>
",0
33535367,33535321,1,"<blockquote>
  <p>will declaring the static variables like this cause compilation issues
  if it is included in multiple cpp files?</p>
</blockquote>

<p>No, because the C++ standard allows this particular usage and unless they are declared <code>extern</code> they will not be seen or collide with other instances of the same named variable in other translation units (i.e. cpp files).</p>
",0
21021544,21021361,2,"<p>You are accessing outside the bounds of your sect_tab array when i = num_of_sect in the following code:</p>

<pre><code> chaine[j]=sect_tab[i][j];
</code></pre>

<p>You can not have </p>

<pre><code>for (int i=0 ; i&lt;=num_of_sect ; i++) {
</code></pre>

<p>since you pass tab = new char*[numofsect];</p>

<p>Remember that arrays are indexed from 0 to size-1.</p>
",0
21021635,21021361,0,"<p>Your for loop in the hasher function should not be <code>&lt;=</code> but just <code>&lt;</code> like this:</p>

<pre><code>  for (int i=0 ; i &lt; num_of_sect ; i++)
</code></pre>

<p>That's probably the issue. Please just use a debugger and step through it and you'll soon see where the problem lies. Debuggers are our greatest friends!</p>

<p>Zero based indexes!</p>
",0
23597768,23597245,0,"<p>When you use</p>

<pre><code> int a = 42;
</code></pre>

<p>instead of </p>

<pre><code> int* a = new int(42);
</code></pre>

<p>fourth and fifth function can't be used. The <code>MyIncrementFourth</code> and <code>MyIncrementFifth</code> (counterintuitive names, by the way) pretend to replace the pointer you allocated in the main with another pointer to another area, allocated inside the functions (and there will be a memory leak since you no longer will be able to delete the original <code>a</code>¡­). But if you stick to <code>int a = 42</code> instead of <code>int* a = new int(42)</code>, your variable is not a pointer, thus those functions have no pointer they can replace.</p>
",4
23597293,23597245,2,"<pre><code>void foo(int a) {
 ...
}

int main() {
  int a = 5;
  foo(a);
  return 0;
}
</code></pre>

<p>While with * it would be like this</p>

<pre><code>void foo(int* a) {
 ...
}

int main() {
  int a = 5;
  foo(&amp;a);
  return 0;
}
</code></pre>

<p>However, this reminds of <code>C</code>.</p>

<p>You could use the <code>&amp;</code> operator, instead of the <code>*</code>, like this:</p>

<pre><code>void foo(int&amp; a) {
 ...
}

int main() {
  int a = 5;
  foo(a);
  return 0;
}
</code></pre>

<p>I assume you know what passing by value and by reference means. If you want a refresh, take a look in my example <a href=""http://gsamaras.wordpress.com/code/functions-in-c/"" rel=""nofollow"">here</a>.</p>

<p>[EDIT]</p>

<p>Also note that the code in the first block of yours is not OK, since you call <code>new</code> twice, but you never call <code>delete</code>.</p>

<p>Also, about what you are asking, you <strong>cannot</strong> do it without using an extra pointer. In other words, it can not be done by only having <code>int a</code> in the play.</p>

<p>Example:</p>

<pre><code>  int* a_pointer = &amp;a;
  MyIncrementFourth(&amp;a_pointer);
  cout &lt;&lt; ""fourth "" &lt;&lt; a &lt;&lt; "", but a_pointer points to "" &lt;&lt; *a_pointer &lt;&lt; endl;
</code></pre>

<p>Why the value of <code>a</code> did not change, despite the fact that we set the <code>a_pointer</code> to be equal with the address of <code>a</code>.</p>

<p>Because inside your function, you are calling <code>new</code> and as you know, it will return a pointer to the new allocated memory.</p>

<p>As a result, <code>a_pointer</code> is assigned a new value. Which value? The address of the new allocated memory.</p>
",0
23597315,23597245,0,"<p>You can use:</p>

<pre><code>int* ap = &amp;a;
MyIncrementFourth(&amp;ap);
MyIncrementFifth(ap);
// These calls change what ap points to.
// It does not change the value a.
</code></pre>

<p>You can also use:</p>

<pre><code>int* ap = NULL;
MyIncrementFourth(&amp;ap);
MyIncrementFifth(ap);
// These calls change what ap points to.
</code></pre>
",3
23597863,23597245,0,"<pre><code>int* ptr;

MyIncrementFourth(&amp;ptr);
a = *ptr;
delete ptr;
std::cout &lt;&lt; ""fourth "" &lt;&lt; a &lt;&lt; std::endl;

MyIncrementFifth(ptr);
a = *ptr;
delete ptr;
std::cout &lt;&lt; ""fifth "" &lt;&lt; a &lt;&lt; std::endl;
</code></pre>
",0
31868879,31868722,3,"<p>All <code>CApi</code> classes will share a single static <code>CSocketClient</code> variable.</p>

<p><code>m_SockWorking</code> is a protected member of <code>CSocket</code> which is inheirited by <code>CSocketClient</code> this makes it a private variable inside the context of <code>CApi</code> and your application. So you can access it through the use of accessor and mutator functions.</p>

<p>Each <code>CSocketClient</code> has its own <code>m_SockWorking</code> variable. Since all <code>CApi</code> all share the same <code>CSocketClient</code> class, they all share the same <code>m_SockWorking</code> variable.</p>

<p><strong>CSocket.h</strong></p>

<pre><code>class CSocket {
  protected:
    int m_SockWorking;
    int InitSocket();
    void CleanSocket();
  public:
    void setSocket(int val){ m_SockWorking = val; } /* added these functions to show how to accessing m_SockWorking can be done */
    int getSocket() const { return m_SockWorking; }
};

class CSocketClient : public CSocket {
  public:
    CSocketClient();
    int InitClient();

};

class CApi {
  static CSocketClient c1;
  public:
    // other methods defined 
};
</code></pre>

<p><strong>main.cc</strong></p>

<pre><code>#include ""CSocket.h""
#include &lt;iostream&gt;
using std::cout;
using std::endl;

int main(){
  CApi a, b;
  CSocketClient c2;
  a.c1.setSocket(0); /* sets static c1 m_SockWorking variable to 0 */
  cout &lt;&lt; b.c1.getSocket() &lt;&lt; endl; /* will print 0 since c1 is a static variable */
  c2.setSocket(1); /* set c2 m_SockWorking to 1 */
  cout &lt;&lt; c2.getSocket() &lt;&lt; endl; /* will print 1 */
  cout &lt;&lt; a.c1.getSocket() &lt;&lt; endl; /* will print 0 */
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>0
1
1
</code></pre>
",1
31870847,31868722,0,"<p>Yes, object c1 is unique, so, all data members within to c1 are unique for CApi.</p>

<p>Maybe it's less confusing in this way:</p>

<p>static object c1 is a standalone &amp; unique object for the ""CLASS"" CApi, accessible by objects of CApi. It belongs to the class, NOT to any objects of CApi; it's NOT A SHARED PART of objects of CApi.</p>
",0
22436735,22436652,1,"<p>Probably a good approach would be to use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow"">getline</a> then extract the first word in each line, otherwise a solution <em>I don't really like but works</em> is (ab)using the getline delimiters</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    std::string name, discard;
    std::getline(std::cin, name, ' '); // Takes just the first word (if present)
    std::getline(std::cin, discard); // Takes the rest until \n, discard this
</code></pre>

<p>then you can join them as you want.</p>
",0
21017967,21017600,1,"<p>How about</p>

<pre><code>int i;
for (i = 0; i &lt; 20; )
{
    int ch = getch();
    if (ch == '\b')
        i = std::max(0, i - 1);  // Backspace, go back a character
    else if (ch == '\r')
        continue;  // Continue loop for unwanted special characters
    else if (ch == '\n')
        break;  // End loop at newline
    else
        passwd[i++] = ch;  // Add character to string
}
passwd[i] = '\0';  // Terminate string
</code></pre>
",0
21017970,21017600,0,"<p>you can do like this</p>

<pre><code>while(ch != '\n') 
{
    ch = getch();
    if(ch !='\n' &amp;&amp; ch!='\r')
    {
        passwd[i] = ch;
        cout &lt;&lt; (char)254; // write dots instead of password that user entered
        i++;
    }
}
</code></pre>
",0
31221025,31220941,1,"<p>Using a <a href=""http://en.cppreference.com/w/cpp/io/basic_stringstream/basic_stringstream"" rel=""nofollow""><code>std::stringstream</code></a> as a class member is perfectly valid. Usually, when you add a new member and have some mysterious errors or crashes, this results from the need to recompile a dependant source. Try doing a <code>make clean</code> and then rebuild everything.</p>

<hr>

<p>Apart from that, you must save the old stream buffer, otherwise you cannot restore it later. Change </p>

<pre><code>void Controller::disableCerr()
{
    std::cerr.rdbuf(this-&gt;cerrOvRdBuf.rdbuf());
}
</code></pre>

<p>to </p>

<pre><code>void Controller::disableCerr()
{
    cerrStdRdBuf = std::cerr.rdbuf(this-&gt;cerrOvRdBuf.rdbuf());
}
</code></pre>
",2
21031307,21030653,0,"<p>My five cents</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

using namespace std;

int main()
{
    const int N = 10;
    int person[N];

    // Entering initial data
    for ( int i = 0; i &lt; N; i++ )
    {
        cout &lt;&lt; ""Enter number of pancakes eaten by person "" &lt;&lt; i + 1 &lt;&lt; "": "";
        cin &gt;&gt; person[i];
    }

    //  Finding the index (favorite) of the person who has eaten the most pancakes.
    int favorite = 0;

    for ( int i = 1; i &lt; N; i++ )
    {
        if ( person[favorite] &lt; person[i] ) favorite = i;
    }

    // Now all is ready to show the result
    cout &lt;&lt; ""\nThe most pancakes are eaten by Person "" &lt;&lt; favorite + 1 
         &lt;&lt; "" with "" &lt;&lt; person[favorite] &lt;&lt; endl;

    system( ""pause"" );

    return 0;
}
</code></pre>
",0
21030787,21030653,0,"<p>Not tested, should work:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{

    int x[11];
    int ans, ansmax = 0;
    for (int i = 1; i &lt;= 10; i++)
    {
        cin &gt;&gt; x[i]; // You had wrong variable here
        cout &lt;&lt; ""Person: "" &lt;&lt; i &lt;&lt; "" has eaten "" &lt;&lt; x[i] &lt;&lt; "" pancakes"" &lt;&lt; endl
        if(x[i] &gt; ansmax)
        {
            ansmax = x[i];
            ans = i;
        }
    }
    cout &lt;&lt; ""The most pancakes are eaten by Person "" &lt;&lt; ans &lt;&lt; "" with "" &lt;&lt; ansmax &lt;&lt; endl;
    system(""pause"");
    return 0;
}
</code></pre>
",0
21031655,21030653,0,"<pre><code>#include &lt;algorithm&gt;

int index = std::max_element(x, x + 11) - x;
</code></pre>
",0
21033769,21033742,1,"<p>The program builds a new number reversing the order of decimal digits of the entered number. For example if 123 was entered then the result will be 321.</p>

<p>By the way why do not to compile it and see the result?:)</p>
",0
21035399,21033742,0,"<p>So simple it is.
Why do not you compile it and see the result?</p>

<p>521 -> 125
789998122 -> 221899987</p>

<p>reverse order of the integer inputted.</p>
",0
30171177,30171080,2,"<p>You could write a function to create the object, and use that in the initialiser list:</p>

<pre><code>static Other make_bar() {
    std::list&lt;int&gt; l;
    // fill the list, do whatever else you need
    return Other(l, ...);
}

Foo() : bar(make_bar()) {}
</code></pre>

<p>Or you could use something like <a href=""http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html"" rel=""nofollow""><code>boost::optional</code></a> to defer initialisation without requiring dynamic allocation.</p>
",0
30171223,30171080,0,"<p>You can implement a constructor in <code>Foo</code> using:</p>

<pre><code>Foo() : bar(std::list&lt;int&gt;()) {}
</code></pre>
",2
33824469,33824338,17,"<p>It can be that you only forward-declared <code>ListOfEmployeeNode</code>, without including it's header (and therefore definition) where it is used.</p>

<p>In that case, the compiler knows about the class, but cannot access any members, including constructors.</p>

<p>If you did include the header, check your include guards. If they happen to be same in the two header files, the definition can be discarded by the preprocessor</p>
",5
29217760,29216054,0,"<p>In your base class <code>Car</code> you have declared the method <code>turnRight</code> <strong>which takes <em>no</em> parameters</strong>.</p>

<p>In your derived class <code>SDLCar</code> you have declared a <em>completely different</em> method with the same name. The reason why it's a different method and not a function <em>override</em> is that its takes a <strong>parameter</strong>. It should be parameterless to override <code>Car::turnRight</code>.</p>

<p>And because it's not a function override, the rules of polymorphism don't apply. Thus you can't call <code>SDLCar::turnRight(SDLMonitor&amp;)</code> from a <code>Car</code> pointer.</p>

<hr>

<p><strong>Right now</strong> is an excellent time to start using the <a href=""http://en.cppreference.com/w/cpp/language/override"" rel=""nofollow""><em><code>override</code> keyword</em></a>. It prevents specifically these kind of programming errors. By marking a function with <code>override</code>:</p>

<pre><code>void turnRight(SDLMonitor&amp; monitor) override;
</code></pre>

<p>the compiler will automatically check that it <em>actually overrides</em> a function from the base class.</p>

<p>E.g. with the above declaration, the compiler would give you an error (or a warning at least). This would've helped you find your error right away and prevented more erroneous code such as <code>car-&gt;turnRight(monitor)</code>.</p>

<hr>

<p>So now that the error is found, you need to find a way to fix it. Either declare the base class <code>turnRight</code> to take a <code>SDLMonitor&amp;</code> as well, or think of something else if that's not how it should behave.</p>

<p>IMO having to pass the game window to a method like <code>turnRight</code> seems weird. Why would turning a car need a window? I think <code>turnRight</code> should do just what it says on the tin: turn the car right. Nothing else.</p>

<p>I don't know why you're passing a window to the method but if it's for drawing, shouldn't the <code>drawCar</code> method handle that? I don't know your code, so I'll leave it up to you.</p>
",0
24372812,24372555,5,"<p>You are using uninitialized varieable <code>size</code> in:</p>

<pre><code>streamSize = (size * 4) + 4;
</code></pre>

<p>Everything after that depends on <code>streamSize</code> is suspect and is a cause for undefined behavior.</p>

<p><strong>Update</strong></p>

<p>Even after <code>size</code> is initialized to <code>1</code>, there are problems. Let's me walk through the code and how it affects the memory you have allocated.</p>

<p>After you execute the line:</p>

<pre><code>uint8_t *buffer = new uint8_t[streamSize];
</code></pre>

<p>you have <code>buffer</code> pointing to memory like this:</p>

<pre><code>buffer
|
v
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
</code></pre>

<p>After you have executed the line:</p>

<pre><code>dataStruct *sStream = (dataStruct *)buffer;
</code></pre>

<p>you have <code>sStream</code> pointing to the same memory like:</p>

<pre><code>sStream
|
v
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
</code></pre>

<p>If your compiler does not add any padding to the members of <code>dataStruct</code> (the best case scenario), you'll have:</p>

<pre><code>sStream.header  sStream.body
|               |
v               v
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
</code></pre>

<p>If your compiler adds padding to <code>dataStream.header</code>, <code>sStream.body</code> will point to something different. Worst case scenario: You have a 64-bit compiler. It adds 32 bits of padding to <code>dataStream.header</code>. In that case, you will have:</p>

<pre><code>sStream.header                  sStream.body
|                               |
v                               v
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
</code></pre>

<p>Then, you will end up using unathorized memory when you try to assign anything to <code>sStream.body</code>, like:</p>

<pre><code>sStream-&gt;body = new uint32_t[1];
</code></pre>

<p>Best case scenario, you have 32 bit compiler and there is no padding added to <code>dataStream.header</code>. Looks like you have a 64-bit compiler. Even if you compiler does not add any padding to <code>dataStream.header</code>, you are still looking at a memory overrun problem if <code>sizeof(void*)</code> is 64 bits, which I think you do.</p>

<p>Let's take the best case scenario of a 32 bit compiler that doesn't add any padding and the member of <code>sStream</code> point to the allocated memory like:</p>

<pre><code>sStream.header  sStream.body
|               |
v               v
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
</code></pre>

<p>After you execute the line:</p>

<pre><code>sStream-&gt;header = 2863311530;
</code></pre>

<p>the memory looks like:</p>

<pre><code>sStream.header  sStream.body
|               |
v               v
+---+---+---+---+---+---+---+---+
| 2863311530    |               |
+---+---+---+---+---+---+---+---+
</code></pre>

<p>After you execute the line:</p>

<pre><code>sStream-&gt;body = new uint32_t[1];
</code></pre>

<p>the memory looks like:</p>

<pre><code>sStream.header  sStream.body
|               |
v               v
+---+---+---+---+---+---+---+---+
| 2863311530    |  SomeMemory   |
+---+---+---+---+---+---+---+---+

SomeMemory
|
v
+---+---+---+---+
|               |
+---+---+---+---+
</code></pre>

<p>After you execute the line:</p>

<pre><code>sStream-&gt;body[0] = 2863311530;
</code></pre>

<p><code>SomeMemory</code> gets populated and looks like:</p>

<pre><code>SomeMemory
|
v
+---+---+---+---+
| 2863311530    |
+---+---+---+---+
</code></pre>

<p>I think you were surprised to see that the memory pointed to by <code>buffer</code> does not look like:</p>

<pre><code>buffer
|
v
+---+---+---+---+---+---+---+---+
| 2863311530    | 2863311530    |
+---+---+---+---+---+---+---+---+
</code></pre>

<p>I hope it makes sense now why it does not.</p>
",2
23565597,23565527,-1,"<p>You need to give the same type of argument as the value to be replaced and the replacing value.</p>

<p><code>'a'</code> is a <code>char</code>, while <code>""1""</code> is a string. You can't mix those two, <code>replace</code> in this case only supports <code>char</code>s.</p>

<p>Note: <code>'11'</code> is not a valid char.</p>
",4
23565800,23565527,0,"<p>You should use some overloaded member function <code>replace</code> of class <code>std::basic_string</code> instead of the standard algorithm <code>std::replace</code>.</p>

<p>For example</p>

<pre><code>for ( std::string::size_type pos = 0;
      ( pos = s.find( 'a', pos ) ) != std::string::npos;
      pos += 2 )
{
   s.replace( pos, 1, 2, '1' );
}
</code></pre>

<p>Or if the number can be any arbitrary string then you can write</p>

<pre><code>std::string number( ""123"" );
for ( std::string::size_type pos = 0;
      ( pos = s.find( 'a', pos ) ) != std::string::npos;
      pos += number.size() )
{
   s.replace( pos, 1, number );
}
</code></pre>

<p>If you want to replace a number with a character then you can write</p>

<pre><code>for ( std::string::size_type pos = 0;
      ( pos = s.find( ""11"", pos ) ) != std::string::npos;
      ++pos )
{
   s.replace( pos, 2, 1, 'a' );
}
</code></pre>
",4
26786757,26786726,2,"<p>This is not a problem specifically related to copy constructors; non-<code>const</code> lvalues references cannot bind to temporaries.</p>

<p>The following code would have compiled:</p>

<pre><code>fruit f1;
fruit f2(f1);
</code></pre>

<p>because <code>f1</code> is not a temporary when you pass it in.</p>

<p>Still, you want temporaries to work, so write your copy constructor like this:</p>

<pre><code>fruit(const fruit&amp; f) {
   i = f.i + 1;
}
</code></pre>

<p>Your cases 1 and 3 succeed because the compiler is able to generate its own ""default"" copy constructor <em>having seen that you did not provide one</em>, which &mdash; unlike you &mdash; it does correctly. :-)</p>
",5
26786805,26786726,1,"<pre><code>fruit f1 = fruit(f2);
</code></pre>

<p>For fruit(f2) , temporary would be created which cannot be bind to non-const reference. You have to use follwoing copy constrcutor for this to work:-</p>

<pre><code>fruit(const fruit&amp; f)
</code></pre>
",2
27550177,27550127,3,"<p>The problem here is that you have </p>

<pre><code>fruit f;
</code></pre>

<p>Which declares a variable <code>f</code> of type <code>fruit</code> then you have:</p>

<pre><code>fruit(f);//same as: fruit f;
</code></pre>

<p>This isn't creating a new fruit with the parameter <code>f</code> but rather creating a variable <code>f</code> of type <code>fruit</code> which is likely not what you expect. which is making another variable which is assigned to <code>f</code>, which gives the error about the redeclaration.</p>

<pre><code>apple(f);// same as: apple f;
</code></pre>

<p>Once again you are trying to re-declare the variable <code>f</code> here.</p>

<p>If you are wanting initialization and not a new variable, use the new uniform initialization syntax. This syntax was introduced with the express intent of removing this ambiguity, so use that instead:</p>

<pre><code>fruit{f};
</code></pre>

<p>This ambiguity between initialization and declaration is sometimes referred to as c++'s <a href=""http://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""nofollow noreferrer"">""most vexing parse""</a>. The new uniform initialization list syntax more closely matches your intent as it unambiguously says ""this is an initialization and not a declaration"".
See <a href=""https://softwareengineering.stackexchange.com/questions/133688/is-c11-uniform-initialization-a-replacement-for-the-old-style-syntax"">this question</a> for more information on when to use this syntax.</p>

<p>Also in your example you are missing the semicolon after your classes, you want to fix that.</p>
",3
27550273,27550127,3,"<pre><code>fruit(f); // redclaration error ? why
</code></pre>

<p>Because that's equivalent to the declaration <code>fruit f;</code> - you can put parentheses around the name in a declaration if you want to. There's already an <code>f</code> declared in this scope, so that's an error.</p>

<pre><code>fruit(a); // invokes fruit(int) constructor
</code></pre>

<p>No it doesn't. Again, that's equivalent to <code>fruit a;</code>, and again fails since there's already an <code>a</code>.</p>

<pre><code>fruit(fruit()) // invokes fruit(const fruit&amp; f) function
</code></pre>

<p>No it doesn't. With the missing <code>;</code>, that's equivalent to <code>fruit fruit();</code> and declares a function (in the surrounding namespace).</p>

<pre><code>apple(f); // redeclaration error. why
</code></pre>

<p>For exactly the same reason as the first two declarations.</p>
",6
27550278,27550127,2,"<p>This</p>

<pre><code>fruit(f); 
</code></pre>

<p>is exactly the same as</p>

<pre><code>fruit f; 
</code></pre>

<p>But you already declared something called <code>f</code> (another <code>fruit</code>.) You've declared <code>f</code> twice. That's why you get a re-declaration error. Along the same lines, this</p>

<pre><code>apple(f);
</code></pre>

<p>is exactly the same as</p>

<pre><code>apple f;
</code></pre>

<p>So, you're re-declaring <code>f</code> again. If you want to create an <code>apple</code> from <code>f</code>, you need</p>

<pre><code>apple x(f);
</code></pre>
",3
22524515,22524453,1,"<p>You are passing <code>x</code> as <code>ItemType</code> which is a <code>float</code>.</p>

<p><code>float</code> doesn't have those methods... looks like you wanted to pass it as a <code>SortedList</code></p>
",1
22525679,22524453,0,"<p>The compare function needs two parameters in order to do a compare. Instead of ComparedTo, you may want to call it CompareToLocation.</p>

<pre><code>RelationType CompareToLocation(ItemType x, size_t location){
    if(x &lt; values[location]) return LESS;
    if(x == values[location]) return EQUAL;
    return GREATER;}
</code></pre>

<p>An example usage would be:</p>

<pre><code>result = CompareToLocation(x, location);
    // ...
</code></pre>
",0
31232583,31232288,4,"<p>Aggregate classes can be aggregate initialized using an initializer list:</p>
<pre><code>struct Agg {
    string a;
    int b;
}
Agg a = {&quot;A string&quot;, 0};
</code></pre>
<p>They are mainly used as a tupple-like return value like so:</p>
<pre><code>struct Response {
    bool success;
    string body; // Body is only set if success is true
}

Response foo() {
    if(failed) return {false, &quot;&quot;};
    return {true, &quot;content&quot;};
}
</code></pre>
<p>As you can see all four requirements have to be fulfilled for this to be meaningful (before c++11).</p>
<blockquote>
<p>All of its data members are public</p>
</blockquote>
<p>It's pretty much just a tuple of objects.</p>
<blockquote>
<p>It does not define any constructors</p>
</blockquote>
<p>Well, either you initialize all members (via aggregate initialization) or you default initialize all members (with the default constructor).</p>
<blockquote>
<p>It has no in-class initializers</p>
</blockquote>
<p>Same as above</p>
<blockquote>
<p>It has no base classes or virtual functions</p>
</blockquote>
<p>It's tuple-like, so base classes would destroy that and virtual functions don't make sense since you wouldn't inherit from such a class.</p>
<p>I hope this clears it up a bit. Remember that this is was invented before C++11 where <code>std::tuple</code> wouldn't exist so you would have used an aggregate class to return multiple values. Nowadays in most use cases you could use <code>tuple</code> aswell but it is not my favorite.</p>
<hr />
<h2><code>std::tuple</code> vs aggregate classes</h2>
<ul>
<li>An aggregate class can define member functions</li>
<li>An aggregate class can overload operators.</li>
<li>An aggregate can define useful names for its attributes</li>
<li>etc.. to expand</li>
</ul>
<p>Most of the time, aggregate classes are the way to go. tuple should only be used if you really want nothing else but returning a tuple of objects, and then &quot;breaking it into its pieces&quot;. Member functions don't make sense most of the time but aggregate classes can still overload the cast operator for example.</p>
<p>Use tuples only when you only want to do nothing but retuning a bunch of objects together, without a need to &quot;name&quot; them (via member names in aggregates)</p>
",6
31232500,31232288,9,"<p>An aggregate is basically a simple collection of data that does not have any invariants the <code>class</code> would have to guarantee. Since there is no invariant and thus all combinations of possible values of the member make sense, there is no point in making them private since there is nothing to protect.</p>

<p>A simple example for such a class would be something like</p>

<pre><code>struct Point3d {
   std::array&lt;double, 3&gt; coordinates;
};
</code></pre>

<p>Since every triple of <code>double</code>s is a point in R^3, there is nothing to gain by hiding the data. (If you are afraid of <code>NaN</code> and <code>infinity</code> values, this might not be the best idea. If this can happen, you might want to not make this an aggregate.)</p>

<p>Another example of an aggregate type is <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""noreferrer""><code>std::array</code></a>. Again, it is just an array of some type and some (immutable) length, so no invariant is to protect.</p>

<p>One advantage of aggregates is <a href=""http://en.cppreference.com/w/cpp/language/aggregate_initialization"" rel=""noreferrer"">aggregate initialization</a>.</p>
",3
24132133,24131948,1,"<p>You can pass the array by reference, so you can return it :</p>

<pre><code>std::string (&amp;func(std::string (&amp; a) [10])) [10]
{
    return a;
}
</code></pre>

<p>Or to make things clearer, use a <code>typedef</code> for your array of strings: </p>

<pre><code>typedef std::string StrArray[10];

StrArray&amp; func2(StrArray&amp; a) {
   return a;
}
</code></pre>

<p><strong>EDIT:</strong></p>

<p>When you did :</p>

<pre><code>std::string (&amp;func(std::string a[])) [10]
{
    return a; // error !
}
</code></pre>

<p>The argument <code>a</code> is an array of <code>std::string</code> and decays to a pointer to <code>std::string*</code> , which is passed by value (so, copied): You are asking the compiler to bind a non-const reference (the return type) to a temporary, which is illegal in C++.</p>
",2
31223140,31223003,0,"<p>You could have tried more than just one approach before asking.</p>

<p>Only a minor tweak is needed: don't call the function, but instead <em>name it</em>:</p>

<pre><code>SomeClass&lt;decltype(func)&gt; c;
</code></pre>

<hr>

<p>Here's an example showing that it works:</p>

<pre><code>#include &lt;iostream&gt;

void foo(int x, char y, bool z)
{
    std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; '\n';
}

template &lt;typename F&gt;
void bar(F f)
{
    f(1, '2', true);
}

int main()
{
    bar&lt;decltype(foo)&gt;(foo);
}
</code></pre>

<h3>(<a href=""http://coliru.stacked-crooked.com/a/8dc0198d457c2c17"" rel=""nofollow"">live demo</a>)</h3>

<p>Of course, in reality, you'd let the template argument be deduced here rather than giving it explicitly, but this shows that <code>decltype(foo)</code> is correct.</p>
",10
22120697,22120630,2,"<p>No as the c++ standard does not require floating point values to be stored in the IEEE 754 format.</p>
",6
22120908,22120630,0,"<p>""Real"" machines are quite careful in implementing the standard exactly (just remember the <a href=""http://en.wikipedia.org/wiki/Pentium_FDIV_bug"" rel=""nofollow"">Pentium division bug</a>). But be careful to check, the i386 line of machines did use some extra bits in its registers, which were cut off when asigning to/from memory, so computations done only in registers gave different results than if some intermediate results where spilled to memory.</p>

<p>Also check out David Goldberg's <a href=""https://ece.uwaterloo.ca/~dwharder/NumericalAnalysis/02Numerics/Double/paper.pdf"" rel=""nofollow"">What every computer scientist should know about floating point arithmetic</a>.</p>

<p>In any case, it doesn't make any sense to ""round"" (or otherwise mangle) a number that can be represented exactly.</p>
",2
30142351,30142125,2,"<p>You have lots of other issues with your code that you should address in order for it to be correct (currently, it doesn't even compile).  However, you could do the following.</p>

<pre><code>std::random_device random_device;
std::mt19937 engine{random_device()};
std::uniform_int_distribution&lt;int&gt; die_distribution;

std::vector&lt;std::unique_ptr&lt;staff&gt;&gt; people;
for (int i = 0; i &lt; 50; ++i)
{
    if (die_distribution (engine) % 2)
    {
        people.emplace_back (new admin{die_distribution(engine), die_distribution(engine)});
    }
    else
    {
        people.emplace_back (new academic{die_distribution(engine), die_distribution(engine)});
    }
}
</code></pre>

<p>You'll need to include the <code>vector</code>, <code>memory</code>, and <code>random</code> headers to make this work.</p>

<hr>

<p>If for some reason you cannot use the <code>random</code> header, you can use the older ""random"" number facilities.  Include <code>cstdlib</code> and <code>ctime</code>.</p>

<pre><code>std::srand (std::time(0));
std::vector&lt;std::unique_ptr&lt;staff&gt;&gt; people;
for (int i = 0; i &lt; 50; ++i)
{
    if (std::rand() % 2)
    {
        people.emplace_back (new admin{ std::rand(), std::rand() });
    }
    else
    {
        people.emplace_back (new academic{ std::rand(), std::rand() });
    }
}
</code></pre>
",3
31246932,31246843,4,"<p>Because of the internal representation of negative numbers. This is called the <a href=""https://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two's complement</a>.</p>
",0
31246961,31246843,9,"<ul>
<li><code>string::npos</code> denotes that the position is not found. It is usually represented by a constant value of <code>-1</code>.</li>
</ul>

<p><a href=""http://www.cplusplus.com/reference/string/string/npos/"" rel=""nofollow noreferrer"">Reference</a></p>

<blockquote>
  <p>This constant is defined with a value of -1, which because size_t is an unsigned integral type, it is the largest possible representable value for this type.</p>
</blockquote>

<ul>
<li>In case, <code>find</code> is unsuccessful, it returns <code>-1</code>.</li>
</ul>

<p>So, both are equal, in your case and the <code>if</code> is satisfied.</p>

<p>Now, to answer</p>

<blockquote>
  <p><em><code>name.npos</code> instead, if I print it, is 4294967295</em></p>
</blockquote>

<p>because, <code>string::npos</code> is of type <code>size_t</code> which is usually <code>typedef</code> to <code>unsigned</code> type. The <code>-1</code>,which is used to initialize an <code>unsigned</code> type will be stored as and printing <a href=""https://stackoverflow.com/q/22801069/2173917"">the maximum possible unsigned value</a>.</p>
",1
28156512,28156438,3,"<p>You have a circular dependency between your two header files. <code>Client.h</code> includes <code>Server.h</code>, and <code>Server.h</code> includes <code>Client.h</code>. As <code>Client.h</code> is being expanded, it defines its include guard <code>CLIENT_H_</code>, and then (eventually) tries to expand <code>Server.h</code>, which tries to include <code>Client.h</code> a second time. The include guard blocks it, because it's already defined, so <code>class Client</code> never actually gets defined prior to the <code>Server.h</code> code being parsed.</p>

<p>The solution here is to forward-declare <code>Client</code> as follows:</p>

<pre><code>class Client;
</code></pre>

<p>You can put that line inside <code>Server.h</code>, or in <code>Client.h</code> above the include guard.</p>
",1
24085231,24085099,7,"<p>If an expression is not compile time evaluated it can't be a template parameter. </p>

<p>Your construct can be modified to perform a compile time evaluation, but that wouldn't result in runtime error (exception) but a compilation error : </p>

<pre><code>template&lt;int N&gt;
typename std::enable_if&lt;(N&gt;0 &amp;&amp; N&lt;=3)&gt;::type function() {
     // stuff     
}
</code></pre>

<p>but that would require the dimensions <code>N</code> to be known at compile time, so that you'd call the function like this : </p>

<pre><code>function&lt;2&gt;(); // OK
function&lt;5&gt;(); // compilation error
</code></pre>
",5
24085240,24085099,2,"<p>That would work, as long as the <code>dimensions</code> parameter is always known at compile-time. See <a href=""http://eli.thegreenplace.net/2011/04/22/c-template-syntax-patterns/"" rel=""nofollow"">http://eli.thegreenplace.net/2011/04/22/c-template-syntax-patterns/</a> for some descriptions of using templates in ways other than the usual ""make this container flexible"".</p>
",0
31163665,31163449,6,"<p>MSVC is mistakenly treating <code>false</code> as a null pointer constant. However, according to N4140, ¡ì4.10 [conv.ptr]/1 (emphasis mine):</p>

<blockquote>
  <p>A null pointer constant is an <strong>integer literal</strong> with value zero
  or a <strong>prvalue of type std::nullptr_t</strong>. A null pointer constant can be
  converted to a pointer type; the result is the null pointer value of
  that type and is distinguishable from every other value of object
  pointer or function pointer type.</p>
</blockquote>

<p>The wording changed a bit from C++11, and you can <a href=""https://stackoverflow.com/q/17501942/962089"">find that discussion here</a>. The verdict there was that it was an error in C++11 as well.</p>

<p>For visibility, TartanLlama provided the definition of ""integer literal"" below, according to [lex.icon]/1:</p>

<blockquote>
  <p>An integer literal is a sequence of digits that has no period or exponent part, with optional separating single quotes that are ignored when determining its value.</p>
</blockquote>
",4
21324175,21324130,1,"<p>You include <code>list.h</code> <em>before</em> the class definition, so it's not available in that header. According to the error message, something in <code>list.h</code> needs a declation of the class.</p>

<p>You don't need a full definition of <code>list</code> here, so replace the <code>#include</code> with a forward declaration</p>

<pre><code>class list;
</code></pre>

<p>Within <code>list.h</code>, you probably need a similar declaration of <code>input</code>; or it might be necessary to include <code>init.h</code> if the header does something complicated with it.</p>
",3
21324177,21324130,1,"<p>You have a circular dependency.</p>

<p>You can forward declare the other class, but this is still a poor design.  Better to just do away with the circular dependency altogether.  At second glance, do you even need to include <code>list.h</code>?  Where are you using anything declared in it?</p>
",3
32398177,32398088,4,"<p>What you have is just undefined behavior. From [stmt.return]:</p>

<blockquote>
  <p>Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</p>
</blockquote>

<p>One type of undefined behavior is magically working code. Another type is magically destroying-your-harddrive code. I wouldn't rely on it magically working for very long. Fix it!</p>
",1
29496625,29496600,3,"<p>You want to use <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow""><code>std::string</code></a>.  It has the methods you are looking for.  It even has a <a href=""http://www.cplusplus.com/reference/string/string/compare/"" rel=""nofollow""><code>compare</code></a> method.</p>

<p>A char array isn't an object with any methods associated with it, it's just data.</p>
",0
29496657,29496600,1,"<p>A char array is not a class, therefore it has no member functions such as <code>compare</code>.</p>

<p>You could use <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow""><code>std::string</code></a> instead:</p>

<pre><code>std::string sType;
</code></pre>

<p>And compare it with <a href=""http://www.cplusplus.com/reference/string/string/compare/"" rel=""nofollow""><code>std::string::compare</code></a>:</p>

<pre><code>if (someStruct.sType.compare(""FF"") == 0)
</code></pre>

<p>Or simply using <a href=""http://www.cplusplus.com/reference/string/string/operators/"" rel=""nofollow""><code>operator==</code></a>:</p>

<pre><code>if (someStruct.sType == ""FF"")
</code></pre>
",2
21718392,21718361,0,"<p>Your first example is in the Top-Down style, the second in Bottom-Up style.</p>

<p>It's largely aesthetic, in that some people prefer one over the other.</p>

<p>For example, someone might prefer to get a high-level overview of the program before getting the details (top-down), while another might person might prefer to see the details first (bottom-up).</p>

<p>A tangible benefit of the declarations in the top-down approach is that you can more easily re-organize the function definitions without having to worry about ordering.</p>
",0
21718393,21718361,17,"<p>It's just for code organization purposes (""aesthetics"", I guess). Without forward declarations you'd need to write every function before it's used, but you may want to write the bodies of a function in a different order for organizational purposes.</p>

<p>Using forward declarations also allows you to give a list of the functions defined in a file at the very top, without having to dig down through the implementations.</p>

<p>Forward declarations would also be necessary in the case of mutually recursive functions. Consider this (silly) example:</p>

<pre><code>bool is_odd(int);  // neccesary

bool is_even(int x) {
  if (x == 0) {
    return true;
  } else {
    return is_odd(x - 1);
  }
}

bool is_odd(int x) {
  return is_even(x - 1);
}
</code></pre>
",2
21718401,21718361,1,"<p>Look at this example:</p>

<pre><code>int max(int num1, int num2) 
{
   // local variable declaration
   int result;

   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;

   return result; 
}
</code></pre>

<p>where, <code>int max(int num1, int num2)</code> is behaving as a function.</p>

<p>Now, here we have a program</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

// function declaration
int max(int num1, int num2);

int main ()
{
   // local variable declaration:
   int a = 100;
   int b = 200;
   int ret;

   // calling a function to get max value.
   ret = max(a, b);

   cout &lt;&lt; ""Max value is : "" &lt;&lt; ret &lt;&lt; endl;

   return 0;
}

// function returning the max between two numbers
int max(int num1, int num2) 
{
   // local variable declaration
   int result;

   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;

   return result; 
}
</code></pre>

<p>I kept <code>max()</code> function along with <code>main()</code> function and compiled the source code. While running final executable, it would produce the following result:</p>

<pre><code>Max value is : 200
</code></pre>

<p><strong>Calling a Function:</strong></p>

<p>While creating a C++ function, you give a definition of what the function has to do. To use a function, you will have to call or invoke that function.</p>

<p>When a program calls a function, program control is transferred to the called function. A called function performs defined task and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>

<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value.</p>
",2
21718716,21718361,8,"<p>Note I mean to make this answer supplementary, others have already given good answers to this questions. </p>

<p>Note that knowing how to forward declare things in C++ becomes very important. Once you begin using header files it basically becomes mandatory. Header files will allow you to build a prototype of functions and classes/structs then define them in a corresponding .cpp file. This  is a very important organizational feature of C++. </p>

<pre><code>// MyClass.h

class MyClass
{
public:
    MyClass(int x);
    void printInt();
private:
    int myInt;
};

// MyClass.cpp

MyClass::MyClass(int x)
{
    MyClass::myInt = x;
}

void MyClass::printInt()
{
    std::cout &lt;&lt; MyClass::myInt;
}
</code></pre>

<p>Doing things this way makes it so you're not completely bound to make a huge hodgepodge of code. Especially if you're writing real programs that will have a considerably large amount of source code. </p>

<p>So while in the question you asked forward declaring is really just more of a preference, later on it really won't be a choice.</p>
",1
22884594,22884500,3,"<p>Your <code>free()</code> member will call itself until it runs out of stack space. You probably meant to call <code>::free()</code>:</p>

<pre><code>void dCAllocator::free(void* ptr) {
    ::free(ptr);
}
</code></pre>
",1
33555970,33555902,3,"<p>You aren't making the member functions const. Do it like this:</p>

<pre><code>class Chore {
    ...
    void output() const;
    bool operator&lt;(const Chore&amp; c1) const; //Also added pass by reference here
};
void Chore::output() const {...}
bool Chore::operator&lt;(const Chore&amp; c1) const {...}
</code></pre>
",2
31544707,31542846,0,"<p>It will work if you </p>

<ol>
<li>put the right value in the bitset (i.e. you want 5_10 = 101_2 but you do octal 0000101_8 = 65_10), and </li>
<li>properly add the representation to your string.</li>
</ol>

<p>Try the following:</p>

<pre><code>std::bitset&lt;8&gt; bs(5);// = 00000101;
int off = 3; // the number of bits I would like
std::string offStr;  // final substring of bitset I wanted
for (std::size_t i = 0; i &lt; off; ++i)
{
      offStr += (bs[i] ? ""1"" : ""0"");
}
</code></pre>

<p>Note, though, that if you are using <code>std::string::operator+=</code> the bits will be in the wrong order, so either change your loop, or better, pre-allocate the string and use <code>operator[]</code>.</p>
",0
21788761,21788689,3,"<blockquote>
  <p>I have overloaded the operator &lt;&lt; to print data about a product in my program. ...  </p>
</blockquote>

<p>You can just insert it into the <code>std::ostream&amp; std::operator&lt;&lt;(std::ostream&amp; out, ...)</code> function call chain:</p>

<pre><code>ostream&amp; operator&lt;&lt; (ostream &amp;out, const Product&amp; p) {
    return out &lt;&lt; '\t' &lt;&lt; (int)p.code &lt;&lt; ""\tR$ "" 
               &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) 
               &lt;&lt; p.price &lt;&lt; '\t' &lt;&lt; p.name;
}
</code></pre>

<p>May be you'll also need to adapt some localization settings to get a <code>,</code> (instead of a <code>.</code>) to get your decimal point separator right.</p>

<blockquote>
  <p>I already tried <strong>out.setprecision(2)</strong>, but it didin't work.</p>
</blockquote>

<p>The reason is that <code>setprecision(int)</code> is not a method of the <code>std::ostream</code> interface, but a global function composed from the following bits (stolen from MinGW GCC 4.6.2 implementation):</p>

<pre><code>struct _Setprecision { int _M_n; };

// This is what's actually called (both functions below):
inline _Setprecision 
    setprecision(int __n) { return { __n }; }

template&lt;typename _CharT, typename _Traits&gt;
inline basic_ostream&lt;_CharT, _Traits&gt;&amp; 
operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __os, _Setprecision __f)
{ 
    // Note you can alternatively call std::ostream::precision() function
    __os.precision(__f._M_n);
    return __os; 
}
</code></pre>
",0
24572569,24572428,4,"<p>""<em>Since it's [...] const</em>"" - Nope.</p>

<p>You need <code>const char* const</code> - assuming you're using C++11.</p>

<p>Otherwise you have to put the definition in the cpp file.</p>

<p>See: <a href=""https://stackoverflow.com/questions/3531060/how-to-initialize-a-static-const-member-in-c"">How to initialize a static const member in C++?</a></p>
",0
24572621,24572428,4,"<p>Because string literals (eg <code>""id""</code>) are stored per file compilation unit.  So if they are in a header file, there's a different instance stored for each source file that includes it.  So your 'initialisation' is trying to store different values in a <code>static</code> variable for each compilation unit that <code>#include</code>s it..</p>
",0
24573119,24572428,17,"<p>Generally speaking you must define your static members in precisely one translation unit, and the language helps to enforce this by prohibiting you from writing an initialiser for such a member inside the surrounding class definition:</p>

<pre><code>struct T
{
   static int x = 42;
   // ^ error: ISO C++ forbids in-class initialization of
   // non-const static member 'T::x'
};
</code></pre>

<p>However, a special exception is made for constants, for convenience:</p>

<pre><code>struct T
{
   static const int x = 42;
   // ^ OK
};
</code></pre>

<p>Note that in most cases you still need to <em>define</em> the constant (in your .cpp file would be the best place):</p>

<pre><code>const int T::x;
</code></pre>

<hr>

<blockquote>
  <p><code>[C++11: 9.4.2/3]:]</code> If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression (5.19). A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. <em>[ Note:</em> In both these cases, the member may appear in constant expressions. <em>¡ªend note ]</em> The member shall still be defined in a namespace scope if it is <em>odr-used</em> (3.2) in the program and the namespace scope definition shall not contain an initializer.</p>
</blockquote>

<hr>

<p>Now, your member is not an <code>int</code> and even a <code>const char* const</code> is not of an ""integral type"":</p>

<pre><code>struct T
{
   static const char* const str = ""hi"";
   // ^ error: 'constexpr' needed for in-class initialization of
   // static data member 'const char* const T::str' of non-integral type
};
</code></pre>

<p>but it <em>is</em> of a ""literal type""; the upshot for you is that if you write it like this:</p>

<pre><code>static constexpr const char* const xml_ID_TAG = ""id"";
//     ^^^^^^^^^             ^^^^^
</code></pre>

<p>you should be okay. (Note that <a href=""https://stackoverflow.com/a/51051942/560648"">you will still need to define it</a>, <a href=""https://stackoverflow.com/q/45183324/560648"">until C++17</a>.)</p>

<p>This probably makes more sense anyway: why would you want to change the pointer?</p>
",2
28157331,28157000,0,"<p>You can mix templates / overloads. No problem.</p>

<p>For example:</p>

<pre><code>template &lt;typename T&gt; 
void DoSomethingIntense(T myBlah) {

}

void DoSomethingIntense(MyCustomClass myBlah) {

}
</code></pre>

<p>Then it will use the non-template version for argument type <code>MyCustomClass</code> and the template version for anything else (like <code>vector</code> or <code>array</code>)</p>

<p>Moreover, you can use <a href=""http://www.cplusplus.com/reference/type_traits/enable_if/"" rel=""nofollow noreferrer"">std::enable_if</a> to restrict the range of possible template arguments. See also <a href=""https://stackoverflow.com/questions/6972368/stdenable-if-to-conditionally-compile-a-member-function"">this question</a>.</p>
",0
28157078,28157000,1,"<p>Yes, you can achieve that by using templates:</p>

<pre><code>template&lt;typename T&gt;
void DoSomethingIntense(const T &amp;myBlah);
</code></pre>

<p>EDIT:</p>

<p>If I get your update right then I would say make use of <a href=""http://en.cppreference.com/w/cpp/language/sfinae"" rel=""nofollow"">SFINEA</a>:</p>

<pre><code>template&lt;typename T&gt;
struct is_vector : std::false_type {};

template&lt;typename T, typename A&gt;
struct is_vector&lt;std::vector&lt;T, A&gt;&gt; : std::true_type {};

template&lt;typename T&gt;
struct is_array : std::false_type {};

template&lt;typename T, size_t N&gt;
struct is_array&lt;std::array&lt;T, N&gt;&gt; : std::true_type {};

// add more if you want or define a macro

template&lt;typename T&gt;
std::enable_if_t&lt;is_vector&lt;T&gt;::value || is_array&lt;T&gt;::value, void&gt;
DoSomethingIntense(const T &amp;myBlah)
{
}

int main()
{
    std::vector&lt;int&gt; v;
    DoSomethingIntense(v); // OK

    std::array&lt;float, 5&gt; a;
    DoSomethingIntense(a); // OK

    std::queue&lt;int&gt; q;
    DoSomethingIntense(q); // ERROR
}
</code></pre>
",0
28157080,28157000,3,"<p>Yes, use a template.</p>

<pre><code>template &lt;typename Container&gt;
void DoSomethingIntense(Container blah) {  // Might be better as Container const &amp;
    // write code using blah.begin() or whatever
}
</code></pre>

<p>You might be able to make it even more generic, following the example of STL, by supporting a general iterator range rather than specifically a container:</p>

<pre><code>template &lt;typename Iterator&gt;
void DoSomethingIntense(Iterator begin, Iterator end);
</code></pre>
",0
21789540,19730976,1,"<p>Find below a faster (less trigono) solution in Go (can be easily translated to c++) which was inspired by <a href=""http://slabode.exofire.net/circle_draw.shtml"" rel=""nofollow"">Sieglord's Abode article</a></p>

<pre><code>func Torus(cx, cy, inner, outer float64, num_segments int) {
    theta := 2 * math.Pi / float64(num_segments)
    c := math.Cos(theta) //precalculate the sine and cosine
    s := math.Sin(theta)
    t_in := 0.0
    t_out := 0.0
    x_in := inner  //we start at angle = 0
    x_out := outer //we start at angle = 0
    y_in := 0.0
    y_out := 0.0

    gl.Begin(gl.QUAD_STRIP)
    for ii := 0; ii &lt;= num_segments; ii++ {
        gl.Vertex2f(float32(x_in+cx), float32(y_in+cy))   //output vertex inner
        gl.Vertex2f(float32(x_out+cx), float32(y_out+cy)) //output vertex outer
        //apply the rotation matrix
        t_in = x_in
        t_out = x_out

        x_in = c*x_in - s*y_in
        x_out = c*x_out - s*y_out

        y_in = s*t_in + c*y_in
        y_out = s*t_out + c*y_out
    }
    gl.End()
}
</code></pre>
",0
22469793,22469684,2,"<p>What the compiler means is the variable 'pcaMat' (pointer) not be initialized, so it doesn't point to anything before used. Not the pointee.</p>

<pre><code>void initPLBP(double *&amp;mat)
{
    if (...)
    {
        int pcaDim = 10;
        int featureDim = 80;
    }
    mat = new double[10 * 80];
}

int main()
{
    double* pcaMat = 0;
    initPLBP(pcaMat);
}
</code></pre>
",0
21593085,21592128,1,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/algorithm/fill"" rel=""nofollow""><code>std::fill</code></a> to completely fill the array with zeros.</p>

<pre><code>std::fill(fileName, fileName+1024, 0);
</code></pre>

<p>If you have C++11 it would be better to use <a href=""http://en.cppreference.com/w/cpp/iterator/begin"" rel=""nofollow""><code>std::begin</code></a> and <a href=""http://en.cppreference.com/w/cpp/iterator/end"" rel=""nofollow""><code>std::end</code></a> to get the iterators for the call.</p>

<pre><code>std::fill(std::begin(fileName), std::end(fileName), 0);
</code></pre>

<p>To initialize it for the first time you can use an initializer. The default value for <code>wchar_t</code> is zero so there's no need to even give any values in the brackets.</p>

<pre><code>wchar_t fileName[1024] = {};
</code></pre>
",0
21600663,21600468,1,"<p>The proper syntax may be found in any C++ reference, e.g. <a href=""http://msdn.microsoft.com/en-us/library/91563f79.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/91563f79.aspx</a>. They should never have any efficiency impact. As for usage hints, as with everything else it depends on specific case. They may make things cleared or more complicated.
One more thing worth mentioning - one should be careful with default parameters in virtual functions, since their values are resolved based on the static type, which can be unexpected.</p>
",1
21600668,21600468,1,"<p>Only case I can think of where it affects efficiency would be when you include something big as a default parameter but it's not used by any of the callers. For example:</p>

<pre><code>#include &lt;iostream&gt;
void foo(std::ostream&amp; out=std::cout) {
    out &lt;&lt; ""foo"";
}
</code></pre>

<p>If none of the callers use the default parameter, and the rest of the program doesn't need <code>&lt;iostream&gt;</code>  then it will have been included in vain, increasing the executable size (and compilation time which may or may not matter much).</p>
",0
21600727,21600468,0,"<p>The default value of a parameter is specified only in the <strong>declaration</strong> of a (member) function, like so:</p>

<pre><code>void fun(int value = 0);
</code></pre>

<p>Note that only the final parameters in a parameter-list may have default-values. E.g. the following is forbidden:</p>

<pre><code>void fun(int v1 = 0, int v2);
</code></pre>

<p>When the function is defined somewhere else, the default value must be omitted. </p>

<pre><code>void fun(int value)
{ 
    cout &lt;&lt; value &lt;&lt; '\n'; // will print 0 when nothing was passed by the user
}
</code></pre>

<p>They do <strong>not</strong> have runtime-overhead in any way, as the compiler will add this value to the function-call when the user has not specified it. Use them only when a certain default behavior is intuitive.</p>

<p>It can sometimes serve as an alternative to function overloading. The effect of the example above could also have been achieved by</p>

<pre><code>void fun();
void fun(int value);
</code></pre>

<p>But this means you'd have to implement <code>fun</code> twice (where <code>fun()</code> just calls <code>fun(0)</code>).</p>
",0
21789155,21789113,2,"<p>Nevermind I figured it out, I realized that the code works perfectly, but when it loops back to the While() it resets nStamina back to 20, so it did do the substraction, but it resets so to fix it I declared the variables outside of the loop.</p>
",1
24124121,24124043,6,"<p>You need to specify template type:</p>

<pre><code>BookmarkRepository&lt;Bookmark&gt;* repo = new BookmarkRepository&lt;Bookmark&gt;(""./resources/bookmarks"");
</code></pre>
",3
22882746,22882731,4,"<pre><code>true || false == true
true &amp;&amp; false == false
!false == true
</code></pre>
",0
22882759,22882731,3,"<pre><code>! ( ( true || false ) &amp;&amp; false )
</code></pre>

<p>is equal to</p>

<pre><code>! ( ( true ) &amp;&amp; false )
</code></pre>

<p>which is</p>

<pre><code>! (  false )
</code></pre>

<p>which is</p>

<pre><code>true
</code></pre>
",0
22882807,22882731,0,"<p>Try to go through it one-by-one:</p>

<p><code>! ( ( true || false ) &amp;&amp; false )</code></p>

<p><code>3 ( (      1        )     2    )</code></p>

<p>1) <code>true || false</code> => true because it is true if at least either of them is true.</p>

<p>2) <code>true &amp;&amp; false</code> => false because it is only true if both are true, i.e. if at least either of them is false, it evaluates to false.</p>

<p>3) <code>!(false)</code> => true because '!' means negation, the negation of false is true, and the negation of true is false.</p>
",0
22882846,22882731,0,"<p>For these kind of Boolean logic issues I always try to break it into steps.</p>

<p>So for this the first condition</p>

<pre><code>    ( true || false )
</code></pre>

<p>This is equal to true as you're saying true OR false</p>

<p>The next condition can now be read as</p>

<pre><code>   ( true &amp;&amp; false )
</code></pre>

<p>Which is false</p>

<p>The final bit that makes it true as oppssed to false is the !</p>

<p>The final part can be equated to </p>

<pre><code>    !( false )
</code></pre>

<p>The ! flips the value so the final statement is true</p>
",0
21298889,21298678,0,"<p>Id rather you have code for me to work off of for my answer but assuming your question and statement I will say this. Have a loop in which counts the amount of times the user inputs a number. When the user enters three numbers; Initialize a row variable in which takes the value of 2. Then loop it based on the amount of times the user imputed numbers with a for loop or any other method you choose.</p>

<p>Also to answer your question about the remaining 3 numbers I have provided a link below about the array uninitialized indexes</p>

<p><a href=""https://stackoverflow.com/questions/11812687/why-is-int-array-not-initialized-to-zeros-in-c"">Why is int array not initialized to zeros in C++?</a>?</p>
",0
21299061,21298678,0,"<pre><code>const int Q = 2;
const int S = 3;
int flag = 0;
int matrixA[Q][S] = {0};
for(int i = 0; i &lt; Q; i++){
    for(int j = 0; j &lt; S; j++){
        matA[i][j] = 0;
    }
 }

for(int i = 0; i &lt; Q; i++){
    for(int j = 0; j &lt; S; j++){
        if(getline(cin, matA[i][j])){

        }
        else{
            flag = 1;
            break;
        }
    }
    if(flag == 1){
        break;
    }
}
</code></pre>

<p>Let me know if that helps.. :)</p>
",0
21298776,21298678,1,"<p>Initialize array MatrixA with 0s and then accept values from user. Code would be something like below:</p>

<pre><code>int iOuter = 0;
int iInner = 0;
for (iOuter = 0; i &lt;2; iOuter++)
   for (iInner = 0; i &lt; 3; iInner++)
   {
      MatrixA[iOuter][iInner] = 0;
      cin &gt;&gt; MatrixA[iOuter][iInner];
   }
</code></pre>
",0
22877151,22877030,1,"<pre><code>std::cin &gt;&gt; num1 &gt;&gt; operation &gt;&gt; num2;
do
{
switch(operation){
case '+': num2 += num1; break;
case '-': num2 -= num1; break;
case '/': num2 /= num1; break;
case '*': num2 *= num1; break;
default: std::cout &lt;&lt; ""Not a valid operation. Try again.""; break; }
std::cout &lt;&lt; num2;
std::cin &gt;&gt; operation;
if (operation == 'q') break;
else std::cin &gt;&gt; num1;
}
while (1);
</code></pre>

<p><strong>Sample I/O</strong>
3+4
7+3
10q
end
3+4</p>
",4
22877157,22877030,0,"<p>Try to do like this.   </p>

<pre><code>    std::cin &gt;&gt; num1 &gt;&gt; operation &gt;&gt; num2;    

do{
    std::cout &lt;&lt; ""Enter operation"";
    std::cin &gt;&gt;operation;
    switch(operation){
        case '+':
            num2 += num1;
            break;
        case '-':
            num2 -= num1;
            break;
        case '/':
            num2 /= num1;
            break;
        case '*':
            num2 *= num1;
            break;
        case 'q':
            return 0;      //or exit(0);
        default:
            std::cout &lt;&lt; ""Not a valid operation. Try again."";
            break;
    }
    std::cout &lt;&lt; num2;
} while (true);
</code></pre>
",4
22877167,22877030,0,"<p>Here's my take.</p>

<pre><code>int main()
{
   long double num1, num2;
   char operation;
   bool stop = false;
   std::cout &lt;&lt; ""Welcome to the calculator!\n\nInput numbers and operations to begin. (2+2) Then hit enter.\n\nThe calculator will continue to expect an operation and number (e.g. +6)\nuntil you enter \""q\"" as an operation.\n\nEnter \""q\"" as an operation to quit.\n\n"";

   std::cin &gt;&gt; num1 &gt;&gt; operation &gt;&gt; num2;

   do{
       switch(operation) {

           case '+':
              num2 += num1;
              break;

           case '-':
              num2 -= num1;
              break;

           case '/':
              num2 /= num1;
              break;

           case '*':
              num2 *= num1;
              break;

           default:
              std::cout &lt;&lt; ""Not a valid operation. Try again."";
              break;
       }
       std::cout &lt;&lt; num2 &lt;&lt; std::endl;

       // Skip till the end of the line.
       while ( std::cin.get() != '\n');

       // Read the next operation.
       std::cin &gt;&gt; operation;
       if ( operation == 'q' )
       {
          stop = true;
       }
       else
       {
          std::cin &gt;&gt; num1;
       }

   } while (std::cin.good() &amp;&amp; !std::cin.eof() &amp;&amp; !stop);
   return 0;
}
</code></pre>
",0
22877220,22877030,0,"<pre><code>case 'q': exit(0);
</code></pre>

<p>or</p>

<pre><code>case 'q': std::exit;
</code></pre>

<p>Don't forget to add cstdio header file.</p>
",0
24602696,24602680,3,"<pre><code>int sum3n5(int max){

    int sum = 0;

    for (int i = 1; i &lt;= max; ++i){

        if( i % 3 == 0 || i % 5 == 0 ){
            sum += i;
        }

    }

    return sum;       
}
</code></pre>

<p>You only need the <code>||</code> (logical or) operator, not the <code>&amp;&amp;</code> (and certainly not both!). And the <code>return</code> needs to be <em>after</em> the for loop so that the loop can complete before the function returns.</p>
",0
24605593,24602680,1,"<p>A version without loop:</p>

<pre><code>int sum3n5(int max)
{
    return 3 * (max / 3) * (max / 3 + 1) / 2
        + 5 * (max / 5) * (max / 5 + 1) / 2
        - 15 * (max / 15) * (max / 15 + 1) / 2;
}
</code></pre>

<p>It uses the fact that <code>1 + 2 + .. + n == n * (n + 1) / 2</code></p>
",0
29173776,29173593,1,"<p><code>SortingVector&lt;Payroll&gt; temp();</code> is not parsed as you expected (vexing parse), you want:</p>

<pre><code>SortingVector&lt;Payroll&gt; temp;
</code></pre>

<p>or</p>

<pre><code>SortingVector&lt;Payroll&gt; temp{}; /* since C++11 */
</code></pre>
",5
26138364,26138063,1,"<p>Instead of <code>#pragma once</code>, I suggest you to use internal <code>#define</code> guards:</p>

<pre><code>#ifndef _FOO_H_
#define _FOO_H_
/* ¡­ */
#endif /* _FOO_H_ */
</code></pre>
",1
23825872,20194324,0,"<p>I've found the answer. If anybody else is having this problem is because Visual Studio thinks that your .inl file is a source file and tries to compile it. </p>

<p>To solve this, you need to remove it from your project and add it again.
If in your project browser is displayed with an icon with 2 ""+"" besides it, it won't compile. That is the icon for source files.</p>
",0
21787294,21786694,0,"<p>Three steps should resolve this:</p>

<ol>
<li>Make your <code>User</code> class have two string data members for the username and password.</li>
<li>Create a stream extractor for <code>User</code> that extracts stream data into both the username and password</li>
<li>Continually extract into a <code>User</code> object and <code>push_back()</code> a copy of that object to the vector.</li>
</ol>
",0
26147182,26147153,1,"<p>Declare in one of your headers </p>

<pre><code>extern float * change;  // does not define the variable, but just that it exists somewhere
</code></pre>

<p>You can also declare this directly in <code>part1.cpp</code> and <code>part2.cpp</code> instead of a common header.  However if you'd later change something, float to double for example, you should not forget any of those declarations.  </p>

<p>Remember Stroustrups famous quote:  ""// global variable ¨C avoid those where you can"" </p>
",0
26147230,26147153,2,"<p>You can define the variable as normal in one of your <code>.cpp</code> files</p>

<pre><code>float* change;
</code></pre>

<p>Then in one of your header files, you can declare it:</p>

<pre><code>extern float* change;
</code></pre>

<p>Now #include the header file wherever the global variable is used.</p>
",3
26147238,26147153,1,"<p>I would recommend to do get/set functions to get variable from whenever you want and you'd keep OOP encapsulation. <a href=""http://www.cplusplus.com/forum/beginner/107842/"" rel=""nofollow"">http://www.cplusplus.com/forum/beginner/107842/</a></p>
",0
25690288,25690234,0,"<p>You need to initialize the class members in the constructor.  You can't initialize them directly as you are attempting to do.  There is no syntax for doing so; your attempt to do so is therefore a syntax error.</p>

<p>Try using these member declarations:</p>

<pre><code>Symbolic t, A, B;
float p1, p2, time;
Symbolic fn;
</code></pre>

<p>Then, initialize these using the initializer list in the constructor:</p>

<pre><code>fitFunction::fitFunction(vector&lt;float&gt; &amp; pars, float tt)
    : t(""t""),
      A(""A""),
      B(""B""),
      p1(pars[0]),
      p2(pars[1]),
      time(tt),
      fn(A * (1 - exp(-B * t)))
{
}
</code></pre>
",0
21718077,21717920,0,"<p>You have a mismatch of types and it's highly likely your code is not doing what you think it is. When you do:</p>

<pre><code>char Yes[1];
</code></pre>

<p>you are creating <code>Yes</code> which is an array of <code>char</code>'s of length 1. Chances are if you are only ever going to be looking at one character then you should just define a <code>char</code> and not an array. Later on you then try to assign an integer to <code>Yes</code>. I suspect what you were trying to do was <code>Yes = '1'</code> here.</p>
",0
22109167,22109141,1,"<p>Yes, this should work. Declaring two more pointers should not be necessary.</p>
",0
23592786,23592585,3,"<p>The standard library is your friend:</p>

<pre><code>#include &lt;set&gt;
#include &lt;iostream&gt;

int main()
{
  std::set&lt;std::string&gt; set;

  for (std::string line; getline(std::cin, line);)
    set.insert(line);

  for (auto const&amp; s : set)
    std::cout &lt;&lt; s &lt;&lt; '\n';
}
</code></pre>
",0
22493347,22493070,1,"<p>Well - if you use <code>return</code> in <code>main</code>, your program will just exit, because that's what return does - ends the function and returns some value. If you want to actually <strong>print</strong> the value of <code>test</code>, do it before you <code>return</code>:</p>

<pre><code>cout &lt;&lt; test;
getch(); // use this so the console won't close automatically
return 0;
</code></pre>

<p>Also, the whole program could be written much better:</p>

<pre><code>int main()
{
    cin&gt;&gt; num;
    cout &lt;&lt; num/4;
    getch(); // use this so the console won't close automatically
    return 0;
}
</code></pre>
",0
22493381,22493070,1,"<p>Do you <em>need</em> to use a loop? If you just need ""How many times is a given number divisible by 4"" and are not required to loop</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int main()
{
    int num;
    cin&gt;&gt; num;
    cout&lt;&lt; num&lt;&lt;"" is divisible by 4 ""&lt;&lt; (num&gt;&gt;2) &lt;&lt;"" time""&lt;&lt;(num&gt;&gt;2&gt;1?""s"":"""") &lt;&lt;endl;
    return 0;
}
</code></pre>

<p><code>num&gt;&gt;2</code> is bit shifting to teh right twice, which is the same as doing an integer divide by 4. It could be replaced by <code>num/4</code> if you wanted. Integer division always truncates, so for all positive numbers, it's like rounding down: the same behavior your loop gives you. </p>
",0
26207809,26207561,0,"<p>As the user n.m suggested, it seemed that because I was reading a text file for Windows and running program on Ubuntu, the output looked wrong. His answer word for word:</p>

<p>""You have a text file created for Windows that has <code>\r\n</code> as the line terminator. Your program either runs on a un*x or fails to open the file in text mode. Thus you are getting <code>\r</code> at the end of each string, which messes your terminal window. ""</p>

<p>He suggested I check to see if the the last character in the string after I've used <code>std::getline()</code> is <code>\r</code> and, if it is, to remove it from the string. I did this by simply making a substring of the strings in question after I acquired them with <code>std::getline()</code> </p>

<p>I then inserted the new substrings into the linked list and the <code>print()</code> method now outputs as desired.</p>
",0
23844418,23844213,0,"<p>Add a space when you reached the end of the original input line:</p>

<pre><code>if printIt == scrambleWords.length()-1
    cout &lt;&lt; "" "";
</code></pre>

<p>Put this code in the inner for loop, after </p>

<pre><code>if (isspace(scrambleWords[printIt]))
    break;
</code></pre>

<p>Note that breaking out of a for loop is not going to win you any programming beauty contests.</p>
",0
23844339,23844213,0,"<p>You may use something like (C++11 for <code>auto</code>): (<a href=""http://ideone.com/mxOCM1"" rel=""nofollow"">http://ideone.com/mxOCM1</a>)</p>

<pre><code>void print_reverse(std::string s)
{
    std::reverse(s.begin(), s.end());
    for (auto it = s.begin(); it != s.end(); ) {
        auto it2 = std::find(it, s.end(), ' ');
        std::reverse(it, it2);
        it = it2;
        if (it != s.end()) {
            ++it;
        }
    }
    std::cout &lt;&lt; s &lt;&lt; std::endl;
}
</code></pre>
",0
23844355,23844213,1,"<p>The cleanest and easiest solution is to rely on the standard libraray:</p>

<pre><code>// 1. Get your input string like you did

// 2. Save the sentence as vector of words:
stringstream sentence {scrambleWords};
vector&lt;string&gt; words;
copy(istream_iterator&lt;string&gt;{sentence},istream_iterator&lt;string&gt;{},
    back_inserter(words));

// 3 a) Output the vector in reverse order
for (auto i = words.rbegin(); i != words.rend(); ++i)
    cout &lt;&lt; *i &lt;&lt; "" "";

// 3 b) or reverse the vector, then print it
reverse(words.begin(),words.end());
for (const auto&amp; x : words)
    cout &lt;&lt; x &lt;&lt; "" "";
</code></pre>
",1
21777569,21777455,4,"<p>Even in this simple case there is a problem, since you could change a pointer to <code>B</code> to point to an instance of <code>A</code> if this conversion were allowed:</p>

<pre><code>A aObj;
B *bPtr;

A **aPtrPtr = &amp;bPtr;
*aPtrPtr = &amp;aObj;
</code></pre>

<p>The last line sets the <code>bPtr</code> to point to <code>aObj</code>. So now a pointer to <code>B</code> actually points to an instance of <code>A</code>.</p>
",0
21777586,21777455,5,"<p>What might happen were it allowed:</p>

<pre><code>struct A { int x; };

struct B : public A { int y; };

//...

B b;
B* pb = &amp;b;
A** ppa = &amp;pb;
A a;
*ppa = &amp;a; // ppa points to pb, thus henceforth, pb == &amp;a
pb-&gt;y = 100; // oops!
</code></pre>
",0
25458873,25458788,4,"<p>The non-existence of virtual constructors has nothing to do with the creation process of the vtable/vptr. In fact, the vtable concept itself is an implementation detail (how/if vtable are used is implementation defined)</p>

<p>Now, what would a virtual constructor do ? The essence of virtual member functions is to provide dynamic polymorphism, when the dynamic type differs from the static type. </p>

<p>But a constructor <em>knows</em> the static type of the object, and it has to be the type of the actual (this) object : there is no dynamic behavior involved here.</p>

<hr>

<p><strong>Note:</strong></p>

<p>There are design patterns, such as the <a href=""http://www.parashift.com/c++-faq/virtual-ctors.html"" rel=""nofollow"">Virtual Constructor pattern</a>, that allows you to clone an object dynamically, if that's what you are really looking for :</p>

<pre><code>class Shape {
public:
  virtual ~Shape() { }                 // A virtual destructor
  virtual void draw() = 0;             // A pure virtual function
  virtual void move() = 0;
  ...
  virtual Shape* clone()  const = 0;   // Uses the copy constructor
  virtual Shape* create() const = 0;   // Uses the default constructor
};

class Circle : public Shape {
public:
  Circle* clone()  const;   // Covariant Return Types; see below
  Circle* create() const;   // Covariant Return Types; see below
  ...
};

Circle* Circle::clone()  const { return new Circle(*this); }
Circle* Circle::create() const { return new Circle();      }
</code></pre>
",0
25672020,25671850,0,"<p>You have included the implementation in the <code>setup_quest_tree.h</code> header file</p>

<pre><code>#include ""setup_quest_tree.cpp""
</code></pre>

<p>and included it in several translation units.<br>
To fix this, at least in <code>setup_quest_tree.cpp</code> just include the declarations from <code>setup_quest_tree.h</code>, and remove that <code>#include ""setup_quest_tree.cpp""</code> statement from <code>setup_quest_tree.h</code> should fix your linker errors.</p>

<p>You have to provide exclusively <strong>one</strong> definition (implementation) for your class (see also <a href=""https://stackoverflow.com/a/4955288/1413395"">this answer</a> for <em>""Is is a good practice to put the definition of C++ classes into the header file?""</em>).</p>

<p>If you put it there, just since you don't know how to add the <code>setup_quest_tree.cpp</code> to your program, check <a href=""https://stackoverflow.com/questions/12573816/what-is-an-undefined-reference-unresolved-external-symbol-error-and-how-do-i-fix"">this Q&amp;A</a> please to learn more about the linking process.</p>

<hr>

<p>Here's the relevant section from the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf"" rel=""nofollow noreferrer"">current c++ standard</a></p>

<blockquote>
  <h3>3.2 One definition rule [basic.def.odr]</h3>
  
  <p><sup>1</sup> No translation unit shall contain more than one definition of any variable, function, class type, enumeration
  type, or template.</p>
</blockquote>
",0
24377692,24377463,0,"<p>This hosts some valuable information to help you: <a href=""http://www.cplusplus.com/forum/general/50090/"" rel=""nofollow"">http://www.cplusplus.com/forum/general/50090/</a></p>

<p>The gist is that you want to do a dynamic_cast and check if it was successful or not. </p>

<p>A simpler alternative is to add a string ClassID to every class or subclass that defines what it is. Then just check for that ClassID string. </p>

<pre><code>if (fooObj.classID == ""fooClass"") { // do something }
</code></pre>
",3
24378113,24377463,0,"<p>There are a couple ways to approach the problem:</p>

<ul>
<li>have overloads of the <code>update</code> function that accept different arguments, and/or
<ul>
<li>then you need some way to work out which one to call</li>
</ul></li>
<li>have <code>update</code> accept arguments of a type such as <code>vector&lt;&gt;</code> or <code>map&lt;&gt;</code> that can contain a variable number of logical arguments, but then you have trouble passing the values in a type-safe way, and potential run-time errors when they're missing</li>
</ul>

<p>You could combine these approaches to lessen the downsides, perhaps:</p>

<pre><code>class gameobject
{
    ...

    enum Fields
    {
        ...  
    };

    tyepdef vector&lt;Fields&gt; Fields;
    virtual Fields get_fields_needed() const;
    typedef boost::variant&lt;int, double, std::string, ...&gt; Field_Types;
    virtual bool update(const vector&lt;Field_Types&gt;&amp;);
};

...

for (std::list&lt;gameobject*&gt;::iterator it = renderobjects.begin(); it != renderobjects.end(); ++it)
{
    vector&lt;Fields&gt; needed = (*it)-&gt;get_fields_needed;
    vector&lt;Field_Types&gt; fields;
    for (Fields::const_iterator i = needed.begin(); i != needed.end(); ++i)
         switch (*i)
         {
           case Field_A: fields.push_back(Field_Types(a_value)); break;
           case Field_B: fields.push_back(Field_Types(b_value)); break;
           ...
         }
    if (!(*it)-&gt;update(fields)) { cerr &lt;&lt; ""error""; }
}
</code></pre>

<p>Whether that's ""over-engineered"" for your purposes will depend on how many functons, parameters, combinations of parameters etc. you have....</p>
",0
31265495,31265439,1,"<ul>
<li>When passed two <code>int</code> operants, <code>&amp;</code> is the bitwise AND operator.</li>
<li>When passed two <code>int</code> operands, <code>&gt;&gt;</code> is the bitwise right shift operator.</li>
</ul>

<p>You can learn more details from any good text book, or online reference. For instance: <a href=""http://en.cppreference.com/w/cpp/language/operator_arithmetic"" rel=""nofollow"">http://en.cppreference.com/w/cpp/language/operator_arithmetic</a></p>
",0
22493220,22493073,1,"<p>you need to declare it in the cpp file with the intialization list</p>

<p>in the cpp file:</p>

<pre><code>vector&lt;Poiint&gt; Foo::vec={Point(1,2,3), Point(4,5,6), Point(8,9,10)};
</code></pre>

<p>where Point(x,y,z) is the constructor so it will populate the vector with three elements</p>

<p>in the class you should declare it like that:</p>

<pre><code>static vector&lt;Point&gt; vec;
</code></pre>
",1
22496281,22493073,0,"<pre><code>    vec[0] = { {1,2}, {3,4}};
</code></pre>

<p>This won't work as there is no vector constructor that takes variable number of objects (works in C++11 with support of initializer_list). </p>

<p>To get around that, you can do this using a couple of arrays:</p>

<pre><code>    Point v1[2] = {Point(1,2), Point(3,4)};
    Point v2[1] = {Point(0.0)}; 

vector&lt;Point&gt; Foo::vec[] = {vector&lt;Point&gt;(v1, v1+2), vector&lt;Point&gt;(v2, v2+1), vector&lt;Point&gt;()};
</code></pre>

<p>This uses the vector constructor that takes the begin and end iterators to construct the vector.</p>

<p>In C++11,  I think you can do it this way:</p>

<pre><code>    vector&lt;Point&gt; Foo::vec[] = {{Point(1,2), Point(3,4)}, {Point(0,0)}, {}};
</code></pre>
",0
22493822,22493073,0,"<p>A work-around would be adding an internal static Class _init (name it the way you like), whose constructor performs the actual initializing.</p>

<pre><code>Class Foo{
public:
static int bar;
static class _init{
 public _init(){// do something to bar}
} Initializer;
};

// --- in .cpp
// define 'bar' and 'Initializer'
</code></pre>

<p>So that Initializer's constructor will be called to initialize bar.</p>
",0
22494024,22493073,0,"<p>It looks like the intention is more like:</p>

<pre><code>static vector &lt; vector&lt;Point&gt; &gt; vec;
</code></pre>

<p><br/>
If so, then with some short testing in the C++11, Windows 64-bit C++Builder compiling and running, that obtains the desired result.  As an additional experiment, after defining parameter-less and passed value constructors for the Point (class?) type used in the example, calling push_back on the multidimensional vec works as well:</p>

<pre><code>vec.push_back( {{1,2}, {3,4}} );
vec.push_back( {{0,0}} );
vec.push_back( {{4,5}} );
</code></pre>

<p>I am confident the reason the <em>Point</em> class can be neglected is because the multidimensional <em>vec</em> vector has been declared to store <em>Point</em> instances.  The last line in the OP above of passing an empty Point does not achieve anything, as can be shown when traversing the vec.  The third element (index two), will not print a thing.  The {4, 5} <em>Point</em> has been added to test traversing to all indices of the vec.  Notice that there are two sets of curly braces inside the call of push_back.  Without the outer set of curly braces, the compiler error says, ""no matching member function for call to push_back.""  </p>

<p>Sample code to traverse the multidimensional vector (e.g. matrix or array):</p>

<pre><code>//
// Declared a typedef to separate the vector row and the whole matrix
// Makes it simpler to traverse each vector row later.  intVals is a 
// test class with public integer elements ""a"" and ""b"".  The intVals
// class substitutes for the Point type in the OP above.
//
typedef vector&lt;intVals&gt; vec_t;
vector&lt;vec_t&gt; matrix;


int jj;
for (int i = 0; i &lt; 3; i++)
{  
   jj = 0;
   for (vec_t::iterator j = matrix[i].begin(); j != matrix[i].end(); j++)
   {
      cout &lt;&lt; ""Matrix at index: "" &lt;&lt; i &lt;&lt; "", element: "" &lt;&lt; jj &lt;&lt; "" a = "" &lt;&lt; (*j).a;
      cout &lt;&lt; "" b = "" &lt;&lt; (*j).b &lt;&lt; endl;
      jj++;
   }
}                                                  
</code></pre>

<p><br/>
Note that the outer loop is clamped at three.  The real implementation could use the matrix::iterator instead (or a range for).</p>

<p>For additional reference on a multidimensional vector see the <a href=""http://www.cplusplus.com/forum/general/833/"" rel=""nofollow"">multidimensional vector, how to</a> forum posting.</p>
",0
31898037,31897140,2,"<pre><code>FlatFace face = FlatFace(&amp;verts ...
</code></pre>

<p>will be allocated on the stack. You add the address of a object on the stack to your vector. When you later iterate over your vector, this address is no longer valid because the object is no longer on the stack.</p>

<p>You could use a vector over shared pointers (<code>std::vector&lt;std::shared_ptr&lt;FlatFace&gt;&gt;</code>)</p>
",3
21033245,21032885,1,"<p>Look at the assembly code generated by your compiler.  </p>

<p>I have observed that a <code>static const</code> variable will directly access data in a read-only memory location, rather than allocating on the stack and copying the data.  </p>

<p>The performance gain is negligible (almost immeasurable) between a <code>static</code> global variable and a global variable.  You would get better results by coding to help the compiler put your variables in registers.  </p>

<p>You would also gain performance by setting up your data to fit into a single data cache line.  The processor can fetch the data once into its cache and refer to it there, rather than fetching from external memory.  </p>

<p>Of course if you want more noticeable performance gains, reduce your function calls, and branches (jumps).  These cause the processor to reload the instruction cache, which costs more time than accessing data variables from external memory.</p>

<p>You will waste more time debugging if you use global variables.  In general, a program's development cost outweighs its performance.  Some game programs take years to develop but are never executed for years.  </p>
",0
21032914,21032885,7,"<p>Performance depends on many factors, you can not assume that simply changing this details would really improve performance.</p>

<p>The best approach to improve performance is to understand the details of your implementation and apply a profiling tool to identify your real bottlenecks.</p>

<p>Most of the time people tend to early optimize code, employing to much effort and making code unreadable on parts that doesn't have much impact on the overall performance of the application.</p>

<p>Cheers</p>
",0
21033042,21032885,12,"<p>You are very unlikely to outperform a function local variable of a built-in type with putting it somewhere else except: If the value of the variable can be computed at compile-time, making it a <code>constexpr</code> will be ideal.</p>

<ul>
<li>Making the variable <code>static</code> may incur a small cost on every call of the function determining if the object was already initialized, especially with C++11 where the initialization is thread-safe. Even if it doesn't need a check, the stack is likely to be in cached memory while a <code>static</code> variable is not.</li>
<li>Making a variable global will increase the chances that it isn't in cached memory, i.e., there is a good chance that it will be slower (aside from adverse other potential like making it a good candidate to introduce data races).</li>
<li>Making a variable <code>const</code> may help if the compiler can compute the value as compile time.</li>
</ul>

<p>If the variable has a non-trivial type things get more intersting because the initialization cost, e.g., of a <code>std::vector&lt;T&gt;</code> is non-trivial. I wouldn't expect a difference between making the objects <code>static</code> function local compared to global objects (i.e., I wouldn't make them global; there is no space for global objects anyway). However, making objects <code>static</code> introduces the potential that they may be shared between threads. If that is a concern the added locking and serialization probably defeats any potential savings and using allocators using stack-based memory is a better approach to improve the costs (assuming they are small enough to reasonably life on the stack).</p>
",3
22123874,22123786,0,"<p>One problem: it makes every object bigger by the size of one reference. The compiler can't optimize the member out of existence.</p>

<p>I guess you could actually use a macro like </p>

<pre><code>#define SELF (*this)
</code></pre>

<p>to get the same effect, without paying the size cost.</p>
",4
24565428,24565336,5,"<p>The problem is with:</p>

<pre><code>srand (time(0));
int randNum = (rand() % 4);
</code></pre>

<p>Probably on your system, <code>time(0)</code> returns the number of seconds this epoch.  So when you call this code multiple times without a second elapsing, it gets the same value. Therefore you get the same random number every time.</p>

<p>You're supposed to do <code>srand</code> just once per program run.  And if you need any serious sort of randomness then you need more entropy than just <code>time(0)</code>.  Even if you fix this, you could still execute your program several times and get the same card sequence every time, if all the runs begin within the same second.</p>

<p>The way that <code>rand()</code> typically works is to generate a long sequence of numbers which is predictable if you know the seed, but hard to predict just from a subset of the number. The <code>srand</code> function says ""start the sequence at <em>this</em> point"".  If you start at the same point each time , you get the same random numbers each time. <a href=""http://en.wikipedia.org/wiki/Pseudorandom_number_generator#Potential_problems_with_deterministic_generators"">Further reading</a></p>
",4
24565430,24565336,3,"<p>Call <code>srand(time(0))</code> only once when your application starts, e.g., at the <code>main()</code> function, not whenever any card is created.</p>
",0
28468858,28468845,2,"<p>Your code is doubly wrong. <code>ack.back()</code> is just the value of the last element - that is unrelated to any operation you are trying to do. Also, <code>ack.back() - 1</code> is not a function of your loop index - so <code>ack[ack.back() - 1]</code> is just some constant that you will add every time in the loop.</p>

<p>Since you want the ""last - Nth"" element every time, that implies that you need to subtract something from the <code>size()</code>. So what you want to do is:</p>

<pre><code>for(size_t i = 0; i &lt; ack.size(); i++)
{
    cout &lt;&lt; ack[i] + ack[ack.size() - i - 1] &lt;&lt; endl;
}
</code></pre>
",7
24584960,24584819,0,"<p>From <a href=""http://msdn.microsoft.com/en-us/library/ee404732.aspx"" rel=""nofollow"">MSDN</a>, <code>make_task</code> returns a <code>task_handle&lt;Function&gt;</code> where <code>Function</code> is the function type you pass in.</p>

<p>Lambdas have types that cannot be named, so your two options are to wrap the lambda in a <code>std::function</code>:</p>

<pre><code>struct ClassContainingTask {
    ClassContainingTask(int Input1, int *Output1, int *Output2) :
        t1(std::function&lt;void()&gt;([&amp;]{ParProcess(Input1,Output1,Output2);}))
    {}
    task_handle&lt;std::function(void())&gt; t1;
};
</code></pre>

<p>or to make your class a template and making the <code>task_handle</code> a template parameter:</p>

<pre><code>template&lt;typename F&gt;
struct ClassContainingTask {
    ClassContainingTask(F &amp;&amp;f) : t1(std::forward&lt;F&gt;(f))
    {}

    task_handle&lt;typename std::decay&lt;F&gt;::type&gt; t1;
};

template&lt;typename F&gt;
ClassContainingTask&lt;F&gt;
make_ClassContainingTask_helper(F &amp;&amp;f) {
    return ClassContainingTask&lt;F&gt;(std::forward&lt;F&gt;(f));
}

//Call this to create the ClassContainingTask instantiated
//with the appropriate template parameter
auto make_ClassContainingTask = [](int Input1, int *Output1, int *Output2) {
    return make_ClassContainingTask_helper([&amp;]{ParProcess(Input1,Output1,Output2);});
};
</code></pre>
",1
24594559,24594520,3,"<p>In a <code>for</code> loop it doesn't matter if you use <code>++x</code> or <code>x++</code> except that <code>++x</code> would be slightly faster since it won't create a temp variable.</p>
",5
24594594,24594520,2,"<p>The difference between <code>a++</code> and <code>++a</code> is whether a is incremented <strong>before</strong> or <strong>after</strong> the expression is returned. Consider the following example:</p>

<pre><code>int a = 5; 
cout &lt;&lt; a++ &lt;&lt; endl; //5
cout &lt;&lt; a &lt;&lt; endl; //6
a = 5;
cout &lt;&lt; ++a &lt;&lt; endl; //6
cout &lt;&lt; a &lt;&lt; endl; //6
</code></pre>

<p>You don't use the value of <code>a++</code>for your loop, so - as <code>cout &lt;&lt; a &lt;&lt; endl;</code> in my example, you will always get the variable to be increased by one.</p>

<p>The syntax of the for loop is as follows:</p>

<p><code>for(initialize;condition;step){ /*block*/}</code></p>

<p>The <em>initialize</em> part is run once at the beginning. For each loop, the <em>condition</em> is checked, and the <em>step</em> is executed afterward. It is not evaluated, and therefore doesn't infer with the condition.</p>
",0
23573982,23573735,2,"<p>In older versions of boost filesystem the return type of the method filename() is of string_type and not of type path. string_type does not have the member filename() contrary to the path type.</p>

<p>For the older version of boost you are using you can just remove the .string() part in the code.</p>
",0
32939338,32939075,0,"<blockquote>
  <p>myarray = new QueueElement(initial_capacity);</p>
</blockquote>

<p>should be:</p>

<pre><code>myarray = new QueueElement[initial_capacity];
</code></pre>

<p>Since queue-element is <code>int</code>, you were allocating an array of just one element, that is why your code crashed at the second call to <code>enqueue</code>.</p>
",0
24601932,24601851,0,"<p>The problem is with how you are using the <code>if-else</code> statement. Try this code out:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
std::cout &lt;&lt; ""What is the password?\n"" &lt;&lt; std::endl;
char password[20] = ""NULL"";
std::cin &gt;&gt; password;
std::cin.ignore();
std::cout &lt;&lt; password &lt;&lt; "" is your entry?\n"";
if (stricmp(""hotdog"", password) == 0)
{
    std::cout &lt;&lt; ""Correct!"";
}
else
{
    std::cout &lt;&lt; ""Incorrect!"";
}
std::cin.get();
}
</code></pre>
",1
24601949,24601851,2,"<p>Firstly, change <code>char password[20]</code> to <code>string password</code>. This prevents a buffer overflow if they type in more than 20, and it enables you to use <code>==</code> for string comparison.</p>

<p>The code <code>std::cin.ignore()</code> ignores a <em>single character</em>.  You want to actually ignore the entire remainder of the line.   There is no way to ignore ""everything else typed so far"" because there may have been characters typed which are still buffered. In practice, it works well to treat input as a series of lines.</p>

<p>The most accurate way to ignore the rest of the line is to ignore all characters up to and including <code>'\n'</code>, which appears in the input stream at the end of the line (by definition).</p>

<pre><code>std::cin.ignore( std::numeric_limits&lt;std::streamsize&gt;::max(), '\n' );
</code></pre>

<p>which may require <code>#include &lt;limits&gt;</code>. Another way is to read a string and discard it:</p>

<pre><code>std::string t;
std::getline( std::cin, t );  
</code></pre>

<hr>

<p>NB. Check your understand of <code>if...else</code> . Once you have <code>if ( condition )</code>, then the next <code>else</code> will already get everything that was not in that condition. It's pointless to actually write <code>else if ( !condition )</code>; and your final <code>else {</code> block can never be entered, because the previous two conditions were exhaustive.</p>
",1
24601994,24601851,0,"<p>When I take your code and compile it, even the term hotdog does not work properly, I obtain the following:</p>

<pre><code>What is the password?

hotdog
hotdog is your entry?
Incorrect!
</code></pre>

<p>As suggested above, a string is a better method and works as intended based on your requirements. Here is sample replacement code that works as intended (with this code spaces are allowed, with the other answers, spaces are not, it all depends what is intended):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main (int argc, char ** argv)
{
    cout &lt;&lt; ""What is the password?\n"" &lt;&lt; endl;
    string password = ""NULL"";
    getline(cin, password);
    cout &lt;&lt; password.c_str() &lt;&lt; "" is your entry?\n"";
    if (password == ""hotdog"")
    {
        cout &lt;&lt; ""Correct!"";
    }
    else if (password != ""hotdog"")
    {
        cout &lt;&lt; ""Incorrect!"";
    }
    else
    {
        // Added from original; however, this should never occur
        cout &lt;&lt; ""Else?"";
    }
    system(""pause"");
    return 0;
}
</code></pre>

<p>Output of Replacement Code</p>

<pre><code>What is the password?

hotdog
hotdog is your entry?
Correct!
</code></pre>
",0
24601997,24601851,-1,"<p>You had to use strcmp() function to compare strings properly in c++,so I added the cstring library:</p>

<pre><code> #include &lt;iostream&gt;
 #include &lt;cstring&gt;
 #include &lt;string&gt;

using namespace std;

int main(){

    string password;
    cin &gt;&gt; password;
    cout &lt;&lt; password &lt;&lt; "" is your entry?\n"";
    char hd [7] = ""hotdog"";
    if (strcmp(password.c_str(),hd) == 0){
        cout &lt;&lt; ""Correct!\n"";
     }  
    else if (strcmp(password.c_str(),hd) != 0){
        cout &lt;&lt; ""Incorrect!\n"";
     }
    else{
        cin.get();
    }

}
</code></pre>
",1
30717366,30717291,1,"<p>If your compiler supports C++ 2011 then write</p>

<pre><code>int* Foo::list = new int[10] { 2 };
</code></pre>

<p>Another way is for example to define a private static function. For example</p>

<pre><code>class Foo
{
// ...
private:
    static int *list;
    static int * init() 
    {
        int *p = new int[10];
        p[0] = 2;
        return p;
    }       
};

int* Foo::list = Foo::init();
</code></pre>
",0
22886300,22886167,4,"<p>Using this test-program based on what you posted:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;


int main()
{
    std::string a;

    std::cin &gt;&gt; a;

    std::cout &lt;&lt; a.length() &lt;&lt; std::endl;
}
</code></pre>

<p>I can do:</p>

<pre><code>./a.out &lt; fact100000.txt
</code></pre>

<p>and get the output:</p>

<pre><code>456574
</code></pre>

<p>However, if I copy'n'paste from an editor to the console, it stops at 4095. I expect that's a limit somewhere in the consoles copy'n'paste handling. The easy solution to that is of course to not use copy'n'paste, but redirect from a file. On some other systems, the restruction to 4KB of input may of course reside somewhere else. (Note that, at least on my system, I can happily copy and paste the 450KB of factorial result to another editor window, so in my system it's simply the console buffer that is the problem). </p>
",3
22886217,22886167,2,"<p>This is much more likely to be a platform/OS problem than a C++ problem. What OS are you using, and what method are you using to get the string fed to stdin? It's pretty common for command-line arguments to be capped at a certain size.</p>

<p>In particular, given that you've tried reading one character at a time, and it still didn't work, this seems like a problem with getting the string <em>to</em> the program, rather than a C++ issue.</p>
",1
26144734,26144702,0,"<p>Static keyword means it is being shared by all the objects that will be instantiated by the class. Hence you need to initialize it outside any function.Static states that it is a class variable shared between all the instance of the class. It is opposite to instance variables, which each instance has its own copy. To access a class variable, there are two ways. 1)  a_class::static_variable 2) a_class a; a.static_variable. The initialization must go in the source file (.cpp) rather than in the header.
Because it is a static variable the compiler needs to create only one copy of it. If you don't, you get a link error. If that is in a header you will get a copy in every file that includes the header, so get multiply defined symbol errors from the linker.</p>

<p>Static data members are not part of objects of a given class type; they are separate objects. As a result, the declaration of a static data member is not considered a definition. The data member is declared in class scope, but definition is performed at file scope. </p>
",1
26144820,26144702,1,"<p>I have stumbled upon something like this once. It was something similar to singleton. The reason (as explained by the person doing it) was that he specifically wanted to initialize instance at the first getInstance() function call and he wanted to make sure that the _instance pointer will be at first initialized to NULL (and not some garbage from memory) so that the check</p>

<pre><code>if (_instance == NULL)
</code></pre>

<p>in the function works properly.</p>

<p>I am not sure this is the case here, but it's possible.</p>
",4
26144846,26144702,0,"<pre><code>myClass* myClass::_instance = NULL;
</code></pre>

<p>the code attempts to initialize the static member variable.</p>
",0
26144891,26144702,0,"<p>It's an initialisation, ensuring that the pointer starts life with the value <code>NULL</code> from the very beginning of the program.<sup>1</sup></p>

<p>It gives the pointer an invalid, but <em>recognisable</em> and <em>testable</em> value before some useful pointer value is assigned to it later on during the program. This way, you can safely test the pointer to see whether it was yet given said useful value.</p>

<p>In this case, since you are showing a singleton, ""later"" means ""when an instance of <code>myClass</code> is first requested"" using some <code>myClass::getInstancePlease()</code> function that you have not shown.</p>

<p>It is more common to implement a singleton with a function-<code>static</code> instance, rather than a class-<code>static</code> pointer to some [probably dynamically-allocated] instance.</p>

<p><sub><sup>1</sup> As an object with static storage duration, it would do so anyway; therefore, this initialisation is actually completely pointless beyond documenting programmers' intent.</sub></p>
",10
26146195,26144702,1,"<blockquote>
  <p>So what is the use of making the <code>_instance</code> to be NULL pointer outside any function?</p>
</blockquote>

<p>Static data members usually have to be defined, in the namespace containing their class, in one source file; they are subject to the One Definition Rule, and so must have exactly one definition in any program that uses them. This is that definition.</p>

<p>Initialising it with <code>NULL</code> makes sure it's initially null, so that the <code>Instance()</code> function can determine whether the instance has been created yet. This isn't strictly necesssary since, like all static variables, it will be zero-initialised whether or not you explicitly provide an initialiser.</p>

<blockquote>
  <p>And when is this line of code executed?</p>
</blockquote>

<p>During <em>static initialisation</em>, before any other code in the program; since it's a trivial type with a constant initialiser.</p>
",0
23595027,23595008,8,"<p>Use <code>g++</code> to compile C++ programs, not <code>gcc</code>.</p>
",0
25458211,25458197,4,"<p>Pointer to function and function Pointer are used synonymously. </p>
",0
22515510,22515302,4,"<p>In C++ there are 3 loops.</p>

<p><a href=""http://en.cppreference.com/w/cpp/language/while"" rel=""nofollow noreferrer"">while</a></p>

<p><a href=""http://en.cppreference.com/w/cpp/language/do"" rel=""nofollow noreferrer"">do while</a></p>

<p><a href=""http://en.cppreference.com/w/cpp/language/for"" rel=""nofollow noreferrer"">for</a></p>

<p>You want to look at your main method as the starting point of the program - and also view it as the first control level. From there you should delegate out to methods that manage the runtime of the program. If you want to reuse a body of code you'll want to use a loop and call it again. Your code example is similar to <a href=""https://stackoverflow.com/questions/3021/what-is-recursion-and-when-should-i-use-it"">recursion</a>, but isn't the right implementation of it nor the right time to use it. Recursion can be a powerful tool to simplify complex iterative algorithms, but doesn't fit all cases that act like a loop. It doesn't fit here.</p>

<p>In your case, <code>do while</code> seems fitting. Do also note that developers have style in their coding preference, and technically any loop can be used with some finesse.</p>

<p><strong>EDIT</strong> I did a little bit of code cleanup. Much more could be done of course. Note that your teacher/online tutorial likely shows variable declarations grouped together at the start of a method. That is an old carryover from <code>c</code> days, is not necessary, and I find it messy. Keep the variables close to their usage. At the point you feel you're declaring too many variables, consider breaking your function apart.</p>

<pre><code>void DegreesToFarenheit()
{
  cout &lt;&lt; ""Please Enter a Temperature in Degrees: "";

  float degrees;
  cin &gt;&gt; degrees;

  float farenheit = (((degrees * 9)/5) + 32);
  cout &lt;&lt; degrees &lt;&lt; "" Degrees is "" &lt;&lt; farenheit &lt;&lt; "" Farenheit"";
  cout &lt;&lt; endl;
}

bool RepeatPrompt()
{
  cout &lt;&lt; ""Would you like to enter a new value? "";

  char ans;
  cin &gt;&gt; ans;

  cout &lt;&lt; endl;

  return ans == 'y' || ans == 'Y';
}

int main()
{
  do
  {
    DegreesToFarenheit();
  } while(RepeatPrompt());

  return 0;
}
</code></pre>
",5
26790556,26790496,4,"<p>You can perform a <a href=""http://en.wikipedia.org/wiki/Flood_fill"" rel=""nofollow noreferrer"">flood fill</a> to determine which squares are reachable from a given starting location. See this animation from <a href=""http://en.wikipedia.org/wiki/Flood_fill"" rel=""nofollow noreferrer"">the Wikipedia article</a>:</p>

<p><img src=""https://i.stack.imgur.com/E9qTp.gif"" alt=""""></p>

<p>Alternatively, if you want to determine if you can reach one square from another one, use a <a href=""http://en.wikipedia.org/wiki/Pathfinding"" rel=""nofollow noreferrer"">pathfinding</a> algorithm such as <a href=""http://en.wikipedia.org/wiki/A*_search_algorithm"" rel=""nofollow noreferrer"">A*</a>. Again, an animation from <a href=""http://en.wikipedia.org/wiki/A*_search_algorithm"" rel=""nofollow noreferrer"">Wikipedia</a>:</p>

<p><img src=""https://i.stack.imgur.com/SCWsq.gif"" alt=""enter image description here""></p>
",2
29251852,29246420,1,"<p>Assuming that <code>amqp</code> is the third-party library, you need to tell the compiler what the alignment is for <em>that</em> code: <code>pack(4)</code>. </p>
",0
23596683,23596653,0,"<p><code>std::toupper()</code> takes an <code>int</code>, but you are passing it a string. Do something like this:</p>

<pre><code>for(int j=0;j&lt;=9;j++){
    for(int p = 0; p &lt; names[j].length(); ++p){
        names[j][p]=toupper(names[j][p]);
    }
    cout&lt;&lt;names[j]&lt;&lt;endl;
}
</code></pre>
",0
23596690,23596653,2,"<p>You must pass a <code>char</code> to <code>std::toupper</code> not whole <code>string</code>:</p>

<pre><code>for (auto &amp;x : names)
  std::transform(x.begin(), x.end(), x.begin(), ::toupper);
</code></pre>
",0
23596750,23596653,0,"<p><code>toupper(int)</code> accepts only one letter, not the whole string. To capitalize whole string, you should write a function such as:</p>

<pre><code>void ToUpperString(std::string&amp; str)
{
    for(int i = 0; i &lt; str.length(); ++i)
    {
        str[i] = toupper(str[i]);
    }
}
</code></pre>

<p>And then call it for each string that you want to capitalize:</p>

<pre><code>for(int j = 0; j &lt;= 9; j++)
{
    ToUpperString(names[j]);
}
</code></pre>
",0
23596786,23596653,0,"<p>Change this loop</p>

<pre><code>for(int j=0;j&lt;=9;j++){
names[j]=toupper(names[j]);
</code></pre>

<p>to</p>

<pre><code>for (int j = 0; j &lt; 10; j++ ) names[j][0] = toupper( names[j][0] );
</code></pre>

<p>In your loop names[j] returns an element of the array that is an object of type <code>std::string</code> while you need to gett access only to the first character of the object.</p>

<p>You could do the same the following way using the range-based for statement</p>

<pre><code>for ( std::string &amp;s : names ) s[0] = toupper( s[0] );
</code></pre>
",0
23596871,23596653,0,"<p>By the way, you can use <strong>strupr</strong> function:</p>

<pre><code>char str[] = ""sample text"";
strupr( str );
cout &lt;&lt; str; // will print SAMPLE TEXT
</code></pre>
",0
31802325,31801965,7,"<p>You have overloaded stream operators for files but you are not using files I/O but console input.</p>

<pre><code>cin &gt;&gt; pnt &gt;&gt; pnt2;
</code></pre>

<p>Change to</p>

<pre><code>friend ostream&amp; operator&lt;&lt; (ostream&amp; s, const Point1&amp; p)
{
    s &lt;&lt; p.x;
    return s;
}
friend istream&amp; operator&gt;&gt; (istream&amp; s, Point1&amp; p)
{
    s &gt;&gt; p.x;
    return s;
}
</code></pre>

<p>If you compare types here there is wrong type overloaded for cin operation, some info
<a href=""http://en.cppreference.com/w/cpp/io/cin"" rel=""nofollow"">http://en.cppreference.com/w/cpp/io/cin</a> <a href=""http://en.cppreference.com/w/cpp/io/basic_ifstream"" rel=""nofollow"">http://en.cppreference.com/w/cpp/io/basic_ifstream</a> <a href=""http://en.cppreference.com/w/cpp/io/basic_istream"" rel=""nofollow"">http://en.cppreference.com/w/cpp/io/basic_istream</a> </p>

<p>Cin is of type istream but there is no operator for this type, there is only operator for ifstream.</p>
",0
31802406,31801965,3,"<p>Your code expects <code>ofstream</code> and <code>ifstream</code>, which are file based streams. You should use the less specific <code>ostream</code> and <code>istream</code> instead. </p>
",0
29463786,29463702,3,"<p>In this line</p>

<pre><code>const int&amp; r3 = r1 * 2;
</code></pre>

<p>a temporary <code>int</code> is created and copy-initialized from the initializer expression <code>r1 * 2</code>, then <code>r3</code> is bound to the temporary. This does not modify the referrent of <code>r1</code> any more than evaluating <code>3 * 2</code> modifies <code>3</code>.</p>
",1
26195421,26195283,2,"<p>This doesn't have anything to do with the <code>using</code> directive. Within the definition of <code>A&lt;T&gt;</code> (and the <code>using</code> directive is in that scope), saying <code>A</code> is the same as saying <code>A&lt;T&gt;</code>.</p>

<p>It's the same reason you may write:</p>

<pre><code>template &lt;typename T&gt;
struct A
{
   void foo(const A&amp;);
};
</code></pre>

<p>instead of</p>

<pre><code>template &lt;typename T&gt;
struct A
{
   void foo(const A&lt;T&gt;&amp;);
};
</code></pre>

<p>For more information, search for ""<em>injected-class-name</em>"".</p>
",0
26195424,26195283,4,"<p>The name of a class is ""injected"" into the class, this is called the <em>injected-class-name</em>. It is similar to:</p>

<pre><code>class my_class_name
{
public:
    typedef ::my_class_name my_class_name;
};
</code></pre>

<p>(But this of course doesn't compile, a class may not have a manually declared member of the same name as the class.)</p>

<p>Class templates also have an injected-class-name, and it can be used to refer to the class template itself, or the current specialization (including the current template arguments), depending on the context:</p>

<p>[temp.local]/1</p>

<blockquote>
  <p>Like normal (non-template) classes, class templates have an <strong>injected-class-name</strong>. The injected-class-name can be used as a <em>template-name</em> or a <em>type-name</em>. When it is used with a <em>template-argument-list</em>, as a <em>template-argument</em> for a template <em>template-parameter</em>, or as the final identifier in the <em>elaborated-type-specifier</em> of a friend class template declaration, it refers to the class template itself. <strong>Otherwise, it is equivalent
  to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code></strong>.</p>
</blockquote>
",0
32465863,32465755,2,"<blockquote>
  <p>will x and y be concatenated, then copied, and then passed to foo? or will they be concatenated and passed to foo, without being copied?</p>
</blockquote>

<p>This depends entirely on the compiler. Both are valid behavior. With optimizations turned on it's very likely that the copy is omitted.</p>

<blockquote>
  <p>Is there a way to test this?</p>
</blockquote>

<p>Yes. Use your own class that prints something in its constructors.</p>
",0
32465979,32465755,1,"<p>First, let's establish that to do the concatenation a copy of both original strings must be made into a temporary string (otherwise where would the full concatenated value go?).</p>

<p>Then notionally a copy is made to pass to you <code>foo</code> function. However the compiler is allowed (but not required) to <em>elide</em> this copy if it wishes. Either behavior is standards conforming and should not affect your design.</p>
",4
21022991,21022939,1,"<p>In main function put:</p>

<pre><code>int result = sum(a,b);
</code></pre>
",0
21022994,21022939,2,"<p>Erm, you could just assign the result of <code>sum</code> to a local variable and print it:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int sum(int a,int b)
  {
   int result;
   result = a + b;
   return result;
  }

main()
{ 
   int a=2;
   int b=3;
   int res=sum(a,b);
   printf(""%d"",res); 
   system(""PAUSE"");
}
</code></pre>

<p>However, if you're asking this sort of question then you're really going to struggle with C++..!</p>
",6
21023521,21022939,0,"<p>Okay, I know that I only know a little of this language, but I still can answer this question easily.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int sum(int a,int b)
  {
   int result;
   result = a + b;
   return result;
  }

main()        // Are you serious? You forgot the int?
{ 
   int a=2;
   int b=3;
   sum(a,b);  // I'll explain this later.
   printf(""%d"",result); 
   system(""PAUSE"");
}
</code></pre>

<p>In the <strong><em>int sum()</em></strong> block, the <strong><em>int result</em></strong> is a local variable which means a variable that can only accessed by the block which is created inside. So the program will not return the result.</p>

<p>The <strong><em>sum(a,b)</em></strong> inside the main block shall be write like this:</p>

<pre><code>int r = sum(a,b);
</code></pre>

<p>Note: You can replace the ""r"" in the code with any names you like.</p>

<p>And the <strong><em>main()</em></strong> part should be write like this:</p>

<pre><code>int main() {
</code></pre>

<p>Anyway, the language you're using right now is called ""C language"", not C++ which it's based on that language I've talked just now. So go take a book about C++, but if you're interested in the one you're using then go find one about C language.</p>
",0
21023067,21022939,1,"<p><code>result</code> is a <em>local</em> variable.  It exists only within the context of the <code>sum()</code> function.</p>

<p><code>sum()</code> is returning <code>result</code> by-value, meaning a copy of <code>result</code> is (potentially) being made and returned from the function.  Since you don't assign that value to anything, it dissappears.</p>

<p>First, do this:</p>

<pre><code>int main()
{
  int a=2;
  int b=3;
  int c = sum(a,b);
  printf(""%d"",c); 
  system(""PAUSE"");
}
</code></pre>

<p>After running that, stop what you're doing and pick up a <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">good book on C++</a>.</p>
",0
23589648,23589532,2,"<p>You should first create the array of objects like below:</p>

<pre><code>T* s = new T[20]; //allocating 20 objects
</code></pre>

<p>now you can call your desired function by making a little change:</p>

<pre><code>class T
{
   public:
   T(){};//default constructor
   /// Constructor
   SetValue(const std::string&amp; baseName);
};
</code></pre>

<p>call the function using a loop:</p>

<pre><code>for( int i=0 ; i&lt;20;i++)
s[i].SetValue(baseString);
</code></pre>
",2
23589679,23589532,2,"<p>The compiler is telling you exactly what's wrong. You can't do this:</p>

<pre><code>T* s = new T[20](baseFileName);
</code></pre>

<p>More specifically, you can't have that <code>(baseFileName)</code> bit when you use new. Just add a default constructor to T and fill it in yourself. Maybe add a method to your T class that returns array for you without you having to loop every time you need to construct one.</p>

<pre><code>T * s = new T[20];
for(int i = 0; i &lt; 20; i++) { s[i].setName(baseFileName); }
</code></pre>

<p>Or since you already know what the array is going to look like at compile-time:</p>

<pre><code>T s [20] {baseFileName, baseFileName,baseFileName, baseFileName,baseFileName, baseFileName,baseFileName, baseFileName,baseFileName, baseFileName,baseFileName, baseFileName,baseFileName, baseFileName,baseFileName, baseFileName,baseFileName, baseFileName,baseFileName, baseFileName};
</code></pre>
",1
23070730,23070424,0,"<p>You are creating an object of type Car on the stack, but you are not saving any reference to it. When you call Car().setManufacturer(""asds""), it will create an object of type Car on the stack, but if you do not save a reference to it, you will technically lose it. What you want to do is assign it to something. Here is what you can do:</p>

<pre><code>Car myCar;
myCar.setManufacturer(""asds"");
cout &lt;&lt; myCar.getManufacturer();
</code></pre>
",0
23087366,23070424,0,"<p>There are a few problems with your code, currently:</p>

<p><strong>1. You're not initializing a Car object in your main method - there is no object to call these methods upon.  This can be fixed by modifying your main method:</strong></p>

<pre><code>    int main() {
        Car c(""Manufacturer"", ""Model"", 2000, ""Color"", 9999.99, 20);
        c.setManufacturer(""asds"");
        cout &lt;&lt; c.getManufacturer() &lt;&lt; endl;
    }
</code></pre>

<p><strong>2. You are trying to copy data to objects that aren't initialized inside the class (MfgYear, vehicleCost, mpg, color, modelName, mfg).</strong></p>

<pre><code>    private:
        int MfgYear;
        double vehicleCost;
        int mpg;
        char color[80];
        char modelName[80];
        char mfg[80];
</code></pre>

<p>I have included the corrected class below:</p>

<pre><code>    class CarChar
    {
    private:
        int MfgYear;
        double vehicleCost;
        int mpg;
        char color[80];
        char modelName[80];
        char mfg[80];

    public:
        Car(char* manufacturer, char* modelName, int mfgYear, char* color, double cost, int mpg)
        {                
            // Copy the data to the objects
            strncpy(this-&gt;mfg, manufacturer, sizeof(this-&gt;mfg));
            strncpy(this-&gt;color, color, sizeof(this-&gt;color));
            strncpy(this-&gt;modelName, modelName, sizeof(this-&gt;modelName));
            this-&gt;MfgYear = mfgYear;
            this-&gt;vehicleCost = cost;
            this-&gt;mpg = mpg;
        }

        char* getManufacturer() {
            return this-&gt;mfg;
        }

        void setManufacturer(char* mfgName) {
            strncpy(this-&gt;mfg, mfgName, sizeof(this-&gt;mfg));
        }
    };
</code></pre>

<p><em>Note: If you notice in the above class, I replaced all calls to strcpy to strncpy to reduce the chance of buffer overflow, a security problem.</em></p>
",0
23576724,23576694,2,"<p>This line</p>

<pre><code> if ( d[d[i]] == i)
</code></pre>

<p>is going access <code>d</code> beyond the valid range of indices since <code>d[i]</code> can be greater than <code>9999</code>.
Change it to:</p>

<pre><code> if ( d[i] &lt;= 9999 &amp;&amp; d[d[i]] == i)
</code></pre>
",1
23576727,23576694,0,"<p>If d[i] ever gets a value greater than 10000, then d[d[i]] will be a reference outside the 10000 integers you've allocated.  That'll cause an error.</p>
",0
21789063,21789020,2,"<p>Your <code>user_exists</code> function is <code>bool</code> but returns no value. Here is a suggestion:</p>

<pre><code>bool BBoard::user_exists(const string &amp;name, const string &amp;pass) const{
    vector&lt;User&gt;::const_iterator i = find(user_list.begin(), user_list.end(), name);
    return !(i == user_list.end());
}
</code></pre>
",3
31263091,31262942,20,"<p>The compiler cannot assume a pointer is non-null; when optimizing code, it has to either prove the pointer is non-null, or emit a program that accounts for the possibility that it is null (in a context where that would be well-defined).</p>

<p>Similarly, the compiler cannot assume the pointer never changes value. (nor can it assume the pointer points to a valid object, although I'm having trouble imagining a case where that would matter in a well-defined context)</p>

<p>On the other hand, assuming that references are implemented as pointers, the compiler <em>is</em> still allowed to assume it is non-null, never changes where it points, and points to a valid object.</p>
",11
31263134,31262942,58,"<p>References have stronger guarantees than pointers, so the compiler can optimize more aggressively. I've recently seen GCC inline multiple nested calls through function references perfectly, but not a single one through function pointers (because it couldn't prove that the pointer was always pointing at the same function).</p>

<p>If the reference ends up stored somewhere, it typically takes the same space as a pointer. That is not to say, again, that it will be used like a pointer : the compiler may well cut through it if it knows which object the reference was bound to.</p>
",10
31264684,31262942,63,"<p>Assume reference as a pointer that:</p>

<ol>
<li>Can't be NULL </li>
<li>Once initialized, can't be re-pointed to other object</li>
<li><p>Any attempt to use it will implicitly dereference it:</p>

<pre><code>int a = 5;
int &amp;ra = a;
int *pa = &amp;a;

ra = 6;

(*pa) = 6;
</code></pre></li>
</ol>

<p>here as it looks in disassembly:</p>

<pre><code>    int a = 5;
00ED534E  mov         dword ptr [a],5  
    int &amp;ra = a;
00ED5355  lea         eax,[a]  
00ED5358  mov         dword ptr [ra],eax  
    int *pa = &amp;a;
00ED535B  lea         eax,[a]  
00ED535E  mov         dword ptr [pa],eax  

    ra = 6;
00ED5361  mov         eax,dword ptr [ra]  
00ED5364  mov         dword ptr [eax],6  

    (*pa) = 6;
00ED536A  mov         eax,dword ptr [pa]  
00ED536D  mov         dword ptr [eax],6  
</code></pre>

<p>the assigning to the reference is the same thing from the compiler perspective as the assigning to a dereferenced pointer. There are no difference between them as you can see (we are not talking about compiler optimization right now)
However as mentioned above, references can't be null and have stronger guarantees of what they contains. </p>

<p>As for me, I prefer using references as long as I don't need <code>nullptr</code> as a valid value, values that should be repointed or values of different types to be passed into (e.g. pointer to interface type).</p>
",7
31275223,31262942,9,"<p>There used to be efficiency advantages because references are easier for the compiler to optimize.  However, modern compilers have gotten so good at it that there is no longer any advantage.</p>

<p>One <strong>huge</strong> advantage references have over pointers is that a reference can refer to a value in a register, while pointers can only point at blocks of memory.  Take the address of something which would have been in a register, and you would force the compiler to put that value into a normal memory location instead.  This can create tremendous benefits in tight loops.</p>

<p>However, modern compilers are so good that they now recognize a pointer that <em>could have been</em> a reference for all intents and purposes, and treat it exactly the same as if it were a reference.  This can cause rather intriguing results in a debugger, where you can have a statement such as <code>int* p = &amp;x</code>, ask the debugger to print the value of <code>p</code>, only to have it say something along the lines of ""p cannot be printed"" because <code>x</code> was actually in a register, and the compiler was treating <code>*p</code> as a reference to <code>x</code>!  In this case, there literally is no value for <code>p</code></p>

<p>(However, if you tried to do pointer arithmetic on <code>p</code>, you would then force the compiler to no longer optimize the pointer to act like a reference does, and everything would slow down)</p>
",0
31279475,31262942,10,"<p>References differ from pointers in that there are things you cannot do to a reference and have it be defined behavior.</p>

<p>You cannot take the address of a reference, but only what is referred to.  You cannot modify a reference once it is created.</p>

<p>A <code>T&amp;</code> and a <code>T*const</code> (note that <code>const</code> applies to the pointer, not the pointed-to, there) are relatively similar.  Taking the address of an actual <code>const</code> value and modifying it is undefined behavior, as is modifying (any storage that it uses directly) a reference.</p>

<p>Now, in practice, you can get a the storage of a reference:</p>

<pre><code>struct foo {
  int&amp; x;
};
</code></pre>

<p><code>sizeof(foo)</code> will almost certainly equal <code>sizeof(int*)</code>.  But the compiler is free to neglect the possibility that someone directly accessing the bytes of <code>foo</code> could actually change the value referred to.  This permits the compiler to read the reference ""pointer"" implementation once, and then never read it again.  If we had <code>struct foo{ int* x; }</code> the compiler would have to prove each time it did a <code>*f.x</code> that the pointer value had not changed.</p>

<p>If you had <code>struct foo{ int*const x; }</code> is again starts behaving reference-like in its immutability (modifying something that was declared <code>const</code> is UB).</p>

<hr>

<p>A trick that I'm not aware of any compiler writers using is to compress reference-capture in a lambda.</p>

<p>If you have a lambda that captures data by reference, instead of capturing each value via a pointer, it could capture only the stack frame pointer.  The offsets to each local variable are compile-time constants off the stack frame pointer.</p>

<p>The exception is references captured by reference, which under a defect report to C++ must remain valid even if the reference variable goes out of scope.  So those have to be captured by pseudo-pointer.</p>

<p>For a concrete example (if a toy one):</p>

<pre><code>void part( std::vector&lt;int&gt;&amp; v, int left, int right ) {
  std::function&lt;bool(int)&gt; op = [&amp;](int y){return y&lt;left &amp;&amp; y&gt;right;};
  std::partition( begin(v), end(v), op );
}
</code></pre>

<p>the lambda above could capture only the stack frame pointer, and know where <code>left</code> and <code>right</code> are relative to it, reducing it size, instead of capturing two <code>int</code>s by (basically pointer) reference.</p>

<p>Here we have references implied by <code>[&amp;]</code> whose existence is eliminated easier than if they where pointers captured by value:</p>

<pre><code>void part( std::vector&lt;int&gt;&amp; v, int left, int right ) {
  int* pleft=&amp;left;
  int* pright=&amp;right;
  std::function&lt;bool(int)&gt; op = [=](int y){return y&lt;*pleft &amp;&amp; y&gt;*pright;};
  std::partition( begin(v), end(v), op );
}
</code></pre>

<hr>

<p>There are a few other differences between references and pointers.</p>

<p>A reference can extend the lifetime of a temporary.</p>

<p>This is used heavily in <code>for(:)</code> loops.  Both the definition of the <code>for(:)</code> loop relies on reference lifetime extension to avoid needless copies, and users of <code>for(:)</code> loops can use <code>auto&amp;&amp;</code> to automatically deduce the lightest weight way to wrap the iterated objects.</p>

<pre><code>struct big { int data[1&lt;&lt;10]; };

std::array&lt;big, 100&gt; arr;

arr get_arr();

for (auto&amp;&amp; b : get_arr()) {
}
</code></pre>

<p>here reference lifetime extension carefully prevents needless copies from ever occuring.  If we change <code>make_arr</code> to return a <code>arr const&amp;</code> it continues to work without any copies.  If we change <code>get_arr</code> to return a container that returns <code>big</code> elements by-value (say, an input iterator range), again no needless copies are done.</p>

<p>This is in a sense syntactic sugar, but it allows the same construct to be optimal in many cases without having to micro-optimize based on how things are returned or iterated over.</p>

<hr>

<p>Similarly, forwarding references allow data to be treated as a const, non-const, lvalue or rvalue intelligently.  Temporaries are marked as temporaries, data that users have no further need for is marked as temporary, data that will persist is marked as being an lvalue reference.</p>

<p>The advantage references have over non-references here is that you can form a rvalue reference to a temporary, and you cannot form a pointer to that temporary without passing it through an rvalue reference-to-lvalue reference conversion.</p>
",0
31283235,31262942,1,"<p><strong>8.3.2 References [dcl.ref]</strong></p>

<blockquote>
  <p>A reference can be thought of as a name of an object</p>
</blockquote>

<p>which is different from <strong>pointers</strong> which is a variable (unlike reference) that holds the address of a memory location of an Object<sup>**</sup>. The type of this variable is pointer to Object.</p>

<p>Internally Reference may be implemented as pointer, but standard never guaranteed so.</p>

<p>So to answer your question: C++Reference are not syntactic sugar to pointers. And whether it provides any speedup has already been answered in depth.</p>

<p><sup>****** Object here it means any instance that has a memory address. Even pointers are Objects and so are functions (and thus we have nested pointers and function pointers). In similar sense, we do not have pointers to reference as they are not instantiated. </sup> </p>
",1
31286807,31262942,11,"<p><strong>No</strong></p>

<hr>

<p>References are not just a <em>syntactic</em> difference; they also have different <em>semantics</em>:</p>

<ul>
<li>A reference always aliases an existing object, unlike a pointer which may be <code>nullptr</code> (a sentinel value).</li>
<li>A reference cannot be re-seated, it always points to the same object throughout its lifetime.</li>
<li>A reference can extend the lifetime of an object, see binding to <code>auto const&amp;</code> or <code>auto&amp;&amp;</code>.</li>
</ul>

<p>Thus, at the language level, a reference is an entity of its own. The rest are implementation details.</p>
",2
29219488,29215916,0,"<p>Indeed, multiple excluded numbers could potentially have the same value. You could use some of C++11's new <code>random</code> features to ensure all of the numbers are different. Here is a possible solution, using <code>std::shuffle</code>; this could likely be optimized, but there is no reason to do so unless the runtime is too long for your needs:</p>

<pre><code>#include &lt;iostream&gt;  // std::cout
#include &lt;algorithm&gt; // std::shuffle
#include &lt;vector&gt;    // std::vector
#include &lt;numeric&gt;   // std::iota
#include &lt;random&gt;

std::default_random_engine rng{std::random_device{}()};

int main()
{
    // Our initial set [0-5843]
    std::vector&lt;int&gt; vec(5844);
    std::iota(vec.begin(), vec.end(), 0);

    // Take a random subset of 854 elements
    const int exclude{854};
    std::shuffle(vec.begin(), vec.end(), rng);
    std::vector&lt;int&gt; excluded(vec.end()-exclude, vec.end());
    vec.erase(vec.end()-exclude, vec.end());

    std::cout &lt;&lt; ""Do work for "" &lt;&lt; vec.size() &lt;&lt; "" elements.\n"";
    for (int i : vec) {
        // Do work...
    }

    std::cout &lt;&lt; ""Excluded "" &lt;&lt; excluded.size() &lt;&lt; "" elements.\n"";

    return 0;
}
</code></pre>

<p>Note that this changes the order of iteration. For example, when doing work, <code>i = 100</code> may be executed before <code>i = 10</code>.</p>

<p><a href=""http://rextester.com/UNV41074"" rel=""nofollow"">Live Demo</a></p>
",4
29222288,29215916,0,"<p>We know how many valid numbers there are, so first pick a number in that range:</p>

<pre><code>static std::mt19937 gen(std::random_device{}());
std::uniform_int_distribution&lt;&gt; dis(nLow, nHigh-ignored.size());
unsigned value = dis(gen);
</code></pre>

<p>Then, for each invalid number less than or equal to the one we picked, we have to increase the value by one.  Luckily, this is a trivial operation.  (Note: the <code>ignored</code> values have to be sorted in increasing order)</p>

<pre><code>auto it = std::upper_bound(ignored.begin(), ignored.end(), value);
value += it-ignored.begin();
</code></pre>

<p>Finally, <em>that</em> operation may have advanced us past a couple more disallowed numbers, so we'll advance past those until we're good.  This might advance us past others, so this is the tricky part logically, even if the code is simple.  The <code>it!=ignored.end()</code> is a sanity check, that should be impossible.</p>

<pre><code>while(it != ignored.end() &amp;&amp; *it&lt;= value) {
    ++it;
    ++value;
}
</code></pre>

<p>That's it!  You can see it working here: <a href=""http://coliru.stacked-crooked.com/a/28b40f978a90216c"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/28b40f978a90216c</a></p>
",0
25517911,25517664,2,"<p>I wasn't going to weight in on this, but HostileFork's answer (which I +1ed) digs in while missing a couple points - too much to comment on easily, so here I am...</p>

<p>Firstly the question:</p>

<blockquote>
  <p>What is the output of the following code snippet?</p>
</blockquote>

<p>For the code given, the <em>output</em> may be <strong><em>anything or nothing</em></strong>, which is not one of the answers.  Still, the intended answer is obviously 4:</p>

<blockquote>
  <p>Error ¨C ptr references memory that no longer belongs to the program</p>
</blockquote>

<p>That said:</p>

<ul>
<li><p>the memory <em>probably</em> still belongs to the program/process (most C++ implementations don't release memory used to satisfy small memory allocations to the OS until program termination), but it's no longer ""owned"" by the application-level code you've listed, as <code>delete[]</code> returns ownership to the memory allocation library</p></li>
<li><p>the problem is not just what <code>ptr</code> references, but specifically that <code>ptr</code> is being dereferenced while pointing to released memory</p></li>
</ul>

<p>Summarily, the question is poorly worded, but the intent behind it is fairly clear.</p>

<p>I won't repeat the explanation of undefined behaviour that addresses your ""Because I'm not necessarily getting an error."" observation, as HostileFork's answer does that well.</p>

<p>Still, computer programs don't tend to go out of their way to do weird things arbitrarily, even when the compiler's not obliged by the C++ Standard to provide any particular behaviour, and in this particular case the observation I made above that the memory's likely still owned by the program, combined with noticing that the value of <code>*ptr</code> before <code>delete[] list;</code> executed must have been <code>1</code>, leads to the question...</p>

<h2>Why did you see -17891602 and not 1?</h2>

<p>On a hunch I converted it to unsigned 32 bit hexadecimal (as one does): the value's then <code>FEEEFEEE</code>.  Wikipedia says of this <a href=""http://en.wikipedia.org/wiki/Magic_number_%28programming%29"" rel=""nofollow"">""magic number""</a>:</p>

<blockquote>
  <p>Used by Microsoft's debug HeapFree() to mark freed heap memory.</p>
</blockquote>

<p>So, Microsoft's <code>delete[]</code> function triggered overwriting of the five <code>int</code> locations with <code>0xFEEEFEEE</code>, intended to make it easier for you - the programmer - to see you had undefined behaviour.  As overwriting the memory takes time while the programm is running, and is only helpful if the program's actually broken anyway which you'll hopefully realise and fix before making and distributing a ""release"" build, this <code>FEEEFEEE</code>-fill behaviour is only done in MS's ""debug"" builds.  Other compilers or malloc libraries often offer similar behaviour enabled by compiler flags / environment variables etc..</p>
",1
25517738,25517664,3,"<p>The <em>output</em> could be anything (including <code>-17891602</code>) since you're invoking undefined behaviour by dereferencing a pointer that has had its backing memory deallocated.</p>

<p>The relevant part of the standard is <code>C++11 3.7.4.2 Deallocation functions /4</code> (my bold):</p>

<blockquote>
  <p>If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value, the deallocation function shall deallocate the storage referenced by the pointer, <strong>rendering invalid all pointers referring to any part of the deallocated storage. The effect of using an invalid pointer value (including passing it to a deallocation function) is undefined.</strong></p>
</blockquote>

<p>On my system, the following program (modelled on your snippet):</p>

<pre><code>#include &lt;iostream&gt;

int main (void) {
    int *list = new int[5];
    int *ptr;
    for (int i = 0; i &lt; 5; i ++)
        list [ i] = i+ 1;
    ptr = list;
    delete [ ] list;
    std::cout &lt;&lt; *ptr;
    return 0;
}
</code></pre>

<p>outputs <code>1</code> but it is by no means required to.</p>

<p>The correct answer to your question is most likely 4, though that's not technically the <em>output</em> (you may not see the ""error"" string sent to the output stream) - it is, however, the <em>result</em> of executing the code.</p>
",0
25517762,25517664,1,"<p>The person writing that question either doesn't understand or wrote it poorly.  It could be fixed by inserting one word on each line:</p>

<ol>
<li><em>Definitely</em> 1</li>
<li><em>Definitely</em> the Address of list</li>
<li><em>Definitely</em> the Address of ptr</li>
<li><em>Programmer</em> Error ¨C ptr references memory that no longer belongs to the program</li>
</ol>

<p>The issue touches upon something called ""Undefined Behavior"", which you can read about here:</p>

<p><a href=""https://softwareengineering.stackexchange.com/questions/99692/philosophy-behind-undefined-behavior"">https://softwareengineering.stackexchange.com/questions/99692/philosophy-behind-undefined-behavior</a></p>

<p>That lays out some of the reasons why--for instance--the compiler has not given you a ""compile-time error"" or ""run-time exception"".  It is a mistake that in the general case may be impossible to detect a priori, and that checking at run-time would add undesirable overhead.</p>
",1
22495075,22495060,6,"<p>You <strong>declare</strong> cootieComplete to take 1 int and you <strong>define</strong> it to take 6 then you call the version taking 1.</p>

<pre><code>// Declaration
bool cootieComplete(int);

...

while (!cootieComplete(apply))

....

// Definition
bool cootieComplete(int numBody,int numHead,int numAntenna,int numWings,int numTongue,int numLeg)
</code></pre>

<p>Since you called the version taking 1 int as parameter, compiler is looking for the definition of <code>cootieComplete(int)</code> but can't find it so throw the <code>undefined reference</code> error. </p>

<p>They need to match. So define it like so:</p>

<pre><code>bool cootieComplete(int, int, int, int, int, int);
</code></pre>
",0
22495094,22495060,1,"<p>Eric is correct, if you need them to match. Make them look like</p>

<pre><code>bool cootieComplete(int, int, int, int, int, int);

bool cootieComplete(int numBody,int numHead,int numAntenna,int numWings,int numTongue,int numLeg){
  // Code here
}
</code></pre>

<p>That should fix your error</p>
",5
22110647,22110417,5,"<p>Usually streams are passed by non-const references.  This is because most useful operations, like insertion (write) and extraction (read) do actually modify the stream state.  With a const reference all you can really do is inspect the existing state, such as the error flags.</p>
",0
23063709,23063650,8,"<p>Because is not an actual assignment since you declare u at the same time. Thus, the constructor is called instead of the assignment operator. And this is more efficient because if it wasn't for this feature there would have been the redundancy of calling first a default constructor and then the assignment operator. This would have evoked the creation of unwanted copies and thus would had deteriorate the performance of the C++ model significantly. </p>
",0
23063769,23063650,3,"<p>Because that's the declaration and initialization of a variable, not the assigment of a value to an existing variable. In the context of a variable declaration, = is just syntactic sugar for passing a parameter to the ctor.</p>
",2
22110745,22110678,2,"<p>Consider this</p>

<pre><code>void foo(int&amp; a) {
  a = 1;
}

int n = 0;
foo(n);
</code></pre>

<p>In order <code>foo</code> to work properly it shall receive address of passed variable. 
So essentially reference is a pointer to some memory location but with special treatment. </p>
",1
22111031,22110678,3,"<p>I was doing some research on my question, I got answer but it surprised me.</p>

<p>alias.cpp</p>

<pre><code>int main()
{
        int a=5;
        int &amp;x=a;
        int y=a+x;
}
</code></pre>

<p>A part of assembly code generated by using g++ -S alias.cpp</p>

<p>alisa.s</p>

<pre><code>subl    $16, %esp
movl    $5, -12(%ebp)        //moving 5 to a
leal    -12(%ebp), %eax      // loading address of a to eax register
movl    %eax, -4(%ebp)       // moving address of a to -4(%ebp) this for x
movl    -4(%ebp), %eax       // moving the value of x that is address of a to eax
movl    (%eax), %edx         // moving the value of the address pointed by eax to edx
movl    -12(%ebp), %eax      // moving the value of a to eax
addl    %edx, %eax           // adding edx and eax
</code></pre>

<p>Another file alias2.cpp, here i am using pointer instead of alias.</p>

<pre><code>int main()
{
        int a=5;
        int *x=&amp;a;
        int y=a+*x;
}
</code></pre>

<p>the corresponding assembly code, alias2.s</p>

<pre><code>subl    $16, %esp
movl    $5, -12(%ebp)
leal    -12(%ebp), %eax
movl    %eax, -4(%ebp)
movl    -4(%ebp), %eax
movl    (%eax), %edx
movl    -12(%ebp), %eax
addl    %edx, %eax
</code></pre>

<p>As we can see the both assembly files generated by two different code blocks are same. that means internally compiler is using the reference variable same as pointer variable, the only difference is the way of managing/writing the code.</p>
",2
22116013,22110678,0,"<p>A reference is nothing more or less than a pointer in disguise. It is basically a C++ way of omitting adding the dereference operators when dereferencing a pointer.</p>

<p>From a language lawyer perspective, references may not be the same a pointers, but for all practical purposes, they are. Take for instance the assertion that references cannot be null, this is one of the arguments that people have used to advocate the use of references over pointers. However, while the language definition may disallow this, it is very easy to produce a null reference:</p>

<pre><code>int&amp; toReference(int* a) {
    return *a;
}
</code></pre>

<p>What happens when you pass a null pointer to <code>toReference()</code>? It will return a null reference. It won't technically dereference the pointer, because <code>toReference()</code> has no interest in the value behind the pointer. To avoid returning a null reference, the compiler would have to specifically insert code to check whether the pointer is null, and abort the program, which would be a waste of CPU time. You get the segfault the moment you try to access the data behind the returned reference, no sooner.</p>

<hr>

<p>Now, should you use references in your code?<br>
As I said above references are pointers in disguise, and that disguise can be harmful. For instance, if you see a call like the following in C, you can be certain that <code>bar</code> is not modified:</p>

<pre><code>foo(bar);
</code></pre>

<p>In C++ you cannot be certain until you have checked whether the function definition contains a <code>&amp;</code>. This is bad. Even worse: imagine you are using a function declared like this:</p>

<pre><code>void foo(int a);
</code></pre>

<p>Now, if someone decided, he needed <code>a</code> to be an in/out parameter, and changed the definition into</p>

<pre><code>void foo(int&amp; a);
</code></pre>

<p>there would be absolutely no warning that the call <code>foo(bar)</code> would now silently modify the value of <code>bar</code>, i. e. the developer of <code>foo()</code> can break essential assumptions in unrelated places. The only way to avoid such nasty surprises, is to ban the use of non-const references from function arguments. You may use const-references when you want to stick to pass by value semantics and want to avoid the overhead of copying, but use pointers if you intent to modify.</p>
",0
25544809,25544742,3,"<p>You should use <code>vector::erase()</code> instead.</p>

<pre><code>    for(it = observers.begin(); it != observers.end(); it++)
    {
        if(it-&gt;second == obsIfP)
        {
            observers.erase(it);
            break;
        }
    }
</code></pre>
",2
25546516,25544742,0,"<p>There's a few issues with your current code.</p>

<p>std::remove will find and <em>move</em> elements equal to the given value to the end of the container. It then returns the iterator pointing to the end of the non-removed range in the vector. To have them completely removed would require vector.erase with the iterator returned from the remove algorithm.</p>

<p><strong>The erase-remove idiom:</strong></p>

<pre><code>v.erase( remove( begin(v), end(v), value ), end(v) )
</code></pre>

<p>Note, your code gives a string as value and will not compile, since elements in the vector are pair&lt; string, Observer* > and the algorithm can't compare between the two.</p>

<p><strong>Erasing while iterating over the same range is dangerous</strong>, since you may invalidate the iterators of the first loop.</p>

<p><strong>Using algorithms with predicates:</strong></p>

<p>Depending on the size of the vector, it may just be simpler (and even faster) to generate a new vector.</p>

<pre><code>typedef pair&lt;string, Observer*&gt; RegPair;
vector&lt;RegPair&gt; new_observers;
new_observers.reserve( observers.size() ); // To avoid resizing during copy.

remove_copy_if( begin(observers), end(obervers), std::back_inserter(new_observers),
    [obsIfP]( const RegPair&amp; p ) -&gt; bool
        { return p.second == obsIfP; } );

observers = std::move(new_observers);

// --- OR THIS

observers.erase( remove_if( begin(observers), end(observers),
        [obsIfP]( const RegPair&amp; p ) -&gt; bool
            { return p.second == obsIfP; } ),
        end(observers) );
</code></pre>

<p>Removing an element in the middle of a vector will cause all the following elements to be moved back one index, which is essentially just a copy anyway. If more than one element has the observer pointer, your initial code would have to move these elements more than once, while this suggestion always has a worst case of O(N), where the elementary operation is a copy of the pair element. If better performance than O(N) is required, you'll have to arrange your observers with std::map&lt; string, Observer* > or perhaps boost::bimap which lets you use both pair values as keys.</p>

<p>The difference between remove_if and copy_remove_if would be the preserving of order. remove_if may swap elements and place them elsewhere in order to get the removed element to the end-range. The copy_remove_if will simply not copy it over to the new container, so order is preserved.</p>

<p>If you're not using c++11, the lambda wont work and you'll have to hand code the loop yourself.</p>
",0
21044821,21044719,13,"<p>C++11 smart pointers don't offer automatic conversions to and from raw pointer types (for safety reasons). Use <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr/get"" rel=""noreferrer""><code>get()</code></a>:</p>

<pre><code>choice = FirstPhase(myCharacter.get(), myEnemy.get(), myInventory.get(), myBoss.get());
</code></pre>

<p>Better still, change your function to accept references instead of pointers (or does it correctly handle a null value passed in?) and just dereference the pointers at call site.</p>
",0
21044842,21044719,1,"<p>You should either use <code>get()</code> to extract the underlying pointer or change the prototype to use smart pointers in functions calls:</p>

<pre><code>choice = FirstPhase(myCharacter.get(), myEnemy.get(), myInventory.get(), myBoss.get());
</code></pre>
",0
26415088,26415054,2,"<p><code>Node</code> is declared within <code>mySpace::CDAL&lt;T&gt;</code> so its name has to be qualified in the definition:</p>

<pre><code>template &lt;typename T&gt;
struct typename mySpace::CDAL&lt;T&gt;::Node* mySpace::CDAL&lt;T&gt;::tailNode()
{...}
</code></pre>

<p><code>struct</code> also isn't needed. Taking it out won't make a difference.</p>
",0
22522380,22522319,2,"<p>In both cases you create a local variable in <code>createBoVector()</code>. <code>reusable</code> is then copy-constructed from that local object, before said local goes out of scope and is destroyed.</p>

<p>The only difference is that one time you make the local variable explicit (<code>boVector bv</code>), one time you don't. All that matters here is the return type of <code>boVector</code>.</p>

<p>It may be that compilers can optimize your simple example to avoid the copy, e.g. by inlining <code>createBoVector()</code>, but you can't really influence that or rely on that. And, unless your objects are prohibitively expensive to copy (unlikely), you shouldn't worry about it either.</p>
",0
22524428,22522319,0,"<blockquote>
  <p>What are the total number of copies in each case? </p>
</blockquote>

<p>If you implement the <em>copy constructor</em> (and <em>copy assignment</em> operator) in your class, you can count the copies for yourself.:</p>

<pre><code>int copies = 0;

class boVector()
{
public:
    boVector(const boVector&amp;) { ++copies; }
    boVector&amp; operator=(const boVector &amp;) { ++copies; return *this; }
};

void main() {
  boVector reusable = createBoVector();
  cout &lt;&lt; ""copies: &lt;&lt; copies &lt;&lt; endl;
}
</code></pre>
",0
22469603,22469461,0,"<p>I seem to recall that you can have fopen not lock the file so in theory that would allow different threads to all write to the same file with independent handles. In practice you're going to run into other issues, namely concurrency. Your threads are almost certainly going to step all over each other and scramble the results unless you implement some synchronization. And if you have to do that, why not just use one handle across all the threads?</p>
",0
22469661,22469461,0,"<p>I/O access is not a parallelizable task (it can't be, you simply can't send two or more data addresses over the device bus at the same time) so you'd better implement a queue in which many threads posts their chunks of data and one single consumer actually writes them to disk.</p>
",3
22469791,22469461,3,"<p><code>std::fstream</code> has functionality defined in terms of the C stdio library. I would be surprised if it were actually specified, but the most likely behavior from opening the same file twice is multiple internal buffers bound to the same file descriptor.</p>

<p>The usual way to simultaneously write to multiple points in the same file is POSIX <code>pwrite</code> or <code>writev</code>. This functionality is not wrapped by C stdio, and by extension not by C++ iostreams either. But, having multiple descriptors to the same filesystem file might work too.</p>

<p><strong>Edit:</strong> POSIX <code>open</code> called twice on the same file in Mac OS X produces different file descriptors. So, it might work on your platform, but it's probably not portable.</p>

<p>A definitive answer would require connecting these dots:</p>

<ul>
<li>Where the C++ standard specifies that <code>fstream</code> works like a C (stdio) stream.</li>
<li>Where the C standard defines when a stream is created (<code>fopen</code> is only defined to <em>associate</em> a stream with a newly-opened file).</li>
<li>Where the POSIX standard defines its requirements for C streams.</li>
<li>Where POSIX defines the case of opening the same file twice.</li>
</ul>

<p>This is a bit more research than I'm up for at the moment, but I'm sure someone out there has done the legwork.</p>
",1
22469914,22469461,1,"<p>I've written some high speed multi-threaded data capture utilities, but the output went to separate files on separate hard drives, and then were post-processed.</p>
",0
21187392,21187380,5,"<p>Yes, that's perfectly possible; it's not different from calling a member function of a returned object, which is quite normal:</p>

<pre><code>std::ostringstream s;
s &lt;&lt; ""file"" &lt;&lt; i;
std::ifstream f(s.str().c_str());  //notice calls here
</code></pre>
",0
21187700,21187380,1,"<p>Please don't use the <code>typedef struct {...} name;</code> idiom in C++.  This is a holdover from C and has no value in C++.  Just use the standard technique: <code>struct name {...};</code></p>

<p>There is nothing <em>technically</em> wrong with doing what you're doing.  Just be careful you don't return a reference to a local, or anything like that.  You're not here.</p>

<p>In fact, you could have a method that does something with the parameters and returns a reference to the object, and then chain together method calls, like this:</p>

<pre><code>struct functionReturn
{
  functionReturn&amp; doSomething() { return * this; }
  functionReturn&amp; doSomethingElse() { return * this; }
};

int main()
{
  functionReturn fr;
  fr.doSomething().doSomethingElse();
}
</code></pre>

<p>This is also valid.  It's called <a href=""http://en.wikipedia.org/wiki/Method_chaining"" rel=""nofollow"">method chaining</a>.  The question is not weather it's valid, but if its semantically clear and maintainable.  Some people consider constructs like this to be elegant and concise.  Others consider it to be an abomination.  Count me in the latter group.  Decide for yourself.</p>
",1
23589123,23589092,5,"<p>No freestanding <code>:</code> are not allowed in <code>C</code> and <code>C++</code>.</p>

<p><code>signals</code> is defined as <code>public</code>, so </p>

<pre><code>signals:
    void valueChanged(int newValue);
</code></pre>

<p>would be pre-processed to</p>

<pre><code>public:
    void valueChanged(int newValue);
</code></pre>

<p>So there is not free colon.</p>

<p>Now slots is defined as nothing so</p>

<pre><code>public slots:
    void setValue(int value);
</code></pre>

<p>would be replaced with (after comments are replaced with whitespace.</p>

<pre><code>public :
    void setValue(int value);
</code></pre>
",0
25687433,25687096,7,"

<p>I guess the author of that book thought that the signature <code>int*</code> would carry out to all of the comma-separate variable declarations, making <code>r</code> a reference to pointer. Indeed <a href=""http://rextester.com/LPQUOF85501"" rel=""nofollow"">the code does not compile</a> because this is not true. <code>ip</code> is declared as a pointer to an <code>int</code> and <code>r</code> is only declared as a reference to an <code>int</code>.</p>

<p>The compiler interprets</p>

<pre class=""lang-c++ prettyprint-override""><code>int * ip, &amp;r = ip;
</code></pre>

<p>equivalently to</p>

<pre class=""lang-c++ prettyprint-override""><code>int * ip;
int &amp; r = ip; // won't compile
</code></pre>

<p>You need an extra <code>*</code> to declare it as a reference to pointer type:</p>

<pre class=""lang-c++ prettyprint-override""><code>int *op, *&amp;r = ip;
</code></pre>

<p>You can also use a <code>typedef</code>:</p>

<pre class=""lang-c++ prettyprint-override""><code>typedef int* IntPtr;
IntPtr op, &amp;r = ip;
</code></pre>
",0
25687612,25687096,6,"<p>You're very right to be confused.</p>

<p>I found <a href=""http://ptgmedia.pearsoncmg.com/images/9780321714114/errata/9780321714114_errata_10-31-12.html"">the errata page</a>, and it states</p>

<blockquote>
  <p>Page 59: Exercise 2.25 (a) should be int* ip, i, &amp;r = i;</p>
</blockquote>

<p>which makes a whole lot more sense.</p>

<p>(This should probably be a comment, but it's easier to read here...)</p>
",0
22421311,22421144,0,"<p>I know that you likely need to implement yourself reverse, but you can use std implementation for tests:</p>

<pre><code>std::string s(""abc"");
std::reverse(s.begin(), s.end());
</code></pre>
",0
22421210,22421144,1,"<pre><code>char *str=""saurabh"";
</code></pre>

<p>You cannot manipulate <code>""saurabh""</code> because it is literal.</p>

<p>For this you should either copy it to <code>char[]</code>, </p>

<p>Example,</p>

<pre><code>char arr[20];
char *ptr = ""Data"";

strcpy(arr,ptr);
</code></pre>
",0
22520735,22520695,3,"<p>Every name before its usage shall be declared.</p>

<pre><code>class c_a
{
public:
    void do_stuff( class c_b *b);
};

class c_b
{
public:
    void call()
    {
        c_a a;
        a.do_stuff(this);
    }

    void move_x()
    {
        cout &lt;&lt; ""test"";
    }
};

void c_a::do_stuff( c_b *b)
{
    b-&gt;move_x();
}

int main()
{
    c_b b;
    b.call();
}
</code></pre>
",0
28239683,28239659,6,"<p>Because the type returned by <code>length()</code> call is size_t which is usually a <code>typedef</code> of <code>unsigned int</code>. That's why it is signed/unsigned mismatch between signed integer which is <code>int</code> and <code>size_t</code> type which is the value returned by <code>std::string::length()</code>.</p>

<p>To make it correct consider to change type of your <code>i</code> variable to <code>size_t</code> or any other unsigned type, but it is better to make types identical (<code>size_t</code> and <code>size_t</code>):</p>

<pre><code>for (size_t i = 0; i &lt; THE_WORD.length(); ++i)
</code></pre>
",1
21178181,21178054,3,"<p>You only need four bits to store the numbers 1 through 10:</p>

<pre><code>0001 = 1
0010 = 2
0011 = 3
0100 = 4
0101 = 5
0110 = 6
0111 = 7
1000 = 8
1001 = 9
1010 = 10
</code></pre>

<p>There's background material on this encoding at <a href=""https://en.wikipedia.org/wiki/Binary_number"" rel=""nofollow"">https://en.wikipedia.org/wiki/Binary_number</a>.</p>
",6
21178211,21178054,2,"<pre><code>0 : 0000000
1 : 0000001
2 : 0000010
3 : 0000011
4 : 0000100
5 : 0000101
6 : 0000110
7 : 0000111
8 : 0001000
9 : 0001001
10: 0001010
</code></pre>

<p>Unless I misunderstood your question, that should work.</p>
",0
27683017,27682931,0,"<p>GetPos is a function that you call on an <em>object</em>, not a <em>class</em>.</p>

<pre><code>NewClass newClassObject;
Position p = newClassObject.GetPos();
SomeFunction(p);
</code></pre>
",0
27683019,27682931,0,"<p>I figured it out. 
I had to change the function to return by reference</p>

<pre><code>class NewClass{
const Position&amp; GetPos();
private:
Positon classPos;
};
const Position&amp; NewClass::GetPos() { return classPos;}
</code></pre>
",6
27683021,27682931,0,"<p>(I am assuming <code>Position</code> is a class where the default copy constructor will not suffice, i.e., a shallow copy will lead to undefined behaviour. Am also overlooking the obvious typos as you indicated in the comments that you are aware of them.)</p>

<p>The assignment operator overload does not get invoked in either of your examples. Passing an object to a function by value invokes either the move or copy constructor, assuming the copy wasn't elided out. The second example</p>

<pre><code>Position new_pos = some_new_class.GetPos();
</code></pre>

<p>is an example of <a href=""http://en.cppreference.com/w/cpp/language/copy_initialization"" rel=""nofollow"">copy initialization</a>. This statement doesn't invoke <code>operator=</code> either. Inspite the of the syntax, what it actually uses, since the rhs has type <code>Position</code>, is the copy constructor. In general, copy initialization will only consider non-explicit constructors and user-defined conversions.</p>
",0
28469550,28469524,0,"<p>How can it work without allocating memory for the pointer <code>pass</code>?</p>
",0
28469574,28469524,0,"<p>You haven't initialized <code>pass</code>. So, it is undefined behaviour to call methods with uninitialized pointer.</p>

<p>You need something like:</p>

<p><code>pass = new Grid();</code></p>
",1
28470105,28469524,1,"<p>You have declared a pointer named <code>pass</code> to an object but have not allocated any memory for it. The pointer <code>pass</code> can contain any random value, which may or may not be a valid address.
Accessing memory from unallocated locations is <code>Undefined behavior</code>.</p>

<p>So you need to allocate memory using <code>new</code>, like this : </p>

<pre><code>Grid* pass = new Grid;
</code></pre>

<p>This allocates memory for the object in the free store so that you can access the data members. Remember to free the memory once you're done.</p>

<p>You can also store the object on contiguous memory like this : </p>

<pre><code>Grid gr_obj;
Grid* pass = &amp;gr_obj;
</code></pre>
",0
22423033,22423010,2,"<p><strong>Because you didnt defined that varible.</strong></p>

<p>Please try to define that in the <strong>right scope</strong>, and you will not get the IDE's error. :)</p>
",0
22423059,22423010,1,"<p>You did not define the vector v, add <code>vector&lt;int&gt; v;</code> to your code</p>
",0
22429806,22429754,1,"<p>Your <code>q</code> and <code>invalid</code> selection paths only print to the console, they don't exit the program.  You would need a <code>return 0;</code> in each.</p>

<p>A better way, though, is to use a boolean that is set if you want to quit or the selection is invalid.</p>

<p>Here is one way to go about it.</p>

<p>Declare the boolean as true</p>

<pre><code>bool validPlanet = true;
</code></pre>

<p>In the <code>quit</code> and <code>invalid</code> paths put this statement</p>

<pre><code>validPlanet = false;
</code></pre>

<p>Then wrap your weight calculations in an <code>if</code> condition like so</p>

<pre><code>if( validPlanet)
{
    newWeight = weightEarth * surfaceGravity;

    distanceFromPlanets = abs(distanceFromSun - distanceFromEarthToSun);

    travelTime = travelDistance / rate;

    cout &lt;&lt; ""Your weight on "" &lt;&lt; planet &lt;&lt; "" :  "" &lt;&lt; newWeight &lt;&lt; endl;
    cout &lt;&lt; ""Your travel time to "" &lt;&lt; planet &lt;&lt; "":\n"";

}
</code></pre>

<p>I'm assuming you have a <code>return 0;</code> immediately after this, otherwise you'll need to use the <code>validPlanet</code> to assure those statements get called appropriately.</p>
",3
22429949,22429754,0,"<p>A simple way is to put <code>getch()</code> after the statement followed by <code>exit(0);</code></p>

<p>The last else if part then becomes:</p>

<pre><code>  else if (selection == 'q')
    {
        cout &lt;&lt; ""You have chosen to quit the program. Thank you for using the program!\n"";
        getch();  //stops the current screen until a key stroke
        exit(0);  //exits the program. (zero value in the argument tells that it was a safe exit)
    }
</code></pre>

<p>OR, if you don't want the user to give a key stroke before exiting, you may use the <code>delay(time)</code> function which stops screen for a particular time.</p>

<p>Then the code becomes:</p>

<pre><code>  else if (selection == 'q')
    {
        cout &lt;&lt; ""You have chosen to quit the program. Thank you for using the program!\n"";
        delay(1000)  //stops the current screen for 1 second. (time in miliseconds, 1000ms = 1 second)
        exit(0);  //exits the program. (zero value in the argument tells that it was a safe exit)
    }
</code></pre>
",2
22430242,22429754,0,"<p><strong>Your code reformatted according to your need</strong> <em>(since we haven't gone over the usage of booleans in if statements. At the moment I'm trying to re-structure my if and if else statements to fix the problem, but I can't seem to get the correct combination.)</em></p>
<pre><code>    double weightEarth = 0; //made these variables global so that display_result()can access it.
    double rate = 0;
    double distanceFromSun = 0;
    double surfaceGravity = 0;
    double newWeight = 0;
    double travelTime = 0;
    double travelDistance = 0;
    double distanceFromPlanets = 0;
    double distanceFromEarthToSun = 93.0;

    void display_result()
    {
           newWeight = weightEarth * surfaceGravity;

           distanceFromPlanets = abs(distanceFromSun - distanceFromEarthToSun);

           travelTime = travelDistance / rate;

           cout &lt;&lt; &quot;Your weight on &quot; &lt;&lt; planet &lt;&lt; &quot; :  &quot; &lt;&lt; newWeight &lt;&lt; endl;
           cout &lt;&lt; &quot;Your travel time to &quot; &lt;&lt; planet &lt;&lt; &quot;:\n&quot;;
    }

    int main()
    {
    string planet;
    char selection;
    
    cout &lt;&lt; &quot;INTERPLANETARY TRAVEL MENU\n&quot;
        &lt;&lt; &quot;----------------------------\n&quot;
        &lt;&lt; &quot;a) Mercury\n&quot;
        &lt;&lt; &quot;b) Venus\n&quot;
        &lt;&lt; &quot;c) Earth\n&quot;
        &lt;&lt; &quot;d) Mars\n&quot;
        &lt;&lt; &quot;e) Jupiter\n&quot;
        &lt;&lt; &quot;f) Saturn\n&quot;
        &lt;&lt; &quot;g) Uranus\n&quot;
        &lt;&lt; &quot;h) Neptune\n&quot;
        &lt;&lt; &quot;q) Quit\n&quot;
        &lt;&lt; &quot;Select a planet to travel to or q to quit the program :\n&quot;;

    cin &gt;&gt; selection;

    if (selection &lt;= 'h')
    {

        cout &lt;&lt; &quot;Please enter your weight: \n&quot;;
        cin &gt;&gt; weightEarth;

        cout &lt;&lt; &quot;At what speed would you like to travel at?\n&quot;;
        cin &gt;&gt; rate;


        if (selection == 'a')
        {
            planet = &quot;Mercury&quot;;
            surfaceGravity = 0.27;
            distanceFromSun = 36;
        }

        else if (selection == 'b')
        {
            planet = &quot;Venus&quot;;
            surfaceGravity = 0.86;
            distanceFromSun = 67.0;
        }

        else if (selection == 'c')
        {
            planet = &quot;Earth&quot;;
            surfaceGravity = 1.00;
            distanceFromSun = 93.0;
        }

        else if (selection == 'd')
        {
            planet = &quot;Mars&quot;;
            surfaceGravity = 0.37;
            distanceFromSun = 141.0;
        }

        else if (selection == 'e')
        {
            planet = &quot;Jupiter&quot;;
            surfaceGravity = 2.64;
            distanceFromSun = 483.0;
        }

        else if (selection == 'f')
        {
            planet = &quot;Saturn&quot;;
            surfaceGravity = 1.17;
            distanceFromSun = 886.0;
        }

        else if (selection == 'g')
        {
            planet = &quot;Uranus&quot;;
            surfaceGravity = 0.92;
            distanceFromSun = 1782.0;
        }

        else
        {
            planet = &quot;Neptune&quot;;
            surfaceGravity = 1.44;
            distanceFromSun = 2793.0;
        }

        display_result();

    }

    else if (selection == 'q')
    {
        cout &lt;&lt; &quot;You have chosen to quit the program. Thank you for using the program!\n&quot;;
    }

    else
    {
        cout &lt;&lt; &quot;You have entered an invalid selection.\n&quot;;
    }
}
    
</code></pre>
<p>I created a function <code>display_result()</code> and shifted the code which was running on exiting the if-else statements. Now this is being called every time only when you try to calculate the weight and not when you are exiting the program. This solved the problem of program complexity and lengthiness of program.</p>
",0
24600872,24600743,-1,"<p>Here&rsquo;s code to unlink a specified node plus rest of list, on the node&rsquo;s left (prev) side, assuming that there always is a previous node (i.e. a list with header node):</p>

<pre><code>auto unlinked_list_from( Node* p )
    -&gt; Node*
{
    p-&gt;prev-&gt;next = nullptr;
    p-&gt;prev = nullptr;
    return p;
}
</code></pre>

<p>Finding the <em>n</em>&rsquo;th node is a separate problem.</p>

<p>Combining the two, in finding the <em>n</em>&rsquo;th node and unlinking it and the rest of the list, is a higher level problem where you use the two lower level solutions.</p>

<hr>

<p>It&rsquo;s generally <em>not a good idea</em> to user ownership smart-pointers such as <code>std::unique_ptr</code> or <code>std::shared_ptr</code> in the internal pointers of linked list or tree. It&rsquo;s simply not the case that each node owns the previous and next node, in the sense of having responsibility for destruction. This is one situation where raw pointers rule.</p>

<p>But instead, except for learning and for advanced programming, use standard library containers such as <code>std::vector</code>.</p>
",3
22442690,22442548,3,"<p>What did you expect it to do (typos aside)? You have a POD type that does not need any destruction to happen. Try the same thing with something more meaty, say, put a <code>std::string</code> in there, and the destructor will actually do something.</p>

<p>Then, put those experiments aside and if at one place in the next twenty years you actually do need placement new and explicitly called destructors, put some debugging output in the destructor you need and check that it is actually called.</p>
",0
22444034,22442548,1,"<blockquote>
  <p>Deconstructor did NOTHING! (?) Why?</p>
</blockquote>

<p>Because it is empty in this case. What did you expect it to do exactly?</p>
",0
22443063,22442548,3,"<p>There are two sets of ideas that you are dealing with:</p>

<ol>
<li>Construction and destruction of objects</li>
<li>Allocation and deallocation of memory.</li>
</ol>

<p>It's important to understand how those can be properly combined.</p>

<p>Say you have a function:</p>

<pre><code>void f1()
{
   // Construct an object.
   // The constructor gets called.
   K k(10);

   // Do something with the object.

   // Done with the function
   // The object k gets destructed.
   // The destructor gets called.
}
</code></pre>

<p>In this function you are constructing the object on the stack. When you return from the function, the destructor gets called automatically. Memory is allocated and deallocated from the stack automatically for you.</p>

<p>Now, let's look at another function.</p>

<pre><code>void f2()
{
   // Allocate memory for the object.
   // Use that Construct an object .
   // The constructor gets called.
   K* k = new K(10);

   // Do something with the object.

   // Done with the function
   // Delete the object.
   // The destructor gets called.
   // Deallocate the memory.
   delete k;
}
</code></pre>

<p>This line <code>K* k = new K(10);</code> in this function performs two operations -- it allocates memory for the object from heap as well as calls the constructor to construct the object.</p>

<p>The line <code>delete k;</code> also combines two operations. It calls the destructor first and then it deallocates memory from heap. If you didn't have <code>delete k;</code>, the function will leak the memory allocated by <code>new K(10)</code>.</p>

<p>Here, we used the <code>new</code> and <code>delete</code> operators.</p>

<p>Now take look at using the global <code>operator new</code> and <code>operator delete</code> functions.</p>

<pre><code>void f3()
{
   // Allocate memory for the object from the heap.
   void* p = ::operator new(sizeof(K));

   // At this point, an object of type K has not been constructed yet.

   K* k1 = reinterpret_cast&lt;K*&gt;(p);
   // Using the reinterpret_cast to treat the `void*` as a `K*` does not
   // change that fact. An object of type K has not yet been constructed still.

   K* k2 = new (p) K(10);
   // Use placement new operator to construct K.
   // At this point, an object of type K has been constructed by calling
   // K's constructor using the memory pointed to by p.


   // Do something with the object.

   // Done with the function.
   // Now it's time to do the necessary things to release resources back to
   // the system.

   // Do not use `delete K` at this point.
   // Whenever you use the placement new operator, call the destructor explicitly.
   // This calls the destructor ~K(), but does not deallocate memory from heap.
   k2-&gt;~K();

   // Deallocate the memory heap.
   ::operator delete(p);
}
</code></pre>
",6
22457939,22457448,1,"<blockquote>
  <p>Getters and setters</p>
</blockquote>

<p>Having getters and setters for the sake of having them is <a href=""https://stackoverflow.com/a/12108025/493122"">never a good idea</a>. Therefore your code for <code>Point</code> can be reduced to:</p>

<pre><code>struct Point {
    int x;
    int y;
};
</code></pre>

<p>Which not only is easier and faster to read, but is just as constant correct as your solution was.</p>

<hr>

<blockquote>
  <p>The array</p>
</blockquote>

<p>Your <code>PointArray</code> class is less than reusable. You can use standard containers instead. Your <code>PointArray</code> class can be reduced to:</p>

<pre><code>using PointArray = std::vector&lt;Point&gt;;
</code></pre>

<hr>

<blockquote>
  <p>The Polygon base class</p>
</blockquote>

<p>The <code>Polygon</code> class can also be improved. First of all you don't need <code>loci</code> to be dynamically allocated. You should use:</p>

<pre><code>class Polygon {
protected: 
   PointArray loci; 
   int sides;
   static int N;
</code></pre>

<p>Now, for the constructor you could use the following instead of the C-style array that you are expecting from the first constructor:</p>

<pre><code>public:
   Polygon(const PointArray&amp; loc) {
      loci = loc
      sides = loc.size();
      N++;
   }
</code></pre>

<p>As you can see there's no need for the <code>len</code> argument. You could also use an <code>std::initializer_list</code> to allow expressions like:</p>

<pre><code>Polygon x { Point(...), Point(...), Point(...), ... };
</code></pre>

<p>And here's how:</p>

<pre><code>    Polygon(const std::initializer_list&lt;Point&gt; list)
        : loci(list)
        , sides(list.size())
        { N++; }
</code></pre>

<p>And after your smart edit you can get rid of the custom copy constructor and destructor, effectively following the <a href=""http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html"" rel=""nofollow noreferrer"">Rule of Zero</a>.</p>

<p>The rest is pretty much the same:</p>

<pre><code>    virtual double area() = 0;
    static int getNumPolygons() { return N; }
    int getNumSides() { return sides; }
</code></pre>

<p>except for <code>getPoints</code>. I'd suggest two different overloads: <code>const</code> and non-<code>const</code>:</p>

<pre><code>    PointArray&amp; getPoints() { return loci; }
    const PointArray&amp; getPoints() const { return loci; }
};
</code></pre>

<hr>

<blockquote>
  <p>The Rectangle class</p>
</blockquote>

<p>And finally your rectangle class can, of course, be improved:</p>

<pre><code>class Rectangle : public Polygon { 
private:
    void makeRectangle(const Point&amp; e, const Point&amp; r) {
        loci.push_back(e);
        loci.push_back(r);
        loci.emplace_back(e.x, r.y);
        loci.emplace_back(r.x, e.y);
    }

    void makeRectangle (const int x1, const int x2, const int y1, const int y2) {
        loci.emplace_back(x1, y1);
        loci.emplace_back(x2, y1);
        loci.emplace_back(x2, y2);
        loci.emplace_back(x1, y2);
    }
};
</code></pre>

<hr>

<blockquote>
  <p>Conclusion</p>
</blockquote>

<p>After this simple refactoring, all your errors should be gone and your code should be much shorter and readable.</p>
",0
22513271,22513168,3,"<pre><code>studentlist[i]=temp; // here is the problem!!
</code></pre>

<p><code>studentlist[]</code> is an array of objects of the class <code>student</code>, and <code>temp</code> is a variable of type <code>int</code>. This is invalid. You are trying to assign an <a href=""https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value"">uninitialized <code>int</code></a>, which could have any value, to an array of <code>students</code>. </p>

<p>I believe, by looking at your implementation, that you are looking for something like this (although this search could be improved):</p>

<pre><code>int num;
cout&lt;&lt;""Enter ID of Student ""&lt;&lt;endl;
cin&gt;&gt;num;

for(int i=0;i&lt;3;i++)
{
    if(studentlist[i].getid() == num)
    {
        // found student with id == num
    }
}
</code></pre>
",0
21043295,21043270,1,"<blockquote>
  <p>Is there a way to extract the <code>sizeof()</code> of the array from just the pointer to the first letter?</p>
</blockquote>

<p>No.</p>

<p>Unfortunately, you have to keep track of this explicitly and maybe pass around the length as extra arguments to functions etc.</p>

<p>You have tagged your question ""C++"". In C++ we usually use <code>std::vector</code>, <code>std::string</code> or other container classes to keep track of this.</p>
",0
21043308,21043270,0,"<p>There is no way to do this - maybe use a <code>std::vector</code> instead, or a <code>std::string</code> if you just need <code>char</code>'s.</p>
",0
21043309,21043270,0,"<p>No.</p>

<p>That information is simply not available at run-time. A pointer is just a pointer, there is nowhere for the extra information (about the area being pointed at) to live.</p>
",0
25506791,25506606,3,"<p>First of all, you are not using <code>operator=</code>, rather this is a <em>copy-initialization</em>.</p>

<p>That is, the expression <code>S s1 = 3;</code> uses <strong>non-explicit</strong> constructor <code>S(int x)</code> and also <strong>non-explicit</strong> and <strong>accessible</strong> copy constructor <code>S(const S&amp; x)</code> (hopefully without any additional overhead).</p>

<p>Going further, you can't use <code>S&amp; s1 = 3;</code> not because you <em>cannot assign 3 to reference</em>, but because the right hand side of assignment is an R-VALUE (that is, <em>a temporary</em>). However, you can extend its lifetime using const reference to l-value, as r-values like very much to be bound by const l-value references:</p>

<pre><code>const S&amp; s1 = 3;
</code></pre>

<p>This will work as long as <code>S(int x)</code> is not marked as <code>explicit</code>.</p>

<p>Alternatively, (you should not do that at all), you can use r-value reference:</p>

<pre><code>S&amp;&amp; s1 = 3; // implicitly
S&amp;&amp; s2 = S(3); // explicitly
</code></pre>

<p>And the error you see trying to compile <code>S&amp; s5;</code>:</p>

<pre><code>main.cpp:16:5: error: ¡®s5¡¯ declared as reference but not initialized
</code></pre>

<p>tells you that you cannot just create a variable that is a <em>reference</em> (as opposed to pointers), without initializing it.</p>

<p>But if you had a validly initialized reference, then whenever you would use assignment, only then the <code>operator=</code> would be invoked:</p>

<pre><code>S s1(1);
S&amp; s1ref = s1;
S s2(2);
s1ref = s2; // s1.operator=(s2);
</code></pre>
",4
25506659,25506606,1,"<p>This is not possible; a reference must refer to an object. You can do either of the following (using C++98 syntax):</p>

<pre><code>S const &amp;s1 (3);   // same as S const &amp;s1 = S(3);
</code></pre>

<p>or</p>

<pre><code>S s0(3); S &amp;s1(s0);
</code></pre>
",0
25507318,25507113,1,"<p>You can't use <code>5</code> literal for other purpose than just a number, but you can declare your own <em>user-defined literal</em>:</p>

<pre><code>struct S
{
};

S A[10];

S&amp; operator """" _(unsigned long long int i)
{
    return A[i];
}

int main()
{
    S&amp; s = 5_;
}
</code></pre>

<p><a href=""http://ideone.com/B1WKgs"" rel=""nofollow"">Live demo link.</a></p>
",1
25507265,25507113,1,"<p>You can only use a constant reference. That is instead of</p>

<pre><code>S&amp; s5;s5=10;
S&amp; s6=10;
</code></pre>

<p>(by the way this statement </p>

<pre><code>S&amp; s5;s5=10;
</code></pre>

<p>is invalid because a reference shall be initialized in the time of its definition )</p>

<p>you have to write</p>

<pre><code>const S&amp; s5 = 10;
const S&amp; s6 = 10;
</code></pre>
",12
25507659,25507113,0,"<p><code>s=5</code> means <em><code>s</code> have to have same value as object initialized using <code>5</code>.</em><br>
<code>s=A[5]</code> means <em><code>s</code> have to have same value as <code>A</code>'s sixth element.</em></p>

<p>Also, it seems you don't understand references.</p>

<p>Reference (<code>S&amp;</code>) is creation referring to variable. While creating it, you have to say to which variable it's pointing to.</p>

<p><code>S&amp; s6=10;</code><br>
In this case, <code>10</code> is <em>temporary</em> variable. It's gonna disappear soon. If you want modify it, you should use <em>reference to temporary</em> (<code>S&amp;&amp;</code>), added in C++11. Alternatively, you can use <em>const reference</em> (<code>const S&amp;</code>), aviable in previous standards.</p>
",3
25508679,25507113,0,"<p>What I see as missing is the possibility in C++ to define a constructor for the reference instead for the object it self.</p>

<p>As Vlad from Moscow pointed out the code compiles when the reference is made constant, albeit the result refers to the just constructed new object ( a new S copied from A with index i ).</p>

<p>In order to obtain what needed the compiler should offer the possibility of a reference constructor something like</p>

<pre><code>S&amp;(int i){....}
</code></pre>

<p>But the compiler ( and or the language - I don't know that ) doesn't offer that possibility limiting what can be done overloading a constructor to non references.</p>
",0
32929595,32929579,1,"<p>It is indeed ""reading as 'else if'"", however if you were to use the brackets you (in the future) or any other reader of your code would not have a need to even raise a question of what code block does that <code>else</code> belong to ;-)</p>

<p>This usage of brackets will yield even better results if some time later you were to add more lines of code before the <code>return;</code> block. With no brackets you are running into a possibility of making an ""innocent"" mistake of completely changing the logic of your code.</p>
",0
32929601,32929579,2,"<p>For the love of kittens, <strong>use</strong> brackets -- espicially for this mess.  Yes it is <code>else if</code> right now.</p>
",0
32929618,32929579,1,"<p>It's reading as <code>else if</code>. The equivalent code utilizing braces and proper formatting:</p>

<pre><code>void balance(Node * &amp; x)
{
    if (x == nullptr) {
        return;
    }
    if (height(x-&gt;left) - height(x-&gt;right) &gt; 1) {
        if(height(x-&gt;left-&gt;left) &gt;= height(x-&gt;left-&gt;right)) {
            rotateLeft(x);
        }
        else {
            doubleRotateLeft(x);
        }
    }
    else if (height(x-&gt;right) - height(x-&gt;left) &gt; 1) {
        if(height(x-&gt;right-&gt;right) &gt;= height(x-&gt;right-&gt;left)) {
            rotateRight(x);
        }
        else {
            doubleRotateRight(x);
        }
    }
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + 1;
}
</code></pre>
",0
32929683,32929579,0,"<pre><code>void balance(Node * &amp; x)
{
    if (x == nullptr)
    {
        return;
    }
    if (height(x-&gt;left) - height(x-&gt;right) &gt; 1)
    {
        if(height(x-&gt;left-&gt;left) &gt;= height(x-&gt;left-&gt;right))
        {
            rotateLeft(x);
        }
        else
        {
            doubleRotateLeft(x);
        }
    }
    else if (height(x-&gt;right) - height(x-&gt;left) &gt; 1) // this one
    {
        if(height(x-&gt;right-&gt;right) &gt;= height(x-&gt;right-&gt;left))
        {
            rotateRight(x);
        }
        else
        {
            doubleRotateRight(x);
        }
    }

    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + 1;
}
</code></pre>

<p>This is the code that compiler think you are writing. Because ""else if"" consider unlimited amount of space in between, so all the books suggest to put brackets all the time.</p>

<p>I think in your case, the auto bracket and the logic I guess from your indentation seems provide the same result.</p>
",0
31269623,31269321,1,"<p>This operation is known as bit rotation.</p>

<pre><code>unsigned rotate_left(unsigned x, unsigned num_bits, int delta) {
    unsigned rdelta = delta % num_bits;
    unsigned mask = (1 &lt;&lt; num_bits) - 1;
    return ((x &lt;&lt; rdelta) | (x &gt;&gt; (num_bits - rdelta))) &amp; mask;
}
</code></pre>

<p>This will rotate bitwheel <code>x</code> containing <code>num_bits</code> bits left by <code>delta</code> bits. Negative shifts should also work. The equivalent <code>rotate_right</code> function can be obtained by changing <code>&lt;&lt;</code> to <code>&gt;&gt;</code> and vice versa.</p>

<p>If <code>num_bits</code> is 32 and you need this operation to execute very fast, you can use intrinsics for the machine rotate instructions.</p>

<p>Addendum: to test the rightmost (zeroth) bit, of course use:</p>

<pre><code>if (x &amp; 1) { ...
</code></pre>

<p>To test bit N:</p>

<pre><code>if (x &amp; (1 &lt;&lt; N)) { ...
</code></pre>

<p>If you need more than 32 bits, use <code>unsigned long</code> or <code>unsigned long long</code> (depends on your platform). If you need an arbitrary number of bits, this solution won't work - you'll need to use something based e.g. on <code>std::bitset</code> like in the second answer, or on <code>vector&lt;bool&gt;</code>.</p>
",2
31269712,31269321,1,"<p>Your ""wheel"" can be represented as a field of bits in your memory.
If the required length is smaller than 64, then you can use any integer type to implement it. it's simple: </p>

<pre><code>void shift_clockwise(unsigned long long *wheel, int size) {
    unsigned long long first_bit = (*wheel) &amp; 1ll;
    (*wheel) = ((*wheel) &gt;&gt; 1) &amp; (first_bit &lt;&lt; (size-1));        
}
</code></pre>

<p>If the size is larger, then you can use <a href=""http://www.cplusplus.com/reference/bitset/bitset/"" rel=""nofollow""><code>std::bitset</code></a>, for example:</p>

<pre><code>void shift_clockwise(std::bitset&lt;wheel_size&gt;&amp; wheel) {
    bool first_bit = wheel.test(0);
    wheel &gt;&gt;= 1;
    set(wheel.size()-1, first_bit);
}
</code></pre>
",0
31271747,31269321,1,"<p>Since you know there is only one <code>1</code> bit, there's no point in storing all the <code>0</code>'s. Just store the position of the <code>1</code>.</p>

<pre><code>struct Wheel {
    Wheel(int size)
    : _size(size)
    , _onePos(0) {}

    void rotate() {
        ++_onePos;
        if(_onePos == _size) {
            _onePos = 0;
            onFullRotation();
        }
    }

    unsigned int bits() const {
        return 1u &lt;&lt; _onePos;
    }

private:
    void onFullRotation() {
        std::cout &lt;&lt; ""&lt;full rotation&gt;"";
    }

    int const _size;
    int _onePos;
};
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/254f6b0aa48b8314"" rel=""nofollow"">Live on Coliru</a></p>
",0
27141165,27141138,1,"<p>You are getting this error as you are calling printcell on const object. Use this to get over this error:-</p>

<pre><code>void printcell() const;
</code></pre>
",0
21015206,21015107,0,"<p>Use <a href=""http://www.cplusplus.com/reference/cstdlib/strtol/"" rel=""nofollow"">strtol</a>.
for example::</p>

<pre><code>int a=(int)strtol(numeric_string.c_str(),(char **)NULL,10);
</code></pre>

<p>if your intension isto simply convert HH:MM:SS, you need to write a function
algorithm would be like(assuming 24Hr format):</p>

<ol>
<li><code>split</code> the string using "":""</li>
<li>Convert each part using <code>strtol</code> to integer.</li>
<li><code>last part+(60* middle part)+(60*60*firstpart)</code> will give you the
actual value</li>
</ol>
",1
21015267,21015107,0,"<p>Since this is not a standard C++ function it greatly depends on what framework or library you are using.</p>

<p>This how it's done in Borland C++ Builder:</p>

<pre><code>String Time;
Time = ""12:34:56"";
TDateTime DT;

try{
    DT = StrToTime(Time);
  }catch(...){String M = ""Error converting time string: ""+Time; Application-&gt;MessageBox(M.c_str(),""ERROR"",MB_OK );}
</code></pre>
",0
21015401,21015107,1,"<p>Use sscanf_s.
For example:</p>

<pre><code>void ScanTime(char* strTime)
{
    int hours;
    int minutes;
    int seconds;

    sscanf_s(strTime, ""%d:%d:%d"", &amp;hours, &amp;minutes, &amp;seconds);

    printf(""hours: %d\nminutes:%d\nseconds:%d\n"", hours, minutes, seconds);
}


int _tmain(int argc, _TCHAR* argv[])
{
    ScanTime(""13:57:44"");
    return 0;
}
</code></pre>
",2
21043519,21043421,1,"<p>Use friend :</p>

<pre><code>class trySort {
friend bool sortThisAsc (const trySort &amp; rhs , const trySort &amp; lhs);

private:
       std::string sortThis;
}
</code></pre>

<p>It will give access only to this function and not to anything else</p>
",2
21043599,21043421,0,"<p><strong>EDIT</strong> This gets rid of the compilation error you mentioned, but only non-member functions can be passed to std::sort(), so this doesn't quite work.</p>

<p>In your cpp file, change the function definition from</p>

<pre><code>bool sortThisAsc (const trySort &amp; rhs , const trySort &amp; lhs) {
</code></pre>

<p>to </p>

<pre><code>bool trySort::sortThisAsc(const trySort &amp; rhs, const trySort &amp; lhs) {
</code></pre>

<p>Without the <code>trySort::</code> the function isn't defined in the <code>trySort</code> class scope (i.e. outside that class), so the compiler complains if you try to access private variables in <code>trySort</code>.</p>

<p>This way, you can keep it as a private method, as you originally asked for.</p>
",4
21043694,21043421,2,"<p>You can add <code>operator &gt;</code> to <code>trySort</code> class.</p>

<pre><code>trySort.h

class trySort {

public:
    bool operator &gt;(trySort const &amp;other) {
        return sortThis &gt; other.sortThis;
    }  
private:
    std::string sortThis;
}
</code></pre>

<p>If you need more flexibility (some other kinds of comparisons), just encapsulate <code>sortThis</code> with a getter function.</p>

<pre><code>trySort.h

class trySort {

public:
    std::string const &amp;getSortThis() const {
        return sortThis;
    }

private:
    std::string sortThis;
}
</code></pre>

<p>If you are absolutely sure that <code>sortThis</code> will always be immutable through the course of a project, thus initialized in the constructor, you can leave it as a public const member, but in most cases this is very speculative approach.</p>

<pre><code>trySort.h

class trySort {

public:
    trySort(std::string const sortThis)
        : sortThis(sortThis) {
    }

    const std::string sortThis;
}
</code></pre>

<p>Or you can do it with <code>friend</code>, but I would leave it as a last resort, since in most cases it turns out to represent excessive intimacy (there is always some other approach you can take to avoid using <code>friend</code>s). Using <code>friend</code> can be appropriate in some circumstances, but it never the less breaks encapsulation, with the difference that <code>friend</code> clause signals to class' clients that breakage was intentional.</p>
",3
21043756,21043421,0,"<p>There are at least two alternatives. 
Either you can declare a public getter to this data member as for example</p>

<pre><code>class trySort {

public:
       const std::string &amp; get_string() const { return sortThis; }

private:
       std::string sortThis;
}
</code></pre>

<p>and then in function sortThisAsc to write </p>

<pre><code>bool sortThisAsc (const trySort &amp; rhs , const trySort &amp; lhs) {
    return lhs.get_string() &gt; rhs.get_string();
}
</code></pre>

<p>Or you can declare the function as a friend function of the class</p>

<pre><code>class trySort {

public:
       friend bool sortThisAsc (const trySort &amp; rhs , const trySort &amp; lhs);

private:
       std::string sortThis;
}
</code></pre>

<p>In this case the function definition will not be changed.</p>
",0
21031283,21031220,0,"<p>You are violating the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29"" rel=""nofollow"">Rule of Three</a>. You should define a copy constructor and a copy assignment operator.</p>
",0
22433892,22433706,0,"<pre><code>for( auto pos = str.find( word ); pos != std::string::npos; pos = str.find( word ) )
{
    str.replace( str.begin() + pos, str.begin() + pos + word.size(), word.size(),'*' );
}
</code></pre>

<p>We find the first appearance of the word we want replaced. We then replace it. We do this until there are no more appearances, as they have all been replaced.</p>
",0
28315910,28315841,4,"<p>Use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/find"" rel=""nofollow""><code>string::find</code></a> and <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stof"" rel=""nofollow""><code>stof</code></a>.</p>

<pre><code>size_t colon_pos = a.find(':');
string str = a.substr(0, colon_pos);
float f = stof(a.substr(colon_pos+1));
</code></pre>
",0
28315915,28315841,1,"<p>Probably sscanf?</p>

<pre><code>sscanf(""a = %s:%f"",&amp;s_string,&amp;f_float);
</code></pre>
",3
28315998,28315841,0,"<p>Like this:</p>

<pre><code>std::string a = ""asda:123"";

size_t colon_pos = a.rfind("":"");

if (colon_pos == std::string::npos) {
    // Error, invalid string
}

std::string the_string = a.substr(0, colon_pos);
try {
    float the_float = std::stof(a.substr(colon_pos + 1));
} catch (const std::invalid_argument &amp; exc) {
    // Error, cannot convert
} catch (const std::out_of_range &amp; exc) {
    // Error, value out of range
}
</code></pre>

<p>Note the use of <code>rfind</code>, thanks to this it should work correctly even if your string part contains colons.</p>

<p>If you don't have C++11, instead of <code>std::stof</code>, you can use:</p>

<pre><code>float the_float = 0.0;
std::string the_float_str = a.substr(colon_pos + 1);
std::stringstream stream;
stream &lt;&lt; the_float_str;
stream &gt;&gt; the_float;
</code></pre>
",0
28316050,28315841,1,"<p>The cleanest way, as one of the comments suggests, is to use <code>std::getline(inputstream,line,delimiter)</code>. An example code would be:</p>

<pre><code>std::string input;//your input string with tag:value information
std::stringstream ss(input);
std::string item;
std::vector&lt;std::string&gt; output;
while (std::getline(ss, item, ':'))
   output.push_back(item);
</code></pre>

<p>Then in the <code>output</code> vector you have your items/tokens as you want. Depending on the rest of the code of your application you may want to wrap this in a function or use as it is.</p>

<p>For example I have it in a function like this:</p>

<pre><code>std::vector&lt;std::string&gt; &amp;split(
    std::string &amp;input,
    std::vector&lt;std::string&gt; &amp;output,
    char delim)
{
    std::stringstream ss(input);
    std::string item;
    while (std::getline(ss,item,delim))
        output.push_back(item);
    return output;
}
</code></pre>

<p>Note that if you have multiple <code>delimiter</code> in the input string this code would separate all of them. You would need to be more specific in your question so that I can adjust the answer.</p>

<p>In order to convert your item to float you can have a look at this example: </p>

<pre><code>// stof example
#include &lt;iostream&gt;   // std::cout
#include &lt;string&gt;     // std::string, std::stof

int main ()
{
  std::string orbits (""686.97 365.24"");
  std::string::size_type sz;     // alias of size_t

  float mars = std::stof (orbits,&amp;sz);
  float earth = std::stof (orbits.substr(sz));
  std::cout &lt;&lt; ""One martian year takes "" &lt;&lt; (mars/earth) &lt;&lt; "" Earth years.\n"";
  return 0;
}
</code></pre>

<p>Note that you need c++11 standard enabled. The example was taken directly from <a href=""http://www.cplusplus.com/reference/string/stof/"" rel=""nofollow"">here</a></p>
",7
30149897,30149697,3,"<p>There is no hash operator, but you could hide the <code>hash</code> struct inside of your <code>X</code>:</p>

<pre><code>struct X
{
    std::string name;

    struct hash
    {
        auto operator()( const X&amp; x ) const
        { return std::hash&lt; std::string &gt;()( x.name ); }
    };
};
</code></pre>

<p>You could even make it a friend and make <code>name</code> private, etc.</p>

<p><a href=""http://coliru.stacked-crooked.com/a/02e50913bac2e270"" rel=""nofollow""><strong>Live example</strong></a></p>
",0
30149936,30149697,1,"<p>I'd recommend to consider a more general hash class.  You could define for this class all the common hash manipulation operations that you could need: </p>

<pre><code>struct ghash {
     // all the values and operations you need here 
}; 
</code></pre>

<p>Then in any class where you want to compute a hash, you could define a conversion operator </p>

<pre><code>struct X { 
    operator ghash () {  // conversion operator 
        ghash rh; 
        // compute the hash
        return rh; 
    }
};
</code></pre>

<p>You can then easily calculate the hash: </p>

<pre><code> X x; 
 ghash hx = x;   // convert x to a hash 
 hx = (ghash)x;  // or if you prefer to make it visible
</code></pre>

<p>This will make it easier to extend the use of your hash structure without  reinventing the common ground for any other struct X, Y,Z that may need a hash in the future. </p>

<p><a href=""http://ideone.com/3xDEZL"" rel=""nofollow"">Live demo here</a></p>
",0
30151204,30149697,2,"<pre><code>namespace hashing {
  template&lt;class T&gt;
  std::size_t hash(T const&amp;t)-&gt;
  std::result_of_t&lt;std::hash&lt;T&gt;(T const&amp;)&gt;
  {
    return std::hash&lt;T&gt;{}(t);
  }
  struch hasher {
    template&lt;class T&gt;
    std::size_t operator()(T const&amp;t)const{
      return hash(t);
    }
  };
}
</code></pre>

<p>the above is some boilerplate that sets up an adl-based <code>hash</code> system.</p>

<pre><code>template&lt;class T&gt;
using un_set=std::unordered_set&lt;T,hashing::hasher&gt;;
template&lt;class K, class V&gt;
using un_map=std::unordered_map&lt;K,V,hashing::hasher&gt;;
</code></pre>

<p>now creates two container aliases where you do not have to specify the hasher.</p>

<p>To add a new hashable:</p>

<pre><code>struct Foo {
  std::string s;
  friend size_t hash(Foo const&amp;f){
    return hashing::hasher{}(s);
  }
};
</code></pre>

<p>and <code>Foo</code> works in <code>un_set</code> and <code>un_map</code>.</p>

<p>I would add support for <code>std</code> containers and tuples into <code>hashing</code> namespace (override the function <code>hash</code> for them), and magically those will work too.</p>
",0
30151441,30149697,8,"<p><code>std::unordered_set</code> is defined within <code>std</code> namespace. And it uses <code>std::hash</code> structures to hash many different types. If you want to be able to use <code>std::unordered_set&lt;X&gt;</code> (without adding much info to the declaration), you must create another overload of the <code>std::hash</code> template, so as to make it <em>hash</em> your structure.</p>

<p>You should be able to get it working by doing the following:</p>

<pre><code># include &lt;unordered_set&gt;
struct X {
    size_t operator()(void) const {}
    bool operator()(const X &amp;other) const {}
};

namespace std {
    template&lt;&gt;
    struct hash&lt;X&gt; {
        inline size_t operator()(const X&amp; x) const {
            // size_t value = your hash computations over x
            return value;
        }
    };
}

int main() {
    std::unordered_set&lt;X&gt; s;
}
</code></pre>

<hr>

<p>Andalso, you must provide either an overload to <code>std::equal_to</code>, or a comparison operator (<code>operator==()</code>) for your structure. You should add one of the following:</p>

<pre><code>struct X {
    ...
    inline bool operator==(const X&amp; other) const {
        // bool comparison = result of comparing 'this' to 'other'
        return comparison;
    }

};
</code></pre>

<p>Or:</p>

<pre><code>template &lt;&gt;
struct equal_to&lt;X&gt; {
    inline bool operator()(const X&amp; a, const X&amp; b) const {
        // bool comparison = result of comparing 'a' to 'b'
        return comparison;
    }
};
</code></pre>
",2
21035883,21035730,0,"<p>Use the following code:</p>

<pre><code>if(strcmp(name,empName)==0)
{
     ...
}
</code></pre>

<p>Note that there must be <strong>no quotation marks</strong> around <code>empName</code> to compare its contents.</p>
",0
23069623,23068929,2,"<p>Any declaration of a function in an inner scope hides all declarations of functions with the same name in the outer scope.</p>

<p>You declared in the block scope of function boo function <code>::foo</code></p>

<pre><code>  void boo() {
    using ::foo;
    foo(1.0);
    foo(1.0f);
    foo(1);
    foo();
  };
</code></pre>

<p>It hides all functions with the same name in enclosing scopes.</p>

<p>More precisely. According to the C++ Standard</p>

<blockquote>
  <p>13 Since a using-declaration is a declaration, the restrictions on
  declarations of the same name in the same declarative region (3.3)
  also apply to using-declarations</p>
</blockquote>

<p>Or maybe it would be better to cite the following quote from the C++ Standard</p>

<blockquote>
  <p>1 A using-declaration introduces a name into the declarative region in
  which the using-declaration appears.using-declaration:The member name
  specified in a using-declaration is declared in the declarative region
  in which the using-declaration appears.</p>
</blockquote>
",0
25517874,25517592,1,"<p>Since you want an increase to the next multiple of .5:</p>

<pre><code>    x = ceil(x*2.0)/2.0;
</code></pre>
",1
25517635,25517592,4,"<p>Consider this:</p>

<pre><code>round(x * 2.0) / 2.0;
</code></pre>
",1
25517678,25517592,0,"<p>To get value rounded by 0.5, double the input value, then use round function, and devide by 2 at last.</p>

<p>C++ code:</p>

<pre><code>answer = ( round(x*2) )/2;
</code></pre>
",0
23847551,23847531,2,"<p>You need to define <code>Edge</code> before you use it in the <code>Node</code> struct.</p>
",1
23850597,23850572,1,"<p>Line 43: change <code>DLList* first = 0;</code> to <code>DLList *first;</code> and in all constructors, initialize <code>first</code> to <code>0</code>. </p>

<p>Line 44: similar</p>

<p>Line 45: change <code>Dlist()</code> to either <code>DList()</code> (if it's meant to be a constructor) or <code>void Dlist()</code> otherwise</p>

<p>Line 178: presuambly <code>empty</code> is meant to be <code>isEmpty</code>.</p>

<p>The other errors are cascades of those. Also I'm not sure why you pasted your errors twice.</p>

<p>The <code>DLList *first = 0;</code> is only supported in C++11 which apparently your compiler doesn't support</p>
",2
23594504,23594467,1,"<p>The destructor has to be defined as</p>

<pre><code>person::~person()
{
    delete [] this-&gt;name;
    delete this-&gt;age;
    delete [] this-&gt;address;
}
</code></pre>

<p>And this statemenet</p>

<pre><code>delete newperson;
</code></pre>

<p>has to be substituted for this statement</p>

<pre><code>delete [] newperson;
</code></pre>
",0
21302392,21302251,7,"<p>As I have commented, you need to change</p>

<pre><code>while (it &lt; this-&gt;_size);
</code></pre>

<p>to</p>

<pre><code>while (it &lt; this-&gt;_size)
</code></pre>

<p>to make it a <code>while</code>-loop with the ability to change its condition in order to avoid infinite loop.</p>
",0
25668698,25668601,-3,"<p>std::endl just adds EOL (end of line) symbol to output. Usually its \n, but it can vary from one OS to another.</p>
",6
25668930,25668601,5,"<p>The stream contains an in-memory buffer where data is written before being flushed to the final destination (in this case, the output console), since flushing can be an expensive operation.</p>

<p>The buffer might be flushed automatically in some circumstances: when the stream is closed, or if there's a lot of buffered data, or if the stream is configured to flush after each line, as <code>std::cerr</code> is.</p>

<p>Sometimes you need to flush manually, for example to make sure the user sees something you've written to <code>std::cout</code>. That can be done in two ways:</p>

<ul>
<li>calling the <code>flush()</code> member function on the stream;</li>
<li>streaming the <code>std::flush</code> manipulator into the stream.</li>
</ul>

<p>The <code>std::endl</code> manipulator does two things:</p>

<ul>
<li>inserts a new-line character (or character sequence), equivalent to <code>&lt;&lt; '\n'</code>; then</li>
<li>flushes the stream, equivalent to <code>&lt;&lt; std::flush</code>, (which is in turn calls the stream's <code>flush()</code> member function).</li>
</ul>

<p>This is useful for writing short messages to the console; but should be used carefully, as it can have a considerable performance impact when producing large amounts of output.</p>

<p>A further complication is that one stream can be <em>tied</em> to another, so that one is flushed before another is accessed. In this case, <code>cout</code> is tied to <code>cin</code>, which is why you see the first output before reading from <code>cin</code> even though there is no explicit flush.</p>

<p>Finally, all the standard streams, including <code>cout</code>, are flushed automatically when the program ends (specifically, when the global instance of <code>std::ios_base::Init</code> is destroyed; but that's a detail you shouldn't need to know about.)</p>
",1
25668749,25668601,1,"<p>After first line, the output is in the buffer, so you will not see it in the terminal. </p>

<p>After the second line, the <code>endl</code> causes the buffer to be flushed so you will now see line 1 and 2 in the terminal output. </p>

<p>After the third line, output is in the buffer and you will not see it in the terminal until the program exits.</p>

<p><strong>Edit:</strong></p>

<p>When you place a cin between line 1 and 2, it causes cout to be flushed. See: <a href=""http://www.cplusplus.com/reference/iostream/cin/"" rel=""nofollow"">std::cin</a></p>

<blockquote>
  <p>cin is tied to the standard output stream cout (see ios::tie), which indicates that cout's buffer is flushed (see ostream::flush) before each i/o operation performed on cin.</p>
</blockquote>
",1
25668799,25668601,0,"<p>After 1st line, cout contains just the given string with no newline char.
After 2nd line, cout additionally contains a line ending and the text appears at the console window.
After 3rd line, cout contains another string including line ending which not necessarily appears at the console window.
After exiting main, the text of the 3rd line is appears.</p>
",1
21174096,21174072,3,"<p>Essentially you need to keep the list of probabilities and their sum.</p>

<p>Generate a random number in the range <code>0 &lt;= number &lt; sum</code> (using <a href=""http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution"" rel=""nofollow""><code>std::uniform_int_distribution</code></a> or <a href=""http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution"" rel=""nofollow""><code>std::uniform_real_distribution</code></a>, depending on the type).</p>

<p>Iterate through the list adding up the values until you reach a value greater than or equal to your generated value.</p>

<p>The number you're currently at is the randomly selected one.</p>

<p>If you have a lot of values there are a few tricks you can use to speed this up such as sorting the list largest values first and potentially even having a skip list type of structure that allows you to jump to certain probability totals in the list. Generally that sort of thing isn't needed though and if you do do it you have to be very careful not to get it wrong and skew the results.</p>
",4
21174126,21174072,1,"<p>Treat the probabilities as ""weights"" and add them all up to get the total weight <em>W</em>. Generate a random floating-point number <em>x</em> between 0 and <em>W</em>. If 0 &lt;= <em>x</em> &lt; <em>W1</em> (where <em>W1</em> is the weight of the first choice), choose the first number. If <em>W1</em> &lt;= x &lt; <em>W1 + W2</em>, choose the second number, and so on.</p>
",0
21174159,21174072,1,"<p>Given an array of elements with their probability `{a=>0.1, b=>0.2, c=>0.3, d=>0.4}' </p>

<p>The total probability must be 1! Then create an array which adds up the probabilities like this <code>{a=&gt;0.1, b=&gt;0.3, c=&gt;0.6, d=&gt;1}</code>. Now generate a random number between 0 and 1.
And check if its smaller 0.1 select <code>a</code>, if its just smaller 0.3 select <code>b</code> and so on!</p>
",2
21174296,21174072,4,"<p>If what you actually want is to treat these ""probabilities"" as weights, you can use a <a href=""http://en.cppreference.com/w/cpp/numeric/random/discrete_distribution"" rel=""nofollow""><code>std::discrete_distribution</code></a>:</p>

<pre><code>std::random_device rd;
std::mt19937 gen(rd());
std::discrete_distribution&lt;&gt; d({0.55, 0.66});
</code></pre>

<p>Then when you call <code>d(gen)</code>, you'll get value 0 with weight 0.55 and value 1 with weight 0.66. This of course means that the <em>probability</em> of getting 0 is actually <code>0.55/(0.55+0.66) = 0.45</code>, and the probability of getting 1 is therefore <code>1 - 0.45 = 0.55</code>.</p>

<p>You then just need to map from <code>0</code> to <code>2</code> and from <code>1</code> to <code>3</code>.</p>
",0
33533449,33533272,0,"<p>Yes, you can do it by including <code>&lt;complex&gt;</code></p>

<pre><code>std::complex&lt;double&gt; com_one; // value 0 + 0i 
std::complex&lt;double&gt; com_two(3.14); // value 3.14 + 0i
std::complex&lt;double&gt; com_three(1.5, 3.14) // value 1.5 + 3.14i 
std::complex&lt;double&gt; com_four(com_two); // value is also 3.14 + 0i
</code></pre>

<p>Then to use arithmetic operations, you can just use</p>

<pre><code>std::cout &lt;&lt; com_one + com_two &lt;&lt; std::endl; 
std::cout &lt;&lt; com_one - 3.14 &lt;&lt; std::endl; 
std::cout &lt;&lt; 2.75 * com_two &lt;&lt; std::endl; 
com_one += com_three / 2.0;
</code></pre>

<p>Source: <a href=""http://stdcxx.apache.org/doc/stdlibug/20-2.html"" rel=""nofollow"">http://stdcxx.apache.org/doc/stdlibug/20-2.html</a></p>

<p>For checking if it's a zero check it using <code>if</code>, and compare it with a zero. This is the most clean technique. </p>
",0
33533468,33533272,1,"<p>I don't think you can avoid doing the condition and printing if non-zero <em>somewhere</em>.</p>

<p>About all you can do is wrap it up so most code doesn't need to deal with it:</p>

<pre><code>class complex { 
   double x;
   double i;
public:
    // ...

    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, complex const &amp;c) { 
        // if both parts are 0, we probably want to print *something*
        if (c.x == 0.0 &amp;&amp; c.i == 0.0)
            return os &lt;&lt; 0;
        if (c.x != 0.0)
            os &lt;&lt; c.x;
        if (c.i != 0.0)
            os &lt;&lt; c.i &lt;&lt; ""i"";
        return os;
     }
};

complex a, b, c;

// ...
cout &lt;&lt; a &lt;&lt; operation &lt;&lt; b &lt;&lt; "" = "" c &lt;&lt; ""\n"";
</code></pre>

<p>You'll have to add a little more if you want this to honor (for example) width/precision correctly (though for real use, you undoubtedly want to use the <code>complex</code> class that's already in the standard library instead).</p>
",0
22426825,22426796,3,"<p>No, not for <code>void *</code>, you will not be able to compute the size of the object whose address is passed.</p>
",2
22426889,22426796,4,"<p>In C++ you could use template argumment deduction to get the type of the pointer (the pointed type) and then compute its sizeof:</p>

<pre><code>template&lt;typename T&gt;
void do_work( T* ptr )
{
    constexpr std::size_t size = sizeof(T);
}
</code></pre>
",3
22426892,22426796,2,"<pre><code>template&lt;typename T&gt;
void do_work(T* ptr)
{
    size_t size = sizeof(T);
    size = sizeof(*ptr); // or this
}
</code></pre>
",2
22426896,22426796,3,"<p>You can use a function template:</p>

<pre><code>template &lt;typename T&gt;
void do_work(T* stuff)
{
  const size_t s = sizeof(T);
  ....
}
</code></pre>

<p><strong>Edit</strong>: version for arrays:</p>

<pre><code>template&lt;typename T, size_t N &gt;
void do_work(T (&amp;array)[N] )
{
  const size_t s = N * sizeof(T);
}
</code></pre>
",2
22426908,22426796,2,"<pre><code>template &lt;typename T&gt;
void do_work(T * t) { do_work(t, sizeof(T)); }
</code></pre>
",0
22427032,22426796,1,"<p>I don't know C++, this question appeared before me, probably because it previously had the C tag. But here's something that you could do in C, probably also in C++:</p>

<pre><code>#define do_work(_a_) do_work_func(_a_, sizeof(_a_))

void do_work_func( void* ptr, size_t size )
{
    //do things with ptr and size
}
</code></pre>

<p>Which would work out, given that <code>one</code> in <code>do_work( one );</code> call had been defined as an array.</p>
",0
22427073,22426796,1,"<p>If I get you right you might want:</p>

<pre><code>#include &lt;iostream&gt;

void do_work(void* ptr, size_t size)
{
    std::cout &lt;&lt; ""Size: "" &lt;&lt; size &lt;&lt; '\n';
}

template &lt;typename T&gt;
void do_work(T&amp; single) {
    do_work(&amp;single, 1);
}

template &lt;typename T, std::size_t N&gt;
void do_work(T (&amp;array)[N]) {
    do_work(array, N);
}

template &lt;typename T&gt;
void do_work(T* multiple, std::size_t n) {
    do_work(static_cast&lt;void*&gt;(multiple), n);
}

int main()
{
    int a = 1;
    int b[] = { 1, 2, 3 };
    int* c = b;
    do_work(a);
    do_work(b);
    do_work(c, 3);
}
</code></pre>

<p>Note: Why the void* ?</p>
",0
28453273,28453169,3,"<p>The <strong>non-constant</strong> initialization of all variable with local scope and static storage duration is from the point it is encountered till the end of the program. So, if the variable is not encountered because of a condition, it would not be initialized and the side effect won't happen.</p>

<p>The following quote from the standard supports the answer (particularly the part in bold)</p>

<p><strong>6.7 Declaration statement [stmt.dcl]</strong></p>

<blockquote>
  <p>The zero-initialization (8.5) of all block-scope variables with static
  storage duration (3.7.1) or thread storage duration (3.7.2) is
  performed before any other initialization takes place. Constant
  initialization (3.6.2) of ablock-scope entity with static storage
  duration, if applicable, is performed before its block is first
  entered.An implementation is permitted to perform early initialization
  of other block-scope variables with static orthread storage duration
  under the same conditions that an implementation is permitted to
  statically initializea variable with static or thread storage duration
  in namespace scope (3.6.2). <strong>Otherwise such a variable is initialized
  the first time control passes through its declaration</strong>; such a
  variable is considered initialized upon the completion of its
  initialization. If the initialization exits by throwing an exception,
  the initialization is not complete, so it will be tried again the next
  time control enters the declaration. If control enters the declaration
  concurrently while the variable is being initialized, the concurrent
  execution shall wait for completion of the initialization.88 If control
  re-enters the declaration recursively while the variable is
  being initialized, the behavior is undefined.</p>
</blockquote>
",0
28453277,28453169,1,"<p>The answer is 3 but you need to think about threading.</p>

<p>The <code>static int xx</code> will be initialised by the first thread encountering that variable, and C++11 will block all other threads at that point until <code>func_with_sideeffect()</code> returns <em>and</em> the result has been assigned to <code>xx</code>. (That's not the case with older standards: a mutex would have been required).</p>

<p>It's more difficult to predict the destruction of <code>xx</code> if it was an instance of an object with a non-trivial destructor.</p>
",0
23096846,23096826,4,"<p>You're missing a curly brace at the start of your for loop's body. By the time you reach the following <code>if</code> statement, <code>strl</code> has gone out of scope.</p>
",0
23096863,23096826,4,"<p>You've left off a brace on your for loop, so it's just a one-liner, despite your indentation. Thus the variable is not in scope in the <code>if</code> statement below it.</p>

<p>Try this:</p>

<pre><code>  for (int on = 0; on &lt; nids; on++) {  // add a brace here
    idstruct strl = ids[on];
    if (strl.state == state) {
      return strl.path;
    }
  }  // and here
</code></pre>
",0
24128544,24127416,8,"<p>Something like this, but with more error checking, should be a good start (this is more C than C++, aside from the <code>cout</code> bit):</p>

<pre><code>const int BUFSIZE = 4096; // should really get PAGESIZE or something instead...
unsigned char buffer[BUFSIZE]; // dynamic allocation rather than stack/global would be better

int fd = open(""/proc/self/cmdline"", O_RDONLY);
int nbytesread = read(fd, buffer, BUFSIZE);
unsigned char *end = buffer + nbytesread;
for (unsigned char *p = buffer; p &lt; end; /**/)
{ cout &lt;&lt; p &lt;&lt; endl;
  while (*p++); // skip until start of next 0-terminated section
}
close(fd);
</code></pre>

<p>In particular, <code>open()</code> and <code>read()</code> should be checked for error conditions, but I haven't shown that part... This may also fail in extreme cases where your command line is > 4096 characters long, or if for some other reason, <code>read()</code> doesn't read the file in one call, which shouldn't happen in current <code>/proc</code> implementations, but is not always guaranteed...</p>
",2
21171303,21171246,8,"<p>In the second example, <code>Ary</code> is local to the function <code>evaluate</code>. When <code>evaluate</code> returns, <code>Ary</code> goes out of scope, and accessing it's memory region results in undefined behaviour.</p>

<p>To avoid this, declare <code>Ary</code> in a scope where it will still be valid at the time you try to access it.</p>
",0
21171320,21171246,4,"<p>It's not working because your <code>pAry</code> is pointing into a local array, which is destroyed when you return from <code>evaluate()</code>. That's undefined behavior.</p>

<p>One possible fix is to make your local array static:</p>

<pre><code>static int Ary[5]={2,5,2,6,8};
</code></pre>
",0
21171341,21171246,3,"<p>In the <code>evaluate()</code> function, you're aiming <code>pAry</code> at a variable (actually array element) <em>local</em> to that function. A pointer can only be dereferenced as long as the object to which it points still exists. Local objects cease to exist when they go out of scope; in this case, this means all elements of <code>Ary</code> cease to exist when <code>evalute()</code> ends, and thus <code>pAry</code> becomes a dangling pointer (it doesn't point anywhere valid).</p>

<p>Dereferncing a dangling pointer gives <em>undefined behaviour;</em> in your particular case, it outputs a garbage value, but it might just as well crash or (worst of all) appear to work fine until the program changes later.</p>

<p>To solve this issue, you can either make <code>Ary</code> global as well, or make it <code>static</code>:</p>

<pre><code>void evaluate(){
    static int Ary[5]={2,5,2,6,8};
    pAry=&amp;Ary[3];
}
</code></pre>

<p>A static local variable persists across function calls (it exists from first initialisation until program termination), so the pointer will remaing valid.</p>
",0
21171423,21171246,1,"<p>The problem is that you need to declare <code>Ary</code> with <em>file scope</em>.  </p>

<pre><code>int Ary[] = {1,2,3,4,5};

void print_ary(void); // The void parameter is a style thingy. :-)

int main(void)
{
  print_ary();
  return EXIT_SUCCESS;
}

void print_ary(void)
{
  for (unsigned int i = 0; i &lt; (sizeof(Ary) / sizeof(Ary[0]); ++i)
  {
    std::cout &lt;&lt; Ary[i] &lt;&lt; std::endl;
  }
}
</code></pre>

<p>A better solution would be to pass a <code>std::vector</code> around to your functions rather than using a global variable.  </p>
",0
26814173,26814151,2,"<p>Forward declarations have to use pointers. The following should compile</p>

<pre><code>class fruit{
    apple* b; // error: incomplete type but why? there is no recursion I guess
};
</code></pre>

<p>The reason for that is that when creating the class fruit, the compiler needs to know how much memory it will allocate for its members. In case it is a pointer this is easy, either 32-bits or 64-bits depending on your architecture. This is why forward declaration works.</p>

<p>If you try to allocate a full object there, then the compiler needs to know how large apple will be to reserve memory for it. But since it is only a forward declaration it has no knowledge of that size and shows an error</p>
",0
26814184,26814151,2,"<p>After the forward declaration and before the definition, the class <code>fruit</code> is indeed an incomplete type. </p>

<p>You can only use it in limited ways, e.g, to define pointers or references to such types, or to declare(but not define) functions that use an incomplete type as a parameter or return type. However, in your code, you are using <code>fruit</code> type, not a pointer or reference to it, so it's illegal.</p>
",0
21300047,21300002,2,"<p>You're looking at an <a href=""http://en.wikipedia.org/wiki/Integer_overflow"" rel=""nofollow"">Integer Overflow</a>. This question is asked so often here there should perhaps be a dedicated forum with this name.</p>

<blockquote>
  <p>...an integer overflow occurs when an arithmetic operation attempts to
  create a numeric value that is too large to be represented within the
  available storage space. For instance, adding 1 to the largest value
  that can be represented constitutes an integer overflow. The most
  common result in these cases is for the least significant
  representable bits of the result to be stored (the result is said to
  wrap).</p>
</blockquote>
",0
21309087,21300002,2,"<p>The range of some datatypes I've mentioned here. Check it out change your code according to requirements.</p>

<pre><code>signed char: -127 to 127
unsigned char: 0 to 255
signed short: -32767 to 32767
unsigned short: 0 to 65535
signed int: -32767 to 32767
unsigned int: 0 to 65535
signed long: -2147483647 to 2147483647
unsigned long: 0 to 4294967295
signed long long: -9223372036854775807 to 9223372036854775807
unsigned long long: 0 to 18446744073709551615
</code></pre>
",0
34233046,34232759,0,"<p>This has nothing to do with time formats.  A much smaller program that shows the same problem is:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void f(int i) {
   i = 20;
}

int main() {
    int i = 10;
    f(i);
    cout &lt;&lt; ""i is still "" &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>The problem is that <code>int i</code> in the parameter list means ""pass by value"".  The function gets a <em>copy</em> of the value.  Any changes you make to that copy are thrown away when the function exits.  Either pass by reference (<code>void f(int&amp; i)</code>) or by pointer (<code>void f(int *pi)</code>).  Look up reference and pointers in your text book.</p>

<p>There are also a number of issues in your function:</p>

<pre><code>void conversion(int hours, int minutes) {
   if (hours &gt; 12) {
       hours -= 12;
       minutes = minutes;  // This line does nothing.
   }
   else
       hours = hours;      // This line does nothing.
       minutes = minutes;  // This line will get executed even if hours was originally
                           // &gt;12.  (Only the hours=hours line is covered by the else).  

   cout &lt;&lt; hours &lt;&lt; "":"" &lt;&lt; minutes &lt;&lt; endl;
   }
</code></pre>

<p>You probably wanted:</p>

<pre><code>void conversion(int&amp; hours, int&amp; minutes) {
   if (hours &gt; 12) {
       hours -= 12;
   }
   cout &lt;&lt; hours &lt;&lt; "":"" &lt;&lt; minutes &lt;&lt; endl;
}
</code></pre>
",0
25711094,25710938,2,"<p>A floating point variable keeps a value of a given type (in memory).<br>
This value ""rests"" there with its own precision, in binary format.<br>
When this value has to be shown or <strong>output</strong> in someway, typically is converted to decimal format. This conversion can have loss of precision sometimes.  </p>

<p>Anyway, when you are doing precise arithmetica operations, as in your example, the conversion to decimal is not, in general, an issue.<br>
What it has to be understood here is that ""printing"" a value is not the same that ""showing the exact value held in memory"".  </p>

<p>The object <code>cout</code> has predefined ways to show the values you are computing.<br>
The exact value has not changed, <strong>it's not, in this case, a problem of bad computing</strong>.<br>
Indeed, <strong>it's only a matter of how to show this value on screen</strong>.  </p>

<p>The format used to print the value is: <em>in exponential notation with ""only"" 6 decimal digits precision</em>.  </p>

<p>You need to increase the precision of values when printed, and to avoid exponential notation.  </p>

<p>Take a look to this website:  <a href=""http://www.arachnoid.com/cpptutor/student3.html"" rel=""nofollow"">Output formatting in C++</a>  </p>

<p>Thus, for example, the following code do the job (for a precision of 8 decimal digits):  </p>

<pre><code>  cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(8) &lt;&lt; round(solution) &lt;&lt; ""\n"";
</code></pre>

<p>In general, you have to investigate and practice more about this formatting options.  </p>
",3
29467220,29465211,0,"<p><a href=""https://stackoverflow.com/questions/1421671/when-are-static-c-class-members-initialized"">When are static C++ class members initialized?</a> contains a great answer about this topic.</p>

<p>In short there are 3 guarantees (citing the original <a href=""https://stackoverflow.com/users/113662/tadeusz-kopec"">Tadeusz Kopec</a> answer in the above mentioned question):</p>

<ol>
<li>Objects defined in the same translation unit (usually it means .cpp file) are initialized in order of their definitions</li>
<li>Initialization of static objects from a translation unit will be done before use of any object or function from this translation unit</li>
<li>They will be initialized before main is entered.</li>
</ol>

<p>If in your specific case static variables <code>object1</code> and <code>object2</code> were not initialized this could be related to a compiler optimization omitting the initialization of unused variables. You can verify this easily by adding a usage of these variables inside main and observe whether these got initialized and when.</p>
",2
22121465,22121323,1,"<p>You have <em>no</em> definition of <code>Student::count</code>, violating the <a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow"">one definition rule</a>. Put a definition in one, and only one, translation unit.</p>

<p>Note that if <code>static int count;</code> <em>was</em> a definition, static members would be almost impossible to use. You'd wind up with a definition each time you included the header file, making the one definition rule almost impossible to comply with.</p>
",0
22121487,22121323,0,"<p>Writing <code>static int count;</code> in your header means: Compiler, somewhere you will find a variable scoped to this class, it will be a <code>int</code> and will be nammed <code>count</code>.</p>

<p>Now, you need to actually instantiate (define) your variable somewhere. Maybe in your case, adding <code>int Student::count;</code> to your main file would be fine.</p>
",0
21717194,21717133,0,"<p><code>const</code> is a promise to not change.</p>

<p>You declare a vector of pointers to <code>const</code> nodes. That's a promise to not change any <code>Node</code> via these pointers.</p>

<p>The <code>getLeaf</code> function can't very well then return a pointer to non-<code>const</code> node, because then the caller can do anything with the node.</p>

<p>So you have to make either the same promise both places, or don't make any such promise.</p>

<hr>

<p>Another matter is whether <code>getLeaf</code> itself should be <code>const</code> (it probably should, it makes sense to let it promise not to change the object), and a second other matter is whether <code>get</code> makes sense as a prefix in C++ (usually not, it's just needless verbosity, while in Java there are tools that can make good use of such of prefix), I'd just call it <code>node</code>.</p>
",2
27537982,27537956,5,"<blockquote>
  <p>and the visual studio just gived me like over 30 Errors though the code seems perfectly fine to me</p>
</blockquote>

<p>It's not fine, it's full of errors.</p>

<p>Listen to your compiler. Go to the lines it tells you have errors. Fix them.</p>

<p>For example:</p>

<pre><code>     head = head &gt; next;
</code></pre>

<p>That's clearly wrong. Fix it.</p>

<p>And this isn't valid C++:</p>

<pre><code>friend Linkedlist ;
</code></pre>

<p>it should be:</p>

<pre><code>template&lt;class T&gt; friend class LinkedList;
</code></pre>

<p>but you should declare <code>LinkedList</code> first, before you say it's a friend.</p>
",2
28248843,28248823,1,"<blockquote>
  <p>Why is it giving me an undefined reference to <code>MySet::MySet()</code> while trying to print my <code>vector</code>? </p>
</blockquote>

<p>You are creating an instance of <code>MySet</code> using</p>

<pre><code>    MySet m;
</code></pre>

<p>That uses the default constructor. The default constructor has been declared in the class but it has not been defined. You can fix it by defining it.</p>

<pre><code>MySet::MySet() {}
</code></pre>
",0
28248851,28248823,0,"<p>Your program does not include a definition for the constructor of MySet.  The constructor's name is <code>MySet::MySet()</code>.  So when you try to create an instance of the object, the compiler does not know what to do.  There are a couple solutions:</p>

<ol>
<li>Remove the line right after ""public:"" that declares the constructor.  If you don't declare any constructors, your object will just use a default constructor supplied by the compiler which might be good enough.</li>
<li>Or, add a definition for the constructor somewhere in your program.</li>
<li>Or, you can change the line that declares <code>MySet::MySet()</code> so that it <em>also</em> defines it.</li>
</ol>

<p>The code for option 2 would look like this, somewhere outside the class:</p>

<pre><code>MySet::MySet()
{
  // do stuff here to construct object
}
</code></pre>

<p>The code for option 3 would look like this, somewhere inside the class:</p>

<pre><code>MySet()
{
  // do stuff here to construct object
}
</code></pre>
",0
26441705,26441679,4,"<p>The C++ Standard has an Appendix dedicated to ""Implementation Quantities"", explained as</p>

<blockquote>
  <p>Because computers are finite, C++ implementations are inevitably limited in the size of the programs they can successfully process.</p>
</blockquote>

<p>You've exceeded your implementation's limit on the total size of variables of automatic storage duration.  (Typically knows as ""stack size"").</p>

<p>You might try using dynamic allocation instead:</p>

<pre><code>std::vector&lt;long long int&gt; v(10000000);
</code></pre>

<p>Dynamic allocations are constrained also, but the limit typically depends on the size of the largest fragment of address space, which is usually far far larger than the stack size.</p>

<p>Static storage duration as Vlad suggests also changes which limit applies, but there tend to be severe drawbacks to large objects of static storage duration (such as the executable file being several gigabytes on disk and taking minutes to load).</p>
",5
26441727,26441679,0,"<p>This array is allocated in the stack the memory of which is usually very limited. Use instead</p>

<pre><code>static long long v[10000000];
</code></pre>

<p>Or it would be better to use standard container <code>std::vector&lt;long long&gt;</code>. Moreover as it is seen from your code the actual size of the array depends on the number entered by the user. So it would be indeed better to use <code>std::vector&lt;long long&gt;</code></p>

<p>For example</p>

<pre><code>cout &lt;&lt; ""n= ""; cin &gt;&gt; n;
std::vector&lt;long long&gt; v( n );
</code></pre>

<p>or</p>

<pre><code>cout &lt;&lt; ""n= ""; cin &gt;&gt; n;
std::vector&lt;long long&gt; v;
v.reserve( n );
</code></pre>
",3
29188855,29188788,1,"<p>This is true. The subclass can use base class methods internally. But the methods of the base class would not be accessible from an instance of the derived class.</p>

<pre><code>void Subclass::baseClassMethodOverride()
{
    useBaseClassMethod(); //&lt;---- ALLOWED
}

int main()
{
    SubClass instance;
    instance.useBaseClassMethod(); //&lt;-----NOT ALLOWED
}
</code></pre>
",0
29188856,29188788,1,"<p>That's true. </p>

<p>If you have a <code>public</code> or <code>protected</code> member you can access them in the derived class irregardless of the access modifier of the inheritance</p>
",0
29188959,29188788,1,"<p>That is by definition what private inheritance is. For example, N4140 explains:</p>

<blockquote>
  <p>¡ì11.2/1 [...] If a class is declared to be a base class for another
  class using the <code>private</code> access specifier, the <code>public</code> and
  <code>protected</code> members of the base class are accessible as <code>private</code>
  members of the derived class<sup>115</sup>.</p>
</blockquote>

<p>Furthermore,</p>

<blockquote>
  <p>¡ì11/1  A member of a class can be</p>
  
  <p>¡ª <code>private</code>; that is, its name can be used only by members and friends
  of the class in which it is declared.</p>
</blockquote>

<p>The phrase ""but are not accessible through the derived class."" is a little vague, but if the intended meaning is ""can't be accessed outside of the derived class except for <code>friend</code>s"", then it's true.</p>

<p>Note: read the access specifier as appertaining to inheritance. i.e., private inheritance means what it inherits is private, not that it inherits private members.</p>
",0
31294261,31294214,2,"<pre><code>int *pValue2(pValue1);
</code></pre>

<p>is equivalent to</p>

<pre><code>int* pValue2 = pValue1;
</code></pre>

<p>Just assign to <code>pValue2</code> <code>pValue1</code> (assign to <code>pValue2</code> address of variable <code>value</code>).</p>
",0
31295452,31294214,1,"<p>The difference should be apparent if you print the pointers themselves (the addresses) in addition to the values which they reference:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    int value = 3;
    int *pValue1 = &amp;value;
    int *pValue2(pValue1);
    int *pValue3 = new int;
    cout &lt;&lt; pValue1 &lt;&lt; "" "" &lt;&lt; pValue2 &lt;&lt; "" "" &lt;&lt; pValue3 &lt;&lt; endl;
    cout &lt;&lt; *pValue1 &lt;&lt; "" "" &lt;&lt; *pValue2 &lt;&lt; "" "" &lt;&lt; *pValue3 &lt;&lt; endl;

    pValue3 = pValue1;
    cout &lt;&lt; pValue1 &lt;&lt; "" "" &lt;&lt; pValue2 &lt;&lt; "" "" &lt;&lt; pValue3 &lt;&lt; endl;
    cout &lt;&lt; *pValue1 &lt;&lt; "" "" &lt;&lt; *pValue2 &lt;&lt; "" "" &lt;&lt; *pValue3 &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>You will also see that after <code>new int</code>, the memory pointed to by the pointer contains uninitialized data.</p>
",0
25473598,25473557,1,"<p>In the beginning of your code, do you have <code>using namespace std</code>?. Because if so, the call is ambiguous. You can fix it through:</p>

<pre><code>i = ::wstring(ws);
</code></pre>
",3
25473599,25473557,0,"<p><code>namespace std</code> has the same name as a typedef for <code>std::basic_string&lt;wchar_t&gt;</code> (i.e <code>std::wstring</code>). You have a name conflict because the compiler doesn't know if you meant <code>wstring(ws)</code> as a cast-expression to a <code>std::wstring</code> object or a function call. This is why, for one, <code>using namespace std</code> is not recommended, and why giving names to objects that have similar names in the global namesapces causes ambiguity.</p>
",0
25473603,25473557,0,"<p>I am assuming you also have at the top of your file</p>

<pre><code>#include &lt;string&gt;
using namespace std;
</code></pre>

<p>This is where your ambiguous call to wstring exists. <a href=""http://www.cplusplus.com/reference/string/wstring/"" rel=""nofollow"">wstring</a> is a type declared in string and the compiler can't tell if you mean the function wstring or if you want to create an object of type wstring and convert it to an int.</p>
",0
22447330,22447304,1,"<p>This isn't specific to function parameters.</p>

<pre><code>const Employee*
</code></pre>

<p>Means a ""mutable pointer to a constant instance of <code>Employee</code>"".</p>

<pre><code>Employee* const
</code></pre>

<p>Means a ""constant pointer to a mutable instance of <code>Employee</code>"".</p>

<pre><code>const Employee* const
</code></pre>

<p>Means a ""constant pointer to a constant instance of <code>Employee</code>"".</p>

<p>See also the <a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow"">Spiral Rule</a>.</p>
",1
22447345,22447304,0,"<p>The pointer and the pointee are both constant.</p>
",0
29459629,29459572,1,"<pre><code>new entity(""entityName"")
</code></pre>

<p>means ""create an instance of <code>entity</code> in the free store and return a pointer to that instance"".<br>
Since a pointer to an <code>entity</code> is not the same as an <code>entity</code>, you cannot initialise an <code>entity</code> with that value unless you have yet another constructor.</p>

<p>The way to do what you want is</p>

<pre><code>entity cube(""entityname"");
</code></pre>

<p>And you need a good book on C++.</p>
",2
29459676,29459572,0,"<blockquote>
  <ol>
  <li>what does the error while using new mean ? (i'm pretty confident with how pointers work but not completely as i started with java.)</li>
  </ol>
</blockquote>

<p>No. C++ is different about this, you don't use an allocation (new) to initialize <code>cube</code>:</p>

<pre><code>entity cube(""entityName"");
</code></pre>

<blockquote>
  <ol start=""2"">
  <li>is it ok for me to create objects like that without the new keyword or is an object even created? (because there are no errors.)</li>
  </ol>
</blockquote>

<p>No. See above. (<em>""because there are no errors.""</em> I doubt this, there should at least be compiler warnings if you assign <code>entity</code> from a pointer.)</p>
",1
29459791,29459572,0,"<p>First, I suggest you to read a C++ tutorial. It has much more complexity than Java.</p>

<p>This is a very partial Java to C++ ""how to convert"" guide that I can give you:</p>

<p>Java code:</p>

<pre><code>void sayHello(String name) {
    system.out.println(""Hello, "" + name);
}

public static void main(String args[]) {
    String name = ""James"";  //  &lt;-- This string is of course created in the dynamic memory
    sayHello(name);   //  &lt;-- ""name"" will be passed by reference to the ""sayHello()"" method
}
</code></pre>

<p><strong>Equivalent in C++ - option 1</strong>:</p>

<pre><code>void sayHello(const std::string &amp;name) {
    std::cout &lt;&lt; ""Hello, "" &lt;&lt; name &lt;&lt; std::endl;
}

int main() {
    std::string name(""James"");  // &lt;-- Variable is created on the stack
    sayHello(name);  // &lt;-- Although ""name"" is not a pointer, it will be passed by reference to ""sayHello"", as ""name"" is defiend there with ""&amp;"", which means that it is a reference
}
</code></pre>

<p>A reference is a very ""weird"" type - it behaves like a local variable, although it actually points to an instance that does not have to be on the stack of the current function or on the stack at all.</p>

<p><strong>C++ - option 2</strong>:</p>

<pre><code>void sayHello(const std::string *name) {
    std::cout &lt;&lt; ""Hello, "" &lt;&lt; *name &lt;&lt; std::endl;  // &lt;-- dereferenceing ""name"" using a preceding star, as ""cout"" needs the variable itself and not its address
}

int main() {
    std::string *name = new std::string(""James"");  // &lt;-- Instance is created in the dynamic memory
    sayHello(name);  // &lt;-- Sending the pointer ""name"" to the ""sayHello"" function
    // You will need to free ""name"" somewhere in the code unless you don't care about memory leaks
}
</code></pre>

<p>There are more options, like passing the instance by value (not recommended in such case), or like creating it in the dynamic memory and deref</p>
",0
21322077,21321993,3,"<p>I can't comment yet but based on the error messages it seems that the compiler has not been setup properly or Eclipse cannot find it.</p>

<p><a href=""http://www.eclipse.org/forums/index.php/t/238347/"" rel=""nofollow"">http://www.eclipse.org/forums/index.php/t/238347/</a></p>

<p>Make sure Eclipse can find your compiler. </p>

<p>You may have to setup some environment variables. </p>

<p><a href=""http://www.computerhope.com/issues/ch000549.htm"" rel=""nofollow"">http://www.computerhope.com/issues/ch000549.htm</a> </p>

<p>Also try following the instruction in the error message.</p>

<p>I hope that helps.</p>
",0
21326199,21321993,0,"<p>install g++ in your system and set env path!</p>
",0
21025604,21025431,1,"<p><strong>Your <code>calcSteps.h</code> does not include the standard headers containing declarations for the standard types you use, such as <code>std::string</code>.</strong></p>

<p>This will result in, among many other error messages, the statement that ""<code>powStr</code> was not declared in this scope"" because <code>powStr</code>'s declaration simply could not be understood with those references to unknown standard types.</p>

<p>Even though you did include those headers in <code>calcsteps.cpp</code>, you did so <em>after</em> including <code>calcSteps.h</code>. Since you're absolutely right that <code>#include</code> is like a copy-and-paste, those inclusions come too late.</p>

<p>We typically include headers <em>where we need them</em> so the standard headers should be included from <code>calcSteps.h</code>.</p>

<p>I would also suggest making your filename case convention consistent, and your <code>calcSteps.h</code> inclusion guard is currently found in <code>main.cpp</code> instead &mdash; presumably a typo.</p>
",0
22877358,22877194,0,"<pre><code>int main()
{
ofstream fout(""E:\\hoss.txt"");
ifstream file(""E:\\test.txt"");
string content;
while(file &gt;&gt; content)
{
    for (size_t i = 0; i &lt; content.size(); i++)
    {
        if((content[i] == 'a') &amp;&amp; (content[i+1] == 'b'))
        {
           fout&lt;&lt;""ab"";
           break;
        }
    }
}
system(""pause"");
return  0;
}
</code></pre>
",0
22877215,22877194,0,"<p>You have no code to print anything out. You just keep adding to the buffer, but you never flush the buffer. Get rid of the <code>system(""pause"");</code> and just let the program end. Ending the program flushes all buffers.</p>

<pre><code>while (content[i] == 'ab')
</code></pre>

<p>This is pretty baffling. Did you really mean <code>ab</code> as a character constant?</p>
",2
26439553,26439521,0,"<p>Just remove the endl at the end of TimeTable for inner ""for""
and add another counter for splitter say:</p>

<p>Edit: change j with count.</p>

<pre><code> int splitter = 0;
 for (int j = 1; j &lt; 13; j++, splitter++)
 {
    cout &lt;&lt; j &lt;&lt; "" x "" &lt;&lt; count  &lt;&lt; "" = "" &lt;&lt; count*j &lt;&lt; ""\t"";
    if (splitter == 5)
    {
       cout &lt;&lt; endl;
       splitter=-1;
    }
 }


1 x 1 = 1   2 x 1 = 2   3 x 1 = 3   4 x 1 = 4   5 x 1 = 5   6 x 1 = 6   
7 x 1 = 7   8 x 1 = 8   9 x 1 = 9   10 x 1 = 10 11 x 1 = 11 12 x 1 = 12 

1 x 2 = 2   2 x 2 = 4   3 x 2 = 6   4 x 2 = 8   5 x 2 = 10  6 x 2 = 12  
7 x 2 = 14  8 x 2 = 16  9 x 2 = 18  10 x 2 = 20 11 x 2 = 22 12 x 2 = 24 

1 x 3 = 3   2 x 3 = 6   3 x 3 = 9   4 x 3 = 12  5 x 3 = 15  6 x 3 = 18  
7 x 3 = 21  8 x 3 = 24  9 x 3 = 27  10 x 3 = 30 11 x 3 = 33 12 x 3 = 36 

1 x 4 = 4   2 x 4 = 8   3 x 4 = 12  4 x 4 = 16  5 x 4 = 20  6 x 4 = 24  
7 x 4 = 28  8 x 4 = 32  9 x 4 = 36  10 x 4 = 40 11 x 4 = 44 12 x 4 = 48 

1 x 5 = 5   2 x 5 = 10  3 x 5 = 15  4 x 5 = 20  5 x 5 = 25  6 x 5 = 30  
7 x 5 = 35  8 x 5 = 40  9 x 5 = 45  10 x 5 = 50 11 x 5 = 55 12 x 5 = 60 

1 x 6 = 6   2 x 6 = 12  3 x 6 = 18  4 x 6 = 24  5 x 6 = 30  6 x 6 = 36  
7 x 6 = 42  8 x 6 = 48  9 x 6 = 54  10 x 6 = 60 11 x 6 = 66 12 x 6 = 72 

1 x 7 = 7   2 x 7 = 14  3 x 7 = 21  4 x 7 = 28  5 x 7 = 35  6 x 7 = 42  
7 x 7 = 49  8 x 7 = 56  9 x 7 = 63  10 x 7 = 70 11 x 7 = 77 12 x 7 = 84 

1 x 8 = 8   2 x 8 = 16  3 x 8 = 24  4 x 8 = 32  5 x 8 = 40  6 x 8 = 48  
7 x 8 = 56  8 x 8 = 64  9 x 8 = 72  10 x 8 = 80 11 x 8 = 88 12 x 8 = 96 

1 x 9 = 9   2 x 9 = 18  3 x 9 = 27  4 x 9 = 36  5 x 9 = 45  6 x 9 = 54  
7 x 9 = 63  8 x 9 = 72  9 x 9 = 81  10 x 9 = 90 11 x 9 = 99 12 x 9 = 108    

1 x 10 = 10 2 x 10 = 20 3 x 10 = 30 4 x 10 = 40 5 x 10 = 50 6 x 10 = 60 
7 x 10 = 70 8 x 10 = 80 9 x 10 = 90 10 x 10 = 100   11 x 10 = 110   12 x 10 = 120   

1 x 11 = 11 2 x 11 = 22 3 x 11 = 33 4 x 11 = 44 5 x 11 = 55 6 x 11 = 66 
7 x 11 = 77 8 x 11 = 88 9 x 11 = 99 10 x 11 = 110   11 x 11 = 121   12 x 11 = 132   

1 x 12 = 12 2 x 12 = 24 3 x 12 = 36 4 x 12 = 48 5 x 12 = 60 6 x 12 = 72 
7 x 12 = 84 8 x 12 = 96 9 x 12 = 108    10 x 12 = 120   11 x 12 = 132   12 x 12 = 144   
</code></pre>
",7
26439556,26439521,2,"<p>To format columns, use <a href=""http://en.cppreference.com/w/cpp/io/manip/setw"" rel=""nofollow noreferrer"">std::setw</a> from <code>&lt;iomanip&gt;</code></p>
<blockquote>
<p>Sets the field width to be used on output operations.</p>
</blockquote>
<p>now.</p>
<p>outside, iterate over the lines.</p>
<p>inside, iterate over the columns.</p>
<h2>CODE</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main()
{
    int cols_per_line = 5;
    for (int line = 1; line &lt; 13; line++)
    {
        for (int col = 1; col &lt;= cols_per_line; col++)
        {
            cout &lt;&lt; setw(2) &lt;&lt; col &lt;&lt; &quot; x &quot; &lt;&lt; setw(2) &lt;&lt; line &lt;&lt; &quot; = &quot; &lt;&lt; setw(3) &lt;&lt; line*col &lt;&lt; &quot;   &quot;;
        }
        cout &lt;&lt; endl;
    }
}
</code></pre>
<h2>OUTPUT</h2>
<pre><code>[root@rnrlabs ~]# ./a.out
 1 x  1 =   1    2 x  1 =   2    3 x  1 =   3    4 x  1 =   4    5 x  1 =   5
 1 x  2 =   2    2 x  2 =   4    3 x  2 =   6    4 x  2 =   8    5 x  2 =  10
 1 x  3 =   3    2 x  3 =   6    3 x  3 =   9    4 x  3 =  12    5 x  3 =  15
 1 x  4 =   4    2 x  4 =   8    3 x  4 =  12    4 x  4 =  16    5 x  4 =  20
 1 x  5 =   5    2 x  5 =  10    3 x  5 =  15    4 x  5 =  20    5 x  5 =  25
 1 x  6 =   6    2 x  6 =  12    3 x  6 =  18    4 x  6 =  24    5 x  6 =  30
 1 x  7 =   7    2 x  7 =  14    3 x  7 =  21    4 x  7 =  28    5 x  7 =  35
 1 x  8 =   8    2 x  8 =  16    3 x  8 =  24    4 x  8 =  32    5 x  8 =  40
 1 x  9 =   9    2 x  9 =  18    3 x  9 =  27    4 x  9 =  36    5 x  9 =  45
 1 x 10 =  10    2 x 10 =  20    3 x 10 =  30    4 x 10 =  40    5 x 10 =  50
 1 x 11 =  11    2 x 11 =  22    3 x 11 =  33    4 x 11 =  44    5 x 11 =  55
 1 x 12 =  12    2 x 12 =  24    3 x 12 =  36    4 x 12 =  48    5 x 12 =  60
</code></pre>
",3
21305712,21305666,0,"<pre><code>while (!(tmp &amp; OMAP3_MCSPI_SYSSTATUS_RESETDONE != 0))
</code></pre>

<p>if you want to avoid the warning</p>
",2
21305868,21305666,3,"<p>The MISRA rule is (quoting from a <a href=""http://www.ristancase.com/html/dac/manual/3.12.02%20MISRA-C%202004%20Rules.html"" rel=""nofollow"">third party site</a> which has to alter the rules for copyright reasons)</p>

<blockquote>
  <p>12.6 (adv): The operands of logical operators (&amp;&amp;, || and !) should be effectively Boolean. Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, || and !).</p>
</blockquote>

<p>This means that you ned to replace the expression <code>tmp &amp; OMAP3_MCSPI_SYSSTATUS_RESETDONE</code> with a boolean. In this case the correct way is to compare it to 0.</p>

<p>e.g.</p>

<pre><code>while (!((tmp &amp; OMAP3_MCSPI_SYSSTATUS_RESETDONE) != 0))
</code></pre>
",1
21305907,21305666,0,"<p>'tmp' is a 32-bit unsigned integer (uint32_t). 'OMAP3_MCSPI_SYSSTATUS_RESETDONE' is an unsigned integer. Using the '&amp;' operator is 'and'ing the bits of these together, resulting in another unsigned integer. The MISRA rule wants you to use a boolean expresison rather than an unsigned integer expression as the parameter to the '!' operator.</p>

<p>To fix this you can use</p>

<pre><code>while ( !((tmp &amp; OMAP3_MCSPI_SYSSTATUS_RESETDONE) != 0))
</code></pre>

<p>or</p>

<pre><code>while ( (tmp &amp; OMAP3_MCSPI_SYSSTATUS_RESETDONE) != OMAP3_MCSPI_SYSSTATUS_RESETDONE)
</code></pre>
",0
21581587,21581471,6,"<p>It's in the namespace containing the class.</p>

<p>However, if it's only declared in the class, then it's only available by argument-dependent lookup. So this would work, with the argument type <code>A</code> finding <code>f</code> in the surrounding namespace:</p>

<pre><code>class A {
    friend void f(A) {}
};

int main() {
    f(A());    // OK: uses ADL
    ::f(A());  // Error: doesn't use ADL, and can't find the name without it
}
</code></pre>

<p>This is often used for overloaded operators, which can only be found by ADL anyway.</p>

<p>Your version would work if you declared, rather than redefined, the function at namespace scope.</p>

<pre><code>void f();
</code></pre>
",1
21581633,21581471,-3,"<p>The friend function should only be declared, not defined, in the class. E.g. friend void f();</p>
",2
25506273,25506093,3,"<p><code>S s1 = 5;</code> and <code>S s1; s1 = 5;</code> are not equivalent. </p>

<p>The first one is a declaration that provides initializer <code>5</code> for the object <code>s1</code> being created. There is no assignment. (The <code>=</code> symbol serves different purposes in a declaration than in a statement - as does <code>&amp;</code>, <code>*</code>, etc.)</p>

<p>The second one declares s1, default-constructing it; and then calls the assignment operator. </p>

<p><code>S s1 = 5;</code> is exactly equivalent to <code>S s1 { S(5) };</code> , but the temporary <code>S(5)</code> usually undergoes copy elision.</p>
",0
21321358,21321344,3,"<p>You have the wrong syntax (which is legal, but doesn't do what you think). You need to call the base class constructor in the <em>initializaton list</em>:</p>

<pre><code>King(color_t color) : Piece(K,'K',color) {}
</code></pre>

<p>By the time you get into a constructor's body, all base classes and data members have already been initialized. If you don't initialize them explicitly, they get default initialized (which means calling the default constructor in the case fo the base class).</p>

<p>In your code, you were instantiating a local, anonymous <code>Piece</code> object.</p>
",5
23828772,23828635,7,"<p>Your code declares your class Date within the namespace std, i.e. your class fully qualified name would be std::Date</p>

<p>A statement</p>

<pre><code>using namepace std;
</code></pre>

<p>Will include the namespace std when searching for symbols.</p>

<p>Some additional notes:</p>

<ol>
<li>The standard explicitly says that adding things to the std namespace can lead to undefined behaviours making it not only a bad practice but outside of the standard. See <a href=""https://stackoverflow.com/questions/320798/adding-types-to-the-std-namespace"">Adding types to the std namespace</a> for a detailed discussion.</li>
<li>It's not a good practice to use <code>using namespace</code> on a *.h (or anything that get included in multiple files)... because it might have unexpected side-effects with symbols resolved to wrong namespaces.</li>
</ol>
",2
23828832,23828635,5,"<p>First of all: you shouldn't put anything in the <code>std</code> namespace, ever.</p>

<pre><code>namespace foo
{
  class A {};
}
</code></pre>

<p>puts the class <code>A</code> in the namespace <code>foo</code>, so its full name is <code>foo::A</code>.</p>

<pre><code>using namespace foo;
</code></pre>

<p>means that you can access all the things that are in <code>foo</code> without using the qualifier <code>foo::</code>.<br>
Note that <code>using namespace</code> is generally frowned upon and can lead to many unexpected problems.<br>
Most importantly, don't write it in headers.</p>

<p>If you say</p>

<pre><code>using namespace foo;

class A{};
</code></pre>

<p><code>A</code> is not inside <code>foo</code>, but in the global namespace.</p>
",2
28523377,28522636,0,"<p>So I figured out a way to do this. The idea is that you can take the parameter out of the function and define a pointer to that parameter.</p>

<pre><code>double param2;
double *pparam2 = param2;
double FN(double param1)
{

    //..
    double paramn;

    return some_solution
}
</code></pre>

<p>and then use a for loop when using solver updating the value of param2 through the pointer everytime as you want like</p>

<pre><code>for(int i =0; i&lt;10; i++){
*pparm2= 55+i; //say
 //and here you can use the solver without changing anything and do what //u want.
}
</code></pre>

<p>Not very elegant but it worked, any better way of doing this?</p>
",4
23083717,23083624,6,"<p>That defines <code>other_type</code> as a pointer to a member of <code>myType</code> where said member is itself a pointer to <code>myType</code>.  For example, you could use it this way:</p>

<pre><code>other_type x = &amp;myType::ptr;
myType mine;
mine.*x = &amp;mine;
</code></pre>

<p>Why you would do that, I can't say.</p>
",5
22874227,22874218,4,"<p>Most of your <code>if</code> statements are missing their opening curly-braces. This means that the completely wrong code is actually being executed by your program because only the first statement after each <code>if</code> statement will be executed if the conditional expression is true and the rest of the code will always be executed.</p>

<p>...this is the same issue as Apple's infamous <code>goto error</code> bug: <a href=""http://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/"" rel=""nofollow"">http://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/</a></p>

<p>C is not Python, indentation is not respected by the compiler and it does not mean code belongs to a certain keyword or block.</p>

<p>I strongly suggest reading up on C's syntax, and it's (generally) a good idea to always use curly-braces with all statement blocks (<code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, etc) to help avoid nasties like these. Internally, my team at Microsoft, runs a program called StyleCop which won't let us check-in code to our central repository if it contains any brace-less statements.</p>
",2
21578493,21578036,1,"<p>Not sure what you want, but following may help:</p>

<pre><code>std::ifstream in(""C:\\input.txt"");

int size;
in &gt;&gt; size;
std::vector&lt;int&gt; a(size);
</code></pre>

<p>Assuming input.txt is something like</p>

<pre><code>42
// Possible other values.
</code></pre>
",0
21578735,21578036,0,"<p>The built-in array type has a fixed size, so you can only use a compile-time constant to specify the size. You'll need a dynamic array, which is provided by <code>std::vector</code>:</p>

<pre><code>#include &lt;vector&gt;

const int arraySize = read_array_size_from_wherever();
std::vector&lt;int&gt; a(arraySize);
</code></pre>
",0
21578802,21578036,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    const char * fn = ""stat.c"";
    struct stat buf;
    stat ( fn, &amp;buf );
    std::cout &lt;&lt; ""File size: "" &lt;&lt; buf.st_size &lt;&lt; std::endl;

    int * a = new int[buf.st_size];

    // Do your processing

    delete[] a;

    return ( 0 );
}
</code></pre>
",0
29473988,29473903,13,"<p>Because you call a function using <strong><em><code>double</code></em></strong> literal, and those can be converted to either <code>int</code> <em>or</em> to <code>float</code>, and the compiler don't know which it should pick.</p>

<p>The easiest solution is to call the function with <code>float</code> literals instead:</p>

<pre><code>add(2.8f,3.1f,4.1f)
</code></pre>
",0
29520656,29520494,4,"<p><code>std::map::operator[]</code> requires the value type (or <code>mapped_type</code>) to be satisfy the DefaultInsertable concept. From [map.access]:</p>

<blockquote>
<pre><code>T&amp; operator[](const key_type&amp; x);
</code></pre>
  
  <p>Effects: If there is no key equivalent to <code>x</code> in the map, inserts <code>value_type(x, T())</code> into the map.<br>
  <strong>Requires: <code>key_type</code> shall be <code>CopyInsertable</code> and <code>mapped_type</code> shall be <code>DefaultInsertable</code> into <code>*this</code>.</strong><br>
  Returns: A reference to the <code>mapped_type</code> corresponding to <code>x</code> in <code>*this</code>.<br>
  Complexity: Logarithmic</p>
</blockquote>

<p><code>Foo</code> declares its own constructor that disables the implicit generation of a default constructor, so it's not default-constructible.</p>

<p>The solution is to either declare a default constructor or use the <code>emplace()</code> method to construct a value type in-place:</p>

<pre><code>fooMap.emplace(1, foo);
</code></pre>
",0
29520538,29520494,8,"<p>This is because <code>operator[]</code> will insert a default constructed object if the key doesn't already exist in the map.</p>

<p>You're probably looking for <code>insert</code> for non-default-constructable object types.</p>
",0
23096539,23096470,0,"<p><a href=""http://www.cplusplus.com/reference/numeric/adjacent_difference/"" rel=""nofollow"">http://www.cplusplus.com/reference/numeric/adjacent_difference/</a></p>

<ul>
<li>adjacent_difference requires an <strong>output iterator</strong> as its third parameter.</li>
<li>it <strong>returns an iterator</strong></li>
</ul>

<p>So you'll be wanting to do something like:</p>

<pre><code>auto dif_iter = adjacent_difference(prices.begin(),prices.end(),back_inserter(dif));
</code></pre>

<p>And then dif will be filled with the difference, and iter will be an iterator to where the differences begin.</p>

<p>By the sounds of it you'll want to iterate over all the differences to show the price change each day. So you'll be wanting to put that in a loop:</p>

<pre><code>for( auto iter = dif_iter; iter != dif.end(); ++iter )
{
  cout &lt;&lt; ... some information with *iter ...
}
</code></pre>
",1
23096553,23096470,0,"<p>The problem is that there is no <code>operator&lt;&lt;</code> function can insert the return value of <code>adjacent_differenc</code> to <code>std::cout</code>.</p>

<p>Did you mean </p>

<pre><code>cout&lt;&lt;""The differences in price: "" &lt;&lt; *adjacent_difference(prices.begin(),prices.end(),dif.begin())&lt;&lt;endl;
</code></pre>
",0
23097198,23096470,0,"<p><code>std::adjacent_difference</code> requires an <code>OutputIterator</code> as its third argument:</p>

<pre><code>adjacent_difference( prices.begin(), prices.end(), back_inserter(dif) );
</code></pre>

<p>You will need <code>#include &lt;iterator&gt;</code> for this.</p>

<p>It returns the same <code>OutputIterator</code>. You cannot use an OutputIterator to retrieve the values. Instead, what you want to do is print out all the entries in <code>dif</code>:</p>

<pre><code>cout &lt;&lt; ""The differences in price: "";
for (int x : dif)
    cout &lt;&lt; x &lt;&lt; "" "";
cout &lt;&lt; endl;
</code></pre>

<p>Moving on, the <code>min_element</code> and <code>max_element</code> function go through the vector looking for those elements. It's redundant to also sort the vector. You should just do one of these two options:</p>

<ul>
<li><code>sort()</code> and then output the first and last elements</li>
<li>don't sort, and use <code>*min_element</code> and <code>*max_element</code></li>
</ul>
",0
23813469,23813339,3,"<p>All of the facilities of the C standard library are still available in C++.  You can write your program like this:</p>

<pre><code>#include &lt;cstdio&gt;
using std::printf;

int main()
{
  int count = 0;
  int total = 0;

  while (count&lt;=10)
  {   
    total = total + count;
    printf(""count=%3d, total=%3d\n"", count, total); 
    count++;
  }
}
</code></pre>

<p>It is my personal opinion that the <code>stdio.h</code> output interfaces are nearly always easier to use and produce more readable code than the <code>iostream</code> output interfaces, particularly for formatted output of numbers (as in this case), so I would not hesitate to do so.  The major advantage of <code>iostream</code> is that it can be extended to format <em>objects</em> via <code>operator&lt;&lt;</code> overloads, but a program like this does not need that.</p>

<p>Note that neither the <code>stdio.h</code> nor the <code>iostream</code> <em>input</em> interfaces are fit for purpose, due to egregious, standard-codified bugs like defining numeric input overflow to trigger undefined behavior (I am not making this up!)</p>
",3
23813662,23813339,3,"<p>Using iostream formatting, you need to include the <code>iomanip</code> header and use the <a href=""http://www.cplusplus.com/reference/iomanip/setw/"" rel=""nofollow""><code>setw</code></a> and <a href=""http://www.cplusplus.com/reference/iomanip/setfill/"" rel=""nofollow""><code>setfill</code></a>, like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() {
    using namespace std;

    int count=0;
    int total=0;

    while(count&lt;=10)
    {   
        total=total+count;   
        cout&lt;&lt;""count""&lt;&lt;""=""&lt;&lt;count&lt;&lt;'\t'&lt;&lt;'\t'&lt;&lt;""total""&lt;&lt;""=""&lt;&lt;setfill(' ')&lt;&lt;setw(3)&lt;&lt;total&lt;&lt;endl;
        count++;
    }
}
</code></pre>
",2
23813701,23813339,2,"<p>You can use <code>setw</code> and <code>left</code> from <a href=""http://www.cplusplus.com/reference/iomanip/"" rel=""nofollow"">iomanip</a> to achive the effect you want.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main()
{
    int count=0;
    int total=0;

    while(count&lt;=10)
    {
        total=total+count;
        std::cout &lt;&lt; ""count = "" &lt;&lt; std::setw(15) &lt;&lt; std::right &lt;&lt; count &lt;&lt; ""total = "" &lt;&lt; total &lt;&lt; std::endl;
        count++;
    }
}
</code></pre>

<p><code>setw</code> set the with of the next ""cout impression"" (15 in this case) and <code>left</code> just set the aligment to the left.</p>

<p><strong>Note:</strong> As suggest by @Zack you can write <code>&lt;&lt; '\n'</code> at the end instead <code>&lt;&lt; endl</code>. Since <code>&lt;&lt; endl</code> is exactly the same as writing <code>&lt;&lt; '\n' &lt;&lt; flush</code> and the flush isn't necessary in this case.</p>
",8
23813778,23813339,0,"<p>In C++ IO formatting is being done either in same way as in C (since all C functionalities are in place also in C++) or with <code>std::setw</code> <code>std::setprecission</code> and other C++ <a href=""http://en.cppreference.com/w/cpp/header/iomanip"" rel=""nofollow"">manipulators</a> presented in header . </p>

<p>So either of this will be fine:</p>

<pre><code>#include &lt;cstdio&gt;

int main()
{
    int count=0;
    int total=0;

    while( count &lt;= 10)
    {
        total += count;
        printf( ""count = %3d, total = %3d\n"", count++, total);
    }
}
</code></pre>

<p>or</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main()
{
    int count=0;
    int total=0;

    while( count &lt;= 10)
    {
        total += count;
        std::cout &lt;&lt; ""count = "" &lt;&lt; std::setw(15) &lt;&lt; 
                        count++ &lt;&lt; ""total = "" &lt;&lt; total &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

<p>You can also do custom formatting by <code>imbue</code> to apply custom facet to <a href=""http://en.cppreference.com/w/cpp/header/locale"" rel=""nofollow"">locale</a> ( i.e. extend std::numpunct).</p>

<p><a href=""http://ideone.com/nHfTL6"" rel=""nofollow"">http://ideone.com/nHfTL6</a></p>
",2
23566257,23566127,5,"<p>Look at <a href=""http://en.cppreference.com/w/cpp/language/cast_operator"" rel=""nofollow"">user-defined conversion</a>.</p>

<p><strong>Example:</strong></p>

<pre><code>struct Y {};

struct X {
     operator Y() const { return ...; } 
};

int main() {
    X x;
    Y y1 = static_cast&lt;Y&gt;(x); // uses conversion operator
    Y y2 = (Y)x; // also possible, but don't use C-style casts in C++!
    Y y3 = x; // even this is possible...
}
</code></pre>

<p>With C++11 you can use the keyword <code>explicit</code> to avoid accidental implicit casting (i.e. <code>Y y3 = x;</code>):</p>

<pre><code>     explicit operator Y() const { return ...; } 
</code></pre>
",1
31300819,31300635,14,"<p>It is implementation defined, but it is typically a static vtable per class, and each instance has a vptr to the vtable for the class. The reason each instance needs the pointer is because the compiler may not know at compile time which concrete implementation a particular variable is going to be, so a pointer to the relevant vtable has to be deterministically accessible from the reference. Hence the whole point of having a vtable :)</p>
",3
31300739,31300635,4,"<p>Yes exactly. A virtual table is per class, it would make no sense otherwise. A virtual pointer is nothing. Don't use this term!</p>

<p><a href=""https://stackoverflow.com/questions/4658627/virtual-pointer"">Virtual Pointer</a></p>

<p>Just throw away your C++ and think how it would be implemented in C:</p>

<pre><code>typedef VirtualFunctionsOfAClass AClassesVTable
struct AClass {
    some_data
    AClassesVTable *vptr;
};
struct VirtualFunctionsOfAClass {
     int(*someFunc1)(struct AClass* _This, int a);
     int(*anotherFunc1)(struct AClass* _This, int a);
};

static AClassesVTable vtableOfClassA = {func1, func2};

struct AClass* constructAClass() {
    AClass* ac=malloc(sizeof(AClass));
    ac-&gt;vptr = &amp;vtableOfClassA;
    return ac;
}

void aNonVirtualMemberFunctionOfClassA(AClass* _This, more arguments)
{
     return; /* just a dummy */
}
</code></pre>

<p>And yes: With plain C you can assign function pointers to each object. But that's not the same as virtual functions in C++.</p>
",6
31300767,31300635,2,"<p>Virtual table is per class. Virtual pointer is per object. See here <a href=""http://www.go4expert.com/articles/virtual-table-vptr-t16544/"" rel=""nofollow"">http://www.go4expert.com/articles/virtual-table-vptr-t16544/</a></p>
",4
22483248,22483143,1,"<p>You have to integrate the speed value in order to get the position. So your guess is correct.</p>

<p>But that value will be unreliable as integration may deviate by large quantities.</p>

<p>Encoders should be able to provide position data themselves (counts). See if you can get them somehow. That would be the best way according to me.</p>

<p>Hope this helps.</p>
",3
21565112,21565078,8,"<pre><code> cout &lt;&lt; a &lt;&lt; ""\t"" &lt;&lt; *p &lt;&lt; endl; //output: 10 11
</code></pre>

<p>You lied to the compiler and it got its revenge. </p>

<p>With:</p>

<pre><code>const int a = 10;
</code></pre>

<p>you promised you'll never modify <code>a</code> object.</p>
",0
21565126,21565078,5,"<p>You promised not to modify <code>a</code>, and the compiler believed you. So it decided to optimise away the reading of <code>a</code>, because it trusted you. You broke your promise.</p>

<p>Having said that, a real C++ compiler won't compile your code because <code>int* p = &amp;a</code> is illegal. So perhaps you are lying to us as well. Or perhaps you need to get a real C++ compiler.</p>
",4
21565150,21565078,2,"<p>Just like Ouah said compiler has taken its revenge</p>

<p>but I disagree with you that it doesn't give any error</p>

<pre><code>const int a = 10;

int* p = &amp;a;
</code></pre>

<p>You cannot assign constant to a non constant pointer. </p>
",16
21565442,21565078,0,"<p>In C, this is <a href=""https://stackoverflow.com/questions/3801557/can-we-change-the-value-of-a-constant-through-pointers"">undefined behavior</a>. In C++, this won't compile. It's been repeated by <a href=""https://stackoverflow.com/questions/21565078/integer-pointer-to-constant-integer#comment32572203_21565150"">David Heffernan</a> multiple times but it is worth repeating. Here is the error you should get on a modern compiler:</p>

<pre><code>main.cpp:7:10: error: cannot initialize a variable of type 'int *' with an rvalue of type 'const int *'

    int* p = &amp;a;  //When compiling it generates warning ""initialization from int* to 
</code></pre>
",0
32485090,32483671,3,"<p>It appears that <code>collisionWorld</code> has longer lifetime duration than <code>contactListener</code>:</p>

<pre><code>ContactListener contactListener;
collisionWorld.SetContactListener(&amp;contactListener);
</code></pre>

<p>Are you sure that <code>collisionWorld</code> is not accessing <code>contactListener</code> after it goes out of scope? (e.g. in <code>CollisionWorld</code> dtor).</p>

<p>Try adding this at the end of the <code>run()</code> function:</p>

<pre><code>collisionWorld.SetContactListener(0);
</code></pre>
",1
24352289,21508437,0,"<p>ToDouble() needs to return a type. In this case, you want to be returning a double type. Your DoubClass should look like:</p>

<pre><code>class DoubClass {
public:
    double toDouble();

};
</code></pre>

<p>Your implementation should look like:</p>

<pre><code>double DoubClass::toDouble() {
    ...
}
</code></pre>

<p>I hope that helps.</p>

<p>Edit: I guess I shouldn't assume that a question is new just because it's on the front page... Oh well. </p>
",0
26125495,26125441,8,"<p>It means that a conditional branch in a constexpr function is allowed to use non-constant expressions (i.e. ones requiring run-time evaluation, such as throwing exceptions) as long as that branch is never taken when the function is called in a constant expression context.</p>

<p>So it's OK to call <code>check</code> to initialized the <code>constexpr</code> variable <code>val</code>, as long as the arguments to the function are constant expressions, and the condition <code>(low&lt;=i &amp;&amp; i&lt;high)</code> is true.</p>

<p>If the arguments are not constants, the function call is not a constant expression and so can't initialize a <code>constexpr</code> variable.</p>

<p>If the condition is false the function needs to take the false branch, which needs to throw an exception, which requires run-time evaluation, so the function is not a constant expression, and so cannot initialize a <code>constexpr</code> variable.</p>

<p>When the argument is a constant expression, the compiler knows at compile-time whether the branch will be taken, so as long as the condition is <code>true</code> it can completely ignore the <code>false</code> branch, and doesn't complain that throwing exceptions is impossible at compile-time.</p>

<p>When the function is called at run-time, it can have any arguments, and the <code>false</code> branch can be taken and the <code>throw</code> will be evaluated as for a normal (non-constexpr) function.</p>
",2
31829110,31828725,1,"<p>While the <code>uint32_t</code> and <code>uint8_t</code> (standard C) are accessible via <code>cstdint</code>, there is no guarantee that they actually exists. The C standard says that they should be exactly that number of bits <strong>if</strong> they exist. For example they could be missing on 36-bit and other odd platform.</p>

<p>Apart from that it's just a matter of converting by arithmetic:</p>

<pre><code>hi = (x &gt;&gt; 24) &amp; 0xFF;
ji = (x &gt;&gt; 16) &amp; 0xFF;
ko = (x &gt;&gt; 8) &amp; 0xFF;
lo = (x &gt;&gt; 0) &amp; 0xFF;
</code></pre>

<p>and similarily the other way around:</p>

<pre><code>x = (hi &lt;&lt; 24ul) | (ji &lt;&lt; 16ul) | (ko &lt;&lt; 8ul) | (lo &lt;&lt; 0ul);
</code></pre>
",1
31829173,31828725,1,"<p>The portable way to manipulate raw byte arrays is <code>std::memcpy</code> and <code>char</code> buffers.</p>

<pre><code>uint32_t toBeSent = 42;
char buffer[sizeof toBeSent];

std::memcpy(&amp;buffer, &amp;toBeSent, sizeof toBeSent);
sendBuffer(buffer);

// ...

uint32_t toBeReceived;
char buffer[sizeof toBeReceived];

receiveBuffer(buffer);
std::memcpy(&amp;toBeReceived, &amp;buffer, sizeof toBeReceived);
</code></pre>
",4
28435758,21569483,63,"<p>The dereference operator (<code>*</code>) overload works like any other operator overload. If you want to be able to modify the dereferenced value, you need to return a non-const reference. This way <code>*sp = value</code> will actually modify the value pointed to by <code>sp.pData</code> and not a temporary value generated by the compiler.</p>

<p>The structure dereference operator (<code>-&gt;</code>) overload is a special case of operator overloading. The operator is actually invoked in a loop until a real pointer is returned, and then that real pointer is dereferenced. I guess this was just the only way they could think of to implement it and it turned out a bit hackish. It has some interesting properties, though. Suppose you had the following classes:</p>

<pre><code>struct A {
    int foo, bar;
};

struct B {
    A a;
    A *operator-&gt;() { return &amp;a; }
};

struct C {
    B b;
    B operator-&gt;() { return b; }
};

struct D {
    C c;
    C operator-&gt;() { return c; }
};
</code></pre>

<p>If you had an object <code>d</code> of type <code>D</code>, calling <code>d-&gt;bar</code> would first call <code>D::operator-&gt;()</code>, then <code>C::operator-&gt;()</code>, and then <code>B::operator-&gt;()</code>, which finally returns a real pointer to struct <code>A</code>, and its <code>bar</code> member is dereferenced in the normal manner. Note that in the following:</p>

<pre><code>struct E1 {
    int foo, bar;
    E1 operator-&gt;() { return *this; }
};
</code></pre>

<p>Calling <code>e-&gt;bar</code>, where <code>e</code> is of type <code>E1</code>, produces an infinite loop. If you wanted to actually dereference <code>e.bar</code>, you would need to do this:</p>

<pre><code>struct E2 {
    int foo, bar;
    E2 *operator-&gt;() { return this; }
};
</code></pre>

<hr>

<p>To summarize:</p>

<ol>
<li>When overloading the dereference operator, the type should be <code>T&amp;</code> because that is necessary to modify the value pointed to by <code>pData</code>.</li>
<li>When overloading the structure dereference, the type should be <code>T*</code> because this operator is a special case and that is just how it works.</li>
</ol>
",0
21594498,21569483,13,"<p>The purpose of dereference operator is to dereference a pointer and returns the object reference. Hence it must return the reference. That is why it is T&amp;.</p>

<p>The purpose of referring operator (->) is to return a pointer and hence T* is returned.</p>
",2
25671135,25671055,2,"<p>Vexing parse again.</p>

<pre><code>matrix&lt;T,R,C&gt; result(); 
</code></pre>

<p>declares a function named <code>result</code> taking no parameters and returning a <code>matrix&lt;T,R,C&gt;</code>. Take out the parens.</p>

<hr>

<blockquote>
  <p>When I try to extend the class I want to return from <code>operator+()</code> and so on object of the child class.</p>
</blockquote>

<p>Then you need to give the derived class its own operators. How is a base class function supposed to know that it is actually operating on a derived class?</p>
",0
26790482,26790415,1,"<p><code>string</code> is not a C++ keyword, as <code>int</code> or <code>char</code>.</p>

<p>If you want to make it look like a keyword, you could do it via <a href=""http://msdn.microsoft.com/en-us/library/zy61y8b8%28v=VS.71%29.aspx"" rel=""nofollow""><strong>usertype.dat</strong></a>.</p>

<p>BTW, Visual Studio 2013 shows <code>string</code> as any other class (light blue on my system).</p>
",0
26790507,26790415,3,"<p>""Built-in"" types like <code>int</code>, <code>char</code> and <code>unsigned char</code> are called fundamental types in the C++ standard (¡ì3.9.1). <code>std::string</code> is not a fundamental type, it's a part of the standard library. Standard header files like <code>&lt;iostream&gt;</code> may include <code>&lt;string&gt;</code> but you shouldn't rely on this behavior and should explicitly include header files when you need them.</p>
",1
21593058,21593006,0,"<p>If you want to print the address of a pointer, cast it to a long.  Usually you'll want to print it in hexadecimal, rather than decimal-  easier to read.  You probably don't want to print &amp;this-  that would be the address where the pointer to the class is held, my guess is you want to print where the class is.  That would just be cout &lt;&lt; (long) this;</p>
",3
21593076,21593006,2,"<p>If I'm not mistaken, <code>std::cout &lt;&lt; this</code> should suffice.</p>

<pre><code>class Foo
{
public:
    void foo()
    {
        std::cout &lt;&lt; this &lt;&lt; std::endl;
    }
};

int main()
{
    Foo foo{};
    foo.foo();
}
</code></pre>
",0
21593133,21593006,0,"<p>C++ pointer is an address. It is just different terms meaning the same thing. So you do not need to get address of the 'this' pointer (which basically means ""pointer to the pointer"" or ""address of the address"")</p>

<p>std::cout &lt;&lt; this;</p>
",0
32970891,32970710,7,"<p>The simple answer is ""NO""!</p>

<p>In your case a different template instance is simply a different type.</p>

<p>If you can do something like you want, the question occurs what to do with this instance of any type. How would you later use this variable?</p>

<p>Remember: Creating a template instance is done during compile time! Running through a switch case is done in runtime.</p>

<p>Your code generates the same problem as in:</p>

<pre><code>switch (foo)
{
    case 1:
       int bar;
       break;

    case 2:
       float bar;
       break;
 }

 ??? and now how the compiler should handle two different types ???
</code></pre>

<p>Again: Template instances are different types!</p>

<p>As others already mention here, you can use a variant type which contains exactly one instance of a list of given types. And it also contains a information which type is actually stored in this variant instance.</p>

<p>But I prefer using a available implementation instead of writing my own. For this see e.g. Boost Variant <a href=""http://www.boost.org/doc/libs/1_58_0/doc/html/variant.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_58_0/doc/html/variant.html</a></p>

<p>But as a resume from my experience: If you feel that you need a variant type you have strongly prove your design. As a hint: If you need a variant type you later will see that you every time you handle this variant you have to check for the actual content. I believe that this is often a violation of a good OOP design. It can help but for my opinion it should be avoided!</p>
",3
32971030,32970710,0,"<p>I agree with @Klaus that this isn't possible in the way you like; different realizations of a template are different types, so the <code>.do_something()</code> call (which, being called on a fully realized object, not a reference or pointer where v-tables might get into the mix) can't possibly know which version of the code to call.</p>

<p>That said, the problems caused by templates can be solved by templates. Instead of having the <code>switch</code> initialize something for use in code after the <code>switch</code>, or duplicating the otherwise identical code in each <code>case</code> (effective, but ugly; violates <a href=""https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"" rel=""nofollow""><code>DRY</code></a>), have each <code>case</code> in the <code>switch</code> call a templated function that creates and uses the templated type appropriately. The remaining body of the function you wrote would migrate to this function, which is templated on the same count you used for the type, and the only action for each <code>switch</code> would be <code>return actionwrapper&lt;15&gt;(any, variables, beyond, t_var, from, current, scope, needed, to, perform, work);</code> (where non-primitive variables are ideally passed by reference, l-value or r-value, to avoid copy construction).</p>
",0
32971127,32970710,0,"<p>The reason why some variable declarations are not allowed in a switch statement is: it is illegal for switch-based control flow to jump over a variable initialisation.
if you want to use the variable outside the switch statement, declare it before the switch. </p>
",1
32971179,32970710,3,"<p>As already written in the comments, you could use a common ancestor base class:</p>

<pre><code>#include &lt;memory&gt;
#include &lt;iostream&gt;

struct RS_Base
{
    virtual void do_something() = 0;
};

template&lt;size_t n, size_t k&gt;
struct RS : RS_Base
{
    void do_something() override {
        std::cout &lt;&lt; ""n="" &lt;&lt; n &lt;&lt; ""k="" &lt;&lt; k &lt;&lt; std::endl;
    }
};


int main()
{
    int n = 15; 
    int k = 2;

    std::shared_ptr&lt;RS_Base&gt; t_var(nullptr);
    switch (n) {
        case 15:
            t_var = std::shared_ptr&lt;RS_Base&gt;(new RS&lt;15,2&gt;()); /* I want it to be outside of switch */
            break;
        case 255:
            t_var = std::shared_ptr&lt;RS_Base&gt;(new RS&lt;255,2&gt;()); /* I want it to be outside of switch */
            break;
        default:
            break;
    }

    if (t_var)
    {
        t_var-&gt;do_something();
    }
}
</code></pre>

<hr>

<p><em>Update: Example for external struct/class</em></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

//External
template&lt;size_t n, size_t k&gt;
struct RS
{
public:
    void do_something() {
        std::cout &lt;&lt; ""n="" &lt;&lt; n &lt;&lt; ""k="" &lt;&lt; k &lt;&lt; std::endl;
    }
};

//Internal
struct RSWrapper_Base
{
public:
    virtual void do_something() = 0;
};

template&lt;size_t n, size_t k&gt;
struct RSWrapper : RSWrapper_Base
{
private:
    RS&lt;n, k&gt; value;

public:
    void do_something() override
    {
        value.do_something();
    }
};

//Usage
int main()
{
    int n = 255; 
    int k = 2;

    std::shared_ptr&lt;RSWrapper_Base&gt; t_var(nullptr);
    switch (n) {
        case 15:
            t_var = std::shared_ptr&lt;RSWrapper_Base&gt;(new RSWrapper&lt;15,2&gt;()); /* I want it to be outside of switch */
            break;
        case 255:
            t_var = std::shared_ptr&lt;RSWrapper_Base&gt;(new RSWrapper&lt;255,2&gt;()); /* I want it to be outside of switch */
            break;
        default:
            break;
    }

    if (t_var)
    {
        t_var-&gt;do_something();
    }
}
</code></pre>

<hr>

<p><em>Update: Example using a template handler function</em></p>

<p>Doesn't work exactly as asked for in the question but might still be a solution for the problem.</p>

<pre><code>#include &lt;memory&gt;
#include &lt;iostream&gt;

template&lt;size_t n, size_t k&gt;
struct RS
{
    void do_something() {
        std::cout &lt;&lt; ""n="" &lt;&lt; n &lt;&lt; ""k="" &lt;&lt; k &lt;&lt; std::endl;
    }
};

template&lt;typename RS_Type&gt;
void handleRS(RS_Type t_var)
{
    t_var.do_something();
};


int main()
{
    int n = 15;
    int k = 2;

    switch (n) {
    case 15:
        handleRS(RS&lt;15, 2&gt;());
        break;
    case 255:
        handleRS(RS&lt;255, 2&gt;());
        break;
    default:
        break;
    }
}
</code></pre>
",2
32971529,32970710,-2,"<p>Language-specific considerations aside, I want to approach with something different; which is called <strong>object posing</strong> in Objective-C.</p>

<p>You can introduce any instance of any class as some instance of some class, like so:</p>

<pre><code>switch (someInstance) {
    case a:
    [ClassWillBePosed poseAsClass: [AClass class]];
    break;
    case b:
    [ClassWillBePosed poseAsClass: [BClass class]];
    break;
    default:
    ...
}
</code></pre>

<p>However, I doubt it is a solution.</p>
",0
27120389,27120349,1,"<p>you need to keep <code>pars</code> as a member and initialize it as:</p>

<pre><code>class myclass
{
private:
  std::vector&lt;double&gt; pars;
}
</code></pre>

<p>...</p>

<pre><code>pars = std::vector&lt;double&gt;(1000,some_value);
</code></pre>
",2
27120435,27120349,0,"<p>You will want to change <code>pars</code> to a member variable as below.</p>

<pre><code>class myclass {
public:
    myclass();
    double method(int i);

private:
    std::vector&lt;double&gt; m_pars;
    double myclass::method(int i);
};

double myclass::method(int i) {
    return this-&gt;m_pars.at(i); 
}
</code></pre>

<p>Consider using the constructor of <code>std::vector</code> or <code>std::fill</code> instead of looping over the values.</p>
",0
27120474,27120349,2,"<h3>Main issue</h3>

<p>In your constructor:</p>

<pre><code>myclass::myclass() {       
    std::vector&lt;double&gt; pars(1000);
    for (int i = 0; i &lt; 1000; i++) {
    pars.at(i) = some_value;
    }
}
</code></pre>

<p>you are declaring a local <code>pars</code> object, which is therefore only shared within the constructor block and not the entire class. </p>

<p>I can see other language influences in this, but in C++ class members must be declared in the class declaration/definition itself:</p>

<pre><code>class myclass {
private:
    std::vector&lt;double&gt; pars;
public:
    ...
};
</code></pre>

<p>Then in your constructor you can use an <em>initializer list</em> to pass arguments to the member constructor:</p>

<pre><code>myclass::myclass() : pars (1000) { ... }
//                 ^^^^^^^^^^^^^
</code></pre>

<h3>Some tips</h3>

<p>Please notice that in C++ you don't need to prefix member variable access with <code>this-&gt;</code>.</p>

<p>And finally, you can use <code>std::vector</code>'s constructor to generate <code>n</code> copies of a certain element:</p>

<pre><code>myclass::myclass() : pars (1000, element) { ... }
</code></pre>

<p>in alternative you can use <a href=""http://en.cppreference.com/w/cpp/algorithm/fill"" rel=""nofollow""><code>std::fill</code></a> in <code>&lt;algorithm&gt;</code> to fill the entire container once it is created:</p>

<pre><code>std::fill(pars.begin(), pars.end(), element);
</code></pre>
",0
34235652,34235626,3,"<p>Not surprising.  You start with d=2.43, and tell the program to repeat <em>while</em> it is lesser than or equal to 0.  So you never repeat.</p>
",0
34235658,34235626,2,"<p>The reason that your loop does not run is this condition:
d&lt;=0.
d is initialized to 2.43. The first condition it checks to enter the loop is d&lt;=0. Obviously,2.43 is not less than 0. So it never enters the loop.</p>

<p>Hope that helps.</p>
",0
23066719,23066659,2,"<p>You are reading in the data wrong. First, you read in all the data to <code>next</code> to increment <code>count</code>. Then you try to read in the nonexistent data with you <code>for</code> loop. I recommend that you use <code>std::vector</code> to avoid the problem of dynamic memory allocation;</p>

<pre><code>vector&lt;double&gt; mydata;
while(myfile&gt;&gt;next)
{
    mydata.push_back(next);
}
</code></pre>

<p>The other easiest solution is just to put the number of elements in the file. Ex:</p>

<p>File:</p>

<blockquote>
  <p>4 1 4 6 7</p>
</blockquote>

<p>And read <code>N</code> from the file and use your for loop</p>
",0
21587682,21587631,2,"<p>You cannot write code outside of a function. Maybe some function definition was accidentally deleted starting from line 69.</p>
",0
21587731,21587631,0,"<pre><code>const char *portname = ""/dev/ttyUSB1"";
 70 
 71 int fd = open (portname, O_RDWR | O_NOCTTY | O_SYNC);
 72 
 73 if (fd &lt; 0)
 74 {
 75         cout&lt;&lt; ""error"" &lt;&lt; endl;

 76         return;
 77 }
 78 {
 79 set_interface_attribs (fd, B115200, 0);  // set speed to 115,200 bps, 8n1 (no parity)
 80 set_blocking (fd, 0);                // set no blocking
 81 
 82 write (fd, ""hello!\n"", 7);           // send 7 character greeting
 83 char buf [100];
 84 int n = read (fd, buf, sizeof buf);
 85 }
</code></pre>

<p>This part of code is outside any function which is not allowed. Maybe you wanted to write this in main() ...</p>
",0
21587737,21587631,0,"<p>It looks like you have some formatting problems. Your curly (<code>{}</code>) brackets do not match, and you have several commands that are outside of any function. </p>

<p>You likely deleted a line of code somewhere. I recommend putting all of the code after line 68 into a function.</p>
",0
23097455,23097433,0,"<p>Store the data as a private member of your class:</p>

<pre><code>private std::string data;
void loadAndPrint::load()
{
    in_file.open(""infile.txt"");
    in_file &gt;&gt; data;
}
void loadAndPrint::print()
{
    ofstream out_file(""outfile.txt"");
    if(!out_file.is_open()) throw myError;
    out_file &lt;&lt; data;
}
</code></pre>
",1
23097503,23097433,0,"<p>You could pass the fstream by reference to the second function. That keeps you from having to make a private variable.</p>

<p>Edit:</p>

<p>Without being able to see the entire class, I can't be sure, but it looks like your instructor wants you to use NTCAs for this assignment. Without just giving you the entire answer, take a look at this article and see if it answers your question:</p>

<p><a href=""http://www.cplusplus.com/doc/tutorial/ntcs/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/ntcs/</a></p>
",4
22130684,22130350,1,"<p>You have in class A a non-static data member declared as</p>

<pre><code>const std::string
</code></pre>

<p>that is with the qualifier const. In this case the implicit copy assignment operator is defined by the compiler as deleted.</p>
",4
22130754,22130350,1,"<p><code>const</code> members don't mix well with copy assignment operators. Not only won't the compiler generate one for you, it would also be semantically hard to come up with an ""assignment"" which does not actually assign everything.</p>

<p>Nothing stops you from writing an assignment operator which does not assign to your <code>const</code> member, of course, but that would mean one of two things:</p>

<ol>
<li>The assigned object does not appear to the client as an identical copy of the source, which is not what one would except from a copy assignment operator, so that would be a case of operator-overloading abuse.</li>
<li>The member variable does not have an observable effect to the outside. In that case, one must wonder why it exists in the first place, or rather why it is not <code>mutable</code> rather than <code>const</code>.</li>
</ol>
",0
26442928,26442865,1,"<p>You need to convert int to string first. Replace <code>id</code> with <code>std::to_string(id)</code>.</p>
",0
26442932,26442865,3,"<pre><code>// C++98

Ship() {
  std::ostringstream tmp;
  tmp &lt;&lt; ""Pirate"" &lt;&lt; ++id;
  name = tmp.str();
}

// C++11

Ship() : name(""Pirate"" + std::to_string(++id)) {}
</code></pre>
",0
26442936,26442865,2,"<p>If data member name has type <code>std::string</code> then you can write</p>

<pre><code>this-&gt;name = ""Pirate"" + std::to_string( id );
</code></pre>
",4
23107695,23107577,2,"<p>Use</p>

<pre><code>int m = fsm.a.template extract&lt; events::A::A_int &gt;();
</code></pre>

<p>Related: <a href=""https://stackoverflow.com/questions/1840253/c-template-member-function-of-template-class-called-from-template-function"">template member function of template class called from template function</a></p>
",0
23831327,23830767,0,"<p>Copy constructors are important for quite the same reasons as a regular constructor would be, and that is to properly initialize the constructed object. Construction is not always trivial, and it doesn't matter where do you take the data from and in what form - other object of the same class or a set of simpler arguments.</p>

<p>Therefore copy constructor is there to solve problems like initializing const fields, but also when you use pointers, to decide on ownership of the pointed resource. You may want to share, or duplicate the data. </p>
",0
23831467,23830767,1,"<h2>What is a copy constructor?</h2>

<p>Quoting the C++11 standard, ¡ì12.8/2:</p>

<blockquote>
  <p>&ldquo;A non-template constructor for class <code>X</code> is a copy constructor if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>,
  <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters
  have default arguments&rdquo;</p>
</blockquote>

<p>So there are 4 different forms. Of these the <code>X const&amp;</code> form is the one most often used. This is also the form of the <strong>implicit copy constructor</strong> that is generated (if possible) if no copy constructor is declared for the class.</p>

<p>A copy constructor is used for copying an object to a new instance of the class. A default copy constructor performs a member-wise copy, which is different from and more safe than just copying the bits. In particular a copy constructor or move constructor is logically used for a <em>copy initialization</em>, an initialization using the <code>=</code> sign like</p>

<pre><code>Some_type x = expression;
</code></pre>

<p>In some circumstances the compiler is allowed to assume that copying is all that a copy constructor does, regardless of what it actually does.  Logically needless copy constructions can then be removed, or as the standard calls it, <em>elided</em>. For example, if the expression above is the number 42, then instead of using that argument to construct a temporary and copying or moving that to <code>x</code>, the argument may be used to initialize <code>x</code> directly.</p>

<p>However, even when that is done, so that the copy constructor is not used, if the copy constructor <em>would</em> have been used except for the optimization then a copy constructor must exist and be accessible.</p>

<p>C++11 ¡ì12.2/1:</p>

<blockquote>
  <p>&ldquo;Even when the creation of the temporary object is unevaluated (Clause 5)
  or otherwise avoided (12.8), all the semantic restrictions shall be respected as if the temporary object had
  been created and later destroyed.&rdquo;</p>
</blockquote>

<p><hr></p>

<h2>Is it necessary to call a destructor?</h2>

<p>Re &ldquo;Is it necessary to call a destructor if we [use a copy constructor]? &rdquo;.</p>

<p>Generally no.</p>

<p>Destructors in C++ are called automatically when an object goes out of scope or when it's indirectly or directly destroyed via <code>delete</code>. The only exception is for placement new, which is a low level feature that has nothing in particular to do with copy constructors. Although placement new can involve copy construction.</p>

<hr>

<h2>A difference between C++03 and C++11 copy constructors.</h2>

<p>To understand the difference between C++03 and C++11 regarding copy constructors you must be aware of three facts:</p>

<ul>
<li><p>If a copy constructor isn&rsquo;t declared, then it&rsquo;s generated if possible. Hence by default every class has a copy constructor. It&rsquo;s there.</p></li>
<li><p>Access is independent of overload resolution.<br>
Overload resolution chooses between all member functions, regardless of whether they&rsquo;re accessible or not. Then access is checked. At that point you may get an error message about calling an inaccessible function, despite an expectation that overload resolution ideally should choose only from the accessible functions&hellip;</p></li>
<li><p>An ordinary function (or just function) is a better match than a an instantiation of a function template with the same signature.</p></li>
</ul>

<p>Here is an example of overloading resolution choosing a <code>private</code> member function, in spite of a <code>public</code> function that <em>could</em> be called:</p>

<p>
File [<i>access_versus_overload_resolution.cpp</i>]<br>
</p>

&nbsp;

<pre><code>class C
{
public:
    void foo( double );
    void foo( int );

    void bar( double );
private:
    void bar( int );
};

int main()
{
    C().foo( 42 );      // OK.
    C().bar( 42 );      //! Uh oh, inaccessible.
}
</code></pre>

<p>And here is an example of an ordinary function trumping a template instantiation:</p>

<p>
File [<i>function_versus_template.cpp</i>]<br>
</p>

&nbsp;

<pre><code>using One = char[1];
using Two = char[2];

auto foo( char const* ) -&gt; One&amp;;
auto foo( char const (&amp;)[10] ) -&gt; Two&amp;;

auto bar( char const* ) -&gt; One&amp;;

template&lt; int n &gt;
auto bar( char const (&amp;)[n] ) -&gt; Two&amp;;

#include &lt;iostream&gt;
auto main() -&gt; int
{
    using namespace std;
    //cout &lt;&lt; sizeof( foo( ""Blah blah"" ) ) &lt;&lt; endl;       //! Ambiguous
    cout &lt;&lt; sizeof( bar( ""Blah blah"" ) ) &lt;&lt; endl;       // ""1""
}
</code></pre>

<p>With these facts at hand:</p>

<ul>
<li><p>An inaccessible copy constructor will be chosen even if there is an accessible member function template that is just as good a match.<br>
(As a logical consequence of the general overload resolution rules.)</p></li>
<li><p>In C++11, a member function template instantiation will therefore be chosen only if it is a better match than the copy constructor, if any.</p></li>
<li><p>But in C++03 there was a special rule that ensured that <em>with a conforming compiler</em> a function member template would never be used to copy an object.</p></li>
</ul>

<p>Here&rsquo;s the C++03 wording, ¡ì12.8/3 in that standard, where I&rsquo;ve added suitable emphasis:</p>

<blockquote>
  <p>&ldquo;A declaration of a constructor for a class <code>X</code> is ill-formed if its first parameter is of type (optionally cv-
  qualified) <code>X</code> and either there are no other parameters or else all other parameters have default arguments. <b><i>A
  member function template is never instantiated to perform the copy of a class object to an object of its class
  type.</i></b></p>
</blockquote>

<p>while in C++11 the wording is subtly changed, in that standard&rsquo;s ¡ì12.8/6, where again I&rsquo;ve added suitable emphasis:</p>

<blockquote>
  <p>&ldquo;A declaration of a constructor for a class <code>X</code>is ill-formed if its first parameter is of type (optionally cv-qualified)
  <code>X</code> and either there are no other parameters or else all other parameters have default arguments. <b><i>A member
  function template is never instantiated to produce such a constructor signature.</i></b>&rdquo;</p>
</blockquote>

<p>I.e. no special injunction against function templates being used to copy objects in C++11.</p>

<p>Unfortunately for history buffs, the most readily available C++03 compiler for Windows, namely MinGW g++ of some old version such as 3.2, does not enforce the C++03 rule.</p>

<p>
File [<i>template_versus_cc.cpp</i>]<br>
</p>

&nbsp;

<pre><code>class S
{
private:
    S( S const&amp; );  // No such.

public:
    S() {}

    template&lt; class T &gt;
    S( T&amp; ) {}
};

int main()
{
    S sm;
    S const sc;

    S s1( sm );     // OK in C++11, template is better match.
    S s2( sc );     //! Line 19. Copy constructor is selected, inaccessible.
}
</code></pre>

<p>Compiling with old g++:</p>

<pre>
[H:\dev\test\copy_construction]
&gt; <b>\bin\MinGW_3_1\bin\g++ --version | find ""++""</b>
g++ (GCC) 3.2.3 (mingw special 20030504-1)

[H:\dev\test\copy_construction]
&gt; <b>\bin\MinGW_3_1\bin\g++ -std=c++98 -pedantic template_versus_cc.cpp</b>
template_versus_cc.cpp: In function `int main()':
template_versus_cc.cpp:4: `S::S(const S&)' is private
template_versus_cc.cpp:19: within this context

[H:\dev\test\copy_construction]
&gt; _
</pre>

<p>By the C++03/C++98 rules the compiler should have flagged both copy initializations, at lines 18 and 19, but only flagged the latter, behaving as a C++11 compiler in this respect.</p>

<p>This is also what the more modern g++ 4.8.2 does, as well as Visual C++ 12.0. But a conforming C++03-compiler must diagnose both initializations.</p>

<p>Scott Meyers has <a href=""http://scottmeyers.blogspot.no/2012/10/copying-constructors-in-c11.html"" rel=""nofollow"">written about this</a>, citing two of the SO C++ Lounge dwellers as sources. Unfortunately the article yields the impressions that (1) it&rsquo;s all about universal reference template arguments in C++11, and (2) there&rsquo;s is no bug in g++. The former is wrong, as shown above, while the latter is literally correct. There <em>was</em> a bug, but as the standard has evolved, with C++11 the g++ behavior is now conforming&hellip;</p>
",0
21157324,21152699,2,"<p>You need to use the correct SFML package. Errors with <code>gxx_personality_v0</code> usually indicate a runtime library mismatch. If you're really using Code::Blocks 12.11 with the compiler they ship with, then you'll have the TDM 4.7.1 compiler, which uses the SJLJ exception model. Thus the matching compiler from the SFML <a href=""http://www.sfml-dev.org/download/sfml/2.1/"" rel=""nofollow"">download page</a> would be <code>GCC 4.7 TDM (SJLJ) - 32 bits</code>.</p>

<p>Keep in mind that there's a newer <a href=""http://www.codeblocks.org/downloads/26"" rel=""nofollow"">Code::Blocks</a> version (13.12), which uses a newer version of TDM, but for which SFML doesn't provide binaries/pre-compiled packages, thus you'd have to build SFML yourself.
While the TDM compiler is easy to install, I wouldn't recommend it, since it breaks the standard way of using GCC-like compilers. Instead you might want to look at Stephan T. Lavavej's build over at <a href=""http://nuwen.net/mingw.html"" rel=""nofollow"">nuwen.net</a> or go with <a href=""http://sourceforge.net/projects/mingwbuilds/files/host-windows/"" rel=""nofollow"">MinGW Builds</a> - for each you'll have to recompile SFML.</p>
",1
21593993,21593979,0,"<p>It's a map of <code>int</code> to <em>pointer</em> to <code>std::vector&lt; RAddr &gt;</code>. The <code>*</code> is not a dereference operator, it signifies a pointer type.</p>
",0
21593997,21593979,0,"<p>That is not the <em>dereference</em> operator, but rather a declaration of a pointer type. The map binds an <code>int</code> to a <code>std::vector&lt;RAddr&gt;*</code>, that is a pointer to a vector of <code>RAddr</code></p>
",0
21729891,21729512,1,"<p>In your <code>isempty()</code> method, you're not returning a value if the stack ISN'T empty.</p>

<pre><code>....

int isempty()
{
    int i = 1;
    if(empty())
    {
        return i;
    }
}

....
</code></pre>

<p>In the above, you're missing a return statement if <code>empty()</code> returns <code>false</code>. This will result in undefined behaviour. On the face of it, this undefined behaviour looks like it results in a miscellaneous non-zero integer being returned.</p>

<p>I would just use the <code>empty()</code> method, and get rid of the <code>isempty()</code> method altogether.</p>
",0
26121587,26115551,0,"<p>You could also take advantage of stream conversion, for a less efficient but simpler solution:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {

    string months[] = {"""", ""January"", ""February"", ""Mars"", ""April"", ""May"", ""June"", ""Jully"", ""August"", ""September"", ""October"", ""December""};

    cout &lt;&lt; ""Enter a date (mm/dd/yyyy): "" &lt;&lt; endl;
    char c;
    int day, month, year;
    cin &gt;&gt; day &gt;&gt; c &gt;&gt; month &gt;&gt; c &gt;&gt; year;
    // error handling is left as an exercice to the reader.
    cout &lt;&lt; months[month] &lt;&lt; "" "" &lt;&lt; day &lt;&lt; "", "" &lt;&lt; year &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
26115868,26115551,2,"<p>As Red Serpent wrote in the comments: Search for the <code>/</code> using <a href=""http://en.cppreference.com/w/cpp/string/basic_string/find"" rel=""nofollow""><code>std::string::find</code></a>, e.g.</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    std::string date = ""09/28/1983"";

    int startIndex = 0;
    int endIndex = date.find('/');
    std::string month = date.substr(startIndex, endIndex);

    startIndex = endIndex + 1;
    endIndex = date.find('/', endIndex + 1);
    std::string day = date.substr(startIndex, endIndex - startIndex);

    std::string year = date.substr(endIndex + 1, 4);

    std::cout &lt;&lt; month.c_str() &lt;&lt; "" "" &lt;&lt; day.c_str() &lt;&lt; "","" &lt;&lt; year.c_str() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",0
22120029,22119896,1,"<blockquote>
  <p>Should I also put functions which are not part of the my class in separate cpp file??</p>
</blockquote>

<p>if those functions are not strictly used only by your class then yes, ie. if they can be used in different projects, then it makes sense to put them in separate .cpp file.</p>

<blockquote>
  <p>Actually some of my functions of class are also using other function not included in the class function. So should I put all the functions including and not including in separate cpp file????? </p>
</blockquote>

<p>hard to understand, but as above if those functions are only for your class use, then put them in .cpp file that contains implementation for your class methods. </p>

<p>Actually if you put some declarations in header file <code>a.h</code> then you also put their definitions into <code>a.cpp</code>. This is not a strict rule, you can put declarations in 'a.h' and 'b.h' while put all the definitions in <code>c.cpp</code>, but then its hard to find where which function is declared. If you know that declaration is in <code>a.h</code> then you simply look for definition in <code>a.cpp</code>.</p>
",2
22128554,22127849,0,"<p>Every scope has exit points. You make use of this and destructors to implement the <a href=""http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Resource_Acquisition_Is_Initialization"" rel=""nofollow"">RAII</a> idiom. Since you have no class to wrap your data in, you can use the <a href=""http://www.boost.org/doc/libs/1_55_0/libs/scope_exit/doc/html/scope_exit/tutorial.html"" rel=""nofollow"">boost</a> library to define actions to be taken on scope exit. </p>

<pre><code>{ // some scope, maybe that of a main function
    double *new_ar = new double[15];
    BOOST_SCOPE_EXIT(new_ar) {
        delete[] new_ar;
    } BOOST_SCOPE_EXIT_END
} // end of scope
</code></pre>
",0
22127869,22127849,1,"<p>The program itself doesn't have a destructor. It starts at the beginning of <code>main</code> and ends at the end of <code>main</code>. If you need to deallocate some memory you allocated at the beginning of <code>main</code>, you should do it before <code>main</code> ends:</p>

<pre><code>int main() {
  int* arr = new int[10];

  // Do lots of work

  delete[] arr;
}
</code></pre>

<p>Of course, it would be much better if you encapsulated this memory allocation inside a class using RAII, so that you don't have to deal with it manually. In fact, types already exist for this - the standard library containers (such as <code>std::vector</code> or <code>std::array</code>).</p>
",3
26441019,26440982,0,"<p>Probably you fail on the user input.
You have to input the whole Path if you do it the way this code works and i guess you just type the executable.
A path would look like this</p>

<pre><code>""C:\\Users\\Administrator\\Desktop\\Programme\\bla.exe""
</code></pre>

<p>You should check if the the try to open the file successes.</p>
",2
30410224,30410111,2,"<p>You should move the default value (below) to header file</p>

<pre><code>CreatureStack::CreatureStack(Creature* creature, CreatureStack* nextArg = NULL)
</code></pre>
",1
29251730,29251674,2,"<p>Either the numerator or the denominator of the division has to be a <code>double</code> to get a <code>double</code> result:</p>

<pre><code>total_in_dollar=(double(total_in_penny)/100);
</code></pre>
",0
29251818,29251674,1,"<p>Please don't use <code>double</code> to represent monetary types. See <a href=""https://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency"">Why not use Double or Float to represent currency?</a> for more information.</p>

<p>Instead, try this:</p>

<pre><code>int total_cents = 305;
int total_dollars = total_cents/100;
int fractional_dollars = total_cents%100;
std::cout &lt;&lt; total_dollars &lt;&lt; ""."";
std::cout.width(2);
std::cout.fill('0');
std::cout &lt;&lt; fractional_dollars &lt;&lt; std::endl;
</code></pre>

<p>It prints <code>3.05</code>.</p>
",0
22435339,22435287,3,"<p>Declare anything that is needed outside of the code in the .cpp file in the header file, and no more. Try to minimise the amount in there as much as possible. The reason for this is that other programmers could be looking at your header (.h) file, it is essentially their API. As an OOP programmer you want to hide as much of the internal workings of your objects as possible i.e. you do not want people using your API to become dependent on factors that may change as the structure of the objects does. Also try and keep the scope of your variables as low as possible. It is better to avoid global variables if you can in general. Passing them as parameters is almost always a better idea. Try to keep variables in the lowest scope possible.</p>
",2
22435480,22435287,0,"<p>In C and C++, the order in which things are declared is important.  Remember that when these languages were designed - compilers were not what they are today.  Header files are things that you ""include"" which <em>describe</em> classes, type-definitions, enums.  Now, you can provide implementation (and in the case of C++ template classes, you <em>have</em> to) in the header file.  You put the <em>implementation</em> of the stuff in to the <code>.cpp</code> file.  You're not writing a function twice (the compiler will have a hissy-fit if you do).  You declare <em>or</em> implement them in the header file and then, in the case of the former, you implement them in the C++ file.</p>

<p>Consumers of your code (in a library project, for example), will include the header files (that describe the classes), and then <em>link</em> against an object file (as opposed to <code>.cpp</code> files).  Header files provide you, ahead-of-time, the symbols to expect and link against.</p>

<p>Templates are a little weird in this respect (you don't export them), they are header file only (at the moment, I believe).</p>

<p>Modern languages such as C# do not have the concept of header files, because of the way the compiler works.  The C# compiler looks at the files as a ""whole"" and therefore there is no need to forward declare anything or worry about header files.  C/C++ compilers do not do this.  I am unsure (without going and looking it up) whether or not this was due to compiler technology at the time or a concsious design decision at the time.</p>

<p>You are not duplicating code.</p>
",0
22435486,22435287,2,"<p>Typically you would have your <em>declarations</em> inside a header file, and your <em>definitions</em> inside the cpp. There are many benefits to doing this, one of the biggest being re-usability. If you have multiple files that need to use a certain class, it is much easier to just include it where needed rather than having to re-declare it.</p>

<p>Being able to separate prototypes from the actual member bodies is also quite useful. This allows you to do things such as having a binary version of the implementation, and still keep the function names publicly available. This way if someone was using your class or library they could see how to use it, but not be able to see how it actually works. This is very important in larger projects and when copyright is involved.</p>

<p>This is a good habit to get into, but can get confusing and overwhelming if you don't stay organized. Common practice is to have an implementation file (.cpp) and a header (.h) for each class, both generally having the same name as the class to improve readability.</p>

<p>You should avoid using a header file just to declare local variables as it's generally best to keep them in the scope where they're needed.</p>
",0
22435533,22435287,1,"<p>Benefits of having a separate .h and .cpp file</p>

<ol>
<li><p><strong>Hide Implementation:</strong> You can separate the declaration from definition. So say you want to create an API, you could put your actual logic in .cpp (which becomes the library file on compilation) and have the declaration in .h which someone one could use to access the API.</p></li>
<li><p><strong>Reduce Compilation time:</strong> One benefit of having definition in .cpp and declaration in .h is when you want to make changes to the definition. Such a change, would just change the cpp file and that .cpp will have to be recompiled. If the definition were to be in .h file, all the .cpp files where the .h file is included would have to be recompiled which would take more time. </p></li>
<li><p><strong>Improves Readability:</strong> Having declaration and definition separate in some ways improves readability.</p></li>
</ol>

<p>One of the reasons we have separate header and source files in C++ is because C++ code is unmanaged . It is directly executed by the processor (unlike C#, Java which are executed in a virtual environment). This requires having a header file to hold the symbol information which while being separate from the implementation, acts as an interface to it.</p>
",0
22435770,22435287,1,"<p>As for your particular sample, you can avoid putting class private methods into the header file using the <a href=""http://en.wikipedia.org/wiki/Opaque_pointer"" rel=""nofollow""><strong>Pimpl Idiom</strong></a>. You'll have only publicly visible (<code>public</code>/<code>protected</code>) members declared in your header file, all the rest goes to the <code>.cpp</code>:</p>

<p><code>.h file</code>:</p>

<pre><code>class ClassA {
public:
    ClassA();
    ~ClassA();
    void foo();
private:
    class ClassAImpl;
    ClassAImpl* pImpl;
};
</code></pre>

<p><code>.cpp file</code>:</p>

<pre><code>#include ""ClassA.h""

struct ClassAImpl
    void function() {
        // ...do something...
    }
};

ClassA::ClassA() 
: pImpl(new ClassAImpl()) {
}

ClassA::~ClassA() {
    delete pImpl;
}

void ClassA::foo() {
     pImpl-&gt;function();
}
</code></pre>
",2
21722875,21722705,1,"<blockquote>
  <p>Why is the second output giving double numbers?</p>
</blockquote>

<p>Because you are giving double input. If you type ""A&lt;enter&gt;"" then the first character is <code>A</code> and the second character is the enter. That causes your loop to output then repeat, resulting in two outputs.</p>

<p>Since your code does <em>not</em> expect an enter between inputs, you should not type one. Type all the answers on the same line and the code will work fine. Alternatively, change the code to <strong>silently</strong> ignore line ending characters.</p>
",2
28492626,28492596,1,"<p>Since <code>data</code> is the only <code>int</code> in your example, I will go ahead and assume that the error is on this line</p>

<pre><code>n-&gt;data = data;
</code></pre>

<p>So your <code>node</code> struct has something like this in it:</p>

<pre><code>struct node
{
 //Nodey stuff
 int* data;
};
</code></pre>

<p>Thus, <code>n-&gt;data = data;</code> makes no sense. You meant to do <code>*(n-&gt;data) = data;</code>.</p>

<p>EDIT : As T.C. points out in the comments, this solution assumes that you have indeed allocated space for <code>node::data</code>. A cleaner solution is to make <code>node::data</code> an <code>int</code> like this:</p>

<pre><code>struct node {
int priority;
int data;
node *next;
node *prev;
};
</code></pre>

<p>Now, you don't need to change <code>DLList::addNode</code>. <code>n-&gt;data = data</code> will work fine.</p>
",2
28492681,28492596,0,"<p>Alright, I feel kind of dumb now for missing it! Thank you for all who commented. The issue was the fact that the data was declared as <code>int *data</code> I removed the * from data and the code now works! Thank you all for your responses, I appologise for the dumb problem...</p>
",0
26129729,26129708,2,"<p>You need to use semicolons instead of commas to separate the three expressions in the <code>for</code> loops:</p>

<pre><code>            for(state,state&gt;0,state--){
                     ^-------^ Change these to ;
</code></pre>
",1
23303997,23303965,0,"<p>It declare the copy constructor private, so that object cannot be copied. See: <a href=""https://stackoverflow.com/questions/6811037/whats-the-use-of-the-private-copy-constructor-in-c"">What&#39;s the use of the private copy constructor in c++</a></p>
",0
23304013,23303965,0,"<p>You need to buy a book on c++. </p>

<p>C and C++ are two distinct languages that happen to share 13 keywords.</p>

<p>The '&amp;' means 'reference'. Kind of like a pointer but more restrictive.</p>
",0
23304028,23303965,0,"<p>That line is a <a href=""http://en.wikipedia.org/wiki/Copy_constructor"" rel=""nofollow noreferrer"">copy constructor</a> which is called when you assign an object to another object of the same type. Since it's declared as private in this case, it means that copy constructor will not be called outside the class. Well, that's the point for a singleton, isn't it?</p>

<p>The '&amp;' on the other hand is called reference. Your copy constructor takes a Singleton reference as a parameter. See <a href=""https://stackoverflow.com/questions/6877052/use-of-the-operator-in-c-function-signatures"">this question</a> to understand how reference operator is used.</p>

<p>I recommend reading a C++ book for understanding references and classes in more depth.</p>
",0
23304030,23303965,0,"<p>In a parameter, const means that the method promises not to alter this object. <code>&amp;</code> means that it is a reference.</p>
",0
21024646,21024591,3,"<p><code>std::replace</code> is <a href=""http://en.cppreference.com/w/cpp/algorithm/replace"" rel=""nofollow"">declared in <code>&lt;algorithm&gt;</code></a>, so you have to <code>#include &lt;algorithm&gt;</code></p>

<p>You also need to make two other changes:</p>

<ol>
<li><code>replace</code> returns <code>void</code>, so if you want the <code>replace</code>d string to be seperate from the original string, you need to make a copy of the original and pass that to <code>replace</code>.</li>
<li><code>replace</code> takes single <code>char</code>s, not strings; but you are passing a nulll-terminated string with <code>""a""</code> and <code>""x""</code>.</li>
</ol>

<p>Code incorporating both of these changes:</p>

<pre><code>std::string output_string = string_to_edit;
replace (output_string.begin(), output_string.end(), 'a', 'x');
</code></pre>
",2
21024652,21024591,5,"<p>You need to <code>#include &lt;algorithm&gt;</code> for <a href=""http://en.cppreference.com/w/cpp/algorithm/replace"" rel=""noreferrer""><code>std::replace</code></a>, but you also need to use single characters. Note the single quotes:</p>

<pre><code>replace(string_to_edit.begin(),string_to_edit.end(),'a','x');  
</code></pre>

<p>Also note that <code>replace</code> will replace the elements in place. <code>std::replace</code> returns <code>void</code>.</p>
",0
21026287,21026165,1,"<p>Just like <code>scanf</code>, <code>cin</code> ignores whitespaces. Check <a href=""https://stackoverflow.com/questions/2765462/how-to-cin-space-in-c"">this out</a>. Try <code>gets</code> <a href=""http://www.cplusplus.com/reference/cstdio/gets/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdio/gets/</a> in order to read the string.</p>

<p>EDIT: As @James Reed pointed out, <code>gets</code> is getting removed from the standard. Another answer has provided an alternative. I'm leaving the answer though for future reference.</p>
",1
21026313,21026165,2,"<p>Use <code>std::getline</code> instead of <code>cin&gt;&gt;input_string</code></p>

<p><code>cin&gt;&gt;input_sting</code> will only read input string till space. </p>

<pre><code>std::getline( std::cin, input_string); 
</code></pre>
",0
21026242,21026165,4,"<p><code>cin&gt;&gt;input_string;</code> will extract text from the input until it reaches whitespace, so only the first word of your input will be put into input_string. Use <code>std::getline</code> in the string library to get a whole line.</p>
",0
21026632,21026165,0,"<p>You need to use <a href=""http://www.cplusplus.com/reference/string/string/getline/"" rel=""nofollow"">std::getline</a>, here's a cleaner / simpler c++11 implementation.</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

std::string replace_vowels(const std::string &amp; str) {
    static const char vowels[] = {'a', 'A', 'e', 'E', 'i', 'I', 'o', 'O', 'u', 'U'};
    std::string cp(str);
    for(std::size_t i = 0; i &lt; str.length(); ++i) {
        auto &amp; ch = str[i];
        for(auto &amp; v : vowels) {
            if(ch == v) {
                cp[i] = 'x';
                break;
            }
        }
    }
    return std::move(cp);
}

int main() {
    std::string input, output;
    std::cout &lt;&lt; ""Enter a string to replace all vowels : "";
    std::getline(std::cin, input);
    output = replace_vowels(input);
    std::cout &lt;&lt; ""Input : "" &lt;&lt; input &lt;&lt; "" / Output : "" &lt;&lt; output &lt;&lt; std::endl;
}
</code></pre>
",0
29210750,29210710,7,"<p>Your <code>trim()</code> function is expecting a non-<code>const</code> reference to a <code>std::string</code>. When you invoke it like this:</p>

<pre><code>std::string rID = trim(dataStr.substr(0, preTitlePos - 1));
</code></pre>

<p>You are invoking it with an rvalue, an unnamed temporary. This will have type <code>const std::string &amp;</code>, so it is not compatible with the <code>trim()</code> function. In order to make it work, you would need to assign it to a named variable first:</p>

<pre><code>std::string temp = dataStr.substr(0, preTitlePos - 1);
std::string rID = trim(temp);
</code></pre>

<p>On a side note, you seem to be mixing two methods of returning outputs from the <code>trim()</code> function. Typically, one will either return the function's result (usually by value), or one will modify arguments that were passed to the function by reference. Your functions do both, which is not typical. </p>

<p>I would change them to either take an input argument and return the result by value, or modify the by-reference argument that you pass in (and change their return types to <code>void</code>).</p>
",7
21717510,21717483,2,"<p>You didn't post the error, but I see that you're missing the semicolon after <code>void print()</code>in the header.</p>

<p>EDIT: That's a linker error. Each source file should be compiled into an object file; then the object files linked:</p>

<pre><code>g++ -c -oADT.o ADT.cpp
g++ -c -otestADT.o testADT.cpp
g++ -oADT ADT.o testADT.o
</code></pre>

<p>You can also do it in one line as in michaeltang's answer, but then you can't recompile the sources individually (the 2 step method scales better).</p>
",0
21717518,21717483,2,"<p>You should also compile <code>ADT.cpp</code></p>

<pre><code>g++ -o testadt testADT.cpp  ADT.cpp
</code></pre>
",0
21726432,21726292,1,"<p>You are not clearing last dots. You could solve it by changing output strings:</p>

<pre><code>void loadprog(int times){
        for(int x = 0; x &lt;= times; x++){
            cout &lt;&lt; ""Loading information.  \r""; //&lt;- added 2 spaces here
            Sleep(500);
            cout &lt;&lt; ""Loading information.. \r""; //&lt;- added 1 space here
            Sleep(500);
            cout &lt;&lt; ""Loading information...\r"";
            Sleep(500);
        }
}
</code></pre>

<p>Also you should notice that you repeat this output not for ""times"" times but for ""times + 1"" times because you repeat it for x = 0, 1, 2, 3, 4, 5, 6 == 7 times.</p>
",1
21300601,21300229,0,"<p>I think these will help you,</p>

<p>double getAverage(int *scores, int size){</p>

<pre><code> int    i, sum = 0;       
 double avg;          

for (i = 0; i &lt; size; ++i)
  {
   sum += scores[i];
   }

 avg = (double)sum / size;

 return avg;
</code></pre>

<p>}</p>

<p>Try and let me know if any  problem?</p>
",0
21300371,21300229,0,"<p>getAverage logic is not correct. You are adding just first number. Add is as below:</p>

<pre><code>   double getAverage(int *scores, int size)
   {
     double ttlScore = 0.0;
     double avgScore = 0.0;

     for(int i=0;i&lt;size;i++) 
     { 
      ttlScore += *(scores+i);
     }
      avgScore = ttlScore / size;
      return avgScore;
   }
</code></pre>
",1
21300374,21300229,0,"<p>You need to loop through your scores array to add them, you cannot just do <code>ttlScore += *scores</code>, it needs to be <code>ttlScore += scores[index]</code></p>

<p>Example:</p>

<pre><code>double getAverage(int *scores, int size)
{
    double ttlScore = 0.0;

    for (int i = 0; i &lt; size; i++)
    {
        ttlScore += scores[i];
    }

    return ttlScore / size;
}
</code></pre>
",0
21300400,21300229,0,"<p>*scores references the start of the array. You need to sum over all of the values of the array pointed to:</p>

<pre><code>for (int i=0; i &lt; size; i++)
{
ttlScore += scores[i];
}
avgScore = ttlScore / size;

return avgScore;
</code></pre>
",3
27502482,27502118,1,"<p>The typical overload used when the operator delete is called is <code>void delete(void *ptr);</code> </p>

<p>Provided the <code>ptr</code> argument points to a C++ object, the object's destructor is called. After the destructor has been called, the memory is de-allocated.</p>
",0
27502216,27502118,1,"<p>This is what happens if a pointer p points to a user-defined type</p>

<pre><code>class X{
    X() {};
    ~X(){};
};

X* p = new X; // calls default constructor
delete p; // calls destructor
</code></pre>
",0
26228148,26227748,1,"<p>Apart from the efficiency issue mentioned in other answer, you should also aware of the fact that using float is actually less intuitive than int.</p>

<p>For a comparison, you should almost never do something like</p>

<pre><code>if (aFloat == anotherFloat) { ...
</code></pre>

<p>You need to understand that not all decimal values can be exactly represented by a floating number.</p>
",0
26227820,26227748,1,"<p>Some reasons:</p>

<ul>
<li><code>int</code> is almost universally more efficient </li>
<li><code>int</code> allows bit-wise operations</li>
<li><code>int</code> is the return type for <code>main()</code></li>
</ul>
",0
26227821,26227748,1,"<p>It is considered to be slower than int in arithmetic computations.<br>
You may not use floats in comparisons because of their precession. (<a href=""http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"" rel=""nofollow noreferrer"">read more here</a>)  </p>

<p>This is a good post as well :   </p>

<p><a href=""https://stackoverflow.com/a/5069643/2736559"">Float vs. integer:</a></p>

<blockquote>
  <p>Historically, floating-point could be much slower than integer
  arithmetic. On modern computers, this is no longer really the case (it
  is somewhat slower on some platforms, but unless you write perfect
  code and optimize for every cycle, the difference will be swamped by
  the other inefficiencies in your code).</p>
  
  <p>On somewhat limited processors, like those in high-end cell phones,
  floating-point may be somewhat slower than integer, but it's generally
  within an order of magnitude (or better), so long as there is hardware
  floating-point available. It's worth noting that this gap is closing
  pretty rapidly as cell phones are called on to run more and more
  general computing workloads.</p>
  
  <p>On very limited processors (cheap cell phones and your toaster), there
  is generally no floating-point hardware, so floating-point operations
  need to be emulated in software. This is slow -- a couple orders of
  magnitude slower than integer arithmetic.</p>
  
  <p>As I said though, people are expecting their phones and other devices
  to behave more and more like ""real computers"", and hardware designers
  are rapidly beefing up FPUs to meet that demand. Unless you're chasing
  every last cycle, or you're writing code for very limited CPUs that
  have little or no floating-point support, the performance distinction
  doesn't matter to you.</p>
</blockquote>

<p>I would suggest you to read the whole post to get a clear view of their distinctions.  </p>
",2
26245776,26245693,1,"<p>Your <code>if</code> conditions should be of the form <code>(a=='b')||(a=='B')</code> instead of <code>a=='b'||'B'</code>.</p>
",7
30145768,30145758,6,"<p>If the function doesn't have a default parameter, e.g.</p>

<pre><code>void f(int x, int y, int z = 0) // we can call inside f(1,2) since z is a default parameter
</code></pre>

<p>then NO, it cannot call itself with less parameters. However, it can call an overloaded version with less parameters: </p>

<pre><code>void f(int x, int y); // one version
void f(int x, int y, int z); // another overload, this can call the first overload f(1,2)
</code></pre>

<p>So check your code for either default parameters or overloaded versions. Also, default parameters should go in the header file, the implementation file does not have to specify them again.</p>
",6
30145834,30145758,0,"<p>Yes, it is possible if myfun is overloaded. 
So, the function </p>

<pre><code>myclass::myfun(int p1, int p2, mytype *p3);
</code></pre>

<p>needs to exists, but it's impossible to know that from your posted fragment. </p>
",1
26251134,26250883,1,"<p>First of all when you do:</p>

<pre><code>string months[SIZE] = { ""January"", ""February"", ""March"",
                         ""April"", ""May"", ""June"",
                         ""July"", ""August"", ""September"", 
                         ""October"", ""November"", ""December"" };
</code></pre>

<p>you don't need ""SIZE"", so you can change it to: </p>

<pre><code>string months[] = { ""January"", ""February"", ""March"",
                    ""April"", ""May"", ""June"",
                    ""July"", ""August"", ""September"", 
                    ""October"", ""November"", ""December"" };
</code></pre>

<p>C++ can count how many elements are in the array.</p>

<p>Instead of saying:</p>

<pre><code>cout &lt;&lt; ""Please enter the amount of rain (in inches) for month "" &lt;&lt; (index + 1) &lt;&lt; "": "" &lt;&lt; endl; 
</code></pre>

<p>Replace <code>(index+1)</code> with <code>months[index]</code>. Who wants to read ""1"" instead of ""January""?</p>

<p>That aside, you don't have any errors! Those are warnings, so they don't make your program stop working.</p>

<p>To get the warnings out, replace:</p>

<pre><code>//Initialize highest
int highestRain = rainData2[0];
</code></pre>

<p>with:</p>

<pre><code>//Initialize highest
double highestRain = rainData2[0];
</code></pre>

<p>And the same thing for:</p>

<pre><code>//Initialize highest
int lowestRain = rainData3[0];
</code></pre>

<p>Change that to a <code>double</code>. That got rid of the warnings but didn't give me more errors like you mentioned.</p>
",2
26251059,26250883,1,"<p>You wrote:</p>

<pre><code> int highestRain = rainData2[0];
 int lowestRain = rainData3[0];
</code></pre>

<p>Since you want to find the highest and lowest values without rounding to an integer, your ""best so far"" variables need to be doubles. You can declare them as such explicitly:</p>

<pre><code> double highestRain = rainData2[0];
 double lowestRain = rainData3[0];
</code></pre>

<p>You can also use the <code>auto</code> keyword. (See <a href=""http://msdn.microsoft.com/en-us/library/dd293667(v=vs.110).aspx"" rel=""nofollow"">docs for Visual Studio 2012</a>.) The advantages and disadvantages of this style are out of scope for this answer, but you probably should be aware of the language feature.</p>

<pre><code> auto highestRain = rainData2[0];
 auto lowestRain = rainData3[0];
</code></pre>
",10
26251074,26250883,1,"<p>Change</p>

<pre><code>int highestRain = rainData2[0];
</code></pre>

<p>To</p>

<pre><code>double highestRain = rainData2[0];
</code></pre>

<p>Same for lowest rain.</p>
",0
23849142,23848631,1,"<p>You didn't obey the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"" rel=""nofollow"">rule of three</a>. You have user defined destructor and copy assignment operator, but you haven't defined a copy constructor. The compiler helpfully<code>&lt;/sarcasm&gt;</code> defined one for you.</p>

<p>On this line:</p>

<pre><code>str S3 = S2;
</code></pre>

<p>You <a href=""http://en.cppreference.com/w/cpp/language/copy_initialization"" rel=""nofollow"">copy initialize</a> S3. As you can see from the rules in the linked page:</p>

<blockquote>
  <p>If T is a class type and the type of other is cv-unqualified version of T or a class derived from T, the constructors of T are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.</p>
</blockquote>

<p>The best matching constructor happens to be the <code>str(const str&amp;);</code> which was added by the compier. The default copy constructor does not make a copy of the data pointed by the charPtr but just copies the pointer instead.</p>

<p>When S2 goes out of scope, after <code>cin.get();</code>, it's destructor deletes S2.charPtr. Next, S3 is destroyed and it's destructor tries to delete S3.charPtr which has the same value as S2.charPtr and is therefore already deleted. <a href=""http://www.parashift.com/c++-faq/double-delete-disaster.html"" rel=""nofollow"">This has undefined behaviour</a>. <a href=""https://www.allegro.cc/forums/thread/457488"" rel=""nofollow"">Quick googling</a> suggests that <code>_BLOCK_TYPE_IS_VALID</code> assertion fails if heap pointer is invalid. I'm guessing it's likely result of this undefined behaviour.</p>

<p>Solution: Implement the copy constructor <code>str(const str&amp;);</code> so that copies don't share data.</p>
",0
26441763,26441739,3,"<p>The <code>size_t</code> values are being narrowed. In c++11, you could make this fail with an error by doing:</p>

<pre><code>#include &lt;string&gt;

int main() {
    std::string line;
    int i{line.size()};
    int j{line.length()};
}
</code></pre>

<p>The errors produced look like:</p>

<pre><code>gh.cc:5:11: error: non-constant-expression cannot be narrowed from type 'size_type' (aka 'unsigned long') to 'int' in initializer list [-Wc++11-narrowing]
    int i{line.size()};
          ^~~~~~~~~~~
gh.cc:5:11: note: override this message by inserting an explicit cast
    int i{line.size()};
          ^~~~~~~~~~~
          static_cast&lt;int&gt;( )
gh.cc:6:11: error: non-constant-expression cannot be narrowed from type 'size_type' (aka 'unsigned long') to 'int' in initializer list [-Wc++11-narrowing]
    int j{line.length()};
          ^~~~~~~~~~~~~
gh.cc:6:11: note: override this message by inserting an explicit cast
    int j{line.length()};
          ^~~~~~~~~~~~~
          static_cast&lt;int&gt;( )
</code></pre>
",6
26442190,26441739,0,"<p>size_t is a 32 bit integer.
Go to your compiler directory and open the <strong>stdio.h</strong> file.</p>

<p>There is a declaration, something like this:</p>

<pre><code>typedef unsigned int size_t;
</code></pre>
",1
24116551,24116456,1,"<p>You need to declare <code>toString</code> as a virtual method that will allow to customize logic hidden in function with same signature</p>

<pre><code>class Contact
{

public:

  //...
  virtual string toString () { return name + "" : "" + email;}
                   ^
           // better use a camel case

};
</code></pre>

<p>And override as desired</p>

<pre><code>#include &lt;sstream&gt;

class Skater : public Contact
{
public:
  //...
  string toString () override {
                      ^^^^
                      // be explicit about this

       std::stringstream sstm;
       sstm &lt;&lt; name &lt;&lt; "":"" &lt;&lt; email &lt;&lt; personalBest;
       result = sstm.str();
};
</code></pre>

<p>You can also return simply  <code>Contact::toString() + personalBest</code> in overriden method.</p>
",2
24116498,24116456,4,"<p>You sholud declare <code>tostring()</code> as <code>virtual</code> in the base <code>Contact</code> class:</p>

<pre><code>virtual string tostring() {...}
</code></pre>

<p>override in Skater and implement here the specific behavior .</p>
",0
24116537,24116456,2,"<p>Just declare <code>toString</code> as <code>virtual</code> in <code>Contact</code> and override it in <code>Skater</code> class:</p>

<pre><code>class Contact{
 public:
  virtual string toString(){ return name + "" : "" + email;}
  //other members
};



class Skater:public Contact{
  public:
   string toString() override { 
     return Contact::toString() + ""anything"";//get return value from parent and append anything you want
   }

};
</code></pre>
",0
24105549,24105467,0,"<p>In this case there is usually used standard container <code>std::map&lt;std::string, size_t&gt;</code></p>

<p>For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

int main()
{
   std::map&lt;std::string, size_t&gt; m;
   std::string word;

   while ( std::cin &gt;&gt; word ) ++m[word];

   for ( const auto &amp;p : m ) std::cout &lt;&lt; p.first &lt;&lt; '\t' &lt;&lt; p.second &lt;&lt; std::endl;
}
</code></pre>

<p>You should press either Ctrl + Z (in Windows) or Ctrl + D (in Unix) that to finish the input of words.</p>

<p>Or you could use function <code>std::getline</code> instead of <code>operator &gt;&gt;</code></p>

<p>For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

int main()
{
   std::map&lt;std::string, size_t&gt; m;
   std::string word;

   while ( std::getline( std::cin, word ) &amp;&amp; !word.empty() ) ++m[word];

   for ( const auto &amp;p : m ) std::cout &lt;&lt; p.first &lt;&lt; '\t' &lt;&lt; p.second &lt;&lt; std::endl;
}
</code></pre>

<p>In this case that to finish the input you need to enter an empty string that is to press simply ENTER key.</p>

<p>If the input is</p>

<pre><code>Spain
England
England
France
</code></pre>

<p>The output will be</p>

<pre><code>England 2
France  1
Spain   1
</code></pre>
",2
22161329,22161291,3,"<p>It's quite hard to give you hints, when you didn't give us any context (what do the classes do? What's the function name?), but you're right - on first glance it does look silly if you really have dozens of subclasses.</p>

<p>Maybe the solution your looking for is using <strong>function pointers</strong>? If it's only one class, maybe it would be better if you had a function pointer pointing to some global function? With that solution you wouldn't need to derive anything from the base class.</p>

<p>You could also implement all the options inside the base class function and call it with an additional parameters which would hint what version to use. Once more - it's hard to tell what's better when there's no hint on what you're doing.</p>
",4
22161376,22161291,0,"<p>To be honest it doesn't look stupid to me, as long as you know what you are doing.</p>

<p>Of course there are other alternatives.  For example, by making use of <a href=""http://en.wikipedia.org/wiki/Strategy_pattern"" rel=""nofollow"">Strategy pattern</a>.  By doing so, you are going to have one context class (something like your original base class), plus one strategy for each kind of special behavior you want to provide.  And when using, in the old way you are going to instantiate the subclass that fit your need.  Now, you will use the same class, and ""plug"" the correct strategy to it.</p>

<p>It doesn't reduce number of class, nor it is a better design.  It is just a different design.  Take a look to know the pros and cons for such approach, and understand your own problem, and choose one that suit your need.</p>
",1
29496811,29496601,2,"<p>Here is how you can assign a 2D boolean array to a 2D integer array (of size 19x19 as in your case):</p>

<pre><code>for(int i=0; i&lt;19; i++) {
    for(int j=0; j&lt;19; j++) {
       lab[i][j] = (tablero[i][j])?1:0;
    }
}
</code></pre>

<p>Please note the use of ternary operator in the assignment statement. If the </p>

<pre><code>tablero[i][j] 
</code></pre>

<p>is true then </p>

<pre><code>lab[i][j] will be 1, otherwise it will be 0.
</code></pre>

<p>Of course you may assign different integer values as well.</p>

<p>Hope that helps!</p>
",0
29497019,29496601,2,"<p>These two arrays</p>

<pre><code>array&lt;array&lt;bool,19&gt;,19&gt; tablero
</code></pre>

<p>and</p>

<pre><code>array&lt;array&lt;int,19&gt;,19&gt; lab;
</code></pre>

<p>have different types and there is no implicit conversion from one array to another.</p>

<p>You can either write loops yourself or use some standard algorithms as it is shown in this demonstrative program</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

int main() 
{

    std::array&lt;std::array&lt;bool,19&gt;,19&gt; tablero; 
    std::array&lt;std::array&lt;int,19&gt;,19&gt; tablero1;

    std::accumulate( tablero.begin(), tablero.end(), tablero1.begin(),
                     []( auto it, const auto &amp;a ) 
                     { 
                        return std::copy( a.begin(), a.end(), it-&gt;begin() ), ++it;
                     } );

    return 0;
}
</code></pre>

<p>Your compiler has to support specifier auto in lambda expressions that the code would compile.</p>

<p>Or the same program but with some output</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

int main() 
{
    const size_t N = 3;
    std::array&lt;std::array&lt;bool, N&gt;, N&gt; tablero = 
    {
        {
            { true, false, false },
            { false, true, false },
            { false, false, true }
        }
    }; 
    std::array&lt;std::array&lt;int, N&gt;, N&gt; tablero1;

    std::accumulate( tablero.begin(), tablero.end(), tablero1.begin(),
                     []( auto it, const auto &amp;a ) 
                     { 
                        return std::copy( a.begin(), a.end(),it-&gt;begin() ), ++it;
                     } );

    for ( const auto &amp;a : tablero )
    {
        for ( auto b : a ) std::cout &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; ' ';
        std::cout &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; std::endl;

    for ( const auto &amp;a : tablero1 )
    {
        for ( auto x : a ) std::cout &lt;&lt; x &lt;&lt; ' ';
        std::cout &lt;&lt; std::endl;
    }

    return 0;
}


true false false 
false true false 
false false true 

1 0 0 
0 1 0 
0 0 1 
</code></pre>
",0
29498808,29496601,0,"<p>Well, so the most straightforward method is simply:</p>

<pre><code>  for (i=0; i&lt;=18; i++){
        for (j=0; j&lt;=18 ; j++){
                lab[i][j]= mys.tablero[i][j];
            }
 }
</code></pre>

<p>As  Mark Ransom suggested in the first place</p>
",0
21329364,21328923,0,"<p>It is simple,</p>

<pre><code>//the int i declaration below is like it's within the {} block
for (int i = 0; i &lt; 10; i++)
{
    //do something
}

//i is out of scope here, you can't use i any more, u must redeclare
//int i = 5; //ok!
//for (int i = 0; i &lt; 20; i++) //ok!
for (i = 0; i &lt; 20; i++) //no, you can't do this
</code></pre>

<p>Two way to solve your problem,</p>

<p>One, put i declaration outside</p>

<pre><code>int i;
for (i = 0; i &lt; 10; i++)
</code></pre>

<p>Two, declare i again</p>

<pre><code>for (int i = 0; i &lt; 10; i++)
</code></pre>
",3
21789706,21789660,2,"<p>You can just work with the end of the list. </p>

<p>So for the pop functionality you would get the last item in the list, remove it from the list, and return it to the caller.</p>

<p>For push you could do the reverse action ie add the item to the end of the list.</p>
",0
24638070,24638021,4,"<p>This is what pure virtuals are for:</p>

<pre><code>virtual std::string ref() = 0;
</code></pre>

<p>now the compiler won't let you instantiate an instance of a derived type that doesn't define that function.</p>
",2
24638234,24638021,2,"<blockquote>
  <p>If we call a method that isn't implemented on the derived class, but
  in the base, it crashes.</p>
</blockquote>

<p>This does not strictly apply to your example code:</p>

<pre><code>virtual std::string ref() {}
</code></pre>

<p>An implementation is there; you get a crash <strong>because the implementation doesn't return anything</strong>. The same would likely happen here, for example:</p>

<pre><code>#include &lt;string&gt;

std::string f() {}

int main()
{
   std::string x = f();
   x = """";
}
</code></pre>

<p>(I say ""likely"" because it's undefined behaviour, so the crash is not guaranteed.)</p>

<p>As for your problem:</p>

<p>If you need to call functions which do not conceptually exist, then you have a design problem; chances are that your base class tries to fulfill too many responsibilities at the same time.</p>

<p>Otherwise, use abstract classes. You can make a class abstract by declaring at least one function <strong>pure virtual</strong>:</p>

<pre><code>class Foo
{
public:
    virtual std::string ref() = 0; // pure virtual function
};
</code></pre>

<p>Please note three further things:</p>

<ul>
<li>You almost certainly need a virtual destructor in your base class.</li>
<li>Except of the destructor, consider making your public functions non-virtual and your virtual functions private, the public non-virtual ones calling the private virtual ones.</li>
<li>Your function looks like a candidate for a const function.</li>
</ul>

<p>Final example:</p>

<pre><code>class Foo
{
public:
    virtual ~Foo() {}
    std::string ref() const { return refImpl(); }
private:
    virtual std::string refImpl() const = 0;
};
</code></pre>
",5
28505488,28505409,3,"<ol>
<li><p>Get a pointer to the base class from the <code>unique_ptr</code>.</p>

<pre><code>Base* basePtr = Objects[""Child1""].get();
</code></pre></li>
<li><p>Do a <code>dynamic_cast</code> on the pointer.</p>

<pre><code>Child1* child1Ptr = dynamic_cast&lt;Child1*&gt;(basePtr);
</code></pre></li>
<li><p>Access the members of the <code>Child1</code> class.</p>

<pre><code>if ( child1Ptr != nullptr )
{
   // ... Use child1Ptr
}
</code></pre></li>
</ol>

<p>Make sure that you make the destructor of the base class <code>virtual</code>. Otherwise, the destructors of the derived classes will never be called when the <code>unique_ptr</code>s are destructed. Also, as observed by @AndyG in comments, <code>dynamic_cast</code> won't work without a any virtual functions.</p>

<pre><code>class Base
{
    public:
        virtual ~Base(){}

    private:
       int foo;
};
</code></pre>
",1
23576096,23575813,0,"<p>The error is in the function report, it asks for two integer and you are passing an array and an integer instead
and again i don't think you need 2 parameters in the function report one would solve your purpose</p>

<p><code>void report(int d)
{
    cout &lt;&lt; ""\nYou entered &lt;&lt;d&lt;&lt;"" distinct numbers"";
}</code></p>

<p>that would solve your error but i don't think you would get your desired output</p>
",0
23575862,23575813,2,"<p>Can't explain it better than your error:</p>

<pre><code>void report (int s, int d);
</code></pre>

<p>this function asks for two integer values, you're passing an array to it which, with decayed functionalities, will behave like an integer pointer</p>

<pre><code>int ruby[size];
report (ruby, numuniq);
</code></pre>

<p>I'm unsure on the behavior of your program but you should rather do something like</p>

<pre><code>report(ruby[0], numuniq);
</code></pre>

<p>that is: access the element of the array and feed it to the function</p>
",0
23576138,23575813,0,"<p>Few problems with the code:</p>

<ul>
<li><code>Report</code> function should be expecting an array of integers rather than single integer</li>
<li>Try using human readable variable or function names</li>
<li><code>remdubs</code> was renamed to <code>rempubs</code> in function definition</li>
<li>phillip function definition didn't have params defined properly</li>
<li>You have <code>const int size</code> but do not use it</li>
<li><code>remdups</code> has a bug somewhere. I will leave that out as I am trying to fix other issues here.</li>
<li>There are better ways of finding duplicates than <code>remdups</code>. Please look at some other solutions.</li>
</ul>

<p><strong>I have fixed your code and provided it <a href=""http://ideone.com/a0QsrK"" rel=""nofollow"" title=""http://ideone.com/a0QsrK"">here on ideone</a></strong></p>
",0
32447864,32447840,3,"<p>The decimal <code>10</code> and hex <code>0xA</code> are the same value internally, so you simply assign it directly:</p>

<pre><code>int i = 10;
char c = i;
</code></pre>
",1
23595378,23595294,2,"<p>The <code>&amp;</code> symbol you're referring to is presumably this one:</p>

<pre><code>static classname &amp; variable = (*(variable##Ref.get()))
</code></pre>

<p>In which case the ampersand isn't anything to do with the C preprocessor, it is in fact the C++ <a href=""https://stackoverflow.com/questions/57483/what-are-the-differences-between-pointer-variable-and-reference-variable-in-c"">reference symbol</a>.</p>

<p>You would typically use it to refer to an already declared object, similar to a pointer.</p>

<p>For example:</p>

<pre><code>int a = 1;
int b = a;
int &amp;c = a;

// a = 1, b = 1, c = 1.

b = 2;   

// a = 1, b = 2, c = 1.

a = 3;

// a = 3, b = 2, c = 3. Note that variable 'c', which is a reference to 'a', has also changed.

c = 4;

// a = 4, b = 2, c = 4.
</code></pre>
",2
23840891,23840835,1,"<p>You want <code>strtod</code>, not <code>strtol</code>. <code>strtol</code> only parses integers.</p>

<p><code>strtod</code> only takes two arguments, because floating point numbers are always in base 10 (as far as <code>strtod</code> is concerned, anyway.) </p>
",1
23840903,23840835,0,"<p>I think you are turning your strings into longs (I'm guessing that's what strtol() is...). I was building a calculator and I had that problem - I wrote a function to handel it:</p>

<pre><code>double string_to_double(string str)
{
    int length = (int)str.length();
    double output = 0; //This holds value of output.  Will be added for each 10's digit
    int decimalPos = length - 1;
    for (int i = 0; i &lt; length; i++)
    {
        if(str.at(i) == '.') // Find if there is a decimal point
        {
            decimalPos = i - 1; //Sets Decimal Position
            str.erase(str.begin()+i);
            length--;
        }
    }



    for (int i = 0; i &lt; length; i++)
    {
        switch (str.at(i))
        {
            case '1':
                output += 1*pow(10, decimalPos - i);
                break;
            case '2':
                output += 2*pow(10, decimalPos - i);
                break;
            case '3':
                output += 3*pow(10, decimalPos - i);
                break;
            case '4':
                output += 4*pow(10, decimalPos - i);
                break;
            case '5':
                output += 5*pow(10, decimalPos - i);
                break;
            case '6':
                output += 6*pow(10, decimalPos - i);
                break;
            case '7':
                output += 7*pow(10, decimalPos - i);
                break;
            case '8':
                output += 8*pow(10, decimalPos - i);
                break;
            case '9':
                output += 9*pow(10, decimalPos - i);
                break;
            case '0':
                break;
        }

    }
    return output;
}
</code></pre>

<p>...but there is probably a better way</p>
",4
26780836,26780795,9,"<p>No, because when you use v in main, it is perfectly defined. The static initialization phase takes place before you use v in main ...</p>

<p>The problem arise if you use 2 globals in different translation units and there is a dependency between the two. See this <a href=""http://www.parashift.com/c++-faq/static-init-order.html"" rel=""nofollow"">C++ FAQ lite</a> for an explanation. The next items in the FAQ explains how to avoid the 'fiasco'.</p>

<p>The problem of static initialization made globals worse in C++ than in any other language. Good library writers know the problem and avoid the static order initialization fiasco. And even if not, if the library is well spread, someone will hit the problem and, I hope, fix it. But 3rd party libs are not always well written, they can be libraries written in your company by an ignorant new to C++ programmer ...</p>

<p>So, yes, it is unsafe, you're right. And in C++ avoid globals even more than in other languages !</p>

<p>Note: Columbo as pointed out that the standard does not not exactly say that v is defined before entering main (see his answer). No practical difference in your instance.</p>
",4
26780853,26780795,0,"<p>Since there's only one global object being defined, there can be only one ordering of its initialization, and therefore there is no issue. </p>
",0
26780878,26780795,6,"<p>It's specified in [basic.start.init]/4:</p>

<blockquote>
  <p>It is implementation-defined whether the dynamic initialization of a
  non-local variable with static storage duration is done before the
  first statement of main. If the initialization is deferred to some
  point in time after the first statement of main, it shall occur before
  the first odr-use (3.2) of any function or variable defined in the
  same translation unit as the variable to be initialized.</p>
</blockquote>

<p>It is therefore defined that <code>v</code> is initialized before its first use in any function of this translation unit, including <code>main</code>. That implies that in this particular program <code>v</code> is initialized before the first statement of <code>main</code>. <br><br>
The <a href=""http://www.parashift.com/c++-faq/static-init-order.html"" rel=""nofollow"">static initialization order fiasco</a> occurs when <strong>multiple</strong> variables in <strong>different</strong> translation units depend on their relative order of initialization; The initializations may be indeterminately sequenced with respect to each other, depending on their initialization.</p>
",0
21717849,21717821,2,"<p>The value of <code>c</code> is stored in temporary memory which is allocated when the function is called and can only be accessed by that specific function call. </p>

<p>EDIT: Apparently the real question is how you use the return value. </p>

<p>In essence, the return value of a function 'replaces' that function once it is finished executing. In this case, <code>change(a)</code> is replaced by 30, but you should know you can't just type integers in the code. You have to assign them. Because of this, you should instead write <code>a = change(a)</code> which ends up looking like <code>a = 30</code>. (or declare another integer ie. <code>int b = change(a)</code>). </p>

<p>This makes the new value of <code>a</code> become the return value of <code>change()</code>. (It doesn't form some crazy infinite loop because <code>change(a)</code> is executed before the assignment is done)</p>
",2
21717975,21717821,1,"<p>That's because you didn't assign the return value to the variable.</p>

<p>You should use</p>

<pre><code>a = change(a);
</code></pre>

<p>or</p>

<pre><code>void change(int &amp;c) // pass c by reference to make it changeable by such function
{
    c=30;
}
</code></pre>
",0
23599175,23599167,3,"<pre><code>std::vector&lt;int&gt;(tSet.begin(), tSet.end())
//                          ^ iterator to begin of data range
// tSet.end() is iterator to end of data range
</code></pre>

<p>creates a temporary variable which is of type <code>std::vector&lt;int&gt;</code> by copying container named <code>tSet</code></p>

<blockquote>
  <p>Is there a name to it by which I could look it up?</p>
</blockquote>

<p>Look at <a href=""http://en.cppreference.com/w/cpp/container/vector/vector"" rel=""nofollow"">this decription of vector constructors</a>:</p>

<p>in particular at constructor (4):</p>

<pre><code>template&lt; class InputIt &gt;
vector( InputIt first, InputIt last, 
        const Allocator&amp; alloc = Allocator() );
</code></pre>

<p>which is called sometimes also a range constructor.</p>
",1
32998798,32998521,1,"<p>In the following block of code,</p>

<pre><code>    if (sizeof(Bike) &gt; 10) {
        return false;
    }
</code></pre>

<p>I am guessing that you are trying to make sure that you don't allow parking of more than 10 bikes in the shed.</p>

<p>In order to do that, you need to have a member variable in <code>park_shed</code> to indicate the number of bikes parked in the shed. Then, you can use:</p>

<pre><code>bool bike_shed::park( const Bike&amp; bike)
{
   if ( number_of_parked_bikes &lt; 10 )
   {
      bikes[number_of_parked_bikes] = bike;
      ++number_of_parked_bikes;
      return true;
   }
   else
   {
      retun false;
   }
}
</code></pre>

<p>Make sure to initialize <code>number_of_parked_bikes</code> to zero in the constructor.</p>

<p>The <code>checkLegal</code> function would be something like:</p>

<pre><code>// Make it a `const` member function since it does not
// change anything in bike_shed.
bool bike_shed::checkLegal() const
{
   bool isLegal = true;
   for ( int i = 0; i &lt; number_of_parked_bikes; ++i )
   {
      if ( bikes[i].getOwner() == ""None"" )
      {
         // No need to check whether this bike is legar or not.
      }
      else if (!bikes[i].isLegal() )
      {
         isLegal = false;
         cout &lt;&lt; ""Illegal bike found.\n"";
         bikes[i].print();
      }
   }

   return isLegal;
}
</code></pre>
",11
32999090,32998521,0,"<p>In method checkLegal() you may want to check whether a given Bike is valid or not before insertion, so you can write something like :</p>

<pre><code>bool bike_shed::checkLegal(const Bike &amp;bike1) {

    if(bike1.getOwner() == ""None""){  // or maybe bike1.isLegal()
        return false;
    }
    else{
        return true;
    }
}
</code></pre>

<p>Also if you want to print all bikes in bike_shed you might want to write something like :</p>

<pre><code>void bike_shed::print(){

    for (int iBike = 0; iBike &lt; nbBikes &lt; iBike++)
        bike[iBike].print();

}
</code></pre>
",3
22126334,22126162,0,"<pre><code>#define FOR_RANGE(C_type, it, C) for(C_type::iterator it=C.begin(); it!=C.end(); ++it)


FOR_RANGE(std::vector&lt;int&gt;, a, v)
{
    std::cout &lt;&lt; *a &lt;&lt; std::endl;
}
</code></pre>
",3
22126569,22126162,0,"<p>Does this do what you want?</p>

<pre><code>#define FOR_RANGE(container_type, var, container) \
  for(container_type::iterator var = container.begin(); var != container.end(); ++var)
</code></pre>
",0
21570068,21569627,2,"<p>The benefit from using shared memory will not be so much, because you will end up with using conditional variables on the shared memory (cf. <code>pthread_condattr_setpshared</code>; it will be a substantial coding work, by the way.)  Then your logic is governed by the OS scheduler, and it's not very different from using <code>localhost</code> TCP connection which has a different and fast implementation than standard TCP on most OS.</p>

<p>If it's OK to entirely rely on a spinlock on the shared mem, then you will indeed realize substantial speed up like x3 fold.</p>
",0
21580616,21580573,3,"<p><code>std::string</code> <code>at</code> returns a <code>char</code> type. Using the <code>%s</code> format specifier for a <code>char</code> type will give you <em>undefined behaviour</em>. <strong>Boom!</strong></p>

<p>Two things:</p>

<p>1) Check the size of the string before accessing elements using <code>at</code>: <code>at(1)</code> is accessing the <em>second</em> character of the string as the indexing is zero based.</p>

<p>2) Use the correct format specifier in <code>printf</code>: <code>printf(""%c"", a.at(1))</code></p>
",0
21580620,21580573,1,"<p>The printf function expect a char pointer and you give a char. The char value gets interpreted as an address and it is wrong.</p>

<p>If you only want to print a single char, use:</p>

<pre><code>printf(""%c"", a.at(1))
</code></pre>

<p>provided your string is at least 2 characters long.</p>
",0
21580629,21580573,2,"<p><code>at()</code> doesn't return a string, it returns a character. <code>%s</code> is trying to interpret that character as a (very invalid) pointer.</p>

<p>Try:</p>

<pre><code>printf(""%c"", a.at(1));
</code></pre>

<p>(assuming <code>a</code> is at least two characters long).</p>
",0
21580631,21580573,7,"<p>The immediate problem is that <code>""%s""</code> requires a pointer to a C-style string as its corresponding argument. <code>a.at(1)</code> is a single character, not a pointer, so you have undefined behaviour when it's misinterpreted as a pointer. You want <code>""%c""</code> to print a character.</p>

<p>The more general problem is the use of non-typesafe C functions. In C++, you could use a typesafe output stream:</p>

<pre><code>cout &lt;&lt; a.at(1);
</code></pre>
",0
22887053,22886855,0,"<p>It's difficult to say for sure what's going one without seeing the value with which you have initialized the Record.  Based on your description of the program's behavior and the code, I can think of one possible explanation of what's happening, although there might be others.  </p>

<p>My guess is the std::ostream is handing the char* like a c-string, which expects a sequence of charcters terminated by a \0.  If your Record has been initialized with a sequence of characters that doesn't terminate with a \0, it would keep doing pointer incrementation, streaming out a character at a time, until it reaches an invalid section of memory.  This will cause undefined behaviour, which might trigger a debug assertion in your implementation of the standard (i.e. the compiler you are using).</p>

<p>I provide you this guess as you say this is a learning exersize, so I don't question your class design but try to help you understand what's happening.  The comments elsewhere are quite relevant however.  If you have record store a std::string instead of a character array, this problem (and several other possible problems) will not occur.  That answer may not help you lean what you are trying to learn of course.</p>
",1
22886927,22886855,0,"<p>Don't call the assignment operator, <code>*this =</code>, from the <code>const char*</code> and copy constructors. This is generally bad practise. In your case, because you haven't defined an assignment operator that takes a <code>const Record&amp;</code>, the default assignment operator is called, which simply copies <em>the pointer</em> and does a <em>shallow copy</em>, meaning that both <code>Record</code>s will have the same pointer in their <code>rec</code>s -- this was pointed out and described in detail in <a href=""https://stackoverflow.com/a/22887287/834521"">PaulMcKenzie's answer</a>. However even if you did define that assignment operator, if you did the same thing as your existing assignment operator, the member variable <code>rec</code> would be uninitialized and <code>delete</code>ing it causes undefined behaviour.</p>

<p>See <a href=""https://stackoverflow.com/questions/2639017/calling-assignment-operator-in-copy-constructor"">Calling assignment operator in copy constructor</a> for a discussion, and what you could do instead of calling the assignment operator from a constructor.</p>

<p><em>Edit</em></p>

<p>One way to make your program work would be for your constructors to look something like this.</p>

<pre><code>void Record::InitFrom(const char* s)
{
    if(s != nullptr) {
        rec = new char[strlen(s) + 1];
        strcpy(rec, s);
    } else {
        rec = nullptr;
    }
}

Record::Record(const char* s) {
    InitFrom(s);
}

Record::Record(const Record&amp; r) {
    InitFrom(r.s);
}
</code></pre>

<p>You could also incorporate the new <code>InitFrom</code> method into your assignment operator.</p>

<pre><code>Record&amp; Record::operator=(const char* s) {
    if (rec != s) { // this test only really necessary if assigning from Record
        delete [] rec;
        InitFrom(s);
    }
    return *this;
}
</code></pre>

<p>You also might have an assignment operator that takes a <code>const Record&amp;</code>. You <em>do</em> need the destructor.</p>
",5
22887287,22886855,1,"<p>I'll put this as an answer, since it is important in how your class behaves and concluding that ""everything is working"" is one of the reasons why C++ is not that easy of a language.</p>

<p>The main() program you wrote does not test something very simple.  Look here:</p>

<pre><code>int main() {
   Record rec1(""inheritance"");
   Record rec2 = rec1;
}
</code></pre>

<p>If you debug this code, you will see that this function is called for the rec2 = rec1 line:</p>

<pre><code>Record::Record(const Record&amp; r) {
    *this = r;
}
</code></pre>

<p>Ok, so the copy constructor is called.  But what does this line of code do?:</p>

<pre><code>*this = r;
</code></pre>

<p>It does <em>not</em> call the assignment operator that you wrote that takes a const char*.  Instead, it calls the default assignment operator that takes a Record&amp;,  The problem is that -- you didn't write one.  So what winds up happening is that the compiler generated assignment operator is called, which does a shallow copy.</p>

<p>In the main() program, when main() returns, both rec2 and rec1 will have their respective destructors called.  The problem is that rec2 will delete the pointer value, ok, but then rec1 will delete the same pointer value (no good), causing a corruption of the heap.  I ran your code with Visual Studio 2013, and immediately an assertion dialog popped up when main() returned.</p>

<p>So you need to write a user defined assignment operator that takes this signature:</p>

<pre><code>Record&amp; Record::operator=(const Record&amp;)
</code></pre>
",0
26411505,26411245,0,"<p>If you can use something else, this should do:</p>

<pre><code>bash $ (tr '[A-Z]' '[a-z]' | tr -d -c '[:alpha:]\n') &lt; dataFile
</code></pre>

<p>Otherwise, this is probably what you want:</p>

<pre><code>#include &lt;cctype&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;

using namespace std;

int main()
{
    char c;
    ifstream file(""dataFile"");

    while (!file.eof()) {
            c = file.get();

            if (isalpha(c) || c == '\n')
                    cout &lt;&lt; tolower(c);
    }

    return 0;
}
</code></pre>
",0
32953854,32953650,10,"<p>An <code>enum</code> just spills its contents into the enclosing scope, and is basically a const static integer. This means that the first element of any default enum is the same using the == operator. </p>

<p>Enum classes have their own scope, and don't pollute the namespace that they are in. They also make sure that the first element in any enum classes aren't equal. </p>

<p>Prefer enum classes because of their perks if you have a compiler that supports them (any major compiler by now)</p>

<p>I'd you want to learn more go here:</p>

<p><a href=""http://en.cppreference.com/w/cpp/language/enum"" rel=""noreferrer"">http://en.cppreference.com/w/cpp/language/enum</a></p>
",0
26411252,26410971,1,"<p><strong>This looks a bit wrong:</strong></p>

<pre><code>while(temp != NULL)
{
    for(int j=0; j&lt;n; j++)
        cout&lt;&lt;temp-&gt;number&lt;&lt;"" ""; // Only this is part of the for() loop
        temp = temp-&gt;next; // This happens after the for() loop ends
}
</code></pre>

<p>Only the first line gets executed by the <code>for()</code> loop so it keeps outputting the same number. Why is the for loop there anyway? What is it supposed to do?</p>

<p><strong>Try this:</strong></p>

<pre><code>while(temp != NULL)
{
    cout&lt;&lt;temp-&gt;number&lt;&lt;"" "";
    temp = temp-&gt;next;
}
</code></pre>

<p>See if that works better.</p>

<p><strong>ALSO:</strong></p>

<p>As @crashmstr pointed out your insert logic is wrong:</p>

<pre><code>for(i=0;i&lt;n;i++)
{
    cin&gt;&gt;x;
    //Insert(x);
    node* temp;
    temp = new node;
    temp-&gt;number = x;
    temp-&gt;next = NULL; // this should point to the nextnode
    head = temp;
}
</code></pre>

<p><strong>Try:</strong></p>

<pre><code>for(i=0;i&lt;n;i++)
{
    cin&gt;&gt;x;
    //Insert(x);
    node* temp;
    temp = new node;
    temp-&gt;number = x;
    temp-&gt;next = head; // the current begining
    head = temp;
}
</code></pre>

<p><strong>*ALSO 2:</strong></p>

<pre><code>include""iostream"" // not right
</code></pre>

<p>Please use:</p>

<pre><code>#include &lt;iostream&gt; // correct!
</code></pre>
",3
26411322,26410971,1,"<p>Remember that when setting the <code>head</code> pointer, you should only do so when the list is empty (i.e when <code>head == NULL</code>). We should do this after we create the new node so we know what to set <code>head</code> to:</p>

<pre><code>node* temp = new node;
temp-&gt;number = x;
temp-&gt;next = NULL;

if (head == NULL) // if the list is empty then...
    head = temp;  // temp is the start of the list
</code></pre>

<p>There's also another problem. <code>temp</code> is supposed to be added to the <em>end</em> of the list each time it's created. If the list is empty then <code>head</code> is the end of the list, but if the list already has elements then we need to go to the end and set the <code>next</code> pointer of that node to <code>temp</code>. This is fairly straightforward, all it takes is a while loop to iterate over the list to the end:</p>

<pre><code>if (head == NULL)
    head = temp;
else // the list is not empty
{
    // so we need to go to the end
    node* p = head;
    while (p-&gt;next != NULL)
        p = p-&gt;next; // keep going through

    // p now points to the last node
    p-&gt;next = temp;
}
</code></pre>

<p>There's also the option of keeping a <code>prev</code> node that points to the last element inserted. This makes it so that we don't have to go through the list each time to find the end:</p>

<pre><code>node* head = NULL, prev = NULL;

for (/* ... */)
{
    // ...
    if (head == NULL)
        head = prev = temp;
    else
    {
        prev-&gt;next = temp;
        prev = temp;
    }
}
</code></pre>

<p>The last thing is the way you're printing. You shouldn't have a nested for loop here:</p>

<pre><code>while (temp != NULL)
{
    for(int j = 0; j &lt; n; j++)
        cout &lt;&lt; temp-&gt;number &lt;&lt; "" "";
        temp = temp-&gt;next;
}
</code></pre>

<p>Taking it out will make it print correctly.</p>
",0
22113652,22033760,0,"<p>As of now there is no locale name found for 'GB18030'.</p>

<p>Only 'chs' is available and its used for Chinese language.</p>

<p>Regards,
Ganesh Sha</p>
",0
22890648,22890615,1,"<p>I suspect you meant to say:</p>

<pre><code>if(n &gt; 0 &amp;&amp; n &lt; 999999 &amp;&amp; b != nullptr) {
</code></pre>

<p>Remember, <code>num</code> is not initialized yet.</p>
",0
22890658,22890615,0,"<p>Perhaps you meant to put the assignment above the <code>if</code> statement?</p>

<pre><code>num = n;
if(num &gt; 0 &amp;&amp; num &lt; 999999 &amp;&amp; b != nullptr) 
</code></pre>

<p>I will say though, R Sahu's fix is better. Less variables. :)</p>
",0
22890659,22890615,0,"<p>Assuming num &amp;&amp; vname are memebers of Vacation</p>

<pre><code>Vacation::Vacation(int n, const char* b) : num(n), vname(nullptr) {
 if(num &gt; 0 &amp;&amp; num &lt; 999999 &amp;&amp; b != nullptr) {
     ...
  } 
 }
</code></pre>

<p>As with all other answers the key is to initialize members before you use them..</p>

<p>And since you allocate memory you should also build a destructor, copy-ctor and operator= to avoid memory leaks</p>
",0
22890960,22890615,0,"<p>I am assuming you missed out n instead of num. The class has n as a passed value. num is nt declared. Is num already declared s a global variable? i suggest you look at the problem.It could have been 'n'</p>
",0
27557158,27557056,3,"<p>Although function pointer casts are possible, calling a function through a function type which doesn't match the original type is undefined behavior. The reason function pointer casts are allowed is to support casting to and storing a common type but recovering the correct by casting the function pointer back before calling it. The basic background for this restriction is that even compatible pointers may require adjustment upon use. Hiding the correct signature would imply a suitable trampoline to exist (i.e., the function pointer would need to have additional state).</p>
",1
22876782,22876664,1,"<p>Well I'm going to add a fun way to do it.</p>

<p>Warning: I wouldn't actually ever do this, it is just a way to do what you like.</p>

<pre><code>#include&lt;iostream&gt;

int main()
{
    int foo = 0;
    switch ( foo ) 
    {
    case 0 :
        goto that;
        break;
    case 1 :
that :
        std::cout &lt;&lt; 'b';
        goto theOther; 
        break;
    case 2 :
theOther :
        std::cout &lt;&lt; 'a';
        goto andAnother;
        break;
    case 3 :
andAnother :
        std::cout &lt;&lt; 'r';
        break;
    }
    return 0;
}
</code></pre>

<p>You can't ""stack"" them freely. In C++ if you remove the break statements it will ""fall through"". For example this will give the same result...</p>

<pre><code>#include&lt;iostream&gt;

int main()
{
    int foo = 0;
    switch ( foo ) 
    {
    case 0 :
    case 1 :
        std::cout &lt;&lt; 'b';
    case 2 :
        std::cout &lt;&lt; 'a';
    case 3 :
        std::cout &lt;&lt; 'r';
    }
    return 0;
}
</code></pre>

<p>What the former would allow you to do is...</p>

<pre><code>#include&lt;iostream&gt;

int main()
{
    int foo = 0;
    switch ( foo ) 
    {
    case 0 :
        goto andAnother; 
        break;
    case 1 :
that :
        std::cout &lt;&lt; 'b'; 
        break;
    case 2 :
theOther :
        std::cout &lt;&lt; 'a';
        goto that;
        break;
    case 3 :
andAnother :
        std::cout &lt;&lt; 'r';
        goto theOther;
        break;
    }
    return 0;
}
</code></pre>
",1
26415729,26415511,2,"<p>Note that a loop will repeat <strong>the next statement</strong>. When you do it ""without calculations"", I assume you mean</p>

<pre><code>for (c = 1; c &lt;= 10; c++)
    cout &lt;&lt; setw(3) &lt;&lt; c;
cout &lt;&lt; endl;
</code></pre>

<p>Here, the first <code>cout</code> statement is repeated and prints out the table in your first screenshot. (Notice the indentation here which indicates what code is ""inside"" the for loop.)</p>

<p>Now when you add the calculations, you have</p>

<pre><code>for (c = 1; c &lt;= 10; c++)
    s = r + c; ** This one
    ts = ts + s; ** and this
    cout &lt;&lt; setw(3) &lt;&lt; c;

cout &lt;&lt; endl;
</code></pre>

<p>Even if you indent to show what you <strong>intend</strong> to repeat, the program will only repeat the statement immediately following the <code>for</code> loop header. In this case, you are repeating the calculation <code>s = r + c;</code> over and over. (Since this result is never used, the compiler most likely just throws it away.)</p>

<p>In order to repeat multiple statements, you need to wrap them in a ""compound statement"" which means using curly braces:</p>

<pre><code>for (c = 1; c &lt;= 10; c++)
{
    s = r + c; ** This one
    ts = ts + s; ** and this
    cout &lt;&lt; setw(3) &lt;&lt; s;
}

cout &lt;&lt; endl;
</code></pre>

<p>I also assume that you want to print out the sum of the row and column.</p>

<p>I strongly suggest that you <strong>always</strong> use curly braces, even when you repeat a single statement. This makes it easier to add more statements inside a loop because you don't have to remember to add the curly braces later.</p>
",0
26415543,26415511,2,"<p>I think you need to enclose the inner loop in curly brackets like so:</p>

<pre><code>for (r = 1; r &lt;= 10; r++)
{
    for (c = 1; c &lt;= 10; c++)
    {
    s = r + c;
    ts = ts + s;

    cout &lt;&lt; setw(3) &lt;&lt; c;
    cout &lt;&lt; endl;
    }
}
</code></pre>

<p>Otherwise you will only run the </p>

<pre><code>    s = r + c;
</code></pre>

<p>line in the inner loop.</p>
",1
26415592,26415511,1,"<p>You need a pair of curly brackets for your for loop</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
int main()
{
    int r, c, s = 0, ts = 0;  // r= row, c= column, s= sum(row+column), ts= sum of all entries   
    for (r = 1; r &lt;= 10; r++)
    {
        for (c = 1; c &lt;= 10; c++) { // &lt;- was missing
        s = r + c; ** This one
        ts = ts + s; ** and this

        cout &lt;&lt; setw(3) &lt;&lt; c;
        cout &lt;&lt; endl;
        } // &lt;- was missing

    }
    cout &lt;&lt; ""the total sum of all table entries is "" &lt;&lt; ts &lt;&lt; endl;
    system(""pause"");
    return 0;
}
</code></pre>

<p>Without the <code>{}</code>, only <code>s = r + c</code> will be considered part of the for loop. </p>

<p>Incidentally this is the cause of the <strong>goto fail</strong> bugs:  <a href=""http://martinfowler.com/articles/testing-culture.html"" rel=""nofollow"">http://martinfowler.com/articles/testing-culture.html</a> </p>
",0
26420130,26420021,3,"<p>If <code>getShipDef</code> returns a pointer you have to use the <code>-&gt;</code> operator to access its members:</p>

<pre><code>mPhysicsBody = physicsWorld-&gt;CreateBody(
     Game::getInstance()-&gt;getShipDef(shipType)-&gt;mBodyDef
);
</code></pre>

<p>If <code>a</code> is a pointer the expression <code>a-&gt;b</code> is equivalent to <code>(*a).b</code> so in your case you could have also written</p>

<pre><code>mPhysicsBody = physicsWorld-&gt;CreateBody(
     (*(Game::getInstance()-&gt;getShipDef(shipType))).mBodyDef
);
</code></pre>
",1
23066041,23065916,2,"<p>You may be able to do what you want with std::system() calls like:</p>

<pre><code>std::system(""program -e input_commands.txt""); // Assuming it accepts some sort of command line args
std::system(""program &lt; input_commands.txt""); // Assuming it responds to stdin
</code></pre>

<p>It depends on the program if this approach will work.</p>
",0
22853283,22853160,0,"<p>Adding is.ignore() before the call to is.getline(desc, 61) fixes the problem</p>
",0
22853299,22853160,1,"<p>You are probably getting this <code>error</code> due your assign operation at your if statement.</p>

<pre><code>if (desc[0] = '\0') {
</code></pre>

<p>should be:</p>

<pre><code>    if (desc[0] == '\0') {
         //do your code here
}
</code></pre>
",0
22459783,22459722,2,"<p>Use </p>

<pre><code>prime_n p(num);
</code></pre>

<p>or (not recommended in this particular case)</p>

<pre><code>prime_n * p = new prime_n(num);
// some other code
req_num = p-&gt;get_num(); // note the -&gt; operator replacing . in case of pointers

delete p;
</code></pre>

<p>The first case declares <code>p</code> on stack and it is automatically deallocated when the program leaves the scope (<code>main</code> function in this case)</p>

<p>The second one allocates space on heap and <code>p</code> is the pointer to it. You have to deallocate the memory manually. </p>

<p>As for your second question, the C++ way would be</p>

<pre><code>#include &lt;iostream&gt;

...
int num;
std::cout &lt;&lt; ""Enter the position at which prime number is to be found ""
std::cin &gt;&gt; num;
std::cout &lt;&lt; std::endl &lt;&lt; ""Number = "" &lt;&lt; num &lt;&lt; std::endl;
</code></pre>
",1
22461139,22459722,1,"<p>You provide a constructor:</p>

<pre><code> prime_n(int num)
 {
     n=num;
     store[n];
 }   
</code></pre>

<p>I think you are under the impression that <code>store[n]</code> creates an array with n elements, but that is not so; it attempts to access the (n+1)th element of an an array. Since store does not point anywhere (we are in the constructor, after all), the program crashes.</p>

<p>You probably want to write <code>store = new int[num]</code> instead.</p>

<p>And then I cannot see any call to find_n() originating from get_num() which is called in main(), so that your program would for now just return a random value.</p>
",0
29480618,29476140,1,"<p>In this sample, your code appears to be stepping down the left side of each tree (but ignoring the right side).</p>

<pre><code>if(top-&gt;left!=NULL)
{
  top=top-&gt;left;
  display();
}
</code></pre>

<p>Generally, a BST has nodes, each node has data, a ptr to left child, and a ptr to right child.</p>

<p>And it appears that your nodes do not yet contain a ""display()"" method.</p>

<hr>

<p>In a tree, I suspect you want to be invoking</p>

<pre><code>&lt;a node&gt; -&gt; display();
</code></pre>

<p>To avoid passing pointers in your recursive 'display' calls.</p>

<p>Next, your names are misleading (to me).  So perhaps if you rename some things, the following might be appropriate and more understandable to you.</p>

<p>Each node needs at least 3 parts, and the display method.  For a depth-first-search, in-line display maybe the following will trigger some thoughts.</p>

<pre><code>Node::display(void)
{
   // first, display nodes of left side-of-tree
   if(nullptr != left)
   { 
       left-&gt;display();
   }
   // else no left node available


   // for in-order, cout the data at this node
   std::cout &lt;&lt; data &lt;&lt; std::endl;


   // continue the depth-first display by tracing the right side
   if (nullptr != right)
   {
       right-&gt;display();
   }
}
</code></pre>

<p>To begin the the display track, you need to have an anchor of the tree.  Perhaps something like:</p>

<pre><code>Tree::display()
{
   if(tree.Top) // is tree not empty?
      tree.Top-&gt;display();
   ...
</code></pre>

<p>So ... I am suggesting a class for tree, another class for node, a display method for tree, a display method for node, etc.</p>

<p>Hope this helps ... Good luck.</p>
",0
22465312,22464649,1,"<p>Now this finally works.....</p>

<p>It had errors such as -
<br>1. Tried copy string by assignment operator. You should use <code>strcpy()</code> for that.
<br>2. Declared variables locally and used them globally.
<br>3. Had typing mistakes.
<br>4. The code does not contain declaration for the Net Amount which is to be printed at last.
<br>5. TAX was never used, which then I used at last where the final results where displayed.
<br>6. while and switch was declared outside a function/method.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;

using namespace::std;    

struct menuItemType
{
    char menuItem[20];
    double menuPrice;
};

void getData(menuItemType menuList[8]);
void showMenu(menuItemType menuList[8], menuItemType orderList[], int orderCounter, int selection);
void printCheck(menuItemType menuList[8], int orderCounter, const double TAX);

const int MAX = 8;
const double TAX = 1.05;

menuItemType menuList[8];
menuItemType orderList[MAX];

int main()
{
    int orderCounter = 0;
    int selection = ' ';



    getData(menuList);
    showMenu(menuList, orderList, orderCounter, selection);
    printCheck(orderList, orderCounter, TAX);

return 0;
}

void getData(menuItemType menuList[8])
{

strcpy(menuList[0].menuItem,""Plain Egg"");
menuList[0].menuPrice = 1.45;
strcpy(menuList[1].menuItem,""Bacon and Egg"");
menuList[1].menuPrice = 2.45;
strcpy(menuList[2].menuItem,""Muffin"");
menuList[2].menuPrice = 0.99;
strcpy(menuList[3].menuItem,""French Toast"");
menuList[3].menuPrice = 1.99;
strcpy(menuList[4].menuItem,""Fruit Basket"");
menuList[4].menuPrice = 2.49;
strcpy(menuList[5].menuItem,""Cereal"");
menuList[5].menuPrice = 0.69;
strcpy(menuList[6].menuItem,""Coffee"");
menuList[6].menuPrice = 0.50;
strcpy(menuList[7].menuItem,""Tea"");
menuList[7].menuPrice = 0.75;

}

void showMenu(menuItemType menuList[8], menuItemType orderList[], int orderCounter, int selection)
{
cout &lt;&lt; ""1 - Plain Egg"" &lt;&lt; setw(14) &lt;&lt; ""$1.45"" &lt;&lt; endl;
cout &lt;&lt; ""2 - Bacon and Egg"" &lt;&lt; setw(10) &lt;&lt; ""$2.45"" &lt;&lt; endl;
cout &lt;&lt; ""3 - Muffin"" &lt;&lt; setw(17) &lt;&lt; ""$0.99"" &lt;&lt; endl;
cout &lt;&lt; ""4 - French Toast"" &lt;&lt; setw(11) &lt;&lt; ""$1.99"" &lt;&lt; endl;
cout &lt;&lt; ""5 - Fruit Basket"" &lt;&lt; setw(11) &lt;&lt; ""$2.49"" &lt;&lt; endl;
cout &lt;&lt; ""6 - Cereal"" &lt;&lt; setw(17) &lt;&lt; ""$0.69"" &lt;&lt; endl;
cout &lt;&lt; ""7 - Coffee"" &lt;&lt; setw(17) &lt;&lt; ""$0.50"" &lt;&lt; endl;
cout &lt;&lt; ""8 - Tea"" &lt;&lt; setw(21) &lt;&lt; ""$0.75\n"" &lt;&lt; endl;
do{
    cout &lt;&lt; ""Enter the number of your selection until you have completed your order."" &lt;&lt; endl;
    cout &lt;&lt; ""Enter 9 when you have finished."" &lt;&lt; endl;
    cin &gt;&gt; selection;

    switch(selection)
    {
        case 9:
        break;
        case 1:
        cout &lt;&lt; menuList[0].menuItem &lt;&lt; setw(14) &lt;&lt; ""$1.45"";
        break;
        case 2:
        cout &lt;&lt; menuList[1].menuItem &lt;&lt; setw(10) &lt;&lt; ""$2.45"";
        break;
        case 3:
        cout &lt;&lt; menuList[2].menuItem &lt;&lt; setw(17) &lt;&lt; ""$0.99"";
        break;
        case 4:
        cout &lt;&lt; menuList[3].menuItem &lt;&lt; setw(11) &lt;&lt; ""$1.99"";
        break;
        case 5:
        cout &lt;&lt; menuList[4].menuItem &lt;&lt; setw(11) &lt;&lt; ""$2.49"";
        break;
        case 6:
        cout &lt;&lt; menuList[5].menuItem &lt;&lt; setw(17) &lt;&lt; ""$0.69"";
        break;
        case 7:
        cout &lt;&lt; menuList[6].menuItem &lt;&lt; setw(17) &lt;&lt; ""$0.50"";
        break;
        case 8:
        cout &lt;&lt; menuList[7].menuItem &lt;&lt; setw(20) &lt;&lt; ""$0.75"";
        break;
        default:
        cout &lt;&lt; ""Invalid Selection! Selections must be between 1 and 9\n"";
    }
}while (selection !=9);
    if((selection &gt;=0) &amp;&amp; (selection &lt;= MAX))
    {
    strcpy(orderList[orderCounter].menuItem, menuList[selection-1].menuItem);
    orderList[orderCounter].menuPrice = menuList[selection-1].menuPrice;
    orderCounter++;
    }
    else if (selection == 9)
    cout &lt;&lt; ""Exit"" &lt;&lt; endl;
    else
    cout &lt;&lt; ""Invalid Entry"" &lt;&lt; endl;

}


void printCheck(menuItemType orderList[], int orderCounter, const double TAX)
{
    cout &lt;&lt; ""Welcome to the Breakfast Place!""&lt;&lt; endl;

    for (orderCounter = 0; orderCounter &lt; MAX; orderCounter++)
    cout &lt;&lt; orderList[orderCounter].menuItem &lt;&lt; "" ""&lt;&lt; orderList[orderCounter].menuPrice&lt;&lt; endl;
    cout &lt;&lt; ""Tax"" &lt;&lt; setw(10) &lt;&lt; TAX&lt;&lt;endl;
    cout &lt;&lt; ""Amount Due"" &lt;&lt; setw(10) &lt;&lt; endl;

}
</code></pre>

<p>The above code is rectified, but the logical errors are still there, you should look at them as you have not mentioned your logics in your code. The <code>amount</code> is still not displayed as you haven't added a code for that!</p>
",0
22465614,22464649,1,"<p>You initialized orderCounter in main but you are not returning it in any function so in the end it still will be 0. Same thing goes for arrays. Functions in c++ are working on copies of passed data unless arguments are passed by reference or pointers. In your case you may want to use global declarations for orderCounter and arrays of your structs.  It is NOT the best solution but it works. Or if you want to stick to your current code read a little about functions and passing arguments. <a href=""http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/"" rel=""nofollow"">http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/</a></p>
",0
21583733,21583694,7,"<p>Because <code>[i]arr == *(i + arr) == arr[i]</code> </p>

<p>Note: <code>+</code> operator holds <code>commutative</code> property </p>
",1
26787156,26786976,3,"<p>Change this</p>

<pre><code>} while (((fCurrentPayload + fParcelWeight)) &lt; fVanCapacity);
</code></pre>

<p>to this</p>

<pre><code>} while (((fCurrentPayload + fParcelWeight)) &lt; fVanCapacity
          &amp;&amp; iParcelLoaded &lt; iParcelCount);
</code></pre>

<p>That way you will load as many items the user inputs. You code contains many syntax errors.</p>

<p>I corrected them for you, but please be more careful next time you post.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

char cBeltFull;
int iVanCount, iParcelCount, iParcelLoaded;
float fHeaviestVanWeight, fParcelWeight, fCurrentPayload, fVanCapacity;
char cExit = 'N';

int main() {

    iVanCount = 1;
    iParcelLoaded = 1;
    fHeaviestVanWeight = 0;
    fVanCapacity = 410;


    do {
        //Get the number of parcels to dispatch
        cout &lt;&lt; ""How many parcels need sending?"" &lt;&lt; endl;
        cin &gt;&gt; iParcelCount;

        do {
            fCurrentPayload = 0;

            do {

                //Get parcel weight
                cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl &lt;&lt; ""What is the weight the parcel "" &lt;&lt; iParcelLoaded &lt;&lt; ""?"";
                cin &gt;&gt; fParcelWeight;

                //'Load' the parcel
                cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; ""Parcel loaded"";
                iParcelLoaded ++;

                //Update the payload
                fCurrentPayload = fCurrentPayload + fParcelWeight;

            } while (((fCurrentPayload + fParcelWeight)) &lt; fVanCapacity &amp;&amp; iParcelLoaded &lt; iParcelCount);

            //Dispatch the van
            cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; ""Van dispatched."";

            //Update the van count
            iVanCount ++;

            if (fCurrentPayload &gt; fHeaviestVanWeight) {

                //Update the heaviest weight
                fHeaviestVanWeight = fCurrentPayload;

            }

        } while (iParcelLoaded &lt;= iParcelCount);

        cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl &lt;&lt; ""Vans dispatched: "" &lt;&lt; iVanCount;
        cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; ""Weight of heaviest van: "" &lt;&lt; fHeaviestVanWeight;

        cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl &lt;&lt; ""Exit?  Y for YES or N for NO."" &lt;&lt; endl;
        cin &gt;&gt; cExit;

    } while (cExit == 'N');

}
</code></pre>
",2
23577306,23577273,1,"<p>you can use a count global variable to find out</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

long int A(int, int);
int count=0;

int main()
{
    int m, n;
        cout &lt;&lt; ""Enter two numbers for Ackerman's Function."" &lt;&lt; endl;
        cin &gt;&gt; m &gt;&gt; n;

        cout &lt;&lt; A(m, n) &lt;&lt; endl;
        count &lt;&lt; "" Ackerman's Function runs "" &lt;&lt; count &lt;&lt; "" times."";
}

long int A(int m, int n)
{   
    count++;
    if(m == 0)
    {
        return n+1;
    }
    else if(m &gt; 0 &amp;&amp; n == 0)
    {
        return A(m-1,1);
    }
    else if(m &gt; 0 &amp;&amp; n &gt; 0)
    {
        int temp = A(m,n-1);
        return A(m-1, temp);
    }
}
</code></pre>
",0
23577338,23577273,0,"<p>Add an extra parameter of type <code>int&amp;</code> to your <code>A</code> function: </p>

<pre><code>long int A(int m, int n, int&amp; count)
{   
    count++;
</code></pre>

<p>And update the prototype, and the recursive calls to match.</p>

<p>In your main function:</p>

<pre><code>int count = 0;
cout &lt;&lt; A(m, n, count) &lt;&lt; endl;
cout &lt;&lt; ""A calls: "" &lt;&lt; count &lt;&lt; endl;
</code></pre>

<p>This avoids globals, which are problematic.</p>
",0
24349694,24349613,0,"<p>Do something like:</p>

<pre><code>int x = a;
int i = 0;
while (x &gt; 0)
{
    b[i++] = x % 10;
    x /= 10;
}
</code></pre>
",5
24349710,24349613,0,"<p>you can do something like this</p>

<pre><code>int i=100;
for(int x=0;x&lt;3;x++)
{
    b[x]=a/i;
    a=a%i;
    i=i/10;
}
</code></pre>
",1
31235882,31235843,3,"<p>Yes, it seems self-evident that leaving the stream in the state you found it (as pertains to formatting flags) is a decent thing to do in the general case.</p>

<p>Whether you should actually do it in your specific case entirely depends on what other components use the same stream and what their expectations are of it.</p>
",0
31543928,31543423,1,"<p>If you want a mutable object that cannot be overwritten you could make the class's <code>operator=</code> private/protected.</p>
",3
31545244,31543423,1,"<p>I would suggest wrapping the global <code>Param</code> object with non-member functions in an appropriate namespace and then implementing those functions using a <code>Param</code> object that is private to the implementation.</p>

<p>Something along the lines of:</p>

<p>GlobalParam.h:</p>

<pre><code>#pragma once

namespace GlobalParam
{
   void setParam1(Args ...);
   void setParam2(Args ...);

   Type1 getParam1();
   Type2 getParam2();

   // etc.
}
</code></pre>

<p>GlobalParam.cc:</p>

<pre><code>#include ""GlobalParam.h""

namespace GlobalParam
{
   // Provide a function that returns a reference
   // to the global Param object. All functions make use of
   // this object. This function is not exposed to the users of
   // the API.
   Param&amp; getParam()
   {
      static Param param;
      return param;
   }

   void setParam1(Args ... args) { getParam().setParam1(args...); }
   void setParam2(Args ... args) { getParam().setParam2(args...); }

   Type1 getParam1() { return getParam().getParam1(); }
   Type2 getParam2() { return getParam().getParam2(); }

   // etc.
}
</code></pre>
",2
32469634,32469312,4,"<p>The problem is in here:</p>

<pre><code>int r;
while(r != 0)
{
    r = m % n;
    m = n;
    n = r;
}
return m;
</code></pre>

<p>The value of <code>r</code> is not initialized to anything, so if the initial value is zero, the algorithm will terminate on the while loop and just return the value of <code>m</code> unchanged.</p>

<p>C++ is not required to initialize the values of stack variables to any default value or anything else, so the value in the <code>r</code> variable is whatever was left on the stack by the previous function call. It would seem that it just so happens that <code>cout &lt;&lt; endl;</code> leaves a nonzero value in the correct stack position for <code>r</code> to have a nonzero value, and actually run the algorithm. (Note that  if C++ did supply a default value, the default value would presumably be zero anyway, so you would still be forced to initialize).</p>

<p>In general, you should initialize the default values of stack variables to a safe value, rather than relying on their default values. So in this case, the fix is to set <code>r</code> to any nonzero value when you first declare it. E.g. <code>int r = 1;</code></p>

<p><em>Side note:</em> In C/C++ any integer value can be used as a boolean, and zero is false, so your while condition can be simplified to just <code>while(r)</code> rather than <code>while(r != 0)</code>; these are completely equivalent  expressions as far as the while loop is concerned.</p>
",0
32469640,32469312,0,"<p>when program's result changes like this, it is likely you forgot to initalize some variable. In your case, it looks you forgot to initialize r:</p>

<pre><code>int r;
while(r != 0)
</code></pre>

<p>'r' will get an arbitrary value (whatever happens to be in the CPU register). It is likely that without print statements, r is zero and thus the while() loop never runs. You want to set to non-zero value explicitly.</p>
",2
23822988,23822925,1,"<p>You should use standard function <code>std::getline</code> with argument of type <code>std::string</code> and after that use <code>std::istringstream</code> to parse each line.</p>

<p>For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

//...

std::string line;

while ( std::getline( YourFile, line )
{
   std::istringstream is( line );
   // using `operator &gt;&gt;` to read items in the line
}
</code></pre>
",0
23842161,23841630,0,"<p>Since the erroe happens at allocation if an array (<code>list = new Task[capacity]</code>) i guess your problem is in default constructor of Task class. try playing with this constructor a liitle , i suggest allocating yor char arrays (names , descriptions and data) befor filling them.</p>

<p>somecode like <code>name = new Char[14];</code> (and of course same for the other two)</p>
",1
23842356,23841630,2,"<p>Here is the problem:</p>

<pre><code>char *name;

// ...

strcpy(name, ""no course name"");
</code></pre>

<p>The first line creates a pointer which currently does not point anywhere. Then you tell <code>strcpy</code> to copy that string to where the pointer is pointing, so it writes the string to ""nowhere"" (in practice: a semi-random memory location). This causes your access violation.</p>

<p>To fix this, replace the code with:</p>

<pre><code>std::string name;

// ...

name = ""no course name"";
</code></pre>

<p>Do the same for <code>description</code> and <code>date</code>. Note that this means you don't need a copy-constructor or copy-assignment operator or destructor; because the default ones behave correctly.</p>

<p>Of course you will need to change your accssor functions (but they were badly designed anyway since the caller cannot prevent a buffer overflow):</p>

<pre><code>std::string getName() const { return name; }
</code></pre>

<p>Also, change <code>Task *list;</code> to <code>std::vector&lt;Task&gt; list;</code> and stop using <code>new</code> and <code>delete</code>. The vector correctly manages memory for you.  </p>

<p>It is simplest and easiest to do this task without using pointers or manual memory management or C-library functions such as <code>strcpy</code>. You'll halve your code size (at least) and it will be much less prone to error. </p>

<p>You may need <code>#include &lt;string&gt;</code> and <code>#include &lt;vector&gt;</code>.</p>
",1
23849047,23841630,0,"<p>You have failed to follow the rule-of-five or the rule-of-zero.</p>

<p>The correct thing (rule-of-zero) would be to implement TaskList in terms of <code>std::vector&lt;Task&gt;</code>.</p>

<p>Seeing as your assignment demands that you use a ""dynamic array"", perhaps they don't want you to use <code>std::vector</code>. This means that you are stuck with manual memory management. This means that you need to correctly implement or remove the following functions:</p>

<pre><code>//You have these
TaskList::TaskList();
TaskList::TaskList(char filename[]);
TaskList::~TaskList();

//You are missing these, this is your problem:
TaskList::TaskList(TaskList const &amp;o); //Copy constructor
TaskList &amp;TaskList::operator=(TaskList const &amp;o); //Copy assignment
TaskList::TaskList(TaskList &amp;&amp;o); //Move constructor
TaskList &amp;TaskList::operator=(TaskList &amp;&amp;o); //Move assignment
</code></pre>

<p>If you do not explicitly supply these functions, the compiler may automatically generate them, and the compiler-generated versions will be incorrect (for the situation where you are manually managing resources within <code>TaskList</code>), as they will do member-wise moves or copies, rather than copying or moving the underlying resources. When you then use these incorrect compiler-generated versions, your code will have strange behaviour.</p>

<p>For <code>Task</code>, you shouldn't be managing multiple resources at once. Use <code>std::string</code>, or otherwise write your own string class, and then use it to manage the string members of <code>Task</code>. If you do not, your code is almost guaranteed to be incorrect (due to a lack of exception safety).</p>
",0
21719556,21719531,2,"<p>What you want might be:</p>

<pre><code>void allocate_mem(XYZ** paVar){
   *paVar = new XYZ[10];
}

XYZ* a;
allocate_mem(&amp;a);
</code></pre>
",0
21719565,21719531,3,"<p>If you want to pass it outside, you need to pass the reference to the variable.<br>
This way the variable's contents can be changed:</p>

<pre><code>allocate_mem(XYZ**&amp; paVar){
   paVar = new XYZ*[10];
}
</code></pre>
",0
21719617,21719531,0,"<p>You may want to try avoiding hand-crafted memory allocation alltogether by using a <code>vector</code>:</p>

<pre><code>typedef std::vector&lt;double&gt; row;
std::vector&lt;row&gt; a(10);

a[1].push(0.5);
...
</code></pre>
",0
21566079,21559066,0,"<p>The function pow returns a double value. The problem might be that it is being used along with long integers in the same sentence in your second snippet. Try changing this line to:</p>

<pre><code>Bin = Bin + Rem*((long) pow(10,i));
</code></pre>
",1
24640432,24640308,1,"<p>The error is that you are giving a list of pairs , say <code>{{0,1},{1,2},{2,3}...}</code> and are asking to find the range of values equal to (for example) <code>2</code>.  The compiler has no idea how to compare a <code>pair&lt;double,double&gt;</code> and a <code>double</code>.</p>
",3
22885834,22885467,2,"<blockquote>
  <p>If I dont add \n or std::endl std::cout will buffer data?</p>
</blockquote>

<p>Yes, exactly.</p>

<p><code>std::flush</code> explicitly flushes the stream. <code>'\n'</code> on its own doesn't do any flushing at the C++ level, but may trigger a flush at a lower level. <code>std::endl</code> prints a <code>'\n'</code> then does a <code>std::flush</code>.</p>

<p>Certainly, without any of those, you can't realistically expect a flush before your <code>std::cin</code>.</p>
",22
21772530,21772378,0,"<p>You cannot directly write the object and expect it to store everything properly when you have members that don't have a fixed size.
If it were <code>char</code> array you could use this way.</p>

<p>Given this situation, I would manually write the details, like length of <code>username</code> first, then write characters in <code>username</code> so that while reading I can read the length of username and read that number of characters from file.</p>
",0
21775925,21773681,0,"<pre><code>char capSentStart(char paragraph[], char newParagraph[])
{
    int index=0;

    for(int i = 0; i &lt; 301; ++i)
    {  
        index=i; 
        if(paragraph[i] == '.' &amp;&amp; paragraph[i + 1] == ' ')
        {   
            newParagraph[i] = '.';
            newParagraph[i + 1] = ' ';
            newParagraph[i + 2] = ' ';
            newParagraph[i + 3] = toupper(paragraph[i + 2]);
            index=i+3;
       }   
       else
       {   
           newParagraph[i] = paragraph[i];
       } 
       i=index;
    }   
}
</code></pre>
",0
21773842,21773681,0,"<p>Use following:</p>

<pre><code>char capSentStart(char paragraph[], char newParagraph[])
{

    for(int i = 0,j = 0; i &lt; 301; ++i,++j)
    {   
        if(paragraph[i] == '.' &amp;&amp; paragraph[i + 1] == ' ')
        {   
            newParagraph[j] = '.';
            newParagraph[j + 1] = ' ';
            newParagraph[j + 2] = ' ';
            newParagraph[j + 3] = toupper(paragraph[i + 2]);
            j=j+3;
            i=i+2;
        }   
        else
        {   
            newParagraph[j] = paragraph[i];
        }   
    }   
}
</code></pre>
",0
21773947,21773681,0,"<p>Executing the first iteration in <code>if(paragraph[i] == '.' &amp;&amp; paragraph[i + 1] == ' ')</code>, gives:</p>

<pre><code>          paragraph[i] = '.'
                    ^
   paragraph = ""Dude. dude.  ...""
newParagraph = ""Dude. D         ""
</code></pre>

<p>After <code>++i</code> and the increment of i in the <code>for</code>loop, <code>i</code> moves to the following:</p>

<pre><code>            paragraph[i] = 'd'
                      ^
   paragraph = ""Dude. dude.  ...""
newParagraph = ""Dude. D         ""
</code></pre>

<p>But this time, the iteration executes the code in <code>else</code>.</p>

<pre><code>else
{
    newParagraph[i] = paragraph[i];
}
</code></pre>

<p>This changes the <code>newParagraph[i]</code> which is <code>D</code> to <code>paragraph[i]</code>, which is <code>d</code>.</p>

<pre><code>            paragraph[i] = 'd'
                      ^
   paragraph = ""Dude. dude.  ...""
newParagraph = ""Dude. d         ""   //'D' is changed back to 'd'
</code></pre>

<p>Afterwards, <code>newParagraph</code> just get overwritten into <code>paragraph</code>.</p>
",0
21773789,21773681,0,"<p>In the True case of the if statement you are filling newParagraph but when you keep itterating you are overwriting them again in the false case of the if statement. You should have two itterating variables for Paragraph and new Paragraph.</p>

<p>In order to give you a more detailed answer you should tell us the expeced output.</p>
",0
21773808,21773681,2,"<p>As per your code, if the current character is <code>"".""</code>, then you are doing what you want inside the <code>if condition</code>. Consider the cases, when the current character is not <code>"".""</code>. You are merely copying the original paragraph which replaces the previous characters in the <code>newParagraph</code>.</p>

<p>Say input: <code>Dude. dude.</code></p>

<p>When the current character is the first <code>.</code>, the <code>newParagraph</code> at the end of iteration is:</p>

<pre><code>Dude. D___
</code></pre>

<p>where <code>_</code> indicates the characters yet to be filled.</p>

<p>But, in the next four iterations, we don't find a <code>.</code>. So, you are copying the data from the <code>input</code> into the <code>newParagraph</code> thus over-writing the changes.</p>

<pre><code>Dude. dude.
</code></pre>

<p><strong>EDIT:</strong></p>

<p>Your code is trying to convert the first character of every sentence to upper Case. Here is how it should be modified:</p>

<pre><code>char capSentStart(char paragraph[], char newParagraph[])
{
    int new_paragraph_idx=0;
    for(int i = 0; i &lt; 301; ++i)
    {   
        if(paragraph[i] == '.' &amp;&amp; paragraph[i + 1] == ' ')
        {   
            newParagraph[new_paragraph_idx++] = '.';
            newParagraph[new_paragraph_idx++] = ' ';
            newParagraph[new_paragraph_idx++] = ' ';
            newParagraph[new_paragraph_idx++] = toupper(paragraph[i + 2]);
            ++i;
        }   
        else
        {   
            newParagraph[new_paragraph_idx++] = paragraph[i];
        }   
    }   
}
</code></pre>

<p>Put a <code>new_ptr</code> which actually fills the <code>newParagraph</code> separately, thus preventing the over-writing. And also take care of the bounds of the strings. Otherwise you might end up with a <a href=""http://en.wikipedia.org/wiki/Segmentation_fault"" rel=""nofollow"">SIGSEGV</a></p>
",1
21773814,21773681,0,"<p>You are always writing based on the index <code>i</code>. Even if you write on higher indexes in <code>newParagraph</code>, then the follow iterations will overwrite what was done.</p>
",0
24376456,24376410,2,"<p>Here is your problem</p>

<pre><code>while (selection != 'Q');
</code></pre>

<p>This results in an infinite while loop. You probably want:</p>

<pre><code>while (selection != 'Q')
{
    int transaction = 0;
    ...
</code></pre>

<p>Here is another one:</p>

<pre><code>while (weekSalary &gt;= 0)
</code></pre>
",2
22120669,22120595,0,"<p>The expression <code>pos++</code> uses <strong>post increment</strong>, which produces the original value of <code>pos</code> as the expression result. Thus the <code>pos</code> argument does not increase in the recursive call. Thus, you get <strong>infinite recursion</strong>, which if you're lucky crashes when it's used up all stack space.</p>
",2
22120722,22120595,0,"<p>There are several issues (at least) with that code:</p>

<p>1)</p>

<pre><code>Member *First_member;
</code></pre>

<p>is only a declaration. To turn it into a definition, you need to actually allocate memory, e.g:</p>

<pre><code>Member *First_member = new Member;
</code></pre>

<p>and also release it in the end, e.g. (not necessarily the best way to do it, but my C++ is a little rusty):</p>

<pre><code>void free(Member* _member) {
    Member* _next = _member-&gt;next_member;
    if (_next!=NULL) free(_next);
    delete _member;
}

Member* First_member = new Member;
// some code ...
free(First_member);
</code></pre>

<p>2) More serious problem is your Member2 method: it does not check whether its Member *member_ arguments is not NULL (in which case the code will indeed crash, because it tries to work with garbage as if it was data).</p>

<p>3) Member2 should also take care about allocating memory for the next element in the chain, e.g.:</p>

<pre><code>if (member_-&gt;next_member == NULL) {
    member-&gt;next_member = new Member;
}
Member2 (member_-&gt;next_member, pos++, rand(), N);
</code></pre>
",0
34221682,34221312,0,"<p>I think you have to define your FILE_LOCATION macro, I cannot see the code where you define it in your snippet.
But wouldn't the code below do it?</p>

<pre><code> #define FILE_LOCATION __FILE__ "": "" STR(__LINE__)
</code></pre>
",0
22493755,22493378,2,"<p>I think using FTP can be a good method.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa384180%28v=vs.85%29.aspx"" rel=""nofollow"">WinInet</a> and <a href=""http://curl.haxx.se/libcurl/c/ftpupload.html"" rel=""nofollow"">libcurl</a> have function relative FTP.</p>

<p>Many developers have been recommanding using libcurl rather than using WinInet. 
However, it depends complexity and scale of your application.</p>
",1
22493858,22493378,0,"<p>The by far easiest would be to use a network share resp. share a directory on the target computer. That would work with *nix systems as well, using Samba. If that's possible the operation boils down to simple file system copies. If that's not possible: </p>

<p>I think you must create an archive of the directory tree before you can send it through a network connection. You could call that serializing. .NET 4.5 has built-in support for creating zip files, cf. <a href=""http://msdn.microsoft.com/en-us/library/system.io.compression.ziparchive%28v=vs.110%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/system.io.compression.ziparchive%28v=vs.110%29.aspx</a>. </p>

<p>How to traverse a dorectory tree is shown in <a href=""http://msdn.microsoft.com/en-us/library/07wt70x2%28v=vs.110%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/07wt70x2%28v=vs.110%29.aspx</a>. </p>

<p>How to use FTP programmatically is shown in <a href=""http://msdn.microsoft.com/en-us/library/ms229715%28v=vs.110%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/ms229715%28v=vs.110%29.aspx</a>. But you'll need a running FTP server on the remote machine.</p>

<p>The remaining problem is how to unzip the file at the destination. For that you'll need a logon.</p>
",0
27571901,27571739,0,"<p>CppReference says: ""This function only reports the stream state as set by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a get(), which returned the last byte of a file, eof() returns false. The next get() fails to read anything and sets the eofbit. Only then eof() returns true.""</p>

<p>oefbit will turn true when a read operation attempts to read beyond end of file, but not when it reads exactly to the end of file without trying to go further. When you read the char, it knows it should read a single byte, so this read operation is ok, the read position advance 1 byte, goes to the end, but let say the the stream still haven't noticed that it is indeed the end, it will if you try to read something else. When you read an integer, it tries to read beyond 42 because the length of the integer is not clear, it could have been 42901, so it has to read until it sees an space, and end of line, or eventually the end of the file/stream if there's nothing else to read.</p>

<p>And the result of the operator >> is the stream itself. When it is converted to void* (or bool, depends on c++11 or previous) it works as !fail(), so it tells you if the read or write operation was ok, regardless of whether it reached the end of file (next read operation will fail if it is now at the end).</p>
",0
27571910,27571739,0,"<p>The EOF condition doesn't actually occur until you try to read <em>past</em> the end of the stream.</p>

<p>In the <code>char</code> case you read exactly one character, the only one available. You don't try to read past the end because there is no need to.</p>

<p>Extracting an <code>int</code> on the other hand attempts to consume as many digits as possible.  It reads the 4 and the 2, and then it tries to read again to see if there is another digit to consume, it <em>does</em> attempt to read past the end in this case.  It notices that the input came to an end and so finishes the conversion of 42.</p>
",0
27572060,27571739,0,"<p>when extracting chars, it will pull a single character at a time and skip white spaces on consecutive calls.</p>

<p>when extracting int, the parser attempts to pull as many characters out to form the number. this causes the integer extraction to hit the eof in your test case.</p>
",0
26792024,26791979,1,"<p>In C/C++, this is an integer division:</p>

<pre><code>5/12
</code></pre>

<p>What you want is a floating point division:</p>

<pre><code>5.0/12.0
</code></pre>

<p>Please note that this has absolutely <em>nothing</em> to do with GLUT or OpenGL.</p>
",1
22130700,22130620,0,"<p>Some pseudocode:</p>

<pre><code>main(){
  nMax;
  avg;
  end = false;
  num;
  nNums = 0;

  cout &lt;&lt; ""to exit enter -1"";

  while(!end){
    do{
    cout &lt;&lt; ""Enter number"";
    cin &gt;&gt; num;
    }while(num &lt; -2 || num &gt; 100);
    if ( num &lt; 0){
      end = true;
    }else{
      avg = ((avg * nNums) + num) / ++nNums;
      nMax = max(nMax, num);
    }
  }
  cout &lt;&lt; avg &lt;&lt; "", "" &lt;&lt; nMax;
}
</code></pre>
",0
22130728,22130620,0,"<p>Here you are:</p>

<pre><code>#include &lt;iostream&gt;

int main(){
   int num;
   int sum=0, count=0;
   int maxGrade = -1;
   std::cout&lt;&lt;""To get final and highest score, enter -1.""&lt;&lt;std::endl;

   while(true) {
     std::cout&lt;&lt;""Enter the score for student ""&lt;&lt;count+1&lt;&lt;"":""&lt;&lt;std::endl;
     std::cin&gt;&gt;num;
     if(num == -1) break;                // &lt;&lt;&lt;&lt; test specifically for break condition
     if(num &lt; 0 || num &gt; 100) {          // &lt;&lt;&lt;&lt; test for any other invalid input
      std::cout&lt;&lt;""Invalid grade. You must enter a number between 0 and 100.\n"";
     }
     else {
       count++;                          // &lt;&lt;&lt;&lt; track number of valid inputs
       sum += num;                       // &lt;&lt;&lt;&lt; track total grade
       if(num&gt;maxGrade) maxGrade = num;  // &lt;&lt;&lt;&lt; track highest grade so far
     }
   }
  std::cout&lt;&lt;""Number of students: ""&lt;&lt;count&lt;&lt;std::endl;
  std::cout&lt;&lt;""Average is ""&lt;&lt; sum * 1.0 / count&lt;&lt;std::endl;
  std::cout&lt;&lt;""Highest grade is ""&lt;&lt;maxGrade&lt;&lt;std::endl;

return 0;
}
</code></pre>

<p>Sample output:</p>

<pre><code>To get final and highest score, enter -1.
Enter the score for student 1:
78
Enter the score for student 2:
55
Enter the score for student 3:
98
Enter the score for student 4:
-2
Invalid grade. You must enter a number between 0 to 100.
Enter the score for student 4:
88
Enter the score for student 5:
-1
Number of students: 4
Average is 79.75
Highest grade is 98
</code></pre>
",2
22131162,22130620,0,"<p>To calculate the highest grade and the average you need not to store all entered values. All what you need is to claculate the sum of entered numbers its quantity and the largest grade. The program could look the following way</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
   bool empty = true;
   int sum = 0;
   int cnt = 0;
   int max;

   cout &lt;&lt; ""To get final and highest score, enter -1."" &lt;&lt; endl;

   while ( true )
   {
      cout &lt;&lt; ""Enter the score for student "" &lt;&lt; n + 1 &lt;&lt; "":  "";

      int num = -1;

      cin &gt;&gt; num;

      if ( num == -1 ) break;

      if ( num &lt; 0 || num &gt; 100 )
      {
         cout &lt;&lt; ""Wrong. You must enter a number between 0 to 100.\n"";
      }
      else
      {
         if ( empty || max &lt; num ) max = num;

         empty = false;
         sum += num;
         ++n;
      } 
   }

   if ( !empty )
   {
      cout &lt;&lt; ""The maximum  score is "" &lt;&lt; max &lt;&lt; endl;
      cout &lt;&lt; ""The average score is "" &lt;&lt; sum / n &lt;&lt; endl; 
//    cout &lt;&lt;  ""The average score is "" &lt;&lt; ( sum + 0.0 ) / n &lt;&lt; andl; //that to get a float number    
   }

   return 0;
}
</code></pre>
",0
21790526,21790229,1,"<p>If you want to match the following to north:</p>

<p>n, no, nor, nort, north</p>

<p>including their capitalised counter parts you can do this if you use boost string algorithms, you can obviously write your own <code>to_lower</code> and <code>starts_with</code> if you can't use boost for some reason.</p>

<pre><code>std::cin &gt;&gt; input;
boost::to_lower(input);
if(boost::starts_with(""north"", input)) {
    //match
}
</code></pre>
",0
21790671,21790229,2,"<p>It sounds like you want to see if a string is contained within an arbitrary set of strings. The C++ standard libraries have functionality for this.</p>

<p>I would use a <a href=""http://www.cplusplus.com/reference/set/set/"" rel=""nofollow""><code>std::set</code></a> to contain a list of valid terms, like so:</p>

<pre><code>std::set&lt;std::string&gt; north_terms_set;
north_terms_set.insert(""n"");
north_terms_set.insert(""north"");
</code></pre>

<p>and then check to see if a given input belongs to the set as follows:</p>

<pre><code>//Convert input to lowercase
std::string input_str = ""NoRtH""; 
std::transform(input_str.begin(), input_str.end(), input_str.begin(), ::tolower);

//compare lowercase version of input to the set of valid terms.
if (north_terms_set.find(input_str) != north_terms_set.end()) {
  //User has typed something like 'north', subtract from stamina, etc.
}
</code></pre>

<p>While the method suggested by 111111 is simpler, this methods enables you to limit which variants are considered valid and also lets you allow alternatives such as 'north', 'up', 'top', etc.</p>
",0
23074691,23074403,1,"<p>I see you use open address for collision and I don't see any problem here. Are you sure that your string ""ZZO"" has been inserted into the hash table correctly? I suggest you do a unit test to check that. Just insert the string and iterate the hashtable see whether it exists.</p>

<p>BTW, I suggest you use <a href=""http://en.wikipedia.org/wiki/Hash_table#Collision_resolution"" rel=""nofollow"">Separate chaining</a> to implement the hashtable because it's easy to implemented and generally more efficient(Well definitely depends on your hash function). And it could be further extended to be thread-safe.</p>
",0
23074755,23074403,1,"<p>Even without seeing your insert function code -- I suggest to you that your 'insert' function is the problem -- it most likely does not handle hash collisions and simply override some values/elements -- why don't you post your code for the insert function as well?</p>
",0
26791210,20372661,2,"<p>If I may I could give you some new code for the same task, in my code you can create a so called 'document'(not really)and it is saved, and can be opened up again. It is also stored as a string file though(not a document).
Here is the code:</p>

<pre><code>#include ""iostream""

#include ""windows.h""

#include ""string""

#include ""fstream""

using namespace std;

int main() {

string saveload;


cout &lt;&lt; ""---------------------------"" &lt;&lt; endl;
cout &lt;&lt; ""|enter 'text' to write your document    |"" &lt;&lt; endl;
cout &lt;&lt; ""|enter 'open file' to open the document |"" &lt;&lt; endl;
cout &lt;&lt; ""----------------------------------------"" &lt;&lt; endl;
while (true){
    getline(cin, saveload);

    if (saveload == ""open file""){
        string filenamet;
        cout &lt;&lt; ""file name? "" &lt;&lt; endl;
        getline(cin, filenamet, '*');
        ifstream loadFile;

        loadFile.open(filenamet, ifstream::in);

        cout &lt;&lt; ""the text you entered was: "";

        while (loadFile.good()){

            cout &lt;&lt; (char)loadFile.get();

            Sleep(100);
        }

        cout &lt;&lt; """" &lt;&lt; endl;

        loadFile.close();

    }

    if (saveload == ""text"") {
        string filename;
        cout &lt;&lt; ""file name: "" &lt;&lt; endl;
        getline(cin, filename,'*');
        string textToSave;
        cout &lt;&lt; ""Enter your text: "" &lt;&lt; endl;
        getline(cin, textToSave,'*');

        ofstream saveFile(filename);

        saveFile &lt;&lt; textToSave;

        saveFile.close();

    }
}
return 0;
}
</code></pre>

<p>Just take this code and change it to serve your purpose.
DREAM BIG,THINK BIG, DO BIG</p>
",0
32956915,32956819,1,"<p>Redefine <code>s</code> to be of type <code>std::string</code></p>

<pre><code>std::string wordOfInterest = ""c++"" // Change as per your needs
std::string::size_type pos = s.find(wordOfInterest); // Index at which the word of interest starts
if (pos != std::string::npos) s[pos] = toupper(s[pos]); // Updating the value at index with its upper case counterpart
</code></pre>
",2
24117292,24117264,12,"<p>The problem is:</p>

<pre><code>for (i = 0; i &lt; j; ++i) {
 if (words[i] == disliked[j]) {
  cout &lt;&lt; ""BLEEP"";
 }
 else {
 }
}
</code></pre>

<p>Here you are using <code>i</code> and <code>j</code> without declaring them. The previous declarations have only the block scope in which you are declaring. Either you have to redeclare them or if u want to use previous values, declare them above the first <code>for</code> loop.</p>
",0
24117514,24117264,4,"<p>You have declared the variable <strong>i</strong> and <strong>j</strong> in the for loop, hence because of the scope issue, you cannot access the variables in another for loop. </p>

<p>From what I have understood, in the final for loop, you are checking whether each word in the <strong>words</strong> array is equal to one of the words in <strong>disliked</strong> array. To do this, you need to use two for loops as follows:</p>

<pre><code>for(int i=0; i&lt;words.size(); i++){
    for(int j=0; j&lt;disliked.size(); j++){
         if(words[i] == disliked[j]){
              words[i] = ""BLEEP"";     //This step replaces the disliked word with ""BLEEP""
           }
    }
}
</code></pre>

<p>Note : If you declare <code>int i,j;</code> before using them in the loops, then you need not declare them again inside any of the for loops.</p>
",2
21039967,21039627,-1,"<p>It depends on how you will be using those functions. Since both belong to the same class, you can make <code>num</code> and <code>denom</code> (private) members of the class. But you can also use references if those values come from outside the class. This will work regardless of the functions belonging to the same class or not:</p>

<pre><code>class fraction
{
public:
  void init(int&amp; num, int&amp; denom) const;
  void otherFunction(int num, int denom);
}

void fraction::init(int&amp; num, int&amp; denom) const
{
  cout&lt;&lt;""enter the values for the numerator and denominator\n"";
  cin&gt;&gt;num;
  cin&gt;&gt;denom;
}

// Define otherFunction() appropriately
</code></pre>

<p>Then use those functions in another piece of code:</p>

<pre><code>// ...
int aNum, aDenom;
fraction fr;
fr.init(aNum, aDenom);
fr.otherFunction(aNum, aDenom);
// ...
</code></pre>
",3
21039660,21039627,5,"<p>Simply define them as members of the class:</p>

<pre><code>class fraction {
private:
  int num;
  int denom;

public:
   void init();          // has access to num and denom
   void otherMethod();   // also has access to num and denom
};
</code></pre>

<p>You should also not rely on <code>init()</code> being called to <strong>initialize</strong> the variables with a default value, and you should also not rely on the various default initializations provides by C++, see <a href=""https://stackoverflow.com/questions/6032638/default-variable-value"">Default variable value</a>.</p>

<p>Instead, add a constructor which sets default values for the variables to make sure that the variables have reasonable values after an object of the class has been created. Then, you can still call <code>init()</code> to set whatever values you want (and probably you should rename <code>init()</code> to something like <code>readValues()</code> to reflect what the method really does).</p>
",0
21042584,21039627,-1,"<p>Either make them members of the class, as so many suggest, or you could try passing them when needed. If you want their values to reflect changes, pass them by reference.</p>

<pre><code>datatype function1(int *a, int *b)
</code></pre>

<p>And then when you call them from init() function, </p>

<pre><code>function1(&amp;num, &amp;denom)
</code></pre>

<p>Hope this helps</p>
",1
23094407,23094055,0,"<p>I don't know if it gives a reasonable random distribution :D</p>

<pre><code>bool randcomp(int, int)
{
    return (rand()%2) != 0;
}


mylist.sort(randcomp);
</code></pre>
",0
23094566,23094055,0,"<p>You can try iterate over list several times and swap adjacent nodes with certain probablity. Something like this:</p>

<pre><code>const float swapchance = 0.25;
const int itercount = 100;

struct node
{
    int val;
    node *next;
};

node *fisrt;

{ // Creating example list
    node *ptr = 0;
    for (int i = 0; i &lt; 20; i++)
    {
        node *tmp = new node;
        tmp.val = i;
        tmp.next = ptr;
        ptr = tmp;
    }
}

// Shuffling
for (int i = 0; i &lt; itercount; i++)
{
    node *ptr = first;
    node *prev = 0;
    while (ptr &amp;&amp; ptr-&gt;next)
    {
        if (std::rand() % 1000 / 1000.0 &lt; swapchance)
        {
            prev-&gt;next = ptr-&gt;next;
            node *t = ptr-&gt;next-&gt;next;
            ptr-&gt;next-&gt;next = ptr;
            ptr-&gt;next = t;
        }
        prev = ptr;
        ptr = ptr-&gt;next;
    }
}
</code></pre>
",0
23094203,23094055,2,"<p>You can always add another level of indirection... ;)<br>
(see <a href=""https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering"" rel=""nofollow noreferrer"">Fundamental theorem of software engineering</a> in Wikipedia)</p>

<p>Just create an array of pointers, sized to the list's length, unlink items from the list and put their pointers to the array, then shuffle the array and re-construct the list.</p>

<p><strong>EDIT</strong></p>

<p>If you must use lists you might use an approach similar to merge-sort:</p>

<ul>
<li>split the list into halves,</li>
<li>shuffle both sublists recursively,</li>
<li>merge them, picking randomly next item from one or the other sublist.</li>
</ul>
",0
23609579,23609507,5,"<p>You can do this on the pure C level, because C api calls are usable also from C++. It eliminiates the problem if you actual c++ library didn't contained the needed <code>std:chrono</code> or <code>std::this_thread</code> (they differ a little bit).</p>
<p>The C api of most OSes contains some like a sleeping function, although it can be also different. For example, on posixen, there is the <code>sleep()</code> API call in the standard C library, and you can use this from C++ as well:</p>
<pre><code>#include &lt;unistd.h&gt;

int main() {
   sleep(5);
   return;
}
</code></pre>
<p>Or you can use <code>usleep()</code> is you want a better precision as seconds. <code>usleep()</code> can sleep for microsecond precision.</p>
<p>On windows, you can use the <code>Sleep(int usec)</code> call, which is with big '<code>S</code>', and uses milliseconds.</p>
",2
23609583,23609507,26,"<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;

int main()
{
    std::cout &lt;&lt; ""Hello waiter"" &lt;&lt; std::endl;
    std::chrono::seconds dura( 5);
    std::this_thread::sleep_for( dura );
    std::cout &lt;&lt; ""Waited 5s\n"";
}
</code></pre>

<p><code>this_thread::sleep_for</code> Blocks the execution of the current thread for at least the specified sleep_duration.</p>
",3
28246996,28246961,8,"<ol>
<li><code>main ()</code> should be <code>int main ()</code></li>
<li><code>False</code> should be <code>false</code></li>
<li><code>elif</code> should be <code>else if</code></li>
</ol>

<p>This makes the code compile at least.</p>

<p>At your level of C++ knowledge you can pretty much trust the compiler to be right. If it says your code is broken, it really is.</p>
",1
28247005,28246961,1,"<p>Have you come from a Python background?</p>

<p>Firstly there is no such keyword as <code>elif</code>.</p>

<p>You should use <code>else if</code> like</p>

<pre><code>if (answer == 1){
    upper = guess;
} else if (answer == 0){
    lower = guess;
}
</code></pre>

<p>Also you should declare <code>False</code> as <code>false</code>.</p>

<p>Finally you have not declared an <code>int</code> return type for main. it should be declared as.</p>

<pre><code>int main()
{
    // your code here
}
</code></pre>
",6
28247012,28246961,0,"<p>try else if instead of elif </p>

<pre><code> if (answer == 1){
        upper = guess;
    } else if (answer == 0){
        lower = guess;
</code></pre>
",0
23583962,23583733,2,"<p>Input streams parse characters one by one. For numeric extraction, the stream will continually read characters until it finds one that is non-numeric. This doesn't set <code>std::ios_base::failbit</code> if it successfully wrote characters to its operand already, and if there was no attempt to read the non-numeric character. Thus, <code>std::cin.good()</code> will return <code>true</code> for the first iteration.</p>

<p>Generally, checking <code>good()</code> is not the preferred means of assessing stream validity. Streams have an internal boolean operator that does this for you. All you have to do is enclose the actual input operation in a boolean expression:</p>

<pre><code>if (std::cin &gt;&gt; option) {
    // successful input
}
else {
    // unsuccessful
}
</code></pre>

<p>Now, to check if the <em>entire</em> input is numeric, it would be best to read into a string and do the parsing manually, as streams cannot do this on their own (by default). Alternatively, to make the stream do this itself, you can create a customized <code>std::num_get&lt;char&gt;</code> facet that sets the error mask if it can determine that the input was not entirely numeric. This facet will be installed into the stream's locale; you can uninstall it at any time by changing to the original:</p>

<pre><code>class num_get : public std::num_get&lt;char&gt;
{
public:
    iter_type do_get( iter_type it, iter_type end, std::ios_base&amp; str,
                      std::ios_base::iostate&amp; err, long&amp; v) const
    {
        auto&amp; ctype = std::use_facet&lt;std::ctype&lt;char&gt;&gt;(str.getloc());
        it = std::num_get&lt;char&gt;::do_get(it, end, str, err, v);

        if (it != end &amp;&amp; !(err &amp; std::ios_base::failbit)
                      &amp;&amp; ctype.is(ctype.alpha, *it))
            err |= std::ios_base::failbit;

        return it;
    }
};
</code></pre>

<p>Install it into the locale and <code>imbue()</code> the locale into the stream to get the desired behavior:</p>

<pre><code>std::locale original_locale(std::cin.getloc());
std::cin.imbue(std::locale(original_locale, new num_get));

if (std::cin &gt;&gt; option) {
    // input was entirely numeric
}
else {
    // input was not entirely numeric
}
</code></pre>
",2
28467479,28467450,0,"<p>You are copying too many characters into a char array of size 1.  Make your <code>char name[1]</code> bigger (e.g. 10 or so for this example).</p>

<p>Better yet, use <code>std::string</code> instead.</p>
",0
21719504,21719412,3,"<p>Firstly, when you do streaming like this (adding error handling)...</p>

<pre><code>if (!(cin&gt;&gt;list[n].firstName&gt;&gt;list[n].lastName&gt;&gt;list[n].age))
{
    std::cerr &lt;&lt; ""oops... unable to parse `firstname lastname age' from stdin... terminating\n"";
    return EXIT_FAILURE;
}
</code></pre>

<p>...the parsing of input for <code>age</code> terminates on and does not consume the first whitespace character following.  That means the terminating newline will always be left on the <code>cin</code> stream.  So, you need to do something to get rid of it.  A simple way to do that while making it clear that you're not interested in the rest of the line's content is:</p>

<pre><code>std::cin.ignore(std::numeric_limits&lt;streamsize&gt;::max(), '\n');
</code></pre>

<p>If you prefer to check everything really carefully, you could use <code>std::getline(std::cin, line)</code> to read the line of input into a <code>std::string</code>, then construct a <code>std::stringstream</code> with it, then parse out the content like this:</p>

<pre><code>std::string line;
if (cin&gt;&gt;list[n].firstName&gt;&gt;list[n].lastName&gt;&gt;list[n].age))
{ 
     std::istringstream iss(line);
     if (!(iss &gt;&gt; firstName &gt;&gt; lastName &gt;&gt; age))
     {
        std::cerr &lt;&lt; ""oops... unable to parse `firstname lastname age' from stdin... terminating\n"";
        return EXIT_FAILURE;
     }

     char c;
     if (iss &gt;&gt; c)  // this should fail - no more non-whitespace content allowed...
     {
        std::cerr &lt;&lt; ""oops... extra input encountered after the age value... terminating\n"";
        return EXIT_FAILURE;
     }
}
</code></pre>

<p>Once we're sure you're reading the entire line of per-person input, for the loop termination itself it's probably easiest to use:</p>

<pre><code>do
{
    ...
} while (std::getline(std::cin, my_string) &amp;&amp; my_string != ""Q"" &amp;&amp; my_string != ""q"");
</code></pre>

<p>That way, any newline characters will automatically be removed from the stream.  Using <code>std::cin.get()</code> to read a single character from the stream is possible and more efficient, but it's a little trickier handling the newline.  Can get fancier if you want to ignore leading whitespace, complain about other non-empty input etc..</p>

<p>Whatever you type may not reach the stream until you press enter, so they'll need to press 'Q' to quit.  To avoid that, you'd need OS-specific non-Standard code or libraries.  There are plenty of SO questions explaining how to read keys without waiting for enter.</p>

<hr>

<p>If you need to tolerate errors and prompt the user to try again, the easiest approach is to read in a way that can't fail due to invalid input, then use a separate stream object when you're attempting the parsing that may fail.  The following shows how to parse a few variables out of a line of input:</p>

<pre><code>std::string line;
while ((std::cout &lt;&lt; ""enter x y z (space separated): "") &amp;&amp;
       std::getline(std::cin, line))
{
    std::istringstream iss(line); // input string stream with contents of last line read
    char c;
    if ((iss &gt;&gt; x &gt;&gt; y &gt;&gt; z) &amp;&amp; !(iss &gt;&gt; c))
        // we successfully parsed out x, y and z, and there was no trailing
        // non-whitespace character, so all's good...
        break;
    std::cerr &lt;&lt; ""unable to parse 'x', 'y' and 'z' from input, or unexpected trailing text\n"";
    std::cerr &lt;&lt; ""please try again\n"";
}
</code></pre>

<p>This way, <code>iss</code> may enter a bad state due to merely bogus user input but is recreated with the next line's content anyway.  <code>std::cin</code> only fails on unrecoverable issues (end-of-file, hardware error etc).  That avoids having to reset any stream state, which is a painful thing to have to do, see <a href=""http://support.microsoft.com/kb/132422"" rel=""nofollow"">http://support.microsoft.com/kb/132422</a> for an example program showing how.</p>
",8
24110874,24110318,0,"<p>I don't know about native C++ functions but it's doable with SFML libraries.</p>

<pre><code>if (event.type == Event::KeyPressed){
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Add))
            {
                //start counter
                if(count &lt; 5) sum++;          
                else
                 sum+=5;
            }
        }
</code></pre>

<p>You can do the same thing with WinApi but in both cases you'll need to use multithreading/multiprocessing for your counter, or find another way to sync your code.
You could try adding <code>Sleep(500)</code> which will sleep your thread for 500ms or something similar.</p>
",0
21773372,21753919,0,"<p>Thanks for the help, but that is my limitation to pass only 1 argument into the function and that can only be an array.
anyways I just wrote that main function to make an understanding, but actually that main function is not available to me. So finally I end up with a function which can get an argument  that can be an int array and return the size of array.</p>

<p>I tried with something that to convert my int array into an ascii array of those int values and since a NULL or '\0' can never be equal to a '0', so comparing them with NULL up to the end of an array is possible. </p>

<p>But again I got stuck when I'm going to convert the array, I required the length.</p>
",0
30180438,30180417,6,"<p>It's undefined behavior.  You are printing whatever occupies the memory of <code>a</code>, which in this case happens to be <code>32767</code>.</p>
",7
30180440,30180417,16,"<p>That is because variables with automatic storage duration are not automatically initialized to zero in C++. In C++, you don't pay for what you don't need, and automatically initializing a variable takes time (setting to zero a memory location ultimately reduces to machine intruction(s) which are then translated to electrical signals  that control the physical bits).</p>

<p>The variable is being reserved a memory location, and it happens that some junk is at that memory location. That junk is being printed out by <code>cout</code>.</p>

<p>As pointed out by @dwcanillas, it is undefined behaviour. Related: <a href=""https://stackoverflow.com/q/1597405/3093378"">What happens to a declared, uninitialized variable in C? Does it have a value?</a></p>

<p>From the C++ standard (emphasize mine): </p>

<p><strong>8.5 Initializers [dcl.init]</strong></p>

<blockquote>
  <p>7) <strong>To default-initialize an object of type T means</strong>:</p>
  
  <blockquote>
    <ul>
    <li>If T is a (possibly cv-qualified) class type (Clause 9), constructors are 
    considered. The applicable constructors are enumerated (13.3.1.3), and the best
    one for the initializer () is chosen through overload resolution (13.3). The 
    constructor thus selected is called, with an empty argument list, to initialize >> the object.</li>
    <li>If T is an array type, each element is default-initialized.</li>
    <li>Otherwise, no initialization is performed.</li>
    </ul>
  </blockquote>
  
  <p>12) <strong>If no initializer is specified for an object, the object is default-initialized</strong>. When storage for an object with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced (5.18). [Note: Objects with static or thread storage duration are zero-initialized, see 3.6.2. ¡ª end note ] <strong>If an indeterminate value is produced by an evaluation, the behavior is undefined</strong> except in the following cases:</p>
  
  <blockquote>
    <p>¡ª If an indeterminate value of unsigned narrow character type (3.9.1) is produced by the evaluation of:</p>
    
    <p>¡ª the second or third operand of a conditional expression (5.16),</p>
    
    <p>¡ª the right operand of a comma expression (5.19),</p>
    
    <p>¡ª the operand of a cast or conversion to an unsigned narrow character type (4.7, 5.2.3, 5.2.9, 5.4), or</p>
    
    <p>¡ª a discarded-value expression (Clause 5) </p>
    
    <p>...</p>
  </blockquote>
</blockquote>
",2
30180691,30180417,1,"<p>The behaviour is covered by C++14 (N3936) [dcl.init]/12:</p>
<blockquote>
<p>If no initializer is specified for an object, the object is default-initialized. When storage for an object with automatic or dynamic storage duration is obtained, the object has an <em>indeterminate value</em>, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced.</p>
<p>[...] If an indeterminate value is produced by an evaluation, <strong>the behavior is undefined</strong> except in the following cases:</p>
</blockquote>
<p>and your code is not covered by any of the &quot;following cases&quot; which cover a few situations in which <code>unsigned char</code> indeterminate values are allowed to propagate.</p>
",0
30185292,30180417,0,"<p>Because ""a"" is not global/static. Its an automatic variable for which initialization happens at run time. If it was global, initialization to zero would have happened at compile time. i.e</p>

<p>?   static variables are initialized at compile-time, since their address is known and fixed. Initializing them to 0 does not incur a runtime cost.</p>

<p>?   automatic variables can have different addresses for different calls and would have to be initialized at runtime each time the function is called, incurring a runtime cost that may not be needed. If you do need that initialization, then request it.</p>
",0
29951181,29926997,3,"<p>Another method that could help you is to have all of your FilePaths in a text file where each one is on their own line terminated by a carriage return. Then write a small parser function to read that text file line by line that would read in each lines contents and save it to a string. Then after you have that string you could use the above wrapper class to store its contents by passing in the string you got from the parser. This way if you need to fix or change the FilePaths, you can just edit the text file and will not have to recompile or rebuild your code everytime you change or add a FilePath! This would create an automatic process!</p>
",0
26784974,26784005,0,"<p>There are several issues with your code. </p>

<p>1) Wrong usage of <code>new[]</code>.</p>

<p>2) No check to see if the lines in the file actually matches (or exceeds) the lines specified in the <code>dir_no</code> value.</p>

<p>3) Unnecessary member variables, such as <code>fstream f</code>.</p>

<hr>

<p>Here is a working example.  The example uses the following:</p>

<p>1) <code>std::vector&lt;std::string&gt; dir</code> instead of <code>char* dir</code>, and <code>std::string</code> instead of <code>char*</code></p>

<p>2) Usage of <code>getline</code> to retrieve the lines of text from a file.</p>

<p>3) Note that the loop will either exit when the loop hits <code>dir_no</code> items, or if the file runs out of lines, whichever happens first.</p>

<p>4) Please look at how we use <code>std::vector</code> to expand the array of lines.  Note that there is no usage of <code>new[]</code> to do this, but instead, a call to the <code>push_back</code> member function of <code>std::vector</code>.</p>

<p>5) To output the results, usage of the algorithm function <code>std::copy</code> is used.   You don't have to learn what this does now, just letting you know what it accomplishes.</p>

<pre><code>#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;

class FilesHandling
{
    int dir_no;
    std::vector&lt;std::string&gt; dir;

    public: 
        void readFile(const std::string&amp; fName)
        {
            std::ifstream f(fName.c_str());
            if (f)
            {
                f &gt;&gt; dir_no;
                f.ignore();
                std::string line;
                for (int i = 0; i &lt; dir_no &amp;&amp; getline(f, line); ++i)
                    dir.push_back(line);

                // output the results for testing
                std::copy(dir.begin(), dir.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, ""\n""));
            }
            else 
                std::cout &lt;&lt; ""Can't open file"" &lt;&lt; std::endl;
        }
    };

    int main()
    {
       FilesHandling fh;
       fh.readFile(""abc123.txt"");
    }
</code></pre>

<p>When you run this, you should see the lines of text outputted to the console.</p>
",1
26793866,26792761,-2,"<p>How about this program </p>

<pre><code>#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
double coneVolume(double, double);
int main( )
{
    //Declare variables and constants
    double coneRadius = 0.0;
    double coneHeight = 0.0;

    //Prompt the user for inputs
    cout &lt;&lt; ""Enter the radius of the cone: "";
    cin &gt;&gt; coneRadius;
    cout &lt;&lt; ""Enter the height of the cone: "";
    cin &gt;&gt; coneHeight;

    //Do the calculation

    //Display the result
    cout &lt;&lt; ""The volume of your cone is: "" &lt;&lt; coneVolume(coneRadius, coneHeight) &lt;&lt; endl;

    system(""pause"");
    return 0;
} //end of main

double coneVolume(double coneRadius, double coneHeight)
{
   double PI = acos(-1.0);
   double volume = coneRadius * coneRadius * coneHeight * PI / 3.0;
   return volume;
}
</code></pre>

<p>Please note that I added the cmath library in order to use the acos function.</p>

<pre><code>double PI = acos(-1.0);
</code></pre>

<p>I read this trick in a piece of code that a guy used to do trigonometry using C++. 
I did not use any kind of parenthesis when I calculated the volume because both * and / are in the same order of precedence and are evaluated from left to right. I divided by 3.0 because I am using doubles. For the prototype of the function that is right above the main function     </p>

<pre><code>double coneVolume(double, double);
</code></pre>

<p>I just wrote the type of arguments of the function as only the type of the arguments of the function is needed for propotypes. </p>
",2
24578219,24578003,4,"<p>OK, a simple example, remove all the x's from a string</p>

<pre><code>char x = 'x';
std::string s = ""Text to remove all 'x's from"";
s.erase(std::remove_if(s.begin(), s.end(), [x](char c) {return x == c;}), s.end());
</code></pre>

<p>Borrowed and modifed from <a href=""http://en.cppreference.com/w/cpp/algorithm/remove"" rel=""nofollow"">http://en.cppreference.com/w/cpp/algorithm/remove</a></p>

<p>In this example, <code>remove_if()</code> only takes a single parameter, but I need two values for the comparison.</p>
",0
24581260,24578003,1,"<p>Closures are not always called immediately. They are objects which can be stored and called later when the data necessary to successfully execute the lambda function may no longer be in scope or easily accessible from the call site.</p>

<p>It's possible to to store any necessary data along with the closure but it's so much simpler for the closure to grab anything it needs when it's created and use it when it's eventually called. It provides a form of encapsulation.</p>

<p>This also decreases code coupling because if you were to store the data along with the code then the caller could only work with the specific objects you decided to store. Since a closure carries its own data along with it, it can work with any data it needs.</p>

<p>Here's an greatly oversimplified real-life example. I built a database server which needed to support fields with multiple values. The problem was that when results were displayed, it was important to highlight which values actually caused a record to match the search criteria. So, the query parser would spit out a predicate in the form of a closure which would indicate whether or not it was a matching value.</p>

<p>It looked something like this:</p>

<pre><code>std::function&lt; bool(int value) &gt; parser::match_int(int search_val) {
    return [=](int value) { value == search_val; };
}
</code></pre>

<p>That closure got stored in a collection. When it was time to render the record, I could easily determine which values needed to be highlighted. Keep in mind that the parser and any associated data is now gone:</p>

<pre><code>void render_values(std::function&lt; bool(int value) &gt; pred, std::vector&lt;int&gt; values) {
    for (int value : values) {
        if (pred(value))
            render_highlight(value);
        else
            render_normal(value);
    }
}
</code></pre>
",1
24082460,24082334,0,"<p>For example let consider the default constructor. According to the C++ Standard</p>

<blockquote>
  <p>An implicitly-declared default constructor is an inline public member
  of its class.</p>
</blockquote>

<p>and </p>

<blockquote>
  <p>The implicitly-defined default constructor performs the set of
  initializations of the class that would be performed by a user-written
  default constructor for that class with no ctor-initializer (12.6.2)
  and an empty compound-statement.</p>
</blockquote>

<p>So it looks like</p>

<pre><code>struct A
{
   A() {}
};
</code></pre>

<p>except that it is not explicitly declared and defined.</p>

<p>About copy constructor you can read at my personal forum</p>

<p><a href=""http://cpp.forum24.ru/?1-1-0-00000021-000-0-0-1388485669"" rel=""nofollow"">http://cpp.forum24.ru/?1-1-0-00000021-000-0-0-1388485669</a></p>

<p>Though it is written in Russian but you can translate it for example using google service translate.</p>
",0
24082499,24082334,0,"<p>For each of these methods, the compiler defines default inline methods that call the default methods of each attribute of the object. (so a pointer won't be initialized neither any built-in type).</p>
",0
24082653,24082334,0,"<p>Those method will do the minimum necessary to initialize the class.</p>

<p>Default construtor - do nothing with simple members but call the constructors of more complex members (class/struct) as well as call the ctor of its super class.</p>

<p>Copy constructor will perform a shallow copy (memcpy).</p>
",0
29472306,29472231,0,"<ol>
<li>Make sure <strong>ES_WANTRETURN</strong> style is used for Edit Box.</li>
<li>Also you should change <code>\n\r</code> back to <code>\r\n</code>  right after <em>flipText()</em> call.</li>
</ol>
",1
29472308,29472231,0,"<p>EDIT control needs '\r\n' combination to break. when you flip all the text, you get <code>\n\r</code> which means nothing to windows but text.</p>

<p>suggestion - flip the text and replace all the <code>\n\r</code> back to <code>\r\n</code></p>
",0
29472313,29472231,1,"<p>For an edit box, a return is a CR+LF sequence, when you reverse the text you are transforming it in an LF+CR, which is not recognized (it shows the individual characters). An easy way out could be to do a second pass on the reversed string and swap all the LF+CR pairs into CR+LF.</p>

<p>Incidentally, your <code>flipText</code> function is seriously broken - you are performing a useless extra copy of the original string, and you are returning a pointer to a local array, which is working only by chance. A way easier method could be just to reverse the string in-place.</p>

<p>Also, if you are working in C++ you should consider using <code>std::string</code> (or <code>std::wstring</code> if working with wide characters), which removes whole classes of buffers lifetime/size problems.</p>
",2
21788789,21788440,1,"<p>My first thought was to just upvote <a href=""https://stackoverflow.com/questions/21788440/stack-memory-with-iostream#comment32966444_21788440"">jalf's comment</a>, but there are some things that are known. Unless the systems implementation of <a href=""http://en.wikipedia.org/wiki/Standard_Template_Library"" rel=""nofollow noreferrer"">STL</a> or the compiler is really unusual.</p>

<p>Unless it's inlined, and that's up to the compiler, there's a function call which means pushing a bunch of things to the stack. How much the call requires depends on the number of registers, size of registers and so on. </p>

<p>But more stack could be used inside the call to <code>operator&lt;&lt;</code>. All local variables use stack, and other function calls inside of the <code>operator&lt;&lt;</code> use the stack, unless they're inlined. And so on.</p>

<p>It depends on the implementation of whichever class <code>some_file</code> is an instantiation of. Without more details we can't say anything specific.</p>
",4
23808564,23808508,6,"<p>No, it's not. <a href=""https://stackoverflow.com/a/3405364/1451714"">Have a look at this answer</a> for an explanation why compilers do not emit an error by default. </p>

<p>Anyway, if there's no return, the function's return value will just be undefined (garbage), and when you try to read it, you get undefined behavior. </p>

<blockquote>
  <p>looks like it's returning this pointer</p>
</blockquote>

<p>What is actually returned depends on the calling convention used for your particular compiler and platform. If, for example, return values are pushed on the stack, the value you get might actually be some (now invalid) leftover data which was pushed on the stack during execution of the <code>cout</code> statement. But it highly depends on very specific internals that you shouldn't need to be aware of most of the time - just remember that the return value will be garbage.</p>

<p>Now why are you able to do <code>object.fun1().fun2()</code>? As @akappa explained in the comments, your member functions are non-virtual and do not access any members, so the compiler is very likely compiling them as free functions that don't require a <code>this</code> pointer.</p>

<p>Many compilers have switches to warn you about missing returns, for example gcc has <code>-Wreturn-type</code>, and it's also activated if you set <code>-Wall</code>. Personally, I always define this warning to be treated as an error by setting <code>-Werror=return-type</code>. It depends on your compiler, but it should have some functionality to enable this as well.</p>
",0
27499666,27499516,0,"<p>You have to cast the operands before the division, otherwise you will be casting the result:</p>

<pre><code>static_cast&lt;float&gt;(us_popn)/static_cast&lt;float&gt;(w_popn)
</code></pre>
",0
28200211,28199998,1,"<p>First of all, as WhozCraig stated, you don't need to use a <code>stringstream</code> here. <code>std::string</code> provides everything you need.</p>

<p>The reason that your code didn't work is that your <a href=""http://www.cplusplus.com/reference/ios/ios/eof/"" rel=""nofollow""><code>eof</code> bit</a> was set through the <code>operator&gt;&gt;</code>. Calling <code>stringstream::clear()</code> resets the bit and makes the stream usable again.</p>

<p>Here is your code with slight modifications, working alright. I also added the fixes suggested by Thomas Matthews:</p>

<pre><code>void losuj(vector &lt;string&gt; &amp;vec, int ile)
{
    int i, j;
    string str;
    char c;
    for(i=0; i&lt;ile; i++)
    {
        for (j=0; j&lt;5; j++)
        {
            c = rand() % 26 + 'A';
            str += c;
        }
        vec.push_back(str);
        str.clear();
    }
}
</code></pre>
",5
28200219,28199998,0,"<p>You have to reset the state of the stringstream because you've reached <code>eof</code>:</p>

<pre><code>ss.clear();
</code></pre>
",0
31179512,31179226,0,"<p>It looks to me like you are printing only in those cases where you have <strong>not</strong> found the number. In other words, the cases in your if-statement are reversed. It should read:</p>

<pre><code>    if(std::find(tab.begin(), tab.end(), tab3[i]) != tab.end())
        output&lt;&lt;tab2[i]&lt;&lt;endl;
</code></pre>

<p>[EDIT] Oops, I read the question not carefully enough. It should print the line, if the number is NOT contained in source3. So the loop should read:</p>

<pre><code>    if(std::find(tab.begin(), tab.end(), tab3[i]) == tab.end())
        output&lt;&lt;tab2[i]&lt;&lt;endl;
</code></pre>

<p>Also: I would strongly suggest to do away with all those constants like 856 and 1050. Why don't you simply read the file until you reach the end?</p>
",2
31180842,31179226,1,"<p>I think below modifications to code should work for you . Replace value of SOURCE_COUNT with 1051 and  SOURCE2_COUNT  with 857</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;vector&gt;

const int SOURCE_COUNT = 4;
const int SOURCE2_COUNT = 3;
//const int SOURCE2_COUNT = 3;

using namespace std;
int main()
{
    ifstream source (""source.txt"");
    ifstream source2 (""source2.txt"");
    ifstream source3 (""source3.txt"");
    vector&lt;int&gt; tab(SOURCE_COUNT,0);
    vector&lt;string&gt; tab2(SOURCE2_COUNT,"""");
    vector&lt;int&gt; tab3(SOURCE2_COUNT,0);

    ofstream output(""output.txt"");
    for(int i=0;i&lt;SOURCE_COUNT;++i)
    {
        source&gt;&gt;tab[i];
    }
    for(int i=0;i&lt;SOURCE2_COUNT;++i)
    {
        string a;
        getline(source2,a);
        tab2[i]=a;
        source3&gt;&gt;tab3[i];
    }
    for(int i=0;i&lt;SOURCE2_COUNT;++i)
    {
        if(std::find(tab.begin(), tab.end(), tab3[i]) != tab.end())
        {
            continue;
        }
        else
        {
            output&lt;&lt;tab2[i]&lt;&lt;endl;
        }
    }
}
</code></pre>
",0
25461962,25461782,1,"<p><strong><em>Longer explanation</em></strong>: That is excatly what the author is talking about - <code>Window::draw()</code> gets called three times:</p>

<ol>
<li>Window::draw();</li>
<li>Window_with_border::draw();</li>
<li>Window_with_menu::draw();</li>
</ol>

<p>You can ommit the first one and rewrite it like this:</p>

<pre><code>class Clock : public Window_with_border, public Window_with_menu {
public:
    void own_draw() { //sth }
    void draw() {
        Window_with_border::draw();
        Window_with_menu::draw();
        own_draw(); }
};
</code></pre>

<p>But still twice, so the final should be:</p>

<pre><code>class Clock : public Window_with_border, public Window_with_menu {
public:
    void own_draw() { //sth }
    void draw() {
        Window::draw();
        Window_with_border::own_draw();
        Window_with_menu::own_draw();
        own_draw(); }
};
</code></pre>

<p>OR:</p>

<pre><code>class Clock : public Window_with_border, public Window_with_menu {
public:
    void own_draw() { //sth }
    void draw() {
        Window_with_border::draw();
        Window_with_menu::own_draw();
        own_draw(); }
};
</code></pre>
",2
26171252,26170737,0,"<p>You could <code>reinterpret_cast</code> your floating point number address to a <code>char*</code>, and manually go over the bits one by one, something like :</p>

<pre><code>double number = 16.4566565776765;

char* fp = reinterpret_cast&lt;char*&gt;(&amp;number);

for (std::size_t i = 0; i &lt; sizeof(float); i++){
    for (std::size_t j = 0; j &lt; CHAR_BIT; j++){
        intVector.push_back(fp[i] &amp; (1&lt;&lt;j) ? 1 : 0);
    }
}
</code></pre>

<p><strong>Note:</strong></p>

<ul>
<li>You would need to take care of the endianess of the platform for the ordering of the bits.</li>
</ul>
",3
25452423,25452287,3,"<p>Your code has one call in excess... in particular the part</p>

<pre><code>...
else {
    fun(x,i,A);
}
</code></pre>

<p>doesn't make sense.</p>

<p>You need to recurse only if the number of points you're subtracting is not getting past or to the total. You're handling correctly the two cases <code>(x-i==0)</code> and <code>(x-i&gt;0)</code>, but for <code>(x-i&lt;0)</code> you must do nothing.</p>
",0
27172497,27172385,0,"<blockquote>
  <p>I'd prefer something on the lines of (2). Before I delve into a for loop, is there a more stl-like way I could do this?</p>
</blockquote>

<p>Consider std::transform and treat both streams (the raw and string one) as a sequence of iterators:</p>

<pre><code>const unsigned char* bar = some_data();
auto length = std::strlen(reinterpret_cast&lt;const char*&gt;(bar));
const auto bar_end = bar + length;
std::string foo{ length, ' ' }; // avoid reallocations in transform
std::transform(bar, bar_end, foo.begin(), [](const unsigned char c) -&gt; const char {
    return c &gt; 127 ? ' ' : reinterpret_cast&lt;const char&gt;(c);
});
</code></pre>
",0
27172526,27172385,5,"<p>Something like this should do the trick if you just want to omit values >= 128 (or <code>&lt; 0</code> if char is signed):</p>

<pre><code>std::copy_if(bar, bar + &lt;length of string&gt;,
    std::back_inserter(foo),
    [](char c) { return c &lt; 128 &amp;&amp; c &gt;= 0;});
</code></pre>
",0
32443367,32442699,3,"<p>¡ì 13.3.3 [over.match.best]/p2:</p>

<blockquote>
  <p>Given these definitions, a viable function F1 is defined to be a better function than another viable function
  F2 if <strong>for all arguments i, ICS<sub>i</sub>(F1) is not a worse conversion sequence</strong> than ICS<sub>i</sub>(F2), and then</p>
  
  <p><sup>(1.3)</sup> ¡ª for some argument j, ICS<sub>j</sub>(F1) is a better conversion sequence than ICS<sub>j</sub>(F2), or, if not that, [...]</p>
</blockquote>

<p>Given function call <code>notify(""%5d "", 89);</code> and two overloads:</p>

<pre><code>void notify(const char*, ...);   // F1
void notify(std::string, int);   // F2
</code></pre>

<p>the compiler has the following set of implicit conversion sequences for the arguments of <code>F1</code>:</p>

<ul>
<li>ICS<sub>0</sub>(F1) - a standard conversion sequence (an array to pointer conversion)</li>
<li>ICS<sub>1</sub>(F1) - an ellipsis conversion sequence</li>
</ul>

<p>and the following set of implicit conversion sequences for the arguments of <code>F2</code>:</p>

<ul>
<li>ICS<sub>0</sub>(F2) - a user defined conversion sequence (via a constructor)</li>
<li>ICS<sub>1</sub>(F2) - a standard conversion sequence (an identity conversion)</li>
</ul>

<p>Because ICS<sub>0</sub>(F1) is better than ICS<sub>0</sub>(F2), but, in turn, ICS<sub>1</sub>(F2) is better than ICS<sub>1</sub>(F1), the compiler can't choose between the two.*</p>

<hr>

<p>* ¡ì 13.3.3.2 [over.ics.rank]/p2:</p>

<blockquote>
  <p>When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1):</p>
  
  <p>¡ª a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and</p>
  
  <p>¡ª a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3).</p>
</blockquote>
",1
22437029,22437003,0,"<p><code>cin</code> is an instance of <code>istream</code> template class. <code>operator &gt;&gt;</code> acts on this istream instance  to load input into data and returns a reference to this <code>istream</code>. Then in <code>while</code> condition it is tested by a call to <code>cin::operator void*() const</code> (<code>explicit operator bool() const</code> in C++11) which invokes <code>fail()</code> function to test if operation succeeded. This is why you can use this operation in while condition</p>

<pre><code>while ( cin &gt;&gt; x)
{
   //...
</code></pre>
",0
22437032,22437003,1,"<p>The expression result of <code>cin &gt;&gt; x</code> is a reference to the <code>cin</code> stream, a <code>std::istream</code>.</p>

<p>A <code>std::istream</code> <em>effectively</em> converts to boolean when used as an <code>if</code> or <code>while</code> condition expression.</p>

<p>The result is equivalent to writing</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; <code>!cin.fail()</code>.</p>

<hr>

<p>In C++03 the conversion was technically an <code>operator void*()</code>.</p>

<p>That, however, was not so nice with respect to overload resolution and some other issues.</p>

<p>So in C++11 it's an <code>explicit operator bool()</code>. The keyword <code>explicit</code> could only be used on constructors in C++03, but in C++11 it can also be applied to conversion operators. It prevents the usual inadvertent implicit conversions, but as a special case it is effectively ignored for conversion to boolean of an <code>if</code> or <code>while</code> condition expression.</p>
",1
22437034,22437003,0,"<p>The return type of <code>operator &gt;&gt;</code> for <code>std::istream</code> is <code>std::istream</code> again.  It returns the left-hand argument (<code>cin</code> in your case).  And <code>std::istream</code> has an <code>operator bool()</code> which enables using a stream in a conditional expression.  These two things together enable testing of a stream the same way we test many other C++ objects for validity, such as pointers.</p>
",0
26196199,26196147,2,"<p>1) listp is a pointer to the list as a whole. This allows operations on the list given only a node pointer.</p>

<p>2) tail is a pointer to the last item in the list. This allows some operations (like append) to be O(1) instead of O(n).</p>
",6
26196543,26196147,0,"<p>This is not a valid (or at least not a very good) implementation for a double-linked list.  The <code>DList</code> class is doing some really dangerous things that the <code>DListNode</code> is not aware of, and <code>DListNode</code> is not managing <code>DList</code>'s <code>head</code> and <code>tail</code> members at all.</p>

<p>The safest approach is to just use the STL <code>std::list</code> class and let it handle all of the details for you.  But if you must implement it manually, try something more like this instead:</p>

<pre><code>class  DList
{
private:
    friend class DlistNode;

    DListNode* head;
    DListNode* tail;
    int size;

public:
    DList() : head(NULL), tail(NULL), size(0)
    {
    }

    ~DList()
    {
        while (head)
            delete head;
    }

    void add_head(DListNode* node)
    {
        node-&gt;add_head(this);
    }

    void add_tail(DListNode* node)
    {
        node-&gt;add_tail(this);
    }
};
</code></pre>

<p></p>

<pre><code>class DListNode
{
private:
    friend class DList;

    DListNode* next;
    DListNode* prev;
    DList* listp;

public:
    DListNode() : next(NULL), prev(NULL), listp(NULL)
    {
    }

    ~DListNode()
    {
        remove();
    }

    void remove()
    {
        if (next)
            next-&gt;prev = prev;

        if (prev)
            prev-&gt;next = next;

        if (listp)
        {
            if (listp-&gt;head == this)
                listp-&gt;head = next;

            if (listp-&gt;tail == this)
                listp-&gt;tail = prev;

            listp-&gt;size--;
            listp = NULL;
        }

        prev = next = NULL;
    } 

    void add_head(DList *parent)
    {
        if (!parent)
            throw std::runtime_error(""no parent specified"");

        if (parent-&gt;head == this)
            return;

        remove();

        if (parent-&gt;head)
        {
            parent-&gt;head-&gt;prev = this;
            next = parent-&gt;head;
        }
        parent-&gt;head = this;            

        listp = parent;
        listp-&gt;size++;
    } 

    void add_tail(DList *parent)
    {
        if (!parent)
            throw std::runtime_error(""no parent specified"");

        if (parent-&gt;tail == this)
            return;

        remove();

        if (parent-&gt;tail)
        {
            parent-&gt;tail-&gt;next = this;
            prev = parent-&gt;tail;
        }
        parent-&gt;tail = this;            

        listp = parent;
        listp-&gt;size++;
    } 

    void add_before(DListNode *node)
    {
        if (!node)
            throw std::runtime_error(""no node specified"");

        if (node == this)
            return;

        remove();

        if (node-&gt;prev)
            node-&gt;prev-&gt;next = this;

        next = node;
        prev = node-&gt;prev;
        node-&gt;prev = this;

        listp = node-&gt;listp;
        if (listp-&gt;head == node)
            listp-&gt;head = this;

        listp-&gt;size++;
    }

    void add_after(DListNode *node)
    {
        if (!node)
            throw std::runtime_error(""no node specified"");

        if (node == this)
            return;

        remove();

        if (node-&gt;next)
            node-&gt;next-&gt;prev = this;

        prev = node;
        next = node-&gt;next;
        node-&gt;next = this;

        listp = node-&gt;listp;
        if (listp-&gt;tail == node)
            listp-&gt;tail = this;

        listp-&gt;size++;
    }
};
</code></pre>
",1
22442348,22442243,4,"<p>Well, first of all this <em>doesn't</em> work -- when you compile it you get an error like</p>

<pre><code>t.cpp:2:32: error: invalid conversion from ¡®void*¡¯ to ¡®A*¡¯ [-fpermissive]
 A* a = ::operator new(sizeof(A));
                                ^
</code></pre>

<p>For what it means, this calls the function <code>operator new</code> in the global scope.  The normal global <code>operator new</code> allocates the specified amount of memory and returns a <code>void *</code> pointer to it (which is why you get the error).</p>

<p>Importantly, this is <em>not</em> a <code>new</code> expression -- it's just a function call that calls the function normally used to allocate memory for <code>new</code> expressions.  It does not call any initializer to initialize the memory in any way.  Which is another reason its an error.</p>
",5
22442353,22442243,7,"<p>Yes you are right, <code>operator new()</code> (function) is different from <code>new</code> (keyword), that it only allocates N bytes and do not perform initialization of objects. However, the <code>new</code> keyword uses <code>operator new()</code> under the hood to allocate memory. </p>

<p>Unlike other (standart) functions, <code>operator new()</code> is not part of the <code>std</code> namespace, but is located in the global namespace. Thus the <code>::</code> in front forces the compiler to take the global definition and not a more specialized one. E.g:</p>

<pre><code>namespace foo {

    void* operator new (std::size_t size)
    {
        std::cout &lt;&lt; ""custom implementation"" &lt;&lt; std::endl;
        // some code...
    }

    void SomeFunc()
    {
         operator new(0);   // prints ""custom implementation""
         ::operator new(0); // prints nothing at all
    }

}
</code></pre>
",0
22442588,22442243,3,"<p><strong>1)</strong> <code>::</code> is known as the <code>scope resolution operator</code>. In C/C++ every identifier has a scope outside of which it does not exist. Identifiers by default exist in the global namespace unless they are a member of functions, classes or namespaces, where they exist as local identifiers. Symbols/Variables/Identifiers declared in the global namespace use the <code>::</code> operator. </p>

<p>Therefore,you have to use the unary scope operator(::) to access an identifier declared within the global namespace, as it can be <em>hidden</em> because of an explicit declaration of another identifier having the same name as its own in a block or class. For-example:</p>

<pre><code>    int random_number = 0;

    int main(void)
    {
      int random_number = 0;
      ::random_number = 1;  // set global random_number to 1
      random_number = 2;    // set local random_number to 2
      return 0;
    }
</code></pre>

<p>The declaration of <code>random_number</code> declared inside the <code>main()</code> function hides the integer named <code>random_number</code> declared in global namespace scope(above the main function). 
By using the unary scope operator like <code>::random_number</code> we can access the variable declared in the global namespace inside the <code>main()</code> function.</p>

<p><strong>2)</strong> <code>operator new()</code> denotes a function whose declaration is as <code>void* operator new  ( std::size_t count );</code> meaning that it allocates memory/storage of <code>count</code> bytes.  If there is insufficient memory for the allocation request, <code>operator new()</code> returns <code>NULL</code> or throws an <code>exception</code></p>
",0
24389809,24389402,1,"<p>See: <a href=""http://en.cppreference.com/w/cpp/io/basic_ifstream"" rel=""nofollow"">http://en.cppreference.com/w/cpp/io/basic_ifstream</a></p>

<p>Try something like this:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    ifstream stream(""file.txt"");
    string foo;

    while(stream &gt;&gt; foo)
            cout &lt;&lt; foo &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>100
150
245
467
367
367
</code></pre>

<p>You can use the stream operators to extract one number at a time.</p>

<p>Update your question if this doesn't answer it as its kind of hard to tell what you're trying to do.</p>
",5
21015354,21015305,2,"<p>Say <code>m_IfacomAmqProducer-&gt;getSenderTimestamp(message.get())</code>.</p>
",1
34211661,34211610,1,"<p><code>std::stack</code> and <code>std::queue</code> are container adapters, They are based on the underlaying conteiner that can be for example <code>std::vector</code> and in this case they will be as you are saying ""cache-friendly"" or <code>std::list</code> and in this case they will not be ""cache-friendly"".</p>

<p>By default the both container adapters use <code>std::deque</code> as the underlaying container because it has all necessary methods to simulate the adapters.
For example <code>std::vector</code> does not have required method <code>pop_front</code> and can not be used as an underlaying container for <code>std::queue</code>.</p>

<p>You can define your own underlaying container. The requirements are described in the C++ Standard.</p>
",0
34211812,34211610,3,"<p><code>std::stack</code> and <code>std::queue</code> are container adapters, a strange beast that provides a stripped down uniform interface on a compile time determined container.</p>
<p>By default, they use <code>std::deque</code> as their backing store, which is not all that cache friendly (in every implementation I have examined).</p>
<p><code>stack</code> can easily be handed a <code>vector</code>, which makes it friendly to the cache.</p>
<p>Making <code>queue</code> use a <code>vector</code> is tricky.  You either have to wrap the <code>vector</code> into a circular buffer, or make it a double-ended vector.  Both of those are non-trivial.</p>
<p>The only cache-friendly adaptive-size container in std is vector (and its near clone string), so there you go.</p>
",1
22429417,22429387,2,"<p>When you write</p>

<pre><code>void setPosition(int nx,int ny)
{
    x=nx;
    y=ny;
    return;
}
</code></pre>

<p>you're defining a standalone function that's not part of any class.  To implement the member function declared in the <code>gSprite</code> class, you have to write</p>

<pre><code>void gSprite::setPosition(int nx,int ny)
{
    x=nx;
    y=ny;
    return;
}
</code></pre>
",8
22428315,22427489,0,"<p>Follow the code given below to check whether the string is null.</p>

<pre><code>   if (myString != NULL) {
      // doSomething
    }
</code></pre>

<p>And if you want to <strong>compare two strings</strong> try these:<br>
   - <code>strcmp(string1, string2)==0</code>   if the CASE of string is also to be compared.<br>
   - <code>strcmpi(string1,string2)==0</code>   if the CASE of string is <strong>NOT</strong> to be compared.</p>
",1
30170671,30170647,5,"<p>When you declare variables on the stack, their destructors will get called when they fall out of scope</p>

<pre><code>{
    int a = 5;
}
// a is now out of scope, it's destructor was called
</code></pre>

<p>You would have to go out of your way to clean up the memory if you allocated from the heap</p>

<pre><code>{
    int* a = new int(5);
}
// a was just leaked, unless you had a pointer to it later
</code></pre>

<p>You would have to have cleaned it up like</p>

<pre><code>{
    int* a = new int(5);
    delete a;
}
</code></pre>

<p>As of C++11, I would strongly advocate for using <code>&lt;memory&gt;</code> if you need heap allocated memory, but still want RAII cleanup.</p>

<pre><code>#include &lt;memory&gt;
{
    std::unique_ptr&lt;int&gt; a = std::make_unique&lt;int&gt;(5);
}
// a falls out of scope, the unique_ptr ensures the memory is cleaned up
</code></pre>
",7
30170769,30170647,1,"<p>The code you wrote only creates temporary objects on the stack, which are destroyed when the method exits.</p>

<p>In general, when your variables go out of scope, their content is no longer available.</p>

<p>If you allocate memory using the ""new"" keyword, then your objects will be kept in memory, but the pointer is lost when the variable referencing them goes out of scope.</p>

<p><strong>Edit:</strong></p>

<p>Actually, ""temporary objects"" are a feature of the C++ language, which can cause headaches if not used correctly. Read more here: <a href=""https://stackoverflow.com/questions/10897799/temporary-objects-when-are-they-created-how-do-you-recognise-them-in-code"">Temporary objects - when are they created, how do you recognise them in code?</a></p>

<p>The objects you create as local variables inside a function are automatically allocated and destroyed, I only used the word ""temporary"" to describe their behaviour: they are discarded when the function exits.</p>
",4
30170977,30170647,0,"<blockquote>
  <p>Do the objects c0 and c1 get destroyed and the memory frees when draw method returns,</p>
</blockquote>

<p>Yes. They get destroyed when the function returns.</p>

<blockquote>
  <p>or will they continue to eat heap memory ?</p>
</blockquote>

<p>The answer to that depends on what you do in the constructor and the destructor of the class. If you allocate memory from heap in the constructor or any of the other member function, that memory should be freed in the destructor. Otherwise, your function will leak memory, indirectly.</p>
",0
23063491,23063204,1,"<p>you have const data members so you can't change them in assignment operator.
other noticeable thing is that you are doing shallow copy in your copy constructor, which you should avoid. you are only copying address in one pointer to another, it means both pointers will point to same address and if later on one deletes it, an other will become dangling pointer.</p>
",0
23063673,23063204,0,"<p>Forget about the 3rd piece of code with the static, you should try to get the second block of code working, and resolve the 2 compile errors. </p>

<p>If removing the constness does not work, you can store C1 and C2 on the heap.</p>

<pre><code>const otherClass1 * C1;
const otherClass2 * C2;
</code></pre>

<p>Change them to pointers and new/delete them where needed, so you can use the copy constructor with a new, instead of the assignment operator (which you say does not exist for those classes)</p>
",0
27554319,27554265,0,"<p>Maybe you need a different kind of vector:</p>

<pre><code>std::vector&lt;Perceptron&gt; perceptrons;
</code></pre>

<p>Hopefully those are cheap to copy.</p>
",0
27554323,27554265,2,"<p>Because you're trying to put a <code>Perceptron</code> into a vector of <code>ints</code>.</p>

<p>Change your code to:</p>

<pre><code>int m = 3;
int l = 4;
int k - 6;
std::vector&lt;Perceptron&gt; perceptrons; // This is the line that needs changing
for(int i = 0; i &lt; k; i++){
    Perceptron Ki = Perceptron(m, l);
    perceptrons.push_back(Ki);
}
</code></pre>
",2
33018302,33017932,0,"<p>You can use the below signature (both in base and derived classes) (keeping the virtual declaration in the base):</p>

<pre><code>int compare(const Number* a){}
</code></pre>

<p>So basically the idea is to use pointers instead of references. This should work and you don't have to perform any kind of casting to call the compare method. </p>

<p>However, with the code above you still have to dynamically cast <em>Number</em> to Rational in the compare method body. Additionally, you have to take into account that it's possible to call a compare with any subclass of Number and maybe you are not interested in this behavior. So you have to added some checks to make sure that you are comparing against an incompatible class.</p>
",5
33019055,33017932,3,"<p>First of all, you need to have some content in order to compare. What is it?</p>

<p>a) Can the <code>Rational</code> only be compared with the other <code>Rational</code>? or</p>

<p>b) somehow <code>Value(Rational())</code> vs <code>Value(OtherNumber())</code>? where</p>

<pre><code>class OtherNumber : public Number
{
     // Some code here
}
</code></pre>

<p>If a, then you need to think why you put the <code>compare()</code> into the super class.</p>

<p>If b, then you need to abstract the other function, say</p>

<pre><code>virtual long Value() const = 0;
</code></pre>

<p>and alter <code>compare()</code> so it works on the <code>Value()</code>:</p>

<pre><code>virtual int compare(const Number&amp; a)
{
    // something about Value() and a.Value();
}
</code></pre>

<p>BTW, normally the compare function is a <code>const</code> function. That is:</p>

<pre><code>virtual int compare ( const Number&amp; a ) const;
</code></pre>

<p>Also, remember to extend the <code>Number</code> with <code>public</code>, i.e.</p>

<pre><code>class Rational : public Number
</code></pre>

<p>Otherwise you will lose polymorphic behavior.</p>
",4
24641041,24641007,3,"<p>instead of </p>

<pre><code>jc.setName = ""Jad Charara w\n"";
</code></pre>

<p>write</p>

<pre><code>jc.setName(""Jad Charara w\n"");
</code></pre>
",0
24641416,24641007,0,"<p>First of all you have defined 2 functions in class JadClass with public access specifier,so please confirm access specifier of which function you want to change from private to public.</p>

<p>Second thing in main you are trying to call setName function.
jc.setName = ""Jad Charara w\n"";</p>

<p>The above function call should be in <strong>jc.setName(""Jad Charara w\n"");</strong> format.</p>
",0
22112959,22112842,1,"<pre><code>getline(fd, school, ';');
</code></pre>

<p>reads from the <code>fd</code> stream, stopping at first occurence of <code>';'</code>. Since there is no <code>';'</code> in your file, it reads whole file into <code>school</code> string. </p>

<p>What you actually want to do is to parse your file line by line, constructing instance of <code>istringstream</code> using each line:</p>

<pre><code>std::string line;
while (std::getline(fd, line)) {

    if (line.empty())
        continue;                      

    std::istringstream is(line);
    std::string name, group;
    if (std::getline(is, name, ',') &amp;&amp; std::getline(is, group, ',')) {
        std::cout &lt;&lt; ""Name: "" &lt;&lt; name &lt;&lt; "" Group: "" &lt;&lt; group &lt;&lt; std::endl;
    }

}
</code></pre>

<p>just don't forget to <code>#include &lt;sstream&gt;</code>.</p>

<hr>

<p>Also note that:</p>

<pre><code>while (!fd.eof()) {
    std::getline(...);
    // relying on getline call being successful here
}
</code></pre>

<p>is not safe, just use its return value directly.</p>
",0
22447700,22447356,4,"<p>The compiler suite calls the preprocessor that creates the preprocessed file. This is usually done at a temporary location and probably with a temporary name. When you want the compiler to stop after preprocessing you have to pass an argument to compiler. When you use GCC it the <code>-E</code> argument that causes creation of the .i file.</p>

<p>Choose any editor of your choice to open this file.</p>

<p><em>Edit</em>:
The compiler might utilize pipes instead of temporary files (like GCC <code>-pipe</code>). If the hosting operation system doesn't support pipes, this will be implemented using temporary files. sigh.</p>
",1
22447732,22447356,1,"<p>Mainly the preprocessed .i files are used when there is a compiler bug. So for that eiher a test case or a preprocessed .i files are used. In those occation where reproducing test cases are not feasible solution it's better to use a preprocessed .i file.</p>

<p>To generate a preprocessed file (.i file), just add ""-EP -P"" to the compile option, and recompile the original .cpp file.  You can also generate a .i file directly from the ""Prepocessor"" property in Visual Studio*: </p>

<ol>
<li>Right click the file name, and click properties</li>
<li>Click Preprocessor\Generate Preprocessed File\Without Line Numbers (/EP /P)</li>
</ol>

<p>if you recompile from a command window, the .i file will be created under the current directory.
if you recompile from within the Visual Studio* IDE, the .i file will be created under the directory where the original source file is located.</p>
",0
24589109,24589052,2,"<p>This is a guess, because I haven't seen your error message or the file from which you include these headers.</p>

<p>In the line <code>virtual bool apply(Image&amp; img, const string filtername);</code> in filter.h, is <code>string</code> in scope?  I'm assuming that you mean <code>std::string</code>, because you include <code>&lt;string&gt;</code>, but you don't import it into the current namespace.  Try replacing <code>string</code> with <code>std::string</code>.</p>
",5
33575294,33575067,1,"<p>EDIT:</p>

<p>Extending c++ <code>string</code> class probably isn't a good idea (<a href=""https://stackoverflow.com/questions/3542030/extending-c-string-member-functions"">see that question</a>).</p>

<p>I don't know in what contexts in your code the <code>append</code> method is used, but You may try to add type casts using your favorite editor and a simple regular expression:</p>

<p>Find pattern:</p>

<pre><code>append\(([^,\)]+),([^\)]*)\);
</code></pre>

<p>Replace pattern:</p>

<pre><code>append((char *)($1),$2);
</code></pre>

<p>See the <a href=""http://regexr.com/3c59s"" rel=""nofollow"">small example</a> I made.</p>
",4
33576414,33575067,0,"<p>Good grief! <em>Don't</em> hack stuff like that!</p>

<p>If you really <em>must</em> change the default signedness of <code>char</code>, use the proper GCC command-line option:</p>

<ul>
<li><code>-funsigned-char</code></li>
<li><code>-fsigned-char</code></li>
</ul>

<p>However, it would be better to simply fix the code to use the proper type at declaration, and deal with the (few) odd spots where something breaks.</p>
",3
23810114,23809042,0,"<p>I don't know much about the <code>ODROID X-2</code> platform but if it's at all unixy you may have access to <code>gettimeofday</code> or <code>clock_gettime</code> either one of which would provide a higher resolution clock if available on your hardware.</p>
",1
22509217,22509186,5,"<p><code>string</code> has a constructor that accepts <code>char*</code>, so:</p>

<pre><code>std::string str(abc);
</code></pre>

<p>edit: oh you changed the question. Your problem is with null termination.</p>

<p><code>str</code> has 3 characters. <code>copy</code> copies these 3 characters. This means <code>abc</code> is not (yet) null-terminated. So you don't know where the end of the string is.</p>

<p>try</p>

<pre><code>abc[str.length()] = 0;
</code></pre>

<p>to null-terminate it.</p>

<p>I would also recommend dynamically allocating this memory because 1. 64kb on the stack is a lot, and 2. you are setting yourself up for a hard-to-find disaster and/or security holes by making assumptions about a string size.</p>

<p>If you can use <code>const char *</code>, then consider just using <code>str.c_str()</code> to access the underlying array.</p>
",1
22509223,22509186,0,"<p>you can use <code>strcpy(abc,str.c_str())</code>, this will copy the string from <code>str</code> to <code>abc</code>.</p>
",0
22509350,22509186,2,"<p>There is no need to use <code>std::copy</code>. Simply call the <code>c_str()</code> method on <code>std::string</code>.</p>

<pre><code>char * cstr = new char [str.length()+1];
std::strcpy (cstr, str.c_str());
</code></pre>
",0
23070250,23070179,5,"<p>Your increment functions need to return values of type <code>Iterator</code>, not <code>node</code>, and should update the internal node stored by the iterator. Your loop never actually modifies the <code>temp</code> object in your <code>Print</code> function, hence the infinite loop.</p>

<p>For example, your pre-increment function might look something like this</p>

<pre><code>Iterator&amp; Iterator::operator ++ ()
{
    // Update the node inside the iterator.
    nodePntr = nodePntr-&gt;next;
    // Return a reference to the updated iterator.
    return *this;
}
</code></pre>

<p>and then your post-increment can be written in terms of your pre-increment</p>

<pre><code>Iterator Iterator::operator ++ (int)
{
    // Make a copy. A working copy constructor is left as an exercise to the reader.
    Iterator temp(*this);
    // Call the pre-increment (code reuse);
    ++(*this); 
    return temp;
}
</code></pre>
",0
27690886,27690788,1,"<p>The first problem is you are not passing enough arguments to <a href=""http://msdn.microsoft.com/en-us/library/a442x3ye.aspx"" rel=""nofollow""><code>localtime_s</code></a>. It requires <em>two</em> arguments but you are only passing one.  The first argument should be a pointer to <code>tm</code> and the second a pointer to a <code>time_t</code>. The second problem is that the return type is <code>errno_t</code> not a pointer to <code>tm</code>. Your code for acquiring the current time should actually be:</p>

<pre><code>time_t rawtime;
tm timeinfo;
errno_t result = localtime_s(&amp;timeinfo, &amp;rawtime);
</code></pre>

<p>There is also a problem with sending the current time to <code>cout</code>. Since there is no overloaded version of <code>operator&lt;&lt;</code> that takes a type <code>tm</code> you will get the value of the pointer instead of the text representation of the time. After applying the above changes you will also need to change the stream out line from:</p>

<pre><code>cout &lt;&lt; ""Current local time and date: "" &lt;&lt; timeinfo &lt;&lt; endl;
</code></pre>

<p>to:</p>

<pre><code>cout &lt;&lt; ""Current local time and date: "" &lt;&lt; asctime(&amp;timeinfo) &lt;&lt; endl;
</code></pre>

<p>Any time you encounter a problem like this you should either look at the function signature or refer to the documentation to determine how to properly call the function. The documentation usually details what the arguments are, what values they can be (i.e. if NULL is acceptable for pointers), and what their return values are (if any). in this case the return value represents an error condition and should be checked to determine if the call was successful.</p>
",3
27690890,27690788,0,"<p>You didn't pass second parameter to <code>localtime_s</code>.</p>

<pre><code>time_t rawtime;
struct tm timeinfo;
errno_t error = localtime_s(&amp;timeinfo, &amp;rawtime);
</code></pre>

<p>It returns <code>zero</code> if successful. The return value is an <code>error code</code> if there is a failure. Error codes are defined in <code>Errno.h</code>. </p>
",0
22495830,22495606,0,"<p>When the file stream come to the end, <code>peek()</code>will return -1, which will lead infinite loop, you should test it like this:</p>

<pre><code>    int next_char;
    while (next_char = inputFile.peek(), (next_char != '\n') &amp;&amp; (next_char != -1) )
</code></pre>

<p>And I don't know why you reset these varibles:</p>

<pre><code>    validGrade = 0;
    invalidGrade = 0;
    grade_average = 0;
    stud_count= 0;
</code></pre>

<p>it will lead an exception: Integer division by zero when <code>grandTotal / stud_count</code>.</p>
",0
22496013,22495606,0,"<p>Your 2nd loop <code>while (inputFile.peek() != '\n')</code> is likely reaching the end of the file and causing an infinite loop due to <code>peek()</code> returning <code>EOF</code> instead of <code>'/n'</code></p>

<p>Your program should exit loop if <code>inputFile.peek() == EOF</code></p>

<p>I hope that helps!</p>
",0
22496156,22495606,0,"<p>if your file has data in same order i would suggest this </p>

<pre><code>while (inputFile.peek() != EOF || (!isalpha(inputFile.peek()))
</code></pre>

<p>this will work for files like this
Bob Marley
1234567
5 75 90 100
Balaji Ram
1265466
4 54 54 98</p>
",0
26419837,26419735,1,"<p>There you calculate position of first <code>/</code> in buffer.</p>

<pre><code>char* temp = strchr(buffer, '/');
</code></pre>

<p>Now <code>temp</code> points to <code>/</code> in buffer. If you want to copy this part of buffer, its enough to get pointer to start and length of string. So <code>temp - buffer</code> evaluates to length.</p>

<pre><code>=================================
The cat is fat/And likes to sing
=================================
^             ^
buffer        temp

|    length   | = temp - buffer
</code></pre>

<p>End of null terminated string determinated by <code>\0</code> (or simply 0). So if you need to store N chars you need to allocate N+1 buffer size.</p>
",0
26419886,26419735,1,"<pre><code>MAX_SIZE+1 is reserving space for the null terminator at the end of the string ('\0')

memcpy(id, buffer, temp - buffer) 
</code></pre>

<p>This is copying (temp-buffer) bytes from buffer to id.  Since strchr finds the '/' character in the input, temp is pointing inside buffer (assumiing it's found). So for example assume buffer points to a location in memory:</p>

<p>buffer = 0x781230001</p>

<p>and the third byte is the '/', after strchr, you have</p>

<p>temp = 0x781230003</p>

<p>temp - buffer therefore is 2.</p>

<p>HOWEVER: If the '/' is not found, then temp will not work and the code will crash.  You should check the result of strchr before doing the pointer arithmetic.</p>
",0
26419979,26419735,2,"<p>In my opinion it is simply a bad code.:)
I would write it like</p>

<pre><code>const size_t MAX_SIZE = 256

char buffer[MAX_SIZE] = {};

std::cin.getline( buffer, MAX_SIZE );

id[0] = '\0';
title[0] = '\0';

if ( char* temp = strchr( buffer, '/' ) )
{
    std::memcpy( id, buffer, temp - buffer );
    id[temp - buffer] = '\0';
    std::strcpy( title, temp + 1 );
}
else
{
    std::strcpy( id, buffer );
}
</code></pre>

<p>As for <code>memcpy</code> in this statement</p>

<pre><code>memcpy(id, buffer, temp - buffer);
</code></pre>

<p>then it copies temp - buffer bytes from buffer to id. As id was previously set to zeroes then after memcpy it will contain a string with terminating zero.</p>
",0
26420153,26419735,2,"<p>You're question concerns <em>pointer-difference</em> calculation, part of the family of arithmetic operations that are done in <em>pointer-arithmetic</em>.</p>

<p>Most beginners don't have too much trouble grasping how pointer-addition works. Given this:</p>

<pre><code>char buffer[256];
char *p = buffer + 10;
</code></pre>

<p>it is usually clear that <code>p</code> points to the 10th slot in the <code>buffer</code> char array. But you need to remember that the pointer <strong>type</strong> is important. The same construct you see above also works for more complicated data types:</p>

<pre><code>struct Something
{
    char name[128];
    int ident;
    int supervisor;
} people[64];

struct Something *p = people+10; // NOTE: same line, different types
</code></pre>

<p>Just as before, <code>p</code> points to the tenth element in the array, but note the arithmetic; the size of the underlying type is used to calculate the relevant memory offset. You don't need to do it yourself. No <code>sizeof</code> required here.</p>

<p>So why do you care? Because just like regular math, pointer math has certain properties, one of them being the following:</p>

<pre><code>char buffer[256];
char *p = buffer+10;   // p addresses the 10th slot in the array
size_t len = p-buffer  // len is the typed-difference between p and buffer.
</code></pre>

<p>In this case, <code>len</code> will be 10, the same as the offset of <code>p</code>. So how does this relate to your question? Well...</p>

<pre><code>char* temp = strchr(buffer, '/');
memcpy(id, buffer, temp - buffer);
</code></pre>

<p>The horrid nature of this code aside (if there is no <code>'/'</code> in the <code>buffer</code> array the result is <code>temp</code> being <code>NULL</code>, and the ensuing memcpy will all-but-guarantee a massive segfault). This code finds the location in the string where <code>'/'</code> resides. Once it has that, the calculation <code>temp - buffer</code> uses pointer arithmetic (specifically pointer differencing) to calculate the distance between the address in <code>temp</code> and the address as the base of the array. The result is the element count <strong>not including the slash itself</strong>. Therefore this code copies up-to, but not including, the discovered slash, into the <code>id</code> buffer. The rest of the <code>id</code> buffer retains all the <code>0</code> values populated with the memset and therefore the string is terminated (which is way more work than you need to do, btw).</p>

<p>After that line, the remainder:</p>

<pre><code>temp++;
strcpy(title, temp);
</code></pre>

<p>post-increments the temp pointer, which says ""move to the next element in the array"". Then the <code>strcpy</code> copies the remaining chars of the null-terminated <code>buffer</code> string into <code>title</code>. Worth noting this could have simply been:</p>

<pre><code>strcpy(title, ++temp);
</code></pre>

<p>And likewise:</p>

<pre><code>strcpy(title, temp+1);
</code></pre>

<p>which retains <code>temp</code> at the <code>'/'</code> position. In all of the above, the result in <code>title</code> will be the same: all chars <em>after</em> the slash, but not including it.</p>

<p>I hope that explains what is going on. Best of luck.</p>
",1
33558784,33558735,2,"<p>In the C++ language, create a class or struct and you can use <code>this-&gt;x</code> the same as <code>this.x</code> in the Java language.</p>
",0
33558802,33558735,3,"<p>In your case you can use <code>::</code> to specify to use global variable,
instead of local one:</p>

<pre><code>void test(int x) {
    ::x += 3;
    cout &lt;&lt; ::x &lt;&lt; endl;

}
</code></pre>

<p>And it is not <code>class member</code> or so on just global and local.</p>
",0
33558958,33558735,0,"<p>First of all, thank you for stating that you come from Java. This will help us <em>a lot</em> in terms of helping you!</p>

<p>Now, let's analyze your code</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;
</code></pre>

<p>Including some headers, using the <code>std</code> namespace (not recommended, BTW), everything's okay here.</p>

<pre><code>int x;
</code></pre>

<p>You declare a variable named <code>x</code> of type <code>int</code> at global scope, with an initial value of zero (this only applies to objects at global scope!).</p>

<pre><code>void test(int x) {
    x += 3;
    cout &lt;&lt; x &lt;&lt; endl;

}
</code></pre>

<p>You declare a function <code>test</code> that takes a parameter <code>x</code> of type <code>int</code> and returns <code>void</code> (a.k.a: nothing). The function increments the value of its intenral <code>x</code> variable by 3, then prints that to standard output by means of <code>std::cout</code>. Just to be clear, once you declare the <code>int x</code> parameter, it ""hides"" the <code>int x</code> at global scope, thus if you want to access the later, you have to use another way (see below).</p>

<pre><code>int main() {
    test(x);
    cout &lt;&lt; x &lt;&lt; endl;


    return 0;
}
</code></pre>

<p>You declare the special <code>main</code> function, taking no parameters and returning <code>int</code>. The function calls <code>test</code> with the global <code>int x</code> as argument, then prints the value of the global <code>x</code> to the standard output by means of <code>std::cout</code>, and finally <code>return</code>s zero, indicating successful execution.</p>

<p>Now, you have a big misconception, that you can attribute to the single-paradigm design of the Java language. In Java, there's no concept of ""global functions"", not to even say there are no ""functions"" at all. You only have ""classes"" with ""methods"".</p>

<p>In C++, this is not the case. The C++ language is a <em>multi-paradigm</em> one; it allows you to do imperative programming, structured programming, object-oriented programming, and even functional programming (you're not expected to have understood that last sentence completely)! When you declare <em>anything</em> without specifying an scope, it's said to lie in the <em>global</em> scope. The global scope can be accessed by <em>anything</em>, <em>anywhere</em>. In the example you presented <strong>there are no classes involved</strong>!</p>

<p>In the global scope, something like <code>void test(int)</code> is <strong>not</strong> a method, but a <strong>function</strong>. There's no class ""owning"" that function; let's say it's of ""everyone"" ;). A function is just a block of code that you can reuse by giving it arguments, if the function has them at all. In C++, you use classes to encapsulate data and corresponding code in a single ""packed"" black-box entity, not for, well, anything, like in Java.</p>

<p>Now, (this is somewhat like Java, but be careful!), when you pass a ""plain"" object, such as an <code>int</code> or something more funky and complex like <code>std::</code> (you were not expected to understand that...) to a function, that function gets a <em>copy</em> of that object. The <code>int x</code> in <code>test</code> is <em>not</em> the same as the one <code>main</code> passed to it. If you assign to it inside <code>test</code>, you'll notice <code>main</code> ""sees no difference"". In Java, this applies too, but only to the fundamental types like <code>int</code>, but in C++ it does for all types.</p>

<p>If you want to be able to change the variable you got, just use references. You get a reference of any type <code>T</code> by typing <code>T&amp;</code>. So, if you assign to a <code>int&amp; x</code> inside the now modified <code>test</code>, <code>main</code> will ""see"" all changes.</p>

<p>Finally, there's the <code>::</code> operator. It's used to access stuff in some scope from, well, other scopes. It has the form <code>namespace-or-class::stuff</code>. So for example, <code>std::cout</code> refers to identifier <code>cout</code> in namespace <code>std</code>. There's a special case: if the left operand is not given, <code>::</code> accesses the global scope. This is useful whenever you ""hide"" something from the global scope. So, for example, in <code>test</code>, you could say <code>::x</code>, and that would refer to the <code>x</code> in the global scope!</p>

<pre><code>void test(int x) {
    // ...
    ::x += 123;
}
</code></pre>

<p><strong>Edit</strong>: If you're curious, you can take a glance at how classes in C++ work with this (I won't explain it, because that's off-topic)...</p>

<pre><code>#include &lt;iostream&gt;

int x = 0;

class MyClass {
    private:
        int x;

    public:
        MyClass() : x(0) {}

        void test(int x) {
            this-&gt;report(x);
            std::cout &lt;&lt; ""Doing some magic...\n"";
            this-&gt;x += x;
            this-&gt;report(x);
        }

        void report(int x) {
            std::cout &lt;&lt; ""this-&gt;x = "" &lt;&lt; this-&gt;x &lt;&lt; '\n';
            std::cout &lt;&lt; ""x = "" &lt;&lt; x &lt;&lt; '\n';
        }
};

int main() {
    MyClass c;
    c.report();

    x += 123;
    c.test(x);
    x += 456;
    c.test(x);

    c.report();
}
</code></pre>
",0
22869667,22869352,1,"<p>First, your logic seems incorrect, as pointed out by Wimmel. I think you want to disable <code>operator--</code> only when <em>both</em> <code>day,hour</code> are zero.</p>

<p>Second, the prefix operator should return a reference.</p>

<p>Third, you may have the postfix operator use the prefix one, so you don't duplicate code.</p>

<p>All in all:</p>

<pre><code>NumDays&amp; NumDays::operator--()
{
    if (day &gt; 0 || hour &gt; 0)
    {
       --hour;
       simplify();
    }
    return *this;
}

NumDays NumDays::operator--(int)
{
    NumDays copy(*this);
    ++(*this);
    return copy;
}
</code></pre>
",0
24589826,24589816,3,"<blockquote>
  <p>Undeclared identifier but is declared</p>
</blockquote>

<p>No, it isn't. Your identifier is <em>defined</em>, not <em>declared</em>. This is a common source of confusion. Declaration of an identifier means to give it a unique signature that can be referred to in the following code lines. Definition means to give it a certain value/implementation. A <em>definition</em> implies <em>declaration</em> for the following code. </p>

<p><strong><em>At least an identifiers complete declaration must have been seen before first usage.</em></strong></p>

<p>That said you can simply put a declaration for your function before <code>main()</code></p>

<pre><code>HIDE int call1(int a,int b);
</code></pre>

<p>or just change your code to </p>

<pre><code>HIDE int call1(int a,int b) {
    int r;
    r= a+b;
    return r;
}

HIDE int main() {
    int x = 10;
    int z = 5;
    int c;

    c=call1(x,z);
}
</code></pre>

<p>and put the <em>definition</em> (which actually implies the <em>declaration</em>) before <code>main()</code> to have a forward declaration for your function.</p>

<p>I'm going to cite the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf"" rel=""nofollow"">current standards</a> section 3.1 here</p>

<blockquote>
  <h3>3.1 Declarations and de?nitions [basic.def]</h3>
  
  <p>1 A declaration (Clause 7) may introduce one or more names into a translation unit or redeclare names
  introduced by previous declarations. If so, the declaration speci?es the interpretation and attributes of these
  names. A declaration may also have e?ects including:<br>
   ¡ª a static assertion (Clause 7),<br>
   ¡ª controlling template instantiation (14.7.2),<br>
   ¡ª use of attributes (Clause 7), and<br>
   ¡ª nothing (in the case of an empty-declaration).  </p>
  
  <p>...</p>
</blockquote>
",7
27141713,27141684,2,"<p>Use</p>

<pre><code>void getNumAccidents(int &amp;value)
{
    cin &gt;&gt; value;
}
</code></pre>

<p>As you need to return the input to main.</p>
",0
27141714,27141684,3,"<p>Try like this </p>

<pre><code>int north;
int south;
int east;
int west;
int central;
cout &lt;&lt; ""Please enter the value for North\n"";
north=getNumAccidents(north);
cout &lt;&lt; ""the number of accidents in the north are:\n"" &lt;&lt; north;
break;
</code></pre>
",2
27142707,27141684,0,"<p>there is anothor way.</p>

<pre><code>void getNumAccidents(int *value)
{
    if (value)
    {
        cin &gt;&gt; *value;
    }
}
</code></pre>

<p>use like this</p>

<pre><code>int value = 0;
getNumberAccidents(&amp;value);
</code></pre>
",1
22111975,22111966,0,"<p>Avoid <strong>cin</strong> and <strong>cout</strong>, and use the C IO functions <strong>scanf</strong> and <strong>printf</strong> instead. You'll find they can be up to 5x faster than the slow c++ functions.</p>
",2
22112628,22111966,4,"<p>I'm pretty certain your code is problematic because you are using <code>cout &lt;&lt; x &lt;&lt; endl;</code> in a loop that will print a huge number of lines. </p>

<p>I will be back with ""difference"" in a few minutes. </p>

<p>Edit: Not sure I can make much of a difference either way. Obviously, depending on compiler, it may vary greatly, but with my g++ -O2 and 100000 input numbers, it takes 0.16 - 0.18s to use <code>endl;</code> and 0.06 - 0.07s to use <code>'\n'</code> for the output.</p>

<p>Using <code>printf</code> isn't faster than <code>cout</code>, but <code>scanf</code> is a little faster than <code>cin</code> (0.04s +/- 0.05). </p>

<p>However, that is really related to <code>sync_with_stdio</code>. If we use <code>cin.sync_with_stdio(false);</code> then the results are the same for <code>scanf</code> and <code>cin</code>.</p>

<p>All measurements are made with a file as input and a file as output - it takes much longer to write to the shell, but that's because it's scrolling 100k lines of text past me. </p>

<p>(Your program will crash with eithr ""large"" inputs or with large number of inputs - if <code>max</code> is greater than about 1 million, the code will crash due to out of stack - on many systems, that may happen for lower values too)</p>
",2
22121200,21413285,1,"<p>There are <strong>tons of problems</strong> with your code, so let's do this step by step.</p>

<p>First, you don't need your preprocessor magic for the namespace, but just a basic <code>namespace mynamespace{}</code>.</p>

<p>Secondly, it is ideal to create a <code>basic_string</code> class, so that it can be used with different character types. <code>char</code> / <code>wchar_t</code>, e.t.c.</p>

<p><strong>Problems with your class:</strong></p>

<p>1) <code>private: const char *_str;</code>. The pointer will be modified, so the <code>const</code> is useless.</p>

<p>2) There are no <code>typedef</code>s. You need them if you are attempting to re-implement a STL class. (Explained in example)</p>

<p>3) Use an <code>allocator</code>. This way you can <code>construct</code>, and <code>destroy</code> elements, <code>allocate</code>, and <code>deallocate</code> memory. You will be certain to keep your memory a lot safer this way.</p>

<p>4) Strings must be null terminated. That means an extra <code>'\0'</code> at the end, meaning you will have to allocate an extra byte for that. Strings are null terminated, because it is a way of telling the code to stop reading the string.</p>

<p>5) You are assigning to a string which has not been allocated. <code>_str = s.c_str();</code> could easily crash, depending on your compiler, because you are writing to non-allocated memory.</p>

<p>6) Use const references, rather than normal types for your parameters (<code>string</code> = <code>const string &amp;</code>). You also need this for your copy constructor <code>basic_string(const _Myt &amp;)</code>.</p>

<p>I still may not have highlighted <em>all</em> of the problems</p>

<p><strong>Example <code>basic_string</code> class</strong></p>

<pre><code>template &lt; typename _Elem, typename _Traits = std::char_traits&lt;_Elem&gt;, typename _Alloc = std::allocator&lt;_Elem&gt; &gt; class basic_string
{
public:
    typedef basic_string&lt;_Elem, _Traits, _Alloc&gt; _Myt;
    typedef _Elem value_type;
    typedef _Traits traits_type;
    typedef _Alloc  allocator_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type *iterator;
    typedef const value_type *const_iterator;
    typedef value_type &amp;reference;
    typedef const value_type &amp;const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    basic_string()
    {
        __data = _Alloc().allocate(1);
        _Alloc().construct(&amp;__data[0], '\0');
    }

    basic_string(const_pointer _Init)
    {
        int count = 0;
        __data = _Alloc().allocate(_Traits::length(_Init) + 1);
        for (const_iterator i = &amp;_Init[0]; i != &amp;_Init[_Traits::length(_Init)]; ++i, ++count)
        {
            _Alloc().construct(&amp;__data[count], *i);
        }
        _Alloc().construct(&amp;__data[_Traits::length(_Init)], '\0');
    }

    basic_string(const _Myt &amp;_Init)
    {
        if (this != &amp;_Init)
        {
            int count = 0;
            __data = _Alloc().allocate(_Traits::length(_Init.__data) + 1);
            for (const_iterator i = &amp;_Init.__data[0]; i != &amp;_Init.__data[_Traits::length(_Init.__data)]; ++i, ++count)
            {
                _Alloc().construct(&amp;__data[count], *i);
            }
            _Alloc().construct(&amp;__data[_Traits::length(_Init.__data)], '\0');
        }
        else
        {
            __data = _Alloc().allocate(1);
            _Alloc().construct(&amp;__data[0], '\0');
        }
    }

    ~basic_string()
    {
        if (__data)
        {
            size_type tmp = size();
            for (iterator i = begin(); i != end(); ++i)
            {
                _Alloc().destroy(i);
            }
            _Alloc().deallocate(__data, tmp);
        }
    }

    _Myt &amp;assign(const_pointer _Rhs)
    {
        int count = 0;
        reserve(_Traits::length(_Rhs) + 1);
        for (const_iterator i = &amp;_Rhs[0]; i != &amp;_Rhs[_Traits::length(_Rhs)]; ++i, ++count)
        {
            _Alloc().construct(&amp;__data[count], *i);
        }
        _Alloc().construct(&amp;__data[_Traits::length(_Rhs)], '\0');
        return *this;
    }

    _Myt &amp;operator=(const_pointer _Rhs)
    {
        return assign(_Rhs);
    }

    _Myt &amp;append(const_pointer _Rhs)
    {
        int count = size();
        reserve(size() + _Traits::length(_Rhs) + 1);
        for (const_iterator i = &amp;_Rhs[0]; i != &amp;_Rhs[_Traits::length(_Rhs)]; ++i, ++count)
        {
            _Alloc().construct(&amp;__data[count], *i);
        }
        _Alloc().construct(&amp;__data[count], '\0');
        return *this;
    }

    _Myt &amp;operator+=(const_pointer _Rhs)
    {
        return append(_Rhs);
    }

            iterator begin()
    {
        return &amp;__data[0];
    }

    iterator end()
    {
        return &amp;__data[size()];
    }

    size_type size()
    {
        return _Traits::length(__data);
    }

    _Myt &amp;swap(basic_string&lt;_Elem&gt; &amp;_Rhs)
    {
        std::swap(__data, _Rhs.__data);
        return *this;
    }

    void reserve(size_type _Size)
    {
        int count = 0;
        if (_Size &lt; size())
        {
            return;
        }
        pointer buf = _Alloc().allocate(_Size);
        for (iterator i = begin(); i != end(); ++i, ++count)
        {
            _Alloc().construct(&amp;buf[count], *i);
        }
        std::swap(__data, buf);
        for (iterator i = &amp;buf[0]; i != &amp;buf[_Traits::length(buf)]; ++i)
        {
            _Alloc().destroy(i);
        }
        _Alloc().deallocate(buf, _Traits::length(buf));
    }

    operator const_pointer()
    {
        return __data;
    }

    operator pointer()
    {
        return __data;
    }

    template &lt; typename _Traits1, typename _Alloc1 &gt; friend std::basic_ostream&lt;_Elem&gt; &amp;operator&lt;&lt;(std::basic_ostream&lt;_Elem&gt; &amp;_Stream, basic_string&lt;_Elem, _Traits1, _Alloc1&gt; &amp;_Str)
    {
        return _Stream &lt;&lt; _Str.c_str();
    }

    const_pointer data() const
    {
        return __data;
    }

    const_pointer c_str() const
    {
        return __data;
    }
private:
    pointer __data;
};

typedef basic_string&lt;char&gt; string;
typedef basic_string&lt;wchar_t&gt; wstring;
</code></pre>

<p>Of course, there is still a bit missing, but I'm sure you can implement that with a little online help.</p>
",0
33035578,33035512,6,"<p>Your vector contains a <em>copy</em> of the object you add to it through <code>push_back()</code>. The first destructor invocation is caused by the temporary you create being destroyed at the end of the full expression containing the call to <code>push_back()</code>. The second destructor is caused by the copy inside the vector being destroyed when the vector itself is destroyed.</p>

<p>You can convince yourself by adding a diagnostic to <code>main()</code>:</p>

<pre><code>int main()
{
    std::vector&lt;Test&gt; container;

    container.push_back( Test() );

    printf(""\nThis is before the vector is destroyed..."");

    return 0;
}
</code></pre>

<p>You can observe the output in this <a href=""http://coliru.stacked-crooked.com/a/19d3e574e30be028"" rel=""nofollow""><em>live example</em></a>.</p>

<p>The copy which your vector contains is created by invoking the automatically-generated move constructor for your class (rather than using default construction), which is why you don't see a corresponding construction diagnostic.</p>

<p>If you defined your own move constructor (or copy constructor, as shown below) to emit a diagnostic, the output would be closer to what you'd expect:</p>

<pre><code>    Test(Test const&amp;)
    {
        printf(""\nCopy construction triggered."");
    };
</code></pre>

<p>Again, <a href=""http://coliru.stacked-crooked.com/a/5a11d66e9434cc84"" rel=""nofollow""><em>live example</em></a>.    </p>
",0
33035582,33035512,3,"<p>Because you don't print every constructor invocation, you're missing out on move-constructor call. Your class, apart from the default constructor you've provided, has also implicitly generated move and copy constructors.</p>

<p>The vector stores a value, and that value has to be initialized in some way. Typically, this happens either via a move c-tor or copy c-tor, altough an object might also be created <em>directly</em> inside of the vector using e.g. <code>emplace_back</code>.</p>

<p>Try adding this:</p>

<pre><code>Test(Test&amp;&amp;)
{
    printf(""\nClass move constructor triggered."");
};
</code></pre>

<p>to your class, it should change the output to something that makes more sense (I've also added a print at the end of <code>main</code>):</p>

<p><a href=""http://coliru.stacked-crooked.com/a/ca11e015d3fc2ed8"" rel=""nofollow""><kbd><strong>Live On Coliru</strong></kbd></a></p>

<pre><code>Class constructor triggered.
Class moveconstructor triggered.
Class desctructor triggered.
Out of main scope.
Class desctructor triggered.
</code></pre>

<p>The first destructor call destroys <strong>moved-out</strong> ""empty"" instance of your class, while the second one fires when the vector itself is destroyed.</p>
",0
33035585,33035512,2,"<p><em>For the sake of simplicity, let's assume you are working with C++03, and move semantics are not available yet.</em></p>

<p>Add copy constructor to see that it is also triggered</p>

<pre><code>Test(const Test&amp;)
{
    printf(""\nClass copy constructor triggered."");
};
</code></pre>

<p>Output</p>

<pre><code>Class constructor triggered.
Class copy constructor triggered.
Class destructor triggered.
Class destructor triggered.
</code></pre>

<p>So, there are two objects constructed/destructed.</p>

<p>Roughly speaking, your code is equal to</p>

<pre><code>int main()
{
    std::vector&lt;Test&gt; container;

    Test test;                    // first object created
    container.push_back(test);    // second object created by copying
    return 0;
}
</code></pre>
",5
33035586,33035512,2,"<p>The <code>push_back()</code> does not trigger any destructor (in this case).</p>

<p>The two calls to <code>Test</code>'s destructor are:</p>

<p>1 - Because you pass a temporary to <code>push_back()</code>, so that object get destroyed when <code>push_back()</code> is done</p>

<p>2 - when the program end, so the <code>vector</code> get destroyed and so it is it's content</p>
",0
23582919,23582771,1,"<ol>
<li>Your understanding is correct.</li>
<li>If used, ASCII characters will have same ordering ( <code>z</code> will always come after <code>a</code>)</li>
<li>I guess not. Compiler will apply optimization when it sees reasonable. Besides, everything in C++ is passed by value. So the <code>reference</code> will be passed by value, and it is more overhead to copy than copying the character itself.</li>
<li><strong>Never</strong> return a <code>pointer</code> or <code>reference</code> to a local variable. When the function returns, the variable will no longer exist, and the <code>pointer</code> or <code>reference</code> will be invalid, and using them will lead to <strong>Undefined Behavior</strong>.</li>
</ol>
",5
22160437,22160272,1,"<p>One solution is to use virtual functions. You can also use <code>std::unique_ptr</code> to avoid memory leaks, i.e.:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
using namespace std;

class base{
public:
    base() { }
    virtual ~base() { }
    virtual void function() { std::cout &lt;&lt; ""base\n""; }
};
class a : public base
{
public:
    a() { }
    ~a() { }
    virtual void function() { std::cout &lt;&lt; ""a\n""; }
};

int main()
{
    vector&lt;std::unique_ptr&lt;base&gt;&gt; list;
    list.push_back(std::unique_ptr&lt;base&gt;(new a()));
    list.push_back(std::unique_ptr&lt;base&gt;(new base()));

    for (const auto&amp; e : list)
    {
        e-&gt;function();
    }
}
</code></pre>

<p>The other is to attempt a <code>dynamic_cast</code> for your derived object. </p>

<pre><code>    a* ptr = dynamic_cast&lt;a*&gt;(e.get());
    if (ptr)
        funktion(ptr);
    else
        funktion(e.get());
</code></pre>
",0
22161110,22160272,0,"<p>Function overloading is done at compile time, whereas what you are wanting here is a runtime choice between the two functions.  So that will mean using virtual methods for polymorphism, or if that isn't going to be possible, then to query the runtime type information directly, such as with dynamic_cast&lt;></p>

<p>If the existing library turns out to be such a poor fit to your object oriented design, it may work out to write an object oriented wrapper to it</p>
",0
24103407,24103370,1,"<p>Looking at your implementation of <code>Adder</code>, it seems like you mean it to be a template but haven't written it as such.</p>

<p>You're only missing the <code>template &lt;typename T&gt;</code> line.</p>

<pre><code>template &lt;typename T&gt;
class Adder
{
private:
    static const char symbol = '+';
public:
    T operator() (const T &amp; x, const T &amp; y) const { return x + y; };
    char getSymbol(void) const { return symbol; };
};
</code></pre>
",1
28458547,28405660,3,"<p>""Scope"" is a language feature, meaning that a variable is only visible and living inside the boundaries of the surrounding code block (here: surrounding <code>{}</code>).</p>

<p>""Stack"" is a computing architecture feature, which allows for functions to be called, operating on their own set of registers, and then, on returning from these functions, restoring the original state of computing as was saved prior to the function call.</p>

<p>Thus, these two concepts are orthogonal to each other. C++ defines, based on scope, which variables are accessible (or reach the end of their lifetime); the compiler adds stack framing as necessary for function calling.</p>
",0
24768181,24768122,1,"<p>As pointed out in the comments, every non-zero number is divisible by 1 and itself. Change this line (line 4)</p>

<pre><code>while (i&lt;= n)
</code></pre>

<p>to</p>

<pre><code>while (i&lt; n)
</code></pre>
",3
24768191,24768122,1,"<p>If that's your whole code, then you're simply missing a <code>main()</code> function.</p>

<p>Though it shouldn't link without a <code>main()</code> function.</p>

<p>There are some additional problems with your code, but that's probably the reason why you don't see any output.</p>

<p>Try adding this to your file:</p>

<pre><code>int main()
{
    prime_numbers();
    return 0;
}
</code></pre>
",1
24768228,24768122,1,"<p>Change your loop to:</p>

<pre><code>for(int i=2; i&lt;n; i++){
    if(n%i==0){
         return false;
    }
}
</code></pre>

<p>Or your while end condition to:</p>

<pre><code>while(i &lt; n-1)
</code></pre>
",0
24769811,24768122,0,"<p>Many people have pointed out the problem with:</p>

<pre><code>while (i &lt;= n)
</code></pre>

<p>...because you allow <code>i</code> to be <code>n</code> in your for loop, every natural number is divisible by itself so it wrongly accuses prime numbers of being composites.  As people pointed out, the quick fix is:</p>

<pre><code>while (i &lt; n)
</code></pre>

<p>But the reason why I reply is because there are other things you can do to make your code better.  The first improvement is that you don't need to try dividing by numbers greater than the square root of <code>n</code> because if there is a greater than it, then there is also a divisor less than it.  So you could do something like this:</p>

<pre><code>while (i*i &lt;= n)
</code></pre>

<p>But there are further improvements you can do on that.  For example, why should you have to compute i*i every iteration?  If you pre-compute square root of <code>n</code> (rounded to int), then you can avoid that computation.</p>

<p>Another optimization is that you can avoid trial dividing by half of the numbers: if <code>n</code> is not divisible by 2, then no reason to try any other even numbers.  So you can jump <code>i</code> by 2 every time in your inner loop.  There are other tricks if you want to eliminate trial dividing by numbers divisible by 3.</p>

<p>Really, however, there is a nice super-duper fast algorithm to find the first <code>x</code> primes if you don't mind using order <code>x</code> bytes of memory.  It is called the <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" rel=""nofollow"">sieve of Eratosthenes</a>, and it is really fun to implement.  Once you get your current code optimized, I recommend trying the sieve.</p>

<p>The problem of finding prime numbers efficiently has received an enormous amount of attention in the academic literature, and it is now considered solved.  But it takes a lot of study to learn it.</p>
",0
33015842,33015782,2,"<p>Replace OR(<code>||</code>) with AND(<code>&amp;&amp;</code>)</p>

<pre><code>if (major != ""math"" &amp;&amp; major != ""Math"" &amp;&amp; major != ""CIS""  &amp;&amp; major != ""cis"")
</code></pre>
",0
33015852,33015782,0,"<p>You are confused between OR (||) and AND (&amp;&amp;). Replacing <code>||</code> by <code>&amp;&amp;</code> in the IF condition should do the trick.</p>

<p>What your current <code>if</code> statement checks <code>(if A is not equal to B) OR (if A is not equal to C)</code>. If B and C are distinct, then A can at max be equal to one of them, or in other words, will always not be equal to at least one of them.</p>

<p>So, your condition will always evaluate to true. The correct term for this is that your <code>if</code> condition is a tautology.</p>

<p>If you want to skip all this and want the code:</p>

<pre><code>if (major != ""math"" &amp;&amp; major != ""Math"" &amp;&amp; major != ""CIS""  &amp;&amp; major != ""cis"") {
</code></pre>
",0
33015917,33015782,1,"<p>If you want the user to have to input a valid major then you need to put it into a loop:</p>

<pre><code>std::string major;
std::cout &lt;&lt; ""Major: "";
std::cin &gt;&gt; major;
while (major != ""math"" &amp;&amp; major != ""Math"" &amp;&amp; major != ""CIS""  &amp;&amp; major != ""cis"")
{
    std::cout &lt;&lt; ""Please enter a valid major!\n"";
    std::cout &lt;&lt; ""Major: "";
    std::cin &gt;&gt; major;
}
</code></pre>

<p>This way the program will not continue unless they enter a valid major.</p>
",0
29488083,29487386,3,"<p>That depends probably more on the way you drive your compiler than a 32/64 bits difference.</p>

<p>My expectation (and what I verified just here with gcc) is that <code>__FILE__</code> gives the name as provided to the compiler.  For instance</p>

<pre><code>$ cat foo.c
int main() { printf(""%s\n"",__FILE__); }
$ gcc foo.c &amp; ./a.out
foo.c
$ gcc ./foo.c &amp; ./a.out
./foo.c
$ gcc `pwd`/foo.c &amp; ./a.out
/the/full/path/as/reported/by/pwd/foo.c
</code></pre>

<p>similarly for include files, the path reported is the one used by the compiler to access the header, thus may depend on the way you specified the include directories.</p>
",0
22522830,22522774,1,"<p>Let's start with the first one, and I'll let you try the others yourself.</p>

<pre><code>int a[ ] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
</code></pre>

<p>That is your main array. You can think of it as a list with 10 slots. 
In slot 0, 1 is stored. In slot 1, 2 is stored. In slot 10, 0 is stored.
It is important to remember than an array starts with 0, and not 1.</p>

<p>If you want what's in the array slot number 5 you can write:</p>

<pre><code>a[5];
</code></pre>

<p>For example:</p>

<pre><code>int sum = a[5];
</code></pre>

<p>Now sum equals to what is in slot 5 of the array. 
Now, if you write:</p>

<pre><code>int sum = a[5] + a[2];
</code></pre>

<p>That would result in sum equaling 9.</p>

<p>A for-loop that is built like this:</p>

<pre><code>for(int i = 0; i &lt; 10; i++)
</code></pre>

<p>first initializes i to 0. </p>

<pre><code>int i = 0;
</code></pre>

<p>Then loops whats inside it's brackets until</p>

<pre><code>i &lt; 10;
</code></pre>

<p>is not true.</p>

<p>The </p>

<pre><code>i++
</code></pre>

<p>Simply adds 1 to i each time the loop iterates.</p>

<p>So, back to the first case.</p>

<pre><code>int a[ ] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
int total = 0;
for (int i = 0; i &lt; 10; i++)
{ 
    total = total + a[i];
}
</code></pre>

<p>In the first iteration, i = 0.</p>

<pre><code>total = total + a[0];
</code></pre>

<p>Which is 1. In the second iteration, i = 1.</p>

<pre><code>total = total + a[1];
</code></pre>

<p>total is already 1. So it's 1 + (what is in the second slot of the array), which is 2.
1+2 = 3.</p>

<pre><code>total = total + a[2];
</code></pre>

<p>total is already 3. So it's 3 + (what is in the third slot of the array), which is 3.
3+3 = 6.</p>

<p>It is important to remember that an array starts with 0.</p>

<p>I hope you can do the rest yourself, and if you can't, I can help you out!</p>
",10
22522876,22522774,0,"<p>You have a loop, for (int i = 0; i &lt; 10; i++)</p>

<p>That means i will start at 0 and go all the way up to 9... which is i &lt; 10 (less than 10)</p>

<p>Inside the loop you are adding... total = total + a[i]</p>

<p>What you are adding is the values in your array... int a[ ] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};</p>

<p>So for a. you are adding all of them... including the last value in your array, 0.</p>

<p>a[0] = 1
a[1] = 2
etc.</p>

<p>In the second example you have for (int i = 0; i &lt; 10; i=i+2) </p>

<p>This means the loop value i will start at 0, then go 2, 4, 6 etc. so you will be adding  a[0], a[2], a[4] etc. all the way up to a[8]</p>

<p>In the more complex examples you have a different starting value for your loop...</p>

<p>for (int i = 2; i &lt;= 10; i++)... this will start at 2 instead of 0... and also will INCLUDE 10, because you have a ""less than or equal to"" instead of just a less than.</p>

<p>In other loops you have i--... this means you value of i will decrease by one instead of increase by 1 in the loop.</p>

<p>Hopefully that's enough to get you going?</p>
",0
24105796,24105513,1,"<p>Using C++11? Use std::condition_variable.</p>
",0
24105808,24105513,1,"<p>What you have is a way.</p>

<p>There other things you can use. A few come to my mind:</p>

<p><strong>Using conditions</strong></p>

<p>A <a href=""http://www.dre.vanderbilt.edu/Doxygen/6.2.6/html/libace-doc/a00123.html"" rel=""nofollow"">condition</a> is somewhere where you can <em>wait()</em> for other part (thread) of the code to <em>signal()</em> you can continue</p>

<p>Conditions are associated to a mutex</p>

<p>In your code:</p>

<p>Thread #1</p>

<pre><code>// start thread #2
mutex.acquire();
// You could check for an actual condition here if it
// is more complex than a true false.
condition.wait();
// If we're checking for a complex condition here
// we should re-evaluate in case it is not satisfied.
mutex.release();
</code></pre>

<p>Thread #2</p>

<pre><code>// do stuff
mutex.acquire();
condition.signal();
mutex.release();
</code></pre>

<p><strong>Using a Future</strong></p>

<p>A <a href=""http://en.wikipedia.org/wiki/Futures_and_promises"" rel=""nofollow"">Future</a> is a higher level construct for representing the result of an asynchronous operation.</p>

<p>It works more or less like this:</p>

<ol>
<li>The caller creates a <code>Future</code> object and keeps a reference to it and passes a reference to the thread performing the asynchronous operation.</li>
<li>The caller continues its processing while the other thread performs its task.</li>
<li>If the caller needs the result, it will try to get it from the Future object. If the result it is not yet available, the caller will be blocked (e.g. using a condition/signal) until the asynchronous operation finishes and sets the value (that sends the signal).</li>
<li>If the asynchronous operation finishes before it is needed, the caller will get the result without wait.</li>
</ol>
",0
22131433,22131382,0,"<p>Just take the input as a string. then <strong>split</strong> the string using <a href=""http://www.cplusplus.com/reference/cstring/strtok/"" rel=""nofollow"">strtok()</a>. insert the values into two variables. Before inserting <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow"">convert</a> the string values to integer.</p>
",1
22131489,22131382,1,"<p>input and <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow"">convert</a> it to string , then split it into 2 strings , and then convert them in integers at last.</p>
",0
22131543,22131382,0,"<p>You almost had it:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    int hours, minutes;
    char colon;
    std::cin &gt;&gt; hours &gt;&gt; colon &gt;&gt; minutes;
    std::cout &lt;&lt; hours &lt;&lt; "" : "" &lt;&lt; minutes;

    return 0;
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/4662d681057cec44"" rel=""nofollow"">Live example</a></p>
",1
22133084,22133045,3,"<p>It doesn't have anything to do with the array being dynamically allocated. Your variable <code>a</code> is not <code>const</code>, so the non-<code>const</code> function will be called on it. If you had <code>const B b(10);</code> and did <code>b[3]</code>, the <code>const</code> version would be called.</p>

<p>If you really want to, you can force the <code>const</code> version to be called by casting to a <code>const</code> reference:</p>

<pre><code>static_cast&lt;const A&amp;&gt;(a)[3]
</code></pre>

<p>(Or alternatively, create a reference variable and call it on that)</p>
",2
22133241,22133045,2,"<p>You've discovered why <code>operator[]</code> is a poor 'interface' for cache-like operations, and also why everybody seems to be caught out by the behaviour of <code>std::map</code> which creates a new object if you try to 'index' one that doesn't exist.</p>

<p>I'd write explicit <code>get</code> and <code>set</code> methods, and that way you won't surprise users of your cache class.</p>
",0
26806034,26805941,5,"<p>This is because reading input with <code>getline</code> does not mix well with reading input character-by-character. When you enter the <code>Y</code>/<code>N</code> character to indicate if you want to proceed or not, you also press <kbd>Enter</kbd>. This puts <code>\n</code> in the input buffer, but <code>&gt;&gt;</code> does not take it from there. When you call <code>getline</code>, the <code>\n</code> is right there, so the function returns an empty string right away.</p>

<p>To fix this, make <code>choice</code> a <code>std::string</code>, use <code>getline</code> to read it, and send the first character to <code>getChoice</code> function, like this:</p>

<pre><code>string choice;
...
do {
    ...
    do {
        getline(cin, choice);
    } while (choice.size() == 0);
} while (getChoice(choice[0]));
</code></pre>
",1
22866504,22865077,0,"<p>So basically you want a specific function to be executed according to a cmd line input? Easy! Create you main function like this:</p>

<pre><code>int main(int argc, char *argv[])
</code></pre>

<p>argc is the argument count and argv is the argument value. Google up on this if you need more info, it's widely used. Use an if statement inside your main function that will call the required function according to the value of argv[]. So when you execute your program you'll execute like</p>

<pre><code>exe_file_name go anything
</code></pre>

<p>If you want to call multiple functions dynamically during a single execution you could instead do
getline(cin,choice);</p>

<pre><code>if(strcmp(choice, ""room"")) //condition
</code></pre>
",0
22866129,22865077,-1,"<p>I think it should be like</p>

<pre><code>if(strcmp(choice , ""room"")){//condition being executed}
</code></pre>
",0
22133263,22133101,5,"<p>I'm not going to give you any code, because that won't allow you to truly explore this concept. Rather, you should use this pseudo code to implement something on your own.</p>

<p>Create a function which accepts two inputs, the base and the exponent.</p>

<p>Now there are several ways to go about doing this. You can use efficient bit shifting, but let's start simple, shall we?</p>

<pre><code>answer = base
i = 1
while i is less than or equal to exponent
    answer = answer * base
return answer
</code></pre>

<p>Simply loop through multiplying the base by itself.</p>

<p>There are other ways that focus on efficiency. Look here to see something that you may want to attempt: <a href=""https://stackoverflow.com/questions/12556906/are-2n-exponent-calculations-really-less-efficient-than-bit-shifts"">are 2^n exponent calculations really less efficient than bit-shifts?</a></p>
",0
22133334,22133101,3,"<blockquote>
  <p>The program must not use any pre-defined C++ functions (like pow function) for this task</p>
</blockquote>

<p>You can use some piece of c++ code like follows, to compute <strong>x<sup>y</sup></strong>, without using any predefined function:</p>

<pre><code>int x = 5;
int y = 3;
int result = 1;
for(int i = 0; i &lt; y; ++i)
{
    result *= x;
}

cout &lt;&lt; result &lt;&lt; endl;
</code></pre>

<p>Output:</p>

<pre><code>125
</code></pre>

<p>See a working sample <a href=""http://ideone.com/BQpmiJ"" rel=""nofollow"">here</a>.</p>
",0
22891699,22891132,1,"<p>You can easily check your arguments as they are simply strings. Storing the result as a std::string allows you to perform many operations to test your input. I've heavily commented the below code to help you understand the checks.</p>

<p>Everytime an error is occured, an error message is printed using <code>fprintf</code> to <code>stderr</code>. You should always print your errors to this stream as opposed to printing to <code>stdout</code>. This is because standard error is still seen by users without interfering with things that store the output from programs.</p>

<p>If the program does not return during checks, then your program can function knowing that your input is good.</p>

<pre><code>#include &lt;string&gt;

int main (int argc, char *argv[]) {
    //Validate
    //If incorrect number of arguments, print error
    if (argc != 3) { //3 as program name is argument, ie argv[1]
        fprintf(stderr, ""Not enough arguments"");
        return 1; 
    } else { //Check arguments
        //Store arguments as strings to allow easy operations
        std::string p1 = argv[1];
        std::string p2 = argv[2];

        //Check P1
        if (! (p1.find_first_not_of( ""0123456789"" ) == std::string::npos) //if p1 is not made of 0-9
            &amp;&amp; (p1.front() != '+' ) &amp;&amp; (p1.front() != '-' ) //and the front char of p1 is none of the allowed characters
            &amp;&amp; (p1.front() != 'e' ) &amp;&amp; (p1.front() != 'E' ) ) //...then we have an error
        {
                fprintf(stderr, ""Not a digit, or a +,-,e,E are the first or last character"");
                return 1; 
        }


        //Check P2
        std::string numeral = p2.substr(1, p2.length()); //store everything but first char into new string
        int n = strtol(numeral.c_str(), NULL, 10); //use strtol to convert this to a number

        if (p2.front() != 'X' //if front is not X, we have error
            ||  !numeral.find_first_not_of( ""0123456789"" ) == std::string::npos //or if substring is not a number, we have an error
            || (n &lt; 2 || n &gt;16) ) //or if n is either less than 2 or greater than 16, we have an error
        {
            fprintf(stderr, ""The first character is not X and the second character is less than 2 or greater than 16"");
            return 1; 
        }


    } 

    //program body here....

    return 0;
}
</code></pre>
",0
28490323,28490126,1,"<p>It looks like you may be missing C++ runtime DLLs.  </p>

<p>Give this program a try: <a href=""http://www.dependencywalker.com"" rel=""nofollow"">http://www.dependencywalker.com</a></p>
",1
22884963,22884554,0,"<p>I tested your code under two cases.</p>

<ol>
<li>The first line is shorter than <code>256</code> characters. In this case, it works corectly.</li>
<li>The first line is longer than <code>256</code> characters. In this case, it breaks.</li>
</ol>

<p>However, using the fix suggested by DietmarKuhl, the code no longer breaks:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

using namespace std;
int main(){
    cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
    char c = cin.peek();
    if(c == '#') 
        cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');

    int num;

    //read in all nums, including x, y, gs
    while(cin &gt;&gt; num) {
        cout &lt;&lt; num &lt;&lt; endl;;
    }
}
</code></pre>
",0
22887667,22887534,2,"<p>You do not initialize the double change variable anywhere, and the same goes for the product price essentially.</p>

<p>You are not using the pPrice variable here.</p>

<pre><code>Money::Money(double amountP, double pPrice) {
...
}
</code></pre>
",1
28457266,28457094,2,"<p>That error message gets produced by g++ default uncaught exception handler, see <a href=""https://gcc.gnu.org/onlinedocs/libstdc++/manual/termination.html#support.termination.verbose"" rel=""nofollow"">Verbose Terminate Handler</a>:</p>

<blockquote>
  <p>The __verbose_terminate_handler function obtains the name of the current exception, attempts to demangle it, and prints it to stderr. If the exception is derived from exception then the output from what() will be included.</p>
</blockquote>

<p>But in:</p>

<pre><code>class RemoveError : exception
</code></pre>

<p><code>std::exception</code> is not a <strong>public</strong> base class of <code>RemoveError</code>, hence that exception handler cannot call its <code>what</code> function.</p>

<p>Fix:</p>

<pre><code>class RemoveError : public exception
</code></pre>

<p>Or:</p>

<pre><code>struct RemoveError : exception
</code></pre>

<hr>

<p>Note 1:</p>

<pre><code>virtual const char* what() const noexcept
</code></pre>

<p>Should be:</p>

<pre><code>const char* what() const noexcept override
</code></pre>

<hr>

<p>Note 2:</p>

<pre><code>T removeFirst() throw(RemoveError);
</code></pre>

<p>Exception specification is depricated in C++11. That should be just plain:</p>

<pre><code>T removeFirst();
</code></pre>
",7
28457332,28457094,1,"<blockquote>
  <p>terminate called after throwing an instance of
  'Deque::RemoveError' </p>
</blockquote>

<p><code>std::terminate</code> was called as there was an active exception that, through stack unwinding, was not caught.<br>
In order to retrieve the message thrown along with the exception you have to catch the exception somewhere and call <code>what</code>.</p>

<pre><code>{
    try {
        // code that might throw
    } catch(RemoveError e) {
       std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>
",1
24585641,24585597,2,"<p>Post-increment returns a value <em>before</em> the increment. That is why when you see <code>return *this</code> in a postfix <code>++</code> or <code>--</code> operator you should immediately know that the implementation is wrong.</p>

<p>The correct sequence of actions is as follows:</p>

<ul>
<li>Make a copy of <code>*this</code></li>
<li>Do the increment</li>
<li>Return the copy.</li>
</ul>

<p>Assuming that your <code>Fraction</code> class has a properly functioning copy constructor, the fix is very easy:</p>

<pre><code>Fraction Fraction::operator++(int a)
{
    Fraction res(*this);
    // The following two lines are most likely shared with the prefix ++
    // A common trick is to call ++*this here, to avoid code duplication.
    numer = (numer + denom);
    normalize();
    return res;
}
</code></pre>
",1
24585703,24585597,2,"<p>When you have problems with overloaded operators as in your example, it's often helpful to look behind the syntactic sugar and see what the calls ""really"" look like.</p>

<p><code>f2 = f1++;</code></p>

<p>This one actually translates as:</p>

<pre><code>f2.operator=(f1.operator++(0));
</code></pre>

<p>It's even clearer if you assume for one moment that these are really just ordinarily named functions:</p>

<pre><code>f2.Assign(f1.PostIncrement());
</code></pre>

<p>Now it should be obvious what happens. Your <code>PostIncrement</code> function is called first, and its result is passed as an argument to <code>Assign</code>.</p>

<p>There is nothing magic about overloaded operators. They are just functions with special names. There are no special rules for returning values or passing arguments. Thus,</p>

<pre><code>Fraction Fraction::operator++(int a)
{
    numer = (numer + denom);
    normalize();
    return *this;
}
</code></pre>

<p>, imagined like this:</p>

<pre><code>Fraction Fraction::PostIncrement()
{
    numer = (numer + denom);
    normalize();
    return *this;
}
</code></pre>

<p>does exactly what you wrote: It increments itself, then returns itself.</p>

<p>If you want the same post-increment semantics as the built-in types, then you have to <strong>implement those semantics manually</strong>. In your <code>operator++(int)</code>, create a temporary copy of <code>*this</code> first, then increment, <em>then</em> return the temporary copy.</p>
",1
22888927,22888194,0,"<p>To show up to 2 decimal places, but not showing trailing zeros you can do something such as:</p>

<pre><code>std::string function(double value)
{
  // get fractional part
  double fracpart = value - static_cast&lt;long&gt;(value);

  // compute fractional part rounded to 2 decimal places as an int
  int decimal  = static_cast&lt;int&gt;(100*fabs(fracpart) + 0.5);
  if (decimal &gt;= 100) decimal -= 100;

  // adjust precision based on the number of trailing zeros
  int precision = 2; // default 2 digits precision
  if      (0 ==  decimal)       precision = 0; // 2 trailing zeros, don't show decimals
  else if (0 == (decimal % 10)) precision = 1; // 1 trailing zero, keep 1 decimal place

  // convert value to string
  std::stringstream str;
  str &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision) &lt;&lt; value;
  return str.str();
}
</code></pre>
",0
22888242,22888194,4,"<p>1) Just because you see two digits, it doesn't mean the underlying value was necessarily <em>rounded</em> to two digits.</p>

<p>The precision of the <em>VALUE</em> and the number of digits displayed in the <em>FORMATTED OUTPUT</em> are two completely different things.</p>

<p>2) If you're using cout, you can control formatting with ""setprecision()"":</p>

<p><a href=""http://www.cplusplus.com/reference/iomanip/setprecision/"" rel=""nofollow"">http://www.cplusplus.com/reference/iomanip/setprecision/</a></p>

<p>EXAMPLE (from the above link):</p>

<pre><code>// setprecision example
#include &lt;iostream&gt;     // std::cout, std::fixed
#include &lt;iomanip&gt;      // std::setprecision

int main () {
  double f =3.14159;
  std::cout &lt;&lt; std::setprecision(5) &lt;&lt; f &lt;&lt; '\n';
  std::cout &lt;&lt; std::setprecision(9) &lt;&lt; f &lt;&lt; '\n';
  std::cout &lt;&lt; std::fixed;
  std::cout &lt;&lt; std::setprecision(5) &lt;&lt; f &lt;&lt; '\n';
  std::cout &lt;&lt; std::setprecision(9) &lt;&lt; f &lt;&lt; '\n';
  return 0;
}
</code></pre>

<p>sample output:</p>

<pre><code>3.1416
3.14159
3.14159
3.141590000
</code></pre>
",0
22888243,22888194,2,"<p>Mathematically, <code>2.2</code> is exactly the same as <code>2.20</code>, <code>2.200</code>, <code>2.2000</code>, and so on. If you want to see more insignificant zeros, use <code>[setprecision][1]</code>:</p>

<pre><code>cout &lt;&lt; fixed &lt;&lt; setprecision(2);
cout &lt;&lt; 2.2 &lt;&lt; endl; // Prints 2.20
</code></pre>
",0
31246572,31246536,3,"<p>The standard makes this clear:</p>

<p>If a destructor throws an exception then it is caught by the <code>try</code> block in which the variable is <strong>defined</strong>.</p>

<p>So if <code>~Bar()</code> throws an exception, then the output is ""inner"". If <code>~Foo()</code> throws, then the output is ""middle"";</p>
",0
24769387,24769362,1,"<p><s>You can probably just pass it:</p>

<pre><code>LOGWriteEntry (buffer);
</code></pre>

<p>If you are using ancient memory models with windows, you might have to explicitly cast it:</p>

<pre><code>LOGWriteEntry ((LPCTSTR) buffer);
</code></pre>

<h2></s></h2>

<p>correction:</p>

<p>LPCTSTr is Long Pointer to a Const TCHAR STRing.  (I overlooked the TCHAR) with the first answer.</p>

<p>You'll have to use the <a href=""http://msdn.microsoft.com/en-us/library/dd319072%28v=vs.85%29.aspx"" rel=""nofollow"">MultiByteToWideChar function</a> to copy <code>buffer</code> to another buffer and pass that to the function:</p>

<pre><code>w_char buf2 [1024];
MultiByteToWideChar (CP_ACP, 0, buffer, -1, buf2, sizeof buf2);
LOGWriteEntry (buf2);
</code></pre>
",6
24769562,24769362,1,"<p>A good way to proceed might be from among these alternatives:</p>

<ul>
<li>Design the <code>logverbose</code> function to use <code>TCHAR</code> rather than <code>char</code>; or</li>
<li>Find out if the logging API provides a <code>char</code> version of <code>LOGWriteEntry</code>, and use that alternative.</li>
<li>If no <code>char</code> version of <code>LOGWriteEntry</code> exists, extend that API by writing one. Perhaps it can be written as a cut-and-paste clone of <code>LOGWriteEntry</code>, with all <code>TCHAR</code> use replaced by <code>char</code>, and lower-level functions replaced by their ASCII equivalents. For example, if <code>LOGWriteEntry</code> happens to call the Windows API function <code>ReportEvent</code>, your <code>LOGWriteEntryA</code> version could call <code>ReportEventA</code>.</li>
<li>Really, in modern applications, you should just forget about <code>char</code> and just use <code>wchar_t</code> everywhere (compatible with Microsoft's <code>WCHAR</code>). Under Unicode builds, <code>TCHAR</code> becomes <code>WCHAR</code>. Even if you don't provide a translated version of your program (all UI elements and help text is English), a program which uses wide characters can at least input, process and output international text, so it is ""halfway there"".</li>
</ul>
",3
23840241,23840125,0,"<p>It's not about overloading the = operator, it's about implementing the assignment operator for the struct. If you do that, you won't need to change your <code>Node</code> class, unless I've missed something else.</p>

<p>The above assumes that you'll be making copies of the data inside the Node. Alternatively, you can pass the data by reference. In this case, you need to be careful that the data doesn't get deleted before the Node object is deleted, otherwise you'll get a crash when trying to access a deleted data object from your Node.</p>
",0
27526995,27526873,0,"<p>The code shall not be compiled because in this point where constructor</p>

<pre><code>Victor(Complex &amp; c) { x = c.getReal(); y = c.getImg(); }
</code></pre>

<p>is defined the compiler knows nothing whether class <code>Complex</code> has methods <code>getReal</code> and <code>getImg</code></p>

<p>You have only do declare the constructor in class <code>Victor</code> and define it only after the definition of class <code>Complex</code>.</p>

<p>Take into account that it would be better that some member functions and objects would have qualifier const. For example functions <code>getReal</code> and <code>getImg</code> could be declared with qualifier const. Also the parameter in the constructor above could be declared with  qualifier const.</p>

<pre><code>Victor( cosnt Complex &amp;c );
</code></pre>

<p>Or for example <code>operator &lt;&lt;</code> could be declared like</p>

<pre><code>friend std::ostream &amp; operator &lt;&lt;( std::ostream &amp;ostr, const Complex &amp;c );

friend std::ostream &amp; operator &lt;&lt;( std::ostream &amp;ostr, const Victor &amp;v );
</code></pre>
",0
27527013,27526873,0,"<p>Work through the errors in order, and fix each problem in turn.</p>

<p>First error:</p>

<pre><code>test.cpp: In constructor ¡®Victor::Victor(Complex&amp;)¡¯:
test.cpp:17:40: error: invalid use of incomplete type ¡®class Complex¡¯
             Victor(Complex &amp; c) { x = c.getReal(); y = c.getImg(); }
</code></pre>

<p>You can't use the <code>Complex</code> type here since it hasn't been defined yet. Just declare the function at this point:</p>

<pre><code>Victor(const Complex &amp;);
</code></pre>

<p>and define it after the definition of <code>Complex</code></p>

<pre><code>Victor::Victor(const Complex &amp; c) { x = c.getReal(); y = c.getImg(); }
</code></pre>

<p>(I took the liberty of adding <code>const</code> since that's appropriate here. You might also want to rename the class <code>Vector</code>, since it appears to represent a vector not a victor.)</p>

<p>Second error:</p>

<pre><code>test.cpp:10:17: error: ¡®int Victor::x¡¯ is private
test.cpp:43:23: error: within this context
    ostr &lt;&lt; ""( "" &lt;&lt; v.x &lt;&lt; "", "" &lt;&lt; v.y &lt;&lt; "" )"" ;
</code></pre>

<p>This is because you declare a function with one signature (taking its second argument by reference)</p>

<pre><code>friend ostream &amp; operator &lt;&lt;(ostream &amp; ostr, Victor &amp; v);
</code></pre>

<p>and define a different overload taking its argument by value:</p>

<pre><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; ostr, Victor v)
</code></pre>

<p>Make the both match; <code>const Victor&amp;</code> is the most appropriate type. Alternatively, you could define the function within the class definition:</p>

<pre><code>class Victor
{
    // ...
    friend ostream &amp; operator &lt;&lt;(ostream &amp; ostr, const Victor &amp; v) {
        return ostr &lt;&lt; ""( "" &lt;&lt; v.x &lt;&lt; "", "" &lt;&lt; v.y &lt;&lt; "" )"" ;
    }
    // ...
};
</code></pre>

<p>Or you could implement the function using the public interface, with no need for a <code>friend</code> declaration:</p>

<pre><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; ostr, const Victor &amp; v) {
    return ostr &lt;&lt; ""( "" &lt;&lt; v.getX() &lt;&lt; "", "" &lt;&lt; v.getY() &lt;&lt; "" )"" ;
}
</code></pre>

<p>After fixing those errors, the code compiles and produces sensible-looking output.</p>
",1
27504885,27504808,3,"<p>Simply use std::string:</p>

<pre><code>string filename = ""/home/giovanni/Scrivania/enzimi/ligan/"" + id[1] + "".pdb"";

...

std::ifstream file(filename.c_str());
</code></pre>
",6
27504937,27504808,0,"<ol>
<li><p>Watch Out For Buffer Overflow!</p></li>
<li><p>You need to append to the existing string; you need to know the number of characters in it, then offset the pointer you pass in to the second call to sprintf:</p></li>
</ol>

<p><code>int len = sprintf(filename, ""/home/giovanni/Scrivania/enzimi/ligan/%s"", id[1].c_str());
    sprintf(filename + len, ""%s"", extension1);</code></p>

<p>(sprintf returns the number of characters written into the buffer, but does not include the NUL terminator.)</p>

<p>Note that the second call to sprintf only has one ""%s"".</p>
",0
27504972,27504808,1,"<p>Simply using this code would do (<code>sprintf</code> takes variable number of arguments):</p>

<pre><code>sprintf(filename,""/home/giovanni/Scrivania/enzimi/ligan/%s%s"", id[1].c_str(), extension1);
</code></pre>

<p>But, as you are using C++, Doing it in C style is not preferable. <code>sprintf()</code> can cuase buffer overflows and you can you safer version <code>snprintf()</code>. Best option would be to use <code>std::string</code></p>
",0
27505422,27504808,1,"<p>C99  and  POSIX.1-2001 specify that the results are undefined if a call  to sprintf()/snprintf would cause copying to take place between objects that overlap (e.g., if the target string array and one of the supplied  input  arguments  refer  to  the same buffer).
So line <strong>sprintf(filename, ""%s%s"", filename,extension1)</strong> is illegal.
You can try other options like std::string.</p>
",0
30206515,30206479,2,"<ol>
<li>is a pointer to a vector of Element objects.</li>
</ol>

<p>The declaration itself is for a pointer to a container object.  It contains individual Element objects.</p>

<ol start=""2"">
<li>is a vector of pointers to Elements.</li>
</ol>

<p>The declaration itself is for the container object.  It contains pointers, each pointing to an Element object.</p>

<ol start=""3"">
<li>is a pointer to a vector of pointers to Elements.</li>
</ol>

<p>The declaration itself is a pointer.  It points to a vector, which contains more pointers.  These pointers are to actual element objects.</p>

<ol start=""4"">
<li>is a reference to a vector of pointers to Elements.</li>
</ol>

<p>This is just like #3, except that it is a reference to a vector instead of a pointer.  A reference basically being a pointer that you can't re-point at something else.</p>
",1
30206756,30206479,2,"<p><strong>A <code>vector</code> of <code>Element</code>s</strong></p>

<pre><code>std::vector&lt;Element&gt; elements;
</code></pre>

<p>You can add <code>Element</code>s to it. Assuming <code>Element</code> has default constructor, you can use:</p>

<pre><code>elements.push_back(Element());
</code></pre>

<p>You can get the first <code>Element</code> from <code>elements</code> using:</p>

<pre><code>Element e = elements[0];
</code></pre>

<p><strong>Pointer to a <code>vector</code> of <code>Element</code>s</strong></p>

<pre><code>std::vector&lt;Element&gt;* elementsPointer;
</code></pre>

<p>In order to add <code>Element</code>s to <code>elementsPointer</code>, is has to point to something valid.</p>

<pre><code>elementsPointer = new std::vector&lt;Element&gt;;
elementsPointer-&gt;push_back(Element());
</code></pre>

<p>You can get the first <code>Element</code> from <code>elementsPointer</code> using:</p>

<pre><code>Element e = (*elementsPointer)[0];
</code></pre>

<p>or</p>

<pre><code>Element e = elementsPointer-&gt;at(0);
</code></pre>

<p><strong>A <code>vector</code> of pointers to <code>Element</code>s</strong></p>

<pre><code>std::vector&lt;Element*&gt; elementPointers;
</code></pre>

<p>You can add <code>Element*</code> to the <code>vector</code>.</p>

<pre><code>elementPointers.push_back(new Element);
</code></pre>

<p>When you get the items from this <code>vector</code>, you get <code>Element*</code>s.</p>

<pre><code>Element* ePtr = elementPointers[0];
</code></pre>

<p><strong>Pointer to a <code>vector</code> of pointers to <code>Element</code>s</strong></p>

<pre><code>std::vector&lt;Element*&gt;* elementPointersPointer;
</code></pre>

<p>In order to add <code>Element</code> pointers to <code>elementPointersPointer</code>, is has to
point to something valid.</p>

<pre><code>elementPointersPointer = new std::vector&lt;Element*&gt;;
elementPointersPointer-&gt;push_back(new Element);
</code></pre>

<p>You can get the first <code>Element*</code> from <code>elementPointersPointer</code> using:</p>

<pre><code>Element* ePtr = (*elementPointersPointer)[0];
</code></pre>

<p>or</p>

<pre><code>Element* ePtr = elementPointersPointer-&gt;at(0);
</code></pre>

<p><strong>Using a reference</strong></p>

<p>Using a reference to any of the above forms is just like using references to any other types in C++.</p>

<p>Use can use:</p>

<pre><code>std::vector&lt;Element&gt; elements;
std::vector&lt;Element&gt;&amp; elementsRef = elements;
</code></pre>

<p>or any of the other variants.</p>
",0
22445921,22444315,2,"<p>You have to tell gcc where allegro.h is installed. Run this command in terminal and post the output.</p>

<pre><code>find / -name 'allegro.h' 2&gt;/dev/null
</code></pre>
",1
22445609,22445588,2,"<p>You have errors here:</p>

<pre><code>if (val1 &gt; val2){
    val1 = greater_val; //^^^should be greater_val = val1; same error apply below
    val2 = smaller_val;
}
else if (val2 &gt; val1){
  //^^you probably don't need this if again, what if they are equal?
    val2 = greater_val;
    val1 = smaller_val;
}
</code></pre>

<p>Since <code>greater_val</code> and <code>smaller_val</code> are initialized as <code>0</code>, so with the code you have now, they are always zero.</p>

<p>Another point: you have to make sure that <code>val2</code> is not 0 when you do division.</p>
",0
27687988,27687769,0,"<p>You can easily do that by using templates.
like this:</p>

<pre><code>template &lt;class T&gt;
class CTest{
    .
    .
    .
}
template &lt;class T&gt;
static void print::CTest&lt;T&gt;(T message){...}
</code></pre>

<p>and then specify your variable type while using in your main function.</p>
",0
27687857,27687769,1,"<p>This is what the templates are for e.g:</p>

<pre><code>template&lt;typename Type&gt;
void print_something(Type something) {
  std::cout &lt;&lt; something &lt;&lt; '\n';
}
</code></pre>

<p>The compiler is smart enough to deduce type from parameter. So you can call it like this:</p>

<pre><code>print_something(""test"");
print_something(42);
</code></pre>

<p>It also works for member functions. What compiler does is it substitutes the <code>Type</code> with a concrete type (like <code>int</code>, or <code>char*</code>, or <code>std::string</code>) and produces an overload.</p>
",0
27687893,27687769,0,"<p>You can use C++ templates, Template provide generic data types in c++.
see this for more details.</p>

<p><a href=""http://www.tutorialspoint.com/cplusplus/cpp_templates.htm"" rel=""nofollow"">http://www.tutorialspoint.com/cplusplus/cpp_templates.htm</a>
<a href=""http://www.cprogramming.com/tutorial/templates.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/templates.html</a></p>
",0
27688230,27687769,0,"<p>just create functions with the same name but with different parameters, this is called function overload, for example:</p>

<pre><code>void print(char *message) { printf(""%s"", message); }
void print(int val) { printf(""%d"", val); }
void print(char ch) { printf(""%c"", ch); }
</code></pre>

<p>All above functions are overloaded, see examples of calling:</p>

<pre><code>print(""Hello World!"");
print(10);
print('P');
</code></pre>

<p>this is only available in C++ (not in C)</p>
",1
27554289,27554177,1,"<p>No. You should depend on compiler performing <a href=""http://en.wikipedia.org/wiki/Return_value_optimization"" rel=""nofollow"">(N)RVO</a> for this. Just remember to turn on all recommended optimizations, which should be obvious, since running c++ and Eigen with out them is kinda slow by definition.</p>

<p>Using a pointer would complicate the logic unnecessarily.</p>
",0
22882182,22881940,1,"<p>As others have said:</p>

<p>1/ Use <code>function(const std::vector&lt;int&gt;&amp; intVector)</code> as the function signature.</p>

<p>2/ Call it with <code>function( {10,12,13} );</code> from main().</p>

<p>3/ Compile with std::initializer_list support enabled: <code>g++ -std=c++0x filename.C</code></p>

<p>Give that a go.</p>
",0
22881975,22881940,3,"<p>Call <code>function</code> like this:</p>

<pre><code>function({10,12,13});
</code></pre>

<p>This will use the <code>std::initializer_list</code> constructor of <code>vector</code> to construct the argument. Notice that you accept a <code>vector</code> by value, which could result in a copy. You might want to use:</p>

<pre><code>void function(const std::vector&lt;int&gt;&amp; v) {}
</code></pre>

<p>as your signature if you don't modify the argument.</p>

<p>If your compiler does not support the <code>initializer_list</code> feature (Visual Studio or a missing <code>-std=c++11</code> switch on <code>clang</code>/<code>gcc</code>) you will need to create a temporary and initialize it manually.</p>

<pre><code>std::vector&lt;int&gt; v;
v.push_back(10); v.push_back(12); v.push_back(13);
function(v);
</code></pre>
",4
22881993,22881940,2,"<p>Try this</p>

<pre><code>// Create vector
std::vector&lt;int&gt; vi{ 10, 12, 13};

// Pass vector to function
function( vi );

// Receive vector parameter at function

  // Option 1: If you want to modify the passed vector
  void function( std::vector&lt;int&gt; &amp; vp );

  // Option 2: if you do not want to modify the passed vector
  void function( std::vector&lt;int&gt; const &amp; vp );
</code></pre>
",2
21325092,21324593,2,"<p>This perhaps isn't the most helpful answer, but given the problem of computing the LCM of a sequence of integers, I'd approach the problem rather differently.</p>

<p>From school mathematics, you might remember that</p>

<pre><code>GCD(m, n) * LCM(m, n) = m*n
</code></pre>

<p>So, for two integers, we have a way to calculate the LCM in terms of the greatest common divisor. The GCD is easy to compute using the well known Euclidean algorithm.</p>

<p>So now we have the fundementals of an LCM algorithm for an arbitrary sequence of integers:</p>

<ol>
<li><p>Let <code>m</code> and <code>n</code> be the first two elements of the sequence</p></li>
<li><p>Set <code>m = m * n/GCD(m, n)</code></p></li>
<li><p>Set <code>n</code> as the next element of the sequence and go to 2.</p></li>
<li><p>Return m</p></li>
</ol>

<p>i.e. we compute the LCM of the first pair, then the LCM of that result and the next element of the sequence, and so on.</p>

<p>I have no idea as to whether this is optimal, but it requires no dynamic storage or sorting of elements, so it should be quicker than your solution above.</p>

<p>(Also, as an aside, I'm pretty sure that LCM(3, 4, 6) = 12, not 24 :-) )</p>

<p><strong>EDIT:</strong> I found the problem interesting enough to hack up a solution, so I may as well share it...</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
inline T gcd(T a, T b)
{
    while (b != 0) {
        T t = b;
        b = a % b;
        a = t;
    }    
    return a;
}

template &lt;typename Iter&gt;
inline auto
lcm(Iter start, Iter end)
    -&gt; typename std::iterator_traits&lt;Iter&gt;::value_type
{
    using value_type = typename std::iterator_traits&lt;Iter&gt;::value_type;

    if (start == end) return 0; // empty sequence

    value_type m{*start};

    while (++start != end) {
        value_type n{*start};
        m = m * n / gcd(m, n);
    }
    return m;
}

int main()
{
    std::vector&lt;int&gt; v{3, 4, 20, 5, 12, 15};
    std::cout &lt;&lt; lcm(v.begin(), v.end()) &lt;&lt; std::endl; // prints 60
}
</code></pre>

<p>Comments and corrections welcome of course :-)</p>
",0
22867383,22867220,2,"<blockquote>
  <p>So, what's the KEY of this problem?</p>
</blockquote>

<p>In your code you say</p>

<pre><code>if (height.size() &gt; T1.height.size())

class idealtype {
    // ...
private:
    int height; // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
};
</code></pre>

<p>since <code>height</code> is declared as <code>int</code> it doesn't have any class like methods. That's why the compiler complains.</p>
",0
21029671,21029589,5,"<p>Something like this?</p>

<pre><code>template &lt;class T1 = int, class T2 = std::string&gt; class recipe {
    T1 timeToPrepare;
    T2 name;
};

typedef recipe&lt; baseQuery&lt;int&gt;, baseQuery&lt;std::string&gt; &gt; recipeQuery;

typedef recipe&lt; schemeItem&lt;int&gt;, schemeItem&lt;std::string&gt; &gt; recipeQuery;
</code></pre>
",0
21029811,21029589,0,"<pre><code>template&lt;template&lt;typename&gt; class T&gt;
class recipe{
public:
    T&lt;int&gt; timeToPrepare;
    T&lt;std::string&gt; name;
};

typedef recipe&lt;baseQuery&gt; recipeQuery;
typedef recipe&lt;schemeItem&gt; recipeScheme;
</code></pre>
",0
28520195,28520161,3,"<p>The rules are strict enough that size of <code>signed char</code> and <code>unsigned char</code> must also be 1.</p>

<p>There is no other type for which the size is guaranteed--and I know of compilers that make <code>sizeof(bool)</code> a value larger than 1, and that make <code>sizeof(int)</code> a value other than 4.</p>
",3
28520209,28520161,2,"<p>Types are not necessarily guaranteed to always have the same byte size across architectures. sizeof(X) is actually implemented by the compiler and outputs an integer (1,2,4,8, etc.) and is therefore not a function call. As a result, the output for a given type (e.g. int) will depend on the system for which your application was compiled. This is why you have to recompile an application for a different architecture.</p>

<p>That said, some types are always a particular size (e.g. int32).</p>

<p>See: <a href=""https://stackoverflow.com/questions/589575/what-does-the-c-standard-state-the-size-of-int-long-type-to-be"">What does the C++ standard state the size of int, long type to be?</a></p>
",2
28520214,28520161,6,"<p>The size is only guaranteed explicitly for <code>char</code>: <code>sizeof(char) == 1</code>. Implicitly this guarantee also applies to <code>signed char</code> and <code>unsigned char</code> as one of them is required to use the same representation as <code>char</code> and the other is bound by the conversion rules between <code>signed char</code> and <code>unsigned char</code> to use the same size.</p>

<p>Other than that there are only guarantees on the number if bits present in some types and a size relation between some types. Note, that <code>char</code> can have any number of bits equal or bigger than 8.</p>
",2
28520228,28520161,2,"<p>In theory, an (old C++) implementation (but probably not C++11) might have <code>sizeof</code> every scalar type (numerical, pointer, boolean) be 1. But I cannot name such an implementation (where <code>sizeof(int)</code>, <code>sizeof(double)</code>, <code>sizeof(long long)</code>, <code>sizeof(bool)</code>, <code>sizeof(void*)</code> are all 1).</p>

<p>You probably should use <a href=""http://www.cplusplus.com/reference/cstdint/"" rel=""nofollow""><code>&lt;cstdint&gt;</code></a> header if you care about data type sizes.</p>

<p>Also, code <a href=""http://en.wikipedia.org/wiki/Software_portability"" rel=""nofollow"">portability</a> can be tricky. You should care not only about integral data type size, but also about <a href=""http://en.wikipedia.org/wiki/Endianness"" rel=""nofollow"">endianess</a> and operating system issues (standards like <a href=""http://en.wikipedia.org/wiki/POSIX"" rel=""nofollow"">POSIX</a> should help). An aphorism says that <em>there is no software that is portable, only code that has been painfully ported</em>.</p>
",2
22522643,22522587,2,"<pre><code>botguess = rand() % (ma - mi + 1) + mi
</code></pre>

<p>You don't want <code>ma</code> different numbers, you want much less of them. Look at an example: <code>(5..10)</code> contains <code>6</code> different numbers: <code>[5, 6, 7, 8, 9, 10]</code>; but if you do <code>rand() % 10 + 5</code>, you're getting numbers from <code>5</code> (<code>5 + 0</code>) to <code>14</code> (<code>5 + 9</code>). What you need is <code>rand() % 6 + 5</code>, where <code>6</code> is <code>10 - 5 + 1</code>.</p>
",1
22522689,22522587,1,"<p>The problem you are having is caused by the fact that mi is set to botguess, which can easily be greater than zero, then on the next cycle if ma is still 100 (or anywhere near it), you're going to sometimes get numbers greater than 100 set into botguess.</p>

<p>Edit added: the % operator in C++ is mod division (ie. gives the remainder of integer division) So for example, 98 % 100 + 15 will be 98 + 15, i.e. 113</p>

<p>This link may help you:</p>

<p><a href=""http://www.cplusplus.com/reference/cstdlib/rand/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdlib/rand/</a></p>
",6
23111742,23111650,3,"<p>That <code>#ifnotdef</code> does not work. The correct precompiler switch is <code>#ifndef</code> or <code>#if !defined()</code>.</p>
",0
23111812,23111650,0,"<p>It seems that the header is included in more than one module and contains the function definition . As for #ifnotdef then I think it is a typo is not it? Otherwise the compiler would issue an other error.</p>
",1
23111974,23111650,0,"<p>Assuming you mean that the headers contain include guards:</p>

<pre><code>#ifndef SOME_HEADER_H  // not #ifnotdef
#define SOME_HEADER_H

// header contents

#endif
</code></pre>

<p>this will only prevent multiple inclusion in a single translation unit. It will <em>not</em> prevent anything defined in there from being multiply defined, if you include it in multiple translation units.</p>

<p>To fix the problem, the definitions of any functions declared in the header can be either:</p>

<ul>
<li>moved into a source file, so there is only one definition; or</li>
<li>made <code>inline</code>, so that multiple definitions are allowed; or</li>
<li>if they're member functions, moved into the class definition, so that they're implicitly inline.</li>
</ul>
",0
21032529,21032491,3,"<p>You are reading the newline character you already entered earlier with your final <code>get()</code> call. You might want to ignore all characters up to and including the first newline before waiting for some other input:</p>

<pre><code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
std::cin.get();
</code></pre>

<p>You can shorten this to become</p>

<pre><code>std::cin &gt;&gt; std::ws;
</code></pre>

<p>if it is OK requiring to enter a non-whitespace character to terminate the program: the <code>std::ws</code> manipulator extracts whitespace characters until either a non-whitespace character or the end of the stream is reached.</p>

<p>Note that <code>std::istream::get()</code> actually <em>does</em> work as it should! It just reads the next character. It just happens not to do what you did expect.</p>
",2
21032548,21032491,0,"<p>Add a cin >> code line instead of the two cin.get(). If the program just closes anyway, then this would probably be the simplest thing to do. </p>
",0
21039852,21039626,0,"<p>You have uninitialized pointers in your code! They will most probabely point to invalid memory, where you cannot write to, causing the Segmentation Faults.</p>

<p>The variables of concern are <code>p</code> and <code>rnd</code>:</p>

<pre><code>long *p;     // p is not initialized, pointing to invalid memory
*p = 67563;  // Writing to invalid memory =&gt; SEGFAULT
</code></pre>

<p>Try this instead:</p>

<pre><code>int i;
void *buf;

long p;    // NO POINTER!
p=67563;

buf=&amp;p;   // Let buf point to where p is (valid address on stack)
RAND_seed(buf,9);

BIGNUM rnd;  // NO POINTER!
i= BN_rand( &amp;rnd, 128,0,0);  // Pass pointer to rnd to BN_rand

BN_bn2hex(&amp;rnd); // Pass pointer to rnd to BN_bn2hex
</code></pre>
",0
23581852,23581809,2,"<p>This record</p>

<pre><code>int &amp;[]
</code></pre>

<p>denotes an array of references that is forbided in C++.</p>

<p>Declare the function the following way</p>

<p>void input( int ( &amp; )[2] );</p>

<p>Also you are using invalid range of indeces. The valid range is [0, 1]. So the function will look as</p>

<pre><code>void input( int ( &amp;a )[2] );
{
   for ( size_t i = 0; i &lt; 2; i++ ) std::cin &gt;&gt; a[i]; 
}
</code></pre>

<p>Also you could define the function the following way</p>

<pre><code>void input( int a[], size_t n );
{
   for ( size_t i = 0; i &lt; n; i++ ) std::cin &gt;&gt; a[i]; 
}
</code></pre>

<p>and call it as</p>

<pre><code>input( a, 2 );
</code></pre>
",0
23581854,23581809,1,"<p>The syntax for returning and taking array references is:</p>

<pre><code>template&lt;typename T, size_t N&gt;
T(&amp;do_nothing(T(&amp;arg)[N]))[N]
{
    return arg;
}
</code></pre>

<p>Or, more simply with a templated type alias:</p>

<pre><code>template&lt;typename T, size_t N&gt; using arrayref = T(&amp;)[N];

template&lt;typename T, size_t N&gt;
arrayref&lt;T, N&gt; do_nothing(arrayref&lt;T, N&gt; arg)
{
    return arg;
}
</code></pre>

<p>When you have defined the previous type alias template, it becomes very simple to work with array references, e.g. This is how you would declare a function that takes a reference to an array of two integers:</p>

<pre><code>void give_me_two_ints(arrayref&lt;int, 2&gt; two_ints);
</code></pre>

<p>To be used like:</p>

<pre><code>int a[] = {1,2,3};
for(auto const&amp; i : do_nothing(a)) std::cout &lt;&lt; i &lt;&lt; ""\n"";
</code></pre>
",0
23581868,23581809,2,"<p>It should be:</p>

<pre><code>void input(int (&amp;a)[2]);
</code></pre>

<p>or simply</p>

<pre><code>void input(int (&amp;)[2]);
</code></pre>

<p>But in function definition, you need also to give the array name:</p>

<pre><code>void input(int (&amp;a)[2]) {...}
</code></pre>

<p>You need to use <code>(&amp;array)</code> to clarify to the compiler that you want a reference to an array, rather than the (invalid) array of references <code>int &amp;array[2];</code>. </p>

<p>And call it like this:</p>

<pre><code>input(a);
</code></pre>
",0
23584923,23584797,0,"<p>Not a direct answer to your question, but this is very wrong:</p>

<pre><code>Number(int *a, int i):
    arr(a),n(i){}

virtual ~Number(){ delete [] arr;
    cout&lt;&lt;""In Number destructor""&lt;&lt;endl;
}
</code></pre>

<p>You are not setting <code>arr</code> to point to dynamically allocated memory, so don't expect <code>delete[] arr</code> to work correctly when called from the destructor. In fact, it will most likely invoke a memory access violation which will abruptly terminate the program (second thought, maybe it is a direct answer to your question after all).</p>
",0
23584935,23584797,0,"<p>Virtual destructor is a red herring, and in fact the base class destructor <em>is</em> being called, which is why you are seeing an error. Note that the point of virtual destructors is to make sure a <em>derived</em> class destructor will be called when you delete a derived object through a base class pointer.</p>

<p>What's happening is that you are passing <code>array</code>, a pointer to an array on the stack, to the <code>Number</code> constructor, which stores it and then happily attempts to delete it (twice, even!) when its destructor is called. A stack array does not need to, and should never, be <code>delete</code>d, let alone twice.</p>
",0
23584941,23584797,0,"<p>Your base class destructor does get called. But it core dumps at:</p>

<p><code>delete [] arr;</code></p>

<p>and that's because you are trying to delete the <code>array</code> memory which is allocated on stack and not on heap.</p>

<p>Your program has many other issue though.</p>
",1
25704369,25704347,0,"<p>You don't have to return a const reference, you can return a const object.</p>

<pre><code>const Object function_name() {
// ...
}
</code></pre>
",4
25705166,25704347,0,"<p>You don't modify returned value, you modify it's copy. In this code, you can't do <code>genObjA()._x=10;</code>.</p>

<p>To reach your goal, you can write extra class:</p>

<pre><code>class A_const{
protected:
    int _x;  
    int _y;
    operator=(const A_base&amp;)=default;
public: 
    A()=default;
    A(const A_base&amp;)=default;
    A( int x, int y): _x(x), _y(y) {};
    int x(){return _x;}
    int y(){return _y;}
    //or
    int get_x(){return _x;}
    int get_y(){return _y;}
};

class A {  
public:
    using A_const::A_const;
    A(const A&amp;)=default;
    int&amp; x(){return _x;}
    int&amp; y(){return _y;}
    //or
    int&amp; set_x(int val){return _x=val;}
    int&amp; set_y(int val){return _y=val;}
};

const A_const genObjA_const(){
    return A_const(0, 0);
}
</code></pre>
",2
25705361,25704347,0,"<p>If you want a fool-proof modification safeguard, you can use the <a href=""http://en.wikipedia.org/wiki/Private_class_data_pattern"" rel=""nofollow"">PIMPL</a> idiom.</p>

<p>However, if you have reasonable faith in the sanity of your coleagues who work with your class, just use a const-reference. If you want to be sure, document the reason <em>why</em> you don't want the object to be modified, so that your fellows can follow your thoughts (and come to the same conclusion). The PIMPL idiom tries to save you from the determined fools. But determined fools will even work around PIMPL, so there's little point in messing up your code in the attempt.</p>
",0
25708052,25708037,3,"<p>The <code>push</code> expects (and accepts) parameter of type <code>X</code>, while you are passing something else (a pair).</p>
",0
25708110,25708037,4,"<p>The class has to be comparable and must respond to operators like &lt; and > so that the queue can sort them:</p>

<pre><code>class X {
    public:
    unordered_map&lt;string, double&gt; distance;
    unordered_map&lt;string, string&gt; vertices;
    int priority;
    bool operator&lt; (const X&amp; b) {
        return priority &lt; b.priority;
    }
    bool operator&gt; (const X&amp; b) {
        return priority &gt; b.priority;
    }
};

void make(std::string source) {
    priority_queue&lt;X, vector&lt;X&gt;, greater&lt;void&gt;&gt; pq;

    X element;
    element.distance[source] = 0;
    element.priority = 100;
    pq.push(element);
}
</code></pre>
",1
25524111,25516153,0,"<p>There are a lot of basic errors in ur code..
Like dis one..</p>

<pre><code>    cout &lt;&lt; ""Wage of Person1 is "" &lt;&lt; Person1.GetWage &lt;&lt; ""\n"";
</code></pre>

<p>It should actually be</p>

<pre><code>    cout &lt;&lt; ""Wage of Person1 is "" &lt;&lt; Person1.GetWage() &lt;&lt; ""\n"";
</code></pre>

<p>Define ur constructor, you have just declared it.
Just a work around ur messed up code.</p>

<p>worker.h</p>

<pre><code>    #include&lt;iostream&gt;
    using namespace std;

    class Worker {

    public:

        double Wage;
        std::string   SSN;

        Worker(double wage, std::string ssn){
            Wage = wage;
            SSN = ssn;
        }

        double GetWage(){
            return Wage;
        }

        std::string GetSSN(){
           return SSN;
        }
 };
</code></pre>

<p>And Main.cpp</p>

<pre><code>    #include ""worker.h""
    #include &lt;iostream&gt;
    using namespace std;

    int main(){
       Worker Person1(5000, ""111111111"");
       cout &lt;&lt; ""Wage of Person1 is "" &lt;&lt; Person1.GetWage() &lt;&lt; ""\n"";
       cout &lt;&lt; ""SSN of Person1 is "" &lt;&lt; Person1.GetSSN() &lt;&lt; ""\n"";
       return 0;
    }
</code></pre>

<p>Remove syntactical errors in your code before posting it!
And as the others have stated..Just write</p>

<pre><code>    Worker Person1(5000, ""111.11.1111"");
</code></pre>

<p>instead of </p>

<pre><code>    Worker Person1(5000, ""111111111"");
</code></pre>
",2
23072197,23071247,0,"<p>Change double <code>while</code> loop in your code with the following piece of code:</p>

<pre><code>    while(getline(fileStream, line, '\n')) {
        std::stringstream ss(line);
        std::vector&lt;int&gt; numbers;
        std::string in_line;
        while(getline (ss, in_line, ',')) {
          numbers.push_back(std::stoi(in_line, 0));
        }
        matrix.push_back(numbers);
    }
</code></pre>

<p><strong>Reason of Failure:</strong> You are messing things up with the parsing of the <code>ss</code> stream, you need to introduce delimiters.</p>

<p>However, I wouldn't recommend such kind of parsing. <strong>C++11 supports <a href=""http://www.cplusplus.com/reference/regex/"" rel=""nofollow"">regular expressions</a></strong> that make parsing smooth sailing.</p>
",0
23092267,23092134,2,"<p>You have to change the initial value of your iteration variable i in you for statement to the following one:</p>

<pre><code>for(i=0;i&lt;=n;i++)
</code></pre>
",7
23092302,23092134,1,"<p>Consider using std::getline.</p>

<pre><code>std::string name;
std::getline(std::cin, name);
</code></pre>

<p>The above example is summarized from:
<a href=""https://stackoverflow.com/questions/5838711/c-cin-input-with-spaces"">std::cin input with spaces?</a></p>
",2
23092396,23092134,0,"<p>Instead of <code>operator &gt;&gt;</code> you should use function <code>std::getline</code>. For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

int main()
{
   int n;

   std::cin &gt;&gt; n;

   std::cin.ignore( std::numeric_limits&lt;std::streamsize&gt;::max() );
   // or simply std::cin.ignore();

   for ( int i = 1; i &lt;= n; i++ )
   {
      std::string p;
      std::getline( std::cin, p );
      std::cout &lt;&lt; p &lt;&lt; ""\n"";
   }

   return 0;
}
</code></pre>
",0
23113702,23113648,1,"<p>You are not counting the 6 carriage return characters and one tab (which adds up to the 7 chars you are missing), but <code>tellg()</code> does.</p>
",3
22423005,22422984,5,"<p>No. If you don't want a parent destructor to be called, don't use inheritance.</p>
",3
22423229,22422984,2,"<p>This is a dirty hack, but it is effective in your situation:<br>
You can simply do the calls to <code>destroy()</code> in the destructor of a derived class, <em>and set the variables <code>m_L</code> and <code>m_R</code> to zero</em> before returning from your destructor. <code>delete</code> is defined to do nothing if passed a null pointer, so, you have effectively deactivated the code within the base class destructor.</p>

<pre><code>struct TB : TA {
  ~TB() {
    if (m_L) ((TB*)m_L)-&gt;destroy();
    if (m_R) ((TB*)m_R)-&gt;destroy();
    m_L = m_R = 0;
  }
  void destroy() {
    if (!--nReference) delete this;
  }
  int nReference;
};
</code></pre>
",3
26786206,26786124,-1,"<p>Type cast the code before you were comparing the signed and unsigned code to avoid warning</p>

<pre><code>int a;
unsigned int b;

if(a==b) gives warning

if(a == (int)b)
</code></pre>

<p>will resolve your issue</p>

<h2>EDIT</h2>

<p>Blind casting will lead to some unexpected results</p>

<p>The warning is because ranges for signed and unsigned are different.</p>

<p>Casting will work fine when signed integer you were used for comparison was greater than zero.</p>

<p>so have check whether the signed integer is greater that zero before comparing</p>

<p>More info <a href=""https://stackoverflow.com/questions/3660901/a-warning-comparison-between-signed-and-unsigned-integer-expressions"">here</a></p>
",4
26786221,26786124,2,"<p>The compiler warns that the code contains comparison of <code>unsigned int</code> with a <code>signed int</code> in the line</p>

<pre><code>while (numberFound &lt; b);
</code></pre>

<p>This has nothing to do with makefiles or make.</p>

<p>You can fix that by changing</p>

<pre><code>int b=50;
</code></pre>

<p>to</p>

<pre><code>unsigned b = 50;
</code></pre>

<p>or by changing</p>

<pre><code>unsigned numberFound = 0;
</code></pre>

<p>to </p>

<pre><code>int numberFound = 0;
</code></pre>

<p>The problems you might run into when comparing <code>signed int</code> and <code>unsigned int</code> are explained in <a href=""https://stackoverflow.com/a/5416498/434551"">this answer to another SO question</a></p>
",2
26786232,26786124,0,"<p>At this line</p>

<p><code>while (numberFound &lt; b);</code></p>

<p>The first is an <code>unsigned int</code> and the second an <code>int</code>. So you have to make them the same type, or if you are completely sure cast one of them.</p>

<p>As Etan commented:</p>

<p>""Blindly casting away a warning just to avoid the warning is a mistake. You need to understand what the warning is telling you and decide what the right fix is.""</p>
",0
26786237,26786124,0,"<p>You are getting this warning about comparing signed and unsigned types because the ranges of signed and unsigned ints are different.
If you have to make such a comparison, you should explicitly cast one of the values to be compatible with the other, but a check is required to make sure value your cast is valid.</p>

<p>For e.g:-</p>

<pre><code>int i = someIntValue();

if (i &gt;= 0)
{
    // i is non-negative, so it is safe to compare to unsigned value
    if ((unsigned)i &gt;= u)
        // do something
}
</code></pre>
",0
26786278,26786124,0,"<p>It says you are comparing two different things. Most notably the range of one does not fit into the range of another.</p>

<p>I.e there. Exists a number in the unsigned range that cannot be expressed as a signed number</p>
",0
22504526,22504354,2,"<p>Most likely you failed to add <code>msoftcon.c</code> and the associated .h to your project. Merely unpacking it in your project directly is not enough. It needs to be actually added to the project, after which it will be compiled and linked with the other files, hopefully eliminating the error you are seeing.</p>

<p>Exactly how that is done depends on your setup (IDE etc.).</p>
",2
22493425,22493379,-1,"<p>X = rand()%(upper-lower+1) + lower</p>

<p>In your case : x = rand()%51 + 50</p>
",0
22493432,22493379,1,"<pre><code>int x;
x=50+(2*(rand()%(26)));
</code></pre>
",1
22493435,22493379,3,"<p>Your computation is wrong, you ask for 2 times a number between 50 and 100.</p>

<p>Go with</p>

<pre><code>x = 2 * ( rand() % 25 ) + 50
</code></pre>
",2
26421163,26421063,0,"<p>Your for loop should be like this. You are not printing the power when the coefficient is 1 or -1:</p>

<pre><code>for(int i=1;i&lt;coefficient.size();i++)
{

    if(coefficient[i]==-1234)
        break;


    if(coefficient[i]==0)
    {
        k++;
    }
    else if(coefficient[i]==1)
    {
        if(coefficient[i]&gt;=1)
            cout&lt;&lt;plus;
        cout&lt;&lt;""x"";
        k++;
        if(k&gt;1)
        {
            cout&lt;&lt;""^""&lt;&lt;k;
        }

    }
    else if(coefficient[i]==-1)
    {
        if(coefficient[i]&gt;=1)
            cout&lt;&lt;plus;
        cout&lt;&lt;""-x"";
        k++;
        if(k&gt;1)
        {
            cout&lt;&lt;""^""&lt;&lt;k;
        }

    }
    else
    {
        if(coefficient[i]&gt;=1)
            cout&lt;&lt;plus;
        cout&lt;&lt;coefficient[i]&lt;&lt;""x"";
        if(coefficient[i]!=-1234)
        {
           k++;
        }
        else
            break;
        if(k&gt;1)
        {
            cout&lt;&lt;""^""&lt;&lt;k;
        }
    }
}
</code></pre>
",0
26421186,26421063,0,"<p>The problem is that you're entering for the last <code>1</code> this block:</p>

<pre><code>    else if (coefficient[i] == 1)
    {
        if (coefficient[i] &gt;= 1)
            cout &lt;&lt; plus;
        cout &lt;&lt; ""x"";
        k++;
    }
</code></pre>

<p>spoiling the <code>x^power</code> part.</p>

<p>A possible solution could be:</p>

<pre><code>void print()
{
    string plus;
    plus = ""+"";
    int k = 0;
    if (coefficient[0] != 0)
        cout &lt;&lt; coefficient[0];

    for (int i = 1; i&lt;coefficient.size(); i++)
    {

        if (coefficient[i] == -1234)
            break;


        if (coefficient[i] == 0)
        {
            k++;
        }
        else if (coefficient[i] == 1 &amp;&amp; i == 1 /* This prevents entering here afterwards */)
        {
            if (coefficient[i] &gt;= 1)
                cout &lt;&lt; plus;
            cout &lt;&lt; ""x"";
            k++;
        }
        else if (coefficient[i] == -1 &amp;&amp; i == 1 /* This prevents entering here afterwards */)
        {
            if (coefficient[i] &gt;= 1)
                cout &lt;&lt; plus;
            cout &lt;&lt; ""-x"";
            k++;
        }
        else
        {
            if (coefficient[i] &gt;= 1)
                cout &lt;&lt; plus;
            cout &lt;&lt; coefficient[i] &lt;&lt; ""x"";
            if (coefficient[i] != -1234)
            {
                k++;
            }
            else
                break;
            if (k&gt;1)
            {
                cout &lt;&lt; ""^"" &lt;&lt; k;
            }
        }
    }

    cout &lt;&lt; endl;
}
</code></pre>

<p>it really boils down to how you're comfortable at printing and formatting the polynomial.</p>
",0
26422178,26421063,0,"<p>Following may help:</p>

<pre><code>void print_polynom(const std::vector&lt;int&gt;&amp; coeffs)
{
    const char* plus = """";
    const char* space = """";

    for (std::size_t i = 0; i != coeffs.size(); ++i) {
        if (coeffs[i] == 0) {
            continue;
        }
        if (coeffs[i] &gt; 0) {
            std::cout &lt;&lt; space &lt;&lt; plus &lt;&lt; space;
        } else {
            std::cout &lt;&lt; space &lt;&lt; ""-"" &lt;&lt; space;
        }
        plus = ""+"";
        space = "" "";
        if (i == 0 || std::abs(coeffs[i]) != 1) { // to avoid to print 1x^k
            std::cout &lt;&lt; std::abs(coeffs[i]);
        }
        if (i == 0) {
            continue;
        }
        std::cout &lt;&lt; ""x"";
        if (i == 1) { // not print x^1
            continue;
        }
        std::cout &lt;&lt; ""^"" &lt;&lt; i;
    }
    std::cout &lt;&lt; std::endl;
}
</code></pre>

<p><a href=""https://ideone.com/KKd4Dh"" rel=""nofollow"">Live example</a></p>
",0
31193498,31193454,20,"<p>This line:</p>

<pre><code>m_pchString[m_nLength-1] = '';
</code></pre>

<p>What you probably mean is:</p>

<pre><code>m_pchString[m_nLength-1] = '\0';
</code></pre>

<p>Or even:</p>

<pre><code>m_pchString[m_nLength-1] = 0;
</code></pre>

<p>Strings are zero terminated, which is written as a plain <code>0</code> or the null character <code>'\0'</code>. For double quote strings <code>""""</code> the zero termintation character is implicitly added to the end, but since you explicitly set a single character you must specify which.</p>
",9
31193499,31193454,1,"<p>what do you think about null-terminated string? Yes, you are right, such strings must be terminated with null:</p>

<p>m_pchString[m_nLength-1] = 0;</p>
",1
31194039,31193454,1,"<p>You've said that you <em>""get an error stating that strncpy is unsafe to use if i use the null terminator,""</em> but you use <code>strlen</code>, which simply <strong>does not work</strong> if the string isn't null terminated. From <a href=""http://www.cplusplus.com/reference/cstring/strlen/"" rel=""nofollow"">cplusplus</a>:</p>

<blockquote>
  <p>The length of a C string is determined by the terminating null-character</p>
</blockquote>

<p>My suggestion to you would be to use null or 0 like others are suggesting and then just use <code>strcpy</code> instead of <code>strncpy</code> as you copy the whole string every time anyways.</p>
",0
23586515,23586491,0,"<p>You're adding <a href=""http://en.wikipedia.org/wiki/Windows_Forms"" rel=""nofollow"">Windows Forms</a> (which are forms for C# or VB.NET) to a C++ project.</p>

<p>This is not gonna work: C++ is an unmanaged language while you're adding a form for a managed language.</p>

<p>Put it simply: Windows Forms are usable if you choose ""C#"" or ""Visual Basic .NET"" as a VS project.</p>
",4
23586656,23586491,0,"<p>In addition to the ""Forms"" problem, setting /SUBSYSTEM:WINDOWS means your program is required to have a winmain entry point, not main. That is probably the reason for the error. (You did not show us the complete error message.)</p>

<p>To use Forms change languages to C#. To build a GUI in C++ you can use a Win32 app, or MFC, or ATL, or Qt.</p>
",4
23587254,23586491,0,"<p>Well the entry point should be </p>

<pre><code>int CALLBACK WinMain(
  _In_  HINSTANCE hInstance,
  _In_  HINSTANCE hPrevInstance,
  _In_  LPSTR lpCmdLine,
  _In_  int nCmdShow
);
</code></pre>

<p>and not the usual ""main"". There is good reason for that and you can read about it here: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms633559%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/ms633559(v=vs.85).aspx</a></p>
",7
22892411,22892323,1,"<p>You'll have to change the type of <code>temp</code> to <code>std::string</code>. <code>int</code> will only work with integer numbers for obvious reasons.</p>

<p>If you encounter such compiler errors, always try to understand the error message first. Why would the program try to convert a string to an integer?</p>

<p>Then, look at the mentioned line (first number after the file name). Keep in mind that this number might be off in case you're using preprocessor macros.</p>

<p>If you go to that line, you'll notice that it's the following:</p>

<pre><code>temp = arr[j];
</code></pre>

<p>Going back to the error message, it's pretty obvious that in this line you're trying to assign a string value to an integer:</p>

<pre><code>integer = string;
</code></pre>

<p>Since you want strings, you'll have to see where <code>temp</code> is defined. Going up you'll hit the following line:</p>

<pre><code>int temp;
</code></pre>

<p>Bingo! Since you know you'll need a string (and the variable isn't used anywhere else), you can now just swap the type to <code>std::string</code> and you're done:</p>

<pre><code>string temp;
</code></pre>
",2
22892468,22892323,1,"<ol>
<li><p><strong>Don't use raw arrays.</strong> Use <code>std::vector&lt;std::string&gt;</code>. Then the strange magic-number limitation of 20 will go away, too.</p></li>
<li><p>I think using a class just complicates things here. Use free-standing functions and pass <code>std::vector&lt;std::string&gt; &amp;</code> as an argument.</p></li>
<li><p>Mind that C++ already provides sorting. See <a href=""http://en.cppreference.com/w/cpp/algorithm/sort"" rel=""nofollow""><code>std::sort</code></a> and related sorting functions and see if they fit your needs.</p></li>
<li><p>In C++, you don't initialize variables and set their starting value later (as is the case with your <code>int temp</code>). It's one pass: <code>int temp = /* starting value */;</code>. However, note that the statement is wrong anyway, because you are trying to set a string to an int.</p></li>
</ol>

<p>Here's a hint how you may change your sort function, based on what you already have:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

void bubblesort(std::vector&lt;std::string&gt; &amp;strings)
{
    typedef std::vector&lt;std::string&gt;::size_type size_type;
    for (size_type i = 1; i &lt; strings.size(); ++i) // for n-1 passes
    {
        // In pass i,compare the first n-i elements
        // with their next elements
        for (size_type j = 0; j &lt; (strings.size() - 1); ++j)
        {
            if(strings[j] &gt; strings[j+1])
            {
                std::string const temp = strings[j];
                strings[j] = strings[j + 1];
                strings[j+1] = temp;
            }
        }
    }
}

int main()
{
    std::vector&lt;std::string&gt; strings;
    strings.push_back(""foo"");
    strings.push_back(""bar"");
    strings.push_back(""foobar"");

    bubblesort(strings);

    for (std::vector&lt;std::string&gt;::const_iterator iter = strings.begin(); iter != strings.end(); ++iter)
    {
        std::cout &lt;&lt; *iter &lt;&lt; ""\n"";
    }
}
</code></pre>
",0
23301806,23301761,2,"<p>Put a conditional in the function checking for certain properties of the objects, e.g. the value of an instance variable.</p>
",0
23301905,23301761,2,"<p>You could have a <em>function object (functor)</em> or a function pointer as a data member.<br>
Each instance would supply a different functor for the click.</p>
",0
23301926,23301761,1,"<p>One way is going to be to create an interface(for C++ that is a class with pure virtual methods and a virtual destructor).  Lets call that class clickHandler to go with your button example.  In the click function you call <code>doclick</code> on the clickHandler the button has been given.  Now when you create your buttons you give them a subclass of clickHandler that does the right thing.</p>

<p>Other options include using C++'s newly added lambdas.</p>
",0
23301960,23301761,0,"<p>Frankly this sounds like bad design. Pretty much the only way to do this is to pass along flags or state in some other form to the method. But if you're doing that the Button  already has all knowledge about what needs to be done and you might as well create and call separate methods. Alternatively you can give up on your requirement of having the Objects be of the same class and use inheritance with virtual methods. However if different subclasses  have vastly differing semantics for those that might be a sign of bad design as well. So I'd recommend using different methods and explicitly calling them.</p>
",1
23301983,23301761,3,"<p>I'll assume, that you are building your own game engine not using a library that actualy handles these things.</p>

<p>What you want to do is register a callback for each function. That is what all the UI libraries/frameworks do. In a simple example:</p>

<pre><code>class Button{
std::function&lt;void()&gt; callback;

public:

void connect(std::function&lt;void()&gt; func){
   callback=func
}
void click(){
  callback();
}
};
</code></pre>

<p>By supplying different callbacks to connect, you can achieve different functionality.</p>
",1
23301995,23301761,2,"<p>I think what you are looking for is called polymorphism. Check out the code:</p>

<pre><code>    #include &lt;iostream&gt;
    using namespace std;
    class Button
    {
    public:
            virtual void click()
            {
                    cout &lt;&lt; ""Button click\n"";
            }
    };

    class StartButton : public Button
    {
    public:
            void click()
            {
                    cout &lt;&lt; ""Start click\n"";
            }
    };

    class EndButton : public Button
    {
    public:
            void click()
            {
                    cout &lt;&lt; ""End click\n"";
            }
    };

    void make_click (Button * button)
    {
            button -&gt; click();
    }

    int main ()
    {
            StartButton * start = new StartButton();
            EndButton * end = new EndButton();
            make_click(start);
            make_click(end);
            return 0;
    }
</code></pre>

<p>The output is:</p>

<pre><code>    Start click
    End click
</code></pre>

<p><a href=""http://www.cplusplus.com/doc/tutorial/polymorphism/"" rel=""nofollow"">Here</a> you can find a nice tutorial.</p>
",0
23074465,23074438,0,"<p>try like this</p>

<pre><code>int a=0;
for (int i=1; i&lt;=10; i++)
{
    a+=i;   //First add all the numbers (1 to 10)
}
cout&lt;&lt;a;    //show the result
</code></pre>
",2
23074472,23074438,0,"<p>try this,</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;conio.h&gt;

using namespace std;

int main()
{
    int a,sum=0;
    for(a=1; a&lt;=10; a++)
    {
        cout&lt;&lt;a&lt;&lt;endl;
        sum=sum+a;
    }
    cout&lt;&lt;sum;
    getch();
}
</code></pre>
",0
23074474,23074438,0,"<p>If this is what you want..  </p>

<pre><code>int main()
{
    int myNum, answer=0;
    cin &gt;&gt; myNum;

    for (int x=1; x&lt;=myNum; x++)
    {

        answer += x;
    }
    cout &lt;&lt; ""Sum of 1 to "" &lt;&lt; myNum &lt;&lt; "" = "" &lt;&lt; answer &lt;&lt; endl; 
}
</code></pre>

<p><strong>Input:</strong> <code>10</code></p>

<p><strong>Output:</strong> <code>Sum of 1 to 10 = 55</code></p>
",1
23074477,23074438,0,"<pre><code>#include &lt;iostream&gt;

int main()
{
    int i = 2;
    int sum = 1;
    std::cout &lt;&lt; sum;
    while (i &lt;= 10)
    {
        std::cout &lt;&lt; "" + "" &lt;&lt; i;
        sum += i;
        i++;
    }
    std::cout &lt;&lt;  "" = "" &lt;&lt; sum &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",0
23074479,23074438,0,"<pre><code>int main()
{
    int total = 0;
    for (int a = 1; a &lt;= 10; ++a)
    {
        std::cout &lt;&lt; a &lt;&lt; '\n';
        total += a;
    }
    std::cout &lt;&lt; total &lt;&lt; '\n';
    getch();
}
</code></pre>
",0
23074485,23074438,0,"<p>Try this one</p>

<pre><code>int n=10;
int sum=0;
sum=(n*(n+1))/2;
cout&lt;&lt;sum;
</code></pre>

<p>or</p>

<pre><code>int a=0;
for(int i=0;i&lt;10;i++)
{
a=a+i;
}
cout&lt;&lt;a;
</code></pre>

<p>Or you cant try this</p>

<pre><code>void main()
{
   cout&lt;&lt;Fun(10);
}
int Fun(int a)
{
   if(a==0)
    return a;
   a+=fun(a-1);
}
</code></pre>
",0
22434955,22434918,0,"<p>link problem : ld can't find a definition of hdr_rtp_v2::access::Packet(Packet const*) and  hdr_rtcp_v2::access::Packet(Packet const*), Constructors of Packet I guess.</p>

<p>This means you have not defined these functions</p>

<p>Or you forgot to link a lib</p>

<p>Or you are trying to link with ld a lib built with VC which use another name mangling causing this problem</p>
",7
22435254,22435155,0,"<pre><code>if(total &lt;=21)
{
    cout &lt;&lt; ""Your Total Score is: "" &lt;&lt; total&lt;&lt;endl;
}
</code></pre>

<p>You have this on both lines so your other desired condition isn't being met.
Just change the second iteration of it to : </p>

<pre><code>if(total &gt; 21)
{
    cout &lt;&lt; ""Your Total Score is: "" &lt;&lt; total&lt;&lt;endl;
}
</code></pre>
",1
22435277,22435155,0,"<p>Fix your indentation, it makes the problem more apparent.</p>

<p>When you are entering the ace processing code in the first else block, the third else block won't be executed. So the score is only printed if it is &lt;= 21. You should do the printing stuff after processing the aces, these two blocks should be indepedent of each other.</p>

<p>Untested, but the code should look something like:</p>

<pre><code>  if(aceCount &gt; 0 &amp;&amp; total &gt; 21)
  {
     do
     {
        total-=10;
        aceCount--;
     }while (aceCount &gt; 0 &amp;&amp; total &gt;21);
  }

  if(total &lt;=21)
        cout &lt;&lt; ""Your Total Score is: "" &lt;&lt; total&lt;&lt;endl;
  }
  else if(total &gt; 21)
  {
        cout &lt;&lt; ""Your Total Score is: "" &lt;&lt; total&lt;&lt; "" Which Means You Busted!\n"";
  }
</code></pre>
",1
22437954,22437920,3,"<blockquote>
  <p>Why does the function return non-const object Integer if type of function is const Integer?</p>
</blockquote>

<p>It <em>does</em> return a constant <code>Integer</code>, that is a <em>copy</em> of the <code>Integer</code> rvalue inside the function body. Also notice that you probably meant to say <code>right.i</code> instead of <code>left.right</code>, <code>operator+</code> instead of <code>opeator+</code> and <code>left.i</code> instead of <code>letf.i</code>.</p>
",0
22437968,22437920,3,"<p>The function is returning a copy of the <code>Integer</code> specified in the <code>return</code> statement.  It doesn't matter if the value is <code>const</code> or not, since it is being copied into a <code>const Integer</code>.</p>

<p>It is similar to this:</p>

<pre><code>const Integer result = Integer(5);
</code></pre>

<p>The <code>Integer</code> on the right side doesn't need to be const, since its value is being copied into <code>result</code>.</p>
",3
23110624,23108939,1,"<p>You're much better off reading the whole file into a buffer in one thread, processing the buffer in parallel without using ordered, and then writing the buffer in one thread.  Something like this </p>

<pre><code>fread(Store,sizeof(char),icount,Rfile);// read
#pragma omp parallel for schedule(static)
for( i=0;i&lt;i_count;i+=16) {
     ENCRYPT(&amp;Store[i]);  //ENCRYPT acts on 16 bytes at a time    
}
fwrite(Store,sizeof(char),icount,Wfile) // write
</code></pre>

<p>If the file is too big to read in all at once then do it in chunks in a loop.  The main point is that the ENCRYPT function should be much slower than reading writing files.  Otherwise, there is no point in using multiple threads anyway because you can't really speed up reading writing files with multiple threads.</p>
",1
23575814,23575739,0,"<p>In this line:</p>

<pre><code>int *numlines = new int[filename.size()];
</code></pre>

<p>you never initialize the values, so they start off as garbage. To explain your results, probably what happened is that the first two entries had large garbage values and the later entries had <code>0</code> by chance.</p>

<p>To fix this you could write: </p>

<pre><code>int *numlines = new int[filename.size()]();
</code></pre>

<p>or you could set <code>numlines[i]</code> to <code>0</code> before using it.</p>

<p>However I would strongly consider getting rid of all those arrays (that's crazy, TBH). Just declare one of each thing inside your <code>i</code> loop.</p>
",0
28480024,28479888,13,"<p>Initialize your variables and you will see what is happening.  It isn't ignore the decimal.  It is causing an error that stops the parsing.  So the crazy number you see is actually the value of the uninitialized integer.</p>

<p>Here is what is happening:
When you type ""10 2.5"" it puts 10 into a, and 2 into b.  It does not ignore th e 0.5.  To understand what actually happens, try this code:</p>

<pre><code>int a=100 , b=200 , c=300, sum;
cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
cout&lt;&lt;a&lt;&lt;endl;
cout&lt;&lt;b&lt;&lt;endl;
cout&lt;&lt;c&lt;&lt;endl;
</code></pre>

<p>Then enter in ""10 2.5"" and a will be 10, b will be 2, and c will be 300!  The "".5"" caused cin to get an error, and so it just left c at the default value.  But since you only read 2 values, it seemed to work just fine.  So try that version with your second set of inputs ""2.5 10"".  A will be 2, then b will be 200 and c will be 300.  That shows how cin encountered an error when it saw the decimal point, and just gave up.  </p>

<p>And finally for fun, remove the initializations in my example, and watch how you get crazy values for b and c.</p>
",4
28480418,28479888,1,"<p>Quote from <a href=""http://www.cplusplus.com/reference/istream/istream/operator%3E%3E/"" rel=""nofollow"">std::istream::operator>></a>:""Extracts and parses characters sequentially from the stream to interpret them as the representation of a value of the proper type, which is stored as the value of val."" </p>

<p>Check the <a href=""http://www.cplusplus.com/reference/istream/istream/operator%3E%3E/"" rel=""nofollow"">std::istream::operator>></a> for an in depth look at how reading the input works.</p>

<p>Moreover, you could std::cout &lt;&lt; std::cin.rdstate(); after reading a double value into an int, to see that the cin object gets into an error state at such an operation. The answer I think, is that cin >> operation does not do implicit type conversions, and is thrown into an error state.</p>
",1
22444032,22443587,1,"<p>The code below is the code provided in the question as I write this, except I've added the requisite headers and <code>using</code> directive at the top:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int input = 0;

    do
    {
        cout&lt;&lt;""Enter a number (-1 = QUIT):"";

        if (!(cin&gt;&gt; input))
        {
            cout&lt;&lt;""INVALID"" &lt;&lt;endl;
            cin.clear();
            cin.ignore(10000, '\n');
        }

        if (input != -1)
        {
            cout&lt;&lt;input&lt;&lt;"" was entered""&lt;&lt;endl;
        }
    }
    while (input != -1);
    cout&lt;&lt;""Done""&lt;&lt;endl;
    cin.get();

    return 0;
}
</code></pre>

<hr>

<pre><code>#include &lt;iostream&gt;
</code></pre>

<p>is a <strong>preprocessor directive</strong>. The source code preprocessor is run before the compiler proper, and performs text substitution, text inclusion and text selection. The <code>#include</code> directs it to include all the text from a <strong>header</strong> called <code>iostream</code>. The angle brackets, as opposed to double-quote characters, says that it shouldn't bother to search in the including file's directory. Well actually it's unspecified what extra search it shouldn't do, but in practice, with current compilers, it's as described.</p>

<p>The <code>iostream</code> header provides declarations of i/o stuff from the standard library, such as <code>std::cout</code>.</p>

<hr>

<pre><code>using namespace std;
</code></pre>

<p>makes the identifiers from the <code>std</code> <strong>namespace</strong> available directly in the global namespace. Meaning you can write, for example, just <code>cout</code> instead of qualified <code>std::cout</code> or fully qualified <code>::std::cout</code>.</p>

<p>A <code>using namespace</code> directive is practical for small exploratory and personal tool programs, but can be more troublesome in larger code base.</p>

<p>Anyway, remember to <strong>NEVER</strong> put such directive in the global namespace in a header, because that's a sure way to create name collisions in code that includes that header. As an example, the standard library defines a name <code>std::distance</code>. Without the qualification, with a <code>using namespace std;</code> directive, the name <code>distance</code> is <em>very</em> likely to collide with a name <code>distance</code> in using code.</p>

<hr>

<pre><code>int main()
</code></pre>

<p>is the minimal declaration of <code>main</code>. The <code>main</code> function was the user-provided startup function in C, and in C++ it serves roughly the same purpose, except that in C++ dynamic initialization of static variables can happen before <code>main</code> is executed.</p>

<p>The declaration above is the C++03 way. In C++11 it can alternatively be declared as</p>

<pre><code>auto main() -&gt; int
</code></pre>

<p>which means exactly the same, and which is a bit more verbose, but can be reasonable to indicate a convention of using this syntax in general. I.e. for consistency.</p>

<p>The <code>main</code> function can also have arguments, which then represent the command line arguments provided to the process, but this scheme only works well in UTF-8 based *nix-es. For the <code>main</code> arguments are <code>char</code>-based, and the default <code>char</code>-based text encoding in Windows is such that e.g. filenames with international characters can't be represented. Thus, it's not a generally good idea to use the <code>main</code> arguments for portable code.</p>

<hr>

<pre><code>    int input = 0;
</code></pre>

<p>declares a variable called <code>input</code>, of type <code>int</code>, and initializes it to <code>0</code>.</p>

<p>Any zero value of a fundamental type represents <code>false</code> when it's <em>used as a boolean</em>. Conversely, any non-zero value represents <code>true</code>, and this convention stems from early C, which didn't have a <code>bool</code> type. In modern C++ it's better to use the <code>bool</code> type for booleans, with the values (literally) <code>false</code> and <code>true</code>.</p>

<p>The variable above, however, is not used as a boolean, but represents the last number input by the user.</p>

<hr>

<pre><code>    do
    {
        // Stuff, called the ""loop body"".
    }
    while (input != -1);
</code></pre>

<p>This is a <code>do-while</code> loop. The <strong>continuation condition</strong> stated after the <code>while</code> is checked <em>after</em> each iteration. Which means that the <strong>loop body</strong> is guaranteed to be executed at least once.</p>

<p>C++ has three other loops: the <code>while</code> loop; the ordinary <code>for</code>-loop, which collects all the loop control stuff in the <strong>loop head</strong>; and the range-based <code>for</code>, which is especially nice for iterating over the items in a collection.</p>

<hr>

<pre><code>        cout&lt;&lt;""Enter a number (-1 = QUIT):"";

        if (!(cin&gt;&gt; input))
        {
            cout&lt;&lt;""INVALID"" &lt;&lt;endl;
            cin.clear();
            cin.ignore(10000, '\n');
        }
</code></pre>

<p>The first statement above just prompts the user. The <code>cout</code> and <code>cin</code> streams are <em>synchronized</em>, so that when the subsequent input operation is attempted, the output, if not already presented on the screen, is <strong>flushed</strong>. Instead of such automatic, implicit flushing, you can guarantee a flush by doing it explicitly, like this:</p>

<pre><code>        cout&lt;&lt;""Enter a number (-1 = QUIT):"" &lt;&lt; flush;
</code></pre>

<p>The expression <code>cin &gt;&gt; input</code></p>

<ul>
<li><p>attempts to interpret the next ""word"" of user input as an integer, and store that in the variable <code>input</code>, and</p></li>
<li><p>produces a reference to <code>cin</code> as its expression result.</p></li>
</ul>

<p>If the input of text fails, or if the conversion from textual specification to <code>int</code> fails, then <code>cin</code> enters a <strong>failure state</strong>. In this state further input is just ignored. Happily that's easy to check for, because when a stream is used directly as an <code>if</code> or <code>while</code> (including <code>do-while</code>) condition, then it converts implicitly to boolean <em>as if</em> you had written <code>!stream.fail()</code>.</p>

<p>Hence, <code>!(cin &gt;&gt; input)</code> does all of the above, and produces the result of <code>!!cin.fail()</code> (twice negated, &ldquo;not not&rdquo;), where <code>fail</code> is a member function that check whether the stream is in a failure state.</p>

<p>If the stream is in a failure state, then that state must be cleared, lest further input operations will all be ignored, and that's what</p>

<pre><code>            cin.clear();
</code></pre>

<p>achieves.</p>

<p>In addition there will be some input text  &ndash; at the least a newline (end of line marker) &ndash; left in the <strong>input buffer</strong>, and to avoid that text being processed as valid input the next time around the loop, it should better be removed! And that's what the</p>

<pre><code>        cin.ignore(10000, '\n');
</code></pre>

<p>accomplished. Under the assumption that there's not more than 10000 characters left in the input buffer&hellip;</p>

<hr>

<pre><code>            cout&lt;&lt;""INVALID"" &lt;&lt;endl;
</code></pre>

<p>Outputs the text &ldquo;INVALID&rdquo; followed by a newline. Outputting the <code>endl</code> <strong>manipulator</strong> has the effect of a newline plus a flush. Thus the above is equivalent to and just short for</p>

<pre><code>            cout&lt;&lt;""INVALID\n"" &lt;&lt; flush;
</code></pre>

<p>It often happens that newbies are concerned with the lack of efficiency of <code>endl</code> as opposed to just <code>\n</code>. This concern is however misplaced. Iostreams are for convenience and (due to stronger type checking) avoiding the easy bugs of C style i/o; they're generally not what one would choose for efficiency.</p>

<hr>

<p>After the loop, the</p>

<pre><code>    cout&lt;&lt;""Done""&lt;&lt;endl;
    cin.get();
</code></pre>

<p>stops the program until the user enters some input.</p>

<p>This is because when the program is run from an IDE (as opposed to from the command line), the console window could just otherwise disappear. And especially for non-interactive programs that's undesirable. So the statement above, while not needed for this particular program, is a general convention.</p>

<p>However, it's ungood. It becomes very annoying when the program is run from the command line! Instead, to see all the output of a program, do either</p>

<ul>
<li><p>run it from the command line, or</p></li>
<li><p>run it in a way that automatically stops at the end (e.g. Ctrl+F5 in Visual Studio), or</p></li>
<li><p>place a breakpoint at the last <code>}</code> right curly brace of <code>main</code>, and run it in the debugger.</p></li>
</ul>

<hr>

<pre><code>    return 0;
</code></pre>

<p>is unnecessary, since this is the default function result for <code>main</code> (<code>main</code> is unique in having a default function result).</p>

<p>The value returned from <code>main</code> will in practice become a <strong>process exit code</strong>.</p>

<p>In both Windows and *nix the convention is that 0 means success and any other value means failure.</p>

<p>In C++ the only portable values are 0, <code>EXIT_FAILURE</code> and <code>EXIT_SUCCESS</code>, where the latter two come from the <code>stdlib.h</code> header. <code>EXIT_FAILURE</code> and <code>EXIT_SUCCESS</code> depend on the system at hand, but the latter is typically just 0. In Windows you may want to use Windows' own <code>E_FAIL</code> instead of <code>EXIT_FAILURE</code>, because (for unfathomable reasons) Windows C++ compilers typically define <code>EXIT_FAILURE</code> as 1, which is also a specific Windows error code &ndash; and in Windows the process exit code is typically literally what that term indicates, namely a standard error code, with 0 as &ldquo;no error&rdquo;.</p>
",0
21189195,21188973,6,"<p>This is how you declare <code>c2</code>:</p>

<pre><code>counter c2;
</code></pre>

<p>As you can see, it's not <code>const</code>. This will never change. Your assignment can't possibly change the <code>const</code>ness of <code>c2</code>.</p>

<p>In your assignment function, it is <code>*this</code> that refers to the object you're assigning to, not the return value. The return value is the value of the expression <code>c2 = c</code>. So if you tried to modify the result, perhaps with <code>(c2 = c).Inc()</code>, it wouldn't work, because the return value is <code>const</code>.</p>

<hr>

<p>I notice that you seem to think <code>const counter&amp; counter::</code> is the return type of the function. Actually, just <code>const counter&amp;</code> is. The <code>counter::</code> part is a nested name specifier that says the <code>operator=</code> function is a member of the <code>counter</code> class.</p>

<pre><code>const counter&amp; counter::operator=(const counter&amp; y)
^^^^^^^^^^^^^^ ^^^^^^^^ ^^^^^^^^^ ^^^^^^^^^^^^^^^^
 return type    scope   func name    parameters
</code></pre>
",6
22443421,22443367,3,"<blockquote>
  <p>I got there pointers because I dont want to create local copies of strings and my question is how to correctly work with with values of these strings.</p>
</blockquote>

<p>To be honest working with pointers in that case is going to be a mess. Mainly because pointers are not that easy to work with as people might think. Just look at the code you have right now. It's buggy because, for example, the default constructor of <code>something</code> will copy the pointers, effectively sharing the strings across two <code>something</code> objects.</p>

<p>I recommend to drop the pointers entirely and forget about this ""performance"" problem until you actually have proof that your application's bottleneck is in the copying of the strings:</p>

<pre><code>struct something {
    something(const string &amp; a, const string &amp;b)
    {
        first = a;
        second = b;
    }
    const string first;
    const string second;
    int somethingelse;
};
</code></pre>
",3
26200177,26200163,3,"<pre><code>int bubble_sort(int list_of_nums[], int size)
{
    ...
    return swaps;
}
</code></pre>

<p>Why do you have trouble? You already make <code>bubble_sort</code> return the swap count.</p>

<p>So, just store it.</p>

<pre><code>int swaps = bubble_sort(arr2, SIZE);
</code></pre>
",0
22858511,22858398,0,"<p>You will get a <code>std::string</code> back from <code>cin</code> which you will need to convert to the appropriate type once you detect if it has a dot or not.</p>

<pre><code>std::string user_input;

cout &lt;&lt; ""enter a whole number or a number with decimal: "";
cin &gt;&gt; user_input;

if(user_input.find('.') != std::string::npos){
  // we found a float (probably)
  // uses boost library to make stuff easier
  printNumber(boost::lexical_cast&lt;float&gt;(user_input));
}else{
  printNumber(boost::lexical_cast&lt;int&gt;(user_input));
}
</code></pre>

<p>instead of <code>boost::lexical_cast</code> you can also use <code>std::stringstream</code></p>

<pre><code>std::stringstream ss;
ss &lt;&lt; user_input;
if(user_input.find('.') != std::string::npos){
  // we found a float (probably)
  float f;
  ss &gt;&gt; f;
  printNumber(f);
}else{
  int i;
  ss &gt;&gt; i;
  printNumber(i);
}
</code></pre>
",0
22858526,22858398,2,"<p>This is not as trivial as one would think. One way could be to read the input as a string, and see if the string contains a decimal-point (which would cause problems on locales where the decimal-point is a comma instead).</p>

<p>Another solution is to read as a string, then try to <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stof"" rel=""nofollow"">convert it to a floating point value</a>, and if that fails then <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow"">convert it to an integer</a>.</p>

<p>I would recommend the last method.</p>

<hr>

<p>Or for simplicity's sake, just instruct the user to input an integer followed by a floating point value:</p>

<pre><code>int a;
std::cout &lt;&lt; ""Enter an integer value: "";
std::cin &gt;&gt; a;

float b;
std::cout &lt;&lt; ""Enter a floating point value: "";
std::cin &gt;&gt; b;
</code></pre>

<p>Then hope that the user actually enters correct values.</p>
",2
22858870,22858398,0,"<p>Joachim is right that this isn¡¯t trivial. The ¡°proper¡± way to do this is to use a parser.</p>

<p>Writing such a parser isn¡¯t too hard ¨C it just needs to check that the number is in the right format, by trying to read it as either type and retrying if it doesn¡¯t work. A ¡°cleaner¡± solution is to use a formal parsing framework such as <a href=""http://www.boost.org/doc/libs/1_55_0/libs/spirit/doc/html/index.html"" rel=""nofollow"">Boost.Spirit.Qi</a>.</p>

<p>Here¡¯s a straightforward (but somewhat convoluted) solution:</p>

<pre><code>int main() {
    std::string value;
    std::cin &gt;&gt; value;

    std::size_t end;
    int intval = std::stoi(value, &amp;end);
    if (end == value.size())
        printnumber(intval);
    else
        printnumber(std::stof(value));
}
</code></pre>

<p>This checks that <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow""><code>std::stoi</code></a> converted the <em>whole</em> string rather than just parts of it.</p>

<p>Notice that this solution is not very robust since it does no proper error checking. In a real application I would strongly recommend going the Boost.Qi way because it makes the code simpler and more robust, but it requires some deeper C++ knowledge.</p>

<p>For reference, the ¡°proper¡± solution using a parsing framework would look something like this:</p>

<pre><code>struct printer : boost::static_visitor&lt;void&gt; {
    template &lt;typename T&gt;
    void operator ()(T const&amp; value) const { printnumber(value); }
};

int main() {
    std::string value;
    std::cin &gt;&gt; value;

    namespace qi = boost::spirit::qi;

    auto begin = std::begin(value);
    auto const end = std::end(value);
    boost::variant&lt;int, float&gt; result;
    bool success = qi::parse(begin, end, (qi::int_ &gt;&gt; !qi::lit('.')) | qi::float_, result);
    if (not success or begin != end)
        std::cerr &lt;&lt; ""Something went wrong\n"";
    else
        apply_visitor(printer{}, result);
}
</code></pre>
",0
22858633,22858398,0,"<p>You do not get the data until runtime, so you can't know the type at compile time, which is when the function overload is determined.  Thus, you need to make some decision at runtime.</p>

<p>I suggest you look up my most favorite C++ book of all time, <em>Advanced C++ Programming Styles and Idioms</em> by Jim Coplien.  Pay careful attention to the letter/envelop idiom, which describes how to accomplish what you want.</p>

<p>It may be overkill for this simple example, but it's worth learning since you are hunting for knowledge.</p>
",0
22855874,22855860,4,"<p>There is no dynamic memory allocation, so there is no memory leak. Your data member just points to a string literal. It is the equivalent of doing this:</p>

<pre><code>const char* c = ""Hello, World!"";
</code></pre>
",0
22855886,22855860,1,"<p>No  there's no memory leak, because nothing is being dynamically allocated.</p>

<p>The space required for 'prompt' is just a pointer, and that's effectively allocated by the compiler.</p>
",0
22855890,22855860,1,"<p>No memory leak. Untill you allocate some memory dynamically.</p>
",0
22855904,22855860,4,"<p>Yes that's fine if a little unsafe: the memory associated with <code>prompt</code> is not owned by the class instance.</p>

<p>(In your particular case <code>ChoiceLine choiceLine(""hello world"");</code> all will be well since the string literal will last the life of the program). </p>

<p>Hence it would have to be kept in scope for as long as the class instance was in scope.</p>

<p>If I were you I'd use a <code>std::string</code> as your class member and suffer a deep copy.</p>
",6
22858162,22855860,1,"<p>It depends on why you cannot use <code>std::string</code>, and what your
class is supposed to do.  As you've written it, it basically
leaves the memory management to the caller; typically, such
classes are used when the only reasonable arguments would be
string literals (which have static lifetime).  In other
contexts, I've used such classes to manage pointers to strings
(or other things) returned by libraries using a C interface; in
such cases, the whole purpose of the class is to free the string
in its destructor (often by calling a specific function in the
library interface, rather than <code>delete[]</code> or <code>free</code>). </p>

<p>The names in your example suggest that you are in the first
case: a <code>prompt</code> is almost certainly a string literal or
a string looked up in a dictionary with static lifetime (for
internationalization purposes); in either case, it would be an
error to attempt to delete or free it.</p>
",0
29476349,29476302,3,"<pre><code>void Bresenham(int x1,int y1, int x2, int y2, colour)
                                              ^ you forgot the type here
</code></pre>

<p>It should be</p>

<pre><code>void Bresenham(int x1,int y1, int x2, int y2, int colour)
</code></pre>

<p>( But you are not even using this function in your code )</p>

<p>You should also use <code>int main()</code> over <code>void main()</code></p>

<pre><code>int main()
  {
     // your code
    return 0;
  }
</code></pre>

<p>You also have an error here</p>

<pre><code>cout&gt;&gt;""Enter your Favorite Colour:"";
     ^
     here
</code></pre>

<p>it should be</p>

<pre><code>cout &lt;&lt; ""Enter your Favorite Colour:"";
</code></pre>

<p>and </p>

<pre><code>cin&lt;&lt;colour;
</code></pre>

<p>should be</p>

<pre><code>cin &gt;&gt; colour;
</code></pre>

<p>You also have an extra parameter in your call yo <code>line()</code>. Remove that <code>colour</code> from there . It should be</p>

<pre><code>line( x1 , y1 , x2 , y2 );
</code></pre>

<p>If you want to set the color, use </p>

<pre><code>setcolor( /* color code */ );
</code></pre>

<p>These are the color codes</p>

<pre><code> 0   BLACK
 1   BLUE
 2   GREEN
 3   CYAN
 4   RED
 5   MAGENTA
 6   BROWN
 7   LIGHTGRAY
 8   DARKGRAY
 9   LIGHTBLUE
 10  LIGHTGREEN
 11  LIGHTCYAN
 12  LIGHTRED
 13  LIGHTMAGENTA
 14  YELLOW
 15  WHITE
</code></pre>

<p>Example, to get RED, you use</p>

<pre><code>setcolor( 4 );
</code></pre>
",9
21717719,21717635,3,"<p>Making an assumption here.</p>

<pre><code>Node * n;
n-&gt;get_Leaf(0);              //works, returns const Node*
n-&gt;get_Leaf(0)-&gt;get_Leaf(0); //fails, can't call
                             //(const Node* Node::get_Leaf) on const Node*
</code></pre>

<p>Assumption is that you're calling <code>get_Leaf</code> on the returned value of <code>get_Leaf</code> or some other function that returns <code>const Node*</code>. In that case, you need to declare <code>get_Leaf</code> like so: <code>const Node* get_Leaf(int i) const;</code></p>
",0
27145699,27145504,1,"<p>I think your function declaration may be like this  =>  "" getText(char *parameter)""</p>

<p>if your function declaration is like this   => "" getText(std::string parameter) ""</p>

<p>it should be working</p>
",0
33006134,33006070,2,"<p>I'm assuming <code>uCommand</code> is a <code>std::string</code>, as you didn't include its declaration.</p>

<p><code>std::string::find</code> returns <code>std::string::npos</code> when the find fails to find anything. This is normally <code>(size_t)-1</code>, <code>size_t</code> is an unsigned type, meaning that <code>npos</code> is an extremely large value. You can't treat this as a <code>bool</code> as anything non-zero is treated as <code>true</code>.</p>

<p>Your code should be</p>

<pre><code>if (uCommand.find(""&lt;"", 0) != std::string::npos &amp;&amp; uCommand.find(""&gt;"", 0)  != std::string::npos)
</code></pre>
",2
23832141,23831836,1,"<p>Serialization of arbitrary class types is a complicated topic. It is <strong>not</strong> sufficient to just take the base address of the object instance and copy <code>sizeof(whatever)</code> bytes. This might work for very simple classes with members of POD type but think of a simple <code>std::string</code> type member which has already heap allocated memory outside of the object instance's memory block. You'd have to follow all pointers to their respective memory location and copy the content there as well and so on.</p>

<p>Only your class itself knows how to properly serialize/deserialize itself and it's also the only one who has access to private members. <strong>One possible approach</strong> would be to add serialization/deserialization functions to your class. You could (should) also put this into a base class/interface then:</p>

<pre><code>class ISerializable
{
public:
  virtual void Serialize(std::ostream&amp; stream) const = 0;
  virtual void Deserialize(std::istream&amp; stream) = 0;
}
</code></pre>

<p>Derive serializable classes from this and implement the virtual functions. Make sure the serializer writes the data of all members to the stream or calls <code>Serialize()</code> functions of class type members. If you have <code>std::string</code> members or other types that you can't modify use their public interface to extract all data needed in order to restore them later. This would be the char buffer data and/or length in case of the <code>std::string</code>. For POD types like <code>int</code> it is sufficient to copy the memory data in some way similar to what you posted.</p>

<p>Please note that all your serializable classes need a default constructor when using the pattern mentioned above since you have to create an instance before you can actually deserialize its content from an <code>istream</code>.</p>
",1
23095505,23095229,2,"<p>Apart from the fact that variable length arrays are not supported in ISO C++ and presumably allowed here by extension in GCC, you start with a buffer overrun: the array <code>t</code> should be at least <code>t[b+1]</code> long, and even then you are trusting the user not to enter more characters that they promised.  </p>

<p>Since you then assign <code>t</code> to a <code>std::string</code> (<code>TA</code>), why would you not just read the input directly into <code>TA</code> which is intrinsically safe (not to mention valid ISO C++)?</p>

<pre><code>string TA ;
cout &lt;&lt; ""Enter your characters : "" ;
cin &gt;&gt; TA ;
</code></pre>
",5
22443078,22443050,2,"<p>This:</p>

<pre><code>double&amp; opeator[] (int Index);
</code></pre>

<p>is supposed to be:</p>

<pre><code>double&amp; operator[] (int Index);
//         ^
</code></pre>

<hr>

<blockquote>
  <p>Please also i didnt understand the use of [] operator properly clearly please also little bit explain that. I read that and did this example to understand but still problem in understanding.</p>
</blockquote>

<p>Well, <code>operator[]</code> is especially useful to <em>simulate</em> an array indexing behavior. The standard library uses this operator on ""array-like"" classes like <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a> or <a href=""http://en.cppreference.com/w/cpp/container/deque"" rel=""nofollow""><code>std::deque</code></a>.</p>

<p>Your example (except for the type obviously):</p>

<pre><code>double&amp; example::operator[](int Index) {       
        return temp[Index];        
}
</code></pre>

<p>is a perfectly fine application of the operator. The only thing I would suggest you to change is the type of the <code>Index</code>: it should really be <code>std::size_t</code>.</p>

<p>For more informations about <em>operator overloading</em>, please, refer to <a href=""https://stackoverflow.com/questions/4421706/operator-overloading?rq=1"">this question</a>.</p>
",4
24124685,24124604,4,"<p>Look at this code in your destructor:</p>

<pre><code>delete temp;       // calling delete 
cout &lt;&lt; temp;
temp = temp-&gt;next; // using a pointer that has been deleted. 
</code></pre>

<p>Calling <code>delete</code> is the last (safe) thing you can do with a pointer. </p>
",7
28498029,28497981,8,"<p>I think you're looking for the conditional operator, which looks like this:<br> <code>testExpression ? trueExpression : falseExpression</code>.</p>

<p>So:</p>

<pre><code>return (retA ? A : 0) + (retB ? B : 0) + (retC ? C : 0) + (retD ? D : 0);
</code></pre>

<p>All of the languages syntactically derived from B have the conditional operator (C, C++, Java, JavaScript, and several others).</p>

<hr>

<p>Side note: You were using <code>A</code> after the <code>RetD</code> condition, but I figure you meant <code>D</code>. Also, no need for the outer pair of <code>()</code>, so I left them off.</p>

<hr>

<p>You'll sometimes hear the conditional operator called ""the ternary operator,"" which is fine but isn't quite correct: It's <strong><em>a</em></strong> ternary operator (that is, an operator that accepts three operands) just like <code>*</code> is <strong><em>a</em></strong> binary operator (an operator that accepts two operands). As far as I know, the conditional is C++'s only ternary operator, but in theory someday there could be more...</p>
",0
25456860,25456687,0,"<p>Looks like you wanted to input a single character:</p>

<pre><code>char c;
//...
scanf(""%c"", &amp;c);
while (c != '\0')
{
  switch (c)
//...
</code></pre>

<p>Also, rather than specifying the constant character to push on the stack, you could use the same variable in the <code>switch</code> statement:  </p>

<pre><code>case '^':
  u.push(c);
  break;
</code></pre>

<p>Since this task has been completed many times and many questions about it have been posted on StackOverflow, I recommend you search the web for ""StackOverflow C postfix calculator"".<br>
If you want to use C++ features:  ""StackOverflow C++ postfix calculator"".</p>
",0
25456734,25456687,2,"<p><code>char *ex; [...] scanf(""%s"",ex);</code> will input a string to an undefined location. Therefore your code will have undefined behaviour.</p>
",0
31295137,31295136,0,"<pre><code>#include &lt;iostream&gt;
using namespace std;

//Extract the reverse function so you don't have to do it inline
int reverse (int n){
  int ret = 0;
  int r;
  while(n) {
    r = n%10;
    n /= 10;

    ret*=10;
    ret+=r;
  }
  return ret;
}

int main()
{
  unsigned  long int num1, num2, sum;
  cin&gt;&gt; num1 &gt;&gt; num2;
  cerr  &lt;&lt; reverse(num1) &lt;&lt; "" + "" &lt;&lt; reverse(num2) &lt;&lt; endl;
  sum = reverse(num1) + reverse(num2);
  cout &lt;&lt; reverse(sum) &lt;&lt; endl;
  return 0;
}
</code></pre>
",0
22852127,22851290,1,"<blockquote>
  <p>It now returns every file, but also one additional.</p>
</blockquote>

<p>Your code's testing <code>eof()</code> incorrectly.  You should test for the success of the input operation, almost never <code>eof()</code> unless you've already had an input failure.  Correct code is:</p>

<pre><code>if (ifstream partIn(""inventoryPricing.dat""))
{
    invCount = 0;

    while (partIn &gt;&gt; partNum[invCount] &gt;&gt; price[invCount])
        ++invCount;

    if (partIn.fail())
    {
        // could set invCount to -1 to avoid partial processing?
        std::cerr &lt;&lt; ""File parsing failed after "" &lt;&lt; invCount &lt;&lt; "" entries\n"";
    }   
}
else
{
    invCount = -1;
    std::cerr &lt;&lt; ""File failed to open.\n"";
}
</code></pre>

<blockquote>
  <p>On top of that, with this new addition, the file now continues into the other lines of code where it didn't before?</p>
</blockquote>

<p>I can't even guess what you might mean by that....</p>
",0
24105086,24104603,1,"<pre><code>ValueType Weapon::getProprtyValue( PropertyType id ) {
   switch( id ) {
      case kWeaponProperty01: return m_weaponProperty01;
      ...
      default: return Item::getPropertyValue( id );
   }
}
</code></pre>

<p>You can make some kind of universal accessor method, though it have some limitations, it could be quite handy, especially in case of content editors, serialization etc.</p>
",1
24104832,24104603,2,"<p>Your second and third option is obviously <strong>not</strong> the way to go - whenever you add a new type of item, you will also have to change the base class or the enum - that is definitely not what you want to if you need any basic form of maintainability in your code.</p>

<blockquote>
  <p>And here comes the problem with interface - how to get access to derived class data</p>
</blockquote>

<p>First you have to think of ""where will your code do this""? Most of your code dealing with the whole <code>inventory</code> should only use the content as <code>Item*</code>, using only functions from the <code>Item</code> class. </p>

<p>If you have code specificially dealing with <code>Weapon</code> objects, the place where the <code>Weapon</code> objects are created (and inserted into the <code>inventory</code>), may also add them to another variable, maybe a weapons list in form of a </p>

<pre><code>std::vector&lt;Weapon*&gt; weapons;
</code></pre>

<p>or to a member variable <code>Weapon*</code> of a class <code>Warrior</code> or something like that (but beware, you now will have two pointers to the same objects, so you have to think about ownership). So the code dealing only with weapons (for example, a member function of <code>Warrior</code>) does not access the <code>inventory</code> to get a <code>Weapon</code> object, it will always use the <code>Weapon*</code> directly. </p>

<p>If, for some reasons, you have to write some code which does something for all weapons from your inventory, then write a single function which extracts all <code>Weapon</code> objects using the <code>dynamic_cast</code> (or even better: make it an iterator function), and reuse this function whenever you need to get access to all weapons. So you don't clutter your code all over with dynamic casts, but keep this in just one place.</p>

<p>EDIT: another alternative (avoiding the dynmic cast) is using the visitor pattern, see <a href=""https://stackoverflow.com/questions/16120394/create-function-taking-base-class-pointer-but-calling-derived-class-function"">this post</a>. But I don't really like the answer of that post, in the presented form it will imply a cyclic dependency ""Base -> Visitor -> Derived -> Base"", which is IMHO a bad design.</p>
",0
25502976,25502891,2,"<p>You get <code>//the error : use of undefined type</code> because <code>class Friend2</code> is only declared, not defined at that point. To solve this move <code>int friend1::comp(friend2* f2o)</code> implementation to <code>friend1.cpp</code> and include <code>friend2.h</code> from there.</p>

<p><strong>UPDATE</strong> In general, if two classes are mutual friends (and even if only one of them is a friend to another), it's a good reason to think about the design.</p>
",4
25504599,25504417,3,"<p>Use the <a href=""http://www.boost.org/doc/libs/1_56_0/libs/tokenizer/tokenizer.htm"" rel=""nofollow"">Boost Tokenizer library</a>:</p>

<pre><code>boost::char_separator&lt;char&gt; sep("",;"");
boost::tokenizer&lt;boost::char_separator&lt;char&gt;&gt; tokens(input, sep);
</code></pre>
",5
25504605,25504417,1,"<p>what about old way style?</p>

<pre><code>std::string string = ""abc,def;ghi"";
std::vector&lt;std::string&gt;strings;
std::string temp;
for(int i=0; i &lt; string.length(); i++)
{
    if(string[i] == ',' || string[i] == ';')
    {
        strings.push_back(temp);
        temp.clear();
    }
    else
    {
        temp += string[i];
    }
}
strings.push_back(temp);
</code></pre>

<p><a href=""http://ideone.com/T3vwkq"" rel=""nofollow"">live demo</a></p>
",2
25504985,25504417,0,"<p>Using strsep in string.h from C library , you could do it like this:</p>

<pre><code>std::string input = ""abc,def;ghi"";
const char* ss = intput.c_str();
const char token[] = "",;"";

for (const char* part; (part = strsep(&amp;ss, token)) != NULL;) {
    std::cout&lt;&lt; part &lt;&lt; std::endl;
}
</code></pre>
",0
25535027,25534908,4,"<p>If each question is terminated with a question mark then you can write</p>

<pre><code>std::string line;

while ( std::getline( FileStream, line ) )
{
    std::istringstream is( line );

    std::string question;
    std::string answer;

    std::getline( is, question, '?' );
    question += '?';
    std::getline( is, answer );

    // some processing of question and answer
}
</code></pre>

<p>If there is used some other separator then you need to substitute the question mark for this separator and maybe to remove line</p>

<pre><code>    question += '?';
</code></pre>
",1
23066207,23066131,0,"<p>Those functions have not been seen yet when you try to use them; the compiler doesn't know what they are which leads to the error. Either move them before <code>main()</code> or prototype them, such as:</p>

<pre><code>double mean(double * mydata, double N);
double standard_dev(double * mydata, double m, int N);
int main()
{
    ...
</code></pre>

<p>This will give the compiler its expectations for those symbols, so when it sees them in use it knows what to do with them.</p>
",0
23066209,23066131,0,"<p>Any name must be defined before its using (with rare exceptions relative to template). You use name <code>mean</code> in statement</p>

<pre><code>m =  mean(mydata, N);
</code></pre>

<p>but name <code>mean</code> is not yet defined.</p>

<p>Place function declarations before main</p>

<pre><code>double mean(double *mydata, double N);
double standard_dev(double *mydata, double m, int N);

int main()
{
//...
</code></pre>

<p>Or before their usage.</p>

<pre><code>int main()
{
   double mean(double *mydata, double N);
   double standard_dev(double *mydata, double m, int N);

   //...
   m =  mean(mydata, N);
   //...
</code></pre>
",0
23066210,23066131,0,"<p>You need to have prototypes for your functions <code>mean()</code> and <code>std_dev()</code> at the top of your file. Otherwise, they don't 'exist' in the main function. Either copy the entire functions to the space above your main function, or make prototypes for them. Good luck!</p>
",0
27543300,27542085,0,"<p>How about using openCV library, you can define matrices of different types and sizes easily using it.</p>
",1
27544002,27542085,0,"<p>Create a random vector <code>v</code> and verify that <code>C * v == A * (B * v)</code> (but allow some rounding errors).</p>
",0
23073553,23073515,2,"<pre><code>if (isalpha(first))
</code></pre>

<p><code>isalpha()</code> accepts <code>int</code> as parameter but you provided a <code>char[]</code> to it.</p>
",1
26127559,26127475,4,"<p><code>std::vector</code> accepts a second parameter for the value to use to initialize elements:</p>

<pre><code>std::vector&lt;int&gt; mydata(1000, -1); // 1000 elements, each initialized to -1
</code></pre>
",0
26127572,26127475,3,"<p><code>std::vector</code> has a constructor that takes a size and a value to use as an initializer:</p>

<pre><code>// create a vector of 10 integers with the value -1
std::vector&lt;int&gt; v(10, -1);
</code></pre>
",0
26248371,26248299,3,"<p>The evaluation of the function arguments is unsequenced, so modifying a variable in one and using its value in another gives undefined behaviour. That's the case whether you use pre-increment or post-increment.</p>

<p>In general, avoid modifying a variable as part of a complicated expression; especially if its value is used elsewhere in the expression, since that tends to give an unspecified value or (in some cases) undefined behaviour.</p>
",12
34235869,34235842,2,"<p>With optimization on, neither of these functions should compile to anything (they initialize and modify a function local variable, which can be optimized to a no-op). Without optimization turned on, none of the results are worth anything (if performance mattered, you'd have optimization turned on). I wouldn't try drawing useful conclusions from a test that doesn't actually test anything meaningful.</p>
",3
23588935,23588870,1,"<p>Use the solution provided below by @Remy Lebeau</p>

<pre><code>CD::CD(const CD &amp;obj) :Media(obj), Cd(obj.Cd) {}
</code></pre>
",7
33539523,33539368,6,"<pre><code>int ia[3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11 };
</code></pre>

<p><code>ia</code> is an array of 3 arrays of 4 <code>int</code> each.</p>

<p><code>ia[0]</code> is <code>{ 0, 1, 2, 3 }</code>.</p>

<p><code>ia[1]</code> is <code>{ 4, 5, 6, 7 }</code>.</p>

<p><code>ia[2]</code> is <code>{ 8, 9, 10, 11 }</code>.</p>

<p>I don't quite understand why you say we would be ""about to initialize"" it -- at this point, <code>ia</code> is completely initialized.</p>

<pre><code>int(&amp;row)[4] = ia[1];
</code></pre>

<p><a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow"">Spiral rule</a> (start with the identifier...):</p>

<p><code>row</code></p>

<p>...is a...</p>

<p><code>(&amp;row)</code></p>

<p>...reference...</p>

<p><code>(&amp;row)[4]</code></p>

<p>...to an array of four...</p>

<p><code>int(&amp;row)[4]</code></p>

<p>...<code>int</code>...</p>

<p><code>= ia[1];</code></p>

<p>...initialized by <code>ia[1]</code> (because you <em>have</em> to initialize a reference, no way around it).</p>

<p>So <code>row</code> is now a reference to <code>ia[1]</code>, which is of type ""array of four <code>int</code>"". That's all there is to it.</p>
",0
33539629,33539368,0,"<p>(&amp;row)[4] means that it can reference to an array of 4 elements and ia[1] is a row from the 2d array ia[][] that contains 4 elements, hence it works fine.</p>
",0
33539481,33539368,13,"<pre><code> int ia[3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11 };
</code></pre>

<p>Is an array of 3 elements, each element is an array of 4 ints.</p>

<pre><code>int(&amp;row)[4] = ia[1];
</code></pre>

<p>Here the <code>int(&amp;row)[4]</code> part declares a reference named row that can reference an array of 4 ints. the <code>= ia[1]</code> initializes it to reference the second element in the <code>ia</code> array, which is an array of 4 ints.</p>
",2
22885397,22885300,0,"<p>Are you assuming the function call <code>validateNumber(num,score,total);</code> in line 5 would calculate the total? You should call the function from <code>main</code> function, and assign the return value to a variable, (e.g. <code>total</code>).</p>
",1
22885498,22885300,1,"<p>If you want to implement the <code>validate()</code> function like you did here,</p>

<pre><code>validateNumber(num,score,total);
</code></pre>

<p>you can make it <code>void</code> and pass the variable <code>total</code> as reference. e.g,</p>

<pre><code>void validateNumber(int num, int score, int &amp;total) {
  while (num &lt; 1 || num &gt; 4) {
    cout &lt;&lt; over3 &lt;&lt; num &lt;&lt; "" is not between 1 and 4! Try again: "";
    cin &gt;&gt; num;
  }
  system(""CLS"");
  for (int i = 1; i &lt;= num; i++) {
    cout &lt;&lt; over3 &lt;&lt; ""Enter score "" &lt;&lt; i &lt;&lt; "": "" &lt;&lt; endl;
    cout &lt;&lt; over3 &lt;&lt; ""Enter a value from 0 to 100: "";
    cin &gt;&gt; score;
    while (score &lt; 0 || score &gt; 100) {
      cout &lt;&lt; over3 &lt;&lt; score
           &lt;&lt; "" is not between 0 and 100! Renter the score: "" &lt;&lt; i &lt;&lt; "": "";
      cin &gt;&gt; score;
    }
    total += score;
  }
}
</code></pre>

<p>and the rest would be same...
Otherwise I wouldn't have use 3 arguments in this case. e.g,</p>

<pre><code>int validateNumber(int num) {
  int total=0,score;
  while (num &lt; 1 || num &gt; 4) {
    cout &lt;&lt; over3 &lt;&lt; num &lt;&lt; "" is not between 1 and 4! Try again: "";
    cin &gt;&gt; num;
  }
  system(""CLS"");
  for (int i = 1; i &lt;= num; i++) {
    cout &lt;&lt; over3 &lt;&lt; ""Enter score "" &lt;&lt; i &lt;&lt; "": "" &lt;&lt; endl;
    cout &lt;&lt; over3 &lt;&lt; ""Enter a value from 0 to 100: "";
    cin &gt;&gt; score;
    while (score &lt; 0 || score &gt; 100) {
      cout &lt;&lt; over3 &lt;&lt; score
           &lt;&lt; "" is not between 0 and 100! Renter the score: "" &lt;&lt; i &lt;&lt; "": "";
      cin &gt;&gt; score;
    }
    total += score;
  }
  return total;
}
</code></pre>

<p>and the call:</p>

<pre><code>int num, total;
...
total=validateNumber(num);
</code></pre>

<p>Hope it helped...</p>
",3
25659527,25659495,4,"<p>1.Change:</p>

<pre><code>copy(names.begin(), names.end(), ostream_iterator&lt;string&gt;(cout, ' ');
</code></pre>

<p>into:</p>

<pre><code>copy(names.begin(), names.end(), ostream_iterator&lt;string&gt;(cout, "" ""));
</code></pre>

<p><em>(string literal, not character)</em></p>

<p>2.add missing paren.</p>

<p>3.and add missing <code>&lt;algorithm&gt;</code>, <code>&lt;iterator&gt;</code> and <code>&lt;string&gt;</code> headers.</p>

<p>4.add <code>using namespace std;</code></p>
",4
24764179,24764031,91,"<p>Try this:</p>

<pre><code>Eigen::MatrixXd d;                       // Matrix of doubles.
Eigen::MatrixXf f = d.cast &lt;float&gt; ();   // Matrix of floats.
</code></pre>
",1
29180918,25802133,0,"<p>I think that's a good fit for <em>Policies</em>.</p>

<p>You could define two interfaces:</p>

<pre><code>class A {
    void fnOldFunction();
public:
    void fn() {
        fnOldFunction();
    }
};
class B {
    void fnNewFunction();
public:
    void fn() {
        fnFunction();
    }
};
</code></pre>

<p><code>A</code> and <code>B</code> could inherit from classes of the old/new library.
Now, you just have to define your working class like this:</p>

<pre><code>template &lt;typename Policy&gt;
class C : public Policy {
    /* Whatever you need */
public:
    /* Say doSomething need to call fn */
    void doSomething() {
        /* Whatever */
        fn();
        /* ... */
    }
};
</code></pre>

<p>Now depending on your usecase, you could either use <code>C&lt;A&gt;</code> or <code>C&lt;B&gt;</code>. Note that this could be cumbersome if many names have changed in the library (breaking the API like that isn't a good idea, you have my sympathy :( ).</p>

<p>With this solution, which in terms does almost the same thing as @Alexander's one, you can still link against the old library as well as the new version. You just have to switch from <code>C&lt;B&gt;</code> to <code>C&lt;A&gt;</code>.</p>

<p>You could even couple that with other metaprogramming techniques such as type traits to make the compiler deduce if you need <code>C&lt;A&gt;</code> or <code>C&lt;B&gt;</code> all by itself. If possible, you wouldn't even have to touch the code to compile with either version of the lib.</p>
",0
31902702,31902655,3,"<p><code>class</code> cannot be used as a type name. You don't need to use <code>*</code> on references.</p>

<pre><code>void swap(T&amp; a, T&amp; a)
{
    T temp = a;
    a = b;
    b = temp;
}
</code></pre>

<p>This only works if your assignment operator and copy constructor are correct for your class. Since these methods are class members it's doesn't matter whether you have private data members or not.</p>
",4
23612456,23612410,2,"<p>Do you intend absolute values? You can use the <code>abs</code> function.</p>

<p><code>abs(-5) + abs(15)</code> gives <code>20</code> as a result.</p>
",0
23612515,23612410,0,"<p>I don't know about such function, however you can simply create one: just add absolute values:</p>

<pre><code>#include &lt;iostream&gt;

int sumAbs( int a, int b) {
    return std::abs( a) + std::abs( b);
}

int main() {
    int a = -5;
    int b = 10;
    std::cout &lt;&lt; sumAbs( a, b); // 15
    return 0;
}
</code></pre>
",0
23612518,23612410,0,"<p>Do you mean the difference? <code>abs(15 - (-5))</code> also gives 20.</p>
",0
28153551,28153343,3,"<p>If you can use C++11, it's required to be thread-safe there.  (But that could easily be implemented by using a mutex as well, if you're concerned about performance issues.)</p>

<p>More generally: try to ensure that the function is called before multiple threads are started.  (In many applications, all that is needed is to call it somewhere in the initialization of a static object.)</p>
",1
28159529,28159501,2,"<p>It's <code>std::vector&lt;char&gt;()</code>. 
In addition one can say that the default constructor generates the defaulted object of that specific class.</p>
",0
28159541,28159501,0,"<p>A default <code>vector&lt;char&gt;</code> will be one constructed using the default constructor, so the same as doing:</p>

<pre><code>std::vector&lt;char&gt; charVector;
</code></pre>

<p>Such a vector will be empty and that's pretty much all that can be said about it.</p>
",0
28159557,28159501,-1,"<p><code>std::vector&lt;char&gt;</code> is an empty vector by default.</p>
",0
28159569,28159501,1,"<blockquote>
  <p>I am unsure what the default value for <code>vector&lt;char &gt;</code> would be</p>
</blockquote>

<p>It will be a default constructed <code>std::vector</code> object.</p>

<p>However, a better way to detect whether the <code>map</code> has entry corresponding to a given key is to use <code>find</code> and check whether the returned value is a dereferenceable <code>iterator</code>.</p>

<pre><code>if ( myMap.find(myKey) != myMap.end() )
{
   // The map has an entry corresponding to myKey
}
else
{
   // The map does not have an entry corresponding to myKey
}
</code></pre>
",1
28165461,28165435,4,"<p>It's infinite recursion: <code>weightConv()</code> calls itself.</p>
",2
28165523,28165435,0,"<p>It is an unending recursion as <code>weightConv()</code> is calling itself again and again causing <code>Segmentation Fault</code>. Also, you never input the string <code>user</code>, hence, it should be removed or input after the <code>weightConv()</code> function.</p>
",0
28440284,28434183,2,"<p>The answer was to have visual studio 2010 installed. Express worked nicely.
Just for other people with the same problem, here is what you do:</p>

<pre><code>Install VS 2013/2012 depending on which one you want.
Install VS 2008 and 2010 ( can be express ).

If that doesnt pick up your compiler tools v90/v100 then just follow these instructions:
-Uninstall all C++ 2010 Redists if any, or SDK 7.1 won't install.
-Install Windows SDK 7.1 and then download the Windows C++ Compiler Tools 2010 update for the SDK.
-Install the C++ Redists again.
-Reboot.
</code></pre>

<p>-Enjoy! :P</p>
",0
23300346,23300317,1,"<p>You probably don't need a whole string for this. Given that you're looking for a single character, the correct type to use is a <code>char</code>:</p>

<p><code>int x = 65;
char xc = (char)x;
assert(xc == 'A');
</code></p>
",0
23300353,23300317,3,"<p>Looking at the <a href=""http://en.cppreference.com/w/cpp/string/basic_string/basic_string"" rel=""nofollow"">string constructors</a>, we can see one that takes a count and a character value. So we can use that:</p>

<pre><code>return std::string(1, ascii_value);
</code></pre>
",0
23300361,23300317,0,"<pre><code>char c;
...
std::string mystring(1, c);
</code></pre>
",0
23839644,23839589,1,"<p>Your compiling as a Windows application, which does not use the ""int main()"" signature when calling the entry point.</p>

<p>Switch to a console application in Project -> Properties -> Linker -> System -> SubSystem -> Console. There might be more involved than just this setting, so if it still doesn't compile, remake your project and make sure to choose Console Application.</p>
",0
33565053,33564948,2,"<pre><code>my_money /= my_money
</code></pre>

<p>is in maths talk</p>

<pre><code>x = a/a, x,a ¡Ê ?\{0}
</code></pre>

<p>and because the (?,+,?) constitute a field, that has to yield the one-element of the multiplicative sub-group (?, ?), and that is 1. </p>
",2
23560637,23559880,1,"<p>You need to use the flag <code>-I&lt;dir&gt;</code>, replacing <code>&lt;dir&gt;</code> to tell g++ where to search for the header files.</p>
",1
23117735,23117584,0,"<blockquote>
  <p>I want to get as many variables as the user enters and then do the required math to get the result.</p>
</blockquote>

<p>How do you want the user to signal stop? You can easily achieve this with a loop:</p>

<pre><code>while(true) {
    std::cin &gt;&gt; user_value1 &gt;&gt; user_symbol &gt;&gt; user_value2;
    v.push_back(user_value1);
    v.push_back(user_value2);
    stop_condition...
    //rest of code
}
</code></pre>
",2
23117700,23117584,3,"<p><code>std::cin &gt;&gt; v.push_back(user_value)</code></p>

<p>You can't do this.</p>

<p>You must do this instead</p>

<pre><code>std::cin &gt;&gt; user_value;
v.push_back(user_value)
</code></pre>
",2
21590554,21590023,1,"<p>To find the number of words per line you would use <code>std::getline()</code> to iterate over each line and use <code>std::stringstream</code> to extract each chunk of whitespace-separated input. Then you would iterate over each chunk of input and check to see if each character is alphabetic:</p>

<pre><code>int numberOfWords = 0;

for (std::string line, word; std::getline(ifile, line); )
{
    std::istringstream iss(line);

    while (iss &gt;&gt; word)
    {
        bool alpha = true;

        for (char c : word)
            if (!std::isalpha(c)) alpha = false;

        if (alpha) ++numberOfWords;
    }
    std::cout &lt;&lt; ""Number of words on this line: "" &lt;&lt; numberOfWords &lt;&lt; std::endl;
    numberOfWords = 0;
}
</code></pre>
",11
23587550,23587523,0,"<p>If you imagine <code>string</code> as a sequence of chars, then <code>(char*) s1[i]</code> is really casting <code>char -&gt; char *</code> in the code segment </p>

<pre><code>if(j == b)
    {return (char*) s1[i];}
</code></pre>

<p>The  <code>operator[]</code> returns the i-th char of the string. (<a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/</a>  ,   <a href=""http://www.cplusplus.com/reference/string/string/operator%5b%5d/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/operator[]/</a>)</p>
",0
23587572,23587523,3,"<pre><code>return (char*) s1[i];
</code></pre>

<p>There's two problems with that. First, you are converting the value if the character to a pointer.  You want to return the address of the character, not its value converted to a pointer. Second, <code>s1</code> is a local <code>std::string</code> initialized from the <code>haystack</code> parameter. You don't want to return a pointer to one of its characters, since it will be out of scope once the function returns. You want a pointer to a character in the original <code>haystack</code> c-string.</p>

<pre><code>return &amp;haystack[i];
</code></pre>
",0
23063880,23062471,1,"<p>This is a classic EOF detection issue that you can search for.  Search StackOverflow for ""c++ read file eof"".  </p>

<p>Change:<br>
<code>while (!infile.eof())</code><br>
To:<br>
<code>while (infile &gt;&gt; usern &gt;&gt; passwd)</code>  </p>

<p>EOF is only detected after a read attempt is made.  </p>
",2
28193712,28193681,1,"<p>Either disable incremental linking, by going to</p>

<pre><code>Project Properties 
   -&gt; Configuration Properties 
       -&gt; Linker (General) 
          -&gt; Enable Incremental Linking -&gt; ""No (/INCREMENTAL:NO)""
</code></pre>

<p>or install VS2010 SP1.</p>
",2
31138130,31137537,2,"<p>Because you doing bitwise xor of individual characters of message and key strings. As bitwise operator doesn't necessarily result in printable character , You are getting non printed characters.</p>
",0
31138597,31137537,1,"<p>You use Bitwise XOR. This can result in ASCII characters under 32 (32 is Space and the first printable ASCII character).
If you want it printable you can encode the result in Base64 or change your encryption so the result can't go below 32.</p>
",0
31138421,31137537,2,"<pre><code>// And now for the encryption part
for (string::size_type i = 0; i &lt; msg.size(); ++i)
    msg[i] ^= key[i];    // msg[i] ^ key[i]
</code></pre>

<p>Bitwise XOR of characters (ASCII values) can result in both printable and non-printable characters, depending on the values.</p>
",0
27560514,27560397,0,"<p>Directories do not contain files.  Directories contain names.  The names are links to  objects in the filesystem. The names <code>.</code> and <code>..</code> are links to the directory and its parent, respectively.</p>
",0
27560463,27560397,0,"<p>In linux and unix there is no difference between a file and a directory. Note that in the case of these dot files they are actually not ""real files"" though, that's another topic.</p>

<pre><code> The ""."" is a special file in the folder which means ""the current directory"" and "".."" is another special file which means ""the parent directory"".
</code></pre>
",1
23599368,23594924,10,"<blockquote>
  <p>Is this still a good idea, or is that coding standard outdated?</p>
</blockquote>

<p>The RTTI is most definitely the most notorious violation of the zero-overhead principle, because it incurs a static cost (executable size, and initialization code) that is proportional to the number of polymorphic classes (i.e., classes with at least one virtual function), and it does not depend on how much you use it, if at all. But there is no way to really provide RTTI without some per-class overhead. That's why you can disable RTTI on most compilers if you don't need it at all, or if you want replace it with an RTTI system you have more control over (as the LLVM guys did). Nevertheless, if you have RTTI enabled, and you are not using it, the overhead is only in the form of code bloat (larger executable, larger memory space needed, larger spread of code) and loading / unloading time, and so, the run-time execution overhead is almost non-existent. But in resource-deprived environments, or for small utility programs (e.g., invoked repetitively in shell scripts), that static overhead can be too much to bear. Moreover, there aren't that many practical situations where you need a high-performance RTTI, most of the time you don't need it at all, and at other times you need it in a few special places that are usually not performance-critical in comparison to other things. LLVM is an exception here because writing a compiler involves dealing with abstract syntax trees and similar descriptive class hierarchies, which is hard to do without lots of down-casting, and since analysing these structures is the core operation that compilers do, performance of the down-casts (or other RTTI invocations) is critical. So, don't take the ""don't use the RTTI"" as a general rule, just know what overhead it entails, and know if it is acceptable for your application in terms of its cost / benefits. </p>

<p>C++ exceptions are certainly next on the list of things that could have more overhead than you would be prepared to bargain for. This is a much more controversial issue, particularly when it comes to actually characterising the overhead of exceptions overall. Evaluating the overhead of exceptions empirically is a very difficult task because it is highly dependent on usage patterns, i.e., there are different ways to use exceptions, different levels of severity (Do you use exceptions for bugs, fatal errors, exceptional conditions, or to replace every if-statement?), and there are different levels of care for error-handling (whether with or without using exceptions). And then, of course, different compilers can implement exceptions differently. The current implementations, so-called ""zero-cost exceptions"", is geared towards having zero run-time cost during normal execution, but that leaves quite a bit of static overhead and makes throw-to-catch execution path slower. <a href=""http://mortoray.com/2013/09/12/the-true-cost-of-zero-cost-exceptions/"" rel=""noreferrer"">Here</a> is a nice overview of that. As far as exceptions being in violation of the ""you only pay for what you use"" principle, it is true (unless you disable them), but they are often justifiable. The basic assumption with exceptions is that you, as a programmer, intend to write robust error-handling code, and if you do handle all errors appropriately, then the overhead of exceptions will pale in comparison to the error-handling code (catch-blocks and destructors), and you will probably have a smaller and faster program than an equivalent C-style error-code implementation of the same amount of error-handling. But if you don't intend to do much error-handling (e.g., the ""if anything goes wrong, just crash!"" approach), then exceptions will incur significant overhead. I'm not exactly sure why LLVM banned exceptions (if I had to be blunt, I would say it's because they aren't really serious about error-handling, as far as I can see from the code I have seen from that project). So, long story short, the guideline should be ""if you intend to seriously handle errors, use exceptions, otherwise, don't"". But remember, this is a hotly debated topic.</p>

<blockquote>
  <p>Are there any other such features which violate ""you only pay for what you use""?</p>
</blockquote>

<p>You have named to two obvious ones, and unsurprisingly, they are the two main features that most compilers have options to disable (and are often disabled when it is appropriate to do so). There are certainly other more minor violations of the zero-overhead principles.</p>

<p>One notorious example is the IO-stream library (<code>&lt;iostream&gt;</code>) from the standard library. This library has often been criticized for having too much overhead for what most people need and use it for. The IO-stream library tends to pull in a lot of code, and require quite a bit of load-time initialization. And then, many of its classes like <code>std::ostream</code> or <code>std::ofstream</code> have too much run-time overhead, both for construction / destruction and for read/write performance. I think they packed a bit too many features into that library, and since most of the time, IO-streaming tasks are very simple, those features are often left unused and their overhead unjustified. But generally, I find the overhead is often acceptable, especially since most IO tasks are already very slow regardless. BTW, LLVM also bans the use of the IO-stream library, and again, that is because the target of LLVM is for writing lean and mean command-line utilities that do a lot of file IO (like a compiler or its related tools).</p>

<p>There might be other standard libraries that have more overhead than some might wish to have for particular situations. Library code often has to make compromises that fall somewhere that won't please everyone. I would suspect that some of the newer libraries like thread, chrono, regex, and random, provide a bit more features or robust guarantees than are necessary in many applications, and therefore, pull in some undue overhead. But then again, many applications do benefit from those features. This is the very meaning of compromise.</p>

<p>As for language rules that put undue overhead, there are many small issues that impose some overhead. For one, I can think of several places where the standard has to make conservative assumptions that prevent optimizations. One notable example is the inability to <a href=""http://en.wikipedia.org/wiki/Restrict"" rel=""noreferrer"">restrict</a> pointer aliasing, which forces compilers to assume that any memory could be aliased by any pointer (even though, in practice, pointer aliasing is rare), limiting the opportunities for optimization. There are many similar cases where the compiler has to make the ""safe"" assumption, limiting optimizations. But most of these are rather small in scope and potential benefits, and they are often justified in terms of being able to guarantee correctness of the behaviour (and repeatability, robustness, portability, etc.). Also, note that in the vast majority of those cases, it doesn't really get any better in other languages, maybe marginally better in C, but that's about it. Some of those issues can also be circumvented with compiler extensions or platform-specific features, or as a last resort, with inline assembly code, that is, if you really need to optimize down to that level.</p>

<p>One example that is no longer valid is the problem of requiring the compiler to produce exception-handling (stack unwinding) code even for functions that will never throw. Now, that can be solved by specifying <code>noexcept</code> on the functions in question.</p>

<p>But other than those microscopic issues, I can't really think of any other major source of undue overhead in C++ (aside from RTTI and exceptions). I mean, there are things in C++ that can create overhead of different kinds, but they are all ""opt-in"" features (per-use) like virtual functions, virtual inheritance, multiple inheritance, templates, etc... but those mostly obey the ""you only pay for what you use"" principle. For an example of the rules imposed for a low-overhead subset of C++, check out <a href=""http://en.wikipedia.org/wiki/Embedded_C%2B%2B"" rel=""noreferrer"">Embedded C++</a>.</p>
",3
33513265,23824570,1,"<p>My functional programming solution</p>

<pre><code>def product(number):
    product_result = 1
    for n in number:
        product_result *= int(n)
    return product_result

length = 13
indices = range(0, len(number) - 13 + 1)
values = indices
values = map(lambda index: {""index"": index, ""number"": number}, values)
values = map(lambda value: value[""number""][value[""index""]:value[""index""] + length], values)
values = map(product, values)
values = max(values)
print values
</code></pre>
",0
23825223,23824570,6,"<p>9^13 ¡Ö 2.54e12 (maximal possible value, needs 42 bit to be represented exactly), which doesn't fit into <code>signed int</code>. You should use int64.</p>
",0
23824843,23824570,27,"<p>In fact your solution is too small rather than too big. The answer is what was pointed out in the comments, that there is integer overflow, and the clue is in the fact that your solution is close to the largest possible value for an signed int: 2147483647. You need to use a different type to store the product.</p>

<p>Note that the answer below is still 'correct' in that your code does do this wrong, but it's not what is causing the wrong value. Try taking your (working) code to <a href=""http://codereview.stackexchange.com"">http://codereview.stackexchange.com</a> if you would like the folks there to tell you what you could improve in your approach and your coding style.</p>

<h2>Previous answer</h2>

<p>You are checking for a new greatest product inside the inner loop instead of outside. This means that your maximum includes all strings of less or equal ton 13 digits, rather than only exactly 13.</p>

<p>This could make a difference if you are finding a string which has fewer than 13 digits which have a large product, but a 0 at either end. You shouldn't count this as the largest, but your code does. (I haven't checked if this does actually happen.)</p>

<pre><code>for (int i=0; i &lt; num.length() -12; i++)
{
    product = ((int) num[i] - 48);
    for (int j=i+1; j&lt;i+13; j++)
    {
        product = product * ((int) num[j] - 48);
    }
    if (greatestProduct &lt;= product)
    {
        greatestProduct = product;
    }
}
</code></pre>
",2
25466704,25466688,3,"<p>The second parameter is the underlying container that the queue uses.</p>

<p>The <code>priority_queue</code> template is a <em>container adaptor</em>. That is, it doesn't provide dynamic storage itself, but rather, it <em>adapts</em> an existing container to provide the desired interface.</p>

<p>(The interface for a priority queue is implemented in terms of the <code>make_heap</code>/<code>push_heap</code>/<code>pop_heap</code> algorithms from the standard library, and the underlying container needs to have suitable iterators.)</p>
",0
28217849,28217789,2,"<p>You should let the compiler help you by declaring data variables as constants by adding the <code>const</code> modifier. For example, change <code>double de = emax/N;</code> to <code>const double de = emax/N;</code>. The compiler will throw an error if the value of <code>de</code> changes.</p>

<p>Your program is crashing at <code>80 k[n-1][i] += 2.0*F[n-1][i];} //append 2*k2 to k1</code>. You can compile your program with debugging symbols <code>g++ -g -o test &lt;your program&gt;.cpp</code> and use gdb/lldb to debug it <code>gdb ./test</code> and <code>r</code>. It will show you where your program crashes.</p>
",2
28218406,28217789,0,"<p>There are couple of places you made the mistake of ending the loop too soon but letting the loop variable be used beyond the loop.</p>

<pre><code>RHS(t + 0.5*dt, Y, F); //calculate k2
for (n=1;n&lt;=N;n++){
    for (i=0;i&lt;=2;i++){
        k[n-1][i] += 2.0*F[n-1][i];} //append 2*k2 to k1

        // Ending the loop above
        // Now i = 3. That's accesssing the array out of bounds.
        Y[n-1][i] = y[n-1][i] + 0.5*F[n-1][i]; //calculate y for k3
}

RHS(t + 0.5*dt, Y, F); //calculate k3
for (n=1;n&lt;=N;n++){
    for (i=0;i&lt;=2;i++){
        k[n-1][i] += 2.0*F[n-1][i];} //append 2*k3 to k1

        // Same mistake again.
        // Ending the loop above
        // Now i = 3. That's accesssing the array out of bounds.
        Y[n-1][i] = y[n-1][i] + F[n-1][i]; //calculate y for k4
}
</code></pre>

<p>Change those loops to:</p>

<pre><code>RHS(t + 0.5*dt, Y, F); //calculate k2
for (n=1;n&lt;=N;n++){
  for (i=0;i&lt;=2;i++){
     k[n-1][i] += 2.0*F[n-1][i]; //append 2*k2 to k1
     Y[n-1][i] = y[n-1][i] + 0.5*F[n-1][i]; //calculate y for k3
  }
}

RHS(t + 0.5*dt, Y, F); //calculate k3
for (n=1;n&lt;=N;n++){
  for (i=0;i&lt;=2;i++){
     k[n-1][i] += 2.0*F[n-1][i]; //append 2*k3 to k1
     Y[n-1][i] = y[n-1][i] + F[n-1][i]; //calculate y for k4
  }
}
</code></pre>

<p>and all should be well.</p>
",1
28217896,28217789,1,"<p>You are going out of bounds of your arrays:</p>

<pre><code>for (int m=0;m&lt;=M;m++){   
Ne = ReP = ImP = 0.0;
for (n=1;n&lt;=N;n++){
....
</code></pre>

<p>overwriting other variables, in this case <code>de</code>.</p>
",1
28217945,28217789,1,"<p>use <strong>const</strong> Qualifier before declaring the variable 
eg:</p>

<p>const int de = value; // changing de after this would cause compiler warnings/error.</p>
",0
28452046,28451680,0,"<p>I think the problem lies here:</p>

<pre><code>std::cin.get();
std::cin.get(ch);
</code></pre>

<p>If there was indeed a character, the first <code>get</code> will clean the newline, and the second will perform another read.</p>

<p>If there was no character to begin with, the first <code>get</code> will consume the actual input, and <code>ch</code> end up as a newline.</p>

<hr>

<p>A solution to that is: don't treat input as valid if you're not sure it's valid. In particular, you're expecting two characters of input: any character except newline followed by newline.</p>

<p>There are two rather simple ways to solve your problem:</p>

<ul>
<li>Don't use characters: simply work on <code>std::string</code> and treat empty string as invalid.</li>
<li>Check if the first character was a newline and <em>don't</em> skip an additional character then.</li>
</ul>

<hr>

<p>A more advanced solution would be to experiment more with functions. Could you wrap the input to return <code>optional&lt;char&gt;</code>? Or even better, <code>optional&lt;Choice&gt;</code>, where <code>Choice</code> is an <code>enum class</code>?</p>

<p>Or perhaps you could create a function that loops automatically, prompting for a proper input every time, and separate it from the main program logic?</p>
",4
22867112,22866795,6,"<p>Your factorization algorithm needs to pick between <code>C</code> and <code>A</code>, because at the end of the process <code>A</code> contains the remainder, which is also a factor of the original <code>A</code>. If it happens to be the largest one, your code would miss it.</p>

<pre><code>if (A &gt; C) {
    C = A;
}
</code></pre>

<p>Once you make this modification, your code produces the correct answer (<a href=""http://ideone.com/OduLJA"" rel=""nofollow"">demo</a>).</p>

<p>Note: now that your program is running, you may consider a few modifications:</p>

<ul>
<li>Trying out potential divisors until you reach <code>A/2</code> is inefficient; you can stop at the square root (do you see why?)</li>
<li>Checking for primality is not required in the way that you have structured your program</li>
<li>Checking for primality by trying out all numbers, i.e. the way the math definition goes, is grossly inefficient: you are trying out too many divisors that are guaranteed to not work. Again, you can stop at the square root. If you start at 2, not at 1, stop at the square root, and find no divisors, the number is prime.</li>
</ul>
",1
22869689,22869459,0,"<p>I found three problems with your code, both are similar to each other
1. in <code>loopfactorial()</code>, <code>value=1</code> should be defined before the loop body
2. in <code>main()</code>, <code>sum=1.0</code> should be defined before the loop body
3. in <code>loopfactorial()</code>, loop variable <code>a</code> should have been initialized with either 1 or 2 instead of 0.</p>
",2
22869771,22869459,1,"<p>For reference and the benefit of future readers, here's the ""correct"" code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main()
{
    unsigned int terms;
    if (!(std::cout &lt;&lt; ""Number of terms: "" &amp;&amp; std::cin &gt;&gt; terms))
    {
        std::cout &lt;&lt; ""Error, I did not understand you.\n"";
        return EXIT_FAILURE;
    }

    double e = terms &gt; 0 ? 1.0 : 0.0, term = 1.0;
    for (unsigned int n = 1; n &lt; terms; ++n)
    {
        term /= n;
        e += term;    // this is ""e += 1/n!""
    }

    std::cout &lt;&lt; ""e is approximately "" &lt;&lt; e &lt;&lt; ""\n"";
}
</code></pre>

<p>(The code can be trivially extended to compute <em>e</em><sup><em>x</em></sup> for any <em>x</em>.)</p>
",4
22869561,22869459,0,"<p>You should move the variable initializations out of the loops - you're resetting them over and over.</p>

<p>Side note: it's rather pointless to put <code>loopfactorial</code> in a class.</p>
",0
22869576,22869459,0,"<p>Try moving your initial values outside the loop:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;

class factorial
{
public:
double loopfactorial ( double y)
    {

        double value;
        // MOVED INITIAL VALUE HERE
        value=1;
    for (int a=1; a&lt;=y; a++)
        {
            value = value*a;
        }
        return value;
    }
};


int main()
{
factorial calcu;
int x;
double sum;
cout&lt;&lt;""Enter the number of terms to approximate exponent:""&lt;&lt;endl;
cin&gt;&gt;x;

// MOVED INITIAL VALUE HERE
sum=1.0;
for (int y=1; y&lt;=x-1; y++)
{
int n = calcu.loopfactorial(y);

sum = sum + 1/n;
}

cout&lt;&lt;""The value of e is ""&lt;&lt;sum&lt;&lt;endl;
    return 0;
}
</code></pre>
",4
28203099,28202817,1,"<p>Use something like a <code>std::map&lt;std::string, std::function&lt;System(T)&gt; ctorMap;</code> where <code>T</code> is the type of <code>Input::getNrWheels</code>, inside <code>Factory</code> to hold the appropriate constructors, indexed by strings. Also provide a method, say <code>Factory::Register(std::string, std::function&lt;System(T))</code> which any class can use to register its constructor. So, the TU which defines <code>Airplane</code> should ensure that there is a call, during static initialization, for example, <code>Factory::Register(""Airplane"", std::make_function(&amp;Airplane::Airplane))</code>.</p>

<p>Also, <code>Factory::build</code> would now look like this:</p>

<pre><code>System&amp; build(const Input&amp; input) {
     return ctorMap[input.getType()](input.getNrWheels);
    }
</code></pre>
",5
28203134,28202817,0,"<p>Cut it out completely. The Factory class serves literally no benefit at all when it can only create one kind of thing. Just use a typedef instead to be flexible about what kind of System you are creating.</p>
",1
22889066,22888977,-1,"<p>This parses as <code>*((repetitions + x)++)</code> -- that is, it tries to modify a constant address, then dereference it. Presumably you intended increment what the address pointed at instead.</p>

<p>You can do that a couple different ways. One would be to use parentheses. Another to use pre-increment:</p>

<pre><code>++*(repetitions + x);
</code></pre>

<p>or:</p>

<pre><code>(*(repetitions + x))++;
</code></pre>
",2
22889078,22888977,1,"<p>You can't increment the rvalue <code>repetitions + x</code>. This is the same error as writing:</p>

<pre><code>int a = 3;
int b = 2;
(a+b)++;     // ????
</code></pre>

<p>The <code>++</code> operator requires an lvalue, i.e. the designation of a variable. <code>a+b</code> is a temporary result and doesn't have a memory address, it can't be incremented.</p>

<p>It's possible that you meant to write <code>(*(repetitions + x))++;</code>, which could be more clearly expressed as <code>repetitions[x]++;</code></p>
",0
26413611,26413599,2,"<p>You should be entering <code>std::string</code>s not <code>char</code>s. Change</p>

<pre><code>char name, email, address;
</code></pre>

<p>To</p>

<pre><code>string name, email, address;
</code></pre>

<p><strong>Why did it seemingly skip your 2nd and 3rd <code>cin</code> prompts?</strong></p>

<p>You used <code>std::cin</code> to read the input from the stream. During the first prompt, you entered <code>""chrys""</code>, which added 5 <code>char</code>s to the stream.</p>

<p>If you followed the operations of <code>cin</code> you basically had:</p>

<pre><code>name = 'c'
email = 'h'
address = 'r'
</code></pre>

<p>If you would have used <code>getch()</code> for example, this would have been obvious. If you were set on <code>char</code> you would have had to use the C-like method of reading into a <code>char[]</code>, but since this is C++, <code>std::string</code> is a much better option for your case. </p>
",10
21598920,21598822,1,"<p>You can use headers.
app1.h:</p>

<pre><code>class s1
{
    private:
        int gx;

    public:
        int gx(int x,int y)
        {
            gx = x;
        }
};
</code></pre>

<p>app2.cpp:</p>

<pre><code>#include""app1.h""
//...
</code></pre>

<p>also the file app1.h should be with your compiled file<br>
or else add address like    </p>

<pre><code>#include ""D:\app1.h""
//...
</code></pre>

<p>if  your file app1.h is in D: drive</p>
",0
21598943,21598822,0,"<p>First, it is <strong>very</strong> bad style to include a cpp file. In theory, you could write all the code from app_core.cpp into a header such as app_core.h. While this works in most cases, it can lead to unnecessarily long compile times.
If you really want to do it, though, you have to leave out the <code>class s1;</code> from both .cpp files.</p>

<p>If the split between header and source is what you meant by the ""messy code"", then I'm sorry but no, there is no general way to achieve that.</p>
",2
21598966,21598822,0,"<p>Build a header file.</p>

<p>app1.h</p>

<pre><code>class s1
{
    private:
        int gx;

    public:
        int gx(int x,int y)
};
</code></pre>

<p>app1.cpp</p>

<pre><code>#include ""app1.h""

int s1::gx(int x,int y)
{
    gx = x;
}
</code></pre>

<p>app2.cpp</p>

<pre><code>#include ""app1.h""
// your code that calls s1 methods
</code></pre>
",0
21598972,21598822,0,"<p>I think this could solve your ""problem"": put your class in a header, and implement it <em>in the header</em> (this is called, e.g. for libraries ""header-only"").</p>

<pre><code>#ifndef CLASS1_H
#define CLASS1_H

class s1
{
    private:
        int gx;

    public:
        int gx(int x,int y)
        {
            gx = x;
        }
};
#endif //CLASS1_H
</code></pre>

<p>Then, just <code>#include ""Class1.h""</code> in every needed <code>.cpp</code>.</p>

<p>There, one class in one file (no separation of declaration and implementation). Just do note that while sometimes convenient, using ""header-only"" code has its drawbacks:</p>

<ul>
<li><p>The implementation is now tied to the declaration, which means that any change to the implementation will imply that you must re-compile the code that includes this header.</p></li>
<li><p>Compilation will take more time, because the compilation unit must see every implementations in the translation unit, rather than just the interfaces.</p></li>
</ul>

<p>Contrary to your belief, having one header and one implementation file isn't messy. It has its advantages, and is a widely used practice. But yeah, one of its drawbacks is that you have to manage two files.</p>
",0
21599121,21598822,2,"<p>In C++ when you #include something, the included file is more or less ""pasted"" in the place of that directive.</p>

<p>There's a concept called <strong>translation unit</strong> which indicates a code unit which gets compiled and might, in the future, be referenced by other units (at linking time).</p>

<p>What you want is to write a translation unit and give other translation units the information on how to access that data. That is the purpose of a <strong>header file</strong>.</p>

<p>A .h file (.h by convention, you might call it whatever you like) is a set of declarations like</p>

<p>File s1class.h</p>

<pre><code>class s1
{
    private:
        int gxd;

    public:
        int gx(int x,int y)
        {
            gxd = x;
            return x;
        }
};
</code></pre>

<p>and</p>

<p>app1.cpp:</p>

<pre><code>#include""s1class.h""

//... use s1 class
</code></pre>

<p>app2.cpp:</p>

<pre><code>#include""s1class.h""

//... use s1 class
</code></pre>

<p>Just notice one thing: you should <strong>never</strong> violate the <a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow"">One Definition Rule</a>, you can declare as many times as you want something (as long as they're consistent declarations) but you CANNOT define more than once a symbol (e.g. a function). (small note: #pragma once directives and similar stuff can help you avoid re-declaring symbols more than once and make your life easier when including a header multiple times in multiple places).</p>

<p>So in the above code the ""gx"" function is defined into your header file.. that function should exist just once per translation unit where it is used.</p>

<p>In that particular case it is used to create the translation units for app1.cpp and app2.cpp. It should violate the ODR, right? It won't instead since a member function for a class is <strong>implicitly inlined</strong>, that means it is ""stitched"" into the caller's body thus being integrated part of the caller's identity.</p>

<p>The alternative is to just <strong>declare</strong> stuff in the header file and <strong>implement them</strong> in a related cpp file:</p>

<p>s1class.h</p>

<pre><code>#pragma once

class s1
{
private:
  int gxd;

public:
  int gx(int x,int y);
};
</code></pre>

<p>s1class.cpp</p>

<pre><code>#include ""s1class.h""

int s1::gx(int x,int y)
{
  gxd = x;
  return x;
}
</code></pre>

<p>and proceed as above: by just including the header file in order to use it at link time (when the symbols are resolved).</p>
",4
21570444,21570187,2,"<p>You need to reset <code>x</code> in your loop - right now, once the condition of <code>x &gt;= exp(-3)</code> becomes false the code will never call the <code>mt()</code> function to get another random number.</p>

<pre><code>for(int i=0;i&lt;simNum;i++)
{


    while(x&gt;=exp(-3))
    {

        x*=mt();

        k++;
    }


    fout&lt;&lt;i&lt;&lt;"",""&lt;&lt;x&lt;&lt;"",""&lt;&lt;k-1&lt;&lt;endl;

    x = 1; // &lt;-- reset x

}
</code></pre>
",0
21581734,21581662,2,"<p><code>coords.at(0)</code> returns a <code>char</code>, not a <code>char*</code>. Try to parse your std::string first, transform each number at a <code>char*</code>, and so, you use <code>atoi</code>.</p>
",0
31128334,31128308,11,"<p><code>c</code> is always 1 no matter what. The loop becomes infinite. Eventually, <code>X</code> becomes <code>0</code> due to integer overflow.</p>

<pre><code>c = 1
c *= 2; c = 2
c++; c = 3
c -= 2; c = 1 &lt;-- infinite
</code></pre>
",12
31128399,31128308,1,"<p>Removing the pause doesn't cause it to <em>always</em> show zero.  It just prints output so quickly that zeroes are all you see at the bottom.  Add the pause back in and click through about 30-40 iterations and see if it helps you understand what is happening.</p>
",0
31128489,31128308,4,"<p>Here is my answer for your questions:</p>
<ol>
<li><p>Why do you get infinitely looping?</p>
<p>awesomeyi did answer you above, because the condition of the while loop is always true, so it is never ended.</p>
</li>
<li><p>Why does X always equal to 0?</p>
</li>
</ol>
<p>Please pay your attention on X varable, its value will be increased after ending one loop x += x*c. Because you are in the infinitely loop, x's value will be increased forever until greater than the limited value of an integer variable. Then, the value will be set as zero. Please see my output when running your code.
<img src=""https://i.stack.imgur.com/Tupve.png"" alt=""enter image description here"" /></p>
",0
28250610,28250550,1,"<p>Please formulate your question better. What do you mean with </p>

<blockquote>
  <p>I have one equation where I have to decrement ""theChar"" equation, or
  the one with ""int var"" by -2</p>
</blockquote>

<p>Do you mean:</p>

<pre><code>char x = 'a';
x = x + 3; //now x is 'd'
int var = 10; 
var -= 2; //equal to var = var -2; 
</code></pre>
",0
28250611,28250550,-1,"<p>The equations are not equations in a math sense of equation.</p>

<p>The <code>=</code> sign tells the computer to store whats on the right side into the variable that is on the left side.</p>

<pre><code>int a;
a = 5;
</code></pre>

<p>this stored the <code>5</code> into <code>a</code> once.</p>

<pre><code>int a, b;
a = 5;
b = a;
a = 6;
</code></pre>

<p><code>b</code> is still <code>5</code> because when it was stored it copied from <code>a</code>. When <code>a</code> changed <code>b</code> was not recalculated but stayed as it was.</p>

<pre><code>int a;
a = 5;
a = a - 2;
</code></pre>

<p><code>a</code> is now beeing decremented by <code>2</code> since <code>a</code> was set to <code>5</code> when the right side ( <code>a - 2</code> ) is calculated it is calculated to be <code>3</code>. When that is done it gets written to the left side which happens to be <code>a</code> so at this point <code>a</code> is overwritten with <code>3</code>;</p>

<pre><code>char c = 'B';
c = c - 1;
</code></pre>

<p><code>c</code> has a value of <code>'A'</code> at the end of this code. There is some behind the scenes magic going on.
Characters are also numbers. So what really happens when i store <code>'B'</code> into the variable the computer actually stores <code>66</code>. You can read up on that <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">here</a>. When i decrement by one the value is decremented from <code>66</code> to <code>65</code>. The character with the number <code>65</code> happens to be <code>'A'</code>.</p>

<p>I read in the comments that you have trouble putting it all into a program.
I went ahead and wrote a code snippet for you.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    int a, b;
    char c;

    //cout is like a friend that you give something to put on the console
    // &lt;&lt; means give this to cout
    cout &lt;&lt; ""Hello World!"" &lt;&lt; endl; //endl is a new line character

    cout &lt;&lt; endl &lt;&lt; ""Setting a, b"" &lt;&lt; endl;
    a = 5;
    b = a;
    cout &lt;&lt; ""Value of a is "" &lt;&lt;  a &lt;&lt; "". ""  &lt;&lt; ""Value of b is "" &lt;&lt; b &lt;&lt; ""."" &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; ""Changing a"" &lt;&lt; endl;
    a = 3;
    cout &lt;&lt; ""Value of a is "" &lt;&lt;  a &lt;&lt; "". ""  &lt;&lt; ""Value of b is "" &lt;&lt; b &lt;&lt; ""."" &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; ""Adding to a"" &lt;&lt; endl;
    a = a + 3;
    cout &lt;&lt; ""Value of a is "" &lt;&lt;  a &lt;&lt; "". ""  &lt;&lt; ""Value of b is "" &lt;&lt; b &lt;&lt; ""."" &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; ""Playing around with characters"" &lt;&lt; endl;
    c = 'B';
    cout &lt;&lt; ""Character c is "" &lt;&lt;  c &lt;&lt; "". ""  &lt;&lt; ""Number stored for c is actually "" &lt;&lt; (int)c &lt;&lt; ""."" &lt;&lt; endl;

    c = c + 1;
    cout &lt;&lt; ""Character c is "" &lt;&lt;  c &lt;&lt; "". ""  &lt;&lt; ""Number stored for c is actually "" &lt;&lt; (int)c &lt;&lt; ""."" &lt;&lt; endl;

    c = 70;
    cout &lt;&lt; ""Character c is "" &lt;&lt;  c &lt;&lt; "". ""  &lt;&lt; ""Number stored for c is actually "" &lt;&lt; (int)c &lt;&lt; ""."" &lt;&lt; endl;
}
</code></pre>
",1
22448705,22447226,1,"<p>The problem is, that ""%"" is a string and not a character. In C/C++, this means that you're silently also getting a string termination. Try using '%'.</p>
",3
32441466,32441417,3,"<p>You're returning <code>totalMonsterHealth</code> in</p>

<pre><code>if(battleChoice =='A' || battleChoice == 'a')
</code></pre>

<p>So when the user hits <code>A</code> or <code>a</code> it will exit the loop</p>
",2
30213243,30213218,5,"<p>By the time you end the initialization loop, your x is pointing beyond the last allocated element. Before second forloop you need to readjust x to point to start of memory</p>

<pre><code>x -= 10;
</code></pre>

<p>Even better would be to keep your walking pointer as a copy</p>

<pre><code>int *xcopy = x;
for(int i =0; i &lt;10; ++i){
    *xcopy = 1;
    xcopy++;
}
</code></pre>

<p>Or use indexing to update the value</p>

<pre><code>for(int i =0; i &lt;10; ++i){
    x[i] = 1;
}
</code></pre>
",0
30213260,30213218,4,"<p>You're incrementing <code>x</code> in the first loop, so after that it points past the end of the array. The second loop uses that new value to read from memory beyond the end, giving undefined behaviour.</p>

<p>The best option is to stop juggling pointers, with the bonus feature of fixing the memory leak:</p>

<pre><code>std::vector&lt;int&gt; x(10, 1);
for(size_t i = 0; i &lt; x.size(); ++i) {
    std::cout&lt;&lt;i&lt;&lt;"" is ""&lt;&lt;x[i]&lt;&lt;std::endl;
}
</code></pre>

<p>Otherwise, you could assign to <code>x[i]</code> rather than <code>*x</code> in the first loop and leave <code>x</code> unmodified; or you use a copy of the pointer, or undo the modification after the loop.</p>
",1
30213303,30213218,3,"<p>Your code has undefined behavior, as you're accessing some random memory (you have changed <code>x</code>).</p>

<p>You should not change <code>x</code> (the pointer). Instead, you can use <code>x[ i ] = 1;</code> or use some other temp pointer to ""loop over"" x.</p>

<p>You can also decrement <code>x</code>, as @Mohit Jain states, but I wouldn't recommend changing where <code>x</code> points at all.</p>
",0
22518407,22518353,0,"<p>I think you are confusing between the two.</p>

<p>There is a difference between a <code>local variable</code> and a <code>local static variable</code>. The former's life is till the <code>function</code> exits (allocated on the stack) where as the later exists till your <code>program</code> exits (allocated in the <code>Global/Static</code> area of your program memory).</p>
",2
22518472,22518353,0,"<p>Local static variables will get initialized only the first time. I don't think there is anything wrong with using a local static variable if you have the need for it.</p>

<p>Say, you need a particular thing to happen only once even though the the method can get called multiple times.</p>

<pre><code>void foo()
{
    static bool bFoo = false;
    if (!bFoo)
    {
        Foo2();
        // Do something only once.
        bFoo = false;
    }
}

foo();
foo();
</code></pre>

<p>Calling the method more than once will only call the Foo2() method the first time and not the second.</p>
",1
22518474,22518353,0,"<p>A local static variable is not allocated on the stack and its life is from when you enter the scope where it's defined to the end of the program.</p>

<p>Sometimes they're used for lazy-initialized objects or for caching results.</p>
",0
22519158,22518353,0,"<p>Local variable are allocated on the stack, so they are new each time you enter the function. This could be called ""reentrant-compatible"" and hence these can be used for multi-thread and recursive functions without any worries.</p>

<p>Static variables, on the other hand, have ONE allocation. So if you call the same function multiple times, you will see a single version of that variable. This is not considered reentrant since modifying that value has side effects that may not be what you'd otherwise expect.</p>

<p>One side note about multi-thread processes and local static variables: the first time you enter a function that has a static variable, it gets initialized under your feet, before any instructions of your code is executed. This means you have no means at all to protect that code from getting executed by more than one thread.</p>

<p>All that said, you should generally ask yourself: why would I want to use a static variable? And not the other way around (i.e. why should I not use it). There are a very few cases when it is useful. In most other cases, it is useless and should be avoided to avoid potential problems.</p>

<p>One place where it is often used is a singleton instance retrieval function:</p>

<pre><code>my_object *get_instance()
{
    static my_object *singleton(NULL);

    if(singleton == NULL)
    {
        singleton = new my_object;
    }

    return singleton;
}
</code></pre>

<p>This works, although frankly I stopped using it in my C++. I now put the singleton variable in a so called ""static"" variable as in:</p>

<pre><code>namespace
{
    my_object *singleton = NULL;
}

my_object *get_instance()
{
    if(singleton == NULL)
    {
        singleton = new my_object;
    }

    return singleton;
}
</code></pre>

<p>The reason for doing that is that way the singleton variable is initialized at startup time, instead of the first time the function is called. Pushing it a little further, you can place the variable in your class as a static variable member. As far as I know that's not any different from having it in a name-less namespace.</p>

<p>IMPORTANT NOTE: If you create a (large) static const local array, know that the first time you call the function, it will build the array ""by hand"", in INTEL assembly, something like this:</p>

<pre><code>   lea pointer, %ecx
   mov 12345678, %eax
   mov %eax, (%ecx)
   mov 12345678, %eax
   mov %eax, (%ecx)
   mov 12345678, %eax
   mov %eax, (%ecx)
   mov 12345678, %eax
   mov %eax, (%ecx)
   mov 12345678, %eax
   mov %eax, (%ecx)
   ...
</code></pre>

<p>It's going to be slow and possibly HUGE. It is a lot better to put your [static] const array in your no name namespace and use that pointer. Then all that code disappears and you get a pre-initialized array directly loaded from disk at start time. (Obviously, if you create a large const array in a non-static local variable, you will get the same sort of code and in that case you'd want it static so it gets initialized only once, but then you realize you can put it in your no name namespace, and can optimize even more!)</p>

<p>Note that some people mentioned recursive functions as being a place where you probably don't want a static variable. I will now give you a case where you could use it and avoid ""wasting"" stack space. However, do NOT use that if you intend to make your software multi-threaded because in that case it would not work (not without some extra work and as I said before, in a multi-thread environment you cannot control the initialization of your static local variables.)</p>

<pre><code>int recursive(int value)
{
    static int depth(0);

    if(depth &gt; 100)
    {
        std::cerr ""too many recursive calls, dying!\n"";
        exit(1);
    }

    ++depth;
    [...]
    if(special-case)
    {
        r = recursive(other_value);
        [...]
    }
    [...]
    --depth;
    return result;
}
</code></pre>

<p>In this case you use a static variable which allows you to work in a simple recursive function and know if it calls itself too many times and breaks (exits here) if the recursion happens too much.</p>

<p>What I mean by ""simple recursive function"" is a function which cannot be called more than once for the computation it needs to do. (i.e. if it creates an object that calls that function anew, the depth parameter won't work as expected since it was go back to zero automatically!)</p>

<p>In most cases, however, it is easier and a lot safer to pretty much always avoid static local variables.</p>
",0
22518740,22518353,0,"<p>The biggest issue that I had with static variables was to force the proper initialization order. When you have very big project with many compilation units it's always good to be aware of that problem. </p>

<p>More info here - <a href=""https://stackoverflow.com/questions/211237/static-variables-initialisation-order"">Static variables initialisation order</a>.</p>
",0
28313364,28312612,0,"<p>As has been rather poignantly identified what you are looking for is <code>next_permutation</code> You could do something like this:</p>

<pre><code>void printPermutations(const string&amp; word){
    sort(word.begin(), word.end());

    cout &lt;&lt; ""1. "" &lt;&lt; word &lt;&lt; endl;

    for(int i = 2; next_permutation(word.begin(), word.end()); ++i){
        cout &lt;&lt; i &lt;&lt; "". "" &lt;&lt; word &lt;&lt; endl;
    }
}
</code></pre>
",0
23817755,23817711,2,"<p>The problem is in your while loop:</p>

<pre><code>while(c &gt; 20)
{
  d+=1;
  c=c-20;
  break;
}
</code></pre>

<p>The loop will only execute once because of your break statement.</p>
",3
34193190,34193087,0,"<p>s_function is a member of the class fun, so the correct way to do this would be:</p>

<pre><code>bool s_function(std::string s)
{
}
</code></pre>

<p>and then call it as:</p>

<pre><code>x.s_function(s);
</code></pre>

<p>which will return a bool that you can work with</p>

<p>Otherwise, the first file has no idea that the string s exists in the second file, which is because s has a local scope (which means it gets created when main is called and deleted when main ends, but doesn't exist outside of that time period). </p>

<p>Passing it to s_function will create a copy for s_function to work with. However, s_function wont actually be able to modify the string s declared in main() because it actually has a copy. (In order to change the one in main, it would need to be passed by reference.)</p>

<p>Hope that helps.</p>
",2
26209143,26209090,3,"<p>You're right in your first attempt. A variant can be seen here:</p>

<pre><code>Animal cat(""silvester"");
Animal dog(""fido"");
cat = dog;
</code></pre>

<p>In your second example, you're actually taking the address of ""Dog,"" and assigning it to a non-pointer type (Animal). The second version won't compile, because the types don't match.</p>

<p>The difference is huge. We're talking about objects, and pointers to objects. The value of a pointer is an address in memory, while the value of an object is the object's data itself.</p>
",0
26209244,26209090,0,"<p>Both those statements are examples of <a href=""http://en.cppreference.com/w/cpp/language/copy_initialization"" rel=""nofollow"">copy initialization</a>. The constructor matching the type of the expression on the rhs of the equals is what gets picked. So, your question really is about how to pass arguments to a function accepting them by reference. The answer is that it looks exactly like it would if you are passing by value. The <code>&amp;</code> Prefix takes the address of the variable and is used when you are passing a pointer to the function. So, if your <code>Animal</code> had a constructor like this <code>Animal::Animal(Animal*)</code>, it would be picked by the call <code>Animal Cat = &amp;Dog</code>.</p>
",0
28210725,28210654,1,"<p>You need to use <code>wvsprintf</code> with <code>va_list</code>, instead of <code>wsprintf</code>:</p>

<pre><code>va_list args;
va_start(args, format); 
wvsprintf(formatted, format, args);
va_end(args);
</code></pre>

<p>With C++11, you may do instead (with <code>wsprintf</code>):</p>

<pre><code>template &lt;typename...Ts&gt;
void ScriptPrint(const wchar_t* format, Ts&amp;&amp;...args) {
    wchar_t formatted[1024] = {0};
    wsprintf(formatted, format, std::forward&lt;Ts&gt;(args)...);

    std::wstring ret = L""print \"""";
    ret += formatted;
    ret += L""\"""";

    ExecuteMAXScriptScript(ret.c_str());
}
</code></pre>
",0
28442554,28442484,0,"<p>1) t<strong>YE</strong>p5 != type5</p>

<p>2) the same reason</p>
",0
28442828,28442484,2,"<p>Your program is ill-formed because of name ambiguity (ignoring the misspelled &quot;tyep&quot; you have scattered around)</p>
<blockquote>
<p><strong>¡ì 10.2 Member name lookup</strong></p>
<p>Member name lookup determines the meaning of a name (id-expression) in a class scope (3.3.7). Name
lookup can result in an ambiguity, in which case the program is ill-formed. For an id-expression, name
lookup begins in the class scope of this; for a qualified-id, name lookup begins in the scope of the nestedname-
specifier. Name lookup takes place before access control (3.4, Clause 11).</p>
</blockquote>
<p>Don't do this:</p>
<pre><code>struct type5
{
   //...
};
static int type5;
</code></pre>
<p>Unsurprisingly, this doesn't compile for me on ideone. <a href=""http://ideone.com/A7t5O1"" rel=""nofollow noreferrer"">Live Demo</a></p>
",2
23826791,23826683,0,"<p>Check to see that the level count of your tree correlates to the number of nodes by this algorithm:</p>

<pre><code>bool isPerfectlyBalanced = pow(2,binaryTree.levelCount())-1 == tree.numberOfNodes();
</code></pre>

<p>So that:</p>

<pre><code>        *
    *       *
  *   *   *   *
</code></pre>

<p>Level count = 3, total nodes = 7</p>

<pre><code>pow(2,3)-1 == 7
</code></pre>
",1
29212407,29212204,1,"<p>As you marked it C++, I thought this might be more idiomatic:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;

std::vector&lt;double&gt; CastToDouble(std::vector&lt;int&gt; const &amp; ints)
{
    auto doubles = std::vector&lt;double&gt;(ints.size());

    std::transform(ints.begin(), ints.end(), doubles.begin(), [](int value) -&gt; double {
        return static_cast&lt;double&gt;(value);
    });

    return doubles;
}

int main(int argc, char* argv[])
{
    auto values = std::vector&lt;int&gt;() = { 
        1, 2, 3, 4
    };

    auto doubles = CastToDouble(values);
}
</code></pre>
",1
23063033,23062788,0,"<p>These types are undefined and therefore unknown to the compiler:</p>

<pre><code>td_NtQuerySystemInformation    NtQuerySystemInformation    = NULL; 
td_NtQueryObject               NtQueryObject               = NULL; 
td_NtDuplicateObject           NtDuplicateObject           = NULL; 
</code></pre>

<p>Same for <code>PSYSTEM_PROCESS_INFORMATION</code>, <code>POBJECT_TYPE_INFORMATION</code> etc.</p>

<p>You need to include their definition.</p>
",0
23072644,23072579,0,"<p>How would the compiler know that <code>Point</code> contains three variables called <code>x</code>, <code>y</code>, and <code>z</code>? How would it know what type they are? You have to tell the compiler these things.</p>
",0
26193838,26193606,1,"<pre><code>class ReadBool {
public:
  ReadBool(bool&amp; v) : v_(v) {}
  void Parse(istream&amp; is) const {
    string s;
    is &gt;&gt; s;
    v_ = (s == ""yes"");  // adjust to taste
  }
private:
  bool&amp; v_;
};

istream&amp; operator&gt;&gt;(istream&amp; is, const ReadBool&amp; rb) {
  rb.Parse(is);
  return is;
}
</code></pre>

<p>Now you can do</p>

<pre><code>bool b;
cin &gt;&gt; ReadBool(b);
</code></pre>
",1
26193643,26193606,1,"<p>Declare variable as bool and take input as 0 or 1 to be treated as false or true respectively.</p>

<pre><code>bool b;
cin &gt;&gt; b;
</code></pre>
",2
24124793,24124583,1,"<p>The cleanest way would probably be to use a stringstream with an istream_iterator, something like this:</p>

<pre><code>std::string str = ""1001 0104 2325 9999"";

std::istringstream in(str);

std::vector&lt;int&gt; numbers {
    std::istream_iterator&lt;int&gt;(in),
    std::istream_iterator&lt;int&gt;()
};

// just to show what we did:
for (int i : numbers)
    std::cout &lt;&lt; i &lt;&lt; ""\n"";
</code></pre>

<p>Note that there is a little bit of ambiguity in the input you provided: it's not clear whether you intent the <code>0104</code> to be decimal or octal (as a leading zero would cause it to be interpreted in source code). The code I've written above interprets it as decimal. If you want a leading <code>0</code> to mean octal (and leading <code>0x</code> to mean hexadecimal) you can do that (at least if memory serves) by setting the base for the conversion to 0.</p>
",1
28531475,28531405,-2,"<p>I figured it out, all I had to do, instead of everything in the function exchange, put:</p>

<pre><code>char * temp;
temp = new char[];

temp = p1;
p1 = p2;
p2 = temp;
</code></pre>
",2
28531588,28531405,0,"<p>You need a solution like <a href=""http://en.cppreference.com/w/cpp/algorithm/swap"" rel=""nofollow"">std::swap</a>:</p>

<pre><code>std::swap(s1, s2);
</code></pre>

<p>The output will be:</p>

<pre><code>s1 = Bye Bye
s2 = Hello
</code></pre>
",0
27152593,27152201,7,"<p>An exception is thrown when a function cannot meet its contract (what it promises the caller it will do). When a function calls another function that throws an exception, there are four main approaches to how it might respond:</p>

<ol>
<li><p><strong>Catch the exception and handle it</strong>. This should only be done if the function is able to meet its contract despite the exception being thrown. If it catches the exception but fails to meet its contract, it is hiding a problem from the calling code.</p></li>
<li><p><strong>Allow the exception to propagate</strong>. This should be done if the exception cannot be handled by this function (that is, the function is unable to meet its contract because the exception has been thrown), and if the exception exposes the appropriate information to the calling code.</p></li>
<li><p><strong>Catch the exception, do some clean-up and/or add extra info, and rethrow it</strong>. This should be done if the exception cannot be handled by this function, but it needs to do some cleaning up before propagating it. It can also provide extra information to help with handling/debugging the exception (I often think of the programmer as the very last exception handler).</p></li>
<li><p><strong>Catch the exception and throw a different exception</strong> (perhaps wrapping the original). This should be done if the exception cannot be handled by this function, but a different exception better expresses the problem to the calling code.</p></li>
</ol>
",0
27152609,27152201,1,"<blockquote>
  <p>Why not let the current catch block handle the exception. For what reasons would you rethrow an exception to another try/catch block?</p>
</blockquote>

<p>The idea behind exceptions is that you throw them at the error site and handle them down the stack, where you have enough information to handle the error.</p>

<p>Conversely, there are cases when you must do something in case of an error, but still don't know how to handle the error (this is the case when you rethrow).</p>

<p>Example:</p>

<pre><code>void connect_and_notify(int connection_data)
{
    try
    {
        create_network_connection(connection_data); // defined somewhere else
        notify(""connection open"");                  // same (notify event listeners)
    }
    catch(const std::runtime_error&amp;)
    {
        notify(""connection failed"");
        throw;
    }
}
</code></pre>

<p>Client code:</p>

<pre><code>void terminal_app_controller()
{
    try
    {
        connect_and_notify(1);
    }
    catch(const std::runtime_error&amp; err)
    {
        std::cerr &lt;&lt; ""Connection failed;\n"";
        exit(1); // this is usually bad bad code but whatever
    }
}

void ongoing_server_controller()
{
    bool connected = false;
    int connection = 1;
    while(!connected)
    {
        try
        {
            connect_and_notify(1);
            connected = true;
        }
        catch(const std::runtime_error&amp;)
        {
            connection++;
        }
    }
}
</code></pre>

<p>In the two usage scenarios, the error is handled differently (<code>connect_and_notify</code> has no way of knowing that, but still, on a failed connection it must notify listeners).</p>

<p>Each function has a different policy to handle the exception and this means different catch blocks.</p>
",0
27153404,27152201,0,"<p>I very much dislike anything like</p>

<pre><code>catch (std::exception&amp;) {
    ... // do some cleanup
    throw;
}
</code></pre>

<p>RAII is the correct solution to that problem. Even:</p>

<pre><code>catch (std::exception&amp;) {
    ... // do some logging here
    throw;
}
</code></pre>

<p>can be handled with RAII, although it is less intuitive.</p>

<p>BUT - where I <em>have</em> rethrown is any situation where 3rd-part (or vendor-supplied) code throws ""generic"" exceptions with state. For example, when logging telematics messages to a database, I know that I often receive duplicate copies of the same message. Each message has a unique ID - so a primary key violation in my DB is an ""innocent"" error that should be silently ignored.</p>

<p>Unfortunately, the DB framework we use doesn't throw a specific exception for PK violations - so we need to catch the generic dbexception and check what its reason code is to decide what to do. Hence:</p>

<pre><code>catch (db::exception&amp; e) {
    if (e.reason != db::exception::reason::pk_violation)
        throw;
}
</code></pre>

<p>Also, <a href=""https://stackoverflow.com/users/948128/piwi"">piwi</a> mentioned internal state. An example would be</p>

<pre><code>for (;;) {
    try {
        ...
    }
    catch (some_exception&amp; e) {
        if (retry_count &gt; 3)
            throw;
    }
}
</code></pre>

<p>Remember: If you are going to rethrow, always catch by reference to avoid slicing the exception object. (You should usually catch by ref anyway, but it is even more important when rethrowing)</p>
",0
29900826,29900223,1,"<p>You have a logic error in <code>List::remove()</code></p>

<p>If I change the lines:</p>

<pre><code>    Node&lt;T&gt; *temp2 = this-&gt;first;
    Node&lt;T&gt; *temp3 = this-&gt;first;
</code></pre>

<p>by:</p>

<pre><code>    Node&lt;T&gt; *temp2 = this-&gt;first;
    Node&lt;T&gt; *temp3 = temp2-&gt;getNext();
</code></pre>

<p>everything works OK for me.</p>
",1
24105940,23984942,0,"<p>The function you passed in is this one.</p>

<pre><code>public:
double integrand(double R);
</code></pre>

<p>Since you declared it inside the class it is a member function. To call a member function you need an object pointer that will become the <code>this</code> pointer inside the function. The compiler is telling you that this (member) function is incompatible with your declaration (of a non-member function). Which of course, it is.</p>

<p>The best solution to this problem is the one given in the answer by @Loopunroller. For fear of subjecting you to <a href=""http://en.wikipedia.org/wiki/Cargo_cult_programming"" rel=""nofollow"">cargo cult programming</a> I offer this alternative simpler approach.</p>

<p>Simply change the declaration of this function (usually in the header file) to make it static. Now the function loses access to the <code>beta</code> member. So repeat the process, and make that static too.</p>

<pre><code>class {
...
public:
  static double integrand(double R);
  static double beta;
...
};
double GalaxyModel::beta;
</code></pre>

<p>That should fix it. When you're happy you understand, then move over to using the template/bind solution for extra power.</p>

<hr>

<p>Sorry, I misread which function on the first round. Edited to refer to the correct function.</p>
",2
26126069,26125832,0,"<p>If the first 3 are digits and the last one is a character and are seperated by a space,which you want to assign to 3 integer variables and a character variable, use <code>scanf</code> like this:</p>

<pre><code>int a,b,c;
char ch; 
scanf (""%d%d%d %c"",&amp;a,&amp;b,&amp;c,&amp;ch);
</code></pre>

<p>Or else if you want to extract 3 integers and a character from a string , use <code>sscanf</code>. It is not possible to do it with <code>scanf</code>.</p>
",0
28521011,28520810,0,"<p>What you need is this:</p>

<pre><code>player = (player + 1) &amp; 1
</code></pre>

<p>This will alternate between 0 and 1.</p>

<p>This will also do it:</p>

<pre><code>player = (player + 1) % 2
</code></pre>
",2
28521031,28520810,0,"<p>This will give you 0 and 1 consecutively:</p>

<p>say <code>int counter = 0;</code></p>

<pre><code>if(counter % 2 == 0)
{
// player O
}else
{
// player X
}

counter++;
</code></pre>
",0
24366964,24366866,1,"<p>Here <code>delete _board[location.getX()][location.getY()];</code> you have deleted the location and You are trying to access deleted memory location.</p>
",4
23584774,23584749,2,"<p>That's because you're using the <a href=""http://mathworld.wolfram.com/IntegerDivision.html"" rel=""nofollow""><strong>integer division</strong></a>, in which the fractional part (remainder) is discarded.</p>

<p>Change</p>

<pre><code>avg=sum/n;
</code></pre>

<p>to</p>

<pre><code>avg=sum/(float)n;
</code></pre>
",0
22494209,22494135,0,"<p>The output you are getting is wrong because you are using integer division. Change 4 to <code>4.0</code> to fix to double division:</p>

<pre><code>average = (num1 + num2 + num3 + num4) / 4.0;
</code></pre>
",0
22494214,22494135,1,"<p>You get average no matter what because all your <code>if</code>s have empty statements.</p>

<pre><code>if  (num1 &lt; 0 || num1 &gt; 100); &lt;-
</code></pre>

<p>Do not put a semi colon after condition, since it means empty statement.</p>

<p>Also you probably want to take a look at boolean logic and block statement.</p>
",1
22494252,22494135,1,"<p>There are several things that need to be fixed:</p>

<pre><code>if  (num1 &lt; 0 || num1 &gt; 100);
if  (num2 &lt; 0 || num2 &gt; 100);
if  (num3 &lt; 0 || num3 &gt; 100);
if  (num4 &lt; 0 || num4 &gt; 100);
</code></pre>

<p>Those ifs are useless, basically if it is out of range, then do nothing. You may want to change it such that</p>

<pre><code>if  (num1 &lt; 0 || num1 &gt; 100
    || num2 &lt; 0 || num2 &gt; 100 
    || num3 &lt; 0 || num3 &gt; 100
    || num4 &lt; 0 || num4 &gt; 100)
</code></pre>

<p>Then it will print the statement <code>out of range</code>.
Else, calculate the average.</p>

<p>And what do you mean by?</p>

<pre><code>string dontcalculateAverage();
float calculateAverage();
</code></pre>

<p>Third, remember that integer division yields integer, even though the result is float. To overcome this, use <code>4.0</code> instead of <code>4</code> when dividing. You can also typecast <code>(float)</code> for the summation of <code>num1 + num2 + num3 + num4</code> as well.</p>
",1
22494361,22494135,0,"<p>Look very closely at the if statements' bodies and what is happening versus the intention.  For example, the intention is:</p>

<pre><code>string dontcalculateAverage()
{
    string sOut;
    if  (    (num1 &lt; 0 || num1 &gt; 100)
          || (num2 &lt; 0 || num2 &gt; 100)
          || (num3 &lt; 0 || num3 &gt; 100)
          || (num4 &lt; 0 || num4 &gt; 100)
        )
        sOut = ""marks out of range"";

    return sOut;

} // end dontCalculateAverage()
</code></pre>

<p>The reality of the code following the dontcalculateAverage() function declaration inside the body of main (please correct this), is that the if statement logic is not doing anything.  The cout line always sends a string to the output stream.  Similarly, the next set of code accomplishes no range checking before performing the average.  And as others have already indicated, the average calculation line itself is in error since it is calling integer division.  At least one floating point number, usually the divisor is easiest, has to be present to force floating point division by the compiler.</p>

<p>Please look closely at what the compiler is saying and the C++ reference material at your disposal.  </p>
",0
23835145,23834890,1,"<p>Try looking at Recursive Descent Parser for inspiration, you need to feed it tokens of identifiers eg) x, sin, cos, e^, log, operators eg) +, -, *, / from a lexical analysis function which reads a string.  The explanation of COMPOSITION operator seems strange, the contents of ( ... ) would appear to be composed into an expression, so the functions operates on a unary expression.</p>
",0
23578042,23577959,2,"<ul>
<li>Remove the "";"" after the #include</li>
<li>Add the <code>#include &lt;cstdlib&gt;</code> to get <code>system</code> and <code>exit</code></li>
</ul>

<p>The following compiled for me:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main()
{
     using namespace std;
     int i=1;
     char ch;
     cout&lt;&lt;""please enter a choice""&lt;&lt;endl;
     cin&gt;&gt;ch;
     switch(ch){
     case 'e':
     case 'E':i=2;break;
     case 'o':
     case 'O':break;
     default:
         cout&lt;&lt;""Wrong input.""&lt;&lt;endl;
         system (""pause"");
         exit(1);
     }
     while (i&lt;50)
         cout&lt;&lt;i&lt;&lt;"" "",i+=2;    
}
</code></pre>
",2
28316390,28316361,2,"<p><code>Term</code> is defined inside <code>Polynomial</code>, so you need to refer to it by its full name <code>Polynomial::Term</code> when using it outside of the scope of the <code>Polinomial</code> class.</p>

<pre><code>Polynomial::Term* pos = Poly.first;
</code></pre>
",0
28464505,28464293,3,"<p>To answer your stated question, you can set registry keys with <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms724921(v=vs.85).aspx"" rel=""nofollow""><code>RegSetKeyValue</code></a>, however you have to get past UAC in order to change the registry. To answer your implicit question, yes you could probably disable UAC programatically for malicious purposes, however you have to get past UAC in the first place to do so. Once you're on the other side of the airtight hatchway, you can do whatever you want of course. However you still have to get past the UAC hurdle.</p>

<p>Furthermore, I highly recommend you do a cursory google search before posting a question like this. The Windows C API is documented very well on MSDN.</p>
",1
28527478,28527425,0,"<p>The default copy constructor generated for you is doing a shallow copy.</p>

<p>Define a copy constructor that does a deep copy and it'll fix your issue</p>
",0
26169516,26169407,5,"<p>This line</p>

<pre><code>while(oldFile.get(c));
</code></pre>

<p>consumes the entire file without any side effects due to the <code>;</code> at the end.</p>

<p>You need:</p>

<pre><code>while(oldFile.get(c)) // Without the ;
{
    std::cout &lt;&lt; c &lt;&lt; std::endl;
    newTarget.put(c);
}
</code></pre>
",1
31890206,31890183,2,"<p>Your confusion is completely understandable - the piece you're missing is that when you assign a variable, you're assigning the left side to the result of the right side <em>at that moment in time</em>. It's not like algebra, where you say <code>f(x) = x + 5</code> and <code>f(x)</code> is always whatever <code>x + 5</code> is.</p>

<p>So, you assign <code>double distance_price = distance * 0.15</code> when <code>distance</code> is <code>0</code> (which you just initialized). <code>distance_price</code> remains <code>0</code> even after you ask for input and change <code>distance</code>.</p>

<p>Do your price calculations after you ask for input, and everything will work just fine.</p>
",0
31891889,31890183,1,"<p>You are calculating the <code>distance_price</code> <code>bag_price</code> <code>meal_price</code> with default values i.e. <code>0</code> not with the value which you took from user.</p>

<p>Below code works fine and you won't see the issue.</p>

<pre><code>   #include &lt;iostream&gt;
    using namespace std;
    // My compiler did not allow void main so used int main
    int main () {

    int distance = 0;
    int num_bags= 0;
    int num_meals= 0;

    double distance_price ;
    double bag_price ;
    double meal_price;
    double total_airfare;

    cout &lt;&lt; ""CorsairAir Fare Calculator"" &lt;&lt; endl;

    cout &lt;&lt; ""Enter the distance being travelled:  "" &lt;&lt; endl;
    cin &gt;&gt; distance;

    cout &lt;&lt; ""Enter number of bags checked:  "" &lt;&lt;endl;
    cin &gt;&gt; num_bags;


    cout &lt;&lt; ""Enter the number of meals ordered:  "" &lt;&lt; endl;
    cin &gt;&gt; num_meals;


    distance_price = distance * 0.15;
    bag_price = num_bags * 25.00;
    meal_price = num_meals * 10.00;
    total_airfare = 0.00;


    total_airfare = distance_price + bag_price + meal_price;


    cout &lt;&lt; total_airfare;
    return 0;
    }
</code></pre>

<p><strong>Result</strong></p>

<pre><code>CorsairAir Fare Calculator
Enter the distance being travelled:
200
Enter number of bags checked:
2
Enter the number of meals ordered:
2
100
</code></pre>
",0
26117448,26115865,2,"<p><a href=""https://stackoverflow.com/a/26115931/4022608"">This answer</a> is how it should be done.
However:</p>

<blockquote>
  <p>I can see, it's hard to find as right solution without generating lots
  of code lines. Thanks @TobiMcNamobi, but in my switch there is about
  200 of cases, so creating a function for each case is not a good idea.
  I think, the best can be (unfortunately) duplicating all cases in a
  big one. Because, I suppose, if else is much less efficient then
  switch statement ?</p>
</blockquote>

<p>With this many cases (what on earth are you working on?) even extracting methods leaves you with 200 extra function calls in the body of your switch statement. This could get harder to maintain quickly.</p>

<p>In <em>this</em> case, I would do the following:</p>

<pre><code>switch(enum_variable)
{
  case e_all:

  case e_1:
    e_1_function();
    if(enum_variable != e_all){break;}   //**

  case e_2:
    e_2_function();
    if(enum_variable != e_all){break;}   //**

  //...

  default:
    break;
}
</code></pre>

<p>The lines marked <code>//**</code> will break when not doing all cases.  It is quick to implement (can be done with a search and replace of <code>break;</code> which speeds things up for you) and does what you want.<br>
With that said, it's still a pretty terrible way of doing it, but exceptions do sometimes have to be made.  </p>

<p>I do however recommend that you <em>do not</em> turn to this as a style to use in the future.  You may find that you can do better by re-thinking the workflow of your project, as this will probably allow you to simplify and improve. Of course, we don't know what you are working on, so I can't offer more advice.</p>
",2
26115931,26115865,6,"<p>You can't just ignore a break. Rather, restructure your code.</p>

<pre><code>switch(obj.nObjType) {
  case eElephant:
    pokeElephant();
    break;
  case eFoo:
    barTheFoo();
    break;
  case eSeptember:
    rememberSeptember();
    break;
  case eAllTypes:
    pokeElephant();
    barTheFoo();
    rememberSeptember();
    break;
  default:
    return;
}
</code></pre>
",3
26115957,26115865,3,"<p>Then use <code>if</code> statements:</p>

<pre><code>if (obj.nObjType == eElephant || obj.nObjType == eAllTypes)
{
    // Elephant code
}

if (obj.nObjType == eFoo || obj.nObjType == eAllTypes)
{
    // Foo code
}

// etc.
</code></pre>
",1
26115973,26115865,1,"<p>If you put your switch statement in a function, and make your <code>obj</code> have a <em>list</em> of flags rather than a flag, you can call the function with the switch statement for each  flag in the list. Pseudo:</p>

<pre><code>void dostuff(flag)
    switch(flag) {
        // ...
    }
}

for (auto flag in obj.flags) {
    dostuff(flag)
}
</code></pre>
",0
28150633,28150388,0,"<p>Method: Apply <strong>Dijkstra</strong> on every vertex of the graph and find out the global maximum of the cost between any two nodes on the graph.</p>

<p>Explanation: As you can see through the method, this is a naive method to calculate the maximum cost between any two routes, because we have to consider <strong>all</strong> the nodes as the <strong>source node</strong> and get the shortest paths from the source node to <strong>every other node on the graph</strong> (This condition is specified in the problem), and then <strong>maximize</strong> the cost of travelling i.e. maximizing the weight of the shortest path between any two nodes. (This condition is also mentioned in the problem). As Dijkstra is quite efficient with a <strong>minimum heap</strong> (Time complexity : <code>O( (V+E)lgV )</code>), this solution runs perfectly in the time limit alloted by the INOI server.</p>

<p>For reference, you can see my code : <a href=""http://pastebin.com/WEMfKbbd"" rel=""nofollow"">FreeTicket Solution</a></p>

<p>Hope that helped. If not, please comment.</p>
",6
34231763,34231691,0,"<p>Really, the answer lies in an extensive benchmark of the two versions. </p>

<p>However, making an assessment, I tend to believe that the first version is going to be faster, due to the fact that in the general case you have to copy less elements from the initial vector to the output vector, than in the second one where you copy them all. </p>
",0
34231773,34231691,2,"<p>Your second example will create a whole bunch of objects (in copying the input parameter) just to get rid of them later (at the call to erase).  The performance difference because of that will depend on what <code>T</code> is, but I doubt the first one would ever be slower.<br>
Also the amount of memory used will be greater in the second version as erase does not reallocate memory.</p>

<p><strong>EDIT</strong><br>
Your current test is flawed because you pass the vector to be subsetted as a temporary, allowing the compiler to move construct the input parameter in <code>drop2</code> and thus eliding the copy completely.  Simply changing:</p>

<pre><code>   for (auto x: range(100000))
       f(200, range(10000));
</code></pre>

<p>to</p>

<pre><code>   auto v = range(10000);
   for (auto x: range(100000))
       f(200, v);
</code></pre>

<p>Changed the results around quite dramatically.  However, the second method was still faster for me until the vectors were much larger.  It's also worth noting that because you are using <code>int</code> the different methods could be optimally optimized to <code>memcpy</code> and a couple of pointer manipulations.</p>

<p><code>drop</code> could become simply a memcpy of <code>(coll.size() - size) * sizeof(int)</code> bytes while <code>drop2</code> could become a memcpy of <code>coll.size() * sizeof(int)</code> bytes.  This is because the destructor for an <code>int</code> is a no op and so the call to erase could become simply subtracting <code>size</code> from the <code>__last</code> pointer of the vector.  </p>

<p>If all you are interested in is primitive types like this then that's okay, but if you also want to have an optimal implementation for, say, <code>std::string</code> then its destructor and copy-constructor become very important factors.  I have tried with <code>std::vector&lt;int&gt;</code> as the type inside the vector and, while being slower overall, for smaller sizes it seems that <code>drop2</code> is still faster.  <code>drop</code> becomes more efficient at a lower threshold, however.  I very much doubt that that is what we are seeing here, so the code we end up running is in some sort of in-between state of being just <code>memcpy</code>'s and being what we wrote verbatim.</p>

<p>I guess in the end we are testing the compiler's ability to optimize different functions (<code>std::uninitialized_copy</code>, <code>std::move</code>(the iterator-based one), calling <code>get_allocator().destroy(p)</code> in a loop on trivial and non-trivial types, etc...).  All I can say at this point is that results can vary quite wildly in terms of what gets optimized and by how much for even seemingly small changes in the code.</p>

<p>I am, however, still surprised the <code>drop2</code> runs faster than <code>drop</code>, even if only for ranges under a certain size.</p>
",0
34231799,34231691,3,"<p>The first one is almost certainly faster, unless you are feeding <code>drop</code> an rvalue, in which case you'd have to measure. </p>

<p>Suppose you have N elements to start with, and M elements to drop:</p>

<ul>
<li>The first copies N-M elements; the second copies N elements.</li>
<li>The first performs no assignment; the second performs N-M move assignments, which may degenerate to copy assignments.</li>
<li>The first may, and in practice will, RVO. The second one requires a move that cannot be elided. However, moving vectors are sufficiently cheap that the extra cost is likely minimal.</li>
</ul>
",2
23575916,23575915,0,"<p><code>int **C</code> declares a pointer to a pointer, and since in C\C++ arrays are pointers, <code>C</code> is an array of arrays. <code>new int*[N]</code> creates the outer array, but it does not create the inner arrays. At no point do you create the inner arrays and assign them to the cells of <code>C</code>, so <code>C[#]</code> contains junk(if I recall correctly, <code>0</code> if you compile in debug mode and whatever was in that memory before if you use release mode). When you use <code>C[i][j]</code>, since <code>C[i]</code> contains either <code>0</code> or junk you get a segfault.</p>

<pre><code>int **multiply(int **A, int **B, int N){
    int **C=new int*[N];
    for(int i=0;i&lt;N;i++){
        C[i]=new int[N]; // Create the inner array here
        for(int j=0;j&lt;N;j++){
            C[i][j]=0; // You need to initialize the cell or else it'll contain some random junk
            for(int k=0;k&lt;N;k++)
                C[i][j]=C[i][j]+A[i][k]*B[k][j];
        }
    }
    return (C);
} 
</code></pre>
",0
28252675,28252593,1,"<p>This part destroys the object:</p>

<pre><code>this-&gt;~example();
</code></pre>

<p>It doesn't release the memory though, except for memory that is released due to the destructor call. Then, it proceeds with an invocation of ""placement new"":</p>

<pre><code>new (this) example(source);
</code></pre>

<p>This will construct an object on the (unreleased) memory of the former object.</p>

<p>Concerning the safety of this, it is at least dangerous. If after destroying the object you fail to create the new object, you have a weird zombie object that will get destroyed a second time (causing undefined behaviour) when its normal lifetime ends.</p>
",2
28252695,28252593,3,"<p>What you are seeing is an attempt at code-reusage. The idea is to use the copy constructor to implement the assignment operator (or, in this case an assignment function).</p>

<p>First, to get rid of the easy stuff:</p>

<ul>
<li><p>The <code>if</code> ensures that a self assignment (e.g. <code>x.assign(x)</code>) is being handled correctly. This is necessary since the implementation relies on the fact that changing <code>*this</code> does not change <code>source</code>. By comparing <code>this</code> to the address of the other object, this does test the objects for equality, but for sameness.</p></li>
<li><p>The function is missing a <code>return *this;</code>, but you probably noticed that already.</p></li>
</ul>

<p>Now to the two remaining lines:</p>

<pre><code>this-&gt;~example();
</code></pre>

<p>Explicitly calls the destructor of the class <code>example</code>. After that line the <code>this</code> pointer no longer points to an object, but to uninitialized memory of <code>sizeof(example)</code>.</p>

<pre><code>new (this) example(source);
</code></pre>

<p>Is the so-called <a href=""https://stackoverflow.com/questions/6783993/placement-new-and-delete"">placement new</a>, which does <em>not</em> allocate memory, but simply creates a new <code>example</code> at the location pointed to by <code>this</code> by calling its copy constructor. In a way this is the syntax to explicitly call a constructor w/o allocating any memory.</p>

<p>Note that this reuses the memory that <code>*this</code> held previously, no matter where that is: It could even be e.g. a <code>virtual</code> base of an element of a dynamically allocated array...</p>

<p>As to the safety: In practice this is safe (although ugly and possibly not very efficient) as long as neither the constructor nor destructor throw. However, you can run into problems when deriving from a class that attempts to be sneaky like that.</p>

<p>If you want to know the simplest way to write an assignment operator/function that reuses the copy constructor, check <a href=""https://stackoverflow.com/questions/8848363/rvalue-reference-with-assignement-operator"">this question</a>, which basically boils down to:</p>

<pre><code>example&amp; assign(example source)
{
    swap(*this, source);
    return *this;
}
</code></pre>

<p>The most important differences:</p>

<ul>
<li>It utilizes a move constructor where applicable.</li>
<li>This code is exception safe if the copy/move constructors and <code>swap</code> are exception safe (which they should always be).</li>
<li>It is slightly less efficient for self-assignment, since it will perform the copy, instead of recognizing a self-assignment.</li>
</ul>
",5
26149568,26147065,0,"<p>Assumptions:  </p>

<ul>
<li>You write non portable code, making use of non portable function <code>[_fullpath()</code>]<a href=""http://msdn.microsoft.com/en-us/library/506720ff.aspx"" rel=""nofollow"">1</a></li>
<li>You target windows only </li>
<li>You work with unicode disabled as you use <code>_fillpath()</code> and not <code>_wfullpath()</code></li>
<li>You do not want to use third party libraries </li>
</ul>

<p><strong>How to do it with windows ?</strong> </p>

<p>You could use FindFirstFile() and FindNextFile() to iterate through the directories.  MSDN has a <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa365200%28v=vs.85%29.aspx"" rel=""nofollow"">nice example</a> of how to use them. </p>

<p>Unfortunately <code>FindFirstFile()</code> is very basic and limits itself to search entries based on a filename containing wildcards.  As you are looking for directories, it's more tricky:  you'll have to use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa364419%28v=vs.85%29.aspx"" rel=""nofollow""><code>FindFirstFileEx()</code></a>.  The parameter called fSearchOp in the function documentation should be <code>FindExSearchLimitToDirectories</code></p>

<p>The data is returned in <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa365740%28v=vs.85%29.aspx"" rel=""nofollow"">WIN32_FIND_DATA</a> structure where you can read the <code>cFileName</code>.  By the way, try to avoid at any cost hard coded length like 255 and prefer well known constants instead (here the windows specific MAX_PATH).  </p>

<p>Finally, while you are looping, you may perform the copying either using your own C++ standard based copy function, or using the windows specific <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa363851%28v=vs.85%29.aspx"" rel=""nofollow""><code>CopyFile()</code></a> </p>

<p><strong>Final remarks</strong></p>

<p>This kind of gymnastics is not at all portable.  If you'd like to use your code on other platforms than windows, you'd have to use a completely different API, for example <a href=""http://pubs.opengroup.org/onlinepubs/7908799/xsh/dirent.h.html"" rel=""nofollow"">dirent.h</a> for unix/linux and co.   This is why, for this particular kind of work, a third party library like boost is extremely useful. If you have time, look here for a <a href=""http://www.boost.org/doc/libs/1_49_0/libs/filesystem/v3/doc/tutorial.html"" rel=""nofollow"">directory iteration</a> tutorial with boost and compare with the windows based code.  </p>
",3
24104135,24093473,1,"<p>I know this is a bit hacky but I could have robust implementation by using <code>__COUNTER__</code> macro instead of <code>__LINE__</code> that is passed as a template function argument to ensure that the function is instantiated for each call site. <code>__COUNTER__</code> isn't part of the C++ standard (to my knowledge) but it is supported by compilers I'm targeting currently (gcc &amp; MSVC). So what could work is this:</p>

<pre><code>struct alloc_site_info
{
  alloc_site_info(const char *filename_, const char *funcname_, unsigned line_)
    :filename(filename_)
    ,funcname(funcname_)
    ,line(line_)
  {}
  const char *filename;
  const char *funcname;
  unsigned line;
};

template&lt;unsigned&gt;
static const alloc_site_info &amp;get_alloc_site_info(const char *filename_, const char *funcname_, unsigned line_)
{
  static const alloc_site_info s_info(filename_, funcname_, line_);
  return s_info;
}

#define MALLOC(bytes__) my_alloc(bytes__, get_alloc_site_info&lt;__COUNTER__&gt;(__FILE__, __FUNCTION__, __LINE__));
</code></pre>

<p>It's not the prettiest implementation but the only working solution I'm currently aware of.</p>
",0
29189454,29189389,1,"<p>You can use <code>std::tie</code> here if you're willing to provide a <code>to_tuple</code> function. A tuple conversion function <a href=""https://stackoverflow.com/questions/26276943/make-custom-type-tie-able-compatible-with-stdtie"">has problems</a> with a nastier workaround so this solution is straight forward.</p>

<pre><code>struct ColorA
{
    float r, g, b, a;
    auto to_tuple() const
    {
        return std::make_tuple(r, g, b, a);
    }
};

int main()
{
    float r, g, b, a;
    ColorA color;
    std::tie(r, g, b, a) = color.to_tuple();

    return 0;
}
</code></pre>
",0
28522111,28522086,3,"<p>""The thing you were using"" (read: your compiler) wanted you to end your <code>using namespace std</code> statement with a semicolon, not to dump one at the start of a function definition.</p>

<p>Your code has a number of extreme and baffling syntax errors, to the extent that it's not even clear what you're trying to accomplish.</p>

<p>Below is a hint to get you started but, from now on, I <em>strongly</em> recommend that you read <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">a good, peer-reviewed C++ book</a> and <em>learn the language</em> before asking any further questions about nonsense code!</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;


int main()
{
    string input;
    getline(cin, input);

    if (input == ""hi"") {
       cout &lt;&lt; ""hello"" &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
",6
31808593,31807052,0,"<p><code>cin.fail()</code> returns true if the last cin call failed.
Consider the input <code>2p 3p 4p</code>. This will work if you use <code>cin.ignore()</code> in between readings. <code>FirstSide</code> will be 2, <code>SecondSide</code> will be 3 and <code>ThirdSide</code> will be 4.</p>

<p>You could try clearing the stream and prompt the user for another input instead of throwing an exception.</p>
",0
31810394,31807052,1,"<p>Using <code>operator&gt;&gt;(double &amp;)</code> will first skip any whitespace characters, and then read character by character until a character is found that is not part of a number (e.g. a <code>p</code> or <code>x</code>, but not an <code>e</code> in case of <code>double</code>). This character is <strong>left inside the stream</strong> and the until then converted number returned. No error or failure is indicated.</p>

<p>(<a href=""http://ideone.com/nPVMLU"" rel=""nofollow"">Example here</a>, unfortunately I couldn't find formal proof for my argument.)</p>

<p>To achieve the desired behaviour, you need to split reading and converting:</p>

<ol>
<li>Read a token, probably terminated by whitespace, and</li>
<li>convert it into the desired value.</li>
</ol>

<p>.</p>

<pre><code>double read_side(std::istream &amp; in) {
 std::string token;
 std::string::size_type next;
 in &gt;&gt; token;
 double result = std::stod(token, &amp;next);
 if (next != token.size()) {
  throw std::invalid_argument(""trailing characters"");
 }
 return result;
}
</code></pre>

<p><a href=""http://ideone.com/X2NtsM"" rel=""nofollow"">Live example here.</a></p>

<hr>

<p><em>I just noticed that you're now using <code>std::numeric_limits&lt;double&gt;::max()</code>, so the following does no longer apply to your code.</em></p>

<p>Considering your question about the comparison: Your variables are of type <code>double</code>, so when you compare them to an integer value, that integer will first be converted to a <code>double</code>:</p>

<blockquote>
  <p>[...] if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</p>
  
  <p>[N4431 ¡ì5/10.3]</p>
</blockquote>

<p>And a <code>double</code> is able to store larger values than <code>std::numeric_limits&lt;int&gt;::max()</code>.</p>
",0
26416917,26416675,1,"<p>This is what happens when you mix C and C++ input and don't pay attention to what they are actually doing.</p>

<p>Try this instead:</p>

<pre><code>int main()
{
    int i = 0;
    int intRate = 0;
    string name;
    while (i != 3)
    {
        cout &lt;&lt; ""Enter name: "";
        getline(cin, name);

        cout &lt;&lt; ""Enter Interest Rate: "";
        cin &gt;&gt; intRate;
        cin.clear();
        cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');

        i++;
        cout &lt;&lt; endl;
    }

    cout &lt;&lt; ""Name is : "" &lt;&lt; name &lt;&lt; endl;
    cout &lt;&lt; ""Interest Rate is: "" &lt;&lt; intRate;

    return 0;
}
</code></pre>

<p>Or this:</p>

<pre><code>int main()
{
    int i = 0;
    int intRate = 0;
    string name, line;
    while (i != 3)
    {
        cout &lt;&lt; ""Enter name: "";
        getline(cin, name);

        cout &lt;&lt; ""Enter Interest Rate: "";
        getline(cin, line);

        stringstream ss(line);
        ss &gt;&gt; intRate;

        i++;
        cout &lt;&lt; endl;
    }

    cout &lt;&lt; ""Name is : "" &lt;&lt; name &lt;&lt; endl;
    cout &lt;&lt; ""Interest Rate is: "" &lt;&lt; intRate;

    return 0;
}
</code></pre>
",0
30131451,30131370,2,"<blockquote>
  <p>Will <code>beta_</code> have already been created by the time <code>gamma_</code> is constructed in this initializer list?</p>
</blockquote>

<p>Yes, <code>beta_</code> will have been default-constructed before <code>gamma_</code>, so it is safe to use its address. Initialization of non-static data members occurs in declaration order, and destruction in reverse-declaration order.</p>
",0
30131455,30131370,3,"<p>The non-static non-variant data members of a class are initialized in declaration order, without exception. The fact that you haven't specified a <em>mem-initializer</em> for <code>beta_</code> simply means that it will be default-initialized, and this default initialization takes place <em>before</em> the initialization of <code>gamma_</code> because <code>beta_</code> precedes <code>gamma_</code> in declaration order.</p>

<p>Besides that, even if you changed the order of <code>beta_</code> and <code>gamma_</code> in the class definition, there's nothing wrong with passing around a pointer to an object that hasn't been initialized yet.</p>
",1
30131485,30131370,0,"<p>From [class.base.init]/13, emphasis mine:</p>

<blockquote>
  <p>In a non-delegating constructor, initialization proceeds in the following order:<br>
  ¡ª First, and only for the constructor of the most derived class (1.8), virtual base classes are...<br>
  ¡ª Then, direct base classes are initialized in declaration order ...<br>
  ¡ª Then, non-static data members are initialized <strong>in the order they were declared in the class definition</strong>
  (again regardless of the order of the <em>mem-initializers</em>).</p>
</blockquote>

<p>So yes, <code>beta_</code> will have been constructed before <code>gamma_</code> (the order of the initializers is irrelevant)</p>
",0
24350410,24350241,0,"<p>delete your auto-generated directories build-yourproject-xxxx-Debug/Release and rebuild it.</p>
",0
24350289,24350241,1,"<p>You forgot to ""moc"" <code>Fenetre.h</code> . Please add it to the <code>HEADERS</code> section in your pro file.</p>

<p>See this: <a href=""http://qt-project.org/doc/qt-4.8/qmake-project-files.html"" rel=""nofollow"">http://qt-project.org/doc/qt-4.8/qmake-project-files.html</a></p>
",0
26189993,26189796,0,"<p>This may not be answer to your question, as your requirement is still not clear, even after reading your comment. But, please check the <code>main</code> function: <br/>
What do you mean by the ""<code>{</code>"" after <code>case 2:</code> statement?</p>

<pre><code>case 2:
        {
</code></pre>

<p>and the ""<code>}</code>"" just before <code>return 0;</code> </p>

<p>It should be </p>

<pre><code>// --------------
    case 2:
        if(weight&lt;=maxWeight[2])
        {
            cout&lt;&lt;""Truck 2 is ready to roll - weight limit passed""&lt;&lt;endl;
            choice();
        }
        else
        {
            cout&lt;&lt;""Truck 2 has exceeded the maximum allowable weight limit of 25000""&lt;&lt;endl;
            choice();   
        }
        break;

/// ----------------
    case 7:
        if(weight&lt;=maxWeight[7])
        {
            cout&lt;&lt;""Truck 7 is ready to roll - weight limit passed""&lt;&lt;endl;
            choice();
        }
        else
        {
            cout&lt;&lt;""Truck 7 has exceeded the maximum allowable weight limit of 30000""&lt;&lt;endl;
            choice();
        }
        break;
    }
    return 0;
}
</code></pre>

<p>Why is the function <code>isInputTruckInvalid</code> so complicated? 
It can be a simple range check between 1 and 7 instead of so many <code>&amp;&amp;</code> and <code>!=</code></p>

<p>Thirdly, don't call <code>main()</code> from <code>choice()</code> - there are better ways to keep the program running.</p>
",1
24112406,24112390,5,"<ol>
<li>Write a function which will tell you whether something is a vowel or not.  This can be as simple as looping through an array or using <a href=""http://www.cplusplus.com/reference/set/set/"" rel=""nofollow"">std::set</a>.</li>
<li>Iterate through the characters and replace the vowels with the return value of <a href=""http://www.cplusplus.com/reference/cctype/toupper/"" rel=""nofollow""><code>toupper</code></a>.</li>
</ol>

<p>As a secondary note, you probably want to use <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow""><code>std::string</code></a> instead of <code>char[]</code>.</p>
",13
24112417,24112390,0,"<pre><code>   //inside the loop body

   cin &gt;&gt; a;
   while(a[i])
   if(a[i] == 'a' || a[i] == 'e' || a[i] == 'i' || a[i]== 'o' || a[i]=='u')
   {
         a[i]=toupper(a[i]);
   }
</code></pre>
",2
24112447,24112390,1,"<p>Basically, you can do this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
char a[20];

int main(){
    cin &gt;&gt; a;
    for (int i = 0; a[i] != '\0' &amp;&amp; i &lt; 20; i++){
        if (a[i] == 'a' || a[i] == 'e' || a[i] == 'i'|| a[i] == 'o'|| a[i] == 'u'){
            a[i] = a[i] + 'A' - 'a';
        }
    }
    cout &lt;&lt; a;
}
</code></pre>

<p>The program iterates each character in the string, and compares it to all five vowels. If it finds it is a vowel, it turns it into uppercase.</p>

<p>The line</p>

<pre><code>a[i] = a[i] + 'A' - 'a';
</code></pre>

<p>may seem hard to understand, but it isn't. Every character is actually an integer in a coding system. In most coding systems, the difference between a letter and its corresponding capital letter is a constant given by ('A' - 'a'). So, by adding ('A' - 'a') to any character, you effectively turn it into uppercase.</p>
",4
26232647,26232519,0,"<blockquote>
  <p>Where can i find the original definition of the reserved identifier ""__CLIBNS"" ?</p>
</blockquote>

<p>In line 4 of the code you posted.</p>

<p>The code is written like this to ensure that the macro is only defined once, and it resolves to <code>::std::</code>.</p>
",0
22890524,22890500,0,"<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
  int num;
  char ch;
  do{
       cout &lt;&lt; ""Enter a number to find Multiplication Table"";
       cin &gt;&gt; num;    
       for(int a=1;a&lt;=10;a++)
       {
           cout&lt;&lt;num&lt;&lt;"" x ""&lt;&lt;a&lt;&lt;"" = ""&lt;&lt;num*a&lt;&lt;endl;
       }
       cout &lt;&lt; ""Press \""n\"" to enter a new number or \""e\"" to exit\n"";
  }while(cin&gt;&gt;ch &amp;&amp; ch=='n');
  return 0;
}
</code></pre>
",2
22890566,22890500,1,"<p>This may be what you want. (this is the implementation of main function)</p>

<pre><code>int num;
char command;
bool exit=false;
while(!exit)
{
    cout &lt;&lt; ""Enter a number to find Multiplication Table   "";
    cin &gt;&gt;num;

    for(int a=1;a&lt;=10;a++)
    {
         cout&lt;&lt;num&lt;&lt;"" x ""&lt;&lt;a&lt;&lt;"" = ""&lt;&lt;num*a&lt;&lt;endl;
    }

    cout &lt;&lt; ""Press n to continue or e to exit\n"";
    cin &gt;&gt; command;
    while(command != 'n' &amp;&amp; command != 'e')
    {
        cout &lt;&lt; ""Just press n to continue or e to exit!\n"";
        cin &gt;&gt; command;
    }
    if (command == 'e')
    {
        exit=true;
    }else
    {
        exit=false;
    }
}
return 0;
</code></pre>
",0
25454578,25454497,0,"<ol>
<li>The pointer is copied</li>
<li>Nothing. The object is deleted and the other object is unchanged.</li>
</ol>
",0
25454587,25454497,2,"<ol>
<li><p>The pointer is copy assigned, as you expect (the default behavior is to memberwise copy/move assign everything)</p></li>
<li><p>Then you might have a memory leak if your class owns the pointee and your destructor does not <code>delete</code> the pointer. Using smart pointers such as <code>std::unique_ptr&lt;&gt;</code> helps a lot to avoid such situations.</p></li>
</ol>
",3
25454643,25454497,0,"<ol>
<li>Pointer is simply copied without touching the pointee at all</li>
<li>Pointee is not affected, its memory is not freed <em>edit:</em> Unless of course the destructor does about it...</li>
</ol>

<p>I'm pretty sure you're looking for a shared smart pointer, such as <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow""><code>shared_ptr</code></a>.</p>
",0
25454887,25454497,0,"<ol>
<li><p>What happen when we assign that object using default assignment operator?</p>

<ul>
<li><p>The assignment operator performs a member-wise assignment of every data member of the class for which it is defined. That means if there is some pointer <em><code>p</code></em> in class <em><code>X</code></em>, the assignment operator will simply <em>assign</em> it to the pointer from that other object. For example:</p>

<pre><code>X&amp; X::operator=(const X&amp; rhs) { // default-assignment operator
    this-&gt;p = rhs.p;
    return *this;
}
</code></pre>

<p>Watch out, because the above might cause a memory leak if <code>p</code> was previously allocated with memory that was not deallocated before the assignment. If you're using a pointer, you might want to wrap it in a <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""nofollow""><code>std::unique_ptr&lt;&gt;</code></a> or <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow""><code>std::shared_ptr&lt;&gt;</code></a> which will safely delete the memory. Otherwise it will be lost after the assignment. </p>

<p>Moreover, the above performs a <em>shallow</em> copy of the pointer. If you want a deep copy, you may need to override this method and do it manually (or wrap the pointer in a class which does it internally).</p></li>
</ul></li>
<li><p>What happen if we use delete one object in the above mentioned situation?</p>

<ul>
<li><p>If you <code>delete</code> the contained pointer, but never assign it to the other object, your class will still be in a valid state, but the value of your pointer will be indeterminate. If you ever use the pointer as if it had a value thereafter, you will invoke <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behavior</a> on your program.</p>

<p>It may be better to give your pointer a value of <code>nullptr</code> after its deletion, that way you can at least know that it doesn't point to a valid object (don't worry about this while using <code>std::unique_ptr/std::shared_ptr</code>. Also, if it makes sense semantically for your pointer to be copy-assigned from the other object, you should do so.</p></li>
</ul></li>
</ol>
",0
25708832,25708781,3,"<p>One of the possibilities is to make the objects constructor protected. Like this</p>

<pre><code>class Shape{
protected:
   Shape(){}//Only derived classes or friends can call this
public:
   void area(){}
};
class DShape:public Shape{
public:
   DShape(){}
};
int main(){
    Shape obj; // error: ¡®Shape::Shape()¡¯ is protected
    DShape obj2;//compiles fine
}
</code></pre>
",4
26208432,26208320,0,"<p>Change <code>HELP_HERE.operator==(dog.HELP_HERE)</code> to:</p>

<pre><code>Animal::operator==(dog)
</code></pre>

<p>In general you can get an Animal reference with: <code>Animal &amp;a = *this;</code> . C++ doesn't have a keyword which indicates ""the parent class"", however you can always make your child class contain <code>typedef Animal super;</code> and then you can use <code>super::operator==</code>, or <code>super &amp;a = *this;</code> etc.</p>
",3
31141524,31141500,0,"<p>It returns a <code>std::string</code> returned from function <code>strerror_r(errorNumber, buffer, maxLength);</code> </p>

<p>You are passing pointer to 'buffer' as a parameter to function <code>strerror_r</code> with other parameters like <code>maxlength</code> and <code>errorNumber</code>.</p>
",0
31141595,31141500,4,"<p>Yes, the function <code>strerror_r</code> uses <code>buffer</code> to store the message and returns it, but since the function <code>getErrnoString</code> returns a <code>std::string</code> then an <a href=""http://en.cppreference.com/w/cpp/language/converting_constructor"" rel=""nofollow"">implicit conversion constructor</a> is called:</p>

<pre><code>string::string(const char* data)
</code></pre>

<p>This constructor copies the data from the passed pointer to the internal buffer of the <code>std::string</code> itself so there are no problems since you then return a copy of the buffer stored in a <code>std::string</code> which you return by value.</p>
",0
31141699,31141500,2,"<p>The above code does not return a pointer to the local buffer. It does not return any pointers at all. It returns an <code>std::string</code> object constructed from the char buffer returned by <code>strerror_r</code>. It is perfectly safe to return <code>std::string</code> objects by value.</p>

<p>The <code>return</code> statement in this function performs an implicit conversion to <code>std::string</code> type. In explicit form it would look as follows</p>

<pre><code>return std::string(strerror_r(errorNumber, buffer, maxLength));
</code></pre>

<p>P.S. Note though that GNU-specific version of <code>strerror_r</code> used in the above code does not guarantee that the function will use the user-supplied buffer. The function is allowed to return a pointer to a system buffer, leaving the user-supplied buffer unused. But in general case the user has to assume that the user-supplied buffer will be used for the string.</p>
",0
26232542,26232482,7,"<p>If you define first and second before including anything, that includes <code>std::pair</code> inside <code>&lt;algorithm&gt;</code>, it will screw your code, because the variables inside <code>std::pair</code> are called <code>first</code> and <code>second</code>, and your macro is defined to that, so it expands the names to the expression they are defined to, making your code malformed.</p>

<p>Basically, its the same as doing</p>

<pre><code>#define A 1

class A{
};
</code></pre>

<p>This will also not compile, because A gets converted to 1, and <code>1</code> is not valid class name</p>
",0
26232549,26232482,1,"<p>As you can see, first and second are used all over the STL, so by defining them to nothing you've rendered it unparseable</p>
",0
23839878,23839754,0,"<p>Maybe something like this? I haven't tested this yet.</p>

<pre><code>#include &lt;thread&gt;
#include &lt;iostream&gt;

using namespace std;
bool loop;
int a = 0, b = 0;
void multiplication () {
    while(loop) {
        a += b;
        b = 0;
        // wait(1000);
        cout &lt;&lt; ""a = "" &lt;&lt; a &lt;&lt; endl;
    }
}

int main () {
   loop = true;
   thread myThread(multiplication);
   while(b != -1) {
       cin &gt;&gt; b;
   }
   loop = false;
   cout &lt;&lt; ""done!"" &lt;&lt; endl;
}
</code></pre>
",4
23840006,23839754,3,"<p>The C++ standard library doesn't define a non-blocking read function. You could create a reader thread which blocks on read and sets a properly synchronized variable which is read from another doing computations. I'd not pursue this direction, though.</p>

<p>Instead, I would set up <code>std::cin</code> to be non-blocking using some platform specific settings. On UNIX, you'd use <code>fcntl()</code> to put the standard input stream into non-blocking input mode:</p>

<pre><code>int flags = fcntl(0, F_GETFL);
fcntl(0, F_SETFL, flags | O_NONBLOCK);

unsigned long count(0);
for (char value(0); !(std::cin &gt;&gt; value) || value != '1'; ) {
    std::cin.clear();
    ++count;
}
std::cout &lt;&lt; count &lt;&lt; '\n';
</code></pre>
",0
24756184,24756082,-1,"<p>You should initialize any instance of a class. There is no way to have a ""dummy"" variable in no well-defined state, unless your class has a constructor without arguments.</p>

<p>Or, add a constructor with no arguments.</p>

<p>Note that assignment in <code>a = A(3)</code> calls an assignment operator on <code>a</code>.</p>
",4
24756193,24756082,2,"<p>The very point of the constructor with parameter is to ensure that no object of the class may exist without a initialised. You cannot ""call constructor later"". You may add another constructor though, without parameters.</p>
",1
24756239,24756082,0,"<p>Whenever you define an object. constructors get automatically called. What you may have as below:</p>

<pre><code>class A{
  int a;
 public:
  A(int x = 0){
    a=x;
  }
  A(const A&amp;arg) {a = arg.a;}
  A&amp; operator =(const A&amp;arg) {a = arg.a;return *this;}
};
int main(){
  A a;
  a=A(3);
  return 0;
}
</code></pre>

<p>Constructors may also have default arguments, so <code>A a;</code> might actually be implemented as like a call to constructor <code>A(0)</code> See  <a href=""https://stackoverflow.com/questions/187640/default-parameters-with-c-constructors"">Default parameters with C++ constructors</a></p>
",0
24756557,24756082,0,"<p>The issue here is that you have defined a constructor for A class which takes int as an argument. 
As you have defined your own constructor, compiler will not define default constructor for your class.</p>

<pre><code>A(int x)
{
        a=x;
}
</code></pre>

<p>When you call:</p>

<pre><code>A a;
</code></pre>

<p>This will look for a constructor for A class which does not take any argument. But that is not present. Thus the compilation error is coming.</p>
",0
24756824,24756082,2,"<p>The only good solution here is to avoid this situation arising in the first place.</p>

<p>The situation typically arises when you have something on the general order of having to create an object where its initial value depends on some condition, so conceptually what you want is something on this general order:</p>

<pre><code>if (xyz)
    A a(123);
else
    A a(456);

// code that uses A goes here
</code></pre>

<p>The problem in this case is that in this case, <code>A</code> goes out of scope before you can use it. The cure is typically to divide this code up into two functions, so you end up with something like this:</p>

<pre><code>if (xyz)
    code_that_uses_A(123);
else
    code_that_uses_A(456);
</code></pre>

<p>Although I certainly prefer to avoid it, there is another possibility that <em>can</em> be workable: a wrapper object that keeps track of whether the object it contains has been initialized or not. For example, it can contain a pointer to the actual object. This is initialized to a null pointer. When you initialize the object it contains, you allocate a contained object. Depending on what you want, attempting to re-initialize the container object could throw or it could just assign a new value to the contained object.</p>

<p>Of these two, the former is nearly always preferable. It tends to clean up the code and give each individual piece of code a single, clear responsibility. The latter can work, but generally requires quite a bit of work to get the wrapper object present a clean interface. Although I'd usually consider it a lesser concern, such a wrapper typically adds substantial overhead to using the wrapped object.</p>
",1
30137604,30137269,2,"<p>We can only specify data-type for the function parameters during function definition and declaration. When we make function call, then we simply pass actual values for those function parameters/arguments. Thus your function call syntax <code>int c = add2var(int a = 5, int b = 6.1);</code> is completely wrong. I have not seen parameter type in function call in any of the language i am are of.</p>

<p>There are many other things which are wrong in your code.</p>

<ol>
<li>call <code>int c = add2var(5, 6);</code> instead of <code>int c = add2var(int a = 5, int b = 6.1);</code>, we can not specify data type here. </li>
<li>passing floating point <code>6.1</code> for <code>int</code> is not good. it will be rounded off during function call.</li>
<li><p>Using const in below code for function parameter is ok in case if you want to inform your API users that your function parameters will be unmodified. However, it does not protect anything when you are passing parameter as value. Nobody can change meaning of ""5"" and ""6"" right ?</p>

<pre><code>int add2var(const int a, const int b)
{
    return a + b;
}
</code></pre></li>
<li><p>If your intention was to have default parameter then see below code. </p>

<pre><code>int add2var(int a = 5, int b = 6)
{
   a + b;
}

int main()
{
  add2var();         // result = 11, a will use default parameter 5 and b will use 6
  add2var(1);        // result = 7, b will use default parameter of 6
  add2var(2, 3); // result = 5, override default value for a and b
}
</code></pre></li>
</ol>
",0
30137439,30137269,2,"<p>There are two approaches. The first one is the following</p>

<pre><code>int a;
int b;
int c = add2var( a = 5, b = 6);
</code></pre>

<p>The second one is the following where the function has default arguments</p>

<pre><code>int add2var(const int a = 5, const int b = 6 );


int main()
{
    int c = add2var();
    //,,,
</code></pre>
",0
30138246,30137269,0,"<p>C++ does not directly support names parameters a.k.a. (Python) keyword arguments.</p>

<hr>

<p>Possibly you just want the ability to specify argument values, nothing more. I suspect that, because you're attempting to store a floating point value <code>6.7</code> in an <code>int</code>, which indicates that you're very new to programming. If that's all you want to, namely specify argument values, then you can use ordinary <strong>positional arguments</strong>, like this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

auto add2var( int const a, int const b )
    -&gt; int
{ return a + b; }

auto main() -&gt; int
{
    int const c = add2var( 5, 6 );
    cout &lt;&lt; c &lt;&lt; endl;
}
</code></pre>

<p>Note that there's no <code>stdafx.h</code> here.</p>

<p>In a Visual Studio project turn off precompiled header support in the project settings in order to make compile without <code>stdafx.h</code>, compile.</p>

<hr>

<p>If you really want to have named arguments For simple cases like the one presented you can use the <strong>named parameters idiom</strong> a.k.a. NMI. Essentially NMI consists in defining an arguments structure with chainable setters and default values. It's <a href=""https://isocpp.org/wiki/faq/ctors#named-parameter-idiom"" rel=""nofollow"">described in the C++ FAQ</a>.</p>

<pre><code>#include &lt;iostream&gt;

struct Args_add2var
{
    int     a_  = 0;
    int     b_  = 0;

    auto a( int const value )
        -&gt; Args_add2var&amp;
    { a_ = value; return *this; }

    auto b( int const value )
        -&gt; Args_add2var&amp;
    { b_ = value; return *this; }
};

auto add2var( Args_add2var const&amp; args )
    -&gt; int
{ return args.a_ + args.b_; }

auto main() -&gt; int
{
    using Args = Args_add2var;
    int const c = add2var( Args().a( 5 ).b( 6 ) );

    using namespace std;
    cout &lt;&lt; c &lt;&lt; endl;
}
</code></pre>

<hr>

<p>For a more general but restricted and IMHO pretty awkward solution, check out the <a href=""http://www.boost.org/doc/libs/1_37_0/libs/parameter/doc/html/index.html"" rel=""nofollow""><strong>Boost Parameters</strong> sub-library</a>. Essentially the idea there is to declare global objects with the names of the parameters, to support the initialization-in-call notation. That's one issue that makes the scheme awkward, and as I recall it also has problems with constructors.</p>

<pre><code>#include &lt;boost/parameter.hpp&gt;
#include &lt;iostream&gt;
using namespace std;

BOOST_PARAMETER_NAME( a )
BOOST_PARAMETER_NAME( b )

BOOST_PARAMETER_FUNCTION(
    (int),                  // 1. parenthesized return type
    add2var,                // 2. name of the function template
    tag,                    // 3. namespace of tag types, ""tag"" used by macro above
    (optional               // 4. two optional parameters, with defaults
        (a, (int), 0)
        (b, (int), 0)
        )
    )
{ return a + b; }

auto main() -&gt; int
{
    int const c = add2var( _a = 5, _b = 6 );
    cout &lt;&lt; c &lt;&lt; endl;
}
</code></pre>

<p>Note that e.g. <code>_a</code> is not a global <code>int</code> variable, rather it's a global variable that represents the argument <em>name</em>.</p>

<p>In more general code it would be placed in a namespace along with the function.</p>

<hr>

<p>For a more general discussion see my 2010 <a href=""http://www.drdobbs.com/cpp/pure-c-options-classes/224700827?queryText=C11"" rel=""nofollow"">DDJ article ""Pure C++ Options Classes""</a>. It does however suffer from Very Bad Formatting (it was nice as submitted), and the code is C++03. I would do things much more cleanly in C++11, but haven't looked at it since.</p>
",0
27573114,27573052,3,"<p>Declare member function <code>cmp</code> as a static member function. 
Take into account that it would be much better if the parameters of the function would be references.</p>

<p>The other way is to define a functional object inside the class. For example</p>

<pre><code>class MyClass {
    struct MyStruct {
        ...
    } MyStructArr[10];

    struct cmp
    {
        bool operator ()( const struct MyStruct &amp;a, const struct MyStruct &amp;b ) const
        {
            //....
        }
    };

    void fun() {
        ...  // setting values of MyStructArr
        sort(MyStructArr, MyStructArr + 10, cmp());
    }

        ...
</code></pre>

<p>Also you could define <code>operator &lt;</code> for structure <code>MyStruct</code>. In this case you could call <code>std::sort</code> without a predicate.</p>
",2
27573202,27573052,2,"<p><code>sort</code> will have some code that looks like this inside:</p>

<pre><code>template &lt;typename Iter, typename Cmp&gt;
void sort(Iter begin, Iter end, Cmp cmp)
{
    // other code
    if (cmp(a, b)) {       // &lt;-- !!!
        // Do something
    } else {
        // Do something else
    }
}
</code></pre>

<p>Note that to call <code>cmp</code> as you originally posted it, you would need something like:</p>

<pre><code>myClassInstance-&gt;cmp(a, b)
</code></pre>

<p>but <code>sort</code> doesn't have a <code>MyClass</code> to call <code>cmp</code> on, it only has the things it actually wants to compare.</p>

<p>You can either make your <code>cmp</code> not depend on <code>MyClass</code> (by making it a nonmember function or by making it <code>static</code>) or you can bind an instance of <code>MyClass</code> to it by using a lambda or <code>std::bind</code> or similar.</p>
",0
26434628,26434607,0,"<p>You need to actually convert the contents to which the pointer points to wide characters. The easiest way to do that is probably to put the narrow version into a string and convert using <code>wstring_convert</code> as detailed in this answer: <a href=""https://stackoverflow.com/a/18374698/82320"">https://stackoverflow.com/a/18374698/82320</a></p>
",1
23813157,23813144,5,"<p>The error is clear. You can only use <em>integral</em> types (<code>integer</code>, <code>enum</code>, <code>char</code> etc. which are <em>convertible</em> to <code>integral</code> value), or any <em>expression</em> that evaluates to an integral type in <code>switch</code> statement.</p>
",0
23813198,23813144,1,"<p><code>params[0]</code> has type of <code>std::string</code>. You can't use <code>std::string</code> type (which is not integral) as a <code>switch</code> parameter. If you are confident strings are not empty use <code>switch (param[0][0])</code> and <code>case 'd'</code>. But in this case you will be able to switch over one-character strings only. If you need to switch over longer strings you need to use the sequence of <code>if-else if-else if-...</code>.</p>
",0
26145449,26145419,5,"<p>You can use</p>

<pre><code>#include &lt;type_traits&gt;

// ...

template &lt;typename T&gt;
void foo() {
    do_something();
    if (std::is_same&lt;T,int&gt;::value) {
        do_somehting_else();
    }
}
</code></pre>

<p>You can learn more about type traits <a href=""http://en.cppreference.com/w/cpp/types"" rel=""noreferrer"">here</a>.</p>
",2
26145460,26145419,5,"<p>Just use a template specialization.</p>

<pre><code>template &lt;typename T&gt; void foo() { do_something(); }

template&lt;&gt; void foo&lt;int&gt;() { do_something(); do_something_else(); };
</code></pre>
",0
25459863,25459686,2,"<p>Static members need to be defined, so at least you need the following line after the class' declaration:</p>

<pre><code>int staticMem::myval;
</code></pre>
",2
25462317,25462047,1,"<p>When an element of a vector is erased then all elements after the erased element are moved left. So for example if the element with index 0 was erased then the first actual element of the vector will have index equal to 9. You must not to increase the index in this case.</p>

<p>The valid loop can look like</p>

<pre><code>for ( int i = 0; i &lt; numbers.size(); )
{
    if ( numbers[i] == 1 )
    {
        numbers.erase( numbers.begin() + i );
    }
    else
    {
        ++i;
    }
}
</code></pre>

<p>Take into account that it is simpler to apply standard algorithm <code>std::remove</code> declared in header <code>&lt;algorithm&gt;</code></p>

<p>For example</p>

<pre><code>#include &lt;algorithm&gt;

//...

numbers.erase( std::remove( numbers.begin(), numbers.end(), 1 ), numbers.end() );
</code></pre>

<p>Here is a demonstrative example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() 
{
    std::vector&lt;int&gt; v = { 1, 1, 2, 1, 3, 1, 4, 1, 5 };

    for ( int x : v ) std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; std::endl;

    v.erase( std::remove( v.begin(), v.end(), 1 ), v.end() );

    for ( int x : v ) std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>The output is</p>

<pre><code>1 1 2 1 3 1 4 1 5 
2 3 4 5
</code></pre>
",0
25462326,25462047,2,"<p>Your code says 
i  &lt; numbers.size(), and you increment i and also delete n[i](if it has 1)
After deleting , you should not increment i because a new number gets in the currrent position of i.</p>

<p>If numbers[]=<strong>{0,1,2,3,1,4}</strong> -> you get numbers[]=<strong>{0,2,3,4}</strong>  </p>

<p>If numbers[]=<strong>{0,1,1,2,3,1,4}</strong> -> you get numbers[]=<strong>{0,1,2,3,4}</strong>,                               </p>

<p>i.e after deleting , it skips the next number
just add i--; after deleting numbers[i]</p>

<p><code>for (int i = 0; i &lt; numbers.size(); i++){
    if (numbers[i] == 1){
        numbers.erase(numbers.begin() + i);
        i--;
    }
}</code>
This will give you the correct answer.</p>
",1
25462132,25462047,6,"<p>Let's try it out.</p>

<p>Say you have a vector with the contents <code>[1, 1, 1]</code> (all ones, just to keep it simple)</p>

<p>First iteration:</p>

<pre><code>for (int i = 0; i &lt; numbers.size(); i++) &lt;-- i == 0; numbers.size() == 3
{
    if (numbers[i] == 1) &lt;-- true
    {
        numbers.erase(numbers.begin() + i); &lt;-- erase is called on element #0
    }
}
</code></pre>

<p>Second iteration:
The vector now contains <code>[1, 1]</code> because we removed the 0th entry.</p>

<pre><code>for (int i = 0; i &lt; numbers.size(); i++) &lt;-- i == 1; numbers.size() == 2
{
    if (numbers[i] == 1) &lt;-- true
    {
        numbers.erase(numbers.begin() + i); &lt;-- erase is called on element #1
    }
}
</code></pre>

<p>Third iteration:
The vector now contains <code>[1]</code></p>

<pre><code>for (int i = 0; i &lt; numbers.size(); i++) &lt;-- i == 2; numbers.size() == 1; the loop condition is false, so we exit the loop
{
    if (numbers[i] == 1)
    {
        numbers.erase(numbers.begin() + i);
    }
}
</code></pre>

<p>Final result:</p>

<p>the vector contains <code>[1]</code>.</p>

<p>As you can probably see from evaluating the code line by line manually, the problem is that you increment <code>i</code> even after removing an element. Every time you remove an element, you shift all the remaining elment to lower indices, but at the same time, you increment the counter so the next index you look at is one higher. So when you remove element <code>i</code>, the element that was previously index <code>i+1</code> is moved to index <code>i</code>. But in the next iteration, you no longer look at index <code>i</code>, but instead <code>i+1</code>, so you skip past an element without ever looking at it.</p>
",2
24625598,24625082,1,"<p><em>Update:</em> The answer below assumes that the expression is evaluated during run-time, i.e. you are not adding compile-time constants. This is not necessarily true, your compiler may evaluate the expression during compile time. It may use higher precision for this. As suggested in the comments, the way you print out the number might be the root cause for your problem.</p>

<hr>

<p>If you absolutly need more precision and can't make any other twists, your only option is to increase precision. <code>double</code> values provide a precision of about 16 decimal digits. You have the following options:</p>

<ul>
<li><p>Use a library that provides higher precision by implementing floating point operations in software. This is slow, but you can get as precise as you want to, see e.g. GMP, the GNU Multiple Precision Library.</p></li>
<li><p>The other option is to use a <code>long double</code>, which is at least as precise as <code>double</code>. On some platforms, <code>long double</code> may even provide more precision than a <code>double</code>, but in general it does not. On your typical desktop PC it may be <code>80</code> bits long (compared to <code>64</code> bits), but this is not necessarily true and depends on your platform and your compiler. It is not portable.</p></li>
</ul>

<p>Maybe, you can avoid the hassle and tune your implementation a bit in order to avoid floating point errors. Can you reorder operations? Your intermediate results are of the form <code>1+x</code>. Is there a way to compute <code>x</code> instead of <code>1+x</code>? Subtracting <code>1</code> is not an option here, of course, because then precision of <code>x</code> is already lost.</p>
",0
22498705,22498670,2,"<p>You can't do it. Because you can not modify the header file of <code>std::list</code> (if you don't want change the standard).</p>

<p>You can wrap <code>std::list</code> with your custom class and export methods to it, then add your own methods.</p>
",0
33579226,33579217,0,"<p>Due to operator precedence, you need to use</p>

<pre><code>if ((i &amp; (1 &lt;&lt; j)) != 0)
</code></pre>

<p>Not the extra parens around the <code>&amp;</code> operator.</p>
",0
26417619,26417592,2,"<p>The <code>return 1</code> statement is causing your program to exit: you are returning from <code>main()</code></p>

<p>Just don't do that.</p>
",0
26417639,26417592,1,"<p>Try removing the <code>return 1</code> or changing it to <code>continue</code>. <code>return 1</code> returns code execution from <code>main</code> and not the loop.</p>
",0
26434958,26434867,-1,"<p>Can't leave a comment, but first off, try this:
instead of </p>

<pre><code>while (inputFile &gt;&gt; number)
</code></pre>

<p>try this</p>

<pre><code>while (!inputFile.eof)
</code></pre>

<p>I forget the exact syntax sitting here, I'm a student too, don't check for still reading, just look at either end of file, or peek at the next value to see if it is valid.</p>
",4
26435158,26434867,3,"<p>Your code is more complicated than it needs to be for the task you are trying to achieve.  Your <code>ReadData()</code> function is trying to do too much, which is complicating the rest of your code.  Get rid of it, then you can simplify the code to the following:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;

const int COMPANY_AMOUNT = 6, AMOUNT_OF_QUARTERS = 4;

int main()
{
    std::string Company[COMPANY_AMOUNT]; // Array for Company names
    double CompanySales[COMPANY_AMOUNT][AMOUNT_OF_QUARTERS]; // Array for Company profits

    std::ifstream inputFile(""C:\\TEMP\\Data.txt"");
    if (!inputFile)
    {
        std::cout &lt;&lt; ""Error opening file.\n"";
        system(""Pause"");
        return PROGRAM_FAILURE;
    }

    for (int x = 0; x &lt; COMPANY_AMOUNT; x++)
    {
        inputFile &gt;&gt; std::ws &gt;&gt; Company[x];
        if (!inputFile)
        {
            std::cout &lt;&lt; ""Error reading file.\n"";
            system(""Pause"");
            return PROGRAM_FAILURE;
        }

        if (inputFile.eof())
        {
            std::cout &lt;&lt; ""Unexpected EOF while reading file.\n"";
            system(""Pause"");
            return PROGRAM_FAILURE;
        }
    }

    for (int x = 0; x &lt; COMPANY_AMOUNT; x++)
    {
        for (int y = 0; y &lt; AMOUNT_OF_QUARTERS; y++)
        {
            inputFile &gt;&gt; std::ws &gt;&gt; CompanySales[x][y];
            if (!inputFile)
            {
                std::cout &lt;&lt; ""Error reading file.\n"";
                system(""Pause"");
                return PROGRAM_FAILURE;
            }
        }    
    }

    inputFile.close();

    // use arrays as neded...

    return 0;
}
</code></pre>

<p>If you absolutely must have a <code>ReadData()</code> function, then you need to re-design it, eg:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;

const int COMPANY_AMOUNT = 6, AMOUNT_OF_QUARTERS = 4;
void ReadData(std::string*, double[COMPANY_AMOUNT][AMOUNT_OF_QUARTERS]);

int main()
{
    std::string Company[COMPANY_AMOUNT]; // Array for Company names
    double CompanySales[COMPANY_AMOUNT][AMOUNT_OF_QUARTERS]; // Array for Company profits

    ReadData(Company, CompanySales);

    // use arrays as neded...

    return 0;
}

void ReadData(std::string* Names, double Sales[COMPANY_AMOUNT][AMOUNT_OF_QUARTERS])
{
    std::ifstream inputFile(""C:\\TEMP\\Data.txt"");
    if (!inputFile)
    {
        std::cout &lt;&lt; ""Error opening file.\n"";
        system(""Pause"");
        exit(PROGRAM_FAILURE);
    }

    for (int x = 0; x &lt; COMPANY_AMOUNT; x++)
    {
        inputFile &gt;&gt; std::ws &gt;&gt; Names[x];
        if (!inputFile)
        {
            std::cout &lt;&lt; ""Error reading file.\n"";
            system(""Pause"");
            exit(PROGRAM_FAILURE);
        }

        if (inputFile.eof())
        {
            std::cout &lt;&lt; ""Unexpected EOF while reading file.\n"";
            system(""Pause"");
            exit(PROGRAM_FAILURE);
        }
    }

    for (int x = 0; x &lt; COMPANY_AMOUNT; x++)
    {
        for (int y = 0; y &lt; AMOUNT_OF_QUARTERS; y++)
        {
            inputFile &gt;&gt; std::ws &gt;&gt; Sales[x][y];
            if (!inputFile)
            {
                std::cout &lt;&lt; ""Error reading file.\n"";
                system(""Pause"");
                exit(PROGRAM_FAILURE);
            }
        }    
    }
}
</code></pre>
",5
24622955,24622924,0,"<pre><code>if ( str.size() &gt;= MAX )
    throw......

std::strcpy(cstring, str.c_str());
</code></pre>

<p>note: The size check is not required if you are only erasing characters; however it makes your code more robust to include it, because you are less likely to introduce a bug in future by doing a different string operation and not realizing that you now actually do need to do the check.</p>

<p>NB. consider making <code>cstring</code> a <code>std::string</code> also! Then all these problems go away.</p>
",0
24622989,24622924,0,"<p>Is this what you are trying to do?</p>

<pre><code>void removeFirstCharacter()
{
    char* it = cstring;
    while (*it)
    {
        *it = *(it + 1);
        ++it;
    }
}
</code></pre>

<p>Or this?</p>

<pre><code>void removeFirstCharacter(char* stringToChange)
{
    char* it = stringToChange;
    while (*it)
    {
        *it = *(it + 1);
        ++it;
    }
}
</code></pre>
",0
30177078,30177028,1,"<p>The author means Microsoft's compiler, more formally known as MSVC.</p>
",2
27125855,27125793,5,"<p>If you declare a function, rather than pointer, type alias</p>

<pre><code>typedef void CommandFunction(const InputArgsMap &amp;, const ArgumentMap *);
</code></pre>

<p>then you can use it to declare functions</p>

<pre><code>CommandFunction _fcn_1;
CommandFunction _fcn_2;
</code></pre>

<p>You'll still need to write out the parameter list when you define them.</p>

<blockquote>
  <p>is there any other (better, oop) way?</p>
</blockquote>

<p>Overriding a virtual member function of an abstract interface might be nicer, depending on exactly what you're doing. You will have to duplicate the parameter list if you do that, which you seem to find distasteful; but in modern C++ you can at least use the <code>override</code> specifier to make sure you get that right.</p>
",2
24627062,24626843,4,"<p>The <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits"" rel=""nofollow""><code>numeric_limits</code></a> template from <code>&lt;limits&gt;</code> gives various constants that might be useful:</p>

<ul>
<li><a href=""http://en.cppreference.com/w/cpp/types/numeric_limits/radix"" rel=""nofollow""><code>radix</code></a> to indicate whether the representation is binary, decimal or something else;</li>
<li><a href=""http://en.cppreference.com/w/cpp/types/numeric_limits/digits"" rel=""nofollow""><code>digits</code></a> for the number of mantissa bits (assuming a binary radix)</li>
<li><a href=""http://en.cppreference.com/w/cpp/types/numeric_limits/min_exponent"" rel=""nofollow""><code>min_exponent</code></a> and <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits/max_exponent"" rel=""nofollow""><code>max_exponent</code></a> from which the range (and hence number of bits) of the the exponent can be calculated.</li>
</ul>

<p>There will only be one sign bit in any sane representation.</p>
",5
24585241,24585063,4,"<p>You should define it like following outside of class <code>Fract</code></p>

<pre><code>template &lt;class C&gt;
std::ostream&amp; operator &lt;&lt;(std::ostream&amp; out, const Fract&lt;C&gt;&amp; f)
{
    // ....
    return out ;
}
</code></pre>

<p><sup><strong><em>SEE <a href=""http://coliru.stacked-crooked.com/a/85b02c39da1afa90"" rel=""nofollow"">HERE</a></em></strong></sup></p>
",1
34186483,34185931,4,"<p>You are going out of bounds:</p>

<pre><code>stages = new string**[num_of_stages];
    for(int i = 0 ; i &lt; N ; i ++) {
        stages[i] = new string*[N];
</code></pre>

<p>If <code>num_of_stages &lt; N</code> you are accessing past the array.</p>

<p>You should use a <code>std::vector</code> instead of dealing with raw pointers and using <code>new/delete</code> yourself. It has an <code>at</code> function that does bounds checking.</p>
",1
23851524,23851477,1,"<p>You have the definition of a default constructor and destructor, but no prototype for them in the class definition. Amend fuelgauge.h with the following.    </p>

<pre><code>class FuelGauge
{
public:
    FuelGauge();
    ~FuelGauge();
    ...
}
</code></pre>
",1
24079027,24078745,0,"<p>Use this code to handle negative input</p>

<pre><code>int square (int x) 
{
    unsigned int result = 0;
    unsigned int absolute_x = std::abs(x);

    for (unsigned int i = 0; i &lt; absolute_x; ++i)
    {
        result += absolute_x;
    }

    return result;
}
</code></pre>
",0
24078791,24078745,0,"<p>You have to chage your code to the follwoing one:</p>

<pre><code>for (int i = 0; i &lt;= x; ++i) {
    x += x; // adding the value of x to x each time 
}
return x;
</code></pre>

<p>The reason why your code doesn't work as it should be, was that you had your return element int you <code>for</code> loop. Also you have to change you accumulator.</p>

<pre><code>int result = 0;
for (int i = 0; i &lt; x; ++i) {
    result += x; // adding the value of x to the accumulator.
}
return result;
</code></pre>
",4
24079260,24078745,0,"<pre><code>int square (int x) {
for (int i = 0; i &lt;= x; ++i) {
x += x; // adding the value of x to x each time 
return x;
}
}
</code></pre>

<p>Your <code>return x;</code> is inside your loop so after it increases the value of x the first time it just returns, also you can't say <code>i &lt;= x</code> since you'll be changing the value x. So if you want to make your code work you need to put <code>return x;</code> at the end of your function and create another int variable to memorize the value of x else you'll end up in infinite loop and your program would crash.</p>

<pre><code>int square (int x) {
int j = x;
for (int i = 0; i &lt;= j; ++i) {
x += x; // adding the value of x to x each time 
}
return x;
}
</code></pre>

<p>That way it will make additions until you have x = x^2 and then it will exit the loop and return the value.</p>

<p>You can also use sqrt(x) from math library for the same result. But note that <code>return</code> always acts in the same way as <code>break;</code> so it will stop the execution of your loop (and function / program ) when it reaches that point. For instance you could write your code like:</p>

<pre><code>while(1){
++i;
if(i&gt;j) return x;
x+=x;
}
</code></pre>
",0
24600503,24598843,1,"<p>When queue is empty <code>QFront == QRear</code>, so when you set next element for <code>QRear</code>, you'll effectively set up next element for QFront, too. That's how QFront knows which element is next.</p>

<p>I believe that setting <code>QRear</code> to <code>NULL</code> in <code>dequeue</code> is unnecessary since it's not used in <code>enqueue</code> in case of empty queue.</p>
",0
24087291,24087187,3,"<p>Your single argument constructor</p>
<pre><code>iterator::iterator(Node&lt;Priority,T&gt;* node) : node(node) {}
</code></pre>
<p>establishes a user-defined conversion from a pointer type <code>Node&lt;Priority,T&gt;*</code> to <code>iterator</code>.  Since <code>nullptr_t</code> implicitly converts to any pointer type, that gives you a conversion from <code>nullptr</code> to your <code>iterator</code> type.  The line <code>z = nullptr;</code> in your example then implicitly converts <code>nullptr</code> to the iterator type, before calling the automatically-generated move- or copy-assignment operator.</p>
<p>Fix: Add the <code>explicit</code> keyword to your constructor.</p>
<pre><code>explicit iterator(Node&lt;Priority,T&gt;* node) : node(node) {}
</code></pre>
<hr />
<p>Rule from the Standard, section 12.3.1:</p>
<blockquote>
<p>A constructor declared without the <em>function-specifier</em> <code>explicit</code> speci?es a conversion from the types of its parameters to the type of its class.  Such a constructor is called a <em>converting constructor</em>.</p>
<p>An  explicit  constructor  constructs  objects  just  like  non-explicit  constructors,  but  does  so  only  where  the direct-initialization  syntax  (8.5)  or  where  casts  (5.2.9,  5.4)  are  explicitly  used.  A default  constructor may be an explicit constructor;  such a constructor will be used to perform default-initialization or value-initialization (8.5).</p>
</blockquote>
",0
25697628,25697602,1,"<p>*a refers to the first element of a[] which is 10. You will get an compiler error at a++. This is because you cannot increment value of a. *a is a constant pointer pointing to the first element of a[] and its address cannot be changed..</p>

<p>It should be:</p>

<pre><code> int a[]={10,20,30,45,50};
 int j;
 for(j=0;j&lt;=4;j++)
 {
     cout&lt;&lt;*(a+j);
 }
</code></pre>
",1
25697874,25697602,1,"<p><strong>It doesn't compile because arrays are not pointers:</strong></p>

<hr>

<p>With <code>int arr[] = {...}</code>:</p>

<ul>
<li><p>The values of <code>arr</code> and <code>&amp;arr</code> are necessarily identical</p></li>
<li><p><code>arr</code> points to a valid memory address, but cannot be set to point to another memory address</p></li>
</ul>

<hr>

<p>With <code>int* ptr = ...</code>:</p>

<ul>
<li><p>The values of <code>ptr</code> and <code>&amp;ptr</code> are not necessarily identical (in fact, they are mostly different)</p></li>
<li><p><code>ptr</code> can be set to point to both valid and invalid memory addresses, as many times as you will</p></li>
</ul>
",0
23854604,23854541,4,"<p>The problem is that <code>Hero.h</code> and <code>Creature.h</code> include each other: you have a cyclic dependency. When <code>Hero.h</code> includes <code>Creature.h</code> and <code>Creature.h</code> tries to include <code>Hero.h</code> again, <code>HERO_H_</code> is already defined, and thus nothing gets inserted (if you removed the include guards, you would get an endless include cycle which is no good either).</p>

<p>However, it seems that <code>Creature.h</code> does not actually use <code>Hero.h</code>, so you can just remove this header. If you later do need something from the header, you may very well get away with a <em>forward declaration</em>. For more on this, see the C++ FAQ entry <a href=""http://www.parashift.com/c++-faq/forward-decl.html"" rel=""nofollow"">""How can I create two classes that both know about each other?""</a>.</p>
",0
26441058,26440874,1,"<p>You can partially specialise a class template, but you cannot partially specialise a <em>member</em> of a class template. And that's precisely what you're trying to do with the <code>pair</code> thing.</p>

<p>Why preceisely the attempts don't work:</p>

<pre><code>template &lt;&gt; const char* name&lt;template&lt;typename,typename&gt; class T&gt;::value = ""pair"";
</code></pre>

<p>An explicit specialisation (that is, not a partial specialisation) is not a template. It is prefixed by <code>template &lt;&gt;</code>, and the fully specialised template name has to have arguments specified for all template parameters. So you could do for example this:</p>

<pre><code>template &lt;&gt; const char* name&lt;std::pair&lt;int, double&gt;&gt;::value = ""pair"";
</code></pre>

<p>But your original code is syntactic nonsense - if anything, it looks like trying to declare a two-parameter class template <code>T</code> inside the template argument list.</p>

<p>As to the second line:</p>

<pre><code>template &lt;typename T1, typename T2&gt; const char* name&lt;std::pair&lt;T1,T2&gt;&gt;::value = ""pair"";
</code></pre>

<p>This is correct syntax for partial specialisation. Unfortunately, as I said above, you cannot partially specialise class template members, only entire class templates. So you have to do this:</p>

<pre><code>template &lt;typename T1, typename T2&gt; struct name&lt;std::pair&lt;T1,T2&gt;&gt;
{
  static const char* value;
};

template &lt;typename T1, typename T2&gt; const char* name&lt;std::pair&lt;T1,T2&gt;&gt;::value = ""pair"";
</code></pre>
",0
34182119,34182008,2,"<p>Throwing an exception from a constructor does not leave you with a half-constructed object. By design, that object does not exist. All the members that were constructed up till the point of the exception will be destroyed.</p>

<p>The solution here is for your object to support a flag that indicates how much data it has.</p>

<p>for example:</p>

<pre><code>class Object {
public:
    Object() {

        read_data1();
        ..
        if(!unsupported_kind)
        {
            read_data2();
            _has_supported_data = true;
        }
    }

    bool has_supported_data() const {
        return _has_supported_data;
    }

    std::vector&lt;char&gt; data1;
    std::vector&lt;char&gt; data2;

private:
    bool _has_supported_data = false;
};
</code></pre>
",0
24626922,24626864,4,"<p>You are using goto, and if you are using goto, raptors will tear you to pieces. Do not, under any circumstances use goto!</p>

<p>But you can use functions to make your code a bit clearer. This wall of text and copy paste is really hard to read.</p>
",0
24632450,24626864,0,"<p>First of all the formula you are using to calculate the random number is wrong. Suppose that min is 10, and max is 12. Then the rand() % max could be, let's say, 10. Adding min (10), the number to guess would be 20 - far greater than max... It should be <code>secret = rand() % (max-min +1) + min;</code> (if your interval is [min, max]).</p>

<p>Now to your question - as far as I understood you want to know if the entered guess is a number. Here is what you can do:</p>

<pre><code>    while(1)
   {
        cin &gt;&gt; guess;

         if(cin){
     if (guess &gt; max){
         cout &lt;&lt; ""Too high!\n\n"";
         cin.clear();
         cin.ignore();
         continue;
     }
     else if (guess &lt; min){
         cout &lt;&lt; ""Too low!\n\n"";
         cin.clear();
         cin.ignore();
         continue;
     }
     else if(guess != secret){
         deposit-=bet;
         cout&lt;&lt; ""Sorry, U lose RM ""&lt;&lt; bet;
     }
     else if(guess == secret){
         bet*=10;
         deposit+=bet;
         cout&lt;&lt; ""\n\nCongratulation! U earn RM ""&lt;&lt; bet;
     }
     break;
 }
 else
 {

     cin.clear();
     cin.ignore();
     cout &lt;&lt; ""Error! You did not enter a number!"" &lt;&lt; endl;
     continue;
 }
}
</code></pre>

<p>If the user didn't enter a number, the cin's fail flag will be up and you can use that.</p>

<p>Also, when trying again (<code>goto AA;</code>) you do not compute the random value again and you should. In order to get a different sequence of random numbers from rand() every time you start the program, you should seed the random generator from the current time. In the beginning of main, put <code>srand((unsigned int)time(NULL));</code> What this does is that it gives the random generator a number and on its base it will generate random numbers. If the number is the same every time the program is started, the same numbers will be generated. But given the always changing current time, every time the sequence will be different.</p>

<p>Using <em>goto</em> can make your code very messy and can make bugs very hard to notice. Yes, it is a part of the language and it is there to be used, but one should be very careful with it. Especially if you are new to programming, try to refrain from using it. You could use <code>while(1)</code> or <code>for(;;)</code> if you need endless loops - you can get to the next iteration with <code>continue;</code> and stop them with <code>break;</code>.</p>

<p>Something is also wrong with the guessing loop. It seems that you cannot lose. You should decrease the deposit in the while loop and check if it is 0.</p>

<p>Edit: In the edited code you can see that whenever the user needs to enter the number again, you just skip the iteration with continue. This is also an example how you should deal with endless loops instead of using goto. With practice, you will get he hang of it. ;)</p>

<p>Edit 2:</p>

<pre><code>    do{
     cout&lt;&lt; ""Wanna play again (y/n)? ""; 
     cin&gt;&gt; reply;

     if( reply!='y'&amp;&amp; reply!='n')      
         cout&lt;&lt; ""\nReally? Ok, try again! \n"";

 }while(reply!='n' &amp;&amp; reply!='y');

 if( reply =='y')
         goto AA;

 if(reply=='n'){
     cout&lt;&lt; ""\n\n\n""&lt;&lt; setw(80)&lt;&lt; setfill('+')&lt;&lt; ""\n\n"";
     cout&lt;&lt; setw(30)&lt;&lt; ""THX FOR PLAYING! UR CURRENT BALANCE IS RM ""&lt;&lt; deposit&lt;&lt; ""\n\n"";
     cout&lt;&lt; setfill('+')&lt;&lt; setw(80)&lt;&lt; ""\n"";
 }
</code></pre>

<p>This should make the reply cycle work. Your program should consist of different chunks of code for different purposes, and in this cycle you mixed up checking the correctness of the answer with what will happen if the answer is correct. It's easier first to do the first, and then to do the second thing. Using functions can generally help you with this.</p>

<p>Edit 3: In that new code you have a lot of problems with if statement. Firstly, what is !> ? I think you meant &lt; or &lt;= , !> does not exist, it won't even compile. Another thing - what happens when max or min is 0? You haven't covered that. </p>

<p>You use if-else chains a lot and in this case it is not necessarily needed. For example you don't need <code>if(min&gt;0)</code> , you don't even need the else before it. If you don't enter one of the if statement - the input is correct and you can break, if you enter one of them - it has continue; in it and the code below is not executed. The same goes for the last if statement in the max if-else chain executed if the input is a number.</p>

<p>Anyway, you could do it a lot simpler. For example the min loop can be:</p>

<pre><code>cout &lt;&lt; ""Pls enter the min of secret number\n"";
while (!(cin &gt;&gt; min) || min&lt;=0){

        cout &lt;&lt; ""Pls enter the min of secret number\n"";
        cin.clear();
        cin.ignore();

}
</code></pre>

<p>You could see that this will work if you realize that you should break if (cin &amp;&amp; min>0). Now when you negate that in order to place it as the while condition it becomes (!cin || min&lt;=0).</p>

<p>Anyway, I didn't see any other problem in the code, I tested it and it worked. And now without goto it looks a lot better.</p>
",7
25540943,25540848,15,"<p>You would pass <code>-I /usr/local/include</code> to the compiler as preprocessor flag, and <code>-L /usr/local/lib</code> to the compiler as linker flag. So to build a single source application <code>small.cc</code> compile it as</p>

<pre><code>  g++ -Wall -I /usr/local/include -L /usr/local/lib \
      small.cc -o small -lglfw3
</code></pre>

<p>If building with <code>make</code> just have</p>

<pre><code>  CXXFLAGS += -I/usr/local/include
  LDFLAGS += -L/usr/local/lib
</code></pre>

<p>in your <code>Makefile</code></p>

<p>If using shared libraries, add once <code>/usr/local/lib</code> to <code>/etc/ld.so.conf</code> and run <code>ldconfig</code> (at least on Linux).</p>
",0
24629944,24629788,3,"<p>My bet is that <code>htons</code> is a macro expanding to an expression with casts and shifts. The benefit of a macro, as opposed to an inline function, is that it works in a constant expression. (C++11 enables suitable inline functions in constants.)</p>

<p>All the inline-function-like macros in the C and POSIX libraries are also required to exist as <code>extern</code> functions. You can defeat the macro and call the function instead by parenthesizing its name:</p>

<pre><code>mFarEnd.sin_port = (htons)( g_DolCommsUdpPort );
</code></pre>

<p>It's also tempting to <code>#undef htons</code>, but this is illegal (undefined behavior). For example, the implementation could internally be using the macro to generate a constant, in some totally unrelated macro.</p>
",0
22124760,22124694,0,"<p>The answer in your particular case is <code>you can't</code>,<br>
Your if statements have particular conditions, which,<br>
wouldn't really work inside a <code>switch</code>.</p>

<p>An example of <code>if</code>/<code>else if</code>/<code>else</code> statements that can be<br>
translated into a <code>switch</code> would be:</p>

<pre><code>if(i == 1) {
    // code here
} else if(i == 2) {
    // code here
} else if(i == 3) {
    // code here
} else {
    // code here
}
</code></pre>

<p>which would translate to:</p>

<pre><code>switch(i) {
    case 1:
        //code here
        break;
    case 2:
        //code here
        break;
    case 3:
        //code here
        break;
    default:
        //code here
        break;
}
</code></pre>

<p>Hope that helps a bit to understand a little more about <code>switch</code> statements.</p>
",0
22124768,22124694,2,"<p>That is not a good way to write a program. What if you need 4 integers? 
One way to do it would be to use a list like <code>std::vector</code> and sort it. </p>

<pre><code>vector&lt;int&gt; numbers;

int number = 0;
while (numbers.size() &lt; 3 &amp;&amp; cin &gt;&gt; number)
    numbers.push_back(number);

sort(cbegin(numbers), cend(numbers)); // sorts ascending by default

for (auto number : numbers)
    cout &lt;&lt; number &lt;&lt; "" "";

cout &lt;&lt; endl;
</code></pre>

<p>You can also use <code>std::multiset</code> which sorts its items automatically as they are inserted. </p>
",2
22124846,22124694,1,"<p>Instead of this approach, why don't you store the input in an array and try any of the sorting alogrithms to sort your input?</p>
",0
22124862,22124694,0,"<p>If the challenge is that you can't sort the numbers, and the limit is 3 integers, then there are better ways to accomplish what you're doing.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
   int combo[6][3] = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
   int values[3];
   cin &gt;&gt; values[0] &gt;&gt; values[1] &gt;&gt; values[2];
   for (int i = 0; i &lt; 6; ++i )
   {
      if ( values[combo[i][0]] &lt;= values[combo[i][1]] &amp;&amp; 
           values[combo[i][1]] &lt;= values[combo[i][2]] )
      {
          cout &lt;&lt; values[combo[i][0]] &lt;&lt; "" "" &lt;&lt; values[combo[i][1]] &lt;&lt;
                "" "" &lt;&lt; values[combo[i][2]];
          break;
      } 
   }
}
</code></pre>

<p>The combo array holds all of the combinations that can occur with 3 slots.  Also note that the input is an array.  Even if you didn't use the loop, the maximum if() statements you would need is 6.</p>

<p>However you should mention up front that this is a challenge, and what the restrictions are.  Otherwise, please look at the other answers concerning storing and sorting these numbers.</p>
",0
22124928,22124694,0,"<p>You only need three conditional swaps to sort a list of three elements:</p>

<pre><code>int x, y, z;
cout &lt;&lt; ""please enter three integers:"";
cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;

if (y &lt; x) swap(y, x);
if (z &lt; y) swap(z, y);
if (y &lt; x) swap(y, x);

cout &lt;&lt; x &lt;&lt; "" "" &lt;&lt; y &lt;&lt; "" "" &lt;&lt; z &lt;&lt; endl;
</code></pre>

<p>Note that this approach doesn't scale. For 10 numbers, you would already need 45 conditional swaps.</p>
",0
24641934,24641862,0,"<p>Here you go, by using for loop it's simple to do what you ask. Read a bit more about for loops and general programming principles. Look at <a href=""http://www.reddit.com/r/learnprogramming/"" rel=""nofollow"">this</a> subreddit sidebar for good resources. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
    //Get number of grades.
    int nofgrades; // Why did you initialize it when you're going to override it anyway?
    cout &lt;&lt; ""How many grades do you want to calculate?\n"";
    cin &gt;&gt; nofgrades;
    //Get grades.
    for (int i = 1; i &lt;= nofgrades; ++i) {
        cout &lt;&lt; ""What's the "" &lt;&lt; i &lt;&lt; ""st grade?\n"";
        //Load aditional grades... 
    }
    //Calculate average.

    //Display average.


    return 0;
}
</code></pre>
",4
24086729,24086696,1,"<p>You can write <code>T t{};</code> in C++11.</p>
",1
24646297,24645970,1,"<p>The problem is not with the <code>cout</code>.</p>

<p>First, your <code>Odd</code> and <code>Even</code> functions should not take pointers, as you are returning the value already.</p>

<p>Second, you're not initializing the variable <code>cycle</code> in the <code>Cycle</code> function.</p>

<p>This code runs correctly:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int Even(int num){

    return (num)/2;
}


int Odd(int num){

    return (3*(num)+1);
}

int Cycle (int num){
    int cycle = 0;

    while (num != 1){

        if( num%2 == 0 ){

            num= Even(num) ;

        }else{

            num = Odd(num) ;
        }

        cycle++;
    }
    return  (cycle+1) ;
}



int main(){

    int num1,num2, max=0, answer;
    cin&gt;&gt;num1;
    cin&gt;&gt;num2;
    for(int i = (num1 &lt; num2 ?  num1 : num2) ; i&lt;=num2 ; i++ ){

        answer = Cycle(i);

        if(max &lt; answer){
            max = answer;
        }

    }

    cout &lt;&lt;""Final Answer ""&lt;&lt; max &lt;&lt;""\n"" ;

    return 0;
}
</code></pre>
",2
24623623,24623601,3,"<p>it's an integer. Declare your function as int.</p>
",0
24623626,24623601,6,"<p>It's a preprocessor macro defined by <code>#include &lt;cstdlib&gt;</code>. </p>

<p>It expands to an integral constant expression. This is not necessarily of type <code>int</code>, however it must have a value within the valid range of <code>int</code> so that it can be passed to <code>exit()</code>.</p>
",0
24623630,24623601,2,"<p>EXIT_FAILURE is an <code>int</code> declared in <code>stdlib.h</code> (or <code>cstdlib</code>), so it's a primitive type, not a class.</p>
",3
24623646,24623601,2,"<p><code>EXIT_SUCCESS</code>  and <code>EXIT_FAILURE</code> are macros defined in <code>stdlib.h</code> or <code>cstdlib</code>.</p>
",0
22152351,22152350,0,"<p>You're dereferencing the <code>end</code> iterator in your second loop.</p>

<pre><code>while (*vectIt == currentVal) {
    cout &lt;&lt; *vectIt &lt;&lt; "" "";
    if (vectIt &lt; myVect.end()) {
        ++vectIt;
    } 
}
</code></pre>

<p>just manually go through the case of <code>vectIt</code> being the last element in the vector (i.e. <code>myVect.end() - 1</code>, like you got when it is at the 3rd <code>80</code>):</p>

<pre><code>if (vectIt &lt; myVect.end()) { // will still be true
    ++vectIt; // now you set it to myVect.end()
}
</code></pre>

<p>now in the next iteration you check:</p>

<pre><code>while (*vectIt == currentVal) // here you dereference it without checking for myVect.end()
</code></pre>

<p>you should change that condition to:</p>

<pre><code>while (vectIt != myVect.end() &amp;&amp; *vectIt == currentVal)
</code></pre>

<hr>

<hr>

<p>Note: This only works if the last elements in the vector are at least 2 equal ones. If the last element in the vector isn't equal to the one before it as in <code>{-47, -2, -2, 19, 80, 80, 80, 100}</code> then you'd hit myVect.end() only after your
    vectIt = adjacent_find(vectIt, myVect.end());</p>

<p>and would either <code>break</code> after it if <code>vectIt</code> is equal to <code>myVect.end()</code> or rather, like I'd suggest put the updating in the while condition.</p>

<pre><code>vector&lt;int&gt;::iterator vectIt = myVect.begin();  
while ( ( vectIt = adjacent_find(vectIt, myVect.end()) ) != myVect.end()) {
    int currentVal = *vectIt; 
    while (vectIt != myVect.end() &amp;&amp; *vectIt == currentVal) {
        cout &lt;&lt; *vectIt &lt;&lt; "" "";
        if (vectIt &lt; myVect.end()) {
            ++vectIt;
        } 
    }
    cout &lt;&lt; endl; 
}
</code></pre>
",1
31871000,31870970,8,"<p>It's two totally unrelated things, perhaps better thought of as</p>

<pre><code>&amp;(::google::protobuf::internal::kEmptyString)
</code></pre>

<p><code>&amp;</code> just means the address-of operator, exactly the same as if you'd done:</p>

<pre><code>int xyzzy = 7;
int *pointer_to_xyzzy = &amp;xyzzy;
</code></pre>

<p>The <code>::</code>, on the other hand, is the global namespace specifier, to ensure you don't start looking in your <em>current</em> namespace.</p>

<p>For example, the following program:</p>

<pre><code>#include &lt;iostream&gt;

int x = 7;
namespace xyzzy {
    int x = 42;
    int getxa() { return ::x; }
    int getxb() { return x; }
}

int main() {
    std::cout &lt;&lt; xyzzy::getxa() &lt;&lt; '\n';
    std::cout &lt;&lt; xyzzy::getxb() &lt;&lt; '\n';
    return 0;
}
</code></pre>

<p>outputs <code>7</code> followed by <code>42</code> since the <code>getxa()</code> function uses the global namespace specifier rather than the <code>xyzzy</code> one.</p>
",0
24351447,24351430,1,"<p>Each class definition must end with a semicolon.  For example:</p>

<pre><code>class Foo {};
</code></pre>
",1
24351456,24351430,0,"<p>Put a semicolon after each class definition:</p>

<pre><code>class MyParser {
    //... body
};
 ^
</code></pre>

<p>Then initialize the members of a class in the constructor initialization list:</p>

<pre><code>class MyMainClass{
    private:    
    MyParser JustPars;
    FILE_ File;
    public:
         MyMainClass( MyMainClass* globInst) : JustPars( globInst ),
                                               File( globInst)
                                               {}
}
</code></pre>
",6
26774769,26774712,1,"<p>The problem states that <code>2 &lt;= n &lt;= 2 * 10^5</code>, but your <code>a</code> array can hold only 1000 integers!</p>

<p>Hence, you have an index out of bounds once you <code>cin &gt;&gt; a[1000];</code>.</p>
",0
24109024,24108939,1,"<p><code>""\n""</code> is a string literal that has type <code>const char[2]</code> and contains two characters: <code>'\n'</code> and <code>'\0'</code>.</p>

<p><code>'\n'</code> - is an escape character literal that has type <code>char</code>.</p>

<p>Take into account that variable <code>result</code> in your function was not initialized.</p>
",2
24109085,24108939,0,"<p><code>'\n'</code> is a char, whereas <code>""\n""</code> is a string literal (of type <code>const char[2]</code> last one for null )</p>

<p>For counting prefer algorithm</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iterator&gt;
//..

std::size_t result = std::count( std::istream_iterator&lt;char&gt;(myfile), 
                                 std::istream_iterator&lt;char&gt;(),
                                  mychar 
                                ) ;
</code></pre>
",0
24109373,24108939,0,"<p>You may want to make a histogram, while you are reading the file:  </p>

<pre><code>std::vector&lt;char&gt; character_counts(256); // Assuming ASCII characters

// ...

char c;
while (cin &gt;&gt; c) // The proper way to read in a character and check for eof
{
  character_counts[c]++; // Increment the number of occurances of the character.
}
</code></pre>

<p>In the case you posted, you could find the number of '\n' by:</p>

<pre><code>cout &lt;&lt; ""Number of \'\\n\' is: "" &lt;&lt; character_counts['\n'] &lt;&lt; endl;
</code></pre>
",0
27528551,27528453,0,"<p>In this case the class member parameter <strong>shadows</strong> the global variable. Thus you see it in the scope of the method. </p>
",0
27528625,27528453,4,"<p>The class variable shadows the global variable. If you want to access the global variable do it like this:</p>

<pre><code>void SomeClass::OperateOnNum()
{
    ::Num = 0;
}
</code></pre>

<p>There's no warnings, because that's just how the language works.</p>
",0
27528922,27528453,1,"<p>You can always use <code>this</code> and global scope resolution to dissambiguate between the two </p>

<pre><code>this-&gt;Num; // refers to the member Num
::Num;     // refers to the global Num
</code></pre>

<p>A good design though, shouldn't have to resort to such methods. You can mark member names and globals (which are a ""don't"" on their own) accordingly :</p>

<pre><code>_name;  // member name prefixed with _
m_name; // member name prefixed with m_
global_name; // global name - prefixed with global_
</code></pre>
",0
26413981,26413957,2,"<p>The compiler can create a temporary from the constant and temporaries are allowed to bind to const references. If the reference wasn't const, this wouldn't be allowed.</p>
",2
26413999,26413957,6,"<p>Constant lvalue references can bind to rvalues. Rvalues, like your literal <code>1</code>, don't have a persistent alias, so if you were to modifying it, you wouldn't be able to observe the effect, but if you promise not to modify it (namely by accessing it through a constant reference), you can still have perfectly sensible code, and that's why this binding is allowed.</p>

<p>(You can also bind rvalues to (mutable) <em>rvalue references</em>: <code>void function(int &amp;&amp;)</code> In that case, the rvalue reference becomes the (unique) alias of the value.)</p>

<p>Note also that without this rule it would be impossible to initialize variables from functions that return prvalues, or use copy-initialization at all:</p>

<pre><code>struct T { T(int); };

T f();

T x = 1;     // ===  ""T x = T(1);"", copy constructor wants to bind to prvalue
T x = f();   // ditto
T x((f()));  // ditto
</code></pre>
",3
26205836,26205732,1,"<p>No, since the tuple address is not known at compile-time. The only thing thats known at compile time is the size of the array, since its extracted from the size of the tuple (Via pack expansion).</p>

<p>Thats a weird algorithm thats only doing type erasure via <code>void*</code> to be able to store tuple elements on an array and then do something on them via standard algorithms.</p>

<p>This has much more sense (Indices trick ommitted to be more clear):</p>

<pre><code>template&lt;typename Tuple , typename T&gt;
bool find_in_tuple( const Tuple&amp; t , const T&amp; e )
{
    bool result[] = { (std::get&lt;Indices&gt;( t ) == e)... };

    return std::any_of(std::begin(result) , std::end(result) , [](bool b){ return b; } );
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/b1939b69735cb030"" rel=""nofollow"">Here</a> is a running example.</p>

<p>For the <code>index_of</code> feature, you can add a counter to the closure when doing <code>any_of()</code>, or do something more complicated like this:</p>

<pre><code>template&lt;typename Tuple , typename T&gt;
std::index_of index_of( const Tuple&amp; t , const T&amp; e )
{
    std::size_t index = 0;
    std::tuple&lt;bool,std::size_t&gt; result[] = { std::make_tuple(Indices,std::get&lt;Indices&gt;( t ) == e)... };

    bool exists = std::any_of(std::begin(result) , std::end(result) , [&amp;](const std::pair&lt;std::size_t,bool&gt;&amp; p){ index = p.first; return p.second; } );

    if(exists)
        return index;
    else
        throw std::bad_argument{};
}
</code></pre>
",3
31886311,31886183,0,"<p>It looks like you have a circular dependency. You can fix it with forward declarations:</p>

<pre><code>class Hero; //in Sword.h, before defining Sword

class Sword; //in Hero.h, before defining Hero
</code></pre>
",0
31886314,31886183,9,"<p>You cannot include Sword.h from Hero.h and Hero.h from Sword.h, the inclusion chain has to stop somewhere. You can use a <strong>forward declaration</strong> to fix it:</p>

<pre><code>//#include &lt;Hero.h&gt; // remove this

class Hero; // forward declaration

class Sword {
    public:
        Sword(Hero* h);
        virtual ~Sword();
};
</code></pre>

<p>This works because you don't need the definition of <code>Hero</code> in Sword.h. The compiler only needs to know that <code>Hero</code> is a <code>class</code>.</p>

<p>You can do the same in Hero.h: replace <code>#include &lt;Sword.h&gt;</code> with <code>class Sword;</code>. You can then include the files in the corresponding .cpp files where you need the definitions in order to use the classes.</p>

<p><strong>Rule of thumb</strong>: always use forward declaration, unless the whole header <em>needs</em> to be included.</p>

<p>Further reading: <a href=""https://stackoverflow.com/q/553682/3425536"">When can I use a forward declaration?</a></p>
",0
30704476,30704454,2,"<p><code>if ( abs( d - 0.01 ) &lt; 0.0000001 ) ...</code></p>
",1
24074942,24074814,0,"<p>You don't show the data type of number.  If you are using floating point, use floating point ... 20 is an integer, 20.0 is floating point.  If number is not a float, it will cause issues with both lines of code shown.</p>

<p>Edit: since the OP said he was using gcc, I wrote a little code.</p>

<pre><code>#include &lt;stdio.h&gt;

main()
{
   int number = 135;
   float taxednumber = number * (float)(20/100.0);

   printf(""number: %d\n"", number);
   printf(""taxednumber: %f\n"", taxednumber);
   printf(""int calc: %d\n"", 20/100.0);
   printf(""float calc: %f\n"", (float)(20/100.0));  
   printf(""float with cast calc: %f\n"", (float)((float)20/100.0));  
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>number: 135
taxednumber: 27.000000
int calc: -1717986918
float calc: 0.200000
float with cast calc: 0.200000
</code></pre>

<p>There is little information with the original question, it could be as simple that the OP is printing the value with the wrong output format (see the ""int calc"" line).</p>

<p>Environment used: gcc on VirtualBox using Ubunto.</p>
",7
26786556,26786404,0,"<p>I'm sure you didn't mean to forward declare the classes.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-css lang-css prettyprint-override""><code>int main()
{
	RandomNumberGen R;
	Simulator S;
	Pellet P;
	DOCO D;
  
    system(""pause"");
	return 0;
}</code></pre>
</div>
</div>
</p>
",4
26787069,26786404,0,"<p>After your #includes in your <code>Simulator.h</code> file, add the line</p>

<pre><code>struct DOCO;
</code></pre>

<p>After the #includes in your <code>Doco.h</code> file, add the line</p>

<pre><code>class Simulator;
</code></pre>

<p>This tells your compiler that even though while compiling the Simulator file it doesn't yet know what a DOCO is, it well eventually figure that out. Likewise for compiling the DOCO file. </p>

<p>When you forward-declare a class like this, you are not able to create any instances of that class until the class has been defined. You can, however, create pointers or references to that class. So if your DOCO struct needs to have a Simulator and vice-versa, make them contain pointer members rather than object members.</p>
",0
26787133,26786404,0,"<p>As my comment above suggested, your problem has to do with recursive inclusion.  </p>

<p>You can do one of two things:</p>

<p>1) Change your Simulator class so that you use references to DOCO or pointers to DOCO, and thus <code>forward declare</code> DOCO.  </p>

<p>2) Change your DOCO header to use pointers to Simulator or references to Simulator, and then just forward declare <code>Simulator</code>.</p>

<p>The easiest one to change (if those comments in your code remain) is to change <code>DOCO.h</code>:</p>

<pre><code>#pragma once
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;vector&gt;

class Simulator;

struct DOCO
{
...
};
</code></pre>

<p>Inside of the <code>DOCO</code> struct definition, you can specify references and pointers to <code>Simulator</code>, not Simulator objects.</p>

<p>I also advise to <em>not</em> put <code>using namespace std;</code> in a header file.  This is discussed in many threads here on SO as to why you shouldn't have that line in your header file.</p>
",0
34188705,34188373,1,"<p>The reason for the performance problem is that your <code>drop</code> function turns the algorithm into <code>O(n^2)</code> rather than linear time, because it has to keep making a new <code>remain</code> container with all the elements that haven't been partitioned out yet.</p>

<p>I'm still trying to grok what the code is intended to do so I could provide a suggestion on how to fix/improve your version.</p>

<p>Totally untested (tight on time right now) but I think this ought to be close:</p>

<pre><code>std::vector&lt;std::vector&lt;T&gt;&gt; partition(int size, int step, const std::vector&lt;T&gt;&amp; coll, bool showPartialEnd=false)
{
    std::vector&lt;std::vector&lt;T&gt;&gt; ret;

    if (size&lt;1||step&lt;1) return ret;

    ret.reserve(coll.size() / step + 1);

    std::vector&lt;T&gt;::const_iterator iter = coll.begin();
    for(; ; iter += step)
    {
        // If you have enough elements left for an entire chunk, push it.
        if((coll.end() - iter) &gt;= size)
        {
            ret.push_back(std::vector&lt;T&gt;(iter, iter + size));
        }
        else if(showPartialEnd)
        {
            ret.push_back(std::vector&lt;T&gt;(iter, coll.end()));
            break;   // Remove if you want *all* partial ends instead of just the first one.
        }
        else break;
    }

    return ret;
}
</code></pre>
",2
29169544,29169372,2,"<p>When you have an object that has member variables to define a tree of the objects, copy constructor or copy assignment operator will not be sufficient to deal with all cases. You may want to:</p>

<ol>
<li>Copy just the contents of a node in the tree (<code>a</code>, and <code>b</code> in your case).</li>
<li>Copy one layer of parents and children.</li>
<li>Copy <code>N</code> layers of parents and children.</li>
<li>Copy <code>N1</code> layers of parents and and <code>N2</code> layers of children.</li>
<li>Copy the entire tree.</li>
</ol>

<p>(1) above can be handled by a copy constructor or a copy assignment operator. For the rest, it's better to have <code>extern</code> functions that traverse the tree and make a copy of the right portion of the tree.</p>
",5
29171638,29169372,0,"<p>You've run into the logical problems of having an XML node copy itself. There is really no clear and intuitive way to go about copying an XML node that's part of a tree. And a rule of thumb in C++ is: if an <code>operator</code> doesn't act intuitively, make it a named function instead.  In your case, I would make a <code>foo&amp; assign_from_content(foo&amp;)</code> function that acts like a copy assignment, and a <code>static foo construct_from_content(foo&amp;)</code> that acts like a copy constructor, that only copies the content. </p>

<p>Now what to do with the copy constructor and copy assignment operators? <code>delete</code> them.  And use move construction and move assignment instead.</p>

<pre><code>foo&amp; operator =(const foo&amp; other)=delete;
foo&amp; operator =(foo&amp;&amp; other) noexcept=delete;
{
    disconnect_from_tree();

    a = other.a;
    delete b;
    b = other.b;
    other.b = null;

    take_place_in_tree(other);       
    return *this;
}

//These are untested, they probably don't compile and have logical errors
void disconnect_from_tree() noexcept {
    if (parentObject) {
        auto it = std::find(parentObject-&gt;childObjects.begin(), 
                            parentObject-&gt;childObjects.end(), 
                            this);
        if(it != parentObject-&gt;childObjects.end())
            parentObject-&gt;childObjects.erase(it);
    }
    for(foo* child : childObjects)
        child-&gt;parentObject = nullptr;
    childObjects.clear();
}

//These are untested, they probably don't compile and have logical errors
void take_place_in_tree(foo&amp; other) noexcept {
    childObjects = std::move(other.childObjects);
    parentObject = other.parentObject;     
    other.disconnect_from_tree();
    for(foo* child : childObjects)
        child-&gt;parentObject = this;  
    if (parentObject) {
        auto it = std::find(parentObject-&gt;childObjects.begin(), 
                            parentObject-&gt;childObjects.end(), 
                            this);
        if(it != parentObject-&gt;childObjects.end())
            parentObject-&gt;childObjects.erase(it);
        parentObject-&gt;childObjects.push_back(this);
    }
}
</code></pre>
",1
33540852,33540662,3,"<p>Out on a limb, add <code>binary</code> to the open flags:</p>

<pre><code>std::wifstream input1(path, std::ios::binary);
std::wstring content((std::istreambuf_iterator&lt;wchar_t&gt;(input1)),
    {});
</code></pre>
",0
30184774,30184313,1,"<p>You're probably learning C++, and trying to take too many steps at once. Try recording to a file, and playing back a file. This will give you the sound-to-bytes and bytes-to-sound parts. Don't try to use a specific file format, just write and read raw audio data.</p>
",0
31271412,24999861,-1,"<p>This has been working for me.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
  double x=0;
  double y=0;
  while(cin &gt;&gt; x ,cin &gt;&gt; y)
  if (x &gt; y){
    cout &lt;&lt; ""The larger value is "" &lt;&lt; x &lt;&lt; "" the smaller value is "" &lt;&lt; y &lt;&lt; ""\n"";
    if (x - y &lt; (1.0/100)) {
        cout &lt;&lt; ""the numbers are almost equal"" &lt;&lt; endl;
       }
       }
       else if (x &lt; y){
        cout &lt;&lt; ""The larger value is "" &lt;&lt; y &lt;&lt; "" the smaller value is "" &lt;&lt; x &lt;&lt; ""\n"";

         if (y - x &lt; (1.0/100)) {
        cout &lt;&lt; ""the numbers are almost equal"" &lt;&lt; endl;
       }
       }
     else if (x == y)
         cout &lt;&lt; ""the numbers must be equal\n"";
</code></pre>

<p>}</p>
",0
30129733,30080923,0,"<p>A common approach to getting around this sort of overload issue is to make a templated overload; e.g.</p>

<pre><code>template &lt;typename Iterator&gt;
Node(Iterator iter, Node *ptr);
</code></pre>

<p>But this assumes the implementation is generic across these types. </p>
",0
34276801,26869010,0,"<p>Was just trying to solve this myself. As much as this solution pains me it's the best I came up with quickly. Use QList to help yourself out here:</p>

<pre><code>// List instances containing labels and drop shadows
QList&lt;QLabel*&gt; label_list_;
QList&lt;QGraphicsDropShadowEffect*&gt; shadow_list_;

// Get all UI labels and apply shadows
label_list_ = this-&gt;findChildren&lt;QLabel*&gt;();
foreach(QLabel *lbl, label_list_) {
    shadow_list_.append(new QGraphicsDropShadowEffect);
    shadow_list_.back()-&gt;setBlurRadius(10);
    shadow_list_.back()-&gt;setOffset(3, 3);
    lbl-&gt;setGraphicsEffect(shadow_list_.back());
}
</code></pre>

<p>If don't want all UI labels in your list you can add manually with <code>append</code></p>
",0
29246814,29246784,0,"<p>You can use the following syntax</p>

<p><code>g++ -Wall aImp.cpp a.cpp -o app</code></p>

<p>Hope this helps</p>
",1
24362850,24351352,0,"<p>You may create 2 maps, and use 2 register methods.
If you want the same name, you may use SFINAE as the following: <a href=""https://ideone.com/iPeg6W"" rel=""nofollow"">Live example</a></p>

<pre><code>class Messenger
{
public:
    template &lt;typename Receiver&gt;
    auto RegisterObserver(Message msg, Receiver&amp;&amp; receiver) -&gt; decltype(receiver(), void())
    {
        _receivers0[msg].push_back(std::forward&lt;Receiver&gt;(receiver));
    }

    template &lt;typename Receiver&gt;
    auto RegisterObserver(Message msg, Receiver&amp;&amp; receiver) -&gt; decltype(receiver(nullptr), void())
    {
        _receivers1[msg].push_back(std::forward&lt;Receiver&gt;(receiver));
    }

    // Others methods

private:

    std::map&lt;Message, std::vector&lt;std::function&lt;void()&gt;&gt;&gt; _receivers0;
    std::map&lt;Message, std::vector&lt;std::function&lt;void(void*)&gt;&gt;&gt; _receivers1;
};
</code></pre>
",1
28435264,27778424,0,"<p>You should both add a newline command in your print function and some sort of pause. </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main(){
  cout &lt;&lt; ""Hello World!\n"" //calls for a newline
  cin.get(); //pauses until a key is pressed
  return 0;
}
</code></pre>

<p>Try this and see if it works</p>
",0
29448569,29448457,6,"<p>Default argument values are based on the <strong>static type</strong> (the type known at compile time).</p>

<p>The choice of virtual function implementation is governed by the object's most derived type at run time, the <strong>dynamic type</strong>.</p>
",0
33000744,33000459,3,"<p>One way I could see you doing this is with a <a href=""http://en.cppreference.com/w/cpp/container/map"" rel=""nofollow""><code>std::map</code></a>.  You could have a <code>static std::map&lt;class_name*, int&gt;</code> in the function and every time the function is called use <code>operator[]</code> with <code>this</code> and increment the <code>int</code> part.</p>

<pre><code>class Foo
{
public:
    void bar()
    {
        static std::map&lt;Foo*, int&gt; counter;
        counter[this]++;
    }
};
</code></pre>
",3
33000750,33000459,3,"<p>C++, like many other languages, doesn't have a way that multiple functions can share a variable without allowing all functions access (besides putting them into a class together, which you already know).  There are some ways to approximate what you want, however.</p>

<p>Here's a simple fix:</p>

<pre><code>class foo
{
public:
  int count () 
  {
    static int count_ = 0;
    return ++count_; 
  }
};
</code></pre>

<p>Now only <code>foo::count</code> can access it, and it does double duty:  increments it, and returns it.</p>

<p>If you don't like that, here's a lengthier fix that matches the desired behavior:</p>

<pre><code>class foo
{
private:
  class Counter //hides all that counting stuff
  {
  public:  
     //ctor initializing count...
  private:      //it's all hidden!  Only friends can access
    friend int  foo::returnCount () const; 
    friend void foo::updateCount ();

    int count () const { return count_; }
    void updateCount (){ ++count_; }

    int count_;
  };

public:
                  //and only these two functions are friends.
  int returnCount () const { return myCounter_.count (); }
  void doSomethingAndIncCount()       { myCounter_.updateCount ();   }

private:
  static Counter myCounter_;
};
</code></pre>

<p>So keeping all the contents of Counter private means nobody can access... except the functions you picked out, and designated as <code>friend</code>s of Counter.</p>

<p>That's an awful lot of mess to go to, though.  I'd go with the first solution, or else not worry about those other member functions accessing count.</p>
",4
33000926,33000459,0,"<p>Is this what you are trying to achieve:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Foo
{
private:
    int counter;

public:

    Foo() : counter(0) {};

    void count()
    {
        counter++;
    }

    int getCounter()
    {
        return counter;
    }
};

int main()
{
    Foo foo1;
    Foo foo2;

    foo1.count(); foo1.count(); foo1.count();
    cout &lt;&lt; ""You called count() from foo1 "" &lt;&lt; foo1.getCounter() &lt;&lt; "" times"" &lt;&lt; endl;

    foo2.count();
    cout &lt;&lt; ""You called count() from foo2 "" &lt;&lt; foo2.getCounter() &lt;&lt; "" times"" &lt;&lt; endl;
}
</code></pre>
",0
33000524,33000459,0,"<p>I don't think there are options in C++ to have method scope private field. Encapsulation rules are that class is the unit of encapsulation so you should know what to do and what not to do within your own class.</p>

<p>You can achieve similar effect by using separate functor:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Counter {
    private:
     int counter = 0;
    public:
     int operator () () {
        return counter++;
     }
};

class Test {
    public:
     Counter count;
};

int main() {
    Test test;
    test.count();
    test.count();
    std::cout &lt;&lt; test.count();
    return 0;
}
</code></pre>

<p>In this case <code>counter</code> is completely inaccessible from class <code>Test</code>.</p>
",3
33000648,33000459,4,"<p>you can hide your counter in a base class</p>

<pre><code>class base_foo
{
public: 
 void doSomething()
 {
     counter++;
     //other fun stuff
 }

private:
   int counter;
};

class foo : base_foo
{
public:
    foo()
    {
        doSomething();
    }
// your other code
};
</code></pre>
",4
30216715,30216551,1,"<p>If the data is updating so fast that painting each update is too much, you can use a timer.  Every (say) quarter second, the timer fires, and if any items are dirty, the timer handler calls <code>InvalidateRect()</code>.  Updating the data no longer invalidates; only the timer handler does that.</p>

<p>Edit: You could query Windows for the CPU load and if it's low, do the Invalidate immediately; see <a href=""https://stackoverflow.com/questions/13218567/how-to-get-system-cpu-ram-usage-in-c-on-windows"">How to get system cpu/ram usage in c++ on Windows</a></p>
",2
30206603,30206477,6,"<p>This is very unlikely to be the bottleneck in your code. You can use a performance profiling tool like <code>perf</code> on Linux to determine where your CPU is spending the majority of its time.</p>

<p>In this case, the compiler can do the transformation you describe (Loop Invariant Code Motion) automatically if it can prove its correctness. In particular, the compiler needs to be sure that <code>obj.size</code> isn't modified inside the loop, so passing <code>obj</code> by reference or invoking a method on <code>obj</code> could cause the compiler to assume that <code>obj.size</code> might be modified, meaning it must be read every time.</p>

<p>In general, assume the compiler will do a good job optimizing your code, and go back and do micro-optimizations manually if profiling indicates it is important.</p>
",2
26791226,26791034,0,"<p>A subtle error that you have is this (given that you fix the obvious error of declaring <code>ptr</code> each time):</p>

<pre><code>my_int_array &amp;operator=(const my_int_array&amp;temp){
    ptr = new int[temp.num];
    for (int i = 0; i &lt; temp.num; i++){
        ptr[i] = temp.ptr[i];
    }
    num = temp.num;
}
</code></pre>

<p>The problem is that your function is supposed to return a reference to a <code>my_int_array</code>, but it doesn't return anything.  This is <code>undefined behavior</code>, thus any code that assigns your objects will be faulty (possibly crash).</p>

<p>However, once you fix this, you have another issue, and that is that you didn't check for self-assignment.</p>

<p>To fix this, I will show you the simpler way of implementing <code>operator=</code>:</p>

<pre><code>#include &lt;algorithm&gt;
//...
my_int_array &amp;operator=(const my_int_array&amp; rhs)
{
    my_int_array temp(rhs);
    std::swap(temp.ptr, ptr);
    std::swap(temp.num, num);
    return *this;
}
</code></pre>

<p>That's it. This works by using the copy constructor and destructor of <code>my_int_array</code> to your advantage, so it requires a perfectly working copy constructor and destructor for <code>my_int_array</code>.  Look up <code>copy and swap idiom</code>.</p>
",0
26804748,26804661,4,"<p>Use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/substr"" rel=""nofollow""><em><code>std::string::substr</code></em></a>, after finding the location of space using <a href=""http://en.cppreference.com/w/cpp/string/basic_string/find"" rel=""nofollow""><em><code>std::string::find</code></em></a></p>

<pre><code>string str = ""hello world"";
auto n = str.find("" "");     // std::string::size_type n =
if (n != std::string::npos ) 
{
    std::cout &lt;&lt; str.substr( n+1 );
}
</code></pre>
",0
26804750,26804661,2,"<p>Try this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
// your code goes here
string str = ""hello world"";
cout &lt;&lt; str.substr( str.find(' ') + 1, string::npos );
return 0;
}
</code></pre>

<p>I use the <code>std::string</code> methods <code>find()</code> and <code>substr()</code>.</p>

<p><code>find()</code> returns the location/position of occurrence of space (' '), which is then passed to <code>substr()</code> which returns the <code>string</code> starting at that position until the end.</p>

<p>If you notice the fist parameter to <code>substr()</code>, it is 1 more than what is returned by <code>find()</code>. This is because you want to print whatever comes <strong>after</strong> the space, and which must not include space itself! Hence adding 1 to point to the character after the space.</p>
",0
26804837,26804661,3,"<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
    string str = ""hello world"";

    size_t len = str.size();
    size_t space;
    if ((space = str.find(' ')) != string::npos) {
        cout &lt;&lt; str.substr(space + 1, len-space) &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>

<p><code>npos</code> is returned by <code>find()</code> method when there is no (in this example) space character in string. If it was found, then <code>substr()</code> method is used in order to take the part of string after space.</p>
",0
27535103,27535035,1,"<p><code>temp</code> is empty, yet you access its  nonexistent  elements by index. The behavior you describe is as expected.</p>
",2
26793877,26793787,1,"<p>It sounds like the function you are looking for is <a href=""http://msdn.microsoft.com/en-us/library/ms646310(v=vs.85).aspx"" rel=""nofollow"">SendInput</a>.</p>

<p>Depending on what sort of keystrokes you need to inject, and where you need to inject them, your text-injection code might need to run inside a <a href=""http://msdn.microsoft.com/en-us/library/bb625963.aspx"" rel=""nofollow"">high-integrity process</a> -- from the linked page:  ""This function is subject to UIPI. Applications are permitted to inject input only into applications that are at an equal or lesser integrity level.""</p>

<p>(Note in particular the ""UIAccess for UI automation applications"" section in the second linked article)</p>
",2
32464125,32462779,1,"<p>You might do something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

// Set the failbit on the stream if the stream or value is invalid
// Note: Additional input is silently ignored.
std::istream&amp; isValid(std::istream&amp; stream, int value) {
    // The current stream state.
    bool success = bool(stream);
    // Clear a possible fail state, but not EOF.
    // Note: This example fails miserable, if the I/O is not interactive.
    //       Input through a pipeline or similar needs additional coding.  
    stream.clear(stream.eof() ? stream.eofbit : stream.goodbit);
    // Ignore the rest of the line.
    stream.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
    // Validate the number
    if(success) {
        // Only one valid value
        if(value != 1)
            success = false;
    }
    // Adjust the stream state.
    if( ! success)
        stream.setstate(stream.failbit);
    return stream;
}

void getInput(int&amp; result)
{
    std::cout &lt;&lt; ""Please enter a number "";
    std::cin &gt;&gt; result;

    while( ! isValid(std::cin, result)) {
        std::cout &lt;&lt; ""Sorry, Please enter a number again "" ;
        std::cin.clear();
        std::cin &gt;&gt; result;
    }
}

int main() {
    int result;
    getInput(result);
    std::cout &lt;&lt; ""Result "" &lt;&lt; result &lt;&lt; '\n';
}
</code></pre>

<p>The code evaluates the stream state, first. Then, it validates the input and adjusts the stream state, accordingly.</p>
",0
32464147,32462779,0,"<p>Regarding:</p>

<blockquote>
  <p>If a user types two for example instead of <code>02</code> for the month, the program catches the error, but the next two <code>cout</code> statements are still executed (without the chance for input) and then the error message is displayed to the user.</p>
</blockquote>

<p>The problem is that <code>cin</code> if raising a <code>fail()</code>(error state flag) if it detects wrong type input in one of your three lines containing <code>cin</code>, and then this causes the rest of the input to fail as well. This is why nothing is displaying as a value in the rest, if only one fails. </p>

<h2>The simplest change would be: (a loop till everything is right)</h2>

<pre><code>void getInput(int&amp; month, int&amp; day, int&amp; year){
//prompt the user for the date
cout &lt;&lt; ""***************************************************************"" &lt;&lt; endl;
cout &lt;&lt; ""Welcome to the Date Validator Program created by ****!"" &lt;&lt; endl;
cout &lt;&lt; ""***************************************************************"" &lt;&lt; endl &lt;&lt; endl;
cout &lt;&lt; ""Enter your date below. Use only whole, positive numbers."" &lt;&lt; endl;

do{
    // get input
    cout &lt;&lt; ""Please enter the month in MM format: "";
    cin &gt;&gt; month;
    cout &lt;&lt; ""Please enter the day of the month in DD format: "";
    cin &gt;&gt; day;
    cout &lt;&lt; ""Please enter the year in YYYY formating: "";
    cin &gt;&gt; year;
    isValidDate(month, day, year);
    cin.ignore();
    cin.clear();
    //send input to be validated    
   }while (!isValidDate(month, day, year))
} 
</code></pre>

<p>As for:</p>

<blockquote>
  <p>I am also having an issue ensuring the year is in YYYY format. Any help on what I am missing? </p>
</blockquote>

<p>Just specify what you consider a valid interval for a year, for example YYYY:[2000,2015], and add it to you validation function:</p>

<pre><code> bool isValidDate(int month, int day, int year)
{ 
    if (year &lt; 2000 &amp;&amp; year &gt; 2015) return false;
    // ...
}
</code></pre>
",1
32463293,32462779,0,"<p>You have to validate every cin alone and then validate the whole thing i.e :</p>

<pre><code>for (;;) {
    cout &lt;&lt; ""Please enter the month in MM format using numbers: "";
    if (cin &gt;&gt; taxableIncome) {
        break;
    } else {
        cout &lt;&lt; ""Please enter the month in MM format using numbers: "" &lt;&lt; endl;
        cin.clear();
    }
}
</code></pre>
",0
25476154,25476049,1,"<p>Did you check what warnings you've got?</p>

<p>for example:</p>

<pre><code>statistician operator * (double scale, const statistician&amp; s)
{
    double multiply;
    multiply = (s.total * scale);
    return s;
}
</code></pre>

<blockquote>
  <p>warning: variable 'multiply' set but not used</p>
</blockquote>

<p>and in the == operator:</p>

<pre><code>bool operator ==(const statistician&amp; s1, const statistician&amp; s2)
{
    return (s1 == s2);
}
</code></pre>

<p>You should tell it how to compare, but what you did is a recursion.</p>
",2
25476223,25476049,0,"<p>To begin with, note that <code>operator+</code> and <code>operator*</code> have been made <code>friend</code>s of class <code>statistician</code>, as such, those operators have access to private members of instances of class <code>statistician</code>.</p>

<p>Now, you want to implement those two operators, this may look like this:</p>

<pre><code>statistician operator + (const statistician&amp; s1, const statistician&amp; s2)
{
    statistician s3; // build up new instance
    s3.count = (s1.count + s2.count); // initialize it's fields based on operands
    return s3; // return new instance
}

statistician operator * (double scale, const statistician&amp; s)
{
    statistician s3; // build up new instance
    s3.total = (s.total * scale); // initialize it's fields based on operands
    return s3; // return new instance
}
</code></pre>

<p>Going further, with your current implementation:</p>

<pre><code>bool operator ==(const statistician&amp; s1, const statistician&amp; s2)
{
    return (s1 == s2);
}
</code></pre>

<p>the call to <code>operator==</code> ends with an infinite recursion (very bad). To solve this, it should look something like that:</p>

<pre><code>bool operator ==(const statistician&amp; s1, const statistician&amp; s2)
{
    return (s1.count == s2.count); // or whatever that makes two instances of statistician ""equal""
}
</code></pre>
",0
34251184,34251153,3,"<p>Yes, it can. <code>private</code> members are accessible to instances of same class. Instance can access another instance data. </p>

<p>For example, this is how move constructors/assigment operators work: steal data and delete it from original object to avoid double references to same data.</p>
",2
29491182,29491101,0,"<p>A big problem is that you are calling a function on <code>start</code>, which is <code>NULL</code>, causing undefined behavior.</p>

<p>Instantiate <code>start</code> before calling anything on it.</p>

<p>E.g. this is bad:</p>

<pre><code>node *start=NULL,*end=NULL;
// ...
case 4: start-&gt;insert_after(&amp;start,&amp;end);
</code></pre>

<p>You probably need to rethink your design.</p>

<p>So, I would recommend you instead implement your behavior with a <code>std::vector</code>.</p>
",4
29491352,29491101,1,"<p>The problem is in the success case of <code>insert_after</code>:</p>

<pre><code>node *obj = new node(n);
obj-&gt;prev = pos;
obj-&gt;next = pos-&gt;next;
pos-&gt;next-&gt;prev = obj; // &lt;==
pos-&gt;next = obj;
</code></pre>

<p>What if we have a list of one <code>node</code>, which is the <code>node</code> we were looking for, so <code>pos</code> points to it. In that case, <code>pos-&gt;next</code> is <code>NULL</code>, so the assignment to <code>pos-&gt;next-&gt;prev</code> would involve dereferencing <code>NULL</code>, which is likely the cause of your segfault.</p>

<p>That part should be:</p>

<pre><code>if (pos-&gt;next) {
    pos-&gt;next-&gt;prev = obj;
}
else {
    // no next? must be at the end
    *end = obj;
}
</code></pre>

<p>That said, all of your <code>node</code> methods should be free functions, not class methods. Your call to <code>insert_after</code> should really look like:</p>

<pre><code>case 4:
    insert_after(&amp;start,&amp;end);
    break;
</code></pre>

<p>As is, since you're starting with <code>start</code> as <code>NULL</code>, all of the calls are undefined behavior - but you don't need them as methods anyway since you're only ever accessing data through the <code>start</code> or <code>end</code> pointers. </p>

<p>Lastly, why is this here?</p>

<pre><code>cin.clear();
cin.ignore(10000,'\n');
</code></pre>

<p>I'm pretty sure you don't need that in this program. </p>
",2
30711466,30711428,1,"<p><code>my_comp</code> should be:</p>

<pre><code>bool mycomp (std::string a1, std::string a2)
{
    std::sort(a1.begin(), a1.end());
    std::sort(a2.begin(), a2.end());
    return a1 &lt; a2;
}
</code></pre>

<p>as <code>std::sort</code> modifies the string, if you pass const references, you have to create a copy for the sort.</p>
",11
26200435,26200373,2,"<p>The keyword <code>auto</code> had a different meaning prior to C++11. It meant a variable is an automatic variable, its scope is local. In C++11, its meaning changed to mean ""deduce the type"" of the variable.</p>

<p>Since VS 2008 does not support C++11 constructs, it interprets the <code>auto</code> with its old meaning. When interpreted like that,</p>

<pre><code>static auto &amp;&amp;PyTuple_GetDWORD = PyTuple_GetUnsignedLong;
</code></pre>

<p>does not make sense since a variable can't be <code>static</code> and <code>auto</code> at the same time.</p>

<p>Related post: <a href=""https://stackoverflow.com/questions/2847410/goal-of-cs-auto-keyword"">Goal of C&#39;s &quot;auto&quot; keyword</a></p>
",3
31160229,31160176,13,"<p>If your compiler supports ref-qualifiers on member functions (a C++11 feature), you can:</p>

<pre><code>operator bar() const &amp;
{
  return bar(the_common_data);
}

operator bar() &amp;&amp;
{
  return bar(std::move(the_common_data));
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/afd2c2ea2ebe29bc"">[Live example]</a></p>
",0
31160240,31160176,4,"<p>Yes, you can using <code>r-value this</code> syntax:</p>

<pre><code>operator bar() &amp;&amp;{ /* std::move(...); */ }
</code></pre>
",0
26164236,26164094,12,"<p><em>[atomics.types.generic]/p9</em></p>

<blockquote>
  <p>Note: The representation of an atomic specialization need not have the same size as its corresponding
  argument type. Specializations should have the same size whenever possible, as this reduces the effort
  required to port existing code</p>
</blockquote>

<p>No, you can't assume that. It's a <em>best-effort</em> endeavor but no guarantees.</p>
",0
29144483,29143603,0,"<p>Assuming you already know how to read an entire line of a text file, you could delimit the text with a specific char (i use ',' a lot).</p>

<p>Fore example you could read the first line in ""Peter   He is a boy."" but if you were to set it up as a delimited string it can look like this ""Peter,He is a boy."". then you can loop through each char of the string till the particular char in question = ',' and you can then split the string accordingly.</p>

<p>Something like this may what you're looking for:</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

int main()
{
    vector&lt;string&gt; lines(3);
    vector&lt;string&gt; names(3);
    vector&lt;string&gt; descriptions(3);
    lines.at(0) = ""Peter,He is a boy."";
    lines.at(1) = ""Mary,She is a girl."";
    lines.at(2) = ""Tom,It is a cat."";

    for(int i = 0; i &lt; lines.size(); i++) {
        for(int j = 0; j &lt; lines[i].size(); j++) {
            if(lines[i][j] == ',') {
                for(int d = 0; d &lt; j; d++) {
                    stringstream ss;
                    ss &lt;&lt; lines[i][d];
                    ss &gt;&gt; names.at(i);
                }
                for(int d = j + 1; d &lt; lines[i].size(); d++) {
                    if(lines[i][d] != '.') {
                        stringstream ss;
                        ss &lt;&lt; lines[i][d];
                        ss &gt;&gt; descriptions.at(i);
                    } else {
                        break;
                    }
                }
                break;
            }
        }
    }
}
</code></pre>

<p>EDIT: This code will look for 3 spaces instead of a single char ','.</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

int main()
{
    vector&lt;string&gt; lines(3);
    vector&lt;string&gt; names(3);
    vector&lt;string&gt; descriptions(3);
    lines.at(0) = ""Peter,He is a boy."";
    lines.at(1) = ""Mary,She is a girl."";
    lines.at(2) = ""Tom,It is a cat."";

    for(int i = 0; i &lt; lines.size(); i++) {
        for(int j = 0; j &lt; lines[i].size(); j++) {
            if(lines[i][j] == 0x20 &amp;&amp; lines[i][j + 1] == 0x20 &amp;&amp; lines[i][j + 2] == 0x20) {
                for(int d = 0; d &lt; j; d++) {
                    stringstream ss;
                    ss &lt;&lt; lines[i][d];
                    ss &gt;&gt; names.at(i);
                }
                for(int d = j + 3; d &lt; lines[i].size(); d++) {
                    if(lines[i][d] != '.') {
                        stringstream ss;
                        ss &lt;&lt; lines[i][d];
                        ss &gt;&gt; descriptions.at(i);
                    } else {
                        break;
                    }
                }
                break;
            }
        }
    }
}
</code></pre>

<p>Also a little tip don't down vote an answer that actually works just because it's not the quick fix you were hoping for or you don't understand it..</p>
",3
29145378,29143603,0,"<p>I only know how to read an entire line or a word.</p>

<p>This is what I have written:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

int main(){
    string line[6153];

    ifstream fin;
    fin.open(""dict.txt"");
    if (fin.fail()){
        cout &lt;&lt; ""File input failed.\n"";
        exit(1);
    }

    else{
        int i;
        for (i = 0; i &lt; 6153; i++){
            getline(fin, line[i]);      
        }
    }
    fin.close();
    return 0;
}
</code></pre>

<p>p.s. there are 6153 lines in ""dict.txt"".</p>
",1
27507039,27507019,2,"<pre><code>node *New=new node;
</code></pre>

<p>This is initializing the pointer which is good thing to remember.</p>

<p>Whereas</p>

<pre><code>node *New;
</code></pre>

<p>not which is a bad thing as chances of de-referencing it in it's naked form are there.</p>
",2
27507258,27507019,2,"<pre><code>node *New=new node;
</code></pre>

<p>Creates a variable called <code>New</code> and initializes it with pointer, returned by <code>operator new</code></p>

<pre><code>node *New;
</code></pre>

<p>Depends on context, for namespace (global) context creates a variable, initialized by <code>nullptr</code>, or for local creates one uninitialized.</p>
",0
27507284,27507019,0,"<p>You should always initialize a variable when declaring it so that you know it is a good know state.  when working with pointer either grab ""new"" memory at the time of the pointers creation or use nullptr.</p>

<pre><code>node * New = new node; // Okay. We know New holds a good node and we can call delete on it
node * New = nullptr; // Okay. We know we can delete on it without crashing
node * New; // Bad.  We dont know what the state of New is and we can't call delete on it
</code></pre>
",0
27507185,27507019,-2,"<p>Both nod *New = new node; and node *New; are invalid declaration types. The reason why it allows the lines at all is because the programmer has declared a keyword as a declared structure. They are both bad lines of code. What you have so far is a pointer to a new structure(but not really). New is a keyword that instantiates an object that is greater in precedence than the current scope of the code block. Whenever an object is made eventually it must be unmade with the delete keyword. </p>
",4
29163330,29163253,10,"<p>What the STL does in this case is throw an exception.</p>

<p>For exemple you can take a look at the <code>std::vector::at</code> member function:</p>

<p><a href=""http://en.cppreference.com/w/cpp/container/vector/at"">http://en.cppreference.com/w/cpp/container/vector/at</a></p>

<p>which throws an <a href=""http://en.cppreference.com/w/cpp/error/out_of_range"">std::out_of_range</a> exception if you ask for something out of range</p>

<hr>

<p>Another option is to return either a pointer or its more semanticaly explicit equivalent in this context, an <a href=""http://www.boost.org/doc/libs/1_57_0/libs/optional/doc/html/boost_optional/tutorial/optional_references.html"">optional reference</a> <code>boost::optional&lt;fCoo&amp;&gt;</code>.</p>

<p>I would advise to go this way if the ""out of range"" case is not that exceptional and is supposed to happen from time to time.</p>

<p>Lastly if you consider that this case should never happen except if it is a developper error, you should use an <a href=""http://en.cppreference.com/w/cpp/error/assert"">assertion</a>.</p>
",2
29163341,29163253,4,"<p>If not having something to return is normal for the function, it shouldn't be returning a reference. There's nothing wrong with returning a pointer:</p>

<pre><code>const fCoo* cContainer::getfoo(std::size_t index) const
{
    if(index &lt; fooList_.size())
        return fooList_[index];
    else
        return nullptr;
};
</code></pre>

<p>If not having anything to return is indicates something <em>exceptional</em> for the function, well then, it should throw an exception:</p>

<pre><code>const fCoo* cContainer::getfoo(std::size_t index) const
{
    if(index &lt; fooList_.size())
        return fooList_[index];
    else
        throw std::invalid_argument(""out of range"");
};
</code></pre>
",3
29186128,29185818,0,"<p>You have several instances in your code where you want to change some object, but don't actually do that.</p>

<p>As Josh stated, your retrieveInput function actually changes the local variables num and denom. You have class members num and denom, but with your statement <code>int num, denom;</code> you hide those member variables.</p>

<p>In your <code>+</code> operator you save the result of the addition in the temp object, which gets destroyed immediately afterwards and you don't return it.</p>

<p>Also, the <code>GreatestCommonDenom</code> function actually calculates the greatest common divisor, not the lowest common denominator.</p>

<p>Just think a little bit more about which objects you actually change and whether those are the ones you want to change.
Any time you write something of the form <code>type varname;</code> (like <code>int num,denom;</code> or <code>RationalNumber temp;</code> ) inside a function, the variable <code>varname</code> will be destroyed as soon as the function reaches the <code>}</code></p>

<p>One more thing: From the sound of the assignment I would assume you are expected to write a constructor that takes two arguments instead of just being able to input values after the number is already created.</p>
",0
29186257,29185818,1,"<p>I would create a reduce function which was always called from a constructor:</p>

<pre><code>RationalNumber::RationalNumber(int a, int b)
{
    // do error checking that denominator b is non-zero etc.

    this-&gt;a_ = a;
    this-&gt;b_ = b;
    reduce(this-&gt;a_, this-&gt;b_);
}
</code></pre>

<p>Then we all operators (like add) would create a new rational number using the constructor. Example of a naive reduce function could be (modify it to deal with negative numbers):</p>

<pre><code>void reduce(int&amp; a, int&amp; b)
{
    int k = 2;
    while(k &lt;= ((a &lt;= b) ? a : b)){
        if(a%k == 0 &amp;&amp; b%k == 0){
            a /= k;
            b /= k;
        }
        else
            ++k;
    }   
}
</code></pre>

<p>The point is to call it from the constructor to always have the rational number in its most reduced form. So an add function might look something like</p>

<pre><code>RationalNumber RationalNumber::add(const RationalNumber&amp; r) const
{
    return RationalNumber(this-&gt;a_ * r.b_ + this-&gt;b_ * r.a_, this-&gt;b_ * r.b_);
}
</code></pre>
",0
29185975,29185818,0,"<p>Sidenote: If I were you, I would overload the operator so the method would be called RationalNumber RationalNumber::operator+(RationalNumber o1). This way when you add two rational numbers you can simply write</p>

<pre><code>RationalNumber sum = frac1 + frac2
</code></pre>

<p>The reason this is happening because your code think its adding just 1/1 + 1/1 since this is what you set in the constructor. In retrieveInput(), you're intention is to set the numerator and denominator from the user input, however you never set the class member variables num and denom. You're only setting the local variables you create in that method leaving you still with 1/1 as the numerator and denominator of your member variables. Does this make sense?</p>
",0
29180750,29180186,0,"<p>Once again, reiterating the comments above for clarity:
<strong>You cannot use modulo on floating-point numbers.</strong></p>

<p>A function called fmod(), however, can give you the remainder of two floating point numbers.</p>
",0
29187424,29187399,0,"<p>You have your matrix indices the wrong way round in several places: the first index runs from 0 to 120 and the second runs from 0 to 60, not the other way around.</p>

<p>Here is an example of one such mistake:</p>

<pre><code>for( int y = 0; y &lt; 61 ; y++ )
{
    for( int x = 0; x &lt; 121; x++ )
    {
        cout &lt;&lt; matrix[y][x];
</code></pre>
",1
32929860,32929748,0,"<p>Your code has undefined behavior unless you enter a string at least 10,000 characters long. The only element outside the string that you're allowed to access is <code>a[a.size()]</code>, which returns a null character (<code>'\0'</code>). Anything beyond that is undefined.</p>

<p>Change your loop to:</p>

<pre><code>size_t len = a.size();
for (int i = 0; i &lt; len; i++)
</code></pre>

<p>so you don't go outside the string.</p>
",0
27121059,27121020,1,"<p>First things first,</p>

<pre><code>cin &lt;&lt; AmerAge;
</code></pre>

<p>should be:</p>

<pre><code>cin &gt;&gt; AmerAge;
</code></pre>

<p>I remember this with the memory aid: you input data <em>to</em> the variable, <code>cin &gt;&gt; var</code>, you output it <em>from</em> it, <code>cout &lt;&lt; var</code>.</p>

<hr>

<p>Secondly, <code>conio</code> is not a C++ header, it's not even a C header.</p>

<p>It's a blast from the past from Borland (or Invogue or Enchilada or whatever they call themselves nowadays).</p>

<p>And it has no place outside assignments in Indian educational institutions, where they seem to favour it despite having much more modern (and free and standards-compliant) options. It also doesn't complain about evils like not specifying a return type from <code>main()</code>.</p>

<hr>

<p>Finally, you may want to go back and reread all those warnings you should have heeded when installing MinGW.</p>

<p>You know, the ones about installing into a path with spaces in it and how that's likely to screw up a large chunk of the toolchain :-)</p>
",0
22484664,22484554,0,"<p>From all the info you have given, it seems that no new line is being printed on the end of the output, that means the either you forgot to recompile when you added <code>std::endl</code>, or you have misplaced it.</p>

<p><strong>Edit:</strong>
I just ran your code the way you posted it. The <code>endl</code> worked correctly, and the command line was placed below the output of your code. You are clearly running an old binary, from when the code didn't had the <code>endl</code> yet. Look carefully in your <code>g++</code> invocation the name of the generated file (the name after <code>-o</code>), and where it is being placed. You may try to rename the executable file you are running to something else, and run <code>g++</code> to see if a new file is generated with the name you are expecting.</p>
",5
22484770,22484554,0,"<p>Like mentioned earlier, make sure you have the <code>using namespace std</code> and <code>#include &lt;iostream&gt;</code> in your code.</p>
",0
22443232,22442997,0,"<p>You didn't declare certain methods as members of <code>DeQueType</code> thus the linker will not be able to resolve this symbols for the following:</p>

<ul>
<li><code>EnqFront</code></li>
<li><code>EnqRear</code></li>
<li><code>DeqFront</code></li>
<li><code>DeqRear</code></li>
<li><code>Print</code></li>
<li><code>Length</code></li>
</ul>

<p>These methods will not be able to access private methods of <code>DeQueType</code> and in the case of <code>EnqFront</code>it will not know what to do or what to link to:</p>

<p>To fix add the following to the definitions:</p>

<p><code>DeQueType&lt;ItemType&gt;::MethodName(args)</code></p>

<p>BTW: Doxygen comments go above the template line like this:</p>

<pre><code> /** @brief Adds newItem to the front of the queue.
  * Pre:  Queue is not full.
  * Post: newItem is at the front of the queue.
  */
template &lt;class ItemType&gt;
 void DeQueType&lt;ItemType&gt;::EnqFront(ItemType newItem)
{
    // DEfinition
}
</code></pre>

<p>You should also heed @rici's advice on what could happen with the print method </p>

<p>Here are the methods with the scope inclusion</p>

<pre><code> template &lt;class ItemType&gt;
 void DeQueType&lt;ItemType&gt;::EnqRear(ItemType newItem)
 // Function: Adds newItem to the rear of the queue.
 // Pre:  Queue is not full.
 // Post: newItem is at the rear of the queue.
 {
  NodeType&lt;ItemType&gt;* newNode;

    newNode = new NodeType&lt;ItemType&gt;;
    newNode-&gt;info = newItem;
    newNode-&gt;next = NULL;
    if (dequeRear == NULL)
        dequeFront = newNode;
    else
        dequeRear-&gt;next = newNode;
    dequeRear = newNode;
 }

 template &lt;class ItemType&gt;
 void DeQueType&lt;ItemType&gt;::DeqFront(ItemType&amp; item)
// Function: Removes front item from the queue and returns it in item.
// Pre:  Queue is not empty.
// Post: Front element has been removed from the queue. 
//       item is a copy of the removed element.
 {
      NodeType&lt;ItemType&gt;* tempPtr;

    tempPtr = dequeFront;
    item = dequeFront-&gt;info;
    dequeFront = dequeFront-&gt;next;
    if (dequeFront == NULL)
        dequeRear = NULL;
    delete tempPtr;
 }

 template &lt;class ItemType&gt;
 void DeQueType&lt;ItemType&gt;::DeqRear(ItemType&amp; item)
// Function: Removes rear item from the queue and returns it in item.
// Pre:  Queue is not empty.
// Post: Rear element has been removed from the queue. 
//       item is a copy of the removed element.
 {
     NodeType&lt;ItemType&gt;* tempPtr;

    tempPtr = dequeRear;
    item = dequeRear-&gt;info;
    dequeFront = dequeRear-&gt;next;
    if (dequeRear == NULL)
        dequeRear = NULL;
    delete tempPtr;
 }

 template &lt;class ItemType&gt;
 void DeQueType&lt;ItemType&gt;::Print( std::ostream &amp;out ) //cause of the problem
    // Function: Prints items in the deque from front to rear.  
    // Deque is printed on a single line of output with one space between each item.
    // Pre:  Deque has been initialized.
    // Post: Deque is unchanged.
{

    out &lt;&lt; dequeFront-&gt;info &lt;&lt; endl;
    while(dequeFront-&gt;next != NULL)
        out &lt;&lt; dequeFront-&gt;next &lt;&lt; endl;
 }

 template &lt;class ItemType&gt;
 int DeQueType&lt;ItemType&gt;::Length()
    // Function: Returns the number of items in the deque.  
    // Pre:  Deque has been initialized.
    // Post: Function value = number of items in the deque.
    //       Deque is unchanged.
{
    return count;
}
</code></pre>
",0
22443772,22442997,1,"<pre><code>template &lt;class ItemType&gt;
void Print( std::ostream out ) //cause of the problem
</code></pre>

<p>Streams are not copyable. They are not containers; they are flows of data. Flows cannot be copied.</p>

<p>Take the stream by reference, instead:</p>

<pre><code>template &lt;class ItemType&gt;
void Print( std::ostream&amp; out )
</code></pre>

<p>The ""weird error"" is because, prior to C++11, the only way for the author of a class to actually denote that the class must not be copied, is to make its copy constructor (and assignment operator) <code>private</code>, so that you get this access error when you try anyway.</p>

<p>By the way, you're missing <code>DeQueType::</code> on all of those definitions, and calling a file that you <code>#include</code> "".cpp"" is misleading. Yes, you need those definitions in a header, but conventionally we use "".ipp"" or some other extension so as to allay confusion.</p>
",0
27150790,27150422,1,"<p>My observation is that you are using floating point values for financial transactions. This is not a good idea. The representation of floating point numbers can be approximate for certain floating point values. It would be much better to use (long) integers to represent the pence/cents, and then represent the larger denomination in the output function.</p>

<p>That way your test will work.</p>

<p>In some contexts you may want to compare floats then use a very small constant floating point value perhaps called epsilon and have the test.</p>

<pre><code>if (fabs(amount - grandtotal) &lt; epsilon)
{
   cout&lt;&lt;""\t\tThank You, Have a nice day! \n"";
   cout&lt;&lt;""\t \tPlease come again \n"";
}
</code></pre>
",0
27150530,27150422,1,"<p>Your <code>else if</code> might be executed but most likely it won't happen, because <code>double</code> values precision is relatively high so there will be difference.</p>

<p>If you set the precision smaller for example that should work. </p>

<p>eg 2.11 == 2.11 rather than 2.15151523 == 2.15151524</p>

<p><a href=""https://stackoverflow.com/questions/12349323/setting-the-precision-of-a-double-without-using-stream-ios-baseprecision"">This</a> question might help you doing so.</p>
",2
27157129,27156777,0,"<p>The operator+ is not defined for to char[]. When you type strings in cpp as ""mystring"" they are interpreted at const char arrays. The operator+ is defined for strings and char[] so this works</p>

<pre><code>std::string mystr(""thisisatring"")
std::string otherstr = mystr + ""otherstring""
</code></pre>
",0
27156899,27156777,0,"<p>If I have understood correctly then you can write for example</p>

<pre><code>std::string mystr( ""a"" );
mystr +=  ""b"";
</code></pre>

<p>Or </p>

<pre><code>std::string mystr;
// ...
mystr = std::string( ""a"" ) + ""b"";
</code></pre>

<p>Or</p>

<pre><code>std::string mystr;
// ...
( mystr = ""a"" ) += ""b"";
</code></pre>

<p>Or</p>

<pre><code>std::string mystr;
// ...
mystr.assign( ""a"" ).append( ""b"" );
</code></pre>

<p>So as you see it can be done in various ways.</p>

<p>operator + may not be overloaded for pointers. 
So this expression</p>

<pre><code>""a"" + ""b""
</code></pre>

<p>is invalid.</p>

<p>For your code would work one of operands of operator + shall have type <code>std::string</code>.</p>

<p>If by some reason you need a pointer to an object of type std::string then you can write for example</p>

<pre><code>std::string *mystr = new std::string( ""a"" );

*mystr += ""b"";
</code></pre>
",1
27157721,27156777,0,"<p>Yes it's true that you can't add string literals with the '+' operator.
However, you can concatenate them without it. Simply remove your '+'.</p>

<pre><code>string mystr;  
mystr = ""a"" ""b"";
</code></pre>
",2
27158021,27156777,0,"<p>I am using usually using pattern below.</p>

<pre><code>std::string a = std::string{""something""} + std::string{"" more""};
</code></pre>
",0
24621425,24621401,4,"<p>If <code>x.currentsize == 0</code> and <code>y.currentsize == 0</code>, then you will never reach a <code>return</code> statement.</p>

<p>I get the feeling that you intended to write the following code. Note that we only <code>return true</code> once we've tested the whole list.</p>

<pre><code>bool operator==(const MyInt&amp; x, const MyInt&amp; y)
{
    if (x.currentSize != y.currentSize)
        return false;
    for (int i = 0; i &lt; x.currentSize; i++)
        if (x.integer[i] != y.integer[i])
            return false;
    return true;
}
</code></pre>
",1
24621431,24621401,2,"<p>You must put a return on the first <code>else</code>, in case your method doesn't go through the for loop, for example, when <code>x.currentSize = 0</code></p>

<p>Also, your <code>if</code> condition always returns a value after the first iteration, so you should change it like this, so you can check all elements in the <code>Array</code></p>

<pre><code>bool operator == (const MyInt&amp; x, const MyInt&amp; y)
{
    if (x.currentSize != y.currentSize)
    {
        return false;
    }
    else
    {
        for (int i = 0; i &lt; x.currentSize; i++)
                if (x.integer[i] != y.integer[i])
                    return false;
        return true;
    }
}
</code></pre>
",1
24621497,24621401,0,"<p>The general reason of such errors is a bad code that is difficult to read.</p>

<p>Rewrite the function the following way</p>

<pre><code>bool operator ==( const MyInt &amp;x, const MyInt &amp;y )
{
    if ( x.currentSize == y.currentSize )
    {
        int i = 0;
        while (  i &lt; x.currentSize &amp;&amp; x.integer[i] == y.integer[i] ) i++;

        return ( i == x.currentSize );
    }

    return ( false );
}
</code></pre>

<p>Or if <code>integer</code> is a pointer or an array then you could apply standard algorithm <code>std::equal</code> declared in header <code>&lt;algorithm&gt;</code>. For example</p>

<pre><code>#include &lt;algorithm&gt;

//...
bool operator ==( const MyInt &amp;x, const MyInt &amp;y )
{
    return ( x.currentSize == y.currentSize &amp;&amp; 
             std::equal( x.integer, x.integer + x.currentSize, y.integer ) );
}
</code></pre>

<p>I think this code looks much better does not it?</p>
",3
24640195,24640114,1,"<p><code>sf::Vector2</code> is a template class, that is you have to provide template arguments such as <code>sf::Vector2&lt;int&gt;</code> or <code>sf::Vector2&lt;float&gt;</code>. SFML defines some typedefs to help you (and you use them). So just fix <code>sf::Vector2</code> with <code>sf::Vector2f</code> which is a typedef for <code>sf::Vector2&lt;float&gt;</code>.</p>
",2
29516897,29516653,4,"<p>There's a ranking of implicit conversion sequences, as defined in [over.ics.rank], emphasis mine:</p>

<blockquote>
  <p>When comparing the basic forms of implicit conversion sequences...<br>
   - a standard conversion sequence (13.3.3.1.1) is <strong>a better conversion sequence than</strong> a user-defined conversion
  sequence or <strong>an ellipsis conversion sequence</strong>, and<br>
   - a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion
  sequence (13.3.3.1.3).</p>
</blockquote>

<p>So we have two functions:</p>

<pre><code>static char   testFun( int (C::*)() ) { return char(); }
static double testFun( ... ) { return double(); }
</code></pre>

<p>Both functions are viable for <code>testFun(0)</code>. The first would involve a ""null member pointer conversion"" as per [conv.mem], and is a standard conversion sequence. The second would match the ellipsis and be an ellipsis conversion sequence. By [over.ics.rank], the former is preferred. There's no ambiguity, the one is strictly better than the other. </p>

<p>An ambiguous overload would arise if we had two <em>equivalent</em> conversion sequences that the compiler could not decide between. Consider if we had something like:</p>

<pre><code>static char testFun(int* ) { return 0; }
static int testFun(char* ) { return 0; }

testFun(0);
</code></pre>

<p>Now both overloads would be equivalent as far as the conversion sequences go, so we'd have two viable candidates. </p>
",0
29516903,29516653,0,"<p>A null pointer literal 0 should be an exact match to a function accepting a function pointer and treated as stronger than matching anything (<code>...</code>).</p>
",0
29516941,29516653,3,"<p>You have a standard conversion vs an ellipsis conversion. The standard says that a standard conversion is a better conversion sequence than the latter. [over.ics.rank]/p2:</p>

<blockquote>
  <p>a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion
  sequence or an ellipsis conversion sequence</p>
</blockquote>

<p>A pointer-to-member conversion is a standard conversion sequence. <code>0</code> is a null pointer constant and can be converted to a pointer-to-member. [conv.mem]/p1:</p>

<blockquote>
  <p>A null pointer constant (4.10) can be converted to a pointer to member type; the result is the null member
  pointer value of that type and is distinguishable from any pointer to member not created from a null pointer
  constant. Such a conversion is called a null member pointer conversion.</p>
</blockquote>

<p>Therefore the first overload is preferred.</p>
",0
29516807,29516653,0,"<blockquote>
  <p>13.3.2 Viable functions
  A candidate function having fewer than m parameters is viable only if it has an ellipsis in its parameter list (8.3.5). For the purposes of overload resolution, any argument for which there is no corresponding parameter is considered to ¡°match the ellipsis¡± (13.3.3.1.3).</p>
</blockquote>

<p>And also</p>

<blockquote>
  <p>Viable functions
  Given the set of candidate functions, constructed as described above, the next step of overload resolution is examining arguments and parameters to reduce the set to the set of viable functions
  To be included in the set of viable functions, the candidate function must satisfy the following:<br/>
  1) If there are M arguments, the candidate function that has exactly M parameters is viable<br/>
  2) If the candidate function has less than M parameters, but has an ellipsis parameter, it is viable.<br/>
  [...]<br/>
  <a href=""http://en.cppreference.com/w/cpp/language/overload_resolution"" rel=""nofollow"">Overloading resolution</a></p>
</blockquote>
",0
28492653,28492610,1,"<p>The reason is that static class members need to a definition. Adding something like this outside your class definition will solve your linking troubles.</p>

<pre><code>int* Instack::s = nullptr;
int Instack::top;
</code></pre>

<p>Unfortunately, that leaks memory. What you likely meant to do is have both <code>s</code> and <code>top</code> as non-static member variables.</p>
",0
22461579,22461232,1,"<p>If you want to go from 1 to n (inclusive), you'll have to declare &amp; initialize the garph as follows:</p>

<pre><code>std::list&lt;int&gt;* graph = new std::list&lt;int&gt;[vertices+1];
</code></pre>

<p>This should get rid of that error you were getting here:</p>

<pre><code>for (int i = 1; i &lt;= edges; i++){
     graph[i] = std::list&lt;int&gt;();
}
</code></pre>
",2
24764803,24764527,1,"<p>Use <code>std::chrono::high_resolution_clock</code> for highest resolution</p>

<pre><code>typedef std::chrono::high_resolution_clock Clock;
auto start = Clock::now();
... do some work ...
auto stop = Clock::now();

std::cout &lt;&lt; stop-start &lt;&lt; '\n';
</code></pre>
",0
24764642,24764527,0,"<p>Using cout formatters.</p>

<pre><code>include &lt;iomanip&gt;

std::cout &lt;&lt; ""Exec Time: "" &lt;&lt; std::setprecision(12) &lt;&lt; tt &lt;&lt; "" Seconds"" &lt;&lt; std::endl;
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/iomanip/setprecision/"" rel=""nofollow"">http://www.cplusplus.com/reference/iomanip/setprecision/</a></p>

<p>I recommend also use of <strong>chrono</strong> new in C++11.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iomanip&gt;

std::chrono::system_clock::time_point begin_time = std::chrono::system_clock::now();

... work ...

std::chrono::system_clock::time_point end_time = std::chrono::system_clock::now();
long long elapsed_seconds = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(end_time-begin_time).count();
std::cout &lt;&lt; ""Duration (min:seg): "" &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (elapsed_seconds / 60) &lt;&lt; "":"" &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (elapsed_seconds % 60) &lt;&lt; std::endl;
</code></pre>
",1
29248330,29248217,6,"<p><code>fill()</code> assigns values (using the assignment operator) to already constructed objects. <code>uninitialized_fill()</code> constructs objects (using the copy constructor) in raw uninitialized memory.</p>
",0
25493173,25493010,6,"<p>Note that <code>pow</code> is a function that works with floating point numbers. Optimizations might lead to rounding errors or truncation during implicit coversion to int. Replace <code>pow(i, 2)</code> with <code>i*i</code> and you'll get pure integer arithmetic and thus exact results. </p>
",1
25524466,25522890,2,"<p>In your code I cannot see checking of newline. See my code, it seems to work fine. Maybe it is solution which you are looking for.   </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

int main()
{
    int sum = 0;
    string line;

    while (getline(cin, line))
    {
        stringstream ss(line);
        int tmp;

        if (ss &gt;&gt; tmp)
        {
            sum += tmp;
        }
        else
        {
            break;
        }
    }

    cout &lt;&lt; ""\nSuma tych liczb to: "" &lt;&lt; sum &lt;&lt; ""\n\n"";

    return 0;
}
</code></pre>
",1
25498669,25498586,2,"<p>When you swap <code>std::string</code>s, they internally exchange fields including <code>char*</code> pointers, no allocation is performed. </p>

<p><strong>EDIT</strong> I missed the point that you are not using <code>std::string</code>s, but you should consider doing it anyway.</p>
",2
25498697,25498586,3,"<p>The pointers are swapped as-they-are: that means each of them after the swap will point to the memory allocated for the other. The contents of memory are not supposed to be changed in any other way.</p>
",1
25489787,25489678,1,"<p>You have to think of resource ownership issues. You have make some policy decisions. Then write code that confirms to that policy.</p>

<p>After you execute:</p>

<pre><code>obj1-&gt;setNext(obj2);
</code></pre>

<p>who owns <code>obj2</code>? Is <code>obj2</code> owned by <code>obj1</code>? Is it owned by the calling function or a higher level object?</p>

<p>If your policy says that <code>obj1</code> owns <code>obj2</code>, then, you have to delete <code>obj2</code> when you delete <code>obj1</code>.</p>

<p>If your policy says that the calling function or a higher level object owns <code>obj2</code>, then you must not delete <code>obj2</code> when you delete <code>obj1</code>.</p>

<p>You asked:</p>

<blockquote>
  <p>if I delete obj1.. obj2 and obj3 get deleted auotmatically. Why?</p>
</blockquote>

<p>Because you did not write the code to delete them.</p>

<blockquote>
  <p>Is this a memory leak?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>Are they actually deleted?</p>
</blockquote>

<p>No.</p>

<blockquote>
  <p>I don't understand such behaviour. Shouldn't there be a delete for every new?</p>
</blockquote>

<p>Yes. there should. However, you have to make sure that <code>delete</code> is called on each object returned from <code>new</code>.</p>

<p>If your policy is that <code>obj1</code> owns <code>obj2</code> after the above mentioned call, you have to implement the destructor of <code>A</code> to delete <code>next</code> and <code>previous</code>. However, you have to make sure that the links are properly taken care of before you do that. Otherwise, you will run into pointers that have already been deleted, you will run into memory leaks if you don't take care of traversing the links correctly.</p>

<pre><code>~A()
{
   // Hopefully next-&gt;previous points to this.
   // You have to unlink next from this. Otherwise, 'delete next' will end up calling
   // delete on 'this`.
   // Similarly with previous

   if ( next != nullptr )
   {
       next-&gt;previous = nullptr;
      delete next;
   }

   if ( previous!= nullptr )
   {
       previous-&gt;next= nullptr;
      delete previous;
   }
}
</code></pre>

<p>You still have to call</p>

<pre><code>delete obj1;
</code></pre>

<p>in <code>main</code> to make sure that all the objects are deleted.</p>

<p>If your policy is that the calling function or a higher level object owns <code>objt2</code> after the statement</p>

<pre><code>obj1-&gt;setNext(obj2);
</code></pre>

<p>you have to call delete on all the objects from the calling function.</p>

<pre><code>int main()
{
  A* obj1 = new A();
  A* obj2 = new A(); 
  A* obj3 = new A();

  obj1-&gt;setNext(obj2);
  obj2-&gt;setNext(obj3);
  obj3-&gt;setNext(nullptr);

  obj1-&gt;setPrevious(nullptr);
  obj2-&gt;setPrevious(obj1);
  obj3-&gt;setPrevious(obj2);

  delete obj3;
  delete obj2;
  delete obj1;

  return 0;
}
</code></pre>

<p>To make this a little cleaner, you should deal with a higher level container that is analogous to <code>std::list</code>. You add and remove items from the list. When the list is deleted, it has to make sure that all the contained elements are deleted too.</p>
",1
28199542,28198944,2,"<p>You are opening the file for output twice, and the second time is overwriting what you wrote the first time. You can either open it only once, or you can open it in append mode the second time:</p>

<pre><code>ofstream outfile(""report.txt"", std::ios::app);
</code></pre>

<p>This will make it append to the end of the file instead of overwriting it.</p>
",1
26816245,26816229,6,"<p>It's because of this</p>

<pre><code>string skey = key;
</code></pre>

<p>There's no overloaded constructor in string which only takes character as its input.See below the complete list:-</p>

<pre><code>string();
string (const string&amp; str); 
string (const string&amp; str, size_t pos, size_t len = npos);  
string (const char* s); 
string (const char* s, size_t n);   
string (size_t n, char c);  
template &lt;class InputIterator&gt;
  string  (InputIterator first, InputIterator last);
</code></pre>

<p>To fix you can use:-</p>

<pre><code>string skey(1, key);
</code></pre>
",0
26816276,26816229,3,"<pre><code>  string skey = key;
</code></pre>

<p>There is no viable converting constructor in <code>string</code> that takes just a <code>char</code>.<br>
Initialize it like this: </p>

<pre><code>string skey{key};
</code></pre>

<p>Or this:</p>

<pre><code>string skey(1, key);
</code></pre>
",1
28204246,28011681,0,"<p>I found some code that does what I was trying to do:</p>

<pre><code>str = (char*)calloc(strlen(txt) - 1, sizeof(char));
strncpy(str, &amp;txt[1], strlen(txt) - 2);
</code></pre>
",0
34241180,34240797,0,"<p>You cannot represent irrational numbers even in the pure math, except symbolically (like Pi, sqrt(2) - you can say ""Pi"" but you cannot write its exact value on the paper). And the same applies to the computer representation - if you want to represent them exactly, you cannot represent them as a ""real"" numbers, only symbolically (in the computer it is actually difficult to represent even the rational numbers precisely).</p>

<p>So, to answer your question - as a consequence of the above, your data members could be for example strings (symbols or entire expressions represented as strings, like ""Pi"" or ""sqrt(2)"") and/or combined with expression trees (operators and operands to store the expressions which represent the irrational numbers, like operator=sqrt, operand=2 and alike).</p>
",0
34242434,34240797,1,"<p>The only way that I think that you may be able to achieve something of this nature would be with identifiers and not the actual mathematical or number representations. Even in pure mathematics Irrational numbers are labeled as irrational due to given postulates. Even a human can not truly represent an irrational number by its digits. So the only thing I can suggest is to have an identifier of the known irrational numbers such as something like this:</p>

<pre><code>enum Irrational {
    PI = 0,
    E,
    SQRT2,

    ...

};
</code></pre>

<p>Then you might want to make an association of them with a map like this:</p>

<pre><code>std::map&lt;Irrational, double&gt; myIrrationals;
myIrrations.insert( std::make_pair&lt;Irrational, double&gt;( PI, 3.141592654 ) );
</code></pre>

<p>Then your check for irrational numbers would be true if they are found in this map and false otherwise.   </p>
",0
25542073,25540952,1,"<p>As Pragnesh suggested, use cURL library. However using cURL means it will both create the packets and send it over the socket. You may try the following two approaches</p>

<ol>
<li><p>The first option is to modify the cURL code itself so that before the packets are written onto socket they are modified. But this will involve gaining a good understanding of the FTP library and recompiling the whole code. This is possible but is not a neat approach.</p></li>
<li><p>The second approach works as follows
a. Allow the library ( cURL or any other library ) to create protocol packets and write it onto socket. However when you pass the FTP server IP to the library pass a fake IP ( this is a temporary IP and will be replaced later ) e.g. 10.1.1.5.</p>

<p>b. Create a virtual device ( TUN device that is part of standard linux distribution ) and have the FTP protocol packets written to the virtual device at the IP layer. For this add a new route table entry which says that for the packets having destination IP as your fake IP ( 10.1.1.5 in this case ) the destination device should be your TUN device. So every time a FTP protocol packet reaches the IP layer with destination IP as 10.1.1.5, it will be written to the virtual device instead to being sent out of the machine.</p>

<p>c. In your application listen on the virtual device using the read() command. All the packets that are written onto the virtual device are received at the application. The received packet is a ""FTP over TCP over IP"" packet. That means it will have the FTP protocol packet, the TCP header and the IP header.</p>

<p>d. Now you can do pretty much anything with this packet that you want. In your case just get the right offset in the buffer ( the size of IP and TCP header is fixed ) and add your data. Once you have modified the packet, you will have to change two IP addresses. The source IP address in this IP packet is the virtual device IP address not your eth0 address. So replace this source IP with your eth0 address. The destination IP address in the pakcet is the fake IP. Again replace this address with the correct FTP server IP. </p>

<p>e. Once done recalculate the IP and TCP header checksums. ( These are standard algorithms can be easily found). After this the last thing is to write the packet again on the virtual device using write () command. Once you do that the packet will be injected on the IP layer and this time will go out of the machine. You will have to set the IP forwarding flag and disable the rp-filter settings. </p></li>
</ol>

<p>Hope this helps. </p>
",1
28463546,28463465,5,"<p>Your <code>if</code> is evaluated from left to right, so for </p>

<p><code>if (!stack.pop(a) || !stack.pop(b)) {</code></p>

<p><code>a</code> is set first, then <code>b</code>.</p>

<p>Note also for your <code>pop</code> method that you never actually pop the stack -  you only return the top-most value.</p>
",2
28463550,28463465,3,"<p>What you have is fine. The logical or operator (<code>||</code>) short-circuits meaning the right side is only executed if the left side evaluates to false. In the case where the first pop succeeds, the left side is <code>false</code>, and therefore the right side will also be evaluated, and store the appropriate value if the stack is not empty.</p>
",0
28463555,28463465,1,"<p>Yes, pop function will be normally executed inside the if statement, so the value will be stored.</p>
",0
28463649,28463465,2,"<p>The value will be stored in both a and b. </p>

<p><strong>Note</strong> a pop function traditionally removes the last element of a list and returns it to the caller. What you are doing is not a pop.</p>
",0
25704367,25704352,0,"<p>Your program needs to provide a <code>main()</code> function because it's called by your system to start the program. Rename <code>name()</code> to <code>main()</code>.</p>
",0
25704384,25704352,0,"<p>You need to define a main function.</p>

<pre><code>int main()
</code></pre>

<p>Or </p>

<pre><code>int main(int argc, char* argv[])
</code></pre>

<p>Since you're not using command line arguments, just rename <code>name</code> to <code>main</code>.</p>
",1
25697995,25697933,2,"<p><code>argv</code> is simply an array of char pointers terminated by a final <code>NULL</code> pointer. You can create your own using <code>my_argv = new char *[number_of_items + 1]</code>, where <code>number_of_items</code> is the number of arguments you want to cherry-pick from ""real"" <code>argv</code> (or your own strings). Such array can be passed to <code>G4MPIManager</code> constructor instead of the actual <code>argv</code> received in <code>main()</code>.</p>

<p>Additional notes:</p>

<ul>
<li><p>Don't forget to terminate <code>argv</code> with a NULL pointer.</p></li>
<li><p>The first member of <code>argv</code>, <code>argv[0]</code>, will be expected to hold the ""program name"" and as such will be either ignored or only used to prefix diagnostic messages. Simply reuse the <code>argv[0]</code> you get from <code>main()</code>.</p></li>
<li><p><code>argc</code> should be such that <code>argv[argc] == NULL</code>, i.e. the same as the <code>number_of_items</code> above. Given that the <code>argv</code> array must contain program name as first member, <code>argc</code> will never be 0.</p></li>
</ul>
",3
25698005,25697933,0,"<p>You just have to construct new pair of argc and argv for whatever your <code>i</code> is and then pass it to your function.</p>

<pre><code>int newArgc = argc - i;
char** newArgv = &amp;argv[i];
G4MPImanager* g4MPI = new G4MPImanager(newArgc, newArgv);
</code></pre>
",0
25698216,25697933,2,"<p>Create a vector of strings.<br>
Erase the arguments you don't want from the vector.<br>
You can then create a <code>char*[]</code> from the vector very easily (at the size is trivial).</p>

<pre><code> int main(int argc, char* argv[])
 {
      std::vector&lt;char*&gt;  args(argv, argv+argc+1);  // +1 to catch the last NULL at argv[argc]

      for(auto loop = args.begin(); loop != args.end();)
      {
          if      (/*Your Test 1 */) { /*STUFF 1*/ loop = args.erase(loop);}
          else if (/*Your Test 2 */) { /*STUFF 2*/ loop = args.erase(loop);}
          else                       { ++loop; /* If you did not remove it increment loop*/ }
      }
      // args.size() -1 becuase we have the extra NULL as the last argument.
      //             and argv[arc] should be null
      // &amp;args[0]    is the address of the first member.
      //             vector keeps its data in contiguous memory so will look like an array
      G4MPImanager* g4MPI = new G4MPImanager(args.size() - 1, &amp;args[0]);
 }
</code></pre>
",0
28237387,28237323,4,"<p>Overload the <code>operator[]</code> function, like so:</p>

<pre><code>int&amp; operator[] (int idx) {
    return v[idx];
}
</code></pre>

<p>Additionally, you should supply a <code>const</code> version of your function which can be used when the <code>Vector</code> is const-qualified.</p>

<pre><code>const int&amp; operator[] (int idx) const {
    return v[idx];
}
</code></pre>
",3
28237353,28237323,0,"<p>You need to overload [] operator.</p>

<pre><code>int &amp;operator[](int i)
      {
          if( i &gt;= sz )
          {
              cout &lt;&lt; ""Index out of bounds"" &lt;&lt;endl; 
              // return first element.
              return v[0];
          }
          return v[i];
      }
</code></pre>
",2
28237373,28237323,0,"<p>Every operator that you want to use with with your class needs to be overloaded.</p>

<p>You can see <a href=""https://stackoverflow.com/questions/4421706/operator-overloading"">this question</a> for details.</p>

<p>Off course unless this is homework the only sane thing to do is to use <code>std::vector</code></p>
",0
25656551,25656507,1,"<p>Your current</p>

<pre><code>Area::calcArea(){
   int answer;
   ...
</code></pre>

<p>definition misses to specify a return type matching the declaration <code>int calcArea();</code> from your <code>Area</code> class declaration.</p>

<p>As T.C. already showed it needs to be </p>

<pre><code>  int Area::calcArea(){
//^^^
      int answer;
      ...
</code></pre>
",0
25656513,25656507,3,"<p>You are missing the return type.</p>

<pre><code>  int Area::calcArea(){
//^^^
</code></pre>
",1
27571373,27571284,4,"<p><code>LCPSTR</code> means long constant pointer to a string, which means it's a null terminated c string.</p>

<p><code>std::string</code> is an object. It is something different. But it luckily provides a convenience method <a href=""http://en.cppreference.com/w/cpp/string/basic_string/c_str"" rel=""nofollow""><code>c_str</code></a> the provides a pointer to a constant c style string. So as the comment says you should go by:</p>

<p><code>MoveFileA(oldLocation.c_str(), newLocation.c_str());</code></p>

<p>It is worth of explicitly noting, that you can't drop it in every place instead of <code>char*</code>, but only when the string won't be modified. It returns <code>const char*</code>. This is where the C in LCPSTR gets important.</p>
",0
29444435,29444188,0,"<pre><code>template&lt;typename DataType&gt;
typename AVLTree&lt;DataType&gt;::AVLNodePointer AVLTree&lt;DataType&gt;::ll_rotation(AVLTree&lt;DataType&gt;::AVLNodePointer parent)
{
}
</code></pre>

<p>The <code>AVLNodePointer</code> type is only defined in the <code>AVLTree&lt;DataType&gt;</code> class, so a prefix is required.</p>

<p>The type <code>AVLTree&lt;DataType&gt;::AVLNodePointer</code> is called a ""dependent name"", because it is dependent on an instantiation of the class <code>AVLTree&lt;DataType&gt;</code>.</p>

<p><a href=""http://eelis.net/c++draft/temp.res"" rel=""nofollow"">Section 14.6</a> of the C++ standard requires use of the <code>typename</code> keyword every time a dependent name is used.</p>

<blockquote>
  <p>A name used in a template declaration or definition and that is
  dependent on a template-parameter is assumed not to name a type unless
  the applicable name lookup finds a type name or the name is qualified
  by the keyword typename.</p>
</blockquote>
",3
29448820,29448551,0,"<p>As Joachim Pileborg said in the comment, <code>mobile</code> is array of integers, not a integer that can hold 11 digits. 
The problem is here</p>

<pre><code>int mobile[11];    
</code></pre>

<p>Replace with</p>

<pre><code>int mobile;
</code></pre>

<p>May be looking at array tutorials will help understand how they work.
<a href=""http://www.cplusplus.com/doc/tutorial/arrays/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/arrays/</a></p>

<p>Since you also want only 11 digits in a phone number, what you can do is to store the mobile into string and then convert it to int.
Something like this</p>

<pre><code>private:
    std::string name;      &lt;-- see difference here
    std::string mobile;    &lt;-- see difference here
public:
    void ask()
    {
       //your code
    }
    void print()
    {
        std::cout&lt;&lt;""Your Name is"";
        std::cout&lt;&lt;name&lt;&lt; std::endl;
        std::cout&lt;&lt;""Aur aapka mobile number hai"";
        std::istringstream sstream(mobile);    
        int cellNum;
        sstream &gt;&gt; cellNum;
        std::cout&lt;&lt;cellNum&lt;&lt; std::endl;
    }
</code></pre>
",3
25706986,25705833,1,"<pre><code>gold += silver / SILVERPERGOLD
</code></pre>

<p><code>+=</code> means ""increment the variable on the left side of <code>+=</code> by the amount on the right side"".</p>

<pre><code>silver = (int)((gold - (int)gold)) * SILVERPERGOLD; 
gold = (double)((int)(gold));
</code></pre>

<p>This is a really, really, really wrong way to do a floating point remainder calculation.</p>

<p>Type castiing is another name for explicit type conversion.</p>

<pre><code>(double)x
</code></pre>

<p>means ""take the value of <code>x</code> and return 'the same' value but of type <code>double</code>"". If <code>x</code> is 7, the result will be 7.0. It is a long obsolete way to do a type cast in C++. Google ""c style casts"" for more info.</p>

<p>Correspondingly,</p>

<pre><code>(int)x
</code></pre>

<p>means ""take x and return 'the same' value as <code>int</code>"". If x is 7.83, the result is 7 (i.e. the fractional part is dropped).</p>

<p>So <code>((gold - (int)gold))</code> would mean ""subtract the whole part from <code>gold</code>, leaving the fractional part"". Then the author multiplies the result by the gold-to-silver conversion rate, and rounds it down to a whole number. This presumably gives us the amount of change in silver pieces. Finally, with <code>gold = (double)((int)(gold))</code> the author rounds the amount of gold down to a whole number. The fractional part is already converted to silver, so the two numbers, <code>gold</code> and <code>silver</code>, together comprise the sum of money you have.</p>

<p>The entire operation tries to fit a whole number of gold pieces into the price, and make up the rest with silver. Never do it this way. </p>
",5
29498206,29498165,3,"<p>Function main shall have return type <code>int</code></p>

<pre><code>int main()
{
//...
}
</code></pre>

<p>From the C++ Standard (3.6.1 Main function)</p>

<blockquote>
  <p>2 An implementation shall not predefine the main function. This
  function shall not be overloaded. It <strong>shall have a return type of type
  int</strong>, but otherwise its type is implementation-defined. All
  implementations shall allow both ¡ª a function of () returning int and
  ¡ª a function of (int, pointer to pointer to char) returning int as the
  type of main (8.3.5).</p>
</blockquote>

<p>Take into account that your program outputs nothing in case when two entered numbers are equal each other.</p>

<p>Also this statement </p>

<pre><code>if (val1 &gt; val2)
    cout &lt;&lt; ""the smaller number you typed was: \n"" &lt;&lt; val1;
</code></pre>

<p>is wrong. There should be</p>

<pre><code>if (val1 &gt; val2)
    cout &lt;&lt; ""the smaller number you typed was: \n"" &lt;&lt; val2;
</code></pre>
",0
29504779,29504677,2,"<pre><code>int mf_option(1);
</code></pre>

<p>is a definition of the variable <code>mf_option</code>. It's type is <code>int</code> and value is <code>1</code>. It's not a declaration of a function.</p>

<p>Later on, you have:</p>

<pre><code>int mf_option(1)
{
 ...
}
</code></pre>

<p>That is a syntactically invalid construct. It starts out like you are going to define a variable and ends up like you are defining a function.</p>

<p>Similar problem exists for <code>mf_rectangle</code>.</p>

<p>If I understand your intention correctly, you need to replace the lines:</p>

<pre><code>int mf_option(1);
int mf_rectangle(2);
</code></pre>

<p>by</p>

<pre><code>int mf_option(int arg);
int mf_rectangle(int arg);
</code></pre>

<p>Make similar changes to where you are trying to define the functions.</p>
",2
29515402,29515046,1,"<p>Just a guess:</p>

<p>Your parameter is a string, not a reference or a pointer of string but a string. Basically when <code>_Add</code> is called a copy of <code>sm_string a</code> is created on the stack.</p>

<p>The destructor is then called twice on the <code>a</code> the variable a in the <code>_Add</code> function (which is a copy of the original object) and on the <code>a</code> in your main function.</p>

<pre><code>void _Add(sm_string a) &lt;= Try to change a with a pointer or a reference
{
    // it adds the string to string(concatenates) and saves result in (*this)
    printf(""\n_Add %s %s\n"",str,a());
    str = (char*)ReallocSave(str,Len()+a.Len()+1,Len()+1);
    memcpy(str+Len(),a(),a.Len()+1);
}
</code></pre>
",1
34257842,34257817,1,"<p>Your constructors do nothing, class members for <code>Fred</code> and <code>Tom</code> are uninitialized.</p>

<p>Use these instead:</p>

<pre><code>Animal::Animal() {
    SetAll(0, 0, """");
}

Animal::Animal(int height, int weight, string name) {
    SetAll(height, weight, name);
}
</code></pre>
",4
34257867,34257817,0,"<p>There are 3 issues:</p>

<p>1) For the default constructor, you failed to initialize your member variables of <code>Animal</code>.  </p>

<pre><code>Animal::Animal()
{
    Animal::numOfAnimals++;
}
</code></pre>

<p>This should be changed to give some sort of default values:</p>

<pre><code>Animal::Animal()
{
    SetAll(0,0,"""");
}
</code></pre>

<hr>

<p>2) In your non-default constructor, you failed to initialize the members.</p>

<pre><code>Animal::Animal(int height, int weight, string name) 
{
}
</code></pre>

<p>It should be changed to this:</p>

<pre><code>Animal::Animal(int height, int weight, string name) 
{
   SetAll(height, weight, name);
}
</code></pre>

<hr>

<p>3) Your code will fail to update the number of Animals in the case of copy construction:</p>

<pre><code>Animal Fred;
Animal Fred2 = Fred;
cout &lt;&lt; Animal::getNumberofAnimals();
</code></pre>

<p>You will see that the output is <code>1</code>, even though there are clearly 2 Animal objects that are created.</p>

<p>To fix this issue, you need to have a copy constructor:</p>

<pre><code>Animal::Animal(const Animal&amp; rhs)
{
   SetAll(rhs.height, rhs.width, rhs.name);
}
</code></pre>
",0
29211211,29211169,1,"<p>That is not a global variabel when you declare it in main.
Move it out of main like this:</p>

<pre><code>int a[100];  // Global variable

void main(){
earray();
}
void earray(){
//i want to use a[] here.
}
</code></pre>
",0
29211202,29211169,7,"<p>It's not a global variable (it's <em>local</em>). I assume you're trying to achieve something like the following:</p>

<p>Pass the local value to the function as a parameter (<em>better practice</em>)</p>

<p>For example :</p>

<pre><code>void earray(int array[]){
    //array.
}

void main(){
    int a[100];
    earray(a);
}
</code></pre>

<p>Or, as a Global Variable (as you mentioned):</p>

<pre><code>int a[100];

void earray(){
    //a.
}

void main(){
    earray();
}
</code></pre>
",4
29908771,29908431,4,"<p>What version of C++ are you using? Before C++11, any class with at least one constructor could not be constructed using an aggregate list:</p>

<pre><code>struct A
{
    std::string s;
    int n;
};
struct B
{
    std::string s;
    int n;

   // default constructor
    B() : s(), n() {}
};

int main()
{
    A a = { ""Hi"", 3 }; // A is an aggregate class: no constructors were provided for A
    B b; // Fine, this will use the default constructor provided.
    A aa; // fine, this will default construct since the compiler will make a default constructor for any class you don't provide one for.
    B bb = { ""Hello"", 4 }; // this won't work. B is no longer an aggregate class because a constructor was provided.
    return 0;
}
</code></pre>

<p>I daresay Circle has a constructor defined, and cannot be constructor with an aggregate initialisation list pre C++11. You could try:</p>

<pre><code>Circle list[] = { Circle(93, ""Yellow""), Circle(16, ""Red"") };
</code></pre>
",0
25705949,25705874,2,"<p>Before writing any code, attempt to create a file using NotePad, WordPad, or some other app in the <code>C:\</code> directory.  If you cannot create a file using NotePad, then you can't create one with your own program.</p>

<p>Therefore either write to a drive\directory you have permission to, or change your access rights to the root directory (which I wouldn't recommend, but just to give you another option).</p>
",2
29452208,29452186,1,"<p>Just fix the return type:</p>

<pre><code>static const Val&amp; get(Map const&amp; self, const Key idx) { return self.at(idx); }
//     ^^^^^
</code></pre>

<p>The explanation is all in the error message you posted (added emphasis):</p>

<blockquote>
  <p>error: invalid initialization of reference of type <strong><code>¡®std::basic_string&lt;char&gt;&amp;¡¯</code></strong> from expression of type ¡®const mapped_type {aka <strong><code>const std::basic_string&lt;char&gt;</code></strong>}¡¯</p>
</blockquote>

<p><code>at()</code> returns a <code>const Val&amp;</code>, but you were trying to return a <code>Val&amp;</code> and there is no such implicit conversion. You just have to change the return type of your <code>get()</code> to match the return type of <code>at()</code>.</p>
",2
27516884,27516867,7,"<p><code>addressinfo info = gna(addressinfo&amp; info)</code> should be <code>addressinfo info = gna(info)</code> because you're <em>calling</em> a function, not creating one.</p>
",3
28175346,28175283,5,"<p>You don't. Either name them something different or use a <code>struct</code> to hold the related data:</p>

<pre><code>string student_name[2] = {};
double student_score[2] = {0};

// or

struct student
{
   student() : name(""""), score(0) {}
   string name;
   double score;
};

student students[2];
</code></pre>
",0
26414948,26414909,1,"<pre><code>#include &lt;math.h&gt;       /* floor */

double myLength = 1.88;
double feet = floor(myLength / 0.3048);
myLength -= feet * 0.3048;
double inches = floor(myLength / 0.0254);
</code></pre>
",0
26414977,26414909,3,"<p>This is more of a math problem than a programming problem. Given a length in feet, which is trivial to get from meters, you need to convert the fractional part of the feet to inches. You can do this with integer casting and modulo operations:</p>

<pre><code>const double METERS_PER_FOOT = 0.3048;
const double INCHES_PER_FOOT = 12.0;
double heightInMeters = 1.78;
double heightInFeet = heightInMeters / METERS_PER_FOOT;
int feet = (int)heightInFeet;
int inches = (int)((heightInFeet - feet) * INCHES_PER_FOOT + 0.5);
</code></pre>

<p>The last step takes the fractional part <code>(heightInFeet - feet)</code>, multiplies it by the number of inches in a foot to get the number of inches, then rounds it by adding half and truncating to an integer.</p>
",0
34081365,34081317,0,"<p>As the first comment to the question you mention says, the behavior is undefined. That basically means every compiler is free to interpret your code however it wants. Clearly, your compiler sees the problem and throws an error, while a different compiler may allow the code to compile, especially if it's internal representation of scope allows the loop to happen.</p>
",0
34082287,34081317,4,"<p>I note that the code in the question is C++ code and not C code.  However, the question is dual-tagged with C and C++, which is irksome since the rules for C and C++ are different.</p>

<h2>The code fails to compile in C++ but equivalent code compiles in C</h2>

<p>The C++ code in the question should not compile.  Analogous code written in C should compile, but the net result is an infinite loop.</p>

<h2>C++11</h2>

<p>In ISO/IEC 14882:2011 (the C++11 standard; I don't have an official copy of the 2014 standard to report on), it says:</p>

<blockquote>
  <h3>6.6.4 The goto statement [stmt.goto]</h3>
  
  <p>?1 The <code>goto</code> statement unconditionally transfers control to the statement labeled by the identifier. The identifier shall be a label (6.1) located in the current function.</p>
  
  <h3>6.7 Declaration statement [stmt.dcl]</h3>
  
  <p>?1 A declaration statement introduces one or more new identifiers into a block; it has the form declaration-statement:
  block-declaration
  If an identifier introduced by a declaration was previously declared in an outer block, the outer declaration is hidden for the remainder of the block, after which it resumes its force.</p>
  
  <p>?2 Variables with automatic storage duration (3.7.3) are initialized each time their declaration-statement is executed. Variables with automatic storage duration declared in the block are destroyed on exit from the block (6.6).</p>
  
  <p>?3 It is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A program that jumps<sup>87</sup> from a point where a variable with automatic storage duration is not in scope to a point where it is in scope is ill-formed unless the variable has scalar type, class type with a trivial default constructor and a trivial destructor, a cv-qualified version of one of these types, or an array of one of the preceding types and is declared without an initializer (8.5).</p>
  
  <p><sup>87)  The transfer from the condition of a switch statement to a case label is considered a jump in this respect.</sup></p>
</blockquote>

<p>Although a plain <code>int</code> is a scalar type, the jump bypasses the initialization and so is not allowed.</p>

<h2>C11</h2>

<p>In ISO/IEC 9899:2011 (the C11 standard), it says:</p>

<blockquote>
  <h3>6.8.6.1 The <code>goto</code> statement</h3>
  
  <p><strong>Constraints</strong><br>
  ?1 The identifier in a <code>goto</code> statement shall name a label located somewhere in the enclosing function. A <code>goto</code> statement shall not jump from outside the scope of an identifier having a variably modified type to inside the scope of that identifier.</p>
  
  <p><strong>Semantics</strong><br>
  ?2 A goto statement causes an unconditional jump to the statement prefixed by the named label in the enclosing function.</p>
</blockquote>

<p>Note that constraint violations require a diagnostic.  Violations of rules in semantics sections do not require a diagnostic.</p>

<p>And in <strong>Annex I (Common Warnings)</strong>, which is an informative annex and not a normative one, it says:</p>

<blockquote>
  <p>¡ª A block with initialization of an object that has automatic storage duration is jumped into (6.2.4).</p>
</blockquote>

<p>And</p>

<blockquote>
  <h3>6.2.4 Storage durations of objects</h3>
  
  <p>?5 An object whose identifier is declared with no linkage and without the storage-class specifier <code>static</code> has <em>automatic storage duration</em>, as do some compound literals. The result of attempting to indirectly access an object with automatic storage duration from a thread other than the one with which the object is associated is implementation-defined.</p>
  
  <p>?6 For such an object that does not have a variable length array type, its lifetime extends from entry into the block with which it is associated until execution of that block ends in any way. (Entering an enclosed block or calling a function suspends, but does not end, execution of the current block.) If the block is entered recursively, a new instance of the object is created each time. The initial value of the object is indeterminate. If an initialization is specified for the object, it is performed each time the declaration or compound literal is reached in the execution of the block; otherwise, the value becomes indeterminate each time the declaration is reached.</p>
  
  <p>?7 For such an object that does have a variable length array type, its lifetime extends from the declaration of the object until execution of the program leaves the scope of the declaration.<sup>35)</sup> If the scope is entered recursively, a new instance of the object is created each time. The initial value of the object is indeterminate.</p>
  
  <p><sup>35) Leaving the innermost block containing the declaration, or jumping to a point in that block or an embedded block prior to the declaration, leaves the scope of the declaration.</sup></p>
</blockquote>

<p>Note that there is no variably modified type (no VLA or <em>variable length array</em>) in the code in the question.  Standard C++ does not support the concept of VLAs (though the GNU C++ compiler does allow them as an extension).</p>

<p>Code (<code>goto1.c</code>):</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    {
        int a = 10;
tag:
        printf(""%d\n"", a);
    }
    goto tag;
    return 0;
}
</code></pre>

<p>Sample compilation:</p>

<pre><code>$ gcc -std=c11 -O3 -g -Wall -Wextra -Werror goto1.c -o goto1
$
</code></pre>

<p>Those are fairly stringent warning options, and GCC utters not a peep ¡ª which is permissible behaviour given what the C standard says.</p>
",2
31250833,31250740,5,"<p>No, <code>getline</code> does not have the same issues as <code>gets</code>. The function has a reference to the string, and so can call the string's <code>size</code> and <code>capacity</code> member functions for boundary checking purposes. However, it doesn't need to do that, because it also has access the string's resizing member functions, such as <code>push_back</code>, <code>resize</code> or <code>operator+=</code>, which will handle boundary checking automatically, reallocating when necessary.</p>
",4
31251146,31250740,0,"<p>get() leaves the delimiter in the queue thus letting you able to consider it as part of the next input. getline() discards it, so the next input will be just after it.</p>

<p>If you are talking about the newline character from a console input,it makes perfectly sense to discard it, but if we consider an input from a file, you can use as ""delimiter"" the beginning of the next field. </p>
",0
28437159,28436980,0,"<p>If you go the <code>BitmapBase</code> route, you need to make <code>BitmapBase::Pixel</code> <code>virtual</code>. Also, if the issue is just about inconvenience of <code>std::vector&lt;Bitmap&lt;T&gt;*&gt;</code>, you could use <a href=""http://en.cppreference.com/w/cpp/language/type_alias"" rel=""nofollow"">template aliases</a>. For example:</p>

<pre><code>using &lt;template T&gt; BitmapPtrVec = std::vector&lt;Bitmap&lt;T&gt;*&gt;
</code></pre>
",1
33555198,33555087,14,"<p>Basically if our object is allowed to be one of different types, we can <code>dynamic_cast</code> to a pointer so we can check if the cast succeeded:</p>

<pre><code>void do_if_derived(Base&amp; b) {
    Derived* d = dynamic_cast&lt;Derived*&gt;(&amp;b);
    if (d) {
        // do something
    }
    else {
        // not a Derived, this is OK
    }
}
</code></pre>

<p>but if our object has to be a single specific type, we can <code>dynamic_cast</code> to a reference and let the cast throw if it happens to be wrong:</p>

<pre><code>void this_better_be_a_derived(Base&amp; b)
{
    Derived&amp; d = dynamic_cast&lt;Derived&amp;&gt;(b);
    // do stuff with d
    // will throw if, e.g. b is a DifferentDerived&amp; instead
}
</code></pre>

<p>It's a matter of wanting to handle the failure case via a branch or via an exception.</p>
",0
33555204,33555087,5,"<p>""Unacceptable"" just means ""cannot be accepted"" here. Specifically, by your own code.</p>

<p>You can use <code>dynamic_cast&lt;T*&gt;(e)</code> if your own code can handle the case where <code>*e</code> is not of type <code>T</code>, by checking the result of the conversion and doing something else if the conversion failed.</p>

<p>You can use <code>dynamic_cast&lt;T&amp;&gt;(e)</code> if the execution of your own code cannot meaningfully continue if <code>e</code> is not of type <code>T</code>.</p>
",0
29449783,29449647,5,"<p>As always, see for yourself and look at the generated code. With g++ 4.8 on Ubuntu 14.04, you get </p>

<pre><code>    movq    -16(%rbp), %rax
    movq    %rax, -32(%rbp)
    jmp .L2
.L3:
    addq    $8, -32(%rbp)
.L2:
    movq    -32(%rbp), %rax
    cmpq    -8(%rbp), %rax
    jb  .L3
</code></pre>

<hr>

<pre><code>    movq    -16(%rbp), %rax
    movq    %rax, -24(%rbp)
    jmp .L4
.L5:
    addq    $8, -24(%rbp)
.L4:
    movq    -24(%rbp), %rax
    cmpq    -8(%rbp), %rax
    jne .L5
</code></pre>

<p>As you can see, the only relevant difference is <code>jb .L3</code> vs <code>jne .L5</code>.</p>

<p>So, I would say both are equivalent from a performance point of view.</p>

<hr>

<p>Answering the second question, the minimum necessary for comparison is <code>operator&lt;</code>. You can deduce everything else from this, e.g. </p>

<pre><code>bool operator==(const T &amp;x, const T &amp;y) {
    return !(x &lt; y) &amp;&amp; !(y &lt; x);
}

bool operator!=(const T &amp;x, const T &amp;y) {
    return !(x == y);
}

bool operator&gt;(const T &amp;x, const T &amp;y) {
    return y &lt; x;
}

bool operator&lt;=(const T &amp;x, const T &amp;y) {
    return !(y &lt; x);
}

bool operator&gt;=(const T &amp;x, const T &amp;y) {
    return !(x &lt; y);
}
</code></pre>

<p>Of course, this is only true if you have the usual comparison semantics.</p>
",0
29449805,29449647,1,"<p>As far as I know, it really doesn't make a difference. I believe that</p>

<pre><code>p != mfirst_free
</code></pre>

<p>would be translated to something in assembly similar to</p>

<pre><code>   loop        
               CMP   p mfirst_free
               BEQ   exit
              {...body...}
               B     loop
   exit
</code></pre>

<p>while the </p>

<pre><code>p &lt; mfirst_free
</code></pre>

<p>would translate to the same, but instead of a BEQ instruction it would be a BGE. Same number of instructions take would take the same amount of time to be executed.</p>

<p>-There are various ways to translate a for loop to assembly, but my point here is that every comparison operator that you use would lead to the same running time, as far as I know.-</p>
",2
29449806,29449647,2,"<p>First of all, in pure c++ terms there is no correct answer to your question since the standard does not specify it and it's left to the compiler and CPU's discretion.</p>

<p>In real terms you're asking whether a 'branch if not equal' instruction takes any less time than a 'branch if less' instruction. In all CPUs I have ever encountered the answer will be 'no' - provided you don't get wrong-footed by incorrect branch prediction.</p>
",0
29449904,29449647,1,"<p>If the counter variable is an integer or pointer, there is probably no difference in efficiency. The effect is the same as long as the variable is just being incremented (by one) and start out smaller or equal and the end value.</p>

<p>But C++ iterators don't necessarily implement <code>operator&lt;</code>. In fact only <code>RandomAccessIterator</code> are required to do so (see <a href=""http://en.cppreference.com/w/cpp/iterator"" rel=""nofollow"">http://en.cppreference.com/w/cpp/iterator</a>). So C++11 translates <code>for(auto&amp;&amp; v : values)</code> to <code>for(auto it = std::begin(values); it != std::end(values); ++it)</code>. For example <code>std::forward_list</code> only has <code>ForwardIterators</code> and so <code>operator&lt;</code> can't be used to iterate through it.</p>

<p>If you use OpenMP for parallelization <code>operator&lt;</code> is needed:</p>

<pre><code>#pragma omp parallel for
for(auto it = std::begin(values); it &lt; std::end(values); ++it)
</code></pre>

<p>Because it needs to split the loop into smaller loops.</p>

<p>I guess in general it would be best to use <code>operator!=</code> to be compatible with all iterator types, unless you do something else than iterate (increment by more than one, etc.), use floating point values as counter, or use OpenMP.</p>
",1
22872593,22872534,3,"<p>In your code you never specify to ask for user input (read from any input streams or files), hence it doesn't ask for any input.</p>

<p>You will probably want to somewhere do something such as <code>cin</code> or <code>cin.readline</code> or any of several other various methods to read the user's input from <code>stdin</code>.</p>

<p>To avoid duplicating other questions I'm not putting further details here.</p>
",0
27559087,27559058,1,"<p>You aren't updating the <code>string guessWord</code> in your <code>int letterFill()</code> function. As soon as you see a letter that matches you return without entering that second <code>if</code> statement. </p>

<p>I assume what you want is only to return after fully updating the <code>guessWord</code>, based on that what you want to do is iterate through the string, updating <code>guessWord</code> as you find matches and after your loop do a check </p>

<p><code>if(matches == 0) return 0;
else return matches;</code></p>
",4
22873459,22872614,1,"<p>You can try this...but you might need version C++11.</p>

<p>This can get down to 0.000001 seconds.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;ratio&gt;
#include &lt;chrono&gt;

//using namespace std;

int main()
{
    using namespace std::chrono;
    high_resolution_clock::time_point t1 = high_resolution_clock::now();

    int finish = 20;
    int start = 1;

    for (int i = start; i &lt;= finish; i++)
    {
        result += i;
    }

    high_resolution_clock::time_point t2 = high_resolution_clock::now();
    duration&lt;double&gt; time_span = duration_cast&lt;duration&lt;double&gt;&gt;(t2 - t1);
    cout &lt;&lt; time_span.count() &lt;&lt; "" seconds"" &lt;&lt; endl;
    end = clock();

    system (""PAUSE"");

    return 0;
}
</code></pre>
",6
22872670,22872614,2,"<p>No matter what technique you use for timing they all have some precision. This simply executes so fast that your timer isn't registering any time as having passed. </p>

<p>Aside #1: Use <a href=""http://en.cppreference.com/w/cpp/chrono/high_resolution_clock"" rel=""nofollow"">high_resolution_clock</a> - maybe that will register something non-zero, probably not.</p>

<p>Aside #2: Don't name your variable <code>null</code>, in C++ that implies <code>0</code> or a null pointer</p>
",1
26208725,26208711,9,"<p>Like so:</p>

<pre><code>void updateAge(list&lt;Person&gt; &amp; people)
{
    for (list&lt;Person&gt;::iterator i = people.begin(); i != people.end(); ++i) {
        i-&gt;age(i-&gt;age() + 1);
    }
}
</code></pre>

<p>This assumes you would have something like the following getter and setter members on <code>Person</code>:</p>

<pre><code>int age() const;
void age(int);
</code></pre>

<p>You can access any members of the current <code>Person</code> object using the <code>i-&gt;</code> prefix within the <code>for</code> loop.  So if you have a <code>public: int age;</code> member instead, you could do this:</p>

<pre><code>++(i-&gt;age);
</code></pre>

<p>Note that the parameter to the example function I've written is a <code>list&lt;Person&gt; &amp;</code> (reference to a list) as opposed to a <code>list&lt;Person&gt;</code> (a by-value list).  If you don't make the parameter a reference then the list (and all of the <code>Person</code> objects it contains!) will be <em>copied</em> when you call the function, and the function will receive that copy, which is independent of the original list.  When the function returns, the copied list and its contents will be destroyed and any modifications made to the copied list will be lost.</p>

<p>Passing by reference (as is done in my example function) means that the <code>people</code> parameter and the <code>list1</code> variable you have in your code would refer to <em>the same list</em> so changes made to one variable can be observed through the other variable.</p>
",1
26208984,26208711,3,"<p>The simplest way is:</p>

<pre><code>for ( auto &amp;person : people )
    ++person.age;
</code></pre>

<p>Another option besides those already posted is to make a function to do the job for one person, and then use standard algorithms to apply that to the whole list.</p>

<p>Doing it this way, you can change your <code>list</code> to be a different container and then you don't have to change any of the other code. Or you can do it on just part of the list at once, and so on.</p>

<pre><code>void update_age(Person &amp;p)
{
    ++p.age;
}

// ... in another function
    std::for_each( people.begin(), people.end(), update_age );
</code></pre>
",0
26231932,26231456,1,"<p>Place <code>cin.get();</code> after <code>cin.get(cSelection);</code> to clear newline.</p>
",0
26231962,26231456,1,"<p>with <code>#include &lt;limits&gt;</code></p>

<p>after</p>

<pre><code>cin.get(cSelection);
</code></pre>

<p>you may add:</p>

<pre><code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
</code></pre>
",0
26231970,26231456,1,"<p>Your additional menu hit is from consumption of a newline char that is still in the input stream. Consume it any number of ways, one of which is shown below. I also took the liberty to fix your <code>while</code> condition, which was not correctly expressed (you were passing a <code>bool</code> to <code>toupper</code>, which was clearly not what you wanted. Likewise I changed the use of <code>sSelection[0]</code>, which is not initialized in this code to <code>cSelection</code>. As it was, you would invoke <em>undefined behavior</em>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;
#include &lt;limits&gt;
using namespace std;

void displayMenu();

int main()
{
    int cSelection;
    string sSelection;

    //Create menu
    const char OPTION_READING = 'A', OPTION_READINGTWO = 'B', OPTION_ENDING = 'C';

    do
    {
        displayMenu();
        cout &lt;&lt; ""\nPlease choose an option"" &lt;&lt; endl &lt;&lt; endl;
        if ((cSelection = cin.get()) == EOF)
            break;

        // eat newline character
        cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');

        //respond to choice
        switch (cSelection)
        {
            case OPTION_READING:
            case 'a':
                cout &lt;&lt; ""You picked 1"" &lt;&lt; endl;
                break;

            case OPTION_READINGTWO:
            case 'b':
                cout &lt;&lt; ""You picked 2"" &lt;&lt; endl;
                break;

            case OPTION_ENDING:
            case 'c':
                cout &lt;&lt; ""Thank you for using this program!\n"";
                return 0;

            default:
                cout &lt;&lt; cSelection &lt;&lt; "" "" &lt;&lt; ""is an invalid choice"";


        }
    } while (std::toupper(static_cast&lt;unsigned char&gt;(cSelection)) != OPTION_ENDING);


}

void displayMenu()
{
    cout &lt;&lt; ""\t \t \t"" ""Menu"" &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; ""A. Option 1\n"";
    cout &lt;&lt; ""B. Option 2\n"";
    cout &lt;&lt; ""C. Quit program"";
}
</code></pre>

<p><strong>How It Works</strong></p>

<p>That <code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code> may look a little cryptic, but it really isn't that bad. C++11 provides a very nice template class called <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits"" rel=""nofollow""><strong><code>std::numeric_limits</code></strong></a>. Given a numeric <em>type</em>, you can fire a static member function of the class and get the numeric limits (min, max, etc) of the type. There are tons of of specializations of that template for every native language type. I advise following the link I provided and checking out how it works and all that it offers.</p>

<p>In our case we're interested in consuming as many chars as possible until we reach a newline, which will be discarded. We use the <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/ignore"" rel=""nofollow""><strong><code>ignore()</code></strong></a> method from our input stream, <code>std::cin</code>, to accomplish the skipping. Therefore:</p>

<pre><code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
</code></pre>

<p>effectively says ""Skip as many chars as you have to looking for a newline. If you find a newline, skip it, then return. Consume as many as you have to, up to EOF if needed.""</p>

<p>It may look a little cryptic, but its not uncommon at all, and quite effective.</p>

<p>Anyway, hope it helps.</p>
",3
31278799,31278690,3,"<p>You are missing a null terminator on your character array. Try making it 5 characters and making the last character '\0'. This lets the program know that your string is done without needing to know the size.</p>

<p><a href=""https://stackoverflow.com/questions/2037209/what-is-a-null-terminated-string"">What is a null-terminated string?</a></p>
",5
31278815,31278690,0,"<p>See <a href=""http://www.cplusplus.com/reference/istream/istream/read/"" rel=""nofollow"">the documentation for istream::read</a>; it doesn't append a null terminator, and you're telling it to read exactly 4 characters.  As others have indicated, the <code>&lt;&lt;</code> operator is looking for a null terminator so it's continuing to read past the end of the array until it finds one.</p>

<p>I concur with the other suggested answer of using <code>std::string</code> instead of <code>char[]</code>.</p>
",0
31278818,31278690,1,"<p>The overload of <code>operator&lt;&lt;</code> for <code>std::ostream</code> for <code>char const*</code> <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2"" rel=""nofollow"">expects a null terminated string</a>. You are giving it an array of 4 characters.</p>

<p>Use the standard library <code>string</code> class instead:</p>

<pre><code>std::string dataLabel;
</code></pre>
",0
31278839,31278690,0,"<p>Your <code>char[]</code> array is not null-terminated, but the <code>&lt;&lt;</code> operator that accepts <code>char*</code> input requires a null terminator.</p>

<pre><code>char dataLabel[5];
wav.read(dataLabel, 4); //Read data label
dataLabel[4] = 0;
cout &lt;&lt; ""Data label:"" &lt;&lt; dataLabel &lt;&lt;  ""\n"";
</code></pre>
",0
31278868,31278690,0,"<p>Variable dataLabel is defined like</p>

<pre><code>char[4] dataLabel;
</code></pre>

<p>that it has only four characters that were filled with characters { 'd', 'a', 't', 'a' ) in statement</p>

<pre><code>wav.read(dataLabel, sizeof(dataLabel));//
</code></pre>

<p>So this character array does not have the terminating zero that is required for the <code>operator &lt;&lt;</code> when its argument is a character array. </p>

<p>Thus in this statement </p>

<pre><code>cout &lt;&lt; ""Data label:"" &lt;&lt;dataLabel &lt;&lt;  ""\n"";
</code></pre>

<p>the program has undefined behaviour.</p>

<p>Change it to</p>

<pre><code>std::cout &lt;&lt; ""Data label: "";
std::cout.write( dataLabel, sizeof( dataLabel ) )  &lt;&lt;  ""\n"";
</code></pre>
",0
22875944,22875911,2,"<pre><code>if(testNum % 10 = 0) 
</code></pre>

<p>should be</p>

<pre><code>if(testNum % 10 == 0) 
</code></pre>

<p><code>=</code> is the assignment operator, while <code>==</code> is the equality operator.</p>

<p>The error is because <code>testNum % 10</code> is an rvalue, while the (incorrect) assignment requires an lvalue as left operand.</p>
",0
22875925,22875915,1,"<p><code>argv[1][i]</code> is the <code>i</code>th character of <code>argv[1]</code>.</p>
",0
22875953,22875915,1,"<p>Remember that <code>argv</code> is a <code>char**</code>, meaning that it is an array of <code>char*</code> strings. So, <code>argv[1]</code> is a <code>char*</code>, so <code>argv[1][i]</code> is the <code>i</code>'th character in the <code>char[1]</code> string. This code is simply searching through the individual characters in the string. </p>
",1
31241461,31240833,1,"<p>As always in life, there is no simple way of comparing the two approaches and different people may have different opinions about them. If those functions were to be incorporated into production code, two things would count:</p>

<ol>
<li>How easy is it to understand, verify, and maintain the code. In that regard clearly Bob's approach wins. In Alice's code there two many ""cryptic"" numbers that are not obvious enough. At least some comments would help to understand how she arrived at that solution.</li>
<li>How fast does the code execute. That is what would count if this were a general library routine that is called millions of times. Just from looking at the code, I would guess that Alice's approach is slightly faster. But that is just an assumption, it would need to be measured on the desired platform.</li>
</ol>

<p>So the ""clear"" answer is again: <em>It depends</em>.</p>

<p>Under the assumptions that Bob's code is only slightly slower and that the function is not all that performance critical I would vote for Bob's approach -- after doing some timings.</p>
",4
31241549,31240833,-1,"<p>They are different as @tobi303 said, but I see first implementation has less computation, and the second is more understandable.</p>

<p>if they where similar, you can compare by test cases it pass as mentioned, and performance measurements (i.e, execution time).</p>

<p><strong>Edit</strong>: ""I see"" the second is understandable, because of meaningful identifiers.</p>

<pre><code>year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0)
</code></pre>

<p>I would not know what does it mean to have true result, if I do not read the function name.</p>
",7
31244093,31240833,2,"<p>if you're looking for guidelines I suggest you to read the C++ Programming Language Book of Stroustrup .</p>

<p>But briefly those are are two different approach :</p>

<p>Alice method (why it should be used):
Simple approach used for program requiring high performance
- one function (one call) 
- Declaring variable only when it is needed
- using statically allocated vector with a known size
- no exhaustive use of object copies.</p>

<p>Bob method (why it should be used):</p>

<p>It is based on the divide and conquer strategy .
-every function is responsible of a single task (useful if you want to maintain code in the future)
-a highly reusable code for other purposes.</p>
",2
31177804,31177753,0,"<pre><code>Location a = b = c = zabaZoo = this;
</code></pre>

<p>The quick brown fox jumps over the lazy dog.</p>
",0
31177816,31177753,0,"<p>You could create a <code>SpecialParent</code> constructor, and use assignment:</p>

<pre><code>Location a, b, c, zabaZoo;

SpecialParent()
{
    a = b = c = zabaZoo = Location(this);
}
</code></pre>
",4
27676763,27676692,1,"<p>I think that the main reason is unwillingness to introduce a new keyword. 
All was tried to do in the frames of C keywords.</p>
",0
27676764,27676692,0,"<p>Why declaring a pure virtual function is not ""direct"" enough?
This way has more sense than declaring the whole class abstract. Compiler should probably assume that all methods are virtual in that case. That would lead to extra overhead etc...</p>

<p>At the end, if you like that, you can always switch to C#, or similar language.</p>
",0
29183429,29182871,2,"<p><code>Word</code> objects are passed by copy to <code>check_number</code>, but you did not define the copy constructor. So default one is used by the compiler and  this one copies pointer (<code>char* content</code>). Temporary objects passed to the function are pointing to data created <code>first</code> and <code>second</code> in the main function...upon deletion (temprary objects are deleted after the function is called), they delete the pointers, so <code>first</code> and <code>second</code> objects are pointing to deleted memory. You have undetermined behaviour here, this explains side effects you experienced.</p>

<p>Passing objects by reference to <code>check_number</code> is an easy way to fix your problem. Here is a working code (including many fixes because you did not access arrays correctly):</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;

class Word
  {
    private:
       char *content;
       int length;
    public:
       Word();
       Word(char *);
       ~Word();
       void print_content(void);
       int check_character(char);
       friend int check_number(const Word&amp;,const Word&amp;); // changed here
  };


Word::Word()
  {
  }

Word::Word(char *n)
  {
    length=strlen(n);
    content=new char [length];
    for(int i=0;i&lt;length;i++)
      {
        content[i]=n[i]; // changed here
      }
  }


Word::~Word()
  {
    delete [] content; // changed here
  }


void Word::print_content(void)
  {
    for(int i=0;i&lt;length;i++)
      {
        cout&lt;&lt;""""&lt;&lt;content[i]; // changed here
      }
  }


int Word::check_character(char a)
  {
    int position=0;
    for(int i=0;i&lt;length;i++)
      {
         if(content[i]==a) // changed here
          {
            position=i+1;
          }
      }
    if(position&gt;0)
      {
        return position;
      }
    else return 0;
  }


int check_number( const Word&amp; n, const Word&amp; m)// changed here
  { 
    int counter_n=0;
    int counter_m=0;
    for(int i=1;i&lt;n.length;i++)
      {
        if((n.content[i-1]=='1')&amp;&amp;(n.content[i]=='0')) // changed here
          {
            counter_n=counter_n+1;
          }
      }
    for(int i=1;i&lt;m.length;i++)
      {
        if((m.content[i-1]=='1')&amp;&amp;(m.content[i]=='0')) // changed here
          {
            counter_m=counter_m+1;
          }
      }
    if(counter_n&gt;counter_m)
      { 
        return counter_n;
      }
    else if(counter_n&lt;counter_m)
      {
        return counter_m;
      }
    else return 0;
  }


int main()
  {
    char characters1[]=""qwerty10"",*p1,*p2;
    char characters2[]=""stackoverflow101010"";
    p1=characters1;
    p2=characters2;
    Word first(p1);
    Word second(p2);
    cout&lt;&lt;""""&lt;&lt;first.check_character('q')&lt;&lt;endl;
    cout&lt;&lt;""""&lt;&lt;second.check_character('f')&lt;&lt;endl;

    cout&lt;&lt;""""&lt;&lt;check_number(first,second)&lt;&lt;endl; 

    first.print_content();
    second.print_content();
  }
</code></pre>

<p>This outputs:</p>

<pre><code>1
10
3
qwerty10stackoverflow101010
</code></pre>

<p>Declaring a copy constructor is another way to fix the problem:</p>

<pre><code>Word( const Wodr&amp; word ) :
    length( word.length ),
    content( new char[word.length] )
{
    memcpy( content, word.content, word.length );
}
</code></pre>

<p>That would be less efficient than passing objects by const reference, but would make your code safer (it's good to always declare copy constructor to prevent bug you experienced here).</p>

<p>Finally, if you are lazy, you can also declare the copy constructor as private, to prevent compiler to copy objects, just declare it, don't impelment it:</p>

<pre><code>class Word
{
   ....
private:
    Word( const Word&amp; word ); // this makes argument passed by copy impossible.
};
</code></pre>

<p>Then, compiler will not let you call check_number.</p>
",0
27745609,27745565,0,"<p>In your do while loop you are always <code>fseek</code>ing to sizeof(your record type). This means the subsequent <code>fread</code> will always read the second record in the file.</p>

<p>Remove the call to <code>fseek</code>.</p>
",0
27761091,27760641,1,"<p>You have many ways to get user profile directory :</p>

<ul>
<li><p>via the environment variable <code>USERPROFILE</code> :</p>

<pre><code>#include &lt;cstdlib&gt;
...
string profile = getenv(""USERPROFILE"");
</code></pre></li>
<li><p>via Windows API, but it is bit harder :</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;userenv.h&gt;
...
HANDLE processToken = ::GetCurrentProcess();
HANDLE user;
BOOL cr = ::OpenProcessToken(processToken, TOKEN_ALL_ACCESS, &amp;user);
DWORD size = 2;
char * buff = new char[size];
cr = ::GetUserProfileDirectoryA(user, buff, &amp;size); // find necessary size
delete[] buff;
buff = new char[size];
cr = ::GetUserProfileDirectoryA(user, buff, &amp;size);
string profile = buff;
delete[] buff;
</code></pre>

<p>and you have to link with <code>userenv.lib</code> - the tests for return codes are left as an exercise :-)</p></li>
<li><p>via <code>ExpandEnvironmentString</code> :</p>

<pre><code>size = ::ExpandEnvironmentStringsA(""%USERPROFILE%\\Desktop\\myfile.anything"",
    NULL, 2);
buff = new char[size];
size = ::ExpandEnvironmentStringsA(""%USERPROFILE%\\Desktop\\myfile.anything"",
    buff, size);
string profile = buff;
delete[] buff;
</code></pre></li>
</ul>

<p>With third way you have directly your string, with first and second you only get profile directory and still have to concatenate it with relevant path.</p>

<p>But in fact, if you want you program to be language independant, you should really use <code>SHGetSpecialFolderPath</code> API function : </p>

<pre><code>    #include &lt;shlobj.h&gt;
    ...
    buff = new char[255];
    SHGetSpecialFolderPathA(HWND_DESKTOP, buff, CSIDL_DESKTOPDIRECTORY, FALSE);
    string desktop = buff;
    delete[] buff;
</code></pre>

<p>Because on my old XP box in french, <code>Desktop</code> is actually <code>Bureau</code> ...</p>
",1
31269456,31267268,1,"<blockquote>
  <p>I am trying to at least fix insertLast func</p>
</blockquote>

<p>Your inserLast() looks fine. Try the following code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Node {
public:
int data;
Node *prev, *next;
Node(int x,Node *p,Node *q) {
    data = x; prev = p; next = q;
}
};

class List {
public:
Node *head;
int size;
public:
List() {
    head = new Node(0,NULL,NULL);
    head-&gt;prev = head;
    head-&gt;next = head;
    size = 0;

}
int Size(){
    return size;
}
void insertFirst(int x)
{
    insertBefore(first(), x);

}
void insertLast(int x)
{
    insertAfter(last(), x);

}

void insertAfter(Node *p, int x) {
    Node *q = new Node(x,p,p-&gt;next);
    p-&gt;next-&gt;prev = q;
    p-&gt;next = q;
    size += 1;
}
void insertBefore(Node *p, int x) {
    Node *q = new Node(x,p-&gt;prev,p);
    p-&gt;prev-&gt;next = q;
    p-&gt;prev = q;
    size += 1;
}
void insertAtRank(int rank, int x)
{
    insertBefore(toPosition(rank), x);
}
void remove(Node *p) {
    p-&gt;prev-&gt;next = p-&gt;next;
    p-&gt;next-&gt;prev = p-&gt;prev;
    p-&gt;prev = p-&gt;next = NULL;
    size -= 1;
}
void removeAtRank(int rank)
{
    remove(toPosition(rank));
}
int element(Node *p)
{
    return p-&gt;data;
}
int elementAtRank(int rank)
{
    return toPosition(rank)-&gt;data;
}
int toRank(Node *p) {
    int r = 0;
    for (Node *q = first(); q != p; q = q-&gt;next) r += 1;
    return r;
}
Node *toPosition(int rank) {
    if (rank &gt; size){
        throw ""exception"";
    }
    Node *q = first();
    for (int r = 0; r != rank; r += 1){
        q = q-&gt;next;

    }
    return q;
}


Node *first() { return head-&gt;next; }
Node *last() { return head-&gt;prev; }
Node *after(Node *p) { return p-&gt;next; }
Node *before(Node *p) { return p-&gt;prev; }
bool isEmpty() { return head-&gt;next == head; }

Node *removeLast(){
    if (last() == NULL){
        throw ""exception"";
    }
    Node *p = last();
    p-&gt;prev-&gt;next = p-&gt;next;
    p-&gt;next-&gt;prev = p-&gt;prev;
    p-&gt;prev = p-&gt;next = NULL;
    return p;
}

};


void main(){
int x;
List l;
int a[]{163, 179, 103, 91, 404,
    531, 745, 405, 686,
    858, 898, 926, 266, 867, 865,
    91, 103, 163, 179, 2,
    66, 404, 405, 531, 686, 745,
    858, 865, 867, 898, 926};
int size = sizeof(a) / sizeof(a[0]);
for (int i = 0; i &lt; size; i++){
    l.insertLast(i);
}

for (int j = 0; j &lt; l.Size(); j++){
    cout &lt;&lt; l.elementAtRank(j) &lt;&lt; endl;
}
cout &lt;&lt; l.Size();
cin &gt;&gt; x;
}
</code></pre>

<p><strong>Changes I made</strong>:</p>

<ul>
<li>Removed the <em>vague</em> class Position : public Node</li>
<li>int Size() { return size; }</li>
<li>Node* toPosition (int rank) {...} - moved the return statement in the end</li>
</ul>

<p><strong>N.B.</strong>: I did not check other parts of your code. I just made your code compile correctly and work as expected, because ""you were trying to at least fix insertLast func""</p>
",3
28180201,28180170,3,"<p>In <code>int dArray[size]</code> size is not a constant value.  Because of that you are getting that error.  What you probably wanted to do was make a new array using a pointer and new like:</p>

<pre><code>int * dArray = new int[size];
</code></pre>
",2
28180211,28180170,2,"<p>C++ requires that the size of arrays are determined at compile-time. As <code>size</code> is determined at runtime, the compiler complains.</p>

<p>If you are interested in having array-like behaviour with a size unknown at compile-time, then consider using <code>std::vector</code>.</p>
",0
28180215,28180170,0,"<p>You have to declare the size of an array using numbers, #define or <code>const unsigned int</code>.  Otherwise they are considered variable length arrays.  </p>

<p>Example:  </p>

<pre><code>const unsigned int MAX_ARRAY_SIZE = 14;
double my_array[MAX_ARRAY_SIZE];
</code></pre>
",0
28180223,28180170,1,"<p>The size of array should be a known constant in compile time, so that compiler can allocate correct memory for that array on the stack. Remember that such a declare is for stack variable. If you do want dynamic array, try std::vector.</p>
",0
30150964,30038828,0,"<p>The answer is the following:</p>

<pre><code> Function index is found in string.h.
 Change line 1187 to: const char *r=index(line,':');
</code></pre>
",0
26143176,26142839,1,"<p>Never mind some of the inefficiencies of your algorithm, the most likely cause for your function seemingly fail to return is a bad parsing of <code>x</code> and thus <code>n</code> not getting set at all, which means it could hold any random value.</p>

<p>Your line:</p>

<pre><code>cin &gt;&gt; x &gt;&gt; n;
</code></pre>

<p>If it fails to parse into <code>x</code> properly then it will not attempt to parse the next number because the input stream will be in an error state.</p>

<p>If <code>n</code> has not been initialised it could hold any value which might in reality be an extremely big integer. Thus your algorithm appears not to ever return.</p>

<pre><code>int main()
{
   double x = 0.0;
   int n = 0;
   double error = 0;
   cout &lt;&lt; ""please enter x and n: "";
   cin &gt;&gt; x &gt;&gt; n;
   if( cin )
   {
         cout &lt;&lt; ""taylor series sum, x="" &lt;&lt; x &lt;&lt; "" n="" &lt;&lt; n &lt;&lt; "" : "";
        cout &lt;&lt;  taylorSeries (x, n, error) &lt;&lt; endl;
        cout &lt;&lt; ""error = "" &lt;&lt; error;
   }
   else
   {
       cerr &lt;&lt; ""invalid input"" &lt;&lt; endl;
   } 
}
</code></pre>

<p>For a more efficient algorithm:</p>

<pre><code>double taylorSeries (double x, int n, double &amp;error)
{
    double sum = 1;
    double xpow = x; // would start at 1 but we have implemented exponent of 0
    double fact = 1;

    for (int i=1; i &lt;= n; i++)
    {
       fact *= i;
       sum += xpow / fact;
       xpow *= x;
    }

    error = fabs(exp(x) - sum);   
    return sum;
 }
</code></pre>

<p>Your <code>factorial</code> function is technically correct until the point where it will overflow. </p>
",3
26146449,26146408,1,"<p>you allocate a array of size 0 ...</p>

<p>you will find answer of what will happen can be found here:
<a href=""https://stackoverflow.com/questions/1087042/c-new-int0-will-it-allocate-memory"">C++ new int[0] -- will it allocate memory?</a></p>
",0
26146505,26146408,4,"<p>The problem is that you define here an empty array of strings and arrays are not dynamic: </p>

<pre><code>int lineN=0;
string line[lineN];
</code></pre>

<p>When you change <code>lineN</code> to 1, nothing changes in the array, and you'll get out of bound !  </p>

<p>The bettter way would be to use <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow"">vectors</a>:  </p>

<pre><code>vector&lt;string&gt; line;  
</code></pre>

<p>Read in a temporary string:  </p>

<pre><code>string current_line;  
getline(input, current_line);
</code></pre>

<p>and add it to your vector:  </p>

<pre><code>line.push_back(current_line); 
</code></pre>

<p>Putting all this in a nice loop would be more useful:  </p>

<pre><code> string current_line; 
 while (getline(input, current_line)) {
        line.push_back(current_line); 
 }
</code></pre>

<p>You may access any line later, by using <code>line[i]</code> exactly with your array, as long as <code>i&lt; line.size()</code>.  Or you may iterate easily throug all its content: </p>

<pre><code> for (string x : line)  {    // means for every x in line[]
     cout&lt;&lt; x&lt;&lt;endl; 
 }  
</code></pre>
",0
26224310,26224284,5,"<blockquote>
  <p>So it would be called with as arguments a ""copy"" of the arguments
  given to addElement().</p>
</blockquote>

<p>Why copies when you can use the original arguments?</p>

<p>With C++11 you can use variadic templates and perfect forwarding:</p>

<pre><code>template &lt;typename... Args&gt;
void CustomList::addElement(Args&amp;&amp;... args)
{
    T *element = new T(std::forward&lt;Args&gt;(args)...);
    // ...
}
</code></pre>

<p>Without proper C++11 support you will have to overload the <code>addElement</code> function (template) for every amount of arguments until a sensible limit is reached. I.e.</p>

<pre><code>template &lt;typename Arg1&gt;
void CustomList::addElement(Arg1 const&amp; arg1)
{
    T *element = new T(arg1);
    // ...
}

template &lt;typename Arg1, typename Arg2&gt;
void CustomList::addElement(Arg1 const&amp; arg1, Arg2 const&amp; arg2)
{
    T *element = new T(arg1, arg2);
    // ...
}

// [...]
</code></pre>
",3
26449820,26449776,1,"<p>You can't <em>hide</em> complexity in a function with something like:</p>

<pre><code>for x = 1 to N
    doSomethingXTimes(x)
</code></pre>

<p>The fact that <code>doSomethingXTimes()</code> is dependent on <code>N</code> means that the whole thing is <code>O(n<sup>2</sup>)</code>, becaue you're executing <code>N * N</code> (or some value proportional to that) steps.</p>
",1
26449853,26449776,0,"<p>No this will not optimize your code as far as algorithmic complexity is concerned.</p>

<p>Also, by using a function within the outer for loop, you will only increase the number of function calls made in your code and make it even slower. (You could make the function inline though) </p>
",0
29158987,29158855,1,"<p>The problem with the <code>do ... while</code> loop is that you just extract the last digit of the changed <code>x</code> only to replace it with the second last digit and so on, until you get the first digit of <code>x</code> stored in <code>s</code>.</p>

<p>There is no effect of <code>reverse(s.begin(), s.end())</code> since <code>s</code> practically holds only one character.</p>

<p>Also, we add <code>'0'</code> to <code>s</code> because <code>s</code> initially stores the integer value of the number, and adding <code>'0'</code> converts it into its ASCII form.</p>

<p>Example:</p>

<pre><code>void IntToString(int x)
{
    bool isNegative = false;
    if(x &lt; 0)
    {
        x = -x;
        isNegative = true;
    }
    string s;
    do
    {
        //The below code appends the new number at the beginning of s.
        s = ('0' + x%10) + s;    //modulus for getting the last number
        x = x/10;   //shorten the number
    }while(x); 
    if(isNegative)
        main_string = '-' + main_string;
    cout &lt;&lt; main_string &lt;&lt; endl;
}
</code></pre>
",1
29158883,29158855,3,"<pre><code>s = '0' + x%10;
</code></pre>

<p>will grabs the last digit from <code>x%10</code> and add ASCII of <code>0</code> i.e. 48, giving the ASCII of desired last digit, which get copy assigned to string <code>s</code> using its assignment operator.</p>

<p>And btw, you need :</p>

<pre><code>s += '0' + x%10;
  ~~ // += operator 
</code></pre>
",1
26166872,26166704,2,"<p>The <code>&gt;&gt;</code> operator for a string extracts words, and stops at the
first white space it sees.  If it doesn't skip initial white
space, then it stops immediately, and returns an empty string.</p>

<p>You don't say how you want the string to be delimited.  To read
until the end of line, just use <code>std::getline</code>.  To read until
the end of file, you can use something like:</p>

<pre><code>std::istringstream collector;
collector &lt;&lt; iss.rdbuf();
std::string results = collector.str();
</code></pre>

<p>It's not the most efficient, but if the file is small, it will
do. </p>
",0
29955114,29955088,1,"<p>This:</p>

<pre><code>Object obj1();
</code></pre>

<p>is a function declaration. It is a function named <code>obj1</code> that takes zero arguments and returns an <code>Object</code>. This is known as the ""most vexing parse."" What you meant was:</p>

<pre><code>Object obj1;
</code></pre>

<p>You can tell this from the error message, indicating that your right-hand-side is of type ""pointer to function that takes zero arguments and returns an <code>Object</code> rather than the ""pointer to <code>Object</code>"" that you were expecting:</p>

<blockquote>
  <p>Error: a value of type ""<code>Object (*)()</code>"" cannot be used to initialize an entity of type ""<code>Object *</code>""</p>
</blockquote>
",1
31176608,31175595,0,"<p>binding wise it seems to be true . But above code have memory leaks </p>

<pre><code>Rectangle* r = new Rectangle;
r-&gt;draw(); // (1)

r = new Square;
r-&gt;draw(); // (2)
</code></pre>

<p>Here in you are allocating memory to r pointer twice , but i can only free memory once, hance memory leak..</p>
",0
34242682,34242542,0,"<p>As you haven't explicitly set the value of firstname there could be any kind of garbage stored in the 20 bytes that make up firstname. char buffers are 0 terminated, so best practice would be to give an initial value to firstname in a default constructor:</p>

<pre><code>Worker(){
  //omitting other code
  firstname[0] = '\0';
}
</code></pre>

<p>Of course, if you want the variable to hold an actual value it would be best to pass it into the constructor.</p>
",0
34243352,34242542,1,"<p><code>getWorker</code> doesn't need an argument. Use a local object to get the input, and return it:</p>

<pre><code>Worker getWorker() {
    Worker worker;
    // whatever
    return worker;
}
</code></pre>

<p>Also, use <strong>initialization</strong> instead of creating objects then assigning to them. Like this:</p>

<pre><code>Worker worker1 = getWorker();
</code></pre>
",0
25505615,25505522,2,"<p>You are referencing an index in a vector that does not exist. The line:</p>

<pre><code>cin&gt;&gt;k[i];
</code></pre>

<p>Is inserting into a vector with index i, but this index does not exist. The [] operator does not perform bounds checking.</p>

<p>Try changing the code to:</p>

<pre><code>ui tmp;
cin &gt;&gt; tmp;
k.push_back(tmp);
</code></pre>

<p>As you see here: <a href=""http://en.cppreference.com/w/cpp/container/vector/operator_at"" rel=""nofollow"">http://en.cppreference.com/w/cpp/container/vector/operator_at</a> bounds checking is not performed.</p>
",0
25505621,25505522,1,"<p>Your problem is here:</p>

<pre><code>vector&lt;ui&gt; k;
   cin&gt;&gt;t;
   for(ui i=0;i&lt;t;i++){
      cin&gt;&gt;k[i];
</code></pre>

<p>You never allocate any space in <code>k</code>.  For safety you can use <code>k.at(i)</code> which will throw an exception if the space doesn't exist.  Before the loop you can do <code>k.resize(t)</code>.</p>
",0
25505627,25505522,2,"<p>I can only see one glaring fault and that's at the line</p>

<pre><code>cin &gt;&gt; k[i];
</code></pre>

<p>In this line, you seem to access an array element, however the array element doesn't exist yet. To add to a vector, please use the <code>push_back</code>-method like this:</p>

<pre><code>ui in;
cin &gt;&gt; in;
k.push_back(in);
</code></pre>

<p>From that point on, you can access k[i], since the array element now exists.</p>

<p>Alternatively, just don't use a vector at all.</p>

<pre><code>for(ui i=0;i&lt;t;i++){
    ui in;
    cin &gt;&gt; in;
    out = palin(in);
    cout&lt;&lt;out&lt;&lt;endl;
}
</code></pre>

<p>See? No vector required.</p>
",0
25498702,25481449,1,"<p>Here is a simple example:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;time.h&gt;
#include &lt;iostream&gt;

int main(int argc, char* argv [])
{
    // first argument is program name, second is timefile
    if (argc == 2)
    {
        // extract time from file (if it exists)
        time_t last_raw;
        std::ifstream ifs;
        ifs.open(argv[1],std::ifstream::in);
        if (ifs.good())
            ifs &gt;&gt; last_raw;
        else
            time(&amp;last_raw); // it does not exist, so create it
        ifs.close();

        // get current time
        time_t now_raw;
        time(&amp;now_raw);

        // compare new to old
        struct tm * now = localtime(&amp;now_raw);
        struct tm * last = localtime(&amp;last_raw);
        if (now-&gt;tm_mday != last-&gt;tm_day || now-&gt;tm_mon != last-&gt;tm_mon || now-&gt;tm_year != last-&gt;tm_year)
        {
            // print whatever here 
        }

        // save new time out to file
        std::ofstream ofs;
        ofs.open (argv[1], std::ofstream::out | std::ofstream::trunc);  // truncate to overwrite old time
        ofs &lt;&lt; now_raw;
        ofs.close();
    }

    return 0;
}
</code></pre>
",2
32953188,32953165,2,"<p>You can't make free-standing functions private. But you can define them as static in your cpp file and do not provide their prototypes in .h file, so that outside callers would not be able to call them.</p>

<p>Edit. To all static haters here, here is something to consider. If you want to declare your functions before defining them (which might be because it is a good practice, or a neccesity since one is calling the another) you will have to open anonymous namespace, declare 'hidden' function, close the namespace, define your visible functions, open anonymous space again, define hidden functions.</p>

<p>Now, while with the compilers I looked for, two anonymous namespace have the same name and this works, this is not guranteed. </p>

<p>Another thing with anonymous namespaces - try putting a breakpoint into thier functions. </p>
",24
32953214,32953165,2,"<p>If the functions have to be templates or inline, the typical solution is to put them in a namespace called <code>detail</code>, and assume people won't access them.</p>

<p>Otherwise, just don't declare them in the header file.</p>
",0
32953229,32953165,15,"<p>Don't declare them in the header, put them in an anonymous namespace in the implementation file.</p>

<p>Example header:</p>

<pre><code>namespace NQueens
{
    int CalcHeuristic(char** state, int size);
}
</code></pre>

<p>Example implementation:</p>

<pre><code>namespace
{
    static int heur = 0;
    void CalcHorzH(char ** state, int &amp;heuristic, int size);
    void CalcColH(char ** state, int &amp;heuristic, int size);
    void CalcDiagH(char ** state, int &amp;heuristic, int size);
    int calcCollisions(int queensPerRow, int size);
}

namespace NQueens
{
    int CalcHeuristic(char** state, int size)
    {
        // ...
    }
}

namespace
{
    void CalcHorzH(char ** state, int &amp;heuristic, int size) {}
    void CalcColH(char ** state, int &amp;heuristic, int size) {}
    void CalcDiagH(char ** state, int &amp;heuristic, int size) {}
    int calcCollisions(int queensPerRow, int size) { return 0; }
}
</code></pre>
",13
32953320,32953165,5,"<p>No you can't make free standing functions <code>private</code>.<br>
What you can do though is not to declare them in the namespace and use an anonymous namespace in your translation unit:</p>

<p>In header:</p>

<pre><code>namespace NQueens {
    static int heur = 0;
    int CalcHeuristic(char** state, int size);
}
</code></pre>

<p>in <code>.cpp</code>:</p>

<pre><code>namespace {
    void CalcHorzH(char ** state, int &amp;heuristic, int size) {
       // Implementation
    }
    void CalcColH(char ** state, int &amp;heuristic, int size) {
        // Implementation
    }
    void CalcDiagH(char ** state, int &amp;heuristic, int size) {
        // Implementation
    }
    int calcCollisions(int queensPerRow, int size) {
        // Implementation
    }
}
</code></pre>

<hr>

<p>Another option is to use a class instead of a namespace, containing all those functions as <code>static</code> function members. You can use all of the usual scope semantics as <code>private</code>, <code>protected</code> and <code>public</code> then.</p>

<p>But IIRC such classes (solely containing <code>static</code> function members), aren't considered good practice in preference of placing the functions free standing into namespaces.</p>

<p>Though if you want to realize kind of <code>protected</code> inheritance, that method could be considered useful.</p>
",4
32953366,32953165,4,"<p>Use private static methods (pseudocode):</p>

<pre><code>class NQueens
{
public:
  static void CalcHeuristic()
  {
    CalcColH();  // Legal here
  }

private:
  static void CalcColH(){}
}

//...
NQueens::CalcHeuristic(); // Legal
NQueens::CalcColH(); // error
</code></pre>

<p>Private - is OOP and it's logical visibility. <code>static</code> or anonymous namespaces - is a link-time visibility.</p>
",1
26207549,26207204,1,"<p>The point of hashing the result of <code>time</code> is to avoid a predictable seed value. It would be used in a situation where you might be alright with an insecure pseudo-random number generator like <code>rand</code>, but still not want clients to be able to predictably determine your pseudo-random sequence.</p>

<p>There's lot's of ways that you can accomplish hashing the <code>time_t</code>. One very simple naive approach is to simply xor the running process pid. This is a classic approach that Unix systems have used for a long time; although, it doesn't really add that much more in the form of security. You could also include other forms of real entropy from the system. Other alternatives would involve a proper hash function or some combination of other data points and hashes. Examples of hashing functions include Bernstein's hash, the <a href=""http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function"" rel=""nofollow"">Fowler¨CNoll¨CVo hash</a> or other cryptographically secure hashes like MD5 or SHA1. However, if you're going to use a cryptographically secure hashing function, you should probably be using a cryptographically secure random number generator as well.</p>

<p>For what it is worth, since this is tagged with C++, you can use the built-in <code>std::hash</code> function provided in the standard library as long as you are using a C++ compiler that supports TR1 or later. In GCC, the <code>std::hash</code> function is implemented using the FNV hash mentioned above.</p>
",2
26207609,26207204,0,"<p>The <a href=""http://eternallyconfuzzled.com/arts/jsw_art_rand.aspx"" rel=""nofollow noreferrer"">article in the link you reference</a> argues that there is no guarantee that you can cast a <code>time_t</code> to an <code>unsigned int</code>, <code>time_t</code> is implementation dependent, and therefore casting to <code>unsigned int</code> is not strictly portable, yet you need an unsigned int to seed srand.  The articles says:</p>

<blockquote>
  <p>The issue is that time_t is a restricted type, and may not be meaningfully converted to unsigned int.</p>
</blockquote>

<p>The solution proposed is to perform a <a href=""http://en.wikipedia.org/wiki/Hash_function"" rel=""nofollow noreferrer"">hash function</a> on the bytes that make up the <code>time_t</code> value, that way you don't have a portability problem.  Hash functions map an input sequence of bits into a value, usually in a specific range, in this case you want to map all bytes that make up <code>time_t</code> (sizeof time_t) into an unsigned int.  Good hash functions will have an <a href=""http://en.wikipedia.org/wiki/Avalanche_effect"" rel=""nofollow noreferrer"">avalanche effect</a>, which means a small change in the input (time changes by one second) will have a significant effect in the output (half of the output bits flip).</p>

<p>As to what the code does, it implements a hash function that iterates through each byte of time_t and adds it to the product of the current seed (modulus the size of unsigned) times a constant <code>UCHAR_MAX + 2U</code>.  This hash function is a <a href=""http://en.wikipedia.org/wiki/Linear_congruential_generator"" rel=""nofollow noreferrer"">linear congruential generator</a>.  Notice that <code>p</code> is a pointer to an unsigned character that is used as the base of an array of characters that aliases the storage for <code>time_t</code>.  Normally you shouldn't do this in C++ because of the <a href=""https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule"">strict aliasing rule</a>, but there is an exception to the rule that allows you to alias another type as an array of characters (signed or unsigned).</p>
",3
26207449,26207204,0,"<p>Hashing time_t means to get a nearly unique number, a ""finger-print"", by applying a mathematical calculation ( hash function ) to the values in a structure carrying the current system time.</p>

<p>This way, every time you run your program, you will get a different value as a seed for srand.</p>

<p>Since the seed will be different, your sequence of random numbers from rand will also be different.</p>
",2
26213179,26212046,1,"<p>The other answers explain correctly that this code results in undefined behaviour. You may be interested as to why the behaviour is as you see it on your compiler.</p>

<p>As far as most compilers are concerned the expression <code>x = n++</code> will be compiled into the following fundamental instructions:</p>

<ol>
<li>take a copy of n, call it n_copy;</li>
<li>add 1 to n</li>
<li>assign n_copy to x</li>
</ol>

<p>Therefore the expression <code>n = n++</code> becomes:</p>

<ol>
<li>take a copy of n, call it n_copy;</li>
<li>add 1 to n</li>
<li>assign n_copy to n </li>
</ol>

<p>Which is logically equivalent to:</p>

<ol>
<li>assign n to n</li>
</ol>

<p>Which is logically equivalent to:</p>

<ol>
<li>do nothing.</li>
</ol>

<p>That's why in your case you see n == 1. Not all compilers will necessarily produce the same answer.</p>
",0
26212097,26212046,10,"<p>Your second example is not allowed and has an undefined behaviour.
You should use a temporary variable if you need something like that. But hardly you <em>need</em> something like that.</p>

<p>Quoting <a href=""http://en.wikipedia.org/wiki/Increment_and_decrement_operators"">Wikipedia</a>:</p>

<blockquote>
  <p>Since the increment/decrement operator modifies its operand, use of
  such an operand more than once within the same expression can produce
  undefined results. For example, in expressions such as x ? ++x, it is
  not clear in what sequence the subtraction and increment operators
  should be performed. Situations like this are made even worse when
  optimizations are applied by the compiler, which could result in the
  order of execution of the operations to be different from what the
  programmer intended.</p>
</blockquote>
",1
26213432,26212046,3,"<p>Other examples from C++11 standard include:</p>

<pre><code>i = v[i++]; // the behavior is undefined
i = 7, i++, i++; // i becomes 9
i = i++ + 1; // the behavior is undefined
i = i + 1; // the value of i is incremented
f(i = -1, i = -1); // the behavior is undefined
</code></pre>
",0
25513902,25513776,0,"<p>You'll need threads to do this, or timers that use them implicitly in combination with a callback.</p>
",0
25513923,25513776,1,"<p>There are two approaches to this. You could either use an existing library like <strong>ncurses</strong>:</p>

<pre><code>#include &lt;curses.h&gt;

int main(void) {
  initscr();
  timeout(-1);
  int c = getch();
  endwin();
  printf (""%d %c\n"", c, c);
  return 0;
}
</code></pre>

<p>If you don't want to use an external library, you could write a multithreaded application. In one thread, you have your countdown function running, with an additional check, something like:</p>

<pre><code>for(int i=9; i&gt;=0; )
{
    pthread_mutex_lock(&amp;someMutex);
    if (someBool == true) {
      // do someting else
    } else {
      cout &lt;&lt; i;
      cout &lt;&lt; string(1,'\b');
      Sleep(1000);
      i--;
    }
    pthread_mutex_unlock(&amp;someMutex);
}
</code></pre>

<p>Then, in the other thread, you wait on user input using <code>getchar</code> or some other mechanism.</p>
",0
25528811,25513776,0,"<h1>Pausing timer</h1>

<p>If you're not interested in portability, you can <code>#include&lt;conio.h&gt;</code> (available on Windows) and use <code>kbhit()</code> to check if there is something to read in keyboard buffer, and use <code>getch()</code> to check which key was pressed, example implementation:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;conio.h&gt;     
#include&lt;windows.h&gt;
using std::cout;

int main (){
    for(int i=9; i&gt;=0; i--){
        if(kbhit()){
            auto got=getch();
            if(got=='p'||got=='P'){
                cout&lt;&lt;""PAUSED, R to resume.\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"";
                do auto got=getch(); while(got!='r'&amp;&amp;got!='R');
            }
        }
        cout &lt;&lt; i &lt;&lt; '\b';
        Sleep(1000);
    }
    do; while(getch()!='\n'); /*don't use system(""anything"") when unnecessary,
                               *it calls external program to do work for your.
                               */
}
</code></pre>

<h1>Using <code>std::cin</code> while timer is running</h1>

<p><code>std::cin</code> locks thread execution. If you want to use it  while timer is running, I redirect you to @Dogbert's answer.</p>
",0
25506443,25506314,0,"<p>You're closing off your method with the ;
It's easier to program if you let indentation help you </p>

<pre><code>traffic_light&amp; operator++(traffic_light &amp;colour)//;&lt;-- THIS was the real culprit
{ //&lt;-- and now the switch is a part of the operator function body
    switch (colour) {
        case traffic_light::green: {
            cout &lt;&lt; ""green\n"";
            return colour = traffic_light::yellow;
        }
        case traffic_light::yellow: {
            cout &lt;&lt; ""yellow\n"";
            return colour = traffic_light::red;
        }
        case traffic_light::red: {
            cout &lt;&lt; ""red\n"";
            return colour = traffic_light::green;
        }
    }
    // also, what do you intend with the following?
    /*traffic_light next = ++light;
    cout &lt;&lt; "" &lt;&lt; next &lt;&lt; \n"";*/
    // if we got here there's an error, maybe a new light type?
    // return red to be safe
    return colour = traffic_light::red;
}
</code></pre>
",1
25696492,25696469,1,"<p>It looks like you're trying to build a class or struct. This <code>public</code> statement would work inside either of those, but not alone.</p>

<p>Try reading <a href=""http://www.cplusplus.com/doc/tutorial/classes/"" rel=""nofollow"">this class introduction</a> and see if that makes it clearer.</p>

<p>If you don't want a class, because you're not trying to build a group of similar objects, then you can place these variables inside your <code>main()</code> - in that case, you might want to read about <a href=""http://www.tutorialspoint.com/cplusplus/cpp_variable_scope.htm"" rel=""nofollow"">variable scope</a>.</p>
",0
25696494,25696469,2,"<p>I don't know why you wrote this ridiculous code, but I assume you may want this:</p>

<pre><code>class Player
{
public:
    static int playerHP;
    static int playerPWR;
};

int Player::playerHP = 100;
int Player::playerPWR = 4;
</code></pre>
",1
25497441,25497414,8,"<p>Write an overload as shown below:</p>

<pre><code>auto get(float d, int e, char f) -&gt; std::function&lt;void(int, char, int)&gt;
{
   return [=](int a, char b, int c) { get(a,b,c, d,e,f); };
}
</code></pre>

<p>That is, this overload takes <code>d</code>, <code>e</code>, <code>f</code> <em>only</em> and returns a callable entity which takes <em>rest</em> of the arguments &mdash; this callable entity eventually invokes your <code>get()</code> function. </p>

<p>You can use it as:</p>

<pre><code>auto partial_get = get(d,e,f); //pass d, e, f
//code
partial_get(a,b,c); //invoke partial_get() passing rest of the arguments!
</code></pre>

<p>Here <code>partial_get</code> is a callable enity which you can invoke anytime passing the rest of the arguments &mdash; <code>partial_get</code> eventually invokes your <code>get()</code> function passing all the required arguments.</p>
",2
25497460,25497414,0,"<p>If you are willing to switch the parameters of the function and give default values to <code>a</code>, <code>b</code>, and <code>c</code>, you can do that.</p>

<pre><code>void get( float d, int e, char f, int a = 10, char b='\n', int c=16);
</code></pre>

<p>Then, you can call the function with values of just <code>d</code>, <code>e</code>, and <code>f</code>.</p>

<pre><code>get(5.0f, 20, '\t');
</code></pre>

<p>The above call is equivalent to</p>

<pre><code>get(5.0f, 20, '\t', 10, '\n', 16);
                    ^^^^^^^^^^^^^^ These are the default value of `a`, `b`, and `c`.
</code></pre>
",0
26248732,26248556,2,"<p>Because you call <code>user()</code> twice: once from <code>main</code>, ignoring the result, and once from  <code>Evaluate()</code>.</p>
",0
26247524,26247497,5,"<p>You haven't initialized any memory into which the string can be read. <code>char *</code> is a pointer to a location in memory where a string <em>can</em> be read, but the memory first has to be allocated using <code>new</code> or <code>malloc</code>.</p>

<p>However, in C++ there is another, better option: use <code>std::string</code>:</p>

<pre><code>#include &lt;string&gt;

int main()
{
    std::string name;
    cout &lt;&lt; ""Enter your name: "";
    cin &gt;&gt; name;
    cout &lt;&lt; ""Your name is: "" &lt;&lt; name;

    return 0;
}
</code></pre>

<p>If you are set on using a c-string, you could do allocate memory and do something like the following:</p>

<pre><code>int main()
{
    char name[MAX_SIZE];
    cout &lt;&lt; ""Enter your name: "";
    cin.get(name, MAX_SIZE);
    cout &lt;&lt; ""Your name is: "" &lt;&lt; name;

    return 0;
}
</code></pre>

<p>(Thanks to Neil Kirk for the improvements)</p>
",8
26217886,26217747,1,"<p>There is no <code>out_stream.open(...);</code> in your <code>secret</code> function, i.e. you never open the output stream.</p>
",1
28184495,28184454,3,"<p>First thing, you don't need a closing semi-colon after the closing parentheses on the 'if' block or the 'for' block. Next thing, I suspect the problem may be:</p>

<pre><code>(int i = 0; i &lt; mBooks.size()-1; i++)
</code></pre>

<p>See that minus 1? That means that you're not going to check the last item in the vector. If the book is the last item in the vector, you won't pick it up! <a href=""http://www.cplusplus.com/doc/tutorial/arrays/"" rel=""nofollow"">This</a> diagram gives a nice little summation of the problem I believed you've come up against.</p>

<p>Try this instead:</p>

<pre><code>int has = 0;

for (int i = 0; i &lt; mBooks.size(); i++)
{
    if (mBooks.at(i) == refBook)
    {
        has = 1;
        cout &lt;&lt; ""Has book "" &lt;&lt; has &lt;&lt; endl;
    }
}

return has;
</code></pre>

<p>Here are a few more tips for you. C++ has a built-in boolean type, bool, which you can use instead of an integer, to signal 'true' and 'false' (which are keywords!). Vectors can also be indexed like native arrays too, so you can the []'s instead of 'at'. So, here's a slightly more C++'ish version of your code:</p>

<pre><code>bool has = false;

for (int i = 0; i &lt; mBooks.size(); i++)
{
    if (mBooks[i] == refBook)
    {
        has = true;
        cout &lt;&lt; ""Has book "" &lt;&lt; has &lt;&lt; endl;
    }
}

return has;
</code></pre>

<p>One final suggestion, which is a bit more advanced, is to use the new C++11 'range for' syntax, which can be used on vectors and lists and the like. I'm also going to introduce the 'auto' and 'break' keywords, which I recommend you familiarise yourself with:</p>

<pre><code>bool has = false;

for (auto&amp; book : mBooks)
{
    if (book == refBook)
    {
        has = true;
        cout &lt;&lt; ""Has book "" &lt;&lt; has &lt;&lt; endl;
        break;
    }
}

return has;
</code></pre>

<p>Finally, it would be worthwhile looking at std::find function (<strong>edit: I see someone else has raised this</strong>) which isprovided for situations just like this.</p>
",1
28184509,28184454,1,"<p>This is not the code you're looking for (waves hand in a Jedi-like manner).</p>

<p>Short of memory corruption, that function, as it stands now, <em>will</em> return <code>1</code> if the statement is printed.</p>

<p>So your problem probably lies elsewhere.</p>

<p>I will give <em>one</em> bit of advice: if you're just looking to see if the book is in there, there's <em>no</em> need to keep looking once you've found it. And you should check the <em>entire</em> vector, at the moment you're skipping the last item. You would be better off with something like:</p>

<pre><code>int hasBook (TBook &amp;refBook) {
    for (int i = 0; i &lt; mBooks.size(); i++) {
        if (mBooks.at(i) == refBook) {
            cout &lt;&lt; ""Has book "" &lt;&lt; refBook &lt;&lt; endl;
            return 1;
        }
    }
    return 0;
}
</code></pre>
",0
28184535,28184454,3,"<p>I'll just throw out that this is precisely what <a href=""http://en.cppreference.com/w/cpp/algorithm/find"" rel=""nofollow""><code>std::find</code></a> exists for:</p>

<pre><code>bool has = (std::find(mBooks.begin(), mBooks.end(), refBook) != mBooks.end());
</code></pre>

<p>It's easy to make mistakes when writing loops (such as stopping one iteration short) - which is why sometimes it can be good to try to avoid writing them in the first place.</p>
",2
30161637,30082821,0,"<p>Thanks all for posting various suggestions. I try a summarizing answer with an additional proposal for the solution.</p>

<p>The prerequisite of my question was to reach a class hierarchy that is trivially copyable. See <a href=""http://en.cppreference.com/w/cpp/concept/TriviallyCopyable"" rel=""nofollow"">http://en.cppreference.com/w/cpp/concept/TriviallyCopyable</a> and especially the requirement of a trivial destructor (<a href=""http://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor"" rel=""nofollow"">http://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor</a>). The class cannot need a destructor implemented. This restricts the allowed data members, but is fine for me. The example shows only C-compatible types without dynamic memory allocation.</p>

<p>Some pointed out that the problem of my code is undefined behaviour, not necessarily a memory leak. Marco quoted the standard regarding this. Thanks, really helpful. </p>

<p>From my understanding of the answers, possible solutions are the following. Please correct me if I am wrong. The solution's point is that the implementation of the base class must avoid that its destructor can be called. </p>

<p><strong>Solution 1:</strong> The proposed solutions use protected inheritance.</p>

<pre><code>class CanData : protected Header
{
  ...
};
</code></pre>

<p>It works but avoids that people can access the public interface of Header. This was the original intention to have a base class. CanData needs to forward these functions to Header. In the consequece, I would reconsider to use composition instead of inheritance here. But the solution should work.</p>

<p><strong>Solution 2:</strong> Header's destructor must be protected, not the base class as a whole.</p>

<pre><code>class Header
{
public:
  uint8_t Version() const;
  const Timestamp&amp; StartTime();
  // ... more simple setters and getters with error checking

protected:
  ~Header() = default;

private:
  uint8_t m_Version;
  Timestamp m_StartTime;
};
</code></pre>

<p>Then no user can delete Header. This is fine for me, because Header has no purpose on its own. With public derivation, the public interface remains available to the user. </p>

<p>My understanding is that CanData needs not implement a destructor to call the base class's desctructor. All can use the default destructor. I am not completely sure about this though.</p>

<p>All in all, the answers to my questions in the end of the origial positing are:</p>

<ol>
<li><p><strong>Is it right that the class hierarchy without the virtual destructor is a problem even if all classes use the compiler's default destructor?</strong> </p>

<p>It is only a problem if your destructor is public. You must avoid that people can access you desctrutor, except for derived classes. And you must ensure that derived classes call (implicitely) the base class's destructor.</p></li>
<li><p><strong>Is it therefore right that I cannot have a safe class hierarchy that is trivially copyable?</strong></p>

<p>You can make your base class safe with protected inheritance or a protected desctructor. Then you can have a hierarchy of trivially copyable classes.</p></li>
</ol>
",0
27682660,27682278,0,"<p>This is going a bit further than you wanted, but the basic concept is there.  In short, use the file.tellg() function to save your current position.  You can use it later to return to your spot.</p>

<p>My modifications basically allow you to pull in any number of tables.  It does not, however, handle jagged tables.  It also does not properly handle the edge case where your file ends with the '#' character (empty table).  There is a situation at the end where, if you don't add a newline to the end of input1.txt, the last row is not going to be pulled.</p>

<p>Anyway, this code was modified without using a debugger to double check so I make no guarantees that it will start without some work.  Or that you won't get an infinite loop when it does work.</p>

<pre><code>// note that row starts from 0 because there is going to be an endline before the '#' character when it wasn't there before.
int col = 0, row = 0;
int temp = 0;
// new variables.
int table = 1, filepos = 0, curtable = 0;
char c;
ifstream file(""input1.txt"");
col = 0;
row = 1;

// calculating the number of tables.
do {
    file.get(c);
    if (c == '#')
        table++;
} while (file);

// Used for rewinding file.
file.clear();
file.seekg(0, ios::beg);

int*** ptrtable = new int**[table];

// calculating the no. of rows and columns of first 2d array in the text file (don't know how to do that for the second but this works perfectly)
do {
    file.get(c);
    if (c == ' ' || c == '\n')
        col++;
    if (c == '\n')
    {
        temp = 2;
        row++;
    }
    if (c == '#')
    {
        // Used for rewinding file.
        file.clear();
        temp = file.tellg;
        file.seekg(filepos, ios::beg);
        filepos = temp;

         // now I am using the info on rows and columns to dynamically allocate 2d array.(this is           working fine too)
         int** ptr = new int*[row];
         for (int i = 0; i &lt; col; i++)
         {
             ptr[i] = new int[col];
         }
         // here I am filling up the first 2d array.
         for (int i = 0; i &lt; row; i++)
         {
             for (int k = 0; k &lt; col; k++)
             {
                 file &gt;&gt; ptr[i][k];
                 cout &lt;&lt; ptr[i][k] &lt;&lt; ' ';
             }
             cout &lt;&lt; endl;
         }

         ptrtable[curtable] = ptr;

         // prepare for the next table.
         curtable++;
         temp = 0;
         row = -1;
         col = 0;

         file.clear();
         // filepos + 1 to jump past the '#' character.
         file.seekg(filepos + 1, ios::beg);

    }

} while (file);
</code></pre>
",0
25538593,25538525,29,"<p>This kind of thing doesn't just magically happen on its own; you changed something! In industry we use <em>version control</em> to make regular savepoints, so when something goes wrong we can trace back the specific changes we made that resulted in that problem.</p>

<p>Since you haven't done that here, we can only really guess. In Visual Studio, Intellisense (the technology that gives you auto-complete dropdowns and those squiggly red lines) works separately from the actual C++ compiler under the bonnet, and sometimes gets things a bit wrong.</p>

<p>In this case I'd ask why you're including both <code>cstdlib</code> and <code>stdlib.h</code>; you should only use one of them, and I recommend the former. They are basically the same header, a C header, but <code>cstdlib</code> puts them in the namespace <code>std</code> in order to ""C++-ise"" them. In theory, including both wouldn't conflict but, well, this is Microsoft we're talking about. Their C++ toolchain sometimes leaves something to be desired. Any time the Intellisense disagrees with the compiler has to be considered a bug, whichever way you look at it!</p>

<p>Anyway, your use of <code>using namespace std</code> (which I would recommend <em>against</em>, in future) means that <code>std::system</code> from <code>cstdlib</code> now conflicts with <code>system</code> from <code>stdlib.h</code>. I can't explain what's going on with <code>std::cout</code> and <code>std::cin</code>.</p>

<p><strong>Try removing <code>#include &lt;stdlib.h&gt;</code> and see what happens.</strong></p>

<p>If your program is building successfully then you don't need to worry too much about this, but I can imagine the false positives being annoying when you're working in your IDE.</p>
",19
28313586,28313558,9,"<p>Since <code>%</code> operator lets you to get a <code>[0; limit)</code> space, a standard approach when you need a <code>[start; limit)</code> space is to get a space <code>[0; limit - start]</code> via <code>%</code> operator and then add it to <code>start</code>. This way you'll get a <code>[start; limit)</code> space. So the formula would be</p>

<p><code>numberToBeWrapped = start + (numberToBeWrapped - start) % (limit - start)</code></p>

<p>Or, in your case:</p>

<p><code>c = 32 + (c + x - 32) % (126 - 32);</code></p>
",4
30133356,30133325,0,"<p>Use a pointer to the base class: <code>GameState* pGameState</code>.
And then in your constructor:</p>

<pre><code>MainMenuGameState::MainMenuGameState() :
    pGameState(new MainMenuGameState())
{
}

MainMenuGameState::~MainMenuGameState()
{
    delete pGameState;
}
</code></pre>

<p>And you should add a virtual destructor to GameState so it can properly clean up any resources:</p>

<pre><code>class GameState {
public:
    virtual ~GameState() {}
}
</code></pre>
",1
30133358,30133325,1,"<p>Use a pointer, preferably <code>std::unique_ptr</code>:</p>

<pre><code>#include &lt;memory&gt;

class Game {
private:
    std::unique_ptr&lt;GameState&gt; gameState;
public:
    Game()
    : gameState(std::unique&lt;MainMenuGameState&gt;(new MainMenuGameState())) { }
};
</code></pre>
",1
30133458,30133325,4,"<p>One of the many fundamental language differences between Java and C++ is that all Java objects are implicitly referenced through shared pointers.</p>

<p>C++ gives you the choice (and therefore the burden) of expressing whether objects should be managed by the scope of pointers to them, or by the scope of the object itself.</p>

<p>In order to hold any polymorphic object you must hold it through some means of pointer (as the the other answers mention, best to use unique_ptr or shared_ptr depending on whether the object's lifetime is to be managed by one owner or many).</p>

<p>full example (warnings fixed):</p>

<pre><code>#include &lt;memory&gt;

class GameState {
public:
    virtual ~GameState() = default;
}; //Will be abstract class, not to be instantiated

class MainMenuGameState 
: public GameState 
{
    public:
        MainMenuGameState() {}
};

class Game {
    private:
        std::unique_ptr&lt;GameState&gt; gameState; //Would want this to be initialized as a MainMenuGameState, not just a GameState;
    public:
        Game();
};

Game::Game()
: gameState { new MainMenuGameState }
{}


using namespace std;

int main()
{
    Game g;

   return 0;
}
</code></pre>
",0
30134929,30134901,0,"<p>You cannot make a pointer, because you are not asking for one.</p>

<p>The syntax you are looking for is:</p>

<pre><code>HUD* hud = new HUD(screenwidth,screenHight);
</code></pre>

<p>The difference between that and :</p>

<pre><code>HUD hud;
</code></pre>

<p>Is that the former instantiates the object on the heap, while the latter instantiates the object on the stack.  You will have to be sure to call:</p>

<pre><code>delete hud;
</code></pre>

<p>if you choose to instantiate with the first method.</p>
",1
30134932,30134901,0,"<p>The correct syntax for declaring a pointer is:</p>

<pre><code>HUD* hud = new HUD(screenwidth,screenHight);
</code></pre>

<p>But then again, you should not use naked pointers where possible. Read <a href=""http://en.wikipedia.org/wiki/Smart_pointer"" rel=""nofollow"">this</a>.</p>

<p><b>Edit</b></p>

<p>I noticed you wrote that it works when you declare the type as <code>Hud</code> instead of <code>HUD</code>. I suspect there is a typo here.</p>
",4
30135009,30134901,0,"<p>Found the source of the problem. the problem was that in the project i used a header called common that included all headers in the project and included common in each cpp file. for some reason even though HUD is included in common it still didnt work till i included HUD.h in the header file declaring the pointer HUD</p>
",0
26145340,26145124,1,"<p>Basically, the only difference between a member function and a non-member function is that it's passed an implicit <code>this</code> pointer as well as any other arguments and it has access to <code>private/protected</code> members.  So to transform <em>any</em> member function to a non-member function is to simply factor it out of the <code>class</code> definition. make it a <code>friend</code> of that class and add a parameter that's a reference to that class.  Pass in an object of that class when you call it.  You can also do a <code>const&amp;</code> of the function.</p>
",0
26145584,26145124,0,"<pre><code>class family
{
private:
    double weight;
    double height;
public:
    family( double x, double y );
    ~family( );

    // getters should be const
    double getWeight( ) const;
    double getHeight( ) const;
    double setWeight( );
    double setHeight( );
};
// no reason to make it friend of class
// b/c it does not work with private/protected members 
bool operator==( const family &amp; first, const family &amp; second );

// better to move into cpp file
bool operator==( const family &amp; first, const family &amp; second )
{
    return first.getWeight( ) == second.getWeight( );
}
</code></pre>
",0
26146174,26145124,0,"<p>You can use Friend Function and use  objects as parameter of that function like we use in &lt;&lt; operator.
we also can use operator without friend function :</p>

<pre><code>bool operator==(const family first, const family second) 
{
if(first.getWeight( ) == second.getWeight( )){
return True;
else
 return False;
}
</code></pre>
",0
28496010,28495867,2,"<p>Just put a newline in:</p>

<pre><code> cout &lt;&lt; ""mkdir: cannot create directory '"" &lt;&lt; arguments[1] 
      &lt;&lt; ""': File exists\n"";
</code></pre>

<blockquote>
  <p><em>""One more question ...""</em></p>
</blockquote>

<p>Same thing</p>

<pre><code> if (arguments[1][0] &lt; '0' || 
     arguments[1][0] &gt; '7' || 
     strlen(arguments[1]) &gt; 1)
</code></pre>
",5
32484882,32484673,2,"<p><code>std::max_element</code> will return ForwardIterator which in your case will be <code>map&lt;char,int&gt;::iterator</code> pointing to <code>pair&lt;char,int&gt;</code>. You have to change the last line to </p>

<pre><code> int max = max_element(count.begin(), count.end(),count.value_comp())-&gt;second;
</code></pre>
",0
32484899,32484673,2,"<p>When you dereference <code>std::map::iterator</code> you get <code>std::pair</code> and you try to assign it to <code>int</code>. Correct syntax would be:</p>

<pre><code>int max = max_element(count.begin(), count.end(), count.value_comp())-&gt;second;
</code></pre>

<p>but you should check if there are elements in that map, otherwise you may dereference <code>count.end()</code> with UB. That would happen if file is empty for example.</p>
",0
32485009,32484673,2,"<p>You have two issues</p>

<ul>
<li>count.value_comp() compares the keys of map::value_type(s), which are pairs</li>
<li>max_element returns an iterator to a pair</li>
</ul>

<p>You might change the code to:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;map&gt;

int main() {
    std::ifstream infile(""filename"");
    if (!infile.is_open())
        return 1;    // Check if file opened correctly
    char x;
    typedef std::map&lt;char, int&gt; map_type;
    map_type count;
    while (infile &gt;&gt; x) count[x]++;
    for (auto it : count)    // Pull this out of the while loop
        std::cout &lt;&lt; it.first &lt;&lt; "" "" &lt;&lt; it.second &lt;&lt; std::endl;
    auto less_count = [] (const map_type::value_type&amp; a, const map_type::value_type&amp; b) {
        return a.second &lt; b.second;
    };
    auto max_pair = std::max_element(count.begin(), count.end(), less_count);
    int  max = max_pair-&gt;second;
    std::cout &lt;&lt; max &lt;&lt; std::endl;
}
</code></pre>
",1
30174419,30174344,5,"<p>It looks like your <code>while</code> loop never exits:</p>

<pre><code>    while (str.size() != len) {
        pos = ((rand() % (str.size() - 1)));
    }
</code></pre>

<p>You only update <code>pos</code> in the loop, but you don't use <code>pos</code> in the <code>while</code> condition.</p>
",0
30160072,30159127,0,"<p>The issue appears to be the if statement comparing the array and int. All you need to do is to modify to use the correct equal comparison symbol and use the correct form of array as per the below;</p>

<pre><code>if (a[0] == 1)
{
    cout &lt;&lt; ""Your Bingo numbers are: 12, 5, 32, 18, 50, 46, 2, 29, 1, 30"" &lt;&lt; endl;
}
else if (a[0] == 2)
{
    cout &lt;&lt; ""Your bingo numbers are: 43, 1, 6, 34, 8, 19, 23, 42, 41, 5"" &lt;&lt; endl;
}
</code></pre>

<p>But it really does appears to be that this does not require array at all to accomplish the task. You just need a variable <code>a</code> with the type of <code>int</code> and then compare as is (a == 1). </p>

<pre><code>int a;
</code></pre>
",0
25457632,25457483,1,"<p>Maybe, you have intended to something like the following:</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;TCHAR.h&gt;

class StringCopyFn {
public:
    static void StringCopy(char *destination, char *source);
};

void StringCopyFn::StringCopy(char* destination, char* source){
    int i = 0;

    while( source[i] != '\0' ){
        destination[i] = source[i];

        i++;
    }
    destination[i] = '\0';
}

int _tmain(int argc, _TCHAR* argv[]){
    char source[] = { ""Computer"" };
    int sourcelength = strlen(source);
    printf(""Source = %s"", source);
    char* destination = new char[sourcelength+1];
    StringCopyFn::StringCopy(destination, source);
    printf(""\ndestination = %s\n"", destination);
    scanf_s(""Hello World""); 
    delete [] destination;
    return 0;
}
</code></pre>

<hr>

<p>or</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;TCHAR.h&gt;

struct StringCopyFn {
public:
    void operator()(char *destination, char *source){
        int i = 0;

        while( source[i] != '\0' ){
            destination[i] = source[i];

            i++;
        }
        destination[i] = '\0';
    }
};

int _tmain(int argc, _TCHAR* argv[]){
    char source[] = { ""Computer"" };
    int sourcelength = strlen(source);
    printf(""Source = %s"", source);
    char* destination = new char[sourcelength+1];
    StringCopyFn()(destination, source);
    printf(""\ndestination = %s\n"", destination);
    scanf_s(""Hello World""); 
    delete [] destination;
    return 0;
}
</code></pre>
",0
25457541,25457483,2,"<p>This is the StringCopyFn constructor:</p>

<pre><code>StringCopyFn::StringCopyFn()
{
}
</code></pre>

<p>Note that it takes zero parameters.</p>

<p>But based on this code:</p>

<pre><code>StringCopyFn(destination, source);
</code></pre>

<p>It seems likely that you meant to call your <code>StringCopy()</code> function.  It's not clear from the question why you created the StringCopyFn class.</p>
",0
28159107,28159054,1,"<p>You are doing integral division, the numerator as <code>double</code></p>

<p>Use :</p>

<pre><code> p = p* ( 1.0/i );
</code></pre>
",0
32412587,32412401,5,"<p>I hope that after @LogicStuff formatted you code you can see that you don't square the hypotenuse if it is <code>a</code> and that you've missed braces around the last <code>else</code>. </p>

<p>However, another thing you should note is the amount of code duplication you have. Within every branch of your conditional you have the same code for printing whether this triangle is right. You could save this into a boolean variable and move the printing logic at the end of the loop.</p>

<p>Taking this one step further, does your problem require you to know which side of a triangle is a hypotenuse? From what you wrote it does not, and in that case you are doing extra work. Instead, you could simplify your code to:</p>

<pre><code>int a, b, c;
while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c)
{
    bool right =  (b*b + c*c == a*a)
               || (a*a + c*c == b*b)
               || (a*a + b*b == c*c);

    if (right)
        cout &lt;&lt; ""right\n"";
    else
        cout &lt;&lt; ""wrong\n"";
}
</code></pre>
",0
31263100,31261950,3,"<p>As long as you have a virtual keyword in you class definition the compiler will build statically the vtable even if you're not inheriting from it, as you can see in your class you didn't define your goBowling method so compilation will fail.</p>
",0
28247500,28247474,1,"<p>You're just printing the converted value but you're not returning it. Each of those if blocks should contain a return statement returning the result of the computation.</p>
",0
28190361,28190329,0,"<p><code>mul(6,8)</code> outputs the result of <code>add(2,3)</code>, i.e. 5, and then returns the result of 6*8, which is 48. That result is printed by main. Since there are no intervening spaces or newlines, what you see is <code>548.</code></p>
",0
28190374,28190329,0,"<p>I think you can solve this problem yourself if you add a newline to each <code>cout</code> statement: <code>cout &lt;&lt; add(2,3) &lt;&lt; endl;</code></p>
",0
28190410,28190329,1,"<p>You are getting what you have programmed. 
first the result of addition which is <code>2 + 3 = 5</code> and then the result of multiplication <code>6 * 8 = 48</code>.</p>

<p>Since you are not giving providing escape characters the result is being printed right beside each other. </p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

//Fuction of add
int add(int x,int y)
{
    return x+y;
}

//Function of multiply calling add fuction
int mul(int x,int y)
{
    cout &lt;&lt; ""Addition of 2 and 3 is ""&lt;&lt; add(2,3) &lt;&lt; ""\n"";
    return x*y;
}


//Main Function
int main()
{
   cout &lt;&lt; ""Multiplication of 6 and 8 is ""&lt;&lt;mul(6,8)&lt;&lt;""\n"";
   return 0;
}
</code></pre>

<p>By providing statements will help you better understand your program.</p>
",0
28184733,28183929,0,"<p>If you're using a 32-bit compiler (either MinGW or the 32-bit version of MinGW-w64), make sure you downloaded the 32-bit version of GLFW3 for Windows and are using the files from the <code>lib-mingw</code> subdirectory. The 64-bit version of GLFW3 will only work with the 64-bit version of MinGW-w64, which is a separate project from the 32-bit only MinGW.</p>

<p>Note that the fact that you're using a 64-bit operating system doesn't matter. If you're using a 32-bit compiler then you need the 32-bit libraries.</p>

<p>While it's not the problem you've run into, I should also note here that 32-bit version GLFW3 for Windows isn't fully compatible with MinGW. The static library <code>lib-mingw/libglfw3.a</code> has a dependency on the MinGW-w64 runtime so won't link properly with MinGW. The import library <code>lib-mingw/glfw3dll.a</code> along with its associated DLL <code>lib-mingw/glfw3.dll</code>, should work fine with MinGW however.</p>
",1
26428942,26428903,6,"<p>This is called an implicit declaration. When you write <code>A a=13;</code>, your compiler is smart enough to recognize that what you really mean is <code>A a(13);</code> since you <strong>have</strong> declared a constructor that takes an int as an argument. If you don't want this to happen, put an <code>explicit</code> keyword before your constructor, and then you will get compiler errors unless you write <code>A a(13);</code> instead of <code>A a=13;</code>.</p>
",0
26428979,26428903,5,"<p>A non-explicit constructor that takes a single parameter can be used as a <em>conversion constructor</em>, to implicitly convert the parameter type to the class type.</p>

<p>So that constructor is used to convert <code>13</code> to type <code>A</code>.</p>

<p>If you want, you can prevent the implicit conversion by making the constructor explicit:</p>

<pre><code>explicit A(int x):a(x),b(a*a){}
</code></pre>

<p>That can still be used for explicit conversions:</p>

<pre><code>A a1(13);     // OK: explicit conversion
A a2 = A(13); // OK: explicit conversion
A a3 = 13;    // Error: implicit conversion not allowed via explicit constructor
</code></pre>
",0
26429122,26428903,2,"<p>It seems that you're unaware of the <strong>conversion constructor</strong>. A <strong>conversion constructor</strong> is a constructor that takes in exactly one argument and constructs an object of that class. It works like a conversion from some type to your class, hence the name <strong>conversion constructor</strong>.</p>

<p><strong>Implicit conversion</strong>, which I believe is what's confusing you here, happens when the compiler sees two different types and tries to make them compatible by looking for possible conversions.</p>

<p>As you can see, <strong>implicit conversion</strong> causes quite a lot of confusion (An int can be an A too?!). Therefore, you should be careful of <strong>conversion constructors</strong> in your class and use the <code>explicit</code> keyword when necessary.</p>

<pre class=""lang-cpp prettyprint-override""><code>explicit A(int i);
</code></pre>

<p>When you specify a conversion constructor as <code>explicit</code>, this tells the compiler to <strong>not</strong> perform any <strong>implicit conversion</strong> on this type. When that happens, you can only convert by using a cast such as <code>static_cast&lt;int&gt;(a);</code>.</p>

<p>Thank you for reading.</p>
",0
28210749,28210671,1,"<p><code>Player</code> is a <strong><em>class</em></strong> and not an object. You need to create an object (an instance) of the <code>Player</code> class, and use that.</p>

<p>For example:</p>

<pre><code>Player p;

...

p.addSpell(mMagic[0]);
</code></pre>
",2
28210941,28210671,0,"<p>you need to instantiate an object(object of class Player) in order to call the member function(addSpell(Spell)).Only static member functions and staic member variables can be called with class name as they are class specific,member functions are object specific and hence you need to have an object instantiate to call them.</p>
",3
28214106,28210671,0,"<p>I think your real problem is that you need access to the same Player instance from many different modules.<br> Usually for that you should store Player instance in your ""game logic"" module (that should be easily accessible from anywhere) and implement accessor to that instance.</p>

<p>Try something like this:</p>

<pre><code>//Game.h
class Game
{
    ...
    private:
        static Game *instance;
        Player *player;
    public:
        static Game* getInstance();
        Player *getPlayer();
        Game::init();
}

//Game.cpp
Game* Game::instance = NULL;
Game* Game::getInstance()
{
    return instance;
}

void Game::init()
{
    ...
    instance=this;
    ...
    player = new Player();
    ...
}

Player* Game::getPlayer()
{
    return player;
}

//Store.cpp
...
    Player* player=Game::getInstance()-&gt;getPlayer();
    //If player already has the spell
    if (player.getSpellName() == mMagic[0].mSpell)
    {
        cout &lt;&lt; ""You already have this spell."" &lt;&lt; endl &lt;&lt; endl;
        break;
    }
    else
    {
        //Increase size of Grimoire to store the purchased spell
        player.increaseGrimoire();

        //Add spell to Grimoire

        player.addSpell(mMagic[0]); //HERE IS THE PROBLEM*******
    }
</code></pre>

<p>For more elaborate/aesthetic ways to handle such problems you should read about Design Patterns and Game Design/Programming Patterns.</p>
",1
28222457,28222325,0,"<p>you can store input in <code>string</code> (or char array) and then later separate you desired parts, for that purpose you can create a function which will take the <code>input string</code> as parameter and separate its parts.</p>
",1
28223053,28222325,2,"<p>I think that you should look into using the date tools that C++11 already provides to you.</p>

<p>time.h's <code>struct tm</code> has <a href=""http://en.cppreference.com/w/cpp/io/manip/get_time"" rel=""nofollow"">it's own streaming operators</a>. So I'd do something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;ctime&gt;

using namespace std;

int main() {
    tm t;
    istringstream ss(""11/11/1980"");

    ss &gt;&gt; get_time(&amp;t, ""%m/%d/%Y"");

    cout &lt;&lt; t.tm_mon + 1 &lt;&lt; ' ' &lt;&lt; t.tm_mday &lt;&lt; ' ' &lt;&lt; t.tm_year &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>I don't know why but it's noteworthy that <code>tm.tm_mon</code> is 0-based...</p>

<p>See also: <a href=""http://en.cppreference.com/w/cpp/io/manip/put_time"" rel=""nofollow"">http://en.cppreference.com/w/cpp/io/manip/put_time</a></p>
",1
28224353,28222325,0,"<p>You could search the web for ""c++ read date"" for some examples.  </p>

<p>One method is:</p>

<pre><code>unsigned int month;
unsigned int day;
unsigned int year;
char         separator;
cin &gt;&gt; month &gt;&gt; separator &gt;&gt; day &gt;&gt; separator &gt;&gt; year;
</code></pre>

<p>But there are issues with that, such as having a space before the '/'.</p>

<p>Another method is to <code>fscanf</code> with a decent format string:</p>

<pre><code>  fscanf(stdin, ""%2d/%2d/%4d"", &amp;month, &amp;day, &amp;year);
</code></pre>

<p>but, that doesn't use the C++ streams.  </p>

<p>You could use strings and <code>getline</code>:  </p>

<pre><code>std::string month_str;
std::string day_str;
std::string year_string;
std::getline(cin, month_str, '/');
std::getline(cin, day_str, '/');
std::getline(cin, year_str); // What's the delimiter here???
</code></pre>
",0
26782548,26782515,2,"<p>In order to get a C-style string from an <code>std::string</code>, use the <code>c_str()</code> member function. It will return a null-terminated <code>const char *</code>. Your function, however, seems to take <code>char*</code>. You could, of course, <code>const_cast</code> the pointer to get the <code>char*</code> but a far more reasonable approach would be for your function to take <code>const char*</code> or <code>const std::string&amp;</code> in the first place.</p>
",0
26782576,26782515,3,"<p>As the error message says, you're trying to pass a <code>std::string</code> to a function that expects a pointer to a character array.</p>

<p>The best solution is to change the function to work with a string:</p>

<pre><code>int Save (int key_stroke, const std::string &amp; file);
</code></pre>

<p>and then extract a pointer when you need one</p>

<pre><code>fopen(file.c_str(), ""a+"");
          ^^^^^^^^
</code></pre>

<p>Alternatively, if you want to preserve the C-style aesthetic of your code, you could change the parameter type to <code>const char *</code>, and pass <code>fileN.c_str()</code> to it.</p>
",0
34088588,34088049,0,"<p>The whole point of template metaprogramming is that all of these ""calls"" will be optimised out of your program; they are ""executed"" during the build.</p>

<p>That doesn't change the fact that there is an implementation-defined limit to the amount of recursion you can use during this process. This is the limit you've hit.</p>

<p>So, no, there's no ""optimisation"" to work around it.</p>
",2
26814952,26814941,0,"<p>Have you ever tried to google it before posting there?</p>

<pre><code>int factorial(int n) 
{
    if (n &lt; 0 ) {
        return 0;
    }
    return !n ? 1 : n * factorial(n - 1);
}
</code></pre>
",0
26814992,26814941,0,"<p>Your fact function just computes factorial for one time. You should do something resursively like:</p>

<pre><code>int fact (int A)
{
     if (A &lt;= 1) {
         return 1;
     }
     return A*fact(A-1);
}
</code></pre>

<p>or if you want it in iterative way then you should do the following:</p>

<pre><code>int fact (int A)
{
    int B = 1, i = 2;
    for (; i&lt;=A; i++) {
        B = B*i;
    }
    return B;
}
</code></pre>
",2
26815008,26814941,0,"<p>And why din't you search it instead.</p>

<p>anyway...</p>

<pre><code>int n, count;
    unsigned long long int factorial=1;         
    cout&lt;&lt;""Enter an integer: "";
    cin&gt;&gt;n;
    if ( n&lt; 0)
        printf(""Error!!! Factorial of negative number doesn't exist."");
    else
    {
       for(count=1;count&lt;=n;++count)    /* for loop terminates if count&gt;n */
       {
          factorial*=count;              /* factorial=factorial*count */
       }
    cout&lt;&lt;factorial;
    }
</code></pre>
",0
26815010,26814941,0,"<p>First of all this has nothing to do with C++ ( as your question says ). This is specific to alogorithms and they can be employed in any language.</p>

<p>You can use below example for your reference.</p>

<pre><code>int fact (int A)
{
     if (A == 0) {
         return 1;
     }
     return A*fact(A-1);
}
</code></pre>
",0
26815041,26814941,0,"<pre><code>int factorial (int a) {
    return a==0 ? 1 : a*factorial(a-1); 
}
</code></pre>
",0
26815044,26814941,-1,"<p>Since you're using C++ rather than C, I'd simply go with a template function. Bonus for this: due to expansion/implementation at compile time, your code will be highly optimized and essentially as fixed as possible with little to no overhead:</p>

<pre><code>// First the generic template for pretty much all numbers
template &lt;unsigned int X&gt;
unsigned int factorial() {
    return X * factorial&lt;X - 1&gt;();
}

// Now the specialization for the special case of 0
template &lt;&gt;
unsigned int factorial&lt;0&gt;() {
    return 1;
}
</code></pre>

<p>For example, to calculate the factorial of 5, you'd just call <code>factorial&lt;5&gt;()</code>. With optimizations enabled, this will result in just <code>120</code>. Unfortunately this is not possible with dynamic variables.</p>
",3
27500142,27496754,1,"<p>To use the random number generator function in C++, you need to include the  header. </p>

<pre><code>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;

using namespace std;

int main()
{

    int randomInteger = rand();
    cout &lt;&lt; randomInteger &lt;&lt; endl;


}
</code></pre>

<p>If you want to produce numbers in a specific range, you can use the modulo operator. It's not the best way to generate a range but it's the simplest. If we use rand() % n we generate a number from 0 to n-1. By adding an offset to the result we can produce a range that is not zero based. The following code will produce 20 random numbers from 1 to 10:</p>

<pre><code>#include &lt;cstdlib&gt; 
#include &lt;iostream&gt;

using namespace std;

int main() 
{ 
    int random_integer; 
    for(int index=0; index&lt;20; index++){ 
    random_integer = (rand()%10)+1; 
    cout &lt;&lt; random_integer &lt;&lt; endl; 
} 
</code></pre>
",0
27496945,27496754,0,"<p>Yes, the C++ library has a substantial numerics library, described in section 26 of the C++11. Specifically, the random number generation classes are described in section 26.5.</p>

<p>Since your question was only whether this functionality is ""available in C++"", the answer would be ""yes"".</p>

<p>You should be able to find plenty of examples of using the <code>std::random_device</code> class, and other classes from the random number generation library, by searching the Intertubes.</p>
",0
27497001,27496754,1,"<p>There's the <code>rand()</code> function from <code>&lt;cstdlib&gt;</code> library, which returns a number between 0 and <code>RAND_MAX</code>. If you want a number between 0 and 1, you have to do a workaround with casts and divisions:</p>

<pre><code>double X = ((double)rand() / (double)RAND_MAX);
</code></pre>

<p>This is a practical example, putting the previous code inside a function:</p>

<pre><code>#include &lt;cstdlib&gt; //  srand, rand
#include &lt;ctime&gt; // time
#include &lt;iostream&gt; //std::cout

double random01()
{
     return ((double)rand() / (double)RAND_MAX);
}

int main()
{

    srand(time(0)); // Remember to generate a seed for srand

    for(int i=0; i&lt; 100; ++i)
    {
        std::cout &lt;&lt; random01()  &lt;&lt; '\n';
    }

    return 0;
}
</code></pre>
",0
27497208,27496754,0,"<pre><code>int randomNumber = rand()%100; // for 0 to 99
</code></pre>
",0
29228237,29228173,2,"<p><code>sphere</code> inherits from <code>Solid</code> in two ways: directly, and indirectly via <code>Cylinder</code>. Since the inheritence is non-virtual, this means it contains two distinct <code>Solid</code> sub-objects, making the conversion to <code>Solid</code> ambiguous.</p>

<p>In this case, the solution is very simple: a sphere isn't a cylinder, so <code>sphere</code> shouldn't inherit <code>Cylinder</code>.</p>
",0
26436431,26436391,2,"<p>It's a pretty simple mistake. Notice that your <code>operator&lt;&lt;</code> function states that it has a return value of <code>ostream&amp;</code>, but your <code>Matrix::print</code> method has no return. To fix this, just change your <code>operator&lt;&lt;</code> function to this:</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; out, const Matrix&amp; x) // display the matrix
{
    x.print(out);
    return out;
}
</code></pre>
",0
26795516,26794974,-1,"<p>link: <a href=""http://ideone.com/4P8AX0"" rel=""nofollow"">http://ideone.com/4P8AX0</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    vector&lt;int&gt; vec;
    int value = 0;
    for(int i=0; i&lt;10; i++){
        cin &gt;&gt; value;
        vec.push_back(value);
    }

    std::sort(vec.begin(),vec.end());

    cout &lt;&lt; ""biggest"" &lt;&lt; vec[9] &lt;&lt; endl;
    cout &lt;&lt; ""2nd biggest"" &lt;&lt; vec[8] &lt;&lt; endl;
    cout &lt;&lt; ""3rd biggest"" &lt;&lt; vec[7] &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>whole program enjoy</p>
",6
28470228,28470149,2,"<p><code>using namespace std;</code> can be used and abused, just like most any other thing.</p>

<p>The one rule you should remember is</p>

<ul>
<li>Never put a <code>using namespace std;</code> in the global namespace in a header.</li>
</ul>

<p>That's because names like <code>distance</code> very easily can collide with client code.</p>

<p>In general, the advantages of C++ namespaces is that they allow easy disambiguation where names clash, while generally allowing you to use readable unqualified names. If one always qualifies names then the only difference from C style fixed prefixes and suffixes is the presence of <code>::</code> in there, and I don't think it can be argued that having those colons in a name is any advantage. But this argument only pertains to namespaces that one defines oneself: for the <code>std</code> namespace it can be argued that it's imposed by the standard, so that a practice of fully qualified names means to use <code>std::</code> always (and I know that this is done by a number of companies, even though I disagree strongly with these programmers' claims that the code then is <em>more</em> readable than without the <code>std::</code> prefixes).</p>
",3
28470248,28470149,0,"<p>That isn't at all a stupid question.</p>

<p>iostream is a C++ code file (more specifically a header file, but that doesn't matter). It contains the code that defines cout, cin, endl, etc. If we want to use them, we need them to be in our code, that's why we include it. However, if we look at it's contents, we will (schematically) see something like this (This is not a serious attempt of trying to map iostream schematically, but I will refrain from making things too complicated, and for the explanation, it will do):</p>

<pre><code>// iostream header file    
    namespace std
    {
       ostream cout;
       istream  cin;
       // etc etc
    };
</code></pre>

<p>Using the using keyword doesn't mean we add functionality, it means we say that we read things by default. If we say using namespace std; then we say: If we come across an OBJECT name that doesn't exist in our current namespace, check if there exists a namespace std in which it does exist, and use that object. Thus, it doesn't really add a function, it is the include  that ""loads"" cout, cin, endl and all the like.</p>

<p>(Note that the schematic above is not what you will find when opening the iostream file, in reality it's a lot more complex and also contains a lot of definitions.)</p>

<p>The tutorials page gives a nice explanation <a href=""http://www.cplusplus.com/doc/tutorial/namespaces/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/namespaces/</a></p>
",0
28470323,28470149,0,"<p>Namespace is a way to structure program, imagine you have your own string class which put in namespace foo. If you don't explicitly type std:string, the compiler will get confused which string should be used.</p>
",0
28462640,28462541,1,"<ol>
<li><p>You are returning a reference to a temporary, you are toast:</p>

<pre><code>const fraction&amp; inverse (const fraction&amp; f) {
    return fraction(f.den,f.num);
}
</code></pre></li>
<li><p>Are you returning a pointer or a reference to a dynamically allocated object? Decide, and correct the code!<br>
Anyway, neither is really a good idea.</p>

<pre><code>const fraction&amp; inverse_version2 (const fraction&amp; f) {
    return new fraction(f.den,f.num); 
}
</code></pre></li>
</ol>

<p>What you should do instead is just returning by value (and relying on RVO / NRVO to eliminate copies/moves), or eliminating any chance of a copy.<br>
Or, if the object is really that big, by <code>std::unique_ptr</code>.</p>

<pre><code>fraction inverse_v1(const fraction&amp; f) { // Uses RVO / NRVO to eliminate temporaries
    return fraction(f.den, f.num);
}
fraction inverse_v2(const fraction&amp; f) { // no temporaries at all
    return {f.den, f.num};
}
std::unique_ptr&lt;fraction&gt; inverse_v3(const fraction&amp; f) { // smart-pointer
    return {new fraction(f.den, f.num)};
}
</code></pre>
",9
28462723,28462541,2,"<p>Both versions are wrong. In the first case you get UB as returning reference to local object, which is destroyed, in the second it would not even compile. If you try to fix second function naive way, as dereferencing the pointer, you will get memory leak. So 100% safe variant is this:</p>

<pre><code>     fraction inverse (const fraction&amp; f) {
          return fraction(f.den,f.num);
     }
</code></pre>

<p>PS if you want to return a pointer to dynamically allocated object return a smart pointer:</p>

<pre><code>     std::unique_ptr&lt;fraction&gt; inverse_ptr( const fraction&amp; f) {
          return std::make_unique&lt;fraction&gt;(f.den,f.num);
     }
</code></pre>
",0
31159356,31159302,18,"<p>You have to <code>#include &lt;algorithm&gt;</code>. See <a href=""http://www.cplusplus.com/reference/algorithm/"" rel=""noreferrer"">this</a>.</p>
",0
31159365,31159302,67,"<p>Include the algorithm header. That's why there is a error.</p>

<pre><code>#include &lt;algorithm&gt;
</code></pre>
",0
30702802,30699007,0,"<p>The problem is because of bad placement of the file closing. </p>

<pre><code>while (getline(inFile, line))
{
    ...parsing...
    inFile.close();
}
</code></pre>

<p>You want:</p>

<pre><code>while (getline(inFile, line))
{
    ...parsing...
}
inFile.close();
</code></pre>

<p>But you don't need to explicitly close the file anyway. <code>ifstream</code>s destructor will take care of it when inFile goes out of scope at the end of the function.</p>

<p>The next problem you'll run into:</p>

<pre><code>iss &gt;&gt; day; // read stream up to whitespace into string
iss &gt;&gt; hour_start; // read stream until not int into int
iss &gt;&gt; minute_start; // read stream until not int into int
iss &gt;&gt; duration; // read stream until not int into int
</code></pre>

<p>The input:</p>

<pre><code>Mo  13:30   16
</code></pre>

<p>What happens:</p>

<pre><code>iss &gt;&gt; day; // reads ""Mo""
iss &gt;&gt; hour_start; // reads 13
iss &gt;&gt; minute_start; // tries to read ':' as int, fails
iss &gt;&gt; duration; // previous error not cleared. Fails
</code></pre>

<p>The read failures were not tested for and handled. Minute start and duration are used unassigned. Comic hi-jinks ensue.</p>

<p>Try instead:</p>

<pre><code>char colon;
if (iss &gt;&gt; day &gt;&gt; hour_start &gt;&gt; colon &gt;&gt; minute_start &gt;&gt; duration &amp;&amp; (colon == ':'))
{
     do calculations
}
else
{
    notify user of bad file
}
</code></pre>
",0
31235372,31235336,7,"<p><strong>You can add <code>cout &lt;&lt; std::fixed;</code></strong></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

int main() {
    float f = 1.66f;
    int d = (int)f;
    double g = (double)d;
    cout.precision(6);
    cout &lt;&lt; std::fixed;
    cout&lt;&lt;g&lt;&lt;""\n"";
}
</code></pre>

<p>and you get <code>1.000000</code></p>

<p><strong>Explanations (edit)</strong></p>

<p>When you use <a href=""http://www.cplusplus.com/reference/ios/fixed/"" rel=""nofollow"">std::fixed</a> :</p>

<blockquote>
  <p>When floatfield is set to fixed, floating-point values are written
  using fixed-point notation: the value <strong>is represented with exactly as
  many digits in the decimal part as specified by the precision field</strong>
  (precision) and with no exponent part.</p>
</blockquote>

<p>When you use the <a href=""http://www.cplusplus.com/reference/ios/defaultfloat/"" rel=""nofollow"">std::defaultfloat</a> (the one you are using)  :</p>

<blockquote>
  <p>When floatfield is set to defaultfloat, floating-point values are
  written using the default notation: <strong>the representation uses as many
  meaningful digits as needed</strong> up to the stream's decimal precision
  (precision), counting both the digits before and after the decimal
  point (if any).</p>
</blockquote>

<p>That's why the following <code>.000000</code> are considered irrevelant !<br>
(If you had <code>1.00001</code> it would have been printed)</p>
",3
31235408,31235336,1,"<p>Setprecision sets how precise the result has to, e.g.</p>

<pre><code>std::cout &lt;&lt; (1.f)/6 &lt;&lt; std::endl;  // prints 0.166667
std::cout.precision(7);
std::cout &lt;&lt; (1.f)/6 &lt;&lt; std::endl;  // prints 0.1666667
</code></pre>

<p>But it does not require that 0's are printed out, consider:</p>

<pre><code>std::cout.precision(5);
std::cout &lt;&lt; 1.1110f &lt;&lt; std::endl;      // prints 1.111
std::cout &lt;&lt; 1.1111f &lt;&lt; std::endl;      // prints 1.1111
</code></pre>

<p>And as coincoin suggests the solution to get 0's printed out is to use std::fixed!</p>
",4
26776228,26776069,4,"<p>The first one is declaring a static variable (usually on the stack*) that will die at the end of the code block in which it is defined.</p>

<p>The second one is dynamically allocating a variable (usually on the heap*) which means that you are the one that can decide where to deallocate it with delete[] (and yes you should remember to do it).</p>
",0
32420762,32420739,2,"<p>Taking the address of <code>n1</code> is done with <code>&amp;n1</code>, not <code>n1*</code>.</p>

<p><code>n1*</code> does not have any meaning in the given context, hence the error.</p>
",0
32420795,32420739,0,"<p>Instead of <code>n1.initNode(n1*,1);</code>  you should put: <code>n1.initNode(&amp;n1,1);</code> 
The <code>n1*</code> is an incorrect expression, to get the pointer you should use <code>&amp;n1</code>.</p>
",0
32420837,32420739,0,"<p>1.You don't need <code>LLToolkit&lt;T&gt;::</code> for the inside class defination of <code>initNode</code>:</p>

<pre><code>template&lt;class T&gt; 
class LLToolkit
{
public:
    initNode(T* head, T x)                
    {
        head-&gt;info = x;
        head-&gt;next = NULL;
    };

//some other functions
};
</code></pre>

<p>2.<code>initNode</code> 's 1st parameter is <code>T*</code>, 2nd parameter is <code>T</code>, according to <code>LLToolkit&lt;Node&gt; n1;</code>, you should pass <code>Node*</code> and <code>Node</code> for <code>n1.initNode</code>.</p>
",0
27574186,27574159,3,"<p>This is not a C program, it is a C++ program. Rename your file to <code>array.cpp</code> and/or use <code>g++</code> instead of <code>gcc</code>, and no, there is no such thing as <code>iostream</code> in C.</p>

<p>The first non-C part of your program is</p>

<pre><code>using namespace std;
</code></pre>

<p>there is no <code>namespace</code>s in C.</p>

<p>the second part is</p>

<pre><code>std:cin&gt;&gt;array[x];
</code></pre>

<p>there are two things wrong with it, first of all why do <code>using namespace std;</code> and then <code>std::cin</code> if you use <code>using namespace</code> in C++ it means that it will lookup in that namespace when omited, secondly that is also C++ specific. There is no <a href=""http://www.cplusplus.com/reference/ostream/ostream/operator&lt;&lt;/"" rel=""nofollow"">stream operator</a> in C.</p>

<p>You included <code>stdio.h</code> so you have to use <a href=""https://www.cl.cam.ac.uk/cgi-bin/manpage?3+fgets"" rel=""nofollow"">fgets</a> or similar functions. And for output the <a href=""https://www.cl.cam.ac.uk/cgi-bin/manpage?3+printf"" rel=""nofollow"">printf</a> family</p>
",2
28467520,28467510,3,"<p>Don't use <code>""|""</code>.  Put <code>'|'</code> instead.  You want to compare a <code>char</code> to a <code>char</code>, NOT compare a <code>char</code> to a <code>char*</code>.</p>
",1
28467531,28467510,1,"<p>You shall use <code>while ( a != '|' )</code> instead</p>

<p><code>'|'</code> is a character and <code>""|""</code> is a string which has only 1 character</p>
",2
29449959,29449911,4,"<p>Well <code>(roll == 8 || roll &gt; 79 &amp;&amp; roll &lt; 90 ? ""an"" : ""a"")</code> is more concise, for starters.</p>

<p>You could have a solution based on a 2-character buffer <code>buf</code> and <code>snprintf(buf, 2, ""%d"", roll)</code>, but that seems overkill. And as pointed out in the comments, just looking at the first digit is not enough for total grammatical correctness, so it is better to stick with the disjunction of special cases.</p>
",2
29450019,29449911,2,"<p>If you want to handle all numbers starting with 8 something along the lines of this should do</p>

<pre><code>bool startsWithEight(int number){
    while(number &gt; 10){
        number /= 10;
    }
    return number == 8;
}
</code></pre>

<p>Might not be the most efficient way.</p>
",3
27175562,27175486,7,"<p>This is a circular problem. You want the compiler to error out and inform you when you're accessing a class member without prefixing <code>this-&gt;</code>, so that you cannot be accidentally referring to a local variable or function argument instead &hellip; but for that exact same reason, how is the compiler supposed to know that you really intended to access the member? And, if you didn't, how would you access the local variables or function arguments?</p>

<p>C++ is simply not designed this way. Some languages, such as PHP, require that you <em>must</em> use <code>this</code> to access members and any other access is treated as an attempt to read local-scope variables (whether they exist or not), but C++ does not have that. And there is no compiler switch to make it happen. If this worries you, <strong>avoid re-using the names of variables</strong>!</p>

<p>In short, this is a non-problem that cannot be solved.</p>
",0
26808013,26807944,2,"<p>You can use initializer lists like this</p>

<pre><code>class B{
    public:
        B(A tempZ) : z(tempZ) {
        }
        A z;
};
</code></pre>

<p>This way z will be initialized with a new instance of A created by the copy constructor.</p>
",0
28467603,28467564,3,"<p>You are using wrong type. Your <code>string</code> is already a string type. Write the code like this.</p>

<pre><code>class Person
{
public:
    Person (const string&amp; n) : name(n) { }
    ~Person() {}

    string getName() const { return name; }
private:
    string name;
};
</code></pre>

<p>If you insist to use pointer in your member variable, you shall overwrite the copy constructor and overload assign operator.</p>

<p>Give you an example:</p>

<pre><code>class Person
{
public:
    Person (const char* n)   : name(new char[strlen(n)+1])      { strcpy(name, n);      }
    Person (const Person&amp; p) : name(new char[strlen(p.name)+1]) { strcpy(name, p.name); }
    ~Person() { delete [] name; }

    Person&amp; operator=(const Person&amp; p)
    {
        if ( &amp;p == this ) return *this;
        delete [] name;
        name = new char[strlen(p.name)+1];
        strcpy(name, p.name);
        return *this;
    }

    string getName() const { return name; }

private:
    char* name;
};
</code></pre>
",1
28467638,28467564,9,"<p>As other said, better to do without pointers. However, if you wondering what is happening, the reason for what you get is that in this line <code>people.push_back(Person(""Tom""));</code> Person object is created, and its copy passed to vector. However, once the object is copied, destructor is executed which deletes the string. </p>

<p>With your usage of pointers, both the original Person object and its copy point to the same string in memory. String gets deleted by destructor, and <code>name</code> pointer in the copy does not point to anything. Thus you get undefined behaviour.</p>

<p>To rectify this issue, either dont use pointers, or you need to define your own copy constructor. For example:</p>

<pre><code>class Person
{
    string * name;
public:
    Person(const string &amp; n) : name {new string {n}} {}

    // copy constructor which makes new string in memory
    //based on the original string.
    Person(const Person &amp; other) {
        name = new string(other.getName());
    }

    ~Person() { delete name; }
    string getName() const {return *name;}
};
</code></pre>
",0
28467691,28467564,1,"<p>The reason why your code is buggy has already been explained, but if you have C++11, you can use <code>emplace_back</code>:</p>

<pre><code>people.emplace_back(""Tom"");
</code></pre>

<p>Still, using pointers instead of a plain member variable is just unnecessarily complicating your program. The less memory management you have to do, the better. Read about the <a href=""http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html"" rel=""nofollow"">Rule of Zero</a>. Better yet, if your <code>getName()</code> function doesn't do anything special, remove it and just make <code>name</code> public.</p>
",2
31803154,31803070,4,"<p>The parameter <code>ListNode* head</code> takes a <em>copy</em> of a pointer. <code>head =</code> then only modifies that copy, and not the original pointer which was passed to the function.</p>

<p>If you need to modify the original pointer, pass a <em>reference</em> to it: <code>ListNode*&amp; head</code></p>
",0
31803110,31803070,5,"<p>C++ has pass by value semantics.<code>head = head-&gt;next;</code> has no effect on the caller side, because <code>head</code> is local to the <code>printList</code> function. In this sense, passing a pointer is no different to passing an <code>int</code> or a <code>double</code>. You get a local copy of the passed object. The difference is that a pointer allows you to refer to a non-local object.</p>
",0
31803131,31803070,3,"<p>With this, you get a copy from the pointer.<br>
If you want to modify the pointer itself you can write something like this.    </p>

<pre><code>void printlist(ListNode*&amp; head)  
</code></pre>

<p>The point of getting the pointer is to avoid copying the object itself, and you get it by pointer instead of reference when the value can be nullptr.</p>
",0
29456434,29456361,1,"<p>Since your structure is non-trivial - it contains members of class type, <code>std::string</code>, which need to be initialised by calling their constructors - you can't simply allocate raw memory and pretend that contains a valid object.</p>

<p>The simplest solution is to use a type-aware dynamic array</p>

<pre><code>std::vector&lt;List&gt; l;
</code></pre>

<p>which can be resized, perserving its contents, with</p>

<pre><code>l.resize((n/S+1)*S);
</code></pre>
",0
29496552,29456361,0,"<p>Tip! Using ""new"" operator to allocate this structure will automatically create string object for each field.</p>

<pre><code>List *l=new struct List[S];
</code></pre>

<p>It fix this issue, l[n].name=""abc"" will works, but it not implements reallocation functional.</p>
",0
23555663,23555620,3,"<p>What you are referring to is called <code>Reflection</code> (function/attribute access by name). C++ by default doesn't have reflection. So probably you need to look for libraries/frameworks for that. Google ""C++ Reflection"" for that. Boost is one of the solution out there for C++ reflection/serialization.</p>
",3
23556305,23555620,4,"<p>If you don't need to use a string to reference the member then the way to do this is called ""pointer to member"":</p>

<pre><code>struct A
{
  int name;
  int value;
};

main()
{
  int A::* b = &amp;A::name; // assign ""name"" to the variable called b

  struct A test = {1,2}; // make a structure and fill it in

  return test.*b;        // use the variable called b to reference test.name
}
</code></pre>

<p>If you do need to refennce the items with a string the other way mentioned in the contents is to use a map.  That can be useful if all your members are the same type.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;

main()
{
  std::map&lt;std::string,int&gt; test; // make something that can be keyed by a string

  test[""name""]=1; // put something called ""name"" in the map with a value of 1
  test[""value""]=2; // put something called ""value"" in the map with a value of 2

  std::cout &lt;&lt; test[""name""] &lt;&lt; std::endl;

  return 0;
}
</code></pre>
",2
23587892,23587744,0,"<p>This code will work for the second diagonal:    </p>

<pre><code>for (int y = 0, x = size-1; y &lt; size; y++, x--){
        if (board[y][x] == ' '){
            count = 0;
        }else if (board[y][x] == p){
            count++;
            if (count == s)
                return true;
        }
}
</code></pre>
",1
23587785,23587744,0,"<p>Your code is overly-complicated. To test the diagonal from (0,0) to (size-1,size-1), inclusive:</p>

<pre><code>for (int z = 0; z &lt; size; ++z) {
  if (board[z][z] == ' ')
    count = 0;
  else if (board[z][z] == p) {
    ++count;
    if (count == s)
      return true;
  }
}
</code></pre>

<p>Note that you don't need a nested (2-dimensional) loop to scan a diagonal, which is essentially a 1-dimensional thing.</p>
",0
26191786,26191733,6,"<p>What you describe is called a <a href=""http://en.wikipedia.org/wiki/Digital_root"">digital root</a>. Interestingly enough, it can be computed by simply determining the remainder when dividing by 9 - whereas 0 is substituted by 9.</p>

<pre><code>unsigned digitalRoot(unsigned i)
{
    return 1 + (i-1)%9; // if i%9==0, (i-1)%9==8 and adding 1 yields 9
}
</code></pre>

<p><code>digitalRoot(185)</code> is <code>5</code> since <code>185 = 9*20 + 5</code>.</p>
",0
26191802,26191733,2,"<blockquote>
  <p>as I type into output as 25 it'll give me as an output 7.</p>
</blockquote>

<p>No, it is actually <code>8</code> (<a href=""http://ideone.com/3g6r6i"" rel=""nofollow"">demo</a>). The problem is that you initialize <code>sum</code> to <code>1</code> instead of <code>0</code>.</p>

<p>As far as making the sum a single digit goes, add another loop to your program:</p>

<pre><code>for (;;) { // Loop until the break is reached
    while(i&gt;0){
        j=i%10;
        sum=sum+j;
        i=i/10;
    }
    if (sum &lt; 10) break; // It's single digit
    i = sum;
    sum = 0;
}
</code></pre>
",1
26191836,26191733,1,"<p>You can try this:  </p>

<pre><code>while(i&gt;0){
    j=i%10;
    sum=sum+j;
    i=i/10;
    if (i == 0 &amp;&amp; sum &gt;= 10) // if all the digits of previous number is processed and sum is not a single digit 
    {
        i = sum;
        sum = 0;
    }
}
</code></pre>

<p>Note that there is no nested loop!  </p>

<p>Do not forget to initialize <code>sum</code> to <code>0</code> instead of <code>1</code>.</p>
",0
28491172,28490611,0,"<p>You can try something like this:</p>

<pre><code>bool valid = false;
while (!valid)
{
  const std::string valid_packages = ""AaCc"";
  char package;
  cin &gt;&gt; package;
  if (valid_packages.find(package) != std::string::npos)
  {
    valid = true;
  }
  else
  {
    cout &lt;&lt; ""\n""
         &lt;&lt; ""Invalid package name, try again.\n"";
  }
}
</code></pre>

<p>The valid package letters are placed into a string.  The User's input is checked against the string of valid letters.  If the User's input is found, the flag <code>valid</code> is set to true, ending the loop.</p>
",0
28490806,28490611,0,"<p>A switch can have a <code>default</code> branch which handles everything not handled in other <code>case</code> branches. You can put your code there and then put the whole <code>switch</code> in a <code>do</code> - <code>while</code> loop like this:</p>

<pre><code>bool valid;
do {
    valid = true;

    switch (package) {
    case 'A':
        ?
    default:
        valid = false;
        cout &lt;&lt; ""Invalid bla bla "" &lt;&lt; package &lt;&lt; "", enter it again"" &lt;&lt; endl;
        cin &gt;&gt; package;
        break;
    }
} while (!valid);
</code></pre>
",0
29454089,29453697,0,"<p>use <code>system(""pause"")</code> outside the loop -</p>

<pre><code>void Display(int rows, int columns, int intervals)
{
    for (int y = 1; y &lt;= rows; y++)
    {
        for (int x = 1; x &lt;= columns; x++) {
            cout &lt;&lt; intervals;
        }
        cout &lt;&lt; endl;
    }
    system(""pause"");
}
</code></pre>
",1
28174390,28174337,3,"<p>Simply </p>

<pre><code>void modify(int&amp; var) {
  if (certainConditions) {
    var++;
  }
}

int oldValue = myValue;
modify(myValue);
if (oldValue != myValue) {
   //modified
}
</code></pre>

<p>Or as @juanchopanza suggested return a bool if value is modified, then you don't have to pass a reference</p>

<pre><code>bool modify(int var) {
  if (certainConditions) {
    var++;
    return true;
  }
  return false;
}


if (modify(myValue)) {
   //modified
}
</code></pre>
",4
28174523,28174337,0,"<pre><code>//Assign the value of the variable into another one *before* invocation.
int oldValue = varValue;
//your function invocation happens here.
//NOTE: you are probably passing a reference of the integer to it.
invokeMyFunction(varValue);
//Compare the old with the current value of the variable
if(oldValue != varValue)
{
  //Code executed if value modified here.
}
</code></pre>
",0
28174472,28174337,0,"<p>What about using another variable?
It's likely that you have a tiny bit of extra memory remaining for this operation</p>

<p>Pseudocode:</p>

<pre><code>int oldvalue = yourUnknownVariable;

func(yourUnknownVariable);

if(yourUnknownVariable==oldvalue)
{
     // not modified
}
</code></pre>
",0
28174493,28174337,0,"<p>The obvious way to do this is to use a <code>bool</code> return value:</p>

<pre><code>bool modifyvar(int&amp; var)
{
    bool ret = false;
    if(condition)
    {
        var++;
        ret = true;
    }
    return ret;
}
</code></pre>

<p>If you are already returning something, you can instead return a <code>tuple&lt;T, bool&gt;</code>, modify a global variable (not recommended, but how the C library often deals with this type of problem), pass a reference to a boolean as a parameter or return a <code>struct</code> or <code>class</code> with all the relevant values if you need to return quite a few different things.</p>
",0
28174724,28174337,0,"<p>int value = 1;
cin>>""Your variable was modified"";</p>

<p>Or</p>

<p>int value =1;
//do somethings with  variable <strong>value</strong>, maybe <strong>value =2;</strong> or what you have to do.</p>

<p>if(value!=1)
cout>>""My value was modified"";
else
cout>>""My value wasn`t modified"";</p>
",0
29160384,29160220,5,"<p>The masking with AND is better since it doesn't depend on the signedness of the value.</p>
<p>But the most efficient way to take the lower 32 bit is to assign it to a 32-bit variable.</p>
<pre><code>uint64_t u = 0x1122334455667788;
uint32_t n;

n = static_cast&lt;uint32_t&gt;(u);  // 0x55667788
</code></pre>
<p>The difference to a bit-wise AND is that the CPU just takes the lower part without doing any logical operation.</p>
<p>If you have a 32-bit CPU it just ignores the upper value stored in a second register or memory place.</p>
<p>If you have a 64-bit CPU it has a single instruction to extend (unsigned) a 32 bit value to 64 bit value.</p>
",0
29160499,29160220,1,"<p>A good optimizer would generate the same code in both cases. To me this is the most straight forward method: <code>lower = some_var &amp; 0xffffffff;</code> The other form may generate unnecessary shiftage.</p>

<p>Sometimes I use union to overlap variables when I want to be absolutely sure the compiler doesn't mess things up.</p>

<p>For example:</p>

<pre><code>typedef union {
    int64 QWORD;
    int32 DWORD[2];
} overlapper64;

overlapper someVariable;
</code></pre>

<p>Then access it as:</p>

<pre><code>someVariable.QWORD;

int32 myVar32 = someVariable.DWORD[0];
</code></pre>

<p>Depending on platform/compiler the order in which the overlap occurs may vary.
Be sure to test it on your specific platform.
In C, I use a bunch of platform specific #ifdefs to control the order automatically.</p>
",0
29160513,29160220,1,"<p>Adding to what others said, based on the compiler you use the second option might be faster because <strong>if not optimized</strong>, the first option is implemented as 2 cpu instructions while the second option is one cpu instruction. That may be the reason for your observation of performance boost using the second option.  </p>
",0
29160271,29160220,7,"<p>Masking with <code>&amp;</code> is better:</p>

<ul>
<li><code>&amp;</code> is reliable for signed and unsigned <code>some_var</code>, while bitshifting right a negative number produces an implementation defined result:</li>
</ul>

<blockquote>
  <p>The value of E1 >> E2 is E1 right-shifted E2 bit positions. [...] If E1 has a signed type and a negative value, the resulting value is implementation-defined.</p>
</blockquote>

<ul>
<li>on every CPU I've ever known (Z80, 6502C, x86, 68000, UltraSparc), bitwise-AND is a single CPU instruction and takes one clock cycle... it's extremely unlikely to be slower or take more bytes of machine code than the bit-shifting approach you mention, though the compiler might optimise that to a bitwise AND anyway.</li>
</ul>

<p>The one disadvantage of masking is that it's relatively easy to accidentally have 7 or 9 <code>F</code>s, whereas a typo in <code>32</code> is obvious: there are other ways to generate the masking value though, e.g. <code>(1LL&lt;&lt;32)-1</code>, or the hackish but somehow elegant <code>uint32_t(-1)</code>.</p>

<p>Of course, if <code>lower</code> is <code>uint32_t</code> and <code>some_var</code> <code>uint64_t</code>, you can just let the conversion be implicit, so the optimiser doesn't even need to realise the bitwise-AND can be removed before assignment, but that might give you a compiler warning, which you can silence ala...</p>

<pre><code>uint32_t lower = static_cast&lt;uint32_t&gt;(some_var);
</code></pre>

<p>The masking is mainly useful when assigning to another <code>uint64_t</code>, or when the mask isn't for all the 32 least significant bits.</p>
",1
29160287,29160220,0,"<p>I think both are equally good. However using bitwise operator would be a better(<em>not sure if there is any performance difference</em>) approach as the standard says:</p>
<blockquote>
<p><strong>6.5.7 Bitwise shift operators</strong></p>
<p>4 The result of E1 &lt;&lt; E2 is E1
left-shifted E2 bit positions; vacated
bits are filled with zeros. If E1 has
an unsigned type, the value of the
result is E1 ¡Á 2E2, reduced modulo one
more than the maximum value
representable in the result type. If
E1 has a signed type and nonnegative
value, and E1 ¡Á 2E2 is representable
in the result type, then that is the
resulting value; otherwise, the
behavior is undefined.</p>
</blockquote>
",0
26207680,26207646,6,"<p>This is just the <a href=""http://www.boost.org/doc/libs/1_56_0/libs/assign/doc/index.html"">Boost.Assignment</a> library. It uses <code>operator+=</code> and <code>operator,</code> overloads to make the assignments of containers easier.</p>

<p>The syntax breakdown could be given by the <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"">operator precedence</a> table.</p>

<p>Essentially <code>input += 1</code> would return a proxy object that has <code>operator,</code> overloaded that would do the sequential insertions roughly equivalent to:</p>

<pre><code>auto x = (input += 1); // input.push_back(1);
x,2; // input.push_back(2);
x,3; // input.push_back(3);
</code></pre>

<p>This was back in C++98 when they didn't have <code>std::initializer_list</code> to directly assign the contents of a container, e.g. <code>std::vector&lt;int&gt; x = { 1, 2, 3 };</code>.</p>
",0
23847305,23846933,1,"<p>To make your code more manageable, I suggest you use function calls in your switch statement:  </p>

<pre><code>  switch (selection)  // ""enter"" is such a bad name.
  {
    case 'a':
      Add_Student();
      break;
    case 'b':  
      Remove_Student();
    //...
    default:
      cout &lt;&lt; ""Invalid menu selection, try again.\n"";
      break;
  }
</code></pre>

<p>This simplification (for easy reading) leads to the following table driven menu system:  </p>

<pre><code>// Declare a function pointer syntax
typedef void (*Function_Pointer)(void);

struct Menu_Entry
{
  char             selection_char;
  Function_Pointer menu_function;
};

// The table
const Menu_Entry First_Menu[] =
{
  {'a', Add_Student}, // A selection entry
  {'b', Remove_Student},
  //...
};
const unsigned int Number_Of_Selections =
  sizeof(First_Menu) / sizeof(First_Menu[0]);

// The lookup engine
char selection;  // This you input from user.
for (unsigned int i = 0; i &lt; Number_Of_Selections; ++i)
{
  if (selection == First_Menu[i].selection_char)
  {
    // Execute the function associated with the selection
    First_Menu[i].menu_function();
    break;
  }
}
</code></pre>

<p>An advantage to the table system is that you can easily add a menu selection item by:</p>

<ol>
<li>Creating a function to perform the selection.</li>
<li>Adding a <code>Menu_Item</code> entry to the table.</li>
</ol>

<p>That's it.  Quite simple.  </p>

<p>Which allows you to get the menu selection process working for one selection, then work on another; piece by piece.  </p>

<p>By placing the functions in separate files, you only need to compile the lookup table source and the new selection source files.  All the other code remains untouched.  Much faster build times.  </p>
",0
28511595,28511265,0,"<p>First:
You do not have a constructor declared or defined in your class so when you compile, the compiler provides you with a default constructor.    </p>

<p>The line</p>

<pre><code> PlayerProfile player; 
</code></pre>

<p>calls the default constructor provided by the compiler. This default constructor only allocates memory for your class member variables, but does not set their values.  This is why name1, pass1, exp1, x1, y1 are not outputting what you expect.</p>

<p>Second:
C++ will not call get or set functions for you, and I think you are misunderstanding how c++ functions work.</p>

<p>this</p>

<pre><code>void PlayerProfile::setName1(string newName1)
{
     name1 = newName1;
}
</code></pre>

<p>is a function definition.  You do not need to assign newName1 inside the function.  It's value is passed to the function when a line like</p>

<pre><code>setName1(""Nematocyst"");
</code></pre>

<p>is executed.</p>

<p>If you write a constructor, you can use it to call your set functions, and pass them the values you want to set member variables to.</p>

<p>If you do not want to write a constructor, you can call class functions/methods from main with:</p>

<pre><code>player.setName1(""Nematocyst"");
</code></pre>

<p>Third:
Your program crashes because you are not using arrays properly.  <a href=""http://www.cplusplus.com/doc/tutorial/arrays/"" rel=""nofollow"">Here is a tutorial</a> on how to declare an array and access it's contents.</p>

<p>Generally, I think you are trying to run before you know how to walk.  Try not to get frustrated.  Learn how arrays work, how functions work, and then how classes work.  I hope this is not your homework assignment!</p>
",0
26225947,26225936,1,"<p>Max does not take three arguments in the way you think it does.</p>

<pre><code>double d=max(max(abs(a), abs(b)), abs(c));
</code></pre>
",1
26225963,26225936,5,"<p>The only overload of <code>std::max</code> with three arguments is used to give the larger of the first two, interpreting the third as a comparison function to use instead of <code>&lt;</code> to compare the values. It doesn't give the largest of three values.</p>

<p>To get the largest of three values, use the overload that takes an initialiser list:</p>

<pre><code>double d=max({abs(a), abs(b), abs(c)});
             ^                      ^
</code></pre>

<p>Or, if you're stuck in a pre-C++11 world, call the overload for two values twice:</p>

<pre><code>double d=max(abs(a), max(abs(b), abs(c)));
                     ^^^^              ^
</code></pre>
",0
26226011,26225936,0,"<p>@GWW is correct but if you are using a C++ 11 compiler, there is a new variadic variation - you just need to supply an initializer list with multiple args instead of multiple args:</p>

<pre><code>void new_doubles(double a, double b, double c)
{
    double d = max( { abs(a), abs(b), abs(c) } );
    cout &lt;&lt; d;
}
</code></pre>
",0
26211013,26210888,0,"<p>When you have a function,</p>

<pre><code>Method(A a, A b);
</code></pre>

<p>You have lost the <code>B</code> part of the objects due to object slicing.</p>

<p>If you want retain the <code>B</code> part of the objects, you have to use references or pointers.</p>

<pre><code>Method(A const&amp; a, A const&amp; b);
</code></pre>

<p>or</p>

<pre><code>Method(A const* a, A const* b);
</code></pre>

<p>In order for <code>Method</code> to work correctly, you have to provide a way for the objects to be treated as <code>B</code>. You can use that using a <code>virtual</code> function in <code>A</code>.</p>

<pre><code>class A
{
    public:
    int x;
    virtual int compare(A const&amp; rhs) const
    {
        return (this-&gt;x - rhs.x);
    }
};
</code></pre>

<p>and make sure to override the function in <code>B</code>.</p>

<pre><code>template &lt;class T&gt;
class B : public A
{
    public:
    T y;
    virtual int compare(A const&amp; rhs) const
    {
       // Use the base class first.
       int r = A::compare(rhs);

       // If the base class result is adequate, return.
       if ( r != 0 )
       {
          return r;
       }

       // Do a dynamic_cast of the rhs.
       B const* rhsPtr = dynamic_cast&lt;B const*&gt;(&amp;rhs);

       // If the dynamic_cast didn't succeed, need
       // to figure out how to handle the case.
       if ( rhsPtr == nullptr )
       {
          // Add error handling code
       }

       return (this-&gt;y - rhsPtr-&gt;y);
    }
};
</code></pre>

<p>Then, in <code>Method</code>,</p>

<pre><code>Method(A const&amp; a, A const&amp; b)
{
   int r = a.compare(b);
}
</code></pre>
",4
26211017,26210888,0,"<p>A possible solution is to create a virtual function that will do the comparison.</p>

<p>Inside the body of the implementation in the derived class the type <code>T</code> is known and you'll have no problems.</p>

<pre><code>struct Base {
  ...
  virtual bool same_y(const Base&amp; other) const = 0;
};

template&lt;typename T&gt;
struct Derived : Base {
    T y;
    virtual bool same_y(const Base&amp; other) const {
        return dynamic_cast&lt; const Derived&lt;T&gt;&amp; &gt;(other).y == y;
    }
};
</code></pre>
",1
26211058,26210888,0,"<p>You could define <code>Method</code> as a template method. </p>

<pre><code>template&lt;typename T&gt;
bool Method(const A&amp; a, const A&amp; b)
{
    const B&lt;T&gt;&amp; first = dynamic_cast&lt;const B&lt;T&gt;&amp;&gt;(a);
    const B&lt;T&gt;&amp; second = dynamic_cast&lt;const B&lt;T&gt;&amp;&gt; (b);
    return first.y == second.y;
}
</code></pre>

<p>With this approach you don't have to know the type of <code>T</code> inside <code>Method</code>. But you have to specify <code>T</code> when you call it:</p>

<pre><code>bool areEqual = Method&lt;int&gt;(a, b);
</code></pre>

<p>Maybe that is no problem in your case.</p>

<p>Be aware that whenever you assign a <code>B&lt;T&gt;</code> to a variable of type <code>A</code> you are loosing the information that is specific to <code>B&lt;T&gt;</code> (in this case the value of <code>y</code> is lost). That's why I changed the signature of <code>Method</code> in order to take references instead of values.</p>
",2
23592919,23592726,2,"<p>You have declared t as a const reference of type Tauler in your disparap2 function. So if you index it, you get a <code>const vector&lt;bool&gt;</code>. If you index that one, you get a const reference, to which you cannot assign. </p>
",1
27155418,26838197,0,"<p>I have the same problem, for me the problem is that my bug tracker track this bug wrong.</p>

<p>The real bug is this:</p>

<p><code>*** -[UIViewAnimationState release]: message sent to deallocated instance 0x1c4c5ab0</code></p>

<p>I'm following <a href=""https://stackoverflow.com/questions/26656342/uiwebview-random-crash-at-uiviewanimationstate-release-message-sent-to-deallo"">this thread</a></p>

<p>hope this can help you.</p>
",0
24125889,24125703,1,"<p>C++07 is plenty up to date - most of the stuff you learn as a beginner should be doable in C++98 - a lot of the new stuff added is not critical to functionality - the new stuff is typically just things to make life a tad easier when doing more complicated things. But for 99.99% of the stuff you could ever do in C++, it is doable in C++03 just as well as C++11.</p>
",3
24125772,24125703,3,"<p>No it is definitly not a problem, you see, learning your first programming language can almost be anything. It is just the way of thinking which you have to learn. </p>

<p>I've been teached C at the university, but learning Java took one night (Yes I had to try for an assignment). Even learning an old cpp standard is not wasted time, almost no basic things have changed since then (mostly some very advanced stuff). So just start the tutorial and try a lot yourself!! Doing things instead of learning helps a lot for understanding</p>

<p>And most of all, be creative, try small programs yourself. Write test programs if you wonder about certain things!! For questions you can always create a Stackoverflow thread!</p>

<p>Good luck</p>
",0
31861455,31861302,0,"<p>For example the following way</p>

<pre><code>Clock clock( /*...*/, ClockTime( h, m, s, t ), /*...*/ );
</code></pre>

<p>or the following way</p>

<pre><code>Clock clock( /*...*/, { h, m, s, t }, /*...*/ );
</code></pre>

<p>where h, m, s, t some arguments for the constructor ClockTime.</p>

<p>Or you can use the default constructor of class ClockTime</p>

<pre><code>Clock clock( /*...*/, ClockTime(), /*...*/ );
</code></pre>
",2
31861476,31861302,0,"<p>This <code>const&amp;</code> just means that function will not modify your <code>Clocktime</code> object. It doesn't actually affect the ways you pass the argument. So the following will work:</p>

<pre><code>ClockTime t;
Clock c(..., t, ...);
</code></pre>
",0
32467350,32467263,0,"<p>When you try to read an integer but pass something else, the reading fails and the stream becomes invalid. Whatever caused the error remains in the stream. This leads to infinite loop.</p>

<p>To fix that, clear the error flags and ignore the rest of the line in your else clause:</p>

<pre><code>    else
    {
        cout&lt;&lt;""You have only 3 options. Please chooses 1,2 or 3""&lt;&lt;endl;
        cin.clear(); // remove error flags
        // skip until the end of the line
        // #include &lt;limits&gt; for std::numeric_limits
        cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
    }
</code></pre>
",1
32467351,32467263,0,"<p>You can modify it like this:</p>

<pre><code>int displayMenu()
{
    while(true)
    {  
        cout&lt;&lt;""Please choose one of following options""&lt;&lt;endl;
        cout&lt;&lt;""1. deposit""&lt;&lt;endl;
        cout&lt;&lt;""2. withdraw""&lt;&lt;endl;
        cout&lt;&lt;""3. exit""&lt;&lt;endl;
        char input = cin.get();  //read a character

        cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');  //skip the rest of characters in cin buffer so that even if a user puts ""123"" only the first one is taken into account

        if(input&gt;='1' &amp;&amp; input&lt;='3' &amp;&amp; cin)  //check whether this is '1', '2' or '3'
        {
            return input;
            break;
        }
        else
        {
            cout&lt;&lt;""You have only 3 options. Please chooses 1,2 or 3""&lt;&lt;endl;
        }
    }
}
</code></pre>
",3
23602444,23602443,1,"<p>Just iterate through the vector containing the vectors, keeping track of the largest one through e.g. a pointer. For example:</p>

<pre><code>unsigned int largestSize = 0;
vector&lt;int&gt;* largestVect = 0;

for(unsigned int i=0; i&lt;vAllvects.size(); ++i) {
    if(vAllvects[i].size() &gt; largestSize) {
        largestSize = vAllvects[i].size();
        largestVect = &amp;vAllvects[i];
    }
}
</code></pre>

<p>Now you have a pointer to the largest vector.</p>
",2
23602491,23602443,4,"<p>There are usually standard library algorithms for this kind of thing. In this case, you can use <a href=""http://en.cppreference.com/w/cpp/algorithm/max_element"" rel=""nofollow""><code>std::max_element</code></a> with a suitable binary predicate:</p>

<pre><code>auto max_iterator = std::max_element(std::begin(vAllvects),
                                     std::end(vAllvects),
                                     [](const std::vector&lt;int&gt;&amp; lhs,
                                        const std::vector&lt;int&gt;&amp; rhs)
                                     {
                                       return lhs.size() &lt; rhs.size();
                                     });
</code></pre>

<p>Here, <code>max_iterator</code> it an iterator to largest vector, or the first one of them if more than one have the largest size.</p>
",0
26133109,26133094,3,"<pre><code>vector&lt;A*&gt; *children;
</code></pre>

<p><code>children</code> is a pointer to <code>vector</code>, not a <code>vector</code>. Hence <code>a-&gt;children-&gt;</code> dereferences uninitialized pointer, causing undefined behavior.</p>

<p>You may try</p>

<pre><code>vector&lt;A*&gt; children;
....
a-&gt;children.push_back(b);
</code></pre>

<p><strong>P.S.</strong> Please pay attention to the memory leaks caused by <code>new</code>s without <code>delete</code>s.</p>
",0
26787727,26787373,0,"<p>There's too many problems with your code to give a simple answer. It's maybe easier to work backwards from working code. You haven't fully specified the problem but this was my best guess at what you're trying to do:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;int&gt; toInts(const string&amp; s) {
    vector&lt;int&gt; v(s.size());
    transform(cbegin(s), cend(s), begin(v), [](int c) { return c - '0'; });
    return v;
}

int main() {
    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    auto n = toInts(a);
    auto m = toInts(b);
    const auto size = max(n.size(), m.size());
    n.resize(size);
    m.resize(size);
    vector&lt;int&gt; sums(size);
    transform(cbegin(n), cend(n), cbegin(m), begin(sums), plus&lt;&gt;{});
    copy(cbegin(sums), cend(sums), ostream_iterator&lt;int&gt;{cout, "", ""});
    cout &lt;&lt; endl;
}
</code></pre>
",0
26801436,26801296,2,"<p>Because <code>beta</code> is a pointer to <code>int</code>, but <code>callbyreference</code> doesn't take a pointer parameter - it takes a reference.<br>
References are not pointers.</p>

<p>You can say either</p>

<pre><code>void callbyreference (int* adam) {
    cout &lt;&lt; *adam &lt;&lt; endl;
}

int main() {
    int *beta = new int();
    *beta = 34;
    callbyreference(beta);
}
</code></pre>

<p>or</p>

<pre><code>void callbyreference (int&amp; adam) {
    cout &lt;&lt; adam &lt;&lt; endl;
}

int main() {
    int beta = 34;
    callbyreference(beta);
}
</code></pre>
",0
26801655,26801296,0,"<pre><code>void callbyreference (int&amp; adam) {
    cout &lt;&lt; adam &lt;&lt; endl;
}

int main() {
   int *beta = new int();
   *beta = 34;
   callbyreference(*beta);
}
</code></pre>
",1
26808034,26807939,1,"<p>They will probably be in a dock window called ""build"". Like all other IDEs, you may need to use the menu to open that window first. If the window is already open, scroll up.</p>

<p>The build dock window is the one at the bottom, in this screenshot:
<img src=""https://i.stack.imgur.com/CXRQy.png"" alt=""enter image description here""></p>
",7
29239250,29238954,1,"<blockquote>
  <ol>
  <li>what is the need of having an enum type instead of using <code>&lt;template typename&gt;</code></li>
  </ol>
</blockquote>

<p>Templates can be parametrised by three kinds of thing:</p>

<ul>
<li>Types </li>
<li>Non-types (which basically means constant values)</li>
<li>Other templates.</li>
</ul>

<p>In this case, it's parametrised by a constant value of type <code>T_Thread</code>. So <code>SBatch&lt;EA&gt;</code> and <code>SBatch&lt;EB&gt;</code> are two specialisations of the template, with a different ""thread"" value for each.</p>

<blockquote>
  <ol start=""2"">
  <li>why am I getting a compilation error</li>
  </ol>
</blockquote>

<p>Because the base-class initialiser is wrong; it must supply constructor arguments:</p>

<pre><code>SBatch&lt;Thread&gt;::SBatch(size_t max) : ParentClass&lt;Thread&gt;(args)
                                                        ^^^^^^
</code></pre>

<p>If you want it to be default-initialised, with no constructor arguments, then either give an empty argument list, <code>()</code>, or leave the initialiser out altogether.</p>
",0
29239189,29238954,2,"<blockquote>
  <ol>
  <li>what is the need of having an enum type instead of using <code>&lt;template typename&gt;</code></li>
  </ol>
</blockquote>

<p>It's just a <a href=""http://en.cppreference.com/w/cpp/language/template_parameters"" rel=""nofollow"">non-type parameter</a>.</p>

<blockquote>
  <ol start=""2"">
  <li><p>why am I getting a compilation error on</p>

<pre><code>SBatch&lt;Thread&gt;::SBatch(size_t max) : ParentClass&lt;Thread&gt;
</code></pre></li>
  </ol>
</blockquote>

<p>It's likely you forgot the parentheses. </p>

<pre><code>SBatch&#x3C;Thread&#x3E;::SBatch(size_t max) : ParentClass&#x3C;Thread&#x3E;<b>()</b></code></pre>
",0
29953414,29953340,3,"<p><code>Vehicle(int, enum, enum, int);</code></p>

<p>This is incorrect, you should be using the name of the enum type you want (in this case <code>street</code> and <code>direction</code> <em>not</em> the keyword <code>enum</code>.</p>

<p>Same goes for those member variables (thanks to @Unda for noticing).</p>
",4
29956127,29955920,1,"<p>It looks like <code>ImageFramework</code> class has a member called <code>main</code>. So the macro <code>#define main ace_main_i ...</code> expands and gives the error.</p>
",1
28246110,28246076,4,"<p>First of all, what is <code>i</code>? And secondly, when you use array-indexing of a <code>std::string</code> object, you get a <em>character</em> (i.e. a <code>char</code>) and not a string.</p>

<p>The <code>char</code> is converted to an <code>int</code> and then the compiler tries to compare that <code>int</code> with the pointer to the string literal, and you can't compare plain integers with pointers.</p>

<p>You <em>can</em> however compare a character with another character, like in</p>

<pre><code>arrey[i] == '\t'
</code></pre>
",2
28246141,28246076,1,"<p><code>std::string::find()</code> might help.</p>

<p>Try this:</p>

<pre><code>...
if(arrey.find('\t') != string::npos)
{
    std::cout &lt;&lt; ""I found a tab!!!!"";
}
</code></pre>

<p>More info on <code>std::string::find</code> is available <a href=""http://www.cplusplus.com/reference/string/string/find/"" rel=""nofollow"">here</a>.</p>
",0
28246147,28246076,1,"<p>Why not using what C++ library provides? You could do it like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
  string arrey;
  getline(cin, arrey);
  if (arrey.find(""\t"") != std::string::npos) {
      std::cout &lt;&lt; ""found a tab!"" &lt;&lt; '\n';
  }
  return 0;
}
</code></pre>

<p>The code is based on <a href=""https://stackoverflow.com/a/2340309/2411320"">this</a> answer. Here is the ref for <a href=""http://www.cplusplus.com/reference/algorithm/find/"" rel=""nofollow noreferrer"">std::find</a>.</p>

<hr>

<p>About your edit, how are sure that the input is going to be 10 positions? That might be too little or too big! If it is less than the actual size of the input, you won't look all the characters of the string and if it is too big, you are going to overflow!</p>

<p>You could use <code>.size()</code>, which says the size of the string and use a for loop like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  string arrey;
  getline(cin, arrey);
  for(unsigned int i = 0; i &lt; arrey.size(); ++i) {
    if (arrey[i] == '\t') {
      std::cout &lt;&lt; ""I found a tab!!!!"";
    }
  }
  return 0;
}
</code></pre>
",0
26209768,26209732,2,"<p>The compiler compiles the function, however your map won't be populated unless its called.</p>

<p>Because <code>funcList[#x] = x;</code> comes inside the function block <code>{ }</code> after macro expansion.</p>
",2
26209792,26209732,5,"<p>The problem is that the code to register the function is inside the function, so won't happen unless you call the function. You might instead register it by initialising a global variable, which will happen automatically before <code>main</code> begins. This might look something like</p>

<pre><code>struct funcRegistration {
    funcRegistration(char * name, funcPointer func) {funcList[name] = func;}
};

#define Function(x) \
    void x(); \
    funcRegistration x##_registration(#x, x); \
    void x() {
</code></pre>
",1
31280695,31280587,1,"<p>The format of your code is awful please make it better so we can help you. </p>

<p>However from what I'm seeing the problem is that your functions are not defined when you try to call them. Before your main give the prototype of your functions and then you c an implement them even after the main function. </p>

<p>EDIT: from what I'm seeing there may be one missing } at the end of your main function which therefore will make your other functions implementations somehow ""nested"" ( don't know if that's the word to use here ). Yet I am not sure about that as your formatting is not good at all and your code is therefore not really readable. </p>

<p>Hope it helps. </p>
",4
31280733,31280587,6,"<p>Other than missing a parenthesis (<code>}</code>) at the end of main, you shouldn't have semicolons in your function definitions:</p>

<pre><code>double getLength(); &lt;-- should not be there
{
    ....
}
</code></pre>
",1
26776270,26774562,0,"<p>There are a couple of problems with the provided code.  The main issues is in 'scan(...)', where you're incremeneting the 'beg' iterator twice each time around the loop, once in the for() construct:</p>

<pre><code>for (auto beg = target.begin(); beg != target.end(); ++beg)
</code></pre>

<p>and once at the end of the for loop:</p>

<pre><code>++iter;
++beg;
</code></pre>

<p>A couple of minor points in the scan(...) function would be to pass 'target' as a reference (const std::string&amp; target), and return false/true, not 0/1.</p>

<p>I checked this on Ubuntu 12.04 using g++-4.8, and that seems to use the c++98 definition for insert, which doesn't return an interator (i.e. the function is ""void insert (iterator p, InputIterator first, InputIterator last);"").... Here's the code modified slightly to work around this problem:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

bool scan(const std::string&amp;, const std::string::iterator);

//replaces occurrences of oldVal in s with newVal
std::string&amp; replace (std::string &amp;s, const std::string &amp;oldVal, const std::string &amp;newVal)
{
    std::string::iterator iter = s.begin();
    while (iter != s.end()) { //process s
        if (scan(oldVal, iter)) { //Checks if characters match
            iter = s.erase(iter, iter + oldVal.size()); //deletes occurrence of oldVal
            // Doesn't work on g++4.8 on Ubuntu, still seems to use the c++98 ""void insert (iterator p, InputIterator first, InputIterator last);""
            //iter = s.insert(iter, newVal.begin(), newVal.end()); //inserts newVal in oldVal's place

            // If the iter == s.end(), then pos will not be the value we need.
            size_t pos = iter == s.end()? s.size() : std::distance(s.begin(), iter);
            s.insert(iter, newVal.begin(), newVal.end()); //inserts newVal in oldVal's place
            iter = s.begin() + pos;
            iter = iter + newVal.size(); //continues processing after inserted newVal
        }
        else
            ++iter; //Move to next character in s to process
    }
    return s;
}

//This function returns 1 if the strings match and 0 if they do not
bool scan(const std::string&amp; target, std::string::iterator iter)
{
    for (auto beg = target.begin(); beg != target.end(); ++beg) {
        std::cout &lt;&lt; ""Line 27 "" &lt;&lt; *iter &lt;&lt; "" "" &lt;&lt; *beg &lt;&lt; std::endl; //MAIN CONCERN! This line is run twice.
                                                                      //(It was solely added for debugging. Verifies values being compared)
        if (*iter != *beg) {
            std::cout &lt;&lt; ""Condition met; ""
                      &lt;&lt; *iter &lt;&lt; "" != "" &lt;&lt; *beg &lt;&lt; std::endl; //added for debugging. Double verifies values post-comparison
            return false;
            }
        ++iter;
    }

    return true;
}

int main()
{
    std::string mainStr, oldStr, newStr;
    std::getline(std::cin, mainStr); //Overall it'd be better for s to be a list of strings, but my concern is with line 27
    std::cin.clear();
    std::cin &gt;&gt; oldStr &gt;&gt; newStr;
    std::cout &lt;&lt; ""Output: "" &lt;&lt; replace(mainStr, oldStr, newStr) &lt;&lt; std::endl; //Prints post-replacement string
}
</code></pre>
",1
26775329,26774562,1,"<p>One bug that I found: In <code>scan()</code> the <code>beg</code> iterator is increased twice in each iteration, due to <code>++beg</code> in <code>for(...)</code> loop line and <code>beg++</code> at the end of the loop.</p>
",0
23844156,23844111,3,"<p><code>char</code> might be (and in your case apparently is) a signed type wit a range from -128 to +127.
So <code>char ch = 255</code> triggers an overflow which yields an implementation defined result for signed types.</p>
",0
23844166,23844111,4,"<p><code>char</code> by default may be signed or unsigned. (implementation dependent)</p>

<p>Minimum range of signed char is -127 to 127 (typically -128 to 127).</p>

<p>If by default char is signed, ch would not be able to accommodate 255(0xFF) and would silently convert it to -1(0xFF). Then you are typecasting it to int and printing so the output is -1.</p>

<p>To avoid this use <code>unsigned char</code> explicitly. (Range is atleast 0 to 255)</p>

<p><strong>4.7  Integral conversions [conv.integral]</strong></p>

<blockquote>
  <p>[3] If the destination type is signed, the value is unchanged if it can
  be represented in the destination type (and bit-field width); 
  otherwise, the value is implementation-defined.</p>
</blockquote>
",4
23818189,23818087,0,"<p>Maybe don't overthink this and keep it simple:</p>

<pre><code>template &lt;typename T, typename Converter&gt;
class MyClass
{
    T value;
    Converter converter;

public:
    explicit MyClass(T const &amp; v, Converter const &amp; c = Converter())
    : value(v), converter(c)
    { }

    template &lt;typename U, typename C = Converter&gt;
    operator MyClass&lt;U, C&gt;() const
    {
        return converter.template convert&lt;U, C&gt;(*this);
    }
};
</code></pre>

<p>Your converter needs to look like this:</p>

<pre><code>struct ExampleConverter
{
    template &lt;typename U, typename C1, typename T, typename C2&gt;
    MyClass&lt;U, C1&gt; convert(MyClass&lt;T, C2&gt; const &amp;) const;
};
</code></pre>

<p>With a little bit more effort, you could take advantage of base class layout optimizations (in the same way that standard library implementations usually take care of allocators and comparators).</p>

<hr>

<p>You could also have some rebind mechanic to allow the converter to be itself a template.</p>

<pre><code>template &lt;typename T, typename Converter = StandardConverter&lt;T&gt;&gt;
class MyClass
{
    T value;
    Converter converter;

public:
    explicit MyClass(T const &amp; v, Converter const &amp; c = Converter())
    : value(v), converter(c)
    { }

    template &lt;typename U,
              typename C = typename Converter::template rebind&lt;U&gt;::type&gt;
    operator MyClass&lt;U, C&gt;() const
    {
        return converter.template convert&lt;U, C&gt;(*this);
    }
};

template &lt;typename T&gt;
struct StandardConverter
{
    template &lt;typename U, typename C&gt;
    MyClass&lt;U, C&gt; convert(MyClass&lt;T, StandardConverter&lt;T&gt;&gt; const &amp;) const;

    template &lt;typename U&gt; struct rebind { using type = StandardConverter&lt;U&gt;; };
};
</code></pre>
",0
23818195,23818087,0,"<p>I suggest you to use a policy-classes approach: Your class template is parametrized with the two conversion policies</p>

<pre><code>template&lt;typename T,
         typename FROM,
         typename TO
        &gt;
class MyClass
{
    FROM from_t_conversion;
    TO   to_t_conversion;

    MyClass() = default;

    template&lt;typename U&gt;
    operator U() const
    {
        return from_t_conversion( *this );
    }

    template&lt;typename U&gt;
    MyClass( const U&amp; u ) : MyClass()
    {
        std::swap( *this , to_t_conversion( u ) );
    }
};
</code></pre>

<p>The point of this design is the type (form) of a conversion policy: A conversion policy could be any callable entity with the expected signature: A function, a functor, a lambda, etc.</p>

<p><strong>EDIT:</strong> Here is an example of converters:</p>

<pre><code>struct float_to_int
{
    MyClass&lt;itn&gt; operator()( const MyClass&lt;float&gt;&amp; )
    {
        return MyClass&lt;int&gt;{};
    }
};

//A more generic conversion function:
template&lt;typename T&gt;
struct generic_to_converter
{
    template&lt;typename U , typename X = T&gt;
    MyClass&lt;X&gt; operator()( const MyCLass&lt;U&gt;&amp; )
    {
        return /* something /*
    }
};
</code></pre>
",4
31287409,31287334,0,"<p>Since this works on blocks, it's not directly possible to rewrite on functions. You'd need to change every usage, unfortunately.</p>

<p>If <code>DO_ALL_BLOCK_IP</code> was a function, this wouldn't compile.</p>

<pre><code>DO_ALL_BLOCK_IP(x)
{
    // stuff
}
</code></pre>

<p>What you can do instead is to just use Standard Library Algorithms or range-for loop (possibly using a lambda).</p>
",0
31287538,31287334,3,"<p>Not directly - the syntax <code>DO_ALL_BLOCK_IP(iter) {/* code here */}</code> is not valid if <code>DO_ALL_BLOCK_IP</code> is a function.</p>

<p>You could use the new C++ range for syntax, as long as you don't need to use the iterator directly (only the values):</p>

<pre><code>for(auto&amp; value : m_block_ip)
{
    // code here
}
</code></pre>

<p>If you <em>must</em> use a function for some reason, you could pass it a functor, and use a lambda expression to define that:</p>

<pre><code>// definition (assuming m_block_ip is a vector of block_ip_t)
void DO_ALL_BLOCK_IP(std::function&lt;void(std::vector&lt;block_ip_t&gt;::iterator)&gt; f) {
    for(auto iter = m_block_ip.begin(); iter != m_block_ip.end(); iter++)
        f(iter);
}

// alternate definition that *may* be more efficient, but also more cumbersome
template&lt;class F_CLASS&gt; void DO_ALL_BLOCK_IP(F_CLASS f) {
    for(auto iter = m_block_ip.begin(); iter != m_block_ip.end(); iter++)
        f(iter);
}

// how to call
DO_ALL_BLOCK_IP([&amp;](std::vector&lt;block_ip_t&gt;::iterator iter) {
    // code here
});
</code></pre>
",0
31287546,31287334,1,"<p>Your macros are basically a prefix for some code that will do something for each iterator in a range. While you can't do <em>exactly</em> the same using functions, the function <a href=""http://en.cppreference.com/w/cpp/algorithm/for_each"" rel=""nofollow""><code>std::for_each</code></a> already pretty much does this; with lambda functions, it can look like this:</p>

<pre><code>std::for_each(nums.begin(), nums.end(), 
    [](int &amp;n){ 
        // Doing something with an element of nums
        // and maybe something else
        // In a block that looks pretty much like you would
        // use with your macro.
        // Note that instead of continue, you'd use return, though.
    });
</code></pre>
",1
33034631,33033944,0,"<p>Try this code. And get the idea for this</p>

<pre><code>#include &lt;iostream&gt;    
#include &lt;string&gt;
#include &lt;array&gt;

int main() {
    std::array&lt;std::string, 3&gt; commands{ ""cmds"",""test"",""test2"" };

    std::cout &lt;&lt; ""To see a list of commands type 'cmds' and press enter\n"" &lt;&lt; std::endl;
    std::string input;
    std::cin &gt;&gt; input;

    if (input == ""cmds"") {
        for (int i = 0; i &lt; commands.size(); i++) {
            std::cout &lt;&lt; commands[i] &lt;&lt; std::endl;
        }
    }
    else {
        if (input == ""test"")
        {
            printf(""This is a test"");
        }
    }
    return 0;
}
</code></pre>
",1
26426996,26426790,0,"<p>In the comment of the assignment there is written</p>

<blockquote>
  <p>Define an enumerated datatype <strong>Language</strong></p>
</blockquote>

<p>So you have to use name <code>Language</code> instead of <code>language</code>.</p>

<p>In your program you defined two enumerations with the same name, The last declaration within function main hides the declaration with the same name in the global namespace, It is obvious that there is no need to define two enumerations. One of them you may remove.</p>

<p>You could write for example</p>

<pre><code>#include &lt;iostream&gt;

enum Language { german, english, spanish, turkish };

int main() 
{ 
    /* Define a varaible lang of type Language */ 
    Language lang; 

    /* Set the varaible lang with the value german */ 
    lang = german; 

    /* Write a statement to print the value of the varaible lang */ 
    std::cout &lt;&lt; lang &lt;&lt; std::endl;

    /* Change the value of the varible lang to turkish */ 
    lang = turkish; 
}
</code></pre>

<p>You may add an output statement after changing variable lang.</p>

<pre><code>//...
    /* Change the value of the varible lang to turkish */ 
    lang = turkish; 

    std::cout &lt;&lt; lang &lt;&lt; std::endl;
}
</code></pre>
",0
26425947,26425892,0,"<p>well, segmentation error arises from you trying to access memory addresses not assigned to you ... as w hot-fix to avoid the error add this function to your code</p>

<pre><code>void foo( ColorComponent* cc )
{
 if( ! ( cc-&gt;data = new unsigned char[cc-&gt;width * cc-&gt;height]))
 {
   fprintf(stderr, ""\nERROR: memory allocation failed!\n\n"");
   exit(-1);
 }
}
</code></pre>

<p>and change these lines </p>

<pre><code>void makeAFrame( YuvFrame* f, int width, int height )
{
 f-&gt;lum.width = width;    f-&gt;lum.height  = height;     
 f-&gt;cb .width = width/2;  f-&gt;cb .height  = height/2;    
 f-&gt;cr .width = width/2;  f-&gt;cr .height  = height/2;   
}
</code></pre>

<p>to </p>

<pre><code>void makeAFrame( YuvFrame* f, int width, int height )
{
 f-&gt;lum.width = width;    f-&gt;lum.height  = height;    
 foo( &amp;f-&gt;lum );
 f-&gt;cb .width = width/2;  f-&gt;cb .height  = height/2;
 foo( &amp;f-&gt;cb  );
 f-&gt;cr .width = width/2;  f-&gt;cr .height  = height/2;   
 foo( &amp;f-&gt;cr  );
}
</code></pre>

<p>things should work now</p>
",0
26434089,26433947,1,"<p>There are so many mistakes in your code. I don't understand your logic, but you can do this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main ()
{
    // checking number starting from 10
    int n = 10;
    bool isPrime;

    // as long as the number is less than or equal to 200
    while(n &lt;= 200) {

        // assume the number is prime
        isPrime = true;

        // since prime number is the number that can only be divided by 1 and itself,
        // check if this number can be divided by any number other than 1 or itself
        for (int i = 2; i &lt; n; i++) {
            // if this number can be divided by any number other than 1 or itself,
            if (n%i == 0) {
                // then this is not a prime number, no need to check anymore
                isPrime = false;
                break;
            }
        }

        if (isPrime == true) {
            cout &lt;&lt; n &lt;&lt; endl;
        }

        // check the next number
        n++;
    }
}
</code></pre>
",2
29450494,29450465,6,"<p>Functions are never ""constant"". Non-static member functions can be <code>const</code>. That doesn't mean they can't be overridden.</p>

<p>A <code>const</code> member function is one that you are allowed to invoke on a <code>const</code> object, and it must not modify the object's non-mutable members or call non-<code>const</code> member functions on the same object. A <code>const</code> virtual function can be overridden by a <code>const</code> function with the same name and parameter types in a derived class.</p>

<p>A function that cannot be overridden is marked <code>final</code>. This is orthogonal to <code>const</code>ness.</p>
",2
29450526,29450465,1,"<p>The <code>const</code> modifier means the object is not modified by the method and the <code>this</code> pointer is <code>const</code>. Nevertheless, <code>mutable</code> members remain modifiable.</p>
",0
32995006,32994827,3,"<blockquote>
  <p>isn't there any predefined symbol or equivalent that could help us here?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>you have to create a deafult iterator to be able to know if the iterator has reach end-of stream</p>
</blockquote>

<p>Here it is!</p>

<blockquote>
  <p>Why doesn't the iterator has a function named, i.e. hasNext() or isEndOfStream()</p>
</blockquote>

<p>The singular iterator as sentinel is actually quite elegant. It doesn't introduce any new names into the library, and it allows us to write generic code with <code>start</code> and <code>end</code> iterators that doesn't care what kind of thing you're iterating over. That's really important for the standard algorithms.</p>

<pre><code>void bar(const char c);

template &lt;typename Iterator&gt;
void foo(Iterator start, Iterator end)
{
   for (Iterator it = start; it != end; ++it)
      bar(*it);
}

void version_1()
{
   std::istreambuf_iterator&lt;char&gt; start(std::cin);
   std::istreambuf_iterator&lt;char&gt; end;
   foo(start, end);
}

void version_2()
{
   std::vector&lt;char&gt; v{0,1,2,3,4,5};
   foo(v.begin(), v.end());
}
</code></pre>

<p>Imagine if for containers you had <code>start</code> and <code>end</code>, but for streams you had <code>start</code> and a call to <code>start.hasNext()</code>? Now, that's not very elegant. <em>That's</em> messy!</p>
",2
30142222,30142066,5,"<p>Completely wrong. Header files are to be included in cpp files. Cpp files are never included in anything. Typically, header files hold declarations, and cpp files hold definitions.</p>
<p>If your program consists of two cpp files, you do not include one in the other. Instead, you compile them together into a single executable.</p>
<p>I would guess that you have some misconceptions about the way declarations and definitions work, or what including does. I suggest you brush up with a textbook, or take a look at some small C++ programs on github.</p>
",0
30142328,30142066,1,"<p>No. You shouldn't <code>#include</code> cpp files. Also, you're using the term 'link' incorrectly.</p>

<ul>
<li>cpp files should #include their corresponding header file, if they have one, on their first line: bar.cpp should #include bar.h, foo.cpp should #include foo.h.</li>
<li>every header should be #included as the first header in a corresponding cpp file, even if you have to make an empty corresponding cpp file just to #include the header.</li>
<li>header files should #include only other headers</li>
<li>cpp files should #include headers for other interfaces they use, or should include forward declarations, if you can write valid forward declarations.</li>
</ul>

<p>'Linking' has nothing to do with <code>#include</code>. It's the task performed by the linker after compilation/assembly has been performed. Linking is performed on object files and libraries, not headers or cpp files.</p>
",0
27142780,27142747,6,"<p>The compiler knows it must construct <strong>both</strong>. So it does. </p>
",2
27142890,27142747,2,"<p>The function will be synthesized when it is <em>instantiated</em> (i.e. when the function is called with known template parameters).</p>

<p>So the compiler sees that you call the function with <code>std::string</code> -- then the template function <code>ptr_swap&lt;std::string&gt;</code> must be created.</p>

<p>Since your program did not call it with <code>bool</code>s, it won't bother creating <code>ptr_swap&lt;bool&gt;</code>.</p>
",0
27134944,27134921,1,"<p>Instead I would use</p>

<pre><code>struct Image{
    int n;
    int m;
    vector&lt;vector&lt;int&gt;&gt; data;
}
</code></pre>

<p>Of you could use a 1D vector that has size</p>

<pre><code>vector&lt;int&gt; data(m * n);
</code></pre>
",5
27135468,27134921,0,"<p>Ignoring encapsulation, something like this could work:</p>

<pre><code>#include &lt;vector&gt;

struct Image {

    int n;
    int m;
    std::vector&lt;std::vector&lt;int&gt;&gt; data; // May want to change int type ?

    Image(int n, int m) : n(n), m(m), data(n) {
        for (int row = 0; row &lt; n; row++) {
            data[row].resize(m);
        }
    }
};

// Example Usage
Image img(10, 10);

for (int row = 0; row &lt; img.n; row++) {
    for (int col = 0; col &lt; img.m; col++) {
        img.data[row][col] = valueFromImageFile;
    }
}
</code></pre>

<p>If you're not just looking for something quick and dirty, and this is going to be an ongoing project, I would recommend that you learn more about object oriented concepts :)</p>
",0
27136417,27134921,0,"<p>There are two common patterns for that (even if inherited from C). Both share a common principle : a logical separation between a fixed size header and a variable part.</p>

<p>First method : the struct contains the fixed size part and a pointer (or pointers in a generic case) to memory allocated with new (in constructor) and deallocated in destructor. It is a bit <em>hand-driven</em>, but easy to use and to understand.</p>

<p>Image could look like (I assume <code>Pixel</code> is a class representing a single pixel):</p>

<pre><code>class Image {
private:
    int _x, _y;
    Pixel *data;

public:
    Image(int x, int y);
    ~Image();

    Pixel&amp; getPixel(int i, int j) {
        return data[i * _y + j];
    }
};

Image::Image(int x, int y) {
    data = new Pixel[x * y];
    _x = x;
    _y = y;
}

Image::~Image() {
    delete[] data;
    data = NULL;
}
</code></pre>

<p>Second method : the pseudo-struct is composed of a fixed size header, and of a dynamic part. The dynamic part is declared in the struct to be of size 1. It is obviously false, and you cannot use <code>sizeof</code> on such a struct, but as C does not inforce comparison of array to the declared size it works :</p>

<pre><code>class Image {
private:
    int _x, _y;
    Pixel data[1];
    Image(int x, int y); // private to force usage of createImage

public:
    static Image* createImage(int x, int y);

    Pixel&amp; getPixel(int i, int j) {
        return data[i * _y + j];
    }
};

Image* Image::createImage(int x, int y) {
    Image* image = (Image *) malloc(sizeof(Image) + (x * y - 1) * sizeof(Pixel));
    image-&gt;_x = x;
    image-&gt;_y = y;
    return image;
}
</code></pre>

<p>I must admit it is really C code embedded in C++, but I cited it because it is heavily used in Microsoft Win32 API.</p>
",0
28533055,28532960,2,"<p>There's nothing wrong with your code. Try re-writing your main as:</p>

<pre><code>int main() {

    intv vi { 3, 2, 1, 5, 4 };
    size_t t = vi.size();
    int i;
    cout &lt;&lt; ""Original: \n"";
    for(i=0; i&lt;t; ++i) cout &lt;&lt; vi[i] &lt;&lt; ' ';
    cout &lt;&lt; '\n';

    double time=mesorti(vi);      
    cout &lt;&lt; ""Sorted: \n"";
    for(i=0; i&lt;t; ++i) cout &lt;&lt; vi[i] &lt;&lt; ' ';
    cout &lt;&lt; '\n';

    return 0;
}
</code></pre>

<p>If you're still having a problem, maybe you have a linking problem (e.g. linking to an old <code>.o</code> file.)</p>

<p>Output:</p>

<pre><code>Original: 
3 2 1 5 4 
Sorted: 
1 2 3 4 5 
</code></pre>

<p>Note: For simplicity I'm using C++11-style vector initialization. If you don't have a C++11 compiler, initialize it in some other way.</p>

<hr>

<p>Edit: Here's the full single-file <code>main.cpp</code> file which compiles and runs for me:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;
using namespace std;

typedef vector&lt;int&gt; intv;
typedef vector&lt;float&gt; flov;
typedef vector&lt;double&gt; douv;

void merge(vector&lt;int&gt;&amp; array, vector&lt;int&gt;&amp; array1, vector&lt;int&gt;&amp; array2) {
     array.clear();

     int i, j, k;
     for( i = 0, j = 0, k = 0; i &lt; array1.size() &amp;&amp; j &lt; array2.size(); k++){
        if(array1.at(i) &lt;= array2.at(j)){
            array.push_back(array1.at(i));
            i++;
        }else if(array1.at(i) &gt; array2.at(j)){
            array.push_back(array2.at(j));
            j++;
        }
        k++;
    }

    while(i &lt; array1.size()){
        array.push_back(array1.at(i));
        i++;
    }

    while(j &lt; array2.size()){
        array.push_back(array2.at(j));
        j++;
    }
}

double mesorti(intv &amp;array) {
auto t0 =chrono::high_resolution_clock::now();
if (1 &lt; array.size()) {
    intv array1(array.begin(), array.begin() + array.size() / 2);
        mesorti(array1);
        intv array2(array.begin() + array.size() / 2, array.end());
        mesorti(array2);
        merge(array, array1, array2);
    }
auto t1 = chrono::high_resolution_clock::now();
double T = chrono::duration_cast&lt;chrono::nanoseconds&gt;(t1-t0).count();
return T;
}

int main() {

    intv vi { 3, 2, 1, 5, 4 };
    size_t t = vi.size();
    int i;
    cout &lt;&lt; ""Original: \n"";
    for(i=0; i&lt;t; ++i) cout &lt;&lt; vi[i] &lt;&lt; ' ';
    cout &lt;&lt; '\n';

    double time=mesorti(vi);      
    cout &lt;&lt; ""Sorted: \n"";
    for(i=0; i&lt;t; ++i) cout &lt;&lt; vi[i] &lt;&lt; ' ';
    cout &lt;&lt; '\n';

    return 0;
}
</code></pre>
",2
31148302,31147958,1,"<p>The question is quite broad. 
Few major steps could be defined as below:</p>

<ol>
<li><p>You could create a socket to a particular website and stream that data from that website. For more information on this, you could check- <a href=""http://www.boost.org/doc/libs/1_57_0/doc/html/boost_asio/overview/networking/iostreams.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_57_0/doc/html/boost_asio/overview/networking/iostreams.html</a> </p></li>
<li><p>Then you can scan the data and write regular expressions in order to retrieve the value from the data and then output them wherever you want to display. </p></li>
</ol>

<p>Then you can write a bash script to run this code object again and again on regular intervals. Hence you would have live results without scanning the website manually. </p>
",0
28529725,28529525,0,"<p>Once you have sorted, you have to do something that is equivalent to:</p>

<pre><code>vii=vi;
</code></pre>

<p>I think assigning <code>vi</code> to <code>vii</code> will be the most efficient method of copying the contents of <code>vi</code> to <code>vii</code>. You can try:</p>

<pre><code>size_t index = 0;
for ( auto const&amp; val : vi )
{
   vii[index++] = val;
}
</code></pre>

<p>However, I will be really surprised if the second method is more efficient than the first.</p>
",2
29494579,29494113,2,"<p>It's this line in the header:</p>

<pre><code> Date&amp; Date::operator =(Date&amp;&amp; data);
</code></pre>

<p>That should be declared inside the class definition, in which case the Date:: is at best unnecessary and at worst liable to cause interesting errors.</p>

<p>If it's declared outside the class definition, it's just wrong.</p>
",0
29956931,29956905,5,"<p><code>char board[10][10];</code></p>

<p><code>xp = 10;</code></p>

<p><code>board[xp][yp] = 'G';</code></p>

<p>When you set ""G"", you have run off the end of the array (valid indexes are 0-9), so you're getting undefined behavior.</p>
",1
29956960,29956905,2,"<p>You are adding the 'G' in the wrong place in array. You are going out of limits. Your array varies from a[0][0] to a[9][9].</p>
",0
29957011,29956905,2,"<p>First of all, I tried your code and got errors because your functions don't return a value (you declared them as returning an int) so change those to return void. Then, to answer your question, the reason you don't see a 'G' is because <strong>your value for xp is 10, which is outside the range of the grid.</strong> Remember, in code, in general, things are 0-based, so slots 1-10 are actually referred to as slots 0-9. So I changed sp = 10 to xp = 9 and your 'G' shows up like a charm.</p>

<hr>

<pre><code>#include &lt;iostream&gt;

void createBoard();
void updateBoard();
void clear();

using namespace std;

void createBoard();
void updateBoard();
void clear();
char board[10][10];
int xp = 9;
int yp = 4;

int main() {

    createBoard();
    board[xp][yp] = 'G';
    clear();
    updateBoard();

}

void createBoard() {
    for (int x = 0; x &lt; 10; x++){

        for (int y = 0; y &lt; 10; y++){
            board[x][y] = '.';
            cout &lt;&lt; board[x][y];
        }
        cout &lt;&lt; endl;
    }
}


void updateBoard(){
    for (int x = 0; x &lt; 10; x++){

        for (int y = 0; y &lt; 10; y++){
            cout &lt;&lt; board[x][y];
        }
        cout &lt;&lt; endl;
    }
}


void clear(){
    cout &lt;&lt; string( 25, '\n' );
}
</code></pre>
",0
34268982,34268922,3,"<p>It is implicit conversion to ancestor. Implicit conversions are generally safe and they cannot do stuff <code>static_cast</code> cannot do. They actually even more restricted: you can do an unchecked downcast with <code>static_cast</code>, but not with implicit conversion. </p>
",0
34268988,34268922,11,"<p>This is a standard derived-to-base pointer conversion. The rules are that a pointer to <code>D</code> with some <code>const</code>/<code>volatile</code> qualifications can be converted to a pointer to <code>B</code> with the same qualifiers if <code>B</code> is a base class of <code>D</code>.</p>

<p>The standard conversions are implicit conversions with built-in meanings and are separate concepts to things like <code>static_cast</code> or C-style casts.</p>

<p>Generally it's best to rely on implicit conversions when you can. Explicit conversions add more code noise and may hide some maintenance mistakes.</p>
",8
31892719,31892669,3,"<p>""First-chance"" exception means just that the debugger noticed that an exception has been thrown. That's not an error (and in facts the execution goes on), just an aid to the programmer that may be on the look for exceptions being incorrectly swallowed.</p>
",4
31225729,31225676,0,"<p>As you want to send output from one connection to other connections, it'll be easier to coordinate from one process, so any of those options <em>except</em> <code>fork</code>....  The problems with <code>fork</code> are that after forking a child to handle one connection, the child process won't have any access to later sockets accepted by the parent, and that even for socket descriptors that are accessible from both processes it'll be harder to work out when it's safe to write without intermingling output.</p>
",2
31881650,31880595,2,"<p>Another approach to address the requirement...</p>

<p><strong>Use functions in a suitable <code>namespace</code> instead of a singleton.</strong></p>

<p>Log.h:</p>

<pre><code>namespace Log
{
   void add(const char *str, bool nl=true);
   void clear();

   const char* get();
   int getNumLogs();
}
</code></pre>

<p>Log.cpp:</p>

<pre><code>namespace detail
{
   // This is almost same as the class from OP's post.
   struct LogImpl
   {
      LogImpl(std::string const&amp; log) : _logs(0), _log(log) {};

      void add(const char *str, bool nl=true);
      void clear();

      const char* get() const { return _log.c_str(); }
      int getNumLogs() const { return _logs; }


      std::string _log;
      int _logs;
   };
}

namespace Log
{
   // This mimics the singleton implementation...
   // Create only one instance of LogImpl.

   static detail::LogImpl impl(""&lt;LOG&gt;\n\n"");

   void add(const char *str, bool nl)
   {
      impl.add(str, nl);
   }
   void clear()
   {
      impl.clear();
   }

   const char* get()
   {
      return impl.get();
   }
   int getNumLogs()
   {
      return impl.getNumLogs();
   }
}

namespace Log
{

   void add(const char *str, bool nl=true);
   void clear();

   const char* get();
   int getNumLogs();
}
</code></pre>

<p><strong>Using functions in a <code>namespace</code> vs using a singleton</strong></p>

<p>To support use of functions in a namespace requires bit more code.</p>

<p>However, it simplifies calling code.</p>

<p>Calling code can use</p>

<pre><code>Log::add(...);
</code></pre>

<p>instead of</p>

<pre><code>Log::instance()-&gt;add(...);
</code></pre>
",0
31880880,31880595,5,"<p>That's one of the rare cases a singleton makes sense:</p>

<pre><code>class Log
{
public:

    void add(const char *str, bool nl=true);
    void clear();

    const char* get() const { return _log.c_str(); }
    int getNumLogs() const { return _logs; }

    static Log&amp; instance() {
         static Log theInstance;
         return theInstance;
    }
private:
    Log() : _logs(0), _log(LOG_DEFAULT_TEXT) {};

    std::string _log;
    int _logs;
};
</code></pre>

<p>This way you can use it elsewhere just accessing </p>

<pre><code> Log::instance().add(""Blah Blah"",true);
</code></pre>
",7
31881974,31880595,1,"<p>Another common pattern inherited from C would be a global object. Globals are generally frowned upon because they are the symptom of bad design. But it makes sense for a logger to be a global.</p>

<p>That means that the header for your class should contain :</p>

<pre><code>extern Log log;
</code></pre>

<p>and the cpp </p>

<pre><code>#include &lt;log.h&gt;
...
Log log;    // unique definition for the global Log
</code></pre>

<p>Then in any module using the log :</p>

<pre><code>#include &lt;log.h&gt;
...
log.add(...);
</code></pre>

<p>The caveat here that there will be static initialization of <code>Log log</code>. And C++ is not always very nice with order of static initialization : <em>... Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization of
a variable defined in a different translation unit.</em>. The only foolproof way is to ensure that :</p>

<ul>
<li>Log construction does not depend on any other statically initialized variable needing a constructor phase in another translation unit - it includes <code>std::string</code> but hopefully not <code>const char *</code></li>
<li>the global variable is used once before any multithreading starts</li>
</ul>

<p>If in doubt, use the singleton pattern suggested by ¦Ð?¦Í¦Ó¦Á ?¦Å?</p>
",1
33533529,33533474,3,"<p>The <code>std::function</code> type is a generalization of function pointers. C++ makes a distinction between functions, member functions, and function objects (if you haven't heard of that last one, go look it up! They're super cool!), so a normal function pointer can't point at all the types of things in C++ that you can call like a function. <code>std::function</code> is essentially a type that acts like a function pointer that can point at just about anything that you could call like a function. To use <code>std::function</code> to point to something with argument types <code>Arg1, Arg2, ..., ArgN</code> and return type <code>Ret</code>, declare a variable of type</p>

<pre><code>std::function&lt;Ret (Arg1, Arg2, ..., ArgN)&gt;
</code></pre>
",1
30132358,30132298,1,"<p>remove <code>using namespace std ;</code> from your code and precede any standard function or object with <code>std::</code> </p>
",0
30132359,30132298,6,"<p>Namespace <code>std</code> has already name <code>right</code> and you included names form <code>std</code> in the global namespace by means of directive</p>

<pre><code>using namespace std;
</code></pre>

<p>So to avoid the ambiguity use a qualified name</p>

<pre><code>memset( ::right, 0, sizeof( ::right ) );
</code></pre>

<p>Or remove the directive and in this case you may use unqualified name <code>right</code> because the compiler will seek the name only in the global namespace.</p>
",1
34266515,34266487,73,"<p>Sure</p>

<pre><code>namespace mynamespace
{
   using namespace std;
   using namespace glm;
}
</code></pre>
",1
34266521,34266487,52,"<p>You can use <code>using</code> to achieve this:</p>

<pre><code>namespace mynamespace {
    using namespace std;
    using namespace glm;
}
</code></pre>
",4
29238733,29238697,4,"<p>Because your <code>char</code>s are signed (highest bit is set).</p>

<p>I'm sorry, I'm not familiar with using <code>std::hex</code> but you somehow need to treat it like an unsigned char value. Try casting the <code>char</code> to and unsigned type.</p>
",9
31232996,31232855,0,"<p>try to write delete [] array_t; in the for cycle. Because in this way you'll ""delete"" the array. And to reallocate it just use array_t= new my_class[number];</p>
",0
31234322,31232855,-1,"<p>So ok, first of all thank all of you for your help ;)
I just made a stupid programming mistake :D</p>

<p>basically what I typed was:</p>

<pre><code>delete my_class[i];
</code></pre>

<p>instead of</p>

<pre><code>delete array_t[i];
</code></pre>

<p>while iterating through the for loop which gave me the ""expected primary-expression before .. token""-error. I got confused with my variables.</p>

<p>The way I posted it above I have tried and it actually works. 
I apologise for the inconvenience ;)</p>
",1
34263079,29068252,1,"<p>Here's one I made in Java, it's not assigned statically and supports lower and upper case letters.</p>

<pre><code>public static char closestVowel(char character) {
    int value = (int) character;
    if(character == 'z' || character == 'Z')
        return (char) (value - 25);
    if(isVowel(character)) {
        return character;
    } else {
        return closestVowel((char) (value - 1));
    }
}

public static boolean isVowel(char character) {
    return ""aeiouAEIOU"".indexOf(character) &gt;= 0;
}
</code></pre>
",1
31232896,31232759,2,"<p>If you're declaring </p>

<pre><code>int *marks[4];
</code></pre>

<p>that doesn't mean there's an appropriate piece of memory allocated for the particular pointers in that array.</p>

<p>You have to allocate memory, before you could write there using a statement like </p>

<pre><code>cin &gt;&gt; *marks[0];
</code></pre>

<p>Allocate memory like follows:</p>

<pre><code>for(size_t i = 0; i &lt; 4; ++i) {
    marks[i] = new int();
}
</code></pre>

<p>before calling the <code>cin &lt;&lt;</code> operation.<br>
And don't forget to deallocate, after it shouldn't be used any longer:</p>

<pre><code>for(size_t i = 0; i &lt; 4; ++i) {
    delete marks[i];
}
</code></pre>

<hr>

<p>The probably better solution would be to use a <code>std::array&lt;int,[size compiletime determined]&gt;</code> or a <code>std::vector&lt;int&gt;</code>:</p>

<pre><code>std::vector&lt;int&gt; marks;
</code></pre>

<p>Depending if you need a fixed size array, or a dynamically allocated array you can use either</p>

<pre><code>const int fixed_array_size = 30;
std::array&lt;int,fixed_array_size&gt; marks;
</code></pre>

<hr>

<pre><code>size_t array_size = 0:
std::cin &gt;&gt; array_size;
std::vector&lt;int&gt; marks(array_size);
</code></pre>
",0
27570696,27570421,2,"<p>to return multiple values from a function, the conventional and safe way is to use a std::tuple.</p>

<p>It looks like your function wants to return a best score and a best co-ordinate so start with a declaration that looks like this:</p>

<pre><code>// holds an x/y coordinate
struct XY {
 // need to declare stuff here
};

std::tuple&lt;int, XY&gt; Search(...args....)
{
   // perform calculations here
   ...

   // return the best move
   return std::make_tuple(bestScore, bestXY);
}
</code></pre>
",2
27570701,27570421,7,"<blockquote>
  <p>it allows to return multiple values from a function passing the
  variables in by reference.</p>
</blockquote>

<p>No. A function always returns only one value. You can pass arguments by reference and modify them within the function (unless it's a constant reference), this will modify their values. Consider this example:</p>

<pre><code>void Foo (int x)
{
    ++x;
}

void Bar (int &amp;x)
{
    ++x;
}

int x = 0;

Foo (x);
// x is still 0
Bar (x);
// x is now 1
</code></pre>

<p>If you want to return multiple objects from a function, use <code>std::tuple</code> (as Richard Hodges proposed below) or define a <code>struct</code>. The former is simpler, but it's relatively easy to mix up the elements of a tuple. The latter has a bit more overhead, but you have clear member names.</p>

<p>As for your case, you need something like</p>

<pre><code>std::tuple &lt;int, bool&gt; Search(int depth, board b)
{
  int bestScore = std::numeric_limits&lt;int&gt;::min(); 
  bool bestMove = false;

  // do stuff

  return  std::make_tuple (bestScore, bestMove);
}
</code></pre>

<p>or</p>

<pre><code>struct Best
{
  int Score;
  bool Move;
};

Best Search(int depth, board b)
{
  Best best = { std::numeric_limits&lt;int&gt;::min(), false };

  // do stuff with best.Score and best.Move

  return best;
}
</code></pre>
",0
27571230,27570421,0,"<p>Ok.Thanks. Something like this:</p>

<pre><code>struct XY {
int score;  
XY;
}

tuple&lt;int, XY&gt; Search(int depth, board b)
{
  board b = combined();
  int w = 0;
  w = Evaluate(b);
  int bestScore = std::numeric_limits&lt;int&gt;::min(); 
  bool bestMove = false;
  if(depth == 0) return w;
  int x=0, int y=0;
  for (int x = 0; x &lt; 9; ++x) {
  for (int y = 0; y &lt; 9; ++y) {
    while (!occupied(x,y));
     make_move(x, y);              
    score = -Search(depth-1,b);       // recursion 
    unMake(b);
    if(score &gt; bestScore) {         
      bestScore = score;
      bestMove = (x,y);
    }
   }
  }

   // return the best move
   return make_tuple(bestScore, bestXY);
}
</code></pre>

<p>There must be still some bugs but at least got something together.</p>
",2
31304471,31304362,2,"<p>Make a function that will give you the part of the barcode for a single digit:</p>

<pre><code>string get_barcode_part(int digit)
{
    switch(digitA)
    {
        case 0: return ""!!..."";;
        case 1: return ""...!!"";;
        case 2: return ""..!.!"";;
        case 3: return ""..!!."";;
        case 4: return "".!..!"";;
        case 5: return "".!.!."";;
        case 6: return "".!!.."";;
        case 7: return ""!...!"";;
        case 8: return ""!..!."";;
        case 9: return ""!.!.."";;
        default: return ""Invalid""; // or whatever else you want
    }
}
</code></pre>

<p>Then you can simply call it for each of your digits:</p>

<pre><code>// Short Zip Code Converter Function
int zip_to_bar(int digitA, int  digitB, int digitC, int  digitD, int digitE)
{
    int sum;
    string bar_Code = ""!"", check_Code;

    bar_Code += get_barcode_part(digitA);
    bar_Code += get_barcode_part(digitB);
    bar_Code += get_barcode_part(digitC);
    bar_Code += get_barcode_part(digitD);
    bar_Code += get_barcode_part(digitE);

    // Sum of Zip_Digits
    sum = (digitA + digitB + digitC + digitD + digitE);
    // Calculation of check_Digit_Code
    check_Code = check_Digit_Code(sum);
    // Assignment of check_Bar_Code to check_Digit_Code
    cout &lt;&lt; bar_Code + check_Code &lt;&lt; endl;
    return sum;
}
</code></pre>

<p>This is the essential function of functions (heh): to refactor and reduce copied code, by putting common functionality in a common place.</p>

<p><strong>Edit:</strong> In addition, you should probably use an array for your digits, like so:</p>

<pre><code>// Short Zip Code Converter Function
int zip_to_bar(int *digits, int numDigits)
{
    int sum = 0;
    string bar_Code = ""!"", check_Code;

    for (int i = 0; i &lt; numDigits; i++)
    {
        bar_Code += get_barcode_part(digits[i]);
        // Sum of Zip_Digits
        sum += digits[i];
    }

    // Calculation of check_Digit_Code
    check_Code = check_Digit_Code(sum);
    // Assignment of check_Bar_Code to check_Digit_Code
    cout &lt;&lt; bar_Code + check_Code &lt;&lt; endl;
    return sum;
}
</code></pre>
",0
31304600,31304362,0,"<p>Easiest way is with a table </p>

<pre><code>string bar_Codes[] = {""!!..."",  ""...!!"", ...};
</code></pre>

<p>and then</p>

<pre><code>bar_Code += bar_Codes[digitA];
bar_Code += bar_Codes[digitB];
bar_Code += bar_Codes[digitC];
</code></pre>

<p>Less efficient, but equally easy is make a function:</p>

<pre><code>void getBarCode(int digit, string &amp; bar_Code)
{
    switch(digit)
    {
        case 0: bar_Code += ""!!...""; break;
        case 1: bar_Code += ""...!!""; break;
        case 2: bar_Code += ""..!.!""; break;
        ....
    }
}
</code></pre>

<p>and then</p>

<pre><code>getBarCode(digitA, bar_Code);
getBarCode(digitB, bar_Code);
getBarCode(digitC, bar_Code);
...
</code></pre>

<p>All you need to do is ensure the digit is in the allowable range</p>
",0
31264450,31262784,3,"<p>Sometimes a set of parenthesis is <strong>needed</strong> to disambiguate declarations. </p>

<p>For example:</p>

<pre><code>int *f();     // a function returning a pointer to int
int (*f)();   // a pointer to a function returning an int
</code></pre>

<p>Rather than listing exactly when and where using parenthesis is required and where it perhaps should be forbidden (because it is useless), the standard just says that they are allowed. </p>

<p>So you end up with the slightly confusing:</p>

<pre><code>int   a;     // an int variable
int   (b);   // another int variable
</code></pre>
",1
27118406,27118352,2,"<p>Well, you could use a third-party component or library that hid the details from you, so that you could simply do something like (from the mythical <code>pax-matrix</code> library):</p>

<pre><code>Matrix a(4, 3,   1,  2 , 3,  4,
                 5,  6,  7,  8
                 9, 10, 11, 12);
Matrix b(2, 4,   1,  2 ,
                 3,  4,
                 5,  6,
                 7,  8);
Matrix c = a.mult(b);
</code></pre>

<p>But, at some point, it will still have to use nested <code>for</code> loops - that's contained in the very <em>definition</em> of matrices.</p>

<p>Your best bet at understanding how looping code works is to run a sample <em>in your head,</em> actually performing the steps taught in maths textbooks.</p>

<p>Start with something like:</p>

<pre><code> / 1  2  3  4 \     / 1 2 \
|  5  6  7  8  | x |  3 4  |
 \ 9 10 11 12 /    |  5 6  |
                    \ 7 8 /
</code></pre>

<p>and work out each cell in the resultant matrix. For example the top-left cell would be the sum of products of the first row of martix 1 and first column of matrix 2, <code>1x1 + 2x3 + 3x5 + 4x7</code>:</p>

<pre><code>( 1 2 3 4 ) x  / 1 \
              |  3  |
              |  5  |
               \ 7 /
</code></pre>

<p>That way you'll be more likely to understand the three loops. The outer two loops simply select each cell in the resultant matrix while the inner loop sums the products for setting that cell.</p>
",0
27118422,27118352,1,"<p>To make the code better and more readable, <em>abstract</em> and <em>refactor</em>.  I see repeditive code for each matrix and that's an obvious common function.</p>

<p>That's also what I call ""meandering"". The monolithic program does different things one after another with no separation. The main function that ""read, multiply, write"" should not go into detail of how any of those chores are actually performed.</p>
",0
31181150,31180605,1,"<p>I think the following will speed up your code significantly, but it's a little work to find out.  Currently you are:</p>

<ol>
<li>iterating over each character of u.</li>
<li>doing a find in sep1 to see if that character is among the separators.</li>
<li>appending one character at a  time, as needed.</li>
</ol>

<p>Assuming your list of separators is smaller than the strings you are parsing, you are probably better off doing the following:  </p>

<ol>
<li>For each seperator, do a find to see if the separator is in the string</li>
<li>If found, append the entire substring in one go, and do a find on the remaing substring.</li>
</ol>

<p>A second optimization is to order your separators in terms of most likely to succeed.  If for e.g. "","" is the most commonly use separator, make sure the find runs on that first.  If one separator is much hotter than others, this will make a big difference.</p>
",0
31181524,31180605,2,"<p>The to things that may be ""very very slow"" here are:</p>

<ol>
<li><code>ustring::length()</code> </li>
<li><code>ustring::append()</code></li>
<li>Random access to <code>ustring</code> via <code>operator[]</code> : e.g. <code>c=u[i];</code></li>
</ol>

<p>Try the following:</p>

<ol>
<li>Instead of calling <code>u.length()</code> in a loop, store the length in a variable and in the loop compare to that variable</li>
<li>Append the characters of the current token to an <code>ostringstream</code> or <code>wostringstream</code> instead of a ustring</li>
<li>Iterate through <code>ustring</code> using iterators instead of indices involving random access.</li>
</ol>

<p>Example:</p>

<pre><code>for(ustring::const_iterator it = u.cbegin(); it != u.cend(); it++)
{
    c = *it;
    //implementation follows
}
</code></pre>
",5
30400021,30399928,2,"<p>prev is a pointer, and it initially points to a variable that retains its scope throughout the while loop. Then in the while loop, you create a new variable 'cur', which has a scope limited to that iteration, and save a pointer to that temporary variable. Try defining cur outside the while loop.</p>

<p>Cheers!</p>
",0
30400033,30399928,3,"<p>The problem is that your code uses an out-of-scope pointer. Any reference to <code>cur</code> that was valid in a prior iteration of the loop is invalid as soon as you get to the next iteration. That's why the first iteration, when <code>prev</code> points to <code>initial</code>, is the only iteration when your code works as expected. On subsequent iterations <code>prev</code> happens to point to the same place as <code>cur</code>, because the compiler keeps it in the same place in all iterations of the loop. However, the behavior is undefined, so you may get different results when compiling with other compilers.</p>

<p>You need to declare both <code>prev</code> and <code>cur</code> outside the loop, and make a copy of the entire structure, like this:</p>

<pre><code>derp prev;
prev.idx = 0;
derp cur;
while (true) {
    int c;
    while ((c = getchar()) != '\n' &amp;&amp; c != EOF)
    {
    }
    if (c == EOF)
    {
        break;
    }
    cur.idx = prev.idx + 1;
    std::cerr &lt;&lt; ""Prev: "" &lt;&lt; prev.idx &lt;&lt; "", cur: "" &lt;&lt; cur.idx &lt;&lt; std::endl;
    prev = cur;
}
</code></pre>

<p><a href=""http://ideone.com/fLORiE#stdin"" rel=""nofollow"">Demo.</a></p>
",0
27076959,27076926,0,"<p>Your condition for printing is not correct.</p>

<pre><code>    (prim);cout&lt;&lt;i&lt;&lt;"","";
</code></pre>

<p>should be</p>

<pre><code>    if(prim) cout&lt;&lt;i&lt;&lt;"","";
</code></pre>

<p>Note that your logic prints primes &lt;= n, not the first <code>n</code> prime numbers.</p>
",0
27076961,27076926,1,"<p>Because <code>(prim)</code> is not the same as:</p>

<pre><code>if (prim) {
    cout &lt;&lt; i &lt;&lt; "","";
}
</code></pre>

<p>On a side note:</p>

<ul>
<li><code>d=d+1</code> and <code>i=i+1</code> can just be <code>d++</code> and <code>i++</code></li>
<li>You can declare variables inside the loops like: <code>for (int i = 0;</code></li>
</ul>
",0
27076969,27076926,0,"<p>You missed off the <code>if</code>:</p>

<pre><code>if (prim) cout &lt;&lt; i &lt;&lt; ',';
</code></pre>
",0
27077066,27076926,0,"<p>Instead of <code>(prim);</code> use <code>if(prim)</code>. The rest of your code is correct.    </p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
 unsigned int i,n,d;
 bool prim;
 cout&lt;&lt;""n="";
 cin&gt;&gt;n;
 for(i=2;i&lt;=n;i=i+1)
    {
     prim=true;
     for(d=2;d&lt;=i/2;d=d+1)
     if(i%d==0)
     {
         prim=false;
         break;
     }
     if(prim)
         cout&lt;&lt;i&lt;&lt;"", "";
    }
  return 0;
}
</code></pre>
",0
31297900,31297824,3,"<p>This is because you check <code>data[i]</code> before reading data into it. Just put <code>if</code> check after the <code>file &gt;&gt; data[i]</code>:</p>

<pre><code>file &gt;&gt; data[i];

if (data[i] == c)
    break;

cout &lt;&lt; data[i];
</code></pre>
",6
31297903,31297824,1,"<p>You check <code>data[i]</code> before it's initialized. Local variables, including arrays, are not initialized, their value is <em>indeterminate</em> (and will seem random), reading from an uninitialized local variable leads to <em>undefined behavior</em>.</p>

<p>What you need to do is to read data first, <em>then</em> check if the character was what you were looking for.</p>
",4
31297908,31297824,0,"<p>Switch the two lines:</p>

<pre><code>if(data[i]==c)break;
file &gt;&gt; data[i];
</code></pre>

<p>To </p>

<pre><code>file &gt;&gt; data[i];
if(data[i]==c)break;
</code></pre>
",0
31298406,31297824,0,"<p>Your issue is with the line</p>

<pre><code>if(data[i]==c)break;
</code></pre>

<p>What is at <code>data[i]</code>? Right now that will result in <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a>. You can fix this by doing two things. Firstly, when you create the array, zero it out so that it will be full of null characters (no more UB!)</p>

<pre><code>char data[1000] = {0}; //fill data with 0's
</code></pre>

<p>Then, in your loop, read the next character into a temp variable, and check the temp variable. Your issue is that you check before you read:</p>

<pre><code>for(int i = 0; i &lt;= 493; ++i)
{
    char temp;
    file &gt;&gt; temp;

    if(temp == c)break;       //If we found one, get out of there!

    data[i] = temp;           //If not, update data
    securitykey += (int)temp; //and security key 
}
</code></pre>
",0
25496427,25496416,7,"<p><code>5/9</code> will result in <code>0</code> because it is <code>int</code> division.</p>

<p>You would need to do</p>

<pre><code>void fun (double *ptr)
{
    *ptr = (5.0 / 9.0);
}
</code></pre>

<p>You need to use the correct type literals:</p>

<pre><code>5      // int
5.0    // double
5.0f   // float
5u     // unsigned int
5l     // long
5ul    // unsigned long
</code></pre>
",6
24126051,24125766,-1,"<p>Try the following</p>

<pre><code>#include&lt;iostream&gt;

int main()
{  
    for ( int i = 100; i &lt; 1000; i++ )
    {
        int sum = i / 100 + i / 10 % 10 + i % 10;

        bool prime = sum == 2 || ( 2 &lt; sum &amp;&amp; sum % 2 );

        for ( int j = 3; prime &amp;&amp; j * j &lt;= sum ; j += 2 )
        {
            prime = sum % j != 0; 
        }

        if ( prime ) std::cout &lt;&lt; ""The sum "" &lt;&lt; sum 
                               &lt;&lt; "" of digits of number "" &lt;&lt; i 
                               &lt;&lt; "" is a prime number""
                               &lt;&lt; std::endl;
    }

    return 0;
} 
</code></pre>

<p>If the statements (for example iterative statements) have to be different you can write for example</p>

<pre><code>#include&lt;iostream&gt;

int main()
{
    int i = 99;  
    while ( ++i &lt; 1000 )
    {
        int sum = i / 100 + i / 10 % 10 + i % 10;

        bool prime = sum == 2 || ( 2 &lt; sum &amp;&amp; sum % 2 );

        for ( int j = 3; prime &amp;&amp; j * j &lt;= sum ; j += 2 )
        {
            prime = sum % j != 0; 
        }

        if ( prime ) std::cout &lt;&lt; ""The sum "" &lt;&lt; sum 
                               &lt;&lt; "" of digits of number "" &lt;&lt; i 
                               &lt;&lt; "" is a prime number""
                               &lt;&lt; std::endl;
    }

    return 0;
} 
</code></pre>

<p>This program has one for loop, one while loop and one if statement.:)</p>
",3
24126105,24125766,3,"<p>Rather than generate all possible 3-digit numbers, then see if the sum of the digits in each is a prime, I'd work in the other direction: Generate all primes in the right range (there aren't very many of them, since <code>999</code> only adds up to <code>27</code>).</p>

<p>Then I'd generate all the three digit numbers possible from each--a couple of loops to generate the first two digits and simple subtraction to generate the third in each case.</p>
",0
27154721,27154671,0,"<p>Because they are incompatible. Member function pointers and function pointers are different in terms of the standard.</p>
",5
27154803,27154671,2,"<p>You should rather use:-</p>

<pre><code>typedef void (Server::*ScriptFunction)(std::pair&lt;std::string, std::string&gt;);
</code></pre>

<p>i.e pointer to member function instead of pointer to function.</p>
",0
29189344,29189286,4,"<p>You are defining your function as if it was a global one:</p>

<pre><code>void updateX(const Rectangle&amp; destRect, const Rectangle&amp; boundingBox,
             units::Coordinate delta_x, Level* level, bool moveAlongSlopes=false) {
  //...
}
</code></pre>

<p>Change it to:</p>

<pre><code>void MapCollidable::updateX(const Rectangle&amp; destRect, const Rectangle&amp; boundingBox,
             units::Coordinate delta_x, Level* level, bool moveAlongSlopes=false) {
  //...
}
</code></pre>

<p>Call to <code>update</code> is signaled as an error, because there is no such function in global scope.</p>

<p>By the way, that's why I <strong>always</strong> reference any member function/variable using <strong>this</strong>.</p>

<p>If you wrote this:</p>

<pre><code>void updateX(const Rectangle&amp; destRect, const Rectangle&amp; boundingBox,
                 units::Coordinate delta_x, Level* level, bool moveAlongSlopes=false) {
  //...
  this-&gt;update(...);
}
</code></pre>

<p>You would immediately got following error:</p>

<blockquote>
  <p>Error: 'this' only allowed in non-static member functions.</p>
</blockquote>

<p>And you would know what is causing this error. Without <strong>this</strong>, many simple errors can be easily omitted.</p>
",3
24128146,24125930,1,"<p>I highly recommend you change your design.  </p>

<p>A <em>function</em> is a container of <em>terms</em>.  So let's define a <em>term</em>:</p>

<p>A term minimally has a <em>coefficient</em> and an exponent:  </p>

<pre><code>struct Fundamental_Term
{
  double coefficient;
  int    exponent;
};
</code></pre>

<p>If your function is only in terms of one variable, all you need is the <code>Fundamental_Term</code>.  Otherwise, you need to have the base variable name:  </p>

<pre><code>struct Term_With_Base
: public Fundamental_Term
{
  std::string variable_name;
};
</code></pre>

<p><em>Note: if you can't use inheritance, copy the member variables of <code>Fundamental_Term</code> into <code>Term_With_Base</code>.</em>  </p>

<p>Remember a <em>function</em> is a collection or container of terms.  Assuming a function with multiple bases, we can declare:  </p>

<pre><code>struct Function
{
  std::vector&lt;Term_With_Base&gt; terms;
};
</code></pre>

<p><strong>Evaluation of Terms</strong><br>
To evaluate a function, f(x), all terms must be evaluated and their results summed.
This decomposes into two requirements:  1) Terms must have an evaluation method; 2) The function class must have an evaluation method that sums the terms.  </p>

<p>So, we add an evaluation function to the base class:</p>

<pre><code>struct Fundamental_Term
{
  double coefficient;
  int exponent;
  double evaluate(double value)
  {
    return coefficient * pow(value, exponent);
  }
};

struct Function
{
  std::vector&lt;Term_With_Base&gt; terms;
  double evauate(double value)
  {
    const unsigned int quantity = terms.size();
    double result = 0.0;
    for (unsigned int i = 0; i &lt; quantity; ++i)
    {
      result = result + terms[i].evaluate(value);
    }
    return result;
   }
};
</code></pre>

<p>When creating a function from a string, a preference is to create a constructor of <code>Fundamental_Term</code> that takes a string parameter.  The term object should read its coefficient, variable name and exponent, not the Function container.  </p>

<p>For more examples, search StackOverflow for ""c++ parse term evaluation"".  </p>

<p><strong>Edit 1:  Inserting terms</strong><br>
One method to insert terms, is to have a method in the term data structure that loads a term from a string:  </p>

<pre><code>bool
Fundamental_Term ::
load_from string(const std::string&amp; input,
                 unsigned int &amp;     start_position)
{
  bool term_is_valid = false;
  // Parse the string and load appropriate fields.
  // Set the start position to the first position after the valid term.
  // Set term_is_valid to true if the term has valid syntax.
  return term_is_valid;
}
</code></pre>

<p>The Function object would have a member to load terms from a string.</p>

<pre><code>bool
Function ::
load_terms_from_string(const std::string&amp; input)
{
  Term_With_Base term;
  unsigned int   position_in_string = 0;
  bool           term_is_valid = true;
  while (term_is_valid &amp;&amp; (position_in_string &lt; input.size()))
  {
    term_is_valid = term.load_from_string(input, position_in_string);
    if (term_is_valid)
    {
      terms.push_back(term);
    }
  }
}
</code></pre>

<p>The <code>std::vector</code> used to contain the terms will expand as necessary with each additional term that is parsed.  The loop will terminate when the string is parsed or there is an invalid term.  </p>
",0
27119228,27117872,2,"<p>Based on the description (but not visible in the text quoted) each line begins with a <code>'\r'</code> (carriage return) character. Some systems uses an end of line sequence. Windows typically uses <code>""\r\n""</code> (carriage return, line feed) which would be replaced by a single <code>'\n'</code> when opening the file in non-<code>binary</code> mode (i.e., when not passing the flag <code>std::ios_base::binary</code> when creating the stream). However, this replacement does <em>not</em> happen for a ""\n\r"" sequence.</p>

<p>You can easily verify this theory by replacing all <code>'\r'</code> characters before creating the <code>std::istringstream</code> (I slipped an extra <code>i</code> in there as I don't see why a read/write stream should be created):</p>

<pre><code>std::transform(line.begin(), line.end(), line.begin(), '\r', '@');
std::istringstream linestream(line);
</code></pre>

<p>With this change I would expect that the output of the first word of all but the first line would look like this:</p>

<pre><code>Value:   @Sale
</code></pre>

<p>The easiest way to fix the problem is to simply skip leading whitespace when reading the line. The corresponding code excerpt would look like this:</p>

<pre><code>std::ifstream file(""test1.csv""); 
for (std::string line; std::getline(file &lt;&lt; std::ws, line); ) {
    std::istringstream   linestream(line);
    for (std::string value; std::getline(linestream, value, ','); ) {
        std::cout &lt;&lt; ""Value:   "" &lt;&lt; value &lt;&lt; '\n';
    } // for
}
std::cout &lt;&lt; ""Done Procesing\n"";
</code></pre>

<p>The magic is the addition of <code>&lt;&lt; std::ws</code> when reading the line which simply removed all leading whitespace. The code also removes the <a href=""http://kuhllib.com/2012/01/14/stop-excessive-use-of-stdendl/"" rel=""nofollow"">inappropriate use of <code>std::endl</code></a>. If the first word on each line may include leading whitespace you would need a different approach, probably removing the <code>'\r'</code> characters before creating <code>linestream</code>, e.g., using</p>

<pre><code>line.erase(std::remove(line.begin(), line.end(), '\r'), line.end());
</code></pre>
",0
27117897,27117853,1,"<p>Take the semicolon off this line:</p>

<pre><code>if (hProcHandle == INVALID_HANDLE_VALUE || ...);
</code></pre>

<p>It's terminating the <code>if</code> statement so that there's a valid block afterwards (which would execute regarless of the <code>if</code> statement):</p>

<pre><code>{
    // some valid statements
}
</code></pre>

<p>followed by a very <em>invalid,</em> ""naked"" <code>else</code>.</p>
",0
27126381,27126111,3,"<p>Why don't you just use <code>std::vector</code>?</p>

<pre><code>std::vector&lt;object&gt; objects;

void addObject(object o)
{
    objects.push_back(o);
}
</code></pre>

<p>..or</p>

<pre><code>void addObject(const object &amp;o)
{
    objects.push_back(o);
}
</code></pre>

<p>to remove additional copying.</p>

<hr/>

<p>When it comes to implementing your own dynamic array without <code>std::vector</code>, Yes. you need to allocate new memory, and copy your array to new memory block. Here's my example code with <code>malloc</code> and placement new.</p>

<pre><code>#include &lt;stdlib.h&gt;    // for malloc/free
#include &lt;new&gt;         // for placement new, std::bad_alloc

object *objects = nullptr;
size_t totalObjects = 0;

void addObject(const object &amp;o)
{
    object *old_objects = objects;
    size_t old_size = totalObjects;

    size_t new_size = totalObjects + 1;

    object *new_objects = (object *)malloc(sizeof(object) * new_size);
    if (new_objects == nullptr)
        throw std::bad_alloc();

    size_t i;
    try
    {
        for (i = 0; i &lt; old_size; ++i)
        {
            new (&amp;new_objects[i]) object(old_objects[i]); // placement new
        }
    }
    catch (...)
    {
        // destroy new_objects if an exception occurs during creating new_objects
        for (size_t j = 0; j &lt; i; ++j)
        {
            new_objects[i].~object();
        }
        free(new_objects);

        throw;
    }

    objects = new_objects;
    free(old_objects);
}
</code></pre>

<p><em>(I haven't tested the code yet >o&lt;)</em></p>

<p>Note that I used <code>malloc</code> and placement new, <em>not</em> <code>new</code> operator. It's impossible to call copy constructor of each element of the dynamic array with array-<code>new</code>.</p>

<p>However, if your <code>object</code> is <a href=""http://en.cppreference.com/w/cpp/concept/TriviallyCopyable"" rel=""nofollow"">TriviallyCopyable</a>, you can use <code>realloc</code>. It can be more efficient, because <code>realloc</code> can just expand memory block, without copying - if the memory is enough.</p>

<hr/>

<p>..And you can select multiple lines and just press <kbd>TAB</kbd> in Visual Studio (..or many other editors).</p>
",8
27127232,27126111,2,"<p>You declared an <code>object</code> pointer, but not yet allocated the actual memory to store <code>object</code> objects. Your assignment statement merely tries to copy the input object <code>o</code> into an <em>unallocated</em> array member.</p>

<p>This is why you should use <code>new</code> before the assignment. The <code>new</code> operator asks the system to allocate some memory in the required size, then return the address of that memory and assign it to the pointer. Then, the pointer points to that newly allocated memory and the assignment (or copying) can be made.</p>

<p>When you finished using the array space, you should free the allocated memory using <code>delete</code>.</p>
",0
27128068,27126111,0,"<p>Okay, I'm going to add an answer to my own question.  Let me know if this is bad etiquette.  I just wanted to post some of my own code to duel with yours.</p>

<pre><code>#include &lt;vector&gt;
std::vector&lt;object&gt; objects;
</code></pre>

<p>okay so I want to have two arrays (vectors) for the objects and double for distances so I may end up with</p>

<pre><code>std::vector&lt;double&gt; distances;

void swap(unsigned int a, unsigned int b)
{
    objects.swap_ranges(a,b);
    distances.swap_ranges(a,b)

}
</code></pre>

<p>I'm going by the cplusplus.com reference for this function so let me know if I have it wrong.  I'm going to go through it and completely redo my code.</p>

<p>Is there a type like the matrix that will let me hold data of different types so I don't have to invent a new object to handle each one individually?</p>

<p>If what you wrote is the most efficient and fast way to do this then I'll make a new class to hold both items.</p>

<p>thanks :)</p>
",4
26793488,26793422,0,"<p>Your <code>trouverNomListe</code> function is recursive, which is incorrect. It should simply go through the list sequentially, e.g.</p>

<pre><code>bool trouverNomListe(Espion* ptr, std ::string nomAChercher)// returns true if the name is already on the list
{
    while (ptr)
    {
         if(ptr-&gt;nom.compare(nomAChercher) == 0)
              return true;
         ptr = ptr-&gt;suivant;
    }
    return false;
}
</code></pre>

<p>There are several other problems with your code too but this seems to be the main issue.</p>
",0
27133617,27133565,4,"<pre><code>string word;
string subfunction(word);
{
     cout &lt;&lt; word &lt;&lt; endl;
}
</code></pre>

<p>This is not declaring a function. This is declaring a variable named <code>subfunction</code> of type string with constructor parameter word (another string), followed by an unrelated block of code that prints the variable word. You're just calling the copy constructor of string meaning subfunction and word are equal strings.</p>

<p>It should be noted that a) you cannot define a function inside another one, b) in C++ function parameters need a type. <a href=""http://coliru.stacked-crooked.com/a/a0b36769a3542fd3"" rel=""nofollow"">I've fixed your code for you</a></p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void subfunction(string word)
{
    cout &lt;&lt; word &lt;&lt; endl;
}

int main()
{
    cout &lt;&lt; ""Enter a number: ""; // ask user for a number
    int x;
    cin &gt;&gt; x; // read number from console and store it in x
    cout &lt;&lt; ""You entered "" &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; ""\n"" &lt;&lt; ""Enter 'a': "";
    string y;
    cin &gt;&gt; y;
    if (y==""a""){
       cout &lt;&lt; ""You typed 'a'!!!"";
       int z;
       cin &gt;&gt; z;
       return 0;
    }
    else {
         cout &lt;&lt; ""You didn't type 'a'!!!"" &lt;&lt; endl;
    }
    string word;
    subfunction(""abc"");

    return 0;
}
</code></pre>

<p>P.S: <code>main()</code> cannot call itself. If you meant to call this multiple times until it succeeds either break off your logic in a separate recursive function <em>or</em> use a while loop.</p>

<p>P.P.S: I've changed the return type of <code>subfunction</code> to <code>void</code> since it was not returning anything.</p>
",3
27133671,27133565,2,"<p>It looks like you are from a python background so I'll point out things that are different in c++. In c++ you cannot define <em>named</em> functions within the body of other functions like you are attempting to do here. To get that type of behavior you might want to use a lambda or other related functionality, see <a href=""https://stackoverflow.com/questions/4324763/c-can-we-have-functions-inside-functions"">this question</a> for more on that topic. The easiest thing to do to make your program work as intended would be to move the <code>subfunction</code> to outside of the main loop:</p>

<pre><code>void subfunction(string word){
     cout &lt;&lt; word &lt;&lt; endl;
}

int main(){
    subfunction(""abc"");
    return 0;
}
</code></pre>

<p>The other thing is that types are not dynamic like in python, you need to explicitly declare your types. What the original code did was actually define a variable of type <code>string</code> called <code>subfunction</code> and then an unrelated block of code below it but not a function. As you can see in <a href=""https://stackoverflow.com/questions/581097/can-i-use-blocks-to-manage-scope-of-variables-in-c"">this question</a> braces can define a block a scope, you might be used to whitespace having a specific meaning from python but in c++ braces don't imply a similar meaning that it must be a function. Then later when you did <code>subfunction(""abc"")</code> it tried to pass the <code>const char*</code> typed ""abc"" into <code>subfunction</code> variable which is of type <code>string</code> which is not allowed and hence gave you your error.</p>

<p>Also your return type from main should be an integer, <a href=""http://www.parashift.com/c++-faq/main-returns-int.html"" rel=""nofollow noreferrer"">main always returns <code>int</code></a> but the more important thing is that you should always be returning the correct type for the function:</p>

<pre><code>int main(){
^^^
this is telling you to return an int
</code></pre>

<p>Get used to looking for the right types then returning the correct types.
Right now you are calling main again which is almost certainly not what you want.</p>
",0
27133674,27133565,3,"<p>Functions cannot be defined inside other functions. Pull out the definition (and remove the trailing <code>;</code> as it is not used after a function definition): </p>

<pre><code>void subfunction( string word )
{
     cout &lt;&lt; word &lt;&lt; endl;
}

int main()
{
    //...
}
</code></pre>

<p>I changed the return type of the function since it does not return anything.</p>

<p>Also, it is illegal to explicitly call <code>main()</code>. If you want your program to loop, use a loop:</p>

<pre><code>int main()
{
    while( true )
    {
        // ...
    }
}
</code></pre>
",0
27133685,27133565,0,"<p>declearation wise there are some difference in syntax.
And you have put the function inside the main function which is function inside function.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

string subfunction(word);
    {
         cout &lt;&lt; word &lt;&lt; endl;
    }

int main()
{
    using namespace std;
    cout &lt;&lt; ""Enter a number: ""; // ask user for a number
    int x;
    cin &gt;&gt; x; // read number from console and store it in x
    cout &lt;&lt; ""You entered "" &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; ""\n"" &lt;&lt; ""Enter 'a': "";
    string y;
    cin &gt;&gt; y;
    if (y==""a""){
       cout &lt;&lt; ""You typed 'a'!!!"";
       int z;
       cin &gt;&gt; z;
       return 0;
    }
    else {
         cout &lt;&lt; ""You didn't type 'a'!!!"" &lt;&lt; endl;
    }
    string word = ""abc"";

    subfunction(word);
}
</code></pre>

<p>if you only want to display you don't need a return type. So your function can be</p>

<pre><code>void subfunction(word);
        {
             cout &lt;&lt; word &lt;&lt; endl;
        }
</code></pre>
",0
27133701,27133565,0,"<p>As it has been mentioned, you cannot define a function within another function. Therefore, you need to move subfunction outside of main. Secondly, putting a "";"" at the end of anything c++ marks the end of that statement. So, string subfunction(word); is one statement and on the next line the ""{"" marks the beginning of a separate scope.</p>

<p>Also, I am pretty sure you cannot return main() from main.</p>

<pre><code>#include &lt;iostream&gt;

string subfunction(word)
{
     cout &lt;&lt; word &lt;&lt; endl;
}
int main()
{
    using namespace std;
    cout &lt;&lt; ""Enter a number: ""; // ask user for a number
    int x;
    cin &gt;&gt; x; // read number from console and store it in x
    cout &lt;&lt; ""You entered "" &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; ""\n"" &lt;&lt; ""Enter 'a': "";
    string y;
    cin &gt;&gt; y;
    if (y==""a""){
       cout &lt;&lt; ""You typed 'a'!!!"";
       int z;
       cin &gt;&gt; z;
       return 0;
    }
    else {
         cout &lt;&lt; ""You didn't type 'a'!!!"" &lt;&lt; endl;
    }
    string word;
    subfunction(""abc"");
    return 0;
}
</code></pre>
",0
27136794,27136750,1,"<p>Why does it need to be a nested loop? This can be done using a simple <code>for</code> loop.</p>

<pre><code>unsigned int input;
cout &lt;&lt; ""Enter a number: "";
cin &gt;&gt; input;

for (unsigned int i = 1; i &lt;= input; ++i)
{
    cout &lt;&lt; i &lt;&lt; "" squared is "" &lt;&lt; i * i &lt;&lt; endl;
}
</code></pre>

<p><a href=""http://ideone.com/idV5yS"" rel=""nofollow"">Working demo</a></p>

<p>The <code>while</code> loop equivalent would be</p>

<pre><code>unsigned int input;
cout &lt;&lt; ""Enter a number: "";
cin &gt;&gt; input;

unsigned int i = 1;
while(i &lt;= input)
{
    cout &lt;&lt; i &lt;&lt; "" squared is "" &lt;&lt; i * i &lt;&lt; endl;
    ++i;
}
</code></pre>
",3
27157664,27157317,1,"<blockquote>
  <p>why the for loop doesn't stop when a is greater than its square ?</p>
</blockquote>

<p>Because it never is. If you compare the graph of <code>y=x^2</code> against the graph of <code>y=x</code>, you will see that the only time <code>y=x</code> is above, is when <code>0 &lt; x &lt; 1</code>. That's never the case for integers<sup>1</sup>. Now, since we're talking about computers with limited storage here, there is a thing called overflow, which will cause a very large number to become a very small number. However, signed integer overflow is undefined behavior in C++. So once your loop gets to the point where overflow would happen, you cannot rely on the results.</p>

<p><sub>1. Note that your loop is not set to stop just when a is greater than its square, but when it is greater than or <em>equal</em> to its square. So, your loop will actually stop if <code>a</code> is 0 or 1.</sub></p>
",0
27157381,27157317,7,"<p>Using multiplication when trying to avoid multiplication seems broken. What about this:</p>

<pre><code>int r = 0;

for (int n = 0; n &lt; a; ++n) {
  r += a;
}
</code></pre>
",3
29201673,29201454,1,"<p>At a guess, your code looks roughly like this:</p>

<pre><code>void stringOutput();

int main() 
{
    ¡­
    stringOutput();
}

void stringOutput(int dayNumber, double *ptrTemperatures)
{
    ¡­
}
</code></pre>

<p>Your <code>main</code> function uses the <code>stringOutput</code> function you declared above, but that function is never defined anywhere, hence the error.</p>

<p>Below <code>main</code>, you declare and define a separate overload of <code>stringOutput</code>, which has two parameters instead of none.</p>

<p>If you want to use the function you have below <code>main</code>, you need to declare it before <code>main</code>:</p>

<pre><code>void stringOutput(int dayNumber, double *ptrTemperatures);

int main()
¡­
</code></pre>

<p>You also need to give it the arguments it needs, instead of giving it nothing:</p>

<pre><code>int main()
{
    ¡­
    stringOutput(dayNumber, ptrTemperatures);
}
</code></pre>
",3
31231617,31231343,0,"<p>Here's a Java implementation:</p>

<pre><code>package time;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Superstition calculates how frequently the 13th falls on each day of the week
 * @author Michael
 * @link https://stackoverflow.com/questions/31231343/on-what-days-does-the-thirteenth-occur-usaco
 * @since 7/5/2015 10:31 AM
 */
public class Superstition {

    public static final DateFormat DEFAULT_FORMAT = new SimpleDateFormat(""yyyy-MMM-dd"");
    public static final int DEFAULT_MAX_YEARS = 400;
    public static final String START_DATE = ""1900-Jan-13"";
    public static final int MONTHS_PER_YEAR = 12;


    public static void main(String[] args) {
        Map&lt;Integer, Integer&gt; frequencies = new LinkedHashMap&lt;Integer, Integer&gt;() {{
            put(Calendar.SUNDAY, 0);
            put(Calendar.MONDAY, 0);
            put(Calendar.TUESDAY, 0);
            put(Calendar.WEDNESDAY, 0);
            put(Calendar.THURSDAY, 0);
            put(Calendar.FRIDAY, 0);
            put(Calendar.SATURDAY, 0);
        }};
        try {
            int maxYears = args.length &gt; 0 ? Integer.parseInt(args[0]) : DEFAULT_MAX_YEARS;
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(DEFAULT_FORMAT.parse(START_DATE));
            for (int i = 0; i &lt; maxYears; ++i) {
                for (int j = 0; j &lt; MONTHS_PER_YEAR; ++j) {
                    int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
                    frequencies.put(dayOfWeek, (frequencies.get(dayOfWeek) + 1));
                    calendar.add(Calendar.MONTH, 1);
                }
            }
        } catch (ParseException e) {
            e.printStackTrace();
         } finally {
            System.out.println(frequencies);
        }
    }
}
</code></pre>

<p>Here's the output for the years from 1900 to 2300:</p>

<pre><code>com.intellij.rt.execution.application.AppMain time.Superstition
{1=687, 2=685, 3=685, 4=687, 5=684, 6=688, 7=684}

Process finished with exit code 0
</code></pre>

<p>As expected, the frequencies with which the 13th falls on each day of the week are roughly the same.  Sum of values equals (# years)*(12 months per year), as it should be.</p>
",0
27749978,27749876,1,"<p>Ok, so update: you should be calling cin.ignore() BEFORE getline and not after getline. If you want to do it your current way, you forgot to call cin.ignore() after you read the number, causing the first one to appear completely empty. </p>

<p>The previous answer was wrong, but the following statement still holds true: </p>

<p>Your '\n' is redundant. See <a href=""http://www.cplusplus.com/reference/string/string/getline/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/getline/</a> for reference. </p>
",6
27750057,27749876,0,"<ol>
<li><p>You need to ignore the rest of line after</p>

<pre><code>cin &gt;&gt; amount_of_people;
</code></pre>

<p>Add the following right after the above line:</p>

<pre><code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
</code></pre></li>
<li><p>Remove the calls to <code>cin.ignore();</code> after the calls to <code>getline()</code>. <code>getline()</code> consumes the <code>'\n'</code> from the stream but does not add it to the output string.</p></li>
</ol>
",0
24606222,24606184,2,"<p><code>std::map</code> is using the relational operator <code>&lt;</code> for ordering and checking key uniqueness. Since your implementations of <code>operator&lt;</code> use the <code>a</code> member only for comparing it will ignore <code>b</code> when evaluating key equality. <code>operator==</code> is not used from the map interface - it is replaced by <code>!(a &lt; b || b &lt; a)</code>. You need something like</p>

<pre><code>bool Entry::operator&lt;(const Entry&amp; e){
    return a &lt; e.a || a == e.a &amp;&amp; b &lt; e.b;
}
</code></pre>

<p>You could remove <code>operator&gt;</code> and <code>operator==</code> or keep them if you need them for other purposes.</p>
",1
26777660,26777546,7,"<p>One way is to do it like this (no loops required):</p>

<pre><code>int lower = (a + c - 1) / c; // find lowest divisor (round up)
int upper = b / c;           // find higher divisor (round down)
d = upper - lower + 1;       // get no of divisors
</code></pre>

<p>For your example case, <code>lower</code> will be 2, <code>upper</code> will be 5, giving <code>d</code> equal to 4.</p>
",0
26777727,26777546,0,"<p>An untested off-the-top-of-my-head algorithm to find all the proper divisors of a positive integer...</p>

<p>Let the number you want to find the divisors for be <code>N</code>.</p>

<ol>
<li>Let <code>i = 2</code></li>
<li>If <code>N % i == 0</code>, then you have two divisors: <code>i</code> and <code>N/i</code>. Add these to the list (or count) of divisors</li>
<li>If <code>i &gt; sqrt(N)</code>, finish, else set <code>i = i + 1</code> and go to (2)</li>
</ol>

<p>For example, if N = 24, then this would give you</p>

<pre><code>i = 2 =&gt; 2, 12
i = 3 =&gt; 3, 8
i = 4 =&gt; 4, 6
sqrt(24) = 4.90, so finish
</code></pre>

<p>(I know this algorithm doesn't strictly match what you asked, but it should be easy enough to adapt.)</p>
",2
26777736,26777546,0,"<p>Rather than checking every number within the range you could something like this.</p>

<p>Find number of divisors within the maximum number and then within minimum number. After subtraction you would get desired result. For e.g:-</p>

<p>Let's say range is [5,15].</p>

<pre><code>15/3 = 5;  //within max number.
5/3 = 1;   //within min number.

result = 5-1 = 4;
</code></pre>

<p>NOTE:- You have to take care of boundaries in the range to get correct result.</p>
",0
26782033,26781882,2,"<p>The author wants you to copy the C++ header file, 'Sales_item.h', into a new folder where you can work with it.</p>

<p>Although I don't have the book, I would guess that the header contains a class describing a particular transaction, and you are supposed to write a program which instantiates (creates) an object for each 'transaction' you have, and then send it to standard output, probably using <code>std::cout</code>.</p>

<p>The class might contain a <code>print()</code> function, or perhaps a <code>friend ostream&amp; operator&lt;&lt;</code> or similar, in which case you could use that function to output the required data.</p>
",2
26791367,26791218,3,"<p>The best solution to do this may be to write public method inside the structure which will compare themselves with structure passed through parameter.</p>

<p>This will look like this</p>

<pre><code>struct Activity {
  int id;
  string Description;
  int parameter1;
  int parameter2;
  int parameter3;
  int parameter4;
  etc...

  public:
    bool compare(const Activity&amp; param)
    {
      //...compare structs here like:
      if (id != param.id)
        //write something

      //etc...

      //at the end you can also return bool that indicates that structs are equal or not
      return true;
    }
}
</code></pre>

<p>This will obviously work only with two the same classes unless you write more comparison methods, but it may be difficult to compare two different structures.</p>

<p>There is also other way to compare two variables (including structs). For this a <strong>memcmp()</strong> function can be used, but it will not tell you directly, which fields are different.</p>

<p>Edited according to what @Tony_D said.</p>
",3
26793818,26793711,0,"<p>It is the same as:</p>

<pre><code>int besti;
int bestSAD;

besti = last;

if ( last == -1 )
    bestSAD = MAX_UINT;
else
    bestSAD = psList[last].getSAD(sElement);
</code></pre>

<p><code>MAX_UINT</code> is not part of Standard C++, it may be something defined in a header file you haven't shown somewhere. If they meant UINT_MAX then this line causes implementation-defined behaviour (which the person who wrote this code may assume will generate <code>bestSAD == -1</code> although that is not guaranteed).</p>
",0
26813649,26813477,1,"<p>I would like to set you on the correct path, that is, without giving you the entire answer. I have found some references which will take you to what it is you would like to learn.
<br /> <br />
Firstly, one must decode the image. That is copy the image into a variable in another, readable, format. Writing one of these, especially when knew to C++, is not a good idea. But there are many libraries which do this very thing. I recommend: <br /> 
<a href=""http://cimg.sourceforge.net/"" rel=""nofollow"">http://cimg.sourceforge.net/</a> and then as brief tutorial: <a href=""http://www.math.ucla.edu/~wittman/hyper/vick/Cimg_tutorial.pdf"" rel=""nofollow"">http://www.math.ucla.edu/~wittman/hyper/vick/Cimg_tutorial.pdf</a> and Proceeding That to Edit a Single Pixel: <a href=""http://cimg.sourceforge.net/reference/group__cimg__loops.html"" rel=""nofollow"">http://cimg.sourceforge.net/reference/group__cimg__loops.html</a> (Look at the: <strong>Loops over interior regions and borders</strong> section) <br /> </p>

<p>This hopefully will point you in the right direction.<br />
P.S. Feel free to ask if you have any more questions.</p>
",3
31542923,31542538,2,"<p>What you're asking is effectively to ""bind"" the first argument (p1) to a function (f) and to have a ""placeholder"" for the second argument (x). Translating that directly into code in C++11, we could use <a href=""http://en.cppreference.com/w/cpp/utility/functional/bind"" rel=""nofollow""><code>std::bind</code></a>:</p>

<pre><code>auto g1 = std::bind(f, p1, std::placeholders::_1);
g1(x); // calls f(p1, x);
</code></pre>

<p>The return type of <code>bind</code> is unspecified, but if you need to store <code>g1</code> somewhere you could store it as a <a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow""><code>std::function&lt;void(double)&gt;</code></a>.</p>

<p>Or you could C++14 it up and write a generic two-argument currier:</p>

<pre><code>template &lt;typename F, typename Arg&gt;
auto curry(F f, Arg arg) {
    return [f,arg](auto arg2) {
        return f(arg, arg2);
    };
}

auto g1 = curry(f, p1);
g1(x);
</code></pre>
",0
31542936,31542538,2,"<p>You can use a <code>std::function</code>, initialized with a lambda</p>

<pre><code>#include &lt;functional&gt;

std::function&lt;void (double)&gt; f(double *p)
{
    return [&amp;](double x) {
        // whatever
    };
}

int main()
{
    double *p = new double[2];

    auto g = f(p);
    g(2);    
}
</code></pre>
",3
31543023,31542538,0,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/utility/functional/bind"" rel=""nofollow"">std::bind</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;

void f(double x, double p[2])
{
    std::cout &lt;&lt; x &lt;&lt; "" "" &lt;&lt; p[0] &lt;&lt; "" "" &lt;&lt; p[1] &lt;&lt; std::endl;
}

int main() {
    double x = 5;
    auto p1 = new double[2];
    p1[0] = p1[1] = 10;
    auto p2 = new double[2];
    p2[0] = p2[1] = 20;
    auto g1 = std::bind(f, std::placeholders::_1, p1);
    auto g2 = std::bind(f, std::placeholders::_1, p2);
    g1(x);
    g2(x);
}
</code></pre>
",0
31542659,31542538,2,"<p>In C++11 you can use a lambda to achieve this:</p>

<pre><code>double x;
auto p1 = new double[2];
auto p2 = new double[2];
auto g1 = [p1](double d){return f(d,p1)};
auto g2 = [p2](double d){return f(d,p2)};
g1(x);
g2(x);
</code></pre>
",0
31542712,31542538,0,"<p>There are a few conceptual problems with your approach:</p>

<ol>
<li>You can return a function pointer from a function (this is what you describe you want to do here: g1 = f(p1) ), but I think that's overkill here.</li>
<li><p>Since g1(x) = f(x,p1) and g2(x) = f(x,p2) it sounds like all you need is f(x,p1) and f(x,p2);</p>

<pre><code>double x;
p1 = new double[2];
p2 = new double[2];
f(x,p1);
f(x,p2);
</code></pre></li>
</ol>
",1
29178803,29178779,5,"<p>With <code>!args[1]</code>, you're trying to call <code>operator!</code> on a <code>std::string</code>, and indeed, the error message is right: <code>std::string</code> has no <code>operator!</code>.</p>

<p>To check whether an element exists in a <code>std::map</code>, use <a href=""http://www.cplusplus.com/reference/map/map/find/"" rel=""nofollow""><code>find</code></a>. It will return <code>std::map::end</code> if the specified key is not in the map:</p>

<pre><code>if (args.find(1) == args.end()) { ... }
</code></pre>
",8
24349704,24347868,1,"<p>C++ Does not come with a built-in support for resource files / internationalization. However there is a huge variety of solutions. </p>

<p>To support multi-language messages, you should have some basic understanding of how such strings are encoded in files and read to memory. Here is a basic introduction if you are not familiar:
""<a href=""http://www.joelonsoftware.com/articles/Unicode.html"" rel=""nofollow"">http://www.joelonsoftware.com/articles/Unicode.html</a>""</p>

<p>To keep and load the correct text at runtime you need to use a third party library: GNU gettext <a href=""http://www.gnu.org/software/gettext/"" rel=""nofollow"">http://www.gnu.org/software/gettext/</a> is one such example. However there are other solutions out there.</p>
",0
27135044,27134801,3,"<p><code>data_ptr</code> is as <code>const Component *</code> while <code>Image::buffer</code> is a <code>Component *</code></p>

<p>By affecting the first to the second you would discard the <code>const</code>. The whole point of this attribute is to protect data and it should be removed by a simple cast.</p>

<p>You could either edite you constructor argument's type to remove the <code>const</code> or use</p>

<pre><code>buffer=const_cast&lt;Component*&gt;(data_ptr);
</code></pre>

<p>In any case, think about the behaviour you want. Is there any sens for the pointer to be const (it's not a ref) ?</p>
",2
31114740,31114644,7,"<p>A multidimensional array is an array of arrays.</p>

<p>The same general array initialization syntax applies.</p>

<p>By the way you can just write <code>{}</code>, no need to put an explicit <code>0</code> in there.</p>
",5
31114758,31114644,18,"<p>You do it exactly the same way</p>

<pre><code>int marr[10][10] = {0};
</code></pre>

<p>Edit:</p>

<p>This is a C solution. For a C++ solution you can go for:</p>

<pre><code>int marr[10][10] = {};
</code></pre>

<p>These 2 solutions do not work for arrays that have size defined via variables. e.g.:</p>

<pre><code>int i, j = 10;
int marr[i][j];
</code></pre>

<p>To initialize such an array in C++ use <code>std::fill</code>.</p>
",13
31115320,31114644,4,"<p>use vector instead of array it will give you more flexibility in declaration and in any other operation </p>

<pre><code>vector&lt;vector&lt;int&gt; &gt; myarray(rows,vector&lt;int&gt;(columns, initial_value));
</code></pre>

<p>you can access them same as you access array,</p>

<p>and if u still want to use array then use <code>std::fill</code></p>
",1
32417752,32417733,4,"<p>In C++11 you can do this:</p>

<pre><code>class complex {
public:
    double re, im;

    complex(double r, double i) 
      : re(r), im(i) {

    }

    complex()
      : complex(0.0d, 0.0d) {

    }
};
</code></pre>

<p>If for some reason you can't use C++11 and you need a case this simple, you can use default arguments: </p>

<pre><code>class complex {
public:
    double re, im;

    complex(double r = 0.0, double i = 0.0) 
      : re(r), im(i) {

    }
};
</code></pre>

<p>which of course has a downside: you can (mistakenly) supply only some of arguments, like this: <code>complex a(1.0)</code>. </p>
",0
32417769,32417733,1,"<p>From C++11 there is <a href=""https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/introduction_to_the_c_11_feature_delegating_constructors?lang=en"" rel=""nofollow"">constructor delegation feature.</a> </p>

<p>You can do: </p>

<pre><code>class A{
public:    
   A(): A(0){ cout &lt;&lt; ""In A()"" &lt;&lt; endl;}
   A(int i): A(i, 0){cout &lt;&lt; ""In A(int i)"" &lt;&lt; endl;}
   A(int i, int j){
      num1=i;
      num2=j;
      average=(num1+num2)/2;
      cout &lt;&lt; ""In A(int i, int j)"" &lt;&lt; endl;}  
private:
   int num1;
   int num2;
   int average;
};

int main(){
   class A a;
   return 0;
}
</code></pre>
",0
29191353,29191262,0,"<p>You have:</p>

<pre><code>if (curnt &lt; 10 &amp;&amp; carry &gt;0)
{
    if ((curnt + carry) &lt; 10)
    {
        currentrow.push_back(curnt + carry);
    }
    else
    {
        workingnum = curnt + carry;
        carry = workingnum / 10;
        currentrow.push_back(workingnum % 10);
    }
}
else
{
    workingnum = curnt + carry;
    carry = workingnum / 10;
    currentrow.push_back(workingnum % 10);
}
</code></pre>

<p>Either the <code>if</code> block or the <code>else</code> block will be executed no matter what you did prior to that <code>if</code> line.</p>

<p><strong>Simplify</strong></p>

<p>You can replace</p>

<pre><code>if (curnt &gt; 10 &amp;&amp; carry ==0)
{
   carry = curnt / 10;
   currentrow.push_back(curnt % 10);
}
if (curnt &lt; 10 &amp;&amp; carry ==0)
{
   currentrow.push_back(curnt);
}
if (curnt &lt; 10 &amp;&amp; carry &gt;0)
{
   if ((curnt + carry) &lt; 10)
   {
      currentrow.push_back(curnt + carry);
   }
   else
   {
      workingnum = curnt + carry;
      carry = workingnum / 10;
      currentrow.push_back(workingnum % 10);
   }
}
else
{
   workingnum = curnt + carry;
   carry = workingnum / 10;
   currentrow.push_back(workingnum % 10);
}
</code></pre>

<p>by</p>

<pre><code>curnt += carry;
carry = curnt / 10;
currentrow.push_back(curnt % 10);
</code></pre>
",3
27178624,27178523,4,"<p>Suppose you represent a large integer, say 123,456,123,456, to six significant figures. You get:</p>

<pre><code>123,456,000,000
</code></pre>

<p>Then you add 1 to it, and get the result 123,456,000,001. If you represent this to six significant figures, you get:</p>

<pre><code>123,456,000,000
</code></pre>

<p>If you add 1 again to 123,456,000,000 then the result, to six significant figures, is:</p>

<pre><code>123,456,000,000
</code></pre>

<p>and so on forever.</p>

<p>If the number you're adding is below the threshold of the numbers you consider significant, you can see you can add that number as many times as you like, and your result will never change. This is essentially what's happening with your attempt to subtract a very small <code>double</code> from a very large one.</p>
",1
33004764,33004066,1,"<p>You can read your file into memory and then write it out after changing any of the lines.  The following example reads it into a vector, then writes it back out.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

using namespace std;

int main()
{
    fstream file;
    string line;
    file.open(""Test.txt"", fstream::in);
    if (file.fail()) exit(-1);

    vector&lt;string&gt; vec;
    while (getline(file, line, '\n'))
    {
        string ln = line;
        vec.push_back(ln);
    }
    file.close();

    // manipulate your lines here

    file.open(""Test.txt"", fstream::out | fstream::trunc);
    for (vector&lt;string&gt;::iterator it = vec.begin(); it != vec.end(); ++it)
    {
        file.write(it-&gt;c_str(), it-&gt;length());
        file.write(""\n"", 1);
    }
    file.close();
}
</code></pre>

<p>But note, when you change a line, the position of lines that follow will change unless the line you are changing is the same size as the original.  Also note, this is a simple ANSI file example, but UNICODE and UTF-8 are also common text file formats.  This should at least get you started.</p>
",0
27517199,27432506,2,"<blockquote>
  <p>The question is why is it this way?</p>
</blockquote>

<p>Unfortunately, I can't answer this with certainty. My guess is that it is a short-hand that came about to save keystrokes in C or one of its predecessors. I will say though that the <code>*</code> operator, IMHO, does change the type of the variable you have declared and so I don't know why it is allowed where <code>const</code> is not.</p>

<p>I would also like to add an example that you have not included which <em>is legal</em>:</p>

<pre><code>int i = 0, * const j = &amp;i;
</code></pre>

<p>And it is legal because the <code>const</code>, in this instance, is being applied to the <code>*</code> and not the <code>int</code>. At least according to <a href=""http://ideone.com/BX61Hh"" rel=""nofollow"">ideone</a>.</p>

<p>It is likely that this is just legacy which needed to be brought forward.</p>

<p>Your extract from the standard sheds some light on the topic:</p>

<pre><code>99) A declaration with several declarators is usually equivalent to the corresponding sequence of declarations each with a single declarator. That is

T D1, D2, ... Dn;
is usually equivalent to

T D1; T D2; ... T Dn;
</code></pre>

<p>The intent seems to be that the <code>Dn</code>'s when declared together separated by commas would be the same type. Because if you're changing types you might as well use a semicolon, since this saves you no keystrokes i.e.</p>

<pre><code>int i, j = 0; double k, l = 7.3;
</code></pre>

<p>Here you've saved yourself typing <code>int</code> and <code>double</code> twice by using the comma in the right place.</p>

<p>I can see your point with the type modifiers like <code>const</code>, <code>volatile</code> etc. Why not allow us to combine those at will? I mean how is this different from the <code>*</code>? I don't think that it is different and I hope that someone smarter than me will come and explain why. I would say either ban the <code>*</code> or allow us to use other modifiers too.</p>

<p>So <strong>in short, I don't know, <em>but here's a cool additional example of the craziness</em></strong>:</p>

<pre><code>int i = 0, * const j = &amp;i;
</code></pre>
",0
27495044,27432506,3,"<p>Short answer: one statement can allow only 'one declaration of a type' but this declaration can declare 'multiple identifiers'. Also const/volatile are either type qualifiers or pointer qualifiers so they need a type or a pointer to bind to.</p>

<p>Long answer:</p>

<p>I haven't ever read the standard but here I go...</p>

<p>""it prevents something silly like int int, but I don't see anything wrong with the invalid code posted above.""</p>

<ul>
<li>The way I see it is that <strong>one statement can allow you only one declaration</strong> but one declaration can allow you to declare multiple identifiers of the same type.</li>
<li>So the problem with int i = 0, double j = 2.0; is that you have two types, int and double. Which goes against [N4140/7.1.6].</li>
<li>It's what the language allows and thus the above statement is incorrect.</li>
</ul>

<p>But you went ahead and dug deeper and I believe your confusion began here onward ""Since we're concerned with only syntax of the form..."". Wouldn't the declaration break up as follows?</p>

<pre><code>int i = 0 ::= simple-declaration
Where in...
int ::= type-specifier
i ::= identifier
= 0 ::= init-declarator
</code></pre>

<p>More</p>

<p>You mentioned...</p>

<pre><code>Not Allowed: int i, const j;
Allowed: int i, * j;
Not Allowed: int i, const * j; // pointer to const int
Allowed: int const * j, * i = &amp;h;
</code></pre>

<p>My response:</p>

<pre><code>Not Allowed: int i, const j; - because const is a type modifier, syntactically there is no type specified to bind to.
Allowed: int i, * j; - because * grabs the type int and j has a complete type.
Not Allowed: int i, const * j; - because const is not associated to a type here. It is the same problem as in the first case. Read it as j is a pointer to &lt;unexpected word in between&gt; and thus screws up the grammar.
Allowed: int const * j, * i = &amp;h; - because syntactically const has a type to bind to.
</code></pre>

<p>""The question is why is it this way?""</p>

<ul>
<li><p>When I was learning C I was initially confused with the use of const before / after the type name and to clear the confusion I tried some test code and figured out what the language allows and the following is what I came up with. It is from my old notes. It definitely looks like something made by a new programmer. However, it clears most of the doubts.</p>

<p><strong>[storage class] [sign qualifier] [size qualifier]  [type qualifiers] &lt;[* [type qualifiers]] [symbol name] [[] | ([parameters])]></strong></p>

<p>storage classes: auto, register, static, extern, typedef</p>

<p>sign qualifiers: signed, unsigned</p>

<p>size qualifiers: short, long, long long</p>

<p>basic types: char, int, float, double, void</p>

<p>type qualifiers: const, volatile</p>

<p>symbol name could be a variable, constant, type(def) name and function</p>

<p>A * prefixed to the symbol makes it a pointer. * can appear N number of times, making it pointer-to-pointer and so on.</p>

<p>A [] suffixed to the symbol makes it an array. [] can appear N number of times, making it a multi-dimension array.</p>

<p>A () suffixed to the symbol makes it a function. () can appear N number of times but since a function cannot return a function, () can appear again when a function returns a function pointer.</p></li>
</ul>

<p>The above helped me think straight when declaring variables.</p>

<p>Modifying the type specifier syntax from my age old notes:</p>

<pre><code>[storage class] [sign qualifier] [size qualifier] &lt;type&gt; [type qualifiers] [* [pointer qualifiers]] [symbol name] [[] | ([parameters])]
</code></pre>

<p>That is const and volatile are either a type qualifier or a pointer qualifier and they need a type or a pointer to bind to qualify them.</p>

<p>Consider the idea of ""one statement can allow you only one declaration but one declaration can allow you to declare multiple identifiers of the same type."" This means the type specifier syntax can be broken down as follows:</p>

<pre><code>type ::= [storage class] [sign qualifier] [size qualifier] &lt;type&gt; [type qualifiers]

symbol ::= [* [pointer qualifiers]] [symbol name] [[] | ([parameters])]
</code></pre>

<p>And a simplified syntax of a declaration would be:</p>

<p>type symbol[, symbol...]</p>

<p>Clearly,</p>

<p>int i, const j; - does not agree with the grammar.</p>

<p>int const  i, j; - agrees with the grammar.</p>

<p>I am sure a person good with the standard can use the standard and provide the answer using the correct terminology and references. However, please keep in mind that less experienced programmers might find a less technical answer easy to understand.</p>

<p>If the form ""int i, const j"" is allowed then one can write ""int const i, const j"" and that would means j is a double constant. That does not make any sense.</p>
",5
27572071,27432506,1,"<blockquote>
  <p>The question is why is it this way?</p>
</blockquote>

<p>Because that's how it was in C at the Dawn of Time (1973 actually) <a href=""http://cm.bell-labs.com/who/dmr/chist.html"" rel=""nofollow"">see here</a></p>

<blockquote>
  <p>If it was legal, you could do it in for loops, which is somewhat useful.</p>
</blockquote>

<p>It is legal, just not very pretty:</p>

<pre><code>for(std::tuple&lt;int, double&gt; t = std::make_tuple(0, 10.0) ; 
    std::get&lt;0&gt;(t) &lt; 10 ; 
    ++std::get&lt;0&gt;(t), std::get&lt;1&gt;(t) *= 1.1)
{
    cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; "", "" &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; std::endl;
}
</code></pre>
",5
29144391,29144004,1,"<p>The question is a bit unclear but try this to prevent segfault.</p>

<pre><code>class C {
  public: void cget(int a);
  private: int a;
};

class U {
  public: void load();

  vector&lt;C&gt; c;    // Note: c is made public in order to add elements from main
};

 void U::load(unsigned x, int a) {
  if (x &lt; c.size())   // Check the size of c _before_ access
  {
    c[x].cget(a);
  }
}

void main()
{
  U u;
  C c;
  u.c.push_back(c);
  u.load(0, 3);  // Will end up calling cget
  u.load(1, 3);  // Will just return without calling cget
}
</code></pre>

<p>EDIT:
Just want to mention that the code in the question has changed a lot sinse my answer. That explains why my code looks quite different ;-)
In any case, the answer is still: Check the size of c before accessing it.</p>
",1
30150377,30148505,0,"<p>C++ templates are built in a way that (afaik) you can't have template class split over header (.h) and implementation (.cpp) files.</p>
",0
31828168,31828104,4,"<p><code>to_string(value)</code> returns a temporary, so in your second example its lifetime ends at the end of the expression. so you have dangling pointer.</p>
",0
31828230,31828104,6,"<p>You could try</p>

<pre><code>ReportInfo(to_string(value).c_str());
</code></pre>

<p>because the temporary will not be destroyed until <code>ReportInfo</code> returns.</p>
",0
26776502,26775335,2,"<p>There is one glaring error in your code:</p>

<pre><code>Node* begin()  { curr = head; }
</code></pre>

<p>This code invokes undefined behavior, since you are not returning a value.  It should be this:</p>

<pre><code>Node* begin()  { curr = head; return curr; }
</code></pre>

<p>In addition, you should pass your <code>LList</code> by const reference in functions that do not change the <code>LList</code> parameter:</p>

<p>For example:</p>

<pre><code>LList::LList(LList&amp; list);
LList&amp; operator=(LList&amp; list);
friend ostream&amp; operator&lt;&lt;(ostream&amp; os, LList&amp; obj);
</code></pre>

<p>should be:</p>

<pre><code>LList::LList(const LList&amp; list);
LList&amp; operator=(const LList&amp; list);
friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const LList&amp; obj);
</code></pre>

<p>Please change these and the other functions to pass const references.  If you want to see why you should change this, you will see the issue immediately if you tried to do this:</p>

<pre><code>LList list1;
LList list2;
//...
std::cout &lt;&lt; list1 + list2;
</code></pre>

<p>The <code>operator &lt;&lt;</code> is looking for non-const <code>LList</code> objects, but the addition ""inline"" returns a temporary <code>LList</code> (which will mean that the return value will be <code>const</code>).  The code will not compile due to your overloaded <code>operator &lt;&lt;</code> accepting only non-const <code>LList</code>.  </p>

<p>So you need to change your parameter in <code>operator &lt;&lt;</code> to a <code>const LList&amp;</code>.</p>
",4
26777125,26775335,0,"<p>You have a built in ""current"" pointer in your list class. This is a grave design error. You are unable to define your functions correctly because of this error.</p>

<p>It is a design error because with this design you cannot iterate over <code>const</code> lists, and this means, among other bad things, that you cannot do anything useful with temporary lists. So when you calculate <code>setA + setB</code>, you cannot assign it to anything,because to assign you need to iterate, so you need a non-const argument to <code>operator=</code> and to the copy constructor. But you cannot bind a temporary to a non-const reference.</p>

<p>Even if you bypass the public interface in the copy constructor and the copy assignment operator, and copy the list directly without using <code>curr</code>, you will have the same problem with any user function that must use the public interface. That is, <code>setA + setB</code> will not be usable as a function argument. You will need to assign it to some variable first, and then pass that variable to the function.</p>

<p>You also cannot take a list and pass it down to some function in the middle of an iteration, and expect to continue to iterate from the place you've left, because anything that iterates the list changes the <code>curr</code> pointer.</p>

<p>The best solution is to get rid of the <code>curr</code> member and make most of your arguments <code>const LList&amp;</code>. While this is not the onky solution, there are many other drawbacks to having a current pointer built into a list class so I won't talk about them.</p>

<p>In order to iterate the list, you have to supply a separate object that can go back and forth over the list, and a separate variant of it that can go back and forth over a <em>const</em> list. This is called an <strong>iterator</strong> and you need to read up on this concept if you want to do anything in C++.</p>

<p>In your case iterators can be <code>Node*</code> and <code>const Node*</code>. You only need to provide member functions that return the first node in the list, which you already have. Real libraries do the same. They normally wrap the node pointer in a separate iterator class, for various reasons; but for a simple homework this is not necessary (though you can do it if you want).</p>
",0
29187176,29186788,1,"<p><code>reversed</code> must be reset to zero at the beginning of every check for palindrome. The best would be to make <code>reversed</code> (and others) a local variable of <code>ispalin</code>.</p>
",2
29193845,29193766,0,"<p>The statement</p>

<pre><code>std::cin &gt;&gt; *pa[i];
</code></pre>

<p>dereferences an uninitialized pointer.<br>
You don't need <code>int*</code> pointers for this case at all. Just change your array and function signature to </p>

<pre><code> int expenses[Seasons];

 void fill(int*  pa, const int x)
</code></pre>

<p>and use </p>

<pre><code> std::cin &gt;&gt; pa[i]; // Note no dereferencing
</code></pre>
",0
26792638,26792579,0,"<p>on the line</p>

<pre><code> matrix[30][30].setassign( filename );
</code></pre>

<p>you are trying to reference an item in the 2D array that is out of bounds. The elements you can use are in the range matrix[0][0] up to matrix[29][29]. matrix[30][30] is out of bounds.</p>

<p>remember in C++ when you allocate an array of 10 for example the first element is at index 0 the last (or tenth element) is at index 9.</p>
",0
29221884,29221828,4,"<p>I think you meant to do this:</p>

<pre><code>for(int i=0; i&lt;10; i++)
{
    cout&lt;&lt;""\t""&lt;&lt;num&lt;&lt;""\t""&lt;&lt;pow(num,2.0)&lt;&lt;""\t""&lt;&lt;pow(num,3.0)&lt;&lt;""\t""&lt;&lt;pow(num,4.0)&lt;&lt;endl;
    num+=5;
}
</code></pre>
",8
26799618,26799521,1,"<p>Define sum variable as 0 and keep on adding it with roll and display it on screen as below.</p>

<pre><code>int rollSum = 0;
cout &lt;&lt; endl;
do
{
    cout &lt;&lt; ""Enter the number of dice you wish to roll.   "" &lt;&lt; endl;
    cin &gt;&gt; dice;
    cout &lt;&lt; endl;
    cout &lt;&lt; ""Enter the number of sides on the dice.       "" &lt;&lt; endl;
    cin &gt;&gt; side;
    cout &lt;&lt; endl;
        for (i = 0; i &lt; dice; ++i) //Increments for the number of dice rolled.
        {
            roll = rand() % side + 1; //Allows for variable sides based on input.
            rollSum += roll;
            cout &lt;&lt; endl;
            cout &lt;&lt; ""["" &lt;&lt; roll &lt;&lt; ""]"" &lt;&lt; rollSum &lt;&lt; endl; //Rolls are displayed in a
            cout &lt;&lt; endl;                       //column in brackets.
        }
} while (true);
</code></pre>
",0
26799621,26799521,1,"<p>Just introduce a variable which accumulates all the rolls:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
using namespace std;
int main()
{
    int roll, side, dice, i;
    srand(time(0));
    cout &lt;&lt; ""-------------------"" &lt;&lt; endl;
    cout &lt;&lt; ""      D I C E      "" &lt;&lt; endl;
    cout &lt;&lt; ""    R O L L E R    "" &lt;&lt; endl;
    cout &lt;&lt; ""*******v1.00*******"" &lt;&lt; endl;
    cout &lt;&lt; endl;
    do
    {
        cout &lt;&lt; ""Enter the number of dice you wish to roll.   "" &lt;&lt; endl;
        cin &gt;&gt; dice;
        cout &lt;&lt; endl;
        cout &lt;&lt; ""Enter the number of sides on the dice.       "" &lt;&lt; endl;
        cin &gt;&gt; side;
        cout &lt;&lt; endl;
        int total = 0;                          // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        for (i = 0; i &lt; dice; ++i) //Increments for the number of dice rolled.
        {
            roll = rand() % side + 1; //Allows for variable sides based on input.
            total += roll;                      // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
            cout &lt;&lt; endl;
            cout &lt;&lt; ""["" &lt;&lt; roll &lt;&lt; ""]"" &lt;&lt; endl; //Rolls are displayed in a
            cout &lt;&lt; endl;                       //column in brackets.
        }
        cout &lt;&lt; ""total ="" &lt;&lt; total &lt;&lt; endl;     // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    } while (true);
    return 0;
}
</code></pre>
",2
29224083,29223091,0,"<p>If you're expecting the line:</p>

<pre><code>;// not give anything
</code></pre>

<p>to produce an error, the reason you aren't seeing one is because empty statements are perfectly legal in C++; This line does not contain any error.</p>

<pre><code>// complete, legal C++ program
int main() {
  ;
}
</code></pre>

<hr>

<p>Using <code>new</code>/<code>delete</code> or <code>malloc</code>/<code>free</code> this way goes against modern C++ practice because it's very difficult to do correctly. Modern practice would be more like:</p>

<pre><code>class Graph {
  int V;
  Matrix adj;
public:
  Graph(int V)
    : V(V), adj(V*V, 0)
  {}
}

int main() {
  Graph g; // automatically initialized and destroyed correctly

  // ...
}
</code></pre>
",0
26803644,26802773,6,"<p>You can't but you can just make a list and put them in a header with a header guard ofc.</p>

<pre><code>// C++ Full Standard Header Include
#include &lt;cstdlib&gt;
#include &lt;csignal&gt;
#include &lt;csetjmp&gt;
#include &lt;cstdarg&gt;
#include &lt;typeinfo&gt;
#include &lt;typeindex&gt;
#include &lt;type_traits&gt;
#include &lt;bitset&gt;
#include &lt;functional&gt;
#include &lt;utility&gt;
#include &lt;ctime&gt;
#include &lt;chrono&gt;
#include &lt;cstddef&gt;
#include &lt;initializer_list&gt;
#include &lt;tuple&gt;
#include &lt;new&gt;
#include &lt;memory&gt;
#include &lt;scoped_allocator&gt;
#include &lt;climits&gt;
#include &lt;cfloat&gt;
#include &lt;cstdint&gt;
#include &lt;cinttypes&gt;
#include &lt;limits&gt;
#include &lt;exception&gt;
#include &lt;stdexcept&gt;
#include &lt;cassert&gt;
#include &lt;system_error&gt;
#include &lt;cerrno&gt;
#include &lt;cctype&gt;
#include &lt;cwctype&gt;
#include &lt;cstring&gt;
#include &lt;cwstring&gt;
#include &lt;cwchar&gt;
#include &lt;cuchar&gt;
#include &lt;string&gt;
#include &lt;array&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;list&gt;
#include &lt;forward_list&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;valarray&gt;
#include &lt;random&gt;
#include &lt;numeric&gt;
#include &lt;ratio&gt;
#include &lt;cfenv&gt;
#include &lt;iosfwd&gt;
#include &lt;ios&gt;
#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;strstream&gt;
#include &lt;iomanip&gt;
#include &lt;streambuf&gt;
#include &lt;cstdio&gt;
#include &lt;locale&gt;
#include &lt;clocale&gt;
#include &lt;codecvt&gt;
#include &lt;regex&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;future&gt;
#include &lt;condition_variable&gt;
#include &lt;ciso646&gt;
#include &lt;ccomplex&gt;
#include &lt;ctgmath&gt;
#include &lt;cstdalign&gt;
#include &lt;cstdbool&gt;
</code></pre>

<p>That should be the full list :) ( C++11 has to be active too )
You might want to remove the ones that are deprecated ( shouldn't be many / you will get a warning anyway ) and the ones you don't have because they're special / old / new</p>
",1
26803140,26802773,2,"<p>libstdc++ <a href=""https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_headers.html"" rel=""nofollow"">documents</a> a header file called <a href=""https://gcc.gnu.org/onlinedocs/gcc-4.9.0/libstdc++/api/a01494_source.html"" rel=""nofollow""><code>stdc++.h</code></a> which includes most of (not all) the standard headers based on the language dialect (for example, neither libstdc++ or libc++ seem to implement <code>&lt;cuchar&gt;</code>). The page gives instructions on how to create a precompiled header from this.</p>

<p>As far as I know, libc++ doesn't have <code>stdc++.h</code>.</p>

<p>In Visual Studio C++, the canonical precompiled header is <code>stdafx.h</code>. You can take the contents of <code>stdc++.h</code> and copy/paste it over if you wish. You will have to modify the <code>#ifdef</code> directives which check the language dialect. In MSVC, <code>__cplusplus</code> seems to defined to something useless like <code>199711</code>. <code>_MSC_VER</code> may be of use in determining the status of C++11 features.</p>

<p>To use it on GCC, <code>#include &lt;bits/stdc++.h&gt;</code>.</p>
",0
26802845,26802773,0,"<p>Preferably you should include only those header files you need because when preprocessor goes through your source file it would replace all header files with there actual contents. So , always try to minimize the use of headers in your program...</p>
",6
26802874,26802773,0,"<p>There is no way and no need to do it in most cases. If you have more than 1 c++ file you could create header file which includes everything what you need and include this single header in all your c++ files - this approach also helps to use precompiled headers.</p>
",0
33564810,33560964,0,"<p>In the end it was pretty simple. The <strong>scope resolution operator</strong> caused the problem. </p>

<p>Here is the updated code.</p>

<pre><code>#include &lt;ifxPkcTest.h&gt;
namespace ScStdTb {

#define CFG_REG 0
#define CMD_REG 0x4
#define CTRL_REG 0x8
#define STAT_REG 0xC

void BasicTB::test()
{
        void testCase();

}

void BasicTB::testCase()              //SOLUTION
{
     unsigned int data = 0x0;
     data=1;
     REG_WRITE(CTRL_REG,&amp;data);

}

}
</code></pre>
",0
27503979,27495585,0,"<p>Got it to work now, thank to 0x499602D2</p>

<p>Here's the code to my Delegate class:</p>

<pre><code>    template &lt;class Callable&gt;
    std::function&lt;Callable&gt; make_function(Callable* callable)
    {
        return{ callable };
    }

    template&lt;typename T&gt;
    class Delegate;

    template&lt;typename R, typename... A&gt;
    class Delegate&lt;R(A...)&gt;
    {
        using TFunc = std::function&lt;R(void* const, A...)&gt;;
    private:
        Delegate(void* obj, TFunc stub)
            : _objectPtr(obj),
            _stubPtr(stub)
        {}
    public:
        Delegate(R(*funcPtr)(A...))
            : Delegate(nullptr, easy_bind(make_function(&amp;functionStub), funcPtr))
        { }

        template &lt;class C&gt;
        Delegate(C* const objectPtr, R(C:: * const methodPtr)(A...))
            : Delegate(objectPtr, easy_bind(make_function(&amp;methodStub&lt;C&gt;), methodPtr))
        { }

        template &lt;class C&gt;
        Delegate(C* const objectPtr, R(C:: * const methodPtr)(A...) const)
            : Delegate(objectPtr, easy_bind(make_function(&amp;constMethodStub&lt;C&gt;), methodPtr))
        { }
    public:
        R operator()(A... args) const
        {
            return _stubPtr(_objectPtr, ::std::forward&lt;A&gt;(args)...);
        }
    private:
        static R functionStub(R(*funcPtr)(A...), void* const, A... args)
        {
            return funcPtr(std::forward&lt;A&gt;(args)...);
        }
        template &lt;class C&gt;
        static R methodStub(R(C::* const methodPtr)(A...), void* const objectPtr, A... args)
        {
            return (static_cast&lt;C*&gt;(objectPtr)-&gt;*methodPtr)(std::forward&lt;A&gt;(args)...);
        }
        template &lt;class C&gt;
        static R constMethodStub(R(C::* const methodPtr)(A...) const, void* const objectPtr, A... args)
        {
            return (static_cast&lt;C*&gt;(objectPtr)-&gt;*methodPtr)(std::forward&lt;A&gt;(args)...);
        }
    private:
        void*   _objectPtr;
        TFunc   _stubPtr;
</code></pre>

<p>And how i use it in my main class:</p>

<pre><code>    void test(int x)
{
    std::cout &lt;&lt; ""Test - print: "" &lt;&lt; x &lt;&lt; std::endl;
}

struct Printer
{
    void print(int x){
        std::cout &lt;&lt; ""Printer - print: "" &lt;&lt; x &lt;&lt; std::endl;
    }

    void print2(int x) const{
        std::cout &lt;&lt; ""Printer - print2: "" &lt;&lt; x &lt;&lt; std::endl;
    }
};

int main(int argc, void* args)
{

    Printer printer;

    Delegate&lt;void(int)&gt; del(&amp;test);
    Delegate&lt;void(int)&gt; del2(&amp;printer, &amp;Printer::print);
    Delegate&lt;void(int)&gt; del3(&amp;printer, &amp;Printer::print2);
    del(1);
    del2(1);
    del3(1);
}
</code></pre>
",2
27495863,27495585,0,"<p>It's failing because of this line:</p>

<pre><code>using TFunc = R(*)(void* const, A&amp;&amp;...);
</code></pre>

<p>The delegate's public constructor is deferring to the private constructor, which is expecting a pointer to a function that takes a void* followed by an int. You are passing a function that takes only an int.</p>

<p>I suspect you're looking to build a delegate that can handle both free functions and functions that take a context parameter (such as a <code>this</code> pointer).</p>

<p><code>std::function</code> takes care of all of that stuff for you. Are you able to write your delegate in terms of <code>std::function&lt;R(A&amp;&amp;...)&gt;</code> ? If so, you can use <code>std::bind</code> to store the object pointer for a member function callback.</p>
",1
27496181,27495585,0,"

<p>The first problem I found was that you were referencing <code>functionStub</code> as <code>functionStub&lt;R(*)(A...)&gt;</code> which was wrong because <code>functionStub</code> takes a function pointer, not a type. The logical fix would be to pass in the address of <code>funcPtr</code> as <code>functionStub&lt;funcPtr&gt;</code>, but that fails as well. I believe this is because function arguments are not constant expressions so passing in the address of <code>funcPtr</code> is ill-formed because templates can only instantiate with constant expressions and types.</p>

<p>So I suggested in the comments that you should pass <code>funcPtr</code> to the parameter of <code>functionStub</code> by changing its signature to the following:</p>

<pre class=""lang-c++ prettyprint-override""><code>static R functionStub(R (*funcPtr)(A...), void* const, A... args);
</code></pre>

<p>The subsequent problem with this is that the function type differs from <code>TFunc</code>. You can solve this by <code>std::bind()</code>'ing <code>functionStub</code> to <code>funcPtr</code> first:</p>

<pre class=""lang-c++ prettyprint-override""><code>: Delegate(nullptr, std::bind(&amp;functionStub, funcPtr, placeholders::_1))
</code></pre>

<p>This also requires changing <code>TFunc</code> to a <code>std::function</code>:</p>

<pre class=""lang-c++ prettyprint-override""><code>using TFunc = std::function&lt;R (void* const, A...)&gt;;
</code></pre>

<p>Now we have gotten rid of the errors, but the bind only placeholds one parameter for the call. <code>A...</code> could be any number of parameters so we have to use some mechanism that placeholds for a variadic number of arguments.</p>

<p>You can use the <code>easy_bind()</code> method as shown in <a href=""https://stackoverflow.com/questions/15024223/how-to-implement-an-easy-bind-that-automagically-inserts-implied-placeholders"">this thread</a>.</p>

<pre class=""lang-c++ prettyprint-override""><code>: Delegate(nullptr, easy_bind(&amp;functionStub, funcPtr))
</code></pre>

<p>And lastly, <code>&amp;functionStub</code> can't be deduced as a <code>std::function</code> type by <code>easy_bind()</code>'s arguments, so you can use a <code>make_function()</code> for that.</p>

<pre class=""lang-c++ prettyprint-override""><code>template &lt;class Callable&gt;
std::function&lt;Callable&gt; make_function(Callable* callable)
{
    return { callable };
}

// ...
: Delegate(nullptr, easy_bind(make_function(&amp;functionStub), funcPtr))
</code></pre>

<p><kbd><a href=""http://coliru.stacked-crooked.com/a/4647d49ae1786851"" rel=""nofollow noreferrer"">Demo</a></kbd></p>
",1
31131782,31131761,4,"<p>It's <code>static int</code>, not <code>staticint</code>.</p>
",0
31131843,31131761,1,"<p>Just like you can't declare an int with <code>intcount</code>, you can't declare a static int with <code>staticint</code>.</p>

<p>No whitespace between alphanumerics/underscores makes the compiler interpret the words as a single identifier.</p>

<p>Also, <code>func</code> can't access <code>count</code> because it's local in <code>main</code>, not global as your comment says.</p>

<p>To make a variable global it needs to be declared outside <em>any</em> function, including the <code>main</code> function.</p>
",0
24603030,24602839,1,"<ol>
<li><p>You declared function with name <code>var</code> twice. One in the global namespace.</p>

<p>void var (){
string name;</p>

<p>}</p></li>
</ol>

<p>and other in the block scope of function main</p>

<pre><code>int var();
</code></pre>

<p>The both functions are not used in the program. Moreover the first function <code>var</code> has a local variable <code>name</code> that in turn is not used in the functioon.</p>

<ol>
<li><p>In function main there is used identifier <code>name</code></p>

<p>cin>> name;</p></li>
</ol>

<p>that was declared neither in the block scope of main nor in the enclosing global namespaec. So the compiler issues the error. Identifier <code>name</code> declared in the first function with name <code>var</code> is not visible outside the function.</p>

<p>So you need to define identifier <code>name</code> used in function main. For example</p>

<pre><code>string name;
</code></pre>

<p>Your program could look for example the following way</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

std::string var()
{
   std::cout &lt;&lt; ""what is your name??? "";

   std::string name;

   std::cin &gt;&gt; name;

   return name;
}

int main()
{
   std::cout &lt;&lt; ""hello world "" &lt;&lt; std::endl;

   std::string name = var();
   std::cout &lt;&lt; ""hello "" &lt;&lt; name &lt;&lt; std::endl;

   return 0;
}
</code></pre>
",0
24602856,24602839,0,"<p>Move ""string name;"" into main. You dont have the variable ""name"" in main's scope (its a local variable of the function ""var"")</p>
",0
24602913,24602839,0,"<p>Problems that I see:</p>

<ol>
<li>'string name' either needs to be declared locally inside your 'var' method, or be declared globally.</li>
<li>Your calling the method 'var' wrong (assuming your trying to call 'var' from 'main'). In C++ you call functions without a return type (void) like this: var(); If the function has a return type, you can assign a local variable with the return type like this: int x = var();
Note: Your void var() method does not return anything, it is void, therefore you cannot assign a local variable.</li>
</ol>

<p>You need to read up about the basics. Dont even play with classes until you have procedural understanding.<br>
Read up about 'scope'. A local variable (name) inside your 'var' method, cannot be used anywhere else because it is declared locally - it only can be used inside the 'var' method.</p>
",0
24602942,24602839,0,"<p>you must declare <code>string name</code> is  a global variable, or is a local variable. 
Example:</p>

<pre><code>#include &lt;iosream&gt;
#include &lt;string&gt;
string name;
</code></pre>
",0
24655665,24655558,0,"<pre><code>a1==b1==c1=='X'
</code></pre>

<p>This doesn't do what you think it does. It compares <code>a1</code> to the boolean result of <code>b1==c1=='X'</code>, probably giving <code>false</code>.</p>

<p>To check whether they are all equal, you need</p>

<pre><code>a1=='X' &amp;&amp; b1=='X' &amp;&amp; c1=='X'
</code></pre>
",0
27133465,27133439,5,"<p><code>""A""</code> is a string literal. What you meant is <code>'A'</code>.</p>
",3
27133472,27133439,4,"<pre><code>  return ""A"";
</code></pre>

<p>will return type <code>const char*</code></p>

<p>You should rather use :- </p>

<pre><code>return 'A'
</code></pre>

<p>to return a character.</p>
",3
27133531,27133439,0,"<p>Alternatively, you can eliminate multiple return statements by doing this:</p>

<pre><code>char evaluate(int score)
{
    char grade;
    if (score &gt;= 90 &amp;&amp; score &lt;= 100)
      grade = 'A';
    else if (score &gt;= 80 &amp;&amp; score &lt;= 89)
      grade = 'B';
    else if (score &gt;= 70 &amp;&amp; score &lt;= 79)
      grade = 'C';
    else if (score &gt;= 65 &amp;&amp; score &lt;= 65)
      grade = 'D';
    else
      grade = 'F';
    return grade;
}
</code></pre>

<p>As others have mentioned, you should use single quotes. <code>E.g. 'A'</code> instead of double quotes. Use double for strings. Single quotes for <code>char</code>.</p>
",0
27133574,27133439,0,"<p>you can do</p>

<pre><code>char evaluate(int score){
char returnValue = 'F';
/*receives an int score out of 100 from main  and determines what letter grade to return */
if (score &gt;= 90 &amp;&amp; score &lt;= 100)
  returnValue = 'A';
else if (score &gt;= 80 &amp;&amp; score &lt;= 89)
  returnValue = 'B';
else if (score &gt;= 70 &amp;&amp; score &lt;= 79)
  returnValue = 'C';
else if (score &gt;= 65 &amp;&amp; score &lt;= 65)
  returnValue = 'D';

return returnValue;
}
</code></pre>
",0
27157932,27157891,4,"<p>You can use <a href=""http://www.cplusplus.com/reference/string/to_string/"" rel=""nofollow""><code>std::to_string</code></a>.</p>

<pre><code>string str = getString1() + getString2() + std::to_string(getInt());
</code></pre>
",3
27158091,27157891,0,"<p>Using <code>std::to_string</code> as suggested by vincent you could also overload the <code>+</code> operator in an easy way:</p>

<pre><code>// string + int
std::string operator+(const std::string &amp;str, const int &amp;i){
    std::string result = str + std::to_string(i);
    return result;
}
// int + string
std::string operator+(const int &amp;i, const std::string &amp;str){
    std::string result = std::to_string(i) + str;
    return result;
}
</code></pre>

<p>Then your original code should work as espected.</p>

<pre><code>string str = getString1() + getString2() + getInt();
</code></pre>

<p>Example:</p>

<pre><code>td::cout &lt;&lt; string(""This is a number: "") + 5 &lt;&lt; endl;
std::cout &lt;&lt; 5 + string("" is a number."") &lt;&lt; endl;
</code></pre>

<p>Output:</p>

<pre><code>This is a number: 5
5 is a number.
</code></pre>
",0
27531019,27530906,7,"<p>This is undefined behavior, so anything is possible - including a possibility when your code ""works"" as expected. Your compiler should have issued a warning about this - it is important to treat such warnings as errors, and fix all reported problems before testing your code.</p>

<p>Compilers use stack or CPU registers to return values from functions. When a <code>return</code> is missing, no data is placed in the space of the return value. However, the data that you planned to return may already be in a register or on the stack in just the right place, so the calling code exhibits the behavior you expect. It remains undefined, though.</p>
",0
27529097,27528975,2,"<p>Certainly you can search for the file as suggested in comments above, but you might be better off specifying an absolute path in your program, so that you know where it's being written.</p>

<p>The formatting of the path is OS-specific, but maybe</p>

<pre><code>/tmp/example.dat

C:\Windows\Temp\example.dat
</code></pre>

<p>for Linux and Windows respectively (but you will need to decide for yourself; these are just examples).</p>
",5
27529224,27528975,4,"<p>The files will be created in the <strong>process working directory</strong>.</p>

<p>In case the process is being run from an <strong>IDE</strong> (e.g. Visual Studio), the working directory can be different from the executable file path. You should check the project properties to find out the actual path.</p>
",0
31860839,31860535,4,"<p>This constructor</p>

<pre><code>C(int i):temp(i){}
</code></pre>

<p>is not the default constructor of the class. However inside main this declaration</p>

<pre><code>C c;
</code></pre>

<p>requires existence of the default constructor of the class. So the compiler issues an error because there is no default constructor.</p>

<p>On the other hand this declaration</p>

<pre><code>C():temp(0){} 
</code></pre>

<p>declares the default constructor that can be used in declaration</p>

<pre><code>C c;
</code></pre>

<p>According to the C++ Standard (12.1 Constructors)</p>

<blockquote>
  <p>4 A default constructor for a class X is a constructor of class X that
  can be called without an argument.</p>
</blockquote>

<p>You could define the default constructor with parameters but the parameters in this case shall have default arguments. For example</p>

<pre><code>C(int i = 0):temp(i){}
</code></pre>

<p>The above constructor is the default constructor because it can be called without arguments.</p>

<p>And in the exersice there is written: </p>

<blockquote>
  <p>Define the default constructor for C</p>
</blockquote>

<p>So you could define it either like</p>

<pre><code>C():temp(0){} 
</code></pre>

<p>or like</p>

<pre><code>C(int i = 0):temp(i){}
</code></pre>

<p>or even the following way</p>

<pre><code>class C{

  private:
    NoDefault temp;
  public:
    C(int i);
};

C::C( int i = 0 ) :temp( i ) {}
</code></pre>

<p>That is to use the default argument in the definition of the contructor outside the class but before main.</p>
",1
31860911,31860535,0,"<p>You almost had it, but you did not define ""the default constructor for C"". You defined some other constructor. So, then, much like in <code>NoDefault</code>, <code>C</code> had no implicit default constructor and could not be instantiated in <code>main</code> through the declaration <code>C c</code>.</p>

<pre><code>C() : temp(1337) {}
</code></pre>

<p>There you go.</p>
",0
29447011,29447003,6,"<p>It is disallowed by the language. The reason is that there would be cases where it couldn't be disambiguated from a function declaration:</p>

<pre><code>struct foo
{
  int bar();
};
</code></pre>

<p>So instead of replicating the whole <a href=""http://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""noreferrer""><em>most vexing parse</em></a> fiasco by allowing <code>()</code> to work sometimes, it is outright disallowed.</p>
",1
31873671,31873363,0,"<pre><code>void Navy::addShip(Ship s)
{
    arr[size] = s;//??
    size++;
}
</code></pre>

<p>Here You run over the bounds of array (because size member initially equals the number of elements in array)! You should keep count of Your ships and dynamically reallocate the array!</p>

<p>I would suggest getting rid of dynamic memory allocation (<code>new</code>) and use <code>std::vector</code> for storing Your objects.</p>
",3
28458033,28455935,0,"<p>To read one line of input like you described (<code>file</code> may be an <code>ifstream</code> or a <code>istringstream</code> here):</p>

<pre><code>for (int i = 0; i &lt; 3; ++i)
{
    file.ignore(numeric_limits&lt;streamsize&gt;::max(), '|'); // Ignores all characters until it finds a '|' character
    file &gt;&gt; ar[i];  // Reads the number following the '|' to ar[i]
}
file.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n'); // Finally, ignores all characters until newline
</code></pre>

<p>You can even make a small shortcut macro if you want:</p>

<pre><code>#define ignore_until(c) ignore(numeric_limits&lt;streamsize&gt;::max(), c)
</code></pre>

<p>and use it like this:</p>

<pre><code>file.ignore_until('|');
</code></pre>
",0
30149946,30149836,0,"<p>You can put your given 2 queues into 2 separate arrays. Note that those 2 separate arrays are sorted by their own. Now, you can simply merge the 2 arrays together to another array - <code>sortedArray</code> and from there, fill your final queue - <code>sortedQueue</code> with the elements of <code>sortedArray</code> in their order </p>

<pre><code>array arr1, arr2
while(!q1.Empty()) {
    insertToArray(arr1, q1.dequeue());
}

while(!q2.Empty()) {
    insertToArray(arr2, q2.dequeue());
}
int maxLength = arr1.Length() &gt; arr2.Length() ? arr1.Length() :arr2.Length()
array sortedArray;
for(int i = 0; i &lt; (q1.size() + q2.size() ); ++i) {
    if((i &lt; maxLength)) {
        sortedArray[i] = arr1[i] &gt;= arr2[i] ? arr1[i] : arr2[i];
    } else {
        fillArr2ToSortedArray();
        break;
    }
}
Queue sortedQueue;
for(int i = 0; i &lt; (q1.size() + q2.size() ); ++i) {
    sortedQueue.enqueu(sortedArray[i]);
}
</code></pre>
",4
27179935,27179754,0,"<p>There's no easy way to <strong><em>automatically evaluate</em></strong> that kind of math expressions from a string in c++ (like you may have experienced with kind of <code>eval()</code> expressions in scripting languages). </p>

<p>C++ is a compiled language, and the compiler can't actually resolve anything to concrete function calls and parameter values at compile time.</p>

<p>You have to parse these strings at runtime, break down the input tokens and parameters, and map the parsing results to concrete function calls of the appropriate <a href=""http://en.cppreference.com/w/cpp/numeric/math"" rel=""nofollow""><code>&lt;cmath&gt;</code></a> functions applying the parsed parameter values, from within your program.</p>

<p>That's not trivial, and there are a number of solution approaches available. But these completely depend on the kind of <em>math language</em> you want to parse from the command line arguments.</p>
",5
27180021,27179754,0,"<p>There is not such thing as 'execute an expression in a string' in standard C++. The reason is because C++ is a compiled language (i.e. the output is binary code that the processor can directly execute without any intermediate interpreter). So it cannot just interpret an expression (or code in general) from a string.</p>

<p>I have an implementation in Snap Websites, there is C++ code:</p>

<p><a href=""https://sourceforge.net/p/snapcpp/code/ci/master/tree/snapwebsites/lib/snap_expr.cpp"" rel=""nofollow"">https://sourceforge.net/p/snapcpp/code/ci/master/tree/snapwebsites/lib/snap_expr.cpp</a></p>

<p>Go here to find the other files:</p>

<p><a href=""https://sourceforge.net/p/snapcpp/code/ci/master/tree/snapwebsites/lib"" rel=""nofollow"">https://sourceforge.net/p/snapcpp/code/ci/master/tree/snapwebsites/lib</a></p>

<p>However, instead of implementing an expression parser and execution environment, you may want to make use of an existing library (mine is an example, obviously, actually I have a tool named snapexpr under snapwebsites/src which will do exactly what you are talking about!) In that case you could also choose a different language. For example, Qt offers QScript:</p>

<p><a href=""http://qt-project.org/doc/qt-5/qtscript-index.html"" rel=""nofollow"">http://qt-project.org/doc/qt-5/qtscript-index.html</a></p>

<p>In that case, you have to write JavaScript code, but since JavaScript is relatively close to C++, it may work in your environment.</p>
",0
27561923,27561840,4,"<p>You return a heap-allocated object which means you transfer ownership. I would suggest you use <code>std::unique_ptr</code> as the return type</p>

<pre><code>std::unique_ptr&lt;Y&gt; func(param)
{
   return std::unique_ptr&lt;Y&gt;(new Y(param));
}
</code></pre>

<p>Even better is to use std::make_unique (if it is already available, otherwise write your own) or - if you use shared_ptr - std::make_shared. It is better for exception safety and in case of shared_ptr more efficient.</p>

<pre><code>std::unique_ptr&lt;Y&gt; func(param)
{
   return make_unique&lt;Y&gt;(param);
}

std::shared_ptr&lt;Y&gt; func(param)
{
   return std::shared_ptr&lt;Y&gt;(param);
}
</code></pre>

<p>And be aware that your <code>func</code> copied the parameter. You may want to use forwarding to avoid this.</p>

<pre><code>template&lt;class T, class U&gt;
std::unique_ptr&lt;T&gt; make_unique1(U&amp;&amp; u)
{
    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;U&gt;(u)));
}

template&lt;class T, class... U&gt;
std::unique_ptr&lt;T&gt; make_unique(U&amp;&amp;... u)
{
    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;U&gt;(u)...));
}
</code></pre>
",0
27563331,27561840,7,"<p>I recommend that you have <code>std::shared_ptr</code> as return type and <code>return std::make_shared&lt;Y&gt;()</code> to transfer ownership.<br><br>
Here is a working example that might help you:</p>

<pre><code>#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class Y {
public:
    Y(const std::string&amp; n)
    : name{n} {}

    std::string name;
};

std::shared_ptr&lt;Y&gt; func()
{
    return std::make_shared&lt;Y&gt;(""new class"");
}

int main()
{
    std::shared_ptr&lt;Y&gt; p_class = func();
    std::cout &lt;&lt; p_class-&gt;name;
    // outputs: ""new class""

    return 0;
}
</code></pre>
",0
31896606,31893585,0,"<p>You will want to place the<code>break;</code> statement as the last line of your conditional <code>if(...){...}</code> statement. When the program reaches the <code>break</code>statement, it will exit the while loop and proceed to the end of the program. Right now your loop is exited before <code>cout</code> has the new stream written to it and the total is updated.</p>

<p>Second, you want to put the value of total on the output stream:</p>

<pre><code>cout &lt;&lt; ""The sum is : "" &lt;&lt; total &lt;&lt; endl;
</code></pre>

<p>Currently, you are just printing out the string <code>""The sum is :""</code></p>

<p>Also, <code>system(""PAUSE"");</code> is a shell and OS dependent statement, and usually not seen as good coding practice. You may want to look into another way to accomplish this: <a href=""http://www.dreamincode.net/forums/topic/30581-holding-the-execution-window-open/"" rel=""nofollow"">http://www.dreamincode.net/forums/topic/30581-holding-the-execution-window-open/</a></p>
",0
31893615,31893585,0,"<p>To print a number do:</p>

<pre><code>cout&lt;&lt;""The sum is : "" &lt;&lt; total &lt;&lt; endl;
</code></pre>
",0
27532386,27532042,1,"<p>Assuming <code>getSex</code> just returns an M or an F as a char, <code>if (stud.getSex() == 'M')</code> should be sufficient.  As an aside, I did not believe that I would ever see the call <code>stud.getSex()</code>, let alone in such a completely innocent context.</p>
",1
27532405,27532042,0,"<p>Correct function</p>

<pre><code>while (!input.eof()) 
{
    stud.read(input);
    if ((stud.getSex() == 'M') | (stud.getSex() == ""m""))
    {
        stud.print();
    }

}
</code></pre>

<p>This should check your object's sex and return it as string to be checked.</p>
",3
29222185,29222134,0,"<p>Write a function to apply the operator. You also need to consider your types - if you just use integers, things like 3/2 may not do what you expect...</p>

<p>If it was me I'd probably use an <code>enum</code> instead of the ASCII operator code.</p>

<pre><code>int getResult(int op1, int op, int op2)
{
    int result = 0;
    if (op== '+') {
        result = op1 + op2;
    }
    else ...

    return result;
}
</code></pre>

<p>You would call it like: <code>printf( ""The result of %d %c %d is: %d"", 4, getOperation, 3, getResult(4, getOperation, 3) );</code> (note printing the operator as <code>%d</code> wont do what you expect and the name <code>getOperator</code> is very misleading.</p>
",2
33600972,33600905,3,"<p><code>std::partition</code> expects the predicate to take a const reference (i.e. <code>const WeightedPoint&amp;</code> in this case), but your predicate signature takes a const pointer. This is where your current compile error comes from. To remove that, for example change</p>

<pre><code>[=](const WeightedPoint *data)-&gt;bool {return data-&gt;pointWeight &lt; key-&gt;pointWeight; }
</code></pre>

<p>to</p>

<pre><code>[=](const WeightedPoint&amp; data)-&gt;bool {return data.pointWeight &lt; key-&gt;pointWeight; }
</code></pre>
",0
27566792,27566406,0,"<p>Check the documentation</p>

<p><a href=""http://en.cppreference.com/w/cpp/algorithm/inner_product"" rel=""nofollow"">http://en.cppreference.com/w/cpp/algorithm/inner_product</a></p>

<p>You are passing values not the iterators. this fuction can create product for longer vectors, so it requires start and end of the data, try this;</p>

<pre><code>std::inner_product(v1.begin(), v1.end(), v2.begin(), 0.0);
</code></pre>
",0
27572426,27572353,0,"<p>Maybe this is just overwhelming you. </p>

<p>Just start with the first line of main: What does </p>

<pre><code>    foo bar(0xe8e711395e65686d);
</code></pre>

<p>do? It creates a variable named bar, which has type foo, and a constructor is called with a parameter 0xe8e711395e65686d. So what does this do? </p>

<p>Reading the comment of Mooing Duck: What is it intended to do, and how do you fix it so that it will do what it is intended to do? </p>

<p>You have two for-loops: </p>

<pre><code>for (int i = 1; i &lt;= 10; i++)
for (int i = 1; i &lt;= 8; i++)
</code></pre>

<p>Both contain the same beginner's mistake. What is the mistake? Fix it. </p>

<p>At last in the output loop, you need to understand what a union is. The code is weird, but you should still be able to explain what it does. </p>
",0
29453809,29453772,0,"<pre><code>int pancakeCount(0), max_person(0);
for(int i=0;i&lt;4;i++){   
    cout&lt;&lt;""Enter how many pancakes eaten by the Person #""&lt;&lt;i&lt;&lt;"" : "";
    cin&gt;&gt;pancake;
    person[i] = pancake;            
}
for(int i=0;i&lt;4;i++){
    if(person[i]&gt;pancakeCount){
        pancakeCount = pancake[i];
        max_person = i;
    }
}

cout&lt;&lt;""The number of most eaten pancakes is ""&lt;&lt;pancakeCount&lt;&lt;"" by Person#""&lt;&lt;i&lt;&lt;endl;
</code></pre>
",0
29453820,29453772,0,"<p>split the loops for finding the max and printing the max. </p>

<p>Code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main(){
    int person[4];
    int pancake, pancakeMax, pancakeMin;
    for (int i = 0; i&lt;4; i++)
    {
        cout &lt;&lt; ""Enter how many pancakes eaten by the Person #"" &lt;&lt; i &lt;&lt; "" : "";
        cin &gt;&gt; pancake;
        person[i] = pancake;
    }

    //equate to one of the elements to make sure negative numbers are accomodated
    pancakeMax = pancakeMin = pancake;

    // most eaten
    for (int i = 0; i&lt;4; i++)
    {
        if (person[i]&gt;pancakeMax)
        {
            pancakeMax = person[i];
        }
    }
    for (int i = 0; i&lt;4; i++)
    {
        if (person[i] == pancakeMax)
        {
            cout &lt;&lt; ""The number of most eaten pancakes is "" &lt;&lt; pancakeMax &lt;&lt; "" by Person#"" &lt;&lt; i &lt;&lt; endl;

        }
    }

    //least eaten
    for (int i = 0; i&lt;4; i++)
    {
        if (person[i]&lt;pancakeMin)
        {
            pancakeMin = person[i];
        }
    }
    for (int i = 0; i&lt;4; i++)
    {
        if (person[i] == pancakeMin)
        {
            cout &lt;&lt; ""The number of least eaten pancakes is "" &lt;&lt; pancakeMin &lt;&lt; "" by Person#"" &lt;&lt; i &lt;&lt; endl;

        }
    }
    return 0;
}
</code></pre>

<p>You can add a break statement in the second loop if you think your logic needs just one value. Otherwise, right now, it give all occurances of maximum pancakes eaten.</p>

<p>If you are targetting efficiency you can merge the loops like so:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main(){
    int person[4];
    int pancake, pancakeMax, pancakeMin;
    int iMax, iMin;
    for (int i = 0; i&lt;4; i++){
        cout &lt;&lt; ""Enter how many pancakes eaten by the Person #"" &lt;&lt; i &lt;&lt; "" : "";
        cin &gt;&gt; pancake;
        person[i] = pancake;
    }

    //equate to one of the elements to make sure negative numbers are accomodated
    pancakeMax = pancakeMin = pancake;

    for (int i = 0; i&lt;4; i++){
        pancake = person[i];
        if (pancake&gt;pancakeMax){// most eaten
            pancakeMax = pancake;
            iMax = i;
        }
        if (pancake &lt; pancakeMin){//least eaten
            pancakeMin = pancake;
            iMin = i;
        }
    }

    cout &lt;&lt; ""The number of most eaten pancakes is "" &lt;&lt; pancakeMax &lt;&lt; "" by Person#"" &lt;&lt; iMax &lt;&lt; endl;
    cout &lt;&lt; ""The number of least eaten pancakes is "" &lt;&lt; pancakeMin &lt;&lt; "" by Person#"" &lt;&lt; iMin &lt;&lt; endl;

    return 0;
}
</code></pre>
",1
29453852,29453772,0,"<p>Hi your code is wrong algorithim try mine</p>

<pre><code>for(int i=0;i&lt;4;i++)
{   
  std::cout&lt;&lt;""Enter how many pancakes eaten by the Person #""&lt;&lt;i&lt;&lt;"" : "";
  std::cin&gt;&gt;pancake;
  person[i] = pancake;            
}
for(int i=0;i&lt;4;i++)
{
  if(person[i]&gt;pancakeCount)
     {
        pancakeCount = person[i];
        personWhoEatMost = i;
     }
}
std::cout&lt;&lt;""The number of most eaten pancakes is ""&lt;&lt;pancakeCount
         &lt;&lt;"" by Person#""&lt;&lt;personWhoEatMost&lt;&lt;std::endl;
</code></pre>
",1
29453910,29453763,1,"<p>Use array</p>

<pre><code>bool monday[30];
for(int i=0;i&lt;30;i++)
if(!monday[i])
std::cout&lt;&lt; ""monday[""&lt;&lt;i&lt;&lt;""]""&lt;&lt;std::endl;
</code></pre>
",0
29522086,29521923,1,"<p>Add member functions to the class that return the name and CWID.</p>

<pre><code>std::string getName() const {return name;}
int getCWID() const {return CWID;}
</code></pre>

<p>Then, add a non-member function to write the data out to a stream.</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Student const&amp; s)
{
   return out &lt;&lt; s.getName() &lt;&lt; "" "" &lt;&lt; s.getCWID();
}
</code></pre>
",1
29522118,29521923,0,"<p>Here is how you do it:</p>

<pre><code>class Student {
    std::string name;
    int CWID;
public:
    Student(std::string name = ""N/A"", int CWID = 99999999) : name(name), CWID(CWID) {}

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Student&amp; student);
};


std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Student&amp; student)
{
    stream &lt;&lt; '(' &lt;&lt; student.name &lt;&lt; "", "" &lt;&lt; student.CWID &lt;&lt; ')';
    return stream;
}
</code></pre>

<p>Please note that this overloaded function is not part of the class.</p>
",0
29522019,29521923,0,"<p>You could write non-member function</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Student&amp; stud)
{
  os &lt;&lt; stud.name &lt;&lt; "" "" &lt;&lt; stud.CWID;
  return os;
}
</code></pre>

<p>and declare it as friend function in your class</p>

<pre><code>class Student {
    std::string name;
    int CWID;
public:
    Student(std::string name = ""N/A"", int CWID = 99999999) : this-&gt;name(name), this-&gt;CWID(CWID) {}
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Student&amp; stud);
};
</code></pre>
",0
33581368,33581264,1,"<p>Make <code>_barkingVoice</code> a <code>std::shared_ptr&lt;VoiceResource&gt;</code>.</p>

<p>A <code>shared_ptr</code> does exactly what you need: uses references counting to track the deletion of the last object, when it will deallocate the resource.</p>
",2
33581376,33581264,2,"<p>First, why <code>VoiceResource</code> is not static? If it's shared between all instances of <code>Dog</code>, it should be. Else, you will need to load or copy the resuorce at every constructor call.</p>

<p>Have a static variable <code>static int instanceCount;</code>, that is set to <code>0</code>. In every casual, copy and move (C++11) constructor increment it, in destructor decrement it. That will give you opportunity to do what you wanted.</p>

<p>That will basicly work like <code>shared_ptr&lt;T&gt;</code> does, the might be a way to use it here instead of writing your own code, I just can't figure that out.</p>

<pre><code>class Dog {
public:
    Dog(const string &amp;name) : _name(name) {
        loadResource();
    }
    Dog(const Dog&amp; b) : name(b.name) {            
        loadResource();
    }
    // only C++11:
    Dog(Dog&amp;&amp; b) : name(std::move(b.name))  {
        loadResource();
    }

    ~Dog() {
        freeResource();
        _barkingVoice.free();
    }

    string getName() const { return _name; }
    void bark() { _barkingVoice.play(); }

private:
    string _name;
    static VoiceResource _barkingVoice;
    static int instanceCount;

    static void loadResource() {
        if (instanceCount == 0) {
            _barkingVoice.load();
        }
        ++instanceCount;
    }
    static void freeResource() {
        --instanceCount;
        if (instanceCount == 0) {
            _barkingVoice.free();
        }
    }
};
int Dog::instanceCount = 0;
</code></pre>
",2
33582021,33581264,2,"<p>Make a reusable class to encapsulate the reference counting:</p>

<pre><code>template&lt;class ResourceType, class OwnerType&gt;
class RefCounted {
public:
    RefCounted()          { if (++_refCount == 1) _resource.load(); }
    virtual ~RefCounted() { if (--_refCount == 0) _resource.free(); }
    ResourceType&amp; operator*()  { return  _resource; }
    ResourceType* operator-&gt;() { return &amp;_resource; }
private:
    static unsigned _refCount;
    static ResourceType _resource;
};

template&lt;class T, class U&gt; unsigned RefCounted&lt;T, U&gt;::_refCount = 0;
template&lt;class T, class U&gt; T RefCounted&lt;T, U&gt;::_resource;

class Dog {
public:
    Dog(const string &amp;name) : _name(name) { }

    string getName() const { return _name; }
    void bark() { _barkingVoice-&gt;play(); }

private:
    string _name;
    RefCounted&lt;VoiceResource, Dog&gt; _barkingVoice;
};
</code></pre>

<p>Every template instantiation will have their own <code>_refCount</code> and <code>_resource</code>.</p>

<p>The second template parameter is to handle cases where you instantiate <code>RefCounted</code> with the same <code>ResourceType</code> but want to have separate reference counting for those instantiations. E.g. if you add a <code>Cat</code> class and want it to have its own <code>Refcounted&lt;VoiceResource&gt;</code>:</p>

<pre><code>class Cat {
    // ...
private:
    RefCounted&lt;VoiceResource, Cat&gt; _meowingVoice;
};
</code></pre>
",1
29178390,29178362,7,"<p><code>main.cpp</code> and <code>Error.cpp</code> are different translation units. You define the macro only for <code>main.cpp</code>, not for <code>Error.cpp</code>.</p>

<p>You should either put your <code>#define</code> directives in a header file included by both .cpp files, or define these macros in project settings/makefile.</p>
",0
32980051,32979912,0,"<p>In the function <code>void removeItem(List&lt;Employee&gt;&amp;)</code>, in the line</p>

<pre><code>if (*iLoc == aID)
</code></pre>

<p>you are comparing a dereferenced iterator, i.e. an <code>Employee</code>, to an <code>unsigned int</code> (<code>aID</code>). The right hand side must be an <code>Employee</code> also, or <code>Employee</code> must have an implicit constructor that takes an <code>unsigned int</code> as a parameter, so the compiler may be able to convert <code>aID</code> to <code>Employee(aID)</code> when trying to resolve the call to <code>(*iLoc).operator==(aID)</code>.</p>

<p>Solution: define either</p>

<pre><code>bool Employee::operator==(const Employee &amp; rhs) const
{
    return comparison_here;
}
</code></pre>

<p>and make sure <code>Employee</code> has a constructor that takes an <code>unsigned int</code>, or create an overloaded <code>operator==</code> that takes an <code>unsigned int</code>,</p>

<pre><code>bool Employee::operator==(unsigned int rhs) const
{
    return comparison_here;
}
</code></pre>

<p>You may also consider defining <code>operator==</code> as a non-member function, so it can also take <code>unsigned int</code> as a left-hand-side parameter. More details: <a href=""https://stackoverflow.com/questions/4421706/operator-overloading"">Operator overloading</a></p>
",3
34229504,34229287,1,"<blockquote>
  <p>Are there specific instances in which this will cause problems for me?</p>
</blockquote>

<p>It will be a problem if the length of the string being copied to <code>buffer</code> is equal to or greater than <code>1024</code>.</p>

<p>You can use <code>snprintf</code> to prevent buffer overflow.</p>

<pre><code>sprintf(buffer, sizeof(buffer), ""Some cool information"");
</code></pre>

<p>It's not clear why you are using <code>sprintf</code> in the first place. If <code>""Some cool information""</code> is supposed to contain formatting directives and there are more arguments in the call to <code>sprintf</code>, what you are trying makes some sense. If there are no other arguments to <code>sprintf</code>, you can simply use:</p>

<pre><code>DATA += ""Some cool information"";
</code></pre>

<p>You can avoid the buffer size limitation problems by using <code>std::ostringstream</code>.</p>

<pre><code>std::ostringstream ostr;
ostr &lt;&lt; ""Some cool information"" &lt;&lt; and other arguments as needed;
DATA += ostr.str();
</code></pre>
",0
28173948,28173793,0,"<p><a href=""http://en.cppreference.com/w/cpp/algorithm/sort"" rel=""nofollow""><code>std::sort</code></a> requires that either it is passed a function/functor that meets the requirements of <a href=""http://en.cppreference.com/w/cpp/concept/Compare"" rel=""nofollow"">Compare</a> or that the type implement an <code>operator&lt;</code>. Therefore somewhere in that code must exist (at least for there to not be a compiler error)</p>

<pre><code>bool operator&lt;(const VertexIndex&amp; lhs, const VertexIndex&amp; rhs)
{
    //comparison logic here
}
</code></pre>
",0
28174072,28173793,0,"<p>The answer is easy:
Whatever
<code>bool operator&lt;(const VertexIndex&amp;a,const VertexIndex&amp;b);</code>
or
<code>bool VertexIndex::operator&lt;(const VertexIndex&amp;other) const;</code>
compares will be the criterion.</p>
",0
27677888,27677851,2,"<p>Arrays are going from <code>0</code> to <code>n-1</code>, so <code>CreateArea</code> loops are incorrect:</p>

<pre><code>for (int i = -1; i &lt;= f; i++){
    for (int j = -1; j &lt;= c; j++){
</code></pre>

<p>-1 is not a valid array index! You must go from 0 to f or c. Most likely excluding f and c if they are zero-based (that's what people often do as indexes of your array are from 0 to 99):</p>

<pre><code>for (int i = 0; i &lt; f; i++){
    for (int j = 0; j &lt; c; j++){
</code></pre>

<p>Also check that f and c are lower than 100 at the beginning of the function! Then, you'll be sure you never write outside array bounds...</p>
",3
32415330,32415282,2,"<p>However you could use <strong><em>std::getline</em></strong></p>

<blockquote>
  <p>Which uses a string instead of a char array. It's easier to use string
  since they know their sizes, they auto grow etc. and you don't have to
  worry about the null terminating character and so on. Also it is
  possible to convert a char array to a string by using the appropriate
  string contructor.</p>
</blockquote>

<p>You can do it by <a href=""http://www.cplusplus.com/reference/sstream/stringstream/str/"" rel=""nofollow"">stringstream</a>:</p>

<pre><code>// stringstream::str
#include &lt;string&gt;       // std::string
#include &lt;iostream&gt;     // std::cout
#include &lt;sstream&gt;      // std::stringstream, std::stringbuf

using namespace std;
int main ()
{
    std::string str;
    getline( std::cin, str );
    std::stringstream ss;
    ss&lt;&lt;str;
    std::string s;
    while(ss&gt;&gt;s)
    {
        std::cout &lt;&lt; s &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>

<p>Input: <code>I am a boy</code></p>

<p>Output:</p>

<pre><code>I
am
a
boy
</code></pre>

<p>If you think that, you want each word to store in a <code>vector</code>, you can do it like:</p>

<pre><code>// stringstream::str
#include &lt;string&gt;       // std::string
#include &lt;iostream&gt;     // std::cout
#include &lt;sstream&gt;      // std::stringstream, std::stringbuf
#include &lt;vector&gt;
using namespace std;
int main ()
{
    vector &lt;string&gt; V;
    V.clear();
    std::string str;
    getline( std::cin, str );
    std::stringstream ss;
    ss&lt;&lt;str;
    std::string s,s1;
    while(ss&gt;&gt;s)
    {
        V.push_back(s);
    }
    return 0;
}
</code></pre>
",4
25527124,25526991,1,"<p>The body of <code>getFeet()</code> isnt defined, but given that it returns an <code>int</code>, and the <code>feet</code> member of d2 was most recently set to ""1"", assuming the missing code meakes sense, the printout would be ""1"".</p>
",2
30157877,30157775,7,"<p>If you are able to use C++ streams, you could use the <code>fill</code> method to set the character of the padding and use the <code>setw</code> modifier from <code>&lt;iomanip&gt;</code> to set the padding of the next output operation.</p>

<pre><code>for(int x = 1 ; x &lt;= 4; x++)
{
    char prev = std::cout.fill(x + '0');
    std::cout &lt;&lt; std::setw(x) &lt;&lt; x &lt;&lt; std::endl;
    std::cout.fill(prev);
}
</code></pre>

<p>Notice this works only for numbers up to 9, I assume that's a non issue for you.</p>
",2
30157793,30157775,2,"<p>You'll have to actually print <code>x</code> <code>x</code> times:</p>

<pre><code>for (int x = 1; x &lt;= 4; ++x) {
    for (int i = 0; i &lt; x; ++i) {
        printf(""%d"", x);
    }
    printf(""\n"");
}
</code></pre>

<p>Or, since this is C++:</p>

<pre><code>for (int x = 1; x &lt;= 4; ++x) {
    for (int i = 0; i &lt; x; ++i) {
        std::cout &lt;&lt; x;
    }
    std::cout &lt;&lt; '\n';
}
</code></pre>

<p>Alternatively, you can use the <a href=""http://en.cppreference.com/w/cpp/string/basic_string/basic_string"" rel=""nofollow""><code>string</code></a> constructor that makes multiple copies of the same char (#2 in the reference):</p>

<pre><code>for (int x = 1; x &lt;= 4; ++x) {
    std::cout &lt;&lt; std::string(x, x + '0') &lt;&lt; '\n';
}
</code></pre>
",1
28160935,28160778,2,"<p>You are mixing <code>unsigned</code> (presumably 32-bits) with values that need 64 bits. </p>

<p>For example, <code>frac_num</code> is only 32-bits, use a <code>long</code> or <code>long long</code>... [or <code>uint64_t</code>, which is a more reliable way to get a 64-bit value. </p>

<pre><code>inline double fraction(double x)
{
    // Get the fraction
    uint64_t frac_mask = (1ul &lt;&lt; 52) - 1;                      // Get 52 1's
//    uint64_t xint = *reinterpret_cast&lt;uint64_t*&gt;(&amp;x);        // Interpret x's bits as an int
      uint64_t xint; 
      memcpy(&amp;xint, &amp;x, sizeof(xint));        // Interpret x's bits as an int
    int64_t frac_num = xint &amp; frac_mask;                                    // Get the fraction as an int
    frac_num += 1ul &lt;&lt; 52; // Add hidden bit.
    double fraction = double(frac_num) / double(2ul &lt;&lt; 52);              // Divide frac_num by 2^52

    return fraction;
}
</code></pre>

<p>Note the addition of <code>l</code> to the <code>1u</code> and <code>2u</code>, to ensure they are <code>long</code>, and. You will need to include <code>cstdint</code> to get the sized integers.</p>

<p>Edit: that will of course just give you the mantissa in the form of a fraction. The decimal point may be anywhere between bit 1023 and -1023, meaning that only values between -1 and +1 will have the correct result. </p>

<p>A complete example using the code above [+ some printouts]</p>

<pre><code>#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

inline double fraction(double x)
{
    // Get the fraction
    uint64_t frac_mask = (1ul &lt;&lt; 52) - 1;                      // Get 52 1's
    std::cout &lt;&lt; ""mask="" &lt;&lt; std::hex &lt;&lt; frac_mask &lt;&lt; std::endl;
//    uint64_t xint = *reinterpret_cast&lt;uint64_t*&gt;(&amp;x);        // Interpret x's bits as an int
      uint64_t xint; 
      memcpy(&amp;xint, &amp;x, sizeof(xint));        // Interpret x's bits as an int
    int64_t frac_num = xint &amp; frac_mask;                                    // Get the fraction as an int

    frac_num += 1ul &lt;&lt; 52; // Add hidden bit.
    std::cout &lt;&lt; ""xint="" &lt;&lt; std::hex &lt;&lt; xint &lt;&lt; "" num="" &lt;&lt; std::hex &lt;&lt; frac_num &lt;&lt; std::endl;
    double fraction = double(frac_num) / double(2ul &lt;&lt; 52);              // Divide frac_num by 2^52

    return fraction;
}


int main()
{
    double a = 0.5;
    double b = 0.75;
    double d = 6.5;
    double e = 4.711;


    double fa  = fraction(a);
    double fb  = fraction(b);
    double fd  = fraction(d);
    double fe  = fraction(e);

    std::cout &lt;&lt; ""fa="" &lt;&lt; std::fixed &lt;&lt; fa &lt;&lt; "" fb="" &lt;&lt; fb &lt;&lt; std::endl;
    std::cout &lt;&lt; ""fd="" &lt;&lt; std::fixed &lt;&lt; fd &lt;&lt; "" fe="" &lt;&lt; fe &lt;&lt; std::endl;
}
</code></pre>

<p>resutl of running the above:</p>

<pre><code>mask=fffffffffffff
xint=3fe0000000000000 num=10000000000000
mask=fffffffffffff
xint=3fe8000000000000 num=18000000000000
mask=fffffffffffff
xint=401a000000000000 num=1a000000000000
mask=fffffffffffff
xint=4012d810624dd2f2 num=12d810624dd2f2
fa=0.500000 fb=0.750000
fd=0.812500 fe=0.588875
</code></pre>

<p>Note that if you divide 4.711 by 2 a few times [3 times to be precise], you get 0.588875, and if you divide 6.5 by 8 (or by 2 three times over), you get 0.8125</p>

<p>I need to go to bed, but you basically have to take the exponent into account to figure out the fraction of a floating point number. Or simply convert to an integer, and subtract it - as long as it's within range.</p>
",5
28487149,28487115,4,"<p>A possible solution is to read every line with e.g. <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow"">std::getline</a> then parse each such line string. You'll use the appropriate methods of <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow"">std::string</a> to search inside it (with <a href=""http://en.cppreference.com/w/cpp/string/basic_string/find"" rel=""nofollow"">find</a>) and split it (with <a href=""http://en.cppreference.com/w/cpp/string/basic_string/substr"" rel=""nofollow"">substr)</a>. You might also access some individual character in that string using <a href=""http://en.cppreference.com/w/cpp/string/basic_string/at"" rel=""nofollow"">at</a> or the <code>[]</code> operator of <code>std::string</code>; alternatively, you might perhaps parse each line -or relevant parts of them- using <a href=""http://en.cppreference.com/w/cpp/io/basic_istringstream"" rel=""nofollow"">std::istringstream</a> (I am not sure it is appropriate in your case). You might be interested by <a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string"" rel=""nofollow"">std::to_string</a>...</p>

<p>An important thing is to define <em>exactly</em> (not only thru examples) the possible acceptable inputs. You could for example use some <a href=""http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form"" rel=""nofollow"">EBNF</a> to formalize that. You should probably care about <a href=""http://en.wikipedia.org/wiki/Character_encoding"" rel=""nofollow"">character encoding</a> (try first by assuming a simple single-byte encoding like <a href=""http://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII</a>, then later consider <a href=""http://en.wikipedia.org/wiki/UTF-8"" rel=""nofollow"">UTF-8</a> if your system uses it).</p>

<p>For example, can the station names (I guess you talk about subway stations) contain digits, or spaces, or underscores, or commas, etc.... ? Could they be French <a href=""http://www.ratp.fr/"" rel=""nofollow"">names</a> like <em>H?tel de Ville</em> (a metro station in central Paris) or <em>Saint-Paul</em> or <a href=""http://www.bourg-la-reine.fr/"" rel=""nofollow""><em>Bourg-La-Reine</em></a> (where I am), or Russian names like <a href=""http://www.mosmetro.ru/stations/arbatsko_pokrovskaya/molodezhnaya/"" rel=""nofollow"">§®§à§Ý§à§Õ§×§Ø§ß§Ñ§ñ</a> in Moscow? (I guess that station names in Tokyo or in Jerusalem might be even funnier to parse).</p>

<p>BTW, explicitly entering the number of entries (like your initial <code>4</code>) is very user-unfriendly. You could have some lexical conventions and e.g. use some tagging or separators.</p>

<p>At last, you might want to keep the information for every travel. Then you'll probably need to define some <code>struct</code> or <code>class</code> (not simply four <em>scalar</em> variables). At that point your program is becoming more interesting!</p>
",2
28487797,28487115,1,"<p>I recommend that you create a <code>struct</code> to hold your stations:</p>

<pre><code>struct station{
    string _stationName;
    int _studentPass;
    int _adultPass;
};
</code></pre>

<p>Then create an operator to use with your struct (props to <a href=""https://stackoverflow.com/users/3357248/sly-theking"">Sly_TheKing</a> for the <code>getline</code> idea):</p>

<pre><code>std::istream&amp; operator&gt;&gt;(std::istream&amp; is, station&amp; rhs){
    getline(is, rhs._stationName, ';');
    is &gt;&gt; rhs._studentPass &gt;&gt; rhs._adultPass &gt;&gt; ws;
    return is;
}
</code></pre>

<p>Say that your <code>ifstream</code> is called <code>foo</code>. You can read these into a <code>vector</code> like this:</p>

<pre><code>foo.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');

vector&lt;station&gt; bar{istream_iterator&lt;station&gt;(foo), istream_iterator&lt;station&gt;()};
</code></pre>
",0
28488731,28487115,1,"<p>First group your variables in struct.</p>

<pre><code>struct MyStruct
    {
        int studentPass;
        int adultPass;
        string stationName;
    };
</code></pre>

<p>Now read size of struct in file and allocate it dynamically</p>

<pre><code>MyStruct *p;

s &gt;&gt; N;
p = new MyStruct[N];
</code></pre>

<p>Now in for loop you read string with delimiter <code>';'</code> and other two vars are ints</p>

<pre><code>for (int i = 0; i &lt; N; i++)
{
    getline(s, p[i].stationName, ';');
    s &gt;&gt; p[i].studentPass &gt;&gt; p[i].adultPass;
}
</code></pre>

<p>Where var <code>s</code> is istream type of variable with flag <code>std::in</code></p>
",1
32391128,32389944,0,"<p>If you use std::string instead of char you could use the truncate functions from boost.</p>
",0
32390013,32389944,0,"<p>use regex <code>\\s+</code> to match all space characters and use <code>regex_replace</code> to remove it</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main()
{
   std::string text = ""Quick brown fox"";
   std::regex spaces(""\\s+"");

   // construct a string holding the results
   std::string result = std::regex_replace(text, spaces, """");
   std::cout &lt;&lt; '\n' &lt;&lt; text &lt;&lt; '\n';
   std::cout &lt;&lt; '\n' &lt;&lt; result &lt;&lt; '\n';
}
</code></pre>

<p><strong>reference</strong>: <a href=""http://en.cppreference.com/w/cpp/regex/regex_replace"" rel=""nofollow"">http://en.cppreference.com/w/cpp/regex/regex_replace</a></p>
",1
32392090,32389944,0,"<p>Use <code>std::string</code> to do it</p>

<pre><code>std::string a(""123     "");
std::string b(""123"");
a.erase(std::remove_if(a.begin(), a.end(), ::isspace), a.end());
if (a == b)
    std::cout &lt;&lt; ""Same"";
</code></pre>

<p>The difference made by <code>using</code> will be</p>

<pre><code>using namespace std;
string a(""123     "");
string b(""123"");
a.erase(remove_if(a.begin(), a.end(), ::isspace), a.end());
if (a == b)
    cout &lt;&lt; ""Same"";
</code></pre>

<p>It is generally advised not to use the <code>using namespace std</code>. Don't forget to include <code>&lt;string&gt;</code> and <code>&lt;algorithm&gt;</code>.</p>

<p><strong>EDIT</strong> If you still want to do it the C way, use the function from this post</p>

<p><a href=""https://stackoverflow.com/a/1726321/2425366"">https://stackoverflow.com/a/1726321/2425366</a></p>

<pre><code>void RemoveSpaces(char * source) {
    char * i = source, * j = source;
    while (*j != 0) {
        *i = *j++;
        if (*i != ' ') i++;
    }
    *i = 0;
}
</code></pre>
",0
31260176,31260138,1,"<p>I'm presuming you want to add the two Matrix's together? You can iterate like this:</p>

<pre><code>Matrix&lt;int&gt; mp3 = Matrix&lt;int&gt;(2, 2);

for (unsigned int i = 0; i &lt; 2; i++)
{
   for (unsigned int j = 0; j &lt; 2; j++)
   {
        mp3[i][j] = mp1[i][j] + mp2[i][j];
   }
}
</code></pre>
",0
32415934,32415455,0,"<p>You could use <code>std::array</code></p>

<p>This is simply an array on the stack, just like you used, but has iterators, type safe, bound safe, use value semantics and work with most stl algorithm.</p>

<p>It is declared like this:</p>

<pre><code>array&lt;string, 3&gt; myArray;
</code></pre>

<p>And it must be passed by reference, because passing by value will copy it's content:</p>

<pre><code>void doSomething(array&lt;int, 6&gt;&amp; aArray) {
    // do something
}
</code></pre>

<p>Notice that you must specify the length of the array, since it's a template parameter. If you want to have an array of any size, use tempaltes:</p>

<pre><code>template&lt;size_t length&gt;
void foobar(array&lt;double, length&gt; theArray) {
    // do something else
} 
</code></pre>
",0
27682418,27682339,0,"<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    cout &lt;&lt; ""Hello"";
    getchar();
    return 0;
}
</code></pre>
",1
32415436,32415388,4,"<pre><code> int i=p*p;
</code></pre>

<p><code>p*p</code> is replaced as <code>5+3*5+3</code> ,thus  gives <code>23 (5+15+3=23)</code>.As you know <code>*</code> will be evaluated before <code>+</code> .</p>

<p>Define macro as follows -</p>

<pre><code>#define p (5+3)
</code></pre>
",0
32415437,32415388,7,"<p><code>p</code> will be replaced by <code>5+3</code>. So the line <code>int i=p*p;</code> is <code>int i=5+3*5+3;</code>. <code>*</code> has an higher rank than <code>+</code>, so the result is <code>23</code>.</p>

<p>You need to paranthese your define:</p>

<pre><code>#define p (5+3)
</code></pre>
",0
31121655,31121580,4,"<p>You may add an overload:</p>

<pre><code>bool testequal(const Point&amp; p1, Point&amp; p2) const;
bool testequal(const Point&amp; p1) const
{
    Point dummy;
    return testequal(p1, dummy);
}
</code></pre>
",4
34199196,34199126,1,"<p>The warning is correct and practically is an error. You're declaring the char array locally so it will be deleted after going out of scope of that function and its address will be no more valid.</p>

<p>Since you're using c++ avoid char array and use a <code>std::string</code>.</p>
",0
34199323,34199126,1,"<p>If you want to access to the internal storage of your string you can call <code>line.c_str()</code> which returns a <code>const char *</code>.</p>

<p>Hence you won't need you function <code>toChar</code> that creates a local array that will go out of scope at the end of your function.</p>

<p>You could simply do :</p>

<pre><code>int main()
{
    string lines[0] = ""line1"";
    const char* a = lines[0].c_str();


    return 0;
}
</code></pre>

<p>But I advise you to keep manipulating <code>std::string</code> as they will handle string better than a simple <code>char *</code>.
And if you want a copy, just do it : <code>std::string mycopy = lines[0]</code>.</p>
",5
34199489,34199126,3,"<p>First use a <code>const &amp;</code> in passing the string to the function to avoid the unnecessary copying, and be able to use temporaries, e.g. <code>toChar(""I am temp"");</code></p>

<p>The are the following alternatives:</p>

<blockquote>
  <p>(1) Return std::string </p>
</blockquote>

<pre><code> std::string toChar(std::string const &amp; line)
 {
     char a[1024];
     strcpy(a, line.c_str());
     return a;
 }
</code></pre>

<p><em>Of course it is assumed that <code>line</code> is smaller than 1024 chars with the null termination symbol</em> </p>

<blockquote>
  <p>(2) Return an allocated array the </p>
</blockquote>

<pre><code>char * toChar(std::string const &amp; line)
{
  char * a = new char[1024];
  strcpy(a, line.c_str());
  return a;
}
</code></pre>

<p>but you will have to actually manage it and delete it later.</p>

<blockquote>
  <p>(3) Allocate the array and pass it to the function</p>
</blockquote>

<pre><code>void toChar(string const &amp; line, char a[])
{
 strcpy(a, line.c_str());
}
</code></pre>

<p>I imagine that you actually want to extract a C-string from an std::string , or some part of it. The proper way to do it is (3).</p>
",3
29532794,29524965,0,"<p>First of all you have mixed C code with some C++ elements which is a bit confusing for what you wish to do (maybe you come from C background). Anyway in order to find the longest word in characters in a text file I whould suggest the following solution:</p>

<pre><code>std::ifstream in(file.txt);
std::string dataline;
std::map&lt;int,std::string&gt; items;
while (getline(in,dataline)){
    std::istringstream ss(dataline);
    std::string item;
    while (getline(ss,item,' ')){
        items.insert(std::make_pair(item.size(),item));
    }
}
std::string largestWord = items.rbegin()-&gt;second;
</code></pre>
",0
32477467,32477381,1,"<p>The postfix increment and decrement operators will always be performed after the current value is used, so in the code shown in the question <code>10</code> will be returned. What the value of <code>top</code> is in the function afterwards doesn't matter, since the function will no longer be executing. If the compiler is smart enough, it might optimize away the actual decrement since it's ""dead code"".</p>
",0
32477490,32477381,1,"<p><code>top--</code> will decrement <code>top</code> and return the original, so <code>test</code> will return <code>10</code>. If <code>top</code> has local storage duration, theoretically it will have a value of <code>9</code> when the function returns, but that doesn't really mean anything as the function is over and the whole calculation will likely be optimized out anyway. If <code>top</code> has non-local storage then you can rely on it being <code>9</code> when the function exits.</p>
",0
32477564,32477381,2,"<p>The return value of test() in this case will be 10; The decrement on the 'top' variable will occur after the function's return value has been returned.</p>

<p>So say you have top as a global</p>

<pre><code>int top;

int test()
{
    top = 10;
    return top--;
}

int main()
{
    top = 0;

    int tmp = test();

    std::cout &lt;&lt; ""top "" &lt;&lt; top &lt;&lt; "" tmp "" &lt;&lt; tmp &lt;&lt; std::endl; // top = 9, tmp = 10
    return 0;
}
</code></pre>
",0
28226755,28226659,5,"<h1>Single Responsibility Principle</h1>
<p>Learn it. Love it. Follow it. Write code where each part has one and only one responsibility.</p>
<p>In this case, I'd start with a struct that does nothing but store one item from the input file:</p>
<pre><code>struct item { 
    std::string item;
    std::string action;
    int price;
};
</code></pre>
<p>Then I'd write a piece of code that just reads one item from a file into a struct:</p>
<pre><code>std::istream &amp;operator&gt;&gt;(std::istream &amp;is, item &amp;i) { 
    std::getline(is, i.name, ',');
    std::getline(is, i.action, ',');
    return is &gt;&gt; i.price;
}
</code></pre>
<p>Then write code to read data from a file into a vector of items:</p>
<pre><code>std::ifstream infile(&quot;input.txt&quot;);

std::vector&lt;item&gt; items {
    std::istream_iterator&lt;item&gt;(infile),
    std::istream_iterator&lt;Item&gt;(),
};
</code></pre>
<p>From there, it sounds like you want to partition the data into a portion for &quot;wanted&quot; items, and a portion for &quot;for sale&quot; items. Then you'd match up &quot;for sale&quot; items with &quot;wanted items&quot; where the item description is the same, and the selling price is less than or equal to the buying price.</p>
<p>To do that, you'd probably want to start with <code>std::partition</code> to separate the for-sale from the wanted items.</p>
<p>Then you'd use <code>std::sort</code> to sort each half (probably on name and price).</p>
<p>Finally, you could use <code>std::set_symmetric_difference</code> to remove matching wanted/for-sale items.</p>
",2
28227604,28226659,0,"<p>Jerry Coffin has outlined the basic idea of requirement-based software development, and provided the first step: Decide how to store your basic data (a ""schema,"" if you like).</p>

<p>Next, you need to find an algorithm that will solve the problem. You've described it in somewhat obtuse mechanical terms, but the purpose of this program seems to be, ""match buyers with sellers, and print the listings that couldn't be matched.""</p>

<p>Let's tackle this with a list of buyers and a list of sellers. We can broker a deal if the asking price and the selling price are exactly equal. (This isn't particularly realistic, but it seems to be the intent reflected in the example data set.)</p>

<p>If the lists of buyers and sellers are both sorted, we can simply read them in the same order and quickly see who is missing. Think of it like an attendance roll call: it's easy to see who is absent from class, given a list of enrolled students and an alphabetized sign-in sheet. Scanning through the list of <a href=""http://en.cppreference.com/w/cpp/algorithm"" rel=""nofollow"">algorithms in the C++ standard library</a>, I can find <a href=""http://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference"" rel=""nofollow"">std::set_symmetric_difference</a> which does this sort of ""attendance check.""</p>

<p>To sort the data, we need to define a less-than relationship. We'll sort buyers before sellers, so as to treat the two halves of the sorted data as separate lists. This relationship may be called <code>operator &lt;</code>, making it an operator overload. Once they're separated, we need a different less-than relationship to define the ""alphabetization"" of the ""attendance check."" This one gets a more descriptive name, <code>item_price_comparison</code>, since it's ignoring the information about buying/selling. (It will always be used to compare one buyer against one seller.)</p>

<pre><code>#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;

typedef std::string item_action;
const item_action sell = ""for sale"";
const item_action buy = ""wanted"";

struct item {
    item_action action;
    std::string item;
    int price;
};

// Compare such that matching ""buy"" and ""sell"" are equal.
// (Neither is less-than the other.)
bool item_price_comparison( item const &amp; lhs, item const &amp; rhs ) {
    return lhs.item &lt; rhs.item? true
        : rhs.item &lt; lhs.item? false
        : lhs.price &lt; rhs.price;
}

// Compare such that sells come before buys.
bool operator &lt; ( item const &amp; lhs, item const &amp; rhs ) {
    return lhs.action &lt; rhs.action? true
         : rhs.action &lt; lhs.action? false
         : lhs.item &lt; rhs.item? true
         : rhs.item &lt; lhs.item? false
         : lhs.price &lt; rhs.price;
}

std::istream &amp; operator &gt;&gt; ( std::istream &amp; s, item &amp; i ) {
    std::getline( s &gt;&gt; std::ws, i.item, ',');
    std::getline( s &gt;&gt; std::ws, i.action, ',');
    s &gt;&gt; i.price;
    return s;
}

std::ostream &amp; operator &lt;&lt; ( std::ostream &amp; s, item const &amp; i ) {
    s &lt;&lt; i.item &lt;&lt; "", "";
    s &lt;&lt; i.action &lt;&lt; "", "";
    s &lt;&lt; i.price &lt;&lt; ""\n"";
    return s;
}

int main() {
    std::ifstream file( ""messageBoard.txt"" ); // Open the file.
    std::vector&lt; item &gt; items; // Create the ""database.""
    std::copy( std::istream_iterator&lt; item &gt;( file ), {},
               std::back_inserter( items ) ); // Read the data.

    std::sort( items.begin(), items.end() ); // Organize the data.
    // Split list: items before first_buyer are for sale, after are wanted.
    auto first_buyer = std::lower_bound( items.begin(), items.end(),
                           item{ buy } );

    std::set_symmetric_difference( // Find mismatches between...
        items.begin(), first_buyer, // ... the list of sellers...
        first_buyer, items.end(), // ... and the list of buyers...
        std::ostream_iterator&lt; item &gt;( std::cout ), // and print the results.
        item_price_comparison // Let matching buy and sell be equal.
    );
}
</code></pre>

<p>A small change will make this program a better broker, by matching a buyer with a seller whose asking price is lower.</p>

<pre><code>// Compare such that matching ""buy"" and ""sell"" are equal.
// (Neither shall be less-than the other if they have a deal.)
// Assume that we are comparing one buy with one sell.
bool item_price_comparison( item const &amp; lhs, item const &amp; rhs ) {
    item const &amp; buyer = lhs.action == buy? lhs : rhs;
    item const &amp; seller = lhs.action == sell? lhs : rhs;

    return lhs.item &lt; rhs.item? true
        : rhs.item &lt; lhs.item? false
        : seller.price &lt; buyer.price? false // We have a deal.
        : lhs.price &lt; rhs.price; // Usual rule applies if no deal.
}
</code></pre>

<p>This broker will pick the first buyers, which are the ones with the lowest offers, and leave very high bids in the lurch. You can remedy that problem by sorting greatest-to-least, but that's well beyond the requirements.</p>
",0
32420610,32420508,-2,"<p>Works as expected. Just command line window with result is closed just after your program ends, so you can't see it.</p>
",2
32420707,32420508,-1,"<p>when you will input a string without spaces then it will work fine . 
but if you are going to enter a string with spaces its behaviour changes as it is going to read the string only upto the space.</p>

<p>For this you can use getline or fgets or sscanf in your code instead of scanf .i.e</p>

<p>try to replace the line  :</p>

<pre><code>scanf("" %s"",&amp;n4m3);
</code></pre>

<p>with   </p>

<p><code>fgets(n4m3,100,stdin);</code></p>

<p>it should work for sure.</p>
",5
32420775,32420508,3,"<p>It's not working because <code>scanf</code> wants a <code>char *</code> and you are passing it a <code>char (*)[100]</code>. To fix this, remember that an array is a contiguous block of memory, and the name of the array is a pointer to the start of that memory. Therefore, <code>n4m3</code> is already a <code>char *</code>, and there is no need to take the address of it with the <code>&amp;</code>. </p>

<p>The line should be <code>scanf("" %s"",n4m3); //no '&amp;'</code>. </p>

<h2>Relevant Notes</h2>

<p>I found this by compiling your code with warnings enabled. You should <strong>always</strong> do this! Compiling on Linux or Mac with clang flags <code>-Wall -Wextra -pedantic</code> yields several warnings for this code. The relevant one is:</p>

<pre><code>tmp.cpp:9:13: error: format specifies type 'char *' but the argument has type
  'char (*)[100]' [-Werror,-Wformat]
scanf("" %s"",&amp;n4m3);
        ~~  ^~~~~
</code></pre>

<p>Googling the error brought me <a href=""https://stackoverflow.com/questions/27805793/why-am-i-getting-warnings-about-this-code-example-what-is-proper"">here</a>, which fixes the problem. Another warning is:</p>

<pre><code>tmp.cpp:51:10: error: variable 'T' is used uninitialized whenever 'if' condition
      is false [-Werror,-Wsometimes-uninitialized]
else if (gI&gt;=1000)
         ^~~~~~~~
tmp.cpp:54:24: note: uninitialized use occurs here
    printf(""\n Tax:%d"",T);
                       ^
tmp.cpp:51:6: note: remove the 'if' if its condition is always true
else if (gI&gt;=1000)
     ^~~~~~~~~~~~~
tmp.cpp:5:15: note: initialize the variable 'T' to silence this warning
int rt,hr,gI,T,td,ss=100,pi=100,hc=100,NetIn;
              ^
               = 0
</code></pre>

<p>There are more warnings that I'll let your compiler (once you set it up correctly) find. On Windows, increase Visual Studio's <a href=""http://blogs.msdn.com/b/vcblog/archive/2010/12/14/off-by-default-compiler-warnings-in-visual-c.aspx"" rel=""nofollow noreferrer"">warning levels</a> by using <a href=""http://mihai-nita.net/2010/05/10/changing-default-vs-warning-level/"" rel=""nofollow noreferrer"">these instructions</a>. You will save many hours of work if you let your compiler analyze code for you.</p>
",4
31165102,31165044,1,"<p>Use the <code>list</code> iterator:</p>

<pre><code>for (std::list&lt;Task&gt;::iterator it = tasks.begin(); it != tasks.end(); ++it){
    // `it` is a reference to an element of the list&lt;Task&gt; so you must dereference
    // with *it to get the object in your list

    for (std::list&lt;Insts&gt;::iterator it2 = it-&gt;inst.begin(); it2 != it-&gt;inst.end(); ++it2){
       // it2 will now reference the elements within list&lt;Insts&gt; of an object Task
    }
}
</code></pre>
",3
32427687,32427590,3,"<p>Your Line #4 reads from <code>a[j][i]</code> many times, and the first time through the inner loop, when <code>k == i</code>, changes <code>a[j][i]</code> to 0.0f, thus breaking the next <code>n-i</code> iterations.</p>

<p>Reordering reads of a variable with a write to the same location is not safe.</p>
",1
28162942,28162907,3,"<p>This is the declaration of a new variable named <code>generate_primes</code></p>

<pre><code>vector&lt;int&gt; generate_primes(7919);
</code></pre>

<p>The variable will hide the function using the same name in a larger scope.</p>

<p>What you wanted was a call to the function you already created, perhaps:</p>

<pre><code>vector&lt;int&gt; primes_list;
generate_primes(7919).swap(primes_list);
</code></pre>

<p>Since C++11, it's just as efficient to use move initialization:</p>

<pre><code>vector&lt;int&gt; primes_list = generate_primes(7919);
</code></pre>

<p>You would also be well advised to do that outside the loop... right now your prime printing program is about the slowest imaginable (at least, of those that actually do make progress).</p>
",4
28162943,28162907,1,"<p>This line</p>

<pre><code> vector&lt;int&gt; generate_primes(7919);
</code></pre>

<p>Is only generating a variable called <code>generate_primes</code> with the default size 7919.</p>

<p>See <a href=""http://www.cplusplus.com/reference/vector/vector/vector/"" rel=""nofollow"">http://www.cplusplus.com/reference/vector/vector/vector/</a></p>

<p>The function is not called.</p>
",0
27765015,27764878,0,"<p>This statement</p>

<pre><code>SelectionSort();
</code></pre>

<p>creates a temporary object of type <code>SelectionSort</code>, and that's it.</p>

<p>You don't actually <em>read</em> anything from the file, you don't have a vector to sort, you don't call the sorting function.</p>
",0
32430881,32430737,0,"<p>If its just matter of crash then you may do something like below.</p>

<pre><code>class MyMatrix{
private:
unsigned _width, _height; 
unsigned char *_data;

public:
    MyMatrix(){
    _width = 2;
    _height = 3;
    _data = new unsigned char[sizeof(unsigned char)];

}
MyMatrix(MyMatrix &amp;other);
};

MyMatrix::MyMatrix(MyMatrix &amp;other) {
_width = other._width;
_height = other._height;
_data = new unsigned char[(_width*_height) + 1];
memcpy(_data, other._data, _width*_height*sizeof(unsigned char));
}
</code></pre>
",0
32432727,32430737,0,"<p>You are writing <code>_Y = MyMatrix(other._Y);</code>, I expect that you have defined the assignement operator for your Matrix class : <code>MyMatrix &amp; operator(const MyMatrix &amp; other);</code> otherwise the compiler will create a default one for you that just copy your attributes, meaning your pointer will be copied, not the content.</p>

<p>And, as I see that you can manipulate an important size of data and if you have c++11 enabled, I would definitely look at the copy swap idiom : <a href=""https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">What is the copy-and-swap idiom?</a></p>
",0
27500225,27500201,0,"<p>Easy: add another parameter for the filename:</p>

<pre><code>#include &lt;string&gt;

void CreateDataOutputFile(int n_values, double* datavector, const std::string&amp; fname)
{
    ofstream mirroreddata(fname, ios::out);                                                    
    for (int i = 0; i &lt; n_values; i++)
    {
        mirroreddata &lt;&lt; datavector[i] &lt;&lt; ""\n"";      
    }
    mirroreddata &lt;&lt; endl;                               
}
</code></pre>
",0
27573335,27573072,0,"<p><code>DllMain</code> is only called once, when the DLL is loaded. This is not where you should be putting your code.</p>

<p>In order to properly ""inject"" code into a process (via DLL or any other mean) you must first determine what function or event in that process you want to <strong>hook</strong>.</p>

<p>In this case, I suppose you want to hook the window event <code>WM_PAINT</code>, a callback from the system sent to the window's procedure telling it that it should repaint its content for whatever reason. (This may not be always correct though, because a program can use other methods of updating a window content.)</p>

<p>So what you are going to do is find the window handle you want to hook, and replace its callback procedure with your own:</p>

<pre><code>WNDPROC originalProc = SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)myHookProc);
</code></pre>

<p>But of course, not before having <code>myHookProc</code> defined and doing its job of hooking <code>WM_PAINT</code>:</p>

<pre><code>LRESULT CALLBACK myHookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT originalResult = originalProc(hWnd, uMsg, wParam, lParam); // call original first
    if (uMsg == WM_PAINT)
    {
        PAINTSTRUCT ps;
        HDC hdc = GetDC(hWnd);
        TextOut(hdc, 150, 150, L""TEST"", 4);
        ReleaseDC(hWnd, hdc);
    }
    return originalResult;
}
</code></pre>

<p>If you are dealing with multiple windows, you may want to use a <code>std::unordered_map&lt;HWND, WNDPROC&gt;</code> to keep relation between each window handle and its original procedure.</p>
",3
32448272,32448231,2,"<p>This line</p>

<pre><code>name = name;
</code></pre>

<p>The compiler is using the parameter <code>name</code> for each part of this statement. This means it is assigning the parameter <code>name</code> to itself.</p>

<p>Change it to</p>

<pre><code>this-&gt;name = name;
</code></pre>
",1
32448279,32448231,6,"<p>The problem is that your constructor is incorrect.</p>

<p>Inside:</p>

<pre><code>people(string name, int newb) {
    name = name;
    balance = newb;
}
</code></pre>

<p><code>name</code> refers to the parameter <code>name</code>, not the class data member <code>name</code>.</p>

<p>To fix this, either qualify <code>name</code> with <code>this</code>, or directly construct name and balance, rather than default-constructing them and then assigning to them:</p>

<pre><code>//Option 1:
people(string name, int newb) {
    this-&gt;name = name;
    balance = newb;
}
//Option 2: Preferred; avoids duplicate initialisation.
people(string name, int newb) :
 name(name), balance(newb)
{
}

//Option 3: Optimal; avoids unnecessary copies.
people(string name, int newb) :
 name(std::move(name)), balance(newb)
{
}
</code></pre>
",1
33579655,33579620,1,"<p>Turn the ""name"" variable into a string not an int.</p>
",0
33579681,33579620,0,"<p>The issue occurs because you have defined <code>name</code> as an <code>int</code> when it should be a <code>string</code>. Change the definition of <code>name</code> and <code>age</code> like so:</p>

<pre><code>string name; //This should be string
int age; //This could be a string too, if you want

void peoples()
{
    cout &lt;&lt;""Enter your name:"";
    cin &gt;&gt; name;
    cout &lt;&lt;""Enter your age:"";
    cin &gt;&gt; age;
    cout &lt;&lt; ""Your name is: "" &lt;&lt; name &lt;&lt; "" Your age is: "" &lt;&lt; age &lt;&lt; endl;
}
</code></pre>
",2
33582787,33579620,1,"<blockquote>
<pre><code>int name, age;
// This is the problem and always giving value of variable as 0 after inputting value.
void peoples()
{
    cout &lt;&lt;""Enter your name:"";
    cin &gt;&gt; name;
</code></pre>
</blockquote>

<p>Here's where the trouble starts. <code>name</code> is an <code>int</code>, which does not make sense. It should be an <code>std::string</code>.</p>

<p>When the user enters something which cannot be parsed as an integer number and you try to extract it into an <code>int</code>, <code>std::cin</code> is set to an <strong>error state</strong>. In addition, depending on which version of C++ you are using, the following happens:</p>

<ul>
<li>Before C++11, <code>name</code> is not modified at all.</li>
<li>Since C++11, <code>name</code> is set to 0.</li>
</ul>

<p>See <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt"" rel=""nofollow"">http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt</a>:</p>

<blockquote>
  <p>If extraction fails (e.g. if a letter was entered where a digit is
  expected), value is left unmodified and failbit is set. (until C++11)</p>
  
  <p>If extraction fails, zero is written to value and failbit is set. <em>(...)</em> (since C++11)</p>
</blockquote>

<p>Let's see what this means for the rest of your code:</p>

<blockquote>
<pre><code>    cout &lt;&lt;""Enter your age:"";
    cin &gt;&gt; age;
</code></pre>
</blockquote>

<p>Since <code>std::cin</code> is still in an error state, no input takes place. <code>age</code> is either not modified (before C++11) or set to 0 (since C++11). </p>

<blockquote>
<pre><code>    cout &lt;&lt; ""Your name is: "" &lt;&lt; name &lt;&lt; "" Your age is: "" &lt;&lt; age &lt;&lt; endl;
</code></pre>
</blockquote>

<p>Before C++11, this would result in <strong>undefined behaviour</strong> because you never initialised <code>name</code> and <code>age</code>, and an attempt to print them without any previous assignment means that anything can happen. In practice, today, you'd ""only"" get seemingly random values printed, but in theory, your program could also crash or do all other kinds of strange things.</p>

<p>Since C++11, you have at least the guarantee that the <code>std::cin</code> extraction operators set the variables to 0, so there is no more undefined behaviour here. That's arguably better because you immediately notice that something is wrong.</p>

<hr>

<p>In either case, the solution is <strong>not to use <code>operator&gt;&gt;</code> directly</strong> when you are dealing with human input. Human users are known to make mistakes when you give them a keyboard and ask them to type something.</p>

<p>Use the <code>std::getline</code> function instead. It reads a <strong>whole line</strong> of input into an <code>std::string</code> object. For <code>name</code>, this is already good enough if you did what I recommended previously and turned the variable into an <code>std::string</code>. It will even allow for names with spaces in them, like ""Computer Lover"".</p>

<p>For <code>age</code>, use the C++11 <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow""><code>std::stoi</code></a> function to convert the input to an <code>int</code> and handle errors with wrong input accordingly, by catching exceptions which may be thrown.</p>

<p>Here is a simple example to get you started:</p>

<pre><code>int name;
std::string age;

void peoples()
{
    std::cout &lt;&lt;""Enter your name:"";
    std::getline(std::cin, name);

    std::cout &lt;&lt;""Enter your age:"";
    std::string age_as_string;
    std::getline(std::cin, age_as_string);
    try
    {
        age = std::stoi(age_as_string);
        std::cout &lt;&lt; ""Your name is: "" &lt;&lt; name &lt;&lt; "" Your age is: "" &lt;&lt; age &lt;&lt; ""\n"";
    }
    catch (std::exception const&amp;)
    {
        // do something meaningful if the user entered
        // something bad, e.g. ""xxx""
    }
}
</code></pre>

<hr>

<p>When you get this to work, the next step would be to <strong>abandon global variables</strong>. They are quite the opposite of encapsulation and structured programming.</p>
",6
28172576,28062055,1,"<p>This code below gets the user input and converts the double to string and turns all 3 variable into line with the delimiter "":"" as seen in your example input and after u open the file u get the line that does not match into a temp file and rename the file essentially removing it.</p>

<pre><code>double expamt;
    string line, expdesc, exptrans;
    cout &lt;&lt; ""Please Enter Expense: \n"";
    cin &gt;&gt; expdesc;
    cout &lt;&lt; ""Please Enter Amount: \n"";
    cin &gt;&gt; expamt;
    string newamt = static_cast&lt;ostringstream*&gt;( &amp;(ostringstream() &lt;&lt; expamt) )-&gt;str();
    cout &lt;&lt; ""Date of Transaction: (e.g 20jan2015)\n"";
    cin &gt;&gt; exptrans;

    string input = expdesc + "":"" + newamt + "":"" + exptrans;

    ifstream myfile;
    ofstream tempfile;
    myfile.open(""Expense.txt"");
    tempfile.open(""temp.txt"");
while (getline(myfile, line))
{
    if (line != input)
        tempfile &lt;&lt; line;
}
    cout &lt;&lt; ""\nExpense "" &lt;&lt; expdesc &lt;&lt; "" has been removed \n"" &lt;&lt;endl;
    myfile.close();
    tempfile.close();
    remove(""Expense.txt"");
    rename(""temp.txt"", ""Expense.txt"");
</code></pre>
",0
27499727,27499647,1,"<p>You would have to formulate a <code>switch</code> statement, reading the desired member of a value of type <code>app</code> like the following.</p>

<pre><code>int choice;
// read choice from somewhere
switch(choice)
{
    case 0:
        // do something with a[i].id
        break;
    case 1:
        // do something with a[i].name
        break;
    default;
        break;
}
</code></pre>

<p>The members of a struct cannot be accessed index-wise.</p>
",1
27499843,27499647,0,"<p>The C++ language doesn't offer first-class properties that you can reflect over at run time, like JavaScript does. So there's no one-line answer to your question. Maybe the closest thing to what you're looking for is a <code>std::map</code>. But if you're working with a struct like <code>app</code>, you'll have to write your own code to fetch each field from an object, as in Codor's example.</p>
",0
28317042,28316769,12,"<p>1024f isn't a <code>float</code> value and also not a int for example<br>
So it can't compile. What you want to do is <code>1024.f</code>
In that way you explicitly say that the number 1024 has to be of type <code>float</code>.</p>

<pre><code>int main() {
    cout &lt;&lt; 1024.f &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
28226861,28225869,0,"<p>I get it! Thanks for the info the comments, its like user657267 and George Houpis said. If T and U are from different types, so, they're from different classes, said that, what i need it was to offer some other ways to acess the private members, something like this may help:</p>

<pre><code>template&lt;typename T&gt;
class C
{
     public:
     template&lt;typename U&gt;
     C&lt;T&gt; operator+(C&lt;U&gt; rhs);
     T getMember() {return this-&gt;member;};

     private:
     T member;
}

template&lt;typename T&gt; template&lt;typename U&gt;
C&lt;T&gt; C::operator+(C&lt;U&gt; rhs)
{
     return this-&gt;member + rhs.getMember();
}
</code></pre>
",0
28243030,28243015,6,"<p><code>std::string::c_str</code> returns a pointer to the internal <code>char</code> array of the <code>string</code>. It must not be deleted by the user because the <code>string</code>-object itself will manage its lifetime.</p>

<p>Also, if you do not intend to modify the <code>string</code>, pass it as <code>const string&amp;</code> instead. If you do in fact modify the <code>string</code>-object, be aware that some operations on <code>string</code>s invalidate the <code>.c_str()</code> pointer.</p>
",4
28243150,28243015,1,"<p>Since you haven't used <code>new[]</code>, you mustn't use <code>delete[]</code>. The program will automatically delete it.</p>
",0
33035408,33035307,2,"<p>Because when you enter this:</p>

<pre><code>case 0:
controller=new ControllerA(this);
printf(""state 0 with ControllerA\n"");
break;
</code></pre>

<p>It first calls the c-tor of <code>A</code>, which calls this:</p>

<pre><code>system-&gt;stateChanged(1);
</code></pre>

<p>Which in turn does this:</p>

<pre><code>case 1:
controller=new ControllerB(this);
printf(""state 1 with ControllerB\n"");
break;
</code></pre>

<h1>Warning</h1>

<p>But that essentially means that <code>delete</code> on the <code>A</code> object is called <em>from inside of its constructor</em> and that sounds kind of wrong. You might want to rethink this idea (starting with ""raw pointers shouldn't ever own resources"" guideline).</p>
",0
33035418,33035307,0,"<p>You create the new <code>ControllerA</code> before outputting your message. Maybe you meant:</p>

<pre><code>void stateChanged(int state){
    if(controller!=NULL){
        delete controller;
    }
    switch(state){
        case 0:
        printf(""state 0 with ControllerA\n""); //print before creating
        controller=new ControllerA(this);
        break;
        case 1:
        printf(""state 1 with ControllerB\n""); //ditto
        controller=new ControllerB(this);
        break;
    }
}
</code></pre>

<p>Although you should be using <code>std::cout</code> rather than <code>printf</code> in C++.</p>
",0
33035421,33035307,0,"<p>You call to <code>system.stateChanged(0);</code> calls the constructor of ControllerA which calls <code>system.stateChanged(1);</code>.</p>

<p>The constructor of ControllerB does nothing and so you end up printing <code>""state 1 with ControllerB\n""</code> going back up into the first <code>stateChanged</code> call and print <code>""state 0 with ControllerA\n""</code>there.</p>
",0
30141566,30140875,0,"<p>It looks like your analysis of the error is correct.
When you break out of the loop, unread input intended for the
current iteration of <code>while(ntestcase--)</code> is left over and is
used as input for the next iteration.</p>

<p>I would probably write all of this code very differently if I were
writing my own program  (for one thing, I would avoid using the same variable <code>i</code> to count both how many times <code>a</code> was read from the input <em>and</em> how many of these were before the first value less than 2), but to continue in the style you've already chosen:</p>

<p>Add another <code>for</code> loop at the end of the body of <code>while(ntestcase--)</code>
to consume the rest of that iteration's input without doing anything else.
Consume <code>n - i</code> values from the input,
and then you will be ready for the next iteration of <code>while(ntestcase--)</code>.</p>

<p>For example, this would probably do the job:</p>

<pre><code>int how_many_to_discard = n - i;
for (int j = 0; j &lt; how_many_to_discard; ++j)
{
  cin &gt;&gt; a;
}
</code></pre>

<p>Or if you don't want to give away too many clues to anyone who might want to debug the code, the loop could instead be</p>

<pre><code>for ( ; i &lt; n; ++i)
</code></pre>
",1
27506166,27505890,1,"<p>Your program is okay.
Just print the numbers as they appeared in input. That is :</p>

<p>Input : <code>10 5</code></p>

<p>Correct Output : <code>10 5 20</code></p>

<p>Your Output : <code>5 10 20</code></p>
",2
29955989,29955845,1,"<p>In the function setPgmPts, you forgot the class scope name, it should be: </p>

<pre><code>void Student::setPgmPts( int newPgmPts )
</code></pre>

<p>Also, you defined these member functions must take an argument</p>

<pre><code> void setQuizPts( int newQuizPts );
 void setSum2Low( int newSum2Low );
 void setExamPts( double newExamPts);
</code></pre>

<p>And in your constructor, you're calling them without passing any argument.</p>

<pre><code>studentQuiz = setQuizPts();
studentLowestQ = setSum2Low();
studentExam = setExamPts();
</code></pre>

<p>Also, your trying to obtain a return value from a void function, which doesn't make any sense.
You must call them following their definition, for example:</p>

<pre><code>setQuizPts(1);
setSum2Low(2);
setExamPts(3.0);
</code></pre>

<p>Or whatever int/double you want to use.</p>
",6
29955991,29955845,0,"<p>You have a function, <code>setPgmPts</code> declared outside the <code>Student</code> class. This function is attempting to access members of <code>Student</code> (<code>MAX_Pgm_Pts</code> and <code>studentProg</code>) but it doesn't have access to <code>Student</code> internals. You will need to make this a member of your <code>Student</code> class, or provide <code>public</code> access and a <code>Student</code> object to work with</p>
",0
29956205,29955845,0,"<p>The code is broken on many levels.</p>

<pre><code>//declarations; those functions take one int argument
void setPgmPts( int newPgmPts );
void setQuizPts( int newQuizPts ); 
void setSum2Low( int newSum2Low );
void setExamPts( double newExamPts);
</code></pre>

<p>The constructor would have to look something like this:</p>

<pre><code>Student::Student(char studentName[],int studentProg,int studentQuiz,int studentLowestQ,double studentExam)

{

    strcpy(studentName,""Ryan Manion"");
    //studentProg = calcPgmAverage();-&gt;invalid
    setQuizPts(studentQuiz); // it has to match the setQuizPts declaration 
    setSum2Low(studentLowestQ); // same as above
    setExamPts(studentExam); // same as above
}
</code></pre>

<p>Instead of </p>

<pre><code>studentProg = calcPgmAverage();
</code></pre>

<p>you would like to use something like this:</p>

<pre><code>Student student ( values for initialization);
double d = student.calcPgmAverage();
</code></pre>
",1
30210866,30210402,3,"<p>Instead of public members or dedicated setter and getter methods, try to provide any logic linked to your class with your interface.</p>

<p>I.e. the length of a vector is logically linked to the vector itself so you would not want to provide any facility for the rest of your program to access your data directly or indirect but provide the length as part of your interface.</p>

<h3>Example getter:</h3>

<pre><code>class v2d
{
  double mx, my;
public:
  double get_x() const { return mx; }
  double get_y() const { return my; }
};

bool foo (v2d const &amp;v)
{
  using std::sqrt;
  return sqrt(v.get_x()*v.get_x() + v.get_y()*v.get_y()) &gt; 1.0;
}
</code></pre>

<h3>Example length interface:</h3>

<pre><code>class v2d
{
  double mx, my;
public:
  double len () const
  {
    using std::sqrt;
    return sqrt(mx*mx + my*my);
  }
};

void foo (v2d const &amp;v)
{
  return v.len() &gt; 1.0;
}
</code></pre>

<p>Using the second you're free to change the data members (i.e. replace both by one <code>double m[2];</code> ...).</p>

<p>The same goes for setters as well: Provide class alteration logic as part of a meaningful interface.</p>

<h3>Example getter and setter:</h3>

<pre><code>class v2d
{
  double mx, my;
public:
  void set_x(double new_x) { mx = new_x; }
  void set_y(double new_y) { my = new_y; }
  double get_x() const { return mx; }
  double get_y() const { return my; }
};

void normalize (v2d &amp;v)
{
  using std::sqrt;
  double const len = sqrt(v.get_x()*v.get_x() + v.get_y()*v.get_y());
  v.set_x(v.get_x()/len);
  v.set_y(v.get_y()/len);
}
</code></pre>

<h3>Example meaningful interface:</h3>

<pre><code>class v2d
{
  double mx, my;
public:
  double len () const
  {
    using std::sqrt;
    return sqrt(mx*mx + my*my);
  }
  v2d&amp; operator/= (double const factor)
  {
    mx /= factor;
    my /= factor;
    return *this;
  }
};

void normalize (v2d &amp;v)
{
  v /= v.len();
}
</code></pre>
",0
30210559,30210402,0,"<p>If you are really so lazy, just use public.</p>

<p>If you want your code maintainable, use <em>get</em> and <em>set</em>.</p>
",2
30211243,30210402,0,"<p>Public data members aren't uder your controll. You or user of your code can access them from anywhere so you cannot change them.</p>

<p>Simply example - if you want to change datatype of global variable, you have to change code everywhere you acces it. If you have setter and getter you simply add conversion to them.</p>

<p>With setters and getters you can add checking if input or output is valid and safe.</p>
",0
31145182,31144669,1,"<p>If you want to sort a 2D array as if it were a 1D array (interpreted row-first or column-first) there's no real need to physically copy it to an 1D array first.</p>

<p>You can always pretend that you already have an imaginary 1D array, whose indices <code>i</code> are mapped to the indices of the original 2D array through the following formulas</p>

<pre><code>i_row = i / columns;
i_column = i % columns;
</code></pre>

<p>Now you can simply use any 1D sorting algorithm on 1D indices, and every time you need to access element <code>i</code> of the imaginary 1D array, you simply calculate <code>i_row</code> and <code>i_column</code> and access the corresponding 2D element instead.</p>

<p>That would implement exactly the same thing as you have in your original code, but without a physical 1D array and without copying data back and forth between 1D and 2D arrays.</p>
",0
31145197,31144669,1,"<p>You could use some mechanism to treat your 2d array as 1d array and this will save you extra space.
If you have a an integer <code>p</code>,you can extract <code>row number</code> and <code>column number</code> as follows</p>

<pre><code> rownumber=p/columnsize;
 columnnumber=p%columnsize;
</code></pre>

<p>following is an implementation of bubble sort using the above</p>

<pre><code>   #include &lt;iostream&gt;
   using namespace std;
   #define colsize 3
   #define rowsize 2
   int main() 
   {
      int arr[rowsize][colsize]={{7,8,9},{3,2,1}};
      int r,c,r2,c2;
      int n=rowsize*colsize;
      for(int i=0;i&lt;n;i++)
      {
         for(int j=0;j&lt;n-i-1;j++)
         {
            r=j/colsize;
            c=j%colsize;
            r2=(j+1)/colsize;
            c2=(j+1)%colsize;
            if(arr[r][c]&gt;arr[r2][c2])
            {
               swap(arr[r][c],arr[r2][c2]);
            }
          }
       }
       for(int i=0;i&lt;rowsize;i++)
       {  
           for(int j=0;j&lt;colsize;j++)
            {
               cout&lt;&lt;arr[i][j]&lt;&lt;"" "";
            }
        }
       return 0;
   }
</code></pre>
",1
34273701,34273679,5,"<p>You should <code>delete[] test</code>, in the array form.</p>
",0
31873600,31873529,0,"<p>Your question is not related to http requests at all.</p>

<p>Basically what you ask is: why can't i handle binary data as string?</p>

<p>The answer is: because string functions (like printf, strlen) all stop parsing at the first null character they encounter, and binary files (like a zip file) do contain null characters.</p>

<p>So when sending the data, dont try to get the length of the data as a string:
<code>BOOL sent= HttpSendRequest(hRequest, hdrs, strlen(hdrs), buffer, strlen(buffer));</code></p>

<p>instead use the length you already have in <code>lSize</code></p>
",8
29246909,29246494,0,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string"" rel=""nofollow""><code>std::to_string</code></a> to get the string representation of the float, and <a href=""http://www.cplusplus.com/reference/string/string/resize/"" rel=""nofollow""><code>std::string::resize</code></a> to resize that string to your preferred length, e.g.:</p>

<pre><code>std::string str = std::to_string(numbers[i]);
str.resize(len, '0');
fileout &lt;&lt; str &lt;&lt; '\n';
</code></pre>

<p>If <code>str.size()</code> is smaller than <code>len</code> then the above will append zeros to make it long enough. If <code>str.size()</code> is greater than <code>len</code> then it will remove the last digits from the string.</p>
",5
25698434,25698409,2,"<p>You're using <code>insert</code> wrong here:</p>

<pre><code>outer-&gt;insert(""X"", inner);
</code></pre>

<p>It expects a value_type i.e. std::pair.  You're passing two arguments instead of one, so you need to do <code>make_pair()</code> on those arguments, plus you need to pass a value, so <code>*inner</code> instead of <code>inner</code> which is a pointer.</p>

<p>Once this is all said and done, you will probably be better off with a different data structure, as a hash table of hash tables is usually not the most efficient.</p>
",1
29474704,29474560,1,"<p>I think you meant to do</p>

<pre><code>void setPages(int num) {
    *pages = num;
}
</code></pre>

<p>and</p>

<pre><code>int getPages() {
    return *pages;
}
</code></pre>

<p>Otherwise, the code won't compile.</p>

<p>Initially, you were trying</p>

<pre><code>pages = num;
</code></pre>

<p>and <code>pages</code> is an int pointer and <code>num</code> is an int, so this won't work.</p>

<p>And then, you were trying</p>

<pre><code>int getPages() {
    return pages;
}
</code></pre>

<p>the function has the return type int, but it tries to return a pointer.</p>

<p>Also, change the function call to</p>

<pre><code>cout &lt;&lt; ""number of pages are = "" &lt;&lt; b1.getPages() &lt;&lt; endl;
                                                ^ you are missing these
</code></pre>

<p>The next problem with you code is in your <code>main()</code></p>

<pre><code>int* pages;
*pages = 500;
</code></pre>

<p><code>pages</code> is not pointing to any address, and you get a SEGFAULT here.</p>

<p>So, you can modify your code to something like</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
class Book 
  {
    private:
      int *pages;
    public:
      void setPages(int num) 
        {
          pages = new int;
          *pages = num;
        }    
      int getPages() 
        {
          return *pages;
        }
      void d()
        {
          delete pages;
        }
  };
int main() 
  {
    Book b1;
    int* pages = new int;
    *pages = 500;
    b1.setPages(500);
    cout &lt;&lt; ""number of pages are = "" &lt;&lt; b1.getPages() &lt;&lt; endl;
    delete pages;
    b1.d();
  }
</code></pre>

<p>This may not be the most efficient, but try it out.</p>
",2
29475592,29474560,2,"<p>This  </p>

<pre><code>pages = num;
</code></pre>

<p>should be   </p>

<pre><code>pages = &amp;num;   
</code></pre>

<p>You should assign the memory address of the <code>num</code> to <code>pages</code> using <code>&amp;</code> (address of operator), not the variable itself.</p>

<p>and<br>
 <code>b1.getPages</code> should be corrected as <code>b1.getPages()</code>.  </p>

<p>I don't know why you declared this pointer since you haven't used it in your code.<br>
<code>int* pages;</code>   </p>

<p>But if you are going to use it you can do it this way  </p>

<pre><code>int* pages;
*pages = 500; 
b1.setPages(*pages);  
</code></pre>

<p>OR</p>

<pre><code>int pages;
pages = 500; 
b1.setPages(pages);
</code></pre>
",0
33815041,33813612,0,"<p>How to make a final class in C++ versions before C++11:
<a href=""https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Final_Class"" rel=""nofollow"">https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Final_Class</a></p>
",0
28453462,28453365,4,"<p>Because first symbol of <code>rev</code> is <code>\0</code> after your reverse operation, and <code>puts</code> considers a string as a null-terminated. So, it sees that first byte is null and stops immediately.</p>

<p>You may modify your loops this way:</p>

<pre><code>for (i = 0; mystr[i] != '\0'; i++);
rev[i] = '\0';
for (int j = i-1; j&gt;=0; j--)
{
    rev[c] = mystr[j];
    c++;    
}
</code></pre>
",0
28453473,28453365,0,"<p>One problem is that the <code>rev</code> array is a local and it is not initialized; this means the resulting string is not guaranteed to have the needed terminating <code>\0</code>.</p>

<p>You can fix that adding a <code>rev[c]='\0'</code> before calling <code>puts</code>.</p>

<p>Also you need to start from the character <strong>before</strong> the <code>\0</code> in the input string, otherwise the output will start with a <code>'\0'</code> and the <code>puts</code> function will stop right there.</p>
",0
28455038,28453365,0,"<p>puts() writes the \0 (null) terminated string to the standard output (stdout) and appends a newline character ('\n'). As rev is having the \0 char at 0th position, puts() prints nothing.</p>

<p>you can use below code to revers a char array.</p>

<pre><code>int lenth = strlen(mystr);
int pos = lenth-1;   // one posation before \0 char
int i = 0
for (; i &lt;= pos; i++)
{
    rev[i] = mystr[pos-i];
}
rev[i] = '\0';
</code></pre>

<p>or</p>

<pre><code>int lenth = strlen(mystr);
int start = 0;
int end = lenth-1;      // one posation before \0 char
for (; start &lt; end; start++, end--)
{
    char t;
    t = mystr[start];
    mystr[start] = mystr[end];
    mystr[end] = t;
}
</code></pre>

<p>Hope it helps!</p>
",0
32430970,32430804,1,"<p>Since you are new couple things you need to remember:</p>

<p><strong>switch case and if/else statement</strong> are pretty similar, therefore you don't need to use them both at the same time on same task.</p>

<p>When the program runs the user inputs a value either <strong>r</strong> or <strong>d</strong> , that value get passed to the <strong>choice</strong> variable. The switch case compares its own cases to the choice value and if both value are equal, it will run that case code block and if they are not it will run the <strong>default code</strong>.</p>

<p>Now inside the case, you are asking for the radius, once you get the radius,</p>

<pre><code> result = number * number * M_PI; 
</code></pre>

<p>OR</p>

<pre><code>result = pow(number,2.0) * M_PI;
</code></pre>

<p>And also there is a big difference between <strong>cout&lt;&lt;""2*3""; and cout&lt;&lt;2*3;</strong></p>

<blockquote>
  <p>The first example will display 2*3 into your screen.</p>
  
  <p>The second example will display the result of 2*3 into the screen
  <strong>6</strong>, the reason you it calculates because there is not quotation mark around it</p>
</blockquote>

<p>Hope that helps...</p>
",0
32430878,32430804,0,"<p>Shoulr calculation of <code>result</code> use <code>choise</code>???</p>

<p>Looks like you have a typo. Replace <code>choise</code> woth <code>number</code> in the</p>

<pre><code>result = choice*choice*M_PI;
</code></pre>

<p>And in the</p>

<pre><code>result = choice*M_PI;
</code></pre>

<p>Using <code>choise</code> in calculation actually uses its ASCII code. This explains the big values that you get in the <code>result</code>.</p>
",0
32430885,32430804,0,"<pre><code>result = choice*choice*M_PI;
</code></pre>

<p>this should be</p>

<pre><code>result = number * number * M_PI;
</code></pre>

<p>also you are printing</p>

<pre><code>* 2 * 3.14 =
</code></pre>

<p>should be</p>

<pre><code>^ 2 * 3.14 =
</code></pre>
",0
28501646,28501333,2,"<p>You may have a particularly complicated data structure with a super specific and arbitrarily ordering that you want to define on it, but no matter. The nice thing about <a href=""http://en.cppreference.com/w/cpp/algorithm/sort"" rel=""nofollow""><code>std::sort</code></a> is that it's completely accommodating:</p>

<pre><code>std::sort(A.begin(), A.end(), MyComparator);
</code></pre>

<p>All you need to write is:</p>

<pre><code>typedef pair&lt;unsigned, pair&lt;vector&lt;unsigned&gt;, vector&lt;unsigned&gt; &gt; &gt; Elem;

bool MyComparator(const Elem&amp; a, const Elem&amp; b) {
    // return true if a should go before b in the sort

    // step 1 is apparently to do a vector comparison
    for (size_t i = 0; i &lt; a.second.second.size(); ++i) {
        if (i == b.second.second.size()) {
            return false;           
        }
        else if (a[i] &lt; b[i]) {
            return true;
        }
        else if (a[i] &gt; b[i]) {
            return false;
        }
    }
    if (a.second.second.size() &lt; b.second.second.size()) {
        return true;
    }

    // if we got here, the two vectors compare equal
    // so onto the next steps 2, 3, ...
    // etc.
}
</code></pre>
",5
28528376,28528346,0,"<pre><code>t.join();
</code></pre>

<p>This will <em>wait</em> for the thread to complete. Remove the line.</p>
",2
28528387,28528346,0,"<p><code>join</code> means ""wait for the thread to finish, then clean it up"".</p>

<p>If you don't want to wait for the thread yet, then don't call <code>join</code> yet. Do something else, then join the thread when you need whatever it's doing to complete. Or call <code>detach</code>, and let the thread run in the background; although in this case, it will end along with the rest of the program when <code>main</code> finishes.</p>
",0
27527454,27527379,1,"<p>You are violating the rules of the language that has multiple increment and decrement in the same expression or as different arguments to the same call as undefined.</p>
",0
31162536,31162288,1,"<p>If you are absolutely sure that <code>other</code> is a <code>Rectangle</code> at that point in the code, then you can safely <code>static_cast</code> it.</p>

<pre><code>case RECTANGLE:
    Rectangle&amp; rect = static_cast&lt;Rectangle&amp;&gt;(other);
    //...
    break;
</code></pre>

<p>Another solution which might be a bit cleaner would be to use double-dispatch via the <a href=""https://en.wikipedia.org/wiki/Visitor_pattern"" rel=""nofollow"">visitor pattern</a>. For instance, you could define <code>collide(Rectangle&amp;)</code> and <code>collide(Circle&amp;)</code> functions, then do the double-dispatch like <code>other.collide(*this);</code>. Doing so would eliminate the need for a type enum.</p>
",0
33591077,33591052,5,"<p>You would need to put it through a loop and read line by line</p>

<pre><code>    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    #include &lt;string&gt;
    using namespace std;

    int main () {
     string line;
     ifstream check (""example.txt"");
     if (check.is_open())
     {
       while ( getline (check,line) )
       {
         cout &lt;&lt; line &lt;&lt; '\n';
       }
       check.close();
     }

    else cout &lt;&lt; ""Unable to open file""; 

    return 0;
    }
</code></pre>
",0
33591608,33591052,-1,"<p>getline gets <em>one</em> line, if you would like more then one line try this;</p>

<pre><code>std::string Line, Result;
while (true){
  getline(check, Line);
  if (!check.eof())
    Result.append(Line), Result.push_back('\n');
  else
    break;
}
</code></pre>
",3
29217238,29217097,6,"<p>You are doing a <em>modulo by zero</em> in </p>

<pre><code>if (n % i == 0)
</code></pre>

<p>when <code>i = 0</code>, hence the error.</p>
",1
29197917,29197683,2,"<p>I think your basic problem is that you're using >> on the input stream and that will read a word at a time. To read a line at a time, you should use getline().</p>
",0
29198019,29197683,0,"<p>At first, you mustn't save <code>/n</code> to the file, it could cause some problems in reading from the file in some cases.</p>

<p>another thing in your code is that you saved the name as character and read it as string,and that is the cause of the problem. the way of saving characters differs from the way of saving strings. When you write string you make one completed line only for writing the sentence.</p>

<p>I thing your code should be like this</p>

<p>Writing:</p>

<pre><code>string name;
cout&lt;&lt;""Enter the name of the book:"";
getchar();
getline(cin,name);
ofstream bookname(""D:bookname.txt"",ios::app);
if(bookname.is_open()){    
    bookname&lt;&lt;name;
    bookname.close();
}
else
    cout&lt;&lt;""The file does'nt open successfully!\n"";
}
</code></pre>

<p>Reading</p>

<pre><code>string n[100];
int c=0;//the number of times you read a sentence
ifstream read(""D:bookname.txt"");
while(read)//keap reading from the file until you reach eof.
{
    read&gt;&gt;n[c];
    c++;
}
read.close();
</code></pre>
",0
27553796,27553585,1,"<p>Modify your code to this.. Hope this will help</p>

<pre><code>for (k = 1; k &lt;= n+1; k++)
{
    cout &lt;&lt; x &lt;&lt; '\t';
    CalculateNChooseK();
    x = nChooseK;

}
</code></pre>

<p>As you are declaring k in for loop, This value is not working as global.</p>

<pre><code>for (int k = 0; k &lt;= n; k++) // don't declare k here.. and also loop from 1 to n+1 inclusive
</code></pre>
",0
28506390,28506340,1,"<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/size"" rel=""nofollow""><code>b.length()</code></a> returns <code>size_t</code> which is unsigned. In your <code>for</code> loop, you are comparing a signed int <code>i</code> with the unsigned <code>b.length()</code>, which is why you see the warning. To get rid of it, use <code>size_t i</code> instead of <code>int i</code> when using <code>i</code> to indicate array indices.</p>

<p>Unrelated : You have an out of bounds access here <code>if (b[i+1] == '""')</code>.</p>
",6
28506516,28506340,0,"<p>You can avoid the <code>unsigned</code>and <code>signed</code> comparison non-sense by using <code>std::string::iterator</code>.</p>

<pre><code>for ( auto iter = b.start(); iter != b.end(); ++iter )
</code></pre>
",0
33013923,33013535,0,"<p>The algorithm is almost the same. But instead of just returning when you have found an exit, you should compare the length of the found path and if it is longer than the previous one then store it somewhere. Than keep searching all other possible ways.
Of course you should mark somehow already visited points, otherwise the longest path to the exit may be infinitely long.</p>
",0
28172775,28172716,6,"<p>There is no <code>this</code> pointer in the function parameter list, so you can't refer to class members in default arguments.</p>

<p>The solution is to overload the function:</p>

<pre><code>bool push(node what, node* current, int actualheight = 1){...}

bool push(node what){ return push(what, root); }
</code></pre>

<p>Now when you call <code>push</code> with one argument it forwards to the other overload, providing <code>root</code> as the second argument, which does exactly what you were trying to achieve.</p>
",0
27748315,27748290,1,"<pre><code>first.insert(first.end(), p.begin(), p.begin() + n);
</code></pre>

<p>if n is actually the length of the whole string, it'd be better to use:</p>

<pre><code>first.insert(first.end(), p.begin(), p.end());
</code></pre>
",0
27748319,27748290,0,"<p>//`for(char&amp; c : p) {
//   first.push_back(c);
//}</p>

<p>Apologies, I was mistaken.  I think if you use this constructor for the vector it would be the fastest way.  Juan has the right idea.</p>

<pre><code>std::vector&lt;char&gt; first(p.begin(), p.end());
</code></pre>
",1
27748607,27748290,0,"<p>Fastest: do nothing. <code>std::string</code> can basically function as <code>std::vector&lt;char&gt;</code> for most purposes, and doing literally nothing is always going to be faster than doing something.</p>

<pre><code>std::string p;
cin &gt;&gt; p;

// just use p
// p[0] is the first char, e.g. '0', so you don't have to do anything
// p[1] is the second, etc. 
// p.size() is the size
</code></pre>

<p>Next fastest: just directly construct your vector:</p>

<pre><code>std::vector&lt;char&gt; data(p.begin(), p.end());
</code></pre>

<p>That will make sure to do only one allocation of the correct amount (of at least <code>p.size()</code>), and will copy the string into the vector as efficiently as feasible. </p>

<p>Next: add each character one at a time:</p>

<pre><code>// C++11
std::vector&lt;char&gt; data;
for (char c : p) {
    data.push_back(c);
}

// C++03
for (size_t i = 0; i &lt; data.size(); ++i) {
    data.push_back(p[i]);
}
</code></pre>

<p>The longer the string, the more extra allocations/copies will be done as opposed to the direct-construction method. The exact amount is implementation dependent, but this approach will always be slower - even your particular implementation default-constructs a vector with large initial capacity (since you would at least have to branch on each <code>push_back</code> to check if you had to <code>resize</code>... whereas the direct construction wouldn't even have to do that). </p>
",0
28202943,28202773,2,"<p>Here's a real world analogy of what's happening. I write down my phone number on a sheet of paper. I give you a copy of that sheet of paper. On the copy, you erase my number and write your own. Then you call the number that you just wrote.</p>
",0
28202989,28202773,2,"<p>Inside this function:</p>

<pre><code>void manipCharBuffer(char* buffer) {
   buffer = ""DERP"";
</code></pre>

<p>the name <code>buffer</code> is a different name to <code>buffer</code> in <code>main</code>. To avoid confusion you could use a different variable name, e.g.:</p>

<pre><code>void manipCharBuffer(char* p_buffer) {
   p_buffer = ""DERP"";
</code></pre>

<p>Hopefully this makes it clearly why there is no difference made to <code>main</code> here. You are setting the local pointer <code>p_buffer</code> to point to a different char array. (<code>""DERP""</code> is a char array located somewhere in memory).</p>

<p>If you want to copy characters from one char array to another the you have to write code that copies characters; one way would be:</p>

<pre><code>std::strcpy( p_buffer, ""DERP"" );
</code></pre>
",0
28203005,28202773,0,"<p>In your main function the variable buffer points to an array of 256 characters allocated on the stack. When sending it to the function manipCharBuffer, the address is transfered by value. That means each call for the function manipCharBuffer creates a local variable also named buffer, which is stored in a different place in memory from the variable buffer in the main function but both point to the same place in memory. So the result of the line:</p>

<pre><code>buffer = ""DERP"";
</code></pre>

<p>is that the local variable in the function now points to a different place in memory where the string-constant ""DERP"" is stored (determined in compile time) without changing that buffer you allocated on the stack, and the buffer variable in main still points to it.</p>

<p>What you tried to do can be achieved as follows:</p>

<pre><code>memcpy(buffer,""DERP"",sizeof(char)*5); //5 and not 4 to include the null terminator
</code></pre>
",0
28213107,28202773,0,"<p>It is not possible to pass C arrays by value, however it is possible for C++ arrays (std::array) and dynamic arrays (std::vector).if you want to use c++ ,its better to use standard library.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std ;

void manipCharBuffer(char* buffer) {

  strcpy(buffer,""DERP"");
  cout &lt;&lt; ""\n string in called  function  ""&lt;&lt;buffer;
}

int main() {
   char buffer[256] = ""JUNK STRING"";
   cout &lt;&lt; "" string before call is : "" &lt;&lt;buffer;

   char*p = buffer ;
   manipCharBuffer(p);
   cout &lt;&lt; ""\n string after call is  : "" &lt;&lt;buffer;

   return 0;

}
</code></pre>
",0
28148426,28148210,0,"<p>After entering the integer you press enter, and this enter input is left in the buffer area and used as the next input for getline and the computer assumes you're done.
add this line before <code>getline</code> statement and re- compile it.
<code>cin.ignore()</code>.</p>
",2
28148295,28148210,1,"<p>Its because you entered a newline for the program to accept the integer you entered for <code>choice</code>, the that newline is not extracted from the buffer, leaving it to be read in your next input operation. The <code>getline</code> call reads that left-over newline, and is happy with that.</p>

<p>There are a couple of ways to solve your problem. The first and most obvious is to use <code>std::string</code> for the <code>word</code> variable, and then use the normal input operator <code>&gt;&gt;</code> as that will skip leading whitespace (which includes newline).</p>

<p>Another solution is to tell the input stream to <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/ignore"" rel=""nofollow""><code>ignore</code></a> until and including a newline. The linked reference has an example on how to do exactly that.</p>
",0
28187905,28187863,-1,"<p>You'd have to input it to a string variable then examine the string and work out what to do</p>
",0
28187936,28187863,3,"<p>Sure - you can just do something like this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main ()
{
    int i = 10000;   // initialise i to default value
    int temp;        // temporary integer for input validation

    if (cin &gt;&gt; temp) // if valid integer entered
        i = temp;    // set i to entered integer (otherwise leave it at default value)
    cout &lt;&lt; i &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Compile and test:</p>

<pre><code>$ g++ -Wall input.cpp 
$ ./a.out
1234
1234
$ ./a.out
fred
10000
$ 
</code></pre>
",0
27688059,27687850,2,"<p><kbd>?</kbd><kbd>?</kbd><kbd>?</kbd> and friends are not single byte characters, UTF-8 uses multibyte characters for non ASCII chars. That is the reason for your code to fail.</p>

<p>So use <code>std::string</code> and a <code>UTF-8</code> decoding library (Greg Kroah-Hartman referenced a fast/minimal implementation which is just a tiny header file, writter by <strong>Bj?rn H?hrmann</strong>) if you need single characters or <code>libiconv</code> for the real deal.</p>
",3
27688233,27687850,1,"<p>Other than the character set issue, you have an error in your loops.</p>

<p>You only have 9 vowels,  but you assume you have 20 vowels in the loop.</p>

<pre><code> for (int x = 0; x&lt;20; x++) 
 {
    // ...
   if (vokal[x] == tolower(ord[i]))
</code></pre>

<p>This is a memory read overrun if x >= 9.</p>

<p>A much better approach would be to create 3 sets of letters, and check each set.</p>

<pre><code>#include &lt;set&gt;
//...
  std::set&lt;char&gt; vokal = {'a','o','u','?','e','i','y','?','?'};              
  std::set&lt;char&gt; konsonant = {'b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','z'};        
  std::set&lt;char&gt; stor_konsonant = {'B','C','D','F','G','H','J','K','L','M','N','P','Q','R','S','T','V','W','X','Z'};   

    string rovarsprak, ord;
    cout &lt;&lt; ""Skriv in ett ord"" &lt;&lt; endl;            
    getline (cin,ord);                                             
    int n = ord.length();                          
    for(int i = 0; i&lt;n; i++)                               
    {
        if ( voka.find(tolower(ord[i])) != voka.end())
           rovarsprak = rovarsprak + ord[i];      
        else 
        if(konsonant.find(ord[i]) != konsonant.end())
           rovarsprak = rovarsprak + ord[i] + ""o"" + ord[i];       
        else 
        if(stor_konsonant.find(ord[i]) != stor_konsonant.end())
           rovarsprak = rovarsprak + ord[i] + ""O"" + ord[i];       
        else 
        if( isspace(ord[i]))
           rovarsprak = rovarsprak + "" "";
        else if(ord[i] == '?')
            cout &lt;&lt; ""?"";
    }
    cout &lt;&lt; rovarsprak &lt;&lt; ""\n"" &lt;&lt; endl;
}
</code></pre>

<p>Given the other answer concerning character set, change the above code accordingly to have sets of the correct character type.  The basic outline will be the same.</p>
",0
28232666,28232618,2,"<p>You are not calling the <code>pullCard</code> function. You need to change this:</p>

<pre><code>d.pullCard.toString();
</code></pre>

<p>to this:</p>

<pre><code>d.pullCard().toString();
</code></pre>
",0
28466114,28463349,0,"<p>The reason here is when you type a e i o u 'they' fed in to std::cin as 5 different words. Because, cin in this situation takes space as the word separator, you will be prompted to enter new words after 5 iterations. So it's correct. If you enter a e i o u q then you will not be prompted again to enter any input since 6th word is q which is supposed to exit from your loop. So the behaviour is correct. </p>

<p>If you debug the program you can understand what's really going on. </p>
",0
33579191,33579143,0,"<p>arr[2][2] array will have </p>

<pre><code>arr[0][0] arr[0][1]
arr[1][0] arr[1][1]
</code></pre>

<p>The below are out of index range</p>

<pre><code>Kaballah_Chaldean_Main[2][1] = 'B' ;
 Kaballah_Chaldean_Main[1][2] = 1 ;
 Kaballah_Chaldean_Main[2][2] = 2 ;
</code></pre>
",0
33579196,33579143,0,"<p>You're doing most of your array indexing wrong.  Your subscripts in <code>Kaballah_Chaldean_Main</code> are 1-based, but C++ uses 0-based arrays.  You should use <code>Kaballah_Chaldean_Main[0][0]</code> etc to avoid going outside the bounds of the array.</p>

<p>Also the <code>Chaldean_Letter_Index</code> should start at 0 and end at 1.</p>
",0
33579209,33579143,0,"<p><strong>Problem 1</strong></p>

<pre><code>fgets(name , 2, stdin);
</code></pre>

<p>reads at most one character to <code>name</code>. See <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow"">http://en.cppreference.com/w/c/io/fgets</a> for more details.</p>

<p>If you want to read 2 characters, use:</p>

<pre><code>char name[3] ;

cout &lt;&lt; ""Type aa ab ba or bb"" &lt;&lt; endl ;

fgets(name , 3, stdin) ;
</code></pre>

<p><strong>Problem 2</strong></p>

<pre><code>name_length = strlen(name) -1 ;
</code></pre>

<p>It makes more sense for it to be:</p>

<pre><code>name_length = strlen(name);
</code></pre>

<p><strong>Problem 3</strong></p>

<p>You have:</p>

<pre><code>char Kaballah_Chaldean_Main[2][2] ;

/* Set the Main Chaldean Kaballah */

Kaballah_Chaldean_Main[1][1] = 'A' ; 
Kaballah_Chaldean_Main[2][1] = 'B' ;

Kaballah_Chaldean_Main[1][2] = 1 ;
Kaballah_Chaldean_Main[2][2] = 2 ;
</code></pre>

<p>Those are wrong indices. You are modifying memory beyond the valid limits. The valid range of indices for <code>Kaballah_Chaldean_Main</code> is <code>[0][0]</code> - <code>[1][1]</code>. Those lines should be:</p>

<pre><code>Kaballah_Chaldean_Main[0][0] = 'A' ; 
Kaballah_Chaldean_Main[1][0] = 'B' ;

Kaballah_Chaldean_Main[0][1] = 1 ;
Kaballah_Chaldean_Main[1][1] = 2 ;
</code></pre>

<p><strong>Problem 4</strong></p>

<p>You have the following variable:</p>

<pre><code>unsigned int Chaldean_Letter_Index ;
</code></pre>

<p>It is not initialized before it's used in the next line. Perhaps it should be initialized to 0.</p>

<pre><code>unsigned int Chaldean_Letter_Index = 0;
</code></pre>
",0
27746767,27746642,2,"<p>The</p>

<blockquote>
  <p><strong>&rdquo;</strong> Could not write to output file</p>
</blockquote>

<p>error message means that the file is in use.</p>

<p>Since it's a DLL, it's in use by some program or programs.</p>

<p>You need to terminate those processes.</p>
",3
32928955,32928860,0,"<p>You declared a class called <code>sf::Event</code>.</p>

<p>This class declares an inner class called <code>MouseButtonEvent</code>.</p>

<p><code>MouseButtonEvent</code> is not a class member. It's an inner class.</p>

<p>You declared an instance of <code>sf::Event</code> called ""menuEvent"":</p>

<pre><code>sf::Event menuEvent;
</code></pre>

<p>Your compiler is failing to compile the following expression:</p>

<pre><code>HandleClick(menuEvent.MouseButtonPressed.x,
            menuEvent.MouseButtonPressed.y);
</code></pre>

<p>The error is because <code>sf::Event</code> does NOT have a class member called <code>MouseButtonPressed</code> (technically that is not exactly true, but I note that this question does not have a ""language-lawyer"" tag, so I'm playing it fast-n-loose...)</p>

<p>The expression ""menuEvent.MouseButtonPressed"" is a reference to a member of <code>menuEvent</code>'s class called ""MouseButtonPressed"".</p>

<p>There is no such class member. <code>MouseButtonPressed</code> is an inner class, and not a class member.</p>

<p>The intentions of your code is not clear to me, so I cannot suggest what would be the right syntax for whatever the code is trying to accomplish here.</p>
",5
33028117,32928860,0,"<p>That did it! Thanks so much for your help Sam Varshavchik. </p>

<p>Here's my final code version;</p>

<p>External Piece;</p>

<pre><code>namespace sf {
  class Event
    {
      public:
      struct MouseButtonEvent
        {
          Mouse::Button button; ///&lt; Code of the button that has been pressed
          int x; ///&lt; X position of the mouse pointer, relative to the left of the owner window
          int y; ///&lt; Y position of the mouse pointer, relative to the top of the owner window
        };

      MouseButtonEvent btnVariable;
    }
}
</code></pre>

<p>Source File Piece;</p>

<pre><code>MainMenu::MenuResult MainMenu::HandleClick(int x, int y)
{
  std::list&lt;MenuItem&gt;::iterator it;

  for (it = _menuItems.begin(); it != _menuItems.end(); it++)
   {
    sf::Rect&lt;int&gt; menuItemRect = (*it).rect;

    if(menuItemRect.contains(sf::Vector2&lt;int&gt;(x,y)))
        {
            return it-&gt;action;
        }
   }
  return Nothing;
}

MainMenu::MenuResult MainMenu::GetMenuResponse(sf::RenderWindow&amp; window)
  {
    sf::Event menuEvent;

    while (true)
    {

    window.pollEvent(menuEvent);

    if (menuEvent.type == sf::Event::MouseButtonPressed)
      {
        return HandleClick(menuEvent.btnVariable.x , menuEvent.btnVariable.y);
      }

    if (menuEvent.type == sf::Event::Closed)
      {
        return Exit;
      }

    }
  }
</code></pre>
",0
27763008,27762759,0,"<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
 ifstream fin;
 ofstream fout;
 int i=0,z,K=100,N=1000,x,j;
fout.open(""High.txt"");

//Generate 1000 positive random numbers below 1000 and print ino High.txt
for(i=0;i&lt;1000;i++){
    fout&lt;&lt;abs(random())%1000;
}
fout.close();

fin.open (""High.txt"");
fout.open(""out.txt"");
if (!fin ) exit( 1 );


while(i&lt;(N/K)){
 z = 1000;
 for(j=0;j&lt;K;j++){ //Reading K line 
        fin&gt;&gt;x;
        z = min(x,z);
 }
 fout&lt;&lt;z&lt;&lt;""\n"";
 i++;
}
fout.close();
fin.close();
fin.open(""out.txt"");
//Print result 
while(!fin.eof()){
    fin&gt;&gt;x;
    cout&lt;&lt;x&lt;&lt;""\n"";
}
}
</code></pre>

<p>//Same code with random number is generated and printed in <code>High.txt</code> it prints correct output .Something would we wrong with file opening. </p>
",6
27763918,27762759,0,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/algorithm/min_element"" rel=""nofollow""><code>std::min_element</code></a> to get the minimum values:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

int main()
{
    std::ifstream infile(""data.txt"");
    std::ofstream outfile(""min_values.txt"");

    const int K = 10;
    std::vector&lt;double&gt; numbers;

    double d;

    while(infile &gt;&gt; d)
    {
        numbers.push_back(d);
    }

    int full_parts = numbers.size() / K;


    for (int i = 0; i &lt; full_parts; i++)
    {
        double min = *std::min_element(numbers.begin() + i * K, numbers.begin() + i * K + K);
        outfile &lt;&lt; min &lt;&lt; std::endl;
    }

    if (numbers.size() % K != 0)
    {
        double min = *std::min_element(numbers.begin() + full_parts * K, numbers.end());
        outfile &lt;&lt; min &lt;&lt; std::endl;
    }
}
</code></pre>
",0
28162366,28162282,2,"<p>Dereferencing a null pointer gives undefined behavior.</p>

<p>In a fairly typical case, there's really nothing there. For example, on an x86 in protected mode, you typically set up some page table entries for the beginning of memory that say nothing is present there, so any attempt at reading or writing that address will result in a page fault (e.g., both Windows and Linux do this).</p>
",0
29478313,29477690,0,"<p>Apparently you don't know how to use if else correctly in c++. You can look them up e.g. <a href=""http://de.wikibooks.org/wiki/C%2B%2B-Programmierung:_Kontrollstrukturen"" rel=""nofollow"">here</a>. </p>

<p>One correct way your program could look like:</p>

<pre><code>#include &lt;iostream&gt;    
#include &lt;string&gt;    
using namespace std;
int main(int argc, char* argv[])
{
    int a, b, c = 0;
    cout &lt;&lt; ""Enter value of 1st variable: "";
    cin &gt;&gt; a;
    cout &lt;&lt; ""Enter value of 2nd variable: "";
    cin &gt;&gt; b;


    if (a == b){
        cout &lt;&lt; ""Both are equal"";
    } else {
        if (a &gt; b) {
            c = a;
        } else if (a &lt; b){ //&lt;-- As indicated by @Thomas Matthews you don't actually need the third check here
            c = b;
        }
        cout &lt;&lt; ""Greater value is "" &lt;&lt; c;
    }
} 
</code></pre>

<p>Other ways to write this:</p>

<pre><code>if (a == b){
    cout &lt;&lt; ""Both are equal"";
}else if (a &gt; b) {
    cout &lt;&lt; ""Greater value is "" &lt;&lt; a;
} else {        
    cout &lt;&lt; ""Greater value is "" &lt;&lt; b;
}
</code></pre>

<p>OR (less obvious):</p>

<pre><code>int t = a - b;
switch ((t &gt; 0) - (t &lt; 0)){ //&lt;-- effectively computing the sign of t
    case -1: cout &lt;&lt; ""Greater value is "" &lt;&lt; b; break;
    case 0: cout &lt;&lt; ""Both are equal""; break;
    case 1: cout &lt;&lt; ""Greater value is "" &lt;&lt; a; break;
}
</code></pre>
",3
29478363,29477690,1,"<p>You have several problems with basic C++ syntax.</p>

<p>An <code>if</code> statement should not normally end with a semicolon:</p>

<pre><code>if ( !(a == b));
</code></pre>

<p>Should be:</p>

<pre><code>if ( !(a == b))
//            /\ No semicolon here!
</code></pre>

<p>The braces for an <code>if</code> statement should go after the closing parenthesis. This:</p>

<pre><code>{
if (!(a == b))
}
</code></pre>

<p>Should be:</p>

<pre><code>if (!(a == b))
{
}
</code></pre>

<p>Neither of these lines do anything:</p>

<pre><code>!true;
!false;
</code></pre>

<p>Extra braces are allowed, which is why your compiler is not complaining about them. Just because I can do this, doesn't mean I should:</p>

<pre><code>int main()
{
  {
    {
      {
        // code here
      }
    }
  }
}
</code></pre>
",0
29478731,29477690,0,"<p>Here is a simple fragment:  </p>

<pre><code>if (a == b)
{
  cout &lt;&lt; ""a == b"";
}
else
{
  if (a &lt; b)
  {
    cout &lt;&lt; ""a &lt; b"";
  }
  else
  {
    cout &lt;&lt; ""a &gt;= b"";
  }
}
cout &lt;&lt; ""\n"";
</code></pre>

<p>You only need 2 comparisons.</p>
",0
34249424,34249365,4,"<p>The</p>

<pre><code>cin &gt;&gt; n;
</code></pre>

<p>consumes only the digits you've entered, and leaves a <strong>newline</strong> (at the least) in the input buffer.</p>

<p>This newline is then read and output by the first executed</p>

<pre><code>getline(cin,data[i]);
cout &lt;&lt; data[i] &lt;&lt; endl;
</code></pre>

<p>To avoid it you can use <code>getline</code> of a string also for the integer input, and e.g. convert to integer via <code>stoi</code>. Or, less robust, you can call the <code>ignore</code> method on the stream to ignore everything up to and including the next newline. It's less robust because formatted input of an integer can put the stream in an error mode where it ignores further input operations until the error mode is cleared.</p>

<p>Re the array, better use a <code>std::vector</code>. Then you don't need to decide on a fixed capacity.</p>
",2
34249434,34249365,1,"<p><code>cin &gt;&gt; n</code> reads the number <em>but leaves the newline in the input stream</em>.  Your first call to <code>getline</code> reads that, so you start up with an empty line.</p>
",0
34249712,34249365,0,"<p>The problem is you are mixing calls to getline() with the use of the operator >>.
Remember that operator >> ignored leading white space so will correctly continue across lines boundaries. But stops reading after the input has successfully been retrieved and thus will not swallow trailing '\n' characters. Thus if you use a getline() after a >> you usually get the wrong thing unless you are careful (to first remove the '\n' character that was not read).</p>

<p>The trick is to not use both types of input.
If you're using getline after cin >> yourdata, you need to flush the newline out of the buffer in between.</p>

<pre><code>    #include &lt;iostream&gt;
    #include &lt;string&gt;
    using namespace std;
    int main(){
        int n = 1;
        string data[13];
        while(n &gt; 0){
            cin &gt;&gt; n;
            cin.ignore(10,'\n'); // insert this into your code
            for(int i = 0; i &lt; n; i++){
                getline(cin,data[i]);
                cout &lt;&lt; data[i] &lt;&lt; endl;
            }
       }
       return 0;
    }
</code></pre>
",4
30197144,30196471,0,"<p>Please provide next time a full functional sample with the proper class attributes. Your question is hardly understandable. But anyway, here your mistake:</p>

<p>You do not provide a pointer, you do give a reference:</p>

<pre><code>E(X&amp; x):D(x)
{
  //do something
}
</code></pre>

<p>In fact you give away the instance itself, not a pointer! At the end of lifetime of <code>E</code>, all instances inseide <code>E</code> will be destroyed, even <code>X</code>. C++ do not care that you have the instance referenced on different places, because C++ has not a something like a reference counter.</p>

<p>Use</p>

<pre><code>E(X *x):D(x)
{
  //do something
} 
</code></pre>

<p>I recommend using <code>std::shared_ptr</code>.</p>
",0
30209757,30209309,0,"<p>Your <code>ulong htonf(float d)</code> is clashing with microsofts.
Each overloaded function must have a distinct different parameter list.</p>

<pre><code>unsigned __int32 __inline htonf( float value)
</code></pre>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/jj710198(v=vs.85).aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/desktop/jj710198(v=vs.85).aspx</a></p>

<pre><code>class C {
   int func();
   double func();   // &lt;----- error C2556
   int func(int i);   // ok parameter lists differ
};
</code></pre>
",0
28311476,28311362,0,"<p>The problem is that when you have:</p>

<pre><code>void getheldtickets()
{
    // ..
    rsvdtickets = seasontkt + corptkt;
}
</code></pre>

<p>You're not defining <code>tickets::getheldtickets</code>, you're actually declaring and defining an entirely unrelated free function called <code>getheldtickets</code>. That function is unrelated to the class <code>tickets</code>, and thus has no access to the <code>tickets</code> members - and so <code>rsvdtickets</code> is an declared identifier.</p>

<p>The correct way to define a class method external to the class is:</p>

<pre><code>void tickets::getheldtickets()
//   ^^^^^^^^^
{
    // everything as before
}
</code></pre>
",0
30209335,30209302,3,"<p>You have copied the makefile wrong, the option is not <code>-W1</code> but <code>-Wl</code> with the letter <code>l</code> (lower-case <code>L</code>) and not the digit <code>1</code>.</p>
",1
28469389,28469299,3,"<p>There are a few problems in your code. <code>arr[n]</code> is non-standard C++, and you're only allowing yourself 5 slots for your odd and even numbers (what if the user wants to input 20 numbers?) Furthermore, you're always writing the <code>j</code>th number to either <code>odd[j]</code> or <code>even[j]</code>... which means that if the first number was odd and the second was even, you now wrote a value to <code>even[1]</code> but never wrote anything to <code>even[0]</code>. You're not populating your arrays correctly, and you end up with several uninitialised <code>int</code>s which make your final computations undefined behavior.</p>

<p>The easy solution is to just sidestep all of those problems by not using arrays at all, since you don't really need them:</p>

<pre><code>int odd = 0, even = 1;
cin &gt;&gt; n;

int x;
for (int i = 0; i &lt; n; ++i) {
    // get the next value
    cin &gt;&gt; x;

    // either multiply or add it as appropriate
    if (x % 2 == 0) {
        even *= x;
    }
    else {
        odd += x;
    }
}
</code></pre>
",2
28469510,28469299,0,"<p>So, I agree with the answer provided by Barry. However, if this is, say, a school assignment where you are required to use arrays, you will still need to use them. </p>

<p>If this is the case, to address this issue:</p>

<p>""Furthermore, you're always writing the jth number to either odd[j] or even[j]... which means that if the first number was odd and the second was even, you now wrote a value to even[1] but never wrote anything to even[0]. You're not populating your arrays correctly, and you end up with several uninitialised ints which make your final computations undefined behavior.""</p>

<p>Consider running the user-defined-length array (that is, arr[n]) through two different tests for array items: one finding even elements and one finding odd elements.</p>

<p>Unless otherwise specified, you should probably not arbitrarily limit the array size of even[] and odd[] to just five items.</p>
",0
33000633,32999562,4,"<p>OP seems to have run afoul of not understanding <a href=""https://en.wikipedia.org/wiki/Virtual_memory"" rel=""nofollow"">Virtual Memory</a>.</p>

<p>Each process has its own virtual addressing with its unique addressing space where any address may or may not be used. This allows physical storage to be in any physically addressable medium: cache, RAM, disk cache or something esoteric like the spin of paired subatomic particles. As a result all processes may concurrently use the same addresses because every address in every process is mapped to different locations in physical storage.</p>

<p>OP has stated that at 0x0178B3A8 in some unknown process X is a valid ID number.</p>

<p>The OP's program is not process X. Let's call it's execution process Y. In process X 0x0178B3A8 very likely is the address of a user ID. I have no way to confirm this. But since 0x0178B3A8 is a virtual reference, not a physical storage reference, process Y cannot read 0x0178B3A8 and expect anything that process Y did not put there. If Y didn't put anything at 0x0178B3A8, the program's behaviour is undefined.</p>

<p>How to solve this problem I want nothing to do with. Odds are good that it will not end well. </p>
",0
27563680,27563565,2,"<blockquote>
  <p>Why can't you pass a string literal to a function that uses a template argument?</p>
</blockquote>

<p>You can, you're not reading the compiler error message properly.</p>

<p>This compiles fine:</p>

<pre><code>new_node(""hi"");
</code></pre>

<p>But this doesn't:</p>

<pre><code>Node&lt;string&gt;* root = new_node(""hi""); //error!
</code></pre>

<p>So the problem is clearly not passing string literals to template functions.</p>
",0
27563618,27563565,7,"<p><code>T</code> is deduced to <code>const char*</code>, so will be returned <code>Node&lt;const char*&gt;*</code>, but you cannot assign it to <code>Node&lt;string&gt;*</code></p>

<p>You can create a temporary:</p>

<pre><code>new_node(std::string(""hi""));
</code></pre>

<p>Or you can call <code>new_node</code> with explicit qualification:</p>

<pre><code>new_node&lt;std::string&gt;(""hi"");
</code></pre>
",0
29220093,29219561,2,"<p>You need to check your pointer value after you malloc:</p>

<pre><code>a = (unsigned int *)malloc(b * sizeof(unsigned int));
if ( a == NULL )
{
   //malloc failed. don't attempt to dereference that pointer.
}
</code></pre>

<p>Also, you're program needs to be compiled in 64-bit mode, just having a 64-bit OS doesn't mean any program can address more than 4GB of RAM.</p>

<p>Lastly, malloc can fail when there isn't a contiguous block of memory the requested size available. So if you are requesting large chunks of memory malloc can fail even if there is enough memory available on the heap if your heap is fragmented.</p>
",0
28166229,28162563,1,"<p><strong>Switch Statement:</strong></p>

<blockquote>
  <p>The switch statement provides a convenient alternative to the <code>if</code> when
  dealing with a multi-way branch. Suppose we have some integer value
  called test and want to do different operations depending on whether
  it has the value 1, 5 or any other value, then the switch statement
  could be employed</p>
</blockquote>

<p><strong>Syntax:</strong></p>

<pre><code>switch(expression resulting to integer literals/integer literals/enumeration types/){
    case constant-expression  :
       statement(s);
       break; //optional
    case constant-expression  :
       statement(s);
       break; //optional
    // you can have any number of case statements.

    default : //Optional and one default statement can be present for a switch
       statement(s);
}
</code></pre>

<p><strong>The following rules apply to a switch statement:</strong></p>

<ul>
<li>The expression used in a switch statement must have an integral or
enumerated type, or be of a class type in which the class has a
single conversion function to an integral or enumerated type.</li>
<li>You can have any number of case statements within a switch. Each case
is followed by the value to be compared to and a colon.</li>
<li>The constant-expression for a case must be the same data type as the 
variable in the switch, and it must be a constant or a literal.</li>
<li>When the variable being switched on is equal to a case, the<br>
statements following that case will execute until a break statement<br>
is reached.</li>
<li>When a break statement is reached, the switch terminates, and the<br>
flow of control jumps to the next line following the switch<br>
statement.</li>
<li>Not every case needs to contain a break. If no break appears, the<br>
flow of control will fall through to subsequent cases until a break<br>
is reached.</li>
<li>A switch statement can have an optional default case, which must<br>
appear at the end of the switch. The default case can be used for<br>
performing a task when none of the cases is true. No break is needed 
in the default case.</li>
</ul>

<p><strong>It works as follows:-</strong></p>

<ul>
<li>The expression, just test in this case, is evaluated.</li>
<li>The case labels are checked in turn for the one that matches the
value.</li>
<li>If none matches, and the optional default label exists, it is
selected, otherwise control passes from the switch compound statement</li>
<li>If a matching label is found, execution proceeds from there. Control
then passes down through all remaining labels within the switch
statement. As this is normally not what is wanted, the <code>break</code>
statement is normally added before the next case label to transfer
control out of the switch statement. </li>
<li><p>One useful exception occurs when    you want to do the same
processing for two or more values. Suppose    you want values 1 and
10 to do the same thing, then:-</p>

<p>case 1 :
/*.
any number of cases
  . 
*/
case 10:
  // Process below statements for case 1 to 10
  break;</p></li>
</ul>

<p>works because the test = 1 case just <strong>""drops through""</strong> to the next section.</p>

<p><strong>Conditional Operator:</strong></p>

<p>The ternary operator (?:) is a very useful conditional expression used in C and C++. It's effects are similar to the if statement but with some major advantages.</p>

<p>The basic syntax of using the ternary operator is thus:</p>

<pre><code>(condition) ? (if_true) : (if_false)
</code></pre>

<p>Which is basically the same as:</p>

<pre><code>if (condition)
    if_true;
else
    if_false;
</code></pre>

<p>Therefore if ""condition"" is true, the second expression is executed (""if_true""), if not, the third is executed (""if_false"").</p>

<p>For you Code:</p>

<p>You can use any of the way to find, one way is,</p>

<pre><code>#define POSITIVE (1)
#define NEGATIVE (-(1))
#define ZERO (0)
switch ( ( user_input &gt;= ZERO )? POSITIVE : NEGATIVE )
{
    case POSITIVE:
        if( user_input == ZERO )
        {
          cout &lt;&lt; ""The given value is a Zero."" &lt;&lt; endl;
        }
        else
        {
          cout &lt;&lt; ""The given value is positive."" &lt;&lt; endl;
        }
        break;
    case NEGATIVE:
        cout &lt;&lt; ""The given value is negative."" &lt;&lt; endl;
        break;
}
</code></pre>
",0
28183631,28183599,2,"<p>Change your programs to receive 'file path' as a parameter. Write a note(ReadMe) with the program to specify the file format and added a sample data file with the package</p>
",0
28184663,28183599,0,"<p>tl;dr: if you just put the text file in the same folder with your executable, you can open it with <code>parseFile(""Store.txt"");</code></p>

<p>In most runtime implementations, there is a notion of a ""working directory."" When you open up an executable via the graphical shell (by double clicking it or something to that effect) the working directory is the same as the directory the executable is in. </p>

<p>Now, if you try to open a file in your program via a path that isn't fully qualified, then the path that gets used will be relative to the working directory.</p>

<p>A fully qualified path is a discrete path that points to a single entity in your filesystem. <code>""/Users/David/Desktop/FinalProject/Store.txt""</code> is one such example, as it starts at root (<code>/</code> on *nix, <code>DriveLetter:\</code> on Windows) and says exactly which directories you need to traverse to get to your file.</p>

<p>A path that is not fully qualified (which basically means that it doesn't start at the root of your filesystem) can be used to perform relative file addressing. Most runtimes will assume that any path that is not fully qualified is meant to be relative to the working directory, which basically means that the path that <em>actually</em> gets opened is the result of concatenating your provided path to the end of the working directory.</p>

<p>As an example, if you opened your binary, which is stored as <code>/Users/David/Desktop/FinalProject/a.exe</code>, then the working directory would be set to <code>/Users/David/Desktop/FinalProject/</code>. If your program then tried to open <code>""Store.txt""</code>, the runtime would see that you're trying to open a path that isn't fully qualified, so it would assume you meant to open a file relative to the working directory, which would then be <code>/Users/David/Desktop/FinalProject/</code> + <code>Store.txt</code>, which would be <code>/Users/David/Desktop/FinalProject/Store.txt</code>. </p>

<p>The nice thing about this is that if you move your binary, the working directory moves too. if you move <code>a.exe</code> along with <code>Store.txt</code> to <code>/Users/David/Desktop/FinalProject(copy)/</code>, then when you open <code>/Users/David/Desktop/FinalProject(copy)/a.exe</code>, the working directory will be <code>/Users/David/Desktop/FinalProject(copy)/</code> now, and now when you call <code>parseFile(""Store.txt"")</code>, it will instead open up <code>/Users/David/Desktop/FinalProject(copy)/Store.txt</code>. This holds true when moving to other computers, too.</p>

<p>It's worth noting that if your binary is run from a command line utility, the working directory will often be the directory the command line shell is in, rather than the executable's directory. It is, however, a part of the C standard that the first command line parameter to <code>main()</code> should be the name of the executable, and most implementations supply you with the fully qualified path. With some minimal parsing, you can use that to determine what path to use as a base for addressing files.</p>
",0
28457101,28456990,0,"<p>It all depends on the text editor you are using. Some will notice edit to the file and ask you if you want to reload a fresh version.</p>

<p>If you work on linux, and you'd like to have an idea of what's happening in real time you could do someting like</p>

<pre><code>tail -f &lt;path-to-file&gt;
</code></pre>

<p>or if the file doesnt yet exist</p>

<pre><code>watch -n 0,2 ""cat &lt;path-to-file&gt; | tail""
</code></pre>

<p>which will display the content of the file and refresh it every 0.2 sec</p>
",1
28458308,28456990,0,"<p>Thx for your fast answers :)
Crazy.. i was working so long with fopen() and found no solution.. also the fflush(pFile) didnt help (I wasnt able to open file.. always error that its already in use by another program). I never tryed the fstream. Seems fstream solved my problem now. I can open my file with msnotepad.exe while the program is still writing to the file :) Here a small test-code:</p>

<pre><code>#include &lt;fstream&gt; #include &lt;iostream&gt; using namespace std;
int main(){
ofstream FILE;
FILE.open(""E:\\Log.txt"");
for (size_t i = 0; i &lt; 50; i++)
{
    FILE &lt;&lt; ""Hello "" &lt;&lt; i &lt;&lt; endl;
    cout &lt;&lt; ""log"" &lt;&lt; endl;
    _sleep(500);        
}   
FILE.close();
cout &lt;&lt; ""finish"" &lt;&lt; endl;
return 0;}
</code></pre>
",1
28457917,28456990,1,"<p>There are 2 different problems.</p>

<p>First is writing of logs. In a Windows system, the buffering will cause the data to be actually written to disk :</p>

<ul>
<li>if you close the file</li>
<li>when you have a fair quantity of new data (unsure between several ko and several Mo)</li>
<li>if you explicitely flush</li>
</ul>

<p>Unless if you have a high throughput, I would advise to at least flush (if not close) after each write to avoid loosing logs if program crashes. And it also allows you to read the log file in real time.</p>

<p>Second is reading. Vim for example is known to be able to monitor a file that can be modified by an external process. It will open a popup saying that file has been modified and offer to reload it. I do not know what notepad does in same conditions. But :</p>

<ul>
<li>it does not have sense unless first problem has gone</li>
<li>it is not very efficient since you will reload whole file each time</li>
</ul>

<p>IMHO, you'd better write a custom reader that mimics Linux <code>tail -f</code> :</p>

<ul>
<li>read (and display) until end of file</li>
<li>repeteadly read (with a short sleep after an unsuccessful read) to process newly added data</li>
</ul>
",0
28229198,28228747,0,"<p>Let me take you through how I would do this.</p>

<p>Note that I didn't try to optimize anything at all. Writing easy to understand code is much more important than optimization. Besides, the current compilers are very good at optimizing this code (using NRVO).</p>

<p>First some typedefs for the types involved. It makes it so much easier to read and write the code:</p>

<pre><code>typedef std::vector&lt;int&gt; Locations;
struct Room
{
  Locations locations; // Apparently, a room has only locations (or should that be exits?) and nothing else.
};
typedef std::vector&lt;Room&gt; Rooms;
</code></pre>

<p>Then some high-level pseude-code:</p>

<pre><code>Open File
Read File into 'rooms'
Print 'rooms'
</code></pre>

<p>Which, in this case, translates easily into a short main:</p>

<pre><code>int main()
{
    std::ifstream openfile(""rooms.dat"");
    Rooms rooms = readRooms(openfile);
    printRooms(rooms);

    return EXIT_SUCCESS;
}
</code></pre>

<p>How do I implement <code>readRooms()</code>? We start with pseudo-code again:</p>

<pre><code>For each line in the file:
    Read the room on this line
</code></pre>

<p>The easiest way to process a file line by line, is reading a full line with std::getline(). Otherwise one risks skipping the newlines by accident. To easy parsing this line, let's create a stringstream from it, so we can use the usual way to parse the line.</p>

<p>Note that <code>readRooms()</code> accept a <code>std::istream</code>, which is more generic than a <code>std::ifstream</code>. When you do this, the function can be used with e.g. std::stringstream as well.</p>

<pre><code>Rooms readRooms(std::istream&amp; is)
{
    Rooms allRooms;
    std::string line;
    while (std::getline(is, line))
    {
       std::stringstream lineStream(line)
       Room newRoom = readRoom(lineStream);
       allRooms.push_back(newRoom);
    }
    return allRooms;
}
</code></pre>

<p>Now reading a single room. Pseudo-code:</p>

<pre><code>for each location on the line:
    add the location to the room
</code></pre>

<p>In code:</p>

<pre><code>Room readRoom(std::istream&amp; is)
{
     Room newRoom;
     int location;
     while (is &gt;&gt; location)
     {
         newRoom.Locations.push_back(location);

         // It would be easier if the locations are separated by whitespace only.
         char shouldBeComma;
         is &gt;&gt; std::ws &gt;&gt; shouldBeComma;
     }
     return newRoom;
}
</code></pre>

<p>Wow, we're already finished with reading our rooms!</p>

<hr>

<p>You should be able to write code to print the rooms yourself. In case you have C++11, it would be very easy:</p>

<pre><code>void printRooms(const Rooms&amp; rooms)
{
    for (const Room&amp; room : rooms)
    {
        printRoom(room);
    }
}
</code></pre>

<p>and so on...</p>
",0
33550893,33550782,0,"<p>I will assume that the file is in UTF8 format. If so then you question is really, how to i read UTF8 files using c++</p>

<p>here is somebody reading chinese <a href=""https://stackoverflow.com/questions/20195262/how-to-read-an-utf-8-encoded-file-containing-chinese-characters-and-output-them"">How to read an UTF-8 encoded file containing Chinese characters and output them correctly on console?</a>. You should be able to adapt this to your locale</p>
",0
25704565,25704516,4,"<p>You need to check the result of the read operation before using the value that is being read.  The <code>&gt;&gt;</code> operator returns a reference to the stream being read from, and the stream contains state information to indicate whether the last operation succeeded or failed.  If failed, the value of the variable being read is indeterminate, so don't use it.</p>

<p>Try this:</p>

<pre><code>int a;
if (cin &gt;&gt; a) // &lt;-- same as: if (!cin.operator&gt;&gt;(a).fail())
{
    // read successful, use the int as needed...
}
else
{
    // read failed, do not use the int...
}
</code></pre>
",2
25704612,25704516,1,"<p>When the user input can't be converted to the type of the variable, cin >> leaves the variable's value untouched. You're seeing what the variable looks like uninitialized, which is zero. So when you enter a word instead of an integer, value of variable is untouched and remains uninitialized.</p>
",1
25705007,25704516,0,"<p>It is not a problem.</p>

<p>In C++, a <code>WORD</code> is typically a subset of <code>int</code>. </p>

<p>So the complete <code>WORD</code> valuerange is easily represented as an <code>int</code></p>

<p>Just have a look here:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx"" rel=""nofollow"">WORD datatype in windows environments</a> (it is just a two byte value here, <code>int</code> in comparison is 4 bytes wide in most cases)</p>

<p>And of course:
<a href=""http://www.makelinux.net/books/lkd2/ch19lev1sec2"" rel=""nofollow"">Word size in linux</a></p>

<p>Of course, this answer is somewhat tongue-in-cheek</p>
",0
30407032,30406706,1,"<p>""Memory consumption after the release of pointers is the same as before the release"". This is not indicative, many implementations of <code>free</code> will not usually return the memory to the OS, instead ""recycling"" it for future allocations. See <a href=""https://stackoverflow.com/questions/2215259/will-malloc-implementations-return-free-ed-memory-back-to-the-system"">this question</a>.</p>
",1
30407038,30406706,3,"<p>In principle your memory doesn't leak, because you've a <code>delete[]</code> fore every <code>new[]</code>.  </p>

<p>But when you allocate huge amounts of memory (and even in general, whenever you allocate memory), you should consider the case the allocation fails:  </p>

<pre><code>    ...
    try {
        test();
    }
    catch(bad_alloc) {
        cerr &lt;&lt; ""No more memory !"" &lt;&lt;endl; 
    }
    ...
</code></pre>

<p>The fact that an exception is raised (which happens here), will cause your code to leave <code>test()</code> before the deletes take place.  So due to the exception, your memory will leak.</p>

<p><strong><em>Remark:</strong> The best way to avoid such memory leaks is to use the <a href=""https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow"">RAII</a> idiom:  you make memory allocation only inside an object, and you free the memory in the object's destructor.  As all objects that go out of scope will be deleted, this will make sure that memory freing always takes place, even in case of exceptions.</em>  </p>
",2
28248491,28248296,0,"<p>There are probably plenty of ways, but I'm still new so what I would do is change the data structure to vector. That way you can push or pop things out.</p>

<pre><code>#include &lt;vector&gt; //Necessary if you are not familiar with vectors.
#include &lt;iostream&gt;
using namespace std;
int main(){
    vector&lt;string&gt; names;
    names.push_back(""Miss Scarlet"");
    names.push_back(""Mrs. Peacock"");
    //...Keep going
    for(int i=0; i&lt;3; i++){
        string temp;
        cout&lt;&lt;""Select"";
        cin&gt;&gt;temp;
        names.erase(find(vector.begin(), vector.end(), temp)!=vector.end());
    }
}
</code></pre>

<p>Something like that I'm not a wizard but hopefully it suffices.</p>
",0
28250509,28248296,0,"<p>You can use this :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;

int main()
{
    int m_NumOfPlayers;

    std::string m_PlayerSelection [6] =
    {
        ""Miss Scarlet"",
        ""Mrs. Peacock"",
        ""Colonel Mustard"",
        ""Professor Plum"",
        ""Mrs. White"",
        ""Mr. Green""
    };

    std::string m_Number [6] =
    {
        ""first"",
        ""second"",
        ""third"",
        ""fourth"",
        ""fifth"",
        ""sixth""
    };

    int taken[7]={0,0,0,0,0,0,0};// Array to keep track of the selected names

    for (int i = 0; i &lt; 3; i++)
    {
        std::cout &lt;&lt; ""\nPlease choose the "" &lt;&lt; m_Number[i] &lt;&lt; "" player"" &lt;&lt; "":"" &lt;&lt; std::endl &lt;&lt; std::endl;
        for (int j = 0; j &lt; 6; j++)
        {
            std::cout &lt;&lt; (j + 1) &lt;&lt; "". "" &lt;&lt; m_PlayerSelection[j] ;

            // printing if the name is already taken by someone
            if(taken[j+1] == 1)
            {
                std::cout &lt;&lt; std::setw(10);
                std::cout &lt;&lt; ""-- taken"" &lt;&lt; std::endl;
            }
            else
              std::cout &lt;&lt; std::endl;
        }

        int selection;
        std::cin &gt;&gt; selection;

        while (selection &lt; 1 || selection &gt; 6 || taken[selection])
        {
            std::cout &lt;&lt; ""Please choose a number between 1 and 6 which is not taken already: "";
            std::cin &gt;&gt; selection;
        }
        taken[selection]=1; // mark selected name
    }
    return 0;
}
</code></pre>
",0
32470415,32469508,1,"<p>The actual problem was identified by Tony D.</p>

<p><strong>The debugger in Xcode had a breakpoint set to the particular line of code. I simply had to drag it out of the gutter. For those who don't know, that the green arrow on the left in of the lines of code is a breakpoint. Drag it to the bottom, out of the code, to remove it.</strong></p>

<p>I'm sure I made a total newbie mistake, since I am one, but lesson learned.</p>
",0
32469690,32469508,1,"<p>Because <code>state_tax_payment</code> and <code>total_tax_payment</code> are not initialize <code>state_tax_payment = net_sales / state_tax_payment;</code> and  <code>county_tax_payment = net_sales / county_tax_payment;</code> lines can be result in undefined behavior</p>

<ol>
<li>Initialize the all float variables</li>
<li>Assign some value to  <code>state_tax_payment</code> and <code>total_tax_payment</code></li>
<li>Correct the type mention by ' Thomas Matthews'.</li>
</ol>

<p>Then your program works fine . May be it exit after execution finish. so you can add something like 'getchar()' , std::cin.get() to pause the console. </p>
",6
28248732,28248655,5,"<p>You want five ints.  Of course you should use </p>

<pre><code>int *a=new int[5];
</code></pre>

<p>Since you are learning C++, it is wise to learn about <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behavior</a>.</p>

<p>You may expect C++ to stop you or warn you if you are doing something that you shouldn't be doing, such as treating an <code>int</code> as if it were an <code>int[5]</code>.</p>

<p>C++ isn't designed to track these sorts of mistakes.  If you make them, C++ only promises that it makes no promises what will happen.  Even if the program worked the last time you ran it, it may not work the next time.</p>
",1
30703551,30703204,0,"<p>The most robust advice is to never mix formatted I/O (e.g. using operator <code>&gt;&gt;</code>) with line oriented input on the same stream (e.g. <code>getline()</code>) or with character oriented input (e.g. <code>cin.get()</code>).</p>

<p>The reason is that the different styles of input function respond to newlines differently.  Formatted I/O tends to stop and leave a newline in the stream (where it will be encountered first up by <code>getline()</code> in your code) whereas line oriented input will tend to respond immediately to any newline and discard it.</p>

<p>So change <code>cin &gt;&gt; t</code> to</p>

<pre><code>string temp_string;
getline(cin, some_string);
istringstream some_stream(some_string);   // from &lt;sstream&gt;
some_stream &gt;&gt; t;
</code></pre>

<p>The above can be placed in a separate function if you find yourself doing such things frequently.</p>

<p>When combined with the code in your loop, this will only ever interact directly with <code>cin</code> using line-oriented input, which will avoid the sort of confusion you are seeing.</p>

<p>Using tricks like <code>cin.ignore()</code> or stream manipulators (e.g. <code>getline(cin &lt;&lt; std::ws, s)</code> will be fragile, depending on how other code (before or after yours) interacts with the stream.    </p>
",9
30703271,30703204,0,"<p>Put <code>cin.ignore</code> before the loop and try again.</p>

<p>If there is a newline left in the stream, it will stop reading there.</p>
",4
29250807,29250660,0,"<blockquote>
  <p>Intuitively it seems me that there should be a simple way to set custom exceptions EngagedListException, ResRegestryException without wrapping the whole std::map class.</p>
</blockquote>

<p>There shouldn't be one. The functions of a class define a contract. If the documentation for a function says ""this function will throw a std::out_of_bounds in this condition"", then that is what the function does.</p>

<p>That said, encapsulating these classes should be easier, when you consider that you will probably not use all methods of the map and vector (so use private encapsulation and just expose what you use in your client code).</p>
",0
34249431,34244361,0,"<p>You really should spend several days to read much more about <a href=""http://stroustrup.com/programming.html"" rel=""nofollow"">Programming using C++</a> and about <a href=""http://en.cppreference.com/w/cpp/container"" rel=""nofollow"">C++ standard containers</a>.</p>

<p>You might have some map or set indexed by user ids (e.g. have some appropriate <code>class userdata</code> then use <code>std::map&lt;int,userdata&gt;</code> and/or <code>std::set&lt;int&gt;</code>  with the <code>int</code> key being the <code>user</code> id).</p>

<p>Contrarily to your claims, if you are working in a team, you should consider (after discussion with co-workers) to improve the data structure and the existing code (so patching the <code>struct vote</code> <em>should</em> be discussed and attempted, and you should consider patching the code at other places too!). A version control system like <a href=""http://git-scm.com/"" rel=""nofollow"">git</a> facilitate doing that.</p>

<p>Perhaps you should use <a href=""https://en.wikipedia.org/wiki/Smart_pointer"" rel=""nofollow"">smart pointers</a>, for example by declaring <code>std::set&lt;std::shared_ptr&lt;vote&gt;&gt; testVotes;</code> or you just want a set of votes <code>std::set&lt;vote&gt; testVotes;</code></p>
",1
34249515,34244361,2,"<p>If looking for the solution for a single specific user a function could build an <code>std::set</code> of all items that him/her rated:</p>

<pre><code>std::set&lt;int&gt; rated_items(int user) {
    std::set&lt;int&gt; result;
    for (auto p : testVotes) {
        if (p-&gt;user == user) result.insert(p-&gt;item);
    }
}
</code></pre>

<p>however if you need to do this for all users then building a single map from users to rated items would be more efficient:</p>

<pre><code>std::map&lt;int, std::set&lt;int&gt;&gt; rated_items() {
    std::map&lt;int, std::set&lt;int&gt;&gt; result;
    for (auto p : testVotes) {
        result[p-&gt;user].insert(p-&gt;item);
    }
}
</code></pre>

<p>Knowing which items a user rated makes trivial to know which items the user has NOT rated.</p>

<p>PS: the data structure <code>std::set&lt;vote *&gt;</code> looks a <strong>very</strong> questionable choice (a <code>std::set&lt;vote&gt;</code> would seem much more reasonable, or an <code>std::vector&lt;vote&gt;</code> if the same user can rate the same item multiple times).
Thousands of lines already written is nothing compared to the grief of living <strong>forever</strong> with a bad data structure.</p>
",3
31886409,31886366,4,"<p>you can easily use <code>sqrt(4*3.142*A)</code>
 but don't forget to add this first <code>#include&lt;cmath&gt;</code></p>
",0
31889215,31886366,0,"<pre><code>****we have function for sqrt provided in math library.****
#include &lt;iostream&gt;
#include&lt;math.h&gt;

using namespace std;


int main()
{
// ¡Ì4*3.142*A
    int A =10;
    float result = sqrt(4*3.14*A);
    cout&lt;&lt;result&lt;&lt;endl;
 }
</code></pre>

<p><strong>result</strong>==11.2071</p>
",0
27557473,27557433,4,"<p>Yes, it thinks that <code>color</code> is a function and not a constructor.</p>

<p>The object is already constructed, and it's too late to call the constructor.</p>

<h1>Option 1</h1>

<p>Add a constructor to <code>Cal</code> that can take color values and forward them:</p>

<pre><code>struct Cal {
    int days;
    Color color;
    Cal(): days(), color(255,255,255){
    }
    Cal(int nred, int ngree, int nblue): days(), color(nread,ngree,nblue){
    }
};
int main() {
    Cal go(100,100,100);
    return 0;
}
</code></pre>

<h1>Option 2</h1>

<p>Manually set the values:</p>

<pre><code>int main() {
    Cal go;
    go.color.red = go.color.green = go.color.blue = 100;
    return 0;
}
</code></pre>

<h1>Option 3</h1>

<p>Assign the <code>color</code> member from a temporary instance:</p>

<pre><code>int main() {
    Cal go;
    go.color = Color(100, 100, 100);
    return 0;
}
</code></pre>
",4
28311124,28311048,1,"<p>if it meets one of the fail criteria you don't want to continue checking the other if cases.  So use the else case for everything.    </p>

<pre><code>int main()    
{    
    int score;

    cout &lt;&lt; ""Please enter the score."" &lt;&lt; endl;
    cin &gt;&gt; score;

    if (score &gt; 100)
       cout &lt;&lt; ""Invalid Score."" &lt;&lt; endl;

    else if (score &lt; 0)
        cout &lt;&lt; ""Invalid Score."";

    else if (score &gt;= 50)
        cout &lt;&lt; ""Pass"" &lt;&lt; endl;
    else
        cout &lt;&lt; ""Fail."" &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;    
</code></pre>

<p>}</p>
",0
28311253,28311048,0,"<p><strong>hint</strong> use else-if statements. These check if the first statement doesn't work, then it checks whether the next one will work, and if it doesn't, nothing runs.</p>
",0
27513927,27513676,1,"<pre><code>    readdata.append(line.substr(0, line.find(""\r"")));
</code></pre>
",0
27513781,27513676,8,"<p>I think you are getting a <code>'\r'</code> at the end of each line.</p>
",0
25704589,25704518,1,"<p>The function can look like</p>

<pre><code>void ss ( int a[], size_t n )
{
   for ( size_t i = 0 ; i &lt; n ; i++ )
   { 
      size _t small = i;

      for ( size_t  j = i + 1; j &lt; n ; j++ )
      {
         if  ( a[j] &lt; a[small] ) small = j;
      }

      if ( i != small )
      {
         int tmp = a[small];
         a[small] = a[i];
         a[i] = tmp;
      } 
   }
}
</code></pre>
",0
25704596,25704518,0,"<p>It doesn't seem to be the SelectionSort I know. in the algorithm I know during every loop I look for the smallest element in the right subarray and than exchange it with the ""pivot"" element of the loop. Here's the algorithm</p>

<pre><code>void selectionSort(int* a, int dim)
{
   int posMin , aux;
   for(int i = 0; i &lt; dim - 1; ++i)
   {
      posMin = i;
      for(int j = i + 1; j &lt; dim; ++j)
      {
         if(a[j] &lt; a[posMin])
            posMin = j;
      }
      aux = a[i];
      a[i] = a[posMin];
      a[posMin] = aux;
   }
}
</code></pre>

<p>and it seems that you change every smaller element you find, but also change the position of the ""pivot"". I hope the answer is clear.</p>
",0
25704621,25704518,0,"<p>Everything is ok in the original function, only that the <code>small</code> variable need to be refreshed when two vector elements will be switched.
Also in if statement set the <code>small</code> variable to the new value of <code>AR[i]</code>.</p>
",0
28493311,28493242,0,"<p>It is a valid question - college level data structure question. And so the answer can be found in many data structures books. <a href=""http://books.google.co.in/books/about/Data_Structures_Using_C.html?id=X0Cd1Pr2W0gC"" rel=""nofollow"">http://books.google.co.in/books/about/Data_Structures_Using_C.html?id=X0Cd1Pr2W0gC</a></p>
",2
28493861,28493242,0,"<p>The wording of your question makes it seem that you are aware of the difference between linked lists and arrays. So I'm going to skip that part.</p>

<p>The main point to remember in the implementation is that while linked lists have pointers to the next element, in an array this will automatically be the next index. So, one way of implementing is to store all the data points of the linked list in the array. If you have to insert or delete an element, then you would first have to create a space in the array to place them at, or remove the extra space created. In a linked list you could have simply changed the pointers for one/two nodes and you would be done. However, we can't do that in an array since we can't manipulate the next pointers in the array. So, a simple idea is to shift every element to the left or right by one step depending upon your choice of operation. In case of insertion, insert that element in the space created by shifting right. In case of deletion, shift everything to the right of the element to be deleted to the left by one index. Note that this way every insertion and deletion will be O(n).</p>

<p>An idea avoid these repeated shifts in case of deletion could be to replace the element to be deleted by a pre-decided character, say '<em>'. So, while traversing the array, a '</em>' can be interpreted as an empty space. This will avoid left shifts in case of deletion. Also, when the array is full, we can traverse the entire array and remove all the '*' and shift the elements in one pass.</p>

<p>Take care to introduce checks about array bounds.</p>
",0
31220771,31220676,0,"<p>While printing each element you could print the same number of <code>*</code>'s</p>

<p>You could implement a function to print required number of <code>*</code>'s.</p>

<pre><code>   for(i=0;i&lt;rows;i++)
   {
       for(j=0;j&lt;cols;j++)
       {
         cout &lt;&lt;arr[i][j];
         print_some_stars(arr[i][j]);
         cout&lt;&lt;endl;
       }
    }
</code></pre>
",3
28445647,28442175,0,"<p>The <em>Breadth-first search</em> algorithm described on <a href=""http://en.wikipedia.org/wiki/Breadth-first_search"" rel=""nofollow"">Wikipedia</a> doesn't require recursiveness. The pseudocode talks about a <code>queue q</code> for the ordering and a <code>set V</code> (capital V) to make sure duplicate values get matched only once (which I have left out in the code below):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

template&lt;class T&gt;
struct tree_item {
    T value;
    vector&lt;tree_item&lt;T&gt;&gt; children;

    tree_item(T value) : value(value) {}
};

// constructs animated gif http://en.wikipedia.org/wiki/Breadth-first_search
tree_item&lt;string&gt; build_tree() {
    tree_item&lt;string&gt; a(""a""), b(""b""), c(""c""), d(""d""), e(""e""), f(""f""), g(""g""), h(""h"");

    e.children = { h };
    b.children = {d, e};
    c.children = {f, g};
    a.children = {b, c};

    return a;
}

// implements ""Algorithm"" -&gt; ""Pseudocode"" http://en.wikipedia.org/wiki/Breadth-first_search
template&lt;class T&gt;
bool find_breadth_first(const tree_item&lt;T&gt;&amp; v, function&lt;bool(const T&amp;)&gt; matcher, tree_item&lt;T&gt;&amp; found_item) {
    queue&lt;const tree_item&lt;T&gt;*&gt; q; // step 2
    q.push(&amp;v); // step 5

    while(!q.empty()) { // step 6
        auto t = q.front(); q.pop(); // step 7

        cout &lt;&lt; ""currently visiting "" &lt;&lt; t-&gt;value &lt;&lt; endl;
        if(matcher(t-&gt;value)) { // step 8
            cout &lt;&lt; t-&gt;value &lt;&lt; "" is a match "" &lt;&lt; endl;
            found_item = *t; return true; // step 9
        }

        for(auto&amp; u : t-&gt;children) // step 11
            q.push(&amp;u); // step 15
    }

    return false; // step 19
}

int main() {
    auto root = build_tree();

    tree_item&lt;string&gt; match(""no match"");
    auto matcher = [&amp;](auto candidate) {
        return candidate == ""g"";
    };

    auto found = find_breadth_first&lt;string&gt;(root, matcher, match);

    if(found)
        cout &lt;&lt; ""found: "" &lt;&lt; match.value &lt;&lt; endl;
    else
        cout &lt;&lt; ""not found"" &lt;&lt; endl;
}
</code></pre>

<p>Output:</p>

<pre><code>currently visiting a
currently visiting b
currently visiting c
currently visiting d
currently visiting e
currently visiting f
currently visiting g
g is a match 
found: g
</code></pre>
",0
34258304,34258279,0,"<p>Closing <code>ifs</code> in the middle of the loop isn't a good idea...</p>
",1
31150624,31150485,0,"<p>You could create a table:</p>

<pre><code>struct Int_String_Entry
{
  unsigned int id;
  char *       text;
};

static const Int_String_Entry my_table[] =
{
  {0, ""My_Function""},
  {1, ""My_Function1""},
  //...
};
const unsigned int my_table_size =
    sizeof(my_table) / sizeof(my_table[0]);
</code></pre>

<p>Maybe what you want is a lookup table with function pointers.</p>

<pre><code>typedef void (*Function_Pointer)(void);
struct Int_vs_FP_Entry
{
  unsigned int func_id;
  Function_Point p_func;
};

static const Int_vs_FP_Entry func_table[] =
{
  { 0, My_Function},
  { 1, My_Function1},
  //...
};
</code></pre>

<p>For more completion, you can combine all three attributes into another structure and create another table.</p>

<p><em>Note:  Since the tables are declared as ""static const"", they are assembled during compilation time.</em>  </p>
",1
31150940,31150485,0,"<p>It is an interesting question.</p>

<p>It is possible to statically-initialize a std::map as follows:</p>

<pre><code>static const std::map&lt;int, int&gt; my_map {{1, 2}, {3, 4}, {5, 6}};
</code></pre>

<p>but I get that such initialization is not what you are looking for, so I took another approach after looking at your example.</p>

<p>A global registry holds a mapping between function name (an <code>std::string</code>) and run time (an <code>std::size_t</code> representing the number of milliseconds).</p>

<p>An <code>AutoProfiler</code> is constructed providing the name of the function, and it will record the current time. Upon destruction (which will happen as we exit the function) it will calculate the elapsed time and record it in the global registry.</p>

<p>When the program ends we print the contents of the map (to do so we utilize the <code>std::atexit</code> function).</p>

<p>The code looks as follows:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;chrono&gt;
#include &lt;cmath&gt;

using ProfileMapping = std::map&lt;std::string, std::size_t&gt;;

ProfileMapping&amp; Map() {
  static ProfileMapping map;
  return map;
}

void show_profiles() {
  for(const auto &amp; pair : Map()) {
    std::cout &lt;&lt; pair.first &lt;&lt; "" : "" &lt;&lt; pair.second &lt;&lt; std::endl;
  }
}

class AutoProfiler {
 public:
  AutoProfiler(std::string name)
      : m_name(std::move(name)),
        m_beg(std::chrono::high_resolution_clock::now()) { }
  ~AutoProfiler() {
    auto end = std::chrono::high_resolution_clock::now();
    auto dur = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - m_beg);
    Map().emplace(m_name, dur.count());
  }
 private:
  std::string m_name;
  std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_beg;
};

void foo() {
  AutoProfiler ap(""foo"");
  long double x {1};
  for(std::size_t k = 0; k &lt; 1000000; ++k) {
    x += std::sqrt(k);
  }
}

void bar() {
  AutoProfiler ap(""bar"");
  long double x {1};
  for(std::size_t k = 0; k &lt; 10000; ++k) {
    x += std::sqrt(k);
  }
}

void baz() {
  AutoProfiler ap(""baz"");
  long double x {1};
  for(std::size_t k = 0; k &lt; 100000000; ++k) {
    x += std::sqrt(k);
  }
}

int main() {
  std::atexit(show_profiles);

  foo();
  bar();
  baz();

}
</code></pre>

<p>I compiled it as:</p>

<pre><code>$ g++ AutoProfile.cpp -std=c++14 -Wall -Wextra
</code></pre>

<p>and obtained:</p>

<pre><code>$ ./a.out
bar : 0
baz : 738
foo : 7
</code></pre>

<p>You do not need <code>-std=c++14</code>, but you will need at least <code>-std=c++11</code>.</p>

<p>I realize this is not what you are looking for, but I liked your question and decided to pitch in my $0.02.</p>

<p>And notice that if you use the following definition:</p>

<pre><code>using ProfileMapping = std::multi_map&lt;std::string, std::size_t&gt;;
</code></pre>

<p>you can record <em>every</em> access to each function (instead of ditching the new results once the first entry has been written, or overwriting the old results).</p>
",2
31150551,31150485,0,"<p>In principle you can.  However, I doubt any option is practical.</p>

<p>You can set your key type to be a <code>constexpr</code> value type (this excludes <code>std::string</code>), initializing the value type you implement is not a problem either, just throw in there a <code>constexpr</code> constructor from an array of chars.  However, you also need to implement a <code>constexpr</code> map, or hash table, and a <code>constexpr</code> hashing function.  Implementing a <code>constexpr</code> map is the hard part.  Still doable.</p>
",0
31150990,31150485,0,"<p>As <a href=""https://stackoverflow.com/users/1411457/harmic"">@harmic</a> has already mentioned in the comments, you should probably just pass the name to the constructor.  This might also help reduce code bloat because you don't generate a new type for each function.</p>

<p>However, I don't want to miss the opportunity to show a dirty hack that might be useful in situations where the string cannot be passed to the constructor.  If your strings have a maximum length that is known at compile-time, you can encode them into integers.  In the following example, I'm only using a single integer which limits the maximum string length to 8 characters on my system.  Extending the approach to multiple integers (with the splitting logic conveniently hidden by a small macro) is left as an exercise to the reader.</p>

<p>The code makes use of the C++14 feature to use arbitrary control structures in <code>constexpr</code> functions.  In C++11, you'd have to write <code>wrap</code> as a slightly less straight-forward recursive function.</p>

<pre><code>#include &lt;climits&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;type_traits&gt;

template &lt;typename T = std::uintmax_t&gt;
constexpr std::enable_if_t&lt;std::is_integral&lt;T&gt;::value, T&gt;
wrap(const char *const string) noexcept
{
  constexpr auto N = sizeof(T);
  T n {};
  std::size_t i {};
  while (string[i] &amp;&amp; i &lt; N)
    n = (n &lt;&lt; CHAR_BIT) | string[i++];
  return (n &lt;&lt; (N - i) * CHAR_BIT);
}

template &lt;typename T&gt;
std::enable_if_t&lt;std::is_integral&lt;T&gt;::value&gt;
unwrap(const T n, char *const buffer) noexcept
{
  constexpr auto N = sizeof(T);
  constexpr auto lastbyte = static_cast&lt;char&gt;(~0);
  for (std::size_t i = 0UL; i &lt; N; ++i)
    buffer[i] = ((n &gt;&gt; (N - i - 1) * CHAR_BIT) &amp; lastbyte);
  buffer[N] = '\0';
}

template &lt;std::uintmax_t Id&gt;
struct Profile
{
  char name[sizeof(std::uintmax_t) + 1];

  Profile()
  {
    unwrap(Id, name);
    std::printf(""%-8s %s\n"", ""ENTER"", name);
  }

  ~Profile()
  {
    std::printf(""%-8s %s\n"", ""EXIT"", name);
  }
};
</code></pre>

<p>It can be used like this:</p>

<pre><code>void
function()
{
  const Profile&lt;wrap(""function"")&gt; profiler {};
}

int
main()
{
  const Profile&lt;wrap(""main"")&gt; profiler {};
  function();
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>ENTER    main
ENTER    function
EXIT     function
EXIT     main
</code></pre>
",0
31150997,31150485,0,"<p>Why not just use an Enum like:</p>

<pre><code>enum ProfileID{myFunction = 0,myFunction1 = 1, myFunction2 = 2 };
</code></pre>

<p>?</p>

<p>Your strings will not be loaded in runtime, so I don't understand the reason for using strings here.</p>
",1
31151397,31150485,0,"<p>You could do something similar to the following.  It's a bit awkward, but may do what you want a little more directly than mapping to an integer:</p>

<pre><code>#include &lt;iostream&gt;

template &lt;const char *name&gt;
class Profile{
public:
    Profile() {
        std::cout &lt;&lt; ""start: "" &lt;&lt; name &lt;&lt; std::endl;
    }
    ~Profile() {
        std::cout &lt;&lt; ""stop: "" &lt;&lt; name &lt;&lt; std::endl;
    }
};


constexpr const char myFunction1Name[] = ""myFunction1"";

void myFunction1(){
    Profile&lt;myFunction1Name&gt; profile_me;

    /* some computations here */
}

int main()
{
    myFunction1();
}
</code></pre>
",1
29151020,29150981,6,"<p><strong>Undefined Behavior</strong> is the short answer. The long answer is that because your class has no virtual methods calling them directly is just a function call with an implicit <code>this</code> parameter that points to the memory you've allocated. That said if any of your methods were to access <code>this</code> it would cause more <strong>undefined behavior</strong> because the object hasn't been constructed.</p>

<p>blatantly stolen from Columbo and LRIO:</p>

<blockquote>
  <p><code>[C++11: 3.8/1]:</code> The lifetime of an object is a runtime property of the object. An object is said to have non-trivial initialization if it is of a class or aggregate type and <strong>it or one of its members</strong> is initialized by a constructor other than a trivial default constructor. <em>[ Note:</em> initialization by a trivial copy/move constructor is non-trivial initialization. <em>¡ªend note ]</em> </p>
</blockquote>

<p>The critical bit there is the <strong>it</strong> the pointer to the object can contain data other than just a place where the members are stored. It is up to the implementation to decide what that is.</p>
",2
29151144,29150981,4,"<blockquote>
<p>An object is not created when we use malloc/free for a class in c++. Then why does this code works?</p>
</blockquote>
<p>It depends on how you define &quot;works&quot;, an incredibly vague term that you should generally avoid in questions like this.</p>
<p>I would consider that the code <em>doesn't</em> &quot;work&quot;: it has a bug. It is broken. On any given run of execution it could fail. It could crash. It could open a wormhole.</p>
<p>What is the bug? The bug is that you are invoking undefined behaviour. You allocated memory for a <code>Test</code> object, but you never created a <code>Test</code> object to put there. You then perform operations on the memory as if it contained a <code>Test</code> object, which it doesn't.</p>
<blockquote>
<p><code>[C++11: 12.1/5]:</code> <em>[..]</em> A default constructor is trivial if it is not user-provided <em>[..]</em> <strong>Otherwise, the default constructor is non-trivial.</strong></p>
<p><code>[C++11: 3.8/1]:</code> The lifetime of an object is a runtime property of the object. <strong>An object is said to have non-trivial initialization if it is of a class or aggregate type and it</strong> or one of its members <strong>is initialized by a constructor other than a trivial default constructor.</strong> <em>[ Note:</em> initialization by a trivial copy/move constructor is non-trivial initialization. <em>¡ªend note ]</em> <strong>The lifetime of an object of type <code>T</code> begins when:</strong></p>
<ul>
<li><strong>storage with the proper alignment and size for type <code>T</code> is obtained, and</strong></li>
<li><strong>if the object has non-trivial initialization, its initialization is complete</strong>.</li>
</ul>
<p>The lifetime of an object of type <code>T</code> ends when:</p>
<ul>
<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>
<li>the storage which the object occupies is reused or released.</li>
</ul>
<p><code>[C++11: 3.8/3]:</code> <strong>The properties ascribed to objects throughout this International Standard apply for a given object only during its lifetime.</strong> <em>[..]</em></p>
<p><code>[C++11: 3.8/5]:</code> Before the lifetime of an object has started but after the storage which the object will occupy has been allocated <em>[..]</em> any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. <em>[..]</em> Such a pointer may be dereferenced but the resulting lvalue may only be used in limited ways, as described below. The program has undefined behavior if:</p>
<ul>
<li><em>[..]</em></li>
<li>the pointer is used to access a non-static data member or call a non-static member function of the object</li>
<li><em>[..]</em></li>
</ul>
</blockquote>
<p>What you are seeing is <em>chance success</em>: the false appearance that your program does not have a bug. It is caused by the fact that your computer does not execute C++ programs, but machine code, and sometimes during the translation from the C++ abstraction to machine code, the breaking of preconditions is lost.</p>
<p>More specifically, your computer doesn't care that your program is broken in this particular way, because it doesn't need to do anything that relies on your object existing. Those member functions do not touch any instance data so your computer never realises that the code is wrong.</p>
<p>That doesn't mean the code &quot;works&quot;.</p>
",0
29151643,29150981,3,"<p><sub>All quotes from the C++11 FD.</sub></p>

<p>Your code is almost fine. The problem is that your class has non-trivial initialization due to it having a user-provided and thus non-trivial default constructor - [basic.life]/1:</p>

<blockquote>
  <p>An object is said to have non-trivial initialization if it is of a
  class or aggregate type and <strong>it [..] is initialized by
  a constructor other than a trivial default constructor.</strong></p>
</blockquote>

<p>Thus the object isn't alive throughout the program, which is clarified right after the above quote:</p>

<blockquote>
  <p>The lifetime of an object of type <code>T</code> begins when:</p>
  
  <ul>
  <li>storage with the
  proper alignment and size for type T is obtained, and </li>
  <li><strong>if the object
  has non-trivial initialization, its initialization is complete.</strong></li>
  </ul>
</blockquote>

<p>... hence UB according to [basic.life]/5:</p>

<blockquote>
  <p>Before the lifetime of an object has started but after the storage
  which the object will occupy has been allocated [..] any pointer that
  refers to the storage location where the object will be or was located
  may be used but only in limited ways. [..] Otherwise, such a pointer
  refers to allocated storage (3.7.4.2), and using the pointer as if the
  pointer were of type <code>void*</code>, is well-defined. Such a pointer may be
  dereferenced but the resulting lvalue may only be used in limited
  ways, as described below. The program has undefined behavior if:</p>
  
  <ul>
  <li><strong>the pointer is used to access a non-static data member or call a
  non-static member function of the object, or</strong></li>
  </ul>
</blockquote>
",3
30188047,30188016,8,"<p>Because in integer maths <code>1 / 2 == 0</code> and <code>0 * 2 == 0</code>.</p>

<p>Try with <code>1.0</code> and <code>2.0</code> instead.</p>
",0
30188089,30188016,1,"<p>If you want to get right result you need to write:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
  double test = ((double)1 / 2) * 2;
  cout &lt;&lt; test &lt;&lt; endl;
  return 0;
}
</code></pre>
",2
30188117,30188016,2,"<p>In <code>(1 / 2)</code> both the 1 and 2 are integers which means that the result is also an integer. This means the expression returns <code>0</code>. <code>0 * 2</code> is <code>0</code>.</p>

<p>To get the result you want, try <code>(1.0 / 2.0)</code></p>
",1
30188139,30188016,0,"<p>You're using <code>int</code> instead of <code>double</code>.</p>

<p>Fixing...</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    double test = (1.0 / 2.0) * 2.0;
    cout &lt;&lt; test &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
28441316,28441020,1,"<p>I'm agree with Alexander completely: first, in your program it won't probably give you anything. Second, premature optimization is the root of all evil.</p>

<p>Still, if you're interested, in general passing a value by reference usually looks like this:</p>

<pre><code>void myFunction(const MyComplicatedClass&amp; argument) {...}
</code></pre>

<p>Here <code>argument</code> is passed as a reference to a constant object. This means that:</p>

<ol>
<li>Instead of passing a value to the function, we pass a reference, so our function, when it accesses <code>argument</code>, will, in essence, work with the same region of memory as the function, that called <code>myFunction</code>. BUT if it works  with the same region of memory, it can mess it up. So</li>
<li>We pass a reference to a <strong>constant object</strong>. It means, that the compiler will ensure, that we don't do anything, that can mess up the original object (which was passed to us as<code>argument</code>). It's not a 100% guarantee, we are talking about C++, it's relatively easy to shoot in the foot here, but the compiler will try his best :)</li>
</ol>

<p>But it's important to understand, that there is no point in using this approach everywhere. For instance, there is no point in passing <code>int</code> value as a const reference, since it is a primitive type already. You might even make things less efficient. Many classes are implemented in a way, that makes copying a very cheap operation. And, finally, compilers nowadays are very smart. They can optimize out many things that you didn't think of.</p>

<p>Still, I don't say that this is useless. As with every tool, you should understand, how it works and when to use it. It comes with experience and studying.</p>

<p>As for returning a reference, <strong>never return a reference to local variables</strong>. They get deleted the moment they go out of scope, and your program will crash when you'll try to access a reference to a deleted content. You can, however, return references (const references) to anything, that you're sure will live long enough. For instance, class fields.</p>
",2
28191227,28191101,1,"<p>Several possibilities come to mind.</p>

<ul>
<li>@abcthomas had the idea to use unsigned; since you are restricted to int, you may <em>abuse</em> int as unsigned. That will probably work, although it is UB according to the standard (cf. <a href=""https://stackoverflow.com/questions/3679047/integer-overflow-in-c-standards-and-compilers"">Integer overflow in C: standards and compilers</a>).</li>
<li>Use <em>two</em> ints. probably involves writing your own scanf and printf versions, but that shouldn't be too hard. Strictly spoken though, you still haven't expanded the range of an int.</li>
<li>[Use long long] <em>Not possible since you must use int.</em></li>
<li>You can always use some big number library. <em>Probably not allowed either.</em></li>
<li>Keep the numbers in strings and do arithmetic digit-wise on the strings. <em>Doesn't use int though.</em></li>
</ul>

<p>But you'll never ever be able to store something > MAX_INT in an int.</p>
",2
28191237,28191101,3,"<p>Any built-in type cannot be altered nor expanded in any sense. You have to switch to a different type.</p>

<p>The type <code>int</code> has the following <a href=""http://en.cppreference.com/w/c/language/arithmetic_types"" rel=""nofollow"">requirements</a>:</p>

<ul>
<li>represents at least the range -32767 to 32767 (16bit)</li>
<li>is at least as large as <code>short</code> (<code>sizeof(short) &lt;= sizeof(int)</code>)</li>
</ul>

<p>This means, that strictly speaking (although most platforms use at least 32bit for <code>int</code>), you can't safely store the value 50000 in an <code>int</code>.</p>

<p>If you need a guaranteed range, use <code>int16_t</code>, <code>int32_t</code> or <code>int64_t</code>. They are defined in the header <a href=""http://en.cppreference.com/w/cpp/types/integer"" rel=""nofollow""><code>&lt;cstdint&gt;</code></a>. There is no arbitrary precision integer type in the language or in the standard library.</p>

<p>If you only need to observe the range of valid integers, use the header <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits"" rel=""nofollow""><code>&lt;limits&gt;</code></a>:</p>

<pre><code>std::cout &lt;&lt; std::numeric_limits&lt;int&gt;::min() &lt;&lt; "" to "" &lt;&lt; std::numeric_limits&lt;int&gt;::max() &lt;&lt; ""\n"";
</code></pre>
",0
28191354,28191101,0,"<p>Try splitting up your value (that would fit inside a 64-bit int) into two 32-bit chunks of data, then use two 32-bit ints to store it. A while ago, I wrote some code that helped me split 16-bit values into 8-bit ones. If you alter this code a bit, then you can split your 64-bit values into two 32-bit values each.</p>

<pre><code>#define BYTE_T uint8_t
#define TWOBYTE_T uint16_t
#define LOWBYTE(x)          ((BYTE_T)x)
#define HIGHBYTE(x)         ((TWOBYTE_T)x &gt;&gt; 0x8)
#define BYTE_COMBINE(h, l)  (((BYTE_T)h &lt;&lt; 0x8) + (BYTE_T)l)
</code></pre>

<p>I don't know if this is helpful or not, since it doesn't actually answer your original question, but at least you could store your values this way even if your platform only supports 32-bit ints.</p>
",0
28191372,28191101,1,"<h2>No!</h2>

<hr>

<p>An int depends on the native machine word, which really means it depends on 3 things - the processor, the OS, and the compiler.</p>

<p>The only way you can ""increase"" an <code>int foo;</code> (not a <code>long foo;</code>, int is not a long) is:</p>

<ol>
<li><p>You are compiling with Turbo-C or a legacy 16-bit DOS compiler on a modern computer, likely because your university requires you to use that, because that's what your professor knows. Switch the compiler. If your professor insists you use it, switch the university.</p></li>
<li><p>You are compiling with a 32-bit compiler on a 64-bit OS. Switch the compiler.</p></li>
<li><p>You have 32-bit OS on a 64-bit computer. Reinstall a 64-bit OS.</p></li>
<li><p>You have 32-bit processor. Buy a new computer.</p></li>
<li><p>You have a 16-bit processor. Really, buy a new computer.</p></li>
</ol>
",2
28191536,28191101,1,"<p>You may try unsigned int. Its same as int but with positive range(if you really dont want to use long).</p>

<p>see <a href=""https://msdn.microsoft.com/en-us/library/s3f49ktz.aspx"" rel=""nofollow"">this</a> for the range of data types</p>

<p><strong>suggestion:</strong> 
You might aswell consider switching your compiler. From the range you've mentioned for int, it seems you are using a 16 bit compiler(probably turbo c). A 16-bit compiler would restrict unsigned int range to 0-65536(2^16) and signed int to ¨C32,768 to 32,767.</p>
",0
28192215,28191101,0,"<p>Here is an idea to actually <strong>store</strong> values larger than MAX_INT in an int. It is based on the condition that there is only a small, known number of possible values.</p>

<p>You could write a compression method which computes something akin to a 2-byte hash. The hashes would have to have a bijective (1:1) relation to the known set of possible values. That way you would actually <em>store</em> the value (in compressed form) in the int, and not in a string as before, and thus expand the range of possible values at the cost of not being able to represent <em>every</em> value within that range. </p>

<p>The hashing algorithm would depend on the set of possible values. As a simple example let's assume that the possible values are 2^0, 2^1, 2^2... 2^32767. The obvious hash algorithm is to store the exponent in the int. A stored value of 4 would represent the value 16, 5 would represent 32, 1000 would represent a number close to 10^301 etc. One can see that one can ""store"" extraordinarily large numbers in a 16 bit int ;-). Less regular sets would require more complicated algorithms, of course.</p>
",0
31237654,31237550,4,"<p>Calling a member function on a NULL pointer is cause for undefined behavior. </p>

<p>Your run time environment is dealing with the NULL pointer leniently. The call to <code>testA()</code> does not cause any problems since you are not accessing any member variables. The call to <code>testB()</code> crashes since you are trying to access a member variable when <code>this</code> is NULL.</p>

<p>Conceptually, a member function is mapped to a function that has the form:</p>

<pre><code>mangled_testA(Test* this){ ... }
</code></pre>

<p>If you call such a function on a NULL pointer, the function gets called with the value of <code>this</code> set to NULL. If you don't access any member variables, you don't notice the error. If you access any member variables, you notice the error right away.</p>

<p><strong>P.S.</strong> this behavior is not guaranteed by the language. This is what happens often.</p>
",3
31237747,31237550,0,"<p>I have tried this code and ran it in ideone <a href=""http://ideone.com/6nV7HM"" rel=""nofollow noreferrer"">link to code</a>.
The issue is with the setting of <code>test =NULL</code> as the Object pointer is set to null.It means that the object is assigned a NULL value and will generally m_value will contain garbage.Depending on the compiler you are using, it will generate error(run time error as it is dynamic allocation). <a href=""https://stackoverflow.com/questions/3030829/c-is-it-possible-to-set-an-object-to-null"">reference1</a><a href=""https://stackoverflow.com/questions/6663230/whats-the-alternative-of-set-object-null-in-c-like-c-sharp"">reference2</a></p>

<p>Just remove the null and assign value to m_value your code will run fine.It is done so as to avoid memory leaks.</p>
",0
28201538,28201491,2,"<p><code>Vertex*</code> is pointer-to-Vertex, so <code>Vertex**</code> is pointer-to-pointer-to-Vertex -- one more level of indirection.</p>

<p>For example:</p>

<pre><code>int i = 0;
int * iPtr = &amp;i;        // iPtr -&gt; i
int ** iPtrPtr = &amp;iPtr; // iPtrPtr -&gt; iPtr -&gt; i
</code></pre>
",0
28461786,28461548,0,"<p>Your conditions are wrong (all three of them), you should compare value pointed by <code>counter</code> (pretty bad name btw) to max and min:</p>

<pre><code>for (int *counter = pRnd + 1; counter &lt; (pRnd + ArraySize); counter++) {

    if (*counter&gt; *pMax )
        pMax = counter;

    if (*counter &lt; *pMin )
        pMin = counter;
 }
</code></pre>

<p>You can still have int <code>counter = pRnd</code> but you will do one additional comparison that is not necessary, as <code>pMax</code> and <code>pMin</code> already point to the first element.</p>
",2
28461822,28461548,0,"<p>The logic used to track the max and min values is not right. </p>

<pre><code>    if (*counter&gt; *(counter + 1))
</code></pre>

<p>doesn't tell you whether <code>*counter</code> is greater than the previous max value. Same problem with the line</p>

<pre><code>    if (*counter&lt; *(counter + 1))
</code></pre>

<p>It doesn't tell you whether <code>*counter</code> is less than the previous min value.</p>

<p>Assuming <code>pMaxElementValue</code> and <code>pMinElementValue</code> are values, not pointers, the core logic can be simplified to:</p>

<pre><code>pMaxElementValue = *pRnd;
pMinElementValue = *pRnd;

for (int *counter = pRnd; counter &lt; (pRnd + ArraySize); counter++)
{
   if (*counter&gt; pMaxElementValue )
      pMaxElementValue = *counter;

   if (*counter &lt; pMinElementValue)
      pMinElementValue = *counter;
}
</code></pre>

<p>If you want to use pointers for the elements containing max and min, you need to use:</p>

<pre><code>pMax = pRnd;
pMin = pRnd;

for (int *counter = pRnd; counter &lt; (pRnd + ArraySize); counter++)
{
   if (*counter&gt; *pMax )
      pMax = counter;

   if (*counter &lt; *pMin)
      pMin = counter;
}
</code></pre>
",0
31254003,31253782,0,"<p>One way you could do this is to have <code>""Name: ""</code> as a string and add <code>message</code> to it and then use the <code>c_str()</code> method of the combined string.</p>

<pre><code>LogMessage((string(""Name: "") + message).c_str(), __FILE__, __LINE__);
</code></pre>
",1
31254105,31253782,1,"<p><strong>Basically, no.</strong></p>

<p>The macro is the traditional workaround, so I'm not sure why you're trying to dump it!</p>
",2
31254393,31253782,2,"<p>Yes, you can. Here is an example</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;Windows.h&gt;

void LogMessage(const std::basic_ostream&lt;char&gt;&amp; ss, const char* const file, int line)
{
    std::stringstream ss1;
    ss1 &lt;&lt; file &lt;&lt; ""("" &lt;&lt; line &lt;&lt; ""): "" &lt;&lt; static_cast&lt;const std::stringstream&amp;&gt;(ss).str();
    OutputDebugStringA(ss1.str().c_str());
}

int main()
{
    LogMessage(std::stringstream() &lt;&lt; ""Hello,"" &lt;&lt; "" World! "" &lt;&lt; 5, __FILE__, __LINE__);
    return 0;
}
</code></pre>

<p>Alternatively, to save some typing in each logging line:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;Windows.h&gt;

class Logger
{
    std::stringstream _ss;
    std::string _file;
    int _line;
public:
    Logger(const char* const file, int line)
    {
        _file = file;
        _line = line;
    }
    ~Logger()
    {
        std::stringstream ss1;
        ss1 &lt;&lt; _file &lt;&lt; ""("" &lt;&lt; _line &lt;&lt; ""): "" &lt;&lt; _ss.str();
        OutputDebugStringA(ss1.str().c_str());
    }
    template&lt;typename T&gt;
    Logger&amp; operator&lt;&lt;(const T&amp; value)
    {
        _ss &lt;&lt; value;
        return *this;
    }
};

#define LOG Logger(__FILE__, __LINE__)

int main()
{
    // approach 1: with a macro, saving from typing of __FILE__ and __LINE__ each time
    LOG &lt;&lt; ""Hello,"" &lt;&lt; "" World! "" &lt;&lt; 6;
    // approach 2: without a macro, but with typing of __FILE__ and __LINE__ each time
    Logger(__FILE__, __LINE__) &lt;&lt; ""Hello,"" &lt;&lt; "" World! "" &lt;&lt; 7;
    return 0;
}
</code></pre>
",3
29464431,29464343,2,"<p>Instead of</p>

<pre><code>cin &gt;&gt; example;
</code></pre>

<p>use</p>

<pre><code>std::getline(std::cin, example);
</code></pre>

<p><code>cin &gt;&gt; example;</code> will stop reading when it finds a white space. <code>std::getline</code> will cotinue reading until a specified delimiter (<code>'\n'</code> by default) is found.</p>

<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow"">More on <code>std::getline</code></a>.</p>
",0
29164200,29164069,6,"<p>You do this when you need to return a reference to yourself. You typically see it in operator overloading, so that the result can return itself:</p>

<pre><code>Foo &amp;operator=(const Foo &amp;rhs)
{
  // Whatever...
  return *this;
}
</code></pre>

<p>By doing this it allow you to easily chain calls:</p>

<pre><code>a=b=c;
</code></pre>

<p>Whereas if returned a pointer it would look messy.</p>

<p>It's also commonly used in fluid api design so that you can combine calls. Using your example you could write:</p>

<pre><code>Sales_Data x,y,z;

x.combine(y).combine(z);
</code></pre>

<p>However, if does loose a bit of its elegance when you've got a pointer lurking around:</p>

<pre><code>  Sales_Data *x=LoadSalesData();
  Sales_Data y,z;

  x-&gt;combine(y).combine(z);
</code></pre>
",0
29164098,29164069,3,"<p>You use <code>*this</code> to return a reference to current object.</p>

<p>This is usually useful to allow method chaining:</p>

<pre><code>rhs1.combine(rhs2).combine(rhs3);
</code></pre>

<p>A well known example of this is the <code>operator&lt;&lt;</code> of streams, that returns a reference to the stream object to make concatenation of outputs possible.</p>

<pre><code>std::cout &lt;&lt; ""first"" &lt;&lt; ""second"";
</code></pre>
",2
29164119,29164069,7,"<p>Doing so you can run multiple combines in one statement:</p>

<pre><code>Sales_Data d1, d2, d3;
d1.combine(d2).combine(d3);
</code></pre>
",0
33579697,33578959,0,"<p><a href=""http://www.cplusplus.com/reference/string/string/c_str/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/c_str/</a></p>

<p>Create your desired string using c++ string and then call the method .c_str() (see the above link)</p>

<p>For a given c++ string, it'll return you a NULL terminated c-string version of the c++ string that you can pass to your function that expects a c-string. </p>
",0
33580813,33578959,1,"<p>The references you gave in your question are actually not appending or concatenating in <code>const char *</code> they used <a href=""http://www.cplusplus.com/doc/tutorial/preprocessor/"" rel=""nofollow"">Preprocessor Directives</a></p>

<p>This is the easy and proper way to achieve the same thing</p>

<pre><code>string pass;
cout &lt;&lt; ""Please enter password for user: Mickey"" &lt;&lt; endl;
getline(cin, pass);
string connectionString(""host=cs-linux dbname=gbianchet user=mickey password="" + pass);
const char *connectInfo = connectionString.c_str();
</code></pre>

<p>include string class header in your source code as <code>#include &lt;string&gt;</code>
<strong>string</strong> class is in <code>std</code> namespace</p>
",0
33513871,33513601,0,"<p>First of all...</p>

<pre><code>int* const&amp;
</code></pre>

<p>Is the same as...</p>

<pre><code>int *const&amp;
</code></pre>

<p><strong>Edit</strong>: Originally, I wrongly stated it was equivalent to <code>const int*&amp;</code>. Sorry, that was my fault.</p>

<p>And, references to pointers are more ""cumbersome"" than pointer themselves (at least IMHO), don't you think so? There's a reason pointers and references shall never be mixed (unless it's a consecuence of template instantiation, of course)...</p>

<pre><code>int const&amp;*
</code></pre>

<p>This is impossible, invalid, and last but no least, insane. Although there's no practical way for references to be implemented other than by pointers, they are <em>not</em> objects, in the sense that they (themselves) don't have a <code>sizeof</code> that does not equals that of their referenced type, and the fact that they don't have address at all, at least as far as the Sacred Writings of N4296 are concerned.</p>

<p>But... pointers <em>are</em> objects! The expression <code>&amp;a</code> returns a rvalue (that is basically an object without an address) of type <code>int*</code>. Now, the statement <code>return &amp;a;</code> will take that value and wrap it up in a reference, because...</p>

<ul>
<li>That's what the function return type expects.</li>
<li>The lifetime of an rvalue of type <code>T</code> can be extended by means of it being holded in a reference of type <code>const T&amp;</code>. However, you can't use this to return references to temporary rvalues.</li>
</ul>

<p>Now, because all this stuff implies that you're returning a reference to a temporary rvalue in an unallowed way, you where tempted and falled into Undefined Behaviour.</p>

<p>The solution? Simply don't use references to pointers at all in the first place...</p>

<pre><code>int const *getContent() { return a; }
</code></pre>

<p>Or, if you prefer it, use references, but not pointers...</p>

<pre><code>int const &amp;getContent() { return *a; }
</code></pre>

<p>Now, to the questions!</p>

<ul>
<li>*Does the compiler implicitly instantiate a local temporary object of type 'int * const' from '&amp;a' before returning its reference?*: Yes and no. It does instantiate such a temporary as explained above (but usually optimized away), but it's type is <code>int*</code>, not <code>int *const</code>, although the latter gets implicitly casted into the former.</li>
<li><em>As I do know that A.a really exists, then can I just ignore this warning? Will there be any undesirable side-effects of using this code?</em>: That depends on whether you would ignore a divide-by-zero warning.</li>
<li><em>What is the proper way of handling this situation? Do I need to work with the member variable 'int *a' instead. This would be cumbersome.</em>: You may either use ""cumbersome"" pointers or ""beatiful"" references, see above.</li>
</ul>

<p>I hope this has led some light on you!</p>
",7
33513721,33513601,7,"<ol>
<li>Yes.</li>
<li>You cannot ignore this warning. <code>A.a</code> exists, but that's not the issue. What you are returning is not a pointer to <code>int</code>, but a reference to a pointer to <code>int</code>, i.e. it is a double indirection. To be specific, a temporary <code>int*</code> was created inside <code>getContent</code> that pointed to <code>A.a</code>. A reference to that temporary was returned, and then the temporary was destroyed. Using the result of <code>getContent</code> will be undefined behavior.</li>
<li>The idiomatic way to handle this situation would typically be to store the member you are passing a const reference to. In other words, have a member <code>int* a</code>, and then simply return <code>a</code> in your function. Returning a const reference is a common way to expose the fully functionality of a data member without allowing the user of the class to mutate it, messing up your class' invariants.</li>
</ol>
",0
33513724,33513601,0,"<p>This is incorrect:</p>

<pre><code>T const&amp; getContent() = 0;
</code></pre>

<p>You can do:</p>

<pre><code>T const getContent() = 0;
int* const getContent() { return &amp;a; }
</code></pre>
",0
28445407,28445360,0,"<p>try this</p>

<pre><code>int main()
{
int height =10;

for (int i = 0 ; i &lt;= height; i++) {
    for (int s = 0; s &lt; i; s++) {
        cout &lt;&lt; ""*"";
    }
    cout &lt;&lt; endl;
}
}
</code></pre>
",1
28445422,28445360,2,"<p>You're outputting a newline after every <em>single</em> character. You only want to do that in the outer loop, after each <em>line</em> of characters.</p>

<p>In addition, using a fixed value for the width will result in a square rather than a triangle. You should therefore base your inner loop on <code>i</code> rather than <code>height</code>:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main (void) {
    int height = 7;
    for (int i = 1 ; i &lt;= height; i++) {
        for (int s = 0; s &lt; i; s++)
            cout &lt;&lt; ""*"";
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>The output of that is the very triangular:</p>

<pre><code>*
**
***
****
*****
******
*******
</code></pre>

<hr>

<p>Of course, that will <em>work</em> but it's hardly embracing the essence of the C++ language.</p>

<p>What you <em>really</em> have there is C code but using C++ output methods, something that will get you quickly labeled as a C+ programmer :-)</p>

<p>Although I wouldn't hand this in as a beginner assignment, it will at least force you to think about using the added facilities of the C++ language going forward:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main (void) {
    int height = 7;
    string s(height, '*');
    for (int i = 1 ; i &lt;= height; i++)
        cout &lt;&lt; s.substr(0,i) &lt;&lt; '\n';
    return 0;
}
</code></pre>

<p>That thinking will convince you at some point to discard character arrays for strings (or arrays in general for vectors, or many other similar decisions), something that will make your programming <em>much</em> faster and safer in future.</p>
",0
28313596,28313516,0,"<p>I can't figure out what's causing the segmentation fault but there is a bug in your code. You are not resetting the value of <code>track</code> after the calls to <code>std::swap</code>. I suggest the following changes to the function.</p>

<pre><code>void Word::arrangeWords(char **&amp;words, int*&amp; pages, int size)
{
   for (int i=0;i&lt;size;i++)
   {
      int track = i;
      char lowest[30]; // If you know the size of the array to be 30,
                       // just create an array. Why use new char[30]?
      strcpy(lowest, words[i]);;
      for(int j=i+1;j&lt;size;j++)
      {
         int compResult=strcmp(lowest, words[j]);
         if (compResult&gt;0)
         {
            strcpy(lowest, words[j]);
            track=j;
         }
      }
      if ( track &gt; i )
      {
         std::swap(words[track],words[i]);
         std::swap(pages[track],pages[i]);
      }
   }
}
</code></pre>
",2
34212489,34212272,0,"<p><s>You can replace the first <code>get</code> with <code>peek</code>:</p>

<pre><code>while (cin.peek() != '\n' &amp;&amp; cin.get() != '.')
</code></pre>

<p><code>std::basic_istream::peek</code> keeps the character in the buffer, so <code>std::basic_istream::get</code> reads the same, but compares it to other.</s></p>

<p>- wrong. That would keep <code>\n</code> in the buffer, but <code>.</code> not.</p>

<p><strong>Right:</strong> Use a <code>char</code> variable into which you extract only once and compare it twice:</p>

<pre><code>char c;

while (cin.get(c) &amp;&amp; c != '\n' &amp;&amp; c != '.')
    ...
</code></pre>
",2
34212857,34212272,0,"<p>Doing a get removes the character from the input stream, so the first two characters are removed in the while loop condition before you've even entered the loop. <code>cin &gt;&gt; a;</code> reads in the next word (space separated) and puts it into a. It does <strong>not</strong> read character by character. This puts ""o."" into a, as 'f'and 'o' have been removed from the input stream. You then read the newline in the condition check and you exit out of the loop. </p>

<p>Instead, you should call <code>cin.get()</code> once and store the return value as an int ready for using it ie.</p>

<pre><code>int ch = cin.get();
while(ch!='\n' &amp;&amp; ch != '.') {
    // Do something with ch

    //get the next character ready for the next iteration
    ch = cin.get();
}
</code></pre>

<p>I should also mention that a only has enough space for one character. You should make a bigger, doing something like <code>char a[200];</code> which creates space for 200 characters.  You should also check you don't try to access anything past <code>a[199]</code>.</p>
",0
34212860,34212272,1,"<p>You shouldn't include both <code>""stdio.h""</code> (or better <code>&lt;cstdio&gt;</code>) and <code>&lt;iostream&gt;</code>. The former lets you use C standard IO functions, while the latter is the standard for C++. Pick one, for example as in your code you are actually using some <code>&lt;iostrem&gt;</code> facilities, include that.</p>

<p>The problem you are facing basically requieres 3 steps:</p>

<ul>
<li>read standard input untill a <code>'.'</code> or a <code>'\n'</code> is entered.</li>
<li>store each character except <code>'.'</code> or <code>'\n'</code>.</li>
<li>send the character read to standard output in reverse order.</li>
</ul>

<p>I think that second point is the key point. Where do you store the character you read? In your code you seem to use c-style null terminated char arrays, but you are not allocating the necessary memory for doing that.</p>

<p>Then, when you use cin.get() you are actually removing a character from to input stream and you do that 2 times before reading a.</p>

<p>I also don't think that using recursion for the last step is a good idea. Maybe it's mandatory in your assigned task, but use of recursion like this (and the tipical factorial example) better stay in books. If you want to use a stack to accomplish the task, it's better to do so explicitly, like here:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stack&gt;

int main() {
    char c;
    std::stack&lt;char&gt; sc;

    while ( std::cin.get(c) &amp;&amp; c!='\n' &amp;&amp; c!='.' ) 
        sc.push(c);
    std::cout &lt;&lt; std::endl;
    while ( !sc.empty() )  {
        std::cout &lt;&lt; sc.top();
        sc.pop();
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>A more ""natural"" way of doing this task is to store the chars in a std::string and show them in reverse order:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt; 

int main()
{
    std::string a;      
    char c;        

    while ( std::cin.get(c)  &amp;&amp;  c != '.'  &amp;&amp;  c != '\n' )
        a += c;      

    std::cout &lt;&lt; std::endl;
    // you can print what you read with:        std::cout &lt;&lt; a;

    for ( std::string::reverse_iterator rit = a.rbegin(); rit != a.rend(); ++rit )
        std::cout &lt;&lt; *rit;

    std::cout &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>If you want to use an array of char to store the input, you have to preallocate enough memory for your needs.</p>

<pre><code>#include &lt;iostream&gt;

#define MAX_CHARS 128       

int main()
{
    char a[MAX_CHARS + 1];      // enough to store 128 char and the '\0'
    char c;        
    int counter = 0;            // better knowing how many char you read

    for ( counter = 0; counter &lt; MAX_CHARS
            &amp;&amp; std::cin.get(c) &amp;&amp; c!='.' &amp;&amp; c!='\n'; counter++ )
        a[counter] = c;

    a[counter] = '\0';          

    std::cout &lt;&lt; std::endl;
    // you can print what you have read with:        std::cout &lt;&lt; a;

    while( counter &gt; 0 ) {
        --counter;
        std::cout &lt;&lt; a[counter];            
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>If you are reading input from terminal you have to enter a whole line followed by newline in any case, because you are reading a buffered input. If you need unbuffered input and to stop reading characters right when a <code>.</code> or <code>enter</code> is pressed then there isn't a standard C++ solution, it depends on your environment. For sake of semplicity you can use the c-style (and deprecated) getch():</p>

<pre><code>#include &lt;cstdio&gt;
#include ""conio.h""

#define MAX_CHARS 128       

int main()
{
    char a[MAX_CHARS + 1];      // enough to store 128 char and the '\0'
    char c;        
    int counter = 0;            // better know how many char you read

    while ( counter &lt; MAX_CHARS &amp;&amp; (c=getch())
            &amp;&amp; c!='.' &amp;&amp; c!='\n' &amp;&amp; c!='\r' ) {
        putchar(c);            
        a[counter] = c;
        counter++
    }
    a[counter] = '\0';          

    printf(""\n"");
    // you can print what you read with:        printf(""%s\n"",a);

    while( counter &gt; 0 ) {
        --counter;
        putchar(a[counter]);            
    }
    printf(""\n"");
    return 0;
}
</code></pre>
",0
28512238,28512193,1,"<p>This may not fix any of your problems, but...</p>

<p>The logic in these lines is wrong.</p>

<pre><code>       istringstream iss(line);
        for(int i = 0; i &lt;= line.length(); i++){
            iss &gt;&gt; word;
</code></pre>

<p>Let's say your line is</p>

<pre><code>This is a test.
</code></pre>

<p>For this line, <code>line.length()</code> is 15 but there aren't 15 words. What you need is </p>

<pre><code>        istringstream iss(line);
        while ( iss &gt;&gt; word ) {
</code></pre>
",0
28512210,28512198,2,"<p>You are calculating the output before you read the user input. Instead of:</p>

<pre><code>total = (((hours * 60) * 60) + (min * 60) + sec);

cout &lt;&lt; ""Please Enter hours, minutes, and seconds"" &lt;&lt; endl;
cin &gt;&gt; hours &gt;&gt; min &gt;&gt; sec;
</code></pre>

<p>use</p>

<pre><code>cout &lt;&lt; ""Please Enter hours, minutes, and seconds"" &lt;&lt; endl;
cin &gt;&gt; hours &gt;&gt; min &gt;&gt; sec;
total = (((hours * 60) * 60) + (min * 60) + sec);
</code></pre>
",1
28511160,28511048,1,"<p>The isupper/islower functions take in a single character. You should be able to loop through the characters in your string and check the case like so:</p>

<pre><code>for (int i = 0; i &lt; word.length(); i++) {
    if (isupper(word[i])) cout &lt;&lt; word[i] &lt;&lt; "" is an uppercase letter!"" &lt;&lt; endl;
    else if (islower(word[i])) cout &lt;&lt; word[i] &lt;&lt; "" is a lowercase letter!"" &lt;&lt; endl;
    else cout &lt;&lt; word[i] &lt;&lt; "" is not a letter!"" &lt;&lt; endl;
}
</code></pre>

<p>Of course, you would replace the cout statements with whatever you want to do in each of those cases.</p>
",0
28205175,28205155,4,"<p>It is not correct because <code>words</code> is not itself dynamically allocated like the pointers it contains.</p>

<p><code>words</code> is on stack, <code>words[i]</code> is on heap. As a general principle you need a <code>delete[]</code> for each <code>new[]</code>. You have 4 <code>new</code> and you need 4 <code>delete</code>.</p>

<pre><code>char *words[4] // on stack, doesn't need deallocation
char **words = new char*[4]; // on heap, would need deallocation too
</code></pre>
",0
28205190,28205155,7,"<p>Only <code>delete</code> what you <code>new</code>. You didn't <code>new words</code>, so don't delete it. Presumably this code is inside a function, in which case <code>words</code> has <em>automatic storage duration</em> and will be destroyed automatically when it goes out of scope.</p>

<p>Moreover, don't <code>new</code> anything you don't have to, to save yourself the hassle of deleting it correctly (which can be surprisingly difficult). Use <code>std::vector</code> when you want a dynamic array, and <code>std::string</code> when you want a dynamic string.</p>
",0
28520337,28520280,0,"<p>A constructor will always call the parent constructor. If you do not specify one, it will call the default constructor (no parameters).</p>

<p>The issue here is that your <code>Square</code> constructor cannot call the <code>Rectangle</code> default constructor because there is none, and you do not explicitly call the existing constructor.</p>

<p>Implement your <code>Square</code> constructor so it explicitly calls the <code>Rectangle</code> constructor, v.g.</p>

<pre><code>Square::Square(double x, double y, double length) : Rectangle(x, y, length, length) {  }
</code></pre>
",0
28520426,28520280,0,"<p>You are missing the definition of the default constructor for the Rectangle.</p>

<p>in Rectangle.h you have said there will be a defined constructor for Rectangle(); - > known by code as Rectangle(void);</p>

<p>This appears to just be a simple oversight, just remove the default constructor from the Rectangle.h.</p>
",0
32985131,32985036,1,"<p>Your default constructor constructs a stack with maximum size 3. You then try to put 6 elements in it:</p>

<pre><code>Element300 temp; // MAX_STACK == 3

while(!old.isEmpty()){  // But old has 6 elements
    temp = old.pop300();
    tempStack.push300(temp);
}
</code></pre>

<p>Also, your copy constructor empties the object been copied from. Those are very confusing ""copy"" semantics.</p>

<p>You should simply copy the data of one stack to the other, without popping or pushing. This could be trivially done if you use <code>std::vector&lt;Element300&gt;</code> for storage instead of your own dynamically allocated array. In this case, the default copy constructor would do the job.</p>
",0
32433726,32433437,-3,"<p>A <em>fun2(){z=n</em>k; return this-1;}</p>

<p>'this' is a self-referential pointer. You cannot subtract 1 from this.
It will then point to a memory location which is one before 'this' pointer</p>
",2
32433979,32433437,3,"<p>Like any pointer, subtracting 1 from <code>this</code> assumes <code>*this</code> is an element of an array, gives the address of the preceding object in the array.   There is an implicit assumption in <code>A::fun2()</code> that <code>*this</code> is an element of an array, and that there is at least one preceding element in that array.</p>

<p>So, in your sample code, <code>a[1].fun2()</code> returns the the address of <code>a[0]</code>.   i.e.  <code>&amp;a[0]</code>.</p>

<p><code>a[0].fun2()</code> would return a (pointer) value equal to <code>&amp;a[-1]</code>.  Notionally, that is a pointer to a non-existent object.  Computing <code>this-1</code> in <code>A::fun2()</code> would give undefined behaviour just as much as computing <code>a-1</code> would in <code>main()</code>.     One common (but not guaranteed) practical symptom of such undefined behaviour would be a program crashing when later dereferencing the pointer.</p>
",5
33586038,33586005,1,"<p>All you need to do is make your simulated <code>stack</code> of type <code>int</code> instead of <code>char</code> (and other related changes).</p>
",1
33586057,33586005,1,"<p>Your stack is type char which is normally restricted to -128 to 127. Try unsigned char which will probably be 0 to 255. If you need larger values on your stack then you will be to make it an array of ints or something bigger.</p>
",0
33586073,33586005,2,"<p><code>operand</code> is of type <code>int</code> while <code>push</code> expects a <code>char</code>.</p>

<p>Because on most machines <code>sizeof(int) &gt; sizeof(char)</code>, the value of <code>operand</code> might get truncated if it is attempted to be stored in a smaller data type like <code>char</code>.</p>

<p>For example, let's assume <code>sizeof(int) == 4</code> and <a href=""https://stackoverflow.com/questions/2215445/are-there-machines-where-sizeofchar-1""><code>sizeof(char) == 1</code></a> and a byte is eight bits. Now, if only the 8<sup>th</sup> bit (starting from 0) is set, a <code>char</code> won't be capable of holding that information and the value <code>0x100</code> is truncated to <code>0x00</code>.</p>

<p>In order to solve this, either make the stack deal with <code>int</code>s or define <code>operand</code> as a <code>char</code>.</p>
",2
31128859,31123959,0,"<p>I did include the file in the solution. and I did used std::string it doesn't serve the purpose.
AnsiString has been declared in header file RpcASync.h as : </p>

<p>typedef struct tagRPC_EE_INFO_PARAM
{ 
    union
        {<br>
        LPSTR AnsiString;
        } u;
}</p>

<p>In CPP file I have included RpcASync.h header file and tried to access AnsiString as a parameter in function as follows  </p>

<p>bool FindRunningProcess(AnsiString process) 
{       </p>

<pre><code> AnsiString compare;
     if (pe32.szExeFile == process) {
            procRunning = true;
        } else {
            // loop through all running processes looking for process
            while (Process32Next(hProcessSnap, &amp;pe32)) { 
                // Set to an AnsiString instead of Char[] to make compare                  easier
                compare = pe32.szExeFile;
                if (compare == process) {
                    // if found process is running, set to true and break from loop
                    procRunning = true;
                    break;
</code></pre>

<hr>

<p>}</p>

<p>but when I compile it throws an error - 
 IntelliSense: identifier ""AnsiString"" is undefined.</p>

<p>Note : pe32.szExeFile is of WCHAR , So I am using process as AnsiString</p>
",0
28498702,28498625,3,"<p>That error means that your version of MSVC++ does not implement non-static data member initialization. You need to initialize it in constructor of <code>Window_mgr</code>.</p>

<p>Since it does not support list initialization in initialization list (uff) either, you need to initialize it in the constructor body:</p>

<pre><code>Window_mgr::Window_mgr()
{
    screens = { Screen(24, 80, ' ') };
}
</code></pre>
",4
28498720,28498625,1,"<p>As the error message says, your compiler doesn't support that style of initialisation, even though it's perfectly cromulent C++11. If you can't update the compiler, then you'll have to populate it the old-fashioned way in the constructor(s)</p>

<pre><code>Window_mgr() /* can't list-initialise it here either */ {
    screens.emplace_back(24, 80, ' ');  // if emplace_back is supported
    screens.push_back(Screen(24, 80, ' ')); // otherwise
}
</code></pre>
",1
28498774,28498625,0,"<pre><code>std::vector&lt;Screen&gt; screens{ Screen(24, 80, ' ') };
</code></pre>

<p>This is C++11 style initialization. And surely, using C++11 this code compiles without a hitch.</p>
",0
28461162,28460217,-1,"<p>I don't understand why you are creating a array of 1 character from dynamic memory.  You should use a <code>char</code> variable:  </p>

<pre><code>void string_push(ifstream&amp; file,  
                 string    text,
                 int       time,
                 int       tm)
{
    char b = '\0';
    while (b  != '\n')
    {
        file.read(&amp;b,1);
        cout &lt;&lt; b;
        Sleep(tm);
    }
    Sleep(time);
}
</code></pre>

<p>By using a temporary <code>char</code> variable, you eliminate memory fragmentation and the problems or memory management (allocation and deallocation).  Also, it eliminates the need to a call to the memory manager, thus making your program more efficient (the process can probably fit a character in a register and not use memory).  </p>
",5
28436459,28301846,2,"<p>The problem occurs when all occurences of WUB are erased: if there is no WUB left in the string, find will return the magic value string::npos, which is usually a very large number and accessing this index will likely lead to an out of bounds exception.</p>

<p><a href=""http://www.cplusplus.com/reference/string/string/find/"" rel=""nofollow"">See the documentation</a>:</p>

<blockquote>
  <p>The position of the first character of the first match. If no matches
  were found, the function returns string::npos.</p>
</blockquote>

<p>Here is a <a href=""http://ideone.com/QZYWkB"" rel=""nofollow"">working example in Ide-One</a>, without the new line below it will throw:</p>

<pre><code>terminate called after throwing an instance of 'std::out_of_range'
  what():  basic_string::erase: __pos (which is 4294967295) &gt; this-&gt;size() (which is 25)
</code></pre>

<p>Adding a check if the string contains the search string fixes the problem:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string x = ""WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB"";
    string s;
    for(int i=0; i&lt;x.size(); i++)
    {
        if (x.find(""WUB"") != string::npos) // &lt;=== this is new
            s = x.erase(x.find(""WUB""),3);
    }
    cout&lt;&lt;s;
    return 0;
}
</code></pre>

<p>PS: I don't think the question deserved 10 downvotes.</p>
",0
31147221,31138688,1,"<p>That code was never really supposed to work (what does it mean to write an input stream to an output stream?!) but used to work ""by accident"" because streams in C++03 had an implicit conversion to <code>void*</code> which could be used to test the stream's status, and so you could print the value of the <code>void*</code>.</p>

<p>In C++11 the conversion has been replaced with an explicit conversion to bool, so the modern equivalent of that code (which is much clearer what it does) is:</p>

<pre><code>cout &lt;&lt; ""(infile) = "" &lt;&lt; (bool)infile &lt;&lt; endl;
</code></pre>

<p>or:</p>

<pre><code>cout &lt;&lt; ""(infile) = "" &lt;&lt; static_cast&lt;bool&gt;(infile) &lt;&lt; endl;
</code></pre>
",0
31147023,31138688,0,"<p>I think you are right and this must be a version issue since my book is so old and I am typing in exactly what it says and it isn't working.  I guess I should learn from a more updated book.</p>
",0
27676682,27676580,1,"<p>Although <a href=""http://www.cplusplus.com/reference/cstdlib/strtof/"" rel=""nofollow"">the reference page</a> describes the parameter <code>pendptr</code> as a reference to a <code>char*</code> object this might be misundestood. In C we have only pointers and the second parameter of <code>strtof</code> is a pointer to a pointer to char.</p>

<p>You can utilize this parameter to get the point in the input char array that could not be used to convert the char array to the output float. If the pointer points to a '\0' than the array has been converted entirely. If it points to something different you can start error handling or further processing of the char array.</p>

<p>You should never cast any pointer when you are not sure what it means. Cast tells the compiler that the programmer knows it better. Depending on the meaning of your <code>EquationPiece</code> it might be useful to pass the endPtr:</p>

<pre><code>ret.push_back(EquationPiece(strtof(&amp;Source[mark], pEnd));
</code></pre>
",1
28522589,28522366,5,"<p>Let's get rid of the templates. Minimized repro:</p>

<pre><code>#include &lt;iostream&gt;

enum bar : unsigned long long { baz = 11400714819323198485ULL };

void foo(int v) { std::cout &lt;&lt; ""int ""&lt;&lt; v; }
void foo(unsigned v) { std::cout &lt;&lt; ""uint "" &lt;&lt; v; }
void foo(unsigned long long v) { std::cout &lt;&lt; ""ull "" &lt;&lt; v; }

int main() { foo(baz); }
</code></pre>

<p>This prints <code>uint 2135587861</code>.</p>

<p>Meanwhile,</p>

<pre><code>#include &lt;iostream&gt;

enum bar : unsigned long long { baz = 11400714819323198485ULL };

void foo(unsigned long long v) { std::cout &lt;&lt; ""ull "" &lt;&lt; v; }

int main() { foo(baz); }
</code></pre>

<p>prints <code>ull 11400714819323198485</code>. So the value is preserved, and the conversion can be done. This looks like a bug in VC++'s overload resolution. This also reproduces in VS2015 CTP5. </p>

<p><strong>Edit</strong>: reported as <a href=""https://connect.microsoft.com/VisualStudio/feedback/details/1131433"" rel=""nofollow"">https://connect.microsoft.com/VisualStudio/feedback/details/1131433</a></p>

<p>The shortest workaround appears to be using <code>foo(+baz)</code>; the unary <code>+</code> forces an integral promotion before overload resolution is performed.</p>
",2
31844289,31844262,4,"<p>I think you want <a href=""http://www.boost.org/doc/libs/1_58_0/libs/serialization/doc/strong_typedef.html"" rel=""nofollow""><code>BOOST_STRONG_TYPEDEF</code></a>. You can't inherit from <code>int</code>, as <code>int</code> is not a class type, but you could do:</p>

<pre><code>BOOST_STRONG_TYPEDEF(int64_t, Time64Base);

struct Time64 : Time64Base {
    std::string Parse() { ... }
};
</code></pre>
",0
31844427,31844262,1,"<p>Here is how to do it without boost:</p>

<p>You need to make your structure implicitly convertable to the underlying type, like CoffeeandCode said.  That is a big part of what <a href=""http://www.boost.org/doc/libs/1_37_0/boost/strong_typedef.hpp"" rel=""nofollow"">BOOST_STRONG_TYPEDEF</a> does.</p>

<pre><code>struct Time64 {
    int64_t Milliseconds;

    operator int64_t &amp;() { return Milliseconds; }
};

int main(){
    Time64 x;

    x.Milliseconds = 0;
    x++;

    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>

<p>This can often be a dangerous approach.  If something is implicitly convertible to an integer, it can often be mistakenly used as a pointer, or it can be unclear what it will do when passed to printf() or cout.</p>
",0
34241077,34241040,1,"<pre><code>// this does not change again, it compares it against true, return value is unused
again == true;
</code></pre>

<p>is not an assignment, this is:</p>

<pre><code>again = true;
</code></pre>

<p>Much simpler is to do:</p>

<pre><code>do { ... } while(x == 'j' || x == 'J');
</code></pre>

<p>don't you think?</p>
",1
34241117,34241040,0,"<p>Your call to <code>nameOnFile</code> in <code>read</code> doesn't do what you want.  You will read a filename, but then just ignore it.  If you want to do that, you will need to declare fin (but not open it), then loop until either you open the file successfully, or the user doesn't want to try again.</p>
",0
34249590,34241040,0,"<p>To have a non-local control flow jump from some inner function back to <code>main</code> you probably want some <a href=""https://en.wikipedia.org/wiki/Exception_handling"" rel=""nofollow noreferrer"">exception handling</a>.</p>

<p>Read more about <a href=""http://en.cppreference.com/w/cpp/language/exceptions"" rel=""nofollow noreferrer"">C++ exceptions</a> (and their <a href=""https://stackoverflow.com/q/8311457/841108"">relation with destructors</a>, notably <a href=""https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow noreferrer"">RAII</a>), <a href=""http://en.cppreference.com/w/cpp/language/throw"" rel=""nofollow noreferrer"">throw</a> expressions, <a href=""http://en.cppreference.com/w/cpp/language/try_catch"" rel=""nofollow noreferrer"">try-catch</a> blocks. You might consider some <code>throw std::runtime_error(""message"");</code> in the inner function, and using <code>try {</code> ...<code>} catch(std::runtime_error err) {</code>...<code>}</code>  in your <code>main</code> (or you could consider having your own exception class, inheriting from <code>std::runtime_error</code> ...)</p>

<p>Read a good book on <a href=""http://stroustrup.com/programming.html"" rel=""nofollow noreferrer"">Programming using C++</a></p>
",0
31148508,31148483,0,"<p><a href=""https://stackoverflow.com/questions/4272432/c-undefined-reference-to-vtable"">This question</a> has a few answers.</p>

<ul>
<li>You need a destructor in your <code>sigListener</code> class</li>
<li>As one of the answers on that question points out, if they're compiled separately and you didn't link all required objects together then you could get this error.</li>
</ul>
",0
29476562,29476523,4,"<blockquote>
  <p>Why ? isnt *(new foo()) a temp ?</p>
</blockquote>

<p>No, it isn't a ""temp"". It is an lvalue expression, referring to the newed object, an object that is alive until someone calls <code>delete</code> on it. It is perfectly fine to bind a non-const lvalue reference to such an expression.</p>

<p>What it is is a memory leak.</p>
",0
34213085,34212822,0,"<p>For <code>vector&lt;char&gt;</code> it can be done in linear time. Let's assume for simplicity that <code>char</code>'s are unsigned, or that we use <code>vector&lt;unsigned char&gt;</code>.</p>

<pre><code>int s[256] = { 0 }, s2[256] = { 0 };
for (auto a : sv)
   ++s[a];
for (auto a : sv2)
    ++s2[a];
int count = 0;
for (int i = 0; i &lt; 256; ++i)
    count += min(s[i], s2[i]);
</code></pre>

<p>In the general case use sorting and <code>set_intersection</code>, as <strong>@Jarod42</strong> suggested.</p>
",0
33564775,33564728,4,"<p>A vector doesn't change its properties by being an element of an array. So you would sort it just like you would sort a vector that is <em>not</em> an element of a 2D array:</p>

<pre><code>sort(cost[tx][ty].begin(), cost[tx][ty].end());
</code></pre>

<p>or</p>

<pre><code>sort(begin(cost[tx][ty]), end(cost[tx][ty]));
</code></pre>

<p>Assuming argument dependent lookup finds <code>std::sort</code>, <code>std::begin</code> and <code>std::end</code>.</p>
",0
29449683,29449492,1,"<p>Indeed, when you want to invoke common functionality defined in the base class' pure virtual member function. </p>

<blockquote>
  <p>(Not sure if the syntax works though).</p>
</blockquote>

<p>It works like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Foo
{
    virtual void f() = 0;
    virtual ~Foo() = default;
};

void Foo::f()
{
    std::cout &lt;&lt; ""common functionality"" &lt;&lt; std::endl;
}

struct Bar: Foo
{
    void f() override
    {
        Foo::f(); // call the base pure virtual implementation, common functionality
        std::cout &lt;&lt; ""derived functionality"" &lt;&lt; std::endl;
    }
};

int main() 
{
    std::unique_ptr&lt;Foo&gt; upFoo{std::make_unique&lt;Bar&gt;()};
    upFoo-&gt;f();
}
</code></pre>

<p>See also Item 34 of Scott Meyers' <em>Effective C++</em> for a very detailed discussion of this topic.</p>
",0
29449791,29449492,0,"<p>One obvious example is when you have a pure virtual destructor. The destructor, while pure, will still be invoked when an object of a derived class is destroyed. Therefore, the destructor is odr-used and requires a definition. In most cases you will just want to explicitly default it. It will still carry out the usual duty of a destructor, invoking the destructors of non-static members and further base classes.</p>
",0
28519081,28519061,0,"<p>You could make a default constructor</p>

<pre><code>struct A {
    A() : a{-1} {}
    int a;
};
</code></pre>
",7
28520058,28519061,5,"<p>First, let's look at the error:</p>

<pre><code>ANSI C++ forbids in-class initialization of non-const static member a
</code></pre>

<p>Initialization of a true instance member, which resides within the memory of an instance of your struct is the responsibility of this struct's constructor.</p>

<p>A static member, though defined inside the definition of a particular class/struct type, does not actually reside as a member of any instances of this particular type. Hence, it's not subject to explaining which value to assign it in a constructor body. It makes sense, we don't need any instances of this type for the static member to be well-initialized.</p>

<p>Normally, people write member initialization in the constructor like this:</p>

<pre><code>struct SomeType
{
    int i;
    SomeType()
    {
        i = 1;
    }
}
</code></pre>

<p>But this is actually not initialization, but assignment. By the time you enter the body of the constructor, what you've done is default-initialize members. In the case of a fundamental type like an int, ""default-initialization"" basically boils down to ""<em>eh, just use whatever value was in those bytes I gave you.</em>""</p>

<p>What happens next is that you ask i to now adopt the value 1 via the assignment operator. For a trivial class like this, the difference is imperceptible. But when you have const members (which obviously cannot be tramped over with a new value by the time they are built), and more complex members which cannot be default-initialized (because they don't make available a visible constructor with zero parameters), you'll soon discover you cannot get the code to compile.</p>

<p>The correct way is:</p>

<pre><code>struct SomeType
{
    int i;
    SomeType() : i(1)
    {
    }
}
</code></pre>

<p>This way you get members to be initialized rather than assigned to. You can initialize more than one by comma-separating them. One word of caution, they're initialized in the order of declaration inside your struct, not how you order them in this expression.</p>

<p>Sometimes you may see members initialized with braces (something like <code>i{1}</code> rather <code>i(c)</code>). The differences can be subtle, most of the time it's the same, and current revisions of the Standard are trying to smooth out some wrinkles. But that is all outside the scope of this question.</p>

<p>Update:
Bear in mind that what you're attempting to write is now valid C++ code, and has been since ratification of C++11. The feature is called ""Non-static data member initializers"", and I suspect you're using some version of Visual Studio, which still lists support as ""Partial"" for this particular feature. Think of it as a short-hand form of the member initialization syntax I described before, automatically inserted in any constructor you declare for this particular type.</p>
",4
28203990,28203608,2,"<p>I thing <a href=""http://en.wikipedia.org/wiki/Regular_expression"" rel=""nofollow"">regular expressions</a> is best solution for your problem.</p>

<p>They are supported by C++11:</p>

<pre><code>#include &lt;regex&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

auto lines = std::vector&lt;std::string&gt; {
    ""WordOne        2"",
    ""WordTwo        10.1"",
    ""WordThree      0.38"",
    ""WordThree      0."",
    ""WordFive      WordFive""
};

int main() {
    std::regex re(""\\w+\\s+\\d+\\.?\\d*"");
    for(auto line : lines) {
        if(!std::regex_match(line, re)) {
            std::cout &lt;&lt; ""Line: \"""" &lt;&lt; line
                    &lt;&lt; ""\"" is incorrectly formatted"" &lt;&lt; std::endl;
        }
    }
}
</code></pre>

<p>This code allows various forms of fractional floating point syntax. You may want to make it more strict or allow exponential forms - just modify regex :)</p>
",1
28203773,28203608,3,"<p>if <code>s</code> is the file associated text stream, given <code>std::string wd; double d;</code></p>

<p>an expression like <code>s &gt;&gt; wd &gt;&gt; d</code> will attempt to read the word and the double and evaluates as ""false"" (nullptr, in fact) if it fails somehow.</p>

<p>At that point you should reset the error flag (<code>s.clear()</code>), discard anything to ""\n"" and continue. ( <code>s.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(),'\n');</code> )</p>

<p>You can count the read lines, as save the line number of the ones that makes the read failure.</p>
",1
28445383,28445353,-1,"<p>The const reference return is better since it does not make a copy of the string. The reason I say this is because the interface is more flexible this way - you can always copy the const reference into another string if needed or you can use it as a reference - up to the caller. Returning a member byvalue and you are always stuck with making a copy. If <code>name</code> is big or used often, then it will impact performance and I assume performance is one of the reasons you use C++ in the first place.</p>

<p>Now, the other answers raise some negative points about returning a const reference, which I do not think are valid.</p>

<p>The concern that you can cast away the const, is valid, but casting away const is just one of the tools in the C++ developer's toolbox. Why take it away? If someone really wants to mess with your object, they can always do so in c++ by addressing memory directly so designing your code to save your callers from themselves is pointless. Casting the const away shows intent to do so and in my opinion is perfectly OK. It means that the caller has some very specific reasons to do so and knows that the const being cast away is for a non-const object and therefore - safe.</p>

<p>The academic example in the other answer is just silly:</p>

<pre><code>const string s&amp; = foo().name();
</code></pre>

<p>Again, designing your code to attempt to save the caller from themselves is limiting you from the power of C++. If one would really want to do the above, the proper way would be</p>

<pre><code>string s = foo().name();
</code></pre>

<p>So that point is moot too.</p>

<p>The only valid point is that it exposes the implementation somewhat. The efficiency gains, however, outweigh this concern in my opinion.</p>

<p>What you really should ask yourself is this - what is the usual case of using <code>name()</code>?</p>

<p>By answering this question, you will answer which flavour you should use.</p>

<p>To me, the fact that it is called <code>name</code> implies that it will mostly be used for printing/logging and comparison. Therefore, the const reference is the clear winner here.</p>

<p>Also, look at the style guides out there. Most of them will have you pass by const reference and return members by const reference. There are very good reasons to do so as outlined above.</p>
",2
28445419,28445353,1,"<p>The first allows callers some-what direct access to your internal name variable. Granted it's constant, so they can only call const methods on it. But still do you want external callers operating on your hidden, internal data? Even worse, what if some bozo decides to const_cast the internal data buffer of the string and hack on it?</p>

<p>The second returns a copy of your internal name variable. Perfectly safe for any callers to use. </p>

<p>I usually steer away from the first type, except for trivial, low level types. But then trivial low level types don't have much overhead for copying anyways. So that means I never write stuff like that. </p>
",0
28445492,28445353,3,"<p>First of all, the reference would be problematic indeed if the underlying value could change, particularly in the context of multi-threaded execution. So it's almost a basic assumption that the value of the data member doesn't change during the lifetime of the object. That it's effectively a constant.</p>

<p>Now, a main problem with the reference is that it exposes an implementation detail so that it gets difficult to change the implementation.</p>

<p>A more academic problem is that it can break code, if there earlier was a by-value return, or just because it's unusual. E.g.</p>

<pre><code>const string s&amp; = foo().name();
</code></pre>

<p>With <code>foo()</code> returning an object by value, and <code>name()</code> returning a string by reference, this gives you a dangling reference instead of the na?vely expected prolonged lifetime. I call it academic because I can't imagine anyone writing that. Still, Murphy's law and all that.</p>

<p>It will probably not be (significantly) more efficient than a value return, precisely because it's unlikely that it's used just to initialize a reference.</p>

<p>So:</p>

<ul>
<li><p>probably not significantly more efficient,</p></li>
<li><p>prevents changing implementation easily,</p></li>
<li><p>also has an academic problem, yielding dangling references.</p></li>
</ul>

<p>In sum, just don't.</p>

<p>This is premature optimization and complication.</p>
",2
29451548,29451516,1,"<p>Name lookup is performed before overload resolution. Name lookup starts in one scope, then if it doesn't find a declaration of the name, it searches an enclosing scope, and so on until it finds the name. In this case <code>d.f</code> finds the declaration <code>void Derived::f(string)</code>. It is only if there were no declaration of a member <code>f</code> in <code>Derived</code> that name lookup would proceed to search the base class. Only after the name has been found does the compiler determine whether there is an appropriate overload, and if so, which overload is the best match.</p>

<p>Note that you can redeclare the base class function in the derived class, to force it to be found:</p>

<pre><code>class Derived : public Base {
public:
    using Base::f;
    void f(string s) {
        cout &lt;&lt; ""\nString: "" &lt;&lt; s &lt;&lt; endl;
    }
};
</code></pre>

<p>Now name lookup will find both overloads of <code>f</code> and then overload resolution will determine which one to call.</p>
",0
29451595,29451516,0,"<p>If you want to be able the <code>Base::f</code> in addition to <code>Derived::f</code>, you can add a line</p>

<pre><code>using B::f;
</code></pre>

<p>in <code>Derived</code>.</p>

<pre><code>class Derived : public Base {
   public:
      using Base::f;
      void f(string s) {
         cout &lt;&lt; ""\nString: "" &lt;&lt; s &lt;&lt; endl;
      }
};
</code></pre>

<p>Now you can use:</p>

<pre><code>Derived d;
d.f(10);
d.f(""Hello"");
</code></pre>
",0
28440362,28440296,6,"<p>For your 1st case, the code <a href=""http://ideone.com/BT5x5a"" rel=""nofollow"">compiles just fine for me</a> (after fixing <code>main()</code>'s return type). I don't know which <em>errors</em> you're bothering about.</p>

<hr>

<p>For your 2nd case, the enum is declared in scope of the class </p>

<pre><code>class Batsman {
public:     
    enum Hand {RIGHT,LEFT};
    // ...
};
</code></pre>

<p>so you'll have to provide the scope qualifier in <code>main()</code>:</p>

<pre><code>int main() {
    Batsman B1(""Ryder"",Batsman::LEFT);
                    // ^^^^^^^^^
    Batsman B2(""McCullum"",Batsman::RIGHT);
                       // ^^^^^^^^^
}
</code></pre>

<hr>

<p><sub>Also note you always should have <code>int</code> as return type of <code>main()</code>.</sub></p>
",7
28166919,28166235,-2,"<p>(int) will cast the float value to sizeof(int) byte integer value &lt;= float value</p>

<p>(int &amp;) will convert the float value to a one byte refrence</p>
",0
33511993,33511962,1,"<p><code>""d""</code> is not a <code>std::string</code>. It is a <code>const char *</code>. As such, when you do <code>string d = ""d""</code>, you set a string to the <code>const char *</code> of <code>{'d', '\0'}</code>. Then when you compare it, the <code>std::string operator&gt;</code> is used instead of the version for a <code>const char *</code>.</p>
",1
32427572,29712215,0,"<p>GCC has the same problem, unless you compile with -O3 -ffast-math. ICC seems to have the problem according to <a href=""http://www.lomont.org/Math/Papers/2011/Intro%20to%20Intel%20AVX-Final.pdf"" rel=""nofollow"">http://www.lomont.org/Math/Papers/2011/Intro%20to%20Intel%20AVX-Final.pdf</a> . (Compare the benchmarks between Complex and Float)</p>

<p>I prefer the hand writen float algorithm for my mandelbrot set demo and don't use std::complex. But for real world problems I don't have an answer.</p>
",0
26780579,26780505,4,"<p>Use a static vector of arrays:</p>

<pre><code>void func()
{
    using array_type = std::array&lt;char,10&gt;;
    static std::vector&lt;array_type&gt; store;

    array_type your_array;
    // ... fill your_array
    store.push_back(your_array);
}
</code></pre>
",2
28469565,28469554,3,"<p>A <code>class</code>'s members are <code>private</code> by default, and a <code>struct</code>'s are <code>public</code>:</p>

<pre><code>class A {
    int x; // this is private to A
};

struct B {
    int y; // this is public
};
</code></pre>

<p>Also when it comes to inheritance, a <code>class</code> will inherit <code>private</code>ly by default and a <code>struct</code> will inherit <code>public</code>ally:</p>

<pre><code>class C : B { }; // private inheritance

struct D : B { }; // public inheritance
</code></pre>

<p>That's it.</p>
",0
28486732,28486011,1,"<p>An important principle of C++ programing is <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow"">Resource Acquisition Is Initialization</a> which achieves an important property of automatic cleanup of resources. This is particularly important for making C++ code exception-safe. You are far less likely to forget to clean up, and the C++ code you write is the same whether or not you <em>actually</em> use C++ exception handling.</p>

<p>A smart-pointer is a way to implement RAII in C++.</p>

<p>The C++11 standard <code>std::unique_ptr</code> is for something that is only ever <em>owned</em> by a single entity. When that entity is destroyed, the thing it owns should be cleaned up immediately.</p>

<p><code>std::shared_ptr</code> is for something that has shared ownership between a number of entities, and the only time it should actually get deleted is when all references to it are gone. This is specifically where you don't actually know for sure which entity will be the 'last one standing'.</p>

<p>For Microsoft platforms when using COM objects, you should use <code>Microsoft::WRL::ComPtr&lt;T&gt;</code>. For WinRT programming with the C++/CX language extensions, the <code>T^</code> is the same thing.</p>

<p>All such references are 'strong' references which have guarantees about ownership. You can also have 'weak' references to the same resource, which in the case of a <code>std::unique_ptr</code> or <code>Microsoft::WRL::ComPtr&lt;T&gt;</code> is just a raw pointer. Weak references allow you to reference the object, but makes <em>no</em> claim about the ownership status of that object.</p>

<p>Raw pointers are therefore ideal for passing to functions as parameters that are going to execute sequentially (as opposed to asynchronously), calling legacy functions, etc. They all work perfectly fine as long as you make the guarantee that the 'strongly owning' objects can't be destroyed while someone is using a weak reference to the same thing.</p>

<p>In practice this means that you probably want to use smart-pointers in your class private data members to keep a hold of resources you created and want to exist for the life of the class, but you can and should use raw pointers as weak references for functions that need only temporary use of a resource.</p>

<p>You <em>can</em> of course pass smart-pointers as parameters, but you want to do as const ref:</p>

<pre><code>void function(const std::unique_ptr&lt;T&gt;&amp; data);
</code></pre>

<p>but it's probably easier and more convenient to use (as well as be able to more easily interface with other code that might not be using the same smart-pointers):</p>

<pre><code>void function(T* data);
</code></pre>

<p>Now if you are actually going to return a fresh object or take ownership, then it would make more sense to use something like:</p>

<pre><code>std::unique_ptr&lt;T&gt; function();

void function(std::unique_ptr&lt;T&gt;&amp; data);
</code></pre>

<p>See <a href=""https://msdn.microsoft.com/en-us/library/hh279674.aspx"" rel=""nofollow"">Smart Pointers</a>, <a href=""https://msdn.microsoft.com/en-us/library/br244983.aspx"" rel=""nofollow"">ComPtr</a>, and <a href=""http://blogs.msdn.com/b/chuckw/archive/2012/09/17/dual-use-coding-techniques-for-games.aspx"" rel=""nofollow"">Dual-use Coding Techniques for Games</a>.</p>
",2
28486239,28486011,0,"<p>You are conflating smart pointer with <code>unique_ptr</code>. When <code>shared_ptr</code> style management is required, clearly <code>unique_ptr</code> will not work, so you cannot say that it is ""ALWAYS"" preferable to a normal pointer. A normal pointer would at least allow shared access, although the management of that would be harder.</p>
",3
28486344,28486011,2,"<p>Assuming the <em>intended</em> question is really</p>

<blockquote>
  <p><strong>&rdquo;</strong> Is there any case where normal pointers are preferable to unique pointers?</p>
</blockquote>

<p>(as indicated by <a href=""https://stackoverflow.com/questions/28486011/is-a-smart-pointer-unique-pointer-always-preferable-to-normal-pointer#comment45294004_28486011"">a comment by the OP</a>), the answer is a clear <strong>yes</strong>.</p>

<p>A <code>std::unique_ptr</code> has unique ownership of an object.</p>

<p>Where you don't want ownership, but just observing and accessing an object, a raw pointer &ndash; or a functionally equivalent abstraction &ndash; is needed to avoid engaging in automated destructive behavior.</p>

<p>These are the most common uses of object pointers. Outputting a string literal you're already using such a pointer, namely a pointer to (the first item of) a character array. Declare the arguments of <code>main</code> and you have such a pointer again. They're just about everywhere. The operative word is perhaps &ldquo;ubiquitous&rdquo;, so common that one just don't notice them.</p>
",0
28464338,28464259,0,"<p>When you declare <code>new</code> variables in c++ they are allocated on the heap.  When the variables go out of scope (like when the program ends), the memory stays allocated, unless you explicitly <code>delete</code> them in your code.</p>

<p>You should read <a href=""http://www.cplusplus.com/doc/tutorial/dynamic/"" rel=""nofollow"">this</a></p>
",1
28464344,28464259,6,"<p>Yes, there certainly is something wrong.</p>

<p><code>someFunc1()</code> will definitely cause a memory leak, because the memory address of the allocated object is lost.</p>

<p><code>someFunc2()</code> will cause a risk for a memory leak, because the user of the function has to remember to delete the returned object with a weird syntax (<code>delete &amp;object</code>).</p>

<p>Neither of them is good C++. A correct version would be:</p>

<pre><code>Student someFunc3() {
    return Student(""John"",25); 
}
</code></pre>
",1
28464348,28464259,3,"<p>The first function allocates an object, that dereferences it and returns.  By default, return does a <em>copy</em> of object.  Thus the originally allocated object still exists, but is not accessible anymore.  Which is a memory leak by definition.</p>

<p>In the second case, however, the reference to the allocated object is returned rather than a copy.  This way, the caller may still take an address of the object and delete it.</p>
",1
29197707,29197661,1,"<p>Just try to implement this in proper order according to your program flow</p>

<pre><code>int i;
#pragma omp parallel
{
    i=omp_get_thread_num();
}
</code></pre>

<p>thus the thread number of currently executing the block of statement is stored in <code>i</code>.</p>
",2
26119147,26118428,1,"<p>To keep track of letters, create a string and add the letter which the user typed . Then loop through it after each input to see if the input is already typed before. If it is ,prompt the user to enter another input. Else continue this process.</p>

<p>Note-I answered your question,but I did not fix several of the bugs in your code.</p>
",15
28509089,28508701,1,"<p>I'm guessing the problem is caused by this:</p>

<pre><code>Matrix::Matrix(const Matrix&amp; m)
{
    this-&gt;element = m.element;
}
</code></pre>

<p>That is an invalid copy constructor for two reasons. First, you're not initializing <code>rows</code> or <code>cols</code>. Second, you'll now have two <code>Matrix</code> objects pointing to the same memory - both of which will delete it on destruction:</p>

<pre><code>{
    Matrix m1(3, 5);
    Matrix m2 = m1;
} // BOOM!
</code></pre>

<p>You need to do a deep copy here:</p>

<pre><code>Matrix::Matrix(const Matrix&amp; m)
: rows(m.rows), cols(m.cols)
{
    element = new int *[cols];
    for (int i = 0; i &lt; cols; ++i) {
        element[i] = new int[rows];
        for (int j = 0; j &lt; rows; ++j) {
            element[i][j] = m.element[i][j];
        }
    } 
}
</code></pre>
",1
29464361,29464289,0,"<p>Whether or not you need a pointer depends entirely on how your <code>BasketArticles</code> class instances are constructed: what's responsible for instantiating and destroying them. If your <code>BasketArticles</code> instance are instantiated elsewhere, and you would like the map to reference them, obviously you need a pointer. Otherwise, if the instances of <code>BasketArticles</code> should only exists in the map, then it's better to avoid using pointers, and have <code>std::map</code> responsible for instantiating them.</p>
",2
28521431,28521210,0,"<p>I'm not sure what you are trying to achieve here, but why don't you try something like:</p>

<pre><code>int flag=0;
int i=0;
void handler(int signum){
   signal(SIGINT, handler);
   flag = 1-flag;
   i=0;
}

int main()
{
   signal(SIGINT, handler);
   while(1){
       if (flag==0){
           sleep(1);
       }else{ 
           i++;
           cout&lt;&lt;""processing""&lt;&lt;i&lt;&lt;endl;
           sleep(2);   
       }
   }
   return 0;
}
</code></pre>

<p>It is a better code design and should give the desired behavior...</p>
",1
28521506,28521210,0,"<p><code>int main()</code> is a declaration, not a function call.</p>

<p>But you're not allowed to call <code>main()</code> anyway so, if you changed this to <code>main()</code>, your program would not compile:</p>

<blockquote>
  <p><code>error: ISO C++ forbids taking address of function '::main'</code></p>
</blockquote>

<p>I suggest refactoring your solution.</p>
",0
30211798,30211635,0,"<p>Essentially for a function definition in a header file is visible to every compilation unit and they attempt to compile it. </p>

<p>However the function is already defined in the dll.</p>

<p>The solution would be place the definition in the cpp file as you noted or to use the static keyword so the definition is only visible to the compilation unit it's defined in and not ones that include it.</p>

<p>Also inlining functions is only a performance hint for the compiler, it may not inline it. And for this function I can't imagine their being any performance benefits given it's simplicity so I'd recommend moving it into the .cpp file.</p>
",6
33550207,33550045,4,"<p>You're solution is clever. Your idea is to jump over all 1's in the binary string by using a closed formula to get the position of the <code>s</code>-th 1 in the sequence. If  the sequence has a 1 at <code>b</code>, you find that very quickly by iterating over <code>s</code>, since for <em>some</em> <code>s</code>, the conditition <code>((s * (s - 1)) / 2) + 1 == b</code> becomes true. So far it is ok.</p>

<p>However, if the sequence has a 0 at <code>b</code>, that condition is <em>never true</em>. You never hit a 1, and you only check that in your condition. So if for one value of <code>s</code>, the formula is <code>&lt; b</code>, and for the next it is <code>&gt; b</code>, you jumped over <code>b</code>. But you continue the for-loop of <code>s</code> until <code>s &gt; b</code> and that is way to much time to spend.</p>

<p>So in a nutshell, you need to check for <code>&gt; b</code>. If this is the case, you know that the sequence has a 0 at <code>b</code>. Simply <code>break;</code> out of the loop in this case.</p>

<hr>

<p>You can even improve that by inverting your formula to compute <code>s</code> directly from <code>b</code>. For this, solve the formula for <code>s</code>. <a href=""http://www.wolframalpha.com/input/?i=solve+s*%28s-1%29%2F2%2B1%3Db+for+s"" rel=""nofollow"">That gives you <code>s = 0.5*(sqrt(8*b-7)-1)</code></a> (Note that the negative solution is irrelevant). This is a computation over the real numbers, so you are going to need floating point numbers for that, and the result is a floating point number, too.</p>

<p>If <code>s</code> turns out to be an integral number, you hit a 1, and 0 otherwise. But checking the result to be integral is error-prone (floating point arithmetic introduces some predictable but unavoidable rounding errors). So instead I'd recommend to use the forward formula (the one you already have) with the rounded-down and rounded-up results of this inverted formula. In other words, guess <code>s</code> using a floating point inverse formula, use this <code>s</code> to check two possible candidates for an integral <code>s</code> against your forward formula.</p>

<pre><code>float guess_s = 0.5*(sqrt(8*b-7)-1);
int s1 = floor(guess_s); // rounded down
int s2 = s1 + 1;         // rounded up
</code></pre>

<p>Then check <code>s1</code> and <code>s2</code> with your formula:</p>

<pre><code>if ( ((s1 * (s1 - 1)) / 2) + 1 == b || ((s2 * (s2 - 1)) / 2) + 1 == b )
    cout &lt;&lt; ""1"" &lt;&lt; endl;
else
    cout &lt;&lt; ""0"" &lt;&lt; endl;
</code></pre>
",7
29152329,29152298,3,"<p>Deleting the variable does not do anything to the memory. It simply says to the operating system ""I am done using this memory space now and you are free to use it.""</p>

<p>Quite honestly, printing a free'd variable is undefined behavior and you never know what will happen. Try running the same program an hour later and it may print out garbage or even crash.</p>
",0
29152335,29152298,1,"<p>It is undefined behavior. It <em>happened</em> to have the same value at that memory address. But if you checked later the value may change. It is not as if as soon as you <code>delete</code> an object, the value at that address will be ""reset"" to zero, or something like that. It will simply stay at it's last value until some other object occupies that memory and writes a value there.</p>

<p>The value of an address that you did not allocate is undefined, period.</p>
",0
33574100,33573486,0,"<p>Change the header file <code>#include ""conio.h""</code> to <code>#include &lt;conio.h&gt;</code>
Becuase <code>getch()</code> functions are defined in this header file.</p>
",1
28486737,28486391,1,"<p>Declare <code>ifAttack</code> not as an <code>int</code> but like the:</p>

<pre><code>string ifAttack;
</code></pre>

<p>You can then read it in just as you were doing with: <code>cin &gt;&gt; ifAttack;</code></p>

<p>But since you're only really concerned with whether the user entered a 'y' for the first character change your <code>if</code> statement to:</p>

<pre><code>if(ifAttack.front() == 'y' || ifAttack.front() == 'Y')
</code></pre>

<p><strong>EDIT:</strong></p>

<p>Filtering user input can be a difficult task. But if you decide that you want to take that on you can compare the <em>whole</em> <code>string</code> rather than just the first character. That way ""yellow elephant"" does not mean ""yes"":</p>

<pre><code>if(_stricmp(ifAttack.c_str(), ""yes"") || _stricmp(ifAttack.c_str(), ""y""))
</code></pre>

<p><code>_stricmp</code> is a Microsoft only function: <a href=""https://msdn.microsoft.com/en-us/library/k59z8dwe.aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/k59z8dwe.aspx</a>
<code>strcasecmp</code> is the Linux equivalent: <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strcasecmp.html"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/009695399/functions/strcasecmp.html</a></p>

<p>I would suggest you save filtering your input till the end of your project. It can be tedious. For example the string comparisons above don't match ""YES!"".</p>
",12
31811924,31811850,0,"<p>stringstream buffer is not guaranteed to provide an infinite length buffer. So if you use this log class, possible chance of missing earlier log info before writing into a file.  Otherwise if you intend to write logs intermittently , you are going to create and destroy  log objects again and again. It will definitely guarantee a performance hit. </p>

<p>So singleton implementation of log class should choose against this one. </p>
",0
31811994,31811850,3,"<p>A temporary object is destroyed at the end of the expression in which it is created. So yes, it will write/log info in a timely manner.   </p>

<p>The drawback of this approach is that each time you create the temporary, you'll create and then destroy a stringstream (and eventually a filestream to log it).  This seems an important performance overhead ! So I'd say that a singleton would be a better approach.</p>

<p>The advantage of a long living logger (be it singleton or not), is that you could optimise the logging overhead (e.g. write immediately to a file, or accumulate the data and write it periodically, especially in high performance sections of your code, where realtime disk i/o would slow down too much the execution).  </p>

<p><strong><em>Edit/Additional infos</em></strong></p>

<p>The overhead of temporary creation/destruction including streams shall not be under-estimated.  I ran <a href=""http://ideone.com/CcnSTE"" rel=""nofollow"">this informal benchmark</a> on my PC with 100 000 small log entries (MSVC release mode):  </p>

<ul>
<li>48 second for the temporary based logger</li>
<li>1 seconds for the permanent logger.  </li>
</ul>

<p>It compares your temporary logger (including a file write in the destructor) to 
a (very) simplified permanent one: </p>

<pre><code>class Log2
{
public:
    Log2();
    virtual ~Log2();
    std::ofstream&amp; Get();
protected:
    std::ofstream os;
};
std::ofstream&amp; Log2::Get() { return os; }
Log2::~Log2() { }
Log2::Log2() : os(""log2"") { }
</code></pre>

<p>By the way, there are some nice logging frameworks around. <a href=""http://www.codeproject.com/Articles/584794/Simple-logger-for-Cplusplus"" rel=""nofollow"">This tiny one</a> is very simple one.  It can have several instances (so not a singleton), which permits also modular loging.  </p>
",5
31812012,31811850,0,"<p>That's fine in this situation. Also, it is acceptable to use constructor/destructor pair to log entry and exit from a function for debugging. All you do is create an instance of the object as first line in function. Contructor logs the entry into the function and destructor(called automatically as part of stack unwinding when function returns) logs exit from function.</p>
",0
29901768,29901721,4,"<p>Local variables that are not assigned any values have what is called <a href=""https://stackoverflow.com/questions/13423673/what-is-indeterminate-value"">Indeterminate Value</a> ( also known as Garbage Value, it is the value that was previously stored in that memory location ( in c and c++) ) and accessing uninitialized variables leads to Undefined Behavior.</p>

<p>If you do not assign them a value, they will be having the garbage value.</p>

<p>But <code>static</code> and global variables have default value as 0</p>
",9
29901840,29901721,3,"<p><a href=""http://en.cppreference.com/w/cpp/language/default_initialization"" rel=""nofollow"">http://en.cppreference.com/w/cpp/language/default_initialization</a></p>

<blockquote>
  <p>Default initialization is performed in three situations: </p>
  
  <p><strong>1) when a
  variable with automatic, static, or thread-local storage duration is
  declared with no initializer</strong>. </p>
  
  <p>2) when an object with dynamic storage
  duration is created by a new-expression with no initializer or when an
  object is created by a new-expression with the initializer consisting
  of an empty pair of parentheses (until C++03). </p>
  
  <p>3) when a base class or
  a non-static data member is not mentioned in a constructor initializer
  list and that constructor is called.</p>
</blockquote>

<hr>

<blockquote>
  <p>The effects of default initialization are:</p>
  
  <p>If T is a non-POD (until C++11) class type, the constructors are considered and subjected to overload resolution against the empty
  argument list. The constructor selected (which is one of the default
  constructors) is called to provide the initial value for the new
  object.</p>
  
  <p>If T is an array type, every element of the array is default-initialized.</p>
  
  <p><strong>Otherwise, nothing is done: the objects with automatic storage duration (and their subobjects) are initialized to indeterminate
  values.</strong></p>
</blockquote>
",0
29901911,29901721,0,"<p>Accessing uninitialized variables will lead to <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>. Also, see <a href=""https://stackoverflow.com/questions/4259885/why-do-i-see-strange-values-when-i-print-uninitialized-variables"">this answer</a>.</p>

<p>You need to initialize 's' before performing the addition assignment s+= plotas((x2-x1), (y2-y1)).</p>
",0
29902035,29901721,0,"<p>Simply initialise the variables to prevent them from assuming any garbage value: </p>

<pre><code>int p=0, a=0,n=0,x1=0,x2=0,y1=0,y2=0,s=0,s1=0;
</code></pre>

<p>You can also initialise them to any <code>int</code> other than <code>0</code> as your code desires.</p>
",0
32492863,32492678,1,"<p>Could it be that you are entering a comma instead? If so, check out <a href=""https://stackoverflow.com/questions/15220861/how-can-i-set-the-comma-to-be-a-decimal-point"">this answer</a>.</p>

<p>As for the last part of the question, <a href=""https://stackoverflow.com/questions/1449324/how-to-simulate-press-any-key-to-continue"">this ""Press any key to continue"" answer</a> might help too.</p>
",1
32492976,32492678,0,"<p>The problem is most likely that an invalid character has crept into your stream.  This will result in the error bit to be set.  Until these bits have been cleared (using <code>ios::clear()</code>), you will not be able to read in from the stream.  This will look like it is in an infinite loop, outputting prompts, but skipping inputs.</p>

<p>See <a href=""https://stackoverflow.com/a/11085193/1366368"">this answer</a> for more info on how to fix the problem:</p>
",0
31867769,31867688,1,"<pre><code>std::string returnvar;
for (std::size_t i = start; i &lt;= end; ++i)
{
    returnvar += library[data[i]];
}
</code></pre>
",0
31867773,31867688,-3,"<p>You can use the += operator: </p>

<pre><code>string returnvar;
for (int i=start; i&lt;=end; i++) {
    returnvar += library[data[i]];
}
</code></pre>

<p>or the <code>append</code> function (edited to reflect Jerry Coffin's correction):</p>

<pre><code>string returnvar;
for (int i=start; i&lt;=end; i++) {
    returnvar.append(1, library[data[i]]);
}
</code></pre>

<p>More info:</p>

<p><a href=""http://www.cplusplus.com/reference/string/string/operator+=/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/operator+=/</a></p>

<p><a href=""http://www.cplusplus.com/reference/string/string/append/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/append/</a></p>
",13
31868025,31867688,7,"<p><code>std::string</code> has a <code>push_back()</code> method, just like <code>std::vector</code>'s (¡ì21.4.6.2/21):</p>

<pre><code>void push_back(charT c);
    Effects: Equivalent to append(static_cast&lt;size_type&gt;(1), c).
</code></pre>

<p>You could use <code>operator+=</code> instead:</p>

<pre><code>returnvar += library[data[i]];
</code></pre>

<p>Or one of the <code>append()</code> overloads:</p>

<pre><code>returnvar.append(&amp;library[data[i]], 1);
</code></pre>

<p></p>

<pre><code>returnvar.append(1, library[data[i]]);
</code></pre>
",0
28526532,28525496,0,"<p>I guess what you are looking for is <code>istream_iterator</code>. Using those, you can treat a stream as a sequence described by two iterators, as required by STL-style algorithms.</p>

<p>Notes:</p>

<ul>
<li>Your above code could have used a <code>std::set</code> instead.</li>
<li>Unless it has previous content, the <code>freq</code> has the same number of elements (<code>freq.size()</code>) as is returned.</li>
<li>The name suggests ""frequence"", but all the values of this key-value store will be zero.</li>
<li>Passing in a pointer is misleading, use a C++ reference instead.</li>
<li>If you actually want to count the number of occurrances, using <code>freq[s]++</code> works, as that will insert an element unless it is already present.</li>
<li>You never check whether the file can be opened or not.</li>
</ul>
",2
28533813,28533787,2,"<p>I think it is because you are mixing floats and ints as in this line:</p>

<pre><code>int aux = (( R * h) / H )
</code></pre>

<p>Note that integers <em>truncate</em> fractions:</p>

<pre><code>int x = 1.0/2.0;    // x = 0;
</code></pre>
",1
29450722,29450692,0,"<p>It is overloaded. The arguments are part of the function signature. And yes, remains abstract.</p>
",0
29450739,29450692,1,"<blockquote>
  <p><em>""Changing the return type is prohibited.""</em></p>
</blockquote>

<p>That assumption is wrong, for the general case.</p>

<blockquote>
  <p><em>""2. The virtual function is not being redefined/overridden but is actually being overloaded in the derived class. As a result, if the virtual function were pure, the derived class is still abstract.""</em></p>
  
  <p><em>""Is it 1 or 2 or something else?""</em></p>
</blockquote>

<p>It's 2.</p>

<p>Changing the signature of a function by adding/changing parameter(s)/types will no longer match the pure <code>virtual</code> function signature provided by the abstract base class.</p>

<p>So yes. The derived class doesn't provide an implementation for the pure <code>virtual</code> function declaration, as inherited from the base class, hence it's still abstract, yes.</p>
",5
29450762,29450692,3,"<blockquote>
  <p>Changing the return type is prohibited</p>
</blockquote>

<p>Nope, covariant return types are fine. Eg.</p>

<pre><code>struct A {};
struct B: public A {};
struct X {
  virtual A&amp; foo() { return a; }
  A a;
};
struct Y: public X {
  B&amp; foo() override { return b; }
  B b;
};
int main() {
  return sizeof(Y);
}
</code></pre>

<p>Changing anything else in the prototype, including the parameter list, will indeed result in an overload rather than an override. You can easily verify this with the 'override' specifier.</p>

<p>As Ben Voigt points out, the ""parameter list"" here means whatever you declare <em>minus</em> any top-level cv-qualification. That is, both these functions are considered to have the same type:</p>

<pre><code>void foo(int, const char *);
void bar(const int, const char * const);
</code></pre>
",3
30399110,30399013,0,"<pre><code>void foo(int* &amp;p){
    int z=40;
    p=&amp;z;
}
</code></pre>

<p>The above code is <em>not safe</em> because whoever called <code>foo</code> now has a pointer to a destroyed stack variable.</p>

<blockquote>
  <p>it gives the ouput 1 rather then the 3.THANKs..</p>
</blockquote>

<p>Of course it does. Learn what a pointer is and how it works.</p>

<pre><code>int a=1, b=2, c=3, *p, **q;
p=&amp;a;
q=&amp;p;
p=&amp;c;
std::cout &lt;&lt; **q &lt;&lt; std::endl;
</code></pre>
",0
30399113,30399013,0,"<p>just thought you should know that in foo() you're assigning the pointer to the address of a variable with automatic storage duration, which means that what it points to when foo returns is actually undefined (and in a larger program this is a disaster waiting to happen).</p>

<p>In your second example you only assign q once. During an assignment, a reference <em>is</em> the object it's referring to. The reference dependency is not carried forward.</p>
",0
30399291,30399013,1,"<pre><code>void foo(int* &amp;p){
    int z=40;
    p=&amp;z;
}
</code></pre>

<p>Here <code>p</code>is a <strong>reference</strong> to a pointer. Which means that when you modify it you will modify the referred pointer too.</p>

<p>When you call <code>foo</code> with</p>

<pre><code>int main(){
    int x=10;
    int *p=&amp;x;  
    foo(p);
    cout&lt;&lt;*p;
}
</code></pre>

<p>You're saying that the <strong>reference</strong> named <code>p</code>in the function <code>foo</code> refers to the pointer named <code>p</code>in the function <code>main</code>so whatever you do to <code>p</code> in <code>foo</code>will affect <code>p</code> in <code>main</code>.</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
    {
       int a=1, b=2, c=3;
       int *p, *q;
       p=&amp;a;
       q=*&amp;p;
       p=&amp;c;
       cout&lt;&lt;*q&lt;&lt;endl;

    } 
</code></pre>

<p>Here you have no reference anywhere, you just have a pointer that you <strong>copy</strong> to another pointer. <code>q=*&amp;p</code>is equivalent to <code>q=p</code>.</p>

<p><strong>The key difference to note here is that the <code>&amp;</code> operator in the first exemple means ""reference"" while the <code>&amp;</code> operator in the second example means ""address of"".</strong></p>

<p>If you want the closest equivalent to the first sample with the second one, try this:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
  int a=1, b=2, c=3;
  int *p, *&amp;q = p;
  p=&amp;a;
  q=*&amp;p;
  p=&amp;c;
  cout&lt;&lt;*q&lt;&lt;endl;

}
</code></pre>

<p>And in this last case you have both an <code>&amp;</code> which means ""reference"" in <code>int *p, *&amp;q = p;</code> and an <code>&amp;</code> that means ""address of"" in <code>q=*&amp;p;</code></p>
",0
30399334,30399013,0,"<p>Let me only consider your second example and I added a few comments and hopefully it will clarify why you are getting that output. </p>

<pre><code>   int a=1, b=2, c=3;
   int *p, *q;
   p=&amp;a; //P now points to the variable a
   q=*&amp;p; // q now points to the value in pointer p
   p=&amp;c;
   cout&lt;&lt;*q&lt;&lt;endl; //You are printing  value from pointer q
</code></pre>

<p>Please note you are not changing the address of a pointer, instead you are changing only the address  where  pointer points to.</p>
",0
30399190,30399013,0,"<p>That's because you aren't changing <code>q</code>.  You are changing <code>p</code>.  When you do</p>

<pre><code>q=*&amp;p;
</code></pre>

<p>it is the same as</p>

<pre><code>q = p;
</code></pre>

<p>So what you have done is assigned <code>p</code> to point to <code>a</code>.  Then you assign the value of <code>p</code> to <code>q</code> so now <code>q</code> points to <code>a</code>.  Then you assign the address of <code>c</code> to <code>p</code>.  Doing that does nothing to <code>q</code> and as such <code>q</code> still points to <code>a</code>.</p>

<p>You should also read <a href=""https://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope"">Can a local variable's memory be accessed outside its scope?</a> to see why your first example has undefined behavior.</p>
",0
30399222,30399013,0,"<p>Why do you expect to get the answer as <code>3</code>?</p>

<p><img src=""https://i.stack.imgur.com/ctjCy.png"" alt=""enter image description here""></p>

<p><code>q</code> points to <code>p</code> then you changed where <code>p</code> points. <code>p</code> points to c but <code>q</code> will still point to where previous address of <code>p</code>.</p>

<p>unless you reassign <code>q</code> to point to <code>p</code>, it will still point to <code>a</code>.</p>
",0
29242335,29242299,12,"<p>Your error is here:</p>

<pre><code>A(int x) {
    x = a;
}
</code></pre>

<p>I believe you want that to be:</p>

<pre><code>A(int x) {
    a = x;
}
</code></pre>
",0
30141927,30138166,1,"<p>The error is rather nasty.  If you look at the test data, you'll notice that the bad <em>fileNumber</em> happens only for <code>WRITE</code> lines and never for <code>READ</code> lines.   </p>

<p>This narrows down the problem to this part of your code, where you used a variable <code>newFile</code> without initialising it first:  </p>

<pre><code>    // write
    if((int)(rng() % 100) &lt; writeRatio) {
        // writeRatio% chance to write
        int block = 1 + (rng() % new_fsize);
        File newFile;                     //  &lt;===== unitialized !!
        if(block == new_fsize) {          //  &lt;===== what happens if this is false ?   
            // writing new block
            diskSize++;
            new_fsize++;
            newFile.id = new_fid;
            newFile.size = new_fsize;
            aliveFiles.pop_back();
            aliveFiles.push_back(newFile);
        }
    outfile &lt;&lt; write(newFile.id, block) &lt;&lt; std::endl; // &lt;== OUCH, if the if condition failed you go here with random data in newFile !!   
        continue;
    }
</code></pre>

<p>Two alternatives to solve the problem:  </p>

<ul>
<li>Just move the  <code>outfile&lt;&lt; ... ;</code> statement into the <code>if</code> block. The generated test file is then totally ok and consistent.  But the WRITE is happens only if <code>block==new_fsize</code> .</li>
<li>Or move <code>newFile.id=new_fid;</code> and <code>newFile.size=new_fsize;</code> outside the  <code>if</code> block. But you then have to think if it's reasonnable to ""write"" on <code>newFile.id</code> without putting it in the <code>aliveFiles</code>.  </li>
</ul>
",4
26196419,26187227,0,"<p>This is possible you can do like this. I have declared like this and the code is working perfectly. The reason why I got these errors was because I wasn't giving the file class name properly. </p>
",0
29230367,29230257,3,"<p>You need to use <code>std::getline</code> to input strings with a space.</p>

<p>For reversing your <code>std::string</code>, consider using <code>std::reverse</code> from <code>&lt;algorithm&gt;</code>, although your algorithm is correct too.</p>

<p>Code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
    string strin;
    cout &lt;&lt; ""enter string;"" &lt;&lt; endl;
    getline(cin,strin);
    reverse(strin.begin() , strin.end() );
    cout &lt;&lt; strin;
}
</code></pre>
",0
29230332,29230257,4,"<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/operator_ltltgtgt"" rel=""nofollow""><code>basic_string::operator&gt;&gt;</code></a>:</p>

<blockquote>
  <p>2) Behaves as an FormattedInputFunction. After constructing and checking the sentry object, which may skip leading whitespace, first clears <code>str</code> with <code>str.erase()</code>, then reads characters from is and appends them to <code>str</code> as if by <code>str.append(1, c)</code>, until one of the following conditions becomes true: <em>[...]</em></p>
  
  <p><strong><code>std::isspace(c,is.getloc())</code> is true for the next character c in is (this whitespace character remains in the input stream)</strong>.</p>
</blockquote>

<p>The method you use by definition reads until a white-space, so you read only <code>Hello</code> into <code>strin</code>. You should use another method for reading like <code>getline</code> or <code>stringstream</code>.</p>
",0
29234774,29230257,2,"<p>See, cin halts the input at any occurrence of a space or a newline character. So, to input a string with spaces, you'd have to use <code>cin.getline()</code> and that can be done by using the following snippet:</p>

<pre><code>string S;
cin.getline(1000,'\n');
</code></pre>

<p>This would take input till the newline character into <code>string S</code> and then we just have to reverse the string, and that can be done in two ways. </p>

<p>Method 1:</p>

<p>Using <code>std::reverse</code> from <code>&lt;algorithm&gt;</code> header file. This function works with all containers and takes iterators as parameters.</p>

<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    string S;
    getline(cin,S);
    reverse(S.begin(), S.end());
    return 0;
}   
</code></pre>

<p>Method 2:</p>

<p>You can create your function which swaps the characters at positions equidistant from end and start, and you get what you need in <code>O(n)</code> time-complexity.</p>

<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

string myfunc(string S)
{
    int l = 0;
    int r = S.size()-1; 
    while(l&lt;r)
    {
        swap(S[l],S[r]);
        l++;
        r--;
    }
    return S;
}

int main()
{
    ios_base::sync_with_stdio(false);
    string S;
    getline(cin,S);
    S = myfunc(S);
    cout&lt;&lt;S;
    return 0;
}   
</code></pre>
",0
29236778,29230257,2,"<p>What I think is you could do fine with your <code>revStr()</code> but you need to get a whole line input, but using <code>cin</code> considers space as a delimiter, hence you get only <code>Hello</code> out of <code>Hello World</code>.</p>

<p>Replace <code>cin &gt;&gt; strin</code> with <code>getline(cin,strin)</code>.</p>
",0
29464623,29464578,2,"<p>If you don't want to redirect the program output like <code>a.out &gt;&gt; output.txt</code> (this will redirect all output), you can redirect <code>std::cout</code> to a file (assuming also you don't want to modify the code in <code>f()</code> to use a <code>fstream</code>)</p>

<p>Simple example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;streambuf&gt;

void f()
{
    std::cout &lt;&lt; ""Say something\n"";
}

int main()
{
    std::cout &lt;&lt; ""Writing to file..."" &lt;&lt; std::endl;

    std::ofstream ofile(""output.txt"", std::fstream::app); // output file
    std::streambuf *oldbuf = std::cout.rdbuf(); // save the buffer
    std::cout.rdbuf(ofile.rdbuf()); //redirect to output.txt

    f(); // call f

    // now redirect back
    std::cout.rdbuf(oldbuf);

    std::cout &lt;&lt; ""Done writing to file"" &lt;&lt; std::endl;
}
</code></pre>

<p>Note: the above works if you print with <code>std::cout</code> and not using <code>prinf</code>. You can even write a RAII-like class that automatically redirects <code>cout</code> and its destructor redirects back, like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;streambuf&gt;

class RAIIcout_redirect
{
    std::streambuf* _oldbuf;
public:
    RAIIcout_redirect(std::ofstream&amp; os): _oldbuf(std::cout.rdbuf())
    {
        std::cout.rdbuf(os.rdbuf());
    }
    ~RAIIcout_redirect()
    {
        std::cout.rdbuf(_oldbuf);
    }
};

void f()
{
    std::cout &lt;&lt; ""Say something\n"";
}

int main()
{
    std::cout &lt;&lt; ""Writing to file..."" &lt;&lt; std::endl;
    std::ofstream ofile(""output.txt"", std::fstream::app); // output file

    // local scope, at exit cout is redirected back automatically
    {
        RAIIcout_redirect tmp(ofile);
        f(); // call f
    } // now redirect back because of ~RAIIcout_redirect()

    std::cout &lt;&lt; ""Done writing to file"" &lt;&lt; std::endl;
}
</code></pre>
",0
29464651,29464578,1,"<p>If you have access to the function src, you can modify the signature to pass in the ostream to which you want that function to write.  Add a default to minimize impact to the other invocations.</p>

<p>header:</p>

<pre><code>void foo(int x, int y, std::ostream&amp; an_ostream = std::cout);
</code></pre>

<p>implementation:</p>

<pre><code>void foo(int x, int y, std::ostream&amp; an_ostream)
{
    an_ostream &lt;&lt; ...
</code></pre>

<p>usage out to std::out:</p>

<pre><code>foo(1,2);
</code></pre>

<p>usage to file (simulated with stringstream):</p>

<pre><code>std::stringstream ss;
foo(3,4,ss);
</code></pre>

<p>output to cerr:</p>

<pre><code>foo(5,6,std::cerr);
</code></pre>

<p>suppress output:</p>

<pre><code>std::ofstream nullDev; // do not open
// set error, ignore errors
nullDev.setstate(std::ios_base::badbit); 
// do not close

foo(7,8,nullDev);
</code></pre>
",0
29464652,29464578,0,"<p>Here's a wild suggestion.</p>

<ol>
<li>Prepend every line of output from the function by a unique token.</li>
<li>Then, use:</li>
</ol>

<pre class=""lang-bash prettyprint-override""><code> a.out | grep &lt;token&gt; | sed -e '1,$s/&lt;token&gt;//' &gt;&gt; output.txt 
</code></pre>
",0
26203565,26203346,1,"<p>As others have noted you're:</p>

<ul>
<li><p>Passing vectors by value</p></li>
<li><p>Using something possibly uninitialized out-of-my-scope (this is nowhere declared/defined in your question) as increment variable</p>

<pre><code>//Creates a new line after every semi-colon.
void sortLines (vector&lt;string&gt; row)
{
  vector&lt;string&gt; tempRow;
  string tempLine;
  string tempString;

  for (unsigned int i = 0; i &lt; row.size(); k++) // &lt;-- what is k??
  {
</code></pre></li>
</ul>
",3
26203793,26203346,1,"<p>Why pass ""string line"" to removeComments? It should be local to that function cos you don't use it outside. It looks dodgy for the same reason that the passed vectors did.</p>
",1
34200110,34200004,2,"<p><a href=""http://en.cppreference.com/w/cpp/chrono/c/strftime"" rel=""nofollow"">strftime</a></p>

<blockquote>
  <p>Return value</p>
  
  <p>The number of bytes written into the character array pointed to by str
  not including the terminating '\0' on success. <strong>If count was reached
  before the entire string could be stored, ?0? is returned and the
  contents are undefined.</strong></p>
</blockquote>
",0
26214977,26214932,5,"<p>It is not incorrect and it is useful to do this in certain circumstances.</p>

<p>Suppose I have a vector with a lot of data and I want to clear the data and the memory..</p>

<pre><code>{ 
   std::vector&lt; int &gt;().swap( myVec );
}
</code></pre>

<p>will clear the memory for certain. <code>myVec.clear()</code> will probably only change the logical size back to 0.</p>

<p>As I showed in a previous question you can use it like this:</p>

<pre><code>class Foo
{
   public:
       Foo&amp; operator+=( Foo const&amp; ); // implement
       Foo operator+( Foo const&amp; rhs ) const
       {
          return Foo( *this ) += rhs;
       }
 };
</code></pre>

<p>The implementation there modifies a temporary then returns it by value (r-value reference in C++11, by value in C++03).</p>

<p>Obviously with r-value references you have more examples like in your case you can return     <code>meow().append( ""purr"")</code></p>
",4
26215159,26214932,1,"<p>It's legal, and useful:</p>

<pre><code>class Foo{
    int *data;
public:
    Foo(){data=new int[100];}
    Foo(const Foo&amp; other){ //copy ctor
        if(other.data!=nullptr){
            data=new int[100]; //make a new array
            for(unsigned i=0; i&lt;100; ++i) //
                data[i]=other.data[i];   //fill it using content of other
        }
    }
    Foo(Foo&amp;&amp; other){ //move ctor
        data=other.data; /* obvioulsly grab the other's pointer :)
                          * other is a temporary, so we don't have to
                          * allocate new array and copy other's content,
                          * because other is going to disappear soon.
                          */
        other.data=nullptr; /* Without this line, other and *this
                             * have the same pointer!
                             * When *this or other gets destroyed,
                             * it frees the data; second object
                             * doesn't know about the deletion, 
                             * and may still want to use the data,
                             * causing undefined behavior by using fryed memory.
                             */
    }
    ~Foo(){delete[] data;} //frees data
};
</code></pre>
",3
30400337,30400108,0,"<p>Member function <code>begin()</code> of class <code>std::string</code> returns iterator. That is its return type either <code>std::string::iterator</code> or <code>std::string::const_iterator</code>.</p>

<p>You are trying to use member function <code>erase</code> that has parameters of type <code>std::string::size_type</code>:</p>

<pre><code>basic_string&amp; erase(size_type pos = 0, size_type n = npos);
</code></pre>

<p>If you want to use this member function you should write the call like</p>

<pre><code>word2.erase( 0, word.length()/2 - 1 )
</code></pre>

<p>If you want to use the function that uses iterators that is the following member function</p>

<pre><code>iterator erase(const_iterator first, const_iterator last);
</code></pre>

<p>then the call can look like</p>

<pre><code>word2.erase( word.begin(), std::next( word.begin(), word.length()/2 - 1 ) )
</code></pre>

<p>or simply</p>

<pre><code>word2.erase( word.begin(), word.begin() + word.length()/2 - 1 )
</code></pre>

<p>I hope that is not a typo that you call the function for object with name <code>word2</code> and in the expression used as the argument you use object with name <code>word</code></p>
",0
30400169,30400108,2,"<p>Looking at <a href=""http://en.cppreference.com/w/cpp/string/basic_string/erase"" rel=""nofollow"">http://en.cppreference.com/w/cpp/string/basic_string/erase</a> (1) you see that you need to pass the <em>index</em> of the first character to erase and the number of how many characters to erase. You pass an iterator instead as the first argument. Just do</p>

<pre><code>word3 = word2.erase(0, word.length()/2 -1);
//                     ^^^^
//                     this should probably be word2
</code></pre>

<p>or use the (3) overload that accepts a range:</p>

<pre><code>word3 = word2.erase(word2.begin(), std::next(word2.begin(), word2.length()/2 -1));
</code></pre>

<p>I also believe you should have <code>word2</code> inside your <code>erase</code>, not <code>word</code>.</p>
",0
26242627,26242480,0,"<p>One solution is to move the declaration of <code>sum</code> into your while block,</p>

<pre><code>// int sum = 0;
while ( inNum &gt;= loopCount) {
  int sum = 0; // &lt;-- or just sum = 0; and keep the declaration outside the loop
</code></pre>

<p>Another (as mentioned in the comments) is to reset <code>sum</code> at the end of the loop body.</p>
",2
33598937,33598703,0,"<p>you have double define for p !!</p>

<pre><code>void ComparePackets::check(Packet *p, Packet *p)
</code></pre>

<p>fix:</p>

<pre><code>void ComparePackets::check(Packet *p, Packet *q)
</code></pre>
",2
30696832,30696508,1,"<p>Your align malloc is erroneous, you can do something like this to align a pointer.</p>

<pre><code>uint8_t* ptr = (uint8_t*)malloc(N + alignment);
....
uint8_t offset = alignment - ((uintptr_t)ptr % alignment);
ptr += offset;
</code></pre>

<p>Now you have a pointer that has offset bytes of free space to the front, you store the offset there.</p>

<pre><code>*((uint8_t*)ptr - 1) = offset;
</code></pre>

<p>To free the ptr you decrement offset to get to the beginning</p>

<pre><code>uint8_t offset = *((uint8_t*)ptr - 1);
free((uint8_t*)ptr - offset);
</code></pre>
",7
30697165,30696508,0,"<p>This is not exactly a dup question, but see my answer here for help</p>

<p><a href=""https://stackoverflow.com/questions/20791428/what-is-the-recommended-way-to-align-memory-in-c11/20792203#20792203"">What is the recommended way to align memory in C++11</a></p>

<p>The methodology is to be able to find the beginning of the block from the returned memory by referencing the memory before the returned memory</p>
",0
34264536,34259591,1,"<p>There is no real question here except it does not work, it does not compile, why ?</p>

<p>As the first line of the matrix in the file seems to define the height and width of the matrix and considering you only store integers in it, you simply have to perform a double for-loop to store values in each line.</p>

<p>Probably something like this:</p>

<pre><code>void LoadFromFile(const std::string&amp; iFile)
{
    std::ifstream infile(iFile);
    infile &gt;&gt; _height;      
    infile &gt;&gt; _width;
    _m = new int*[_height];
    for (int i = 0; i &lt; _height; ++i)      
    {
        _m[i] = new int[_width];         
        for (int j = 0; j &lt; _width; ++j)     
        {
            infile &gt;&gt; _m[i][j];
        }
    }
}
</code></pre>

<p>Of course, you must not trust data provided in a file so some checks have to be added in the previous code.</p>
",0
26444974,26444916,0,"<p>If you get the default beep then it is most likely that the sound file can't be found. <code>PlaySound</code> searches for the sound file in the current directory, then the windows directory, then the system directory and finally the PATH.</p>
",0
26444998,26444916,0,"<p>The <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/dd743680(v=vs.85).aspx"" rel=""nofollow"">documentation</a> includes the following:</p>

<blockquote>
  <p>Three flags in fdwSound (SND_ALIAS, SND_FILENAME, and SND_RESOURCE)
  determine whether the name is interpreted as an alias for a system
  event, a file name, or a resource identifier. If none of these flags
  are specified, PlaySound searches the registry or the WIN.INI file for
  an association with the specified sound name.</p>
</blockquote>

<p>So if you want to play a file on disk, you have to include the <code>SND_FILENAME</code> flag, for example:</p>

<pre><code>if (handler == 0) op = SND_ASYNC | SND_FILENAME;
if (handler == 1) op = SND_LOOP | SND_ASYNC | SND_FILENAME;
</code></pre>

<p>Something else, this line is probably wrong:</p>

<pre><code>file = LPCTSTR(file_old);
</code></pre>

<p>If you don't compile with Unicode, <code>file_old</code> is compatible with <code>file</code> so you don't need to cast. If you compile with Unicode, a typecast is not sufficient.</p>
",5
29203805,29203234,0,"<p>your sir request you do <code>Merging two arrays in ascending order</code>. so i think you should return a new array, fill with array1 and array2's element, and the elements should be ascending order. here is a implement.(suppose your input arraies is already in ascending order.)</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int mergeArrays(int array1[],int size1,int array2[],int size2, int outArray[]);
int main()
{
    const int size1=8;
    const int size=12;
    int arrayA[size1]={10,25,37,49,50,51,55,60};
    int arrayB[size]={2,5,26,27,29,32,40,45,70,80,90,95};
    int outArray[size1+size];
    int len = mergeArrays(arrayA,size1,arrayB,size, outArray);
    cout &lt;&lt;"" ""&lt;&lt; len;
    for (int i = 0; i&lt; size1+size; ++i){
      cout &lt;&lt;"" "" &lt;&lt; outArray[i];
    }
}

int mergeArrays(int array1[], int size1, int array2[], int size2, int outArray[])
{
  int i=0, j=0, k=0;
  int retSize = size1+size2;
  while (k&lt;retSize){
    if (i==size1){// only left array2, copy it
      for (; j&lt;size2; ++j){ 
        outArray[k++] = array2[j];
      }
    }else if (j == size2) { // only left array1, copy it
      for (; i&lt;size1; ++i){
        outArray[k++] = array1[i];
      }
    }
    else if (array1[i] &gt; array2[j]){ // copy the min value to outArray
      outArray[k++] = array2[j++];
    }else{
      outArray[k++] = array1[i++];
    }
  }
  return k;
}
</code></pre>

<p>now, let's look at your first code:</p>

<pre><code>int mergeArrays(int array1[],int size1,int array2[],int size2)
{
    int size3=size1+size2;
    int *array3=new int[size3];
    int k=0;
    for(int i=0;i&lt;size1;i++)
    {
       array3[k]=array1[i]; // k is not changed, so you just assign array1's each value to array3[0]
       cout&lt;&lt;"" ""&lt;&lt;array3[k];
   }
   int j=0;

   // what's the purpose of this loop?
   // and in loop, you don't use i, you just repeat set array3[0] = array2[0]!!
   for(int i=size1;i&lt;size2;i++) 
   {
        array3[k]=array2[j];
   }
   for(int i=size1;i&lt;size2;i++) // if array2's length bigger than array1's, will enter this loop. 
   {
        for(int j=0;j&lt;size2;j++)
        {
            array3[i]=array2[j]; // this just repeat assign array2's each value to array3[i]!!
            cout&lt;&lt;"" ""&lt;&lt;array3[i];
        }
            cout&lt;&lt;endl;
            delete[]array3;     
            return array3[k++];  // you delete array3, but at here you access it!! this will crash! 
            // also, in this for i loop, you have return, so it will only execute once.
    }
   // reach function end and no return if not enter for loop.
}
</code></pre>

<p>I haven't looked at your second code. I think you still need to do more study.</p>
",0
29165637,29165323,0,"<p>If you're looking to just default initialize a <code>len</code> by <code>len</code> matrix you can do this:</p>

<pre><code>vector&lt;vector&lt;float&gt;&gt; cost(len, vector&lt;float&gt;(len));
</code></pre>

<p>This uses the <a href=""http://www.cplusplus.com/reference/vector/vector/vector/"" rel=""nofollow"">fill constructor</a> to create <code>len</code> <code>vector&lt;float&gt;</code>s, with each of those <code>vector&lt;float&gt;</code>s being of size <code>len</code> with defaulted values (<code>float()</code>).</p>
",0
29165378,29165323,1,"<p>Edit: This answers the original question posted.</p>

<p>Assuming C++11 support, it should be</p>

<pre><code>vector&lt;vector&lt;float&gt; &gt; cost = {
    { 1.000000000, 2.000000000, 3.000000000 },
    { 1.000000000, 1.414213562, 2.236067977 },
    { 1.414213562, 1.000000000, 1.414213562 }
};
</code></pre>
",5
32387369,32383461,3,"<p>A <a href=""http://en.cppreference.com/w/cpp/language/function-try-block"" rel=""nofollow"">function-try-block</a> is a <code>try</code> block that wraps <em>outside</em> the entire body of a function or constructor, rather than just a section of code <em>inside</em> of the body.</p>

<p>In the case of a constructor, it allows you to catch an exception that is thrown while initializing base classes and data members within the <em>initialization list</em>.  If such an exception is thrown, you can <code>catch</code> it and process the error as needed, but you cannot <code>return</code> from the <code>catch</code> block.  When execution reaches the end of the <code>catch</code> block, the current exception is automatically rethrown.  Before the <code>catch</code> is entered, any base class and data member that was successfully constructed before the initial exception was thrown has already been destructed to prevent leaks.</p>

<p>As the standard says:</p>

<blockquote>
  <p>If a <code>return</code> statement appears in a handler of the function-try-block of a constructor, the program is ill-formed.</p>
</blockquote>

<p>In this case, the <em>handler</em> is referring to a <code>catch</code> block of the <code>try</code> block.</p>

<p>For example:</p>

<pre><code>int checkValue(int value)
{
    if (value == 1)
        throw std::runtime_error(""illegal value"");
    return value;
}

struct A
{
    std::string str;
    int value;

    A(int i) try : str(""hello""), value(checkValue(i))
    {
        // constructor body here ...
        // 'return' is OK here!
    }
    catch (...)
    {
        // do something here (log the error, etc)...
        // 'return' is illegal here!
    }
};
</code></pre>

<p>Notice how the <code>try</code> is before the <em>initialization list</em>, and the <em>body</em> of the constructor is inside of the <code>try</code> block.</p>

<p>If <code>checkValue()</code> throws an exception, the construction of <code>A</code> is aborted, automatically destructing <code>str</code> in the process.</p>

<p>You could accomplish the same thing without using a <em>function-try-block</em>:</p>

<pre><code>int checkValue(int value)
{
    if (value == 1)
        throw std::runtime_error(""illegal value"");
    return value;
}

struct A
{
    std::string str;
    int value;

    A(int i)
    {
        try
        {
            str = ""hello"";
            value = checkValue(i);
            // 'return' is OK here!
        }
        catch (...)
        {
            // do something here (log the error, etc)...
            // 'return' is OK here! But then the constructor
            // would not be aborted...
            throw;
        }
    }
};
</code></pre>

<p>Where <em>function-try-block</em> is commonly used is when you want to catch/log exceptions that are thrown in things that <em>cannot</em> be invoked inside the normal constructor <em>body</em>, only in the <em>initialization list</em>, such as base class constructors and data member constructors.</p>
",0
31886529,31886339,0,"<p>Yes, I believe you're right.</p>

<p>Unfortunately, the language for template argument deduction in the standard is so incredibly verbose, I daren't even begin trying to prove this as a fact.</p>
",2
33006456,33006396,1,"<p>Move declaration of your variables into a scope inside the loop, so they will be reinitialized on each pass.</p>

<pre><code>int main() {

do {
//new scope
{
int numA, numB, numC;
char charA = 'A', charB = 'B', charC = 'C';

// Randomly assigning some numbers between 1-3 range into numA, numB and numC

...

// Converting the integers above into chars depending on the random numbers

switch (numA)
{
  case 1:
  numA = charA;
  break;

  case 2:
  numA = charB;
  break;

  case 3
  numA = charC;
  break;
}

switch (nu...

...

// A lot of IFs and SWITCHs that consistently changes the values above within themselves.

...

// Taking 1 input from user to re-execute the program
}//end of scope
} while (input == 1)
</code></pre>

<p>However you should understand, that usage of uninitialized variables is undefined behavior and should always be avoided. </p>

<p>Also your char variables initialization (<code>char charA = 'charA'</code>) is completely invalid. You could not store 6 character string (5 characters and null terminator) in one character variable. You either should use <code>char*</code> or this is simple typographical error and it should be <code>char charA = 'A'</code>.</p>
",1
33006478,33006396,0,"<p>You initialized all chars to 'c'. As you are initialising all chars to 'charA', 'charB' &amp; 'charC' but while initialising chars it need only one character like <code>char ch1= '6', ch2='\n' ;</code>
As all the initializers have first letter common that is 'c'. That's why all initialized to 'c'.<br>
Also you forgot the semicolon after <em>while</em>() of do.<br>
Also you are using numA as switch control variable. &amp; inside switch statement you are changing value inside numA. This is not wrong, but bad practice. Sorry for many edit, as I'm on stackexchange app I need to see question many times.</p>
",0
32971928,32968993,0,"<p>Try This one. This is a much simple If Else condition but based on your requirements, it does not need to be dynamic</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

char Convert(int input)
{ char ToBeReturn = ' ';

if (input == 100)
{
    ToBeReturn = 'A';
}
if (input == 200)
{
    ToBeReturn = 'B';
}
if (input == 300)
{
    ToBeReturn = 'C';
}
if (input == 400)
{
    ToBeReturn = 'D';
}

return ToBeReturn;
}


void main()



{ int rand_val1, rand_val2, rand_val3;

cout &lt;&lt; ""Enter Value 1: "";
cin &gt;&gt; rand_val1;
cout &lt;&lt; ""Enter Value 2: "";
cin &gt;&gt; rand_val2;
cout &lt;&lt; ""Enter Value 3: "";
cin &gt;&gt; rand_val3;

cout &lt;&lt; Convert(rand_val1) &lt;&lt; "" "" &lt;&lt; Convert(rand_val2) &lt;&lt; "" "" &lt;&lt; Convert(rand_val3) &lt;&lt; endl; }
</code></pre>
",0
32971001,32968993,0,"<p>Because you told there are a lot of such conversion, so I dont think any function / std::cout type casting suit you. You can use a wrapper class here. Just declare all the rand_valXXX as Integer class.</p>

<p>If every rand_val have different conversion logic, then I think you have no way, but cast it every time when you print.</p>

<pre><code>#include &lt;iostream&gt;

class Integer
{
public:
    Integer( int a ) : _a(a){}

    operator int() const { return _a; }

private:
    int _a;
};

std::ostream&amp; operator&lt;&lt; ( std::ostream&amp; out, const Integer&amp; val )
{
    switch( val )
    {
    case 100:
        out &lt;&lt; 'A';
        break;
    case 200:
        out &lt;&lt; 'B';
        break;
    default:
        out &lt;&lt; (int)val;
    }
    return out;
}

int main()
{
    Integer a = 100;
    std::cout &lt;&lt; a;

    a = 200;
    std::cout &lt;&lt; a;

    a = a + 100;
    std::cout &lt;&lt; a;

    a = a / 200;
    std::cout &lt;&lt; a;
}
</code></pre>
",0
32969871,32968993,1,"<p>How about defining an ""exception list"" ?
<a href=""http://cpp.sh/7pjdk"" rel=""nofollow"">Here's an example</a></p>

<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main ()
{
    const unordered_map&lt;int, char&gt; exceptionList = {
        { 100, 'A'},
        { 200, 'B'},
        { 300, 'C'},
        { 400, 'D'},
        { 500, 'E'}
    };

    int rand_val1 = 100;

    if (exceptionList.find(rand_val1) == exceptionList.end())
    {
        cout &lt;&lt; rand_val1 &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; exceptionList.at(rand_val1) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<p>Or <a href=""http://cpp.sh/84cq"" rel=""nofollow"">with a lambda</a>:</p>

<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main ()
{
    const std::unordered_map&lt;int, char&gt; exceptionList = {
        { 100, 'A'},
        { 200, 'B'},
        { 300, 'C'},
        { 400, 'D'},
        { 500, 'E'}
    };

    int rand_val1 = 100;
    int rand_val2 = 101;

    const auto charOrInt = [&amp;exceptionList] (const int val) -&gt; string {
        if (exceptionList.find(val) == exceptionList.end())
        {
            return to_string(val);
        }
        else
        {
            return string{exceptionList.at(val)};
        }
    };

    cout &lt;&lt; charOrInt(rand_val1) &lt;&lt; "" "" &lt;&lt; charOrInt(rand_val2) &lt;&lt; endl;

    return 0;
}
</code></pre>
",0
32470935,32470890,4,"<p>When sent to some terminal programs, <code>\a</code> indeed plays an audible note.  Some terminals allow that to be disabled, or e.g. changed to flash the screen.  It only tends to work in non-GUI text-mode terminals.  There are no other such codes that are anywhere near as common across terminals, though you could check the documentation for your particular terminal program.</p>

<p>More generally, you'll have to look for some system specific mechanism to play notes, as the C++ language and Standard Library do not provide any such facilities.</p>
",0
31829506,31821788,1,"<p>The problem is that is any used can unload a driver, they'd be able to interfere with other users. Drivers are a shared resource.</p>

<p>""Signing"" the executable makes a few warnings less scary but doesn't affect security. </p>
",0
31846109,31845959,1,"<p>Are you using Visual Studio? It seems like your linker can't find your main function. Right click on your project, go to Properties -> Configuration Properties -> Linker -> System and try changing the Subsystem to either Console or Windows, whichever one works (<a href=""https://stackoverflow.com/questions/4845410/error-lnk2019-unresolved-external-symbol-main-referenced-in-function-tmainc"">source</a>). I don't know which supposed fixes you've tried, so hopefully this one solves your issue.</p>

<p>I'm new to Stackoverflow so I hope I did this right and that this helps!</p>
",0
30138652,30137775,3,"<p>There are several answers. It would help to know why you actually want to hide the implementation. Here's the reasons why you might want to do this I can think of offhand.</p>

<ol>
<li><p><strong>Protecting trade secrets:</strong> Forget it. To be able to execute your code, the computer has to be able to run it. Effectively you can strip away comments, method names and variable names by compiling the code as a static library, even run an obfuscator over it to obscure the control flow (at the cost of slowing it down by adding unneeded jumps), but in the end the code (or the machine code generated from it) <em>has</em> to stay sort of readable or it couldn't be executed.</p></li>
<li><p><strong>Make it easier to use your code:</strong> If you have several source files and might add more files, and you want your clients to just be able to drop in one file to get all the newest changes without having to add individual source files, compile it as a static or dynamic library. Then you can hand someone the library plus the headers and they can just use them.</p>

<p>You can also create an ""umbrella header"" that includes all the other headers. That way, clients can simply add the path to your library's <code>includes</code> folder to their compiler invocation/project file and include the one header, which includes all others. If you add or split up a header, you just change the umbrella to include the new headers and all projects that use it keep working.</p>

<p>Note that using a library will limit your clients: They can't step through your code in the debugger easily, they can't fix and compile stuff easily. If they need your code to run on a new platform, or want to use different optimization settings in the compiler, they can't just recompile it.</p>

<p>On the other hand if you plan to sell your library, you might want to hold on to your sources. Customers who don't care about the security of having the code if you ever go out of business can get a cheaper version of the library without the source code, you can charge them extra if they want any of the other features by making them buy a version for the new platforms that <em>you</em> coded for them, etc.</p></li>
<li><p><strong>Prevent clients from accidentally relying on implementation details:</strong> You don't really need to do anything for this except split up your code into public and private files. Usually your implementation file is private and your headers are public, but you may have some private headers for internal classes.</p>

<p>Since C++ does not allow defining instance variables or methods that aren't declared in the header's class declaration like other languages do that support <em>categories</em> or <em>class extensions</em>, you may have to resort to the <em>Private Implementation</em> (aka 'pimpl') pattern.</p>

<p>What this usually means is that you declare one class that defines the public API that simply wraps a pointer to the actual class that contains the real implementation and calls through to it. It usually only has one instance variable, <code>pimpl</code>, which is the pointer to the other class. You simply forward-declare the private class using <code>class Foo;</code> and thus your clients' code doesn't know anything about the private class (unless they explicitly peek into the implementation file or private header, e.g. when fixing a bug).</p></li>
<li><p><strong>Create a single-file class</strong> I mention this last because it is generally a stupid thing to do, but just in theory, you could also move the implementation file's content into the header. Then clients only need to include the header and get all the sources. This has lots of downsides, though, like making code harder to read, slowing down compile times, and requiring the client to deal with duplicate definitions of the class caused by including the file from several <code>.cpp</code> files. In short: Don't do it.</p></li>
</ol>
",1
29163687,29163477,0,"<p>I suspect that <code>factorial</code> is returning an <code>int</code>. If <code>int</code> is 32 bit (very common), then <code>factorial</code> will overflow once the argument reaches 13 (<code>i = 5</code> in your case). Signed integer overflow is <em>undefined behaviour</em> in C++.</p>

<p>You could use a <code>std::uint64_t</code> (an unsigned 64 bit integer). This will allow you to evaluate a few larger factorials.</p>

<p>For more reference, see <a href=""https://stackoverflow.com/questions/2098319/calculating-large-factorials-in-c"">Calculating large factorials in C++</a></p>

<p>Better still, use a <em>recurrence</em> relation between your Taylor terms.</p>
",0
29175019,29174998,1,"<p>You are initializing <code>p</code> using a copy constructor.</p>

<p>Instead of <code>polygon p = q;</code>, try:</p>

<pre><code>polygon p;
p = q;
</code></pre>
",8
33037544,33037415,0,"<p>The newline will be eaten up when extraction succeeds (whether the extracted integer is positive or not).</p>

<p>It won't be eaten up when extraction fails.</p>
",7
30139017,30138020,3,"<p>You can do this with 32-bit arithmetic. You just have to reduce mod k after every multiplication, to stop the numbers getting too big:</p>

<pre><code>int pow_mod_k (int a, int b, int k) {
    int result = 1 ;
    while (b--) {
       result *= a ;
       result %= k ;
    }
    return result ;
}
</code></pre>

<p>As jadhachem points out in a comment, you can make this faster by using a squaring ladder. But for such small numbers, it would hardly be worth it.</p>
",0
31883902,31883831,6,"<p>Your functions can <code>return</code> values so you can pass variables to other functions, like so</p>

<pre><code>std::pair&lt;int, int&gt; function1() {
    int a = 1;
    int b = 2;
    return {a, b};
}

std::pair&lt;int, int&gt; function2() {
    int c = 3;
    int d = 4;
    return {c, d};
}

void function3 () {
    int a, b, c, d;
    std::tie(a, b) = function1();
    std::tie(c, d) = function2();
    std::cout &lt;&lt; a;  
    std::cout &lt;&lt; b;  
    std::cout &lt;&lt; c;  
    std::cout &lt;&lt; d;  
}
</code></pre>

<p><a href=""http://cpp.sh/8bl5k"">Working demo</a></p>
",5
31883911,31883831,4,"<p>Make the functions methods of a class, and the variables attributes of the class.</p>

<pre><code>class A
{
public:
int a;
int b;
int c;
int d;

void function1() { 
  a = 1;
  b = 2;
}

void function2() {
  c = 3;
  d = 4;
}

void function3 () {
  cout &lt;&lt; a;  
  cout &lt;&lt; b;  
  cout &lt;&lt; c;  
  cout &lt;&lt; d;  
}
};
</code></pre>
",3
31883946,31883831,4,"<p>Use pass-by-reference:</p>

<pre><code>int main() {
    int a;
    int b;
    function1(a, b);

    int c;
    int d;
    function2(c, d);

    function3(a, b, c, d);

    return 0;
}

void function1(int&amp; a, int&amp; b) { 
  a = 1;
  b = 2;
}

void function2(int&amp; c, int&amp; d) {
  c = 3;
  d = 4;
}

void function3(int a, int b, int c, int d) {
  cout &lt;&lt; a;  
  cout &lt;&lt; b;  
  cout &lt;&lt; c;  
  cout &lt;&lt; d;  
}
</code></pre>
",3
31884727,31883831,2,"<p>You can pass them by reference</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
void function1(int &amp;a,int &amp;b) {
    a = 1;
    b = 2;

}

void function2(int &amp;c, int &amp;d) {
    c = 3;
    d = 4;
}

void function3(int a1,int b1,int c1,int d1) {

    cout &lt;&lt; a1;
    cout &lt;&lt; b1;
    cout &lt;&lt; c1;
    cout &lt;&lt; d1;
}
int main(){
    int a = 0, b = 0, c = 0, d = 0;
    function1(a, b);
    function2(c, d);
    function3(a, b, c, d);



}
</code></pre>
",0
34197741,34197492,4,"<p>Just using templates in a function to create a generic class and call some function in it is simple, the problem you have is the <code>/*eventual params*/</code> part. You can solve that with something called <a href=""http://en.cppreference.com/w/cpp/language/parameter_pack"" rel=""nofollow""><em>parameter packs</em></a>, also called <a href=""https://en.wikipedia.org/wiki/Variadic_template"" rel=""nofollow"">variadic templates</a>.</p>

<p>Perhaps something like this:</p>

<pre><code>template&lt;typename T, typename ...A&gt;
T* create(A... args)
{
    T* object = new T(std::forward&lt;A&gt;(args)...);
    if (object-&gt;Initialize())
        return object;

    delete object;
    return nullptr;
}
</code></pre>

<p>With your example class <code>Next</code> can be used like</p>

<pre><code>Base* pointer_to_next = create&lt;Next&gt;(/* eventual arguments */);
</code></pre>

<p>Of course, it requires C++11.</p>
",1
29193558,29193522,5,"<p>Your <code>Pi</code> definition contains a semi-colon, <code>;</code>.</p>

<p>Upon substitution, the compiled code is</p>

<pre><code>cout &lt;&lt;  3.1415; &lt;&lt; endl;
</code></pre>

<p>When it should be</p>

<pre><code>cout &lt;&lt;  3.1415 &lt;&lt; endl;
</code></pre>

<hr>

<p>In other words, do</p>

<pre><code>#define Pi 3.1415
</code></pre>

<p>Without the semi colon.</p>

<hr>

<p>Though, better still is to not use <code>#define</code> for things like this.</p>

<p>See for example <a href=""https://stackoverflow.com/questions/1727881/how-to-use-the-pi-constant-in-c"">How to use the PI constant in C++</a> for suggestions.</p>
",0
29193568,29193522,1,"<p>Your <code>Pi</code> definition is a macro not a constant and it expands to a superfluous <code>;</code> in your output statement</p>

<pre><code>#define Pi 3.1415; // &lt;&lt;
</code></pre>

<p>will become </p>

<pre><code>cout &lt;&lt; 3.1415; &lt;&lt; endl;
           // ^
</code></pre>

<p>and you end up with a compilation error.</p>

<p>To declare a constant correctly in C++, you should write</p>

<pre><code>const double Pi = 3.1415;
</code></pre>
",0
29193573,29193522,1,"<p>You need to remove <code>;</code> after <code>3.1415</code>. 
The code </p>

<p><code>#define Pi 3.1415;</code></p>

<p>implies that whenever you use <code>Pi</code>, it will be replaced by <code>3.1415;</code>. Notice how the semicolon also gets included along with the double. So when you use <code>cout&lt;&lt;Pi&lt;&lt;endl</code>, the compiler reads it as <code>cout&lt;&lt;3.1415;&lt;&lt;endl</code>, which you can see will give an error.</p>
",0
29197830,29197739,0,"<p><code>std::istream::oprator&gt;&gt;()</code> functions stop reading when they encounter white space. You can use <code>std::getline()</code> to read the entire line.</p>

<pre><code>for (int i = 0; i &lt; arraySize; i++)
{
    std::getline(inputFIle, b[i].visitTeam);
    inputFile &gt;&gt; b[i].homeScore &gt;&gt; b[i].visitScore;

    // Now, make sure you skip everything in the line.
    // Otherwise, the next call to getline() will return an
    // empty string.
    inputFile.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
}
</code></pre>
",3
33511631,33511588,2,"<p>I believe short holds less bits than required to show the FF. Think of it like a <code>0xffff</code> mask, which thus hides all bits higher than that.</p>

<p>Edit: Ok, in more depth, the int and short share the same location in memory. But when you specify the format, you'll get the memory data in that format (in memory, it's just a bunch of bits anyway).</p>

<p>So the whole Union takes up only the size of the biggest component; the int in this case.</p>

<p>Pretend it starts at 0x00000000.</p>

<p>You then set the int (the whole memory segment) to 0xFF0001.</p>

<p>Now it looks like 0x00FF0001.</p>

<p>Now you want to print out the data as a short, but a short normally only looks like 0x0000. So in this case we ignore the top half 0x00FF, and our short is the remaining part: 0x0001.</p>

<p>Hence you get the output of 1.</p>
",0
33511706,33511588,1,"<p>A union is a data structure where <a href=""https://en.wikipedia.org/wiki/Union_type#C.2FC.2B.2B"" rel=""nofollow"">the data can be viewed different ways</a>. The compiler gives enough memory to <code>c</code> to store its <em>longest</em> entry. When you assign <code>0xFF0001</code> to <code>c.i</code>, that also assigns <code>c.s</code>, because they overlap. When you tell it to print <code>c.s</code>, it prints the memory, but assumes you only want to see a <code>short</code>. That's why you see only <code>1</code> and not the other characters.</p>

<blockquote>
  <p>second question; is there a way to compute <code>a ^= b</code>; without converting <code>a</code> and <code>b</code> in binary?</p>
</blockquote>

<p>Yes; in fact, that's what the program does (that's <strong>hexadecimal</strong> format, not binary). Just assign the corresponding decimal values, if you like, and <code>a ^= b</code> will work exactly the same way. Writing it in binary or hexademical format just makes it easier to read.</p>
",3
29201422,29201367,-1,"<p>Not sure how you think that piece of code would work, bottom line is you can't declare arrays of non-constants in C++. Especially uninitialized ones.</p>
",0
29201519,29201367,0,"<p>In C++, variable length arrays are not allowed. <code>W1</code> and <code>W2</code> needs to know both of its dimensions at <em>compile time</em>. </p>

<p>Use </p>

<p><code>std::vector&lt;std::vector&lt;double&gt; &gt; W1, W2 ;</code> </p>

<p>if you want to initialize row and col at runtime.</p>

<pre><code>class NNetwork
{
    public:
    NNetwork(size_t ni, size_t nh, size_t no ): NI(ni),NH(nh),NO(no)
    {  }

    private: 
    const size_t NI, NH, NO; 

    vector&lt;vector&lt;double&gt; &gt; W1, W2;  
};
</code></pre>

<p>For compile time you can use templates or <code>std::array</code><sub><em>C++11</em></sub> like :</p>

<pre><code>template&lt;size_t NH, size_t NI, size_t NO&gt;
class NNetwork
{
private:
    double W1[NH][NI]; // or std::array&lt; std::array&lt; double, NH&gt;, NI &gt; W1;
    double W2[NO][NH];
};
</code></pre>

<p>Then,</p>

<pre><code>NNetwork&lt; 1,2,3&gt; W1 ;
NNetwork&lt; 7,8,9&gt; W2 ;
</code></pre>
",0
31897226,31897090,0,"<p>use <code>char again;</code> instead of <code>int again;</code></p>

<p>in your code <code>again</code> is <code>int</code> and when in <code>(again == 'y' || again == 'n')</code>you compare <code>again</code> (an <code>int</code>) with a <code>char</code>, that does not make sense</p>
",0
31897314,31897090,0,"<p>You need to change the again variable to a char datatype because you need to store text. Something like this:</p>

<pre><code>char again;
</code></pre>

<p>You also need to change the while statement to:</p>

<pre><code>while(again != ""n"");
</code></pre>

<p>Or</p>

<pre><code>while(again == ""y"");
</code></pre>
",0
31897808,31897090,1,"<p>OK. So the OP is using an <code>int</code> where they should have used a <code>char</code>. That covers the immediate problem. <code>int again</code> should be <code>char again</code>.</p>

<p>But there is an important point the other answers have missed.</p>

<pre><code>int again;
cin &gt;&gt; again;
</code></pre>

<p>The user input will be converted into an integer as required by <code>again</code>. Inputting y or n fails to convert to an integer as neither y nor n are numbers and cannot be converted. <code>again</code> remains unchanged, keeping whatever junk value happened to be sitting at that spot in memory and <em>might actually be a y or an n</em>, but more importantly <code>cin</code> is now in an error state that needs to be cleared before continuing. </p>

<p><code>cin</code> would have notified the OP of this if it had been tested. So let's test it.</p>

<pre><code>int again;
if (cin &gt;&gt; again)
{
     // got good input. Do something with it.
}
else
{
     // got bad input. 
     cin.clear();
     // that bad input is still in the buffer and needs to be removed
     cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
     // the above line will wipe out everything to the end of the stream or 
     // end of line, whichever comes first. 
}
</code></pre>

<p>Why this is important: Because the OP is doing a lot of numeric input with <code>cin</code> and none  of it is checked for validity. For example:</p>

<pre><code>cout &lt;&lt; ""Please enter a number [1 or 2]"" &lt;&lt; endl;
cin &gt;&gt; a_number;
</code></pre>

<p>The program is broken completely and cannot exit without a kill signal if the user types in anything but a number.</p>

<p>Always check the error state and return codes. They are there to help. Always validate user input before using it. Users are evil and will try to break your program. Don't let them.</p>
",0
29189599,29189187,0,"<p>It's not clear what you mean by ""issues distinguishing between AM and PM"". Is it that you enter a time in the afternoon, e.g. 12pm, then add minutes and it becomes am? That's because minutesAdded() is using the number of minutes to determine whether it's the morning or evening. You would be better off calculating the time -- meaning the whole time, hours and minutes, not just minutes -- before printing out the time. You have made a start with</p>

<pre><code>nTime = minutes + addedMinutes;
</code></pre>

<p>but don't stop there. As long as the accumulated minutes value is >= 60, you have to take off 60 minutes and bump the hours up by one. Not just once. If you add 122 minutes, you have to take TWO lots of 60 minutes off. Does that sound like a while loop? No, not unless you want the teacher to laugh at your code! Look up the operators for division and remainder. You're trying to do the calculation and the output in one step. That's difficult. Work out the value first, then print it afterwards.</p>

<p>Oh, and by the way, don't forget about what happens if you add 200 minutes to 23:00...</p>

<p>When you are working out the time after adding the minutes, why do you not use the hours and minutes variables? If you add some minutes to your time, the time should be changed, meaning the minutes and/or hours members should be updated. </p>

<p>You should have a method to add the minutes -- not to read the amount to be added, and then print out the time with the minutes added, just a method to add the minutes.</p>

<pre><code>void Time::incrementMinutes(int nMinutes)
{
    ...the code to update hours and minutes variables correctly 
       is left as an exercise...
}
</code></pre>

<p>Then after you have got addedMinutes from cin, call</p>

<pre><code>incrementMinutes(addedMinutes);
</code></pre>

<p>Then you could make a method to print the time, printTime() which sends the time to cout. That would then be used by minutesAdded() and by militaryClock(), so you don't have to worry in BOTH places about all the conditions for whether it's AM or PM. You only have to get that right in printTime().</p>

<p>Now, about the structure of your program.</p>

<p>First, the constructor should construct the object, set everything in it. It gets called automatically when an instance is constructed, to set up the whole instance. It's not the way to just set one field. Please write a different method to set the minutes to 0 if you are not constructing a Time object. </p>

<p>Maybe setMinutes was to have been that method. But setMinutes() is</p>

<pre><code>void Time::setMinutes()
{
    this -&gt; minutes = minutes;
}
</code></pre>

<p>That doesn't do anything. Within the method of an object, the member name refers to the member of the object (unless overridden by the same name in a closer scope). So within this function, 'minutes' means the same as 'this->minutes'. </p>

<p>Maybe you intended something like this instead?</p>

<pre><code>void Time::setMinutes(int newMinutes)
{
    minutes = newMinutes;
}
</code></pre>

<p>That would at least set this->minutes to a certain value. Then, to set minutes to 0, you don't call Time(), you call setMinutes(0).</p>

<p>Finally, you can tell cout to use 2 characters for minutes, by piping setw(2) before the number; you can tell it to use the value '0' for the extra character by piping in setfill('0'). You have to #include  to get this stuff. So </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

int main()
{
  cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; 1 &lt;&lt; "":"" &lt;&lt; setw(2) &lt;&lt; 2 &lt;&lt; endl;
}
</code></pre>

<p>will output 
01:02
The setfill('0') means any padding will be done with '0'; the setw(2) means the single next thing output will be padded to 2 chars.</p>

<p>Hope that helps... without doing your homework for you...</p>
",0
34211767,34211560,1,"<p>You have stack overflow in function:</p>

<pre><code>int pow(int ap, int nt)
{
  if (nt == 0)
    return 1;
  else
    return ap *= pow(ap, --nt);
}
</code></pre>

<p>for very large nt it will enter too deeply in recursion causing SO</p>
",0
34211929,34211560,0,"<p>You are trying to compute exact integer 2 to the power <code>x</code> for some rather large values of <code>x</code>.  No ordinary data type can hold that value.  But if you had some data type holding that value, then testing whether the result minus one is prime by that simplistic method would take more time than the life of the universe.  </p>

<p>You are attacking a very hard and very well studied problem, and using nothing but naive ignorance as a tool.</p>

<p><a href=""https://primes.utm.edu/mersenne/"" rel=""nofollow"">https://primes.utm.edu/mersenne/</a></p>
",0
34081329,34066467,2,"<pre><code>template&lt;class T&gt;

        sp&lt;T&gt;&amp; sp&lt;T&gt;::operator = (const sp&amp; q)
        {
            if(*this==q) return *this;
            if(p!=NULL) delete p;
            p = q.p;
            return *this;
        } 
</code></pre>

<p>In the Above Function The Pointer 'p' gets deleted and next instruction tries to assign a value 'q.p' to the deleted 'p',which can cause problem.</p>

<p>I made changes to above function as given below.</p>

<pre><code>template&lt;class T&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::operator = (const sp&amp; q)
{
    if(*this==q) return *this;
    if(p!=NULL) p = q.p;
    return *this;
}
</code></pre>

<p>This worked out well.</p>
",2
34081968,34066467,0,"<p>You have no copy constructor, so the default copy constructor will just copy the pointer, giving you two smart pointer objects that point at the same object.</p>

<p>Similarly, you assignment operator just copies the pointer, giving you two smart pointer objects that point at the same object.</p>

<p>Whenever either of these happens, the destructor for the first smart pointer will delete the object, leaving the other smart pointer dangling.  When the second smart pointer is destroyed, it deletes the already deleted pointer again, causing undefined behavior.</p>

<p>When you copy or assign a smart pointer, you need to either also clone the pointed at object, or have a reference count somewhere that tracks how many pointers point at the same object.  In this latter case, you only delete the object when the refcount drops to 0.</p>
",0
29482862,29482802,0,"<p>Inside your bubbleSort function where you swap two elements of the wages array, you need to also swap the corresponding elements of the empId, hours and payRate arrays. Also, you need to use a the same types for the temporary swap variables as the values you are swapping or you will lose accuracy from converting to an int.</p>

<pre><code>void bubbleSort(long empId[],int hours[],double payRate[],double wages[],int size)
{
    bool swap; 
    double temp1; 
    int temp2;
    long temp3;

    do
    {
        swap = false; 
        for (int count = 0; count &lt; (size - 1); count++)
        {
            // compare the wages, because that is what you are sorting on
            if (wages[count] &gt; wages [count + 1])
            {
                // swap all the data between the two array positions:
                temp1 = wages[count]; 
                wages[count] = wages[count + 1]; 
                wages[count + 1] = temp1; 

                temp1 = payRate[count]; 
                payRate[count] = payRate[count + 1]; 
                payRate[count + 1] = temp1;

                temp2 = hours[count]; 
                hours[count] = hours[count + 1]; 
                hours[count + 1] = temp2; 

                temp3 = empId[count]; 
                empId[count] = empId[count + 1]; 
                empId[count + 1] = temp3; 

                swap = true; 
            }
        }

    } while (swap); 
}
</code></pre>
",2
29482965,29482802,0,"<p>Create a Helper Function to Swap </p>

<pre><code>void swaphelper(long (&amp;emp)[] , doubles(&amp;wages)[] ,doubles(&amp;payrate)[] , int(&amp;hours)[],  int fromIndex , int toIndex) 
{

   emp[fromIndex] = emp[fromIndex]^emp[toIndex];
   emp[toIndex] = emp[toIndex]^emp[fromIndex];

   wages[fromIndex] = wages[fromIndex]^wages[toIndex];
   wages[toIndex] = wages[toIndex]^wages[fromIndex];

   payrate[fromIndex] = payrate[fromIndex]^payrate[toIndex];
   payrate[toIndex] = payrate[toIndex]^payrate[fromIndex];

   hours[fromIndex] = hours[fromIndex]^hours[toIndex];
   hours[toIndex] = hours[toIndex]^hours[fromIndex];

}


void bubbleSort(long empId[],int hours[],double payRate[],double wages[],int size)   
{
bool swap; 
int index; 

do
{
    swap = false; 
    for (int count = 0; count &lt; (size - 1); count++)
    {
        if (wages[count] &gt; wages [count + 1])
        {
            swaphelper( emp , wages , pirate , hours , count , count+1); // can be abstracted to a struct
            swap = true; 
        }
    }

} while (swap); 
}
</code></pre>
",0
34246290,34245867,0,"<pre><code>char** data= new char*[2];
data=get_conn();
</code></pre>

<p>Here, you have <em><a href=""https://en.wikipedia.org/wiki/Memory_leak"" rel=""nofollow"">memory leak</a></em>. You allocate <code>data</code> but immediately it gets overwritten with the value returned from <code>get_conn()</code>.</p>

<p>Another problem is you are returning a local variable. <code>mystring</code> is a local array whose lifetime is only its enclosing block (i.e. <code>get_conn()</code> function here). So you can't return it. This leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behaviour</em></a>. You can do the allocation in <code>get_conn()</code> itself and return it:</p>

<pre><code>const char** get_conn(void);

int main(void){
 const char** data;
 data=get_conn();

 ....
}

const char** get_conn(){
 const char **mystring = new const char*[2];

 mystring[0]=""One thing"";
 mystring[1]=""another thing"";

 return(mystring);
}
</code></pre>
",0
31245234,31244884,1,"<p>Actually you have passed a funtion pointer to ab. if your intent is to pass the function ( clearly not! ) you can use the following syntax : </p>

<pre><code>float ab(float(*callback)(int),int pass) {
  callback(pass); /* It calls the function indirectly with &lt;pass&gt; */
}
</code></pre>

<p>Its great for menu creation for example if you have two options:
1. Fahrenheit to Cell
2. Fahrenheit to Kelvin it will be useful</p>

<p>You can search <strong>callback functions in C</strong> with google.</p>
",0
31244909,31244884,10,"<p><code>ab</code> takes a <code>float</code> and returns a <code>float</code>:</p>

<pre><code>float ab(float a)
</code></pre>

<p>But <code>cels</code> isn't a <code>float</code>, it's a function:</p>

<pre><code>float cels(int a)
</code></pre>

<p>You probably meant</p>

<pre><code>ab(cels(farh))
</code></pre>

<p>Or to take a temporary:</p>

<pre><code>float cur_cels = cels(farh);
cout &lt;&lt; farh &lt;&lt; cur_cels &lt;&lt; ab(cur_cels) &lt;&lt; ""\n"";
</code></pre>

<p>Side-note, <code>ab</code> should probably be named <code>kelvin</code>. </p>
",1
29234157,29233832,0,"<p>In C++, array index starts from 0. There is no need to do 'int k = i+1;', You could use i itself in the loop. </p>
",0
29233911,29233832,1,"<p>On the last iteration of the inner loop, <code>i == 4</code> and <code>k == 5</code>.</p>

<p>This means that <code>bodyVel[k]</code> is <code>bodyVel[5]</code>, which is the 6th of the 5 element array created by <code>new bodyVelocity[5]</code> (and thus is beyond the end of the array, meaning that the dereference has undefined behaviour).</p>

<p>This is the problem that valgrind is warning you about.</p>
",3
32466693,32464630,1,"<p>Can this be done better using standard library functions? Hell yes.
At the very least, </p>

<pre><code>temp = RandomizeArray[i];
RandomizeArray[i] = RandomizeArray[j];
RandomizeArray[j] = temp;
</code></pre>

<p>Is all replaced by </p>

<pre><code>std::swap(RandomizeArray[i], RandomizeArray[j]);
</code></pre>

<p>The whole process is sort-of replaced (but not quite. Almost certainly a different backing algorithm) by the <a href=""http://en.cppreference.com/w/cpp/algorithm/random_shuffle"" rel=""nofollow"">std::random_shuffle family</a>, but that would be totally defeating the point of the exercise.</p>

<p>Unless the examiner is the sort to go, ""Oh! He recognized the algorithm and suggested a time saving replacement! Excellent! Excellent!"" Look for these sorts of bosses. They are generally more fun to work for.</p>

<p>Anyway... Is The OP's solution a correct interpretation of the Pseudo Code?</p>

<p>No.</p>

<p>Take a look at <code>int j = rand() % max_i + i;</code> and run though the possible range of values for j as you proceed through the values of i. </p>

<pre><code>i = 0 : [0 .. max_i] 
i = 1 : [1 .. max_i + 1]
i = 2 : [2 .. max_i + 2]
</code></pre>

<p>Note the upper bound is moving, violating the contract of the Pseudo Code. As of i = 1, j may be outside the range of RandomizeArray and it will only get more likely from there on up.</p>

<p>Using a slight modification, <code>int j = rand() % (max_i - i) + i;</code></p>

<pre><code>i = 0 : [0 .. max_i] 
i = 1 : [1 .. max_i]
i = 2 : [2 .. max_i]
</code></pre>

<p>Extra note: <code>rand</code> sucks. <a href=""http://en.cppreference.com/w/cpp/numeric/random"" rel=""nofollow"">C++11 and better have a number of fun toys for generating much better random numbers</a>. A <a href=""http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution"" rel=""nofollow"">uniform_int_distribution</a> is probably what you'd want here. </p>
",1
29247332,29247325,1,"<p>Because you have't <strong><em>defined</em></strong> them. You only <em>declared</em> them (<code>extern</code> only declares).</p>

<p>You need to add the definitions for both <code>airports</code> and <code>flights</code> in a <code>.cpp</code> file, like so:</p>

<pre><code>vector&lt;Airport&gt; airports;
vector&lt;Flight&gt; flights;
</code></pre>

<p>Furthermore, <code>vector&lt;Airport&gt; airports;</code> is not a forward declaration, it's a definition. To forward declare <em>variables</em> you <strong>need</strong> to use the <code>extern</code> keyword.</p>
",0
29247355,29247325,3,"<pre><code>extern vector&lt;Airport&gt; airports;
</code></pre>

<p>This is a <em>declaration</em> of <code>airports</code>. It says ""Somewhere in the program is a global variable called <code>airports</code> of type <code>vector&lt;Airport&gt;</code>"".</p>

<pre><code>vector&lt;Airport&gt; airports;
</code></pre>

<p>This is a <em>definition</em> of <code>airports</code>. It creates a global variable called <code>airports</code> of type <code>vector&lt;Airport&gt;</code>. You cannot have two global variables with the same name, even if they are in different files.</p>

<p>You should know that <code>#include</code> effectively copy-pastes the whole contents of the included file into this file. So if you put a definition in a header file, and include that header file in two different source files, then you have two definitions.</p>

<p>The solution is to put the declarations in the header file (with <code>extern</code>) and the definitions in <em>one</em> source file.</p>
",2
30140137,30139572,0,"<p>Ok, as from the link in your comment we have the following constraint</p>

<pre><code>m and n (1 &lt;= m &lt;= n &lt;= 1000000000, n-m&lt;=100000)
</code></pre>

<p>So your algorithm will most probably fail in line</p>

<pre><code>int a[n+1];
</code></pre>

<p>for large numbers n:</p>

<p>array of n = 1000000000 (1e9!) ints (4 bytes) needs 3.7GB of RAM!</p>

<p>So your approach doesn't work well for large numbers as it consumes too much RAM! </p>

<p>(I can reproduce it on local computer, just add <code>cout</code> message before and after definition of the array)</p>

<p><strong>Edit</strong></p>

<p>To make this algorithm work you should reserve memory on heap (instead of stack) and minimize size by <code>int -&gt; unsigned char</code> at least:</p>

<pre><code>...
while(t--)
{
 cin&gt;&gt;m&gt;&gt;n;

 unsigned char *a = new unsigned char[n+1];
 ...
 delete[] a;
}
</code></pre>
",1
29223144,29222973,0,"<p>Use template class specialization, I would say</p>

<pre><code>template &lt;&gt; class A&lt;vector&lt;int&gt;&gt;
{
    // all your old code here
}
</code></pre>

<p>should work...</p>

<p>UPDATE</p>

<p>Just to be clear, there is a semantic difference between template specialization and type alias. With template specialization you could put your (true and tested and bug-for-bug compatible) code into specialization and use new and shiny (but potentially buggy code) elsewhere in new production, and later when you fill it is good enough you could remove specialization and use only new code. With type specialization it is new code everywhere right away...</p>
",0
29223209,29222973,1,"<p>You could use type-erasue, but will still need to update the code here and there... An approach could be doing something like:</p>

<pre><code>class A {
   map&lt;int, boost::any&gt; m;

   template &lt;typename T&gt;
   T valueAs(int idx);
};

A a;
a.valueAs&lt;int&gt;();
</code></pre>

<p>You would have the implementation verify that the type stored and the type retrieved are the same. Then you would probably want to go to all existing uses of <code>A</code> and enforce the check (or check the potential error).</p>

<p>That is, if you want to support mixed types inside <code>A</code>... if you each <code>A</code> can only hold a particular type, you can just make a <code>ATmpl</code> type with the contents in the question, and then <code>typedef ATmpl&lt;vector&lt;int&gt;&gt; A;</code>. At this point you would still have to fix some use cases (specifically: forward declarations)...</p>
",0
29223296,29222973,3,"<p>So, the easiest and most legible solution that comes to mind is a <a href=""http://en.cppreference.com/w/cpp/language/type_alias"" rel=""nofollow"">type alias</a>:</p>

<pre><code>template &lt;typename T&gt;
class Tool {
  private:
    map&lt;int,vector&lt;T&gt;&gt; m;
  public:
    vector&lt;T&gt; GetJsonVal(int k) {
      return m[k];
    }
};

using A = Tool&lt;int&gt;;
</code></pre>

<p>And so now the old code can continue using <code>A</code>, and all new code can use <code>Tool&lt;int&gt;</code> or another type alias.</p>
",0
30186347,30185775,0,"<p>To me it seems to a C code. But I did quickly analyze your code. I Think the problem lies where your are calculating the </p>

<blockquote>
  <p>(partiehexa &lt; 10)</p>
</blockquote>

<p>The LRCascii only gets assigned while looping through the ""reste"" part of the code. In the ""partiehexa"" part of the code it do not get assigned to anything.</p>

<p>Suggestion: Change the code to the following and your code will work</p>

<pre><code>if (partiehexa&lt;10) 
{ 
    std::stringstream ss3;
    ss3 &lt;&lt; partiehexa;
    ss3 &gt;&gt; temp2;
    LRCascii += temp2;
}
</code></pre>

<p>Best solution would be to rewrite the code in proper optimized way.</p>
",3
28312098,28312029,3,"<p>This is happening because you're defining a function in your header file which is not marked <code>inline</code>.  Either move the definition of <code>operator &lt;&lt;</code> to the corresponding .cpp file, or add the <code>inline</code> keyword:</p>

<pre><code>inline std::ostream&amp; operator&lt;&lt; // ...
</code></pre>

<p>Personally I'd move it to the .cpp file.  Then you can move the <code>#include &lt;iostream&gt;</code> in your header to the .cpp file as well, and add <code>#include &lt;iosfwd&gt;</code> to your header, which is a slimmer dependency.</p>
",0
29514532,29514214,1,"<p>Instead of</p>

<pre><code>else if (index = (count - 1))
</code></pre>

<p>try</p>

<pre><code>else if (index == (count - 1))
</code></pre>
",0
29501316,29501163,0,"<p>You can check ios_base::iostate for eofbit, failbit or badbit after extraction. see <a href=""http://www.dcs.uni-pannon.hu/smidla/web/cplusplus/reference/iostream/istream/operator%3E%3E/index.html"" rel=""nofollow"">http://www.dcs.uni-pannon.hu/smidla/web/cplusplus/reference/iostream/istream/operator%3E%3E/index.html</a></p>
",0
29501269,29501163,0,"<p>You can test the result of the stream insertion. If it's not the right format, it will be in an invalid state:</p>

<pre><code>if(!(iss &gt;&gt; i &gt;&gt; c &gt;&gt; s &gt;&gt; f)) // skip the loop if not correct format
    continue; 
</code></pre>
",0
29501274,29501163,0,"<p>The problem you are facing is due to the fact that the invalid string was placed inside your istringstream, from which you then tried to extract according to a valid format. This of course fails, so variables i, c, s and f retain their original values. If you would like to ignore the invalid lines, you should query the fail bit of istringstream. Something along the lines of</p>

<pre><code>if ( iss.fail() ) {
    continue;
}
</code></pre>

<p>should do the trick.
From <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt"" rel=""nofollow"">http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt</a></p>

<blockquote>
  <p>If extraction fails (e.g. if a letter was entered where a digit is
  expected), value is left unmodified and failbit is set</p>
</blockquote>
",0
29485312,29484721,0,"<p>Try the recursive function:</p>

<pre><code>void Delete(link h)
{
  if(h)
  {
    if(h-&gt;l) Delete(h-&gt;l);
    if(h-&gt;r) Delete(h-&gt;r);
    delete(h);
  }
}
</code></pre>
",0
29485119,29484721,0,"<p>When you delete a node, you call <code>deleteAll(temp)</code> which deletes <code>temp</code>, but it doesn't remove the pointer value from the <code>l</code> or <code>r</code> of <code>temp</code>'s parent node.</p>

<p>This leaves you with a invalid pointer, causing garbage printing and crashing.</p>

<p>Unfortunately, the way your find works currently, you don't know what the current <code>temp</code> node's parent is when you get around to checking its value.</p>

<p>One way to fix it is to have a different type of <code>find</code> (called something like <code>remove</code>) that looks in <code>l</code> and <code>r</code> at each iteration for the value and sets <code>l</code> or <code>r</code> to <code>NULL</code> before returning the pointer. You might have to have a special case for when the value is found in the root.</p>

<p>Edit (sample code added): </p>

<p>I am assuming you are not using recursion for some reason, so my code uses your existing queue based code. I only changed enough to get it working.</p>

<p><code>findAndUnlink</code> find the node with the value given and ""unlinks"" it from the tree. It returns the node found, giving you a completely separate tree. <strong>Note:</strong> it is up to the caller to free up the returned tree, otherwise you will leak memory.</p>

<p>This is a drop in replacement for <code>find</code> in your existing code, as your existing code then calls <code>deleteAll</code> on the returned node.</p>

<pre><code>link findAndUnlink(int x) {
    if (head == 0) {
        cout &lt;&lt; ""\nEmpty Tree\n"";
        return 0;
    }
    link temp = head;
    if (temp-&gt;item == x) {
        // remove whole tree
        head = NULL;
        return temp;
    }
    // To find the node with the value x and remove it from the tree and return its link
    QUEUE q(100);
    q.put(temp);
    while (!q.empty()) {
        temp = q.get();
        if (temp-&gt;l != NULL) {
            if (temp-&gt;l-&gt;item == x) {
                link returnLink = temp-&gt;l;
                temp-&gt;l = NULL;
                return returnLink;
            }
            q.put(temp-&gt;l);
        }
        if (temp-&gt;r != NULL) {
            if (temp-&gt;r-&gt;item == x) {
                link returnLink = temp-&gt;r;
                temp-&gt;r = NULL;
                return returnLink;
            }
            q.put(temp-&gt;r);
        }
    }
    return 0;
}
</code></pre>
",1
30714023,30713750,0,"<pre><code>std::unordered_map&lt;std::string, std::list&lt;std::string&gt; &gt; data;
</code></pre>

<p>Although I am having a bit of a hard time understanding what exactly you are trying to accomplish... I am not sure if a map of linked lists is what you will need</p>
",1
29465373,29465228,0,"<p>Problem is in the <code>if</code> condition. </p>

<blockquote>
  <p>cin.good() returns 0 if it has a problem reading from the file, file not existing, etc</p>
</blockquote>

<p>As said in the comments under your post, entering 1234 as integer would still be considered as ""1234"". I think the best way would be to iterate through each character to check if they are digit and if it reaches the end, then it is a number.</p>

<pre><code>string::const_iterator it = str.begin();

while(it != str.end() &amp;&amp; isdigit(*it))
{
    it++;
}

if (!str.empty() &amp;&amp; it == str.end())
    cout &lt;&lt; ""not a string"";
else
    cout &lt;&lt; ""valid"";
</code></pre>

<p><a href=""https://ideone.com/gZkmQ0"" rel=""nofollow"">Here</a> is the link to the working example of the above code.</p>
",1
29473322,29465228,0,"<blockquote>
  <p>Even if I input a number instead of string, it still does not work</p>
</blockquote>

<p>There is no such thing as ""input a number instead of string"".  The user doesn't have any control over the datatype, the code reads a string.</p>

<p>In case the user inputs a string which is a representation of a number, that is still a valid string, and <code>cin</code> will still be in a good state.</p>

<p>You could use (for example) <code>strtoi</code> on the string to see if it is a number.  But that is still very weak validation logic.  ""C*7"" is not a number, but probably you don't want to accept it as a state/province name either.  Apply some rules on what makes a valid name, and numeric inputs will be blocked along with all the other garbage.</p>
",0
30196562,30196497,3,"<p>Why not just use <code>std::pair&lt;T1, T2&gt;</code>? See also <a href=""http://www.cplusplus.com/reference/utility/pair"" rel=""nofollow"">http://www.cplusplus.com/reference/utility/pair</a> and <a href=""http://en.cppreference.com/w/cpp/utility/pair"" rel=""nofollow"">http://en.cppreference.com/w/cpp/utility/pair</a></p>
",0
30196599,30196497,2,"<p>It would be simpler to return an aggregate:</p>

<pre><code>struct ReturnObject {
    std::vector&lt;int&gt; o1;
    std::map&lt;int, int&gt; o2;
};

ReturnObject function() {
    ReturnObject ret;
    return ret;
}
</code></pre>

<p>Or you could return a pair or tuple, rather than defining your own type, if you don't mind losing the member names.</p>
",5
32416297,32416143,1,"<p>The unary operator <code>!</code> is the boolean inversion operator, i.e.</p>

<pre><code>!true  ¡ú false
!false ¡ú true
</code></pre>

<p>The binary operator <code>!=</code> is the ""not equal"" operator, i.e. the boolean inverse of ""equal to""</p>

<pre><code>a != b ¡ú true &lt;=&gt; a == b ¡ú false
</code></pre>

<p>or written slightly differently</p>

<pre><code>(a != b) == !(a == b)
</code></pre>

<p>Take note of putting the boolean inverse operator in front of a pair of parentheses. The reason for that is, that the boolean inversion operator has a higher precedence than the boolean equality operator. Which means that <code>!a == b</code> is equivalent to <code>(!a) == b</code>.</p>

<p>In C and by extension C++ every nonzero value is considered boolean true, and zero is boolean false. Also the result of boolean operators is specified to be either 0 (¡úfalse) or 1 (¡útrue).</p>

<p>Now let's look at your two different expressions ""<code>!a==-1</code> and <code>a!=-1</code>""</p>

<p>Since <code>!</code> is a boolean operator the result of <code>!a</code> is defined to be either <code>0</code>, or <code>1</code>. So in case <code>a</code> is nonzero, i.e. true <code>(!a) ¡ú 0</code> thus <code>0==-1 ¡ú false</code> as for a being zero <code>(!0) ¡ú 1</code> thereby <code>1==-1 ¡ú false</code>. Hence the expression <code>!a==-1</code> will always yield false.</p>

<p><code>a!=-1</code> on the other hand is comparing the value of a with -1. Its boolean algebra equivalent would be <code>!(a==-1)</code>.</p>
",10
32416155,32416143,5,"<p>Well <code>server[i].type != -1</code> is true if <code>server[i].type</code> is not equal to <code>-1</code>. </p>

<p>On the other hand, <code>!server[i].type==-1</code> due to <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"">operator precedence</a> evaluates as <code>(!server[i].type) == -1</code>, which is never going to be true because the left hand side is either going to be <code>0</code> or <code>1</code>, unless <code>server[i].type</code> has <code>operator!</code> overloaded... which I'm assuming is not the case. The equivalent version would be <code>!(server[i].type == -1)</code>.</p>
",0
33601891,33601846,6,"<p>A very simple solution: call <code>rand()</code> with a modulo value equal to the total count of numbers in your output range. Then define a mapping function to map values into your required specific output ranges.</p>

<p>For example: to get a random value between 1 and 5 or 11 and 15, inclusive:</p>

<pre><code>int map(int val)
{
    if (val &gt; 5)
        return val+5;
    else
        return val;
}

int value = rand()%10+1;
value = map(value);
</code></pre>
",0
33601948,33601846,5,"<p>Sounds that you want to have e.g. a random number of the set { 1, 2, 3, 7, 8, 9, 14, 15 } (isn't it)?</p>

<p>So, for this example, this is a count of 8 different values and you can do it like this:</p>

<pre><code>lookupTable[] = { 1, 2, 3, 7, 8, 9, 14, 15 };
num1 = lookupTable[rand() % 8];
</code></pre>

<p>I'd placed a running example <a href=""http://coliru.stacked-crooked.com/a/7a0cb4f052e0af11"" rel=""nofollow"">here</a>.</p>
",0
33601960,33601846,3,"<p>To get real random numbers between 1 and 15, you can use such C++11 code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;

int main()
{
        std::random_device rd;
        std::mt19937 mt(rd());
        std::uniform_int_distribution&lt;int&gt; dist(1, 15);

    for (int i = 0; i &lt; 100; ++i)
        std::cout &lt;&lt; dist(mt) &lt;&lt; "", "";

}
</code></pre>

<p>To remove some of this number you can use <code>map</code> as suggested owacoder
Also you see video (from MS guy who wrote part of VS STL) about how to get real random number, and why <code>rand</code> can not be used for that:</p>

<p><a href=""https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful"" rel=""nofollow"">https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful</a></p>
",0
30165384,30165285,0,"<p>If leading zeros are meaningful, you should be storing your ""numbers"" as strings, not integers.  Your ""numbers"" aren't really numbers - the number <code>098</code> is the same as the number <code>98</code>, but the string <code>098</code> is different from the string <code>98</code>.</p>
",0
30165328,30165285,3,"<p>Because the number you entered is <code>98</code>. That's the number above <code>97</code> and the number below <code>99</code>. A count. A quantity. An abstract concept.</p>

<p>An <code>int</code> is <strong>NOT</strong> a string of digits. It is not <code>'9'</code> followed by <code>'8'</code>, or <code>'0'</code> followed by <code>'9'</code> followed by <code>'8'</code>.</p>

<p>This makes complete sense when you think about how numbers are stored in the computer: in binary. Why would the computer, translating a decimal input into binary, separately store the number of leading zeroes you entered? That just isn't what it does, because there is no need for it.</p>

<p>I would generally recommend storing a ""part number"" as a string, because the ""number"" element is just what it's called in English and doesn't really accurately reveal what the value <em>is</em>: as you've indicated, you want it to be a string of characters. If nothing else, I routinely encounter ""part numbers"" with letters in them.</p>
",2
29505304,29504954,2,"<p>SVG doesn't use a traditional Cartesian coordinate system. Instead it uses a system such that <a href=""http://www.w3.org/TR/SVG/images/coords/InitialCoords.svg"" rel=""nofollow"">the Y-Axis scales in the positive direction as you move down along the screen</a>. Because of this your rectangles are drawn with Y1 300 and Y2 300 + the user input.</p>

<p>For everything conforming to a 400 pixel size, first find the maximum of the user inputs. 400/Max = ScaleFactor. Multiply this scale factor times the height of each to find their scaled height.</p>
",1
29156781,29156725,0,"<p>change:</p>

<pre><code>Book(string theAuthor,string theTitle,int thePages){
    author = theAuthor;
    title=theTitle;
    pages=thePages;
}
</code></pre>

<p>to:</p>

<pre><code>Book::Book(string theAuthor,string theTitle,int thePages){
    author = theAuthor;
    title=theTitle;
    pages=thePages;
}
</code></pre>
",2
29156804,29156725,1,"<p>You need to declare it like so:</p>

<pre><code>Book::Book(string theAuthor,string theTitle,int thePages){
</code></pre>

<p>This way, the compiler knows that you are trying to implement the Constructor (that's what the second ""Book(...)"" is for) of the class ""Book"" (that's what ""Book::"" means)</p>
",1
29156859,29156725,1,"<p>You've declared the constructor of <code>Book</code> inside your class, but you've placed the definition outside. That definition isn't of a free function, so you must name both the class and the method of the class which you're defining. For a constructor, those names are identical. So: <code>Book::Book</code>.</p>

<p>A destructor definition outside your class would be <code>Book::~Book</code> but the default destructor usually is OK.</p>
",0
34188202,34187829,2,"<p>If you erase the element at <code>it2</code>, then you can no longer use <code>it2</code>. Incrementing it will no longer be possible.</p>

<p>You can easily write an iteration loop which tolerates the erasure of the loop control itself:</p>

<pre><code>iterator it = iterpair2.first;
while (it != iterpair.second)
{
    iterator next_it = it;
    ++next_it;
    /* it's possible for it to be deleted here */
    it = next_it;
}
</code></pre>

<p>However, the above will fail if <code>next_it</code> is erased in the loop body. So if you wanted to be more general, you'd need an explicit comparison:</p>

<pre><code>while (it != iterpair.second)
{
    iterator next_it = it;
    ++next_it;
    /* ... */
    if (some_condition)
    {
        /* Need to erase it_to_erase */
        if (it_to_erase == next_it) ++next_it;
        theMap.erase(it_to_erase);
    }
    /* ... */
    it = next_it;
}
</code></pre>

<p>Even that requires that the code which iterates is also the code which erases the element. If the erasing code is unrelated (say, because it is in a function called in the iteration), then there is really no solution which allows for immediate erasure.</p>

<p>So in that case, you'd need to implement some form of deferred erasure. In the particular case presented in the OP, where the map's <code>mapped_type</code> is a pointer whose value cannot be null, an easy form of deferred erasure is to simply set the mapped value of the element to be erased to 0.</p>

<p>In the simple deferred erasure scheme below, I assume that the outer loop is itself free to erase elements; that is, it is not in a function called during an iteration. I use some C+11 features for simplicity.</p>

<pre><code>/* Outer loop */

for (auto it = myMap.begin(), end = myMap.end();; ++i) {
  /* Erase any previously marked elements */
  while (it != end &amp;&amp; !it-&gt;second) it = myMap.erase(it);
  if (it == end) break;

  /* Do something with this element */
  /* ... */
  /* This function might ""delete"" arbitrary elements. See below */
  secondProcess(myMap);
  /* At this point, ""it"" might not be valid, so you would need to
     check before trying to use it.
   */
}
</code></pre>

<p>And here's the inner function:</p>

<pre><code>void secondProcess(MapType&amp; myMap) {
  /* ... */
  for (auto it2 = myMap.begin(), end = myMap.end(); it2 != end; ++it2) {
    if (it2-&gt;second) { /* Make sure the element is not already marked */
      /* ... */

      /* Here we've decided to erase the element at ""it2""
       * The delete comes from the code in OP; it is only OK if the
       * mapped value is the only pointer to the object it points to.
       */
         delete it2-&gt;second;
         it2-&gt;second = 0;
       /* Since we don't actually erase it2, no other adjustment
        * is needed 
        */
    }
  }
}
</code></pre>
",2
32996529,32996403,4,"<p>This is common.  Keeps clutter out of the header file.  Normally, you would put them in an anonymous namespace in the .cpp file.</p>

<p>You can accomplish this without an anonymous namespace by using the static keyword.</p>
",3
32996543,32996403,1,"<p>Yes, non-member functions can be placed inside the translation unit.  </p>

<p>Declare and define them as <code>static</code> so they are <em>private</em> within the translation unit.  </p>
",0
32996672,32996403,1,"<p>It's OK to declare them in header file. But if you define them in the header and the header was included by more than one compiling unit, it will cause a link error of confliction.</p>

<p>See this example:</p>

<h1>header.h</h1>

<pre><code>class Foo
{
};

void f()
{
}
</code></pre>

<h1>b.cpp</h1>

<pre><code># include ""header.h""
</code></pre>

<h1>a.cpp</h1>

<pre><code># include ""header.h""

int main()
{
}
</code></pre>

<h1>Compiling OK but link error:</h1>

<pre><code>[~]$ g++ -c a.cpp
[~]$ g++ -c b.cpp
[~]$ g++ -o run a.o b.o
b.o: In function `f()':
b.cpp:(.text+0x0): multiple definition of `f()'
a.o:a.cpp:(.text+0x0): first defined here
collect2: error: ld returned 1 exit status
[~]$
</code></pre>

<p>Alternately, if you separate the declaration and definition like this:</p>

<h1>header.h</h1>

<pre><code>class Foo
{
};

void f();
</code></pre>

<h1>b.cpp</h1>

<pre><code>#include ""header.h""

void f()
{
}
</code></pre>

<h1>a.cpp</h1>

<pre><code>#include ""header.h""

int main()
{
}
</code></pre>

<h1>Then it will be fine</h1>

<pre><code>[~]$ g++ -c a.cpp
[~]$ g++ -c b.cpp
[~]$ g++ -o run a.o b.o
[~]$
</code></pre>

<h1>Also, the static works for that as the posts above said.</h1>
",3
32998049,32996403,0,"<p>You can just put functions in their own namespace so that it doesn't interfere with rest code. A common practice is to make the namespace an inner namespace of your main library namespace and to call it details or something similar.</p>

<p>Of course, if you need to function to be available through ADL(argument dependent lookup) then it has to live in the namespace enclosing the classes for which the ADL is supposed to match. There's no way around this.</p>
",0
34193243,34193026,1,"<p>Make sure you're not including any additional files that also define main()</p>

<p>If you're working in visual studio, you should check the solution explorer for other .cpp files, especially if you've moved this over from an old solution, where you could've forgotten to get rid of old references. If that fails, you could just copy and paste the code that you do have into a new project, since what you have shouldn't be producing the error that you're getting.</p>
",0
34193250,34193026,2,"<p>The following code compiles well with TurboC++ on windows and gives the appropriate result according to as required:</p>

<pre><code>    #include &lt;iostream.h&gt;
    enum bool {true, false};
    bool isPrime (int num);
    int main()
    {
     int num=0;

      cout &lt;&lt; ""Enter a number and I'll tell you whether it is prime: "";
      cin &gt;&gt; num;

      if (isPrime(num)==true)
        cout &lt;&lt; num &lt;&lt; "" is prime."";
      else
        cout &lt;&lt; num &lt;&lt; "" is NOT prime."";

      return 0;
    }

    bool isPrime(int input)
    {
    if(input&lt;1) {
      cout&lt;&lt;""Negatives not allowed""&lt;&lt;endl;
      return false;
    }
    else if(input == 1) {
      return false;
    }
    else if (input ==2 ||input==3) {
      return true;
    }
    else {
      for(int i=2; i&lt;input; i++) {
         if(input%i==0)
            return false;
        }
            return true;
     }
    }
</code></pre>
",1
34193527,34193026,1,"<p>Are you including this file from multiple others without an include guard? Or you could possibly have another main written in another cpp file in your project that you forgot about, in which case make sure you do not build that one with the project by excluding, or creating an entirely new project and adding each file you need individually. </p>

<p>I have found that with most IDE's, and even with command-line compiling, when you get really weird errors and cannot fix them creating a new project can solve many of them.</p>
",0
34193801,34193026,1,"<p>Your exact code runs perfectly on my compiler. So there is no problem on your code. This kind of problem always happens for you compiler. I think you are using an IDE in which you have created a project and added another code, that has a <code>main()</code> function too. So you can easily resolve this by creating a new project from scratch and copy paste this code.</p>
",0
34274734,34274593,5,"<p>Before you attempted to read, the stream won't know whether there is any useful data. At the very least you'll need to look at the first character, e.g., using</p>

<pre><code>if (std::cin.peek() != std::char_traits&lt;char&gt;::eof()) {
    // do something with the potentially present input.
}
else {
    // fail
}
</code></pre>

<p>More likely you'll depend on some non-space data to be available. If so, you could see if there is something other than space in the file:</p>

<pre><code>if (!(std::cin &gt;&gt; std::ws).eof())
  ...
</code></pre>

<p>The <em>manipulator</em> <code>std::ws</code> will skip leading whitespace. It will stop when either a non-whitespace character or the end of file is reached. If the end of file is reached, <code>std::cin.eof()</code> will be <code>true</code>.</p>

<p>In general, I wouldn't bother but rather try to read the first item. If nothing at all is read it would still be viable to fail:</p>

<pre><code>bool hasData = false;
while (std::cin &gt;&gt; some &gt;&gt; data) {
    hasData = true;
    // do something with the input
}
if (!hasData) {
    // report that there was no data at all
}
</code></pre>

<p>The no data case may be implicitly testable, e.g., by looking at the size of a read data structure.</p>
",0
29166983,29166525,1,"<pre><code>int *count=new int[max+1];
for (int i = 0; i &lt;= max+1;i++) {
    count[i]=0;

}
</code></pre>

<p>Note that here you goes out of range, because you try to access the last element as <code>count[max+1]</code>, because the <code>&lt;=</code> in the conditional test, and this position is not allocated. It should be like this:</p>

<pre><code>int *count=new int[max+1];
for (int i = 0; i &lt; max+1;i++) {
    count[i]=0;

}
</code></pre>

<p>I suggest to you to carefully check each <strong>for</strong>, looking if you aren't accessing some position not bounded/allocated. Use printf's or cout's to debug, this is really useful. </p>
",0
34088819,34071425,2,"<p>This is normal. It happens if you run your program 'inside' Visual Studio IDE:</p>

<ul>
<li><p>a console window is opened;</p></li>
<li><p>your program is ran;</p></li>
<li><p>the console window is closed.</p></li>
</ul>

<p>Your program runs fine, only the above happens too fast.</p>

<p>There are three solutions I can think of:</p>

<ol>
<li>If you are in debug mode, <strong>place a breakpoint</strong> (F9, usually) at last line and launch the program (F5). Once the breakpoint is reached, switch to console window, then back to IDE and press F5 to end the program.</li>
<li>Run your program in a <strong>console window</strong> (START+R, CMD, ENTER).</li>
<li><strong>Change your code</strong>: add <code>cin.ignore();</code> before <code>return 0;</code>. The program will wait for you to enter something before it ends.</li>
</ol>
",3
34213355,34211417,0,"<p>After a long back and forward in the comments, the OP explained what was his purpose. To generate random words of the same size as input and stop when it matched the input.</p>

<p>This code does what you want. It's in <code>c++14</code> so you need a recent compiler and to set the <code>c++14</code> option. Please note the actual use of <em>random</em>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

using std::cin;
using std::cout;
using std::cerr;
using std::endl;

class RandomCharGenerator {
private:
  static std::string s_chars_;

private:
  std::random_device rd_{};
  std::default_random_engine r_eng_{rd_()};
  std::uniform_int_distribution&lt;int&gt; char_dist_{
      0, static_cast&lt;int&gt;(s_chars_.size())};

public:
  RandomCharGenerator() = default;

  auto getRandomChar() -&gt; char { return s_chars_[char_dist_(r_eng_)]; }
  auto setRandomString(std::string &amp;str) -&gt; void {
    std::generate(std::begin(str), std::end(str),
                  [this] { return this-&gt;getRandomChar(); });
  }
};

std::string RandomCharGenerator::s_chars_ = ""abcdefghijklmnopqrstuvwxyz"";

auto main() -&gt; int {
  RandomCharGenerator rand_char;

  auto input = std::string{};

  cin &gt;&gt; input;
  auto generated = std::string(input.size(), ' ');

  do {
    rand_char.setRandomString(generated);
    cout &lt;&lt; generated &lt;&lt; endl;
  } while (input != generated);

  cout &lt;&lt; ""We generated what you input"" &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>For input longer than 4 characters it takes a long time to generate the input.</p>

<p><a href=""http://ideone.com/hEL3Lw"" rel=""nofollow"">Ideone demo</a></p>

<hr>

<p>To understand why you had only 1 char in your <code>Passwords</code>:</p>

<p><code>Passwords = Alpha + I;</code></p>

<p><code>Alpha</code> is a <code>char</code>, <code>I</code> is an <code>int</code>. Their sum is an <code>int</code>. This is converted to <code>char</code> when assigning to <code>Passwords</code> which is a <code>string</code>. So <code>Passwords</code> is now a string composed of only one char.</p>

<p>It's not clear what that actual line of code was supposed to do, so can't tell you what would have been the fix. Maybe you meant to append to <code>Passwords</code>. Then you should have written <code>Passwords += Alpha + I</code>.</p>
",1
34214218,34211417,0,"<p>The code below is an example of what I am trying to make. I did not make the code below, am just giving you and example of what am trying to do in the code above</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unistd.h&gt;
using namespace std;

int main()
{
    string password;
    string Generated;

    cout &lt;&lt; ""Password to find: "";
    cin &gt;&gt; password;

    char Alpha[]={'a'-1,'a','a','a','a','a','a','a','a','a'};

    while( password.compare(Generated) != 0 )
    {

    Alpha[0]++;
    for(int x=0;x&lt;password.length();x++)
    {
       if (Alpha[x] == 'z'+1)
            {
                Alpha[x] = 'a';
                Alpha[x + 1]++;
            }
    }


    Generated=Alpha[password.length()-1]; 

    for(int i=password.length()-2;  i&gt;=0  ;  i-- )
        Generated+= Alpha[i]; 

        system(""clear"");

        cout &lt;&lt; ""Trying: ""&lt;&lt; Generated &lt;&lt; endl; 
    }

    system(""clear"");
    sleep(1);
    cout &lt;&lt;""Access Granted: ""&lt;&lt; Generated &lt;&lt; endl; 
    return 0;
}
</code></pre>
",0
34257613,34257566,0,"<p>Likely old compiler that can't take string as an argument. Use a cstring:</p>

<pre><code>ifstream input_file(fileName.c_str());
</code></pre>

<p>Or specify <code>-std=c++11</code> on the commandline to get C++11 support.</p>
",0
34257623,34257566,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;


int main() {

 std::string fileName;
 std::cout &lt;&lt; ""Enter the file name to be read: "";
 std::cin &gt;&gt; fileName;
 std::ifstream input_file(fileName.c_str());
 std::string line_; // string which text file contents will be stored in

 if(input_file.is_open()){ // validation to see if the file is open
   while(getline(input_file, line_)){
     std::cout&lt;&lt;line_&lt;&lt; '\n'; //prints the contents of the file into the console
   }
  input_file.close();
 }
 else {
   std::cout&lt;&lt;""File is not open""&lt;&lt; '\n';
 }
 std::cin.get();
}
</code></pre>

<p>Good luck...</p>
",4
34232666,34232600,4,"<p><code>i &lt;&lt; n</code> , multiplies <code>i</code> with 2<sup>n  </sup></p>

<p>You are getting 8 as 
1 &lt;&lt; 3 = 1 * 2<sup>3</sup></p>

<pre><code>1 &lt;&lt; 0 = 000...0000001 = 1
1 &lt;&lt; 1 = 000...0000010 = 2
1 &lt;&lt; 2 = 000...0000100 = 4
1 &lt;&lt; 3 = 000...0001000 = 8
</code></pre>
",1
34240775,34240766,6,"<pre><code>Pointer = &amp;var;
</code></pre>

<p>This is a statement that performs an action (rather than declaring a thing).</p>

<p>You can't have it floating about in random space. It must be in a function, so that your computer knows <em>when</em> to execute it.</p>

<p>Either:</p>

<ul>
<li>move that assignment statement into <code>main</code>, or</li>
<li><p>replace it, and the previous line, with an <em>initialisation</em> so that it may be part of the initial declaration:</p>

<pre><code>int* Pointer = &amp;val;
</code></pre></li>
</ul>
",0
29248255,29248218,0,"<p>take input within while loop(I am assuming other things and your logic is correct):</p>

<pre><code>while ( deposit &lt; 1)
{
    cout &lt;&lt; ""\tPlease enter a positive number! "" &lt;&lt; endl;
    cout &lt;&lt; setw(60) &lt;&lt; ""Amount on deposit: "";
    cin.ignore(deposit);
    cin &gt;&gt; deposit;
}
</code></pre>
",0
29248260,29248218,1,"<p>Add the header <code>&lt;limits&gt;</code> and use this code to get rid of those character inputs that you asked in the comment.</p>

<p>Change your code to</p>

<pre><code>while ( deposit &lt;= 0)
{                 
    cin.clear();
    cin.ignore(numeric_limits&lt;int&gt;::max( ),'\n');
    cout &lt;&lt; ""\tPlease enter a positive number! "" &lt;&lt; endl;
    cout &lt;&lt; setw(60) &lt;&lt; ""Amount on deposit: "";
    cin &gt;&gt; deposit; // take the input inside the while loop                    
}
</code></pre>

<p>The problem is that you are not changing the value of <code>deposit</code> inside your loop. In your code, the value of <code>deposit</code> does not change inside your while loop, which is causing the infinite loop.</p>

<p>Also, rather than <code>!deposit</code>, you can just change your condition to</p>

<pre><code>while ( deposit &lt;= 0)
</code></pre>

<p>Also, unless you really need it, I'd remove the if statement as well, as I don't see a use for it ( unless you have some specific reason for using it )</p>
",1
29902592,29902435,1,"<p>Your <code>readInt()</code> doesn't work if there are non-leading zeroes. For example, if the input is <code>10</code>, you'll return <code>1</code>.</p>

<p>Here's my tried and tested implementation (for non-negative integers only).</p>

<pre><code>int get() {
    int res = 0;
    int c;
    do {
        c = getchar_unlocked();
    } while (c &lt;= 32);
    do {
        res = 10*res + c - '0';
        c = getchar_unlocked();
    } while (c &gt; 32);
    return res;
}
</code></pre>

<p>Also I suggest using <code>std::vector</code> instead of calling <code>malloc</code> or <code>new</code> directly.</p>
",0
30174385,30174341,1,"<p>Your compiler error above is unrelated to what kind of value the object is:</p>

<pre><code>hello4 lol = returning;
</code></pre>

<p>should be</p>

<pre><code>hello4 lol = returning();
</code></pre>

<p>Without the brackets, the compiler thinks you are trying to assign a function to a <code>hello4</code> value.  You can see this here:</p>

<pre><code>int main()
{
    auto lol = returning;
    hello4 foo = lol();

    return 0;
}
</code></pre>
",0
30174399,30174341,5,"<blockquote>
  <p>A rvalue reference is a temporary object right?</p>
</blockquote>

<p>No, it's a reference to an object which might or might not be a temporary.</p>

<blockquote>
  <p>Why isn't the following compiling?</p>
</blockquote>

<p>Because you left the (empty) argument list off the function call:</p>

<pre><code>hello4 lol = returning();
                      ^^
</code></pre>

<p>The error message indicates that your code tries to assign a function, not the result of calling a function, to a variable.</p>

<blockquote>
  <p>I thought this function returned a rvalue reference</p>
</blockquote>

<p>No, it returns an object, which is just as well since there's nothing for a reference to refer to. But that temporary object can bind to a <em>rvalue</em> reference, so it can be used to construct the <code>hello4</code>.</p>
",0
34246174,34246135,1,"<pre><code>while (!infile.eof())
{
    infile &gt;&gt; digit;
</code></pre>

<p>Here is the problem. EOF bit is set only when operation tried to read to read past th end of stream and failed.</p>

<p>In your example, code reads last D, as it read a single character, it did not encountered the end of stream yet, so loop condition is still true. Then it tries to read, finds out that there is no characters in stream, fails, sets eof and failbits, but it is too late. The rest of loop body is executed, operating on whatever value is in <code>digit</code>. In short: <strong><code>eof</code> in loop condition is almost always wrong</strong>. </p>

<p>Preferable way is to loop on input operation:</p>

<pre><code>while (infile &gt;&gt; digit)
{
</code></pre>
",0
34247147,34247118,1,"<p>call use from main with the command <code>use(name)</code> but you also need to declare use with a string parameter since your passing it a string parameter so your use function should look like:</p>

<pre><code>int use(string myString)
{
    cout&lt;&lt;myString&lt;&lt;endl;
    return 0;
}
</code></pre>

<p>Also i dont know if your returning 0 from this function for a reason but its not like main where you should return 0 at the end so if you dont need that you can do this instead:</p>

<pre><code>void use(string myString)
{
    cout&lt;&lt;myString&lt;&lt;endl;
}
</code></pre>
",6
34256545,34247118,0,"<p>as you are using cpp, you can also use:</p>

<pre><code>    void use(string &amp;myString) {
        cout &lt;&lt; myString &lt;&lt; endl;
    }
</code></pre>

<p>Write in your main:</p>

<pre><code>use(string_blabla);
</code></pre>

<p>This is a ""reference"". Your PC only sends the Adress of your string to the use function and so no data will have to be copied (which needs time). Ofc at this point this effect is not noticeable but I just wanted to show some of the advantages of c++.  :)</p>

<p>Joiny</p>
",0
34257908,34257813,-1,"<p>Your issue here is possibly coming from the fact you're doing division in double precision using a <code>const int</code>. If you cast <code>SIZE</code> as a <code>double</code> and write the rest of your double numbers with a .0 on the end, it works fine:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

const int SIZE = 6;
double grades[SIZE];
double low(double[]);

int main()
{
    double preavg = 0.0;
    double avg = 0.0;

    cout &lt;&lt; ""This program will take an input of six test grades\n""
         &lt;&lt; ""and determine the average of the highest five grades.\n\n""
         &lt;&lt; ""Please input the first test grade\n"";
    cin &gt;&gt; grades[0];
    cout &lt;&lt; ""Please input the second test grade\n"";
    cin &gt;&gt; grades[1];
    cout &lt;&lt; ""Please input the third test grade\n"";
    cin &gt;&gt; grades[2];
    cout &lt;&lt; ""Please input the fourth test grade\n"";
    cin &gt;&gt; grades[3];
    cout &lt;&lt; ""Please input the fifth test grade\n"";
    cin &gt;&gt; grades[4];
    cout &lt;&lt; ""Please input the sixth test grade\n"";
    cin &gt;&gt; grades[5];

    for (int i = 0; i &lt; SIZE; i++)
    {
        preavg += grades[i];
    }

    avg = (preavg - low(grades)) / ((double)SIZE - 1.0);

    cout &lt;&lt; ""Your average grade is "" &lt;&lt; avg &lt;&lt; ""\n"";

    system(""PAUSE"");

    return 0;
}

double low(double grades[SIZE])
{
    double lowest;

    lowest = 100.0;
    for (int i = 0; i &lt; SIZE; i++)
    {
        if (grades[i] &lt; lowest)
        lowest = grades[i];
    }

    return lowest;
}
</code></pre>
",3
32390644,32390094,-1,"<pre><code>void main()
{
string item1Name;
string item2Name;
string item3Name;

float item1Price;
float item2Price;
float item3Price;
float budget;
float total;

cout&lt;&lt;""Please input your budget: "";
cin&gt;&gt;budget;


cout&lt;&lt;""Please input the first items name: "";
cin&gt;&gt;item1Name;

cout&lt;&lt;""Please input the second items name: "";
cin&gt;&gt;item2Name;

cout&lt;&lt;""Please input the third items name: "";
cin&gt;&gt;item3Name;


cout&lt;&lt;""Please input the first items price: "";
cin&gt;&gt;item1Price;

cout&lt;&lt;""Please input the second items price: "";
cin&gt;&gt;item2Price;

cout&lt;&lt;""Please input third items price: ""
cin&gt;&gt;item3Price;


system(""CLS"");


total = item1Price + item2Price + item3Price;

cout&lt;&lt;""the total cost is ""&lt;&lt;total&lt;&lt;endl;
if (item1Price &lt; item2Price  item1Price &lt; item3Price)
{
  if(item2Price&gt;item3Price)
  {
  cout&lt;&lt;""you should swap "" &lt;&lt; item2Name &lt;&lt; "" for something less     expensive\n"";
}
else
{
cout&lt;&lt;""you should swap "" &lt;&lt; item3Name &lt;&lt; "" for something less expensive\n"";
}

}
else
{
cout&lt;&lt;""you should swap "" &lt;&lt; item1Name &lt;&lt; "" for something less expensive\n"";
}


if(total &gt; budget)
{
    cout&lt;&lt;""you have gone overbudget!""&lt;&lt;endl;

    cout&lt;&lt;""Maybe you could swap ""&lt;&lt; //most expensive item goes here;
}
}
</code></pre>
",0
32390186,32390094,0,"<pre><code>if (item1Price &gt; item2Price &amp;&amp; item1Price &gt; item3Price)
    cout &lt;&lt; ""you should swap "" &lt;&lt; item1Name &lt;&lt; "" for something less expensive\n"";
</code></pre>

<p>etc.</p>
",0
29205694,29205300,1,"<p>This is so confusing!
The overlap test should be like so:</p>

<pre><code>if ((classes[i].second &lt; classes[j].first) || (classes[i].first &gt; classes[j].second))
  printf(""no overlap"");

if (!((classes[i].second &lt; classes[j].first) || (classes[i].first &gt; classes[j].second)))
  printf(""overlap"");
</code></pre>

<p>assuming <code>classes[n].first</code> is always less than <code>classes[n].second</code></p>
",0
29206454,29205300,-1,"<p>check out interval trees. You will get logarithmic complexity: <a href=""http://en.wikipedia.org/wiki/Interval_tree"" rel=""nofollow"">http://en.wikipedia.org/wiki/Interval_tree</a></p>
",1
29451061,29450954,3,"<p>There are several problems</p>

<ul>
<li>The default constructor doesn't initialize its members</li>
<li><code>Queue::Queue(int arrSize)</code> has a local variable <code>elements</code>, which shadows the member <code>elements</code>. The consequence, this constructor doesn't initialize its member</li>
<li><code>enqueue</code> should copy <code>count * sizeof(float)</code> bytes, not <code>newSize</code> bytes</li>
<li>as @Vladimir noticed, <code>enqueue</code> assigns one element beyond the allocated memory. Should be <code>elements[count - 1] = element;</code></li>
<li><code>dequeue</code> should copy <code>newSize * sizeof(float)</code> bytes, not <code>newSize</code> bytes</li>
</ul>
",2
31285728,31285386,0,"<p>This function &hellip;</p>

<pre><code>void f1(int e) {
    if (e) {}
}
</code></pre>

<p>&hellip; compiles to &hellip;</p>

<pre><code>f1:
    rep ret
</code></pre>

<p>&hellip; while this function &hellip;</p>

<pre><code>void f2(int e) {
    if (e) return;
}
</code></pre>

<p>&hellip; compiles to &hellip;</p>

<pre><code>f2:
    rep ret
</code></pre>

<p>&hellip; when optimization is enabled using the <code>-O2</code> option.</p>
",0
31285769,31285386,0,"<p>If there is only one statement, then there is no difference in using ""block"" and ""writing inline"".</p>

<p>Braces are used only to enclose a sequence of statements that are intended to be seen as a single process. </p>

<p>General syntax for <code>if</code>:</p>

<pre><code>if ( condition_in_the_diamond )
    statement_to_execute_if_condition_is_true;
</code></pre>

<p>So to make multiple lines of code as a single process, we use braces.</p>

<p>Hence if you have only one statement to execute in if statement, the it would be similar.</p>

<hr>

<p>Using braces are better because it reduces the chances of error. Suppose you are commenting a line of code in hurry to debug:</p>

<pre><code>if(condition)
//    statement1;
statement2;        //this will bring statement2 in if clause which was not intended
</code></pre>

<p>or while adding a line of code:</p>

<pre><code>if(condition)
    statement1;
    statement3;    // won't be included in if
statement2;
</code></pre>

<p>But if you are using inline statement as:</p>

<pre><code>if(condition) statement1;
</code></pre>

<p>then it might prevent you from above error but it will make <code>statement1</code> of limited length (assuming 80 character width code). That will make it sweet and simple to read though.</p>

<p>Hence unless you are using inline statement, using braces is suggested.</p>

<p><a href=""https://softwareengineering.stackexchange.com/questions/16528/single-statement-if-block-braces-or-no/16530#16530"">Source</a></p>
",0
31285503,31285386,1,"<p>No, there is no difference between the two examples. You can use a profiler to see what assembly code is outputted and see for your self.</p>
",1
31285517,31285386,2,"<p>If there's going to be only one statement within the block then both are identical.</p>

<pre><code>if (e)
{
   stmt;
}

if (e) stmt;
</code></pre>

<p>are the same. However, when you've more than one statement to be executed, it's mandatory to wrap them in <code>{}</code>.</p>
",0
31285526,31285386,0,"<p>Aside from the <code>return</code> statement, there is no difference.</p>

<p>A compiler may optimise out the first case altogether if the expression is either compile-time evaluable (e.g. <code>sizeof</code>) or has no side-effects.</p>

<p>Similarly, the second case might be optimised out to a simple <code>return;</code></p>
",0
31286173,31285386,0,"<p>With poorly-written macros nasty things can happen.</p>

<pre><code>// c-style antipattern. Better use scoped_ptr
#define CLEANUPANDRETURN delete p; return

if (*expr*) CLEANUPANDRETURN;

// preprocesses to: (with added linebreaks)
if (*expr*)
  delete p;
return;
</code></pre>

<p>Many functions of the C-Library may actually be macros. See 
<a href=""https://stackoverflow.com/questions/154136/do-while-and-if-else-statements-in-c-c-macros"">Why use apparently meaningless do-while and if-else statements in macros?</a> for a trick of somehow safer macros.</p>
",1
32402961,32402842,2,"<p>Fixed, there is not reason to try to call the constructor within the overload, the object will be constructed at returned void*'s pointed allocated memory.</p>
",0
32403394,32402842,0,"<blockquote>
  <p>I'm trying to overload the new operator in order to allocate my own memory, but I still need to construct the object.</p>
</blockquote>

<p>No you don't. <code>operator new</code> by definition initializes the object. See [expr.new]/15:</p>

<blockquote>
  <p>A <em>new-expression</em> that creates an object of type <strong>T</strong> initializes
  that object as follows:</p>
  
  <p>¡ª If the <em>new-initializer</em> is omitted, the object is
  default-initialized (8.5); if no initialization is performed, the
  object has indeterminate value.</p>
  
  <p>¡ª Otherwise, the <em>new-initializer</em> is interpreted according to the
  initialization rules of 8.5 for direct-initialization.</p>
</blockquote>

<p>At a minimum, your overload can look like this:</p>

<pre><code>void *operator new(size_t sz)
{
    return ::operator new(sizeof(A));
}
</code></pre>

<p>The <code>static</code> keyword is optional.</p>
",0
29464593,29464533,0,"<p>What about doing this: 
I merely factorized the <code>x++</code> line. </p>

<pre><code>while (x &lt;= rows * columns) {
    cout &lt;&lt; ""*"";
    if (x % intervals == 0) {
        cout &lt;&lt; ""?"";

    }
    if (x % columns == 0) {
        cout &lt;&lt; ""\n"";
    }
    x++;
}
cout &lt;&lt;""\nDONE!!!"";
</code></pre>
",0
29464595,29464533,0,"<p>If columns is a multiple of intervals, the second statement will never evaluate to true.</p>
",0
29464596,29464533,1,"<p>There is no reason you cannot have two or more if statements in a while loop.</p>

<p>without the context it is hard to say what is going wrong.</p>

<p>however, as you are running x++ within one of the IF statements you could potentially be causing the loop to exit before you hit your ""column"" condition as you could be skipping the value of ""X"" that is divisible by your Columns ( stated in x % columns)</p>

<p>Please provide some context</p>
",0
29466008,29464533,0,"<p>Found My problem. The reason it was skipping it was because the trial I was running was with an odd number and the x was initialized as 1. So the second x++ in the first if statement was making the x skip through that odd number. Therefore x % columns never resulted in 0. I fixed it though. Thanks anyways guys.</p>
",0
29465007,29464956,3,"<p>You said in a comment: ""test"" is supposed to be a member variable.</p>

<p>Then, you need to change your class to:</p>

<pre><code>class Something {
     public:
         Random&amp; random(); // should access a data member of type Random
     private:

         // Not this. This declares test to be member function.
         // Random test(int r, int c);

         // Use this. This declares test to be member variable.
         Random test;
}

Random&amp; Something::random() {
         return test;
}
</code></pre>
",0
29479533,29479445,3,"<p>What you need is a list of unique pointers to the base class:</p>

<pre><code>list&lt;unique_ptr&lt;base&gt;&gt; your_list;
</code></pre>

<p>Then, you can populate it both with instances of <code>base</code> class <em>and</em> <code>derived</code> class.</p>
",2
29479571,29479445,-1,"<p>To complete the answer of Roman, you might like this : <a href=""https://limbioliong.wordpress.com/2013/01/03/storing-c-objects-in-a-stl-vector-part-3/"" rel=""nofollow"">https://limbioliong.wordpress.com/2013/01/03/storing-c-objects-in-a-stl-vector-part-3/</a> . It s about vectors but it s exactly the same for list.</p>

<p>EDIT : Using this, here is the complete example given on the site (note the dynamic_cast to get the derived object):</p>

<pre><code>typedef unique_ptr&lt;Base&gt; BasePtr;
std::list&lt;BasePtr&gt; listBasePtr;

listBasePtr.push_front(BasePtr(new Base(0)));
listBasePtr.push_front(BasePtr(new Derived(1, 2)));

std::list&lt;BasePtr&gt;::iterator theIterator;

for (theIterator = listBasePtr.begin(); theIterator != listBasePtr.end(); theIterator++)
{
    BasePtr&amp; base_ptr = (BasePtr&amp;)(*theIterator);

    base_ptr -&gt; func();

    Derived* pDerived = dynamic_cast&lt;Derived*&gt;(base_ptr.get());

    if (pDerived)
    {
        pDerived -&gt; func();
    }
}
</code></pre>
",3
29175689,29175529,2,"<p><a href=""http://ideone.com/XLmNKb"" rel=""nofollow"">Why not test it?</a></p>

<pre><code>class Base {
private: 
    int a;
};

// Private inheritance.
class A : private Base {
public:
    A() {
        a = 0;
    }
};
</code></pre>

<p>This gives me:</p>

<pre><code>error: 'int Base::a' is private
</code></pre>

<p>The type of inheritance does not matter when it comes to the ability for a class to access it's base-classes private variables.</p>
",0
32447812,32447710,1,"<p>Since <code>M</code> has dimensions <code>[9][17][3]</code>, the loop</p>

<pre><code>for(i=0; i&lt;17; i++) M[i][0][0]=0, M[i][0][1]=1, M[i][0][2]=0;
</code></pre>

<p>modifies non-existent elements.   That is undefined behaviour.   Modifying some other variable (or element of an array) is a feasible outcome.</p>
",1
28173347,28173276,0,"<p>Your assignment operator makes a <em>copy</em></p>

<pre><code>Produs &amp;operator=(const Produs p){
</code></pre>

<p>Of the source instance, so is your copy constructor implemented properly?</p>
",1
29454615,29454608,3,"<p>You have three big problems:</p>

<p>First of all, you are misusing <code>delete[]</code>. It is meant to be called when you allocate an array with <code>new []</code>. You haven't done that. You need to loop over array <code>b</code>, calling <code>delete</code> on each element.</p>

<p>Second, your <code>Base</code> virtual destructor is <code>private</code>. It needs to be accessible to the derived types, so make it <code>public</code>.</p>

<p>Third, so <code>DerivedN</code> <em>is-a</em> <code>Base</code>, you need to make the inheritance <code>public</code>. Without this you can't assign or initialize a pointer to a Derived object to a pointer to Base.</p>

<p>Here is a fixed version:</p>

<pre><code>class Base {
 public:
    virtual ~Base() = default;
};

class Derived1 : public Base {};
class Derived2 : public Derived1{};
class Derived3 : public Derived2{};

int main()
{
    Base* b[] = {new Base, new Derived1, new Derived2, new Derived3};
    for (auto p : b) delete p;
}
</code></pre>
",6
29454618,29454608,5,"<p><strong>Issue 1</strong></p>

<p>Put the destructor in <code>public</code> section of <code>Base</code>.</p>

<pre><code>class Base {
    virtual ~Base() = default;
};
</code></pre>

<p>is equivalent to:</p>

<pre><code>class Base {
  private:
    virtual ~Base() = default;
};
</code></pre>

<p>Change it to:</p>

<pre><code>class Base {
  public:
    virtual ~Base() = default;
};
</code></pre>

<p><strong>Issue 2</strong></p>

<pre><code>Base* b[] = {new Base, new Derived1, new Derived2, new Derived3};
</code></pre>

<p>constructs the objects by using the <code>new</code> operator three times. You need to call <code>delete</code> three times -- once for each pointer.</p>

<p>Instead of</p>

<pre><code>delete[] b;
</code></pre>

<p>use </p>

<pre><code>delete b[0];
delete b[1];
delete b[2];
</code></pre>

<p><strong>Issue 3</strong></p>

<p>To be able to use</p>

<pre><code>Base* p = new Derived1;
</code></pre>

<p>You have to make <code>Base</code> a <code>public</code> base class of <code>Derived1</code>, not <code>protected</code>.</p>

<p>Change</p>

<pre><code>class Derived1 : protected Base {};
class Derived2 : protected Derived1{};
class Derived3 : protected Derived2{};
</code></pre>

<p>to</p>

<pre><code>class Derived1 : public Base {};
class Derived2 : public Derived1{};
class Derived3 : public Derived2{};
</code></pre>
",9
29505849,29505796,5,"<p>The static variable is initialized once, the first time that the execution passes through the declaration.</p>

<p>Later calls just use the value.</p>

<p>In C++11 the initialization is thread-safe.</p>
",0
29178951,29178907,8,"<p>The problem is that your pair is a pair of references, not values. When you have:</p>

<pre><code>using pair_t = std::pair&lt;const std::string&amp;, const int&amp;&gt;;
pair_t(""test"",1);
</code></pre>

<p>The compiler needs to find the best candidate for the construction, the best match in C++11 is:</p>

<pre><code>template&lt; class U1, class U2 &gt;
constexpr pair( U1&amp;&amp; x, U2&amp;&amp; y );
</code></pre>

<p>Where the types are <code>U1 = const char(&amp;)[5]</code> and <code>U2 = int</code>. Internally, to bind the reference it is going to create a temporary string, but when that expression completes (and before returning from that constructor), the temporary will go away and you will be left with a dangling reference.</p>

<p>The program has undefined behavior, and it prints an empty string in the same way that it could have crashed or print any garbage.</p>

<p>In the case where you do:</p>

<pre><code>pair_t(std::string(""test""), 1);
</code></pre>

<p>The expression in which the temporary is created is the same expression that calls the function, and the lifetime of that temporary will last until the function completes, so that second line is correct and exhibits the expected behavior.</p>
",3
29183951,29183772,0,"<p><code>strcat</code> requires that there already be a null-terminated string in the destination to concatenate the source string onto; you're calling it with uninitialised values in the destination.</p>

<p>It looks like you want <code>strcpy</code> in every case, not just the first.</p>

<p>Also, remove the bogus <code>TeamList[5][7]= '\0';</code>. Even if you fix it to write inside the array bounds, each string has already been terminated by <code>strcpy</code> so there's no need to try to do that yourself.</p>

<p>Then stop messing around with low-level arrays and pointers. <code>std::vector&lt;std::string&gt;</code> would be much friendlier.</p>
",1
29184030,29183772,0,"<p><a href=""http://www.cplusplus.com/reference/cstring/strcat/"" rel=""nofollow"">strcat()</a> (which is a ""less-safe"" version of strcat_s()) requires both strings to be null-terminated. That's because strcat() appends its second parameter (<code>source</code>) where first parameter (<code>dest</code>) ends. It replaces null-terminator of dest with first character of source, appends rest of <code>source</code> and then</p>

<blockquote>
  <p>a null-character is included at the end of the new string formed by
  the concatenation of both</p>
</blockquote>

<p>I would simply change</p>

<pre><code>strcpy_s(TeamList[0], Team1);
strcat_s(TeamList[1], Team2);
strcat_s(TeamList[2], Team3);
strcat_s(TeamList[3], Team4);
strcat_s(TeamList[4], Team5);
</code></pre>

<p>to</p>

<pre><code>strcpy_s(TeamList[0], Team1);
strcpy_s(TeamList[1], Team2);
strcpy_s(TeamList[2], Team3);
strcpy_s(TeamList[3], Team4);
strcpy_s(TeamList[4], Team5);
</code></pre>

<p><code>strcpy_s()</code> does not have any requirements regarding contents of destination - only its capacity matters.</p>

<p>If you want to stick with <code>strcat_s()</code>, do this:</p>

<pre><code>char TeamList[5][7];
memset(TeamList, 0, sizeof(char) * 5 * 7);
</code></pre>

<p>Then, this line:</p>

<pre><code>TeamList[5][7]= '\0';
</code></pre>

<p>is not required, It is incorrect anyway, because for N-element array valid indexes are [0; N-1].</p>

<p><strong>EDIT</strong></p>

<p>Since in your case swapping comes into play, I would suggest you totally different approach.</p>

<p>First of all:</p>

<pre><code>#include &lt;string&gt;
</code></pre>

<p>Then, initialize teams this way:</p>

<pre><code>std::string TeamList[] =
{
  ""Grubs"",
  ""Giants"",
  ""Bulls"",
  ""Snakes"",
  ""Echos""
};
</code></pre>

<p>Now, <code>TeamList</code> is an array containing 5 elements and each of these elements is an object of type std::string, containing name of a particular team.</p>

<p>Now, if you want to swap, let's say, teams 1 and 3:</p>

<pre><code>std::swap(TeamList[1], TeamList[3]);
</code></pre>

<p><code>std::swap()</code> is a standard C++ function extensively used in standard library implementation. It is overloaded for many standard types, including <code>std::string</code>. This solution has one, critical benefit: if string's content is held on the heap, swapping two strings is as simple as swapping pointers (and some length/capacity variables).</p>

<p>Oh, and one more thing: if you are not familiar with <code>std::string</code> and you would need to get pointer to a buffer containing string's data, you can do it this way:</p>

<pre><code>const char* team_1_raw_name = TeamList[0].c_str();
</code></pre>

<p>See <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow"">this page for more info about std::string</a></p>
",7
29514336,29514302,2,"<p>Your main function declaration should look like this:</p>

<pre><code>int main ( int argc, char *argv[] )
</code></pre>

<p>The integer, <strong>argc</strong> is the argument count. It is the number of arguments passed into the program from the command line, including the name of the program. </p>

<p>The <strong>array of character</strong> pointers is the listing of all the arguments.</p>

<p>I'd suggest using <code>Boost.Program_options</code> to parse arguments.</p>
",0
29514373,29514302,2,"<p>You can use command line arguments. But your main should look like as below.
Where <code>argc</code> shows the argument count (including the executable itself) and <code>argv</code> shows the arguments (including the name of the executable itself). So <code>argc = 1</code>, <code>argv = {""myProgram""}</code> by default. (if your output file is ""myProgram"")</p>

<pre><code>int main (int argc, char* argv[])
{
    fstream file;
    if (argc == 2){
        file.open(argv[1],ios::in);
    }else{
        // handle the error
    }
}
</code></pre>

<p>When you run the program :</p>

<pre><code>./myProgram ""/filepath""
</code></pre>

<p>But make sure to check <code>argc</code>, before using <code>argv[1]</code>, to avoid segmentation faults, when there are no additional arguments given.</p>
",0
26789990,26789933,13,"<p>The string doesn't <em>become</em> an integer, the <code>std::cin</code> operation fails and what you get as output is the garbage value that was in <code>N</code> originally. Initialize <code>N</code> to 0, and type in ""hello"" you should see 0 as output.</p>
",3
26789994,26789933,5,"<blockquote>
  <p><em>""when I input an Integer it returns the same value but when I input <code>hello</code> it gives me <code>1961729588?</code>.""</em></p>
</blockquote>

<p>The <code>cin &gt;&gt; N;</code> actually fails returning <code>false</code> for the stream state, when a input is given that cannot be converted to an integer. You can check for such error condition with </p>

<pre><code> if(!(cin &gt;&gt; N)) {
     cerr &lt;&lt; ""Input a valid number!"" &lt;&lt; endl;
 }
 else {
     cout &lt;&lt; "" The integer entered is:"" &lt;&lt; N &lt;&lt; endl;
 }
</code></pre>

<p>The value of <code>N</code> will be initialized (reset) to <code>int()</code> (default value) which actually renders to <code>0</code>.</p>

<hr>

<p><a href=""http://coliru.stacked-crooked.com/a/9799a0ad8601e6f1"" rel=""nofollow noreferrer""><strong>Full live sample</strong></a></p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main () {
    int N;
    cout &lt;&lt; "" Input an integer:"";
    if(!(cin &gt;&gt; N)) {
        cout &lt;&lt; ""Input a valid number!"" &lt;&lt; endl;
        cout &lt;&lt; ""N = "" &lt;&lt; N &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; "" The integer entered is:"" &lt;&lt; N &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>Input </p>

<pre><code>Hello
</code></pre>

<p>Output </p>

<pre><code>Input an integer:Input a valid number!
N = 0
</code></pre>

<p>This was cross checked with a <a href=""http://ideone.com/nRzrUW"" rel=""nofollow noreferrer"">Ideone code sample</a></p>

<p><strong>I cannot reproduce</strong> getting some <em>garbage value</em> like <code>1961729588</code>. The value was correctly reset by the <code>std::istream&amp; operator&gt;&gt;(std::istream&amp;, int&amp;);</code> input operator.</p>

<hr>

<p>Is it an issue of your current compiler's implementation, c++ standards level (<code>-std=c++11</code>) settings?</p>

<p>I have found some notes about eventual differences regarding c++ standards at <a href=""http://en.cppreference.com/w/cpp/locale/num_get/get"" rel=""nofollow noreferrer"">cppreference.com</a>:</p>

<p><img src=""https://i.stack.imgur.com/8oqnc.png"" alt=""enter image description here""></p>

<p><img src=""https://i.stack.imgur.com/4Huqg.png"" alt=""enter image description here""></p>

<p><sub>Though I didn't spot what they really refer to with <em>'a value as described above'</em>, to be honest.</sub></p>
",0
26790007,26789933,3,"<p>When you input a non-integer the input fails. When the input fails, <code>N</code> retains its original value which isn't defined, i.e., writing results in undefined behavior. You should test your inputs, e.g.:</p>

<pre><code>if (std::cin &gt;&gt; N) {
    // do something with the successful input
}
else {
    // deal with the input failure
}
</code></pre>
",3
26790253,26789933,1,"<p>When you enter <code>cin &gt;&gt; N;</code> the compiler sees that <code>N</code> was declared as an <code>int</code>. Thus your program will call a function that will attempt to read text representing an <code>int</code> from <code>cin</code> and store the result in <code>N</code>.</p>

<p>To do this it will read as much numeric characters from cin as it can, and stop when a non-numeric character is encountered.</p>

<p>For example if you enter <code>32\n</code> your program reads <code>3</code>, then <code>2</code>, then <code>\n</code>. When it sees the <code>\n</code> it stops reading, because <code>\n</code> is not a number. The program will push <code>\n</code> back on to the stream (in case we want to read it later) and store 32 in <code>N</code>.</p>

<p>Suppose instead of a number you type some word such as <code>""hello""</code>. The your program will read <code>h</code> and then stop, because <code>h</code> is not a number. <code>h</code> will be pushed back onto the stream (to be read later) and nothing will be stored in <code>N</code>. <code>cin</code> will return an error since no numeric characters were read.</p>

<p>This still does not explain the value of 1961729588.</p>

<p>Notice <code>N</code> was never initialised. According to the C++ Standard the value of an uninitialised automatic variable is undefined. Thus the value of <code>N</code> will be some garbage value. In your case this was 1961729588.</p>
",0
33599554,33599521,0,"<p>They both just mean operators, in fact '[]' does not mean array, it mean whatever you may want it to be (although is usually used for indexin over objects or array initializations).</p>

<p>Check <a href=""http://en.cppreference.com/w/cpp/language/operators"" rel=""nofollow"">operators overloading</a> for more information about this topic. But making a resume, almost any common operator can be redefined for custom behaviour on specific objects or data.</p>
",0
33599593,33599521,1,"<p>An operator is a function which can be represented with a special syntax. So the following, if defined on a class MyClass:</p>

<pre><code>T MyClass::operator% (int k);
</code></pre>

<p>can be called as follows:</p>

<pre><code>MyClass a;
int k = 1;
T answer = a % k;
</code></pre>

<p>The other operator:</p>

<pre><code>T MyClass::operator[] (int k);
</code></pre>

<p>Can be called by:</p>

<pre><code>T answer = a[k];
</code></pre>

<p>By convention the % operator is called the modulo operator, while the [] operator is called the subscript operator, but you as they are just functions you can redefine them to make them do what you like.</p>
",3
32459154,32459082,0,"<p>Since you tagged you question as C++, I would suggest to use build-in <code>std::next_permutation()</code> :</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    std::vector&lt;int&gt; v = {1,2,3}
    do {
        compare_digits_from_permutation_to_given_number(givennumber,v[0],v[1],v[2]);
    } while(std::next_permutation(v.begin(), v.end()));
}
</code></pre>
",2
32460093,32459082,0,"<p>You may do something like:</p>

<pre><code>void foo(std::vector&lt;int&gt; v, int n)
{
#if 1 // remove duplicate input, so with {3, 3, 3, 4, 5},
      // the triplet (3, 4, 5) is shown only once.
    std::sort(v.begin(), v.end());
    v.erase(std::unique(v.begin(), v.end()), v.end());
#endif

    for (const auto&amp; e1 : v)
    {
        for (const auto&amp; e2 : v)
        {
            if (e2 == e1) {
                continue;
            }
            for (const auto&amp; e3 : v)
            {
                if (e3 == e1 || e3 == e2) {
                    continue;
                }
                if (e1 &gt;= e2 + e3 || e2 &gt;= e1 + e3 || e3 &gt;= e1 + e2) {
                    continue;
                }
                const auto total = e1 + e2 + e3;
                std::cout &lt;&lt; e1 &lt;&lt; ""+""  &lt;&lt; e2 &lt;&lt; ""+""  &lt;&lt; e3 &lt;&lt; ""="" &lt;&lt; total;
                if (total &lt; n) {
                    std::cout &lt;&lt; "" is less than "" &lt;&lt; n &lt;&lt; std::endl;
                } else if (total == n) {
                    std::cout &lt;&lt; "" is equal to "" &lt;&lt; n &lt;&lt; std::endl;
                } else {
                    std::cout &lt;&lt; "" is more than "" &lt;&lt; n &lt;&lt; std::endl;
                }
            }
        }
    }
}
</code></pre>

<p><a href=""https://ideone.com/EyMmY7"" rel=""nofollow"">Live Demo</a></p>
",0
29194269,29194175,2,"<p>Why do you need to put <code>0</code> in front of the <code>10</code>?</p>

<p>You are writing down a <em>numeric value</em>, and not a string that needs conversion. If you want to write down the value <code>10</code> (base 10), you can do that in base ten, being the default, by just typing <code>10</code>, in base <code>8</code> (octal) by typing <code>012</code>, in base <code>16</code> (hex) by typing <code>0xA</code>.</p>

<p>If you need to convert a string to integer, then (using <code>c++11</code>), you can do:</p>

<pre><code>int myval = std::stoi(""010"");
</code></pre>

<p>Which will truncate any leading 0s, and the result is <code>myval = 10</code>.</p>

<hr>

<p>The default base for <code>std::stoi</code> is <code>10</code>, but you can specify a different base with the third parameter.</p>

<pre><code>int myval = std::stoi(""010"", 0, 8); // Base 8, myval = 8 now.
int myval = std::stoi(""010"", 0, 16); // Base 16, myval = 16 now.
</code></pre>
",1
32416247,32415962,0,"<p>Using a array to store the single integers at a time will help you achieving the desired effect! 
This is the one of the best <a href=""https://discuss.codechef.com/questions/7349/computing-factorials-of-a-huge-number-in-cc-a-tutorial"" rel=""nofollow"">tutorial from codechef</a> for this well known big-int problems!</p>

<p>Hope that helps!</p>
",0
32416000,32415962,1,"<p>You can use <code>boost::multiprecision::cpp_int</code> if you need an arbitrary precision integer. If you need it to be fast, you can use <code>boost::multiprecision</code> with linking to one of several options of an external back-end.</p>
",0
32492961,32492928,2,"<p>This is a great example of a floating point precision error. Precise values like multiples of 0.1, 0.2 cannot be precisely represented internally in the computer's memory. You'll want to do a comparison using EPSILON (<a href=""http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon"" rel=""nofollow"">http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon</a>)</p>

<p>Something like</p>

<pre><code>for (float i = 1; fabs(1.5 - i) &lt; EPSILON; i+=0.1) {
  //statements
}
</code></pre>
",1
32493335,32492928,0,"<p>It is because multiples of <code>0.1</code> cannot be presented precisely in binary, and the actual value stored is an approximation that may be slightly less than 0.1.   So, <code>5*0.1</code> might be less than 0.5 or it might be more (depending on how the floating point values are represented).</p>

<p>It is usually a really bad idea to use a floating point variable (and tests involving equality or inequality of floating point values) to control loops at all.   Effects can include running more (or less) times that intended, or - in some bad cases - an infinite loop where a finite number of runs was expected.</p>

<p>In your case, you would be better off doing something like</p>

<pre><code>for (int i = 0; i &lt; 5; ++i)
{
     float value = 1.0 * i*0.1;
       // use value here rather than the i in your original code
}
</code></pre>

<p>Alternatively, you can use some test that allows for the imprecision of floating point (e.g. compare <code>i - 1.5</code> with some value such as machine epsilon).   The catch with this is that the actual number of iterations still potentially has some level of unpredictability, particularly in loops that involve a large number of iterations (e.g. iterating from <code>1.0</code> to <code>50000.0</code> in steps of <code>0.01</code>) because rounding errors can either accumulate or cancel out at different stages during the loop.</p>
",0
29205376,29205272,0,"<p>If you don't want to use more memory, you can either use more cpu time (scan the array twice, the first time to count the number of overpasses, the second time to print them), or use more hard disk space (create a temporary file to hold the overpasses, print the content of the file on screen and at the end delete it).</p>
",0
29208190,29205272,0,"<p>Your task description screams for an implementation of bubble sort.  </p>

<p>As for displaying the number of swaps (which correspond to the overtakes) and the swaps itself: 
Just count the swaps, while you are executing the qlgorithm and display each swap right when you do it.</p>
",0
33534043,33533902,0,"<p><code>BaseServer::~BaseServer()</code> was <code>inline</code>. Without <code>inline</code> all works properly.</p>
",0
29250777,29250531,3,"<p>You should just read documentation more carefully. As it is states,  <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow"">std::stoi</a> may throw exceptions and specifically <code>std::invalid_argument</code> is thrown if no conversion could be performed. </p>

<p>Your code is trying to convert <code>""/""</code> to number, in that case <code>std::stoi</code> throws an exception which is not caught and thus your program is terminated.</p>
",1
29229720,29229555,0,"<pre><code>#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;string&gt;

std::string str = ""Hello World"";

boost::to_upper(str);
</code></pre>
",0
29229750,29229555,0,"<p>You can use <code>std::transform()</code> from <code>#include &lt;algorithm&gt;</code> library:</p>

<pre><code>#include &lt;algorithm&gt; // for std::transform
#include &lt;functional&gt; // for std::ptr_fun
#include &lt;cstring&gt; // for std::toupper

int main()
{
    std::string ids;

    std::cout &lt;&lt; ""Enter client ID TO Change email"";
    std::cin &gt;&gt; ids;

    // make the entire string uppercase
    std::transform(ids.begin(), ids.end(), ids.begin()
        , std::ptr_fun&lt;int, int&gt;(std::toupper));

    std::cout &lt;&lt; ids &lt;&lt; '\n';
}
</code></pre>

<p>It may be worth making a function wrapper for it:</p>

<pre><code>std::string to_uppercase(std::string s)
{
    std::transform(s.begin(), s.end(), s.begin()
        , std::ptr_fun&lt;int, int&gt;(std::toupper));
    return s;
}
</code></pre>

<p><strong>References:</strong> <a href=""http://en.cppreference.com/w/cpp/algorithm/transform"" rel=""nofollow"">std::transform</a>, <a href=""http://en.cppreference.com/w/cpp/utility/functional/ptr_fun"" rel=""nofollow"">std::ptr_fun</a></p>
",1
31231065,31230942,1,"<p>i just added a <code>declaration</code> for the <code>class B</code>(called <em>forward declaration</em> of a <code>class</code>) at the top and it compiles. You need to declare the <code>class B</code> before you use it as a <code>parameter</code> in your <code>member functions</code> of <code>class A</code>.</p>

<p>Here is the code -></p>

<pre><code>#include&lt;iostream&gt;

class B;

class A {
public:
    int Func1(B&amp; b);

private:
    int Func2(B&amp; b);
};

class B {
private:
    int _b;


    // A::Func1 is a friend function to class B
    // so A::Func1 has access to all members of B
    friend int A::Func1(B&amp;);
};

int A::Func1(B&amp; b) { return b._b; }//the same error as the one below    is here
//int A::Func2(B&amp; b) { return b._b; } 

int main(void){ return 0; }
</code></pre>

<p>If the error still persists then maybe your compiler is at fault.</p>
",6
31218347,31218282,1,"<p>The include path - perhaps change &lt;> to ""</p>
",0
27690070,27689748,1,"<p>The problem appears to be that it buffers the output. </p>

<p>You need to tell it somehow to not buffer it. i.e with python program, you run it with <code>-u</code> flag</p>

<pre><code>python -u theprocess.py
</code></pre>

<p>alternatively you can use <code>stdbuf</code>:</p>

<pre><code>// 0 buffer
stdbuf -i0 -o0 -e0 command
// line buffer
stdbuf -oL -eL command
</code></pre>
",0
32443276,32443186,2,"<p>Use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow""><code>std::getline</code></a> to read an entire line of input including spaces.</p>
",0
32443971,32443186,1,"<p>There are 2 ways to get the string with spaces and special character.</p>

<ol>
<li>cin.getline(name);</li>
<li>gets(name);</li>
</ol>

<p>Hope this will serve your purpose.</p>
",0
32443293,32443186,2,"<p>std::cin is able to get several parameters at once. </p>

<p>That mean you may write:</p>

<pre><code>std::cin &gt;&gt; name0 &gt;&gt; name1 &gt;&gt; name2;
// input: a1 a2 a3
// make: name0: a1, name1: a2, name3:a3
</code></pre>

<p>By default, the space is the separator between parameters.</p>

<p>To avoid this behavior, you could use getLine:</p>

<pre><code>std::getline(std::cin, name0);
</code></pre>
",1
32443316,32443186,2,"<p><code>cin &gt;&gt; text;</code> will read one whitespace delimited token from the input stream. One word in == one word out.</p>

<p><code>std::getline(cin, text);</code> will read a whole line. Reading more than that is tricky, but typically a loop around multiple calls to getline.</p>

<p>Suggestion: Save yourself time and fire up your IDE's debugger to see what's happening in your code before posting a question. Almost always faster, and if not, you can make much better, tighter-focused questions.</p>
",6
34256612,34256592,1,"<p>Make it be defined for your whole project. Like adding <code>-DSHOW_STEPS</code> to GCC command line.</p>
",2
34256682,34256592,5,"<p>As you suspected - place the definition in a header file (.h), and include it wherever necessary.</p>

<p>Either that, or don't use compiler tricks, make a configuration class, and pass the configuration object into the relevant part(s) of the program.  Have the configuration class read from a file or be initialised in a relevant way.</p>

<p>Edit: Just to comment on, <em>""To make this more ""C++ish"" I would like to change the global variable to conditional compilation""</em>.  Both are pretty dodgy practises.  Decent code design is probably what you're looking for!</p>
",0
34256703,34256592,3,"<p>If you introduce #defines to make your code more ""C++ish"", you're doing something very wrong.  </p>

<p>You don't need to explictly remove the if's at all, the compiler can do this for you, given better circumstances. To start with, change your global variable from <code>extern</code> to <code>static</code> in a header.</p>

<p>...That should be enough. If in doubt, check the asm output.</p>
",0
34240413,34240390,3,"<p>Only the last value in the comma expression is returned. That's <code>x/2 == 40</code>. <code>j-1</code> is <a href=""http://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator"" rel=""nofollow"">evaluated but discarded</a>.</p>
",0
34240534,34240390,0,"<p>When there are two expressions in the form <code>e1,e2</code> the value after computation of e1 is discarded, so it is only useful only if e1 computation somehow alters the computation result of e2. Here <code>return (j-1),x/2</code> evaluates <code>(j-1)</code> (this does not have any effect on evaluation of <code>x/2</code>) and then evaluates <code>x/2</code> and returns it.</p>

<p>C++ functions can return only <strong>one</strong> element at anytime. If you were trying to return two values, one possible way is you create a <code>struct</code> containing the two values and you return the single <code>struct</code> instead.</p>
",0
34241088,34240390,0,"<p>The secret function does the same as this version</p>

<pre><code>int secret (int x)  
{
   return x/2;
}
</code></pre>

<p>The rest can be ignored.</p>

<p>This results in: 80 / 2 = 40 </p>
",0
31162026,31161842,0,"<p>It is related to <a href=""https://en.wikipedia.org/wiki/Virtual_method_table"" rel=""nofollow"">vtables</a>. With multiple inheritance, an object may have <em>several</em> of them (perhaps one for each super class containing virtual member functions).</p>

<p>Casting an object pointer to some of it parent classes may need adding some offset (to get the right vtable &amp; member functions).</p>
",0
30132275,30132173,3,"<p><code>name_of_player</code> is defined as an array of 31 <code>string</code>s:</p>

<pre><code>string name_of_player[31];
</code></pre>

<p>You get the element from that array enumerated by <code>counter</code> when you do:</p>

<pre><code>name = name_of_player[counter]; 
</code></pre>

<p>So <code>name</code> is a <code>string</code>. <code>string</code>s do not have a <code>get_name</code> method.</p>

<p>You may be confused about what <code>name</code> is cause you define a local <code>person name</code> in <code>get_player</code>, but then you never use that locally defined <code>name</code>.</p>

<hr>

<p>An ugly way to solve this would be to create another global where you declare <code>name_of_player</code> as:</p>

<pre><code>person stats_of_player[31];
</code></pre>

<p>Then at the bottom of the <code>for</code>-loop in <code>get_player</code> you can assign the locally declared variable to the global array:</p>

<pre><code>stats_of_player[counter] = name;
</code></pre>

<p>You would then be able to use <code>stats_of_player</code> in <code>list_players</code> instead of your <code>for</code>-loop as follows:</p>

<pre><code>for (int i=1; number_of_players &gt;= i; i++)
{
    cout &lt;&lt; stats_of_player[i].get_name() &lt;&lt; stats_of_player[i].get_won() &lt;&lt; stats_of_player[i].get_lost() &lt;&lt; endl &lt;&lt; endl;
}
</code></pre>
",1
30132357,30132173,0,"<p>name_of_player is array of strings, not person objects. So you trying to call get_name on string object and this is why you are getting such error.</p>
",0
30132397,30132173,0,"<p>Running your code I get that std::string has no member named get_name, get_won, or get_lost. This is because you are trying to invoke those methods on a c++ string object, which does not have those methods. </p>

<p>Furthermore it seems like you expect name_of_player to be an array of players when it is in fact an array of strings.</p>

<p>Because the methods of your person class are public and not static you need an instance of your person class to invoke those methods (outside of the class definition e.g. main).</p>

<pre><code>void get_player() {
  ....
  player p();
  p.set_name(""Bob"");
  p.get_name();
  ...
}
</code></pre>
",0
29441905,29441799,0,"<p>I noticed a ` after    sampleFile.ignore(1);
And what I would do is make a for statement iterating through each character, looking for a match for ""1"", and if it's found, removing it.</p>
",1
29442119,29441799,0,"<p>Instead of <code>cin.peek()</code>, you should rather use getline() to read the entire line.</p>

<pre><code> while(getline(sampleFile, line))
  {
    //do stuff here
  };
</code></pre>

<p>Then, parse the line and store the values into x,y and featClass using <code>stringstream</code> </p>

<p>So your code (reading file and parsing it) would look similar to this:</p>

<pre><code>  char ch;   &lt;-- include this for comma
  while(getline(sampleFile, line))
  {
       //do stuff here
       stringstream sstream(line);
       //this is for your particular problem as your file format is --&gt; int, int, char
       sstream &gt;&gt; x &gt;&gt; ch &gt;&gt; y &gt;&gt; ch &gt;&gt; featClass;
       cout &lt;&lt; x &lt;&lt; "" "" &lt;&lt; y &lt;&lt; "" "" &lt;&lt; featClass &lt;&lt; endl;
  };
</code></pre>

<p>Check out this link to read and learn more about <code>stringstream</code></p>

<p><a href=""http://www.eecis.udel.edu/~breech/progteam/stringstream.html"" rel=""nofollow"">http://www.eecis.udel.edu/~breech/progteam/stringstream.html</a></p>
",0
32957746,32957641,0,"<p>If you do not specify the explicit path for the file to be read, the run time library will default to the process current working directory.  If you are running the program in the debugger, the current working directory will be your project directory rather than the location where the executable is linked.  </p>
",4
30144629,30144588,1,"<p>Function <code>std::isgraph</code> returns true if character has graphical symbol. Then again all visible characters will have <code>true</code> as output from this function for them, so all will hit <code>tolower</code>. What signs do you want to have in uppercase if all will be displayed with <code>std::tolower</code>?</p>

<p>Check <code>std::isgraph</code> <a href=""http://en.cppreference.com/w/cpp/string/byte/isgraph"" rel=""nofollow"">here</a>.</p>
",0
30144700,30144588,1,"<p>If you enter a character in your program, weather it is a lower case or upper case letter, it will always end up in this first else statment:</p>

<pre><code>else if (isgraph(ch) )
{
    ch = tolower (ch);
    cout &lt;&lt; ch;
}
</code></pre>

<p>So you have to check first if your input is in upper/lower case.
For example <a href=""http://en.cppreference.com/w/cpp/string/byte/isupper"" rel=""nofollow"">isupper</a> and <a href=""http://en.cppreference.com/w/cpp/string/byte/islower"" rel=""nofollow"">islower</a> should be helpful.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cctype&gt;

int main ()
{
    using namespace std;

    char ch;

    while (ch != '@') {
        cin &gt;&gt; ch;

        if (isdigit (ch)) {
            cout &lt;&lt; ""this was a digit"" &lt;&lt; endl;
        }
        else if (isgraph(ch) &amp;&amp; isupper(ch)) {
            ch = tolower (ch);
            cout &lt;&lt; ch &lt;&lt; endl;
        }
        else if (isgraph(ch) &amp;&amp; islower(ch))
        {
            ch = toupper (ch);
            cout &lt;&lt; ch &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
",0
30152709,30152662,1,"<p>You should define those functions in <code>Circle.cpp</code>.</p>

<p>Suppose you define them in <code>Circle.h</code>, and two source files, <code>foo.cpp</code> and <code>bar.cpp</code>, include <code>Circle.h</code>. Then both object files <code>foo.o</code> and <code>bar.o</code> will contain code for those functions. Then if you attempt to link those two object files in order to build an executable, there will be a conflict between the two versions (even though they are identical).</p>

<p>You could define the functions in some other source file like 'Shape.cpp`, but then it would be difficult to remember where they were.</p>
",4
30155012,30152662,1,"<p>A good practice is to keep <strong><a href=""http://www.tutorialspoint.com/cplusplus/cpp_interfaces.htm"" rel=""nofollow"">class interface</a></strong> (only <a href=""http://www.cplusplus.com/doc/tutorial/classes/"" rel=""nofollow"">declarations</a>) in your <code>.h</code> file and member implementation in, a complementary, <code>.cpp</code> file.</p>

<p>In your example:</p>

<p><strong>in file <code>Circle.h</code></strong>:</p>

<pre><code>#ifndef _Circle_h_  
#define _Circle_h_

class Circle: {
private:
    float r;
public:
    Circle();
    Circle(float r);
    void Draw();
};

#include ""Circlce.cpp""
#endif
</code></pre>

<p><strong>in file <code>Circle.cpp</code></strong>:</p>

<pre><code>#include ""Circle.h""

Circle::Circle(){
    // code
}

Circle::Circle(float r){
    // code
}

void Circle::Draw(){
    // code
}
</code></pre>
",0
29453959,29453928,1,"<blockquote>
  <p>I mean, since the destructor is not virtual, I don't think you can delete a dynamically allocated instance of the derived class type using the pointer of the base class type. What do you think?</p>
</blockquote>

<p>You can see <a href=""https://stackoverflow.com/questions/20573587/why-simple-destructor-does-not-delete-the-derived-object-if-declared-using-base"">here</a> and <a href=""https://stackoverflow.com/questions/25220229/in-c-inheritance-derived-class-destructor-not-called-when-pointer-object-to-b"">here</a> that this is undefined behavior.</p>

<blockquote>
  <p>If the base class has no virtual destructor the behavior of such code is simply undefined.</p>
</blockquote>

<p><p></p>

<blockquote>
  <p>From the C++ standard:</p>
  
  <p>5.3.5 Delete</p>
  
  <p>3 In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand¡¯s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>
</blockquote>
",3
29455345,29453928,0,"<p>When a function is defined as virtual then the compiler will call the function using a pointer to the base using <em>dynamic binding</em>, i.e. the call to the actual function will go through the class vTable to find the relevant implementation of the function. If a function is not defined as virtual then the code generated by the compiler will use <em>static binding</em>, i.e. the compiler will simply call the function it knows. In other words, if you call a non-virtual function on the base class pointer which points to a derived class then the compiler will generate code for calling the base class implementation.</p>

<p>Now, destructor behavior is just a private case of the general behavior described above. As in the absence of a destructor implementation the compiler will generate a default non-virtual destructor for you, the destruction of an object using a base class pointer will just call the base class destructor. You can reproduce this behavior it easily by explicitly defining the non-virtual destructors for both base and derived classes and use the debugger to see that the base class version is the one being called.</p>
",0
30398079,30397886,3,"<p>Non-static data member initializers need to use braces or an equals sign. Parentheses are not an option, probably so that the whole <a href=""http://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""nofollow"">Most Vexing Parse</a> fiasco doesn't happen with data members. Change it to one of the following:</p>

<pre><code>test&lt;double&gt; first = 10.2; //option 1 (doesn't work with explicit constructor)
test&lt;double&gt; first{10.2}; //option 2
</code></pre>
",0
30398111,30397886,0,"<pre><code> test&lt;double&gt; first(10.2);
</code></pre>

<p>this is a syntax error.</p>

<p>it looks like either a function declaration with a constant value in place of an argument type (illegal), or the declaration of a member variable which is being initialised with illegal syntax.</p>
",0
30171133,30170854,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;set&gt;

using namespace std;

int main()
{

    multiset&lt;string&gt; words;

    for(string temp; cin &gt;&gt; temp; words.insert(temp))
    {
    }

    cout &lt;&lt; endl;
    copy(words.begin(), words.end(), ostream_iterator&lt;string&gt;(cout, ""\n""));

    return 0;
}
</code></pre>
",1
30171811,30171743,0,"<p>You have two extra <code>}</code>'s.  Once I removed them it compiled fine.</p>
",5
29461319,29461275,2,"<p>The following code defines fields (variables) rather then methods.</p>

<pre><code>public:
    Student(std::string, std::string, std::string);
    std::string get_name;
    std::string get_degree_programme;
    std::string get_level;
</code></pre>

<p>Then, when you implement it in the .cpp file the compiler complains that you try to implement a method that was not declared (since you declared get_name to be a variable).</p>

<pre><code>std::string Student::get_name()
{
    return name;
}
</code></pre>

<p>To fix, just change your code as below:</p>

<pre><code>public:
    Student(std::string, std::string, std::string);
    std::string get_name();
    std::string get_degree_programme();
    std::string get_level();
</code></pre>
",0
30152372,30152342,3,"<p>Stack allocation is nothing more than increasing and decreasing the value of a register.</p>

<p>Even if the compiler is a dumb one this means executing at most 1 ADD and 1 SUB instruction for each iteration. This is unlikely in any case, since the compiler knows that they are locals to the loop and that they can't change their size.</p>

<p>Actually they could also not stay on stack at all, since they could be fit in two floating point registers for the whole loop.</p>
",0
34084372,34084014,0,"<p>From the standard:</p>

<blockquote>
  <p>Unless specified otherwise, the distribution parameters are calculated as: pk = wk/S for k = 0, . . . , n?1 , in which the values wk, commonly known as the weights , shall be non-negative, non-NaN, and non-infinity.</p>
</blockquote>

<p>Therefore undefined behaviour.</p>
",0
32420151,32420139,2,"<p>Of course this doesn't work.</p>

<p>It's like calling <code>0xffffffff test = new 0xffffffff</code>. See? The statement doesn't make sense right</p>
",6
31129548,31129219,7,"<p>The listing for <code>a</code> says that it's a class with two fields: a vptr that points to a byte with offset 16 inside the vtable for A and a data element <code>a</code> containing zero. </p>

<p>The second is along the same lines but more complicated due to the virtual base class. It's saying b consists of 3 fields: an instance of A with fields similar to those above, and then the two elements of B, again as above. This time the vptr is directed at offset 24.</p>

<p>Why does the vptr point into the middle of the table rather than its start? You'd have to know more about the details of gcc memory layout to say, and I don't. It's possible the initial bytes are RTTI (run time type information) and the given offset is the first element of the array of virtual function pointers. There are uncountably many other options. </p>

<p>NB. There is some good information <a href=""https://stackoverflow.com/questions/5712808/what-is-the-first-int-0-vtable-entry-in-the-output-of-g-fdump-class"">in this earlier article</a> saying there are always 2 pointers leading the vtable: one for the multiple inheritance top pointer and another for RTTI.  If your machine and compiler are 64 bits (you really should mention this; it's important), this coincides with 16 bytes of pointers. B could be 24 bytes because there's an extra pointer to access the virtual base class.</p>
",1
29956701,29956684,6,"<p>The loop never executes</p>

<pre><code>for(int i=0; i&gt;98; i++){
</code></pre>

<p>since <code>i&gt;98</code> is <code>false</code></p>
",5
29956740,29956684,0,"<p>If you're asking what I think you're asking, absolutely. A for loop is almost more of a convenience syntax, giving you a place to specify an initial condition, a break condition, and a command to execute every iteration. To the best of my knowledge you can use as many or as few of these as you want, for example</p>

<pre><code>#include &lt;iostream&gt;
int main(){
    int myage = 0;
    for(; myage&lt;10; myage++)
        std::cout &lt;&lt; myage &lt;&lt; std::endl;
}
</code></pre>

<p>will print out the numbers 0 through 9. </p>
",0
29956779,29956684,0,"<p>Since this is already answered, you could improve and shorten your code by using += operator like this:
 <code>myage += 1;</code></p>

<p>or this:
<code>myage++;</code> </p>

<p>instead of <code>myage=myage+1;</code></p>
",0
29956975,29956684,0,"<p>Understanding scope is important. Loops and functions create a scope, and they can always access things at a higher up scope; however, things cannot be accessed from a smaller scope. Objects exist for the entire duration of their scope, and anything within that scope can access them.</p>

<pre><code>// Global scope:
int g = 0; // everything in this file can access this variable

class SomeClass
{
    // Class scope
    int c = 0;
    void ClassFunction()
    {
        // ClassFunction scope
        // Here we can access anything at global scope as well as anything within this class's scope:
        int f = 0;

        std::cout &lt;&lt; g &lt;&lt; std::endl; // fine, can access global scope
        std::cout &lt;&lt; c &lt;&lt; std::endl; // fine, can access class scope
        std::cout &lt;&lt; f &lt;&lt; std::endl; // fine, can access local scope
    }
    // Outside of ClassFunction, we can no longer access the variable f
};

void NonClassFunction()
{
    // NonClassFunction scope
    // We can access the global scope, but not class scope
    std::cout &lt;&lt; g &lt;&lt; std::endl;

    int n1 = 0;
    for (...)
    {
        // New scope
        // Here we can still access g and n1
        n1 = g;
        int x = 0;
    }
    // We can no longer access x, as the scope of x no longer exists

    if (...)
    {
        // New scope
        int x = 0; // fine, x has not been declared at this scope
        {
            // New scope
            x = 1;
            g = 1;
            n1 = 1;
            int n2 = 0;
        }
        // n2 no longer exists
        int n2 = 3; // fine, we are creating a new variable called n2
    }
}
</code></pre>

<p>Hopefully this has helped explain scope to you. With all this new information in mind, the answer is yes: you can access your variables within a for loop because the scope of those variables persists within an inner scope.</p>
",1
31129744,31129580,2,"<p>you can change pData into int *, then you can print the int valve.</p>

<hr>

<pre><code>cout&lt;&lt;*((int *)pData);
</code></pre>
",0
31130165,31129580,1,"<p>If you really need to allocate memory as <code>unsigned char*</code>, you can do it like below:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main() {
    int id = 12;
    int age = 14;

    // const pointer to buffer which can contain 2 ints
    unsigned char* const pData = new unsigned char[2*sizeof(int)];

    // non-const pointer to operate on data
    unsigned char* pDataPtr = pData;

    memcpy(pDataPtr,&amp;id,sizeof(int));
    pDataPtr += sizeof(int);
    memcpy(pDataPtr,&amp;age,sizeof(int));

    std::cout&lt;&lt;*reinterpret_cast&lt;int*&gt;(pData)&lt;&lt;std::endl;
    std::cout&lt;&lt;*reinterpret_cast&lt;int*&gt;(pData + sizeof(int))&lt;&lt;std::endl;

    delete [] pData;

    return 0;
}
</code></pre>
",0
31130223,31129580,2,"<p>After using <code>memcpy</code> to copy the bytes of an <code>int</code> into an unsigned char buffer, the only correct way to display the ints is to copy the bytes back into an int. For example:</p>

<pre><code>int temp_int;
memcpy(&amp;temp_int, pData, sizeof temp_int);
std::cout &lt;&lt; temp_int &lt;&lt; '\n';
memcpy(&amp;temp_int, pData + sizeof temp_int, sizeof temp_int);
std::cout &lt;&lt; temp_int &lt;&lt; '\n';
</code></pre>

<p>Attempting to reinterpret the buffer as an <code>int</code> would cause undefined behaviour by violating the strict aliasing rule.</p>
",2
31129855,31129580,1,"<p>You can print pData using reinterpret_cast operator :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;

int main(void)
{
    int id = 12;
    int age = 14;
    const size_t size = sizeof(int);
    unsigned char* pData = new unsigned char[2*size];
    memcpy(pData,&amp;id,size);/* using memcpy to copy */
    pData = pData + size;
    memcpy(pData,&amp;age,size);/* using memcpy to copy */
    std::cout&lt;&lt;*reinterpret_cast&lt;int*&gt;(pData)&lt;&lt;std::endl;
    pData = pData - size;
    std::cout&lt;&lt;*reinterpret_cast&lt;int*&gt;(pData)&lt;&lt;std::endl;
    delete []pData;
    return 0;
}
</code></pre>
",2
31129909,31129580,2,"<pre><code>memcpy(pData,&amp;id,4);
</code></pre>

<p>This line copies the four bytes data in id to pData as int but you declared it as char * .
if you declare it as int *pData = new int[2]; then you can ptint exact values.</p>

<pre><code> using namespace std;
 int id = 12;
 int age = 14;
 unsigned int* pData = new unsigned int[2];
 memcpy(pData,&amp;id,4);
 pData = pData + 1;
 memcpy(pData,&amp;age,4);
 pData = pData - 1;
 cout&lt;&lt;""ID:""&lt;&lt;pData[0]&lt;&lt;""\nAge:""&lt;&lt;pData[1]&lt;&lt;endl;
</code></pre>

<p>This will print the values.</p>
",6
30159018,30158982,1,"<p>Change:</p>

<pre><code>    printf (""%12.3f"",C[i][j]);
</code></pre>

<p>To</p>

<pre><code>    printf (""%12.0f"",C[i][j]);
</code></pre>

<p>The number after the decimal in the format specifier tells printf how many digits to include.</p>

<p>Google: ""printf format specifier"" for more details.</p>
",1
32957633,32956767,0,"<p>The immediate problem is here: </p>

<pre><code>while (len1 &gt; len2)
    num2 += ""0"";
while (len2 &gt; len1)
    num1 += ""0"";
</code></pre>

<p><code>len1</code> and <code>len2</code> are cached values and never change as the strings grow in size. Unless both strings are the same size, one loop will spin until the string it's modifying gets so big that the computer runs out of storage.</p>

<p>Solution (also removes the need to reverse the strings): </p>

<pre><code>while (len1 &gt; num2.length())
    num2 = ""0"" + num2;
while (len2 &gt; num1.length())
    num1 = ""0"" + num1;
</code></pre>

<p>Couple other problems in there, but you shouldn't have any trouble finding them <a href=""https://en.wikipedia.org/wiki/Debugger"" rel=""nofollow"">with a debugger</a>.</p>
",0
32965927,32965368,1,"<h1>The problem</h1>

<p>Your code work for this example but it won't work when you have a second ""max list"" which has more than 2 elements. </p>

<p>Indeed with <code>array[] = {2, 8, 8, 8, 8, 8, 6, 8, 8};</code>  (notice the last 8)<br>
We get the result : <code>middle=4</code> instead of <code>middle3</code> because you enter this branch condition when you encounter <code>8</code> again :</p>

<pre><code>else { 
   int a = array[m] - array[m-1];
</code></pre>

<p>And you enter the branch <code>if (a==0)</code> and you set <code>EndMax</code> to the end of the array !<br>
<code>StartMax = 1</code> and <code>Endmax = 8</code> thus <code>middle = 4</code>
This is not what you want !</p>

<p><a href=""http://ideone.com/i954QN"" rel=""nofollow"">Live Code</a></p>

<h1>Solution</h1>

<p>I would suggest to use a boolean tracker to manage that instead :</p>

<pre><code>size_t give_middle_max_list(const std::vector&lt;int&gt;&amp; v) {
    size_t idx_start_max = 0;
    size_t idx_end_max = 0;
    int max_val = v[0];
    bool should_continue = false;

    for(size_t i = 1; i &lt; v.size(); i ++) {
        if(v[i] &gt; max_val) {
            max_val = v[i];
            idx_start_max = i;
            idx_end_max = i;
            should_continue = true;
        }
        else {
            if (v[i] == max_val &amp;&amp; should_continue == true) {
                idx_end_max = i;   // I am still in the first max list 
            }
            else {
                should_continue = false; // I am not in the first max list anymore !
            }
        }
    }
    std::cout &lt;&lt; idx_start_max &lt;&lt; "";"" &lt;&lt; idx_end_max &lt;&lt; std::endl;
    return (idx_end_max + idx_start_max) / 2;
}
</code></pre>

<p><strong><a href=""http://coliru.stacked-crooked.com/a/127e4c79652afe52"" rel=""nofollow"">Live code</a></strong></p>
",1
30135860,30135668,7,"<p>Two ""correct"" ways to test:</p>

<ul>
<li>Isolate the fraction with <code>std::fmod(x, 1.0)</code>.</li>
<li>Discard the fraction using <code>floor</code> or <code>ceil</code> or <code>trunc</code>, e.g. test whether <code>x == std::floor(x)</code>.</li>
</ul>

<p>And one incorrect way:</p>

<ul>
<li>Casting to an integral type will fail (with undefined behavior!) for numbers outside the range of the destination type, so this is not suitable for validation of untrusted input (and if the input is trusted, why does it need to be validated?)</li>
</ul>

<blockquote>
  <p>A prvalue of a ?oating point type can be converted to a prvalue of an integer type.  The conversion truncates; that is, the fractional part is discarded.  <strong>The behavior is undefined if the truncated value cannot be represented in the destination type.</strong></p>
</blockquote>
",3
30135704,30135668,0,"<p>I think you are looking for something like this:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
  double a;
  std::cin &gt;&gt; a;
  if(int(a) != a)
  {
      std::cout &lt;&lt; ""decimal"";
  }
  else
  {
      std::cout &lt;&lt; ""no decimal"";
  }
  return 0;
}
</code></pre>
",2
32977894,32967635,0,"<p>You have too many <code>if else</code> conditions that make your code unnecessarily complex, to answer your second question specifically the unwanted behaviour is caused from the:  </p>

<pre><code>  if (tries &gt; 2)
  {
      break;
  }
</code></pre>

<p>which exits the loop regardless of the guess, as it is dependant only on the number of tries. Regarding your first question, I decided to provide you with more simple implementation that includes an answer to it as well.</p>

<p>You could replace your <code>while</code> loop with a <code>do-while</code> loop, terminated when the random number is guessed, i.e.:</p>

<pre><code>int main(){
    // initialize random seed
    srand (time(NULL));
    // generate a random number within [1,10]
    int secretRandom = rand() % 10 + 1;
    // initialize 
    int yourGuess = 11;

    // input loop
    string promptMessage = ""Type a a number from 1 to 10.""
    do{
        cout &lt;&lt; promptMessage &lt;&lt; '\n';
        // read input
        cin &gt;&gt; yourGuess &gt;&gt; endl;
        // guessed number relatively to the randomly generated  
        if (secretRandom &lt; yourGuess) cout &lt;&lt; ""The secret number is lower\n"";
        else if (secretRandom &gt; yourGuess)  cout &lt;&lt; ""The secret number is higher\n"";
    }while(yourGuess != secretRandom) 
    // if you guess the random number exit the loop and display success message
    cout &lt;&lt; ""You guessed right!\n"";

return 0;
}
</code></pre>

<p>To reduce the amount of guesses to specific number you can enclose the <code>do-while</code> loop and the <em>success message</em> in a <code>for</code> loop, for example: </p>

<pre><code>int numberOfGuesses = 3;
for (int i = 0; i &lt;= numberOfGuesses; ++i){
    //...
} 
</code></pre>

<p>If you want to enforce the user to input a number in the range from 1 to 10, you could do it by:</p>

<pre><code>int yourGuess = 11;
int lowerBound = 0;
int upperBound = 10;
do{
    cin &gt;&gt; yourGuess;
    // not type safe
}while(yourGuess &lt; lowerBound || yourGuess &gt; upperBound);
</code></pre>
",0
32978088,32967635,1,"<p>instead of writing the program for you here is some pseudo code.</p>

<pre><code>get a random number rand()%10+1  1..10 call it R
loop
  get user input N
  if N == R then show OK and break loop
  if N &lt; R show too low 
  else show too high
  increment tries
  if tries == 3 then break loop
end loop
</code></pre>
",2
27165517,27165375,0,"<p>assuming i>j, your prog to find HCF of two no.s using recursion can be done using while. try this :</p>

<pre><code>int i=val1,j=val2;
            while (j != 0)
            {
                int t;
                t = j;
                j = i % j;
                i = t;
            }
</code></pre>
",6
27165526,27165375,0,"<p>First, you identify the condition for ending the recursion, and that will be the condition to end your <code>while</code> loop.</p>

<p>Next, you identify the statements to be executed during recursion, and those will form the body of your <code>while</code> loop.</p>

<p>Lastly, you identify the statements to be executed upon the end of the recursion, and those will be performed right after the <code>while</code> loop.</p>

<p>Pseudocode:</p>

<pre class=""lang-cpp prettyprint-override""><code>while condition to perform recursion is true
{
  perform statements to be executed during recursion
}
perform statements to be executed upon exiting recursion
</code></pre>
",0
27176433,27176241,3,"<p>Normally this is solved by passing ""this"" object (i.e. instance) as a parameter to the static function:</p>

<pre><code>class foo
{
public:
    void startTheThread()
    {
        //Start the thread for the receive function (note ""this"")
        receiveMessageHandle = 
            _beginthreadex(0, 0, &amp;foo::receiveMessageThread, this, 0, 0);
    }
private:
    void receiveMessages()
    {
    }

    static unsigned int __stdcall receiveMessageThread(void *p_this)
    {
        foo* p_foo = static_cast&lt;foo*&gt;(p_this);
        p_foo-&gt;receiveMessages(); // Non-static member function!
        return 0;
    }
    unsigned int receiveMessageHandle;
};

// somewhere
foo* the_foo = ...
the_foo-&gt;startTheThread();
</code></pre>
",6
33032351,33032208,0,"<p>For some reason you define the variables for what you're counding (averages and counts) twice - once in <code>main</code> and the other time in <code>computePay</code>. You call <code>computePay</code> in a loop, and each time it is called, all the variables in it are re-initialized with zeros, thus you can't accumulate anything. There are two ways to fix this:</p>

<ol>
<li><p>Pass the variables from <code>main</code> into <code>computePay</code> as references:</p>

<pre><code>int computePay(int&amp; Length, char&amp; AuthorLevel, int &amp;averagePayout, int &amp;highestPayout, &lt;...&gt;);
//call it from main like:
computePay(Length, AuthorLevel, averagePayout, highestPayout, &lt;...&gt;);
</code></pre></li>
<li><p>Make those variables <code>static</code> inside the function - that will cause them to keep their values between function calls</p>

<pre><code>int computePay(int&amp; Length, char&amp; AuthorLevel)
{
   float PayOut;        // The final payout.
   static int numA = 0; // Number of A's that have been printed.
   static int numB = 0; // Total number of B's.
   &lt;...&gt;
</code></pre></li>
</ol>
",0
30213347,30213281,0,"<p>If the path doesn't exist until a certain time, you can check if it was loaded or empty:</p>

<pre><code>Mat imageIwantToLoad;
while (imageIwantToLoad.empty()) {
    imageIwantToLoad = imread(""test.jpg"", 1);
}
cout &lt;&lt; endl &lt;&lt; ""My image was finally loaded!"";
</code></pre>

<p>But you should implement other way to know or wait until the file is ready.</p>
",2
33013062,33012171,1,"<p>Not sure what you want to do, but according to <a href=""http://www.codeproject.com/Articles/12612/HexView-an-introductory-MFC-application"" rel=""nofollow"">this</a> tutorial your code should look like:</p>

<pre><code>class CHexApp : public CWinApp 
{
protected:
    //{{AFX_VIRTUAL(CHexApp)
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

protected:
    //}}AFX_MSG(CHexApp)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};
</code></pre>
",0
31885225,31883260,0,"<p>In <code>class A</code>, the <code>func()</code> is worthless because:<br>
1. <code>size</code> is not returned to the caller.<br>
2. The pointer <code>data</code> is local to <code>func</code> and it's contents will disappear after the end of execution in <code>func()</code>.  </p>

<p>You don't need to return <code>const int</code> from a function.  A function will return a <em>copy</em> of variables, so they are constant (copies).  </p>

<p>Don't use <code>malloc</code> in C++, use <code>operator new</code>.  The <code>malloc</code> function does not call constructors for objects.  </p>

<p>Don't use <code>new</code> or <code>malloc</code> <em>unless absolutely necessary</em>.  Usually, dynamic memory is for containers where their capacity is not known at compile time; or for objects that live beyond a function or statement block's execution time.  If you must use dynamic memory, use a smart pointer (like <code>boost::shared_ptr</code>).  </p>

<p>Use <code>std::vector</code> for dynamic arrays.  It works; it's been tested; you don't have to write your own, including memory management.  </p>

<p>You are passing <code>data</code> by value (a copy of the pointer).  If you want to modify a pointer, pass it by reference or pass a pointer to the pointer; (what I call the address of the pointer).  </p>

<p>Example:   </p>

<pre><code>void my_function(uint8_t * &amp; p_data)
{
  p_data = new uint8_t[512];
}
</code></pre>

<p>Or</p>

<pre><code>void another_function(unsigned char * * pp_data)
{
  *pp_data = new unsigned char [1024];
}
</code></pre>

<p>A much better solution:</p>

<pre><code>void better_function(std::vector&lt;uint8_t&gt;&amp; data)
{
  data.reserve(64);
  for (uint8_t i = 0; i &lt; 64; ++i)
  {
    data[i] = i;
  }
}
</code></pre>
",3
31271772,31271256,0,"<p>In C++, enums are only implicitly convertible to an <code>int</code> type; it makes no sense to associate a <code>const char*</code> or <code>std::string</code> type like ""John"". Moreover, enumerated types are supposed to represent a collection of predefined values instead of runtime values like so:</p>

<pre><code>enum Colors { BLUE, RED, GREEN };
</code></pre>

<p>or with C++11:</p>

<pre><code>enum class Colors { BLUE, RED, GREEN };
</code></pre>

<p>Your class should be holding a std::string type variable to store a name read from a file since it is more intuitive for a name to be a std::string type rather than a predefined value.</p>

<p>If we can assume your file looks like so:</p>

<pre><code>John
Mary
Joseph
Karen
</code></pre>

<p>you can write code like this:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
using namespace std;

struct MyInfo{
    std::string name;
    MyInfo(const std::string&amp; s) : name(s) {}
    MyInfo() {}
};

int main (int argc, char** argv)
{
  ifstream file(""myfile.txt"");
  string line;

  if (!file){
     // handle error
     return;
  }

   while (file){
      getline(file, line);
      MyInfo m(line); // this is your MyInfo object
      // ...
   }
}
</code></pre>
",0
31271563,31271256,0,"<p>Hard to really understand what you need, but reading strings and converting them to enum value can be done by explicit ifs</p>

<pre><code>std::ifstream in(...);
std::string name;
in &gt;&gt; name;
MyInfo info;
if (name == ""John"")
   info.person = Person2Name;
</code></pre>

<p>or some maps</p>

<pre><code>std::map&lt;std::string, Person&gt; map;
map[""John""] = Person2Name;
in &gt;&gt; name;
info.person = map[name]; // UGLY! not checking if name is in map (use std::map::find in real code)
</code></pre>

<p>Still it's strange to hardcode all available names as enum in code.</p>
",0
32940842,32940826,2,"<p>Using <code>&amp;ptr-&gt;array[a]</code> will give you a pointer to element <code>a</code> within <code>ptr-&gt;array</code>.</p>
",0
32940857,32940826,0,"<p>and also <code>ptr-&gt;array+a</code>, becuase of pointer arithmetics. but use @Vaughn Cato way for readability.</p>
",0
32940905,32940826,0,"<p>You can use the address-of operator (&amp;) to get the address of a variable. (As in <code>&amp;ptr-&gt;array[a]</code>.)</p>

<p>However, since <code>ptr-&gt;array</code> is already an address, you can also use the syntax <code>ptr-&gt;array + a</code>.</p>
",2
27689801,27689777,5,"<p><code>x</code> is defined in two translation units (because the defining header is included by two cpp files). Define it only once:</p>

<p>main.cpp:</p>

<pre><code>#include ""a.h""

int main()
{
    return 0;
}
</code></pre>

<p>a.cpp:</p>

<pre><code>#include ""a.h""
int x = 0;
</code></pre>

<p>a.h:</p>

<pre><code>#ifndef A_H
#define A_H

extern int x;

#endif // A_H
</code></pre>
",0
27689808,27689777,1,"<p>You need to declare <code>int x</code> in a.cpp and <code>extern int x</code> in a.h.</p>
",0
30718148,30717761,0,"<p>Local variables are not created on the heap. We say that they are created on stack. But in reality, registers are used to store the local variables, if available. Storing in registers is far less expensive than storing in stack. Every-time the line int b = 2 is encountered in the loop, the register is re-written. Therefore, you will not get a redefinition error. That's the reason the value of b is lost every iteration.</p>
",0
30717997,30717761,0,"<p>When an object is declared and initialized, there are two things that we need to think about:</p>

<ol>
<li>Allocation of memory for the object.</li>
<li>Initializing the object.</li>
</ol>

<p>When a stack frame is created for a function, the stack frame <em>usually</em> has enough space for not only the automatic variables in the function scope but also local variables that are in the function. In that case, when the line</p>

<pre><code>  int b=2;
</code></pre>

<p>is executed in the loop, the only thing that happens is the value of the variable is re-initialized in every iteration of the loop.</p>

<p>It's quite possible for a run time environment to push the memory required for <code>b</code> onto the stack frame when the loop is entered and pop the memory when the loop ends.</p>

<p>If a run time environment uses the first strategy, the address of <code>b</code> is going to be same in every iteration of the loop.</p>

<p>In a run time environment uses the second strategy, the address of <code>b</code> will most likely be same in every iteration of the loop. I am hesitant to say a definite ""is going to be the same"" because I am not sure.</p>
",0
30717797,30717761,0,"<p>The creation of the variable for each iteration is optimized out, and instead it's simply initialized once every iteration through the loop. See <a href=""https://stackoverflow.com/questions/7959573/declaring-variables-inside-loops-good-practice-or-bad-practice-2-parter"">this question</a>.</p>
",0
30717814,30717761,0,"<p>There's a new <code>b</code> in the same location on every iteration.<br>
Since the ""old"" one doesn't exist on the following iteration, the space it occupied can be reused.<br>
If this didn't happen, you'd run out of memory very quickly.</p>
",4
30717835,30717761,2,"<p>A (non-static) variable defined in a block is re-created every time that block is entered.</p>

<p>If it's a local variable, it may easily reside at the same address on successive entries to the block. In the case of an <code>int</code>, nothing needs to be done (other than allocating space) to create the variable.</p>

<p>On the other hand, if you were to create an object of a type with a constructor that did something, whatever the constructor did would execute every time that block was entered (and the destructor would run every time execution left the block).</p>
",2
30197422,30197308,1,"<p>My advice is forget that C++ has the goto statement and never use it. :) When the goto statement is used the program loses its structure and as result such programs are difficult to read. Also one goto statement usually produces another goto statements in the same program because the discipline of writing the structured code is broken.:) And usually it is dificult to modify such programs. </p>

<p>The program that you showed can be rewritten the following way</p>

<pre><code>#include &lt;iostream&gt;

int main() 
{
    const int N = 10;
    int i = 0;

    do
    { 
       std::cout &lt;&lt; i &lt;&lt; "" is less than "" &lt;&lt; N &lt;&lt; ""\n"";
    } while ( ++i &lt; N );

    return 0;
}
</code></pre>

<p>Or the following way</p>

<pre><code>#include &lt;iostream&gt;

int main() 
{
    const int N = 10;

    for ( int i = 0; i &lt; N; i++ )
    { 
       std::cout &lt;&lt; i &lt;&lt; "" is less than "" &lt;&lt; N &lt;&lt; ""\n"";
    }

    return 0;
}
</code></pre>

<p>Though in general case when N can be initially set to 0 the two programs are not equivalent.</p>

<p>Take into account that variable a is not used in your porgram and its declaration should be removed.</p>

<p>Also it is a bad idea to use keywords as identifiers. <strong>this</strong> is a reserved keyword in C++.</p>
",1
30197342,30197308,7,"<p>Arguably, there's no proper way to use <code>goto</code>. Use a structured loop instead:</p>

<pre><code>for (int i = 0; i &lt; 10; ++i) {    
    std::cout &lt;&lt; i &lt;&lt; "" is less than 10\n"";
}
</code></pre>

<p>If you insist on using <code>goto</code>, then you'll have to change the name of the label. <code>this</code> is a keyword in C++, and can't be used as an identifier.</p>
",18
29899193,29899057,-3,"<p>Exceptions provide a way to react to exceptional circumstances (like runtime errors) in programs by transferring control to special functions called handlers.</p>

<p>To catch exceptions, a portion of code is placed under exception inspection. This is done by enclosing that portion of code in a try-block. When an exceptional circumstance arises within that block, an exception is thrown that transfers the control to the exception handler. If no exception is thrown, the code continues normally and all handlers are ignored</p>

<p><a href=""http://www.cplusplus.com/doc/tutorial/exceptions/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/exceptions/</a></p>
",0
29899277,29899057,2,"<p><code>try</code> is a statement, so it can appear anywhere a statement can appear. It is designed to allow you to handle exceptions.</p>
<pre><code>try
{
    //this code may throw!
}
</code></pre>
<p>After <code>try</code> block, there must be <strong>one or more</strong> handling blocks (or simply: handlers), that are defined as <code>catch</code> block:</p>
<pre><code>catch(const std::exception&amp; e)
{
}
catch(const MyException&amp; e)
{
}
...
</code></pre>
<p>Formal parameter of <code>catch</code> block determines, what types of exceptions can be caught (and causes this block to be entered).</p>
<blockquote>
<p>When an exception of type <code>E</code> is thrown by any statement in compound-statement (<code>try</code> block), it is matched against the types of the formal parameters <code>T</code> of each catch-clause (<code>catch</code> block) [...], in the order in which the catch clauses are listed. The exception is a match if any of the following is true:</p>
<ul>
<li><code>E</code> and <code>T</code> are the same type (ignoring top-level cv-qualifiers on <code>T</code>)</li>
<li><code>T</code> is an lvalue-reference to (possibly cv-qualified) <code>E</code></li>
<li><code>T</code> is an unambiguous public base class of <code>E</code></li>
<li><code>T</code> is a reference to an unambiguous public base class of <code>E</code></li>
<li><code>T</code> is a (possibly cv-qualified) pointer or a reference to a const pointer (since C++14), and <code>E</code> is also a pointer, which is implicitly convertible to <code>T</code></li>
<li><code>T</code> is a pointer or a pointer to member or a reference to a const pointer (since C++14), while <code>E</code> is <code>std::nullptr_t</code>.</li>
</ul>
</blockquote>
<p>Source: <a href=""http://en.cppreference.com/w/cpp/language/try_catch"" rel=""nofollow noreferrer"">try-block</a>.</p>
",0
31300997,31300904,4,"<p>Each time you assign an instance of the variable <code>ob</code> of type <code>B</code> an integer value, you are basically constructing a new instance of <code>B</code> thus calling the constructor. Think about it, how else would the compiler know how to create an instance of <code>B</code> if not through the constructor taking an <code>int</code> as parameter?</p>

<p>If you overloaded the assignment operator for your class <code>B</code> taking an <code>int</code>, it would be called:</p>

<pre><code>B&amp; operator=(int rhs)
{
    cout &lt;&lt; ""Assignment operator"" &lt;&lt; endl;
}
</code></pre>

<p>This would result in the first line: <code>B ob = 5;</code> to use the constructor, while the two following would use the assignment operator, see for yourself:</p>

<pre><code>Constructor called
Assignment operator
Assignment operator
</code></pre>

<p><a href=""http://ideone.com/fAjoA4"" rel=""nofollow"">http://ideone.com/fAjoA4</a></p>

<p>If you do not want your constructor taking an <code>int</code> to be called upon assignment, you can declare it <code>explicit</code> like this:</p>

<pre><code>explicit B(int x)
{
    cout &lt;&lt; ""Constructor called"" &lt;&lt; endl;
}
</code></pre>

<p>This would cause a compiler error with your code, since it would no longer be allowed to implicitly construct an instance of <code>B</code> from an integer, instead it would have to be done explicitly, like this:</p>

<pre><code>B ob(5);
</code></pre>

<p>On a side note, your constructor taking an <code>int</code> as parameter, is not a default constructor, a default constructor is a constructor which can be called with no arguments.</p>
",0
31301020,31300904,5,"<blockquote>
  <p>B ob =5;</p>
</blockquote>

<p>This uses the given constructor.</p>

<blockquote>
  <p>ob=6;</p>
</blockquote>

<p>This uses the given constructor because there is not a <code>B&amp; operator=(int)</code> function and <code>6</code> must be converted to type <code>B</code>. One path to do this is to temporarily construct a <code>B</code> and use it in the assignment.</p>

<blockquote>
  <p>ob=7;</p>
</blockquote>

<p>Same answer as above.</p>

<blockquote>
  <p>I fail to understand why is the constructor being called thrice with each assignment</p>
</blockquote>

<p>As I stated above you do not have a <code>B&amp; operator=(int)</code> function but the compiler is happy to provide a copy assignment operator (i.e., <code>B&amp; operator=(const B&amp;);</code>) for you <a href=""https://stackoverflow.com/questions/3734247/what-are-all-the-member-functions-created-by-compiler-for-a-class-does-that-hap"">automatically</a>. The compiler generated assignment operator is being called and it takes a <code>B</code> type and all <code>int</code> types can be converted to a <code>B</code> type (via the constructor you provided).</p>

<p><strong>Note:</strong> You can disable the implicit conversion by using <code>explicit</code> (i.e., <code>explicit B(int x);</code>) and I would recommend the use of <code>explicit</code> except when implicit conversions are desired.</p>

<h3>Example</h3>

<pre><code>#include &lt;iostream&gt;

class B
{
public:
    B(int x) { std::cout &lt;&lt; ""B ctor\n""; }

    B(const B&amp; b) { std::cout &lt;&lt; B copy ctor\n""; }
};

B createB()
{
    B b = 5;
    return b;
}

int main()
{
    B b = createB();

    return 0;
}
</code></pre>

<h3>Example Output</h3>

<p>Note: Compiled using Visual Studio 2013 (Release)</p>

<pre><code>B ctor
</code></pre>

<p>This shows the copy constructor was elided (i.e., the <code>B</code> instance in the <code>createB</code> function is triggered but no other constructors).</p>
",2
31301748,31300904,3,"<p>You are not taking the <strong>assignment operator</strong> into account.  Since you have not defined your own <code>operator=()</code> implementation, the compiler generates a default <code>operator=(const B&amp;)</code> implementation instead. 
Thus, your code is effectively doing the following logic:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class B
{
  public:  
  B(int x) //custom constructor
  {
    cout &lt;&lt; ""Constructor called"" &lt;&lt; endl;
  }    

  B(const B &amp;b)  //copy constructor
  {
     cout &lt;&lt; ""Copy constructor called"" &lt;&lt; endl;
  } 

  B&amp; operator=(const B &amp;b)  //default assignment operator
  {
     return *this;
  } 
};

int main()
{ 
  B ob(5); 
  ob.operator=(B(6));
  ob.operator=(B(7));

  return 0;
}
</code></pre>

<p>The compiler-generated <code>operator=()</code> operator expects a <code>B</code> object as input, but you are passing an <code>int</code> value instead.  Since <code>B</code> has a non-<code>explicit</code> constructor that accepts an <code>int</code> as input, the compiler is free to perform an implicit conversion from <code>int</code> to <code>B</code> using a temporary object.</p>

<p>That is why you are seeing your constructor invoked three times - the two assignments are creating temporary <code>B</code> objects.  </p>
",0
30400945,30400895,3,"<p>this is a complex problem which those wonderful guys at boost.org have already solved for you:</p>

<p><a href=""http://www.boost.org/doc/libs/1_58_0/libs/serialization/doc/index.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_58_0/libs/serialization/doc/index.html</a></p>
",1
30185299,30185183,-1,"<p>Is it possible that when you are executing the line</p>

<p><code>traverser_prev-&gt;next = traverser-&gt;next;</code></p>

<p>traverser_prev == NULL?</p>
",3
30185313,30185183,2,"<p><em>One</em> problem is that in the <code>delete_node</code> function you pass the list head <em>by value</em>, which means that the pointer is copied and inside the function you only modify the copy.</p>

<p>There are two solutions: Either don't use the argument at all and only use the global variable, or pass the argument <em>by reference</em>:</p>

<pre><code>void delete_node(node*&amp; hea)
</code></pre>
",0
34204695,34204446,2,"<blockquote>
  <p>I don't know why it is corrupting iterator in this case.</p>
</blockquote>

<p>Just read <a href=""http://en.cppreference.com/w/cpp/container/list/pop_front"" rel=""nofollow"">documentation</a>:</p>

<blockquote>
  <p>References and iterators to the erased element are invalidated.</p>
</blockquote>

<p>in the first iteration <code>itr</code> points to <code>l.begin()</code> which erased, then <code>++itr</code> on invalid iterator fails. You need to increase iterator before <code>pop_front()</code> called. But better you erase explicitly using iterator to avoid surprises:</p>

<pre><code>for (list&lt;int&gt;::iterator itr=l.begin(); itr != l.end(); )
{
    if(*itr &lt;= 3) l.erase( it++ );
    else ++it; 
}
</code></pre>

<p>This code may have different behavior than yours as you always delete the first element no matter where <code>itr</code> points to but I assume you wanted to delete elements less or equal than 3.</p>
",0
34204848,34204446,0,"<p>So there's a few things going on here.</p>

<p>First: you're changing a list while iterating through it. Typically this is a bad idea to attempt. Consider list as a linked list. Each node consists of its own value and a pointer/reference to the next element. By popping an item you remove it from the list, then the iterator will no longer know where to look for the next element. It's actually a bit more complicated than this (each type of standard collection has certain defined operations that have to invalidate iterators, but they vary between collection types), but this is the general idea.</p>

<p>Second: you aren't removing elements with an index less than 3, you're trying to remove elements with a value less than 3. It would work logically in this case only because the first 3 elements have values 1, 2, and 3.</p>

<p>To fix your problem I would write your second loop like this:</p>

<pre><code>for(int index=0; index&lt;3; index++){
  l.pop_front();
}
</code></pre>

<p>And then you can iterate through the list later if there are other operations you need to perform.</p>
",0
34206951,34204446,0,"<p>Thanks for your response, </p>

<p>I think I found answer for question I asked for:</p>

<p>Answer: In for loop 'Initiating iterator with list begin' and in for loop block I am deleting 'first element of list using pop_front', once we delete first element list.begin() changes to next element in list. but still iterator is not. so it is becoming dangling pointer, and next we are accessing dangling pointer in next loop, Hence it is dumping code.  </p>

<p>Found above informations through gdb. </p>

<pre><code>Breakpoint 2, main (argc=1, argv=0x7fffffffdfd8) at list_erase.cpp:20
20      for (list&lt;int&gt;::iterator itr=l.begin(); itr != l.end(); ++itr)
(gdb) n
22          if(*itr &lt;= 3)
(gdb) p *itr
$5 = (int &amp;) @0x603020: 1
(gdb) p itr
$6 = {_M_node = 0x603010}
(gdb) p l.begin()
$7 = {_M_node = 0x603010}
(gdb) n
23              l.pop_front();
(gdb) n
20      for (list&lt;int&gt;::iterator itr=l.begin(); itr != l.end(); ++itr)
(gdb) p itr
$8 = {_M_node = 0x603010}
(gdb) p l.begin()
$9 = {_M_node = 0x603030} 
(gdb) n
22          if(*itr &lt;= 3)
(gdb) p itr
$10 = {_M_node = 0x0}
(gdb) p l.begin()
$11 = {_M_node = 0x603030}
</code></pre>

<p>To fix my problem through 'pop_front', I should do like below:</p>

<pre><code> for (list&lt;int&gt;::iterator itr=l.begin(); itr != l.end(); )
 {
    if(*itr &lt;= 3)
    {
       l.pop_front();
       itr = l.begin();
       //  OR
       // itr = l.erase(l.begin()); 
    }else
       ++itr;
 }
</code></pre>

<p>'pop_front work like this' :
Since, std::list pop_front implemented like below:</p>

<pre><code> void pop_front() { erase(begin()); } 
</code></pre>

<p>And in pop_front code implementation, we are not catching return value of next element of list, so after it erase it will be dangling pointer. So, crash expected.</p>

<p>Let me know, If am wrong..</p>
",0
31260013,31259967,1,"<p>You must define the constructor in the .h file:</p>

<pre><code>MyList&lt;T&gt;::MyList() {};
</code></pre>

<p>and </p>

<pre><code>MyList&lt;T&gt;::MyList(initializer_list&lt;T&gt; li):List&lt;T&gt;(Li) {};
</code></pre>
",1
31260086,31259967,2,"<p>You have to specify <code>list&lt;T&gt;</code> in mem-initializers of the constructors. For example</p>

<pre><code>template&lt;class T&gt;
MyList&lt;T&gt;::MyList():list&lt;T&gt;()
{

}

template&lt;class T&gt;
MyList&lt;T&gt;::MyList(initializer_list&lt;T&gt; li):list&lt;T&gt;(li){

}
</code></pre>

<p>Though the first constructor could be written simpler</p>

<pre><code>template&lt;class T&gt;
MyList&lt;T&gt;::MyList()
{

}
</code></pre>

<p>Or it could be defined in the class definition like</p>

<pre><code>MyList() = default;
</code></pre>
",0
29912044,29911947,1,"<p>""What kind of collection should I use to get best performance?"" - a <code>std::vector&lt;element&gt;</code> is a good fit for storing the elements.</p>

<p>To sort, you've a rather unusual ordering requirement.  I can't think of an efficient way to directly sort the elements into the desired order, so I suggest you initially create three indices - one for each element, then you can iterate through all of them concurrently, taking turns at selecting the next element from each of the three indices, but skipping over any already-selected elements while doing so.</p>

<pre><code>std::vector&lt;element&gt; v;
element e;
std::vector&lt;std::pair&lt;decltype(e.c1), size_t&gt;&gt; byc1;
std::vector&lt;std::pair&lt;decltype(e.c2), size_t&gt;&gt; byc2;
std::vector&lt;std::pair&lt;decltype(e.c3), size_t&gt;&gt; byc3;
while (input_file &gt;&gt; e.c1 &gt;&gt; e.c2 &gt;&gt; e.c3)
{
    byc1.emplace_back(e.c1, v.size());
    byc2.emplace_back(e.c2, v.size());
    byc3.emplace_back(e.c3, v.size());
    v.push_back(e);
}
std::sort(byc1.begin(), byc1.end());
std::sort(byc2.begin(), byc2.end());
std::sort(byc3.begin(), byc3.end());
std::vector&lt;bool&gt; already_selected(v.size());
std::vector&lt;size_t&gt; index;
auto in_byc1 = byc1.rbegin();
auto in_byc2 = byc2.rbegin();
auto in_byc3 = byc3.rbegin();
for (size_t i = 0; i &lt; v.size(); ++i)
{
    while (already_selected[in_byc1-&gt;first])
        ++in_byc1;
    index.push_back(in_byc1-&gt;second);
    already_selected[in_byc1-&gt;first] = true;

    while (already_selected[in_byc2-&gt;first])
        ++in_byc2;
    index.push_back(in_byc2-&gt;second);
    already_selected[in_byc2-&gt;first] = true;

    while (already_selected[in_byc3-&gt;first])
        ++in_byc3;
    index.push_back(in_byc3-&gt;second);
    already_selected[in_byc3-&gt;first] = true;
}
</code></pre>

<p>That should leave <code>index</code> with the desired order of elements (e.g. in your example, index should contain the numbers 2, 6, 3, 5, 4 and 1): you can then use the values from index to loop up the actual <code>element</code> values in <code>v</code>.  If you've reason to, you can then use the index to actually sort the data, or a copy of it... left as an exercise for the OP.</p>
",6
30204568,30204535,0,"<p><a href=""https://msdn.microsoft.com/en-us/library/37zc9d2w.aspx"" rel=""nofollow"">Here</a> is the description of break statement from MSDN.</p>

<blockquote>
  <p>The break statement ends execution of the nearest enclosing loop or
  conditional statement in which it appears. Control passes to the
  statement that follows the end of the statement, if any.</p>
</blockquote>

<p>Comment out the break statement as you are not using a while or for statement.</p>

<pre><code>if(num&gt;76)
{
    cout&lt;&lt;""You lose!\n"";
    //break;
}
</code></pre>
",4
30204579,30204535,3,"<p>The error message says it all:</p>

<blockquote>
  <p><code>break</code> statement not within loop or switch</p>
</blockquote>

<p>There are only two places you can use a <code>break</code> statement in C++: within a loop (whether <code>for</code>, <code>while</code>, or <code>do/while</code>) and within a <code>switch</code>. Your <code>break</code> meets neither of those criteria, so it's invalid.</p>

<p>Note that the code you just posted is structured as:</p>

<pre><code>while (count &lt;= 10) {  // &lt;== this loop encloses
    ...
    break;             // &lt;== this break statement
    ...
}
</code></pre>

<p>whereas your original example has no loop.</p>
",0
30204582,30204535,0,"<p>You probably want return(1) instead to exit the function. Break is used to 'break' out of a loop. IE if you have a 'for' loop, you can 'break' out of it and stop iterating.</p>

<p>In other words, a return statement will 'break' out of this function and get you the same results you need. </p>

<p>In your code, there isn't a while loop. In the example you've showed, there IS a while loop. If you're attempting to copy that code to learn from , you're missing that line.</p>

<p>Note, that you can return anything. It does not have to be 1. The return keyword is just an alternative to your intended use of break.</p>
",2
30204594,30204535,0,"<p>You can't put a <code>break</code> statement inside an <code>if</code> loop. You can only use a jump statement like <code>break</code> or <code>continue</code> within a <code>for</code> or <code>while</code>. An <code>if</code> statement only executes once, whereas a <code>for</code> or <code>while</code> loop could continue for a while (which is why you'd want to <code>break</code> or <code>continue</code> from it).</p>

<p><code>break</code> and <code>continue</code> will perform the action for the inner-most loop. Having the following code:</p>

<pre><code>while (...)
{
    for (;;)
    {
        if (...)
        {
            break; // this IS valid, because it will break from the for loop (only the for loop, not the while loop)
        }
    }
}
</code></pre>
",0
31541753,31541652,5,"<p><code>guess</code> has a size of <code>4</code>, however, you enter a number between <code>1000 - 9999</code> which is <code>4</code> characters long. Remember that in a string, there must be a <code>\0</code> at the end of the string, so <code>guess</code> is 1 character short. This might be overwriting the first element of <code>answer</code>. Try making <code>guess</code> of size 5, or better yet, use <code>std::string</code> instead.</p>
",3
31542193,31541652,0,"<p>Clearly, the <code>guess</code> is an array of 4 chars. Whenever the user enters characters in range <code>1000-9999</code> it doesn't have a space for the string terminator '\0'. Thus, you need to define the array as:</p>

<pre><code>char guess[5];
</code></pre>

<p>or you can use <code>string</code> implementations too</p>
",0
29951584,29951273,0,"<p>You can do it following this code:</p>

<pre><code>  std::ifstream is (""test.txt"", std::ifstream::binary);
  if (is) {
    // get length of file:
    is.seekg (0, is.end);
    int length = is.tellg();
    is.seekg (0, is.beg);

    char * buffer = new char [length];

    std::cout &lt;&lt; ""Reading "" &lt;&lt; length &lt;&lt; "" characters... "";
    // read data as a block:
    is.read (buffer,length);

    if (is)
      std::cout &lt;&lt; ""all characters read successfully."";
    else
      std::cout &lt;&lt; ""error: only "" &lt;&lt; is.gcount() &lt;&lt; "" could be read"";
    is.close();

    // ...buffer contains the entire file...

    delete[] buffer;
  }
</code></pre>

<p>Found this snippet of code here: <a href=""http://www.cplusplus.com/reference/istream/istream/read/"" rel=""nofollow"">http://www.cplusplus.com/reference/istream/istream/read/</a></p>

<p>Replace ""test.txt"" with the name of your file.  However your main code has no way of knowing what the file name is created in Get_Answers().</p>
",0
29951521,29951273,0,"<p>If you mean store each line to an array, a for loop and getline should work well.</p>

<p>Edit: judging by your previous answer, I would say yes this is how to do it.</p>

<p>To elaborate a little more, a simple way of doing this would be to make a for loop to count how many lines there are, then go to the beginning of the file and make another for loop: for(int i = 0; i != lines; i++) </p>

<p>Then in the for loop make it array[i] = getline(file,string);</p>

<p>You can use while(!file.EOF()) instead of the for loop and the while loop. I just prefer getting a line count for some reason.</p>
",2
29952241,29951273,0,"<p>Ok, judging by what you wrote as your question and by my debug results, the problem you have is that you correctly read the file inside the function, but you don't pass this data outside the Get_Answers() function.</p>

<p>I think the C++ way of doing this would be:</p>

<p>1) Initialize a pointer to empty char array in main() function:</p>

<pre><code>char* userAnswersPointer = new char[NUM_ANSWERS];
</code></pre>

<p>2) Parametrize your Get_Answer() function to pass a pointer to this array:</p>

<pre><code>void Get_Answers(char* userAnswers_Ptr, int N_ANS) {

//...

for (int i = 0; i &lt; N_ANS; i++)
    {
        cout &lt;&lt; ""\nEnter the test answers "";
        cin &gt;&gt; userAnswers_Ptr[i];

        textFileOut &lt;&lt; userAnswers[i] &lt;&lt; '\n';
    }

//...

}
</code></pre>

<p>3) Use it properly in main():</p>

<pre><code>int main() {

    //...

    Get_Answers(userAnswersPointer, NUM_ANSWERS);

    //...

    return 0;
}
</code></pre>

<p>I didn't compile it, just wrote out of my head, so feel free to check this out. It should give you an idea how this should be done.</p>
",1
29149074,29148930,1,"<p>Use std::setprecision(N), where N is the total number of digits to be printed.</p>

<pre><code>double x = 1.23456789;
std::cout &lt;&lt; ""x: "" &lt;&lt; std::setprecision(3) &lt;&lt; x &lt;&lt; std::endl; // Prints 1.23
std::cout &lt;&lt; ""x: "" &lt;&lt; std::setprecision(7) &lt;&lt; x &lt;&lt; std::endl; // Prints 1.234567
</code></pre>
",0
29149198,29148930,0,"<p>For C try the following</p>

<pre><code>    # include &lt;float.h&gt;
     .  .  .
    printf(""Our approximation is: %20.*lf"", DBL_DIG , x);
</code></pre>

<p>Note: %lf is the correct specifier to double (not %f)</p>

<p>For C++ use <code>setprecision(DBL_DIG)</code> before output</p>
",0
32996354,32996268,1,"<p>No you can't. <code>new int</code> returns an <code>int*</code> and the behaviour on casting it to <code>int</code> is undefined.</p>

<p>If you dislike explicit pointers, you could write <code>typedef int* int_ptr;</code> and use <code>int_ptr my_var = new int;</code></p>

<p>And yes, you <strong>must</strong> <code>delete my_var</code> at some point.</p>
",0
32997579,32996268,1,"<p>Memory allocation is taken care if you just write :</p>

<pre><code>int n = 45;
</code></pre>

<p>but when using dynamic allocation, you have to use pointer and new operator, so that it can be deleted later:</p>

<pre><code>int * foo;
foo = new int [5];
</code></pre>

<p>If you dont want your program to terminated during allocation due to some exception, try using nothrow. example:</p>

<pre><code>int * foo;
foo = new (nothrow) int [5];
if (foo == nullptr) {
// error assigning memory. Take measures. 
}
</code></pre>

<p>using nothrow the pointer returned by new is a null pointer, and the program continues its execution normally.</p>
",1
31815027,31814957,11,"<p>The point of functions is reusability. If you find yourself writing certain long expressions or groups of statements repeatedly, it might be time to refactor it out.</p>

<p>In this case, I would write a simple function to do the bounds checking:</p>

<pre><code>bool isInBounds(int a, int b, int c, int d, int e)
{
     return a &gt;= 0 &amp;&amp; a &lt; 16 &amp;&amp;
            b &gt;= 0 &amp;&amp; b &lt; 16 &amp;&amp;
            c &gt;= 0 &amp;&amp; c &lt; 16 &amp;&amp; 
            d &gt;= 0 &amp;&amp; d &lt; 16 &amp;&amp;
            e &gt;= 0 &amp;&amp; e &lt; 16;
}
</code></pre>

<p>Then use it instead of your long condition:</p>

<pre><code>if (isInBounds(a, b, c, d, e))
{
    // do things with array[a][b][c][d][e]
}
</code></pre>
",2
31815085,31814957,40,"<p>You could write a variadic <code>check</code> function:</p>

<pre><code>bool check(int a) {
  return 0 &lt;= a &amp;&amp; a &lt; 16;
}   

template&lt;typename... Args&gt;
bool check(int a, Args... args) {
  return check(a) &amp;&amp; check(args...);
}
</code></pre>

<p>You can use it like <code>check(a, b, c, d, e, ...)</code>. It also has the advantage of being able to take any number of conditions.</p>

<p><a href=""http://ideone.com/tScbKt"">Here's a demo</a></p>
",5
31815125,31814957,9,"<p>You can store your variables as elements in a <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer"">std::vector</a> rather than separate variabes like this:</p>

<pre><code>bool test(const std::vector&lt;int&gt;&amp; values)
{
    for(auto v: values)
        if(v &lt; 0 || v &gt;= 16)
            return false;
    return true;
}
</code></pre>

<p>Alternatively if you are using <code>C++11</code> or later you can use <a href=""http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"" rel=""nofollow noreferrer"">std::all_of</a>:</p>

<pre><code>if(std::all_of(std::begin(values), std::end(values),
    [](int i){ return i &gt;= 0 &amp;&amp; i &lt; 16; }))
{
    // do stuff with values
}
</code></pre>

<p>In that case you may also be able to use a <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow noreferrer"">std::array</a>.</p>
",0
31816011,31814957,5,"<p>You could combine the 5 integers making up your index into one <code>std::array</code> or your own class.</p>

<pre><code>using Index5 = std::array&lt;int, 5&gt;;
</code></pre>

<p>Then you can write a function like:</p>

<pre><code>bool contains(Index5 bounds, Index5 point) {
    for (Index5::size_type d = 0; d != bounds.size(); ++d) {
        if ((unsigned)point[d] &gt; bounds[d])  // using the trick mentioned in comments
            return false;
    }
    return true;
}
</code></pre>

<p>Then use it like this:</p>

<pre><code>auto bounds = Index5{16, 16, 16, 16, 16};
auto point = Index5{a, b, c, d, e};

if (contains(bounds, point)) {
    // do things with point
}
</code></pre>

<p>Generally, I would suggest using something like <code>Index5</code> instead of managing five integers.</p>
",0
31821215,31814957,13,"<p>Here's a compact and efficient way to do the check. It assumes two's complement arithmetic.</p>

<pre><code>bool IsInBounds(int a, int b, int c, int d, int e)
{
    // Make sure only bits 0-3 are set (i.e. all values are 0-15)
    return ((a | b | c | d | e) &amp; ~0xf) == 0;
}
</code></pre>

<p>This works by noting that all values outside the 0-15 range all have a bit set that isn't one of the four least significant ones, and all values inside the range don't.</p>

<p>Of course it's only worth using this sort of optimization if the gains in efficiency outweigh the loss of code readability.</p>
",2
31823443,31814957,1,"<p>If the quantities <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, and <code>e</code> are something that occur
together quite frequently and all need to stay within the bounds
of your ""world"" (e.g. they represent the ""state"" of something in that world)
then it might make sense to define a class whose primary purpose is
to hold one ""state"" consisting of those five quantities.</p>

<p>Then make sure that if any code ever tries to store values in an object
of that class that are not within the bounds, something reasonable
(not a segfault) happens instead, 
and no out-of-bounds values are ever stored there.
That way, an object of that class is safe to pass to any function that
requires <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, and <code>e</code> to be within bounds,
and there is no need for any such function to do bounds-checking
on those five values.</p>
",0
30711965,30710268,3,"<p>Here's a solution that doesn't use any array storage. The spiral can be thought of as a set of right angled triangles inside each other. The function iterates over all the rows and columns and for each position, it calculates what triangle the element is on by finding the closest distance to the edge of the outer triangle, then computes its adjusted position (x, y) relative to the top-left corner of that inner triangle, the number of rows of the inner triangle (r), and the start number of the inner triangle (start+1). Then it outputs a number based on whether it lies on the diagonal, horizontal or vertical side.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

int main(void) {
    int rows;
    cout &lt;&lt; ""Enter the number of rows : "";
    cin &gt;&gt; rows;
    int i, j;
    for(i = 0; i &lt; rows; i++)
    {
        for(j = 0; j &lt;= i; j++)
        {
            // find the closest side:
            int distance = j; // distance to vertical side
            if(i-j &lt; distance)
               distance = i-j; // distance to diagonal side
            if((rows-1)-i &lt; distance)
               distance = (rows-1)-i; // distance to horizontal side
            int r = rows - distance * 3;
            // compute position on inner triangle:
            int x = j - distance;
            int y = i - distance * 2;
            // compute start number for inner triangle:
            int start = (((rows+1)*rows)/2) - (((r+1)*r)/2);
            // output number based on side:
            if(x==y)           // diagonal side
                cout &lt;&lt; setw(2) &lt;&lt; (start+y+1) &lt;&lt; "" "";
            else if(y==(r-1))  // horizontal side
                cout &lt;&lt; setw(2) &lt;&lt; (start+(r*2)-(x+1)) &lt;&lt; "" "";
            else               // vertical side
                cout &lt;&lt; setw(2) &lt;&lt; (start+(r*3)-(y+2)) &lt;&lt; "" "";
        }   
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/URhiUQ"" rel=""nofollow"">Demo</a></p>

<p>Take the example where rows equals 7. In that case the <code>distance</code> value for each element will be:</p>

<pre><code>(0) 
 0  0 
 0 (1) 0 
 0  1  1  0 
 0  1 (2) 1  0 
 0  1  1  1  1  0 
 0  0  0  0  0  0  0 
</code></pre>

<p>All elements with the same distance value form a triangle. The number of rows of the outer triangle is 7, the next smaller one has 4, then 1. So r = rows - (distance * 3).</p>

<p>The top-left corner of the outer triangle is at row 0, column 0. The first inner triangle is row 2, column 1, the next one is at row 4, column 2. So the position of a given row/column position on the inner triangle that it lies on is found by subtracting distance * 2 from the row and distance from the column, so y = i - (distance *2) and x = j - distance.</p>

<p>The inner triangle column is stored in x. The inner triangle row is stored in y. In the example above, the values in brackets are the top-left corners of each triangle, where x = 0 and y = 0. For example for the top-left corner of the triangle with distance = 1, i = 2 and j = 1, so x = 1 - 1 = 0, and y = 2 - (1 * 2) = 0.</p>

<p>The start value is found by calculating the number of elements in the entire large triangle ((row+1)*row)/2 and then subtracting the number of elements remaining, which is the number of elements in the inner triangle.</p>

<p>For a triangle with n rows, the total number of elements is ((n+1)*n)/2, as shown below for rows = 5:</p>

<pre><code>1  X 0 0 0 0 0
2  X X 0 0 0 0
3  X X X 0 0 0
4  X X X X 0 0
5  X X X X X 0

   1 2 3 4 5 6
</code></pre>

<p>To count the number of X's, we can see that it's half the number of elements in a rectangle of (5+1)*5, so half of 30, which is 15.</p>

<p>If there are 2 triangles one inside the other, like this:</p>

<pre><code>X
X X
X O X
X O O X
X X X X X 
</code></pre>

<p>and we want to count the number of X's, then we can calculate the size of the entire triangle using the above formula to get 15, and then calculate the size of the inner triangle which has 2 rows as ((2+1)*2)/2 = 3, and subtracting the smaller from the larger gives 15 - 3 = 12. So if there are 12 X's, then the first O must be number 13. That's how we can calculate the number to output for the top-left corner of the inner triangle.</p>

<p>Once you've calculated all that it's just a matter of working out which side of the inner triangle the element is on and printing it out.</p>
",7
30711511,30710268,2,"<p>Here is a general idea as to how to solve this with recursion. There is probably a way to solve this in a space-efficient way, but I leave that for someone else. So let's say we store this as an array of arrays accessed by <code>x[i][j]</code> and let's say the size of sides of the triangle are <em>n</em>. You can google for how to dynamically create an array of arrays.</p>

<p>Now what we want is an equation for the outside of the triangle. Numbers along the diagonal are (i(i+1))/2 for 1 &lt;= <em>i</em> &lt;= <em>n</em>. Numbers along the left edge are 1+(i(i-1))/2 for 1 &lt;= <em>i</em> &lt;= <em>n</em>. And numbers along the bottom are 1+(n(n-1))/2 .. (n(n+1))/2.</p>

<p>So now to the recursion. Let <em>j</em> be the size of the remaining triangle yet to be numbered, <em>k</em> the highest number you've encountered before and (<em>l</em>,<em>m</em>) the index of the top of the triangle. Use the equations above and the preceding information to calculate the number and store that into the remaining triangle array. If there is yet another interior, recurse with the highest number and index of the top. And so on.</p>

<p>Example for side size 4. First number the outside. Highest prior number is 0. Index of the first position is (0,0)</p>

<pre><code>1
9 2
8 x 3
7 6 5 4
</code></pre>

<p>We are not done because we still have an interior of size one. So when you recurse you, the position of the top of the triangle is (2,2), the highest number so far is 9 and the size of the triangle remaining is 1.</p>

<p>Now try with side size 5. After the first numbering we'd get:</p>

<pre><code>1
12 2
11 x 3
10 x x 4
9  8 7 6 5
</code></pre>

<p>And the triangle remaining also starts at (2,2) as for side 4. But the size of the triangle remaining is now 2 and the highest number seen so far is 12.</p>

<p>After all the recursion is done, then print out of the table. </p>
",0
31223549,31223449,0,"<p>An alternative way is to convert to a string and use the digit characters:</p>

<pre><code>BYTE bMins = 36;
std::string s = std::to_string(bMins);
BYTE bMin1 = s[0] - '0';
BYTE bMin2 = s[1] - '0';
</code></pre>
",1
31223759,31223449,1,"<p>Here is a demonstrative program</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main() 
{
    typedef unsigned char BYTE;
    BYTE bMins = 36;
    BYTE bMin1, bMin2;

    auto d = std::div( bMins, 10 );
    bMin1 = d.quot;
    bMin2 = d.rem;

    std::cout &lt;&lt; ""bMin1 = "" &lt;&lt; ( int )bMin1 &lt;&lt; "", bMin2 = "" &lt;&lt; ( int )bMin2 &lt;&lt; std::endl; 
}
</code></pre>

<p>The program output is</p>

<pre><code>bMin1 = 3, bMin2 = 6
</code></pre>
",0
31223464,31223449,5,"<p>Integer division and modulo help:  </p>

<pre><code>BYTE bMins = 36;
BYTE bMin1 = bMins / 10;
BYTE bMin2 = bMins % 10;
</code></pre>
",1
30134520,30134421,1,"<p>You're missing all the return statements in <code>numDaysMonth()</code>.</p>

<p>If you compile your code with your compiler's extra warnings turned on, you would've certainly gotten ""returning from function without a value"" type of a diagnostic.</p>
",0
30134522,30134421,1,"<p>Right here: </p>

<pre><code>for (dayOfWeek = 1; dayOfWeek &lt;= numDaysMonth(year, month); dayOfWeek++)
</code></pre>

<p>You depend upon the return value of <code>numDaysMonth()</code> to stop the display of the calendar. If you examine that function, it doesn't return what you intend, because you don't explicitly specify a return. </p>

<p>Since you're required to use an array - one way you can refactor this is this: </p>

<pre><code>int numDaysMonth(int year, int month)
{
  const int LEAP_FEBRUARY = 13;
  int daysMonth[13];
  daysMonth[0] = 31;
  daysMonth[1] = 28;
  daysMonth[2] = 31;
  daysMonth[3] = 30;
  daysMonth[4] = 31;
  daysMonth[5] = 30;
  daysMonth[6] = 31;
  daysMonth[7] = 31;
  daysMonth[8] = 30;
  daysMonth[9] = 31;
  daysMonth[10] = 30;
  daysMonth[11] = 31;
  daysMonth[12] = 31;
  daysMonth[LEAP_FEBRUARY] = 29;

  if (month == 2) {
    if (isLeapYear(year)) {
      return daysMonth[LEAP_FEBRUARY];
    }
    else {
      return daysMonth[1];
    }
  } 

  return daysMonth[month - 1];
}
</code></pre>
",3
29164520,29164273,1,"<p>When you create an instance of class A, the two maps are automatically allocated. To counter this, you can make pointers out of them:</p>

<pre><code>class A{
    unsigned t;
    bool isPresent;
    map&lt;unsigned,unsigned&gt;* isPresentA;
    map&lt;unsigned,unsigned&gt;* isPresentB; 
};
</code></pre>

<p>However, you need to allocate (and delete!) them yourself now! A safer option is using std::shared_ptr:</p>

<pre><code>class A{
    unsigned t;
    bool isPresent;
    std::shared_ptr&lt;map&lt;unsigned,unsigned&gt;&gt; isPresentA;
    std::shared_ptr&lt;map&lt;unsigned,unsigned&gt;&gt; isPresentB; 
};
</code></pre>

<p>You still need to initialize them, but at least you won't have to worry about deleting them. You should add a constructor or initializer function to your class to do this:</p>

<pre><code>class A{
    A(bool is_present) {
        isPresent = is_present;
        if (isPresent) {
            isPresentA = std::make_shared&lt;map&lt;unsigned int, unsigned int&gt;&gt;();
            isPresentB = std::make_shared&lt;map&lt;unsigned int, unsigned int&gt;&gt;();
        }
    }
    unsigned t;
    bool isPresent;
    std::shared_ptr&lt;map&lt;unsigned,unsigned&gt;&gt; isPresentA;
    std::shared_ptr&lt;map&lt;unsigned,unsigned&gt;&gt; isPresentB; 
};
</code></pre>
",8
29164710,29164273,1,"<p>You can achieve what you want without complicating your class by using unique_ptr:</p>

<pre><code>#include &lt;map&gt;
#include &lt;memory&gt;

class A {
    unsigned t;
    unique_ptr&lt;map&lt;unsigned, unsigned&gt;&gt; isPresentA;
    unique_ptr&lt;map&lt;unsigned, unsigned&gt;&gt; isPresentB;
};
</code></pre>

<p>you can check for presence by using isPresentA or B directly:</p>

<pre><code>if (a.isPresentA) {
}
</code></pre>

<p>or wrap it into some class method alla <code>bool isPresent();</code></p>

<p>A somewhat more refined version might look like this:</p>

<pre><code>#include &lt;memory&gt;
#include &lt;map&gt;

using namespace std;


class A {
    struct OptinalParts {
        map&lt;unsigned, unsigned&gt; a;
        map&lt;unsigned, unsigned&gt; b;
    };
    unsigned t;
    unique_ptr&lt;OptinalParts&gt; optional;

public:
    A() :t(0),optional(nullptr){};
    A(bool initState):t(0) {
        makePresent(initState);
    }
    bool isPresent() {
        return (bool)optional;
    }
    void makePresent(bool set) {
        if (set &amp;&amp; !isPresent())  {             
            optional.reset(new OptinalParts);                   
        }
        else {
            optional.reset(nullptr); 
        }
    }
    /*
    * accessors
    */
};
</code></pre>

<p>You probably have to replace any occurence of <code>nullptr</code> by <code>NULL</code></p>
",5
30143922,30143379,0,"<p>The problem is there, where You are requesting such thing:</p>

<pre><code>encrypted[pos] = text[i + j * n - 1];
</code></pre>

<p>where:</p>

<ul>
<li><em>i</em> goes to <em>n</em></li>
<li><em>j</em> goes to <em>n</em> and is additionally multiplied by <em>n</em></li>
</ul>

<p>So, as a result, You are requesting element <em>n+n*n</em> of <em>text</em>, which is only <em>d</em> elements long.
From the above case, index 56 is over 44.</p>
",1
31172148,31171775,0,"<p><code>map</code>s are sorted by their keys, not their values. Consider using a <code>set</code> instead.</p>
",1
31171868,31171775,1,"<p>From <a href=""http://en.cppreference.com/w/cpp/container/unordered_map"" rel=""nofollow"">cppreference.com</a>, <code>std::unordered_map</code> is defined as</p>

<pre><code>template&lt;

    class Key,
    class T,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt; std::pair&lt;const Key, T&gt; &gt;
&gt; class unordered_map;
</code></pre>

<p>As this container is unordered, it doesn't need comparator to sort elements. </p>

<p>So, define your (unordered) map as</p>

<pre><code>    unordered_map &lt;int, pair&lt;int,int&gt; &gt; mymap;
</code></pre>

<p>i.e. without the <code>cmp</code>.</p>

<p>Also, don't forget toincrement the iterator in your last <code>while</code>-loop, i.e. add a <code>++it</code>, or else 
...</p>

<p>Your example should compile now:</p>

<pre><code>$ ./mwe 
4
3
2
1
5
5   1   3
1   1   2
2   1   1
3   1   0
</code></pre>

<p><strong>UPDATE</strong></p>

<p>With reference to your comment, if you change the type of <code>mymap</code> from <code>std::unordered_map</code> to 
<code>std::map</code>, bare in mind that elements will be sorted by their keys. And that shouldn't be changed. 
If you want to sort the elements by values, consider this alternative:</p>

<p>Use a <code>std::vector</code>, add a struct that includes both, the above key and value, and update your <code>cmp</code> accordingly, e.g.</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;tuple&gt;

typedef std::tuple&lt; int /* key */, int /* pair::first */, int /* pair::second */ &gt; Element;
typedef std::vector&lt; Element &gt; ElementList;

template &lt;int N&gt;
bool cmp( const Element &amp; a, const Element &amp; b )
{
    return std::get&lt; N &gt;( a ) &lt; std::get&lt; N &gt;( b );
}

int main()
{
    ElementList list;

    // Just dummy data, but you get the idea.
    list.push_back( std::make_tuple( 1, 2, 3 ) );
    list.push_back( std::make_tuple( 2, 3, 4 ) );
    list.push_back( std::make_tuple( 3, 4, 5 ) );

    // Sort by ""pair::first"", which is at element index 1 of 
    // the tuple, cf. cmp&lt;1&gt; below. Change this template parameter 
    // to the index value of the tuple element that should be used to 
    // sort your data.
    std::sort( list.begin(), list.end(), cmp&lt;1&gt; );

    return 0;
}
</code></pre>
",4
31889942,31889927,2,"<pre><code>int num_0, num_1, num_2, num_3 ,num_4, num_5, num_6 , num_7 ,num_8 , num_9 = 0;
</code></pre>

<p>only initializes <code>num_9</code> to 0. The other variables are <em>uninitialized</em>.</p>

<hr>

<p>It would have been a lot less work to use an array instead of 10 <code>num_x</code> variables:</p>

<pre><code>void count_numbers(int array[4][4]) {
    int num[10] = {0};
    int i, j = 0;
    for (i = 0; i &lt; 4; i++) {
        for (j = 0; j &lt; 4; j++) {
            if (array[i][j] &gt;= 0 &amp;&amp; array[i][j] &lt; 10) {
                ++num[array[i][j]];
            }
        }
    }
    for (i = 0; i &lt; 10; ++i) {
        cout &lt;&lt; i &lt;&lt; "":"" &lt;&lt; num[i] &lt;&lt; ';';
    }
    cout &lt;&lt; '\n';
}
</code></pre>
",0
31889944,31889927,1,"<p>A statement of the form:</p>

<pre><code>int a, b, c = 0;
</code></pre>

<p>Only initializes <code>int c</code>. You want:</p>

<pre><code>int a = 0, b = 0, c = 0;
</code></pre>

<hr>

<p>Instead of making 10 different variables, you can use an array.</p>

<pre><code>int count[10] = {0};
</code></pre>

<p>This notation initializes the entire array to <code>0</code> (Note that if you wrote <code>{k}</code> instead of <code>{0}</code>, it would initialize only the first element to <code>k</code> and the rest of the array to <code>0</code>).</p>

<p><code>count[i]</code> would be the number of instances of the digit <code>i</code>.</p>
",0
31889985,31889927,0,"<p>You have not initialized all you local variables except last variable i.e. num_0,1,2...</p>

<p>int a, b = 0 In this case ""a"" will remain uninitialized and only ""b"" will be initialized. Either define them in different lines like</p>

<pre><code>int a = 0;
int b = 0;
</code></pre>

<p>or</p>

<pre><code>int a = 0 , b = 0,
</code></pre>

<p>or</p>

<p><code>static int a, b;   //default initialized to 0, no need to worry about</code> initialization.</p>
",0
32433396,32432656,3,"<p>I suggest you use <code>std::sort</code> form the <code>&lt;algorithm&gt;</code> header. <a href=""http://rosettacode.org/wiki/Sort_using_a_custom_comparator#C.2B.2B"" rel=""nofollow"">It allows you to pass your own sorting operator.</a> In this operator you have to define your ordering. Your ordering should look something like this:</p>

<pre><code>char value(char inp){
  if (inp == 'A')
    return 0;
  if (inp == 'B')
    return 1;
  if (inp == 'V')
    return 2;
  if (inp == 'G')
    return 3;
  if (inp == 'D')
    return 4;
  ...
} 

struct comp {
  bool operator()(const std::string&amp; s1, const std::string&amp; s2) {
    for(size_t i = 0; i &lt; std::min(s1.size(), s2.size()) &amp;&amp; value(s1[i]) == value(s2[i]); ++i)
      ;
    if (value(s1[i]) == value(s2[i]))
      return s1.size() &lt; s2.size();
    return value(s1[i]) &lt; value(s2[i]);
  }
};
</code></pre>

<p>There is even <code>std::lexicograpical_compare</code>, which you can use:</p>

<pre><code>bool value_lt(char v1, char v2){
  return v1 &lt; v2;
}

struct comp {
  bool operator()(const std::string&amp; s1, const std::string&amp; s2) {
    return std::lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end(), value_lt);
  }
};
</code></pre>

<p>If what you are trying to do really is getting a better understanding of bubblesort, I suggest you try to figure it out with the standard ordering first, and then abstract the ordering away to make use of one of the comparisons I just outlined.</p>
",1
27556391,27556019,0,"<p>This is incorrect, as the loop will never execute if <code>i</code> is not 0.</p>

<pre><code>for(int i= matrices_vector.size()-1; i=0; i--)
</code></pre>

<p>This should be </p>

<pre><code>for(int i= matrices_vector.size()-1; i &gt; 0; i--)
</code></pre>

<p>Additionally, you should check for the <code>matrices_vector</code> being empty before entering the loop, as <code>matrices_vector.size() - 1</code> will yield an invalid value if <code>matrices_vector.empty()</code> is <code>true</code>.</p>

<p>Also, since your loop checks for pairs, you need to enforce that there are is at least 2 items in the vector before proceeding.</p>
",0
31825721,31825223,-1,"<p>First of all, the code above is wrong, it should be:</p>

<pre><code>for(i=1;i&lt;=n;i++)
{
  for(j=1;j&lt;=i;j++)
  {
    cout&lt;&lt;k&lt;&lt; "" "";
    k++;
  }

  cout &lt;&lt; '\n';
}
</code></pre>

<p>Now, to draw the pattern, you could use a loop that would use the following logic:</p>

<pre><code>for(;i &gt; 0; i--)
{
    k -= i-1;

    for(j=1;j&lt;i;j++)
    {
        cout &lt;&lt;k&lt;&lt; "" "";
        k++;
    }

    cout &lt;&lt; '\n';
    k -= i-1;
}
</code></pre>
",4
31826369,31825223,-1,"<pre><code>int main()
{
    int n;
    int i, j, k = 1;
    cout &lt;&lt; ""Enter row"";
    cin &gt;&gt; n;
    int elemcount = 0;
    for (i = 1; i &lt;= n; i++)
    {
        elemcount = 0;
        for (j = 1; j &lt;= i; j++)
        {

            cout &lt;&lt; k &lt;&lt; ""\t"";
            k++;
        }
        cout &lt;&lt;endl;
    }
    k = k - n;      //Reset Counter to the value of the first digit in current row.
    i--;
    j--;
    for (; i &gt; 0; i--)
    {
        j = i;
        elemcount = 0;          //Counter to keep track of elements printed.
        for (; j&gt; 0; j--)
        {
            cout &lt;&lt; k &lt;&lt; ""\t"";
            k++;
            elemcount++;
        }
        k = k - elemcount - (i-1); //Resetting K, substracting the number of elements printed and number of elements to be printed in next row.
        cout &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
",2
32997274,32997172,1,"<p>Your terminology is all wrong. I can't do much more than address your specific observations. I <em>think</em> you're getting confused by the address-of operator <code>&amp;</code>, which has effectively no relationship with the symbol <code>&amp;</code> as found in reference types (or with bitwise-<code>AND</code>).</p>

<ul>
<li><code>T&amp;</code>: the type ""reference to <code>T</code>"";</li>
<li><code>&amp;a</code>: an expression evaluating to the <em>address of</em> the object <code>a</code> (a pointer!);</li>
<li><code>a &amp; b</code>: an expression evaluating to the result of <code>AND</code>ing the numbers <code>a</code> and <code>b</code>.</li>
</ul>

<p>These three usages of <code>&amp;</code> are (confusingly) unrelated. So, neither <code>return (&amp;c)</code> nor <code>&amp;my_constant_class</code> have anything to do with references.</p>

<p>Reference and pointer semantics are actually remarkably simple, but once you've gone off-piste with misconceptions there's no coming back. That is one reason it is really important to learn C++ from a good, peer-reviewed book, rather than from random tutorials on the internet, your mate down the pub, or not at all!</p>

<hr>

<blockquote>
  <p>value of pointer1_to_constant_class is assigned to a reference of a const reference.</p>
</blockquote>

<p>No. A pointer of type <code>MyClass*</code> is assigned to <code>pointer1_to_constant_class</code>. No references here.</p>

<blockquote>
  <p>value of pointer2_to_constant_class is assigned to a reference of an object.</p>
</blockquote>

<p>No. A pointer of type <code>MyClass*</code> is assigned to <code>pointer2_to_constant_class</code>. No references here.</p>

<blockquote>
  <p>(so although both pointers are of the same type, they are assigned to different types)</p>
</blockquote>

<p>They are both of the same type, but have been assigned to different values.</p>

<blockquote>
  <p>value of reference_to_constant_class is assigned to an object.</p>
</blockquote>

<p>An object is assigned to the object referred to by <code>reference_to_constant_class</code>, yes.</p>

<blockquote>
  <p>value of copy_to_my_class is assigned to an object.</p>
</blockquote>

<p>A new object <code>copy_to_my_class</code> is declared and copy-initialised from an object, yes.</p>

<blockquote>
  <p>(so reference and object are assigned to the same type)</p>
</blockquote>

<p>You never assign a reference.</p>

<blockquote>
  <p>So why we have to call pointer2_to_constant_class->GetNumber, if it is assigned to a reference of an object.</p>
</blockquote>

<p>It's not. <code>pointer2_to_constant_class</code> is a pointer.</p>

<blockquote>
  <p>Also, why there is no difference in calling reference_to_constant_class.GetNumber(), versus copy_of_my_class.GetNumber(),</p>
  
  <p>if one is an object, another just a reference?</p>
</blockquote>

<p><strong>We access member functions like <code>a.b()</code> whether <code>a</code> is the object itself, or a reference to it.</strong></p>

<p><strong>We access member functions like <code>a-&gt;b()</code> when <code>a</code> is a pointer to an object.</strong></p>
",2
27563523,27563456,2,"<p>This will just exit <code>main()</code> on the first iteration of the for loop:</p>

<pre><code>for (int i=0; i&lt;1000; ++i)

    return ffibi(n);  
</code></pre>

<p>so you won't get a timing result because the rest of <code>main()</code> does not even get executed.</p>

<p>Change it to e.g.:</p>

<pre><code>for (int i=0; i&lt;1000; ++i)
{
    volatile int result = ffibi(n);  
}
</code></pre>

<p>Note the use of <code>volatile</code> to prevent the compiler from optimising away the redundant loop.</p>
",4
31821623,31821345,1,"<p>I think you might be misunderstanding the concept of getters and setters.</p>

<p>A getter is a public function on a class that returns the value of a private member variable. </p>

<pre><code>int get_id_num() const {
    return id_num;
}
</code></pre>

<p>Typically,  you expect it to take no parameters and have no side effects.  You certainly don't expect a getter to get input from the user or output anything to the user. </p>

<p>A setter on the other hand sets the value of a private member variable.</p>

<pre><code>void set_id_num(int num) {
    id_num = num;
} 
</code></pre>

<p>It typically takes one parameter (the value you wish to set)  and returns nothing.  Again, you don't expect a setter to get input from the user or output anything to the user. </p>

<p>And you don't expect a getter to call a setter or vice versa.</p>

<p>Usually you would separate the user interface from game object classes. For example you could get the value from the user in the main function and pass it to a setter:</p>

<pre><code>int main(){
    game_object test;

    int id_num = 0;
    cout &lt;&lt; ""Please enter a four digit id number for the game: "";
    cin &gt;&gt; id_num;  // get id_num from the user

    test.set_id_num(id_num);  // pass id_num to the setter by value
}
</code></pre>

<p>If the class <em>must</em> have responsibilities to get input from the user then getters and setters are not the place to do it. </p>
",2
30715154,30715128,6,"<p>No, it's not true. Nothing magical happens here:</p>

<pre><code>myFunction(&amp;myObject)
</code></pre>

<p>That is just taking the address of <code>myObject</code>, on the stack (if that is indeed where it is), and passing that address to <code>myFunction</code>.</p>
",0
30715173,30715128,1,"<p>You said:</p>
<blockquote>
<p>However, if in the following line myObject was passed to a function, like this:</p>
<pre><code>myFunction(&amp;myObject)
</code></pre>
<p>it wouldn't cause an error, instead the object would be magically allocated on the heap. Is that true or am I missing something?</p>
</blockquote>
<p>That is not correct. The call</p>
<pre><code>myFunction(&amp;myObject)
</code></pre>
<p>will simply use the address of <code>myObject</code>, which is an object on the stack, to call <code>myFunction</code>.</p>
",0
30715437,30715128,0,"<p>The call of your function would cause an error or not will depend on the definition of your function. It does not relate to your object located at heap or stack.
In here, you pass an address of myObject into your function, your function need have parameter passed by pointer, something like below:</p>

<pre><code>myFunction(MyClass* myObject);
</code></pre>
",0
30716381,30715128,0,"<p>Consider the following:</p>

<pre><code>int * foo ()
{
    int x = 0;
    return x;
}
</code></pre>

<p>Because <code>x</code> is allocated on the stack, when <code>foo</code> finishes, it goes out of scope, and no magic happens, just undefined behavior that will generally lead to a core dump</p>

<p>Heap allocation requires calling <code>new</code> (except for placement <code>new</code>)</p>
",0
34255182,34255160,4,"<pre><code>if (result[1].count(3))
{
    std::cout &lt;&lt; ""3 exists!"" &lt;&lt; std::endl;
}
else
{
    std::cout &lt;&lt; ""3 doesn't exist"" &lt;&lt; std::endl;
}
</code></pre>
",0
34255187,34255160,4,"<p>Provided that the key <code>1</code> exists in the map:</p>

<pre><code>if(result[1].find(3) != result[1].end()) {
  // key exists
} else {
  // key doesn't exist
}
</code></pre>
",0
33023401,33020027,0,"<p>The code you have fails to compile for two reasons:</p>

<ul>
<li><p>Using <code>double</code> item type for the <code>tmp</code> vector. A <code>vector&lt;double&gt;</code> does not convert implicitly to the required function result type <code>vector&lt;int&gt;</code>.</p></li>
<li><p>The standard library does not define output of vectors, so the <code>cout &lt;&lt;</code> <em>a vector</em> in <code>main</code> doesn't compile.</p></li>
</ul>

<p>To output the vector you can define function like this:</p>

<pre><code>void write_to( ostream&amp; stream, vector&lt;int&gt; const&amp; v )
{
    for( int i = 0; i &lt; int( v.size() ); ++i )
    {
        stream &lt;&lt; (i &gt; 0? "" "" : """") &lt;&lt; v[i];
    }
}
</code></pre>

<p>and call it like this:</p>

<pre><code>write_to( cout, find_index(vec2, vec1) );
cout &lt;&lt; ""\n"";
</code></pre>

<p>It's also possible to write a little glue code that would enable the <code>cout &lt;&lt;</code> notation, i.e. that would make it use the <code>write_to</code> function, but that is maybe just complication now.</p>

<p>With these changes your code compiles and outputs</p>

<pre>
0 1 2 3
</pre>
",1
30716799,30716553,0,"<blockquote>
  <p>Is this possible?</p>
</blockquote>

<p>It is possible and should work ok if you use a <code>virtual</code> member function. If you use a non-virtual member function, it won't work.</p>

<p>Example program:</p>

<pre><code>#include &lt;iostream&gt;

class Base1
{
   public:

      void BaseMethod(void (Base1::*basemth)(), double a)
      {
         (this-&gt;*basemth)();
      }

      virtual void Method2() = 0;

};

class Derived1 : public Base1
{
   public: 

      void Method2()
      {
         std::cout &lt;&lt; ""In Derived1::Method2()\n"";
      }

      void ChildMethod2()
      {
         double double_a = 1.0;
         BaseMethod(&amp;Base1::Method2, double_a);
      }

};

int main()
{
   Derived1 d;
   d.ChildMethod2();
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>In Derived1::Method2()
</code></pre>
",3
31546067,31546017,0,"<p>You should draw a flowchart for this.  If <code>gradeCounter &lt;= 10</code>, you go into the loop, and only when <code>gradeCounter &gt;= 11</code> do you proceed with <code>average = total/gradeCounter</code></p>

<p>That's why you get a result divided by 11 instead of 10.</p>
",4
31546069,31546017,1,"<pre><code>while ( gradeCounter &lt;= 10 ) { //10 times cycle 
    cout &lt;&lt; ""Enter grade: ""; //input prompt
    cin &gt;&gt; grade;            //input grade
    total = total + grade;   //adds the grade to the total
    gradeCounter = gradeCounter + 1; //increases the counter
}
</code></pre>

<p>In this piece of code, when <code>gradeCounter</code> is <code>10</code>, the <code>while</code> loop runs once more, incrementing <code>gradeCounter</code> to <code>11</code>. So later, you're really dividing by 11 rather than 10.</p>
",0
31546072,31546017,1,"<pre><code>while ( gradeCounter &lt;= 10 )
</code></pre>

<p>This condition evaluates to false when, in your case, <code>gradeCounter</code> is incremented to 11.
(11 is not less or equal to 10)</p>

<p>So your counter is eleven, not ten after your loop.</p>
",0
31546073,31546017,1,"<p><code>while ( gradeCounter &lt;= 10 ) { //10 times cycle</code>
<code>gradeCounter = gradeCounter + 1;</code></p>

<p>Grade counter will be 11 after the loop ends (last iteration it gets set to 11, then &lt;= 10 is not true and it exits. So you'd be doing a divide by 11 instead of 10.</p>
",0
31546142,31546017,1,"<p>Actually what is happening is that after each run of your while loop, the value of <code>gradeCounter</code> is 1 more than the number of times the loop has been run(because you have initialized <code>gradeCounter</code> to 1 before start of the loop). You can do any 1 of the following to fix this.</p>

<p>1)</p>

<pre><code>average = total / (gradeCounter-1);
</code></pre>

<p>2)</p>

<pre><code>gradeCounter = 0;
while ( gradeCounter &lt; 10 ) {
    cout &lt;&lt; ""Enter grade: "";
    cin &gt;&gt; grade;
    total = total + grade; 
    gradeCounter = gradeCounter + 1;
}
</code></pre>
",0
34199587,34199297,1,"<p>Why are you compiling vertex.hh?  Why not just
    g++ vertex.cc</p>

<p>Secondly, can you show us the contents of your header file and source file.  Actually, the source file can probably be:</p>

<pre><code>#include ""vertex.hh""
int main() { return 0; }
</code></pre>

<p>and the header file:</p>

<pre><code>#include ""svl/SVL.h""
</code></pre>

<p>Secondly, when you say ""#include "" are you just including some of SVL internal headers?  That may not work.  <a href=""http://www.cs.cmu.edu/~ajw/doc/svl.html"" rel=""nofollow"">http://www.cs.cmu.edu/~ajw/doc/svl.html</a> says ""for basic use, the only header file needed is svl/SVL.h"".</p>
",4
31128666,31127768,0,"<p>I suppose you have defined <code>string</code> type as:</p>

<pre><code>typdef char * string;
</code></pre>

<p>In that case, change</p>

<pre><code>string newtext = text;    /// Here, both point to same memory
</code></pre>

<p>to</p>

<pre><code>string newtext = strdup(text);
</code></pre>
",0
33569247,33569150,1,"<p>Maybe you mean a compile error:</p>

<pre><code> media = media + height[¨ª]; // wrong character
</code></pre>

<p>Substitute with:</p>

<pre><code> media = media + height[i];
</code></pre>
",0
34248668,34248451,1,"<p>Below is probably what you would want.
I changed your Complex number class to only use one constructor that has default parameters both will default to 0 if you do not provide any parameters.</p>

<p>In your code your parameter less function does nothing and defaults to just using the default constructor for x and y (in the case of floats using 0). You can combine this with the parametered constructor by using default parameters, as mentioned above.</p>

<p>This makes it explicit that if you don't provide values to the Complex constructor you should expect x and y to be 0.</p>

<p>I also added input and output stream operators, but that may not be necessary for your uses.</p>

<p>But it allows you to use <code>cin &gt;&gt; c1;</code> and it is apparent that you expect the user to input the values for c1, instead of embedding that code in the default constructor.</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

class complex{
    float x;
    float y;
  public :
    // it seems like one constructor with default parameters
    // should work for your case.
    complex(float real = 0, float imag = 0):x(real),y(imag){}
    complex operator+(complex);
    friend ostream&amp; operator &lt;&lt; (ostream&amp; outs, Complex C);
    friend istream&amp; operator &lt;&lt; (istream&amp; ins, Complex C);
};

ostream&amp; operator &lt;&lt; (ostream&amp; outs, Complex C){
  cout &lt;&lt; C.x &lt;&lt; "" + i"" &lt;&lt; C.y;
  return outs;
}

istream&amp; operator &lt;&lt; (istream&amp; ins, Complex C){
  if (ins == cin){
    cout &lt;&lt; ""Enter real part"" &lt;&lt; endl;
    ins &gt;&gt; C.x;
    cout &lt;&lt; ""Enter imaginary part"" &lt;&lt; endl;
    ins &gt;&gt; C.y;
  } else {
    ins &gt;&gt; C.x &gt;&gt; C.y;
  }
  return ins;
}

// your plus operator is fine.

int main(){
    complex c1,c2(2.5,1.7),c3(0,0); //c1 will have x = 0, y = 0
    c3 = c1+c2;  // c3.x = 2.5, c3.y = 1.7
    cout &lt;&lt; c1 &lt;&lt; endl;  // displays 0 + i0
    cout &lt;&lt; c2 &lt;&lt; endl;  // displays 2.5 + i1.7
    cout &lt;&lt; c3 &lt;&lt; endl;  // displays 2.5 + i1.7
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>0 + i0
2.5 + i1.7
2.5 + i1.7
</code></pre>

<p>If this is not what you expect for output, what would you expect?</p>
",0
34248879,34248451,0,"<p>I have made a couple of assumptions and modified your code accordingly, the assumptions are:</p>

<ol>
<li>The second constructor constructs values from the ones present in the main function, so we need a different constructor to create object using the input</li>
<li>c1 contains the values entered by the user and c3 is created using default constructor</li>
</ol>

<p>Keeping the above in mind the code can be modified as follows:</p>

<pre><code>    #include&lt;iostream&gt;

using namespace std;

class complex
{
      float x;
      float y;
      public :
             complex() {}
             complex(float real, float imag) { x=real; y=imag; } //constructor for creating x and y from values given in the code
             complex(istream&amp;);//constructor for creating values entered as input
             complex operator+(complex);
             void display(void);
};

//definition for constructor for taking user input
complex::complex(istream&amp; in)
{
    cout&lt;&lt;""Enter real = "";
    in&gt;&gt;x;
    cout&lt;&lt;""Enter imaginary = "";
    in&gt;&gt;y;
}

complex complex :: operator+(const complex&amp; c) const
{
        complex temp;
        temp.x = x + c.x;
        temp.y = y+c.y;
        return(temp);
}
void complex :: display(void)
{
     cout&lt;&lt;x&lt;&lt;"" +i""&lt;&lt;y&lt;&lt;""\n"";
}
int main()
{
    complex c1(cin),c2(2.5,1.7),c3;
    //note the changes, c1 is made from user input, c2 from constructor and c3 using default constructor
    c3 = c1+c2;
    c1.display();
    c2.display();
    c3.display();
}
</code></pre>

<p>Make note of the modifications made which I have indicated by the comment lines</p>
",4
33572185,33571947,1,"<p>If I get you right you want <code>(sum(a, b, c) - min(a, b, c)) / 2</code>:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main (int argc, const char **argv) {
    double a = 1;
    double b = 2;
    double c = 3;
    double min = std::min({a, b, c});
    // double max = std::max({a, b, c});
    double sum = a + b + c;
    // double result = ((sum - min - max) + max) / 2;
    // which is:
    double result = (sum - min) / 2;
    std::cout &lt;&lt; result &lt;&lt; '\n';
}
</code></pre>
",0
31134545,31134089,1,"<p>Just use <code>std::hex</code> to read in the integer, it will take care of the leading zeroes.</p>

<pre><code>unsigned int i;
std::cin &gt;&gt; std::hex &gt;&gt; i;
</code></pre>

<p>Input/Output:</p>

<pre><code>&gt; 00001234
i = 4660
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/7b5f8596c8daabeb"" rel=""nofollow"">Live on Coliru</a></p>
",0
33818995,33818859,0,"<p>Here's the correct way to do this:</p>

<p>You define your attributes in a class/struct, and when that struct is initialized, the constructor(OrcishAttributes()) is called: </p>

<pre><code>struct OrcishAttributes
{
  int m_orcishHP;
  int m_orcishMP;
  int m_orcishAttack;
  int m_orcishDef;
  int m_orcishSpeed;
  OrcishAttributes(int orcishHP, int orcishMP, int orcishAttack, int orcishDef, int orcishSpeed)
  {
    m_orcishHP=orcishHP;
    m_orcishMP = orcishMP;
    m_orcishAttack = orcishAttack
    m_orcishDef = orcishDef;
    m_orcishSpeed = orcishSpeed;
  }

}

class Orc
{
  public:
  Orc(OrcishAttributes oa)
  {
     m_orcAttributes = oa;
  }
  private:
    OrcishAttributes m_orcAttributes;
}

int main()
{

  OrcishAttributes oa(50,5,15,10,20);
  Orc* o = new Orc(oa);
}
</code></pre>
",6
33819015,33818859,0,"<p>That's why we have OOP.</p>

<p>You can define a base class, lets say <code>Unit</code>. It can store common members like fields or methods:</p>

<pre><code>class Unit
{
protected:
    int HP;
    int MP;
    int Attack;
    int Def;
    int Speed;

public:
    int getHPplusMP()
    {
        return HP + MP;
    }
};
</code></pre>

<p>Then, you can create inherited classes and initialize these values in its constructors:</p>

<pre><code>class OrcUnit : public Unit
{
public:
    OrcUnit()
    {
        HP = 20;
        MP = 0;
        Attack = 13;
        Def = 4;
        Speed = 5;
    }
};

class ElfUnit : public Unit
{
public:
    ElfUnit()
    {
        HP = 25;
        MP = 15;
        Attack = 15;
        Def = 1;
        Speed = 8;
    }
};
</code></pre>

<p>Then, you will be able to work with it:</p>

<pre><code>ElfUnit elf;
OrcUnit orc;

Unit u = elf;
cout &lt;&lt; u.getHPplusMP();

Unit u = orc;
cout &lt;&lt; u.getHPplusMP();
</code></pre>

<p>In general, it is definitely a good idea to learn OOP very well before trying to implement games. </p>
",2
27676184,27675956,0,"<p>It seems function initObcych2 is used to initialize elements of array</p>

<pre><code>obcyObiekt obcy[15];
</code></pre>

<p>In this case the function can be declared like</p>

<pre><code>void initObcych2( obcyObiekt obcy[], size_t n );
</code></pre>

<p>and called like</p>

<pre><code>initObcych2( obcy, 15 );
</code></pre>

<p>Or you can declare the function like</p>

<pre><code>void initObcych2( obcyObiekt ( &amp;obcy )[15] );
</code></pre>

<p>and call it like</p>

<pre><code>initObcych2( obcy );
</code></pre>

<p>However the first function declaration is more flexible because you will not need to change the function declaration in case when the size of the array will be changed and it may be called for arrays of different sizes.</p>

<p>As for this record that you showed</p>

<pre><code>void initObcych2(struct obcyObiekt &amp;obcy[15] )
</code></pre>

<p>when</p>

<pre><code>struct obcyObiekt &amp;obcy[15] 
</code></pre>

<p>is an array of 15 references to objects of type struct obcyObiekt. C++ does allow to declare arrays of references. It allows to declare a reference to an array like</p>

<pre><code>struct obcyObiekt ( &amp;obcy )[15] 
</code></pre>
",0
27675986,27675956,0,"<p>If you want to have the function signature keep the size of the array as part of the type safety:</p>

<pre><code>void initObcych2( obcyObiekt (&amp;obcy)[16])
</code></pre>

<p>This method will only accept an array of <code>16</code> elemnts of type <code>obcyObiekt</code>, the parameter variable name will be <strong>obcy</strong>.</p>
",0
31224846,31224789,1,"<p>As already mentioned, you cannot somehow ""build"" some string at run time and use it as variable name. This is a compile time mechanism, and even if this was a compile time problem, it would be a bad idea.</p>

<p>You most likely want</p>

<pre><code>std::vector&lt;int&gt; nx(someLength);
std::vector&lt;int&gt; ny(someLenght);

int value = 5;
cerr &lt;&lt; nx[value] &lt;&lt; ny[value] &lt;&lt; endl;
</code></pre>

<p>instead. (Or the same thing with <code>std::array&lt;int, someLength&gt; nx{}</code> if <code>someLength</code> is known at compile time and not big.)</p>
",0
31224821,31224789,1,"<blockquote>
<pre><code>cerr &lt;&lt; n+value+x &lt;&lt; n+value+y &lt;&lt; endl;
</code></pre>
</blockquote>

<p>Uhhm what please? You mean to expand symbol names and bind to them at runtime?</p>

<p>No that's not possible.</p>

<p>The closest thing you can get is setting up a <code>std::map&lt;std::string,int&gt;</code> and generate the <em>key</em> string values as needed.</p>
",2
31889128,31889081,0,"<p>Don't use an array, its so old fashioned. Use a <code>vector</code> its simple.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;

using namespace std;

int main(){

    vector&lt;float&gt; costs;
    vector&lt;string&gt; names;

    char choice = 'y';

    while(choice != y){
        float price;
        cout&lt;&lt;""Enter price: "";
        cin&gt;&gt;price;

        costs.push_back(price);

        string name;
        cout&lt;&lt;""Enter grocery name: "";
        cin&gt;&gt;name;

        names.push_back(name);

        cout&lt;&lt;""Enter y to continue"";
        cin&gt;&gt;choice;
    }

    return 0;
}
</code></pre>

<p>Then you can simply do <code>names[49]</code> to get the 50th grocery name.</p>
",4
31889213,31889081,2,"<p>The simplest way to do this is to insert the elements into a single vector of a <a href=""http://en.cppreference.com/w/cpp/utility/pair"" rel=""nofollow""><code>std::pair</code></a> or <a href=""http://en.cppreference.com/w/cpp/utility/tuple"" rel=""nofollow""><code>std::tuple</code></a> or a simple object like a <code>struct</code>.  this way you don't need to maintain two different collections of data and with the vector you can add as many items as you need.  Using a <code>struct</code> it would look like:</p>

<pre><code>struct Item
{
    std::string name;
    double price;
};

std::istream &amp; operator &gt;&gt;(std::istream &amp; is, Item &amp; item)
{
    is &gt;&gt; item.name &gt;&gt; item.price;
    return is;
}

int main ()
{
    std::vector&lt;Item&gt; items;
    Item reader;
    // get items
    while (cin &gt;&gt; reader)
        items.push_back(reader);

    // display items
    for (const auto &amp; e : items)
        std::cout &lt;&lt; e.name &lt;&lt; ""\t"" &lt;&lt; e.price &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>You can see an example of this running with this <kbd><a href=""http://ideone.com/LenmWh"" rel=""nofollow"">Live Example</a></kbd></p>
",1
33548360,33547566,4,"<p>You're missing the other side of the fitness check:</p>

<pre><code>bool Chromosome::operator&lt;(const Chromosome &amp; rhs) const
{
    const Chromosome&amp; lhs = *this;
    if (lhs.fitness &lt; rhs.fitness)
        return true;
    else if (rhs.fitness &lt; lhs.fitness)
        return false; // &lt;== this!
</code></pre>

<p>Otherwise, if <code>lhs.fitness &gt; rhs.fitness</code>, you're checking the vectors, when you shouldn't. </p>
",1
33548528,33547566,1,"<p>Use <code>std::tuple</code>:</p>

<pre><code>bool Chromosome::operator&lt;(const Chromosome &amp; rhs) const
{
    // Fill in the ... here.
    using base_type = std::vector&lt;...&gt;;

    return std::tie(fitness, static_cast&lt;base_type const&amp;&gt;(*this)) &lt;
        std::tie(rhs.fitness, static_cast&lt;base_type const&amp;&gt;(rhs));
}
</code></pre>

<p>Side note: inheriting from <code>std::vector&lt;...&gt;</code> is pretty horrible. Use a <code>std::vector&lt;...&gt;</code> data member and implement the functionality you need as forward functions.</p>
",0
33547886,33547566,0,"<p>When <code>rhs.size()&lt;lhs.size()</code> your comparison function looks seriously wrong. (Not just a bad comparison rule, but undefined behavior as well).</p>

<p>That might be fixed inside your <code>operator[]</code> which I don't see.  So I can't be certain of the above.  But since that fits the described symptoms, I am assuming you didn't actually fix it inside <code>operator[]</code>  </p>

<p>Even for <code>rhs.size()&gt;lhs.size()</code> there is something very questionable in your code.  So it seems you are assuming they are the same size.  If so, throw an <code>assert</code> in, so code reviewers might believe that.</p>
",1
31282811,31282731,2,"<p>I'm not sure what you mean by not having default functions. Not having data members is basically to avoid various kinds of conflicts for a class that has multiple interfaces, or especially interfaces and a true base class. </p>

<p>For example, say that class X implements InterfaceA, which has member m_foo. If InterfaceB also has member m_foo, and X decides to inherit from InterfaceB as well and implement the interface, it's likely the existing implementation of X will be broken, as referring to m_foo in X will be ambiguous. See: <a href=""https://stackoverflow.com/questions/12255087/c-multiple-parents-with-same-variable-name"">c++ Multiple parents with same variable name</a></p>

<p>I should probably also add: not having member variables is a logical consequence of interfaces not providing any implementation. Since they don't do any work or run any code, there's no reason an interface class would need non-static member variables. </p>

<p>Edit: ok, so by defaulted functions, I think you mean, why does the style guide say the functions cannot have an implementation and must be pure virtual. </p>

<p>It again boils down to difficult cases in what's called multiple inheritance in c++. If the interface class methods had implementations, you could inherit them without re implementing. If you have two interfaces with the same method name and you inherit both, which function gets called? It's the same problem as with member variables.</p>

<p>Basically, this all comes back to the fact that multiple inheritance in c++ can be quite tricky. The rules for interfaces mimic an actual language construct in java, which does not have full multiple inheritance. With these restrictions, you can avoid these tricky situations, but you also lose some of the power of c++ full multiple inheritance. </p>

<p>See: <a href=""https://stackoverflow.com/questions/225929/what-is-the-exact-problem-with-multiple-inheritance"">What is the exact problem with multiple inheritance?</a></p>
",2
31231988,31231966,0,"<p>There's only so many values that can be represented exactly as a <code>float</code>, and 1234.56 ain't one of them:</p>

<pre><code>public class WhatsTheFloatingPoint
{
    public static void main(String[] args)
    {
        float x = 1234.56f;
        BigDecimal y = new BigDecimal(x);
        System.out.println(y);
    }
}
</code></pre>

<p>This program prints the closest value that is actually used: <code>1234.56005859375</code></p>
",2
31232010,31231966,0,"<p>Its value is always:</p>

<pre><code>1234.560059...
</code></pre>

<p>when you show fewer digits, it will round off the tiny extra amount required to map into binary fractions</p>

<p>That is why floating point equivalence is generally done with some acceptable epsilon,  or tiny difference.</p>

<p>Note that the amount off can vary by architecture and compiler options</p>
",0
33574451,33574269,0,"<p>The question is ""how the store in <code>std::map&lt;std::string, void(*)(GLenum)&gt;</code> a function pointer that accepts parameters""? If yes, then the answer is: That is not possible, because you declared a map with a fixed function pointer signature. And the signature in your code sais, that the stored function pointer does not accept any parameters.</p>

<p>If you want to store parameter, then you have two options:</p>

<ol>
<li><p>A wrapper function that accesses the parameters not over the stack and call the specified function with the provided parameters.</p></li>
<li><p>Create a map for every function pointer signature you are using.</p></li>
</ol>

<p>Hint: Be lucky that your program didn't crash due to the wrong calling convention. It is advisable to adapt the calling convention to <code>__cdecl</code>.</p>
",2
33574831,33574269,2,"<p>Change this:</p>

<pre><code>std::map&lt;std::string, void(*)(GLenum)&gt; glEnableDisable;
</code></pre>

<p>to this:</p>

<pre><code>std::map&lt;std::string, std::function&lt;void(GLenum)&gt;&gt; glEnableDisable;
</code></pre>

<p>and never worry about calling conventions again. An <code>std::function</code> is able to store any function or callable object, whatever its calling convention is.</p>

<p>Cast is not needed:</p>

<pre><code>Main.glEnableDisable[SplittedUp[0]])(Parameter);
</code></pre>
",1
33574623,33574269,0,"<p>Obviously:</p>

<pre><code>void(*)(GLenum)
</code></pre>

<p>is <em>not</em> the correct prototype for the <code>GLenum</code> function.  </p>

<p>This assumes a <code>C</code> calling convention, which in Visual Studio defaults to <code>__cdecl</code>.  However the actual function you want to call uses a different calling convention, namely <code>__stdcall</code>.</p>

<p>Something like this should solve the issue:</p>

<pre><code>typedef void (__stdcall *GLenumFunc)(int, int); // or whatever your params are
//...
std::map&lt;std::string, GLenumFunc&gt; glEnableDisable;
</code></pre>

<p>As to what a calling convention is: <a href=""https://en.wikipedia.org/wiki/X86_calling_conventions"" rel=""nofollow"">Calling Conventions on x86 platforms</a></p>
",0
33598957,33598946,1,"<p>You have a typo in your first for</p>

<pre><code>for (int i = 0; i &lt; numberRolling, i++)
</code></pre>

<p>Should be</p>

<pre><code>for (int i = 0; i &lt; numberRolling; i++)
</code></pre>
",1
31237362,31236854,1,"<p>After running your code against some test cases. This is what I found.</p>

<blockquote>
  <p>If you take the value of <strong>greaterFactor</strong> as <strong><em>2^n</em></strong>  i.e (16, 32, 64, 128, 256, 512, ...so on). It fails to execute. And the algorithm you have used is very <em>inefficient</em>.</p>
</blockquote>

<p>Now, let's talk about the correct and efficient algorithm:</p>

<blockquote>
  <p>Here, I'm considering the Problem : Project Euler 3 as described in this <a href=""https://www.hackerrank.com/contests/projecteuler/challenges/euler003"" rel=""nofollow"">link</a> of Hackerrank Domain. Please, go through the link and check the constraints before reading further. </p>
</blockquote>

<p>As Problem says that the maximum value of <strong>N</strong> (or your greaterFactor) could be <strong><em>10^12</em></strong>. And, suppose you are given a value of <strong>N</strong> as 199,815,106,433 which is the 8,000,000,000th prime number. Now, think how would you sort this problem out with your algorithm, whose time complexity is O(n) .</p>

<p>Now, look at this code snippet:</p>

<pre><code>long long N, temp_N, i;
cin&gt;&gt;N;
temp_N = N;

for(i=2; i*i &lt;= N; i++) {
    if(N%i == 0) {
        while(N%i == 0) {
            N /= i;
        }
    }
}

if(N != 1) {
    cout&lt;&lt;N&lt;&lt;endl;
} else {
    cout&lt;&lt;i-1&lt;&lt;endl;
}
</code></pre>

<p>This code has the time complexity of O(sqrt(n)) and is efficient to calculate the desired output for <strong>all the values of num</strong> greater than <strong>1</strong>.</p>

<p><strong>Note:</strong> The above code could even work fine for the values of <strong>N</strong> in the range of <strong>[2, 10^18]</strong>.</p>
",0
31236932,31236854,0,"<p>You are almost on the right track. Here is alternative solution. It is fast (might not be the fastest)</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    long long i;
    long long n = 600851475143;

    for(i = 3; i &lt;= n; i += 2) {
        while(n % i == 0) {
            n /= i;
        }

        if (n == 1) break;
    }

    std::cout &lt;&lt; ""Largest prime factor "" &lt;&lt; i;
}
</code></pre>
",6
31236937,31236854,2,"<p>There is an inefficiency in your algorithm. You don't do the division if the ""other"" divisor is bigger. That's a BIG mistake. Always do the division as that will reduce the number. By taking the divisors out in order from lowest to highest, each will be prime. The last one you find is the highest.</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    long long i, n = 600851475143;
    for (i = 3; n &gt; 1; i += 2)
        while (n % i == 0)
            n /= i;
    printf(""%lld\n"", i - 2);
    return 0;
}
</code></pre>
",1
29508335,29508313,1,"<p>The issue is not access control, but rather scoping. <code>Leaf</code> is defined in <code>BST</code>, so its name is in the <code>BST</code> scope:</p>

<pre><code>BST::Leaf* BST::InsertNode(BST::Leaf *pos, BST::Leaf *node)
</code></pre>

<p>Now, being a private type of <code>BST</code> places some limitations on how non-friends can access the type. They won't be able to say</p>

<pre><code>BST::Leaf* leaf = foo.InsertNode(bar, baz);
</code></pre>

<p>but they can say</p>

<pre><code>auto leaf = foo.InsertNode(bar, baz);
</code></pre>

<p>On the surface it looks like <code>BST::Leaf</code> should be <code>public</code>.</p>
",0
31307548,31305813,0,"<blockquote>
  <p>For the input {15, 10, 20}</p>
</blockquote>

<p>Input 1: Initially, Add <code>15</code> to the BST <br></p>

<pre><code>    15
</code></pre>

<p>Input 2: Now, Add <code>10</code> to the BST <br></p>

<pre><code>    15
   /
  10
</code></pre>

<p>Input 3: Now, Add <code>20</code> to the BST <br></p>

<pre><code>    15
   /  \
  10  20
</code></pre>

<p><strong>Therefore</strong>, The <code>min</code> and <code>max</code> height of the <strong>BST</strong> would be <code>2</code><br>
<br><br></p>

<blockquote>
  <p>Now, Consider another input case {15, 5, 7, 10, 20, 25, 30, 35}</p>
</blockquote>

<p>Input 1: Initially, Add <code>15</code> to the BST<br></p>

<pre><code>    15
</code></pre>

<p>Input 2: Now, Add <code>5</code> to the BST <br></p>

<pre><code>    15
   /
  5
</code></pre>

<p>Input 3: Now, Add <code>7</code> to the BST <br></p>

<pre><code>    15
   /
  5
   \
    7
</code></pre>

<p>Input 4: Now, Add <code>10</code> to the BST <br></p>

<pre><code>    15
   /
  5
   \
    7
     \
      10
</code></pre>

<p>Input 5: Now, Add <code>20</code> to the BST <br></p>

<pre><code>    15
   /  \
  5   20 
   \
    7
     \
      10
</code></pre>

<p>Input 6: Now, Add <code>25</code> to the BST <br></p>

<pre><code>    15
   /  \
  5   20 
   \    \
    7   25
     \
      10
</code></pre>

<p>Input 7: Now, Add <code>30</code> to the BST <br></p>

<pre><code>    15
   /  \
  5   20 
   \    \
    7   25
     \    \
      10   30
</code></pre>

<p>Input 8: Now, Add <code>35</code> to the BST <br></p>

<pre><code>    15
   /  \
  5   20 
   \    \
    7   25
     \    \
      10   30
            \
            35
</code></pre>

<p>As you could see from the <em>above diagram</em> the <code>min</code> <em>height</em> of <strong>BST</strong> = <code>4</code> &amp; <code>max</code> height = <code>5</code> 
<br>
<br>
<br></p>

<p>Therefore, if look properly into your <code>findMin</code> code, then you will find a bug:</p>

<pre><code>int findMin(Node* root)
 {
     if (root == NULL)
        return 0;

     return 1 + std::min(findMin(root-&gt;left), findMin(root-&gt;right));
 } 
</code></pre>

<p><strong>Bug</strong> : When your <code>root</code> is pointing to the <code>5</code> (i.e left child of <code>15</code> in second example) it will return <code>1</code> to its parent. ( Why ?) </p>

<p><strong>Correction</strong> : The below code snippet will work properly :
<br></p>

<pre><code>int min_depth(struct Node* root, int depth)
{
    if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
        return depth;

    int x = (root-&gt;left != NULL) ? min_depth(root-&gt;left, depth+1) :  depth;
    int y = (root-&gt;right != NULL) ? min_depth(root-&gt;right, depth+1) : depth;

    return (x &lt; y) ? x : y;
}
</code></pre>
",1
33598910,33598875,0,"<p>You can't do that directly. You can convert the number to a string first and search for the string in <code>buff</code>.</p>

<p>You can use a C approach:</p>

<pre><code>char temp[10];
sprintf(temp, ""%d"", myId);
if ( strstr(buff, temp) != NULL )
{
   // Found it.
}
else
{
   // Did not find it.
}
</code></pre>

<p>If you want to use more of a C++ approach, you can use:</p>

<pre><code>auto found = std::string(buff).find(std::to_string(myID));
if ( found != std::string::npos )
{
   // Found it.
}
else
{
   // Did not find it.
}
</code></pre>
",3
32950795,32950709,11,"<p>From ¡ì7.2/5 of the C++ standard, you have that in your case the underlying type is not <em>fixed</em>:</p>

<blockquote>
  <p>The underlying type can be explicitly specified using an enum-base. For a scoped enumeration type, the underlying type is int if it is not explicitly specified. In both of these cases, the underlying type is said to be fixed. [...]</p>
</blockquote>

<p>Which leads to ¡ì7.2/7:</p>

<blockquote>
  <p>For an enumeration whose underlying type is not fixed, the underlying type is an integral type that can represent all the enumerator values defined in the enumeration. If no integral type can represent all the enumerator values, the enumeration is ill-formed. It is implementation-defined which integral type is used as the underlying type except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0.</p>
</blockquote>

<hr>

<p>Summing up, for your enumeration the underlying type is at most an <code>int</code> or <code>unsigned int</code>. You can check the size via <code>sizeof</code>, and the type via <code>typeid</code>. Example checking code that prettifies the result with g++ (not necessary with Visual C++):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;typeinfo&gt;     // std::type_info
#include &lt;type_traits&gt;  // std::underlying_type
using namespace std;

int const bits_per_byte = CHAR_BIT;

#ifdef __GNUC__
#   include &lt;cxxabi.h&gt;      // abi::*, free
#   include &lt;string&gt;        // std::string

    auto display_name( type_info const&amp; info )
        -&gt; string
    {
        int   status;
        char* demangled = abi::__cxa_demangle( info.name(), 0, 0, &amp;status );
        string result = demangled;
        free( demangled );
        return result;
    }
#else
    auto display_name( type_info const&amp; info )
        -&gt; string
    { return info.name(); }    
#endif // __GNUC__

enum Cars {
    Toyota, Suzuki, Volkswa, Mitsubish, Alfarome, Holden, Bradleys
    };

auto main() -&gt; int
{
    using Cars_type = typename underlying_type&lt; Cars &gt;::type;
    type_info const&amp; info = typeid( Cars_type );
    cout &lt;&lt; ""This compiler is "" &lt;&lt; bits_per_byte*sizeof(void*) &lt;&lt; ""-bit.\n"";
    cout &lt;&lt; ""Underlying type is '"" &lt;&lt; display_name( info ) &lt;&lt; ""'.\n"";
    cout &lt;&lt; ""Size = "" &lt;&lt; sizeof( Cars ) &lt;&lt; "" bytes.\n"";
}
</code></pre>

<p>Output with MinGW g++ (tdm64-1) 5.1.0:</p>

<pre>
This compiler is 64-bit.
Underlying type is 'unsigned int'.
Size = 4 bytes.
</pre>
",11
32950905,32950709,7,"<p>The size depends on the platform/implementation.</p>

<p>In C++11, you can specify the underlying type (and hence the size).
In the following example the size would be 1 byte:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdint&gt;

enum cars : std::uint8_t {
    Toyota, Suzuki, Volkswa, Mitsubish, Alfarome, Holden, Bradleys
};

int main() {
    cars my_car = cars::Toyota;
    std::cout &lt;&lt; sizeof(my_car) &lt;&lt; std::endl;
};
</code></pre>

<p>Returns:</p>

<pre><code>1
</code></pre>

<p>While</p>

<pre><code>enum cars : std::uint32_t { ...
</code></pre>

<p>Returns:</p>

<pre><code>4
</code></pre>
",1
32952583,32950709,1,"<p>Each enumeration is a separate entity.</p>

<p>The compiler needs to allocate enough storage to hold the highest value of the enumeration.  </p>

<p>In your case, there are 7 entities.  The compiler needs to allocate enough storage to hold the value 7.  </p>

<p>The minimum size of an addressable data type is 1.  </p>

<p>If you create a variable of the <code>enum</code> type, it must have a <strong>minimum</strong> size of 1.  However, the compiler can choose a size that is more optimal for the architecture (platform), such as 2 bytes (16-bit word), 4 bytes (32-bit word) or other.  </p>

<p>If the enumeration items are used individually, like in an <code>if</code> statement, the compiler may not allocate any data storage and emit the values into an instruction in the executable.  </p>

<p>So the answer to your question is:  the minimum space for a variable of the enum type is 1.  What your compiler uses is dependent on the compiler and the platform.  If the enumeration value is used in an expression, the compiler may choose to put the value in the instruction, so there will be zero data space allocated.  </p>
",0
31802331,31801960,0,"<p>Your issue lies in this loop</p>

<pre><code>while(num!='=')
   {
      sum=sum+num;
      cin&gt;&gt;num;
   }
</code></pre>

<p>I will tell you why your code is hanging and why is not asking for more inputs, even if the condition in while loop fails. This happens when you insert a <code>char</code> instead of an <code>int</code> to something, when you input <code>'='</code> the stream gets corrupted.</p>

<p>You need to use something like this to avoid hanging.</p>

<pre><code>    {
        sum = sum + num;
        cin &gt;&gt; num;
        cin.clear();
        cin.ignore();
    }
</code></pre>

<p>And don't insert a char when your code is expecting an int, it sets the error flag and no more reading is possible. And since you can't input char inplace of an int, ask the user at the start how many numbers he wants to add, and then run your loop for that many times to get the input.</p>

<p>like this:</p>

<pre><code>cout&lt;&lt;""Enter the number of items""&lt;&lt;endl;
cin&gt;&gt;items;
cout&lt;&lt;""Enter first item"" &lt;&lt;endl;
while(items)
{
cin&gt;&gt;num;
sum=sum+num;
items--;
}
</code></pre>
",9
31802789,31801960,0,"<p>After you type '=', this character be convert to int since you declare num as int. But unfortunately the result isn't as you expected. The conversion failed!When an error occurs when reading from a stream, an error flag gets set and no more reading is possible until you clear the error flags. That's why you get an hang</p>

<p>Please refer to <a href=""https://stackoverflow.com/questions/18400620/cin-for-an-int-inputing-a-char-causes-loop-that-is-supposed-to-check-input-to-go"">cin for an int inputing a char causes Loop that is supposed to check input to go wild</a></p>
",0
31129250,31129225,0,"<p>You need to make sure you add your breaks after each case if you want the switch statement to break/exit. Else everything underneath is going to be executed.
Also you mixed up the != (does not equal) and wrote =!</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{

    cout &lt;&lt; ""1. Facebook"" &lt;&lt; endl;
    cout &lt;&lt; ""2. Twitter"" &lt;&lt; endl;
    cout &lt;&lt; ""3. Instagram"" &lt;&lt; endl;
    cout &lt;&lt; ""4. SnapChat"" &lt;&lt; endl;

    int input;

    do {
        cout &lt;&lt; ""Enter a selection &gt; "";
        cin &gt;&gt; input;
        switch(input) {
        case 1:
            cout &lt;&lt; ""Facebook is Loading..."" &lt;&lt; endl;
            break;  
        case 2:
            cout &lt;&lt; ""Twitter is Loading..."" &lt;&lt; endl;
            break;  // add break
        case 3:
            cout &lt;&lt; ""Instagram is Loading..."" &lt;&lt; endl;
            break;  // add break
        case 4:
            cout &lt;&lt; ""SnapChat is Loading..."" &lt;&lt; endl;
            break;  // add break
        default:
            cout &lt;&lt; ""Wrong Selection"" &lt;&lt; endl;
        }
    } while(input != 1 &amp;&amp; input != 2 &amp;&amp; input != 3 &amp;&amp; input != 4); // != not =!

    return 0;
}
</code></pre>
",1
31129268,31129225,1,"<p>Firstly...</p>

<pre><code>input =! 1 &amp;&amp; input =! 2 &amp;&amp; input != 3 &amp;&amp; input != 4
</code></pre>

<p>... those <code>=!</code> should be <code>!=</code>.</p>

<p>Secondly, if someone types non-numeric input, <code>cin &gt;&gt; input</code> will fail and all future input attempts will instantly fail - without even waiting for the user to type anything further.  You need to clear the error state and ignore any bad input characters remaining in the stream - say up to the end of the line:</p>

<pre><code>default:
    cout &lt;&lt; ""Wrong Selection"" &lt;&lt; endl;
    std::cin.clear(); // clear error state
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');.
</code></pre>

<p>You'll need to <code>#include &lt;limits&gt;</code> atop your program to use <code>std::numeric_limts&lt;&gt;</code>.</p>

<p>Separately, you're first two <code>case</code> statements lack a <code>break</code> and will fall through to execute the following <code>case</code>(s) code....</p>

<hr>

<p>I'd recommend explicitly checking <code>cin &gt;&gt; input</code> for success too, though with C++11 it guarantees to set <code>input</code> to <code>0</code> on failure so it will work reliably.  With C++03 there's no such guarantee and you may get arbitrary garbage left in <code>input</code> after a failure, which might coincidentally match one of the <code>case</code>s.  To handle this explicitly:</p>

<pre><code>if (!(cin &gt;&gt; input)) input = -1; // sentinel meaning erroneous
</code></pre>
",0
31129301,31129225,0,"<p>Add a <code>break</code> statement after each <code>case</code>:</p>

<pre><code>case 2:
cout &lt;&lt; ""Twitter is Loading..."" &lt;&lt; endl;
break; 
case 3:
cout &lt;&lt; ""Instagram is Loading..."" &lt;&lt; endl;
break;
</code></pre>

<p>Change <code>=!</code> to <code>!=</code></p>

<pre><code>while(input != 1 &amp;&amp; input != 2 &amp;&amp; input != 3 &amp;&amp; input != 4);
</code></pre>
",0
31810443,31810350,2,"<p>You are trying to return a function-local variable by reference, which will leave you with a dangling reference as soon as you return from the function.  If you are trying to get a reference to the <code>Task</code> in your <code>vector</code>, your <code>successor</code> function would look like</p>

<pre><code>Task&amp; Task::successor(int index) const {
    if (index &lt; 0) throw TaskException("""");
    return *task_to.at(index);
}
</code></pre>

<p>Know that this does not check that the <code>Task*</code> at that index is not <code>nullptr</code>.</p>
",5
34235624,34235553,1,"<p>Your declaration is not the same with your definition:</p>

<pre><code>friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, complex c);
std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, complex const&amp; c) {
    return out &lt;&lt; c.getReal() &lt;&lt; ""+"" &lt;&lt; c.getImag() &lt;&lt; ""i"";
}
</code></pre>

<p>You need to change your declaration to </p>

<pre><code>friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const complex &amp;c);
</code></pre>
",2
32400226,32398834,1,"<p><code>for (int i = ...</code> // signed vs. unsigned comparsion (use size_t instead)</p>

<p><code>i &lt;= names.size()</code> // it'll access element after last valid one later</p>

<p>And also unused variable on line 139</p>

<p>Token::get(), double get_value(std::string) and double primary(): at least one path without return...</p>
",2
31217074,31216797,1,"<p>You could use a stringstream.</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;iostream&gt;
using namespace std;
int main(int argc, char* argv[]) {
    string enteredSentence; // It's initialized to """" by default, by the way
    getline(cin,enteredSentence);
    cout&lt;&lt;""size of sentence: ""&lt;&lt;enteredSentence.length()&lt;&lt;endl;
    istringstream str_in(enteredSentence);
    string word;
    while(str_in &gt;&gt; word) {
        // Do stuff with word
        // I believe str_in.str() will also give you the portion that hasn't yet been processed.
    }
    return 0;
}
</code></pre>
",0
31216946,31216797,1,"<p>I'm not 100% sure that I understand what you want to achieve. But I can help you with find:</p>

<p>It has a second parameter that specifies from where on in the string the search will start:</p>

<pre><code>size_t pos = 0;
while ((pos = str.find(' ', pos)) != std::string::npos) {
  std::cout &lt;&lt; ""Found a space at "" &lt;&lt; pos &lt;&lt; std::endl;
  ++pos;
}
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/find"" rel=""nofollow noreferrer"">Reference</a></p>

<p>With more information on what you actually want your code to do (show example input plus wanted output) I can help you clear the rest of your code.<br>
Currently your description suggests that you want to output the entire string, but in pieces (separated by spaces).</p>

<p>Your code makes a (needless?) copy of your input, generates substrings only to throw them away and doesn't return an <code>int</code> as said in the function declaration.</p>

<p>If you want to tokenize your input then <a href=""https://stackoverflow.com/q/53849/1116364"">this question</a> has some answers for you.</p>
",1
31216994,31216797,1,"<p>This is how I fixed your code:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    string enteredSentence="""";

    getline(cin,enteredSentence);
    string sentenceString(enteredSentence);

    int sentenceLength = enteredSentence.size();
    cout&lt;&lt;""size of sentence:""&lt;&lt;sentenceLength&lt;&lt;endl;
    string::size_type stringSize = sentenceString.size();
    while(stringSize &gt; 0)
    {
        int spaceLoc = sentenceString.find("" ""); //there was incorrect var
        cout&lt;&lt;spaceLoc&lt;&lt;endl;

        if(spaceLoc == string::npos){
            cout&lt;&lt;""last part:""&lt;&lt;sentenceString&lt;&lt;endl;
            break;
        }//check if there are no spaces left

        cout&lt;&lt;sentenceString.substr(0,spaceLoc)&lt;&lt;endl;
        //the substr line here was redundant
        cout&lt;&lt;""string before string erased:""&lt;&lt;sentenceString&lt;&lt;endl;

        sentenceString.erase(0, spaceLoc + 1);//also delete the space
        cout&lt;&lt;""string after string erased:""&lt;&lt;sentenceString&lt;&lt;endl;

        stringSize=sentenceString.size();
        cout&lt;&lt;""string size:""&lt;&lt;stringSize&lt;&lt;endl&lt;&lt;endl;

    }
    return 0;
}
</code></pre>
",2
34234771,34234700,1,"<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/compare"" rel=""nofollow""><code>std::basic_string::compare</code></a> returns a value less than 0, 0 or more than 0.  Since</p>

<pre><code>if (line.compare(getFriendName()) == string::npos)
</code></pre>

<p>Is seeing if the return is the maximum value of the type of <code>string::npos</code> you more than likely will never trigger the if statement.  If you only want to match a string exactly then you can use</p>

<pre><code>if (line == getFriendName())
</code></pre>

<p>If instead you want to find any line that starts with <code>getFriendName()</code> then you want</p>

<pre><code>if (line.find(getFriendName()) == 0) 
</code></pre>

<p>In the above <code>find</code> will only return <code>0</code> if the string starts with what you want.</p>
",0
34234809,34234700,2,"<p>The problem is that you are assuming that <a href=""http://en.cppreference.com/w/cpp/string/basic_string/compare"" rel=""nofollow""><code>compare</code></a> returns the same value as <a href=""http://en.cppreference.com/w/cpp/string/basic_string/find"" rel=""nofollow""><code>find</code></a> would. The <code>compare</code> function returns an integer with value:</p>

<ul>
<li><code>0</code> if the strings are equal</li>
<li><code>&gt;0</code> if the <em>compared</em> string (in your case <code>line</code>) is lexicographically first</li>
<li><code>&lt;0</code> if the <em>comparing</em> string (in your case <code>getFriendName()</code>) is lexicographically first</li>
</ul>

<p>Therefore to check for an exact match, you would want:</p>

<pre><code>if(line.compare(getFriendName()) == 0) {
    setExists(false);
    // ...
}
</code></pre>

<p>Comparing the result of <code>compare</code> with <code>string::npos</code> will never trigger since the magnitude of <code>compare</code> is the first differing character between your two strings.</p>
",0
31542165,31541891,3,"<p>Use some sort of iostream. For example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;

using namespace std;

int main() {
    string input(""1+2=4"");
    stringstream ss(input);

    int a, b, c;
    char sign;
    ss &gt;&gt; a &gt;&gt; sign &gt;&gt; b &gt;&gt; sign &gt;&gt; c;

    cout &lt;&lt; (a + b == c) &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Having converted your numbers using a stream, you can store them wherever you need.</p>
",2
31542223,31541891,0,"<p>You should split the string and then use a library to parse the numbers.
For example you can use:</p>

<pre><code>string input_number_string = ""42.42"";
float number;
sscanf(input_nuber_string, ""%f"", &amp;number);
</code></pre>

<p>There are better libraries out there as well.</p>
",2
32430374,32430357,1,"<p>I¡¯m guessing it doesn¡¯t realize that <code>Plane</code> is a class, and thinks instead you¡¯re trying to declare a static member named <code>Plane</code> (and warns you that it¡¯s assuming it¡¯s of type <code>int</code> since you didn¡¯t give it a type).</p>

<p>Add <code>struct Plane;</code> before <code>class Utility {</code> in your <code>Utility.h</code> to forward-declare <code>Plane</code>, which should make it understand that <code>Plane</code> is a type, not the name of a member you¡¯re trying to declare, and hence solve your problem.</p>

<p>(I should also note that many people frown on <code>using namespace std;</code> at the top level in header files.)</p>
",2
32430377,32430357,1,"<p>In <code>utility.h</code> you have</p>

<pre><code>static Plane* getPlanes(const char* fileName);
</code></pre>

<p>But there is nothing in the header file to tell the compiler what a <code>Plane</code> is.  You either need to include the file that has the <code>Plane</code> type in it or forward declare it in your header file.</p>
",0
32430402,32430357,0,"<p>You need to tell the compiler about <code>Plane</code>.</p>

<p>The most basic way of doing this is to include the header that defines <code>Plane</code> in <code>Utility.h</code>.</p>

<p>A more advanced way of doing this is to forward declare the class or struct by adding <code>class Plane;</code> or <code>struct Plane;</code>, as appropriate, to <code>Utility.h</code> before <code>class Utility</code>, and then include the header that defines <code>Plane</code> in <code>Utility.cpp</code>. You can do this because in the header you only have a pointer to <code>Plane</code>, and therefore the compiler only needs to know of it's existence. While to use it you need to include the definition of the class/struct.</p>
",0
34085470,34085093,5,"<p><strong>auto</strong> is not limited to the return values of functions, but to mostly everything where the compiler can actually deduce the type of a variable without you having to tell it explicitly. So:</p>

<pre><code>  std::vector&lt; std::string &gt;::iterator it = myVector.begin();  // C++98 -&gt; c'mon compiler, you know what the returned value of begin is, why do I have to write it?
  auto it = myVector.begin();  // C++11 -&gt; ah, that's much more convenient
                                 // note that the type of it is still the same, you just didn't have to write it down
</code></pre>

<p>In C++14, auto can also be used for the return types of functions, so</p>

<pre><code>// c++98
std::vector&lt; std::string &gt; createAFancyStringVector()
{
  std::vector&lt; std::string &gt; vec;
...
  return vec;
}

// c++14
auto createAFancyStringVector()
{
  // same function body, the compiler deduces the return type from the return statement
}
</code></pre>

<p>For in-depth reading on this, I recommend Scott Meyer's 'Effective Modern C++', chapter 2.</p>

<p>Ah, and to answer the question: your code looks fine, there's no other place where using auto makes sense (you could use auto instead of int in the loop, but that brings no real benefit)</p>

<p><strong>Additional Info</strong>: since auto is a C++11 feature, it obviously depends on a compiler that supports it and has this feature enabled. Namely that would be e.g. Clang > 3.3 or GCC >4.3 (with compiler flag -std=c++11) or VC++ 2013 / 2015</p>
",5
34248929,34248786,0,"<p>The only thing I can think would cause this kind of problem would be a linking error. </p>

<p>If you go under the File tab, then select class, and go through the window prompts, and it should automatically create and link a header and source file. </p>

<p>If you want to link your files manually you can add the path to the folder the file is within, under the tab Project, then Build Options, then Search directories. Any addresses you add to the compiler and and linker will be searched when the compiler looks for an #include.</p>
",3
31538600,31538500,-1,"<p>You are correct about the while, it will keep reading until it finds <code>EOF</code>, or End-Of-File. While can accept anything that returns true or false, so any function that returns bool (or even numbers, etc) will work.</p>
",0
31538660,31538500,0,"<p>In C++ you can read a file char by char as given example   </p>

<pre><code>char oneChar;
fstream fin(""file"", fstream::in);
while (fin &gt;&gt; noskipws &gt;&gt; oneChar) 
{
    cout &lt;&lt; oneChar; 
    // or do desired operation with oneChar
}
</code></pre>
",0
31185465,31185119,30,"<blockquote>
  <p>why is it so 
  Shouldn't compiler return error in (2) and (3) as in (1)?</p>
</blockquote>

<p>It is an interesting question.. and answer to this is even more interesting. </p>

<p>In the code you posted, <code>inner</code>is a <em>name</em> of a type.  It is the <em>name</em> which is declared to be <code>private</code>, not the <em>type</em> itself<sup>1</sup> &mdash; accessibility of <em>type</em> doesn't make sense in the context of C++; accessibilty applies to <em>name</em> only &mdash; be it <em>name</em> of type, <em>name</em> of function, <em>name</em> of data . So when you hear something like <em>""the type X is a public class""</em>, it almost always means <em>""the name X is declared to be public, and it refers to a type and the type is omnipresent, it exists everywhere""</em>.</p>

<p>Coming back to why using <code>auto</code> doesn't give error, well because when you use <code>auto</code>, you're accessing the <em>type</em> without using its name, which is why it doesn't give error.</p>

<blockquote>
  <p>how can i prevent return of an instance of private inner class from outer methods, </p>
</blockquote>

<p>There is no way.</p>

<hr>

<p><sup>1. <code>struct { int data; }</code> is a <em>type</em>, without a <em>name</em> to refer to, though note that is not a valid declaration, because it lacks <em>name</em>. Either you've to declare an object of <em>unnamed</em> type as in <code>struct { int data; } obj;</code> Or give it a name as <code>struct data_type { int data; };</code></sup></p>
",12
31185591,31185119,1,"<p>I'm not sure that it's what you want but you can delete the copy constructor like that:</p>

<pre><code>inner(inner const&amp;) = delete;
</code></pre>
",3
31195885,31195700,1,"<p>The derivation of the rotation matrix used in the blog is <a href=""http://inside.mines.edu/fs_home/gmurray/ArbitraryAxisRotation/"" rel=""nofollow"">here</a>. The Rz matrix used in the derivation is a counter clockwise rotation about the z axis, so the rotation is counter clockwise about the (u, v, w) vector.</p>
",0
31844461,31844430,6,"<p>Allocate your string as an array on the stack and not as a pointer into a possibly read-only segment of your program.</p>

<pre><code>char str[] = ""hello"";
</code></pre>
",4
31845071,31844430,2,"<p>First of all, this line should atleast give you a warning: </p>

<pre><code>char* str = ""hello"";
</code></pre>

<p>you are converting a string constant to a pointer, which is not allowed.
To fix your code, you should use, <code>char str[] = ""hello""</code> in <code>main()</code>.</p>

<p>When you pass this array in <code>reverse()</code>, it decays to <code>char*</code>, now the question which you asked in previous answer's comment.</p>

<blockquote>
  <p>But when I write cout &lt;&lt; str &lt;&lt; endl;, why does it print out ""hello""? Shouldn't it print only the first character of the string since it points to the first element of the array?</p>
</blockquote>

<p>It is because the <code>&lt;&lt;</code> operator on <code>std::cout</code> is overloaded. If you give it a <code>char*</code> or <code>const char*</code>, it treats the operand as a pointer to (the first character of) a C-style string, and prints the contents of that string:</p>

<pre><code>const char * str= ""hello"";
cout &lt;&lt; str; // prints ""hello""
</code></pre>

<p>If you give it a char value, it prints that value as a character:</p>

<pre><code>cout &lt;&lt; *str;   // prints ""h""
cout &lt;&lt; str[0]; // prints ""h""
</code></pre>
",0
28160108,28160099,2,"<p>You are on the right track, but you just need to include the '&amp;' symbol in your function header. The '&amp;' symbol is used to pass an argument by reference, as opposed to by value. </p>

<p>In this case you are passing the address to the first element of your array by reference, meaning that you can modify that address in the function, and the changes will be reflected in your main function.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

void passArrayByReference(int * &amp;array) {
    cout &lt;&lt; ""Address of array in function is: "" &lt;&lt; array &lt;&lt; endl; 
    int * localArray = new int [2];
    //put some dummy values in our localArray
    localArray[0] = 9;
    localArray[1] = 9;
    array = localArray;
    cout &lt;&lt; ""Address of array in function is now: "" &lt;&lt; array &lt;&lt; endl; 
}

int main()
{
   int * array = new int [2];
   int totalElements = 2;
   //put some initial values into our dynamic 1D array
   array[0] = 0;
   array[1] = 1;
   //print our initial values
   for(int i = 0; i &lt; totalElements; i++)
        cout &lt;&lt; array[i] &lt;&lt; endl;
   cout &lt;&lt; ""Address of array in main is: "" &lt;&lt; array &lt;&lt; endl; 
   passArrayByReference(array);
   cout &lt;&lt; ""Address of array in main is now: "" &lt;&lt; array &lt;&lt; endl; 

   //now print the values of our 'new' array
   cout &lt;&lt; ""The values of array are now:"" &lt;&lt; endl;
   for(int i = 0; i &lt; totalElements; i++)
        cout &lt;&lt; array[i] &lt;&lt; endl;

   return 0;
}
</code></pre>
",2
28160144,28160099,1,"<p>Pointers are variables as well.
That's why you need to pass <code>array</code> as a reference to <code>passArrayByReference</code> so you don't just modify the copy of it.</p>

<pre><code>void passArrayByReference(int *&amp;array)
</code></pre>
",0
28160181,28160099,1,"<p>First, you have to pass pointer by pointer or reference to make persistent change to it - that is change original pointer and not only <strong>copy</strong> of it in function body:</p>

<pre><code> void passArrayByReference(int *&amp;array) {
     //...
     array = new_address;
     std::cout &lt;&lt; ""Address of array in function is now: "" &lt;&lt; array &lt;&lt; std::endl; 
 }
// and here it is the same
</code></pre>

<p>And second you should assign valid address <code>new_address</code> and take care of memory that <code>array</code> referenced just before it entered the function, <strong>to avoid memory leak</strong>.</p>
",0
32390469,32389627,0,"<ol>
<li><p>Your code has <a href=""http://ideone.com/BiqsE6"" rel=""nofollow"">compilation errors</a>.</p></li>
<li><p><code>^</code> is <a href=""http://www.tutorialspoint.com/cprogramming/c_bitwise_operators.htm"" rel=""nofollow"">Binary XOR Operator</a>. You can't expect it to produce <code>pow(10,i)</code>. So replace <code>nmbrs.push_back(((n/10^i) % 10);</code> with <code>nmbrs.push_back(((n/pow(10,i)) % 10);</code> </p></li>
<li><p>When I was able to remove the compilation errors, i realized your code has logical errors too. As your given definition of simber, <code>int is_simber(int n)</code> should be fair and simple.</p></li>
</ol>

<pre class=""lang-cpp prettyprint-override""><code>bool is_simber( int n )
{
    if ( n&lt;0 ) return false; // simber is a positive integer

    int digitCount[10] = {}; // initializing all with 0;
    // digitCount array holds the number of occurance of a digit
    // so d[1] holds the number of times 1 occurred
    // d[2] holds the number of times 2 occurred and so on ... 

    while( n ){
        int d = n%10;
        n /= 10;
        digitCount[d]++;
    }

    // we just have to check 
    // any odd digit, if present, occurs an odd number of times

    for( int i=1; i&lt;=9; i= i+2) // Attention i=i+2, to iterate over just odd numbers
    {
        if( digitCount[i] != 0 &amp;&amp; digitCount[i]%2 == 0 ) return false;
    }
    return true;
}
</code></pre>
",4
32395216,32389627,0,"<p>My definition of <code>is_simber</code></p>

<pre><code>inline bool is_even(int n) { return n % 2 == 0; }

bool is_simber(int n) {
    if (n &lt; 0) return false;
    int digits[10] = {0};
    for (; n; n /= 10) ++digits[n % 10];
    for (int i = 0; i &lt; 10; i += 2)
        if (!is_even(digits[i]) &amp;&amp; is_even(digits[i + 1])) return false;
    return true;
}
</code></pre>

<p><kbd><a href=""http://coliru.stacked-crooked.com/a/a1c3e812ea53208f"" rel=""nofollow"">LIVE DEMO</a></kbd></p>
",0
32389847,32389684,0,"<blockquote>
  <p>void * memset ( void * ptr, int value, size_t num );</p>
</blockquote>

<p>So you have to write something like that:</p>

<pre><code>#include &lt;iostream&gt;
#include ""memory.h""

void* paranoid = (void*)sigScan(""\x00\x00\x70\x41\x01\x00\x00\x00"",""xxxxxxxx"");

void initiate() {

if(paranoid)
    memset(paranoid,-1, sizeof(int));//were I'm having issues at (I don't understand this function)
std::cout&lt;&lt;""toggled paranoid""&lt;&lt;std::endl;
}
</code></pre>

<p>Also its worth pointing out, that use of the <code>DWORD</code> variable to store pointer is potentially unsafe, because it could lead to the pointer truncation in the x64 environment.</p>
",1
32402372,32402117,0,"<p>There is no easy / universal way to do so. There are separate methods for Linux (alarm, signal handlers, followed by manual stream flushing and resetting) and Windows (not sure -- implement your own readline using raw keyboard input?), but they are all quite complicated and hard to get right.</p>
",0
32402873,32402221,0,"<p>The most obvious bug is you forgot to modify <code>temp</code> in your loop</p>

<pre><code>for(j=0;j&lt;m;j++)
    a[i][j]*x[j];
</code></pre>

<p>That bug gives you garbage answers and hides the more fundamental flaw that you can't blindly take the input matrix in original sequence.  You need to resequence the matrix to avoid the divides by zero.</p>

<p>You might want to also detect the case in which no resequence of the matrix can avoid divide by zero (implying the original matrix was singular and the system cannot be uniquely solved).</p>
",2
32422439,32402221,1,"<p>In your comments (after correcting the bug I mentioned in your original post) you described this input matrix</p>

<pre><code>1 -2  -6  12
2  4  12 -17
1 -4 -12  22
</code></pre>

<p>which produces this upper triangle:</p>

<pre><code>1  -2  -6   12  
0   8  24  -41  
0   0   0  -0.25  
</code></pre>

<p>In the original, you should observe the first and third rows are contradictory:  Double all the coefficients of the unknowns but the right hand side is not doubled.  That means the system has no solution.  In the upper triangle form, that same problem has been compressed into the third row:  Zero times each unknown adds up to nonzero, so the third unknown is -INF and the other two can't be computed in any meaningful way.</p>

<p>Then you tried this matrix</p>

<p><strong>0</strong> 2 1 -8<br>
1 <strong>-2</strong> -3 0<br>
-1 1 <strong>2</strong> 3<br>
Notice I marked the main diagonal in bold.  You are dividing by the main diagonal, so that first zero wrecks the whole process.  That is what I meant in my first answer about needing to resequence to avoid divide by zero.  </p>

<p>Your first example can't be solved.  No resequence would eliminate the contradiction between the first and third rows.  </p>

<p>Your second example can be solved by resequencing.</p>

<p>I added crude resequencing to your code:<br>
(my whole change is the loop beginning <code>for(i=k; ;i++)</code> )</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;cmath&gt;
using namespace std;
int main()
{
  float a[10][10],b[10],temp,x[10]={0};
  int i,j,k,n,m;
  cout&lt;&lt;""enter order of matrix"";
  cin&gt;&gt;m&gt;&gt;n;
  cout&lt;&lt;""\n enter the elements of a matrix"";
  for(i=0;i&lt;m;i++)
  {
      for(j=0;j&lt;n;j++)
      cin&gt;&gt;a[i][j];
  }
  cout&lt;&lt;""\n matrix is"";
  for(i=0;i&lt;m;i++)
  {       cout&lt;&lt;""\n"";
      for(j=0;j&lt;n;j++)
      cout&lt;&lt;a[i][j]&lt;&lt;""  "";
  }
  // upper triangular matrix
  for(k=0;k&lt;m;k++)
  {
      for(i=k; ;i++)
      {
          if (i==m)
          {
              cout &lt;&lt; ""\nThe matrix is singular\n"";
              return -1;
          }
          if (a[i][k] != 0)
          {
              for(j=0;j&lt;n;j++)
                  std::swap( a[k][j], a[i][j] );
              break;
          }
      }
      for(i=k+1;i&lt;m;i++)
      {   temp=a[i][k]/a[k][k];
          for(j=0;j&lt;n;j++)
          {a[i][j]=a[i][j]-temp*a[k][j];
      }
  }
  }
  cout&lt;&lt;""\n the gauss elimination matrix is"";
  for(i=0;i&lt;m;i++)
  {   cout&lt;&lt;""\n"";
      for(j=0;j&lt;n;j++)
      cout&lt;&lt;a[i][j]&lt;&lt;""  "";
  }
  // values of variables
  for(i=(m-1);i&gt;=0;i--)
  {   temp=0;
      for(j=0;j&lt;m;j++)
    temp=temp+a[i][j]*x[j];
      x[i]=(a[i][m]-temp+a[i][i])/a[i][i];
  }
  cout&lt;&lt;""\n the values of variables are"";
  for(i=0;i&lt;m;i++)
  {       cout&lt;&lt;""\n"";
      cout&lt;&lt;x[i]&lt;&lt;""  "";
  }
}
</code></pre>
",2
32424361,32424187,1,"<p>When you type 'a', there is nothing to eat the input.  This  will keep failing, going ""insane""</p>

<pre><code>cin &gt;&gt; a;
</code></pre>

<p>Reads numbers into a.  If it is unable to read, then it sets an error and reads nothing.  </p>
",1
32424720,32424187,0,"<p>it happens when your reentered in to <strong>Josh goto</strong> statement and cin>>b doesn't take input because of previous value in <strong><em>inputstream</em></strong> 
So, just clear the inputstream by calling <strong>cin.ignore();</strong> </p>

<pre><code>#include&lt;iostream&gt;
#include&lt;limits&gt;
    using namespace std;
    int main()
    {
        int a,b;
    Claude:
    {
    cout&lt;&lt;""Please Enter Your Pin: "";
    cin&gt;&gt;a;
    cout&lt;&lt;endl;
    system(""cls"");
    cin.get();
    }

        if(a==1234)
        {
         Josh:

           cout&lt;&lt;""Choose An Option: ""&lt;&lt;endl;
           cout&lt;&lt;""1: Withdraw                 2: Check Balance"";
           cout&lt;&lt;endl;
           cout&lt;&lt;""3: Deposit                  4: Exit"";
           cout&lt;&lt;endl;
           cout&lt;&lt;""Enter Here: "";
           //cin.ignore(numeric_limits&lt;streamsize&gt;::max(),'*');
           cin&gt;&gt;b;

          system(""cls"");
    }
    else
        {
        cout&lt;&lt;""Incorrect Pin, Please Try Again""&lt;&lt;endl;
        cout&lt;&lt;endl;
        cout&lt;&lt;""Press Any Key To Continue ""&lt;&lt;endl;
        system(""pause&gt;nul"");
        system(""cls"");
        goto Claude;


    }

      if(b==1)
        {
        cout&lt;&lt;""How Much: "";

        }
    else if (b==2)
        {
        cout&lt;&lt;""2000.00"";

        }
    else if(b==3)
        {
        cout&lt;&lt;""Nothing To Withdraw"";

        }
    else if(b==4)
        {
        cout&lt;&lt;""test"";
        }   
    else
        {
            cout&lt;&lt;""Please Enter Valid Input, Press Any Key To Continue "";





        cin.clear();
        cin.ignore();



        cin.get();
        cin.get();

        system(""cls"");
        goto Josh;  
        }


    return 0;   
    }
</code></pre>
",2
32424407,32424187,1,"<p>You have to clear your console input buffer (std::cin).</p>

<p>You can do that with cin.clear() and cin.ignore()</p>

<pre><code>//...
cout&lt;&lt;endl;
cout&lt;&lt;""Press Any Key To Continue ""&lt;&lt;endl;

cin.clear( );
cin.ignore( 10000, '\n' );
//...
</code></pre>
",1
31801377,31801307,4,"<p>It seems you need this code: </p>

<pre><code>float a = 0;
for(int n = 1; n &lt; 100; n++){ //n increases everytime
  sum = (1.0/(n * (n+1.0)));
  a += sum;
}
cout &lt;&lt; a &lt;&lt; endl;
</code></pre>
",1
28312028,28311930,1,"<p>The problem is having the wrong conditions for a tie.</p>

<p>The condition is not</p>

<ul>
<li>There is no winner</li>
</ul>

<p>but</p>

<ul>
<li>The game is over and there is no winner</li>
</ul>

<p>You never checked if the game is over.</p>
",0
28248432,28248385,3,"<p>If you meant for those integers to be percentages, make them cumulative. For the orange's cutoff, use the sum of apple and orange as you have them now. For cherry, the sum of the first three (apple, orange, and cherry). If you want the user to be able to enter percentages, express this process in the function you're using to set the thresholds (the Cspinner constructor).</p>
",6
28248446,28248385,0,"<p>The value of apple is greater than all the other values.  Yet you are checking it first.  The only two possible outcomes are apple or nothing</p>
",0
31536709,31536047,0,"<p>I really like the ""blocking calls on multiple threads"" design. It enables you to have distinct independent tasks, and you don't have to worry about how each task can disturb another. It can have some drawbacks but it is usually a good fit for many needs.</p>

<p>To do that, just use <code>pthread_create</code> to create a new thread for each task (you may keep the main thread for one task). In your case, you should have a thread to receive commands, and another one to send your data. You also need for the receiving thread to notify the sending thread of the commands. To do that, you can use some synchronization tool, like a mutex.</p>

<p>Overall, you should have your receiving thread blocking on <code>recvfrom</code>, and the sending thread waiting for a signal from the mutex (wait for the mutex to be freed, technically). When the receiving thread receive a start command, it signals the mutex and go back to <code>recvfrom</code> (optionally you can set a variable to provide more information to the other thread).</p>

<p>As a comment, remember that UDP are 1-to-many, thus your code here will react to any packet sent to you (even from some random or malicious host). You may want to filter with the remote <code>sockaddr</code> after <code>recvfrom</code>, or use <code>connect</code> + <code>recv</code>. It depends on what you want.</p>
",4
34180102,34179972,1,"<pre><code>double Cmfc_test5Dlg::GuassianTerms(int kernalSize, double sigma, double* terms)
{
        for (int i = 0; i &lt; kernalSize; ++i) {
                terms[i] = Guassian(i - kernalSize / 2, sigma);
        }
        return 1;//*terms;
}
</code></pre>
",3
31841566,31841553,3,"<p>If you want to perform string concatenation, you can use the <code>+</code> operator</p>

<pre><code>file.open(""/sth/sth/sth/"" + tab[i] + ""/sth/sth.txt"", ios::in);
</code></pre>

<p>By the way, the <code>fstream</code> constructor can take these arguments so you don't need to make a separate <code>open</code> call</p>

<pre><code>for(int i=0;i&lt;5;i++)
{
    fstream file{""/sth/sth/sth/"" + tab[i] + ""/sth/sth.txt"", ios::in};
}
</code></pre>
",4
34244612,34244547,1,"<p>It is to be expected.  The C++ Standard gives the compiler the freedom to optimise in various ways, one of which is to use floating point registers in the CPU to store intermediate results, rather than using actual Random Access Memory to write back a double.  On some hardware, the process of writing back to double requires rounding.  For example, modern Intel CPUs have 80 bit floating point registers, but doubles are represented in 64 bits in memory.  So - rounding earlier can lead to different results.</p>

<p>FWIW (not much) - if you enable optimisation you <em>might</em> find a register is used consistently, while without optimisation the compiler's likely to follow your code naively and round to a variable in memory as implied by the use of local variables.</p>
",0
31824860,31824555,4,"<p>The simple way is to remove by employee ID. You just ask for the employee ID, to know what employee to remove.</p>

<p>Then, you cannot remove lines in the middle of a sequential file, so you just </p>

<ul>
<li>rename the file as <code>document.back</code></li>
<li>create a new <code>document.txt</code></li>
<li>read <code>document.back</code> and copy all employees to <code>document.txt</code> except the one you want to delete</li>
<li>close both files</li>
<li>remove <code>document.back</code></li>
</ul>

<p>That's all ... except for the usual test for IO errors, backup file existing, and so on...</p>

<p>I tested your code. First, you forgot to close document in method <code>int Document::No_of_lines()</code>. Next on my MSVC2008, I have to explicitely call <code>document.clear()</code> after reaching end of file. You also do not test <code>document</code> immediately after a <code>getline</code>, meaning that you execute the code after a bad read.</p>

<p>I removed <code>newdocument</code> from <code>Document</code> class, because IMHO it is useless. Here is a possible implementation of <code>Delete</code>:</p>

<pre><code>void Document::Delete()
{
    Document d2;
    Display();
    int num;
    document.open(""document.txt"");
    document.clear();
    d2.document.open(""newdocument.txt"", ios::out | ios::trunc);
    cout &lt;&lt; ""Enter the ID to delete \n"";
    cin &gt;&gt; idtodelete;
    while (document.good())
    {
        getline(document, data);
        if (document) {
            int n = 0;
            istringstream(data) &gt;&gt; num;
            if (num != idtodelete)
            {
                d2.document &lt;&lt; data &lt;&lt; endl;
            }
        }
    }
    document.close();
    d2.document.close();
    remove(""document.txt"");
    rename(""newdocument.txt"", ""document.txt"");
}
</code></pre>
",2
31855396,31855180,0,"<p>Use EnumWindows for enumerate all top level windows and EnumChildWindows to enumerate the child windows</p>
",0
31833053,31832695,0,"<p>You should rather use this code:</p>

<pre><code>    int numarr[10];
    int sum = 0, even = 0, odd = 0;
    for (int i = 0; i &lt; 10; i++)
    {
        cin &gt;&gt; numarr[i];
        if (numarr[i] % 2 == 0)
            even = even + numarr[i];
        else
            odd = odd + numarr[i];
        sum = sum + numarr[i];

    }
</code></pre>

<p>Those multiple <code>if-else</code> statements are very unpleasing to the eyes.</p>
",3
31858567,31858422,0,"<p><code>rect1(7.0, 8.9);</code> is attempting to find an overload for <code>operator()(double, double)</code>, which you haven't implemented.</p>

<p>Did you mean <code>rectangle rect1(7.0, 8.9);</code> etc? That's how you call a <em>constructor</em>.</p>
",0
31858578,31858422,0,"<p>The line:</p>

<pre><code>rect1(7.0,8.9);
</code></pre>

<p>is calling <code>operator()</code> on your rectangle object, however you have not defined this operator which is why you get that error.  I think what you wanted to do was call the constructor, which you have to do when you instantiate the object, like this:</p>

<pre><code>rectangle rect1(7.0, 8.9);
</code></pre>
",0
31858584,31858422,0,"<p>There's at least a problem there:</p>

<pre><code>rectangle rect1,rect2,rect3;
rect1(7.0,8.9);
rect2(11.4,12.8);
</code></pre>

<p>You must provide construction parameters at the location that the object is defined. Otherwise, the compiler thinks you're calling a function.</p>

<pre><code>rectangle rect1(7.0,8.9);
rectangle rect2(11.4,12.8);
rectangle rect3;
</code></pre>
",0
31858590,31858422,1,"<p>You should call the constructor when you declare the object like this:</p>

<pre><code>rectangle rect1(7.0, 8.9);
</code></pre>

<p>Otherwise, you are not actually calling the constructor, but the operator <code>()</code>, which you haven't defined somewhere in your class, leading to an error.</p>

<hr>

<p>Also, the <strong>overload of the <code>+</code> operator</strong> is not correct, since you return this: <code>return rectangle(length,width);</code>, where you should actually return <code>recta</code>, since this is the object on which you have applied the operator.</p>

<p>Putting them all together, your program should look like this:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class rectangle
{
    double length,width;

public:
    rectangle()
    {
        length=0;
        width=0;
    }

    rectangle(double len,double wid)
    {
        length=len;
        width=wid;
    }

    double display()
    {
        return(length*width);
    }

    rectangle operator+(const rectangle&amp; rect) const
    {
        rectangle recta;
        recta.length=this-&gt;length+rect.length;
        recta.width=this-&gt;width+rect.width;
        return recta;
    }
};

int main()
{
    rectangle rect1(7.0, 8.9), rect2(11.4,12.8), rect3;
    rect3=rect1+rect2;
    cout&lt;&lt;rect1.display()&lt;&lt;endl;
    cout&lt;&lt;rect2.display()&lt;&lt;endl;
    cout&lt;&lt;rect3.display()&lt;&lt;endl;
    return 0;
}
</code></pre>
",2
31858598,31858422,0,"<p>You defined a constructor, but are trying to use a call overload.</p>

<p>Constructors, the methods that have the same name as the struct/class, are only used when you initially build the thing, typically at the initial declaration point. You wrote:</p>

<pre><code>         rectangle rect1,rect2,rect3; 
         rect1(7.0,8.9); 
         rect2(11.4,12.8); 
</code></pre>

<p>The first line calls the default constructor and then the rectangle is built. The next lines try to call them as a function - since they are already made, it no longer tries to construct. (Specifically, it is trying to call <code>operator()(double,double)</code> now).</p>

<p>To fix this, you should initialize/construct them right at the declaration point:</p>

<pre><code>rectangle rect1(7.0, 8.9);
rectangle rect2(11.4, 12.8);
rectangle rect3 = rect1 + rect2;
</code></pre>
",0
31858616,31858422,0,"<p>The line</p>

<pre><code>rect1(7.0,8.9);
</code></pre>

<p>does not call <code>rectangle</code> constructor. It is calling <code>rect1</code> like a function; technically, it is calling <code>rectangle::operator()</code>. Since <code>rectangle</code> doesn't have such an operator, you get compilation error.</p>

<p>If you wanted to call the constructor, the correct syntax is</p>

<pre><code>rectangle rect1(7.0, 8.9);
</code></pre>
",0
31901850,31901794,1,"<p>You have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a>, you have a pointer <code>bufferString</code> but you never actually make int <em>point</em> anywhere. Since it's not initialized its value will be <em>indeterminate</em> and will seem to be random, meaning you will write to unallocated memory in the <code>fgets</code> call.</p>

<p>It's easy to solve though, declare it as an array, and use the array size when calling <code>fgets</code>:</p>

<pre><code>char bufferString[500];
...
fgets(bufferString, sizeof(bufferString), file);
</code></pre>

<hr>

<p>Besides the problem detailed above, you should not do <code>while(!feof(file))</code>, it will not work as you expect it to. The reason is that the <code>EOF</code> flag is not set until you try to read from beyond the file, leading the loop to iterate once to many.</p>

<p>You should instead do e.g. <code>while (fgets(...) != NULL)</code></p>

<hr>

<p>The code you have is not very C++-ish, instead it's using the old C functions for file handling. Instead I suggest you read more about the <a href=""http://en.cppreference.com/w/cpp/io"" rel=""nofollow"">C++ standard I/O library</a> and <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow""><code>std::string</code></a> which is a auto-expanding string class that won't have the limits of C arrays, and won't suffer from potential buffer overflows in the same way.</p>

<p>The code could then look something like this</p>

<pre><code>std::ifstream input_file(path);
std::string input_buffer;

while (std::getline(input_file, input_buffer))
    std::cout &lt;&lt; input_buffer &lt;&lt; '\n';
</code></pre>
",0
31901876,31901794,2,"<p><a href=""http://www.cplusplus.com/reference/cstdio/fgets/"" rel=""nofollow""><code>fgets</code></a> reads into the memory pointed to by the pointer passed as first parameter, <code>bufferString</code> on your case.</p>

<p>But your <code>bufferString</code> is an uninitialised pointer (leading to undefined behaviour):</p>

<pre><code>char * bufferString;
// not initialised,
// and definitely not pointing to valid memory
</code></pre>

<p>So you need to provide some memory to read into, e.g by making it an array:</p>

<pre><code>char bufferString[1000];
// that's a bit large to store on the stack
</code></pre>

<p>As a side note: Your code is not idiomatic C++. You're using the IO functions provided by the <em>C</em> standard library, which is possible, but using the facilities of the C++ STL would be more appropriate.</p>
",0
28468574,28468522,3,"<p>No, the two are not equivalent from the point of view of readability: when you return a pointer, readers of your code think about the ownership of that pointer; when you return a reference, they know for sure that you own it.</p>

<p>It is natural for users of your API to delete a pointer that you return. Your API documentation needs to say whether the pointer needs to be deleted with <code>delete[]</code> or <code>delete</code>, - or not at all, in cases when your library retains the ownership of the object that you return by pointer.</p>

<p>It is entirely unnatural for users of your API to think that they may need to delete anything returned to them by reference. It does not mean that you cannot do it - you certainly can, but it would be completely unexpected, so one should avoid doing it.</p>
",7
28468645,28468522,1,"<p>If the compiler is smart enough, the two cases may compile to the same machine code (my compiler does, at least), for example:</p>

<pre><code>int* func1() {
    return new int;
    /*
    push $04
    call $00402afe
    pop ecx
    */
}

int&amp; func2() {
    return *(new int);
    /*
    push $04
    call $00402afe
    pop ecx
    */
}
</code></pre>

<p>Other than the possibility of maybe having slightly different machine code being generated by the compiler if the second case's de-referencing/re-referencing is not optimized away, they are essentially equivalent in that the caller ends up receiving a memory address to the allocated <code>int</code> value in both cases.  From a technical standpoint, pointers and references are treated identical in machine code, the main difference is that the compiler validates that a reference is never unassigned but a pointer can be.  But from a coding standpoint, pointers and references are different beasts with different coding semantics, rules of use, etc.</p>
",0
33513120,33513049,0,"<p>You have a couple of problems.</p>

<p>First - your <code>friend</code> declaration and your method definition don't match (you missed out a <code>const</code>). This means that the method definition is not a friend.</p>

<p>Second - the <code>+=</code> operator needs to take its first parameter as a reference, so it can update it. It should also return a reference.</p>

<p>So you should end up with</p>

<pre><code>    ...
    friend double &amp; operator+=(double &amp;, const Bank&amp;);
};

double &amp; operator+=(double &amp;a, const Bank&amp; rhs) {
    a += rhs.balance;
    return a;
}
</code></pre>
",2
33513130,33513049,0,"<p>In your implementation of <code>operator+=</code>, you are changing a local copy of the variable. It doesn't change the variable in the calling function. You need to use:</p>

<pre><code>double&amp; operator+=(double&amp; a, const Bank&amp; rhs) {
   a += rhs.balance;
   return a;
}
</code></pre>

<p>Also, you need to provide a constructor in <code>Bank</code> to be able to construct instances of the class, something like:</p>

<pre><code>Bank(char const* n, double b) : balance(b)
{
   std::strcpy(name, n);
}
</code></pre>
",0
31904215,31902103,0,"<p>The problem is that break only exits the innermost loop.</p>

<p>So when you break you exit the while loop but not the for loop, so you get asked again for the birthday.</p>

<p>Change this</p>

<pre><code>for (int i=0; i&lt;3; i++)
</code></pre>

<p>to this</p>

<pre><code>for (int i=0; i&lt;3 &amp;&amp; !found; i++)
</code></pre>
",3
34220969,34220469,7,"<p>Let's start with the simple stuff: <code>std::cin</code> is an instance of a type derived from <code>std::istream</code>. Similarly, <code>std::cout</code> is an instance of a type derived from <code>std::ostream</code>. These stream types are used to have something you can overload the input and output operators for (and you should <em>not</em> try to derive from them to change their behavior - that's done using <code>std::streambuf</code>). There are other stream types, e.g., <code>std::ifstream</code>/<code>std::ofstream</code> (to read from/write to files) and <code>std::istringstream</code>/<code>std::ostringstream</code> (to read from/write to strings).</p>

<p>The next thing to look at is your output operator: for starters, you need parenthesis when calling a member function. You'll also need a separator between the two values as otherwise the real and the imaginary part may blend into each other. I'd probably implement the operator as</p>

<pre><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, complex const&amp; value) {
    return out &lt;&lt; value.getReal() &lt;&lt; "" "" &lt;&lt; value.getImag();
}
</code></pre>

<p>The use of a space and no other delimiter may be suboptimal in general but makes reading easier. For an actual implementation of a complex class I might use a format writing <em>real</em><code>+</code><em>imag</em><code>i</code> or <code>(</code><em>real</em><code>,</code><em>imag</em><code>)</code> but these are harder to parse.</p>

<p>Reading values from a stream should <em>always</em> be checked after an attempt to read a value was made. For example, the code could look like this:</p>

<pre><code>std::istream&amp; operator&gt;&gt; (std::istream&amp; in, complex&amp; c) {
    double h, j;
    if (in &gt;&gt; h &gt;&gt; j) {
        c.set(h, j);
    }
    return in;
}
</code></pre>

<p>Except for the missing check the input function looks OK assuming the two values are separated by a space: before attempting to read a value, space is skipped by default with the input operators. If the values are formatted more fancy with some separators, these would need to be separately processed. The code to do so could look like the this:</p>

<pre><code>template &lt;char C&gt;
std::istream&amp; skip_char(std::istream&amp; in) {
    if ((in &gt;&gt; std::skipws).peek() != C) {
        in.setstate(std::ios_base::failbit);
    }
    else {
        in.ignore();
    }
    return in;
}
std::istream&amp; (*const open_parenthesis)(std::istream&amp;) = &amp;skip_char&lt;'('&gt;;
std::istream&amp; (*const close_parenthesis)(std::istream&amp;) = &amp;skip_char&lt;')'&gt;;
std::istream&amp; (*const comma)(std::istream&amp;) = &amp;skip_char&lt;','&gt;;

std::istream&amp; operator&lt;&lt; (std::istream&amp; in, complex&amp; c) {
    double real, imag;
    if (in &gt;&gt; open_parenthesis &gt;&gt; real &gt;&gt; comma &gt;&gt; imag &gt;&gt; close_parenthesis) {
        c.set(real, imag);
    }
    return in;
}
</code></pre>

<p>These funny looking entities <code>open_parenthesis</code>, <code>close_parenthesis</code>, and <code>comma</code> are function pointers initialized to point to instance of the function template <code>skip_char</code>. They have a specific signature which qualifies them as being <em>manipulators</em>. When ""reading into"" a manipulator, the corresponding function is called with the stream they are ""read"" from. That is, for example <code>std::cin &gt;&gt; comma</code> results in a call <code>comma(std::cin)</code> which is actually a call to <code>skip_char&lt;','&gt;(std::cin)</code>. However, I guess for this assignment the full-blown approach is a bit of overkill.</p>
",1
34234679,34234591,3,"<p>You are trying to input into read only string literals in</p>

<pre><code>if (in &gt;&gt; h &gt;&gt; ""+"" &gt;&gt; j &gt;&gt; ""i"")
</code></pre>

<p>Which is not going to work.  What you need to do is create a variable to store the text content of the input.  Since the content is not needed we can just toss it out when done.  That will give you something along the lines of</p>

<pre><code>std::istream&amp; operator&gt;&gt; (std::istream&amp; in, complex&amp; c) {
    double h, j;
    char eater;
    if (in &gt;&gt; h &gt;&gt; eater &gt;&gt; j &gt;&gt; eater) { // eater now consumes the + and i
        c.set(h, j);
    }
    return in;
}
</code></pre>

<p>As for the errors in you header files you need to have <code>#include &lt;iostream&gt;</code> in your header file so the compiler knows what <code>istream</code> and <code>ostream</code> are.</p>
",5
34259464,34259436,4,"<p>Whether you need a destructor is <em>NOT</em> determined by whether you use a <code>struct</code> or <code>class</code>. The deciding factor is whether the <code>struct</code>/<code>class</code> has acquired resources that must be released explicitly when the life of the object ends. If the answer to the question is yes, then you need to implement a destructor. Otherwise, you don't need to implement it.</p>

<p>For the first set of <code>struct</code>s, it's best to let the compiler implement the destructors. There is nothing to do in the destructors.</p>

<p>If you implement them, they will be:</p>

<pre><code>~mySubject() {}
</code></pre>

<p>and</p>

<pre><code>~myLogStructure() {}
</code></pre>

<p>You may need to implement destructors in the second set of classes depending on whether you need to release any resources.</p>

<p>Since you have pointers to <code>w_char</code> to store that data, you most likely need to implement destructors, and release the memory acquired during the life time of the object.</p>
",6
34259477,34259436,1,"<p>You don't need to provide your own destructors for <code>mySubject</code> or <code>myLogStructure</code> because the compiler-generated ones will work fine (they will call destructors of <code>std::string</code> members).</p>

<p>You do need to provide destructors for <code>MyLogStructure</code> and <code>MySubject</code> if these classes manage memory which seems to be the case considering members of pointer types.</p>
",0
32937413,32936994,0,"<blockquote>
  <p>which I think I did right.</p>
</blockquote>

<p>No you didn't, it should rather look like</p>

<pre><code>void seedRand(int seed) {
    srand(seed == 0?time(0):seed);
}
</code></pre>

<p>If there's a parameter passed, it's probably meant to be actually used. I've chosen zero as a convention, when <code>seed()</code> should be called with a randomly time based value.</p>

<blockquote>
  <p>So I set the next one to print out numbers to the second decimal place.</p>
</blockquote>

<p>Your second function sets up the output stream state well, but misses to output the value, it should look like</p>

<pre><code>void printMoney(double money) {
    std::cout &lt;&lt; std::setprecision(2) &lt;&lt; std::fixed &lt;&lt; money &lt;&lt; std:: endl;
                                                    // ^^^^^
}
</code></pre>

<p>And at least your last function is probably supposed to be implemented as</p>

<pre><code>void payMoney(double &amp; wallet, double amount) {
    wallet -= amount;
}
</code></pre>

<hr>

<p>All in all it's hard to answer what you're supposed to do with this task.   </p>

<p>But since you tagged this question <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a>, I'd rather recommend to go putting these functions in context of classes like <code>class Casino</code> and <code>class Player</code>.</p>

<pre><code>class Casino;
class Player {
    double wallet;
public:
    void payMoney(Casino&amp; Casino, double amount);
};

class Casino {
public:
    void addToBank(double money) {
        bank += money;
    }
private:
    double bank;
};

void Player::payMoney(Casino&amp; casino, double amount) {
    wallet -= amount;
    casino.addToBank(amount);
}
</code></pre>
",3
28447419,28447289,0,"<p>There is one simple error in your code.</p>

<pre><code>while (val &lt;= 10)
    sum += val;   {
    ++val;
}
</code></pre>

<p>If you look closely you will see that only</p>

<pre><code>sum += val;
</code></pre>

<p>is inside your while loop and val does not change due to which it becomes an infinite loop</p>

<p>You should change your code to</p>

<pre><code>while (val &lt;= 10)
  {
    sum += val;   
    ++val;
  }
</code></pre>

<p>Hope this solves your problem.</p>
",0
28447421,28447289,0,"<p>@trash i have done a slight modification in code and ran it in <a href=""https://ideone.com/RCwp6c"" rel=""nofollow"">https://ideone.com/RCwp6c</a> </p>

<p>the edit is at </p>

<pre><code>while (val &lt;= 10)
        sum += val;{   
        ++val;
    }
</code></pre>

<p>change is at the curve bracket</p>

<pre><code>while (val &lt;= 10){ 
            sum += val;  
            ++val;
        }
</code></pre>

<p>Run your original code now..it is edited</p>
",1
28448140,28447289,1,"<p>Simple Solution:</p>

<p>Just include <code>sum += val;</code> inside the while loop..! </p>

<p>Should be something like below and this will work fine.</p>

<pre><code>while (val &lt;= 10){
    sum += val;
    ++val;
}
</code></pre>
",0
32959021,32959003,2,"<p>You're using <code>if (startingNumber % 2 != 0)</code> which means it will only add up numbers which are <strong>not</strong> divisible by two, resulting in -1 + 1 + 3 = 3. The condition in the if statement is only true if the remainder of dividing <code>startingNumber</code> by two is non-zero, which will be the case for odd numbers.</p>

<p>Use <code>if (startingNumber % 2 == 0) result += startingNumber;</code> instead and you should get the right sum.</p>
",0
32959035,32959003,0,"<p>Change this <code>(startingNumber % 2 != 0)</code> with this:</p>

<pre><code>(startingNumber % 2 == 0)
</code></pre>

<p>Because what you want is to sum the <strong>even</strong> numbers and not <strong>odd</strong> numbers.</p>
",0
28489536,28488974,0,"<p>This'll work. Please cross-check output for different inputs for coz haven't had the time to do so.</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int main (){
    int units;
    double priceA,priceB,priceC;
    char package, goAgain;

    do {
        cout &lt;&lt; ""Enter the Package chosen. Enter 'A' or 'a' for package A.\n"";
        cout &lt;&lt; ""Enter 'b' or 'B' for package B.\n"";
        cout &lt;&lt; ""Enter 'c' or 'C' for package C.\n"";
        cin &gt;&gt; package;
        cout &lt;&lt; ""Enter the number of message units"";
        cin &gt;&gt; units;

        priceA=15.95;
        priceB=25.95;
        priceC=45.95;

        if (units&gt;20){
            priceB += (units-20)*.10;
            priceA += (units-10)*.20;
        }
        else if (units&gt;10){
            priceA += (units-10)*.20;
        }

        switch(package)
        {
            case 'a':
            case 'A':   cout &lt;&lt;""\nThe cost of package A is"" &lt;&lt; "" $"" &lt;&lt;priceA &lt;&lt; endl;
                        if(priceA&gt;priceB)
                        {
                            cout &lt;&lt; ""\nBy switching to package B you would save"" &lt;&lt; "" $"" &lt;&lt; priceA-priceB&lt;&lt;endl;
                        }
                        if(priceA&gt;priceC)
                        {
                            cout &lt;&lt; ""\nBy switching to package C you would save"" &lt;&lt; "" $"" &lt;&lt; priceA-priceC&lt;&lt;endl;
                        }
                        break;
            case 'b':  
            case 'B':   cout &lt;&lt;""\nThe cost of package B is"" &lt;&lt; "" $"" &lt;&lt;priceB &lt;&lt; endl;
                        if(priceB&gt;priceA)
                        {
                            cout &lt;&lt; ""\nBy switching to package A you would save"" &lt;&lt; "" $"" &lt;&lt; priceB-priceA&lt;&lt;endl;
                        }
                        if(priceB&gt;priceC)
                        {
                            cout &lt;&lt; ""\nBy switching to package C you would save"" &lt;&lt; "" $"" &lt;&lt; priceB-priceC&lt;&lt;endl;
                        }
                        break;
            case 'c':
            case 'C':   cout &lt;&lt;""The cost of package C is"" &lt;&lt; "" $"" &lt;&lt;priceC &lt;&lt; endl;
                        if(priceC&gt;priceB)
                        {
                            cout &lt;&lt; ""\nBy switching to package B you would save"" &lt;&lt; "" $"" &lt;&lt; priceC-priceB&lt;&lt;endl;
                        }
                        if(priceC&gt;priceA)
                        {
                            cout &lt;&lt; ""\nBy switching to package A you would save"" &lt;&lt; "" $"" &lt;&lt; priceC-priceA&lt;&lt;endl;
                        }
                        break;
            default: cout &lt;&lt; ""\nIncorrect Input!!"";
        }

        cout&lt;&lt;""do you want to go again? y/n"" &lt;&lt; endl;
        cin &gt;&gt;goAgain;
    }
    while(goAgain=='y');
}
</code></pre>
",0
34242107,34242018,6,"<p>A unique pointer represents at most <em>one</em> owner of its pointee. Therefore, a unique pointer cannot be copied. It can however be <em>moved</em>, which transfers the (potential) ownership to the target of the move and leaves the source of the move null (i.e. not owning anything).</p>

<p>Given classes <code>Xp</code>, <code>Xl</code> and <code>Xx</code>, each with a member <code>std::unique_ptr&lt;T&gt; p_;</code>, the following constructors all work:</p>

<pre><code>Xp(std::unique_ptr&lt;T&gt; p) : p_(std::move(p)) {}
Xp(std::unique_ptr&lt;T&gt; p) { p_ = std::move(p); }

Xl(std::unique_ptr&lt;T&gt; &amp; p) : p_(std::move(p)) {}
Xl(std::unique_ptr&lt;T&gt; &amp; p) { p_ = std::move(p); }

Xx(std::unique_ptr&lt;T&gt; &amp;&amp; p) : p_(std::move(p)) {}
Xx(std::unique_ptr&lt;T&gt; &amp;&amp; p) { p_ = std::move(p); }
</code></pre>

<p>Only <code>Xp</code> and <code>Xx</code> have sensible constructors, though. They can be used as follows:</p>

<pre><code>{
    Xp xp(std::make_unique&lt;T&gt;(a, b ,c));
    Xx xx(std::make_unique&lt;T&gt;(a, b ,c));
}
{
    auto p = std::make_unique&lt;T&gt;(a, b ,c);
    // Xp xp(p);  // Error, cannot duplicate p!
    Xp xp(std::move(p));
}
{
    auto p = std::make_unique&lt;T&gt;(a, b ,c);
    // Xx xx(p);  // Error, cannot duplicate p!
    Xx xx(std::move(p));
}
</code></pre>

<p>On the other hand, the constructor of <code>Xl</code> is weird and surprising:</p>

<pre><code>// Xl xl(std::make_unique&lt;T&gt;(a, b ,c));  // Error, cannot bind to temporary
auto p = std::make_unique&lt;T&gt;(a, b ,c);
Xl xp(p);              // OK?!?
assert(p == nullptr);  // grand theft autoptr!
</code></pre>
",0
32929877,32929856,0,"<p>You can use nested <code>if</code> statements.</p>

<pre><code>triangle = false;
if (x + y &gt; z) {
    if (x + z &gt; y) {
        if (z + y &gt; x) {
            triangle = true;
        }
    }
}
if (triangle) {
    printf(""\nTriangle can be performed"");
} else {
    printf(""\n Triangle cannot be performed"");
}
</code></pre>
",0
30411994,30411764,0,"<p>Found it!
2 ways for it:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct node
{
int i;
node *nxt;
};

int main()
{

node head, temp;

head.i=10;
temp.i=20;

head.nxt=&amp;temp;
temp.nxt=NULL;

cout&lt;&lt;head.i&lt;&lt; "" - "" &lt;&lt;head.nxt&lt;&lt; endl;
cout&lt;&lt;temp.i&lt;&lt; "" - "" &lt;&lt;temp.nxt&lt;&lt; endl;

return 0;
}
</code></pre>

<p><strong>OR</strong></p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct node
{
int i;
node *nxt;
};

int main()
{

node *head=NULL;
head = new node;

node *temp=NULL;
temp = new node;

head-&gt;i=10;
temp-&gt;i=20;

head-&gt;nxt=temp;
temp-&gt;nxt=NULL;

cout&lt;&lt;head-&gt;i&lt;&lt; "" - "" &lt;&lt;head-&gt;nxt&lt;&lt; endl;
cout&lt;&lt;temp-&gt;i&lt;&lt; "" - "" &lt;&lt;temp-&gt;nxt&lt;&lt; endl;

return 0;
}
</code></pre>

<p>The difference is the first one use stack for memory and the second one use heap!</p>

<p>Thanks again :)</p>
",2
30411905,30411764,0,"<p>Write main the following way</p>

<pre><code>node node1, node2;

node *head = &amp;node1, *temp = &amp;node2;

head-&gt;i = 10;
temp-&gt;i = 20;

head-&gt;nxt = temp;
temp-&gt;nxt = NULL;

cout &lt;&lt; head-&gt;i &lt;&lt; ""-"" &lt;&lt; head-&gt;nxt &lt;&lt; endl;
cout &lt;&lt; temp-&gt;i &lt;&lt; ""-"" &lt;&lt; temp-&gt;nxt &lt;&lt; endl;
</code></pre>

<p>The other approach is to allocate memory dynamically. For example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

struct node
{
    int i;
    node *nxt;
};

int main() 
{
    std::unique_ptr&lt;node&gt; head( new node );
    std::unique_ptr&lt;node&gt; temp( new node );

    head-&gt;i = 10;
    temp-&gt;i = 20;

    head-&gt;nxt = temp.get();
    temp-&gt;nxt = nullptr;

    std::cout &lt;&lt; head-&gt;i &lt;&lt; ""-"" &lt;&lt; head-&gt;nxt &lt;&lt; std::endl;
    std::cout &lt;&lt; temp-&gt;i &lt;&lt; ""-"" &lt;&lt; temp-&gt;nxt &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>The program output might look like</p>

<pre><code>10-0x8745018
20-0
</code></pre>
",0
30411930,30411764,0,"<p>You are trying to dereference NULL pointers. You could use <code>new</code> like so, to allocate memory for the pointers to point to.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct node
{
  int i;
  node *nxt;
};

int main()
{
  node *head = new node, *temp = new node;

  head-&gt;i = 10;
  temp-&gt;i = 20;

  head-&gt;nxt = temp;
  temp-&gt;nxt = NULL;

  cout &lt;&lt; head-&gt;i &lt;&lt; ""-"" &lt;&lt; head-&gt;nxt &lt;&lt; endl;
  cout &lt;&lt; temp-&gt;i &lt;&lt; ""-"" &lt;&lt; temp-&gt;nxt &lt;&lt; endl;

  delete head;
  delete temp;
}
</code></pre>
",0
33581795,33581783,1,"<p>It's an oktal number literal, that's the reason.</p>

<p>Cite from the <a href=""http://en.cppreference.com/w/cpp/language/integer_literal"" rel=""nofollow"">reference</a>:</p>

<blockquote>
  <p><em>octal-literal</em> is the digit zero (0) followed by zero or more octal digits (0, 1, 2, 3, 4, 5, 6, 7)</p>
</blockquote>
",0
34214868,34214509,1,"<p>I am going to go a bit further than David Fang's answer to demonstrate some basic error checking and storage of the players once read.</p>

<p>Note: Starter code lifted from the semi-official answer for this sort of question, <a href=""https://stackoverflow.com/questions/7868936/read-file-line-by-line"">Read file line by line</a>.</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
</code></pre>

<p>Need a few includes for this function</p>

<pre><code>std::vector&lt;Player&gt; loadGame()
</code></pre>

<p>Define a function that loads all player data from the file into a <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer""><code>std::vector</code></a>. Why a vector? If the game has multiple players, we've got to put them somewhere, and vector is a damn easy somewhere.</p>

<pre><code>{
    std::vector&lt;Player&gt; players; 
    std::string line;
    while (std::getline(infile, line))  
</code></pre>

<p>Read in a line, exit if no line. <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow noreferrer""><code>getline</code> documentation.</a></p>

<pre><code>    {
        std::string playerName;
        int funds, supplies, turn;
        std::istringstream iss(line); 
</code></pre>

<p>Load the line into <a href=""http://en.cppreference.com/w/cpp/io/basic_istringstream"" rel=""nofollow noreferrer"">an easily parsed stream</a>. Use is exactly the same as with cin or infile </p>

<pre><code>        if (iss &gt;&gt; playerName &gt;&gt; funds &gt;&gt; supplies &gt;&gt; turn) 
</code></pre>

<p>Read in all expected input on line. If there are any errors, skip to else case to clean up. Note: Doesn't handle unexpected input on line. We read in all input here rather than later because there is no point building a <code>Player</code> if the input is bad. </p>

<p>If any of the variables cannot be read and converted to the correct type, the stream will be set into an error state. The if will check this state just as if you'd called <code>good()</code>. If the input is good, we can set up the <code>Player</code> all in one call to the constructor rather than having a bunch of calls to the setter. This way anyone using a <code>Player</code> knows it is all set up and ready to go and merely allocated. With complex objects and multi-threaded systems this is important.</p>

<p>Also the <code>Player</code>'s name is not going to change part-way through the game, so a setter function for name is dodgy.</p>

<pre><code>        {  
            Player player(playerName, funds, supplies, turn);
            players.push_back(player);
</code></pre>

<p>Make a <code>Player</code> and put player in vector, or</p>

<pre><code>            players.emplace_back(playerName, funds, supplies, turn);
</code></pre>

<p>Make a <code>Player</code> directly in the vector.</p>

<pre><code>        }
        else
        { 
</code></pre>

<p>One or more errors occurred reading the line. Do whatever you need to  do to handle the error</p>

<pre><code>        }
    }
    return players;
}
</code></pre>

<p>Return the loaded game to the caller. This may look a little odd. We're passing a list that could be huge to the caller by value. This could mean a very large and expensive copy operation. </p>

<p>Fortunately compilers are not dumb. They know we'll never be using  <code>players</code> in this function again and that it is a local variable and thus will be destroyed as soon as the function goes out of scope. The compiler can do anything it wants to the vector, because this vector is effectively dead. For example, it can rip the vector's guts out and transplant them into another vector in the caller's scope without copying anything and leave the vector for the digital crows to gobble up. </p>

<p>Usage of the function is:</p>

<pre><code>std::vector&lt;Player&gt; players = loadGame();
</code></pre>

<p>All together without the running commentary: </p>

<pre><code>#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::vector&lt;Player&gt; loadGame()
{
    std::vector&lt;Player&gt; players; 
    std::string line;
    while (std::getline(infile, line))  
    {
        string playerName;
        int funds, supplies, turn;
        std::istringstream iss(line); 

        if (iss &gt;&gt; playerName &gt;&gt; funds &gt;&gt; supplies &gt;&gt; turn) 
        {  
            // Player player(playerName, funds, supplies, turn);
            // players.push_back(player);
            players.emplace_back(playerName, funds, supplies, turn);
        }
        else
        { 
            // handle error
        }
    }
    return players;
}
</code></pre>
",0
34214585,34214509,3,"<p>You can try <code>std::getline</code> and <code>std::stringstream</code>.</p>

<p>First include sstream.</p>

<pre><code>#include &lt;sstream&gt;
</code></pre>

<p>Then you can read data line by line and split into strings.</p>

<pre><code>string line;
while(getline(data, line)) {
    stringstream ss(line);
    string name;
    int funds, supplies, turns;
    ss &gt;&gt; name &gt;&gt; supplies &gt;&gt; turns;
}
</code></pre>
",0
32425039,32424784,1,"<p>You need to dynamically resolve NtCreateKey by using LoadLibrary to get a handle to ntdll, and the use GetProcAddress to resolve the function.</p>

<p>Conversely, you could use the supported Win32 API function RegCreateKey/RegCreateKeyEx. Unless you have a real reason to use the native API, you should probably stick to the Win32 API.</p>
",0
32971745,32961644,0,"<p>When you use (=) in a if, you don't COMPARE the values, you actually give him the value, so the first ""if"" will always be true. If they were all ""if"" and not ""else if"" they would all be true(use ""=="" instead)! Also, for your variables, if you don't specify them to be public, they will be private by default. </p>
",0
31903145,31903089,0,"<p>They will often be compressed into .cab or other kinds of archival formats to decrease required space and provide tamper protection.</p>
",0
28531713,28531696,1,"<p>You incorrectly spelt the function name, isNoteEven instead of isNotEven.</p>
",1
33005724,33004904,0,"<p>Well I am not sure what your problem really is. Your function ""isLychrel"" currently returns false if the input is known not to a Lychrel number within the input max number of iterations, and true otherwise. Do you want your function to also return the actual number of iterations that executed? If so you could provide a reference to an integer variable in the signature to receive the actual number of iterations. </p>

<p>That is, your function could look like this </p>

<pre><code> bool isLychrel(int num, int&amp; ornNumIters, const int iterCount = 50)
 {
    int temp = num;
    int rev;
    for (int i = 0; i &lt; iterCount; i++)
    {

         rev = Reverse(temp);
         if (is_Palindrome(rev + temp))
         {
             ornNumIters = i; 
             return false;
         }
         temp = temp + rev;
    }
    ornNumIters = iterCount; 
    return true;
}
</code></pre>

<p>and you would call it like : </p>

<pre><code> int nActualIterations = 0; 
 bool bResult = isLychrel(89,nActualIterations); 
</code></pre>
",0
33004974,33004904,0,"<p>If you want to reuse ""i"" outside of the loop then you need to take the initialiser out of the for loop.</p>

<p><strong>Change this</strong></p>

<pre><code>for (int i = 0; i &lt; iterCount; i++)
</code></pre>

<p><strong>To this</strong></p>

<pre><code>for ( i &lt; iterCount; i++)
</code></pre>

<p>Otherwise I would suggest using a while loop.</p>

<p><strong>Edit:</strong> For more information on variable scope I would recommend <a href=""http://www.learncpp.com/cpp-tutorial/4-1a-local-variables-and-local-scope/"" rel=""nofollow"">this</a> tutorial.</p>
",0
32487411,32486171,2,"<p>And because Comments are often unread by answer seekers...</p>

<pre><code>while( getline(inFile, line) ) 
</code></pre>

<p>Reads through the entire file. When it's done <code>inFile</code>'s read location is set to the end of the file so the word counting loop</p>

<pre><code>while (inFile &gt;&gt; words)
</code></pre>

<p>starts reading at the end of the file and finds nothing. The smallest change to the code to make it perform correctly is to use <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/seekg"" rel=""nofollow"">seekg</a> rewind the file before counting the words.</p>

<pre><code>inFile.seekg (0, inFile.beg);
while (inFile &gt;&gt; words)
</code></pre>

<p>Positions the reading location to file offset 0 relative to the beginning of the file (specified by <code>inFile.beg</code>) and then reads through the file to count the words.</p>

<p>While this works, it requires two complete reads through the file, which can be quite slow. A better option suggested by crashmstr in the comments and  implemented by simplicis veritatis as another answer requires one read of the file to get and count lines, and then an iteration through each line in RAM to count the number of words. </p>

<p>This has the same number of total iterations, everything must be counted one by one, but reading from a buffer in memory is preferable to reading from disk due to significantly faster, orders of magnitude, access and response times.</p>
",1
32486683,32486171,1,"<p>Here is one possible implementation (not tested) to use as a benchmark:</p>

<pre><code>int main(){

// print prompt message and read input
cout &lt;&lt; ""Please enter the file name "" &lt;&lt; endl;
string fileName;
getline(cin,fileName);

// create an input stream and attach it to the file to read
ifstream inFile;
inFile.open(fileName.c_str());

// define counters
string line;
string chars;
int number_of_lines = 0;
int number_of_chars = 0;
vector&lt;string&gt; all_words;

do{
    getline(inFile, line);
    // count lines
    number_of_lines++;
    // count words
    // separates the line into individual words, uses white space as separator
    stringstream ss(line);
    string word;
    while(ss &gt;&gt; word){
        all_words.push_back(word);
    }
}while(!inFile.eof())
// count chars
// length of each word
for (int i = 0; i &lt; all_words.size(); ++i){
    number_of_chars += all_words[i].length(); 
}

// print result
cout &lt;&lt; ""Words: "" &lt;&lt; all_words.size() &lt;&lt;"""" &lt;&lt; endl;
cout &lt;&lt; ""Chars: "" &lt;&lt; number_of_chars &lt;&lt;"""" &lt;&lt; endl;
cout &lt;&lt; ""Lines: "" &lt;&lt; number_of_lines &lt;&lt;"""" &lt;&lt; endl;

return 0;
}
</code></pre>
",0
28532888,28532856,1,"<p>Make the function take its argument by reference:</p>

<pre><code>void func1(Class3* &amp; class3Pointer)
// ----------------^
</code></pre>

<p>Then changes to <code>class3Pointer</code> in the function will also change the argument that was passed (in fact both of those two things will denote the same variable).</p>
",3
33023887,33023635,3,"<p>If <code>Der3</code> naturally has no <code>f1()</code> then it fails to be the same sort of thing as <code>Der1</code> and <code>Der2</code>. You'd be better to have <code>Base1</code> which has no <code>f1()</code> and derive <code>Der3</code> directly from that, then have a <code>Base2</code> which implements <code>f1()</code> derived from <code>Base1</code> and derive <code>Der1</code> and <code>Der2</code> from that. Thus:</p>

<pre><code>class Base1
{
};


class Der3 : public Base1
{
};


class Base2 : public Base1
{
    public:
    f1();
};


class Der1 : Base2
{
};

class Der2 : Base2
{
};
</code></pre>
",0
33023892,33023635,2,"<p>If you want your function to do nothing, and if it makes semantic sense that <code>Der3</code> overrides the common implementation that instead does nothing, yes, you can make your function do nothing.</p>

<p>This is fine.</p>
",0
28533009,28532890,2,"<p><strong>Point 1</strong></p>

<p>When making <code>function prototypes</code>, you need to keep them consistent with the actual definition of the <code>function</code>.</p>

<p>You have:</p>

<pre><code>void showMedian();
</code></pre>

<p>As a <code>function-prototype</code> but you have:</p>

<pre><code>double showMedian(int *vecmedian, int size)
</code></pre>

<p>As the actual definition. <strong>They both need to be consistent</strong>.</p>

<p>Since you have not declared an array, maybe change the parameters of <code>showMedian</code> to:</p>

<pre><code>double showMedian(const vector&lt;int&gt; &amp; vecmedian, int size)
</code></pre>

<p><strong>Point 2</strong></p>

<pre><code>if(nums[i] &lt; *itr)
</code></pre>

<p>Where is <code>nums</code> declared?</p>

<p><strong>Point 3</strong></p>

<p>If you want to use the definition of <code>showMedian</code>, then use the parameters that it uses assuming you made the changes above (and assuming <code>n</code> is size).</p>

<pre><code>showMedian(vecmedian, n);
</code></pre>

<p><strong>Edit</strong></p>

<p>With all the consulting in the comment section and the new updated OP Question, here is a fairly solid program which finds the <code>median</code> in a <code>vector</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

double showMedian(const vector&lt;double&gt; &amp; vecmedian, int num);

int main()
{
    unsigned int n;
    double input;
    vector&lt;double&gt; vecmedian;

    // cout &lt;&lt; ""Enter the amount of numbers: "";

    do {
        cout &lt;&lt; ""Enter the amount of numbers: "";

        while(!(cin &gt;&gt; n)){
            cout &lt;&lt; ""Wrong input"" &lt;&lt; endl;
            cout &lt;&lt; ""Enter the amount of numbers: "";
            cin.clear();
            cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
        }

        if (n == 0)
        {
            cout &lt;&lt; ""Invalid, size must be greater than 0"" &lt;&lt; endl;
        }

    } while (n == 0);

    // cout &lt;&lt; ""Enter your numbers to be evaluated: "" &lt;&lt; endl;

    for (int i  = 1; i &lt;= n; ++i)
    {
        cout &lt;&lt; ""Enter number here ("" &lt;&lt; ((n + 1) - i) &lt;&lt; "" number/s remaining): "";
        while(!(cin &gt;&gt; input)){
            cout &lt;&lt; ""Wrong input"" &lt;&lt; endl;
            cout &lt;&lt; ""Enter number here ("" &lt;&lt; ((n + 1) - i) &lt;&lt; "" number/s remaining): "";
            cin.clear();
            cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
        }

        vecmedian.push_back(input);
    }

    //        while (vecmedian.size() &lt; n &amp;&amp; cin &gt;&gt; input){
    //            vecmedian.push_back(input);
    //        }

    sort(vecmedian.begin(), vecmedian.end());

    showMedian(vecmedian, vecmedian.size());
    return 0;

}

double showMedian(const vector&lt;double&gt; &amp; vecmedian, int num)
{
    int middle;
    double median;

    middle = (num / 2);
    if (num % 2)
        median = vecmedian[middle];
    else
        median = (vecmedian[middle - 1] + vecmedian[middle]) / 2.0;
    cout &lt;&lt; ""The median is: "" &lt;&lt; median &lt;&lt; endl;
    return median;
}
</code></pre>
",12
32408222,32408157,3,"<p>You never allocated any space for <code>words</code> and <code>wordCount</code> to point to. It should be:</p>

<pre><code>#define MAXWORDS 1000
string *words = new string[MAXWORDS];
int *wordCount = new int[MAXWORDS];
</code></pre>

<p>and then at the end of the program you should do:</p>

<pre><code>delete[] wordCount;
delete[] words;
</code></pre>

<p>or you can allocate a local array:</p>

<pre><code>string words[MAXWORDS];
int wordCount[MAXWORDS];
</code></pre>

<p>But you could do it more simply by using <code>std::map</code> to map the string to a count. This will automatically grow as needed.</p>
",3
32418984,32418852,5,"<p>I have corrected (using that word loosely here) the code that you've shared. Like others mentioned in the comments, your variable names are misspelled and were not initialized with a value. </p>

<p>Another mistake was that you were dividing 5 by 9 using integer division <code>(farenheight + 459.67)*(5 / 9);</code>. This causes type coercion, since both operands are of type int the result is coerced to an int, dropping any numbers after the decimal place. In this case 5 / 9 results in 0, so your entire result is multiplied by 0. </p>

<p>Another issue that would cause the results to be incorrect is that you are outputting the variables to the stream before you are declaring what the variables should contain. If you do this, whatever was stored in memory, the null string, will be output to the screen. </p>

<hr>

<p>Here is the corrected code:</p>

<pre><code>//  This program converts from Farenheight to Celsius or Kelvin

#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    string input, Celsius, Kelvin;
    double farenheight = 0.0, celsius = 0.0, kelvin = 0.0;

    cout &lt;&lt; ""Hi! What is the weather today in Farenheight?? "" &lt;&lt; endl;
    cin &gt;&gt; farenheight;
    cout &lt;&lt; ""Would you like to convert this temperature to Celsius or Kelvin?"" &lt;&lt; endl;
    cin &gt;&gt; input;
    if (input == ""Celsius"")
    {
        celsius = (5.0 * (farenheight - 32.0)) / 9.0;
        cout &lt;&lt; ""Today's weather in Celsius is "" &lt;&lt; celsius &lt;&lt; "" degrees Celsius! "" &lt;&lt; endl;
    }
    else if (input == ""Kelvin"")
    {
        kelvin = (farenheight + 459.67)*(5.0 / 9.0);
        cout &lt;&lt; ""Today's weather in Kelvin is "" &lt;&lt; kelvin &lt;&lt; "" degrees Kelvin! "" &lt;&lt; endl;
    }
}
</code></pre>

<hr>

<p>Two examples of output are here:</p>

<p><code>Hi! What is the weather today in Farenheight??
100.0
Would you like to convert this temperature to Celsius or Kelvin?
Celsius
Today's weather in Celsius is 37.7778 degrees Celsius!
</code></p>

<hr>

<p><code>Hi! What is the weather today in Farenheight??
100.0
Would you like to convert this temperature to Celsius or Kelvin?
Kelvin
Today's weather in Kelvin is 310.928 degrees Kelvin!
Press any key to continue . . .
</code></p>
",0
32418927,32418852,4,"<p>You declare variables called <code>Celsius</code> and <code>Kelvin</code>; however, their default value is set to <code>""""</code> (empty string). You forgot to initialize them.</p>

<p>If you want to make your program work, you need to initialize these variables to their expected values (which are probably <code>""Celsius""</code> and <code>""Kelvin""</code>) like this:</p>

<pre><code>string Celsius = ""Celsius"", Kelvin = ""Kelvin"";
</code></pre>

<p>However, even better solution here would be not to make any variables at all for these 2 options and compare it in the condition directly with the string literal. Like this:</p>

<pre><code>if(input == ""Celsius"")
{
...
}
else if(input == ""Kelvin"")
{
...
}
</code></pre>

<p>Also another thing I have noticed. You are calculating values for <code>celsius</code> and <code>kelvin</code> after you have printed them. You should do it before.</p>
",0
33579134,33578856,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

int main() {
    int size;                              //array size
    int* array;                            //array of ints
    std::vector&lt;int&gt; vecInput;
    int arraycount;                        //counter for array loop
    void findMode(std::vector&lt;int&gt; vec);  //function prototype

    //intialize array
    cout &lt;&lt; ""Enter number of integers "";
    cout &lt;&lt; ""you wish to input."" &lt;&lt; endl;
    cin &gt;&gt; size;

    cout &lt;&lt; ""Enter the integers."" &lt;&lt; endl;

    array = new int[size];

    for (arraycount = 0; arraycount &lt; size; arraycount++) 
    {
            int num;
            cin &gt;&gt; num;
            vecInput.push_back(num);
    }


    //call function
    findMode(vecInput);

    return 0;
}

void findMode(std::vector&lt;int&gt; vec) 
{
    std::sort(vec.begin(), vec.end());
    std::map&lt;int, int&gt; modMap;
    std::vector&lt;int&gt;::iterator iter = vec.begin();
    std::vector&lt;int&gt; results;
    int prev = *iter;
    int maxCount = 1;
    modMap.insert(std::pair &lt;int,int&gt;(*iter, 1));

    iter++;
    for (; iter!= vec.end(); iter++)
    {
        if (prev == *iter)
        {
            std::map&lt;int, int&gt;::iterator mapiter = modMap.find(*iter);
            if ( mapiter == modMap.end())
            {
                modMap.insert(std::pair &lt;int,int&gt;(*iter, 1));
            }
            else
            {
                mapiter-&gt;second++;
                if (mapiter-&gt;second &gt; maxCount)
                {
                    maxCount = mapiter-&gt;second;
                }
            }
        }
        else
        {
            modMap.insert(std::pair &lt;int,int&gt;(*iter, 1));
        }

        prev = *iter;
    }

    std::map&lt;int, int&gt;::iterator mapIter = modMap.begin();
    for (; mapIter != modMap.end(); mapIter++)
    {
        if (mapIter-&gt;second == maxCount)
        {
            results.push_back(mapIter-&gt;first);
        }
    }

    cout &lt;&lt; ""mod values are "" &lt;&lt;endl;

    std::vector&lt;int&gt;::iterator vecIter = results.begin();
    for (; vecIter != results.end(); vecIter++)
        cout&lt;&lt;*vecIter&lt;&lt;endl;


}
</code></pre>
",3
33587772,33578856,0,"<p>Thank you all for the help, I was able to get the code to work.  Turns out the problem was the cin in my vector portion of the function.  Here is my revised code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
using namespace std;

#define N 100

void findMode(int x[], int size);       //function prototype
vector&lt;int&gt; results;    //vector

int main(void) {
   int* x;
   int size=0;
   int arraycount;

//intialize array
   cout &lt;&lt; ""Enter number of integers "";
   cout &lt;&lt; ""you wish to input.""  &lt;&lt; endl;
   cin &gt;&gt; size;
   cout &lt;&lt; ""Enter the integers."" &lt;&lt; endl;
   x = new int[size];

   for (arraycount = 0; arraycount &lt; size;
   arraycount++)
      cin &gt;&gt; x[arraycount];

//send array and size to function
   findMode(x, size);

   return 0;
}

//findMode function    
void findMode(int x[], int size) {
   int y[N]={0};
   int i, j, k, m, cnt, count, max=0;
   int mode_cnt=0;
   int num;
   int v;
   vector&lt;int&gt; results;
   vector&lt;int&gt;::iterator pos;

//loop to count an array from left to right
   for(k=0; k&lt;size; k++) {
      cnt=0;
      num=x[k]; //num will equal the value of x[k]

      for(i=k; i&lt;size; i++) {   
         if(num==x[i])
            cnt++;              
      }
      y[k]=cnt; //
   }

//find highest number in array
   for(j=0; j&lt;size; j++) {
      if(y[j]&gt;max)
         max=y[j];
   }

//find how many modes there are
   for(m=0; m&lt;size; m++) {
      if(max==y[m])
         mode_cnt++;
   }

//push results to vector
   for (m=0; m &lt; size; m++) {
      if(max == y[m]) {
//after taking out this line the code works properly
//      std::cin &gt;&gt; x[m];      
       results.push_back(x[m]);
      }
   }

//sort vector and print
   std::sort(results.begin(), results.end());
   cout &lt;&lt; ""The mode(s) is/are: "";
   for (pos=results.begin(); pos!=results.end(); ++pos) {
         cout &lt;&lt; *pos &lt;&lt; "" "";
   }
}
</code></pre>
",0
32471782,32471524,1,"<p>You could achieve that functionality by creating pure virtual class <code>CommandHandler</code> for example and every command should be derived from it. And with it you should create <code>CommandEngine</code> for registering all your handlers in it and finnaly feed arguments of command line to it. </p>

<p>Here is example:</p>

<pre><code>class CommandHandler
{
    virtual string&amp; const GetCommandName() const = 0;
    virtual void run(const std::vector&lt;string&gt;&amp; argumentList /* or char*[] */) const = 0;
}

/*
This class should parse command line to find and execute appropriate command handler. Of course we should register handlers here before parsing.
*/

class CommandEngine
{
    CommandEngine();
    //Should add handler into array/vector or even better map.
    void registerHandler(CommandHandler handler);
    /* This function should pick first word as command name, find appropriate handler and execute it with remaining arguments*/

    void run(std::vector&amp; const arguments /* or char*[] */);
}

class AddHandler : public CommandHandler
{
   //Implement CommandHandler interface
   ...
}

void main(...argc, argv...)
{
    CommandEngine engine;
    engine.register(AddHandler);
    ....
    engine.run(argv);
}
</code></pre>
",0
34257232,34257211,1,"<p>The class member ""y"" appears to be uninitialized. Unless there's additional code that you did not show, this is undefined behavior. The first time you enter the loop that searches for the highest or the lowest value, you will end up comparing an uninitialized class member, whose value will be random binary garbage.</p>
",2
34259550,34257211,0,"<p>Using a pointer to an uninitialized variable is considered bad practice. In the instructor you're setting the value of the two pointers to the address of y and z but they're not initialized so they both contain garbage. The simplest way to solve the problem is to have two floats that contain the highest and lowest value later but initialize them with -1 first. To determine the highest value set the highest float variable to the value of the first grade then compare it to each grade then replace it if it's greater. you can add an if statement to test if the function returns -1 then there's an error.</p>
",0
34237266,34237233,0,"<p>If its within range, it says you have gone all in, return 100, and exit</p>

<p>change if (Player_Bet = b) by if (Player_Bet == b) because = sets b to Player_Bet and == is to compare values.</p>

<p>If you don't want it to exit before having a in range value, move return Player_Bet; out of the while loop</p>
",0
34237271,34237233,0,"<p>First check if <code>Player_bet</code> greter than <code>0</code> and less than <code>b</code>. Check if equal <code>b</code> after. </p>

<pre><code>int Player_Money = 100;
int Computer_Money = 100;

int Check(int &amp;b) { //b here would be Player_Money
    int Player_Bet = 0;
    bool Exit_Loop = false;

    cout &lt;&lt; ""Please Enter A Number Between 0 and "" &lt;&lt; b;

    while (!Exit_Loop) {
        cin &gt;&gt; Player_Bet;
        if (Player_Bet &lt;= 0) {
            cout &lt;&lt; ""The Amount That You Have Entered Is To Low.\n"";
        }
        else if (Player_Bet &gt; b) {
            cout &lt;&lt; ""The Amount That You Have Entered Is Too High.\n"";
        }
        else if (Player_Bet &gt; 0 &amp;&amp; Player_Bet &lt; b ) {
            Exit_Loop = true;
        }
        else /* if (Player_Bet == b) */ {
            cout &lt;&lt; ""You Have Gone All In!\n"";
            Exit_Loop = true;
        }       
    }
    return Player_Bet;
}
</code></pre>
",1
34237273,34237233,0,"<p>One of the main problems I see in the code segment you posted is that you have your <code>return</code> statement <em>within</em> your <code>while loop</code>. So no matter the value of <code>Player_Bet</code> if will always return and end the method at the end of the first iteration....in other words, if will never <em>actually</em> loop.</p>
",0
34237298,34237233,0,"<p>There are several issues in your code:</p>

<ol>
<li>You are using = to compare, you should use ==</li>
<li>You are making redundant compare.</li>
<li>Your exit loop has no meaning since you will always return.</li>
</ol>

<p>This will suits you better. However be aware that doing while(true) is generally not a good idea.</p>

<pre><code>while (true) {
   cin &gt;&gt; Player_Bet;
   if (Player_Bet &lt;= 0) {
       cout &lt;&lt; ""The Amount That You Have Entered Is To Low.\n"";
   } else if (Player_Bet &gt; b) {
       cout &lt;&lt; ""The Amount That You Have Entered Is Too High.\n"";
   } else {
       if (Player_Bet == b) {
           cout &lt;&lt; ""You Have Gone All In!\n"";
       }
       return Player_Bet;
   }
}
</code></pre>
",0
32486370,32486346,6,"<p>The scope of variables declared in for loops is limited to the for loop.  In order to use <code>op</code> outside the for loop you need to change it to</p>

<pre><code>char op;
for (; cin &gt;&gt; op;)
</code></pre>

<p>But while we are changing things lets just make this a while loop</p>

<pre><code>char op;
while (cin &gt;&gt; op)
</code></pre>

<p>Some compilers allowed using variables declared in a for loop outside the for loop but that is not standard and it should not be relied on.  An easy way to tell if you have a non conforming compiler is to run</p>

<pre><code>int main()
{
    for(int i = 0; i &lt; 0; i++) {}
    i++;
}
</code></pre>

<p>The <code>i++</code> should cause an error(<a href=""http://coliru.stacked-crooked.com/a/cbaf94b3d793f7fb"" rel=""nofollow"">example</a>).</p>
",0
32447171,32447086,2,"<pre><code>for (count = 0; count &lt; SIZE; count++)
{
    cout &lt;&lt; ""\nEnter an integer value: "";
    cin  &gt;&gt; values[count];
}
</code></pre>

<p>loops <code>SIZE</code> (10) amount of times and gets user's input. Puts the input of each time into an array (<code>values</code>).</p>

<pre><code>largest = smallest = values[0];
</code></pre>

<p>means that <code>smallest</code> and <code>largest</code> start using the first item in the array.</p>

<pre><code>for (count = 1; count &lt; SIZE; count++)
{
    if (values[count] &gt; largest)
        largest = values[count];
    if (values[count] &lt; smallest)
        smallest = values[count];
}
</code></pre>

<p>is where we loop through the array <code>values</code> (that we got from user) and check to see if <code>largest</code> is not larger than the current item. If it's not, we set <code>largest</code> to the larger value.</p>

<p>We do the same for <code>smallest</code> and check to see if <code>smallest</code> is not smaller than the current item. If it's not, we set <code>smallest</code> to the smaller value.</p>
",4
32448975,32447086,1,"<p>values[size] is equals to value[10].<br>
  it simply means value is an array that can hold 10 elements.</p>

<pre><code>for (count = 0; count &lt; SIZE; count++)
{
    cout &lt;&lt; ""\nEnter an integer value: "";
    cin  &gt;&gt; values[count];
}
</code></pre>

<p>This loop insert 10 elements inside the value array. 
Count is initialized to 0 because array index starts from zero and the first element need to be stored at the very first index.</p>

<pre><code>smallest=largest=value[0]
</code></pre>

<p>it means whatever stored at first index is either the smallest or the largest element.By doing so you can compare rest of the element with the first element to find the smallest or the largest that's why second for loop starts with count=1.  </p>

<pre><code>    if (values[count] &gt; largest)
        largest = values[count];
    if (values[count] &lt; smallest)
        smallest = values[count];
</code></pre>

<p>the above code literally means </p>

<pre><code>if(values[1]&gt;value[0]) 
</code></pre>

<p>because value [0] is already stored in smallest and largest.</p>

<p>Hope This explanation will serve your purpose</p>
",1
32472212,32471565,1,"<p>If every instance which the inline function is used, can be inlined/compiler decides to inline them all, then no instances of the function are necessary in the translation unit.</p>
",2
32479413,32479393,0,"<p>The issue is that you haven't declared the strings <code>str1</code> and <code>str2</code>. </p>
",0
32479447,32479393,1,"<p>You have to declare string str1 before using it. Decraling means </p>

<pre><code>std::string str1;
</code></pre>

<p>In C++ the definition is e.g. </p>

<pre><code>str1 = ""heureka"";
</code></pre>

<p>And the declaration has always be in front of the definition.
But you can do both in one line:</p>

<pre><code>std::string str1 = ""heureka"";
</code></pre>

<p>or</p>

<pre><code>std::string str1(""heureka"");
</code></pre>

<p>If you want to add ""&lt;"" in front and "">"" behind the characters name. You can do it as follows:</p>

<pre><code>charName = ""&lt;"" + charName + ""&gt;"";
</code></pre>

<p>There is no need to create new strings for it. There is simply a + operator for strings and it is easier to use than strcpy, strcat or so. </p>
",3
32480021,32479995,3,"<p>The commas are a red herring; this is just concatenation of string literals.</p>

<p>In source code, <code>""abc"" ""def""</code> means the same thing as <code>""abcdef""</code>.</p>
",5
32480112,32479995,3,"<p>Adjacent string literals are concatenated in C++.  So</p>

<pre><code>""foo"" ""bar""
</code></pre>

<p>Becomes</p>

<pre><code>""foobar""
</code></pre>

<p>In your case the function will return a <code>Qstring</code> with the value of</p>

<pre><code>""estrain,eslip,edashpot""
</code></pre>

<p>This behavior is defined in section 2.2.6 [lex.phases] of the C++ standard</p>

<blockquote>
  <p>Adjacent string literal tokens are concatenated.</p>
</blockquote>
",0
32480300,32479995,0,"<p>The quotation mark here is because your function return type is string. So <code>""""</code> is for the string type return.</p>

<p>Now the second part as to why you have comma, then as others have answered it is for getting the adjacent string literal or different string literals. If you remove the comma then you will get a single string. If you don't have the comma then the return string will be equivalent to <code>estraineslipedashpot</code></p>
",0
32489220,32489133,1,"<p>I think you better review the latest lesson in C++ first.</p>

<p>Here is the fix for your code:</p>

<pre><code>double a = Const * Radius; //'A' == Const * Radius;

double c = 2 * Const * Radius; //'C' == 2 * Const * Radius;  

double d = 2 * Radius; //'D' == 2 * Radius;  

if (Code == 'A')
    cout &lt;&lt; ""The area of a circle with radius"" &lt;&lt; Radius &lt;&lt;   ""is"" &lt;&lt; a /*'A'*/&lt;&lt; endl;


else if (Code == 'C')
    cout &lt;&lt; ""The circumference of a circle with radius"" &lt;&lt;  Radius &lt;&lt; ""is"" &lt;&lt; c /*'C'*/ &lt;&lt; endl;


else if (Code == 'D')
    cout &lt;&lt; ""The diameter of a circle with radius"" &lt;&lt; Radius &lt;&lt; ""is"" &lt;&lt; d /*'D'*/ &lt;&lt; 

endl; 
</code></pre>

<p>'A', 'B', 'C' are values as well as 1, 3, 100, etc.</p>

<p><code>=</code> is an assignment operator while <code>==</code> is compare operator.</p>

<p>Once you write something like <code>'A' == Radius;</code> it will be evaluated to boolean (most likely <code>false</code> value) and that's it. In the same way you can write <code>false;</code> or <code>5;</code> in your code. It does nothing at all.</p>
",1
32489349,32489133,0,"<p>You're not assigning the value but making it equal to that. by the you can assign a value to char.</p>

<pre><code> #include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

/*run this program using the console pauser or add your own     getch, system(""pause"") or input loop */

int main(int argc, char** argv) {

cout &lt;&lt; fixed &lt;&lt; setprecision(2);
char Code;
double Radius;

//promt for a code and A, C, or D
cout &lt;&lt; ""Please enter your code A, C, or D "";

// read the input
cin &gt;&gt; Code;

//promt user for value of radius
cout &lt;&lt; ""Please enter a value for the radius"";

//read the input radius
cin &gt;&gt; Radius;
// based on the code, calculate the required computed result
double Const;

Const = 3.1416;
/*      NO need of this. you can't assign value to a char.
'A' == Const * Radius;
you have used == sign whic is not assigning
'C' = 2 * Const * Radius;  

'D' = 2 * Radius;  
*/
if (Code == 'A'){
    float temp;    //change
    temp=Const * Radius;   //change
    cout &lt;&lt; ""The area of a circle with radius"" &lt;&lt; Radius &lt;&lt;   ""is"" &lt;&lt; temp &lt;&lt; endl;

}


else if (Code == 'C'){
    float temp;
    temp=2 * Const * Radius; 
    cout &lt;&lt; ""The circumference of a circle with radius"" &lt;&lt;  Radius &lt;&lt; ""is"" &lt;&lt; temp&lt;&lt; endl; 
}



else if (Code == 'D'){
    float temp;
    temp=2 * Radius;  
    cout &lt;&lt; ""The diameter of a circle with radius"" &lt;&lt; Radius &lt;&lt; ""is"" &lt;&lt; temp &lt;&lt; endl;    
}
    //Hope this helps.
//output the result

return 0;
}
</code></pre>
",0
32426630,32426598,0,"<p>First, you can do something like if(input == ""C"" || input == ""c"")
Or you can convert the input to lower/upper case</p>

<p>Second, you can add an else statement that says something like ""please enter a valid command"". Play around with it, you can even use loops to wait for correct input!</p>
",9
32426702,32426598,0,"<p>My approach is to test the input against a container of all valid inputs.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

bool valid(std::string s,std::vector&lt;std::string&gt; y)
{
    std::sort(y.begin(), y.end());
    return std::binary_search(y.begin(), y.end(), s);
}
int main()
{
    std::string s;

    do
    {
        std::cout &lt;&lt; ""Enter K or C: "";
        std::cin &gt;&gt; s;
    } while (!valid(s, { ""K"",""C"",""k"",""c"" }));

    std::cout &lt;&lt; ""good!"" &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",0
32426896,32426598,0,"<p>You need a while loop. This is probably the simplest way to do it. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string word;
    std::cin &gt;&gt; word;
    //Keep asking for a word until this condition is false, i.e.
    //word will be equal to one of these letters
    while(word != ""C"" &amp;&amp; word != ""c"" &amp;&amp; word != ""K"" &amp;&amp; word != ""k"")
    {
            std::cout &lt;&lt; ""Invalid temperature type: "" &lt;&lt; word &lt;&lt; "" Use 'K' or 'C'"" &lt;&lt; std::endl;
            std::cin &gt;&gt; word;
    }

    if (word == ""C"" || word == ""c"")
    {
        std::cout &lt;&lt; ""Celsius"" &lt;&lt; std::endl;
    }
    else if (word == ""K"" || word == ""k"")
    {
        std::cout &lt;&lt; ""Kelvin"" &lt;&lt; std::endl;
    }
}
</code></pre>
",0
32426900,32426598,1,"<p>Usually user inputs are checked using <code>while</code> or <code>do...while</code> loops.
The idea is simple, you always get back to the same error message and read again the input until it is correct.</p>

<p>The advantage of placing the valid options in the single <code>string</code> is to allow easy addition or removal of the options without dealing with long <code>if</code> conditions.</p>

<p>I believe something simple like this will do the job:</p>

<pre><code>std::string valid_options(""kKcC"");
std::string input;
bool illegal_input;

std::cout &lt;&lt; ""Would you like to convert this temperature to Celsius or Kelvin? (C/K)"" &lt;&lt; std::endl;
std::cin &gt;&gt; input;
// check that only one letter was provided and it belongs to the valid options
while (input.size() != 1 || valid_options.find(input) == std::string::npos)
{
    std::cout &lt;&lt; ""Input invalid, please enter K or C.\n"";
    std::cin &gt;&gt; input;
}
</code></pre>
",0
32983330,32983199,1,"<p>The function signature in your header is:</p>

<pre><code>istream&amp; operator&gt;&gt;(istream&amp; is, Date&amp; dd);
</code></pre>

<p>This is incorrect in your implementation file:</p>

<pre><code>istream&amp; operator&lt;&lt;(istream&amp; is, Date&amp; dd)
//               ^^ Should be &gt;&gt;
</code></pre>
",0
29162787,29162744,1,"<p>Try without the '.h' at the end:</p>

<pre><code>#include &lt;fstream&gt;
</code></pre>

<p><strong>Edit:</strong></p>

<p>It appears some further explanation is in order. </p>

<p>When you have some code that uses fstream for the compiler to understand what that code does it needs the declarations etc. from the fstream header file in the standard library. To tell the compiler to fetch that it needs an include statement. (Note: this explanation is slightly simplified for more info look up C++ preprossesor)</p>

<p>All the imports are handled first. When the compiler can't find file fstream.h it stops. Why? Because without a file that the programmer expects is necessary it is pointless to continue compiling the rest of the code. The code will (most likely) refer to names expected by the programmer to be defined in the missing file.</p>

<p>So when an included file is missing it is not looking any closer at the code you have written.</p>

<p>When you change the include statement to include the right file, the compilation can continue to look more closely at your code. From the comments I read that you get 'more errors'. But the errors are in your code.</p>

<p>As suggested try to fix them yourself. After that create a new question on stackoverflow about specific errors that you don't understand.</p>
",7
29162988,29162744,3,"<p>Drop <code>.h</code> from <code>&lt;fstream.h&gt;</code>.</p>

<p>Add <code>using namespace std;</code> below the included header files.</p>
",3
29164460,29162744,5,"<p>Your sample code is very, very old. Definitely previous century. In this century, we use <code>&lt;fstream&gt;</code>. The problem with <code>&lt;fstream.h&gt;</code> was that it's not standardized, so there are quite some possibilities about what it can contain. The sample code you downloaded will have made some assumptions, and we can't guess.</p>

<p>In general, since we're talking about old code, it's going to predate <code>namespace std;</code>. That is to say, there's likely no <code>std::ifstream</code> class but there could be an <code>ifstream</code> class. You've commented that <code>using namespace std;</code> didn't help, which is the normal hack to get <code>ifstream</code> working after including <code>&lt;fstream&gt;</code>. It seems you would need another hack, or newer sample code.</p>
",0
33549264,33549089,0,"<p>i would do it like this :</p>

<pre><code>int i = 0;
char **s1;
s1 = (char **)malloc(t * sizeof(char *));
while (i &lt; t)
{
 s1[i] = (char *)malloc(1000009 * sizeof(char));
 i++;
}
</code></pre>

<p>the first malloc create you t line.
The second one fill alloc 100000009charactere for each lines</p>
",5
33549430,33549089,1,"<p>Since you tagged this question as C++ I would do it like this:</p>

<pre><code>std::vector&lt;std::string&gt; s1(1000009);
</code></pre>

<p>That's all - no need to use malloc, no need to take care about destruction.
If you are using C++ use the Tools you have available.</p>
",0
33549436,33549089,5,"<p>Use a vector of strings instead of using malloc/new.</p>

<pre><code>int t;
std::cin &gt;&gt; t;
std::vector&lt;std::string&gt; strings(t); //Create t strings
for(int i = 0; i &lt; t; i++)
    std::cin &gt;&gt; strings[i]; //Read into each string
</code></pre>
",4
33542880,33542736,0,"<p>You discard every odd symbol, <code>cin.get()</code> read symbol 1,
<code>cin &gt;&gt;</code> read symbol two, and again <code>cin.get()</code> read symbol 3,
and <code>cin &gt;&gt;</code> read symbol 4 from standard input.</p>
",0
33542882,33542736,0,"<p>You get two characters, once increment i variable and only second of them insert in array</p>

<pre><code>int main()
{
    char a[200];
    int i;
    \\ cin.get() - get one char and insert it in a[i]
    \\ after that, compare this value with '\n'
    \\ if equal, break the loop, if different, continue
    for (i = 0; (a[i] = cin.get()) != '\n'; i++);
    \\ last character ('\n') should be replaced with '\0'
    a[i]='\0';
    cout &lt;&lt; i;

    system(""pause"");
    return 0;
}
</code></pre>

<p>while solution:</p>

<pre><code>int main()
{
    char a[200];
    int i=0;
    cin &gt;&gt; a[i];
    while (a[i] != '\n')
    {
      i++;
      cin &gt;&gt; a[i];
    }

    a[i]='\0';
    cout &lt;&lt; i;

    system(""pause"");
    return 0;
}
</code></pre>

<p>do - while solution:</p>

<pre><code>int main()
{
    char a[200];
    int i=0;
    do
    {
      cin &gt;&gt; a[i];
    }
    while(a[i++]!='\n');

    a[i-1]='\0';
    cout &lt;&lt; i-1;

    system(""pause"");
    return 0;
}
</code></pre>
",12
33543033,33542736,0,"<p>You are throwing out half of your <code>cin</code> results. </p>

<p>When you use <code>cin</code>, a character is read, but you are not assigning it to anything inside the <code>for</code> loop criteria; only inside the loop body are you saving it. </p>

<p>Inside the loop, you read in <em>another</em> character (after the one you already read in during the loop's test criteria) and assign <em>that</em> one. The loop repeats, and the <em>next</em> character read is again thrown away with the line <code>cin.get() != '\n'</code> because you are not assigning the results to anything. And this continues, alternating characters you throw away with characters you ""save"" into the array.</p>
",0
33543110,33542736,0,"<p>As a matter of fact, you are reading the standard input (<code>std::cin</code>) in two different ways, storing its output only once every two character extractions.</p>

<p><a href=""http://en.cppreference.com/w/cpp/io/basic_istream/get"" rel=""nofollow""><code>std::basic_istream::get</code></a> (<code>cin.get()</code>) extracts character or characters from stream. Once extracted, whey are forgotten, sent to limbo. You simply ignore them. Which is not what I suspect you want to do.</p>

<p><a href=""http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt"" rel=""nofollow""><code>std::basic_istream::operator&gt;&gt;</code></a> (<code>cin &gt;&gt; ...</code>) also extracts character or characters (following the type of the right hand side operand).</p>

<p>So, with an input of ten characters, you ignore five of them in your <code>for</code> condition check and store five in the loop block.</p>

<p>A correct way to read the characters would be to use <code>std::getline</code> (en.cppreference.com/w/cpp/string/basic_string/getline):</p>

<pre><code>std::string input;
std::getline(cin, input);
std::cout &lt;&lt; input &lt;&lt; std::endl;
</code></pre>

<p>This example code will simply read a line and output it, verbatim, in the standart output.</p>
",0
32989393,32983172,0,"<p>I hope it helps. I have tried to keep it clean and simple.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

//Function Prototypes
void convert(int&amp;, int&amp;, int&amp;, string&amp;);
void output(int&amp;, int&amp;, string&amp;);

int main()
{

    int hours, minutes, delay;
    string ampm;

    cout &lt;&lt; ""Enter hours(0-24): "";
    cin &gt;&gt; hours;

    do{
        cout &lt;&lt; ""Enter minutes: "";
        cin &gt;&gt; minutes;

        cout &lt;&lt; ""Enter delay(in minutes): "";
        cin &gt;&gt; delay;

        convert(hours, minutes, delay, ampm);
        output(hours, minutes, ampm);

        cout &lt;&lt; endl &lt;&lt; ""Enter the value for Hours (999 to quit):  "";
        cin &gt;&gt; hours;
    } while (hours != 999);

    return 0;
}


void convert(int&amp; hours, int&amp; minutes, int&amp; delay, string&amp; ampm)
{
    int temp = 0;

    minutes += delay;
    if (minutes &gt; 60) {
        temp = minutes / 60;
        hours += temp;
        minutes = minutes - temp * 60;
    }

    if (hours &gt; 12){
        hours -= 12;
        ampm = ""PM"";
    }
    else {
        ampm = ""AM"";
    }
}


void output(int&amp; hours, int&amp; minutes, string&amp; ampm)
{
    if (minutes &gt; 0 &amp;&amp; minutes &lt; 10) {
        cout &lt;&lt; hours &lt;&lt; "":0"" &lt;&lt; minutes &lt;&lt; "" "" &lt;&lt; ampm &lt;&lt; endl;;
    }
    else if (minutes == 0) {
        cout &lt;&lt; hours &lt;&lt; "":0"" &lt;&lt; minutes &lt;&lt; "" "" &lt;&lt; ampm &lt;&lt; endl;;
    }
    else {
        cout &lt;&lt; hours &lt;&lt; "":"" &lt;&lt; minutes &lt;&lt; "" "" &lt;&lt; ampm &lt;&lt; endl;
    }
}
</code></pre>
",0
33535870,33535616,0,"<p>You have not read the string more than once in program. below is sample program, which is very naive to demonstrate the process. The loop terminating condition can be much better than mine though.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>int main()
{
    //setup
    std::vector&lt;int&gt; alphabetCount;

    for (int i = 0; i &lt; 26; ++i)
    {
        alphabetCount.push_back(0);
    }

    //now the interactive bit
    std::cout &lt;&lt; ""Enter a line of text\n"";
    std::string line;
	do{
		std::getline(std::cin, line);
		for (size_t i = 0; i &lt; line.size(); ++i)
		{
			char currentChar = tolower(line[i]);
			if (isalpha(currentChar))
			{
				++alphabetCount[currentChar - 'a']; //subtract a, so if currentChar = a, 'a' - 'a' = 0, so its index 0
			}
		}
	}while(line != ""exit"");

	--alphabetCount['e' - 'a'];
	--alphabetCount['x' - 'a'];
	--alphabetCount['i' - 'a'];
	--alphabetCount['t' - 'a'];

    for (size_t i = 0; i &lt; alphabetCount.size(); ++i)
    {
        std::cout &lt;&lt; ""there were "" &lt;&lt; alphabetCount[i] &lt;&lt; "" occurences of "" &lt;&lt; static_cast&lt;char&gt;(i + 'a') &lt;&lt; ""\n""; //add 'a' for the same reason as above, though we have to cast it to a char.
    }
	system(""pause"");
    return 0;
}</code></pre>
</div>
</div>
</p>
",1
33535707,33535616,0,"<p>The reason why it is taking one string at a time is because you are taking one as input, you should make a vector of string and take input in it. </p>
",1
33578761,33578352,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace std;

int main()
{
   int y = 63;
   int minx = log2(y);
   int x = y - (pow(2,minx) + 1);
   if (x &gt; y / 2) 
   {
       x = y / 2;
   }
   cout &lt;&lt; x &lt;&lt; endl;
   return 0;
}
</code></pre>
",1
33578441,33578352,0,"<pre><code>Let 'n' = number of bits in binary representation of Y
X = Y - (2 pow (n-1) + 1);

ex: Y = 19 ( 5 bits)
n = 5.
X = 19 - (2 pow 4 + 1) = 19 - 17 = 2
</code></pre>
",0
33578794,33578352,0,"<p>We can take advantage of the property that a power of 2 has exactly one bit set to 1: only a power of 2 (and zero) will return zero when bitwise ANDed with itself minus 1.</p>

<pre><code>int ispow2plus1(int n)
{
    int pow2 = n - 1;
    return pow2 != 0 &amp;&amp; (pow2 &amp; (pow2 - 1)) == 0;
}
</code></pre>

<p>Consider 33.  <code>pow2</code> is then 32, which is not zero, and <code>pow2 &amp; (pow2 - 1)</code> equals <code>32 &amp; 31</code> - in binary, <code>100000 &amp; 011111</code>, which is zero.</p>

<p><strong>EDIT</strong>: somewhat under-scoped question based on misunderstanding in off-site chat.  You'll also need to find the most significant 1 bit in case what you have is not in fact a power of 2 plus 1.  I've gone out of my way here to avoid the use of floating-point math, thus the loop to remove 1 bits other than the most significant from pow2.</p>

<pre><code>int pow2plus1excess(int n)
{
    int pow2 = n - 1;
    for (int temp = pow2; temp &gt; 0; temp &amp;= temp - 1) pow2 = temp;
    return (n - 1) &amp; ~pow2;
}
</code></pre>

<p>This returns 0 if the number is a power of 2 plus 1, otherwise the excess beyond that point.  1, 2, 3, 9, and 33 all result in 0 returns, while 16 results in a return of 7.</p>
",0
29242901,29242758,4,"<p>it must be hard for your professor to figure out the correct size of array.  </p>

<pre><code>for (int i=0; i&lt;count; i++){ //not count-1
        total=total+nums[i];
       }
       cout&lt;&lt;""\nThe total is: ""&lt;&lt;total; 
       avg=total/count; 
       cout&lt;&lt;""\nThe average is: ""&lt;&lt;avg;
       system(""pause"");
    } 
</code></pre>
",4
34188238,34188047,0,"<p>If you take a look closer to the <code>man ascii</code> command in your terminal, you'll find the character <code>\r</code> also known as ""carriage ret"". This might answer your problematic actually.</p>

<p>By printing it, it brings your display cursor at the beginning of the current line without generating a new line.</p>

<p>Just try</p>

<pre><code>cout &lt;&lt; '\r';
</code></pre>

<p>And avoid the</p>

<pre><code>cout &lt;&lt; endl;
</code></pre>

<p>which brings a new line with it (Here an explanation of <a href=""http://www.cplusplus.com/reference/ostream/endl/?kw=endl"" rel=""nofollow"">endl</a>)</p>
",2
34188261,34188047,0,"<p>Unfortunately using a ""character by character"" approach here is difficult in the console. </p>

<p>One cute and feasible way to accomplish your task in the console by having a list of std::string for each star ""character"", where every entry in the vector is a vertical slice of the output. </p>

<p>you can define a class to represent partial ""star strings"" and you can keep appending new star characters to it by appending the appropriate lists. </p>

<p>the best way to accomplish that is to create a class starChars and overload the + operator for appropriate concatenation. (in this case appending the lists one by one). note that you probably want all characters to have the same number of height.(even if you need to leave some empty) </p>

<pre><code>class starChars
{
 private std::list&lt;std::string&gt; content; 
...

starChars operator+(starChars &amp; newCharacter)...

}
</code></pre>
",3
33534973,33534941,1,"<p>Employee() is trying to default construct an Employee but there is no default constructor for Employee.  Instead, construct it with the parameters your constructor it expects.</p>

<p>The Chef constructor should look like this:</p>

<pre><code>Chef(int theempID, string thefirstName, string thelastName, char theempClass, int thesalary, string theempCuisine) :
    Employee(theempID, thefirstName, thelastName, theempClass, thesalary), empCuisine(theempCuisine)
    {}
</code></pre>

<p>Note the body of the constructor is empty.  The Employee base class and the member variable are <strong>initialized</strong> in the initialization list.  No <strong>assignment</strong> necessary in the body.  You should also change the base class constructor so it uses initialization instead of assignment.</p>
",2
32954323,32954133,1,"<p>There are twp problems: </p>

<p>1) you never update x, so you'll iterate a long time.  </p>

<p>2) x/2>1 even if x is not divisible by two.  Consider use of modulo for the test</p>

<p>For example:  </p>

<pre><code> ...
 while(x&gt;1 &amp;&amp; fmod(x,2)==0)  // sorry %  is for integers only
 {
     num++;
     x /= 2; 
 } 
</code></pre>
",2
32974465,32974311,1,"<p>What I think you're trying to say is that you want to initialize the data members of a <code>Derived</code> to those members from some <code>Base</code>.</p>

<p>You can do this with a copy constructor in <code>Base</code>, and a corresponding constructor in <code>Derived</code> that passes the value on.</p>

<p><a href=""http://coliru.stacked-crooked.com/a/80b79db222d2e4b6"" rel=""nofollow"">Code</a>:   </p>

<pre><code>class Base
{ 
    public : 
        Base() { /*...*/}
        Base(const Base&amp; other){/*...*/}
        virtual ~Base() {/*...*/}  
    private:
        /*...*/
};

class Derived : public Base
{ 
    public : 
        Derived() {/*...*/} 
        ~Derived() {/*...*/} 
        Derived(const Base&amp; other) : Base(other){/*...*/}

};

int main()
{
    Base b;
    Derived d(b);
}
</code></pre>

<p>You can do similar operations for forwarding constructors and assignment operators.</p>
",2
32975923,32974311,0,"<blockquote>
<pre><code>Derived::Base::d = b;
</code></pre>
  
  <p>Any ideas on the syntax?</p>
</blockquote>

<p>It's wrong. Options for a working syntax would include:</p>

<ul>
<li><code>static_cast&lt;Base&amp;&gt;(d) = b;</code></li>
<li><code>d.Base::operator=(b1);</code></li>
</ul>

<p>Both are pretty ugly; a result of the fact that the assignment operator in the subclass hides the base version. As is often the case in C++, the ugliness of the syntax indicates that this kind of operation is unusual and that refactoring may be a good idea.</p>

<hr>

<p>Generally, operator overloading and inheritance don't mix well, especially if you are using inheritance for object-oriented programming (i.e. with virtual functions). In that case, one typically makes sure that the class is not assignable at all (which C++11 makes very easy because you simply <code>delete</code> the generated assignment operator in the base class).</p>

<p>You should also read more about object slicing, for example all answers and comments for these two questions:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/274626/what-is-object-slicing"">What is object slicing?</a></li>
<li><a href=""https://stackoverflow.com/questions/13606143/c-slicing-causing-leak-undefined-behavior-crash"">C++ slicing causing leak / undefined behavior / crash</a></li>
</ul>
",0
32963698,32962512,0,"<blockquote>
  <p>I'm trying to learn how to use classes but I am having a hard time
  trying to understand it so I tried to create a game.</p>
</blockquote>

<p>Since you want to create a game, visualize all the characters and scenes or anything that you want.</p>

<p>Model your idea/view of the game..</p>

<p>Example:</p>

<p><a href=""https://i.stack.imgur.com/yQMes.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yQMes.png"" alt=""game model""></a></p>

<p>Once you have determined all the classes that you need and the relationships between them, you can now start coding them up in any language you want to.</p>

<p>I know this will take time but it is a better way to learn designing and these skills will be helpful in the long run.</p>
",0
32963872,32962512,0,"<p>The first line in main <code>Player *p = new Player[10];</code> is creating an array of 10 players on the heap.</p>

<p>It seems that that you want to 'initialize' these 10 players with the second line <code>p-&gt;createPlayer(&amp;p,10);</code> but the code is wrong :</p>

<p>The loop in <code>createPlayer()</code> function always works on the same player (it increments i but p is always the same).</p>

<p>try this :</p>

<pre><code>class Player
{
    public:
        Player(); /// can be private if players can be instantiated only by createPlayer()
        ~Player();

        static int genRanNum(int);
        static Player* createPlayer(int);
    private:
        int plyrSkill1,plyrSkill2,plyrSkill3;
        int plyrId;
};
</code></pre>

<p>createPlayer() and getRanNum() are static because they are class method (it's not related to one instance in particular)</p>

<pre><code>Player * Player::createPlayer(int si)
{
    Player *player = new Player();
    player-&gt;staId = si;
    player-&gt;staSkills1 = genRanNum(10);
    player-&gt;staSkills2 = genRanNum(10);
    player-&gt;staSkills3 = genRanNum(10);

     return player;   
}
</code></pre>

<p>Finally in main :</p>

<pre><code>int main()
{
    std::vector&lt;Player *&gt; p(10); 
    for (int iPlayer=0; iPlayer&lt;10; iPlayer++)
    {
       p[iPlayer] = Player::createPlayer(iPlayer);
    }

    ...
    /// Don't forget to delete players
}
</code></pre>
",0
33004763,33004418,1,"<p>Try changing your code to:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main(int argc, char ** argv)
{
    cout &lt;&lt; ""Hello World.  "";
    cout &lt;&lt; ""This is my program."" &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>The problem is that you just started writing code in a block at the top level of the file.  I think you meant to define a function named <code>main</code> and put the code in that function, because code like that needs to be inside a function.</p>
",0
33004316,33004245,0,"<p>Try this:</p>

<pre><code>int main()
{

    int quarters;
    int dimes;
    int pennies;
    int nickles;

    cout &lt;&lt; ""Please enter the amount of quarters you wish to convert"" &lt;&lt; endl;
    cin &gt;&gt; quarters;

    dimes = (quarters * 5);
    pennies = (quarters * 25);
    nickles = (pennies / 10);

    cout &lt;&lt; ""Pennies = "" &lt;&lt; pennies &lt;&lt; endl;
    cout &lt;&lt; ""Dimes = "" &lt;&lt; dimes &lt;&lt; endl;
    cout &lt;&lt; ""Nickles = "" &lt;&lt; nickles &lt;&lt; endl;
    cin.get();
    cin.get();

    return 0;
}
</code></pre>
",1
33004325,33004245,1,"<p>The error message clearly says what's wrong. You have declared <code>quarters</code> but haven't initialized before you used it.
Put this</p>

<pre><code>cout &lt;&lt; ""Please enter the amount of quarters you wish to convert"" &lt;&lt; endl;
cin &gt;&gt; quarters;
</code></pre>

<p>Before</p>

<pre><code>int dimes = (quarters * 5);
int pennies = (quarters * 25);
int nickles = (pennies / 10); 
</code></pre>
",0
33004351,33004245,1,"<p>Initialise the variable <code>quarters</code> and then use it in your calculations. </p>

<pre><code>int quarters;
cout&lt;&lt;""Please enter the amount of quarters you wish to convert"" &lt;&lt; endl;
cin&gt;&gt;quarters;

int dimes = (quarters * 5);
int pennies = (quarters * 25);
int nickles = (pennies / 10);
</code></pre>
",0
33004397,33004245,0,"<p>As others have said, you must get the input before you use it, like:</p>

<pre><code>int quarters;
cout &lt;&lt; ""Please enter the amount of quarters you wish to convert"" &lt;&lt; endl;
cin &gt;&gt; quarters;
</code></pre>

<p>and then, AFTER this, you can calculate the other values:</p>

<pre><code>int dimes = (quarters * 5);
int pennies = (quarters * 25);
int nickles = (pennies / 10);
</code></pre>

<p>That said, let's see why it happens. Maybe you think that when you assign a ""formula"" to a variable (like <code>dimes = quarters * 5</code>), the value will always be recalculated, similarly to what Excel does. C++ doesn't work like that: <strong>when you assign a value to a variable you are not defining a general formula which will be automatically updated, but rather calculating the result at that moment.</strong> And the program is run from the top to the bottom. So when you reach the lines that define <code>dimes</code>, <code>pennies</code> and <code>nickles</code>, you are taking the (not defined yet) value of <code>quarters</code> and trying to use that to calculate the other variables. Here the program stops, but if it continued and it reached the line with <code>cin</code>, it would indeed store the value in <code>quarters</code>, but the other 3 variables wouldn't be updated!</p>
",1
33029839,33028701,0,"<p>you can try:</p>

<pre><code>for (auto &amp;item : map)
    {
        std::cout &lt;&lt; item &lt;&lt; std::endl;
        saveFile &lt;&lt; ""Hoppa"" &lt;&lt; std::endl;
    }
</code></pre>
",0
33028897,33028701,2,"<p>Welp, I dunno, but it works when I use <code>std::map&lt;int, int&gt;</code> and input 4 <code>std::pair&lt;int, int&gt;</code> and use the same <code>for</code> loop:</p>

<p><a href=""http://coliru.stacked-crooked.com/a/e694252e96aebab5"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/e694252e96aebab5</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

void save()
{
    std::map&lt;int, int&gt; mappa;

    for (size_t i = 0; i &lt; 4; ++i) {
        mappa.insert(mappa.begin(), std::pair&lt;int, int&gt;(i,i));   
    }

    std::ofstream saveFile;
    saveFile.open(""test.txt"", std::ios::trunc | std::ios::out);
    if (saveFile.is_open())
    {
        saveFile &lt;&lt; ""File opened. Begin saving.\n"";
        for (auto it : mappa)
        {
            saveFile &lt;&lt; ""Hoppa"" &lt;&lt; std::endl;
            std::cout &lt;&lt; ""PRINTED LINE"" &lt;&lt; std::endl;
        }
     }
     saveFile.close();
}

int main() {
    save();
}
</code></pre>
",0
33030364,33030102,0,"<blockquote>
  <p>This program keeps outputting the first function multiple times before working and the first output first the second function keeps outputting the inputs for the first input</p>
</blockquote>

<p>You have a call to <code>userInput</code> from <code>computePay</code>. That explains the above behavior.</p>

<blockquote>
  <p>and -1 isn't stopping the entire program like it should. Could anyone help?</p>
</blockquote>

<p>After the call to <code>userInput</code> from <code>computePay</code>, you don't have any code to break out of the loop if <code>Length == -1</code>. Hence, you get more output from the following <code>printf</code> calls.</p>

<p>My suggestions:</p>

<ol>
<li><p>Change <code>main</code> slightly so that the flow of control is simpler. Replace the lines:</p>

<pre><code>userInput(Length, AuthorLevel);
computePay(Length, AuthorLevel);
</code></pre>

<p>by</p>

<pre><code>while (1)
{
   userInput(Length, AuthorLevel);
   if ( Length == -1 )
   {
      break;
   }
   computePay(Length, AuthorLevel);
}
</code></pre></li>
<li><p>Remove the call to <code>userInput</code> from <code>computePay</code>.</p></li>
<li><p>Remove the <code>while</code> loop from <code>computePay</code>.</p></li>
<li><p>The logic behind the following line is not clear to me:</p>

<pre><code>averagePayout = (averagePayout += PayOut) / counter;
</code></pre>

<p>You should simplify it. I get a compiler warning from that line that  says:</p></li>
</ol>

 <pre class=""lang-none prettyprint-override""><code>    socc.cc: In function ¡®int computePay(int&amp;, char&amp;)¡¯:
    socc.cc:108:58: warning: operation on ¡®averagePayout¡¯ may be undefined [-Wsequence-point]
           averagePayout = (averagePayout += PayOut) / counter;
</code></pre>

<p>Here's an updated version of your program:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdlib&gt;

using namespace std;

int userInput(int&amp; Length, char&amp; AuthorLevel);
int computePay(int&amp; Length, char&amp; AuthorLevel);

int main(void)
{
   int Length;      // The length of the story.
   int counter = 0;
   int numA = 0;
   int numB = 0;
   int numC = 0;
   char AuthorLevel;    // The level of the author.
   float PayOut;        // The final payout.
   float averagePayout = 0.0;
   float highestPayout = 0.0;

   while (1)
   {
      userInput(Length, AuthorLevel);
      if ( Length == -1 )
      {
         break;
      }
      computePay(Length, AuthorLevel);
   }

   return 0;
} //end main()
//==================================================================

int userInput(int&amp; Length, char&amp; AuthorLevel )
{
   cout &lt;&lt; ""Please enter the word count of the story (-1 to stop): "";
   cin &gt;&gt; Length;
   if( Length != -1)
   {
      cout &lt;&lt; ""Now enter the author's level (A, B, or C): "";
      cout &lt;&lt; ""Level: "";
      cin &gt;&gt; AuthorLevel;
      cout &lt;&lt; endl;
   }
   return 0;
}

//==================================================================
int computePay(int&amp; Length, char&amp; AuthorLevel)
{
   float PayOut;        // The final payout.
   int numA = 0; // Number of A's that have been printed.
   int numB = 0; // Total number of B's.
   int numC = 0; // Number of C's.
   float averagePayout = 0.0;
   float highestPayout = 0.0;
   int counter = 0; // The number of times the program has ran.

   if(Length &lt; 7500 || Length != -1)
   {
      PayOut = 0.08 * Length;
   }
   else if(Length &lt; 8000)
   {
      PayOut = 600;
   }
   else if(Length &lt; 17500)
   {
      PayOut = 0.075 * Length;
   }
   else if(Length &lt; 19000)
   {
      PayOut = 1313;
   }
   else if(Length &gt;= 19000)
   {
      PayOut = 0.07 * Length;
   };

   if (AuthorLevel == 'A' || AuthorLevel == 'a')
   {
      numA++;
      PayOut = 1.75 * PayOut;
   }
   else if(AuthorLevel == 'B' || AuthorLevel == 'b')
   {
      numB++;
      PayOut = 1.25 * PayOut;
   }
   else if (AuthorLevel == 'C' || AuthorLevel == 'c')
   {
      numC++;
      PayOut = 1.00 * PayOut;
   }
   else
   {
      cout &lt;&lt; ""That was not a valid input. Please try again."" &lt;&lt; endl;
   };

   counter++;
   cout &lt;&lt; ""The amount the author will make from the story will be: $"" &lt;&lt; PayOut;
   cout &lt;&lt; endl &lt;&lt; endl;
   cout &lt;&lt; ""The number of payments calculated is: "" &lt;&lt; counter &lt;&lt; endl;
   cout &lt;&lt; ""The number of A's inputted: "" &lt;&lt; numA &lt;&lt; endl;
   cout &lt;&lt; ""The number of B's inputted: "" &lt;&lt; numB &lt;&lt; endl;
   cout &lt;&lt; ""The number of C's inputted: "" &lt;&lt; numC &lt;&lt; endl;

   // FIXME
   averagePayout = (averagePayout += PayOut) / counter;
   // FIXME

   if(highestPayout &lt; PayOut)
   {
      highestPayout = PayOut;
   }
   else if(highestPayout &gt; PayOut)
   {
      highestPayout = highestPayout;
   }
   cout &lt;&lt; ""The highest payout so far has been: $"" &lt;&lt; highestPayout &lt;&lt; endl;
   cout &lt;&lt; ""The average payout is: $"" &lt;&lt; averagePayout &lt;&lt; endl &lt;&lt; endl;

   return 0;
}
//===================================================
</code></pre>
",1
33028950,33028760,2,"<p>I see at least one bug in your code that is going to result in undefined behavior. I am not familiar with the actual compiler diagnostic you're asking about, but undefined behavior is undefined behavior. Who knows.</p>

<p>The bug is that the assignment operator is allocating too short of a buffer. As a result, this code is going to stomp on the heap.</p>

<p>The assignment operator should be doing:</p>

<pre><code>str = new char[len+1];
</code></pre>

<p>Your constructor sets <code>len</code> to the size of the string that does not include the terminating null byte. Subsequently, the assignment operator will allocate one fewer bytes, for the assigned string. Compare the <code>new</code> in the constructor, with the <code>new</code> in the assignment operator.</p>

<p>The assignment operator is also leaking memory by not freeing the existing buffer, but that's a separate issue.</p>
",2
33030452,33030217,1,"<ol>
<li>First, you need to make an array of <code>string</code> instead of a single string to avoid overwriting.</li>
<li>After that, <strong>sort</strong> them <code>lexicographically</code> and print them.</li>
</ol>
<h3>EDIT:</h3>
<p>Have a look at the code given below:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;      /* Used to sort the string lexicographically */
#define LIMIT 50          /* I'm considering that you are not providing more than 50
                             names at once to a program*/
using namespace std;

int main () {
    int studentCount;              /* Count number of the students */
    string studentName[LIMIT];     /* Array of string */

    cin &gt;&gt; studentCount;           /* Input number of student */

    /* Keep on asking until the correct value of studentCount is not provided */
    while (studentCount &lt; 1 || studentCount &gt; 25) {  
        cout &lt;&lt; &quot;Please try again.&quot; &lt;&lt; endl;  
        cout &lt;&lt; &quot;Try putting in a number between 1 and 25.&quot; &lt;&lt; endl;
        cin &gt;&gt; studentCount;
    }
    
    cout &lt;&lt;&quot;Please enter a student's name: &quot;;
    for (int count = 0; count &lt; studentCount; count++) {  
        cin &gt;&gt; studentName[count];        /* I started the count value from 0 to n-1 
                                          because the index of an array starts from 0 */ 
    }
    
    /* Now, time to sort the array of string lexicographically */
    sort(studentName, studentName+studentCount);
    
    /* Print the names of the student */
    cout &lt;&lt; &quot;Names of the students : &quot; &lt;&lt; endl;
    for(int i=0; i&lt; studentCount; i++) {
        cout &lt;&lt; studentName[i] &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<p>This code will keep on asking until correct value of <code>studentCount</code> is <strong>not</strong> received. You can even change the upper limit of the program by changing the value of <code>LIMIT</code> from <code>50</code> to something else you may need.</p>
",5
33030611,33030217,1,"<p>As you collect names, Store the names in a data structure.If you keep adding all names to a single string, then, it can be stored as one concatenated string but we want different names(strings).
So, Lets take vector as our datastructure.</p>

<pre><code>int main () {

int studentCount;
string studentName;
vector&lt;string&gt; attendanceBook;

for (int count = 1; count &lt;= studentCount; count++) {

    cout &lt;&lt; ""Please enter a student's name: "";
    studentName.clear();
    cin &gt;&gt; studentName;
    attendanceBook.push_back(studentName);
}

std::sort(attendanceBook.begin(),attendanceBook.end());

cout&lt;&lt;""First: ""&lt;&lt;name.front&lt;&lt;endl&lt;&lt;""Last: ""&lt;&lt;name.back();
</code></pre>
",1
33032324,33030217,1,"<p>So this is the completed code, after hours of work, and it runs and does everything properly. It's simple, I know, but to a college freshman only having been exposed to the surface of Java, this is complicated to me. :) I knew there was a way of doing this without vectors or arrays.. Thanks to everyone who tried their best to help me. I'll be sure to come back in the future. </p>

<pre><code> #include &lt;iostream&gt;
 #include &lt;string&gt;

    using namespace std;

    int main () {

        int studentCount;
        string studentNames;
        string first;
        string last;

        cout &lt;&lt; ""Hello fellow educator!"" &lt;&lt; endl;
        cout &lt;&lt; ""I will be helping you with your line-up for today."" &lt;&lt; endl;
        cout &lt;&lt; ""Please enter the number of students in your class: "";
        cin &gt;&gt; studentCount;
        cout &lt;&lt; endl;
        cout &lt;&lt; endl;

        while (studentCount &lt; 1 || studentCount &gt; 25) {
            cout &lt;&lt; ""Please try again."" &lt;&lt; endl;
            cout &lt;&lt; ""Try putting in a number between 1 and 25: "";
            cin &gt;&gt; studentCount;
        }

        for (int count = 0; count &lt; studentCount; count++) {

            cout &lt;&lt; ""Please enter the name for student number "" &lt;&lt; count + 1 &lt;&lt; "":"";
            cin &gt;&gt; studentNames;

            if (count == 1) {

                first = studentNames;
                last = studentNames;

            }
            else {
                if (studentNames &lt; first) {
                first = studentNames;
            }
                else if (studentNames &gt; last) {
                    last = studentNames;
                }
            }
        }

            cout &lt;&lt; ""The first student in line is "" &lt;&lt; first &lt;&lt; ""."" &lt;&lt; endl;
            cout &lt;&lt; ""The last student in line is  "" &lt;&lt; last &lt;&lt; ""."" &lt;&lt; endl;

        return 0;
    }
</code></pre>
",1
32931125,32930893,0,"<p>cin is a object declared in iostream 
it has a function named by "">>"" .
so what you have to do is called operator overloading.
in this you change the defination of function defined by "">>""
but you can't overload it for cin since its class i.e iostream's constructor is not accessible so make another class derived from iostream than overload "">>"" then make a object of it and use "">>"" with that
for more info go to google and search about operator overloading</p>
",1
32931556,32930893,1,"<p>Your question is not entirely clear, but here are some solutions to possible issues that you might have:</p>

<h2>a) Reading more than one number, one after the other, unrelated</h2>

<p>In this case it's the best to extract the code to read and validate the input operation into a function, like:</p>

<pre><code>template&lt;typename T, typename Q, typename E&gt;
T askForOne(std::ostream &amp; out, std::istream &amp; in, Q&amp;&amp; question, E&amp;&amp; error) {
  T value;
  out &lt;&lt; question;
  while (not (in &gt;&gt; value)) {
    in.clear();
    in.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
    out &lt;&lt; error;
  }
  return value;
}
</code></pre>

<p>Then you can call this function to retrieve more than a single value from some stream:</p>

<pre><code>int one = askForOne&lt;int&gt;(std::cout, std::cin, ""Enter a number: "", ""Invalid. "");
int two = askForOne&lt;int&gt;(std::cout, std::cin, ""Enter a number: "", ""Invalid. "");
</code></pre>

<h2>b) Reading more than one number, related</h2>

<p>If you want to read multiple numbers, and only accept the input if <em>all</em> of them have been read, then you could use a function like:</p>

<pre><code>template&lt;typename T, std::size_t N, typename Q, typename E&gt;
std::array&lt;T, N&gt; askFor(std::ostream &amp; out, std::istream &amp; in, Q&amp;&amp; question, E&amp;&amp; error) {
  std::array&lt;T, N&gt; values;
  auto const scan = [&amp;in, &amp;values] {
    for (auto &amp; value : values) {
      if (not (in &gt;&gt; value)) {
        return false;
      }
    }
    return true;
  };
  out &lt;&lt; question;
  while (not scan()) {
    in.clear();
    in.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
    out &lt;&lt; error;
  }
  return values;
}
</code></pre>

<p>This would try to get the specified number of values, and fail as soon as one isn't valid. Instead of using a constant, compile time of numbers one could also use a run time sized <code>std::vector</code>.</p>

<p>A small test of the above functions:</p>

<pre><code>// in some function
using namespace std;
int one = askForOne&lt;int&gt;(cout, cin, ""Int? "", ""Meh. "");
int two = askForOne&lt;int&gt;(cout, cin, ""Int? "", ""Meh. "");
auto ints = askFor&lt;int, 5&gt;(cout, cin, ""5 ints? "", ""Meh. "");
cout &lt;&lt; ""one = "" &lt;&lt; one &lt;&lt; endl;
cout &lt;&lt; ""two = "" &lt;&lt; two &lt;&lt; endl;
cout &lt;&lt; ""ints = "";
copy(begin(ints), end(ints), ostream_iterator&lt;int&gt;{cout, "", ""});
</code></pre>

<blockquote>
  <p><strong>Int?</strong> Haha</p>
  
  <p><strong>Meh.</strong> 21</p>
  
  <p><strong>Int?</strong> Ha ha ha</p>
  
  <p><strong>Meh.</strong> Ha</p>
  
  <p><strong>Meh.</strong> 42</p>
  
  <p><strong>5 ints?</strong> 1 2 3 4 BUUUUUU</p>
  
  <p><strong>Meh.</strong> 1 2 3 4 BUUU JA</p>
  
  <p><strong>Meh.</strong> Ehm 1 2 3 4 5</p>
  
  <p><strong>Meh.</strong> 9 8 7 6 5</p>
  
  <p><strong>one = 21</strong></p>
  
  <p><strong>two = 42</strong></p>
  
  <p><strong>ints = 9, 8, 7, 6, 5,</strong></p>
</blockquote>

<p>(<a href=""http://ideone.com/BiLvkH"" rel=""nofollow"">Live here</a>)</p>
",5
32931618,32930893,0,"<p>You can try putting the code into a function with an int parameter and passing in the two variables like so: </p>

<pre><code>using namespace std;
int main()
{
    int x = 0;
    int z = 0;
    inputNumber(x);
    inputNumber(z);
}  

void inputNumber(int input)
{
    cout &lt;&lt; ""Enter an int: "";
    while(!(cin &gt;&gt; input)){
        cin.clear();
        cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
        cout &lt;&lt; ""Invalid input.  Try again: "";
    }
    cout &lt;&lt; ""You entered: "" &lt;&lt; input &lt;&lt; endl;
}
</code></pre>
",2
34212821,34212719,1,"<p>You are declaring <code>GameIntro</code> function but there is no definition for <code>GameIntro</code> in your program. Add it to your source file or if it is already present in another source file ensure it is also compiled and linked to your program.</p>

<p>Also please notice that C++ contrary to C does not allow you to call <code>main</code> function in your program. </p>
",2
33015945,33015748,1,"<p>What actually seems to happen is the real <a href=""https://en.wikipedia.org/wiki/Stack_overflow"" rel=""nofollow"">stack overflow</a>. You have a recursive function and it goes into infinite recursion, so at some time moment it runs out of stack.</p>
",0
33015952,33015748,6,"<p>The C++ standard 3.6.1/3 does not permit you to call main() inside main()</p>

<blockquote>
  <p>The function main shall not be used (3.2) within a program. The linkage (3.5) of main is implementation defined. A program that declares main to be inline or static is illformed. The name main is not otherwise reserved. [Example: member functions, classes, and enumerations can be called main, as can entities in other namespaces. ]</p>
</blockquote>

<p>You are eventually getting a stack overflow.(<em>Actually it's an undefined behavior by calling main inside main</em>)</p>

<p>The <strong>used(3.2)</strong> says:</p>

<blockquote>
  <p>An object or non-overloaded function is used if its name appears in a
  potentially-evaluated expression.</p>
</blockquote>

<p>And also see this:</p>

<blockquote>
  <p><strong>5.2.2.9</strong><br>
  ""Recursive calls are permitted, <strong>except to the function named main</strong>""</p>
</blockquote>
",4
33015960,33015748,1,"<p>First, you eventually get a stack overflow because you have an endless recursion. What did you think would happen?</p>

<p>Second, standard C++ doesn't allow you to call <code>main</code>. Your code is invalid and a compiler would be justified (and smart) in doing so.</p>
",0
33016122,33015748,0,"<p>The better question is <em>what do you expect to happen with this code?</em></p>

<p>You've got an infinitely recursive function that continually adds to the standard output stream. Of course you're getting an error- you're continually allocating ""WORK"" strings onto your stack, which is going to overflow. I'm not sure that happens when you push too much data into the standard output stream, but that can't be healthy either. </p>
",0
33016799,33015748,0,"<p>Just to add some practical infos:</p>

<p>This is the warning you would get with:</p>

<p>gcc -Wall test.c</p>

<blockquote>
  <p>warning: control reaches end of non-void function [-Wreturn-type]</p>
</blockquote>

<p>its not saying anything about main (I hoped it will show something)</p>

<p>And this is the backtrace if you would run the app in gdb:</p>

<p><code>gdb ./a.out</code></p>

<p>..</p>

<pre><code>Program received signal SIGSEGV, Segmentation fault. 0x00007ffff7a8dffe in _IO_new_file_write (f=0x7ffff7dd4400 &lt;_IO_2_1_stdout_&gt;, data=0x7ffff7ff7000, n=5) at fileops.c:1261 1261    fileops.c: No such file or directory. (gdb) bt
#0  0x00007ffff7a8dffe in _IO_new_file_write (f=0x7ffff7dd4400 &lt;_IO_2_1_stdout_&gt;, data=0x7ffff7ff7000, n=5) at fileops.c:1261
#1  0x00007ffff7a8f4dc in new_do_write (to_do=5, data=0x7ffff7ff7000 ""WORK\n"", fp=0x7ffff7dd4400 &lt;_IO_2_1_stdout_&gt;) at fileops.c:538
#2  _IO_new_do_write (fp=fp@entry=0x7ffff7dd4400 &lt;_IO_2_1_stdout_&gt;, data=0x7ffff7ff7000 ""WORK\n"", to_do=5) at fileops.c:511
#3  0x00007ffff7a8f8b3 in _IO_new_file_overflow (f=0x7ffff7dd4400 &lt;_IO_2_1_stdout_&gt;, ch=10) at fileops.c:876
#4  0x00007ffff7a84f72 in _IO_puts (str=0x4005d4 ""WORK"") at ioputs.c:42
#5  0x000000000040053b in main ()
</code></pre>
",0
33531424,33527864,0,"<p><code>cin &gt;&gt; b;</code> will skip leading whitespace and then read the next word. That's how it is designed.</p>

<p>If you want to read an entire line of input, use <code>getline</code> instead.</p>

<p>It will also be much easier, and a lot safer, if you read into a <code>std::string</code> instead of a fixed size <code>char b[80];</code>. If you ever happen to read more than 80 characters into that, you're toast.</p>
",0
33517334,33514725,0,"<pre><code>cin&gt;&gt;tester1; 
while(!cin) {
    cin.clear();
    cin.sync();
    cout &lt;&lt; ""Please enter an integer!!"" &lt;&lt; endl;
    cout &lt;&lt; "" &gt;&gt;"";
    cin&gt;&gt;tester1;
}
array[counter].registry=tester1;
</code></pre>
",3
33514219,33513875,1,"<p>You can also try this:</p>

<p>take input from user and compare it to random generated value and print output according to it:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
int age;

srand(time(NULL));
int a = rand()%3;
cout&lt;&lt;a&lt;&lt;endl;   // print the random generated number (between 0 and 3 )
cout &lt;&lt; ""How old are you?"" &lt;&lt; endl;
cin &gt;&gt; age;

if (age &lt; 0)
{
    cout &lt;&lt; ""Invalid age"" &lt;&lt; endl;

}

if(age == a){
    cout &lt;&lt; ""Oh you're just a baby"" &lt;&lt; endl;
}else{
    cout &lt;&lt; ""Time to take a nap!"" &lt;&lt; endl;
}


    return 0;
}
</code></pre>
",0
33513973,33513875,1,"<p>try :</p>

<pre><code>#include &lt;cstdlib&gt;
...
...
...
/* initialize random seed: */
srand(time(NULL));

/* generate secret number: */
int ss = rand() % 2;
if (ss) {
    cout &lt;&lt; ""Oh you're just a baby"" &lt;&lt; endl;
} else {
    cout &lt;&lt; ""Time to take a nap!"" &lt;&lt; endl;
}
</code></pre>
",0
33514701,33513875,1,"<p>This uses the STL and only does the random selection from a table, without any user input:</p>

<pre><code>#include &lt;array&gt;
#include &lt;chrono&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

using std::cout;
using std::endl;

int main(void) {
  // The size of the table:
  constexpr size_t n = 2;
  // A table of insults:
  constexpr std::array&lt;const char*, n&gt; insults = {
    ""Oh, you're just a baby!"",
    ""Time to take a nap.""
  };

  // Boilerplate to initialize a RNG:
  const std::default_random_engine::result_type seed = std::chrono::system_clock::now().time_since_epoch().count();
  std::default_random_engine generator (seed);
  // Generate a random index into the string table:
  std::uniform_int_distribution&lt;size_t&gt; distribution(0, n-1);

  // A random number from distribution:
  const size_t x = distribution(generator);
  // Our random string:
  const char* const s = insults[x];

  cout &lt;&lt; s &lt;&lt; endl;

  return EXIT_SUCCESS;
}
</code></pre>
",0
33525646,33525585,2,"<p>You never call set_value() so your member <code>a</code> is uninitialized when you call show_value () and so <code>a</code> will be undefined</p>
",3
33525719,33525585,0,"<p>you can do like this: </p>

<pre><code>class showNum
{
int a;
public:  //change hear
void set_value(int num)
   {
     //change hear
    a=num;
   }

void show_value()
{cout&lt;&lt;a;}
};
main()
{
showNum num1;
num1.set_value(5);//change hear
num1.show_value();
}
</code></pre>
",1
33534230,33534114,1,"<p>You are either printing the address of the function <code>power</code> or printing the uninitialized value of the double <code>power</code> the way you have written the code.  (Technically you are hitting an uninitialized shadowed variable).  In any case, you are not even calling the function you wrote... How does the <code>power</code> function know to be called? With what arguments?</p>

<p>Fix 1. Suggest you delete the 'double' of <code>power</code>.<br>
Fix 2. Actually call the function and use/store/print the result  </p>

<p>example. 
After getting input from user do this:</p>

<pre><code>double result = power( base, exponent );
cout &lt;&lt; result &lt;&lt; endl;
</code></pre>

<p>To print the result.  </p>
",0
33534192,33534114,1,"<p>You need call function like this, with parameters:
Here is your main. You don't need local variable power. You want call function with name power.</p>

<pre><code>int main ()
{    
 double base,esponente;    
 cout&lt;&lt;"" \n Inserisci base \n"";
 cin&gt;&gt;base;
 cout&lt;&lt;""\nInserisci esponente\n"";
 cin&gt;&gt;esponente;                                                   
 cout&lt;&lt;""\nL'elevamento a potenza e': ""&lt;&lt;power(base,esponente)&lt;&lt;endl;
 system (""PAUSE"");                                     
}    
</code></pre>
",1
33534214,33534114,4,"<p>In your code you have two declarations of <code>power</code>.</p>

<p><code>double power(double base, double esponente);</code></p>

<p><code>double base,esponente,power;</code></p>

<p>You declare the variable <code>power</code> but you never initialize it before printing it, so it's going to be undefined. Rerunning your program will actually give you a different number, in all likelihood. You need to remove this local variable declaration, as it shadows the global function declaration.</p>

<p>Then, instead of</p>

<p><code>cout&lt;&lt;""\nL'elevamento a potenza e': ""&lt;&lt;power&lt;&lt;endl;</code></p>

<p>You want this line:</p>

<p><code>cout&lt;&lt;""\nL'elevamento a potenza e': ""&lt;&lt;power(base, esponente)&lt;&lt;endl;</code></p>
",0
34248502,34248446,0,"<p>Start by declaring an array correctly. <code>int array(10)</code> initializes a single integer variable named array to have the value 10.  (Same as saying <code>int array = 10</code>)</p>

<p>You declare an array of 10 integers as follows:</p>

<pre><code>int array[10];
</code></pre>

<p>Anyway, two simple loops and you are done.</p>

<pre><code>int array[10];
cout &lt;&lt; ""Enter 10 numbers"" &lt;&lt; endl;
for (int x = 0; x &lt; 10; x++)
{
    cin &gt;&gt; array[x];
}

int smallest=array[0];
int largest=array[0];

for (int x = 1; x &lt; 10; x++)
{
    if (array[x] &lt; smallest)
    {
         smallest = array[x];
    }
    else if (array[x] &gt; largest)
    {
         largest = array[x];          
    }
}

cout &lt;&lt; ""Largest: "" &lt;&lt; largest &lt;&lt; endl;
cout &lt;&lt; ""Smallest: "" &lt;&lt; smallest &lt;&lt; endl;
</code></pre>

<p>You can actually combine the two for loops above into a single loop. That's an exercise in an optimization that I'll leave up to you.</p>
",0
34248582,34248446,-1,"<p>In this case, you don't actually have to do a binary search, or search the array. Since you will be receiving the input directly from the user, you can keep track of minimum and maximum as you encounter them, as show below. You know the first number you receive will be both the min and max. Then you compare the next number you get with those ones. If it's bigger or smaller, you store it as the max or min respectively. And then so on. I included code to store the number in an array, to check errors and to output the array back to the user, but that's probably not necessary on an exam due to the limited time. I included it as a little bit of extra info for you.</p>

<pre><code>#include &lt;cctype&gt;   // required for isdigit, error checking
#include &lt;cstdlib&gt;  // required for atoi, convert text to an int
#include &lt;iostream&gt; // required for cout, cin, user input and output
#include &lt;string&gt;   // required for string type, easier manipulation of text

int main()
{
  // The number of numbers we need from the user.
  int maxNumbers = 10;

  // A variable to store the user's input before we can check for errors
  std::string userInput;

  // An array to store the user's input
  int userNumbers[maxNumbers];

  // store the largest and smallest number
  int max, min;

  // Counter variables, i is used for the two main loops in the program,
  // while j is used in a loop for error checking
  int i;
  unsigned int j;

  // Prompt the user for input.
  std::cout &lt;&lt; ""Please enter "" &lt;&lt; maxNumbers &lt;&lt; "" numbers: "" &lt;&lt; std::endl;

  // i is used to keep track of the number of valid numbers inputted
  i = 0;

  // Keep waiting for user input until the user enters the maxNumber valid 
  // numbers
  while (i &lt; maxNumbers)
  {
    // Get the user's next number, store it as string so we can check 
    // for errors
    std::cout &lt;&lt; ""Number "" &lt;&lt; (i+1) &lt;&lt; "": "";
    std::cin &gt;&gt; userInput;

    // This variable is used to keep track of whether or not there is
    // an error in the user's input.
    bool validInput = true;

    // Loop through the entire inputted string and check they are all 
    // valid digits
    for (j = 0; j &lt; userInput.length(); j++)
    {
      // Check if the character at pos j in the input is a digit.
      if (!isdigit(userInput.at(j)))
      {
        // This is not a digit, we found an error so we can stop looping
        validInput = false;
        break;
      }
    }

    // If it is a valid number, store it in the array of 
    // numbers inputted by the user.
    if (validInput)
    {
      // We store this number in the array, and increment the number 
      // of valid numbers we got. 
      userNumbers[i] = atoi(userInput.c_str());

      // If this is the first valid input we got, then we have nothing 
      // to compare to yet, so store the input as the max and min
      if (i == 0) 
      {
        min = userNumbers[i];
        max = userNumbers[i];
      }
      else {
        // Is this the smallest int we have seen?
        if (min &lt; userNumbers[i])
        {
          min = userNumbers[i];
        }

        // Is this the largest int we have seen?
        if (max &lt; userNumbers[i])
        {
          max = userNumbers[i];
        }
      }

      i++;
    }
    else
    {
      // This is not a valid number, inform the user of their error.
      std::cout &lt;&lt; ""Invalid number, please enter a valid number."" &lt;&lt; std::endl;
    }
  }

  // Output the user's numbers to them.
  std::cout &lt;&lt; ""Your numbers are: "" &lt;&lt; userNumbers[0];
  for (i = 1; i &lt; maxNumbers; i++)
  {
    std::cout &lt;&lt; "","" &lt;&lt; userNumbers[i];
  }
  std::cout &lt;&lt; ""."" &lt;&lt; std::endl;

  // Output the min and max
  std::cout &lt;&lt; ""Smallest int: "" &lt;&lt; min &lt;&lt; std::endl;
  std::cout &lt;&lt; ""Largest int: "" &lt;&lt; max &lt;&lt; std::endl;
  return 0;
}
</code></pre>
",3
33535340,33535025,1,"<p>You need to build it with MinGW - probably MinGW-w64.  Use MSYS2 to run the install scripts.  It basically mimics a Linux environment on Windows.  Follow the directions in the <code>INSTALL</code> file in the repository.  You should be able to Google the details.  Any decent MSYS2 build tutorial should be helpful.</p>
",0
33536230,33536084,1,"<p>You must set what's the decimal precision to be used, you can do it with stream manipulator <code>setprecision (int n)</code> where <code>n</code> will be the new precision to be used.</p>

<p>You can look at the following example from <a href=""http://www.cplusplus.com/reference/iomanip/setprecision/"" rel=""nofollow"">http://www.cplusplus.com/reference/iomanip/setprecision/</a>:</p>

<pre><code>// setprecision example
#include &lt;iostream&gt;     // std::cout, std::fixed
#include &lt;iomanip&gt;      // std::setprecision



int main () {
     double f =3.14159;
     std::cout &lt;&lt; std::setprecision(5) &lt;&lt; f &lt;&lt; '\n';
     std::cout &lt;&lt; std::setprecision(9) &lt;&lt; f &lt;&lt; '\n';
     std::cout &lt;&lt; std::fixed;
     std::cout &lt;&lt; std::setprecision(5) &lt;&lt; f &lt;&lt; '\n';
     std::cout &lt;&lt; std::setprecision(9) &lt;&lt; f &lt;&lt; '\n';
     return 0;
   } 
</code></pre>

<p>Where the expected output should be:</p>

<pre><code>3.1416
3.14159
3.14159
3.141590000
</code></pre>
",0
33536165,33536084,2,"<p>try <a href=""http://www.cplusplus.com/reference/iomanip/setprecision/"" rel=""nofollow"">setprecision</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
using namespace std;
int main()
{
    double avg = 112964.6;
    cout &lt;&lt; setprecision(9) &lt;&lt; avg &lt;&lt; endl;
}
</code></pre>
",0
33591712,33591430,0,"<p>I'm not sure what it is you are trying to do but here are some tips:</p>

<ul>
<li>Every header file should include all headers that you are going to use for that file or class.</li>
<li>Every cpp file that corresponds to a particular header file should include ONLY that header file.</li>
<li>Your main.cpp should include all headers that you are using for your program.</li>
</ul>

<p>Your code should look something like this:</p>

<pre><code>// main.cpp
#include ""second.h""
#include ""employee.h""

int main(){
//code
}
</code></pre>

<p>In your other files:</p>

<pre><code>//second.h

//includes here
void function();
//---------------------------------------------

//second.cpp
#include ""second.h""

void function(){ //code }

//---------------------------------------------

//employee.h

//includes here

class employee{
public:
     void payment();
//ctor, dtor, and other declarations
}

//---------------------------------------------

//employee.cpp

#include ""employee.h""

void employee::payment(){ //code }

//rest of methods
</code></pre>

<p>Unfortunately, there will be build problems if you include the same header more than once in the same program. So for all header files, you should implement this guard:</p>

<pre><code>#ifndef __MYCLASS_H__
#define __MYCLASS_H__

//includes

class MyClass{
//declarations
}

#endif
</code></pre>
",2
33596739,33596582,0,"<p>I might recommend something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

using std::cout;
using std::cin;
using std::endl;
using std::string;

int main() {
    std::ofstream outputFile(filename); // This will open and close your file. Look up RAII

    string sInput;
    cout &lt;&lt; ""Please Enter the Text "";
    std::getline(cin, sInput); // Get a string from stdin, strip newline.
    // Check if it's a quit condition
    if(sInput == ""x"" || sInput == ""X"") { 
      cout &lt;&lt; ""Entered 'x', now exiting."" &lt;&lt; endl;
      qApp-&gt;quit(); // or something similar
    }
    // If it's not a quit condition, write to file
    outputFile &lt;&lt; sInput &lt;&lt; endl;
    // Once outputFile goes out of scope, it is closed.
    return 0;
}
</code></pre>
",0
33596848,33596582,0,"<pre><code>int main(){

        string sInput;
        std::ofstream outputfile;
        outputFile.open(""C:\\UseCr\\pp\\qt_projects\\test.txt"");
        cout &lt;&lt; ""Please enter the text : ""&lt;&lt;endl;

        do{
            getline(cin,sInput); //it read from the keyboard what the user write and save into sInput variable
            outputfile &lt;&lt; sInput&lt;&lt; endl;
        }while(sInput!= ""X"" || sInput != ""x"");
        outputFile.close();
        }
return 0;
}
</code></pre>

<p>`</p>
",1
29154964,29154904,0,"<pre><code>B(int x) : o(x) {
    cout &lt;&lt; ""\nParameterized constructor of B called.\n"";
    b = x;
}
</code></pre>

<p>Note the intialization of member variable o using the parameter passed into B's constructor.</p>
",2
29154974,29154904,1,"<p>Using <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow"">member initializer lists</a>:</p>

<pre><code>class C
{
private:
    A a;
    int b;

public:
    C(int x) :
        a(x),  // &lt;- Calls the `A` constructor with an argument
        b(x)   // &lt;- Initializes the `b` member to the value of `x`
    { }
};
</code></pre>
",2
29184147,29184060,0,"<p>Store the value that you need into a char variable instead of an Integer variable, as you are asking for character input   </p>

<pre><code> {
    char a;
    int x;
    cout &lt;&lt; ""Please enter the amount of squares"" &lt;&lt; endl;
    cout &lt;&lt; ""Pick a number between 1 and 10"" &lt;&lt; endl;
    cin &gt;&gt; x;
    cout &lt;&lt; ""Now enter a character"" &lt;&lt; endl;
    cin &gt;&gt; a;
    if (x == 1)
        cout &lt;&lt;""\t""&lt;&lt; a &lt;&lt; endl;

    return 0;
    }
</code></pre>
",0
29158717,29158687,2,"<pre><code>string rom_num;
roman = Roman_int(rom_num);
</code></pre>

<p>This expects a <code>Roman_int::Roman_int(const std::string&amp; argument)</code> implemented somewhere. You are calling a constructor which doesn't exist for the class.</p>

<p>Implement it inside the definition:</p>

<pre><code>Roman_int(const std::string&amp; r) : r(r) { }
</code></pre>
",4
29174988,29171600,1,"<p>It's to avoid accidentally providing access to/calling base class methods you don't intend to call. If you explicitly want to ALSO provide the base class methods the language provides that syntax with <code>using Base::function_name;</code>. Alternately if the functions are orthogonal in functionality, don't name them the same thing.</p>
",0
33601729,33601690,4,"<p><code>(char)8</code> is not <code>'8'</code>, but the ASCII value 8 (the backspace character). To display the character 8 you can add it to <code>'0'</code>:</p>

<pre><code>int x = 8;
int y = 17;
char final[2];

final[0] = '0' + x;
final[1] = '0' + (y%10);

cout &lt;&lt; final[0] &lt;&lt; final[1] &lt;&lt; endl;
</code></pre>
",0
33601761,33601690,1,"<p>As per your program you are printing char 8, and char 7.
They are not printable. In fact they are BELL and Backspace characters respectively.
Just run you program and redirect it to a file.
Then do an hexdump, you will see what is printed.<br>
./a.out > /tmp/b<br>
hd /tmp/b<br>
00000000  08 07 0a                                          |...|<br>
00000003  </p>
",1
33601778,33601690,1,"<p>What you need to understand is that in C++, chars are <em>numbers</em>, just like ints, only in a smaller range. When you cast the integer 8 to char, C++ thinks you want a char holding the <em>number</em> 8. If we look at our <a href=""http://www.asciitable.com/"" rel=""nofollow"">handy ASCII table</a>, we can see that 8 is BS (backspace) and 7 is BEL (which sometimes rings a bell when you print it to a terminal). Neither of those are printable, which is why you aren't seeing anything.</p>

<p>If you just want to print the <code>87</code> to standard output, then this code will do that:</p>

<pre><code>cout &lt;&lt; x &lt;&lt; (y%10) &lt;&lt; endl;
</code></pre>

<p>If you really need to convert it chars first, then fear not, it can still be done. I'm not much of a C++ person, but this is the way to do it in C:</p>

<pre><code>char final[2];
snprintf(final, sizeof final, ""%d%d"", x, y % 10);
</code></pre>

<p>(See <a href=""http://linux.die.net/man/3/snprintf"" rel=""nofollow"">snprintf(3)</a>)</p>

<p>This code treats the 2-char array as a string, and writes the two numbers you specified to it using a <code>printf</code> format string. Strings in C normally end with a NUL byte, and if you extended the array to three chars, the final char would be set to NUL. But because we told <code>snprintf</code> how long the string is, it won't write more chars than it can.</p>

<p>This should also work in C++.</p>
",3
32430615,32430557,5,"<p>You need to include this is the <code>main.cpp</code></p>

<p><code>#include ""HelloWorld.h""</code></p>

<p>not the <code>HeloWorld.cc</code> file.</p>
",3
32463674,32430557,2,"<p>You want to have the <em>declarations</em> in the header file, and the <em>implementation</em> separate.  The client code (<code>main</code> in your case) only needs the declarations, so it should include the header:</p>

<pre><code>#include ""World.h""
</code></pre>

<p>Preprocessor includes are very simple; it's little more than replacing the <code>#include</code> line with the contents of the file it names.  When you included the source file <code>World.cc</code>, you caused the definitions to be built with your <code>main.o</code> object file.  Then, when you link <code>main.o</code> with <code>World.o</code>, they both contain definitions for the functions of <code>World.cc</code>.</p>
",0
34260347,34260279,1,"<p>You need to apply <code>const</code> where possible.  For example:</p>

<pre><code>Fraction(const Fraction &amp;);
friend ostream&amp; operator&lt;&lt; (ostream&amp; out, const Fraction&amp; f);
int getM() const;
int getN() const;
</code></pre>

<p>etc.</p>
",0
29213750,29213567,0,"<p>It's not your syntax that's the issue, it's that you're invoking undefined behaviour.</p>

<pre><code>std::string start_choices[num] = { """", ""Home"", ""The Store"", ""Your friend Taylor's place"" };
choices = start_choices;
</code></pre>

<p>When your function exists, the <code>start_choices</code> array will be destroyed, so assigning it to <code>choices</code> and trying to access it outwith the function is undefined.</p>

<p>Instead, copy the data into your <code>choices</code> array:</p>

<pre><code>std::copy (std::begin(start_choices), std::end(start_choices), choices);
</code></pre>

<p>Or alternatively just use <code>std::vector</code> and avoid the headache completely.</p>
",2
33589245,33589188,1,"<p>In the identifiers you have shown, the underscore bears no special meaning. It is simply part of the function name.</p>
",0
33575012,33574937,7,"<p>No, that's not possible. There is no |x| operator (there is no such syntax). || is logical OR.</p>

<p>Generally speaking, it's a good idea to avoid writing code that attempts to change the <strong>syntax</strong> of C++ because it makes the code much less maintainable.  Imagine that you figured out a way to create a |x| operator (I don't think there's a way...).  The next person that read your code who knew C++ would have no idea what that was.</p>
",0
34179336,34171906,0,"<p>Generally when I see code like that I tend to wince a little. The worst case was a single file, 22 thousand lines long and only three functions - that made me sob.</p>

<p>The fact that at the lowest level you have a series of conditions which generally means some sort of type is involved.</p>

<p>So your code will look a bit like:</p>

<pre><code>    If (...) {
       OnTypeConditionOne(...);
     Else if (...) {
       OnTypeConditionTwo(...);
     Else {
       OnTypeConditionThree(...);
     }
</code></pre>

<p>Obviously you pass through whatever variables are needed to perform the subclauses.  You then do the same to those subclauses until you have lots of small files. It is important to name the files something logical otherwise you might get lost in similar sounding names.</p>
",0
33558573,33558487,1,"<p>one problem I can spot:</p>

<pre><code>void addLeaf(int data)
{
    node* curr = root;
.....
        //Check for curr-&gt;left
        if(curr-&gt;left != NULL)
        {
            addLeaf(data);
        }
</code></pre>

<p>your so-called recursion did nothing.  It only keep on calling <code>addLeaf</code> function, and the function keep on checking if root's left is not null and in turn call the <code>addLeaf</code> again.  </p>

<p>Refactor all your code. Don't use any global variable.  Make sure you passed correct parameters (e.g. you should pass the next level node to addLeaf)</p>
",1
33558672,33558487,0,"<p>The <code>addleaf</code> function is going to run infinitely. You only keep adding to the root without any check.
You assign <code>Ptr</code> to <code>root</code>, but then using <code>new</code>, assign it to some new address in memory, which the root does not point to.
You have to pass <code>Ptr</code> by reference to <code>addLeaf</code>, otherwise changes will be made to its copy which is destroyed as <code>addLeaf</code> terminates.
<code>printTree</code> prints the current node value twice (a copy paste error?)</p>

<p>Here is the complete code :</p>

<pre><code>#include ""stdafx.h""
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
using namespace std;

struct node
{
  int data;
  node* left;
  node* right;
};

node* root = NULL;

node* createLeaf(int data)
{
  node* n = new node;
  n-&gt;data = data;
  n-&gt;left = NULL;
  n-&gt;right = NULL;

  return n;
}
void addLeaf(node* &amp;curr, int data)
{
  //If tree is empty, create first node
  if(curr == NULL)
    {
      curr = createLeaf(data);
    }

  //Left(Less than)
  else if(data &lt; curr-&gt;data)
    {
      addLeaf (curr-&gt;left, data);
    }
  //Right(greater than)
  else if(data &gt; curr-&gt;data)
    {
      addLeaf(curr-&gt;right, data);
    }
  else
    {
      cout &lt;&lt; ""The data "" &lt;&lt; data &lt;&lt; "" has already been received\n"";
    }
}

void printTree(node* Ptr)
{


  if(root != NULL)
    {
      if(Ptr-&gt;left != NULL)
        {
      printTree(Ptr-&gt;left);
        }
      cout &lt;&lt; Ptr-&gt;data &lt;&lt; "" "";
      if(Ptr-&gt;right != NULL)
        {
      printTree(Ptr-&gt;right);
        }
    }
  else
    {
      cout &lt;&lt; ""The Tree is empty\n"";
    }


}

int main()
{
  int data[4] = {1, 7, 5, 4};

  for(int i = 0; i &lt; 4; i++)
    {
      addLeaf(root, data[i]);
    }

  printTree(root);

  system(""PAUSE"");
  return 0;
}
</code></pre>
",0
29204264,29204230,4,"<pre><code>for (int a = 0; a &lt;= argc; a++)
//                ^^
</code></pre>

<p>That loop will include <code>a[args]</code> (it's one past the end of the array of arguments) and later dereference it, causing undefined behaviour - which in your case results in access violation. You need to loop while <code>a</code> is <em>less than</em> <code>argc</code>.</p>
",3
29204266,29204230,7,"<pre><code>for (int x = 0; argv[a][x] == '\0'; x++) //counts until x = '\0'
</code></pre>

<p>No, actually, that condition in the middle is the <em>continuation</em> condition, not the termination condition.</p>

<p>You need something like:</p>

<pre><code>for (int x = 0; argv[a][x] != '\0'; x++)
</code></pre>

<p>In addition, that loop prints out the length cumulatively where you probably only want it at the end.</p>

<p>The solution there is to move <code>x</code> to an outer scope and print <em>after</em> the inner loop.</p>

<p>You also want to only process the ""real"" arguments you're given, changing:</p>

<pre><code>for (int a = 0; a &lt;= argc; a++)
</code></pre>

<p>into:</p>

<pre><code>for (int a = 1; a &lt; argc; a++)
</code></pre>

<p>since <code>argv[argc]</code> is stipulated to be NULL and you don't want to dereference that. And <code>argv[0]</code> represents the program name, which you probably don't care about.</p>

<p>That would make your code look something like:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main (int argc, char *argv[]) {
    for (int a = 1; a &lt; argc; a++) {
        int x;
        for (x = 0; argv[a][x] != '\0'; x++)
            ;
        cout &lt;&lt; ""Chars in argument '"" &lt;&lt; argv[a] &lt;&lt; ""' = "" &lt;&lt; x &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>

<p>Running that code with <code>testprog 1 12 123 """" 1234567890</code> gives:</p>

<pre><code>Chars in argument '1' = 1
Chars in argument '12' = 2
Chars in argument '123' = 3
Chars in argument '' = 0
Chars in argument '1234567890' = 10
</code></pre>
",2
29204332,29204230,0,"<p>Here 1st you need to count the number of characters for each argument. So the loop will be till -</p>

<pre><code>a &lt; argc  
</code></pre>

<p>For each argument you need to count the number of characters. So you need to calculate the characters till <code>null value</code>. So the loop will be till -</p>

<pre><code>argv[a][x] != '\0' 
</code></pre>

<p>Now you can just print the number of character for each argument :)</p>

<p>Change this portion :</p>

<pre><code>for (int a = 0; a &lt; argc; a++) //counts until a = number of arguments
                 ^^^
{
    int x;
    for (x = 0; argv[a][x] != '\0' ; x++) //counts until argv[a][x] == '\0'
                   ^^^
    {
        ;
    }
    cout &lt;&lt; ""Number of characters in argument "" &lt;&lt; argv[a] &lt;&lt; "" = "" &lt;&lt; x &lt;&lt;""\n""; //Outputs the argument and string length x
}
</code></pre>

<p>here changed part is indicated by <code>^^^</code></p>
",0
33596508,33596092,1,"<p>The standard advice in a situation like this is to use a debugger and figure out what's going wrong.</p>

<p>IMO, in a case like this that's fairly poor advice. Even when you debug the code and correct the problem you've observed, it's still going to be code that (I hope) you won't like in a few months or so.</p>

<p>To make a long story short, you're not making very good use of the language and standard library--you're doing a lot of work to duplicate capabilities it already has ready for you to use, and you're using some non-standard (and non-portable) extensions of one specific compiler for no particularly good reason.</p>

<p>I'd probably do something more like this:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

// We'll use this a little later: just ""eat"" all the leading white-space
// from a stream.
std::istream &amp;eat_whitespace(std::istream &amp;is) {
    char ch;
    while (isspace(is.peek()))
        is.get(ch);
    return is;
}

// define a class to store, read, write, and compare people's names:
class name {
    std::string first;
    std::string last;
public:
    // Define how to read a name from a stream:
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, name &amp;n) {
        is &gt;&gt; n.first;
        eat_whitespace(is);
        return std::getline(is, n.last);
    }

    // likewise, how to write a name to a stream:
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, name const &amp;n) {
        return os &lt;&lt; n.first &lt;&lt; ' ' &lt;&lt; n.last;
    }

    // Define how to compare two names. This will compare first by last name,
    // then if those are equal, first names:
    bool operator&lt;(name const &amp;other) const {
        if (other.last &lt; last)
            return false;
        if (last &lt; other.last)
            return true;
        return first &lt; other.first;
    }
};

int main() {
    // Read the names from a file into a vector:
    std::vector&lt;name&gt; names { std::istream_iterator&lt;name&gt;(std::cin),
        std::istream_iterator&lt;name&gt;() };

    // Sort them:
    std::sort(names.begin(), names.end());

    // Write out the results:
    for (auto const &amp;n : names)
        std::cout &lt;&lt; n &lt;&lt; ""\n"";
}
</code></pre>

<p>Probably the single most important point here is having encapsulated all the ""knowledge"" of a <code>name</code> into the <code>name</code> class. This lets the rest of the program just read, compare and write <code>name</code> as a complete things, instead of dealing with all the internal details of how a name is stored (and such). The rest of the program doesn't care (or need to know) anything about how a <code>name</code> works internally.</p>

<p>Also note how it's split up into a number of separate functions instead of having nearly everything in one giant function. In this case, each function is so small and simple (and its purpose simple enough) that for nearly all of them, most real problems would be pretty obvious almost at first glance.</p>

<p>Then there's that last piece: leaving as much of the work as we can to the standard library. Just for the most obvious example, it already has code to sort things--we don't need to write a sort of our own.</p>
",0
29245183,29244708,3,"<p>Both are ""correct"" in that they recover from failed inputs and give the user another chance.</p>

<p>Both are only useful for interactive input.  You mention reading from a file -- there's really no recovery possible.  Ignoring a mangled field will simply cause the next field to be consumed and <strong>interpreted differently from what its location in the file indicates</strong>.  Best course of action when reading from a file is to output as good an explanation as possible (exactly where in the file the error occurred, e.g. line and columns numbers, what kind of data was expected, and what about the data encountered was invalid).</p>

<p>In interactive usage, clearing the buffer and prompting again is useful.. Your version has the disadvantage that after entering a length correctly, if the user fat-fingers the width, they can't just re-enter the wrong data, but have to type the length a second time as well.</p>

<p>Writing the loop a second time is incredibly pointless, however.  Instead you should write a helper function, something like:</p>

<pre><code>template&lt;typename T&gt;
T prompt_for_value( const char* const prompt )
{
    T result;
    while (true) {
         std::cout &lt;&lt; prompt &lt;&lt; std::flush;
         if (std::cin &gt;&gt; result) return result;
         std::cout &lt;&lt; ""Bad input, try again"" &lt;&lt; std::endl;
    }
}

double width = prompt_for_value&lt;double&gt;(""Enter the width in meters: "");
double height = prompt_for_value&lt;double&gt;(""Enter the height: "");
</code></pre>

<p>Notice that the code is shorter overall and avoids the clunky use of the <code>good</code> variable which inverted its meaning halfway through the original code.  Also, the call site now is very clean and focuses completely on the important information -- the prompt and the data type of the input.</p>

<p>Thanks the C++11 lambda support, it's now also very easy to add parameter validation to the helper function:</p>

<pre><code>T prompt_for_value( const char* const prompt, std::function&lt;bool(T)&gt; validation = {} )
{
    T result;
    while (true) {
         std::cout &lt;&lt; prompt &lt;&lt; std::flush;
         if (std::cin &gt;&gt; result) {
             if (validation &amp;&amp; !validation(result)) {
                 std::cout &lt;&lt; ""Input out of range, try again"" &lt;&lt; std::endl;
                 continue;
             }
             return result;
         }
         std::cout &lt;&lt; ""Bad input, try again"" &lt;&lt; std::endl;
    }
}

double width = prompt_for_value&lt;double&gt;(""Enter the width in meters: "",
                                        [](int w) { return w &gt;= 0; });
double height = prompt_for_value&lt;double&gt;(""Enter the height: "",
                     [&amp;width](int h) { return (h &gt;= 0) &amp;&amp; (h &lt;= 10000.0 / width); }));
</code></pre>
",1
29246429,29244708,0,"<p>What you have indicated as your professor's proposed method is very bad form as given due to violation of the <a href=""http://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself"" rel=""nofollow"">don't-repeat-yourself (DRY) principle</a> in the code.  If you want to do basically the same thing multiple times, you should either use a loop or a function to avoid writing duplicate logic.</p>

<p>Your method involves all-or-nothing checking and therefore may require the <em>user</em> to repeat themselves.  The usability of this should be decided on a case-by-case basis.</p>

<p>Both methods fail to detect extraneous characters at the end of the input line.  Such input might reasonably be interpreted as erroneous -- regardless of whether or not it happens to work with the subsequent input request.</p>

<p>However, as you have demonstrated, the all-or-nothing approach does in fact basically work.  Given that, here's an alternative all-or-nothing implementation based on the automatic exception-based checking that the <a href=""http://en.wikipedia.org/wiki/Input/output_(C%2B%2B)"" rel=""nofollow"">iostream library</a> is capable of.</p>

<pre><code>   cin.exceptions( ~std::ios::goodbit );

   int length=0, width=0;

   for ( bool ok=false; !ok; )
      {
      try
         {

         cout &lt;&lt; ""Enter the length and the width of the rectangle: "";
         cin &gt;&gt; std::skipws &gt;&gt; length &gt;&gt; width;

         std::string s;
         std::getline( cin, s );
         s.erase( std::remove_if( s.begin(), s.end(), ::isspace ), s.end() );
         if ( !s.empty() ) throw std::runtime_error(""too much input"");

         ok = true;
         }
      catch( std::ios::failure const &amp; e )
         {
         cout&lt;&lt;""\n""&lt;&lt;""bad input [""&lt;&lt;e.what()&lt;&lt;""], try again...\n"";
         cin.clear();
         cin.ignore( std::numeric_limits&lt;std::streamsize&gt;::max(), '\n' );
         }
      catch( std::runtime_error const &amp; e )
         {
         cout&lt;&lt;""\n""&lt;&lt;e.what()&lt;&lt;"", try again...\n"";
         }
      }

   cout&lt;&lt;""\n""&lt;&lt;""length=""&lt;&lt;length&lt;&lt;"", width=""&lt;&lt;width&lt;&lt;""\n"";
</code></pre>

<p>Output:</p>

<pre><code>Enter the length and the width of the rectangle: x

bad input [basic_ios::clear], try again...
Enter the length and the width of the rectangle: 1 x

bad input [basic_ios::clear], try again...
Enter the length and the width of the rectangle: 1 2 x

too much input, try again...
Enter the length and the width of the rectangle: 1 2 3

too much input, try again...
Enter the length and the width of the rectangle: 4 5

length=4, width=5
</code></pre>
",3
29253383,29253271,2,"<p>You didn't proper initialization of instance variable ""pos"" of class ""Stack"". This means that initially it can have any value. If that value is beyond the range of your ""employeeList"", you are accessing an area of memory that does not belong to you. That's probably a segmentation error.</p>
",0
33559504,33559456,1,"<pre><code>string str(""hang man"");
for (auto it = str.begin(); it != str.end(); ++it)
{
    if (*it!=' ')
    {
        *it = '_';
    }
}
</code></pre>
",2
33559526,33559456,1,"<p>Simple example of doing it with C++ standard library algorithms:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() 
{
    std::string str = "" this is a   test;?"";
    std::transform(str.begin(), str.end(), str.begin(),
        [](char c){return  c != ' ' ? '_' : ' ';});

    // this also does it
    /* std::for_each(str.begin(), str.end(), 
        [](char&amp; c){if(c != ' ') c = '_';});
    */

    std::cout &lt;&lt; str;
}
</code></pre>
",6
33559595,33559456,1,"<p>Here's yet another alternative using the standard library algorithm <a href=""http://en.cppreference.com/w/cpp/algorithm/replace"" rel=""nofollow""><code>std::replace_if</code></a>. I like this solution because the name of the algorithm is meaningful and clearly says what it does.</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string str = ""I like turtles"";

    std::replace_if(str.begin(), str.end(), [](char ch){ return ch != ' '; }, '_');

    std::cout &lt;&lt; str &lt;&lt; '\n';
}
</code></pre>
",0
32432523,32432470,0,"<p>It is a shared pointer so you can use 
<code>*name = ""Your Text""</code></p>

<pre><code>std::cout &lt;&lt; *name;
</code></pre>

<p>and so on</p>
",0
34257004,34256732,0,"<p>added</p>

<pre><code>if (cin.fail())
{
    cin.clear();
    cin.ignore(numeric_limits&lt;int&gt;::max(), '\n');
}
</code></pre>

<p>To clear the invalid input and buffer. Found info on cplusplus.com/forum/beginner/2957/</p>
",0
34246012,34245455,0,"<p>To answer the <em>title</em> of your question, you can use the <code>fread</code> method of <code>std::istream</code>:  </p>

<pre><code>std::string filename;
std::cout &lt;&lt; ""Enter name of file to read: "";
std::getline(std::cin, filename);
uint8_t    data_buffer[1024*1024]; // Reserve some space.
std::ifstream input_file(filename.c_str());
input_file.read(&amp;data_buffer[0], sizeof(data_buffer));
</code></pre>
",0
30696397,30696345,1,"<p>No, you can't do that. </p>

<p>The closest functionality is to use a map.</p>

<pre><code>std::map&lt;std::string, int&gt; aMap;
</code></pre>
",0
33558606,33558574,0,"<p>difference is more understandable in context of function.
float - pass by value
float&amp; - pass by reference (does not assign new memory, points to same value as original)</p>
",0
33558928,33558574,0,"<p><code>float var1; float&amp; var2=var1;</code> means to make a float variable with two names, <code>var1</code> and <code>var2</code>.</p>

<p>It is exactly the same as <code>float var2; float &amp;var1 = var2;</code> except for the result of <code>decltype</code></p>

<p>To make a copy you would write: <code>float var3 = var1;</code></p>
",0
34189127,34188978,0,"<p><code>inFile.get(c1)</code> Reads one character and stores it to c1 if available. Otherwise, leaves ch unmodified and sets failbit and eofbit.</p>

<p>You can use <code>inFile.eof()</code> to check whether the end of the file has been reached.</p>
",0
33511478,33511462,1,"<p>You are passing the same counter variables <strong>by reference</strong> to your function <code>lab14</code> without resetting them to zero between subsequent calls. This means that the counts are never reset the next time you call that function and so the totals keep on building giving you incorrect values on all but the first function call.</p>

<p>Add</p>

<pre><code>even = 0;
odd = 0; 
zero = 0;
</code></pre>

<p>at the end of your loop after your <code>cout</code> calls to reset the variables. Alternatively zero them inside your <code>lab14</code> function before the <code>while</code> loop.</p>

<p>Incidentally, you have 3 return statments in that function - 2 of which are never reached.</p>
",0
33511700,33511462,1,"<p>Here you are.</p>

<pre><code>#include &lt;iostream&gt;

void lab14( unsigned long long int num, unsigned int &amp;even, unsigned int &amp;odd, unsigned int &amp;zero )
{
    const unsigned long long Base = 10;

    even = odd = zero = 0;

    do
    {
        long long int digit = num % Base;

        if ( digit % 2 != 0 ) ++odd;
        else digit == 0 ? ++zero : ++even;
    } while ( num /= Base );        
}

int main()
{
    std::cout &lt;&lt; ""#############################"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""## Even, odd, zero counter "" &lt;&lt; std::endl &lt;&lt; std::endl;;


    while ( true )
    {
        std::cout &lt;&lt; ""## Please enter a # (0-exit): ""; 

        unsigned long long int num = 0;
        std::cin &gt;&gt;num;

        if ( !num ) break;

        unsigned int even, odd, zero;

        lab14( num, even, odd, zero );

        std::cout &lt;&lt; ""## Even numbers: ""&lt;&lt;  even &lt;&lt; std::endl
                  &lt;&lt; ""## Odd Numbers: "" &lt;&lt; odd &lt;&lt; std::endl
                  &lt;&lt; ""## Zeros: "" &lt;&lt; zero &lt;&lt; std::endl;

        std::cout &lt;&lt; std::endl;            
    }

    return 0;
}
</code></pre>

<p>If to enter </p>

<pre><code>123456789012345678 
</code></pre>

<p>and then </p>

<pre><code>0
</code></pre>

<p>then the output will be</p>

<pre><code>#############################
## Even, odd, zero counter 

## Please enter a # (0-exit): 123456789012345678
## Even numbers: 8
## Odd Numbers: 9
## Zeros: 1

## Please enter a # (0-exit): 0
</code></pre>

<p>As for your function then I think that it is too complicated with the three return statements:)</p>

<pre><code>return odd;
return even;
return zero;
</code></pre>

<p>They would be enough for three separate functions.</p>

<p>As for me then I decided that the function does not require a return statement.</p>
",0
33521748,33521007,2,"<p>Following code will cater the purpose.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;

int main()
{
  int n;
  std::cin &gt;&gt; n;

  std::set&lt;std::string&gt; redact;
  std::string word;
  for(int i = 0; i &lt; n; ++i)
  {
    std::cin &gt;&gt; word;
    redact.insert(word);
  }
 while( std::cin&gt;&gt; word &amp;&amp; word != ""END"" )
 { 
     if ( redact.find(word) == redact.end() )
        std::cout&lt;&lt;word&lt;&lt;' ';
 }
 std::cout&lt;&lt;'\n';
return 0;
}
</code></pre>

<p>I believe you are a learning C++, please note a point use <code>typesafe</code>, <code>bound-safe</code> and <code>scope-safe</code> C++. </p>

<p>So, no <code>new</code> <code>delete</code> unless you can call yourself an <code>adept</code>. Use the algorithms and containers provided by C++, instead of inventing your own. </p>
",0
33514824,33513908,2,"<p>You can try this by <strong>vector</strong> and <strong>pair</strong> in c++. You can learn <a href=""http://www.cplusplus.com/reference/vector/vector/vector/"" rel=""nofollow"">vector</a> and <a href=""http://www.cplusplus.com/reference/utility/pair/pair/"" rel=""nofollow"">pair</a> from this.</p>

<p>It's ok now, exactly what you wanted:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int main ()
{
    vector &lt; pair &lt;double, double&gt; &gt; v;

    int N = 4;
    for (int i=0; i&lt;N; i++)
    {
        double x,y;
        scanf(""(%lf,%lf)"", &amp;x, &amp;y);
        v.push_back(pair &lt;double, double&gt;(x,y));
        getchar();
    }

    cout&lt;&lt; ""X := [""&lt;&lt; v[0].first;
    for (int i=1; i&lt;N; i++)
        cout&lt;&lt;"" ,""&lt;&lt;v[i].first;
    cout&lt;&lt; ""]""&lt;&lt;endl;

    cout&lt;&lt; ""Y := [""&lt;&lt; v[0].second;
    for (int i=1; i&lt;N; i++)
        cout&lt;&lt;"" ,""&lt;&lt;v[i].second;
    cout&lt;&lt; ""]""&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>Input:</p>

<pre><code>(0.5,1) (0.6,1.5) (0.7,2) (0.8,2.5)
</code></pre>

<p>Output:</p>

<pre><code>X := [0.5, 0.6, 0.7, 0.8]
Y := [1, 1.5, 2, 2.5]
</code></pre>
",0
33515446,33513908,0,"<p>First of all, I think all suggestions of using vector and pair c++ stl are absolutely right. However, considering that mid_code just begins his journey of programming, I think <strong>using arrays is a good way to practise</strong>. I think you could use two double arrays to store information about points.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;iostream&gt;
using namespace std;

int main()
{
    int n;
    char c;

    cin &gt;&gt; c &gt;&gt; c &gt;&gt; n;
    // store x, y coordinates in two separated arrays.
    double *x = new double[n];
    double *y = new double[n];
    for (int i = 0; i &lt; n; i++) {
        // Read x, y coordiantes and ignore the parenthesis and comma.
        cin &gt;&gt; c &gt;&gt; x[i] &gt;&gt; c &gt;&gt; y[i] &gt;&gt; c;
    }

    cout &lt;&lt; ""X := ["";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; x[i];
        // Here worth beginner's attention.
        if (i &lt; n - 1) {
            cout &lt;&lt; "", "";
        }
    }
    cout &lt;&lt; ""]"" &lt;&lt; endl;

    cout &lt;&lt; ""Y := ["";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; y[i];
        if (i &lt; n - 1) {
            cout &lt;&lt; "", "";
        }
    }
    cout &lt;&lt; ""]"" &lt;&lt; endl;

    return 0;
}
</code></pre>
",1
34245918,34244736,2,"<p>You got wrong answer because of <strong>int</strong> overflow.</p>

<p><em>Lets give you an example</em></p>

<p>Lets say your input like below</p>

<pre><code>4
* 432
* 422
* 432
% 8
</code></pre>

<p>your program will give wrong answer because </p>

<p>after first input, ans = 4 * 432 = 1728</p>

<p>after second input, ans = 1732 * 432 = 746496 (which is greater than <em>int</em>  highest range, it occurs int overflow and gives you wrong answer)</p>

<p>For this reason, we can use below modular arithmetic formula so that we can leave <em>int</em> overflow.</p>

<ol>
<li>(A + B) % R = (A % R + B % R) % R</li>
<li>(A * B) % R = (A % R * B % R) % R </li>
</ol>

<p>For Your Information,
(26+3*2)%3 = (26%3 + 3%3 * 2%3) % 3</p>

<p><strong>Try this</strong></p>

<pre><code>#include &lt;iostream&gt;
#define MAX 100 // guess at most 100 lines input
using namespace std;
int main()
{
    int num1, count = 0, num2[MAX];
    char oper[MAX];
    cin &gt;&gt; num1;

    do{
       cin &gt;&gt; oper[count] &gt;&gt; num2[count];
       count = count + 1;
    }while(oper[count -1 ] != '%');

    int ans = num1, remainder = num2[count - 1]; // last number is remainder value

    for(int i = 0; i &lt; count - 1; i++)
    {
       if(oper[i] == '+')
          ans = (ans % remainder + num2[i] % remainder) % remainder;
       if(oper[i] == '*')
         ans = (ans % remainder * num2[i] % remainder) % remainder;
    }

    cout &lt;&lt; ans &lt;&lt; endl;
 }
</code></pre>
",3
32406421,29327167,0,"<p>Side nitpick: The <code>SAFE_DELETE_VECTOR</code> macro is horrible and has no place in C++ code. It won't help you with speeding anything up.</p>

<p>You should have an anonymous namespace function instead, without the redundant empty check:</p>

<pre><code>namespace {
template &lt;typename C&gt; void safeDelete(C &amp; container) {
  for (auto &amp; slot : container) {
    delete slot;
    slot = nullptr;
  }
}
}
</code></pre>
",0
33534133,33533999,0,"<p>You need put a semicolon after every line, like this:</p>

<p>return 0;</p>
",0
33556749,33556690,3,"<p>If <code>Home::input</code> and <code>Home::output</code> don't require implementations, make them pure virtual functions:</p>

<pre><code>virtual void input() = 0;
virtual void output() = 0;
</code></pre>

<p>Otherwise, you need to define an implementation for them in <code>Home</code> so the linker doesn't complain about it:</p>

<pre><code>virtual void input() { /* code */ }
virtual void output() { /* code */ }
</code></pre>

<p>You will also need to make the signatures of <code>input</code> and <code>output</code> the same for the base class <code>Home</code> and derived class <code>Ocelot</code>. Either add the stream parameters to the signatures of <code>Home::input</code> and <code>Home::output</code> or remove them from <code>Ocelot::input</code> and <code>Ocelot::output</code>.</p>

<p>Additionally: <code>list&lt;Home&gt;</code> will cause problems for you; you will need to use <code>list&lt;Home*&gt;</code> instead so the base class (which is now abstract because of the pure virtual functions) is not being instantiated.</p>
",4
33556900,33556690,0,"<blockquote>
  <p>list animals;</p>
</blockquote>

<p>You cannot do this if <code>Home</code> is an abstract class. std containers cannot hold abstract classes (interfaces), simply because these cannot be constructed or instanciated. What you can do is:</p>

<pre><code>list&lt;Home*&gt; animals;
</code></pre>

<p>Apart from this, make your <code>input()</code> and <code>output()</code> methods pure virtual (<code>=0;</code>) and do implement them in child classes that inherit the <code>Home</code> interface.</p>
",0
33583286,33583215,0,"<p>As mentioned in the comments, you need to use <code>to_string</code> to convert the <code>int</code> to <code>string</code> first:</p>

<pre><code>mainmenutext += std::to_string(userAppID) + userAppName;
</code></pre>
",3
34235872,34235836,1,"<p>I think the problem is with your cast. Try:</p>

<pre><code>double Averager::getAverage()
{
    return (double)sum / count;
}
</code></pre>
",0
34200222,34200181,1,"<p>That's because your <code>operator=</code> can't bind to temporaries.</p>

<p>You should define it like this:</p>

<pre><code>Fraction &amp; Fraction::operator = (const Fraction &amp;A)
</code></pre>

<p>so, it will bind to temporaries and constant objects and literals.</p>
",0
34200232,34200181,2,"<p>Your assignment operator is declared to take a reference to a non-const <code>Fraction</code>. Your addition operator returns by-value, so you are trying to assign a temporary to <code>frac_c</code>. Temporaries can not bind to non-const references.</p>

<p>The fix is to make your assignment operator take by const-reference:</p>

<pre><code>Fraction &amp; operator = (const Fraction &amp;);
</code></pre>
",3
34200274,34200181,0,"<p>You defined the assignment <code>operator=</code> to take an lvalue reference as argument, but tried to pass it a temporary. Temporaries only bind to <strong>const</strong> references or rvalue references.</p>

<p>You should read up on how to overload operators in a usable way, e.g. the same problem occurs with the nonconst lvalue references accepted by your <code>operator+</code>.</p>

<p>That means, use <code>Fraction&amp; operator=(Fraction const&amp;)</code> and <code>Fraction operator+(Fraction const&amp;, Fraction const&amp;)</code>. </p>
",1
33582738,33582641,0,"<p>Yes you do need a courier class. Now to tell your class if courier is required or not you have two ways. You can create a constructor in your class which takes Courier class object as null.Some thing like </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class {
    public:
    Courier();
};
Courier::Courier(){

};

class COverNightPackage {
    public:
    COverNightPackage(Courier* obj);
};

COverNightPackage::COverNightPackage(Courier* obj){
        if(obj == NULL){
            cout&lt;&lt;""Courier is null""&lt;&lt;""\n"";
        }else{
            cout&lt;&lt;""Courier is not null""&lt;""\n""; \\ Store package info here
        }

};
int main() {
    Courier* o2 = new Courier();
    COverNightPackage* o1 = new COverNightPackage(NULL);
    COverNightPackage* o3 = new COverNightPackage(o2);
    return 0;
}
</code></pre>

<p>Now you can store its value as per your convenience. While showing the value you can check if courier class is null or not.</p>

<p>Second way could be to keep a Courier class object inside your class and provide a setter to help the user to set value at runtime.
Hope it will help you :-) </p>
",2
33582978,33582641,0,"<p>Indeed, you will need a <code>Courier</code> class, and you should store a pointer to this <code>Courier</code> class within your <code>COverNightPackage</code> class.  You just want to be sure that this pointer is set to <code>NULL</code> when there is no <code>Courier</code>.  To do this, you should create two constructors for your <code>COverNightPackage</code>.  Use initializers for each constructor to be sure that the pointer to the <code>Courier</code> class is either initialized to <code>NULL</code> or pointing to a <code>Courier</code> class.</p>

<pre><code>class Courier;

class COverNightPackage: public CPackages {
public:
  COverNightPackage()
   : m_courier(NULL)
  { }

  COverNightPackage(Courier* courier)
   : m_courier(courier)
  { }

private:
  Courier* m_courier;
}
</code></pre>

<p>Alternatively, you can accomplish this using a single constructor with a default argument of <code>NULL</code></p>

<pre><code>class Courier;

class COverNightPackage: public CPackages {
public:
  COverNightPackage(Courier* courier = NULL)
   : m_courier(courier) { }

private:
  Courier* m_courier;
}
</code></pre>

<p>If the constructor is called with no argument, the <code>Courier</code> pointer will be initialized to <code>NULL</code></p>
",0
33524807,33524678,1,"<p>Your problem is you never change the question in <code>askQuestion</code>.  You have the question hardcoded</p>

<pre><code>cout &lt;&lt; ""What does cout do?"" &lt;&lt; endl;
</code></pre>

<p>What you should have is</p>

<pre><code>cout &lt;&lt; Question_Text &lt;&lt; endl;
</code></pre>
",0
29472844,29472747,2,"<p>Constructors and destructors can't return anything. Perhaps you can store the return value in a public property of the class the constructor is for, and provide an alternate function to get that property.</p>
",3
29472990,29472747,0,"<p>Constructors cannot return anything (the only <code>return</code> statement allowed is one with no expression, so nothing is returned to the caller (i.e. <code>return;</code>).</p>

<p>A common way to report errors from a constructor is to throw an exception.</p>
",0
33553044,33552688,2,"<p>I am guessing by:</p>

<pre><code>vector.length=0 
</code></pre>

<p>you are trying to initialize a vector object that is initially empty; </p>

<p>for that you will need to do:  </p>

<pre><code>Vector vector;
vector.length=0;
</code></pre>
",1
33553117,33552688,2,"<p>Actually <code>vector</code> is really not declared in this scope... The compiler does now what type vector is.</p>

<p>First declare a variable, and then use it.</p>

<pre><code>Vector vector;
// your code 
</code></pre>
",0
33553397,33552688,1,"<p>The structure definition included from header file is just a definition i.e. a new user defined data type. However to use this datatype you need to create/declare an object/variable.
As suggested in previous answers you need to declare a variable of this structure/data type(just like declaring 'int i' for using an integer variable named 'i') before using it - in your case would be 'vector'.
Just declare a variable in the beginning of the function</p>

<pre><code>Vector vector;
</code></pre>
",0
29464180,29463888,0,"<p>You should try to debug through your code using a debugger to see what is going on.</p>

<p>One thing that jumps out is that you don't use the return value from <code>deleteAux</code> in your first call, so if deleteAux changes what the root should be you won't have the right root value. Try changing your <code>remove</code> function to:</p>

<pre><code>myRoot = deleteAux(myRoot,value);
</code></pre>
",0
33569757,33569509,0,"<p>Perhaps you could use a <code>std::stringstream</code>:</p>

<pre><code>std::string hexString = ""0x2901"";
std::istringstream instream(hexString);
unsigned int receiver = 0;
instream &gt;&gt; std::hex &gt;&gt; receiver;
std::cout &lt;&lt; ""Value parsed: "" &lt;&lt; receiver &lt;&lt; std::endl;
std::cout &lt;&lt; ""Should be 10497"" &lt;&lt; std::endl;
</code></pre>

<p>Output:</p>

<blockquote>
  <p>Value parsed: 10497 <br/>
  Should be 10497</p>
</blockquote>

<p><a href=""http://coliru.stacked-crooked.com/a/feb9af9bc4fd74b0"" rel=""nofollow"">Live Demo</a></p>
",3
33569832,33569509,0,"<p>You can try also C style (<code>sscanf</code> function), like that:</p>

<pre class=""lang-cpp prettyprint-override""><code>    std::string hex = ""0x2901"";
    unsigned int x;
    sscanf(hex.c_str(), ""%x"", &amp;x);
    printf(""%#X = %u\n"", x, x);
</code></pre>

<p><code>sscanf</code> allows checking in the following style:</p>

<pre class=""lang-cpp prettyprint-override""><code>    std::string hex = ""0x2901"";
    unsigned int x = 0;
    if ( sscanf(hex.c_str(), ""%x"", &amp;x) == 1) 
    {
        printf(""%#X = %u\n"", x, x);
    }
    else
    {
        printf(""Incorrect string value\n"");
    }
</code></pre>
",0
34085035,34083747,1,"<p>There are a number of different ways of doing this but it's tricky to offer a 'better' solution without knowing why simply using a bit mask is a problem. For example, you could use a helper function along the lines of:</p>

<pre><code>template&lt; typename BITS&gt; inline BITS set_bit(BITS data, size_t pos, bool val)
{
    return ( val ) ? data | ( 1 &lt;&lt; pos ) : data &amp; ~ ( 1 &lt;&lt; pos );
}

unsigned int a = 128;
a = set_bit(a, 0, true);
std::cout &lt;&lt; a &lt;&lt; std::endl;   // gives 129 = 10000001
a = set_bit(a, 4, true);
std::cout &lt;&lt; a &lt;&lt; std::endl;   // gives 145 = 10010001
a = set_bit(a, 7, false);
std::cout &lt;&lt; a &lt;&lt; std::endl;   // gives 17  = 00010001
</code></pre>

<p>(Note that I've not added any bounds checking to this on the <code>pos</code> parameter)</p>

<p>Another way to do this might be to use a <em>bitfield</em> which allows you to declare variable names for individual bit and groups of bits of a larger type as follows:</p>

<pre><code>struct MyBits {
    unsigned int alpha : 1,
                 beta : 1,
                 gamma : 1;
};

MyBits b;
b.alpha = 1;
b.gamma = 1;

std::cout &lt;&lt; b.alpha &lt;&lt; std::endl;  // gives 1
std::cout &lt;&lt; b.beta &lt;&lt; std::endl;   // gives 0
std::cout &lt;&lt; b.gamma &lt;&lt; std::endl;  // gives 1
</code></pre>

<p>A third way - although this is not strictly using an <code>int</code> as such - might be to use a <em>bitset</em> to achieve a similar job:</p>

<pre><code>#include &lt;bitset&gt;

std::bitset&lt;8&gt; c;
c[0] = true;
c[2] = true;

std::cout &lt;&lt; c[0] &lt;&lt; std::endl; // gives 1
std::cout &lt;&lt; c[1] &lt;&lt; std::endl; // gives 0
std::cout &lt;&lt; c[2] &lt;&lt; std::endl; // gives 1
</code></pre>

<p>All have their advantages and disadvantages. It largely depends on the motivating factors behind your question. </p>
",0
34086274,34083747,0,"<p>In C++ (and computers in general) you have two types of operations: numerical and bit operations. Since you want to avoid the latter, you have to use the former.</p>

<p>Luckily there's a simple association between bits and numbers. Bits in an integer correspond to powers of two. The lowest bit represents 2^0=1, the next one 2^1=2 etcetera.</p>

<p>We need to start with the highest power of two:</p>

<pre><code>int p2 = (INT_MAX - INT_MAX/2);
</code></pre>

<p>and then copy every set bit over:</p>

<pre><code>int result = 0
while (p2 &gt; 0)
{
    if (a&gt;p2) // This bit is set in a2, copy it.
    {
         result += p2;
         a -= p2;
    }
    p2 /= 2;
}
</code></pre>

<p>except when p2 is the bit you want to set, of course. I'll leave that part of the exercise to you.</p>
",0
29500730,29500704,2,"<p>You can simply do:</p>

<pre><code>while(in &gt;&gt; i &gt;&gt; c &gt;&gt; s &gt;&gt; f)
{
    cout &lt;&lt; ""\nInteger:"" &lt;&lt; i &lt;&lt; "", Character: "" &lt;&lt; c &lt;&lt; "", String: "" 
         &lt;&lt; s &lt;&lt; "", Float: "" &lt;&lt; f &lt;&lt; endl; 
}
</code></pre>

<hr>

<p>If your values are comma-separated, you can use a <code>std::stringstream</code>/<code>std::getline</code> combination to parse the tokens (<code>std::getline</code> allows specifying a separator), like so:</p>

<pre><code>std::stringstream ss; // from &lt;sstream&gt;
int field = 0; 
while (std::getline(in, ss, ','))
{
    switch (field)
    {
    case 0:
        ss &gt;&gt; i; 
        break;
    case 1:
        ss &gt;&gt; c;
        break;
    case 2: 
        ss &gt;&gt; s;
        break;
    case 3:
        ss &gt;&gt; f;
        break;
    }
    if(++field == 4)
        field = 0;
}
</code></pre>

<p>Or, you can read the whole line, remove the commas (<code>std::remove_if</code>), send the transformed line into a <code>stringstream</code>, then do <code>ss &gt;&gt; i &gt;&gt; c &gt;&gt; s &gt;&gt; f</code>.</p>
",11
29454069,29454023,0,"<p>Yes. It is best to assume there will be subclasses that have destructors that need to be run, so the virtual destructor needs to exist in <code>Base</code>. Also, even in scenarios where you don't have code in any destructors, other things are expected to happen on destruction.</p>

<pre><code>class Derived : public Base {
    MyMember m;
}
</code></pre>

<p>With no virtual destructor on <code>Base</code>, the destructor of <code>m</code> will never be called when you delete polymorphically (deleting it as a <code>Base*</code>).</p>

<p>If you plan to allow subclassing of <code>Base</code> for arbitrary subclasses, you need <code>Base</code> to have a virtual destructor in order to safely delete these subclasses. </p>

<p>It is not recommended to consider a nonvirtual destructor for <code>Base</code> because you would need to guarantee that all subclasses not only have no destructor, but also that they all have <em>no members with destructors</em>... that means no stl containers or anything else in the object. It's very easy for such strange requirements to be missed by other developers, so you should just have a virtual destructor in <code>Base</code>.</p>
",0
29454076,29454023,0,"<p>You only need to make the destructor of the base class virtual. Derived classes can define the destructor explicitly or use the implicit one defined by the constructor.</p>

<pre><code>struct Base
{
   virtual ~Base() {}
};

struct Derived1 : public Base
{
   // Explicitly defined destructor.
   // Use of virtual is optional.
   ~Derived () {}
   std::vector&lt;std::string&gt;&gt; data;
};

struct Derived2 : public Base
{
   // Use the compiler defined destructor
   std::vector&lt;int&gt;&gt; data;
};
</code></pre>

<p>Usage:</p>

<pre><code>Base* p = new Derived1;
...
delete p;   // OK

p = new Derived2;
...
delete p;   // OK
</code></pre>
",0
29454079,29454023,1,"<blockquote>
  <p><code>Base* p = new Derived;</code><p>
  Now to delete p, i.e. free memory, we MUST have the destructor declared as virtual and do:</p>
  
  <p><code>delete p;</code><p>
  Correct?</p>
</blockquote>

<p><strong>Yes</strong></p>

<p>As the answer to this question (<a href=""https://stackoverflow.com/questions/294927/does-delete-work-with-pointers-to-base-class"">Does delete work with pointers to base class?</a> also states.</p>

<blockquote>
  <p>Yes, it will work, if and only if the base class destructor is virtual</p>
</blockquote>

<h2>C++ 11</h2>

<p>If the destructor's implementation is trivial you can just do</p>

<pre><code>virtual ~Base() = default;
</code></pre>

<p>Furthermore the derived types should make use of <code>override</code>.</p>

<pre><code>virtual ~Derived() override = default;
^^^1^^^            ^^^2^^^^
// 1: Optional because the base destructor is virtual
// 2: The compiler will verify the base destructor is virtual
</code></pre>
",3
33584340,33584313,0,"<p>You should call <code>c_str()</code>:</p>

<pre><code>fp = fopen(e.c_str(), ""w"");
</code></pre>
",0
33584325,33584313,3,"<p>This happens because <code>fopen</code> takes <code>const char *</code></p>

<pre><code>fp = fopen(e, ""w"");
</code></pre>

<p>use <code>e.c_str()</code> instead</p>
",0
34233632,34233582,1,"<p><code>addItem</code> is a <code>static</code> function, which does not not operate on any instance of <code>WindowManager</code>. It can not access <code>m_guilist</code>, which is non-static without an instance.</p>

<p>Maybe you just want:</p>

<pre><code>Get()-&gt;m_guilist.push_back(newGUIItem);
</code></pre>

<p>But you're starting to make the interface <code>static</code>, that's kind of hybrid. It's usually that <code>addItem</code> is non-static and you call it with the instance you acquire by <code>WindowManager::Get()</code>.</p>

<p>Yet, <code>WindowManager</code> doesn't have inaccessible or deleted constructor to qualify as a singleton class. <a href=""https://stackoverflow.com/questions/1008019/c-singleton-design-pattern"">Ways to implement a Singleton design pattern</a>.</p>
",2
34214969,34214865,1,"<p>That's probably because you declared your function as <code>AverageDay</code>, but when you call it, you called <code>Average(day)</code>. Just change it to <code>AverageDay(day)</code>. As for the other errors, you need to add <code>#include &lt;string&gt;</code>.</p>
",0
34215472,34214865,0,"<p>The function name was wrong (This should compile):  </p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int matrix[5][5] = {0};

string DayOfWeek(int i) {
    if(i == 0)
        return ""Monday"";
    if(i == 1)
        return ""Tuesday"";
    if(i == 2)
        return ""Wednesday"";
    if(i == 3)
        return ""Thursday"";
    if(i == 4)
        return ""Friday"";
}

string Child(int i) {
    if(i == 0)
        return ""Alex"";
    if(i == 1)
        return ""Brian"";
    if(i == 2)
        return ""Carla"";
    if(i == 3)
        return ""David"";
    if(i == 4)
        return ""Ellen"";
}

bool CheckInput(int i) {
    if(i &gt;= 0)
        return true;
    else
        return false;
}

void ReadInput(int child, int day) {
    cout&lt;&lt;""Enter food eaten by ""&lt;&lt;Child(child)&lt;&lt; "" on "" &lt;&lt;DayOfWeek(day);
    int a;
    cin&gt;&gt;a;
    if (CheckInput(a))
        matrix[child][day] = a;
    else {
        cout&lt;&lt;""Invalid (negative) food quantity. Please re-enter a correct value\n"";     
        ReadInput(child, day);
    }
}

float AverageDay(int day) {
    float average = 0;
    for (int i=0; i&lt;5; i++)
        average += matrix[i][day];
    return average/5;
}

void LeastAmount(int &amp;child, int &amp;day) {
    child = 0; day = 0;
    for(int i=0; i&lt;5; i++)
        for(int j=0; j&lt;5; j++)
            if(matrix[child][day] &gt; matrix[i][j]) {
                child = i; day = j;
            }
}

void MaxAmount(int &amp;child, int &amp;day) {
    child = 0; day = 0;
    for(int i=0; i&lt;5; i++)
        for(int j=0; j&lt;5; j++)
            if(matrix[child][day] &lt; matrix[i][j]) {
                child = i; day = j;
            }
}

int main() {
    for(int i=0; i&lt;5; i++)
        for(int j=0; j&lt;5; j++)
            ReadInput(i, j);

    bool ok = true;
    while (ok) {
        cout&lt;&lt;""Average amount of food eaten per day by all children - press 1\n"";
        cout&lt;&lt;""The least amount of food eaten during the week by any one child - press 2\n"";      
        cout&lt;&lt;""The greatest amount of food eaten during the week by any one child - press 3\n"";
        cout&lt;&lt;""To exit - press 0\n"";

        int answer;
        cin &gt;&gt; answer;
        if (answer == 0)
            ok = false;
        if (answer == 1) {
            cout&lt;&lt;""Enter a day of the week [from 1 to 5]\n"";
            int day;
            cin&gt;&gt;day;
            cout&lt;&lt;""Average food consumed on ""&lt;&lt;DayOfWeek(day)&lt;&lt;"": ""&lt;&lt;AverageDay(day)&lt;&lt;endl;
        }

        if(answer == 2) {
            int child, day;
            LeastAmount(child, day);
            cout&lt;&lt;""The least daily food consumed was by ""&lt;&lt; Child(child)&lt;&lt;"" on ""&lt;&lt;DayOfWeek(day)&lt;&lt;endl;
        }

        if(answer == 3) {
            int child, day;
            MaxAmount(child, day);
            cout&lt;&lt;""The most daily food consumed was by ""&lt;&lt; Child(child)&lt;&lt;"" on ""&lt;&lt;DayOfWeek(day)&lt;&lt;endl;
        }
    }

    return 0;
}
</code></pre>
",0
33590040,33590020,2,"<p>The error is pretty clear: you are calling <code>Horizontal</code> with less than the required 2 arguments: in fact, you are calling it with <em>no</em> arguments.</p>

<p>Shouldn't you be calling it <em>after</em> you've read in <code>length</code> and <code>width</code>, so you can pass them to it?</p>
",0
33591331,33591274,0,"<p>The way the <code>for</code> loop has been coded, <code>i &lt;= argc</code> will always be <code>true</code>. Hence the loop will never end. As soon as <code>i</code> is <code>-1</code>, you end up accessing memory out of bounds. That is cause for undefined behavior. In your case, the undefined behavior manifests as segmentation fault.</p>

<p>You need to use <code>i &gt; 0</code> for the conditional of the <code>for</code> statement.</p>

<p>Remember that <code>argv[0]</code> is the program name. The arguments to the program start at <code>argv[1]</code>.</p>
",0
33591344,33591274,3,"<p>This:</p>

<pre><code>for(int i=argc; i&lt;=argc; i--)
</code></pre>

<p>should be</p>

<pre><code>for(int i = argc - 1; i &gt;= 0; i--)
</code></pre>

<p>because</p>

<ol>
<li>Your condition for loop termination was wrong</li>
<li>Array indices start from 0 and end at length - 1 (Note: For <code>argv</code>, <code>argv[argc]</code> is <code>NULL</code>)</li>
</ol>

<p>Change <code>&gt;=</code> to <code>&gt;</code> if you do not want to include the first argument (the name of the program).</p>
",0
33601100,33600978,2,"<p>According to your own error message, the line:</p>

<pre><code>cout &lt;&lt; ""Diamond width: +;""
//                       ^ no
</code></pre>

<p>should be:</p>

<pre><code>cout &lt;&lt; ""Diamond width: +"";
//                        ^ yes
</code></pre>

<p>Look at your error message again:</p>

<pre><code>./main.cpp: In function ¡®int main()¡¯:
./main.cpp:16:2: error: expected ¡®;¡¯ before ¡®cin¡¯
cin &gt;&gt; width; 
^
</code></pre>

<p>The correction I mentioned is made immediately before the <code>cin</code>. I didn't look at the rest of your code, but if you have additional problems, the error message is what you need to understand, so I'll try to break it down for you.</p>

<p>The line <code>./main.cpp: In function ¡®int main()¡¯:</code> tells you the issue is in the <code>main.cpp</code> file, in the <code>main</code> function.</p>

<p>The line <code>./main.cpp:16:2: error: expected ¡®;¡¯ before ¡®cin¡¯</code> tells you the compiler is ""looking"" at line 16, column 2, which points to the beginning of the <code>cin &gt;&gt; width;</code> part mentioned last.</p>

<p>It's very straightforward.</p>
",3
33601176,33600971,1,"<p>you are calling <code>fleetCapacity(ships, NUMSHIPS);</code> which is then accessing <code>s[e]</code> (<code>ships[NUMSHIPS]</code>) in the function. The valid indices are <code>0</code> through <code>NUMSHIPS-1</code>.</p>
",3
34244856,34244846,1,"<p><code>using namespace std;</code> imports every symbol in the <code>std</code> namespace into the present namespace. It is a <em>using-directive</em>. From the <a href=""http://en.cppreference.com/w/cpp/language/namespace"" rel=""nofollow noreferrer"">c++ wiki page on namespaces</a>:</p>
<blockquote>
<pre><code>using namespace ns_name;
</code></pre>
<p>From the point of view of unqualified name lookup of any name after a using-directive and until the end of the scope in which it appears, every name from namespace-name is visible as if it were declared in the nearest enclosing namespace which contains both the using-directive and namespace-name.</p>
</blockquote>
<p><code>using std::cin;</code> imports only the <code>std::cin</code> symbol into the present namespace. It is a <em>using-declaration.</em> From <a href=""http://en.cppreference.com/w/cpp/language/namespace"" rel=""nofollow noreferrer"">the same wiki page as above</a>:</p>
<blockquote>
<pre><code>using ns_name::name;
</code></pre>
<p>makes the symbol name from the namespace ns_name accessible for unqualified lookup as if declared in the same class scope, block scope, or namespace as where this using-declaration appears.</p>
</blockquote>
",0
34244841,34244749,0,"<p>Here's how. Create a <a href=""http://forgetcode.com/Cpp/667-Parameterized-Constructor"" rel=""nofollow"">Parameterized Constructor</a> and pass the values you want to be assigned to the object as arguments. <br><br></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

class bankAccounts
{
private:
    std::string customerName;
    char accType;
    int accountNo;
    double accBalance;

public:
    bankAccounts();

    bankAccounts(std::string cn ,char act, int acno, double accB) //Parameterized constructor
    {
        customerName =cn;
        accType=act;
        accountNo=acno;
        accBalance=accB;
    }

    //Implement your functions inside/ outside the class

    // displayAccount();
    // depositAccount();
    // withdrawAccount();
    // deleteAccount();
    // showAccounts();

};


int main()
{
    std::string customerName;
    char accType;
    int accountNo;
    double accBalance;
    std::cin&gt;&gt;customerName&gt;&gt;accType&gt;&gt;accountNo&gt;&gt;accBalance;//get your data
    bankAccounts B(customerName, accType, accountNo, accBalance);
    //object B has all attributes you wanted

    //Enjoy :)

    return 0;
} 
</code></pre>
",10
34245429,34245395,3,"<p>Actually there is a mistake in your condition.</p>

<p>The boolean || is used in a wrong way. If you want to check if <code>a</code>' is equal to <code>1</code> or <code>2</code> you should check it like this</p>

<p><code>a == 1 || a == 2</code></p>

<p>When you say <code>input3 != ""1""||""2""||""3""</code> It will first evaluate <code>input3 != ""1"" || ""2"" || ""3""</code>. This is will always evaluate to TRUE because anything that is not zero and can be converted to a boolean is not <code>false</code> in <code>C++</code>.</p>

<p>Modifying your code to use the correct comparisons .. </p>

<pre><code>if(input2 == ""1""){
    string input3;
    do {
        cout &lt;&lt; ""Which would you like to check?"" &lt;&lt; endl;
        cout &lt;&lt; ""1. Checking."" &lt;&lt; endl;
        cout &lt;&lt; ""2. Savings."" &lt;&lt; endl;
        cout &lt;&lt; ""3. Credit Card."" &lt;&lt; endl;
        cin &gt;&gt; input3;
            if(input3 != ""1"" &amp;&amp; input3 != ""2"" &amp;&amp; input3 != ""3""){
            cout &lt;&lt; ""That is an invalid response. Please enter again."" 
            &lt;&lt;endl;
            }
    } while(input3 != ""1"" &amp;&amp; input3 != ""2"" &amp;&amp; input3 != ""3"");
}
</code></pre>
",2
34245436,34245395,1,"<p>This code:</p>

<pre><code>input3 != ""1""||""2""||""3""
</code></pre>

<p>means (input3 is not ""1"") or (""2"") or (""3"")</p>

<p>A string literal like ""2"" in C++ will evaluate to a boolean true when used in a boolean expression like this, so your expression will always be evaluated as true.</p>

<p>I think what you want is this:</p>

<pre><code>input3 == ""1"" || input3 == ""2"" || input3 == ""3""
</code></pre>

<p>meaning input3 is either ""1"", ""2"" or ""3""</p>

<p>or</p>

<pre><code>input3 != ""1"" &amp;&amp; input3 != ""2"" &amp;&amp; input3 != ""3""
</code></pre>

<p>meaning input3 is neither of ""1"", ""2"" or ""3""</p>
",2
34088918,34088697,1,"<p>If you are facing a SegFault I think this line could be the problem :</p>

<pre><code>write(""database"",t);
</code></pre>

<p>because in your <code>write</code> function you use <code>strcat</code> on <code>fname</code> but you pass a read-only string.</p>

<p>Also, I think it might be best to use real c++ instead of c+ like :</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

void my_write(std::sting &amp; fname, std::string &amp; text) {
    std::string file = fname + "".txt"";
    std::osftream w(file, std::ios::app);
    w &lt;&lt; text &lt;&lt; ""\n"";
    w.flush();
    w.close();
}

int main() {
    std::string t = """";
    std::string id = ""Its id"";
    std::string pass = ""Its password"";
    std::string fname = ""database"";
    int login = 1;

   t = id + ""\n"" + pass;
   my_write( fname, t);
}
</code></pre>

<p>I haven't test it but the idea is here.</p>
",8
33826277,33825712,7,"<p>The warning is probably because of the <code>char*</code>. Change it to <code>char const*</code>.</p>

<p>Explanation: String literals have the type <code>char const[N]</code>, where <code>N</code> is the number of characters in the string + 1 for the NUL at the end. Normally an array of this type would only be convertible to <code>char const*</code>, but a special rule used to exist that allowed string literals to be converted to <code>char*</code> for C compatibility. This is an unsafe conversion so compilers warn against it.</p>
",0
34219512,34219302,0,"<p>======1======</p>

<p>Your function declaration is not right, the parameter <code>int array[]</code> or <code>int *array</code>.</p>

<pre><code>void memsetNincr(int array[], int howmany, int startingVal);
</code></pre>

<p>or
    void memsetNincr(int *array, int howmany, int startingVal);</p>

<p>======2======</p>

<p>the <code>memsetNincr</code> is void, it meams that function does not return any value, so it can't by print by <code>cout</code> or <code>printf</code>.</p>

<pre><code>cout &lt;&lt; memsetNincr(array, size, initVal) &lt;&lt; endl;
</code></pre>

<p>should by write </p>

<pre><code>memsetNincr(array, size, initVal);
</code></pre>

<p>this is your codes</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void memsetNincr(int*, int, int);

int main()
{
    int size, initVal;

    cout &lt;&lt; ""Enter size of array followed by the value of its' first element: \n"";
    cin &gt;&gt; size &gt;&gt; initVal;

    int array[size];

    //cout &lt;&lt; memsetNincr(array, size, initVal) &lt;&lt; endl;
    memsetNincr(array, size, initVal);

    return 0;
}

void memsetNincr(int array[], int howmany, int startingVal)
{
    int i;

    array[0] = startingVal;

    for (i=0; i&lt;=howmany; i++)
    {
        array[i] = array[i-1]-1;
        cout &lt;&lt; array[i] &lt;&lt; ""  "";
     }

}
</code></pre>
",0
34219579,34219302,0,"<p>There are no Variable Length Arrays in C++. So the size of the array shall be a constant expression.</p>

<p>You could use standard class <code>std::vector</code> declared in header <code>&lt;vector&gt;</code> if the number of elements is given by the user.</p>

<p>Function <code>memsetNincr</code> accepts the first argument of an array type. So at least it first parameter should be declared like</p>

<pre><code>void memsetNincr(int *, int, int);
</code></pre>

<p>or</p>

<pre><code>void memsetNincr(int [], int, int);
</code></pre>

<p>Moreover the function has return type <code>void</code>. So you may not use it in statements like this</p>

<pre><code>cout &lt;&lt; memsetNincr(array, size, initVal) &lt;&lt; endl;
</code></pre>

<p>You should use a separate loop to output the elements of the array.</p>

<p>Take into account that if the array has <code>howmany</code>  elements then the corresponding loop will look like</p>

<pre><code>for (i=0; i &lt; howmany; i++)
          ^^^^^^^^^^^
</code></pre>

<p>because the valid range of indices is <code>[0, howmany-1]</code></p>
",0
34219370,34219302,1,"<p><code>cout</code> expects a stream or something that can be casted to a stream. Your function returns void, and void cannot be casted. Either change the function to return a string or stringstream object or just call it outside of cout. </p>

<p>Edit: With calling it outside of <code>cout</code> I mean something like this:</p>

<pre><code>int main()
  {
  int size, initVal;

  cout &lt;&lt; ""Enter size of array followed by the value of its' first element: \n"";
  cin &gt;&gt; size &gt;&gt; initVal;

  int array[size];

  memsetNincr(array, size, initVal);
  cout &lt;&lt; endl;
  return 0;
}
</code></pre>
",0
34219405,34219302,1,"<p>first run <code>i = 0</code></p>

<pre><code>array[i] = array[i-1]-1;
</code></pre>

<p>so</p>

<pre><code>array[0] = array[0-1]-1;
</code></pre>

<p>so</p>

<pre><code>array[0] = array[-1]-1; -&gt; error

(i=1; i&lt;=howmany; i++) 
</code></pre>

<p>should fix it.</p>
",0
34219410,34219302,1,"<p>change <code>cout &lt;&lt; memsetNincr(array, size, initVal) &lt;&lt; endl;</code> to <code>memsetNincr(array, size, initVal);</code></p>

<p>change </p>

<pre><code>for (i=0; i&lt;=howmany; i++)
{
    array[i] = array[i-1]-1;
    cout &lt;&lt; array[i] &lt;&lt; ""  "";
}
</code></pre>

<p>to </p>

<pre><code>for (i=1; i&lt;=howmany; i++)
{
    array[i] = array[i-1]-1;
    cout &lt;&lt; array[i] &lt;&lt; ""  "";
}
</code></pre>
",0
34190301,34190133,6,"<p>There are couple of issues with your code:</p>

<ol>
<li>You haven't initialized <code>sum</code> so the output of this program is not deterministic. I guess in your case the compiler simply sets it to <code>0</code> which is the intended behavior anyways, so this is why your result is close to the correct one. However, don't expect that this will always be the case and always make sure that you use initialized variables.</li>
<li>In the end of the loop you need to reset the values of <code>numb</code> and <code>sum</code>.</li>
<li><p>You work with integers which always rounds the result down. You can either use doubles or cast the variables where needed.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;math.h&gt;
using namespace std;
int main() {
  int a, b;
  double average, sum;
  int numb;
  cin &gt;&gt; a;
  for (int i = 0; i &lt; a; i++) {
    sum = 0.0;
    numb = 0;
    do {
      cin &gt;&gt; b;
      sum = b+sum;
      numb++;
    } while (b != 0);
    average = sum / (numb - 1);
    cout &lt;&lt; round(average) &lt;&lt; "" "";
  }
}
</code></pre></li>
</ol>

<p>Also note that if for same case you directly type in <code>0</code>, the program will crash because of division by 0.</p>
",3
34080690,34080652,4,"<p><code>int arr[SIZE] = {0};</code> is array initialization syntax. It's only legal when you are declaring and initializing the array on the same line.</p>

<p>It's illegal in the function, because the array already exists. Outside the declaration line after all, <code>arr[SIZE]</code> is interpreted as trying to index the array, not size it.</p>

<p>For something like this, you can just use <code>memset</code>:</p>

<pre><code>memset(arr, '\0', sizeof(arr[0]) * SIZE);
</code></pre>

<p>For a more C++-y way to do it, you can use:</p>

<pre><code>std::fill(arr, arr+SIZE, 0);
</code></pre>
",13
34081086,34080652,0,"<p>This can be done using the c++ array in the standard library. By simply changing initialization of the array from <code>int x[5] = {1,2,3,4,5}</code> to <code>std::array&lt;int,5&gt; x = {1,2,3,4,5}</code>. The beauty of using <code>std::array</code> is that it when compiled with the flag <code>-std=c++11</code> it will allow you assign the entire array to one value after initialization e.g. <code>x = {0};</code> essentially ""clearing"" your array. This simplifies your code and does not require you to use functions like <code>memset()</code>, <code>std::fill</code>, it even does away with for loops. It is widely recommended that you adopt the use of c++ standard container such as <code>std::vector</code> and <code>std::array</code> as they allow for much safer cleaner code with little or no performance overhead. To demonstrate using <code>std::array</code> I have written the code below which again should be compiled using the <code>-std=c++11</code> flag.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;array&gt;

int  main()
{
    // Declares an array of size 5 and of type int and intialises.
    std::array&lt;int,5&gt; x = {1,2,3,4,5};

    // Prints each element
    for (size_t i = 0; i &lt; x.size() ; i++)
    {
        std::cout &lt;&lt; x[i] &lt;&lt; std::endl;
    }

    // Assigns each element to ""0"" or ""Clearing the array""
    x = {0};

    // Prints each element
    for (size_t i = 0; i &lt; x.size() ; i++)
    {
        std::cout &lt;&lt; x[i] &lt;&lt; std::endl;
    }
    std::cin.get();
    std::cin.get();
    return 0;
}
</code></pre>
",0
29906590,29906446,0,"<p>You can solve the problem by passing the arguments by value, and not by reference:</p>

<pre><code>Car(string make, string model, int year=2015);        // constructor 
bool SetValue(string make, string model, int year);  
</code></pre>

<p>This will allow to automatically the trigger the constructor of <code>std::string</code> that takes as input a <code>const char *</code>.</p>

<p>The compiler will take care of optimizing away unused copies. You can add <code>const</code> to your input parameters, but it is usually superfluous (and cumbersome) to add it when the arguments are passed by value.</p>

<hr/>

<p>Besides, in C++ member initialization in the constructor should be preferably made in the following way (<a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow"">initializer list</a>):</p>

<pre><code>Car::Car(string make, string model, int year)
  : automake(make), automodel(model), autospeed(0), autoyear(year &lt; 0 ? 2015 : year)
{
//If the above autoyear code is not clear, you can perfectly
//keep your code for it, which was just fine
}
</code></pre>

<p>You have to take care of initializing the members in the same order in which they are declared.</p>
",0
29906496,29906446,0,"<p>As the error says, you need to provide a constructor for <code>const</code> references:</p>

<pre><code>Car(const string &amp;make, const string &amp;model, int year=2015);    
</code></pre>
",0
34081254,34081020,1,"<p>After a little bit of skimming another section, I found the ""while"" loop, and had success implementing this - without creating another function.</p>

<pre><code>#include ""stdafx.h""
#include ""constant.h""
#include &lt;iostream&gt;

int main()
{
    using namespace std;
    cout &lt;&lt; ""Put tower height meters \n"";
    double t_height;
    cin &gt;&gt; t_height;

    cout &lt;&lt; ""Put number of seconds here \n"";
    int seconds;
    cin &gt;&gt; seconds;

    int count{ 0 };
    while (count &lt;= seconds)
    {
        double distance{ constant::g*count*count / 2 }; //Modified from original to include int count as the new second, as at the end of the loop, count is increased by one for each run.

        double b_height{ t_height - distance };
        if (distance &gt; t_height)
        {
            b_height = 0;
        }
        cout &lt;&lt; ""After "" &lt;&lt; count &lt;&lt; "" seconds the ball is at "" &lt;&lt; b_height &lt;&lt; "" meters above the ground. \n"";

        count = count + 1;
    }

    return 0;
}
</code></pre>

<p>If there's anything I can do to make the program more efficient (including more advanced tips and tricks) please comment so I can build on the knowledge I have. Thank you.</p>
",0
34081442,34081020,1,"<p>A way of modifying your code can be like this : </p>

<pre><code>#include ""stdafx.h""
#include ""constant.h""
#include &lt;iostream&gt;

using namespace std;

void main()
{
    double       t_height;
    int          seconds;
    int          count = 0;

    cout &lt;&lt; ""Put tower height meters \n"";
    cin  &gt;&gt; t_height;

    cout &lt;&lt; ""Put number of seconds here \n"";
    cin  &gt;&gt; seconds;

    while (count &lt;= seconds)
    {
        double distance = (constant::g * count * count) / 2; 
        double b_height = t_height - distance;

        if (distance &gt; t_height){
            b_height = 0;
        }
        cout &lt;&lt; ""After "" &lt;&lt; count &lt;&lt; "" seconds the ball is at "" &lt;&lt; b_height &lt;&lt; "" meters above the ground. \n"";

        count++;
    }
}
</code></pre>

<p>You already solved the problem and this version is just changing the way the code is written and it is not improving the algorithm of the process. </p>
",1
34080692,34080656,1,"<p>You have a vector of <code>Book*</code>, which are pointers, but you are using dot notation when you call <code>holdings[bookOnFile].getLocation()</code>. Same goes for the other method calls. Try replacing with <code>holdings[bookOnFile]-&gt;getLocation()</code>, etc.</p>
",2
31833055,31832734,0,"<p>First problem : you defined an unrelated, global <code>a</code>. The one you're trying to define is scoped inside the class(es).</p>

<pre><code>static constexpr unsigned char class1::a[2] = {0x4,0x5};
//                             ^^^^^^^^
</code></pre>

<p>Second problem : defintions belong in .cpp files, not headers.</p>
",0
31833866,31832734,0,"<p>Here is an example of static const a in 2 classes :</p>

<pre><code>#include &lt;iostream&gt;

class class1 {
public:
    static unsigned char const a[2];
};

class class2 {
public:
    static unsigned char const a[2];
};

constexpr unsigned char class1::a[] = {0x4,0x5};
constexpr unsigned char class2::a[] = {0x4,0x5};

int main() {
    std::cout &lt;&lt; static_cast&lt;unsigned&gt;(class1::a[0])
        &lt;&lt; static_cast&lt;unsigned&gt;(class2::a[1]) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Note:</p>

<ul>
<li>the <em>declaration</em> contains <code>static</code> and <code>const</code> and should be in a <code>.h</code> file</li>
<li>the <em>definition</em> constains <code>constexpr</code> and should be in a <code>.cpp</code></li>
</ul>
",2
34216178,34216109,1,"<p>The warning message is correct, the <code>doggies</code> object <em>is</em> uninitialized, you never initialize the member variables which has to be done in a constructor.</p>

<p>And since you don't initialize the object, the member variable <code>name</code> will have an <em>indeterminate</em> value and using the variable in any way except to initialize it will lead to <em>undefined behavior</em>.</p>

<p>The compiler doesn't stop you from doing bad things, it might detect them but it isn't required to do anything about it. And C++ doesn't have any kind of run-time checking either, the compiler and run-time system will happily let you shoot yourself in the foot.</p>

<p>Also, if you mostly use the dereference operator to access a pointer then you probably don't need a pointer in the first place.</p>
",4
34216185,34216109,0,"<p>The member <code>string *name</code> has no memory allocated for it. So you'd get a segmentation fault inside <code>set_dog_name</code>, where you assign another <code>string</code> to it.</p>

<p>Additionally, you don't initialize the members either in-class or in a constructor. This perhaps is pointed out by the compiler. GCC 5.2 however shows no warnings or errors, with both <code>-Wall</code> and <code>-Wextra</code>. I just get a segmentation fault when running the program. Live demo <a href=""http://coliru.stacked-crooked.com/a/8586fc343f4e88d7"" rel=""nofollow"">here</a>.</p>

<p><strong>Aside:</strong>
Initializing the global <code>dogsbreed</code> array is in no way the <code>struct</code>'s concern. Instead you could make the variable as the <code>struct</code>'s <a href=""http://en.cppreference.com/w/cpp/language/static"" rel=""nofollow"">static member</a> and initialize it separately.</p>

<pre><code>struct dog {
static string dogsbreed[3];
};

string dog::dogsbreed[3] = { ""Collie"", ""Poodle"", ""Pit Ball"" } ;
</code></pre>
",0
34256353,34256317,2,"<p>change</p>

<pre><code>ifstream input_file(""fileName"");
</code></pre>

<p>to</p>

<pre><code>ifstream input_file(fileName);
</code></pre>
",1
34215879,34215646,0,"<p>There is a very simple solution to your problem:</p>

<ol>
<li>Iterate through your array, using a loop: 
<code>for(int i=0; i &lt; array_length; i++)</code></li>
<li><p>Within this loop, make use of another loop, to check whether any value prior to the one, to which <code>i</code> is pointing, is equal to <code>your_array[i]</code>. If this is the case you have found a duplicate and can <code>return true</code>, else the loops will just run until the end of the array is reached and then you can <code>return false</code>.
Thus your entire function would be something like:</p>

<pre><code>bool contains_duplicates(int array[], int len) {
    for(int i=0; i &lt; len; i++) {
        for(int j=0; j &lt; i; j++) {
            if(array[j]==array[i]) {
                return true;
            }
        }
    }

    return false;
}
</code></pre></li>
</ol>

<p>Hope I could help, cheers! <br>
lindebear</p>
",10
34215966,34215646,-1,"<p>You can use templates to extend the type contained on vector like this. This solution reduces the algorithm complexity to O(n log n) which is better than O(n^2) from your nested loop, it doesn't mean it will be faster always but it make a difference on large vectors.</p>

<pre><code>template&lt; typename T&gt;
bool hasDuplicates(std::vector&lt;T&gt; vect) {
    std::sort(vect.begin(), vect.end());
    T last;
    typename vector&lt;T&gt;::iterator it;
    for(it = vect.begin(); it &lt; vect.end(); it++) {
        if (vect.begin() != it) {
            if(last == *it) {
                return true;
            }
        }
        last = *it;
    }
    return false;
}
</code></pre>
",2
33016825,33016632,3,"<p>From the comments, it looks like you have four bytes of input, each holding a 4-bit nibble. In that case you can use something like this:</p>

<pre><code>unsigned short int result;
unsigned char buffer[4];

...

result = buffer[0] &lt;&lt; 12;
result |= buffer[1] &lt;&lt; 8;
result |= buffer[2] &lt;&lt; 4;
result |= buffer[3];
</code></pre>

<p>This code assumes that the high nibble of each character is zero. For a little endian input, reverse the indexes to be descending.</p>
",9
29951142,29950743,0,"<p>You need to make sure your .h is only parsed once. #pragma once or #ifndef myheader_h ...</p>
",0
34248661,34248558,3,"<p>As @Jonathan_Potter has said that <code>Sleep</code> is a part of <code>Windows API</code> &amp; hence you need to include <code>windows.h</code> so I don't think you need to know any further why your code isn't working. However I'm writing this answer to give you a standardized alternative to ""your sleep problem"".</p>

<p>C++11 has introduced <code>sleep_for</code> &amp; <code>sleep_until</code> which are defined in the namespace <code>std::this_thread</code>. When the former is for a span of time, the latter is for absolute time. I would give an example of <code>sleep_for</code> :-</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
using namespace std;
int main()
{
    cout &lt;&lt; ""start"" &lt;&lt; endl;
    this_thread::sleep_for (chrono::seconds(1));  // for C++14 users you can simply write 1s to denote 1 second
    cout &lt;&lt; ""end\n"";   // will be printed after 1 second of printing 'start'
    return 0;
}
</code></pre>

<p>I'm giving you this answer because you should always prefer using features from the standard so as to make your program portable. You can differ from this advice only if it's really necessary.</p>
",0
34206445,34206405,1,"<p>Add a <code>L</code> to the end of your 9's.</p>
",6
34207926,34206405,2,"<p>You need to use <code>long long</code> if you want to store 64 bits (and you do).</p>

<pre><code>    const auto lValue = 9999999999999LL;
</code></pre>

<p>or</p>

<pre><code>    long long lValue = 9999999999999LL;
</code></pre>
",0
34178927,34178344,0,"<p>The problem is that you need to run the executable in the same directory where <code>Hamlet.txt</code> lives. This is a big problem in C++, so typically you'll give the absolute path to the file, so you might do something like this:</p>

<pre><code>ifstream file(""/path/to/Hamlet.txt"", ios::in);
</code></pre>

<p>A few other notes: the file is either <strong>open</strong>, or it's not. Thus, you don't need <code>else if</code>, you can simply use <code>else</code>. Additionally, you can use non-falsey values to indicate true; so you don't need to check <code>== true</code> (though it's more explicit). You could just check <code>if(file.is_open())</code>, which I think is more readable.</p>

<p>Putting these suggestions together, here's what you can do:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;

int main()
{ 
      ifstream file(""/absolute/path/to/Hamlet.txt"", ios::in);
      if (file.is_open()) {
        std::cout &lt;&lt; ""File is open"" &lt;&lt; std::endl;
      } else {
        std::cout &lt;&lt; ""File isnt open"" &lt;&lt; std::endl;
      }
      return 0;
}
</code></pre>
",1
34179358,34178344,2,"<p>If you are talking about Win32 resource files, you can't open your file
like that. You need to use the resource API:</p>

<pre><code>HRSRC const rsrc = FindResource(nullptr, MAKEINTRESOURCE(HAMLET), RT_STRING);
HGLOBAL const resource = LoadResource(nullptr, rsrc);
void const* const data = LockResource(resource);
// Use your data here.
</code></pre>

<p><code>HAMLET</code> is a preprocessor macro used to identify your ""Hamlet.txt"" file from the .rc file.</p>
",0
34243113,34243075,1,"<p>The area of a square with side 8, is 64... what are you getting as output?</p>

<p>Please paste your actual code:</p>

<pre><code> cout &lt;&lt; ""The area is ""&lt;&lt; box.setArea(side)&lt;&lt;endl;
</code></pre>

<p>would not compile with the code you paste (where is setArea defined)</p>
",1
34243212,34243075,3,"<p>Oh dear. </p>

<ul>
<li><code>setSide</code> should only take one argument, and store the value in the member variable.</li>
<li><code>setArea</code> should be called <code>getArea</code> or <code>findArea</code>.  (I prefer ""get"", but in that case, make it <code>getPerimeter</code> too.)</li>
<li>Both <code>getArea</code> and <code>getPerimeter</code> should not take any arguments (and should be const member functions).</li>
<li>You should decide to use either <code>float</code> or <code>double</code> throughout.  (If in doubt, use <code>double</code>).</li>
</ul>
",0
34244192,34243742,0,"<p>Sorry for wasting your time, I figured out the problem, It is working as it needs to now, I used to many Initializations for my array I fixed it by readjusting it's parameter's </p>
",0
34244215,34243742,0,"<p>It's a compiler bug. I tried the same code in VS2015 and received the message:</p>

<pre><code>1&gt;------ Rebuild All started: Project: scratch, Configuration: Debug Win32 ------
1&gt;  scratch.cpp
1&gt;E:\Code\VS2015\scratch\scratch\scratch.cpp : fatal error C1001: An internal error has occurred in the compiler.
1&gt;  (compiler file 'f:\dd\vctools\compiler\utc\src\p2\main.c', line 246)
1&gt;   To work around this problem, try simplifying or changing the program near the locations listed above.
1&gt;  Please choose the Technical Support command on the Visual C++
1&gt;   Help menu, or open the Technical Support help file for more information
1&gt;
========== Rebuild All: 0 succeeded, 1 failed, 0 skipped ==========
</code></pre>

<p>As pointed out in the answer by Patrick Duggin and the comments it is related to the array initialisation. My minimal reproducible is as follows:</p>

<pre><code>#include &lt;string&gt;

class X
{
    std::string strings[2] = { ""first"" };
};

int main()
{
    X x;
}
</code></pre>

<p>The above code produces the same error. This is valid C++ code. Adjusting the array size, or adding another initialiser to the array is a workaround for the bug.</p>

<p>I could not reproduce the bug using an array of a different type. I don't have the motivation to find out exactly what it is about <code>std::string</code> that causes this.</p>
",0
30183155,30182983,1,"<p>What's wrong with doing something like this?</p>

<pre><code>#include &lt;cmath&gt; // abs and round
#include &lt;cfloat&gt; // DBL_EPSILON

bool TestForDecimal(double Num) {
  double diff = abs(round(Num) - Num);
  // true if not a whole number
  return diff &gt; DBL_EPSILON;
}
</code></pre>
",1
30183262,30182983,0,"<p>The look is quite inefficient...what if Num is large...</p>

<p>A faster way could be something like</p>

<pre><code>if (Num == static_cast&lt;int&gt;(Num))
</code></pre>

<p>or</p>

<pre><code> if (Num == (int)Num)
</code></pre>

<p>if you prefer a C-style syntax.</p>

<p>Then a range check may be useful... it oes not make sense to ask if Num is an intger when is larger than 2^32 (about 4 billions)</p>

<p>Finally do not think od these numers as decimals. They are stored as binary numbers, instead of multiplying Power and Denominator by 2 you are better of multiplying them by 2.</p>
",0
30183344,30182983,0,"<p>After studying your ""unfixed"" function, from what I can tell, here's your basic algorithm:</p>

<ol>
<li><code>double TestForDecimal(double Num) { ...</code></li>
</ol>

<p>A function that accepts a <code>double</code> and returns a <code>double</code>. This would make sense if the returned value was the decimal value, but since that's not the case, perhaps you meant to use <code>bool</code>?</p>

<ol start=""2"">
<li><code>while (Num &gt; 1) { make it less }</code></li>
</ol>

<p>While there is nothing inherently wrong with this, it doesn't really address negative numbers with large magnitudes, so you'll run into problems there.</p>

<ol start=""3"">
<li><code>if (Num &gt; -INT_MAX &amp;&amp; Num &lt; INT_MAX &amp;&amp; Num == (int)Num) { return 0; }</code></li>
</ol>

<p>This means that if <code>Num</code> is within the signed integer range and its integer typecast is equal to itself, return a <code>0</code> typecasted to a <code>double</code>. This means you don't care whether numbers outside the integer range are whole numbers or not. To fix this, change the condition to <code>if (Num == (long)Num)</code> since <code>sizeof(long) == sizeof(double)</code>.</p>

<p>Perhaps the algorithm your function follows that I've just explained might shed some light on your problem.</p>
",3
30183816,30182983,0,"<p>Beware. A double is (generally but I think you use a <em>standard</em> architecture) represented in <a href=""http://en.wikipedia.org/wiki/IEEE_floating_point"" rel=""nofollow"">IEE-754</a> format, that is <em>mantissa * 2<sup>exponent</sup></em>. For a double, you have 53 bits for the mantissa part, one for the sign and 10 for the exponent. When you multiply it by 10 it will grow, and will get an <em>integer</em> value as soon as exponent will be greater than 53.</p>

<p>Unfortunately, unless you have a 64 bits system, an 53 bits integer cannot be represented as a 32 bits int, and your test will fail again.</p>

<p>So if you have a 32 bits system, you will never reach an integer value. You will more likely reach an infinity representation and stay there ...</p>

<p>The only use case where it could work, would be if you started with a number that can be represented with a small number of negative power of 2, for example 0.5 (1/2), 0.25(1/4), 0.75(1/2 + 1/4), giving almost all digits of mantissa part being 0.</p>
",1
30183825,30182983,0,"<p>Most decimal fractions can't be represented exactly in a binary floating-point format, so what you're trying to do can't work in general. For example, with a standard 64-bit <code>double</code> format, the closest representable value to <code>3.1415</code> is more like <code>3.1415000000000001812</code>.</p>

<p>If you need to represent decimal fractions exactly, then you'll need a non-standard type. <a href=""http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html"" rel=""nofollow"">Boost.Multiprecision</a> has some decimal types, and there's a <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3871.html"" rel=""nofollow"">proposal</a> to add decimal types to the standard library; some implementations may have experimental support for this.</p>
",4
30178555,30178465,8,"<p>These are two seperate variable because they are declared in a different <a href=""http://www.tutorialspoint.com/cplusplus/cpp_variable_scope.htm"" rel=""nofollow"">scope</a>. The scope of a variable is the ""area"" of code in which it's visible. </p>

<p>As a simple rule of thumb, any place where curly brackets are, or could be placed, is a new scope. The  <code>fly</code> inside the for loop, overrides the other <code>fly</code>  variable. If it wasn't declared, or declared under a different name. The original variable would still be accessible. </p>
",0
34256230,34255605,4,"<p>I think you're asking if a contiguous subsequence can be found inside another range of values. The standard library <a href=""http://en.cppreference.com/w/cpp/algorithm/search"" rel=""nofollow""><code>std::search</code></a> algorithm does just that.</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

bool included(const std::vector&lt;int&gt;&amp; seq, const std::vector&lt;int&gt;&amp; sub)
{
    return std::search(seq.begin(), seq.end(), sub.begin(), sub.end()) != seq.end();
}

int main()
{
    auto v1 = std::vector&lt;int&gt;{ 1,2,3,2 };
    auto v2 = std::vector&lt;int&gt;{ 1,2,3 };

    std::cout &lt;&lt; std::boolalpha &lt;&lt; included(v1, v2) &lt;&lt; '\n';

    auto v3 = std::vector&lt;int&gt;{ 1,2 };
    auto v4 = std::vector&lt;int&gt;{ 2,3,1 };

    std::cout &lt;&lt; included(v3, v4) &lt;&lt; '\n';
}
</code></pre>

<p><a href=""http://ideone.com/WntswW"" rel=""nofollow"">Demo on ideone.com</a></p>

<p>Note: I stole Jarod42's function name and coincoin's test data.</p>
",1
34254018,34253966,4,"<p><code>animal</code> does not have a <code>cry</code> method. So you cannot call a <code>cry</code> on animal.</p>

<p>Also you have numerous syntax errors, which should give you errors before this line:</p>

<p>Your vector contains pointers and you are trying to stuff object itself inside.</p>

<p>To access member of object pointer points to, you should use <code>-&gt;</code>, not <code>.</code>.</p>
",0
34254070,34253966,1,"<p>A lot of changes needed.<code>static_cast</code> is essential to call your <code>cry</code> method.</p>

<ol>
<li><p>class definition should end with <code>;</code></p></li>
<li><p>Since you created <code>vector&lt;animal*&gt;</code>,  you need to <code>new</code> the object before push back.</p></li>
<li><p>When you invoke the function <code>cry</code> , you need to <code>static_cast</code> it back to <code>beast*</code> and use <code>-&gt;</code> instead <code>.</code> to invoke the cry function.</p></li>
</ol>

<blockquote>
<pre><code>class animal{

};
class beast : public animal {
public:
 beast(std::string name){}
void cry(){
std::cout&lt;&lt;""kuuuuu""&lt;&lt;std::endl;
}
};
int main(){
std::vector&lt;animal*&gt; a;
a.push_back(new beast(""tiger""));
(static_cast&lt;beast*&gt;(a[0]))-&gt;cry();
}
</code></pre>
</blockquote>
",0
34254078,34253966,1,"<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class animal {
public:
    virtual void cry() = 0; // declare public virtual cry method
};

class beast : public animal {
public:

    beast(string name) {
    }

    void cry() {
        cout &lt;&lt; ""kuuuuu"" &lt;&lt; endl;
    }
};

int main() {
    vector&lt;animal*&gt; a;
    a.push_back(new beast(""tiger"")); // create new object and end with semicolon
    a[0]-&gt;cry(); // use -&gt; instead of . to call cry method of beast object pointed at
}
</code></pre>
",2
31216866,31216818,0,"<p>The second argument of <code>MessageBoxA</code> is of type <code>LPCSTR</code>. The way you have defined <code>LoadMoveLevel</code>, the return value of <code>LoadMoveLevel(""teste"")</code> is <code>void</code>. That's what the compiler is complaining about.</p>

<p>If the function that lives at the address <code>0x0051DF70</code> is supposed to return <code>void</code> indeed, you cannot use <code>LoadMoveLevel</code>. If that function is supposed to return a <code>LPCSTR</code>, then, you have to change <code>LoadMoveLevel</code> to:</p>

<pre><code>#define LoadMoveLevel ((LPCSTR (*) (char *)) 0x0051DF70)
</code></pre>

<p>and then, the call</p>

<pre><code>MessageBoxA(NULL, LoadMoveLevel(""teste""), ""example"", MB_OK);
</code></pre>

<p>should work.</p>
",0
31216869,31216818,1,"<p>According to definition of <code>MessageBoxA</code>,</p>

<blockquote>
  <p>int WINAPI MessageBox(<br>
        _In_opt_ HWND    hWnd,<br>
        _In_opt_ LPCTSTR lpText,<br>
        _In_opt_ LPCTSTR lpCaption,<br>
        _In_     UINT    uType);  </p>
</blockquote>

<p>When you call <code>MessageBoxA(NULL, LoadMoveLevel(""teste""), ""example"", MB_OK);</code>, the 2nd parameter needs a <code>LPCTSTR</code>, but you return <code>void</code> by</p>

<p><code>#define LoadMoveLevel ((void(*) (char *)) 0x0051DF70)</code></p>
",0
31216875,31216818,1,"<p>Per the <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms645505(v=vs.85).aspx"" rel=""nofollow noreferrer"">documentation</a> the <code>MessageBoxA</code> function has the following signature:</p>

<blockquote>
  <p>int WINAPI MessageBox(<br>
   _In_opt_ HWND    hWnd,<br>
   _In_opt_ LPCTSTR lpText,<br>
   _In_opt_ LPCTSTR lpCaption,<br>
   <em>In</em>     UINT    uType<br>
  );</p>
</blockquote>

<p>You can see that the 2nd argument is of type <code>LPCTSTR</code> but you're function returns <code>void</code>. Therefore, you cannot call it in the 2nd parameter because it does not return the required type.</p>

<p><code>#define LoadMoveLevel ((void(*) (char *)) 0x0051DF70)</code><br>
<code>//                      ^^^^ // This is the return type of the function</code></p>

<p><strong>Note:</strong> The 'A' appended to the message box function name means you're using the ANSI version (as opposed the the UNICODE version) and the 2nd argument is actually <code>LPCSTR</code> (i.e., <code>const char*</code>) in your case.</p>

<p>As <a href=""https://stackoverflow.com/users/434551/r-sahu"">R Sahu</a> mentions to call it as a parameter the the message box function the return type would need to be changed from <code>void</code> to the appropriate type.</p>
",0
31216894,31216818,0,"<p>You have defined LoadMoveLevel() to be a call via a pointer to a function that returns <code>void</code>.   The second argument of <code>MessageBoxA()</code> is a (<code>const</code>) <code>char *</code>.   A return of <code>void</code> from a function does not yield any value, so cannot be converted to anything.   Hence the error.</p>

<p>What the macro is doing is converting the value to a pointer (to function) and then calling the function.   To make it compile, change your macro to either</p>

<pre><code>#define LoadMoveLevel ((LPCSTR (*) (char *)) 0x0051DF70)
</code></pre>

<p>or (expanding <code>LPCSTR</code>) to</p>

<pre><code>#define LoadMoveLevel (((char *) (*) (char *)) 0x0051DF70)
</code></pre>

<p>Note that what you are doing is extremely dangerous.   Converting an arbitrary value to a function pointer in order to call it relies on there ACTUALLY being valid code at that location.    Odds are, if you do not understand the syntax (as per your question) you do not know how to ensure that the code at that location corresponds to a function that accepts a <code>char *</code> as an argument, and returns a <code>char *</code>.</p>
",2
31217850,31216818,1,"<p>First load the interface: <code>#include ""MoveCommand.h""</code></p>

<p>Then call the function by its proper name: <code>gMoveCommand.LoadMoveLevel(""teste"");</code></p>

<p>The return value is still an <code>int</code>, not a <code>char*</code>. Please refer to the server documentation to learn about proper usage.</p>

<p>(Seeing something like <code>#define DataRecv</code> would cause me to run away from a project. Do not take any of this muOnline clone as an example of good, or even valid, C++.)</p>
",0
34196931,34196883,5,"<p>Read <a href=""https://stackoverflow.com/q/388242/841108"">more</a> about C++11. Spend a few days reading a good book on <a href=""http://www.stroustrup.com/Programming/"" rel=""nofollow noreferrer""><em>Programming in C++</em></a></p>

<p>This <a href=""http://en.cppreference.com/w/cpp/language/try_catch"" rel=""nofollow noreferrer""><code>try</code>...<code>catch</code> block</a> explanation tells that </p>

<blockquote>
  <p>When an exception of type E is thrown by any statement in compound-statement, it is matched against the types of the formal parameters T of each catch-clause in handler-seq, <em>in the order</em> in which the catch clauses are listed.</p>
</blockquote>

<p>hence you might want to order your <code>catch</code> block by putting the most frequent exceptions first (but in practice, the order does not matter much, as long as there is no overlap between <code>catch</code>....; if there is an overlap then put the most precise <code>catch</code> clause first).</p>

<p>Since in <a href=""http://en.cppreference.com/w/cpp/header/stdexcept"" rel=""nofollow noreferrer""><code>&lt;stdexcept&gt;</code></a> the <code>std::logic_error</code> is a subclass of <code>std::exception</code> you should put <code>catch(logic_error)</code> (the more precise) before <code>catch(exception)</code> (the less precise but overlapping catch)</p>
",1
34197887,34196883,2,"<p>When you throw an exception, the code in <code>try</code> block ends its execution. The program executes corresponding <code>catch</code> block, and then continues to execute lines that come after that. A <code>catch</code> block is only executed after you throw an exception.</p>

<p>If you want to continue execution after catching an exception, you should use multiple <code>try</code> blocks. The following code prints 1 and 2.</p>

<pre><code>void func1() { cout &lt;&lt; ""1"" &lt;&lt; endl; throw exception("" no t h ing ""); }
void func2() { cout &lt;&lt; ""2"" &lt;&lt; endl; throw string("" 12345 ""); }
try{
    func1();
    cout &lt;&lt; ""this is not printed"" &lt;&lt; endl;
}
catch(exception){
    // This is executed after throw
}
catch(string){
    // This is not executed
}

try{
    func2();
}
catch(exception){
    // This is not executed
}
catch(string){
    // This is executed after throw
}
</code></pre>
",5
34255690,34255595,0,"<p><code>std::ofstream</code> (<strong>out</strong> file stream) is for writing to a file.  You cannot read from a <code>std::ofstream</code>.  Use <code>std::ifstream</code> (<strong>in</strong> file stream) to read a file, or <code>std::fstream</code> if you need to use the same stream to read and write.</p>
",0
34255733,34255595,0,"<p><code>ofstream</code> is for output, you want <code>ifstream</code>.</p>
",0
30158301,30158270,1,"<p>Seems like the project is configured as a Windows application rather than a console application. </p>

<p>Since you are using int main it will not know where to start.</p>

<p>You can set the entry point to int main function in the Code::Blocks additional linker options by adding '/entry:mainCRTStartup', or just as easily create a new console application workspace.</p>
",4
30180297,30179831,0,"<p>Neither <code>memcpy</code> or <code>memmove</code> seems well suited to the task at hand.</p>

<p>Obvious choices would be <code>memset</code>, <code>std::fill</code>, <code>std::fill_n</code>, or a <code>for</code> loop.</p>

<p>Of those, <code>memset</code> works if and only if you want to fill the memory with <code>char</code>-sized items. Personally, I'd probably use <code>std::fill_n</code>.</p>
",1
34266141,34266112,6,"<p>You must open the stream with the <em>at the end</em>, <em>in</em> and <em>out</em> bits set:</p>

<pre><code>std::fstream out(""file.bin"", ios::binary | ios_base::ate);
</code></pre>

<p>This will prevent your file to be <em>reset</em> at opening; then, using <code>seekp</code> and <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream"" rel=""nofollow""><em>unformatted output</em></a> functions you will be able to edit it in the middle.</p>

<hr>

<p>This example outputs <code>stackovstrlow</code>, showing how to chain all steps together:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main()
{
    // create the bin file
    {
        std::string str(""stackoverflow\n"");
        std::ofstream file(""file.bin"", std::ios_base::binary);
        file.write(str.c_str(), str.length() + 1);
    }
    // edit the bin file ""in the middle""
    {
        std::fstream file(""file.bin"", std::ios_base::in | std::ios_base::out | std::ios_base::ate);
        file.seekp(7);
        file.write(""str"", 3);
    }
    // read and see what we've done
    std::ifstream file(""file.bin"", std::ios_base::binary);
    std::vector&lt;char&gt; v(14);
    file.read(v.data(), 14);
    std::string str(v.cbegin(), v.cend());
    std::cout &lt;&lt; str;
}
</code></pre>
",6
34266569,34266112,2,"<p>Seeking on file streams is supposed to work although not always. Notably, seeking does fail if the encoding used by the <code>imbue()</code>ed <code>std::locale()</code> is variable width. Quoting from 27.9.1.5 [filebuf.virtuals] paragraph 13:</p>

<blockquote>
  <p><em>Effects</em>: Let <code>width</code> denote <code>a_codecvt.encoding()</code>. If <code>is_open() == false</code>, or <code>off != 0 &amp;&amp; width &lt;= 0</code>, then the positioning operation fails. ...</p>
</blockquote>

<p>Assuming the file was opened OK, it would imply a <code>std::locale</code> with a non-fixed width encoding was used. The approach to avoid this issue is to use the C-locale before opening the file. For example:</p>

<pre><code>std::fstream stream;
stream.imbue(std::locale::classic());
stream.open(""file.bin"", std::ios_base::binary | std::ios_base::in | std::ios_base::out);
</code></pre>
",0
34265371,34265156,8,"<p>First, put your items into a vector since you will need to randomly access them many times:</p>

<pre><code>vector&lt;int&gt; items(itemInTest.begin(), itemInTest.end());
</code></pre>

<p>Then, if you need 100 items and don't want to pick the same one twice, you may as well just shuffle the whole thing:</p>

<pre><code>std::random_device rd;
std::mt19937 gr(rd());
shuffle(items.begin(), items.end(), gr);
</code></pre>

<p>Now just take the first 100 elements.  If you want them in a set again:</p>

<pre><code>set&lt;int&gt; result(items.begin(), items.begin() + 100);
</code></pre>

<p>Or you can use any output container type you like--including vector.</p>

<p>You can do the <code>random_shuffle</code> step again until you finish your 100 overall iterations.</p>

<p>If you don't have C++11, you can use <code>std::random_shuffle()</code> instead of <code>std::shuffle()</code>, noting that the quality of randomness may be reduced.  Then you don't need <code>std::mt19937</code>, just:</p>

<pre><code>random_shuffle(items.begin(), items.end());
</code></pre>
",10
34265467,34265156,1,"<p>You may use <a href=""http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"" rel=""nofollow"">Fisher¨CYates shuffle</a>:</p>

<p>Something like:</p>

<pre><code>// Fisher¨CYates_shuffle
std::vector&lt;int&gt; FisherYatesShuffle(std::size_t size, std::size_t max_size, std::mt19937&amp; gen)
{
    assert(size &lt; max_size);
    std::vector&lt;int&gt; b(size);

    for(std::size_t i = 0; i != max_size; ++i) {
        std::uniform_int_distribution&lt;&gt; dis(0, i);
        std::size_t j = dis(gen);
        if(j &lt; b.size()) {
            if(i &lt; j) {
                b[i] = b[j];
            }
            b[j] = i;
        }
    }
    return b;
}
</code></pre>

<p><a href=""https://ideone.com/OKc3vS"" rel=""nofollow"">Live example</a></p>

<p>then from indexes, you take value from your set (which should be transformed into <code>vector</code> for random access).</p>
",0
31184449,31184145,1,"<p>First of all your code is broken.</p>

<pre><code>cout&lt;&lt;'x'; | printf(""%c"",'x');
</code></pre>

<p>is not a valid <code>C++</code> syntax. Try only <code>cout</code> or <code>printf</code>. Like this:</p>

<pre><code>if(x&gt;0)
{
    cout&lt;&lt;'x';
    f(x/3);
    cout&lt;&lt;'y';
}
</code></pre>

<blockquote>
  <p>tell me please what does this code output</p>
</blockquote>

<p>Compile it, you will get the output.</p>

<blockquote>
  <p>show me the pseudo code</p>
</blockquote>

<p>Its a simple <a href=""https://en.wikipedia.org/wiki/Recursive_function"" rel=""nofollow"">recursive function</a> where the <em>base case</em> is </p>

<pre><code>x &lt;= 0
</code></pre>

<p>If the function <code>f ()</code> called with <code>x &gt; 0</code> then it will print the char <code>x</code> and then call <code>f ()</code> again with <code>x/3</code> and print the char <code>x</code> again and so on. After the terminating case reached it will print the char <code>y</code> the total number of time  <code>f ()</code> recursively called.</p>

<p>Note that, <em>integer</em> division discards the decimal part. Say, </p>

<pre><code>x = 7
x/3 = 7/3
x/3 = 2.3333333....
x/3 = 2 (0.33333 discarded)
</code></pre>

<p>So, if <code>-3 &lt; x &lt; 3</code> then after executing <code>f ()</code>, the recursion will terminate. </p>
",0
34256162,34254408,0,"<p>You can use a map for parsing your input:</p>

<pre><code>int main()
{
    ifstream file(""text1.txt"");                      //open file
    if(!file) { /* file could not be opened */ }     //and check whether it can be used

    std::map&lt;std::string, float&gt; com;
    std::string lastCom;                             //last command for use in ""Repeat""

    std::string line;
    while (std::getline(file, line))                 //read a line at once until file end
    {
        if(line.empty()) continue;                   //and continue if it is empty

        std::string tempCom;
        float tempVal;

        std::stringstream ss(line);                  //extract command and value
        ss &gt;&gt; tempCom;
        ss &gt;&gt; tempVal;

        if(tempCom == ""Repeat"")
        {
            com[lastCom] += tempVal;                 //add the value to the last command
        }
        else
        {
            com[tempCom] += tempVal;                 //add the value to the current command
            lastCom = tempCom;                       //and update last command
        }
    }       
}
</code></pre>

<p>The code is untested.</p>
",1
34257475,34254408,0,"<p>Well, I prefered to rewrite your code from scratch using a different container instead of filling the blanks:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main() {
    std::map&lt;std::string,int&gt; moves{{""Forward"", 0}, {""Left"", 0}, {""Right"", 0},
                                    {""Jump"", 0 }, {""Repeat"", 0}};

    auto iRepeat = moves.find(""Repeat"");
    auto iold = moves.end();

    std::ifstream iFile(""text1.txt"");
    if ( !iFile.good() ) return 1;

    std::string s;
    int x;                       // There aren't floats in your file...
    while ( iFile &gt;&gt; s &gt;&gt; x ) {
        auto im = moves.find(s);
        if ( im == iRepeat ) {
            if ( iold == moves.end() ) continue;    // there must be a move to repeat
            iold-&gt;second += x;
        } else if ( im != moves.end() ){
            im-&gt;second += x;                        // update the move
            iold = im;
        }
    }

    iFile.close();

    for ( auto i = moves.begin(); i != moves.end(); i++ ) { 
        if ( i != iRepeat )     // shows only the moves
            std::cout &lt;&lt; i-&gt;first &lt;&lt; "": "" &lt;&lt; i-&gt;second &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>

<p>The output is:</p>

<pre><code>Forward: 6
Jump: 0
Left: 20
Right: 0
</code></pre>
",0
31216820,31216803,1,"<pre><code>int *scores = new int[]; // To dynamically allocate an array
</code></pre>

<p>Above line will fail with the error message you specified in question, since you didnt specify the array length for initialization. In C++ array declaration using dynamic allocation need a constant integer as array size. </p>

<p>If you change your code as follow, or a number suitable for your need in place of 10 , will solve your issue.</p>

<pre><code>int *scores = new int[10]; // To dynamically allocate an array
</code></pre>

<p>Since you allocate memory using new operator, you should deallocate after usage as follows:</p>

<pre><code>delete[] scores;
</code></pre>
",1
31216851,31216803,1,"<p>Your error is here:</p>

<pre><code>int *scores = new int[]; // To dynamically allocate an array
</code></pre>

<p>You can't do this in C++. If you don't know the size of array you can create the pointer:</p>

<pre><code>int *scores;
</code></pre>

<p>When you will know the size, you will be able to allocate memory on heap:</p>

<pre><code>scores = new int[5]; // To dynamically allocate an array
</code></pre>

<p>About the difference between static and dynamic allocation you can read here:</p>

<p><a href=""https://stackoverflow.com/questions/6159968/declaring-array-of-int"">Declaring array of int</a></p>

<p>And delete <code>scores</code> after you are done with it or you will get memory leak.</p>
",0
31282667,31281906,0,"<p>You can do several things to speed it up. HTH.</p>

<p>One, separate inputs from processing, in the <code>main</code>. Then you can time your algo, not your typing speed. Something like</p>

<pre><code>   for(int i = 0; i &lt; lines; i++) {
      long input;
      cin &gt;&gt; input;
      p_results_array[i] = input;
    }
   for(int i = 0; i &lt; lines; i++) {
      p_results_array[i] = Factorial_expansion( (long) p_results_array[i]);
    }
</code></pre>

<p>Two, keep a map of what you already got so that you don't have to re-do calcs, such as</p>

<pre><code>#include &lt;map&gt;
map&lt;long, long&gt; fivepowers;
// and later, to check or set with known answers
</code></pre>

<p>Your <code>Divisible_by_5</code> can now be enhanced, somethng like - and notice I changed the input type of <code>const long&amp;</code> so that you retain a functional interface</p>

<pre><code>int Divisible_by_5(const long &amp;number)
{
  long hold = number;
  int result = 0;
      while(hold % 5 == 0 )
        {
          result++;
          hold = hold/5;
          if ( fivepowers.find(hold) != fivepowers.end() ) return fivepowers[hold] + result;
        }
  fivepowers[number] = result;
  return result;
}
</code></pre>

<p>Lastly, you can improvise the <code>Factorial_expansion</code> knowing that the answer for 10,11,12,13,14 is the same as for 10. For the first pass, you need to find out how much ahead of a 5X you are, and bring the next number to an exact 5X. Thereafter, reduce by 5, not by 1. So, some math and some programming.</p>

<pre><code>int Factorial_expansion(const long &amp;number)
{
  long hold = number;
  int result = 0;
  int adjuster = number % 5;
  if ( adjuster == 0 ) adjuster = 5; // else you double-count sometimes
  while(hold &gt; 4)
    {
      result += Divisible_by_5(hold);
      hold -= adjuster;
      adjuster = 5;
    }
  return result;
}
</code></pre>

<p>I will be curious what timing you get. </p>
",2
31230017,31229865,0,"<p>pointers are important for performance example of this are for functions. originally when you pass a value in a function it copies the value from the argument and stores to the parameter 
but in pointers you can indirectly access them and do what you want</p>
",1
31230473,31229865,2,"<p>Anyplace you would want to use a reference, but have to allow for <code>null</code> values</p>

<p>This is common in libraries where if you pass a non zero pointer, it will be set to the value</p>

<p>It is also a convention to have arguments to a function that will be changed to use a pointer, rather than a reference to emphasize that the value can be changed to the user.</p>
",0
31230102,31229865,1,"<p>Here are some cases:</p>

<ul>
<li><p><strong>Objects with large lifetime</strong>. You created some object in function. You need this object afterwards (not even copy of it).
But if you created it without pointers, on stack - after function would finish, this object would die. So you need to create this object using dynamic memory and return pointer to it.</p></li>
<li><p><strong>Stack space is not enough</strong>. You need object which needs lot of memory, hence allocating it on the stack won't fit your needs, since stack has less space than heap usually. So you need to create the object again using dynamic memory on heap and return pointer to it.</p></li>
<li><p><strong>You need reference semantics</strong>. You have structure which you passed to some function and you want the function to modify this structure, in this case you need to pass a pointer to this structure, otherwise you can't modify the original structure, since copy of it will be passed to the function if you don't use pointers. </p></li>
</ul>

<p>Note: in the latter case, indeed using pointer is not necessary, since you can substitute it using reference. </p>

<p>PS. You can browse <a href=""https://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself"">here</a> for more scenarios, and decide in which cases are pointer usages necessary.</p>
",5
31229900,31229865,2,"<p>If you are using a C Library which has a function that returns a pointer, you have to use pointers then, not a reference.</p>
",0
31229927,31229865,2,"<p>There are many other cases (explicitly dealing with memory, for instance) - but these two came to my mind first:</p>

<p><strong>linked data-structures</strong></p>

<p><em>How:</em> You need to reference parts of your structure in multiple places. You use pointers for that, because containers (which also use pointers internally) do not cover all your data-structure needs. For example,</p>

<pre><code>  class BinTree {
      BinTree *left, *right;
  public:
      // ...
  };
</code></pre>

<p><em>Why there is no alternative:</em> there are no generic tree implementations in the standard (not counting the sorting ones).</p>

<p><strong>pointer-to-implementation pattern</strong> (pimpl)</p>

<p><em>How:</em> Your public <code>.hpp</code> file has the methods, but only refers to internal state via an opaque <code>Whatever *</code>; and your internal implementation actually knows what that means and can access its fields. See:
<a href=""https://stackoverflow.com/questions/8972588/is-the-pimpl-idiom-really-used-in-practice"">Is the pImpl idiom really used in practice?</a></p>

<p><em>Why there is no alternative:</em> if you provide your implementation in binary-only form, users of the header cannot access internals without decompiling/reverse engineering. It is a much stronger form of privacy.</p>
",0
31229974,31229968,2,"<p>Yes, that'll work for single bytes.</p>

<p>Alternatively, you can do <code>byte &amp; 0x80</code> to avoid the shifting.</p>
",1
31264107,31264027,3,"<p><strong>Advantages of passing by reference:</strong> </p>

<ol>
<li>It allows us to have the function change the value of the argument, which is sometimes useful. </li>
<li>Because a copy of the argument is not made, it is fast, even when used with large structs or classes. </li>
<li>We can pass by const reference to avoid unintentional changes. </li>
<li>We can return multiple values from a function. </li>
</ol>

<p><strong>Disadvantages of passing by reference:</strong> </p>

<ol>
<li>Because a non-const reference can not be made to a literal or an expression, reference arguments must be normal variables. </li>
<li>It can be hard to tell whether a parameter passed by reference is meant to be input, output, or both. </li>
<li>It¡¯s impossible to tell from the function call that the argument may change. An argument passed by value and passed by reference looks the same. We can only tell whether an argument is passed by value or reference by looking at the function declaration. This can lead to situations where the programmer does not realize a function will change the value of the argument. </li>
<li>Because references are typically implemented by C++ using pointers, and dereferencing a pointer is slower than accessing it directly, accessing values passed by reference is slower than accessing values passed by value.</li>
</ol>

<p><strong>Sources</strong>:</p>

<ol>
<li><p><a href=""http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/"" rel=""nofollow"">http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/</a></p></li>
<li><p><a href=""http://www.functionx.com/cppcli/functions/Lesson10b.htm"" rel=""nofollow"">http://www.functionx.com/cppcli/functions/Lesson10b.htm</a></p></li>
<li><p><a href=""https://en.wikibooks.org/wiki/C++_Programming/Code/Statements/Functions"" rel=""nofollow"">https://en.wikibooks.org/wiki/C++_Programming/Code/Statements/Functions</a></p></li>
</ol>
",1
31264931,31264027,1,"<p><code>int &amp;a</code> is a reference to any parameter passed to that function, You should always  think of references as Alias to a variable (it is similar to a <code>const</code> pointer).</p>

<p>If your reference is not <code>const</code> you are allowed to changed and therefore change the content of the original variable. </p>

<p>It is useful for many reason first of all it can improve performances by avoiding doing copies when passing a parameter by reference, and it is also useful if you have a function that your expecting to return multiple results for example =:</p>

<pre><code>int f (int &amp;a,int &amp;b,int &amp;c,int&amp;d);

int main
{
    int first,second,third,result;
    result = f(first,third,result);
} 
</code></pre>

<p>All your <code>int</code> variables can be change within you function. </p>
",0
31264641,31264027,1,"<p>There is already a good answer (imho worth accepting). However, I would like to give a more basic answer, as it seems like you encountered passing by reference for the first time:</p>

<p>This function:</p>

<pre><code>void foo(int x){x +=1;}
</code></pre>

<p>can do anything with the value of the passed (by value) parameter, but it has no chance to return anything to the caller, i.e. the <code>x+=1</code> has practically no effect at all.</p>

<p>On the other hand, this function:</p>

<pre><code>void bar(int&amp; x){x +=1;}
</code></pre>

<p>gets not only the value, but it is working on the actual variable that you pass as parameter (by reference). Thus the <code>x+=1</code> has an effect also outside of the function.</p>

<p>Both functions in action:</p>

<pre><code>int main(){
    int a = 1;
    foo(a);      // foo gets a copy of a and increments its value
                 // a is still 1
    bar(a);      // bar directly increments the value of a
                 // a is now 2
}
</code></pre>

<p>This is the main difference of passing a parameters by reference (bar) vs passing by value (foo). The main advantage of passing by reference is that the value of the parameter needs not to be copied. (This is whypassing by value is usually done with a const reference. Passing a const reference is like passing the value because the value cannot be changed even if actually a reference is passed.) However, for more details I refer to Rohits answer.</p>
",0
31302785,31302592,3,"<p>This condition in the if statement</p>

<pre><code>if  (choice != 1||2||3)
</code></pre>

<p>is equivalent to</p>

<pre><code>if  ( ( choice != 1 ) || 2 || 3 )
</code></pre>

<p>So it is always equal to <code>true</code> because even if <code>choice != 1</code>  evaluates to <code>false</code> nevertheless expressions <code>2</code> and <code>3</code> are always unequal to zero and consequently each of them evaluate to <code>true</code>.</p>

<p>What you mean is the following</p>

<pre><code>if  ( ( choice != 1 ) &amp;&amp; ( choice != 2 ) &amp;&amp; ( choice != 3 ) )
</code></pre>

<p>Or you could write it simpler</p>

<pre><code>if  ( choice &lt; 1  || choice &gt; 3 )
</code></pre>

<p>Or maybe this one will be more readable</p>

<pre><code>if  ( !( 1 &lt;= choice &amp;&amp; choice &lt;= 3 ) )
</code></pre>

<p>or even the following way:)</p>

<pre><code>if  ( not ( 1 &lt;= choice &amp;&amp; choice &lt;= 3 ) )
</code></pre>

<p>Take into account that you could this part of the program enclose in do-while loop. For example</p>

<pre><code>int choice;
bool valid_input;

do
{
    cout &lt;&lt; ""Choose option 1,2 or 3: \n"";
    cout &lt;&lt; ""1: Drop a single chip into one slot \n"";
    cout &lt;&lt; ""2: Drop multiple chips into one slot \n"";
    cout &lt;&lt; ""3: Quit the program \n"";

    if ( !( cin &gt;&gt; choice ) ) break;

    valid-input  = 1 &lt;= choice &amp;&amp; choice &lt;= 3;

    if  ( !valid_input )
    {
        cout &lt;&lt; ""Please enter 1 2 or 3 \n"";
    }
} while ( !valid_input );

if ( valid_input )
{
    cout &lt;&lt; ""it worked. There was selected option "" &lt;&lt; choice &lt;&lt; std::endl;
}
</code></pre>
",0
31302701,31302592,1,"<blockquote>
  <p>Did I use my or operator wrong?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>if  (choice != 1||2||3)</p>
</blockquote>

<p>What this really does:</p>

<p><code>if ((choice != 1) || (2) || (3))</code></p>

<p>which is to say: ""if choice does not equal 1 or true or true"". </p>

<p>This is the same as doing <code>if (true)</code>.</p>

<p>What you want to do is:</p>

<p><code>if (choice != 1 &amp;&amp; choice != 2 &amp;&amp; choice != 3) { ... re-enter number }</code></p>
",1
31302712,31302592,3,"<p>Its because your <code>if</code>:</p>

<pre><code>choice != 1||2||3  
</code></pre>

<p>is evaluating to: </p>

<pre><code>int != int|| true || true
</code></pre>

<p>And thats always true (something OR yes OR yes -> yes)</p>

<p>Every non-zero integer (<code>x!=0</code>) value casted to boolean will become <code>true</code>.   </p>

<p>Its because humans and computers cant make decision on <code>1</code> number - you must change it to <code>true</code> or <code>false</code> (yes or no)</p>

<p>To resolve the problem simply change it to: </p>

<p><code>if (choice != 1 &amp;&amp; choice != 2 &amp;&amp; choice != 3)</code></p>

<p>EDIT:  Thanks to @StillLearning for improvements</p>
",0
31302722,31302592,-4,"<p>You need this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {

    cout &lt;&lt; ""Choose option 1,2 or 3: \n"";
    cout &lt;&lt; ""1: Drop a single chip into one slot \n"";
    cout &lt;&lt; ""2: Drop multiple chips into one slot \n"";
    cout &lt;&lt; ""3: Quit the program \n"";

    int choice;
    cin &gt;&gt; choice; 

    if  (choice != 1 || choice != 2 || choice != 3)
    {
        cout &lt;&lt; ""Please enter 1 2 or 3 \n"";
        cin &gt;&gt; choice;
    }
    else 
    {
        out &lt;&lt; ""it worked \n"";
    }
}
</code></pre>
",3
32402597,32402427,1,"<p>You didn't call <code>GetLastError()</code>, which you should always do when a Windows function fails, but the most likely cause is that you failed to fill in <code>FileData</code> correctly before calling <code>FindFirstFile</code>.</p>

<p>Nearly all output buffers for use by Windows functions must be prepared:</p>

<ul>
<li>Populate the <code>dwSize</code> member using <code>sizeof</code> (this structure doesn't have this)</li>
<li>Fill all other members with zero.</li>
</ul>

<p>So try initializing the buffer with:</p>

<pre><code>WIN32_FIND_DATAA FileData = {};
</code></pre>
",1
34186823,34186728,3,"<p>You can define a conversion operator to make <code>int i = my_id</code> work:</p>

<pre><code>class IDCard {
    int id;
public:
    operator int() const { return id; }
};
</code></pre>

<p>However I'd strongly advise against it and recommend using a normal accessor method instead:</p>

<pre><code>class IDCard {
private:
    int id_;
public:
    int id() const { return id_; }
};
</code></pre>
",1
32446160,32446084,1,"<p><code>putback</code> puts its parameter back into the input stream, making it the next character to be read.  To see it at work, change your loop to the following and watch the program enter an endless loop:</p>

<pre><code>while (next != '2') {
    fin.get(next);
    fin.putback(next); // This will cause an infinite loop
    fout.put(next);
}
</code></pre>

<p>This happens because the very first <code>5</code> you read will be immediately put back into the input stream, causing <code>next</code> to never become <code>2</code>.</p>
",0
32446881,32446084,0,"<blockquote>
  <p>What does this mean exactly?</p>
</blockquote>

<p>I think it means something like</p>

<ul>
<li><p>each character of a text file 'resides' at a certain 'position indicator' in the file (you may also have read about 'file offset').</p></li>
<li><p>get() transfers a copy of the value at the current 'position', to your variable (called next), and then</p></li>
<li><p>increments the 'position' indicator (i.e. simulates 'consumption' of the char)</p></li>
</ul>

<p>Note that there is a buffer associated with 'ifstream fin'. fin handles lots of specifics that I think you don't want to worry about. For instance, what causes transfers (from the current 'position') some of the file contents from disk to the buffer (of fin) so that 'get()' knows where to find it.  How much of the file is buffered?  etc.</p>

<ul>
<li>putback() decrements the 'position' indicator, </li>
</ul>

<p>Although this is probably too simple a description of all the stuff going on, the result is no change to the file.  The next get() will read the same char once again. </p>

<p>Now consider the test case where the user code puts back the last character of the previous full buffer; or the test case where the user code puts back the last n chars read.  Just be glad it is being done for you.</p>

<p>Your experiment is flawed. I hope the above helps you devise a better experiment.  </p>

<p>I suggest you do a small number of get(), then use tellg to see if it changes for each get or putback.  Also, experiment with seekg.</p>

<p>Hope this helps. </p>
",0
32472426,32471813,2,"<p>Try setting <code>rtemp</code> to double, since this line:</p>

<pre><code>rtemp = repRate[j+1];
</code></pre>

<p>will cut off some accuracy. That should be a warning on your compiler, if not enable warnings!</p>

<p>After that the output is like this:</p>

<pre><code>5
1 10 3456
2 10 5644
3 10 4566
4 20 234
5 20 232
344.6
563.4
455.6
10.7
10.6
0
</code></pre>

<p>where 0 is what you want.</p>
",0
34239627,34239000,0,"<p>I think what you are looking for is <a href=""https://en.wikipedia.org/wiki/Multiple_dispatch"" rel=""nofollow"">multiple dispatch</a>. 
Unfortunately C++ does not provide multiple dispatch (only single dispatch) and it is <a href=""http://www.stroustrup.com/multimethods.pdf"" rel=""nofollow"">discussed</a>. </p>

<p>You can find a way around using <strong>dynamic_cast</strong> with something like :</p>

<pre><code>bool IsIntersecting(Collider&amp; coll1, CircleCollider&amp; coll2) {
  if (CircleCollider* circle_collider = dynamic_cast&lt;CircleCollider*&gt;(&amp;coll1)) {
    // do what you need 1
  else if (BoxCollider* box_collider = dynamic_cast&lt;BoxCollider*&gt;(&amp;coll1)) {
   // do what you need 2
  }
}
</code></pre>

<p>On the wiki article they also mention other alternatives such as using the visitor pattern or pointer-to-method lookup table. </p>

<p>Or maybe a better idea : redesign your code to avoid such complications. </p>
",1
33820250,33819871,0,"<p>How about this:-</p>

<pre><code>int number1 = 2;
int number2 = 6;
float number3 = static_cast&lt;float&gt;(number1) / static_cast&lt;float&gt;(number2);
bool isfraction = number3 &gt; 0 &amp;&amp; number3 &lt; 1;
if(isfraction){
    std :: cout &lt;&lt; ""true\n"" &lt;&lt; number3;  
}
else{
    std :: cout &lt;&lt; ""false"" &lt;&lt; number3;
}
</code></pre>
",0
33820269,33819871,0,"<p>The quotient is 0(2/6) with the fractional part discarded.The fractional part is .3333 ... So you are basically talking about the fractional part of the quotient , not the modulus value. Modulus can be calculated as follows :</p>

<pre><code>(a / b) * b + (a % b) = a
(2 / 6) * 6 + (2 % 6) = 2
0 * 6 + (2 % 7) = 2
(2 % 6) = 2
</code></pre>

<p>*6 goes into 2 zero times with 2 left over.</p>
",0
33820842,33819871,0,"<p><code>number != 0</code> includes <code>number &gt; 0</code> and <code>number &lt; (0 x &lt; 1)</code>. And <code>number &gt; 0</code> includes <code>number &lt; (0 x &lt; 1)</code>. Generally we do not classify so. For example, people classify <code>number &gt; 0</code>, <code>number == 0</code> and <code>number &lt; 0</code>.<br>
If you do the modulous operation, you get remainder. Remainder's definition is not one thing. You can see it at <a href=""https://en.m.wikipedia.org/wiki/Remainder"" rel=""nofollow"">https://en.m.wikipedia.org/wiki/Remainder</a></p>
",0
32416807,32416744,0,"<p>If a function's parameter is unused, you don't have to give it a name. In this case, these functions are <code>virtual</code>, meaning they're expected to be overridden by a derived class, which may use these parameters in the overridden function definitions.</p>

<p><code>const IContact* = 0</code> means an unused parameter of type ""pointer to const <code>IContact</code>"" whose value is not required to be specified by the caller, and null is used if the caller omits its value.</p>

<p><code>const QVariant&amp;</code> is an unused parameter of type ""reference to const <code>QVariant</code>"". The caller must still specify its value, however.</p>
",6
32415521,32415244,1,"<p>The problem is </p>

<pre><code>Monster monsters[4]; // ---&gt; Means initiliaze 4 Monsters with a ctor which takes no arguments(eg default Ctor) 
Player player;  ---&gt; //The initiliaze 1 Player with a ctor which take no arguments
</code></pre>

<p>Since you defined Monster(int xPos, int yPos); default Ctors are deleted. You have to define them yourself. Entity has the same problem. I compiled your code , if you do like below it will work. </p>

<p>Add ""Entity() = default;"" , initiliaze x and y like below, </p>

<pre><code>class Entity {
    protected:
        int x = 0;  --&gt; Critical 
        int y = 0;  --&gt; Critical 
        char sign;
    public:
        Entity() = default; --&gt; Critical 
        Entity(int xPos, int yPos);
        int getX();
        int getY();
        void move(int xPos, int yPos);
        char getSign();
};
</code></pre>

<p>Do the same for player and monster </p>

<pre><code>class Monster : public Entity {
    private:
        char sign = 'M';
    public:
        Monster(int xPos, int yPos);
        Monster() = default; --&gt; Critical 
        void moveTowards(Entity p);
};


class Player : public Entity {
    private:
        char sign = 'P';
    public:
        Player() = default; --&gt; Critical 
        Player(int xPos, int yPos);
};
</code></pre>
",1
32415525,32415244,0,"<p>You should add a default constructor to your Monster class because it's implicitly called when the Monster array is initialized. If you don't want to do that for some reason, you could change the Monster array contain raw or smart pointers to Monster objects.</p>
",0
32432434,32432387,1,"<p>Since the <code>age</code> variables are <code>int</code>, the <code>cin &gt;&gt; age1;</code> will leave the newline character in the input stream. When next you call <code>getline()</code>, you will get the remainder of that line - which is empty, and so on.</p>

<p>Also, you have a copy-paste bug in your code. <code>getline(cint, studentname2);</code> is run for students 2, 3 and 4.</p>

<p>You can either solve the problem by using <code>getline()</code> for all input:</p>

<pre><code>string agestring;
getline(cin, agestring)
stringstream(agestring) &gt;&gt; age1;
</code></pre>

<p>or clear <code>cin</code> when you're done reading the age:</p>

<pre><code>cin &gt;&gt; age1;
cin.ignore();
</code></pre>
",0
32446594,32446444,1,"<p>You'll have to link the project having <code>camera.cpp</code> with the main project.</p>

<ul>
<li><p>Project 2: (containing camera.cpp ) Create a static/dynamic library.</p></li>
<li><p>Project 1: (containing main ) Create the executable providing the <em>.lib</em> of the Project 2</p></li>
</ul>
",1
32451106,32450890,1,"<p>if i understood your question:</p>

<p>there are 2 ways you can do that.</p>

<ol>
<li><p>make <strong>lettersort</strong> function return the new value, and put it in af2</p>

<pre><code>int lettersort(int cnt1) {
    cout &lt;&lt; ""RESULT:"" &lt;&lt; cnt1 &lt;&lt; endl;
    cnt1++;
    cout &lt;&lt; ""RESULT WHEN+:"" &lt;&lt; cnt1 &lt;&lt; endl;
    cout &lt;&lt; ""RESULT IN GLOBAL INT:"" &lt;&lt; af2 &lt;&lt; endl;
    return cnt1;
}
int main()
{
af2 = lettersort(af2);
return 0;
}
</code></pre></li>
<li><p>pass the value by reference. you can read about it <a href=""http://www.learncpp.com/cpp-tutorial/73-passing-arguments-by-reference/"" rel=""nofollow"">here</a>, but generally its about passing a pointer to that value. meaning whatever you do on the argument you are passing, will happen on the original var.</p></li>
</ol>

<p>example:</p>

<pre><code>    void foo(int &amp;y) // y is now a reference
    {
        using namespace std;
        cout &lt;&lt; ""y = "" &lt;&lt; y &lt;&lt; endl;
        y = 6;
        cout &lt;&lt; ""y = "" &lt;&lt; y &lt;&lt; endl;
    } // y is destroyed here

    int main()
    {
        int x = 5;
        cout &lt;&lt; ""x = "" &lt;&lt; x &lt;&lt; endl;
        foo(x);
        cout &lt;&lt; ""x = "" &lt;&lt; x &lt;&lt; endl;
        return 0;
    }
</code></pre>
",0
32450921,32450890,3,"<p>At the moment you are just passing <code>af2</code> to <code>cnt1</code> <em>by value</em>, so any changes to <code>cnt1</code> are strictly local to the function <code>lettersort</code>. In order to get the behaviour you want you need to pass your <code>cnt1</code> parameter <em>by reference</em>. Change:</p>

<pre><code>void lettersort(int cnt1)
</code></pre>

<p>to:</p>

<pre><code>void lettersort(int &amp;cnt1)
</code></pre>
",1
32452636,32450890,1,"<ul>
<li>here you have to just modified the argument pass to lettersort
function   as passed by reference.</li>
<li><p>for example if you declare and initialize any variable like:</p>

<pre><code>  int a=10;    int &amp;b = a;
</code></pre></li>
<li><p>now a and b refer to the same value.if you change a then the changes
also reflect in b also.</p></li>
<li><p>so,  </p>

<pre><code>  cout &lt;&lt; a; cout &lt;&lt; b;
</code></pre></li>
<li><p>both statement produce the same result across the program. so using
this concept i modified the function argument and    made it as by
reference.</p></li>
<li><p>your correct code is :</p>

<pre><code>  #include &lt;iostream&gt;


  #include &lt;string&gt;
  using namespace std;
  int af1 = 1;
  int af2 = 1;
  void lettersort(int &amp;cnt1) {
  cout &lt;&lt; ""RESULT:"" &lt;&lt; cnt1 &lt;&lt; endl;
  cnt1++;
  cout &lt;&lt; ""RESULT WHEN+:"" &lt;&lt; cnt1 &lt;&lt; endl;
  cout &lt;&lt; ""RESULT IN GLOBAL INT:"" &lt;&lt; af2 &lt;&lt; endl;
  }

  int main()
  {
  lettersort(af2);
  return 0;
  }
</code></pre></li>
</ul>
",0
32450952,32450890,2,"<p>You are passing the argument <strong>by value</strong>. I.e., you are copying the value of <code>af1</code> to a local variable in <code>lettersort</code>. This integer is then incremented, and disposed of when the function ends, without affecting the original <code>af1</code>. If you want the function to be able to affect <code>af1</code>, you should pass the argument <strong>by reference</strong>:</p>

<pre><code>void lettersort(int&amp; cnt1) { // Note the ""&amp;""
</code></pre>
",0
32463408,32463268,2,"<p>You do not need two loops to use the straightforward linear search:</p>

<pre><code>int best = 0;
for (int i = 1 ; i != W ; i++) {
    if (pr[i]*ca[best] &lt; pr[best]*ca[i]) {
        best = i;
    }
}
</code></pre>

<p>Note that the loop starts at index 1, not 0, because we do not need to compare the <code>pr[0], ca[0]</code> pair with itself.</p>
",5
32941081,32941059,3,"<p>You need a range of numbers so input <em><strong>two</strong></em> numbers</p>

<pre><code>int num1, num2;

cin &gt;&gt; num1 &gt;&gt; num2;

int sum=0;
int mul = 1; // Initialize mul to 1, since anything multiplied by 0, results in 0

for (int i = num1; i &lt;= num2; i++) // Start from num1 and end to num2
{
    sum += i;
    //while (i &lt;= num1)  // Don't need another loop
    //{
        mul *= i;
    //}
}
</code></pre>
",0
32977979,32977945,1,"<p><code>else if ((time_start &lt; 800) &amp;&amp; (time_start &gt; 1800))</code></p>

<p>It is not possible that a number can be less than 800 and be bigger than 1800. I'm assuming you meant:</p>

<p><code>else if ((time_start &lt; 800) || (time_start &gt; 1800))</code></p>
",0
32977981,32977945,1,"<p>You've got a <em>'logic bug'</em>: use <code>||</code> instead of <code>&amp;&amp;</code> in <code>else if</code>. It's simply impossible for a number to be less than 800 and greater than 1800 <em>at the same time</em>.</p>
",2
32977984,32977945,0,"<p>As soon as I asked this question I realized my second else if statement should be an or || statement instead of &amp;&amp;.</p>
",0
32978009,32977945,0,"<p>change</p>

<blockquote>
  <blockquote>
    <p>else if ((time_start &lt; 800)  (time_start > 1800</p>
  </blockquote>
</blockquote>

<p>to</p>

<blockquote>
  <blockquote>
    <p>else if ((time_start &lt; 800) || (time_start > 1800</p>
  </blockquote>
</blockquote>
",0
32978050,32977945,0,"<p>You can simplify the code to this, else statement is not needed. Store the value in coeficient variable, that's needed to be defined before</p>

<pre><code>// else coef (default value)
float coef = 0.25;
if ((time_start &gt;= 800) &amp;&amp; (time_start &lt;= 1800))
{
    coef = 0.40; // if true
}
cout &lt;&lt; ""How many minutes did your call last? "";
cin &gt;&gt; minutes;
// use coef here and remove duplicate calls
cost = minutes * coef;
cout &lt;&lt; setprecision(2) &lt;&lt; fixed &lt;&lt; cost;
system(""pause"");
keepgoing = false;
</code></pre>
",0
32979267,32979223,0,"<p>There are a number of issues with your <code>printMatch</code> function. Give this a try</p>

<pre><code>void printMatch()
{
    int x1 = 4, y1 = 3, x2 = 2, y1 = 1; //you'll need to define these values in some useful way
    int attempt = 0;

    int match = isMatch(x1, y1, x2, y2);

    if(match == 2)
    {
        cout &lt;&lt; ""You have a match!"";
        attempt++;
    }
}
</code></pre>
",10
32979288,32979223,2,"<p>Change your printMatch() function to this:</p>

<pre><code>void printMatch(int x1, int y1, int x2, int y2)
{
    int attempt;

    int temp = isMatch(x1, y1, x2, y2);

    if(temp == 2)
    {
        cout &lt;&lt; ""You have a match!"";
        attempt++;
    }
}
</code></pre>

<p>This saves your return value from the <code>isMatch</code> function to a variable named <code>temp</code>. Use can then use this variable <code>temp</code> to test your condition.</p>
",0
32993454,32992425,0,"<p>You can't make that code work as written since <code>x</code> and <code>y</code> are private.</p>

<p>If you make them public, this will work:</p>

<pre><code>XY* operator -&gt;() 
{
    return this;
}
</code></pre>
",0
33038892,33033832,0,"<p>If <code>i==100</code>, what do you think <code>(1 &lt;&lt; i)</code> does? What <em>should</em> it do? And why are you ignoring <code>a[0]</code> in <code>GetQInt</code> ?</p>

<p>In general, you have quite a few problems. You're not comfortable with <code>std::string</code>, and making a mess of the <code>char*</code> everywhere. You're not clearly articulating (not even to yourself) what methods are supposed to be doing. You're putting mathods in a class that are unrelated to the class. Even worse, some of those methods <em>redefine</em> the name <code>a</code> ! That is very confusing.</p>
",0
30158281,30158164,1,"<p>The reason you are getting the wrong result, is that in your recursive call, you constantly invert the result:</p>

<pre><code>float power(float x, float y) {
    float c;
    cout &lt;&lt; y &lt;&lt; endl;
    if (y == 0) return 1;
    c=x*power(x, (y+1)); //result previous call (can already been inversed)
    return (1/c); //the inversion step
}
</code></pre>

<p>What thus happens is:</p>

<pre><code>pow(2,-2)
    pow(2,-1)
        pow(2,0) = 1
        return 1/(2*1)=0.5
    return 1/(2*0.5)=1 (here you undo the effect)
</code></pre>

<p>I've omitted the calculations in between, because these are not ""relevant"" to show what is wrong. Or a more advanced example:</p>

<pre><code>pow(2,-4)
    pow(2,-3)
        pow(2,-2)
            pow(2,-1)
                pow(2,0) = 1
                return 1/(2*1)=0.5
            return 1/(2*0.5)=1 (here you undo the effect)
        return 1/(2*1)=0.5
    return 1/(2*0.5)=1 (here you undo the effect)
</code></pre>

<p>Thus you multiply by <code>x</code> and divide by <code>x</code>. If the original <code>y</code> is even, it will always result in <code>1.00</code>, otherwise it will result in <code>1/x</code>. Furthermore this method will never end if you provide a positive exponent.</p>

<p>If you don't invert constantly, it will (in the case of a negative <code>y</code>), simply calculate <code>x^-y</code>, so you can do the inversion post-call.</p>

<p>But your method is in general rather error-prone: performing increment/decrement on floats as well as checking on zero is known to ask for trouble. Furthermore your algorithm isn't very efficient. A better way to solve this (with integral power), is:</p>

<pre><code>float power(float x, int y) {
    if(y &lt; 0) {
        return 1.0f/power_positive(x,-y);
    } else {
        return power_positive(x,y);
    }
}
float power_positive(float x, int y) {
    if(y == 0) {
        return 1.0f;
    }
    float r = power_positive(x*x,y&gt;&gt;0x01);
    if(y&amp;0x01) {
        r *= x;
    }
    return r;
}
</code></pre>

<p>This algorithm will work faster as well since it divides the exponent by half each time. As said before, it however works only for integral exponents. You can generalize it. But I would trust the 80x87-coprocessor more with floating point arithmetic anyway.</p>
",0
34192651,34192379,0,"<p>There really is value in keeping code pretty (esp. standardized indentation).  It will help you find these mismatched brace issues easier.</p>

<p>It's much easier if you write pretty code to start, but you can use your editor to help. If your editor doesn't have a code reformatter feature, think about getting another editor.   Most editors will also have a find matching brace feature.  If you put the cursor on a brace, parenthesis, or bracket it the brace match key will find the corresponding open or close and you can verify if this is what you expect.</p>
",0
33596032,33595996,2,"<p>No, you do not need to reinitialize x = 0 in your code. That's what the x=0 in your for loop is for. The for loop automatically initializes x to the value you set when starting.</p>
",0
33596045,33595996,3,"<p>Lets take a simple <code>for</code> loop, like the one you have:</p>

<pre><code>for (i=0; i&lt;7; i++)
{
    // statements...
}
</code></pre>

<p>It's equivalent to the following code:</p>

<pre><code>{
    i=0;
    while (i&lt;7)
    {
        // statements...
        i++;
    }
}
</code></pre>

<p>This is for <em>all</em> <code>for</code> loops.</p>

<p>So to answer your question: The initialization is done before the <code>for</code> loop <em>always</em>.</p>
",1
34217578,34217514,0,"<p>In the start of each loop(x) you should reset n to 0.</p>

<p>Also you should move the statment </p>

<pre><code>cout &lt;&lt; x &lt;&lt; "": "" &lt;&lt; n &lt;&lt; endl;
</code></pre>

<p>From the second loop the end of the first loop</p>
",0
34079661,34079647,3,"<p>It doesn't match because the function you're trying to define returns <code>void</code>:</p>

<pre><code>void Library::checkOutBook(std::string pID, std::string bID)
</code></pre>

<p>but the declaration in the <code>Library</code> class says it returns <code>std::string</code>:</p>

<pre><code>std::string checkOutBook(std::string pID, std::string bID);
</code></pre>

<p>Also, remove that semicolon between the <code>)</code> and the <code>{</code> in the function header.</p>
",5
34080392,34080179,1,"<p>The name of the variable is the same name of the function you are calling. You can change eighter the name of the variable or the name of the function. Usually when you are using C++ and declaring variables is a good practice to initialize the value of the double to something like 0.0. </p>

<p>And you are using 2 lines: 1 for declare the variable and another to give it the value when you can perfectly do this in one line. Better code uses less lines always keep it in mind.</p>

<p>This was my approach:</p>

<pre><code>#include ""stdafx.h""
#include &lt;iostream&gt;
#include ""constant.h"" //comented

double Gettowerheight()
{
  std::cout &lt;&lt; ""Input tower height"" &lt;&lt; std::endl;
  double height;
  std::cin &gt;&gt; height;
  return height;
}

double ballheight(double towerheight)
{
  return 0.0;
//valid stuff goes here in program, but not applicable to question
}

int main()
{
   double towerheight = Gettowerheight();
   ballheight(towerheight);
   system(""pause"");
   return 0;
 }
</code></pre>

<p>I put a return in the ballheight to compile the code as well as comment the 3rd include ""constant.h""</p>

<p>Tested on Visual Studio 2013</p>
",1
34080250,34080179,2,"<p>In <code>main</code>, the variable named <code>towerheight</code> shadows the function <code>towerheight</code>. Hence,</p>
<pre><code>towerheight = towerheight(); 
</code></pre>
<p>is not valid. It is analogous to calling a function on a variable.</p>
<pre><code>double towerheight;
double dummy;
towerheight = dummy();
</code></pre>
<p>That's why it is not correct.</p>
<p><strong>Solution 1</strong></p>
<p>You can use:</p>
<pre><code>double towerheight;
towerheight = ::towerheight();
</code></pre>
<p>Using <code>::towerheight</code> works since it refers to the name in the enclosing namespace and not the locally defined variable of the same name.</p>
<p><strong>Solution 2</strong></p>
<p>Use different names.</p>
<p>You can avoid some of the confusion by using two different names.</p>
<pre><code>double t_height = towerheight();
</code></pre>
",0
34254396,34254342,2,"<p>After <code>is_sorted</code> function, file stream has reached its end. All subsequent reads will return nothing,. You are essentually trying to merge two empty streams.</p>

<p>You will need to rewind your stream after you call is_sorted. Use <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/seekg"" rel=""nofollow""><code>seekg</code> member function</a>.</p>

<pre><code>file.seekg(0)
</code></pre>
",0
34210699,34210611,10,"<p>You need to catch <code>range_error</code> first since it is derived from <code>runtime_error</code>.  Catching <code>runtime_error</code> first also catches <code>range_error</code>.</p>

<p>Also, you should catch exceptions by const reference.  By catching them by value you are making copies of them which is unneeded.</p>

<p>I would add one more thing... Generally, you don't want to use exceptions to control program flow as you are doing.</p>
",0
34219216,34217518,0,"<p>You need a template template parameter:</p>

<pre><code>template &lt;template &lt;typename...&gt; PointerType&gt;
class object
{
public:
    PointerType&lt;object&gt; _parent;
};
</code></pre>

<p>with usage similar to:</p>

<pre><code>object&lt;std::shared_ptr&gt; a;
a._parent = std::make_shared&lt;object&lt;std::shared_ptr&gt;&gt;();
</code></pre>
",0
34249747,34249634,0,"<p>I think this is what you are asking for:
Declare </p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; os, const Booking&amp; b)
{
    return os&lt;&lt;b.bT&lt;&lt;"" ""&lt;&lt;b.dT&lt;&lt;"" ""&lt;&lt;b.aT;
}
</code></pre>

<p>and declare public method in class New:</p>

<pre><code> Booking getV(int i) const { return v[i];}

friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Booking&amp; b);
</code></pre>

<p>and replace this:</p>

<pre><code> std::cout&lt;&lt;book.gB(5,6,7,0,3)&lt;&lt;std::endl;
</code></pre>

<p>with </p>

<pre><code>book.gB(5,6,7,0,3);
std::cout&lt;&lt;book.getV(i); //i represent number of booking in v
</code></pre>
",5
34239608,34238708,0,"<p>The only way this can happen is if <code>B::what()</code> does not override the function in the base class, which will happen if it's signature doesn't match the function in the base class.</p>

<p>Make sure you didn't forget to make it <code>const</code> in <code>B</code>, to match <code>const char* what() const</code> in the base class.</p>
",0
34249717,34249684,1,"<p>Code is not complete but you should use at least infile.eof() as infile.eof is a (member) function pointer and will always be non-zero (so true).</p>

<p>infile.eof() will call the member function and return something sensible.</p>
",0
34249737,34249684,1,"<p><code>eof</code> names a member function (or <em>method</em>).  You should use it as follows.</p>

<pre><code>while(inFile.eof())
</code></pre>

<p>The way you used it (i.e. without the parentheses that mandate the function to be called) mean that you're taking the address of the function.  Since that address is not zero, it will always be interpreted as a true condition.</p>
",0
25673149,25673013,0,"<pre><code>#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

string toString(int a) {
    float f = a * 0.1f;
    ostringstream ss;
    ss &lt;&lt; f;
    return ss.str();
}

int main() {
    cout &lt;&lt; toString(101);
    return 0;
}
</code></pre>
",3
25673200,25673013,2,"<p>Dividing by 10 can cause precision loss if the numbers exceed the float point precision of the CPU. Instead, use something like this:</p>

<pre><code>string intNumStr = itoa(intNum);
char lastDigit = intNumStr[intNumStr.length() - 1];
intNumStr[intNumStr.length() - 1] = '.';
intNumStr += string(lastDigit);
</code></pre>
",3
25673758,25673013,0,"<p>For c++11 you can use this:</p>

<pre><code>std::string toString( int i )
{
    int t = abs( i );
    return ( i &lt; 0 ? ""-"", """" ) + std::to_string( t / 10 ) + ""."" + std::to_string( t % 10 );
}
</code></pre>

<p>for pre c++11 you can replace it with <code>std::stringstream</code> or <code>snprintf</code>:</p>

<pre><code>std::string toString( int i )
{
    char buffer[128] = { '-' };
    int t = abs( i );
    snprintf( buffer + 1, sizeof(buffer) - 1, ""%d.%d"", t / 10, t % 10 );
    return std::string( i &lt; 0 ? buffer : buffer + 1 );
}
</code></pre>
",0
25674232,25673013,0,"<pre><code>#include &lt;sstream&gt;
using namespace std;

string Decimal1ToString(int i)
{
    ostringstream stream;
    stream &lt;&lt; (i / 10) &lt;&lt; '.' &lt;&lt; (i % 10);
    return stream.str();
}
</code></pre>

<p>Note the use of integer / and %.
This prevents precision loss.</p>
",0
25674307,25673013,1,"<p>I was curious about the relative performance of these conversions so I did a few tests with the naive versions of a few methods. A few notes and caveats:</p>

<ul>
<li>The below conversion codes have no error checking and haven't been tested (i.e., don't copy/paste the code).</li>
<li>Some methods only work for positive integers.</li>
<li>The methods do not have equivalent output. For example numbers 0-9 ('0.0', '.0', '.') and factors of 10 ('10', '10.', '10.0'). You should decide exactly what output you want for these cases.</li>
<li>I would start by choosing the simplest algorithm and only optimize once it is found I need to. Do you really need performance of ~100 million integers/second? </li>
<li>Unfortunately, I don't have a C++11 compiler to test the <code>std::to_string()</code> versions.</li>
</ul>

<p>Algorithms tested are:</p>

<pre><code>string toString1 (const int a)
{
    char buffer[32];
    string result = itoa(a, buffer, 10);
    char lastDigit = result[result.length() - 1];
    result[result.length() - 1] = '.';
    result += lastDigit;

    return result;
}

void toString1a (string&amp; Output, const int a)
{
    char buffer[32];
    Output = itoa(a, buffer, 10);
    char lastDigit = Output[Output.length() - 1];
    Output[Output.length() - 1] = '.';
    Output += lastDigit;
}

string toString2 (const int a) {
    float f = a * 0.1f;
    ostringstream ss;
    ss &lt;&lt; f;

    return ss.str();
}    

const char* toString3 (const int a)
{
    static char s_buffer[32]; //Careful!

    itoa(a, s_buffer, 10);
    size_t len = strlen(s_buffer);
    char lastDigit = s_buffer[len-1];
    s_buffer[len-1] = '.';
    s_buffer[len] = lastDigit;
    s_buffer[len+1] = '\0';

    return s_buffer;
}    

const char* toString4 (char* pBuffer, const int a)
{
    itoa(a, pBuffer, 10);
    size_t len = strlen(pBuffer);
    char lastDigit = pBuffer[len-1];
    pBuffer[len-1] = '.';
    pBuffer[len] = lastDigit;
    pBuffer[len+1] = '\0';

    return pBuffer;
}

void toString4a (char* pBuffer, const int a)
{
    itoa(a, pBuffer, 10);
    size_t len = strlen(pBuffer);
    char lastDigit = pBuffer[len-1];
    pBuffer[len-1] = '.';
    pBuffer[len] = lastDigit;
    pBuffer[len+1] = '\0';
}

const char* toString5 (char* pBuffer, const int a)
{
    snprintf(pBuffer, 16, ""%.1f"", a/10.0);
    return pBuffer;
}

const char* toString6 (char* pBuffer, const int a)
{
    snprintf(pBuffer, 16, ""%d.%01d"", a / 10, a % 10);
    return pBuffer;
}

string toString7 (const int a)
{
    ostringstream stream;
    stream &lt;&lt; (a / 10) &lt;&lt; '.' &lt;&lt; (a % 10);
    return stream.str();
}

string toString8 (const int a)
{
    char buffer[16];
    string result = _itoa(a, buffer, 10);
    result.insert(result.length()-1, 1, '.'); 
    return result;
}
</code></pre>

<p>Basic benchmarks were run on the above methods for 100 million integers (starting from 0). If performance really matters for your case please profile/benchmark for yourself for your exact use-case.</p>

<ul>
<li>toString1 = 0.64 sec (itoa to string)</li>
<li>toString1a = 0.61 sec (inplace, no return)</li>
<li>toString2 = 33.4 sec (stringstream, ouch!)</li>
<li>toString3 = 0.52 sec (itoa, static buffer)</li>
<li>toString4 = 0.52 sec (itoa)</li>
<li>toString4a = 0.52 sec (itoa, inplace)</li>
<li>toString5 = 6.35 sec (snprintf, float)</li>
<li>toString6 = 2.29 sec (snprintf, two ints)</li>
<li>toString7 = 33.3 sec (stringstream, two ints)</li>
<li>toString8 = 0.70 sec (itoa and string::insert)</li>
</ul>

<p>Which one is ""better"" really depends on what you need. Personally I would use the simplest stream case (toString7) unless I was absolutely sure I needed the performance of the other methods.</p>
",3
25676684,25673013,3,"<p>Convert the number to a <code>std::string</code>:</p>

<pre><code>char buffer[12];
std::string s = itoa(1234, buffer, 10);
</code></pre>

<p>Or:</p>

<pre><code>std::string s = std::to_string(intNum);
</code></pre>

<p>Then simply <code>insert()</code> the decimal character into it:</p>

<pre><code>s.insert(s.length()-1, "".""); 
</code></pre>

<p>Or:</p>

<pre><code>s.insert(s.length()-1, 1, '.'); 
</code></pre>
",2
25680810,25673013,0,"<p>This is my version:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    char price[18];
    _itoa_s(98321, price, 10);
    int len = strlen(price);
    char lastDigit = price[len - 1];
    price[len - 1] = '.';
    price[len] = lastDigit;
    price[len + 1] = 0;

    printf(price);

    return 0;
}
</code></pre>
",0
23610949,23610746,5,"<p>Generally any imaging code that makes a call for each pixel is going to be slow. If you can, refactor the code so it works with a much larger block, perhaps a raster line at a time.</p>

<p>If you can determine which class to use at compile time rather than run time, you can use the <a href=""http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"" rel=""noreferrer"">Curiously Recurring Template Pattern (CRTP)</a> to eliminate the overhead of a virtual call.</p>
",2
23612243,23610746,0,"<p>Not really an answer, but there are themes here worth following.</p>

<ol>
<li><p>GetPixel() is a notoriously bad thing from a performance point of view. Seriously consider using algorithms that do not require a heavy dependence on this. Maybe convert it to inline or template or macro if it really has to be.</p></li>
<li><p>Are you sure about the benchmarking? The inherent overhead from a virtual function call is a couple of machine instructions, which would not ordinarily cause such a severe impact. Are you sure there isn't something else going on here?</p></li>
<li><p>Do you really need virtual? Inheritance is a solution to many problems, not all of which require virtual functions and dynamic binding. Perhaps you can reorganise your code to use static inheritance or templating, at least for a good part of what you need, and avoid the virtual call to GetPixel() entirely.</p></li>
</ol>

<p>If you have more info please edit your question accordingly.</p>
",0
22125220,22125208,1,"<p><code>:</code> initializes <code>center</code> member with <code>center</code> parameter.</p>

<p>In most case (not always!) your code</p>

<pre><code>Rectangle(Point2D center, double w, double h, double r, double g, double b):center(center)
{
    ....
}
</code></pre>

<p>could be replaced with</p>

<pre><code>Rectangle(Point2D center, double w, double h, double r, double g, double b)
{
    this-&gt;center = center;
    ....
}
</code></pre>

<p>You can read more about initialization lists in C++ <a href=""http://www.cprogramming.com/tutorial/initialization-lists-c++.html"" rel=""nofollow"">here</a></p>
",3
22125297,22125208,0,"<p>It's used to initialize the element . Since C++ is object oriented everything is treated as object even datatypes. so when you use initialization list the object are initialized when the object is created for it. </p>

<p>This is considered to better(faster) way then assigning to the variable directly. </p>

<p>As definition and declaration happens in one go.    </p>
",0
30166010,30040389,2,"<p>The Standard Library already has a class which can convert a function pointer to a default-constructible class type:</p>

<pre><code>template &lt;class T, T v&gt;
struct integral_constant {
    ...
    constexpr operator value_type() { return value; }
};
</code></pre>

<p>Thus it can be used instead of that <code>fn_to_type</code> class:</p>

<pre><code>#include &lt;type_traits&gt;

bool CloseHandle(void* handle);
using UniqueHandle = std::unique_ptr&lt;void, std::integral_constant&lt;decltype(&amp;CloseHandle), &amp;CloseHandle&gt;&gt;;

bool FooLess(const Foo&amp; lhs, const Foo&amp; rhs);
using FooSet = std::set&lt;Foo, std::integral_constant&lt;decltype(&amp;FooLess), &amp;FooLess&gt;&gt;;
</code></pre>
",3
28519701,28519415,9,"<p>This is not a constructor call or a ""function"". There is no ""int function"".</p>

<p>This is <em>functional cast notation</em>; <a href=""http://en.cppreference.com/w/cpp/language/explicit_cast"" rel=""noreferrer"">it's just a cast</a>.</p>

<p>It's the same as <code>(int)(32.5/5)</code> (in this particular case).</p>

<p>And, no, C does not have it.</p>
",5
29456292,29455770,2,"<p>Your macro:</p>

<pre><code>#define (str).Equals(str1) (str.compare(str1) == 0)
</code></pre>

<p>does not fit because it's not in line with macro definition. You can write something like this:</p>

<pre><code>#define Equals(str, str1) (str.compare(str1) == 0)
</code></pre>

<p>but there is no need. All <code>std::string</code> instances can be compared with the overloaded <code>operatror==</code>.<br>
So that you can write following code:</p>

<pre><code>if (str == str1)
</code></pre>

<p>Using macro definition in C++ is highly unrecommended.</p>
",3
25479625,25479592,3,"<p>I see a misconception in the question : the first one doesn't declare the variable <code>static</code>. Only the second one does. In the first one, the variable is an <em>instance</em> variable i.e different instance of the class will have their own variables, but in the second case it is (usually called) a class variable which means it is shared by <em>all</em> instances. You must <em>understand</em> this difference first before you ask any further question.</p>

<p>As to which one is better, depends on how/why you want to use it which is not clear from your question. It is also not clear why you want to use a class and non-static member function at all.</p>
",5
25479763,25479592,2,"<p>When you create a static variable inside a member function, all instances of the class share the same variable. So for example:</p>

<pre><code>void Foo::foo()
{
    static int i = 0;
    std::cout &lt;&lt; ++i;
}

// ...
Foo foo, foo2;
foo.foo();  // i = 1
foo2.foo(); // i = 2
</code></pre>

<p>However, a data member without the static key word is a different variable for each instance of the class. Therefore if you don't mind your instances sharing the same variable, use the second example, otherwise, use the first.</p>
",0
25479776,25479592,0,"<p>If you declare an <em>instance</em> variable inside the class then you have the following effects:</p>

<ul>
<li>You must initialize the variable in the constructor.</li>
<li>Any method in the class can access and change that variable.</li>
<li>If you instantiate multiple class variables, they will all have separate copies of <em>i</em>.</li>
</ul>

<p>If you use a <em>static</em> variable in the member function, then:</p>

<ul>
<li>You can initialize the variable right where it is being used.</li>
<li>No other method in the class can access/change the value.</li>
<li>There is a single shared value across all instantiations of the class.</li>
</ul>

<p>These obviously are implemented differently by the compiler, but unless you can show with a profiler that this is a bottleneck in performance, you shouldn't worry about this. Instead worry about your intended behavior and which case you actually want.</p>
",0
25479654,25479592,1,"<p>You use a static variable when you want to access it without an instance of the class or to share it between multiple instances. And you use the member variable when you want each class instance to have its own copy of the variable.</p>

<p>Hope this helps.</p>
",0
34202982,34202932,5,"<p>Because <code>argv</code> is an array of pointers to char and you can't just compare <em>a pointer to char and a string literal</em>. To solve your problem, you can convert both to <code>std::string</code> like this:</p>

<pre><code>if(std::string(argv[i]) == ""-width"")
</code></pre>

<p>Otherwise, you can use <code>strcmp</code> to compare <em>C strings</em> as shown <a href=""http://www.cplusplus.com/reference/cstring/strcmp/"" rel=""nofollow"">in the docs</a>. </p>
",2
30165197,30165196,13,"<p>It's not as simple as that. There is no ""list of runtime operators"" or ""list of compile-time operators"". There are <em>operators</em>, and many of them may be optimised to be ""executed"" by the compiler rather than coded into the program as an operation to be performed at runtime.</p>

<p>The obvious one is <code>sizeof</code>, which <em>never</em> needs to be deferred until program execution. In fact, speaking generally, operators which act on <em>types</em> may be expected to be purely a semantic operation with no reliance on run-time information. As another example, there is absolutely no reason for <code>const_cast</code> to have any run-time relevance, seeing as <code>const</code> doesn't even exist in your compiled program. A <code>static_cast</code> <em>may</em> be optimised away, but that would depend on what the relevant conversion operators do.</p>

<p>What may not be so obvious is that many expressions that invoke, say, arithmetic operators, may be optimised away.</p>

<p>For example:</p>

<pre><code>const int x = 2 + 4;
</code></pre>

<p>That addition is not going to be performed at runtime unless your compiler is very, very silly. But does that make <code>operator+</code> a ""compile-time operator""? No.</p>

<p>And the function call operator <code>()</code> is only ever going to be invokable at compile-time if the applicable <code>constexpr</code> rules apply, or the function definition is visible in the same translation unit as the call site and is sufficiently trivial.</p>

<p>Whilst we're at it, <code>reinterpret_cast</code> disqualifies an expression from being <code>constexpr</code>. This is reasonably unintuitive but, according to the rationale in <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1384"">CWG issue #1384</a>:</p>

<blockquote>
  <p>Although <code>reinterpret_cast</code> was permitted in address constant expressions in C++03, this restriction has been implemented in some compilers and has not proved to break significant amounts of code. CWG deemed that the complications of dealing with pointers whose tpes <em>[sic]</em> changed (pointer arithmetic and dereference could not be permitted on such pointers) outweighed the possible utility of relaxing the current restriction.</p>
</blockquote>

<p>My point is that, really, it's not worth trying to come up with general rules for this: the process of C++ program compilation is just <em>not</em> that straightforward. You have to examine what your program is doing on a case-by-case basis.</p>

<p>However, I do appreciate that you are trying to answer a poor exam question. For that, you have my sympathies.</p>
",4
23095683,23095591,2,"<p>My immediate thought is to not make your constants of type <code>Example</code>.  You might even make them different types.</p>

<pre><code>struct Example {
    static const RequestType {} ByRequestOnly;
    static const EventType {} OnEventOnly; 
    struct Automatic {
        explicit Automatic(int v) 
            :value(v)
        {
            if(value&lt;1 || value&gt;200)
                throw std::runtime_error(""Invalid automatic interval."");
        }
    private: 
        friend Example;            
        int value;
    };

    void setMessageType (int id, RequestType type) {internal = 0;}
    void setMessageType (int id, EventType type) {internal = 252;}
    void setMessageType (int id, Automatic type) {internal = type.value;}

private:
    int internal;
};
</code></pre>
",1
23095701,23095591,2,"<p>Your <code>Example</code> class would compile if you put the initialization of the static constants in a source file, not in the header. </p>

<pre><code>class Example {
public: 

    struct MessageType {
        friend class Example;
    private:
        explicit MessageType (int iv) : internalValue_(iv) { }
        int internalValue_;
    };

    static const MessageType ByRequestOnly;

    static const MessageType OnEventOnly;

    static MessageType Automatic (int interval) {
        if (interval &gt;= 1 &amp;&amp; interval &lt;= 200)
            return MessageType(interval);
        else
            throw runtime_error(""Invalid automatic interval."");
    }

};
</code></pre>

<p>Elsewhere in a cpp file</p>

<pre><code>const Example::MessageType Example::ByRequestOnly = Example::MessageType(0);
const Example::MessageType Example::OnEventOnly = Example::MessageType(252);
</code></pre>
",1
22420912,22420860,4,"<p><code>this</code> is a pointer value, but your function is looking for a reference parameter. Try:</p>

<pre><code>if (otherBlks[mm].theNeighbourPolyline(*this) == 1)
</code></pre>
",2
21789513,21789349,4,"<p>In C++11 you can use <code>std::aligned_storage</code> (<a href=""http://en.cppreference.com/w/cpp/types/aligned_storage"" rel=""nofollow"">see also</a> ):</p>

<pre><code>template&lt;typename T&gt; 
struct Slot {
    typename std::aligned_storage&lt;sizeof(T)&gt;::type _storage;

    Slot() {}
    ~Slot() { 
       // check if destroyed!
       ...
    }

    template&lt;typename... Args&gt;
    T* init(Args&amp;&amp;... args) { 
        return new(address()) T(std::forward&lt;Args&gt;(args) ...); 
    }

    void release() { (*address()).~T(); }

    T* address()  {
        return static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;_storage));
    }
};
</code></pre>
",2
28522718,28522667,4,"<p>The compiler isn't smart enough to generate a warning in this case.</p>

<p>Note: <em>The fact that the compiler doesn't produce any warnings or errors doesn't mean your code is right.</em> A lot of people don't realise this when they start programming.</p>

<p>Compilers aren't even required to generate warnings for <code>show_uninit</code>, although many do, because it's relatively easy to detect a local variable that is <em>never</em> initialized. (If <code>i</code>, <code>j</code> and <code>k</code> were initialized <em>sometimes</em>, you might not get a warning)</p>

<p>When executed, <code>show_all</code> will print unpredictable values, just like <code>show_uninit</code>.</p>
",3
23848283,23848201,2,"<p>The problem is that your code provides two meanings for <code>Nothing</code> and <code>Just</code>:</p>

<ul>
<li>A value in an enumeration, and</li>
<li>A template type</li>
</ul>

<p>The compiler appears to prefer the former; you want the later.</p>

<p>In order to fix this, you could do one of three things:</p>

<ul>
<li>Rename your <code>enum</code> values,</li>
<li>Rename your template classes, or</li>
<li>Make sure that the two colliding names belong to different namespaces.</li>
</ul>

<p><a href=""http://ideone.com/2gg0bg"" rel=""nofollow"">Demo on ideone with the renamed <code>enum</code> constants.</a></p>

<p><a href=""http://ideone.com/y3wIPX"" rel=""nofollow"">Demo on ideone with a separate namespace for the <code>enum</code>.</a></p>
",1
23580503,23580462,0,"<p>Your <code>log</code> function is virtual, so linker doesn't worry about it. Linker doesn't care about virtual functions because their address is known only at run-time.</p>

<p>The issue with your code is that you call virtual function from <code>Base</code> constructor. But at the time when <code>Base</code> constructor is called, <code>Derived</code> isn't constructed yet, so <code>log</code> function is kind of undefined.</p>

<p>Each object of <code>Derived</code> class contains ""sub-object"" of <code>Base</code> class which is constructed before object itself (That is, <code>Base</code> constructor is called prior to <code>Derived</code>). When <code>Base</code> constructor executes it doesn't know virtual table of <code>Derived</code> class, so it can't resolve address for <code>log</code> to call. Thus it considers it to be a pure virtual function and aborts execution.</p>
",2
23580512,23580462,2,"<p>Derived classes are built from the base class up. During the constructor of Base, the constructor of Derived has not yet been executed. Therefore the vtable is not yet complete.</p>

<p>Calling virtual functions (even non-pure ones) in a constructor is naughty. It implies an incorrect class design.</p>

<p>Here's why it's a bad idea:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class Base {
    public:
        Base() {
            init();
         //   log();
        }

        virtual void log() { cout &lt;&lt; ""stange outcome 1"" &lt;&lt; endl; }
    private:
        void init() {
            log();
        }
};

class Derived: public Base {
    public:
    virtual void log() { cout &lt;&lt; ""stange outcome 2"" &lt;&lt; endl;}

    Derived() 
    : Base() 
    { 
        log();
    }
};

int main() {
    Derived d;
    d.log();
    return 0;
}
</code></pre>

<p>output:</p>

<pre><code>Compiling the source code....
$g++ -std=c++11 main.cpp -o demo -lm -pthread -lgmpxx -lgmp -lreadline 2&gt;&amp;1

Executing the program....
$demo 
stange outcome 1
stange outcome 2
stange outcome 2
</code></pre>

<p>Explanation of why:</p>

<p>When we create an object of class Derived, the program does the following:</p>

<ol>
<li>Allocate memory big enough for a Derived</li>
<li>Set the vtable pointer of the object to point to a vtable of a Base</li>
<li>execute Base::Base() [ calls to log() will call Base::log() ]</li>
<li>Set the vtable pointer of the object to point to a vtable of a Dervied</li>
<li>execute Derived::Derived() [ calls to log() will call Dervied::log() ]</li>
<li>object is now fully constructed.</li>
</ol>
",3
23078258,23075476,0,"<p>what is the definition of line? It is (very) probable you are read more characters than the variables size.</p>
",0
24584548,24584336,1,"<p>There are three ways to solve this:</p>

<ol>
<li><p>Signal and slot: Create a signal for dialog1 and a slot for dialog2. Both must have a QString as parameter. Connect them in the main window where the dialogs are constructed.</p></li>
<li><p>Relation by setter: Give dialog1 a setter that accepts a pointer to dialog2. Memorize the dialog2 pointer in a member variable. Call the callfunction of dialog2 in dialog1 using that pointer. Call the pointer-setter where the dialogs are constructed. Don't forget to clear the pointer if dialog2 isn't available anymore and to check pointer validity before accessing it.</p></li>
<li><p>Relation by reference: Add a dialog2 reference as parameter to the constructor of dialog1. Memorize that referenze in a member variable. Call the callfunction of dialog2 in dialog1 using that reference. You need to construct dialog2 before dialog1 to do this. This works only safely if dialog2 always lives longer than dialog1.</p></li>
</ol>

<p>You should be able to move forward with that information.</p>

<p>I would go with 1.</p>

<p>I suggest to read more about the needed fundamentals. Read about Qt's signals and slots. Read about C++ pointers, references and constructors.</p>
",0
31173669,31172927,3,"<p>As @ PaulMcKenzie points out, you've defined the class SortedLL in both your header and your .cpp file. What you want in the .cpp is just the method definitions. Something like:</p>

<pre><code>int SortedLL ::findLinear(int data, struct Node ** pPrev, struct Node ** pCurr) {
   ...
}
</code></pre>
",0
31159936,31159856,1,"<p>Well, it depends. In your example, it will be inlined, because the definition of the function is in the same translation unit where it is used. </p>

<p>Otherwise, if no LTO is possible, and at compile time the definition of the function is not available to the compiler, then no, the function will not be inlined.</p>

<hr>

<p><strong>Prior answer</strong></p>

<p>The answer is: it depends. It depends on the compiler, and it may depend on compiler's configuration<a href=""https://msdn.microsoft.com/en-us/library/47238hez.aspx"" rel=""nofollow"">(1)</a><a href=""https://msdn.microsoft.com/en-us/library/0zza0de8.aspx"" rel=""nofollow"">(2)</a> too.</p>

<p>See also <a href=""http://en.cppreference.com/w/cpp/language/inline"" rel=""nofollow"">inline description at cppreference.com</a> (quoted below):</p>

<blockquote>
  <p>The intent of the inline keyword is to serve as an indicator to the optimizer that inline substitution of the function is preferred over function call, that is, <strong>instead of executing the call CPU instruction to transfer control to the function body, a copy of the function body is executed</strong> without generating the call. This avoids extra overhead created by the function call (copying the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.
  Since this meaning of the keyword inline is non-binding, compilers are free to use inline substitution for any function that's not marked inline, and <strong>are free to generate function calls to any function marked inline</strong>. Those choices do not change the rules regarding multiple definitions and shared statics listed above.</p>
</blockquote>
",2
31159990,31159856,1,"<p>You need to have the body available at the time the inlining is supposed to happen.</p>

<p>I.e. if you have the following files:</p>

<pre><code>inlineFunc.h
inlineFunc.c
main.c
</code></pre>

<p>And you compile with:</p>

<pre><code>compile inline.c
compile main.c
link innline.o mcompile inline.c
</code></pre>

<p>compile main.c
link innline.o main.o yourCoookProgramain.o yourCoookProgram</p>

<p>there is no way that <code>inlineFunc</code> gets inlined in <code>main.c</code> however calls to <code>inlineFunc</code> in <code>inlineFunc.c</code> can be inlined.</p>

<p>As Paolo mentioned, <code>inline</code> is only a hint to a compiler however some compilers also have ways to force the inining, i.e. for gcc you can use <code>__attribute__(always_inline)</code>. Take alook here for a discussion on how <a href=""https://gcc.gnu.org/onlinedocs/gcc/Inline.html"" rel=""nofollow"">gcc</a> handles inlining.</p>

<p><a href=""https://gcc.gnu.org/ml/gcc-help/2007-01/msg00049.html"" rel=""nofollow"">An interesting sitenote</a>:</p>

<blockquote>
  <p>The warning is issued in this case as the definition of foo() is not
  available when main() is compiled. However, with -O2 or better
  optimizations, gcc performs a kind of ""backward inlining"", meaning
  that even function definitions that are further ahead in the source
  file can be embedded into a caller. Consequently, the warning
  disappears as soon as one uses at least -O2 optimizations. Is there
  any specific option responsible for this behavior? I would like to
  enable ""backward inlining"" even with -O1 or -O0.</p>
</blockquote>
",2
31160867,31159856,2,"<p>Inlining is a two-step process:
* Is it possible?
* Is it worthwhile?</p>

<p>The first step is fairly trivially decided by the compiler, the second is a far more complex heuristic. Thus it makes sense to only consider the benefits of <em>possible</em> optimizations.</p>

<p><code>always_inline</code> means that the second step is ignored. It does not affect the first consideration. Now, you've also stated that LTO is disabled, which means that first consideration, the ability for inlining, is restricted. This shows that <code>LTO</code> and <code>always_inline</code> are pretty unrelated since they affect two different inlining considerations.</p>

<p>Not that LTO matters for your example anyway. The two functions under consideration are in the same Translation Unit. There appear to be no other restrictions such as recursion, library calls, or other observable side effects. That means it should be possible to inline, and since that's the only consideration, it should be inlined.  </p>
",0
29455662,29455469,1,"<p>You forgot to add braces on your Rectangle constructor. Make it like this:</p>

<pre><code>Rectangle() {}
</code></pre>

<p>So the problem is you have the definition but not the implementation. You can indeed declare a function without braces but it is like you make a promise to the compiler that you are going to add the function's body somewhere else. That's why separating classes to .hpp and .cpp files works.</p>

<p><strong>Note</strong>: Retired Ninja gave the answer first in a comment below the post.</p>
",0
33006612,33006218,1,"<p>This code is almost certainly not what you want, since it is casting a pointer into a scalar.</p>

<pre><code>utf8proc_uint8_t* a = ...;
char b = (char)a;
</code></pre>

<p>Instead, you want to cast and produce a <em>pointer</em>:</p>

<pre><code>utf8proc_uint8_t* a = ...;
const char *b = (const char *)a;
</code></pre>

<p>I also added <code>const</code>, which is not strictly necessary but a good idea to use wherever you can.</p>
",0
33007439,33006218,1,"<p>There appear to be a couple problems here.  The biggest is the assignment:</p>

<pre><code>char b = (char)a;
</code></pre>

<p>What you are doing is telling the compiler to take the pointer (memory location) and convert that to a char, then assign it to single char value b.  So you'll basically have random jibberish in b.</p>

<p>Instead, if you want to treat a like a basic char*, you would write:</p>

<pre><code>char* b = (char*)a;
</code></pre>

<p>Then you could use the string class with either:</p>

<pre><code>string d = string(b);
</code></pre>

<p>or you could skip several line by the direct conversion:</p>

<pre><code>string d = string((char*)a);
</code></pre>

<p>You are also looking for a headache down the line if you don't delete the conversion value returned by the utf8proc_NFC() call, and if you don't do an error check after the conversion.</p>

<p>Plus I'll put in a plug for using some Hungarian notation to distinguish a pointer (a 'p' prefix on variables).  This makes it obvious that you can do things like:</p>

<pre><code>char tmp = *pStr;     // a single character (first in the string)
char tmp2 = pStr[1];  // a single character (second in the string)
char* pTmp = pStr;    // a pointer to a null terminated string
</code></pre>

<p>But you would never see:</p>

<pre><code>char tmp3 = (char)pStr;     // compiles, but makes no sense to treat pointer as a character.
</code></pre>

<p>So here is a clean version of all of this:</p>

<pre><code>utf8proc_uint8_t* pUTF = utf8proc_NFC( (const unsigned char*)e.c_str() );
string strUTF;
if (pUTF)
{
   strUTF = (char*)pUTF;
   free pUTF;
}
</code></pre>
",0
28510266,28510119,0,"<p>Generally asserts are checked in debug builds but not release builds.  If you want to save time and skip the check in your final released code, then asserts are the way to go.  If your function needs to blow up in the face of unexpected input even in release, then the exception may be the way to go.</p>

<p>Of course the details of exactly what you should do for error conditions will vary with context beyond what was provided in your example. </p>
",0
28510276,28510119,1,"<p>It really depends on the situation.</p>

<p>There are four major groups of error handling:</p>

<ol>
<li><p>assert - used to deal with programming errors (""We don't expect this function to get a NULL pointer, and if it does, it's because some other part of our code is broken, and it should NEVER happen""). If the assert wasn't there, the code would probably crash, loop forever, or otherwise ""fail"". </p></li>
<li><p>exceptions - such as <code>std::invalid_argument</code> - this is more used when the program EXPECTS things to go wrong, and there is some way to ""try again"". More likely when the actual user is using the program wrong - e.g. inputs from keyboard/file, etc. As the name states, this should be an ""exception"" - something unusual and unexpected.</p></li>
<li><p>return value - when an error is entirely likely (trying to see if the serial port is on port COM1, COM2, COM3 or COM4 or ""is the result of the equation matching what I expect yet?"")</p></li>
<li><p>Let it crash - if the inputs are wrong, the application runs out of memory, etc, just crash. It may seem like a rough method, but sometimes there's not much better you can do anyway - what are you going to ACTUALLY do in the middle of your compiler if some linked list is broken and the <code>next</code> node is not pointing at your special <code>sentry</code> pointer, but to <code>NULL</code>? Printing a message may be a little better, but not a huge amount.</p></li>
</ol>
",0
28510290,28510119,1,"<p>Is the integer passed to <code>method1</code> always going to be done so by a programmer, or might it be passed in by the users of your application?</p>

<p><strong>Assert</strong>,
for example if your code looks like this:</p>

<pre><code>int i;
if ( condition ) {
    i = 1;
}
else {
    i = 3;
}

method1(i);
</code></pre>

<p>If this is the case, you'd likely want to use an <code>assert</code>, because it indicates you (the programmer) has made an error. If <code>i = 3</code>, you want your program to blow up and make it obvious there is a problem in your code, so you can catch it before you release it to your clients.</p>

<p><strong>Throw an exception</strong>,
on the other hand, if your code looks like this:</p>

<pre><code>int i;
cin &gt;&gt; i;
method1(i);
</code></pre>

<p>You're passing the user's input to the function. You can't anticipate what they might enter. So if it's an invalid value, you should throw an exception or return an error code and handle it accordingly (e.g., print out a message to the user saying they have entered an invalid number).</p>
",2
21021659,21021566,3,"<p>Overriding works on functions with the same signature, but this is actually a red herring here. </p>

<p>Things is, member functions in derived class <strong>hide</strong> member functions in the base class that have the same name (regardless of the signature). The fact that your functions are virtual doesn't matter here, as you don't attempt dynamic dispatch anywhere.</p>

<p>If you wrote:</p>

<pre><code>Foo* f = new Bar;
f-&gt;IsItSo();
</code></pre>

<p>it would work, as it would <code>f-&gt;IsItSo(""Oi"");</code> (and it would call the function from the derived class).</p>

<p>Name lookup starts looking in static type of the object (in your case, it is <code>Bar</code>) and stops looking when it encounters the name. The only <code>IsItSo</code> that's visible from <code>Bar</code> is the one that takes a <code>std::string</code> parameter.</p>
",4
21021749,21021566,1,"<p>You need to dynamic cast the pointer to the base class if you want to use that method</p>

<pre><code>class Foo
{
  public:
     virtual bool IsItSo();
     virtual bool IsItSo(string x);
};

bool Foo::IsItSo()
{
  return true;
}

class Bar : public Foo
{
   public:
     // not here
     virtual bool IsItSo(string x);
};

bool Bar::IsItSo(string x)
{
   return (x == """");
}

int main()
{
    Bar *p = new Bar();

    Foo* p_converted = dynamic_cast&lt;Foo*&gt;(p);
    bool b = p_converted-&gt;IsItSo();

    return 0;
}
</code></pre>

<p>otherwise the base class will have overloaded methods hidden by the overridden one in the derived class (lookup stops in the <strong>first scope</strong> where a name is resolved)</p>
",0
26232178,26232098,0,"<p>I would just use <code>bool</code> parameter if these are the only two cases. Keep it simple. And document it properly.</p>

<p>Or you can have two methods <code>computeA(S s)</code> and <code>computeZ(S s)</code>. In this case it is really about what you are comfortable with.</p>
",3
26232190,26232098,1,"<p>I'd use an enum.  It's no more or less efficient than bool, but it may be more clear at the call site:</p>

<pre><code>compute(s, UseAB);
compute(s, UseZB);
</code></pre>

<p>Instead of:</p>

<pre><code>compute(s, false);
compute(s, true);
</code></pre>

<p>The template option is possible but probably not better; you should try the regular run-time way first.  If you care a lot about performance, consider making <code>compute()</code> inline if it is short and simple.</p>
",1
23588485,23588442,1,"<p>One problem is that you have a macro <code>#define OS</code>. Macros are a text substitution, so the line <code>friend class OS;</code> is transformed to <code>friend class ;</code> which is a syntax error.  </p>

<p>To fix this, use names for your include guards that will not clash with your class names.  I use H_ALLUPPER for header include guards, and don't use all-uppercase for anything else other than preprocessor macros.</p>
",2
34248127,34248051,2,"<p>The link you posted is more of an example of concept, not complete ready-to-build code.</p>

<p>You declare <code>D::do_f</code> but nowhere define it. Add at least an empty body, and it will build without error. (As noted in @Peter's comment, the listed errors actually come from the linker, not compiler.)</p>

<pre><code>struct D : public B {
    void do_f() override {} // overrides B::f
};
</code></pre>
",1
26145787,26145639,9,"<p>Meyers gives his reasoning in <a href=""http://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197"">this article</a>. Here's an extract:</p>

<blockquote>
  <p>We've now seen that a reasonable way to gauge the amount of encapsulation in a class is to count the number of functions that might be broken if the class's implementation changes. That being the case, it becomes clear that a class with n member functions is more encapsulated than a class with n+1 member functions. And that observation is what justifies my argument for preferring non-member non-friend functions to member functions: if a function f could be implemented as a member function or as a non-friend non-member function, making it a member would decrease encapsulation, while making it a non-member wouldn't.</p>
</blockquote>
",6
26146601,26145639,5,"<p>Meyers does <em>not</em> say avoid member functions. He says that functions should not be members (or friends) <em>unless they need to be</em>. Obviously there need to be <em>some</em> functions which can access the private members of a class otherwise how could any other code interact with the class, right?</p>

<p>But every function which can access the private members of a class <strong>is coupled to the private implementation details of that class</strong>. The functions which should be members (or friends) are the ones which can only be efficiently implemented by accessing the private details. These are the <em>primitive functions</em> of a class. Non-primitive functions are those which can be efficiently implemented on top of the primitive ones. Making non-primitive functions members (or friends) increases the amount of code which is coupled to the private details.</p>

<p>Also, in writing a function which is able to modify the private members of an object, more care must be taken in order to preserve the class invariants.</p>
",0
26146754,26145639,3,"<p>Just a little example:</p>
<ol>
<li><code>std::list</code> has <code>sort</code> member function, because it benefits from list element's natural moving ability.</li>
<li>But if you cannot get any advantage from internal structure knowledge, there is a general solution ¡ª <code>std::sort</code> free function.</li>
</ol>
",0
26148331,26145639,1,"<p>I'm going to answer the OP's question of ""why would anyone prefer non-member non-friend functions over member functions?"" with this simplistic example.  Consider an application that generates graphical simulations from geospatial data. The data is ingested in a representation like what you¡¯d expect to see on a compass (in degrees, winding clockwise, where 0 points North/positive on the y-axis).  When you pass the direction information to your renderer, it might expect it in a representation like what you¡¯re used to from trig (in radians, winding counter-clockwise, where 0 points right/positive on the x-axis).</p>

<p>Since both representations of a direction can be stored as a float, you write a pair of boxed primitives to enforce some type-safety (so you don¡¯t accidentally pass an azimuth to a rendering call that expects an angle). To convert between the two representations, you write a member function on Azimuth called AsAngle(), and you write a member function on Angle called AsAzimuth().</p>

<pre><code>class Angle
{
    public:
        float GetValue() const;
        Azimuth AsAzimuth() const;

    private:
        float m_Value;
};

class Azimuth
{
    public:
        float GetValue() const;
        Angle AsAngle() const;

    private:
        float m_Value;
};
</code></pre>

<p>The first breakdown of encapsulation here is that now Angle and Azimuth have a dependency on each other¡¯s type.  You¡¯d need to forward declare one in the other¡¯s header, and #include it in the source file so it can construct the other in the conversion function.  You could reduce this dependency by having the conversion functions return floats instead of objects of the other class, but that doesn¡¯t fully remove logical dependencies on each other, because the next breakdown of encapsulation is that both classes must also know inner details about the other.</p>

<p>If you were to later switch to a renderer that expects angles in degrees instead of radians, you¡¯d change your Angle class for this different representation.  However, even though the only change is in the details of what an Angle is, an entirely separate class, Azimuth, now must also change, or else it will continue to return angles in radians instead of degrees. If you update the AsAzimuth() member of Angle but forget to update the AsAngle() member of Azimuth, you could end up with rendering that looks wrong while you scratch your head looking over your changes to Angle for errors when there are none.</p>

<p>Azimuth should not have to care about the inner details of Angle, but it has to when you implement the conversion routine as member functions.  If you wrote the conversion as a non-member function, neither class need care about the details of the other anymore ¨C the concern of how to convert between the two representations is now fully encapsulated within a separate function.</p>

<p>If you don't like the idea of having a global function, or some dumping ground for random functions in some kind of utilities namespace, you could improve this design by creating a new Direction class that further encapsulates the details of how direction is stored and converted.  It could store the direction however it comes in from the hardware that collects the geospatial data, let¡¯s say as an azimuth stored in a float, and have member functions that return it in whatever representation users of the class want, relying solely on visual cues if you do something wrong (such as calling graphicalThingy.SetAngle(direction.AsAzimuth())).  But if you don¡¯t want to sacrifice the type-safety of the boxed primitives, you could still use the previous two Angle and Azimuth classes, and implement the conversion as a member of Direction.  It¡¯s still a non-member non-friend function of Angle and Azimuth, it takes in the information it needs from them through their now-smaller public interface using the GetValue() call so it has no access to any of their other private members, it¡¯s located in an appropriate place to keep such functions (the Direction class), and neither Angle nor Azimuth needs to care about the details of the other, nor do they have a dependency on each other anymore.</p>

<pre><code>class Direction
{
    public:
        Angle AsAngle() const
        {
            return Angle(Convert(m_Azimuth.GetValue());
        }
        Azimuth AsAzimuth() const
        {
            return m_Azimuth.GetValue();
        }

    private:
        float Convert(const float) const
        {
            ...conversion stuffs here...
        }
        Azimuth m_OriginalAzimuth;
};
</code></pre>

<p>In this example, the conversion could be written as a member function, and it does require a piece of private data from the class it's used with.  However, there is absolutely no reason to prefer a member function over non-member non-friend function, as the non-member function improves encapsulation.</p>
",0
31258208,31257801,0,"<p>You might come up with something nicer but this just might work.
Tested in MSVC++.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define PRINT_IF_THIS_EXISTS \
    if (strchr(__FUNCTION__,':')) printf(""this exists in %s!\n"", __FUNCTION__)

class test
{
public:
    test()
    {
        PRINT_IF_THIS_EXISTS;
    }
};

void staticFunction()
{
    PRINT_IF_THIS_EXISTS;
}

int main()
{
    PRINT_IF_THIS_EXISTS;
    staticFunction();
    test t;

    std::cin.get();
    return 0;
}
</code></pre>
",4
31259377,31257801,0,"<p><code>is_foo_static</code> in following code checks if <code>X::foo()</code> is a static function.<br>Maybe you can use it in your macro to tell if it is thiscall.</p>

<pre><code>template&lt;typename T&gt;
struct is_foo_static {
  template&lt;typename X&gt;
  static std::true_type check(X*, decltype(X::foo())* = 0);

  static std::false_type check(...);
  typedef decltype(check((T*)(0))) _tmp;
  static const bool value = _tmp::value;
};

struct FooStatic {
  static void foo() {}
};

struct FooNonStatic {
  void foo() {}
};

int main(){
  cout&lt;&lt;boolalpha
      &lt;&lt;is_foo_static&lt;FooStatic&gt;::value&lt;&lt;endl
      &lt;&lt;is_foo_static&lt;FooNonStatic&gt;::value&lt;&lt;endl;
  return 0;
}
</code></pre>
",0
22124585,22124552,2,"<blockquote>
  <p>For instance if two operators are between the dashed lines like <code>-&gt;</code> comes before <code>[]</code> does this mean <code>-&gt;</code> has higher precedence than <code>[]</code> ?</p>
</blockquote>

<p>Yes, both are at same precedence level but because of Left to right associativite for example: </p>

<pre><code>a-&gt;b[i];
</code></pre>

<p>is parsed or equivalent as <code>(a-&gt;b)[i];</code>. This is useful when <code>a</code> is a pointer to structure and <code>b</code> is a array member of struct.  </p>

<p>And an expression like:</p>

<pre><code>a[i]-&gt;b;  
</code></pre>

<p>same as <code>(a[i])-&gt;b;</code>. This is useful when <code>a</code> is an array of structure's pointers. </p>

<p>You don't need parenthesis.</p>

<p>For <code>*</code>, <code>.</code>, <code>-&gt;</code>, and <code>[]</code> operators you can read this answer <a href=""https://stackoverflow.com/a/18254652/1673391"">""Pointer to structure""</a>. </p>
",0
22124669,22124552,2,"<p>Yes .. you are right..  also note that in case like when <code>*</code> and <code>/</code> comes in an expression,that's where associativity is considered... in such a case you have to evaluate from left to right...</p>

<p>In <code>a * b / c</code>, the operation    <code>a * b</code> is evaluated first and then <code>/</code> is evaluated.  </p>

<p>In <code>a / b * c</code>, the operation   <code>a / b</code> is evaluated first and then <code>*</code> is evaluated. </p>
",1
24615288,24615256,6,"<p>In short: No, it's intentionally not possible.  </p>

<p>Think twice: Something like <em>uninitialized references</em> cannot really exist; such wouldn't make sense at all.<br>
Thus they'll need to be set at the time of construction of the enclosing class, or at a point of static initialization. </p>

<p>You'll need to use pointers for such case.</p>

<hr>

<p>Besides note that </p>

<pre><code> yumminess = (int*)view;
</code></pre>

<p>would be wrongly casted (to a pointer) anyway.</p>

<hr>

<blockquote>
  <p><em>""Right now i just use a pointer and dereference it all the time ...""</em></p>
</blockquote>

<p>That's also easy to overcome writing an appropriate member function to access the reference.</p>

<pre><code>int* yumminess;

// ...

int&amp; yumminessRef() {
    if(!yumminess) { 
        throw some_appropriate_exception(""`yumminess` not initialized properly."");
    }
    return *yumminess;
}
</code></pre>
",8
24615295,24615256,2,"<p>No, not directly.</p>

<p>If you think the pointer is inconvenient, have a look at <code>std::optional</code>.</p>
",0
28520383,28520350,4,"<p>The new line, comes from the return character that is used to submit the name while using the cin command. It is simply placed because it is what is originally written by the user while typing ""Bob"".</p>
",5
28520519,28520350,1,"<p>This is what got written to the terminal:</p>

<blockquote>
  <p>What is your first name: Bob\nHello Bob\n</p>
</blockquote>

<p>This is where it came from (italics from your program writing to stdout, bold from terminal echo):</p>

<blockquote>
  <p><em>What is your first name:</em> <strong>Bob\n</strong> <em>Hello Bob\n</em></p>
</blockquote>

<p>When the user types (shift)+B,O,B the terminal buffer holds <code>Bob</code>.  Since the terminal is line buffered, <code>stdin</code> hasn't received any data at all yet.</p>

<p>Now the user presses the Enter key.  This is seen by the line buffered terminal as the end of a line, so <code>stdin</code> now sees <code>Bob\n</code>.  <code>operator&lt;&lt;(cin, name)</code> follows the rules for a formatted input function, discarding leading whitespace and then transferring data to the result until it finds another whitespace.</p>

<p>Now, <code>name</code> contains <code>""Bob""</code> (no newline here), and the newline character has been used up by <code>cin</code> to end this input operation.</p>
",2
28520638,28520350,6,"<p>The output stream doesn't go to the next line.</p>

<p><em>You pressed Enter</em> after typing the name. The terminal has local echo on, which means the characters you enter on the keyboard get echoed to the terminal. </p>

<p>The ""Bob"" and the newline that you see on the screen are there because you typed them, not because they were sent to <code>cout</code> by your program.</p>

<p>If you used a terminal with local echo turned off, or if you piped input from a file containing <code>Bob</code>, then the output would look like:</p>

<pre><code>What is your first name: Hello Bob
</code></pre>
",1
24079776,24079739,4,"<p>This is so because you cannot initialise base class member in a derived class. What you call ""initialisation inside the constructor"" is not initialisation, it is assignment after the member was already initialised by the constructor of the base class.</p>
",0
24079844,24079739,0,"<p><code>data</code> is already initialized by A's constructor when we get to the init list of B (the part after the base constructor call if that exists). You cannot <em>initialize</em> something twice. You can either tell A's constructor how to initialize it, or assign something else to the already initialized member.</p>
",2
26131170,26130843,0,"<p>Your code isn't actually doing anything to transpose the matrix! It's writing the message into the matrix, but it's printing each entry out right after it's written, so it doesn't end up changing the order at all.</p>

<p>You'll need a separate set of loops to read data out of the matrix.</p>
",1
26131211,26130843,1,"<p>this should do it..</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()
{
    string input;

    cout &lt;&lt; ""Enter information to be encrypted"" &lt;&lt; endl;
    getline(cin,input);
    input.erase(std::remove (input.begin(), input.end(), ' '), input.end());

    int columns = 6;
    int rows;
    if (input.size() &lt;= 5){
        rows = 1;
    }
    else if (input.size()% 5 &gt; 0){
        rows = input.size()/5 + 1;
    }
    else
        rows = input.size()/5;

    char message[rows][columns];

    for(int i = 0; i &lt; rows; i++){
        for(int j = 0; j &lt; (columns-1); j++){
            if ((i*5 + j) &lt; int(input.size())){
                message[i][j] = input[i*5 + j];
            }
            else {
                message[i][j] = 'x';
            }
            // place++;
            if (i != rows-1) message[i][5] = 'y';
            else message[i][5] = 'x';
            // cout &lt;&lt; ""i: "" &lt;&lt; i &lt;&lt; "" | j: "" &lt;&lt; j &lt;&lt; "" | "" &lt;&lt; message[i][j] &lt;&lt; endl;
        }
        cout &lt;&lt; endl;
    }
    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; columns; j++) {
            cout &lt;&lt; message[i][j];
        }
        cout &lt;&lt; "" "";
    }
    cout &lt;&lt; endl;
}
</code></pre>
",0
26216965,26216868,11,"<p>That is known as an elaborated type specifier and is generally only necessary when your class name is ""shadowed"" or ""hidden"" and you need to be explicit. </p>

<pre><code>class T
{
};

// for the love of god don't do this
T T;
T T2;
</code></pre>

<p>If your compiler is smart, it will give you these warnings:</p>

<pre><code>main.cpp:15:5: error: must use 'class' tag to refer to type 'T' in this scope
    T T2;
    ^
    class 
main.cpp:14:7: note: class 'T' is hidden by a non-type declaration of 'T' here
    T T;
      ^
</code></pre>

<p>If your class is not previously defined, it will also act as a forward declaration. </p>

<p>For example:</p>

<pre><code>template &lt;typename T&gt;
void Method()
{
    using type = typename T::value_type;
}

Method&lt;class T&gt;(); // T is a forward declaration, but we have not defined it yet, 
                   // error.
</code></pre>

<p>Otherwise it's not necessary.</p>

<pre><code>class T
{
public:
    using value_type = int;
};

// method implementation...

Method&lt;T&gt;();
Method&lt;class T&gt;(); // class is redundant here
</code></pre>
",0
26217034,26216868,2,"<p>In addition to other answers, you can you <code>class</code> keyword to forward declare a class in the usage spot. E.g. instead of:</p>

<pre><code>class SomeClass;
SomeClass* p = some_function();
</code></pre>

<p>You can write:</p>

<pre><code>class SomeClass* p = some_function();
</code></pre>

<p>This is often used with templates and tag dispatching, when instantiating a template requires a tag type argument whose only purpose is to make the instantiation a unique type and the tag does not have to be a complete type. E.g.:</p>

<pre><code>template&lt;class Tag&gt; struct Node { Node* next; };

struct Some : Node&lt;class Tag1&gt;, Node&lt;class Tag2&gt; {};
</code></pre>
",5
21013568,21013525,0,"<p>Depends on what makes the most sense.  You could also do</p>

<pre><code>void ClassABC::someMethod1() { ... }
void ClassABC::someMethod2() { ... }
void ClassABC::someMethod3() { ... }
</code></pre>

<p>Instead, though the caller(s) would have to be slightly more aware of their context.</p>

<p>Or, it could do</p>

<pre><code>int  ClassABC::someMethodIndex;
void ClassABC::someMethod()
{
    switch (someMethodIndex)
    {
    case 0:   ... // first portion
              someMethodIndex = 1;  // next time do portion 1
              return;
    case 1:   ... // second portion
              someMethodIndex = 2;  // next time do portion 2
              return;
    case 2:   ... // third portion
              someMethodIndex = 0;  // next time do portion 0
              return;
    }
}
</code></pre>
",0
21013603,21013525,0,"<p>If you count for all object of the class, you can use static data members: <a href=""http://msdn.microsoft.com/en-us/library/b1b5y48f.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/b1b5y48f.aspx</a></p>

<p>It's much better from the encapsulation point of view than a global variable.</p>

<p>If you count for every object of the class separately then just use a regular private member variable that will store the counter.</p>
",0
21013607,21013525,4,"<pre><code>void ClassABC::someMethod() {
    static size_t counter = 0;

    switch (counter++) {
        case 0: {
            // 1
            break;
        }
        case 1: {
            // 2
            break;
        }
        default: {
            // 3
            break;
        }
    }
}
</code></pre>

<p>Note that this approach would only work for a <code>static</code> member function.</p>

<p>For non-static member functions use this:</p>

<pre><code>class ClassABC {
public:
    ClassABC();
    void someMethod();
private:
    size_t someMethodCounter;
}

ClassABC::ClassABC() {
    this-&gt;someMethodCounter = 0;
}

void ClassABC::someMethod() {
    switch (this-&gt;someMethodCounter++) {
    // ...
    }
}
</code></pre>
",0
21013609,21013525,0,"<p>Use a counter variable and a <code>switch</code> statement:</p>

<pre><code>switch(counter++) {
case 0:
    // portion 1
    break;
case 1:
    // portion 2
    break;
case 2:
    // portion 3
    break;
...
}
</code></pre>
",0
21013643,21013525,0,"<p>You can have a static variable inside the method initialized to zero, and increment on every call and make a decision to call the appropriate portion of the code.</p>
",0
21013706,21013525,2,"<p>In embedded systems, we would use a function pointer.  It typically has lower overhead than a switch statement, especially if one case is going to run repeatedly.</p>

<pre><code>void ClassABC
{
  void part1() {
    // portion 1 ;
    op_= part2 ;
  }
  void part2() {
    // portion 2
    op_= part3 ;
  void part3() {
    // portion 3
  }

  void someMethod() { op_() ; }

  std::function&lt;void()&gt; op_ = part1 ;
} ;
</code></pre>
",0
24593565,24593551,1,"<p>Use <code>'typename'</code> keyword</p>

<pre><code>typename basic_string&lt;T&gt;::size_type i = 0;
</code></pre>

<p>Suggested Reading :<a href=""https://stackoverflow.com/q/610245/1870232""><em>Where and why do I have to put the ¡°template¡± and ¡°typename¡± keywords?</em></a></p>
",0
33602860,33602641,3,"<p>The problem is that <code>i</code> is a double. Then you write <code>x2[i]</code>.</p>

<p>It's not a very good error message; however with the <code>[]</code> operator, one of the operands must be a pointer and the other must be an <em>integer</em>.  There is no implicit conversion of floating-point to integer when using this operator.</p>

<p>To fix this change <code>double i;</code> to <code>int i;</code></p>

<hr>

<p>Another issue is that your code accesses out of bounds of the arrays. <code>double x2[10]</code> means that there are <code>10</code> elements whose indices are <code>0</code> through <code>9</code>.  But your loop tries to write to <code>x2[10]</code>. This causes undefined behaviour, which could explain your strange output.</p>

<hr>

<p>There is also a potential logic error. Maybe you meant to use a different variable for the inner loop than the outer loop. As it stands, the inner loop will take <code>i</code> to <code>11</code> (or <code>10</code> if you fix the code) and then the outer loop will be complete and not execute any more iterations.</p>

<p>Based on your description though, perhaps you only meant to have one loop in the first place. If so, remove the outer loop and just leave the contents there. </p>

<p>Also you do not need two separate arrays, you could just perform the addition in-place. </p>

<hr>

<p>Regarding the output, <code>cout &lt;&lt; x</code> and <code>cout &lt;&lt; x2</code> will output the number of the memory address at which the array is located.  To output the contents of the array instead you will need to write another loop, or use a standard library algorithm that iterates over containers.</p>
",0
33602778,33602641,0,"<p>Try this, it works, I converted to C</p>

<pre><code>int main(  )
{

  int i = 0;
// Arrays
  double x[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  double x2[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

  for ( i = 1; i &lt; 10; i++ )
  {
    const double pM[2] = { -1, 1 };
    int randoid = rand(  ) % 2;
    for ( i = 1; i &lt;= 10; i++ )
    {
      x2[i] = x[i] + pM[randoid] * 0.25;    //Error Line

      printf( ""\nx[%d]==%2.2f"", i, x[i] );
      printf( ""\nx2[%d]==%2.2f"", i, x2[i] );

    }
  }

}
</code></pre>
",0
33602820,33602641,1,"<p>I see 3 issues - </p>

<ol>
<li>Change the type of <code>i</code> to <code>int</code>.</li>
<li><code>x</code> and <code>x2</code> are arrays of size 10. You need to loop from <code>i =
0</code> to <code>i = 9</code>. But you are looping from <code>i = 1</code> to <code>i = 10</code>. <code>x[10]</code>
is out of bounds since <code>arrays</code> are 0 indexed.</li>
<li><p><code>cout &lt;&lt; x</code> - This is a wrong way to print an array. You need
to loop through the array and print - e.g. -</p>

<pre><code>for(i = 0; i &lt; 10; i++)
    cout &lt;&lt; x[i] &lt;&lt; "" "";
</code></pre></li>
</ol>
",0
29221708,29221671,3,"<p>In the call <code>doSomething(a)</code>, <code>a</code> is converted to an rvalue of type <code>B</code> using the conversion operator (which returns by value, hence the new temporary object).</p>

<p>Since rvalues can only be used as non-const reference or value parameters, you can't call <code>doSomething</code> with an rvalue.</p>

<p>Either declare <code>doSomething</code> to take its argument by const reference, by value, or by rvalue-reference. You could also make <code>operator B</code> return a reference to the <code>b</code> member if that's appropriate.</p>
",0
29221727,29221671,1,"<p>The cast-operator returns <code>b</code> <em>by value</em>, and using that result when calling the <code>doSomething</code> function would create a <em>temporary</em> value, and you simply can't have references to temporary values because of their temporary nature.</p>

<p>Either change <code>doSomething</code> to receive its argument by value, or by <em><code>const</code></em> reference (which can bind to a temporary value), or possibly a rvalue-reference (using the <code>&amp;&amp;</code> syntax in the argument declaration), or of course make a cast-operator that returns a reference.</p>
",0
29478660,29478621,16,"<p>You still only return one value, which is <code>1</code>.</p>

<pre><code>return 0,1;
</code></pre>

<p>makes use of the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow noreferrer"">comma operator</a>, its result is its right hand side. With the right warning level, your compiler (gcc and clang at least) will warn because its left hand side has no effect.</p>

<p>If you actually want to return multiple values, you can return a <code>std::tuple</code> (or <code>std::pair</code>):</p>

<pre><code>auto fun () {
    return std::make_tuple(0,1);
}

int main () {
    int a, b;
    std::tie(a,b) = fun();
    // Now a == 0, b == 1
}
</code></pre>

<hr>

<p>Equivalent alternative as of C++17:</p>

<pre><code>auto fun () {
    return std::make_tuple(0,1);
}

int main () {
    auto [a,b] = fun();
}
</code></pre>

<p><a href=""https://wandbox.org/permlink/ygtGd1Wl3pVE66JD"" rel=""nofollow noreferrer"">Live</a></p>
",1
29478681,29478621,4,"<p><code>0,1</code> is an operator that does nothing except evaluate both expressions in order and results in the value of the second operator (1).  So <code>return 0,1</code> is equivalent to saying <code>return 1</code>.</p>

<p><code>int a,b = foo();</code> creates two variables.  <code>a</code> is uninitialized, and <code>b</code> is assigned the return value of <code>foo()</code>.</p>

<p>That's why the value of <code>b</code> is 1 and the value of <code>a</code> is wacky (it's undefined).</p>

<hr>

<p>IME, the main benefit of the comma operator is <code>for</code> loops in C.  For example, suppose you wanted to enumerate elements of a linked list.  Lists don't have a built-in concept of order so you end up keeping two trackers of position in the list.</p>

<pre><code>for (index = 0, curr_node = list_begin; 
  curr_node != NULL; 
  ++index, curr_node = curr_node-&gt;next)
{
  // Stuff
}
</code></pre>

<p>It's a convenient little trick for readability and it also guarantees that index/curr_node are in sync no matter what you do with <code>break</code> or <code>continue</code>.</p>
",4
23067282,23067208,2,"<blockquote>
  <p>I cannot use the '&amp; kinect = freenect.createDevice(0)</p>
</blockquote>

<p>That is right, you cannot <em>assign</em> references; once initialized, they refer to the same object forever. What looks like an assignment in your code that works</p>

<pre><code>KinectCV&amp; kinect = freenect.createDevice(0);
</code></pre>

<p>is not an assignment, it's initialization. It can be rewritten using the initialization syntax instead of the assignment syntax, like this:</p>

<pre><code>KinectCV&amp; kinect(freenect.createDevice(0));
</code></pre>

<p>The reason behind it is that in C++ all initialization must happen in the constructor, not in a ""designated initialization function"". C++ has no idea that <code>init</code> is your initialization function; all it knows is that once the constructor is over, the object must be in a consistent state, included with all the references that it might hold.</p>

<p>Moving the initialization code into <code>MyKinect</code>'s constructor will fix the problem:</p>

<pre><code>class MyKinect {
    public:
    KinectCV kinect;
    MyKinect() : kinect(freenect.createDevice(0)) {
    }
}
</code></pre>
",0
32458602,32458560,12,"<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/basic_string"" rel=""noreferrer"">string constructor</a> can work with <code>char*</code>, that contains <code>\0</code>, if <code>size</code> is right.</p>

<blockquote>
  <p>Constructs the string with the first count characters of character
  string pointed to by s. s can contain null characters. The length of
  the string is count. The behavior is undefined if s does not point at
  an array of at least count elements of CharT.</p>
</blockquote>

<p>So just use</p>

<pre><code>std::string message(static_cast&lt;const char*&gt;(data), size);
</code></pre>
",0
32458620,32458560,7,"<p>You can cast <code>data</code> to <code>const char*</code>, then use the <code>std::string</code> two iterator constructor.</p>

<pre><code>const char* sdata = static_cast&lt;const char*&gt;(data);
std::string message(sdata, sdata + size);
</code></pre>

<p>Note that is all you need is a byte buffer, it might be simpler and clearer to use an <code>std::vector&lt;unsigned char&gt;</code> instead.</p>

<pre><code>const unsigned char* sdata = static_cast&lt;const unsigned char*&gt;(data);
std::vector&lt;unsigned char&gt; message(sdata, sdata + size);
</code></pre>
",1
32458648,32458560,1,"<p>As long as size indicates the correct number, casting is fine. You can have <code>NULL</code> anywhere <code>std::string</code> and you don't even need to NULL terminate your buffer for that matter.</p>
",0
32459013,32458560,1,"<p>And of course, if you already have a <code>string</code> object</p>

<pre><code>myString.insert(0, static_cast&lt;const char*&gt;(data), size);
                ^^ -- starting index
</code></pre>

<p>which calls </p>

<pre><code>basic_string&amp; insert( size_type index, const CharT* s, size_type count );
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/insert"" rel=""nofollow"">¡ì</a></p>

<blockquote>
  <p>Inserts the first count characters from the character string pointed to by s at the position index. s can contain null characters.</p>
</blockquote>
",0
21567858,21567771,1,"<p>In the class declare friend as :-</p>

<pre><code>template&lt;typename U&gt;
friend ostream&amp; operator&lt;&lt;(ostream&amp; os,const dynArray&lt;U&gt;&amp; A);
</code></pre>

<p>And define it as :-</p>

<pre><code>template&lt;typename U&gt; 
ostream&amp; operator&lt;&lt; (ostream&amp; os,const dynArray&lt;U&gt;&amp; A){...}
</code></pre>

<p>See <a href=""http://coliru.stacked-crooked.com/a/c4db6edd90344192"" rel=""nofollow""><strong>HERE</strong></a></p>
",0
21567895,21567771,2,"<p>You cannot <code>friend</code> a specialization of an undeclared template function. You need to declare the <code>operator &lt;&lt;</code> beforehand. Of course to do so, you'll need to already have a declaration of <code>dynArray</code>. This mess of forward declarations looks like this (<a href=""http://coliru.stacked-crooked.com/a/0fdabc2af1dd8c51"" rel=""nofollow noreferrer"">Live at Coliru</a>):</p>

<pre><code>template&lt;typename T&gt; class dynArray;

template&lt;typename T&gt;
ostream&amp; operator &lt;&lt; (ostream&amp; os, const dynArray&lt;T&gt;&amp; A);

template&lt;typename T&gt;
class dynArray {
    // ...
    friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp; os, const dynArray&amp; A);
    };
</code></pre>

<p>As <a href=""https://stackoverflow.com/questions/21567771/friend-function-for-template-class-c/21567895#comment32577260_21567895"">@ooga points out in his comment</a>, the template parameters in the friend declaration are unnecessary; the compiler can deduce them. You could simply declare it as:</p>

<pre><code>friend ostream&amp; operator&lt;&lt; &lt;&gt; (ostream&amp; os, const dynArray&amp; A);
</code></pre>

<p>I personally find that syntax a bit punctuation-heavy in this instance.</p>

<p>Alternatively, if you find the forward declarations offensive, you could declare a separate non-template friend function for each specialization of <code>dynArray</code> by defining it in the class definition (<a href=""http://coliru.stacked-crooked.com/a/66c637ac2c3c308f"" rel=""nofollow noreferrer"">Coliru again</a>):</p>

<pre><code>template&lt;typename T&gt;
class dynArray {
    // ...
    friend ostream&amp; operator&lt;&lt; (ostream&amp; os,const dynArray&amp; A) {
        for (int i=0; i &lt; A.size ; i++)
        os &lt;&lt; *(A.ptr+i) &lt;&lt; "" "";
        return os;
    }
};
</code></pre>
",3
32959598,32959564,11,"<p>Yes, this is expected, as part of the so-called <em>usual arithmetic conversions</em> combined with the rules for <em>integral promotion</em>.</p>

<p>The exact wording changed between C++03 and C++11, but the end result is the same in this case.</p>

<hr>

<blockquote>
  <p><code>[C++03: 4.5/1]:</code> An rvalue of type <code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short int</code>, or unsigned <code>short int</code> can be converted to an rvalue of type int if <code>int</code> can represent all the values of the source type; otherwise, the source rvalue can be converted to an rvalue of type <code>unsigned int</code>.</p>
  
  <p><code>[C++03: 4.5/5]:</code> These conversions are called <em>integral promotions</em>.</p>
  
  <p><code>[C++03: 5/9]:</code> Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result.</p>
  
  <p>This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:</p>
  
  <ul>
  <li>If either operand is of type <code>long double</code>, the other shall be converted to <code>long double</code>.</li>
  <li>Otherwise, if either operand is <code>double</code>, the other shall be converted to double.</li>
  <li>Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>.</li>
  <li><strong>Otherwise, the integral promotions (4.5) shall be performed on both operands.</strong><sup>54</sup></li>
  <li>Then, if either operand is <code>unsigned long</code> the other shall be converted to <code>unsigned long</code>.</li>
  <li>Otherwise, if one operand is a <code>long int</code> and the other <code>unsigned int</code>, then if a <code>long int</code> can represent all the values of an unsigned int, the unsigned int shall be converted to a <code>long int</code>; otherwise both operands shall be converted to unsigned <code>long int</code>.</li>
  <li>Otherwise, if either operand is <code>long</code>, the other shall be converted to <code>long</code>.</li>
  <li>Otherwise, if either operand is <code>unsigned</code>, the other shall be converted to <code>unsigned</code>.</li>
  </ul>
  
  <p><em>[Note:</em> otherwise, the only remaining case is that both operands are <code>int</code> <em>]</em></p>
</blockquote>

<hr>

<blockquote>
  <p><code>[C++11: 4.5/1]:</code> A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion rank (4.13) is less than the rank of <code>int</code> can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned <code>int</code>.</p>
  
  <p><code>[C++11: 4.5/7]:</code> These conversions are called <em>integral promotions</em>.</p>
  
  <p><code>[C++11: 5.9]:</code> Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result.</p>
  
  <p>This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:</p>
  
  <ul>
  <li>If either operand is of scoped enumeration type (7.2), no conversions are performed; if the other operand does not have the same type, the expression is ill-formed.</li>
  <li>If either operand is of type long double, the other shall be converted to long double.</li>
  <li>Otherwise, if either operand is double, the other shall be converted to double.</li>
  <li>Otherwise, if either operand is float, the other shall be converted to float.</li>
  <li><strong>Otherwise, the integral promotions (4.5) shall be performed on both operands.</strong><sup>59</sup> Then the following rules shall be applied to the promoted operands:
  
  <ul>
  <li>If both operands have the same type, no further conversion is needed.</li>
  <li>Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank shall be converted to the type of the operand with greater rank.</li>
  <li>Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the rank of the type of the other operand, the operand with signed integer type shall be converted to the type of the operand with unsigned integer type.</li>
  <li>Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type shall be converted to the type of the operand with signed integer type.</li>
  <li>Otherwise, both operands shall be converted to the unsigned integer type corresponding to the type of the operand with signed integer type.</li>
  </ul></li>
  </ul>
</blockquote>
",4
30161715,30161663,2,"<blockquote>
  <p>Are s1 and s2 equal?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>Is the \0 stripped from ""ab"" when creating s2?</p>
</blockquote>

<p>That's not really a meaningful question. The code that constructs <code>s2</code> can construct if however it wants. It can copy the terminator, remove it, leave it, whatever it wants. It just has to know how to find the end of the C-style string, and it does.</p>

<blockquote>
  <p>If not, is there an easy (one-line, preferably) way to check if s1 contains only and exactly {'a', 'b'}?</p>
</blockquote>

<pre><code>if (s1 == ""ab"")
</code></pre>

<p>The <code>string</code> class has an <code>operator==</code> that does what you probably expect, comparing the values for equivalence. It understands how both C-style and C++-style strings work and so can compare their values.</p>
",12
30162193,30161663,0,"<p>It is easy to determine what happens by using method size().</p>

<p>For example after creating an object like this</p>

<pre><code>std::string s1 = """";
</code></pre>

<p>the size of s1 will be equal to 0.</p>

<p>Here is called constructor</p>

<pre><code>basic_string(const charT* s, const Allocator&amp; a = Allocator());
</code></pre>

<p>that copies characters from an array first element of which is pointed to by s. As the length of string literal """" is equal to 0 then the constructed object also does not have elements and its size is equal to 0.</p>

<p>After these statements</p>

<pre><code>s1 += 'a';
s1 += 'b';
</code></pre>

<p>the object will contain two characters 'a' and 'b'.
Thus the object will be equal to the object constructed like <code>std::string( ""ab"" );</code>.</p>

<p>Take into account for example if you have a character array defined like</p>

<p>char s[] = { 'a', 'b', '\0', 'c', 'd', '\0' };</p>

<p>and will use to construct an object of type std::string like this</p>

<pre><code>std::string s1( s );
</code></pre>

<p>then s1 will contain only two elements 'a' and 'b'  and its size will be equal to 2.</p>

<p>It will be useful to consider another example. Let's assume that you wrote</p>

<pre><code>std::string s1 = """";
</code></pre>

<p>and then</p>

<pre><code>s1 += 'a';
s1 += 'b';
s1 += '\0';
</code></pre>

<p>In this case s1 will not be equal to object <code>std::string( ""ab"" )</code> because the size of s1 is now equal to 3.</p>

<p>Another interesting example. You can use constructor</p>

<pre><code>basic_string(const charT* s, size_type n, const Allocator&amp; a = Allocator());
</code></pre>

<p>It is similar to the previous constructor except it allows to specify explicitly the number of characters in the character array pointed to by  pointer s that will be used to construct an object of type std::string. 
In this case if you will write</p>

<pre><code>std::string s1( ""ab"", 3 );
std::cout &lt;&lt; s1.size() &lt;&lt; std::endl;

if ( s1 == std::string( ""ab"" ) ) std::cout &lt;&lt; ""They are equal"" &lt;&lt; std::endl;
else std::cout &lt;&lt; ""They are not equal"" &lt;&lt; std::endl;
</code></pre>

<p>then the output will be</p>

<pre><code>3
They are not equal
</code></pre>

<p>At the same time if you will write</p>

<pre><code>std::cout &lt;&lt; s1 &lt;&lt; std::endl;
</code></pre>

<p>you will see</p>

<pre><code>ab
</code></pre>
",0
21785086,21783488,0,"<pre><code>template&lt;unsigned...&gt;struct indexes {};
template&lt;unsigned Max, unsigned...Is&gt;struct make_indexes:make_indexes&lt;Max-1,Max-1,Is...&gt;{};
template&lt;unsigned...Is&gt;struct make_indexes&lt;0,Is...&gt;:indexes&lt;Is...&gt;{};

template&lt; class T, std::size_t X, std::size_t Y, unsigned...Is &gt;
std::array&lt;T*, X&gt; as_jagged_helper( T(&amp;arr)[X][Y], indexes&lt;Is...&gt; ) {
  return {arr[Is]...};
}

template&lt; class T, std::size_t X, std::size_t Y, unsigned...Is &gt;
std::array&lt;T*, X&gt; as_jagged( T(&amp;arr)[X][Y] ) {
  return as_jagged_helper(arr, make_indexes&lt;X&gt;());
}
</code></pre>

<p>then simply call <code>f(&amp;(as_jagged(M)[0]));</code></p>
",0
21783603,21783488,3,"<p>An array of pointers to pointers and a bidimensional array are completely different data structures in C:</p>

<ul>
<li><code>int **</code> normally refers to an <em>array of pointers</em>, each of which points to a different row (allocated elsewhere)</li>
<li><code>int [5][5]</code> under the hood is a plain linear array where the rows are stored one after each other, and the compiler automatically performs the calculations on the index to access the right element.</li>
</ul>

<p>So, having an <code>int[5][5]</code>, you have to build the array of pointers by yourself, which will act as an ""index"" for the rows of your matrix.</p>

<pre><code>int * m2[5];
for(int i=0; i&lt;5; ++i)
    m2[i]=M[i];
f(m2);
</code></pre>
",1
22122884,22122873,6,"<p>You're returning <code>std::ofstream</code> by value from <code>getLogBuffer()</code> and <code>getErrorBuffer()</code> which will make a call to the copy ctor which (as the error message suggests) has been deleted. You should return a reference instead.</p>
",1
23301828,23301482,2,"<p>I just suppose you know <em>why</em> you pass a pointer to a BSTR, instead of a BSTR.</p>

<pre><code>char* CFichierTrace::ConvertBSTRToString(BSTR* str) {
    return _com_util::ConvertBSTRToString(*str);
}
</code></pre>

<p>Due to <code>BSTR</code>-semantics, this is the proper implementation.<br>
To clarify, all proper <code>BSTR</code>-functions treat <code>NULL</code> identical to a 0-length <code>BSTR</code>.</p>

<p>Anyway, use multiple return points wherever they make sense, unless you have a broken coding-standard disallowing such.</p>
",1
23301570,23301482,2,"<p>You'd do this:</p>

<pre><code>    char* CFichierTrace::ConvertBSTRToString(BSTR* str)
    {
       char* buf;

       if ( str == NULL )
       {
          buf = new char[2];
          sprintf_s(buf, 2, ""%s"", """");
       }
       else
          buf =  _com_util::ConvertBSTRToString(*str);

       return buf;
    }
</code></pre>
",0
23301606,23301482,2,"<pre><code>   char* CFichierTrace::ConvertBSTRToString(BSTR* str)
   {
       char* ret;
       if ( str == NULL )
       {
          ret = new char[1];
          ret[0] = 0;
       }
       else
          ret =  _com_util::ConvertBSTRToString(*str);

       return ret;
    }
</code></pre>

<p>And btw, you should not mix C++ <code>new</code> with C <code>malloc</code>.
Also, it is arguable that multiple return points is a bad practice. There are many situations when the code is more readable when you have multiple return points. </p>
",0
26232355,26232307,4,"<p>Simple:</p>

<p>move the random value generator lines inside the loop:</p>

<pre><code>seed = time(0);
srand(seed);    //setting the seed should only be done outside the loop (as per original code)

while (temBool) //Start of the loop
{

    //Random generated operands
    addFirstNum = rand() % 40 + 10;
    addSecondNum = rand() % 40 + 10;
    subFirstNum = rand() % 40 + 10;
    subSecondNum = rand() % 40 + 10;
    multFirstNum = rand() % 40 + 10;
    multSecondNum = rand() % 40 + 10;

    //...
}
</code></pre>

<p>Now every time it loops, the numbers will have a new value.</p>

<p>edit: Answer now shows <code>srand(seed)</code> explicitly outside the loop in case that was your problem was moving that code into the loop.<br>
Also, like <a href=""https://stackoverflow.com/users/1322972/whozcraig"">whozcraig</a> said, you only need two random numbers each time as you are only using two of the numbers you are generating each time.</p>
",7
26232561,26232307,0,"<p>Just an addition answer to Baldrick, when you seed with time(0) and then just do a while loop, without any stops or asking user what to do next( exit/continue ), the values will be the same you seed with the same value of time( time value didn't change because the while loop processed the program quickly ).Maybe it's not the issue here, but it's good to know :)</p>
",3
28502276,28502172,2,"<p>For unix/linux you want to <code>tee</code> your output to the file and the output will be sent to <code>stdout</code> as well:</p>

<pre><code> myProgram | tee out.txt 
</code></pre>
",0
28502405,28502172,1,"<p>On recent Windows (Windows 7 or later), the easiest way should be to use the powershell, which has a <a href=""https://technet.microsoft.com/en-us/library/hh849937.aspx"" rel=""nofollow""><code>Tee-Object</code></a> cmdlet for this:</p>

<pre><code>powershell -command ""myprogram | Tee-Object out.txt""
</code></pre>

<p>For less recent Windows, take a loot at <a href=""https://code.google.com/p/wintee/"" rel=""nofollow"">wintee</a>, or download and install powershell from <a href=""https://technet.microsoft.com/en-us/scriptcenter/dd742419.aspx"" rel=""nofollow"">Microsoft</a>.</p>
",0
22864781,22864667,0,"<p>In C++11, you can do exactly that (or at least, you could if the class members were public).</p>

<p>If you're stuck in the past, then it's messier; either write a function to create and return the vector, or use something like the <a href=""http://www.boost.org/doc/libs/release/libs/assign/doc/index.html"" rel=""nofollow"">Boost.Assignment</a> library.</p>
",0
22864816,22864667,1,"<p>Make those members as <code>public</code> and it will be initialized in C++11. Otherwise you can use initializer list and constructor:</p>

<pre><code>class MenuPage {
    std::string menuTitle;
    std::vector&lt;MenuItem&gt; menuItems;
public:
    MenuPage (std::string s, std::vector&lt;MenuItem&gt; m) :
    menuTitle(s), menuItems(m) {}
};

static const MenuPage menuMain (
    ""Main menu"",
    {{ ""Item1"", 0, 0 },
     { ""Item2"", 0, 0 },
     { ""Item3"", 0, 0 }}
);
</code></pre>

<p>Note that, you should do same thing fot <code>MenuItem</code>.</p>
",0
27492956,27492733,0,"<p>There are tons of errors here, from incorrect attempts to overload operators to using data members by the wrong name.  I'll step through what I see.</p>

<hr>

<p>When defining the binary <code>operator+</code> as a member function it only takes one argument, which is the right-hand argument to <code>+</code> (the left-hand is implicitly <code>*this</code>).</p>

<p>Also your operators use the nonexistent fields <code>r</code> and <code>i</code> -- you probably meant <code>real</code> and <code>imaginary</code>.</p>

<pre><code>class Complex
{
    // ...

public:
    // Wrong, will cause compile-time errors:
    // Complex operator+(Complex c1, Complex c2);  

    // Right:
    Complex operator+(Complex c);
};

Complex Complex::operator+(Complex c) 
{
    Complex result;
    result.real = real + c.real;
    result.imaginary = imaginary + c.imaginary;
    return result;
}
</code></pre>

<p>Alternatively you can define the operator as a free function instead of as a member of the class, but you'd have to make it a friend of the class since it accesses private members:</p>

<pre><code>class Complex
{
    // ...

    friend Complex operator+(Complex, Complex);
};

Complex operator+(Complex c1, Complex c2) 
{
    Complex result;
    result.real = c1.real + c2.real;
    result.imaginary = c1.imaginary + c2.imaginary;
    return result;
}
</code></pre>

<hr>

<p>Similarly, your <code>operator&lt;&lt;</code> overload for <code>std::ostream</code> should be a free function, and needs to be fixed to use <code>real</code> and <code>imaginary</code>.  However, since these members are private to <code>Complex</code>, this will fail unless you make this operator a friend of <code>Complex</code>.  Since <code>ostream</code> is an abstract type you can't accept or return instances by value, you need to use references.  Further you don't actually return anything.</p>

<pre><code>class Complex
{
    // ...

    friend ostream &amp; operator&lt;&lt;(ostream &amp;, Complex);
};

ostream &amp; operator&lt;&lt;(ostream &amp; out, Complex number)
{
    out &lt;&lt; number.real &lt;&lt; ""+"" &lt;&lt; number.imaginary &lt;&lt; endl;
    return out;
}
</code></pre>

<hr>

<p>Your <code>Complex</code> class is missing a default constructor, so you can't declare variables like <code>Complex c;</code> because this requires the existence of the default constructor:</p>

<pre><code>class Complex
{
    // ...

public:
    Complex();
};

Complex::Complex() : real(0), imaginary(0) { }
</code></pre>
",11
27529421,27529351,6,"<p>You don't have a default constructor. The two-argument constructor could be used as one, since both arguments are optional; but you'll have to put the default arguments on the declaration in the header, not the definition in the source file, for them to be usable from <code>main</code>.</p>

<p>Personally, I'd use <code>std::complex</code> rather than reinventing it.</p>
",0
27529491,27529351,1,"<p>You don't have a default constructor because you put the default parameters in the definition, so you can only construct <code>Complex</code> instances by passing two parameters.</p>

<p>You could add a default constructor, </p>

<pre><code>Complex() : r(0), i(0) {}
</code></pre>

<p>or put the default parameters in the function declaration instead of in the definition</p>

<pre><code>Complex(double real = 0.0, double imaginary = 0.0);
</code></pre>

<p>or write your code like this:</p>

<pre><code>int main () {
    Complex x(2, 4);
    Complex y(3, 0);
    Complex sum = x + y;
    cout &lt;&lt; ""The sum (x + y) is:  "" &lt;&lt; sum &lt;&lt; endl;
    return 0;
}
</code></pre>
",5
25702716,25702096,4,"<p>The same as:</p>

<pre><code>char char_func(char** ptr)
{
    char c = **ptr;       // read the current character (pointed by ptr)
    (*ptr)++;             // move the original pointer (ptr) to next character
    if (c != '\0')        // if the character in c is not the one ending the sequence
    {
        return c;         // return that character
    }
    else                  // otherwise
    {
        --(*ptr);         // move the original pointer back one step (back to '\0')
        return **ptr;     // return that last '\0' character
    }
}
</code></pre>

<p>which means that <strong>each subsequent call</strong> returns the <strong>next character</strong> of the string (characters' sequence) passed as an argument until character <code>\0</code> is encountered (then it repeatedly returns that <code>\0</code> character):</p>

<pre><code>int main()
{
    char tab[] = { 'a', 'b', 'c', '\0' };

    char* ptr = tab;                     

    printf(""%c "", char_func(&amp;ptr));      //  a  b  c  \0
                                         //  ^  
    printf(""%c "", char_func(&amp;ptr));      //  a  b  c  \0
                                         //     ^  
    printf(""%c "", char_func(&amp;ptr));      //  a  b  c  \0
                                         //        ^   
    printf(""%c "", char_func(&amp;ptr));      //  a  b  c  \0
                                         //            ^
    printf(""%c "", char_func(&amp;ptr));      //  a  b  c  \0
                                         //            ^       ^=ptr
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>a b c \0 \0
</code></pre>
",0
25702664,25702096,2,"<p>If <code>*str</code> isn't zero, it will return <code>**str</code> and increment <code>*str</code>.<br>
Otherwise, it resets the increment and returns <code>**str</code> (which will be zero in that case).</p>

<p>That is, you can use it to pop off the front of <code>*str</code> until you reach zero.</p>

<p>Rewriting the function to be less obfuscated:</p>

<pre><code>char char_func(char **str) {
   char c = str[0][0];
   if (c)
      str[0] += 1;
   return c;
}
</code></pre>

<p>Example: the following program prints ""Hello, world!"" one character at a time.</p>

<pre><code>#include &lt;iostream&gt;

char char_func(char **str) {
   char c; 
   return ((c=*((*str)++))?c:*(--(*str)));
}

int main() {

   char test[] = ""Hello, world!"";
   char* t = test;
   for (char c = char_func(&amp;t); c; c = char_func(&amp;t))
      std::cout &lt;&lt; c;
}
</code></pre>
",0
28439964,28439854,3,"<pre><code>volatile const double x = 2.71828;
volatile double y = 0;
// ^^ VERY IMPORTANT
</code></pre>

<p>There, I fixed your benchmark.</p>

<p>Now enable optimization again, and worry only about timing with optimization enabled.</p>
",2
28439971,28439854,1,"<p>A debug build will not inline those accessor methods, so it will take longer. A release build will not have this problem.</p>

<p>Try using a release build but make your variables <code>volatile</code>, I believe that will disable the loop optimization.</p>
",0
21025069,21023316,2,"<p>I know you want a one-liner, but can't find anything that meets your needs.</p>

<p>With a <code>string escape(const string &amp;s)</code> function, you could write your own one-liner:</p>

<pre><code>#include &lt;algorithm&gt;

string escape(const string &amp;s)
{
    // Do your thing.
    return result;
}

string joinEscaped(const vector&lt;string&gt; &amp;v, const string &amp;delimiter)
{
    std::vector&lt;string&gt; temp(v.size());
    std::transform(v.begin(), v.end(), temp.begin(), escape);

    return boost::algorithm::join(temp, delimiter);
}
</code></pre>
",0
28223386,28223307,4,"<p>You are missing the first underscore.  It should be:</p>

<pre><code>_ns1__changePinTestResponse
</code></pre>

<p>not</p>

<pre><code>ns1__changePinTestResponse
</code></pre>
",0
27745520,27745486,27,"<p>Both <code>int i = 0;</code> and <code>int i(0);</code> declare, define and initialize an <code>int</code> object with the value <code>0</code> in C++. They are strictly equivalent, so are the two loop constructs. Note that in C, <code>int i(0);</code> is not an allowed construct.</p>
",15
27745569,27745486,9,"<p>Two forms of initialization you mentioned are:-</p>

<pre><code>T t = u;     _1
T t(u);      _2
</code></pre>

<p>_1 </p>

<p>This <em>could</em> involve two calls. One would be to <em>conversion constructor</em> and another would be to <em>copy constructor</em>.Although most compiler can elide the copy construction.</p>

<p>_2</p>

<p>This would just require only a single call to <em>conversion constructor</em>.</p>

<p>So, _2 is preferred over _1. As for built-in types, it won't make much difference.</p>
",15
27745670,27745486,0,"<p>In C programming language, you have to define the variables first and initialize them afterwards. To perform a <em>for</em> cycle, you would need to define the variable in the beginning of the function, and only then write <code>for( i=0 ; i&lt;5 ; ++i )</code>. So, people who often use this language, might not be used to this type of assignment, possible in C++, or just don't want to confuse possible beginner readers.</p>

<p>However, in C++, using
<code>for( int i=0 ; i&lt;5 ; ++i )</code> and <code>for ( int i(0);  i &lt; 5; ++i )</code> is the same, since in both cases the variables are created before the first iteration of the cycle.</p>
",3
27745897,27745486,1,"<p>You can write is as well as:</p>

<pre><code>int i(5);
</code></pre>

<p>or</p>

<pre><code>int i{5};
</code></pre>

<p>or</p>

<pre><code>int i=5;
</code></pre>

<p>All of these are initializations-not assignments.
*And they're not different.</p>
",1
23827659,23827280,1,"<p>To put it in a few words, the <code>operator /</code> can be written like this:</p>

<pre><code>class Rational
{
    //...rest of the stuff:

    Rational Divide( const Rational &amp; rhs) const
    {
        return Rational(_n * rhs._d, _d * rhs._n);
    }
};
</code></pre>

<p>and instead of the <code>operator /</code> for <code>result = a/b</code> you can write <code>result = a.Divide(b)</code>
Basically  <code>operator /</code> behaves the same way as <code>Divide</code> method:</p>

<p>Now , let's analyze the divide method:</p>

<p>you have:</p>

<pre><code>result = a.Divide(b); // which is the same as result = a/b in your case
</code></pre>

<p>and </p>

<pre><code>Rational Divide( const Rational &amp; rhs) const
{
    return Rational(_n * rhs._d, _d * rhs._n);
}
</code></pre>

<ul>
<li><p><code>rhs</code> is the argument passed to <code>Divide</code> which is the variable <code>b</code>.</p></li>
<li><p><code>_n</code> and <code>_d</code> are the members of the variable <code>a</code>. You can also write them like this: <code>this-&gt;_n</code> and <code>this-&gt;_d</code>. <code>Divide</code> is a member function so it can access <code>_n</code> and <code>_d</code> directly.</p></li>
</ul>

<p>Now to simplify this even further to understand the way it works, here is another way to write this:</p>

<pre><code>class Radional {/*stuff*/};

Rational Divide( const Rational &amp; a, const Rational &amp; b)
{
    return Rational(a._n * b._d, a._d * b._n);
}
</code></pre>

<p>For this example the <code>result = a.Divide(b)</code> transforms into <code>result = Divide(a,b)</code>
Notice that now you have <code>a._n</code> and <code>a._d</code> which is the first argument of function <code>Divide</code></p>

<p>As a conclusion the expression <code>a/b</code> is just a very nice way of writing <code>Divide(a,b)</code> that c++ standard allows.</p>
",1
24760091,24759965,5,"<p>To output the result you have to make <code>cin &gt;&gt; current</code> false. To do this, use <code>Ctrl-D</code> to send end of file (EOF) to <code>cin</code> which will cause the loop to stop executing.</p>

<p>Edit: Apparently in Windows, the sequence is <code>Ctrl-Z</code>.</p>

<p>Edit: As @pdw noted, <code>cout</code> will need to be flushed. This is usually done when there is a newline character, but since you don't have one you can use <code>std::flush</code> or <code>std::endl</code>:</p>

<pre><code>cout &lt;&lt; ""Dear "" &lt;&lt; name &lt;&lt; ""."" &lt;&lt; letter &lt;&lt; std::flush;
</code></pre>
",3
24760321,24759965,0,"<p>You have an infinite loop here.  <code>while (cin &gt;&gt; current)</code> will always evaluate to true, and will just continuously wait for user input. That is why you never reach the last line of code.  You are just continuously creating new values for current on each input in the prompt and then adding them to letter.  I would recommend not using a while loop, or set some escape input.  For example, if the user enters done, exit from the loop, using <code>break;</code></p>
",0
24760160,24759965,0,"<pre><code>while (cin &gt;&gt; current)
</code></pre>

<p>To make this loop interrupt you need to put end of stream marker into <code>std::cin</code>. Type <code>Ctrl-Z</code> on Windows or <code>Ctrl-D</code> on Unix like systems at the end of input to achieve that.</p>
",0
23303777,23303706,3,"<p>1) Yes, you must overload <code>istream &gt;&gt;</code> and <code>ostream &lt;&lt;</code> operators for the code to compile. Having read C++ Primer, they cover that in the later chapters.</p>

<p>2) This is primarily opinionated, but I feel that it is one of the <em>better</em> operators to overload, as it does make life a lot easier. The book overloads them for teaching purposes.</p>
",2
23303786,23303706,4,"<p>It is idiomatic C++ by grace of being in the standard library to use the bit-shifting operators for stream insertion and extraction.<br>
That works because bit-shifting a stream-object has no sense ;-)<br>
For the same reasons, <code>+</code> is acceptable for string concatenation.</p>

<p>Your observation that you have to define the overloads for <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> yourself is correct. But free functions are fine.<br>
For all the details of operator-overloading (though not move semantics), there's this question: <a href=""https://stackoverflow.com/questions/4421706/operator-overloading"">Operator overloading</a></p>
",0
23303801,23303706,0,"<p>You would need to overload operator&lt;&lt; and operator>> for a user defined type if you want to stream it.
In my opinion stream operators, and getters and setters are for different kinds of behaviors so your second question looked like an apples to oranges comparison to me.  If you want to be able to fill the object directly from the stream, then overloading stream operators is the only way to do it.  Otherwise you'd have to stream into basic types first, and then use mutators.  Certainly you would not want to use operator overloading for all mutations of the object, but only when you are interfacing to streams.  You might need to define classes with stream overloading, and getters and setters.  It's not a mutually exclusive choice.</p>
",0
23303853,23303706,0,"<ul>
<li><p>You don't overload std::cin and std::cout but operator &lt;&lt; and operator >> of your class on a specific stream.</p></li>
<li><p>In most cases you use getter and setter for manipulate your data but operators overload is useful when you want to manipulate your object as a whole and not only in simple cin/cout cases. You can put and get your object to every kind of stream. </p></li>
</ul>
",0
25447370,25447099,3,"<p>You've seen that you have to store a reference (of some sort) to the object if you want 1 thing to appear in 2 places. Whilst you once would have used a pointer, today we have <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow"">shared_ptr</a>.</p>

<p>This wraps the pointer so you don't have to manage lifetime ownership- the pointer will only get delete'd when the reference count of the shared_ptr drops to 0, ie when everyone holding the shared_ptr has relinquished it. You use the shared_ptr object as a real object so it's easy to manage in your containers.</p>

<p>If you don't have a C++11 compiler, you can use the <a href=""http://www.boost.org/doc/libs/1_55_0/libs/smart_ptr/shared_ptr.htm"" rel=""nofollow"">boost version</a> (that comes with an <a href=""http://www.boost.org/doc/libs/1_55_0/libs/smart_ptr/example/shared_ptr_example.cpp"" rel=""nofollow"">example</a> of storing shared_ptr objects in both a vector and a set)</p>
",4
32489692,32489679,3,"<p>It is a user-defined conversion operator</p>

<p><a href=""http://en.cppreference.com/w/cpp/language/cast_operator"" rel=""nofollow"">http://en.cppreference.com/w/cpp/language/cast_operator</a></p>

<pre><code>struct X {
    //implicit conversion
    operator int() const { return 7; }

    // explicit conversion
    explicit operator int*() const { return nullptr; }

//   Error: array operator not allowed in conversion-type-id
//   operator int(*)[3]() const { return nullptr; }
    using arr_t = int[3];
    operator arr_t*() const { return nullptr; } // OK if done through typedef
//  operator arr_t () const; // Error: conversion to array not allowed in any case
};

int main()
{
    X x;

    int n = static_cast&lt;int&gt;(x);   // OK: sets n to 7
    int m = x;                     // OK: sets m to 7

    int* p = static_cast&lt;int*&gt;(x);  // OK: sets p to null
//  int* q = x; // Error: no implicit conversion

    int (*pa)[3] = x;  // OK
}
</code></pre>
",0
26223868,26223795,5,"<p>You are being bit by <em>floating point rounding errors</em>. Use an <code>int</code> to keep track of the number of <em>cents</em>, rather than using a <code>double</code> to keep track of dollars.</p>

<p>In more detail, the problem is that the value 0.05 can't be represented exactly in binary floating point. It might really be 0.0499999999999, which isn't exactly what you want. When you compare this to your target value, the comparison goes ""yep, that is less"" even thought it might be just 0.0000000000001 cent less.</p>
",2
22497356,22497319,0,"<p>Because it is treating <code>i</code> as a char &amp; taking its ASCII value.</p>
",1
22497369,22497319,1,"<p>You've put a number (i.e., <code>i</code>) into a string without converting it to characters first. The result is that the string contains a character with that numeric code. Given how most common character sets are laid out, a character with a code less than 32 is typically going to be a control code.</p>

<p>You probably want to use <code>std::to_string</code> to convert the number to a string before adding it to the existing string. Alternatively, format the data into a <code>stringstream</code>, then return its content, something on this general order:</p>

<pre><code>string LinkedList::toString() {
    std::ostringstream buffer;
    Node *cur = first;
    for (int i = 0; i &lt; size; i++) {
        buffer &lt;&lt; ""node "" &lt;&lt; i &lt;&lt; "": "" &lt;&lt; cur-&gt;toString() &lt;&lt; ""\n"";
        cur = cur-&gt;getNext();
    }
    return buffer.str();
}
</code></pre>
",0
22497392,22497319,0,"<p>You are appending <code>int</code>s to your <code>output</code> <code>string</code>. These are being displayed as their ASCII representation.</p>

<p>You can fix this using <a href=""http://en.cppreference.com/w/cpp/io/basic_ostringstream"" rel=""nofollow""><code>std::ostringstream</code></a> (untested):</p>

<pre><code>std::string LinkedList::toString() {
    std::ostringstream output;
    Node *cur = first;
    for (int i = 0; i &lt; size; i++) {
        output &lt;&lt; ""node "";
        output &lt;&lt; i;
        output &lt;&lt; "": "";
        output &lt;&lt; cur-&gt;toString();
        output &lt;&lt; ""\n"";
        cur = cur-&gt;getNext();
    }
    return output.str();
}
</code></pre>

<p>This may be more readable as:</p>

<pre><code>std::string LinkedList::toString() {
    std::ostringstream output;
    Node *cur = first;
    for (int i = 0; i &lt; size; i++) {
        output &lt;&lt; ""node "" &lt;&lt; i &lt;&lt; "": "" cur-&gt;toString() &lt;&lt; ""\n"";
        cur = cur-&gt;getNext();
    }
    return output.str();
}
</code></pre>
",0
22497593,22497319,0,"<p>Use <code>itoa</code> for changing int to ascii. simply solves your problem.
Try Following code:</p>

<pre><code> string LinkedList::toString() {
string output = """";
char buff[100];
Node *cur = first;
for (int i = 0; i &lt; size; i++)
{
    itoa(i,buff,10);
    output += ""node "";
    output += buff;
    output += "": "";
    output += cur-&gt;toString();
    output += ""\n"";
    cur = cur-&gt;getNext();
}
return output;
}
</code></pre>
",0
33003316,33003295,4,"<p>Yes, but you could have the same thing much easier by just using <code>unique_ptr</code> and <code>make_unique</code> for all these pointers.</p>
",0
21602236,21602164,2,"<p>You can do:</p>

<pre><code>t_agent_val_c = &amp;*itr;
</code></pre>

<p>And <code>*itr != std::string::npos</code> is incorrect, should be <code>itr != my_string.end()</code>.</p>
",0
23838602,23838511,4,"<p>The <code>[]</code> operator has higher precedence than the unary <code>*</code> operator. Thus, <code>*values[1]</code> is the same as <code>*(values[1])</code>. What you want is <code>(*values)[1]</code>, as @sigfpe pointed out in the comments.</p>
",1
23838607,23838511,5,"<p>Easier to read...</p>

<pre><code>somefunction(float*&amp; values)
{
    values = new float[lines];
    values[0] = 0;
    values[1] = 1;
}

main()
{
    float* values;
    somefunction(values);
}
</code></pre>
",0
23838648,23838511,0,"<p>Simpler still:</p>

<pre><code>float* somefunction()
{
    float* values = new float[lines];
    values[0] = 0;
    values[1] = 1;
    return values;
}

main()
{
    float* values = somefunction();
}
</code></pre>
",3
26208276,26208252,2,"<p>Why don't you want to use a variable ? If you do, you can use a compound ternary operator :</p>

<pre><code>int val = GetValue(board);
cout &lt;&lt; val == 0 ? ""Tie"" : (val &lt; 0 ? ""White wins"" : ""Black wins"");
</code></pre>

<p>Edit: But THAT isn't one line, is it? The REAL one liner, courtesy of lambda functions.<br>
It also assumes that <code>GetValue</code> returns an int. And requires a <code>using namespace std</code> for conciseness.</p>

<pre><code>cout &lt;&lt; vector&lt;string&gt;({""White wins"", ""Tie"", ""Black Wins""})[([](int x){return(0&lt;x)-(x&lt;0)+1;}(GetValue(board)))];
</code></pre>

<p>(Also don't actually use that)</p>
",2
26208510,26208252,1,"<p>If you want to output the score with one function call you can do something like:</p>

<pre><code>cout &lt;&lt; msg[ GetValue(board) + 1] &lt;&lt; endl;
</code></pre>

<p>Where:</p>

<pre><code>msg[0] = ""White Wins"";
msg[1] = ""Tie"";
msg[2] = ""Black Wins"";
</code></pre>

<p>This assumes that <code>GetValue</code> returns -1, 0, or 1;</p>
",3
26208714,26208252,1,"<pre><code>std::string win_message(int const &amp;x)
{
    if ( x == 0 ) return ""Tie"";
    if ( x &lt; 0 ) return ""Black wins"";
    return ""White wins"";
}

// ...

    cout &lt;&lt; win_message( GetValue(board) );
</code></pre>
",2
26784967,26784852,3,"<p>N is 10^4 in the question ,your  maximum array size is 1000.  </p>

<pre><code>int a[1000];//Make this 10000
</code></pre>
",0
29188200,29188083,0,"<p>I think you are using find the wrong way. take a look at the doc: <a href=""http://www.cplusplus.com/reference/algorithm/find/"" rel=""nofollow"">http://www.cplusplus.com/reference/algorithm/find/</a>
You probably wanted</p>

<pre><code>if (find(colours, colours+7, askAnswer) != colours+7)
</code></pre>

<p>where 7 is size of your array (which means <code>colours+7</code> is an invalid pointer pointing to ""one after last"" element ). 
But it would be better to use std::begin() and std::end() as below:</p>

<pre><code>if (find(std::begin(colours), std::end(colours), askAnswer) != std::end(colours))
</code></pre>

<p>Also - take a look here: <a href=""http://en.cppreference.com/w/cpp/iterator/end#Example"" rel=""nofollow"">http://en.cppreference.com/w/cpp/iterator/end#Example</a></p>
",2
22439423,22439383,0,"<p>You can enter the number as a string and then parse the string.</p>
",0
22439437,22439383,0,"<p>You could use a function like this, where n is the number and d is the digit you want to count:</p>

<pre><code>int count_dig(int n, int d) {
    int result = 0;
    while (n &gt; 0) {
        if (n % 10 == d) {
            result++;
        }
        n/=10;
    }
    return result;
}
</code></pre>

<p>Using this, you could print your formatted result like:</p>

<pre><code>printf(""%d -- You used digit %d %d times."", n, d, count_dig(n, d));
</code></pre>
",0
26167157,26166218,1,"<p>No, there's no general theoretical basis for determining how <code>[u]int_fastN_t</code> should be defined, apart from the obvious requirement that they must be at least <code>N</code> bits wide.</p>

<p>There's really no firm definition of what a ""32-bit"" or ""64-bit"" CPU is. The number might refer to the size of a general-purpose CPU register, or to the size of an address, or to the width of some internal bus, or to the whim of the marketing department. There have been a number of CPUs whose ""bitness"" has been vague; some CPUs have been 8-bit in some ways and 16-bit on others, or 16-bit and 32-bit. See the evolution of the x86 and 68k CPU families for examples.</p>

<p>It's entirely possible to have a CPU with 64-bit general-purpose registers that also has instructions that can perform 32-bit arithmetic faster than 64-bit arithmetic. For that matter, 64-bit addition might be faster than 32-bit addition, and 32-bit division faster than 64-bit division.</p>

<p>Personally, I'm content to let the compiler and runtime library implementers worry about it, and define the <code>[u]intfastN_t</code> types in the most reasonable way for the targeted architecture. If I need to know the actual size at run time, there's always the <code>sizeof</code> operator. If I need to know the actual size when I'm writing code, I probably shouldn't be using <code>[u]int_fastN_t</code> in the first place.</p>

<p>Here's what the C standard says about the <code>[u]int_leastN_t</code> types (<a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow"">N1570</a> 7.20.1.3:</p>

<blockquote>
  <p>Each of the following types designates an integer type that is usually
  fastest to operate with among all integer types that have at least the
  specified width.</p>
  
  <p>The typedef name <strong><code>int_fastN_t</code></strong> designates the fastest signed integer
  type with a width of at least <strong><code>N</code></strong>. The typedef name <strong><code>uint_fastN_t</code></strong>
  designates the fastest unsigned integer type with a width of at least
  <strong><code>N</code></strong>.</p>
  
  <p>The following types are required:<br>
  <strong><code>int_fast8_t</code></strong>  <strong><code>uint_fast8_t</code></strong><br>
  <strong><code>int_fast16_t</code></strong> <strong><code>uint_fast16_t</code></strong><br>
  <strong><code>int_fast32_t</code></strong> <strong><code>uint_fast32_t</code></strong><br>
  <strong><code>int_fast64_t</code></strong> <strong><code>uint_fast64_t</code></strong><br>
  All other types of this form are optional.</p>
</blockquote>

<p>There are the only guarantees offered by the C standard; anything beyond that is non-portable.</p>
",3
23095736,23095616,1,"<p>The line</p>

<pre><code>result.w = m.m[3]*v.x + m.m[7]*v.y + m.m[11]*v.z + m.m[15]*v.w;
</code></pre>

<p>is equivalent to:</p>

<pre><code>result.w = m.m[15]*v.w;
</code></pre>

<p>if <code>v.x</code>, <code>v.y</code>, and <code>v.z</code> are always set to <code>0.0</code>, like you indicate.</p>
",0
23096256,23095616,0,"<p>My problem was that I didn't adapted the vector3f properly when adding <code>w</code>. The <code>=</code> shouldn't just pass the reference, so the vector3f had this:</p>

<pre><code>vector3f&amp; vector3f::operator = ( const vector3f &amp;other )
{
    x = other.x;
    y = other.y;
    z = other.z;

    return *this;
}
</code></pre>

<p>I adapted the other functions, but forgot this one, so the value of <code>w</code>was never passed on <code>=</code> operation. The correct is:</p>

<pre><code>vector3f&amp; vector3f::operator = ( const vector3f &amp;other )
{
    x = other.x;
    y = other.y;
    z = other.z;
    w = other.w;

    return *this;
}
</code></pre>

<p>I passed 2 days trying to find what was wrong with my program and then more than 2 hours trying to find why <code>w</code> didn't changed just to find this. Sory to bother people here with my stupidity.</p>
",1
25516632,25516613,0,"<p>They are equally efficient/inefficient. Both involves copying the string and using the copy as the value of the argument 'str'. A better way would be declaring func as</p>

<pre><code>void func(const std::string &amp;str) {
}
</code></pre>

<p>This can avoid copying of the string.</p>
",2
31233212,31233107,2,"<p>Consider this scenario</p>

<pre><code> s[1]=s[2] and s[1]=s[4] and s[0]=s[2]//rest everything we don't care about
</code></pre>

<p>Code1 will output <code>yes</code>.Good.
Now consider code2</p>

<pre><code>    if(s[0]==s[2]||s[0]==s[3])//s[0]==s[2] so we enter here
   {
          if((s[0]==s[4]||s[0]==s[5])) //this condition is not true so `yes` is not printed
           { cout&lt;&lt;""YES""&lt;&lt;endl; } 
   }
   else if(s[1]==s[2]||s[1]==s[3])//now we won't enter here as we already entered if
   {
          if((s[1]==s[4]||s[1]==s[5])) cout&lt;&lt;""YES""&lt;&lt;endl;
   }
</code></pre>

<p>So code2 outputs nothing.</p>
",0
31233224,31233107,1,"<p>You are missing some condition in the 2nd:</p>

<p>Like this:</p>

<pre><code>if(s[0]==s[2] &amp;&amp; s[1]==[5])
</code></pre>

<p>What will be the output of this??</p>

<p>In every <code>if-else if</code> condition you have to add a <code>else</code> condition.</p>

<p>In code:</p>

<pre><code>if(s[0]==s[2]||s[0]==s[3])
{
    if((s[0]==s[4]||s[0]==s[5]))
    {
        cout&lt;&lt;""YES""&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;""No""&lt;&lt;endl;
    }
}
</code></pre>
",1
27748101,27747944,0,"<p>The below function</p>

<pre><code>void _medianfilter(const element* signal, element* result, int N)
</code></pre>

<p>requires a one dimensional array as input and returns the smoothed result in again an one dimensional array.  </p>
",2
22853726,22853566,1,"<p>I suspect you declare saving and checking private members as ""Account"" rather than double. Even if that is your intended design, you can not add user defined class objects without expliclity define operator+(const Account &amp;).</p>
",0
22853744,22853566,5,"<p>You need to define the + operator for the Account class so it knows what to do. Since you were trying to add an Account object with a double, you would need this.</p>

<pre><code>double Account::operator+(const double value) const {
    return balance + value;
}
</code></pre>

<p>If you want to add two account objects, you can overload with this.</p>

<pre><code>Account Account::operator+(const Account &amp;other) const {
    return Account(balance + other.balance, interest_rate);
}
</code></pre>
",2
22853753,22853566,1,"<p>In this line of your source code:</p>

<pre><code>            savings = savings + amount;
</code></pre>

<p><code>savings</code> has a type of <code>Account</code>, but <code>amount</code> is a <code>double</code>. Unless you define a <code>+</code> member operator on the <code>Account</code> class like</p>

<pre><code>Account operator+(const double value) const;
</code></pre>

<p>Or a global <code>+</code> operator(possible as a <code>friend</code> function) like</p>

<pre><code>Account operator+(const Account&amp; account, const double value);
</code></pre>

<p>Then you cannot do such addition.</p>
",0
22854020,22853566,5,"<p>If you don't want to add extra operators to your classes, then instead of writing:</p>

<pre><code>savings = savings + amount;
</code></pre>

<p>use the already declared methods of the Account class and write:</p>

<pre><code>savings.deposit(amount);
</code></pre>
",0
22467959,22467938,3,"<p>No, since it is allocated on stack. </p>

<p>I found this thread useful after typing my answer: <a href=""https://stackoverflow.com/questions/2672085/c-static-array-vs-dynamic-array"">C++ Static Array VS Dynamic Array</a></p>
",0
22489542,22489333,5,"<p>You're hitting Undefined Behaviour here:</p>

<pre><code>dynamic_cast&lt;childb*&gt;(b)-&gt;printout();
</code></pre>

<p>The cast actually fails (returns a null pointer). You never check the return value and call a member function through it. That's Undefined Behaviour and anything can happen. In your case, it seems that because the function does not access <code>this</code> in any way, it executes just fine even though invoked through a null pointer. But that's not guaranteed.</p>

<hr>

<p>As for what a sideways cast (or cast up another chain) is, that needs a more complex inheritance hierarchy to demonstrate:</p>

<pre><code>struct base1
{
  virtual ~base1() {}
};

struct base2
{
  virtual ~base2() {}
};

struct child1 : base1
{};

struct child2 : base2
{};

struct both : child1, child2
{};


int main()
{
  child1 *c1 = new both();
  static_cast&lt;base1*&gt;(c1);  // ok
  static_cast&lt;both*&gt;(c1);  // ok
  static_cast&lt;child2*&gt;(c1);  // compile-time error, unrelated types
  dynamic_cast&lt;child2*&gt;(c1);  // succeeds, because the object is actually of type `both`, i.e. derived from `child2`; cast sideways
  static_cast&lt;base2*&gt;(c1);  // compile-time error, unrelated types
  dynamic_cast&lt;base2*&gt;(c1); // succeeds, because the object is actually of type `both`, i.e. derived from `base2`; cast up another chain

  base1 *b1 = new child1();
  static_cast&lt;child1*&gt;(b1);  // ok
  static_cast&lt;both*&gt;(b1);  // compiles, but produces UB, as the object is not of correct type
  static_cast&lt;base2*&gt;(b1);  // compile-time error, unrelated types
  dynamic_cast&lt;base2*&gt;(b1);  // fails (returns null pointer), because the object is not actually derived from `base2`.
}
</code></pre>
",0
22490254,22489333,0,"<p><code>dynamic_cast&lt;T*&gt;(a)</code> returns a not null <code>T*</code> if and only if <code>*a</code> is instance of <code>T</code>; otherwise, it returns <code>NULL</code>.</p>

<p>Invoking a method or attribute from a null pointer produces an undefined behavior.</p>
",0
22490467,22489333,0,"<p>The usefulness of dynamic_cast is in his answer. With this code</p>

<pre><code>int main()
{
    base* b = new childa;
    b -&gt;print();

    childa* testA = dynamic_cast&lt;childa*&gt;(b);
    if (testA)
    {
        //Here you can be sure that your object is right
        testA-&gt;printout();
        testA-&gt;c1 = 'a';
    }
    else
        std::cout &lt;&lt; ""Error casting b to testA"" &lt;&lt; std::endl;

    childb* testB = dynamic_cast&lt;childb*&gt;(b);
    if (testB)
    {
        //Here you can be sure that your object is right
        testB-&gt;printout();
        testB-&gt;c2 = 2;
    }
    else
        std::cout &lt;&lt; ""Error casting b to testB"" &lt;&lt; std::endl;
}
</code></pre>

<p>you obtain the following output</p>

<pre><code>childa
childa out
Error casting b to testB
</code></pre>
",0
31160635,31160055,0,"<p>Here increment takes place before assignment by toupper so the proccess is:
<code>*beg++;</code> then <code>*beg=toupper(*beg-1);</code> I have written *beg-1 because *beg value has increased by one, but it takes previous value.</p>
",0
31160345,31160055,0,"<p>As the second link you posted states out, this is a <strong><em>sequence point</em></strong>. So, the problem with this:</p>

<pre><code>*beg = toupper(*beg++);
</code></pre>

<p>is that you do not know which part is going to be evaluated first (notice the <code>*</code> operator). If you are not convinced, read this <a href=""https://stackoverflow.com/a/4638525/2411320"">answer</a>.</p>

<p>You understand well the <em>postfix</em> concept, but you tangled up in a sequence point.</p>
",0
31230646,31230539,3,"<p>Your problem is the original function definition:</p>

<pre><code>C &amp;f() const {return *this;}
</code></pre>

<p>here you return a non-const reference to the const object, which would allow changing the const object and would be dangerous, therefore it's forbidden.</p>

<p>If you were to write it as </p>

<pre><code>const C &amp;f() const {return *this;}
</code></pre>

<p>would be callable from both const and non-const objects and would always return a const reference.</p>

<blockquote>
  <p>Of course, we could provide a non-const version of C::f() to work on non-constant objects. However, I do not believe that this is what we want.</p>
</blockquote>

<p>Probably that is exactly what you want. It's the only way to return a non-const reference when called on non-const objects and keep const correctness when calling it on const objects.</p>
",8
26169809,26168824,0,"<p>The simpliest way is to use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb773831.aspx"" rel=""nofollow""><code>SHCreateMemStream()</code></a>, eg:</p>

<pre><code>CString str = ...;
IStream *strm = SHCreateMemStream((BYTE*)(LPCTSTR)str, str.GetLength() * sizeof(TCHAR));
if (strm)
{
    ConvertToODF(strm);
    strm-&gt;Release();
}
</code></pre>

<p>Depending on what character encoding <code>ConvertToODF()</code> is actually expecting, you may need to convert the content of the <code>CString</code> before then calling <code>SHCreateMemStream()</code>.</p>
",0
24639869,24639795,1,"<p>You can reference it by using its full path or by referencing through one or more <code>..</code>'s in your path (that means ""go up one level""), or you can specify the directory in which the header file resides in the 'header file search path' (the 'include path') and then just use the filename.</p>

<p>However, using the full path is not recommended because if you move the header file relative to the file it is being referenced from, then it will not work anymore.</p>

<p>Look at <a href=""https://stackoverflow.com/questions/12562807/include-absolute-path-syntax-in-c-c"">this SO question</a> for a nice answer as well.</p>
",2
24639940,24639795,0,"<p>For CPP files you need add those files in your project. If you are using Visual Studio you can add the cpp file by right clicking on your working project and selecting add existing item. If you want to refer a .h file you need include this, e.g</p>

<pre><code>#include ""../Documents/wx/Windows.h""
</code></pre>

<p>It is always good to use relative path rather than using absolute path.</p>
",0
24639864,24639795,4,"<pre><code>#include ""../Documents/wxMathPlot.h""
</code></pre>

<p>Should work. To elaborate:</p>

<p>When you use an include such as <code>#include ""header.h""</code> the same directory as the file is searched.</p>

<p>When you use an include such as <code>#include &lt;header.h&gt;</code> a specific directory is searched, chosen by your compiler, which is where you will find most standard library header files.</p>
",0
29232469,29232147,1,"<p>C++ does not provide a mechanism for doing this automatically, but you can make a class that supports the behavior that you are trying to make.</p>

<p>Here is a grossly oversimplified version of what you can do:</p>

<pre><code>class IntRef {
    int *ptr;
    int copy;
public:
    IntRef(int&amp; d) : ptr(&amp;d) {}
    IntRef&amp; operator=(const int&amp; rhs) {
        // Detach from the original on assignment
        copy = rhs;
        ptr = &amp;copy;
    }
    operator int() const {
        return *ptr;
    }
};

int main() {
    int x = 5;   //Original variable
    IntRef y(x); //Reference variable to x.
    x = 5;      //Modifying original variable.
    cout&lt;&lt;x&lt;&lt;"" ""&lt;&lt;y&lt;&lt;endl;
    y = 10;      //Modifying reference variable.
    cout&lt;&lt;x&lt;&lt;"" ""&lt;&lt;y&lt;&lt;endl;
    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/s6ve6T"" rel=""nofollow"">Demo.</a></p>

<p>This prints</p>

<pre><code>5 5
5 10
</code></pre>

<p>The idea of the implementation above is to keep a pointer pointing to the original value for as long as <code>y</code> is not assigned. After the assignment the pointer is switched to a copy that is kept internally.</p>
",3
29232258,29232147,1,"<p>No, what you want to do isn't possible. Consider what happens if you modify both <code>y</code> and <code>x</code>. Where does <code>y</code> take its value then? From the updated value of <code>x</code> which should modify both <code>x</code> and <code>y</code>, or from the updated value of <code>y</code> which should update <code>y</code> only and not <code>x</code>?</p>

<p>The only way forward is to implement your own logic. In any case, you need to have two <code>int</code> variables.</p>
",2
29232261,29232147,2,"<p>There is no language construct that can immediately give you what you seek but you can implement it fairly straightforward by encapsulating x and y.</p>

<pre><code>struct XChangesY{
   set_x(int x_and_y){  y = x = x_and_y; }
   set_y(int y_){ y = y_; }
   int get_x(){ return x; }
   int get_y(){ return y; }
private:
   int x;
   int y;
}
</code></pre>
",0
29232571,29232147,1,"<p>What you're looking for isn't inherently built-in the language - having two variables sharing the same value, changing one changes both but changing the other one only changes one.</p>

<p>That question though is similar to shared pointers and reference counters. For example, when you make a copy of a <code>std::string</code>, the content of the string isn't copied. A new <code>string</code> object is created with a pointer to the same data as the first string, and a reference counter.</p>

<p>So both strings share the same data. But when you change one - either one - and the reference counter is more than one, then that <code>string</code> dissociates itself and copies the data, and both strings are no longer linked. This is in order to avoid duplicated long strings of data when there's no need.</p>

<p>The same thing happens with Qt containers (<code>QByteArray</code>, <code>QMap</code>, <code>QList</code>, ...).</p>

<p>Another way to look at your problem is a logic of watcher - data received from outside updates the internal value, but the internal value can be changed by other means. Qt's signals/slot feature can be used to do that naturally, or you can easily implement your own logic to do that yourself.</p>
",0
29232414,29232147,1,"<p>Sure, but it's not elegant-- </p>

<pre><code>template&lt;typename T&gt;
class C
{
   public:
      C(T t) : m_t(new T(t)), t_local(t), is_copy(false) {}
      C(const C&amp; c) : m_t(c.m_t), t_local(t), is_copy(true) {}

      T Get() { return *m_t; }
      T GetLocal() { return t_local; }
      void Set(T t) 
      { 
           t_local = t; 
           if (!is_copy) *m_t = t;
      }

   private:
      T* m_t;
      T t_local;
      bool is_copy;
};
</code></pre>

<p>And your setup creates an ambiguity when it comes to evaluating <code>y</code>, after both it has been changed--do you want the value of <code>x</code>, or the new, different value of <code>y</code>?  I don't see any way to avoid creating separate methods for each case.</p>
",0
29232583,29232147,1,"<p>Seems like what you want is <em>copy-on-write</em> semantics. Something like this might work for you, but is easily abused:</p>

<pre><code>template &lt;class T&gt;
class cow_ptr
{
    public:
        using ref_ptr = std::shared_ptr&lt;T&gt;;

    private:
        ref_ptr m_sp;
        bool m_original; //don't detach the original

        void detach()
        {
            T* tmp = m_sp.get();
            if( !( tmp == 0 || m_sp.unique() || m_original ) ) {
                m_sp = ref_ptr( new T {*tmp} );
            }
        }

    public:
        cow_ptr(T* t)
            :   m_sp{t}, m_original{true}
        {}
        cow_ptr(const ref_ptr&amp; refptr)
            :   m_sp{refptr}, m_original{true}
        {}
        cow_ptr(const cow_ptr&amp; cowptr)
            :   m_sp{cowptr.m_sp}, m_original{false}
        {}
        cow_ptr&amp; operator=(const cow_ptr&amp; rhs)
        {
            m_sp = rhs.m_sp;
            return *this;
        }
        const T&amp; operator*() const
        {
            return *m_sp;
        }
        T&amp; operator*()
        {
            detach();
            return *m_sp;
        }
        const T* operator-&gt;() const
        {
            return m_sp.operator-&gt;();
        }
        T* operator-&gt;()
        {
            detach();
            return m_sp.operator-&gt;();
        }
};
</code></pre>

<p>Then you can use it like this:</p>

<pre><code>int main()
{
    auto x = cow_ptr&lt;int&gt;{ new int{5} };
    auto y = x;
    const auto &amp;yr = y; //so dereferencing doesn't detach
    cout&lt;&lt;*x&lt;&lt;"" ""&lt;&lt;*yr&lt;&lt;endl; //5 5
    *x = 10;
    cout&lt;&lt;*x&lt;&lt;"" ""&lt;&lt;*yr&lt;&lt;endl; //10 10 (updating x updated y)
    *y = 15;
    cout&lt;&lt;*x&lt;&lt;"" ""&lt;&lt;*yr&lt;&lt;endl; //10 15 (updating y did not update x)
    //from now on, changing x will not change y
}
</code></pre>
",0
31880469,31880356,0,"<p>An array variable cannot used on the LHS of an assignment operator. In other words, the value of an array variable cannot be changed, it can only be initialized. You can change the elements of the array but not the array.</p>

<p>It's not clear to me what you hope to accomplish in the line</p>

<pre><code>iHisto = tHisto;
</code></pre>

<p>You certainly don't need to copy the contents. <code>tHisto</code> is initialized to point to the first element of <code>iHisto</code>. The elements of <code>iHisto</code> can be accessed through <code>iHisto</code> as well as <code>tHisto</code>.</p>
",0
31880538,31880356,0,"<p>You can copy the contents of an array to another using memcpy.</p>

<pre><code>void * memcpy ( void * destination, const void * source, size_t num );
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/cstring/memcpy/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstring/memcpy/</a></p>
",0
21577615,19385193,0,"<pre><code>#include&lt;iostream.h&gt;
#include&lt;conio.h&gt;
void main()
{
int i,j,n=5;
clrscr();  
for(i=0;i&lt;n;i++)
  {
    for(j=1;j&lt;=i;j++)
      {
      cout&lt;&lt;i;
      }
    cout&lt;&lt;endl;
  }
getch();
}
</code></pre>
",1
24756728,19471938,0,"<p>In your code, person1 and person2 are defined as 2 char arrays not char pointer variables, you can not swap them, if you pass the 2 arrays into the swapname function which takes 2 pointers as parameters, it should not even compile.</p>
",0
26447020,26446991,4,"<p><code>'cs'</code> is a multicharacter constant</p>

<p>And <code>A='cs'</code> is assignment not comparison, which also is not intended and incorrect</p>

<p>You should use <code>std::string A;</code>  </p>

<p>and do comparison like following</p>

<pre><code>if( A == ""cs"" ) { }
</code></pre>
",0
26447602,26446991,0,"<pre><code>int main()
{
char A,B='cs';

cout &lt;&lt; ""You have before you a closed door !"" &lt;&lt; endl;
cin &gt;&gt; A;

while (1)
{
  if (A==B)
    break;

  else
    cin &gt;&gt; A;
}

cout &lt;&lt; ""Congratulations ! The door has opened !"" &lt;&lt; endl;

return 0;
}
</code></pre>

<p>You have done mistake in the comparison of the multicharacter constant. </p>
",0
21026966,21026903,4,"<p>You have a circular dependency - <code>Vector.h</code> and <code>Point.h</code> each try to include the other. The include guards will prevent serious problems, but you'll end up with one of the classes defined before the other, and the name of the second will not be available within the first.</p>

<p>Luckily, <code>Point</code> doesn't need a full definition of <code>Vector</code> - a forward declaration will do.</p>

<pre><code>class Vector;
class Point {
    // ...

    // No problem using `Vector` to declare a return type here
    friend Vector operator-(const Point&amp; left, const Point&amp; right);
};
</code></pre>
",1
31126658,31126605,2,"<p>You are using it with an integral type. It will only fail when used with a non-integral type. The following should fail to compile:</p>

<pre><code>float f;
is_even(f);
</code></pre>

<p>Note that with a C++14 compiler you <a href=""http://en.cppreference.com/w/cpp/types/enable_if"" rel=""nofollow"">can write</a>:</p>

<pre><code>template &lt;class T,
          class = std::enable_if_t&lt;std::is_integral&lt;T&gt;::value&gt;&gt;
</code></pre>

<p>However, you may want to use a <a href=""http://en.cppreference.com/w/cpp/language/static_assert"" rel=""nofollow"">static_assert</a> here, since the function probably does not make sense for non integral types, and it will give a better error message at compile time.</p>

<p>Another usage of additional parameters in SFINAE is to lower the preference for a given function. The template with more template arguments with be less likely to get selected than the one with less templates arguments.</p>
",2
31127083,31126605,1,"<p>The purpose of the <code>enable_if</code> in this case is to cause a compilation error when the deduced template argument for <code>T</code> is not an integral type. We can see from <a href=""http://en.cppreference.com/w/cpp/types/is_integral"" rel=""nofollow noreferrer"">cppreference/is_integral</a> that integral types are integers, characters and their signed and unsigned variants.</p>

<p>For any other type you will get an error that looks like:</p>

<pre><code>main.cpp:21:32: error: no matching function for call to 'is_odd'
  std::cout &lt;&lt; ""i is odd: "" &lt;&lt; is_odd(NotIntegral()) &lt;&lt; std::endl;
                               ^~~~~~
main.cpp:6:25: note: candidate template ignored: disabled by 'enable_if' [with T = NotIntegral]
typename std::enable_if&lt;std::is_integral&lt;T&gt;::value,bool&gt;::type
</code></pre>

<blockquote>
  <p>I understand if it's used as a return type specifier is that the compiler will ignore the code</p>
</blockquote>

<p>This isn't true. The return type is evaluated just like any other part of the declaration. See <a href=""https://stackoverflow.com/questions/14600201/why-should-i-avoid-stdenable-if-in-function-signatures"">Why should I avoid std::enable_if in function signatures</a>. The choice of placement of the <code>std::enable_if</code> has its pros and cons.</p>

<blockquote>
  <p>But i am confused what is the purpose of that second argument?</p>
</blockquote>

<p>Consider the example where you have a function named <code>foo</code> that takes some <code>T</code>.</p>

<pre><code>template&lt;class T&gt; void foo(T);
</code></pre>

<p>You want to restrict one overload of <code>foo</code> whose <code>T</code>'s have a <code>value</code> member equal to <code>1</code>, and want to use another overload for when <code>T::value</code> does not equal <code>1</code>. If we simply have this:</p>

<pre><code>template&lt;class T&gt; void foo(T); // overload for T::value == 1
template&lt;class T&gt; void foo(T); // overload for T::value != 1
</code></pre>

<p>How does this convey to the compiler that you want to use two separate overloads for two separate things? It doesn't. They are both ambiguous function calls:</p>

<pre><code>template&lt;std::size_t N&gt;
struct Widget : std::integral_constant&lt;std::size_t, N&gt; { };

int main() {
    Widget&lt;1&gt; w1;
    Widget&lt;2&gt; w2;

    foo(w1); // Error! Ambiguous!
    foo(w2); // Error! Ambiguous!
}
</code></pre>

<p>You will need to use <a href=""https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error"" rel=""nofollow noreferrer"">SFINAE</a> to reject the templates based on our condition:</p>

<pre><code>template&lt;class T, class = std::enable_if_t&lt;T::value == 1&gt;* = nullptr&gt;
void foo(T); // #1

template&lt;class T, class = std::enable_if_t&lt;T::value != 1&gt;* = nullptr&gt;
void foo(T); // #2
</code></pre>

<p>Now the correct ones are called:</p>

<pre><code>foo(w1); // OK! Chooses #1
foo(w2); // OK! Chooses #2
</code></pre>

<p>What makes this work is the way <code>std::enable_if</code> is built. If the condition in its first parameter is true, it provides a member typedef named <code>type</code> equal to the second parameter (defaulted to <code>void</code>). Otherwise, if the condition is false, it does not provided one. A reasonable implementation could be:</p>

<pre><code> template&lt;bool, class R = void&gt;
 struct enable_if { using type = R; };
 template&lt;class R&gt;
 struct enable_if&lt;false, R&gt; { /* empty */ };
</code></pre>

<p>So if the condition fails, we will be trying to access a <code>::type</code> member that doesn't exist (remember that <code>std::enable_if_t</code> is an alias for <code>std::enable_if&lt;...&gt;::type</code>). The code would be ill-formed, but instead of it causing a hard error, during overload resolution the template is simply rejected from the candidate set and other overloads (if present) are used instead.</p>

<p>This is a simple explanation of SFINAE. See the <a href=""http://en.cppreference.com/w/cpp/language/sfinae"" rel=""nofollow noreferrer"">cppreference page</a> for more information.</p>

<p>In your case there is only one overload of <code>is_odd</code> and <code>is_even</code>, so if you pass <code>NotIntegral</code> to them, they will fail because their respective overloads are taken out of the candidate set, and since there are no more overloads to evaluate overload resolution fails with the aforementioned error. This could be cleaned up a bit with a <code>static_assert</code> message instead. </p>

<pre><code>template&lt;class T&gt;
bool is_even (T i) {
    static_assert(std::is_integral&lt;T&gt;::value, ""T must be an integral type"");
    return !bool(i%2);
}
</code></pre>

<p>Now you will no longer be given a weird looking error message but your own custom one. This also rules out SFINAE since the <code>static_assert</code> is evaluated after template arguments are substituted, so it's your choice on which route to take. I would recommend the assertion since it's much cleaner and there is no need for SFINAE here.</p>
",5
29452617,29452577,2,"<blockquote>
  <p>Is there some reason this was done?</p>
</blockquote>

<p>Since accessing the <code>streambuf</code> is more common than changing it, that case was made more convenient.</p>

<p>The special functions added by <code>stringstream</code> won't work unless the buffer is a <code>streambuf</code>, so it doesn't really make sense to treat it as a <code>stringstream</code> with a different buffer. You can use the entire base <code>iostream</code> class interface, though.</p>

<blockquote>
  <p>Is it possible to change the internal <code>streambuf</code> object used by a stringstream?</p>
</blockquote>

<p>Sure, just qualify the member access: <code>s.iostream::rdbuf( newbuf )</code>. You should similarly qualify any subsequent call to the <code>rdbuf()</code> accessor if the buffer isn't a <code>std::stringbuf</code>, to avoid an illegal cast to that class.</p>

<p>Or, just create an <code>iostream &amp;</code> reference and forget the original <code>stringstream</code>, except for the purpose of destroying it.</p>
",2
23808462,23808247,5,"<p>You <em>are</em> printing the addresses, using the ""address-of"" operator:</p>

<pre><code>std::cout &lt;&lt; &amp;n &lt;&lt; std::endl;
</code></pre>

<p>I suspect you inserted the ""&amp;"" to stop the compiler from complaining that there's no <code>&lt;&lt;</code> operator for <code>node</code>.<br>
It's much more effective to provide one:</p>

<pre><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const node&amp; n)
{
     // Output the data from 'n' on 'os' the way you like...
     os &lt;&lt; ""whatever"";
     return os;
}
</code></pre>
",1
22883389,22883358,6,"<p>You need</p>

<pre><code>Test::Inner* Test::foo(){
</code></pre>

<p>}</p>

<p>If a member function definition is outside the class definition, then the return type is <strong><em>not</em></strong> in the class scope, unlike the rest of the function, so you need to explicitly qualify the return type.</p>
",0
22883393,22883358,3,"<p>Inner is a <strong>nested</strong> class and outside class <code>Test</code> it has to be fully qualified:</p>

<pre><code>Test::Inner* Test::foo() {
    //...
}
</code></pre>

<p>because in global scope<code>Inner</code> is indeed unknown, only <code>Test::Inner</code>, so a <code>Inner</code> inside <code>Test</code> is known. You could also have another <code>Inner</code> in global scope, just the same as with <code>Test</code>, and this will be other <code>Inner</code>, not <code>Test::Inner</code>.</p>
",0
22883402,22883358,3,"<p>You does not seem to specify the scope so it, of course, remains unknown. The C++ compiler will look for an <code>Inner</code> class outside your <code>Test</code> class which could also present as a different class, but it is not in your particular case.</p>

<p>That is why you will need to also provide the scope, even for the return type. That is not to say you would need to use the scope inside your test class, but outside, you will have to due to that.</p>

<p>Thereby, the correct code would be something like this:</p>

<pre><code>class Test {
    class Inner {
    };    
public:    
    Inner* foo (void);
};

Test::Inner* Test::foo(){
//^^^^
}
</code></pre>

<p>Strictly speaking, if you have a recent compiler, you could even use auto, but then it gets a bit less comprehensive.</p>
",0
22883411,22883358,2,"<pre><code>class Test {
class Inner {
};     
public:    
    Inner* foo (void);
};

Test::Inner* Test::foo(){
}
</code></pre>
",0
22883441,22883358,5,"<p>Since no one has mentioned it, you can also do this in C++11:</p>

<pre><code>auto Test::foo() -&gt; Inner * {...}
</code></pre>

<p>This can be useful if the fully qualified name is long. In C++14, you can leave off the trailing type part and just do:</p>

<pre><code>auto Test::foo() {...}
</code></pre>

<p>This will deduce the return type.</p>
",0
24569344,24566296,2,"<p>Yout main performance problem isn't copying, it's memory allocation. Assuming you actually removed the static, your stirng object is located in stack memory, but the string data in located in memory dynamicallty allocated on the heap. Since you are constructing your string operation each time, you have one or more dynamic allocations and a free for each line copied. These are very expensive allocations.</p>

<p>Making the string static will help with timing at the expense of memory. In most library implementations, getline will not change the amount of memory allocated to hold string data. So the string buffer will expand to the size of the largest string read from the file and stay there. But since the string object is static you have no way to release this memory. There are other ways to structure the program that can resolve this problem.</p>

<p>If this piece of code is really the hold-up in your code (how do you know it is?), and your input has a maximum line length, then don't use a std::string and use istream::getline to read into a character array. This will set a error in the ifstream if you encounter a line longer than your buffer. Inserting into a character array is faster tha inserting into a string. However, I'd be surprised if this code is really taking that much time.</p>
",0
22510227,22509986,2,"<p>Your <code>command::printCommands()</code> is declared const. Since <code>file</code> is a member, you are trying to pass a <code>const ifstream&amp;</code> as a non-const <code>std::istream&amp;</code> parameter (received by <code>std::getline</code>).</p>

<p>The conversion looses the <code>const</code> qualifier on call (so compilation fails with the error you got).</p>

<p>To fix, remove the const qualifier from <code>command::printCommands()</code>.</p>
",4
22510258,22509986,1,"<pre><code>void command::printCommands() const
</code></pre>

<p>That line declares <code>printCommands()</code> to be a const function. I.e., one that does not change the <code>command</code> object. Reading from an input stream is a change, so if the input stream is part of the <code>command</code> then reading from it necessarily changes the <code>command</code>.</p>

<p>I don't know your program so I can't say whether the following is a good idea or not, but it should make the error go away: declare <code>file</code> as a mutable member:</p>

<pre><code>mutable std::ifstream file;
</code></pre>
",0
24107714,24107699,4,"<p>Change it to </p>

<pre><code>Question(int id=0, const std::string&amp; text="""",char correctAnswer='a')
</code></pre>

<p><code>'a'</code> is a single char.</p>

<p>Double quotes always creates an array.</p>

<p>""Hello"" is an array of size 6.</p>

<p>""a"" is an array of size 2.</p>

<p>The extra 1 is for a null terminator (0 or '\0')</p>
",0
24107716,24107699,2,"<pre><code>Question(int id=0, const std::string&amp; text="""",
                            char correctAnswer='a')
//                                              ^^ Use single Quote for a char
        id(id),text(text),correctAnswer(correctAnswer) 
{

}
</code></pre>
",0
21298511,21297329,3,"<p>This line in main:</p>

<pre><code>HealthProfile person;
</code></pre>

<p>Declares an instance of the HealthProfile class using a default constructor.  You've not declared a default constructor.  Creating your own custom constructor prevents a default constructor from being implicitly created for you.  If you want to use a default constructor as well as a custom one, you need to explicitly declare and define it.  If you don't want to use a default constructor, then pass in arguments to use your custom one.</p>

<p>To declare a default constructor in your .h:</p>

<pre><code>HealthProfile();
</code></pre>

<p>And to define it in your .cpp:</p>

<pre><code>HealthProfile::HealthProfile() { }
</code></pre>

<p>Or to simply call your existing custom constructor in main:</p>

<pre><code>HealthProfile person(first,last,g,m,d,y,h,w);  // AFTER collecting values for these arguments
</code></pre>
",1
21327410,21326795,0,"<p>Assuming your code describes what you have to do, that is, compare the difference from each corresponding cell in a pair of matrices, then yes, you will need to ""visit"" each cell, and this requires some form of loop. So there is no way to avoid that. </p>

<p>As others have said, if your matrix is 3x3, then you should have <code>a &lt; 3</code> and <code>b &lt; 3</code>, or you go outside the matrix in your loop.</p>

<p>There are possibly ways that you could write it in a different way, but I can't really think of any that makes is ""nicer"" in this case. </p>

<p>If your goal is to determine if ALL cells are below a certain value, then you can ""stop early"" if the value doesn't match your criteria. Something like this:</p>

<pre><code>success = true;
for(int a = 0; a &lt; 3 &amp;&amp; success; a++)
{
   for(int b = 0; b &lt; 3 &amp;&amp; success; b++)
   {
      if((wheat[a][b] - nineGrain[a][b]) &gt;= shopperChoice) {
         sucess = false;
      }
   }
}
</code></pre>

<p>And then instead of <code>if (custSmiles == 9)</code> or whatever, you do <code>if (success)</code> to determine that it was a ""good one"". </p>

<p>It probably makes little difference in this case, but will save substantial time for very large matrices that often ""don't match"" [assuming the mismatch is venly distributed position, if it's always the lower right corner, then you may want to do the loop in reverse, or some such].</p>
",0
21327490,21326795,1,"<p><code>Will I have to resort to for loops for comparing two 2d arrays in C++?</code></p>

<p>It's late, i'm really bored and i made this, take it as you will however i felt this had some kind of worth, if i made any mistakes someone should feel free to tell me, so i stop doing whatever it is that i shouldn't be doing, i'm only trying to help and i certainly don't do things wrong knowingly..</p>

<p>Also I realize i pick some god awful names but you can change them to whatever you want, i'm working on choosing better names, if you find anything useful in this, slice it up and make it work for you, anyway enough rambling.</p>

<p><strong>main.cpp</strong>;</p>

<pre><code>#include &lt;iostream&gt;
#include ""hide.h""

int main(){

    float array_A[3][3] = {
        {1, 1, 1},
        {1, 1, 1},
        {1, 1, 1}
    };  
    float array_B[3][3] = {
        {0.1, 0.2, 0.3},
        {0.4, 0.5, 0.6},
        {0.7, 0.8, 0.9}
    };

    hide::setChoice(0.35);

    hide A(array_A), B(array_B);

    std::cout&lt;&lt; ""\ncounter after A - B: ""&lt;&lt; A - B &lt;&lt; ""\n"";

    hide::resetCounter();
}

    /* * * * * * * * * * * * * * * * * * * * * * * * *
     *
     * the values returned by ( A - B ) are useless in this
     * context it would only make sense if you changed this
     * to fill/populate them with the proper values.
     *
     * that said this version of the class evaluates the
     * the same expression you did in the if statement within
     * the for loops (x[a][b] - y[a][b] &lt; c) on each element
     * within the array/s.
     *
     * This effectively *hides* the for loops if you don't
     * look in the classes source files when you're thinking
     * ""Geez i hate loops"".
     *
     * lastly there is no bounds checking (or error) present,
     * you can index any value you could without a class
     * wrapped around the array should you decide to do that.
     *
     * * * * * * * * * * * * * * * * * * * * * * * * *
     *
     * (A - B) evaluates to s_counter
     *                  
     *  A (or) B.access( row, col ) treats like 2d
     *
     *  A (or) B.index( i ) treats like 1d
     *
     *  access() &amp; index() are not used in the example
     *
     * * * * * * * * * * * * * * * * * * * * * * * * *
     *
     * hide::getCounter() also returns s_counter
     *
     * hide::resetCounter() sets s_counter to 0
     *
     */
</code></pre>

<hr>

<p><strong>hide.h</strong></p>

<pre><code>#ifndef HIDE_H
#define HIDE_H // include guard

// width and height constants need to be set accordingly
#define _WIDTH 3
#define _HEIGHT 3

class hide {
    private:
        static const int s_height;
        static const int s_width;
        static float s_choice; // a.k.a shopperChoice
        static int s_counter; // a.k.a custSmiles


        float (*m_array)[_WIDTH];
        /*
         * I'm using this as a pointer to
         * a multidimensional array, that is what
         * a 2d array really is under the hood,
         * i prefer to just use it that way and
         * create the abstractions myself..
         */

    public:
        static float setChoice(const float &amp;choice);
        static int resetCounter();
        static int getCounter();

        hide(float (*ptr)[_WIDTH]);
        ~hide();

        float access(const int &amp;row, const int &amp;col);
        float index(const int &amp;i);

        int operator-(hide &amp;aHide);
};

#endif
</code></pre>

<hr>

<p><strong>hide.cpp</strong></p>

<pre><code>#include ""hide.h""

// static initializations
int hide::s_counter = 0;
float hide::s_choice = 0;
const int hide::s_height = _HEIGHT;
const int hide::s_width = _WIDTH;
//------------------------------------

// Constructor
hide::hide(float (*ptr)[_WIDTH]){
    m_array = ptr;
}

// Destructor........
hide::~hide(){
    // default
}

// overloaded (-) minus operator to perform the
// desired operation, this could be changed to
// any operator you feel better suited..
int hide::operator-(hide &amp;aHide){

    for(int i = 0; i&lt;s_height*s_width; ++i){
        if( (*m_array)[i] - aHide.index(i) &lt; s_choice ) {
            ++s_counter;
        }
    }
    return s_counter;

}

// static member functions
//----------------------------
// resets s_counter to 0
int hide::resetCounter(){
    s_counter = 0;
}

// sets choice to a specified value
float hide::setChoice(const float &amp;choice){
    s_choice = choice;
}

// returns s_counters current value
int hide::getCounter(){
    return s_counter;
}
//----------------------------

// access m_array like a 2d array
float hide::access(const int &amp;row, const int &amp;col){
        return (*m_array) [row*s_width+col];
}

// access m_array like a 1d array
float hide::index(const int &amp;i){
    return (*m_array) [i];
}
</code></pre>

<hr>

<p>[ORIGINAL ANSWER] You can resort to just one <em>for loop</em> with a pointer to an array of arrays;</p>

<pre><code>#include &lt;iostream&gt;

int main(){
    const unsigned height = 3, width = 3;

    float A[height][width] = {
        {1, 1, 1},
        {1, 1, 1},
        {1, 1, 1}
    };  
    float B[height][width] = {
        {0.1, 0.2, 0.3},
        {0.4, 0.5, 0.6},
        {0.7, 0.8, 0.9}
    };

    int counter = 0;
    float choice = 0.35;

    for(int i = 0; i &lt; height*width; ++i){
        if( (*A)[i] - (*B)[i] &lt; choice ) {
            ++counter;
        }
    }

    std::cout&lt;&lt; ""counter: "" &lt;&lt; counter; 
}
</code></pre>

<p>output;</p>

<pre><code>counter: 3
</code></pre>
",1
21327325,21326795,0,"<p>Yes. When it comes to arrays, vectors, matrices or stuff like this and you want to do the same operation (comparing, for example) on each (or on a subset) of the cells then loops are the weapon of choice.</p>

<p>It doesn't matter if you choose for- or while-loops (or other more uncommon constructs).</p>

<p>Sidenote: What matters though is readability. But fortunately, if you do it right, loops will support this. Personally I'm inclined to extract inner loops to separate functions. If the function name is chosen well, this helps a lot. Like Joachim Pileborg already stated, encapsulation is the key here.</p>
",0
34276228,34275845,2,"<p>I think you have a misconception of exactly how <code>std::istream</code>'s formatted input works.  In your example, <code>aCard</code> <em>must</em> be a <code>char</code>, because you've declared it as such.  If the use enters more than one character, one character will be put into <code>aCard</code>, and <code>std::cin</code> will hold onto the other characters and give them to you the next time you call <code>operator&gt;&gt;</code> (or any other input function); if the user enters a number, <code>aCard</code> will be the character representation of the first digit of that number.</p>

<p>Keep in mind that <code>operator&gt;&gt;</code> knows what type of variable you've given it, and it will ensure that the user's input is valid for that type.  If you give it an <code>int</code>, it will make sure the users input is convertible to an <code>int</code> or give you <code>0</code> if it isn't.  A variable can never be anything but the type you declared it to be.</p>

<p>If you're interested in <code>char</code>s in particular, there's a whole bunch of <a href=""http://en.cppreference.com/w/cpp/string/byte"" rel=""nofollow"">character classification functions</a> you can use to tell what sort of character (letter, digit, whitespace, etc.) you're working with, but keep in mind that <code>char foo('4')</code> is entirely different than <code>int foo(4)</code>.</p>
",2
34275958,34275845,0,"<p>If you want to force y or n as only allowed  characters you can do:</p>

<pre><code>char pickCard(){
    std::string response;
    std::cout &lt;&lt; ""Would you like another card?"";
    std::cin &gt;&gt; response;
    if (response==""y"" || response==""n""){

        return response[0]; //or anything useful 
    } else {
        std::cout &lt;&lt; ""Not a char!"";
         //... more code here
    }
         //... more code here
}
</code></pre>

<p>you can use length() property of std::string to find its length. a string of length one is a char in most cases. </p>
",5
34276573,34275845,0,"<p>I  guess you just want to know if the input string is in number format. <code>&gt;&gt;</code> will set the <code>istream</code>'s failbit if it cannot convert the input string to <code>int</code>. </p>

<pre><code>int num;

if (cin &gt;&gt; num) {       // input is ""123abc"", num == 123
  cout &lt;&lt;  ""yes, input is a number. At least start with some figures. ""
  cout &lt;&lt; ""num == "" &lt;&lt; num;
} else { // input is ""abc"" , error
  cout &lt;&lt; ""no, input is not a number or there is some kind of IO error."" 

} 
</code></pre>
",0
21159901,21159692,4,"<p>The maximum value you can store in n bits (when the lowest value is 0 and the values represented are a continuous range), is 2? ? 1.  For 8 bits, this gives 255. For 16 bits, this gives 65535.</p>

<p>Your mistake is thinking that you can just concatenate 255 with 255 to get the maximum value in two <code>char</code>s - this is definitely wrong. Instead, to get from the range of 8 bits, which is 256, to the range of 16 bits, you would do 256 ¡Á 256 = 65536. Since our first value is 0, the maximum value is 65535, once again.</p>

<p>Note that a <code>char</code> is only guaranteed to have <em>at least</em> 8 bits and a <code>short</code> at least 16 bits (and must be at least as large as a <code>char</code>).</p>
",6
21160017,21159692,2,"<p>When using decimal system it's true that range of one digit is 0-9 and range of two digits is 0-99. When using hexadecimal system the same thing applies, but you have to do the math in hexadecimal system. Range of one hexadecimal digit is 0-Fh, and range of two hexadecimal digits (one byte) is 0-FFh. Range of two bytes is 0-FFFFh, and this translates to 0-65535 in decimal system.</p>
",1
21160211,21159692,2,"<p>Decimal is a base-10 number system. This means that each successive digit from right-to-left represents an incremental power of 10. For example, <code>123</code> is <code>3 + (2*10) + (1*100)</code>. You may not think of it in these terms in day-to-day life, but that's how it works.</p>

<p>Now you take the same concept from decimal (base-10) to binary (base-2) and now each successive digit is a power of 2, rather than 10. So <code>1100</code> is <code>0 + (0*2) + (1*4) + (1*8)</code>. </p>

<p>Now let's take an 8-bit number (<code>char</code>); there are 8 digits in this number so the maximum value is <code>255</code> <code>(2**8 - 1)</code>, or another way, <code>11111111 == 1 + (1*2) + (1*4) + (1*8) + (1*16) + (1*32) + (1*64) + (1*128)</code>.</p>

<p>When there are another 8 bits available to make a 16-bit value, you just continue counting powers of 2; you don't just ""stick"" the two <code>255</code>s together to make <code>255255</code>. So the maximum value is <code>65535</code>, or another way, <code>1111111111111111 == 1 + (1*2) + (1*4) + (1*8) + (1*16) + (1*32) + (1*64) + (1*128) + (1*256) + (1*512) + (1*1024) + (1*2048) + (1*4096) + (1*8192) + (1*16384) + (1*32768)</code>.</p>
",0
21160619,21159692,1,"<p>It depends on the type: integral types must be stored as binary
(or at least, appear so to a C++ program), so you have one bit
per binary digit.  With very few exceptions, all of the bits are
significant (although this is not required, and there is at
least one machine where there are extra bits in an <code>int</code>).  On
a typical machine, <code>char</code> will be 8 bits, and if it isn't
signed, can store values in the range <code>[0,2^8)</code>; in other words,
between 0 and 255 inclusive.  <code>unsigned short</code> will be 16 bits
(range <code>[0,2^16)</code>), <code>unsigned int</code> 32 bits (range <code>[0,2^32)</code>)
and <code>unsigned long</code> either 32 or 64 bits. </p>

<p>For the signed values, you'll have to use at least one of the
bits for the sign, reducing the maximum positive value.  The
exact representation of negative values can vary, but in most
machines, it will be 2's complement, so the ranges will be
<code>signed char:</code>[-2^7,2^7-1)`, etc.</p>

<p>If you're not familiar with base two, I'd suggest you learn it
very quickly; it's fundamental to how all modern machines store
numbers.  You should find out about 2's complement as well: the
usual human representation is called sign plus magnitude, and is
very rare in computers.</p>
",0
21161233,21159692,2,"<p>You have got the math totally wrong. Here's how it really is</p>

<p>since each bit can only take on either of two states only(1 and 0) , n bits as a whole can represents 2^n different <strong><em>quantities</em></strong> not numbers. When dealing with integers a standard short integer size of 2 bytes can represent 2^n - 1 (n=16   so  65535)which are mapped to decimal numbers in real life for compuational simplicity. 
<br>
When dealing with 2 character they are two seperate entities (string is an array of characters). There are many ways to read the two characters on a whole, if you read is at as a string then it would be same as two seperate characters side by side. let me give you an example :<br>
remember i will be using hexadecimal notation for simplicity! <br>
if you have doubt mapping ASCII characters to hex take a look at this <a href=""http://asciitable.com"" rel=""nofollow noreferrer"">ascii to hex</a> 
<br></p>

<p>for simplicity let us assume the characters stored in two adjacent positions are both A.<br>
Now hex code for A is 0x41 so the memory would look like <br></p>

<p>1 byte  .......  2nd byte   <br>
01000100 01000001   <br></p>

<p>if you were to read this from the memory as a string and print it out then the output would be <br>
AA <br><br></p>

<p>if you were to read the whole 2 bytes as an integer then this would represent <br></p>

<p>0 * 2^15 + 1 * 2^14 + 0 * 2^13 + 0 * 2^12 + 0 * 2^11 + 1 * 2^10 + 0 * 2^9 + 0 * 2^8 + 0 * 2^7 + 1 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 <br></p>

<blockquote>
  <p>=  17537 <br></p>
</blockquote>

<p>if unsigned integers were used then the 2 bytes of data would me mapped to integers between 
0 and 65535 but if the same represented a signed value then then , though the range remains the same the biggest positive number that can be represented would be 32767. the values would lie between -32768 and 32767  this is because all of the 2 bytes cannot be used and the highest order bit is left to determine the sign. 1 represents negative and 2 represents positive. <br> <br> </p>

<p>You must also note that type conversion (two characters read as single integer) might not always give you the desired results , especially when you narrow the range. (example a doble precision float is converted to an integer.)</p>

<p><br><br>
For more on that see this answer <a href=""https://stackoverflow.com/questions/2377733/how-does-this-program-work"">double to int</a>
<br>
hope this helps.</p>
",0
22132274,22132247,1,"<p>27 * 27 = 729. So your first vector has got the same number of lines as the second file does. Why? Because you're reading from <code>kdfile</code> when you meant to read from <code>wdfile</code>.</p>

<pre><code>while (std::getline(kdfile, line))
                    ^^^^^^
</code></pre>

<p>That means you're reading everything out of the pairwise distance file and then the second loop has nothing left to extract.</p>
",1
21033467,21033450,4,"<p>You haven't initialized <code>thesum</code> variable. Initialize it to <code>0</code>.  </p>

<pre><code>int i = 1, thesum = 0;   
</code></pre>

<p>Otherwise it will invoke <strong>undefined behavior</strong>.</p>
",1
21033573,21033450,2,"<p>As it was already pointed out you did not initialize local variable thesum. So it has some arbitrary value.
Also there is no any need to include header <code>&lt;cstdlib&gt;</code> because no one declaration from it is used.
As variable i is not used outside the loop it is better to make it a local variable of the loop.</p>

<p>So I would rewrite the program the following way</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
   const int N = 5;
   int theSum = 0;

   for ( int i = 0; i &lt; N; i++ ) theSum += i + 1;

   cout &lt;&lt; ""The sum of first "" &lt;&lt; N &lt;&lt; "" natural numbers is "" &lt;&lt; theSum &lt;&lt; endl;    

   return 0;
}
</code></pre>
",6
24572317,24569686,1,"<p>You probably saw a signed/unsigned mismatch warning on this line when you compiled:</p>

<pre><code>if (pos &gt;= arr.size())
</code></pre>

<p>What that warning is telling you is that one of the values in the expression, in this case arr.size() is unsigned and the other, pos is signed.  This means that in order to compare them, pos will be converted to an unsigned value first.  That means that instead of -1 it will be a very large value, certainly larger than the number of lines in the menu, the comparison will be true and pos will be set to 0.</p>

<p>The smallest change to fix that would be to change the line to this:</p>

<pre><code>if(pos &gt;= static_cast&lt;int&gt;(arr.size()))
</code></pre>

<p>This forces arr.size() to be the same type as pos so the values can be compared directly and solves your problem.  It also gets rid of the warning.</p>

<p>You should see some other warnings as well, another signed/unsigned mismatch in the for loop that displays the menu and a conversion from int to char warning for _getch() since it returns an int and you are storing it in a char.  Neither should cause a problem in this program, but you should always check and correct them to avoid issues.</p>

<p>Another potential issue is that discarding the extended key value, 0 or 0xE0 means you have no way to tell if the key is really an arrow key or the actual key with the ASCII value you are checking for.  As an example, typing H would also return 72 from _getch().</p>

<p>I won't try and talk you out of goto, but in my opinion you should avoid it.</p>
",0
21155725,21155681,4,"<p>The problem is when you try to output <code>(*i).second</code>. As <code>i</code> is of type <code>map&lt;string, list&lt;int&gt; &gt;::iterator</code> <code>(*i).second</code> is a <code>list&lt;int&gt;</code> and <code>c++</code> does not know how to output it. </p>

<p>You have two options - either overload <code>ostream&amp; operator&lt;&lt;(ostream&amp; out, const list&lt;int&gt;&amp; l)</code> or use an inner cycle to output the elements one by one. I personally recommend the second option as overloading the operator for such ""popular"" type may be dangerous. </p>
",6
21157071,21155681,1,"<p>The simplest solution:</p>

<pre><code>// !!! DO NOT DO THIS AT HOME OR AT ALL !!!
namespace std {
    template &lt;typename T, typename A&gt;
    ostream&amp; operator&lt;&lt;(ostream&amp; out, list&lt;T, A&gt; const&amp; l) {
        if (l.empty()) { return out &lt;&lt; ""[]""; }

        out &lt;&lt; '[';

        bool first = true;
        for (auto const&amp; t: l) {
            if (first) { first = false; } else { out &lt;&lt; "", ""; }
            out &lt;&lt; t;
        }

        return out &lt;&lt; ']';
    } // operator&lt;&lt;
} // namespace std
</code></pre>

<p>Unfortunately... it is strictly forbidden to do so (you are only allowed to specialize existing templates in the <code>std</code> namespace, not add any overload).</p>

<p>Therefore, the best standard compliant solution is to:</p>

<ol>
<li>Declare a new stream of your own (which forwards everything to a <code>std::ostream&amp;</code>)</li>
<li>Overload this operator for your new stream (in its namespace)</li>
<li>Only ever use this new stream afterward</li>
</ol>

<p>Feel free to bitch at the clumsiness...</p>

<p>Example of custom stream <a href=""http://ideone.com/mnB26y"" rel=""nofollow"">to get you started</a>:</p>

<pre><code>namespace project {
    class OStream {
    public:
        explicit OStream(std::ostream&amp; out): _out(out) {}

        template &lt;typename T&gt;
        OStream&amp; operator&lt;&lt;(T const&amp; t) { print(*this, t); return *this; }

        template &lt;typename T&gt;
        void push(T const&amp; t) { _out &lt;&lt; t; }

    private:
        std::ostream&amp; _out;
    }; // class OStream

    // Generic Operator (directly forwards to `std::ostream`)
    template &lt;typename T&gt;
    void print(OStream&amp; out, T const&amp; t) { out.push(t); }

    // STL Containers
    template &lt;typename It&gt;
    void print_range(OStream&amp; out, It begin, It end) {
        if (begin == end) { out &lt;&lt; ""[]""; return; }

        out &lt;&lt; '[' &lt;&lt; *begin;

        for (++begin; begin != end; ++begin) { out &lt;&lt; "", "" &lt;&lt; *begin; }

        out &lt;&lt; ']';
    } // push_range

    template &lt;typename T, typename A&gt;
    void print(OStream&amp; out, std::list&lt;T, A&gt; const&amp; l) {
        print_range(out, l.begin(), l.end());
    } // operator&lt;&lt;
} // namespace project

// usage
int main() {
    std::list&lt;int&gt; example = { 1, 2, 3, 4 };
    project::OStream(std::cout) &lt;&lt; example &lt;&lt; ""\n"";
}
</code></pre>

<p><em>Note: there are other solutions than creating a custom stream, such as copy pasting <code>std::copy(example.begin(), example.end(), std::ostream_iterator&lt;int&gt;(std::cout, "", ""));</code> everywhere you need to print a list, but I am yet to meet another handy one.</em></p>
",0
26803634,26803124,12,"<p>You should see table about special class members. When you set copy constructor as a deleted one move constructor won't be generated automatically.</p>

<p>See more in table:</p>

<p><a href=""https://i.stack.imgur.com/Jgurl.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/Jgurl.jpg"" alt=""enter image description here""></a></p>

<p><a href=""https://accu.org/content/conf2014/Howard_Hinnant_Accu_2014.pdf"" rel=""noreferrer"">Source (slides)</a>.</p>
",0
31303758,31303715,2,"<p>Since <code>a</code> and <code>b</code> are not objects but primitive datatypes, there is no constructor to call.  In contrast, <code>c</code> is an object, so its default constructor is called.</p>
",13
31303780,31303715,7,"<p><code>a</code> and <code>b</code> have non-class types, meaning that they have no constructors at all. Otherwise, your description is correct: <code>my_object.a</code> and <code>my_object.b</code> will have indeterminate values, while <code>my_object.c</code> will be properly constructed.</p>

<p>As for why... by writing a user-defined constructor and not mentioning <code>a</code> and <code>b</code> in the initializer list (and not using C++11 in-class member initializers) you explicitly asked the compiler to leave these members uninitialized.</p>

<p>Note that if your class did not have a user-defined constructor, you'd be able to control the initial values of <code>my_object.a</code> and <code>my_object.b</code> from outside, by specifying initializers at the point of object declaration</p>

<pre><code>my_class my_object1;
// Garbage in `my_object1.a` and `my_object1.b`

my_class my_object2{};
// Zero in `my_object2.a` and null pointer in `my_object2.b`
</code></pre>

<p>But when you wrote your own default constructor, you effectively told the compiler that you want to ""override"" this initialization behavior and do everything yourself.</p>
",10
21306585,21306529,0,"<p>If it is a text file, you can easily read the ""words"" from the file and then determine if they are numbers or not using <code>atoi</code>, <code>atol</code>, <code>atoll</code>, <code>atoq</code>. And when you got an answer (ie: this is a number, or not), just increment a variable :)</p>
",1
21306637,21306529,0,"<pre><code>std::string word;
while (std::cin &gt;&gt; word)
{
    std::istringstream iss(word);
    int my_int;
    char garbage;
    num_ints += (iss &gt;&gt; my_int) &amp;&amp; !(iss &gt;&gt; garbage);
    ++num_words;
}
num_strings = num_words - num_ints;
</code></pre>
",1
21306727,21306529,0,"<p>Parse through each item. For each item compare the ascii values of the characters in it.If it is between 48 and 57(inclusive) , it is an int. Otherwise it is a string.</p>
",1
21323775,21323696,4,"<p><code>x = num % i;</code></p>

<p>Computes the remaining of dividing <code>num</code> by <code>i</code></p>

<p>But <code>i = 0</code> in the first step, and you cannot devide by zero.</p>
",7
23852886,23852774,1,"<p>Probably the problem is occurring because you are revisiting already visited node.</p>

<p>Consider you are at the extra dot you are considering at beginning of function. Now on your west side you might have missed checking if it is a start point, and considering start point as not outside maze and available path. So now the program again starts checking from start and thus giving false positive result.</p>

<p>Without actual code its hard to debug though.</p>

<p><strong>EDIT:</strong> It suffers from exact problem is was talking about above</p>

<p>Do you know where start point is. If so do following</p>

<p>Replace </p>

<pre><code>if (ch =='.' || ch == '#')
         return false;
</code></pre>

<p>with</p>

<pre><code>if (ch =='.' || ch == '#' || ch=='s')
         return false;
</code></pre>
",5
23581321,23581272,0,"<p>The first character is at index 0. But you never call <code>substr</code> when <code>i</code> is 0, so you can never get that character.</p>
",0
23581337,23581272,0,"<pre><code>#include &lt;string&gt;
 #include &lt;iostream&gt;
 using namespace std;

 int main() {

  string a = ""123456789ab"";

  int b = a.length();

  string pos;
  int i;
  for (i = b - 3; i &gt; 0; i-=3) {
    if (i &gt; 0) {
      pos = "","" + a.substr(i,3) + pos;
    }
  }
  cout &lt;&lt; a.substr(0,i+3)+pos;
  return 0;
 }
</code></pre>

<p>When the index is negative, it means that it can't make any more group of 3. But there may be 1-3 numbers which may be left. We need to explicitly add them</p>
",1
25670095,25669715,1,"<p>The problem is that you're using unformatted input directly after a formatted extraction. By default, formatted extractors do not ignore or discard the residual newline that appears after the user submits input. You need to clear tha newline manually using <code>std::ws</code>.</p>

<p>Moreover, using <code>!eof()</code> has a condition for input is always wrong. It is wrong beause you are checking the state of the stream before performing input which can cause problems if you use the result of a failed extraction.</p>

<p>Use the input operation itself as a condition. It will perform the read and <em>then</em> check the state of the stream, returning true or false if the stream encountered errors.</p>

<pre><code>while (std::getline(fi &gt;&gt; newline &gt;&gt; std::ws, streamline))
{
    std::cout &lt;&lt; streamline;
}
</code></pre>
",0
21320319,21320032,1,"<p>If you're planning to change it during runtime, then you can use any of the following options:</p>

<pre><code>       char result[] = ""invalid""; // 8 bytes in the stack
static char result[] = ""invalid""; // 8 bytes in the data-section
</code></pre>

<p>If you're not planning to change it during runtime, then you can use any of the following options:</p>

<pre><code>       const char  result[] = ""invalid""; // 8 bytes in the stack
static const char  result[] = ""invalid""; // 8 bytes in the data-section
       const char* result   = ""invalid""; // 8 bytes in the code-section, and a pointer (4 or 8 bytes) in the stack
static const char* result   = ""invalid""; // 8 bytes in the code-section, and a pointer (4 or 8 bytes) in the data-section
</code></pre>

<p>If you want to initialize it only at a later point during runtime:</p>

<pre><code>       char result[] = ""invalid""; // 8 bytes in the stack
static char result[] = ""invalid""; // 8 bytes in the data-section
...
strcpy(result,""MMM"");
// But make sure that the second argument is not larger than the first argument:
// In the case above, the size of ""MMM"" is 4 bytes and the size of 'result' is 8 bytes
</code></pre>
",4
21320046,21320032,8,"<p>You need to <em>initialize</em> the array:</p>

<pre><code>char result[] = ""invalid"";
</code></pre>

<p>This creates a size 8 array of <code>char</code>.</p>

<p>But you may be better off using an <code>std::string</code>:</p>

<pre><code>std::string result(""invalid"");
</code></pre>
",5
27166256,27166184,2,"<p>For integer values larger than 0, you can use this:</p>

<pre><code>void Print(int val)
{
    if (val &gt; 0)
    {
        Print(val/10);
        cout &lt;&lt; val%10 &lt;&lt; endl;
    }
}
</code></pre>
",2
27166727,27166184,0,"<p>Try</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char * argv[]) 
{

int value = 23487;

while(value &gt; 0)
{
    int d = value % 10;

    value /= 10;

    printf(""d = %d\n"", d);
}

return 0;
}
</code></pre>

<p>Note that the digits will be printed backwards.</p>
",7
27167542,27166184,0,"<p>Try this... This code will print as exactly you want... :)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
   int a=23487,ara[10],i=0,j;
    while(a)
    {
        ara[i++]=a%10;
        a/=10;
    }
    for(j=i-1;j&gt;=0;j--)
    cout&lt;&lt;ara[j]&lt;&lt;endl;
    return 0;
}
</code></pre>
",0
30398296,30398251,7,"<blockquote>
  <p>Is it function overloading?</p>
</blockquote>

<p>Yes. The two functions have the same name but different parameters, so they are overloads.</p>

<blockquote>
  <p>Why function without <code>const</code> will be called it my case?</p>
</blockquote>

<p>Because <code>x</code> is not <code>const</code>. Try with a pointer to a <code>const int</code>, and you'll get the other overload:</p>

<pre><code>const int y;
A(&amp;y);
</code></pre>
",0
29218355,28523892,6,"<p>From the <a href=""http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20130930/090167.html"" rel=""nofollow"">patch that fixed this in earlier versions</a>:</p>

<blockquote>
  <p>MinGW uses the Microsoft runtime DLL msvcrt.dll. Here lies a problem: while gcc creates 80 bits long doubles, the MS runtime accepts 64 bit long doubles only.</p>
</blockquote>

<p>This bug happens to me when I use 4.8.1 revision 4 from MinGW-get (the most recent version it offers), but not when I use 4.8.1 revision 5.</p>

<p>So you are not using long double wrong (although there would be better accuracy to do <code>long double lValue = 123.456789L</code> to make sure it doesn't take 123.456789 as a double, then cast it to a long double).</p>

<p>The easiest way to fix this would be to simply change the version of MinGW you are using to 4.9 or 4.7, depending on what you need (you can get 4.9 <a href=""http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/4.9.1/"" rel=""nofollow"">here</a>).</p>

<p>If you are willing to instead use printf, you could change to <code>printf(""%Lf"", ...)</code>, and either:</p>

<ul>
<li>add the flag -posix when you compile with g++</li>
<li>add <code>#define __USE_MINGW_ANSI_STDIO 1</code> before <code>#include &lt;cstdio&gt;</code> (found this from the <a href=""http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20130930/090167.html"" rel=""nofollow"">origional patch</a>)</li>
</ul>

<p>Finally, you can even just cast to a <code>double</code> whenever you try to print out the <code>long double</code> (there is some loss of accuracy, but it shouldn't matter when just printing out numbers).</p>

<p>To find more details, you can also look at <a href=""http://www.diusrex.com/2015/05/long-double-bug-in-mingw/"" rel=""nofollow"">my blog post on this issue</a>.</p>

<p>Update: If you want to continue to use Mingw 4.8, you can also just <a href=""http://sourceforge.net/projects/mingwbuilds/"" rel=""nofollow"">download</a> a different distribution of Mignw, which didn't have that problem for me.</p>
",0
22503394,22503283,1,"<p>u have too much repeated code, u can make a method that takes an extension and return the folder it is supposed to be in, then store this file in the returned folder</p>
",1
22503596,22503283,4,"<p>Try something like this:  (I didn't compile it so it may have some errors)</p>

<pre><code>std::map&lt;std::string,int&gt; extMap;

// put your extensions here...
extMap.insert( std::pair&lt;std::string,int&gt;("".txt"", 0) );
extMap.insert( std::pair&lt;std::string,int&gt;("".doc"", 0) );

extMap.insert( std::pair&lt;std::string,int&gt;("".mp3"", 1) );
...

// find an extension and its index
std::map&lt;std::string,int&gt;::iterator it2 = extMap.find( it-&gt;path().extension() );

if( it2 != extMap.end() ) {
    int index = it2-&gt;second;

    f[index].filePath = ...
}
</code></pre>
",2
22503704,22503283,0,"<p>I've had to use <code>auto</code> as I've got no idea what your types are. There's also no error checking (i.e. if an extension isn't matched).</p>

<pre><code>auto path = it-&gt;path();
auto extension = path.extension();

int index = -1;
auto queryFolder = """";

    if (extension == "".txt"" || extension == "".doc"" || extension == "".docx"" || extension == "".pdf"") 
    {   
        index = 0;
        queryFolder = ""Documents"";
    }
    else if (extension == "".mp3"" || extension == "".wma"") 
    {      
        index = 1;
        queryFolder = ""Music"";
    }
    else if (extension == "".mp4"") 
    {          
        index = 2;
        queryFolder = ""Videos"";
    }
    else if (extension == "".jpg"" || extension == "".jpeg"" || extension == "".gif"") 
    {          
        index = 3;
        queryFolder = ""Pictures"";        
    }
    else 
    {     
        index = 4;
        queryFolder = ""Others"";
    }

    f[index].filePath = path;
    f[index].fileName = path.filename();
    f[index].fileExt = extension;     

    auto query = ""Insert into Filemanager(Filepath,Filename,Category)values('"" + f[index].filePath.string() + ""','"" + f[index].fileName.string() + ""','"";
    query += queryFolder;
    query += ""')"";
</code></pre>
",0
22504064,22503283,1,"<p>This is not related to avoid the if-then conditions, but given that your are going to rework your code...</p>

<p>not knowing if you're working in a ""secure environment"", I would use <a href=""https://stackoverflow.com/questions/301008/what-is-a-query-parameter-in-c"">parameterized queries</a> rather than constructing the query in a string. These are much better for handling <a href=""http://en.wikipedia.org/wiki/SQL_injection"" rel=""nofollow noreferrer"">SQL Injection Attacks</a>.</p>

<p>SQL injection is being one of the mostly exploited issues in application security and has found a place in OWASP Top 10 since 2004. There are many blog posts, papers available on SELECT query injection exploiting WHERE or HAVING clauses but there are also <a href=""http://amolnaik4.blogspot.it/2012/02/sql-injection-in-insert-query.html"" rel=""nofollow noreferrer"">SQL injection in INSERT query</a>.</p>
",0
21597048,21597019,3,"<p>It's not possible, but you can set it to some initial value that indicates that it needs to be initialized again.</p>
",1
21597060,21597019,7,"<p>There is no way of knowing if a local non-static variable is initialized or not. However, global variables, as well as local <code>static</code> variable are always initialized (global and static local variables that are not explicitly initialized are zero-initialized by the compiler run-time system).</p>

<p>To not have to worry about it, always initialize local variables.</p>

<p>You might want to read about <a href=""http://en.cppreference.com/w/cpp/thread/once_flag"" rel=""nofollow""><code>std::once_flag</code></a> and <a href=""http://en.cppreference.com/w/cpp/thread/call_once"" rel=""nofollow""><code>std::call_once</code></a>.</p>
",0
21597194,21597019,3,"<p>Generally you cannot and its is a bad practice to use uninitialized variables. </p>

<p>You may use something like this:</p>

<pre><code>int x = -1;
....
rest of your code
....
if( x == -1 )
{
}
</code></pre>

<p>in the above example it is assumed that under program execution <code>x</code> will never be set to <code>-1</code>. If it is -1 then it is uninitialized.</p>
",0
21597315,21597019,1,"<p>Global/static zero-fill not withstanding, the simple answer is this: </p>

<p><strong>You detect ""uninitialized"" variables when you're <em>writing</em> the code; not <em>running</em> it.</strong> </p>

<p>You at least appear to be trying to ""detect"" an <em>indeterminate value</em> condition. Assuming local variables in function or loop-scope:</p>

<pre><code>int a;
int b = a;
</code></pre>

<p>That simple little snippet is not defined behavior. Ask yourself what is <code>b</code> after this code executes? You think its whatever <code>a</code> is? Well then what is <code>a</code>? Don't know? Neither does anyone else, and that is the point. Its indeterminate, and if <code>a</code> is indeterminate, so then must be <code>b</code>.</p>

<p>An even simpler example:</p>

<pre><code>int *p;

if (p) { do-something }
</code></pre>

<p>So.. does <code>do-something</code> execute? Are you <em>sure</em> about that ?</p>

<p>You avoid this by <em>always</em> initializing your variables <em>before</em> they're ever evaluated. A decent compiler, appropriately configured, will warn you if your code <em>may</em> evaluate something without it being set, but you can avoid it yourself by taking the steps to see it doesn't happen in the first place. Always initialize your variables. If they're objects in C++ they can self-initialize, but for types that have no default construction, you need to take the matter in to your own hands. In the process you never encounter this problem and your code will be further down the path to being well-formed.</p>
",0
21600009,21597019,0,"<p>It's not directly possible.</p>

<p>You may initialize it with a unique '<em>invalid</em>' value (so it is <em>initialized</em>).</p>

<p><code>-1</code> for a <code>int</code> which should contain positive value.
<code>nullptr</code>(or <code>NULL</code>) for a pointer which should contain data.</p>

<p>An other method is to use additional data to keep track of uninitialized value.</p>

<pre><code>class A
{
public:
    A() : hasBeenSet(false) {}

    bool isInitialized() const { return hasBeenSet; }
    void set(int value) { hasBeenSet = true; myInt = value; }
    int get() const
    {
        if (!isInitialized()) {
            throw std::runtime_error(""Not initialized"");
        }
        return myInt;
    }
private:
    bool hasBeenSet;
    int myInt;
};
</code></pre>
",0
21590750,21590492,0,"<p>The default behaviour of <code>cout</code> is to print six significant digits of floating points. You can change that with:</p>

<pre><code>cout.precision(10);
cout &lt;&lt; alt &lt;&lt; endl;
</code></pre>

<p>which gives the output:</p>

<pre><code>12019.2925
</code></pre>

<p>which seems to be the correct solution.</p>

<p>You should not try to set the precision to anything higher than roughly 15, because that is about the precision limit of the double type (typically). You can use the <code>numeric_limits&lt;double&gt;::digits10</code> from <code>&lt;limits&gt;</code> to make sure what precision you actually have.</p>
",1
22493192,22492137,0,"<p><code>send</code> does not guarantee that all bytes will be sent. Its return value tells you how much was sent out of what you requested (and I can pretty much guarantee that it won't be all 65KB!). You should keep going until all your outgoing buffer is sent.</p>

<p>Read the documentation for functions that you use.</p>
",2
26446770,26446662,4,"<p>On this line:</p>

<pre><code>f=a*b*c*d*e*h*j*k*l*m*n*o*p;
</code></pre>

<p>all of the right hand side are ints, so you get integer overflow. You need to do the multiplication in long long precision, e.g.:</p>

<pre><code>f= 1ULL * a*b*c*d*e*h*j*k*l*m*n*o*p;
</code></pre>

<p>Also (now that you have changed to using unsigned long long) you also need to update the format string for printing the result:</p>

<pre><code>printf(""%llu\n"", max);
</code></pre>
",2
21717060,21716963,2,"<p>When you use the <code>&gt;&gt;</code> stream operator to read into a value, it uses whitespace delimiters by default.  So, your newlines and spaces will be automatically eaten up.  All you need to do is read values one by one until there are none left.</p>

<p>Because you want the values output in the same format, and they appear to be <code>double</code> or <code>float</code> types, you should really read into a <code>std::string</code>.  Otherwise translation issues and rounding errors can creep in.</p>

<pre><code>std::ifstream infile( ""values.txt"" );
std::string val;

while( infile &gt;&gt; val ) cout &lt;&lt; val &lt;&lt; std::endl;
</code></pre>
",0
22496252,22496148,1,"<p>The following two methods are not defined:</p>

<pre><code>virtual void setLeft(BinNode*) = 0;//set the node's left child's element;
virtual void setRight(BinNode*) = 0;//set the node's right child's element;
</code></pre>

<p>Because the defined methods in <code>BinNodePtr</code> have different parameters:</p>

<pre><code>void setLeft(const Elem&amp; e){lc-&gt;ele = e;}
void setRight(const Elem&amp; e){rc-&gt;ele = e;}
</code></pre>
",0
22496254,22496148,2,"<p>In abstract class.</p>

<pre><code>virtual void setLeft(**BinNode***) = 0;//set the node's left child's element;
virtual void setRight(**BinNode***) = 0;//set the node's right child's element;
</code></pre>

<p>and in derived class</p>

<pre><code>void setLeft(const **Elem**&amp; e){lc-&gt;ele = e;}
void setRight(const **Elem**&amp; e){rc-&gt;ele = e;}
</code></pre>

<p>Function signature doesn't match..</p>
",1
22496434,22496148,0,"<p>Because you don't implement these pure virtual functions</p>

<pre><code>virtual void setLeft(BinNode*) = 0;//set the node's left child's element;
virtual void setRight(BinNode*) = 0;//set the node's right child's element;
</code></pre>

<p>So the class <code>BinNodePtr</code> is an abstract class.
And there is an import rule: you can instantiate an abstract class, that say you can't create an class object using abstract class.</p>

<p>you can read this <a href=""http://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/"" rel=""nofollow"">article</a>:</p>
",0
22522125,22522047,1,"<p>When you use <code>cin &gt;&gt; help</code>, you're only reading one character, the <code>y</code> or <code>n</code>. The newline after that is left in the input buffer.</p>

<p>Then when the main function uses <code>getline</code>, it reads up to the next newline, which is the one that was left in the buffer by <code>provideHelpIfNecessary</code>. So it just reads a zero-length line, and that causes the <code>while</code> loop to <code>break</code>.</p>

<p>Use <code>getline</code> in <code>provideHelpIfNecessary</code> instad of reading just one character.</p>
",2
34183450,34183401,2,"<p>Match the return type to what you want to return.</p>

<p>Try this: <code>list&lt;pair&lt;double, int&gt;&gt;::iterator begin() { return l.begin(); }</code></p>

<p><strong>UPDATE:</strong> the compiler told me that you have to create <code>end()</code> function as a member of <code>class cEvents</code>. It should be like this:</p>

<pre><code>list&lt;pair&lt;double, int&gt;&gt;::iterator end() { return l.end(); }
</code></pre>
",2
34183464,34183401,4,"<p>You need to use the iterator of the container as the return type.</p>

<pre><code>iterator begin() { return l.begin(); }
</code></pre>

<p>Should be</p>

<pre><code>list&lt;pair&lt;double, int&gt;&gt;::iterator begin() { return l.begin(); }
</code></pre>

<p>Or in C++14</p>

<pre><code>auto begin() { return l.begin(); }
</code></pre>
",1
34183530,34183401,1,"<p>You've defined <code>begin()</code> to return some type named <code>iterator</code>, but you haven't defined what type that actually is.</p>

<p>The only type the compiler can find by that name is <code>std::iterator</code>, which is a class template, so you can't use it without a template parameter list (and it's probably not what you want in this case anyway).</p>

<p>In this case, it looks to me like you probably want your <code>begin()</code> (and <code>end()</code>) to return iterators into the <code>list&lt;pair&lt;double, int&gt;&gt;</code> that the object contains, so you'd do something like:</p>

<pre><code>typedef list&lt;pair&lt;double, int&gt;&gt;::iterator iterator;
</code></pre>

<p>...or, better still:</p>

<pre><code>typedef decltype(l)::iterator iterator;
</code></pre>

<p>...or equivalently (but more readably, at least in some people's view):</p>

<pre><code>using iterator = decltype(l)::iterator;
</code></pre>

<p>Then, since you've defined what <code>iterator</code> means, you can use the name as the return type of your function (or as a parameter, etc.) Given that you apparently have something that acts/works like a collection anyway, you'd probably be better off defining the other ""standard"" types for a collection as well (e.g., <code>typedef std::pair&lt;double, int&gt; value_type;</code> as well.</p>

<p>I would advise <em>against</em> directly specifying <code>std::list&lt;std::pair&lt;double, int&gt;&gt;::iterator</code> as the return type. This does work, but it contains substantial redundancy. You always want that return type to be the same as the iterator type for the collection, so if you change your mind and use some other collection instead of <code>list</code>, the return type of the function needs to change to match. Using <code>decltype(l)::iterator</code> makes that automatic, where using <code>std::list&lt;std::pair&lt;double, int&gt;&gt;::iterator</code> requires that you do manual editing to keep the types in sync.</p>

<p>I should probably add that in this particular case, I think making it easy to change to a different type as easily as possible is more important than usual. Specifically, using <code>std::list</code> is a mistake <em>much</em> more often than not, so unless this is throwaway code, chances of wanting to change to a different container are quite high.</p>
",1
22510547,22510331,0,"<p>You have to specify the default include directories for your compiler correctly or place the <code>colours.h</code> file in the same directory as your other files.</p>
",0
22510555,22510331,1,"<p><code>colours.h</code> isn't a standard include file, so the problem is that it isn't available on the other machine. You need to install the software that provides it (or copy it there if it is a file you have created yourself).</p>
",0
24088051,24087977,2,"<p>You're just missing some () on your function calls:</p>

<pre><code>void Deck::shuffle()
{
    std::forward_list&lt;Card*&gt; help;
    help.swap(m_deck);

    while (!help.empty())
    {
        if (rand() % 2 == 0)
        {
            m_deck.emplace_front(help.front());
            help.pop_front(); //###line 65###
        }
        else
        {
            m_deck.emplace_after(m_deck.end(), help.front()); //###line 69###
            help.pop_front(); //###line 70###
        }
    }
}

Card* Deck::takeFront()
{
    Card* help = m_deck.front();
    m_deck.pop_front(); //###line 78###
    return help;
}

void Deck::placeBack(Card* card)
{
    m_deck.emplace_after(m_deck.end(), card); //###line 84###
}
</code></pre>
",0
22131213,22131193,3,"<p>The definition of <code>moveBoat</code> needs to be in the <code>FerryBoat</code> scope, otherwise it is a non-member function, with no access to <code>FerryBoat</code>'s members:</p>

<pre><code>void FerryBoat::moveBoat(int nextStop)
{
   ....
}
</code></pre>
",0
32949225,32949186,4,"<p>References are bound to an object <em>once</em> and can never be reseated. There is simply no syntax for that. As you've seen with your use of e.g. <code>s.push_back</code>, whenever you name <code>s</code> you are accessing the <em>referent</em> <code>r</code> (which, by extension, is actually <code>x</code>).</p>

<p>So, <code>s=y</code> does not make the reference refer to the other vector. What you're doing here is the same as <code>x=y</code>. All the elements originally in <code>x</code> are lost.</p>

<p>Reference semantics in Java bear approximately zero relation to reference semantics in C++. You'd do well to immediately cease trying to compare the two, or to ""transition"" from one to the other. Come to C++ with a clean, fresh mind.</p>
",3
32949269,32949186,6,"<p>Important point: <em>references are non-reseatable.</em> Once you initialise a reference, it will <em>always</em> refer to the same object.</p>

<p>Now let's analyse your code step by step:</p>

<pre><code>std::vector&lt;int&gt; x;
x.push_back(1);
</code></pre>

<p><code>x</code> is a vector which contains <code>1</code>.</p>

<pre><code>std::vector&lt;int&gt; y;
y.push_back(2);
</code></pre>

<p><code>y</code> is a vector which contains <code>2</code>.</p>

<pre><code>std::vector&lt;int&gt;&amp; r=x;
r.push_back(3);
</code></pre>

<p><code>r</code> is a reference to <code>x</code>, which now contains <code>1 3</code>.</p>

<pre><code>std::vector&lt;int&gt;&amp; s=r;
s.push_back(4);
</code></pre>

<p><code>s</code> is a reference to <code>x</code>, which now contains <code>1 3 4</code>.</p>

<pre><code>s=y;
</code></pre>

<p>Now, you've copied the vector <code>y</code> to the vector <code>x</code> (through reference <code>s</code> which refers to it). That replaces the contents of <code>x</code> with the contents of <code>y</code>, which is <code>2</code>.</p>

<pre><code>r.push_back(5);
s.push_back(6);
</code></pre>

<p><code>x</code> (to which both <code>r</code> and <code>s</code> refer) now contains <code>2 5 6</code>.</p>

<p><code>y</code> was never modified after the single <code>push_back</code> after its creation, and so it contains just <code>2</code>.</p>

<hr>

<p>The concept which Java calls ""references"" is actually what ""pointers"" are in C++. With pointers, the code would have looked like this:</p>

<pre><code>std::vector&lt;int&gt;* r = &amp;x;
r-&gt;push_back(3);

std::vector&lt;int&gt;* s = r;
s-&gt;push_back(4);

s = &amp;y;

r-&gt;push_back(5);
s-&gt;push_back(6);
</code></pre>

<p>Then, <code>x</code> would contain <code>1 3 4 5</code>, and <code>y</code> would contain <code>2 6</code>.</p>

<p>Notice that the syntax for creating a pointer to an object (taking the object's address) requires explicit use of the address-of operator <code>&amp;</code>. Likewise, dereferencing a pointer requires explicit syntax: <code>*p</code> for simply obtaining the object pointed to, or <code>p-&gt;m</code> for accessing the member <code>m</code> of the object pointed to by <code>p</code>.</p>
",0
32949295,32949186,2,"<p>Assignment <code>s=y;</code> where <code>s</code> refers to <code>x</code>, results in copying <code>y</code> to <code>x</code> which overwrites (1,3,4). So <code>x</code> becomes (2) and then is appended 5 and 6. Meanwhile <code>y</code> remains untouched and is finally (2).</p>
",0
28246363,28246341,4,"<p>The proper way to go is:</p>

<pre><code>char c = 'p';
</code></pre>
",0
28246399,28246341,1,"<p>Try with <code>char c = 'x';</code>. What you are trying is defining a string (char array) and assigning to char variable.</p>
",0
22129881,22129854,5,"<p>Two things, if <code>maxVal</code> is double, you cannot assign value of <code>&amp;max</code>. It should be <code>double *</code>.<br>
 Secondly, never return address of local variable. Because once you return from function, local variable die.</p>
",5
22134466,22134279,1,"<pre><code> istream&amp; get(char&amp; ch);
</code></pre>

<p>That line will declare a function.  You need to <strong>call</strong> a function:</p>

<pre><code>while (ins.get(ch) &amp;&amp; ch != '\n')
{
    target += ch;
}
</code></pre>
",1
22134689,22134579,3,"<p>You forgot to return your search results in your else and else if block.
For example replace</p>

<pre><code>search(s, left, mid-1, x);
</code></pre>

<p>with </p>

<pre><code>return search(s, left, mid-1, x);
</code></pre>
",0
22420964,22420767,3,"<p>You've hit upon the answer: you need to tell the compiler to build code for the correct platform. You can do that by selecting 'TDM-GCC 4.8.1 32-bit Release' from that list and recompiling your application.</p>

<p>The three options given for 32-bit and 64-bit (Release, Debug and Profiling), should be used in different circumstances:</p>

<ul>
<li><strong>Debug</strong>: should be selected when you're working on your code and want to use a <a href=""http://en.wikipedia.org/wiki/Debugger"" rel=""nofollow"">debugger</a>. The compiler will add 'debug symbols', to the executable that a debugger (such as <a href=""http://en.wikipedia.org/wiki/GNU_Debugger"" rel=""nofollow"">GDB</a>), can identify and use to give you meaningful error messages.</li>
<li><strong>Release</strong>: builds an application suitable for you to send to your customers, or your friend.</li>
<li><strong>Profiling</strong>: builds an application suitable for use with a <a href=""http://en.wikipedia.org/wiki/Profiling_%28computer_programming%29"" rel=""nofollow"">profiler</a>.</li>
</ul>

<p>I hope that makes things clear for you.</p>
",0
27509410,27509366,18,"<p>C++11 ¡ì3.6.1/2:</p>

<blockquote>
  <p><strong>&rdquo;</strong> This function shall not be overloaded.</p>
</blockquote>
",0
22889596,22889547,1,"<p>There are much better methods than that. This subtractive method is arbitrarily slow for large dividends and small divisors. The canonical method is given as Algorithm D in Knuth, D.E., <em>The Art of Computer Programming,</em> volume 2, but I'm sure you will find it online. I'd be astonished if it wasn't in Wikipedia somewhere.</p>
",3
25494131,25494109,1,"<blockquote>
  <p>because with new() we can only call the default constructor</p>
</blockquote>

<p>Nonsense.</p>

<p>I believe the code you are looking for is something like this:</p>

<pre><code>MyClass(const std::vector&lt;std::string&gt; &amp;s)
  : T(new MyType(s))
{
}
</code></pre>
",1
25494238,25494109,2,"<p>I'm going to go out on a limb here and guess that you don't actually need a pointer, you just think you do. And the reason you think you do is because you aren't aware that you can call a constructor other than the default constructor for member objects. Well, you can, using the <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow"">member initializer list</a>.</p>

<pre><code>class MyClass {
private:
    MyType T;
public:
    MyClass (const std::vector&lt;std::string&gt; &amp;S)
        :T(S)
    {}
};
</code></pre>

<p>If I'm wrong in my assumptions, let me know, and I'll delete this answer.</p>
",1
22853910,22853866,0,"<p>you should define it  <code>Info customer[50];</code> as global variable , not local variable</p>
",0
22854501,22853866,0,"<p>Declare that structure as global in the file where you are loading that structure and then use the extern keyword along with the structure name in all the files where you want to use that function.</p>

<p>DO check this link:
<a href=""http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"" rel=""nofollow"">http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/</a></p>
",0
22854114,22853866,0,"<ol>
<li>define Info customer[50]; in main(), </li>
<li>Change newRecord() interface to add two parameters: Info * customer, int sizeCustomer</li>
<li>Change newRecord() internal loop to control customer's overflow, something like ""if(j >= sizeCustomer) break;""</li>
<li>Change newRecord() interface to return number of customers have been read</li>
<li>Change updateRecord() interface to add two parameters: const Info * customer, int actualCustomerSize</li>
<li>Change updateRecord() internal loop to run for actualCustomerSize only, for example by modifing for(;j!=actualCustomerSize;)</li>
<li>Make changes in main()</li>
<li>Enjoy</li>
</ol>
",0
31307797,31307723,6,"<p>The declaration is required because you need to tell the compiler to reserve a slot in the vtable for that specific method starting from the base class in which it is declared (which is the type you could want to use when calling a method on a derived class)</p>

<p>Just to give you the idea let's make an example (which is not to be considered exactly what happens under the hood). Let's suppose you have three virtual methods in <code>Base</code>, one of which is pure, </p>

<pre><code>class Base {
  virtual void pure() = 0;
  virtual void nonpure() { }
  virtual void nonpure2() { }
};
</code></pre>

<p>so the <code>Base</code> vtable will look like</p>

<pre><code>0 [ pure ] -&gt; nothing
1 [ nonpure ] -&gt; address of Base::nonpure
2 [ nonpure2] -&gt; address of Base::nonpure2
</code></pre>

<p>now let's derive it with</p>

<pre><code>class Derive : public Base {
  virtual pure() override { }
  virtual nonpure2() override { }
};
</code></pre>

<p><code>Derived</code> vtable will look like</p>

<pre><code>0 [ pure ] -&gt; address of Derived::pure
1 [ nonpure ] -&gt; address of Base::nonpure
2 [ nonpure2 ] -&gt; address of Derived::nonpure2
</code></pre>

<p>When you then try to do</p>

<pre><code>Base* derived = new Derived();
derived-&gt;pure();
</code></pre>

<p>The method is roughly compiled as</p>

<pre><code>address = derived-&gt;vtable[0];
call address
</code></pre>

<p>If you don't declare the pure virtual method in the <code>Base</code> class there is no way to know it's index in the vtable (0) in this case at compile time since the method is not present at all. </p>

<p>But being a hole in the vtable you can't instantiate a class that has a vtable with an empty ""slot"".</p>
",1
31307821,31307723,6,"<p>You cannot instantiate an object of an abstract class. Which actually makes your question kinda meaningless: since you will never instantiate your abstract class, the virtual table for that class is not needed at all. (In reality it might be needed temporarily during construction/destruction, but this is a different story.)</p>

<p>When you actually instantiate an object, it is an object of some <em>derived</em> class, which is no longer abstract. It does not have any pure virtual functions anymore. The derived class that you actually instantiate has all pure virtual functions overridden by that time. This is why an entry is needed in the virtual method table - to store a pointer to the actual overrider function.</p>

<p>Later in your code, you might call <code>myFunction()</code> through a pointer to that abstract base class</p>

<pre><code>MyAbstractBaseClass *ptr = some_function();
// Pointer actually points to some non-abstract derived object
ptr-&gt;myFunction();
</code></pre>

<p>The compiler will generate code that will go into the virtual method table associated with <code>*ptr</code> object, extract the pointer entry that corresponds to <code>myFunction()</code> and pass the control trough that pointer. As I said above, that pointer will actually point to an overriding function from some derived class. This is exactly what that entry was reserved for.</p>
",0
23093276,23093197,0,"<p>The result you get is the result you want divided by 4. So changes are you forgot to multiply by 4 somewhere.</p>
",1
23093413,23093197,1,"<p>You've got</p>

<pre><code>(-b+sqrt(diskriminantas))/2 * a
</code></pre>

<p>in your code, which is the same as</p>

<pre><code>a * (-b + sqrt(diskriminantas))/2
</code></pre>

<p>... and I think you can figure it out from there.</p>
",0
23060380,23060170,0,"<p>Is block allocated with sufficient buffer size? If not, please do so, Check with all such pointers, whether pointing to an allocated space before accessing</p>
",0
25695624,25695593,4,"<p>All the assignment operators have the same precedence, and they group right-to-left.</p>

<p>Semantically, the <code>+=</code> operator is a combination of <code>=</code> and <code>+</code>, but syntactically it's an operator by itself, and it's the syntax that determines the precedence.</p>

<p>Quoting the C++ standard, the syntax is:</p>

<pre class=""lang-none prettyprint-override""><code><i>assignment-expression:
    conditional-expression
    logical-or-expression assignment-operator initializer-clause
    throw-expression</i>

<i>assignment-operator</i>: one of
     = *= /= %= += -= >>= &lt;&lt;= &= ^= |=
</code></pre>

<p>The C syntax is a bit simpler:</p>

<pre class=""lang-none prettyprint-override""><code><i>assignment-expression:
    conditional-expression
    unary-expression assignment-operator assignment-expression</i>
</code></pre>

<p>In C++, an <em>initializer-clause</em> is either an <em>assignment-expression</em> or a <em>braced-init-list</em>; the C grammar makes it clearer that the right operand can be an <em>assignment-expression</em>, which makes it right-associative.</p>
",2
25695685,25695593,0,"<p>""a row further below it"" doesn't refer to <code>+=</code> appearing on the <em>line</em> below <code>=</code>, it refers to <code>throw</code> and <code>,</code> appearing on the <em>row</em> below it, with a table rows separated by borders.</p>

<p>The only way in which <code>a = b += c</code> can mean anything other than <code>(a) = ((b) += (c))</code>, assuming <code>a</code>, <code>b</code> and <code>c</code> are all valid expressions, is if any of those expressions contain operators that the page you link to lists as precedence level 15 or higher.</p>

<p>An example of that would be if <code>b</code> is actually the expression <code>d, e</code>: <code>a = d, e += c</code> naturally means <code>(a = d), (e += c)</code>, not <code>a = ((d, e) += c</code>.</p>
",1
25476640,25476625,1,"<p>The error you see is because you have violated <strong><a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow"">One Definition Rule</a></strong>. That is, you have included the declaration of same symbol more than once. To solve this, your <code>linkedList.h</code> file should follow the pattern:</p>

<pre><code>#ifndef LINKEDLIST_H
#define LINKEDLIST_H

// file content

#endif
</code></pre>

<p>(or at least single <code>#define LINKEDLIST_H</code> statement in your case).</p>

<p>Additionally, using structures like:</p>

<pre><code>#if !defined(LINKEDLIST_H)
#include ""linkedList.h""
#endif
</code></pre>

<p>is <em>strange (to me)</em>, you should <em>rather</em> use guard macros in every header file, and not care about any other translation units that include them:</p>

<pre><code>#ifndef PROJECT_SCOPE_UNIQUE_NAME
#define PROJECT_SCOPE_UNIQUE_NAME

// include whatever you want 

// header content

#endif
</code></pre>

<p>where <code>PROJECT_SCOPE_UNIQUE_NAME</code> is a unique name across your project, preferably the name/path of file written in uppercase.</p>
",2
25478559,25476625,0,"<p>It is odd for your <code>ifdef define endif</code>, it should be like this :</p>

<p>inkedList.h:</p>

<pre><code>#ifndef LINKEDLIST_H 
#define LINKEDLIST_H

struct intLink{
    int data;
    intLink* nextLink;
    intLink* prevLink;
};  

class linkList{
    private:
        intLink* first;
        unsigned int numLinks;
    public:
        linkList(){};
        ~linkList(){};
        void append(int dd);                                                                                                                                                 
        void extend(linkList&amp; ll);
        int pop();
        unsigned int getTotal();
};

#endif /*LINKEDLIST_H*/
</code></pre>

<p>hashTable.h:</p>

<pre><code>#ifndef HASHTABLE_H 
#define HASHTABLE_H

#include &lt;cassert&gt;
#include ""linkedList.h""

#define HASH_TABLE_MAX_SIZE 1000

class hashTable{
    protected:
        unsigned int TABLE_SIZE;
        linkList** tableAdd;
    public:                                                                                                                                                                  
        hashTable(int SIZE);
        ~hashTable();
};

#endif /*HASHTABLE_H*/
</code></pre>

<p>hashTable.cpp:</p>

<pre><code>#include ""hashTable.h""
#include ""linkedList.h""

hashTable::hashTable(int SIZE){                                                                                                                                              
    // c-tor
    assert(0 &lt; SIZE and SIZE &lt; HASH_TABLE_MAX_SIZE);
    TABLE_SIZE = SIZE;
    for (int i=0; i&lt;TABLE_SIZE; i++){
        tableAdd[i] = new linkList;
    }
}       

hashTable::~hashTable(){
    // d-tor
}
</code></pre>
",0
25706852,25706837,3,"<p>Use:</p>

<pre><code>bar.print();
</code></pre>

<p>Please note that the original <code>foo</code> object is not changed when <code>bar</code> is created. <code>foo</code> has type <code>class A</code>, which doesn't contain a <code>print</code> method, and in C++ it's not possible to add methods on the fly.</p>
",3
25708231,25706837,0,"<p>Your code is an example of Type Conversion. By doing the following</p>

<pre><code>B (const A&amp; x) {}
</code></pre>

<p>You are constructing a new object of  Type B from an object of Type A. Here the original object A remains unchanged. When you write</p>

<pre><code> A foo;
 B bar = foo;  // calls constructor
</code></pre>

<p>You have first created foo which is an  object of Type A. From this object you are now creating an object of Type B taking foo as an argument. It will construct bar but will leave foo unchanged. That is why you cannot invoke the print method on foo since the print method is defined only for bar and not foo. 
Now as you asked what would you gain by doing this.</p>

<p>Consider the following code</p>

<pre><code>void fun ( B&amp; b )
{
   // do something with object b
}

void main ()
{
   A a;
   fun ( a );
}
</code></pre>

<p>The function fun here is expecting an object of type B but it is being passed an object of Type A. Before generating compile error, the compiler will try to see if there is any way it can construct object of Type B from an object of Type A.  If you had not defined any conversion, the compiler will generate compile error. But here since we can construct an object of type B taking A as an argument, the compiler will do that and the call will succeed. This type of mechanism does have some unintended consequences. Here you wanted to call the function fun with object of type B but the call succeeded even with object of type A since compiler does an implicit conversion from Type A to Type B using the constructor in B. To stop this kind of behavior, keyword 'explicit' can be used on the affected constructor.</p>

<pre><code>explicit B (const A&amp; x) {}
</code></pre>

<p>Consider the following code inside class B</p>

<pre><code>B&amp; operator= (const A&amp; x) {return *this;} 
</code></pre>

<p>This will not create any new object. However it will be used modify an object of type B using an object of type A. If on the other hand we want to construct an object of Type A from an object of Type B we will have to use a typecast operator ( conversion function) in class B:</p>

<pre><code>operator A() { return A(); }
</code></pre>

<p>So the class B would look something like:</p>

<pre><code>class B
{
   public:
      B ( const A&amp; a ) {} // conversion from A using constructor
      B&amp; operator= ( const A&amp; a ) { return *this;} // conversion from A using assignment
      operator A() { return A(); } // conversion to A using typecast operator
};

int main ( int argc, char** argv )
{
   A a;        
   B b= a;    // Construct B from A using constructor ( 1st one above )
   b = a;      // copy a into b using assignment operator ( 2nd one above)
   a = b;      // construct A from B using typecast operator ( 3rd one above )
   return 0;
}
</code></pre>

<p>Please refer to <a href=""http://www.cplusplus.com/doc/tutorial/typecasting/"" rel=""nofollow noreferrer"">this</a> and <a href=""https://stackoverflow.com/questions/4920530/typecast-operator-overloading-problem"">this</a> for some additional information</p>
",5
23575129,23574807,0,"<p>As guest has pointed out, the pointers inside C haven't been initialised. You need to initialise them in the first loop (commented 1) and initialise their elements to zero in the second (commented 2):</p>

<pre><code>int **multiply(int **A, int **B, int N){
    int **C = new int*[N];
    for (int i = 0; i &lt; N; i++) {
        C[i] = new int[N]; //1
        for (int j = 0; j &lt; N; j++) {
            C[i][j] = 0; //2
            for (int k = 0; k &lt; N; k++)
                C[i][j] = C[i][j] + A[i][k] * B[k][j];
        }
    }
    return (C);
}
</code></pre>
",0
23575180,23574807,5,"<p>It is not a good idea to make matrices as pointers of pointers. To do that properly, you need a rather complex:</p>

<pre><code>int **C = new int*[N];
for(int i = 0; i &lt; N; ++ i)
    C[i] = new int[M];
</code></pre>

<p>And freeing this up is a similarly complicated process. Also think about what happens if one of the <code>operator new</code> fails and you want to free up the partially allocated matrix.</p>

<p>It is a convention to store 2D arrays inside of a 1D ones. You can do:</p>

<pre><code>int *C = new int[M * N];
</code></pre>

<p>And then the elements are accessed as:</p>

<pre><code>C_ij = C[i + N * j];
</code></pre>

<p>or as:</p>

<pre><code>C_ij = C[j + M * i];
</code></pre>

<p>Where <code>i</code> is in <code>[0, N)</code> interval and <code>j</code> is in <code>[0 to M)</code> interval. These are actually quite similar to how the compiler generates accesses to a constant-sized 2D array (so the multiplication is in fact not overly costly, and when considering cache, the whole thing is likely to be much faster than your array of arrays). The difference between the two lines above is that the one is column-major (the elements of a column are consecutive items when unrolled to 1D) or alternately row-major. That is a matter of convention. The default ""C"" arrays will be row-major. Some libraries, such as OpenGL or Eigen use column major.</p>
",4
23574877,23574807,4,"<pre><code>int **C=new int*[N];
</code></pre>

<p>This makes space for an array of pointers. It doesn't initialize them, so they could point anywhere. They might even be NULL pointers.</p>

<pre><code>C[i][j]
</code></pre>

<p>This might cause a null pointer dereference. That's probably what causes the segmentation fault.</p>
",4
26795882,26795763,1,"<p>Regarding the error message you have - you don't have a method (at least in this question) with the signature that your code is apparently looking for. You have:</p>

<pre><code>virtual void registerObserver(ISubscriber *observer)
    {
        subscribers.append(observer);
    }
</code></pre>

<p>Your first file describes an <code>ISubscriber</code> but your second file inherits from an <code>ISubsrciber</code> (sic).</p>

<p>You have a typo in your file. Change to <code>ISubscriber</code> and you should have better luck!</p>
",0
26795899,26795763,0,"<p>here updateManager->registerObserver(this); you are sending it object of UpdateReceiver while it requires ISubscriber.</p>
",0
26795938,26795763,0,"<p>class </p>

<pre><code>class UpdateReceiver: public ISubsrciber   // wrong 
class UpdateReceiver: public UpdateManager // right
</code></pre>

<p>should inherit UpdateManager not ISubsrciber?</p>
",0
26796348,26795763,0,"<p>Well I do see a few problems along your solution. Firstly you do have different forward declarations for the type <code>ISubscriber</code> as I stated in my earlier comment. Which results in your program not compiling.</p>

<p>These two wont match for sure.</p>

<pre><code>virtual void registerObserver(ISubscriber *observer) {...}
class UpdateReceiver: public ISubsrciber {...}
                                 ^^^^
</code></pre>

<p>Secondly your <code>notifyObserver</code> implementation does need some rethinking as well. But since you kind of commented that code out, I'll leave this one up to you. Just remember that you're holding pointers to <code>ISubscriber</code> in your subscriber list when you're trying to iterate/loop over it.</p>

<p>Also the definition of <code>unregisterObserver</code> does not match your declaration.</p>

<pre><code>virtual void unregisterObserver(ISubscriber &amp;observer) = 0;
virtual void unregisterObserver(ISubscriber *observer) {...}
</code></pre>

<hr>

<p><strong>BUT</strong>
I would consider some major refactorings for your code. In my opinion you should not mix up the Interface of the <code>Observer</code>pattern with your application logic.</p>

<p>I think your solution should look similar to this. It's not complete and does not use your QT classes tho but you should get the idea. See the <a href=""http://ideone.com/vKWx1Q"" rel=""nofollow"">demo</a> for a runnable solution.</p>

<pre><code>class ISubscriber {
public:
    virtual void update() = 0;
};

class Publisher {
    std::vector&lt;ISubscriber*&gt; m_observerList;
public:
    virtual void registerSubscriber(ISubscriber&amp; observer);
    virtual void unregisterSubscriber(ISubscriber&amp; observer);
    virtual void notifySubscribers();
};

class UpdateManager : public Publisher {
    int m_baudRate;
    int m_aspectRatio;
    int m_volumeLevel;
public:
    virtual void setBaudRate(int newBaudRate);
    virtual void setAspectRatio(int newAspectRatio);
    virtual void setVolumeLevel(int newVolume);

    int getBaudRate() const;
    int getAspectRatio() const;
    int getVolumeLevel() const;
};

class UpdateReceiver : public ISubscriber {
    UpdateManager&amp; m_manager;
public:
    UpdateReceiver(UpdateManager&amp; manager) : m_manager(manager) {
        m_manager.registerSubscriber(*this);
    }
    virtual void update() {
        // Process the new values
        m_manager.getBaudRate();
        m_manager.getAspectRatio();
        m_manager.getVolumeLevel();
    }
};
</code></pre>

<p><strong><a href=""http://ideone.com/vKWx1Q"" rel=""nofollow"">DEMO</a></strong></p>
",0
24386211,24386166,2,"<p>Only if you implement it yourself. If you come from a C# or Java (or other managed language) then this can be a difficult concept.</p>

<p>You would be better using one of the standard pointer types provided by <a href=""http://en.cppreference.com/w/cpp/memory"" rel=""nofollow"">C++11</a> or <a href=""http://www.boost.org/doc/libs/1_55_0/libs/smart_ptr/smart_ptr.htm"" rel=""nofollow"">Boost</a>.</p>

<p>For example, <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow""><code>shared_ptr&lt;T&gt;</code></a> will keep a count of all the 'references' to your objects and manage the lifecycle. <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""nofollow""><code>unique_ptr&lt;T&gt;</code></a> will only allow a single pointer to your object.</p>
",0
24386319,24386166,4,"<p>Raw pointers do not do reference-counting. You would need to either implement a reference-counting smart pointer class yourself, or use an already existing one, such as <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow""><code>std::shared_ptr</code></a>.</p>

<p><code>shared_ptr</code> allows you to access its reference count with the <code>use_count()</code> member function.</p>

<p>For example:</p>

<pre><code>#include &lt;memory&gt;
#include &lt;iostream&gt;

class A
{
  public :
    A(){}
}

int main()
{
  //Dynamically allocate an A rather than stack-allocate it, as shared_ptr will
  //try to delete its object when the ref count is 0.
  std::shared_ptr&lt;A&gt; ptr1(new A());
  std::shared_ptr&lt;A&gt; ptr2(ptr1);
  std::shared_ptr&lt;A&gt; ptr3(ptr1);
  std::cout&lt;&lt;""Count: ""&lt;&lt;ptr1.use_count()&lt;&lt;std::endl; //Count: 3
  return 0;
}
</code></pre>
",0
27688993,27688946,2,"<p>You call the function <code>menu</code> as</p>

<pre><code>menu();
</code></pre>

<p>Though it is declared as </p>

<pre><code>void menu(float kgs)
</code></pre>

<p>You said that the function would take a <code>float</code> argument, but did not pass it one.</p>

<p>As a side note, it looks like you are trying to <code>cin</code> a value into <code>kgs</code>. If you want this to act as you expect, you need to pass <code>kgs</code> by reference, otherwise you will input a value to a <strong>copy of</strong> <code>kgs</code>, then the original would be unchanged. You could change <code>menu</code> to </p>

<pre><code>void menu(float&amp; kgs)
</code></pre>

<p>Then call it as</p>

<pre><code>float kg;    // Declare a float variable
menu(kg);    // Pass that float by reference to your function
</code></pre>
",1
27137861,27137777,1,"<p>The first case defines operator() so you could could use it as a function - in short they are functors. The advantage is that it can have a state and depending how you define the operator() you could use the instance of that class as a function. Thse second case is simply a static functionn and does not hold the state in the sense of a class/struct.</p>
",0
27137985,27137777,0,"<p>I suspect the question is related to functors</p>

<p>ie you have seen</p>

<pre><code>mycompare_instance1(x,y)
</code></pre>

<p>vs</p>

<pre><code>mycompare2(x,y)
</code></pre>

<p>The first one is a functor. It used where we need to make things that are both objects with state and can be invoked like functions. The second one is a simple function</p>
",0
28208881,28208857,3,"<p>Use <code>while (getline(std::cin, s_array)) { }</code> instead.</p>

<p><code>std::getline()</code> returns <code>istream&amp;</code>, and <code>istream::operator void*()</code> makes it evaluated as <code>false</code> whenever any error flag is set.</p>
",3
28209134,28208857,0,"<p>You should definitely read Joseph Mansfield's blog post titled <a href=""http://josephmansfield.uk/articles/dont-condition-input-on-eof.html"" rel=""nofollow"">""Don't condition input on eof()""</a> which describes this pitfall in details and provides a well justified guideline.</p>
",0
24766933,24766516,1,"<p>You are double summing Fibonacci numbers, look closely in <code>if (i % 2)</code> and corresponding <code>else</code>.</p>
",2
27554531,27554391,1,"<p>In Enemy.h you have <code>void update(float delta, Player player);</code>.  How does the compiler know what a play is?  It cant since you never included the player.h file in enemy.h.  You have to options to fix this you can either include player.h or you could <a href=""https://stackoverflow.com/questions/4757565/c-forward-declaration"">forward declare</a> player and change the function to take a pointer to a player.</p>
",0
24763624,24763538,3,"<p>The problem is that you're using the <a href=""http://www.cplusplus.com/reference/map/map/operator[]/"" rel=""nofollow"">operator[]</a> to access the map, the documentation says:</p>

<blockquote>
  <p>If k does not match the key of any element in the container, the
  function inserts a new element with that key and returns a reference
  to its mapped value. Notice that this always increases the container
  size by one, even if no mapped value is assigned to the element (the
  element is constructed using its default constructor).</p>
</blockquote>

<p>thus you need a default constructor if you intend to use it: that operator needs it to return a reference to the newly default-constructed and inserted element.</p>

<p>Otherwise you can do this:</p>

<pre><code>m.insert(std::pair&lt;int,A&gt;(0,A(3)));
</code></pre>

<p>which doesn't need a default constructor available.</p>
",4
25501042,25500661,1,"<p>If you want the aggregate A inside B to initialize always to let say 3 its better to do this:</p>

<pre><code> class A{
     public:
            int x;
            A(){
               x=0;
            }
            A(int a){
                    x=a;
            }
};
class B{
     public:
           A objA;
           B() : objA(3)
           {

           }
};
</code></pre>

<p>If you do not have pointers and buffers in B you should not worry about memory allocations etc. Object objA will start to exist only when B start to exist, B* b = new B(), will allocate all the necessary memory. It is however better to initialize all aggregates like objA in this way rather than using assign operator.</p>
",2
25500813,25500661,-3,"<p>Yes it's in fact a wrong way to use it.</p>

<p>The fact that you do this:</p>

<pre><code>B(){
  ojbA=A(3);
}
</code></pre>

<p>Create an object A and affect the variable objA by using it's copy constructor, wich you haven't defined.</p>

<p>It would be better to do it like this:
B() : objA(3) {}</p>

<p>And if you don't understand how this sample of code work i invite you to look after initialization list (<a href=""http://www.cprogramming.com/tutorial/initialization-lists-c++.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/initialization-lists-c++.html</a>)</p>
",3
30147870,30147790,5,"<p>When you write <code>#include anything.any_extension</code>, the extension doesn't really matter to the preprocessor. It's really like a <em>""take the contents from that file and paste it into this file""</em> kind of brute mechanism. So you can include anything without error provided that the code inside is legit, and you can name a header file with any extension. So you can even name them with a <code>.txt</code> extension and it wouldn't really matter to the preprocessor.</p>

<p>I would suggest that the practice of including source files is rather confusing, mainly from a build standpoint since it's not very clear whether a source file (cpp, cc, etc) is supposed to be built as a separate object file to link against or #included or both.</p>

<p>Yet it's sometimes done anyways. For example, <code>pfarray.cpp</code> might contain an implementation for a template since templates typically need their full implementation visible at compile time at the site generating the code, and sometimes authors establish a habit of #including files with source file extensions to avoid putting the implementation details into the same header file while uniformly conforming to a style that favors putting all such details into files named with a source file convention. </p>

<p>Another reason this can be done, but I don't think it's the reason it was done in your case, is as a build optimization (see Unity builds). It can sometimes be more efficient to compile and link fewer files, so using <code>#include</code> for source files can be a crude way to fuse them all together into a single build target.</p>
",3
30147933,30147790,5,"<p>You don't have to.</p>

<p>A translation unit is a group of files with definitions and declarations. Compiling a translation unit, the compiler needs to know everything about declarations and re-parse them again and again. The definitions on the other hand can be compiled just once and reused for another units.</p>

<p>A translation unit can be separated in <code>.h</code> and <code>.cpp</code> files. You should put the declarations in <code>.h</code> and definitions in <code>.cpp</code> files to obey one definition rule. This approach also reduces compilation time.</p>

<p>Writing template-d classes and functions (without specialization), some coders (a bad habit in my opinion) will put the implementations in the <code>.cpp</code> files and they have to include them at the end of its corresponding <code>.h</code> file or in a <code>.cpp</code> file which needs them. It's just confusing. A better naming convention is to rename these type of <code>.cpp</code> files to <code>.impl.cpp</code> and including them at the end of its <code>.h</code> file.</p>
",0
24581600,24581560,0,"<p>There are too many loops in your code. You can just use a single <code>for</code> loop and within the loop:</p>

<ol>
<li>test if the indexed character in the string is <code>a</code></li>
<li>if so, perform the computation</li>
</ol>

<p>This leads to something along the lines of:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

int main(){
    std::string test = ""aaa"";
    double a=1.0;
    for (std::size_t j = 0; j &lt; test.size(); ++j) {
        if (test[j] == 'a') {
            a /= (1.5 - 0.01 * j);
            std::cout &lt;&lt; ""a="" &lt;&lt; a &lt;&lt; '\n';
        }
    }
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/bbe3bd24d3247734"" rel=""nofollow""><kbd>Live demo</kbd></a></p>

<p>To further explain this row:</p>

<pre><code>a /= (1.5 - 0.01 * j);
</code></pre>

<p>You should see your computation as:</p>

<pre><code>a = 1    / (1.5 - 0.01 * 0) = 0.66
a = 0.66 / (1.5 - 0.01 * 1) = 0.44
a = 0.44 / (1.5 - 0.01 * 2) = 0.30
</code></pre>

<p>which is:</p>

<pre><code>a = 1    / (1.5 - 0)    = 0.66
a = 0.66 / (1.5 - 0.01) = 0.44
a = 0.44 / (1.5 - 0.02) = 0.30
</code></pre>

<p>The above code will produce:</p>

<blockquote>
  <p>a=0.666667</p>
  
  <p>a=0.447427</p>
  
  <p>a=0.302316</p>
</blockquote>
",2
24581624,24581560,0,"<p>I'm a moment too slow, but here's a similar solution to the one Jeffrey gave:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;

int main(int, char**)
{
    string test=""aaa"";

    double i = 1.5;
    double a = 1.0;

    for (unsigned int j = 0; j &lt; test.length(); ++j)
    {
        a = a / i;

        i -= 0.01;  
    }

    cout &lt;&lt; ""a="" &lt;&lt; a &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>The result is something along the lines of 0.302316</p>
",1
24590115,24589436,1,"<blockquote>
  <p>add a progress bar to show the progress</p>
</blockquote>

<p>Read up about the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb760818.aspx"" rel=""nofollow"">Progress Bar</a> control.</p>

<p>You already know how to create a window and subwindows.  Creating a ProcessBar is no different than creating a Button, or any other control, using <code>CreateWindow/Ex()</code>.</p>

<blockquote>
  <p>add a window inside the main one showing the names of the files being currently moved.</p>
</blockquote>

<p>That is more difficult.  You are executing an external command to move the files, so you don't have direct access to its status information.  You would have to replace <code>system()</code> with <code>CreateProcess()</code> so you can redirect its output:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx"" rel=""nofollow"">Creating a Child Process with Redirected Input and Output</a></p>

<p>Once you have access to the output, you can parse it as needed and display it however you want, such as in a multi-line <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb775458%28v=vs.85%29.aspx"" rel=""nofollow"">Edit</a> control, a <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb775146%28v=vs.85%29.aspx"" rel=""nofollow"">ListBox</a> control, a <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb774737%28v=vs.85%29.aspx"" rel=""nofollow"">ListView</a> control, etc.</p>

<p>Alternatively, use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa364418%28v=vs.85%29.aspx"" rel=""nofollow""><code>FindFirstFile()</code></a> and <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa364428%28v=vs.85%29.aspx"" rel=""nofollow""><code>FindNextFile()</code></a> in a recursive loop to iterate the source folder yourself, using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa363855%28v=vs.85%29.aspx"" rel=""nofollow""><code>CreateDirectory()</code></a> and <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa363852%28v=vs.85%29.aspx"" rel=""nofollow""><code>CopyFileEx()</code></a> as needed.  Then you will have direct access to each filename and progress information for each file.  Then you do not need to use a redirected robocopy process anymore, and have more control over the iterating and copying.</p>
",0
24621906,24621785,0,"<p>In the separate-compilation case, the compiler must produce object code for the Year class methods and later link it against main().  This means the function calls will be done the normal way.  But if you expose all the code in a single translation unit and compile it at once, the compiler (or, well, the optimizer) can see everything and build it for faster performance.  Specifically, your constructor can be inlined if the compiler sees all the code, otherwise not.  It's even possible that the compiler will completely eliminate the loop or at least the copies within it when it can see all your code.</p>

<p>If you want the same high performance with separate files, simply #include ""Year.cpp"" in your main file  and compile just that one file.  This will have the same effect (single translation unit) without cluttering up your main file.  To do this ""for real"" you'd want to define all the methods as <code>inline</code> to avoid linker errors, though in a single-file program this won't matter.</p>
",1
24621937,24621785,0,"<p>In most cases, the distribution of functions to more than one file, has no impact on performance.  </p>

<p>However, there are a few cases of optimization where the compiler can better optimize performance when all the functions are in the same module.  One example is <em>inline</em>.  </p>

<p><strong>Automatic Inlining</strong><br>
If the compiler can find the implementation of a function in the same file (translation unit) as the calling function, the compiler may be able to <em>inline</em> the function.  To <em>inline</em> means to replace the function call with the actual code of the called function.  The compiler may invoke this on some of the more advanced optimization settings.  This would be performed by the compiler.  </p>

<p>One method around this is to declare and define small functions as inline in the header file.  This is a suggestion to the compiler to paste the code in from the header file.</p>

<p><strong>Linker Optimization</strong><br>
Some linker options allow for optimizations across translation units.  These optimizations may counter any effects of distributing code among different files.  </p>

<p><strong>Negligible Loss</strong><br>
In most applications, the loss of performance is negligible.  In most cases, functions are distributed to improve development and maintenance times, which are more costly than performance bottlenecks.  </p>

<p>I suggest not to worry about any performance loss by distributing functions.  <strong>After</strong> your program works correctly and robustly, then worry about performance.  When you need to improve performance <strong>optimize first</strong> to find where the bottlenecks are and concentrate your performance optimizations in those areas.  Most of them will not be related to function distribution.  </p>
",4
24621944,24621785,4,"<p>Compiler optimizations can have impressive effects. Loop optimizations are among the most profitable ones, and what you're seeing is a standard optimization: if the compiler can prove that a loop has no other effects and performs only a tractable action, it can remove the loop entirely and replace it just by the resulting final state.</p>

<p>Clearly, in your case, inclusion of the class member definitions allows the compiler to see that there is no side effect in the <code>Year</code> constructor aand copy-assignment operator, so the only effect of the loop is to set the final value.</p>

<p>For a simpler demonstration, consider this code:</p>

<pre><code>int main()
{
    int val = 0;
    for (int i = 1; i &lt;= 10; ++i) { val += i; }
    return val;
}
</code></pre>

<p>Let's look at mildly optimized code:</p>

<pre><code>main:
.LFB0:
        .cfi_startproc
        mov     eax, 55
        ret
        .cfi_endproc
</code></pre>

<p>As you can see, the compiler has figured out what the loop does.</p>
",2
24622125,24621785,-1,"<p>Cross-procedure optimizations, the most important of which is inlining, require the optimizer to see into all related procedures at the same time.  Luckily, the sweet spot for inlining generally corresponds to very short functions that don't deserve to be placed into a separate implementation file.</p>

<p>For your example, I would recommend a header-only implementation:</p>

<pre><code>#ifndef YEAR_H
#define YEAR_H
class Year
{
private:
    long m_nYear;

    Year(void) : m_nYear(-1) {}

public:
    Year(long nYear) : m_nYear(nYear) {}

    void SetYear(long nYear) { m_nYear = nYear; }
    long GetYear(void) { return m_nYear; }
};
#endif
</code></pre>

<p>Now you won't have that <code>#include ""some.cpp""</code> code smell.</p>

<p>I've also removed useless semicolons and demonstrated the right way to initialize class subobjects, using the initializer list.</p>

<p>In most cases, prefer to put function bodies inside the class definition.  A function that feels too long to put in the header file, is also unlikely to be inlined.</p>

<p>The downside is that you lose benefits of compile firewalling, as may be provided by pimpl.  But you can't get aggressive cross-procedure optimization and minimal compile surface at the same time.</p>
",1
24624494,24624380,0,"<p>When you use <code>%s</code> in <code>printf</code> family of functions, the corresponding argument type needs to be <code>const char*</code> or something that can be converted to <code>const char*</code>. The argument you are using is not such a type. Perhaps you meant to use:</p>

<pre><code>printf(""Version = '%s'\n"", gABXVER.m_pBuffer);
</code></pre>
",3
24624844,24624380,0,"<p>The compiler should compile just fine (with possible warnings for printf) because printf doesn't care what you pass to it (beyond the first parameter) or whether it matches the format string. Modern compilers or error checking progs like lint will issue a warning if the params obviously don't match, and if you have a setting ""treat warnings as errors"", the prog may fail to compile.</p>

<p>That said, CISPFVar_BINSTR needs a public copy constructor if you want to pass it as a parameter by value to a function (because at least semantically a copy will be made). Does it have one? As others remarked it's customary to help your helpers by providing any information you have. Here we are badly missing the compiler errors. (You can edit your post at any time.)</p>

<p>I could imagine that the class has a conversion to char* or std::string, so it may suffice to try either <code>printf(""Version = '%s'\n"", (char *)gABXVER)</code> or <code>printf(""Version = '%s'\n"", (std::string(gABXVER)).c_str() )</code>.</p>
",3
24625325,24624380,0,"<p>You can only <code>printf</code> things that have format specifiers designed specifically for them. There is no format specifier that accepts a value of class type, so you cannot <code>printf</code> one directly.</p>

<p>The best thing you can do is explicitly convert your object to a <code>const char*</code> and pass the result to <code>printf</code>.</p>
",0
24625480,24624380,0,"<p>In c++ you can use many techniques to implement things like <a href=""http://msdn.microsoft.com/en-us/library/1z2f6c2k.aspx"" rel=""nofollow noreferrer"">streaming operators</a></p>

<pre><code>#include &lt;iostream&gt;

class Whatever
{
    int value = 42;

public:
    int Get() const {
        return value;
    }

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, Whatever const&amp;);
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Whatever const&amp; what) {
    os &lt;&lt; what.Get();
    return os;
}

int main() {
    Whatever x;
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>

<p>printf <a href=""https://stackoverflow.com/a/14436941/847349"">is unsafe</a></p>

<p>In effect, you're doing <a href=""http://en.wikipedia.org/wiki/Serialization"" rel=""nofollow noreferrer"">serialization</a> of your object into a readable string.</p>
",0
24626992,24626538,5,"<p>During the compilation this:</p>

<pre><code>ms = a;
</code></pre>

<p>attempts to resolve an assignment of one or more of the following immediate forms</p>

<pre><code>my_struct&amp; operator ()(double)
my_struct&amp; operator ()(double&amp;)
my_struct&amp; operator ()(const double&amp;)
</code></pre>

<p>and a litany of other potential conversion from <code>double</code>. And none is found. In fact, only the following is discovered:</p>

<pre><code>my_struct&amp; operator=(const my_struct &amp;ms)
</code></pre>

<p>which indicates the compiler does allow assignment via a const-reference of another <code>my_struct</code>. At that time a <em>conversion constructor</em> is sought, starting with the most immediate conversion (explicit to the type <code>double</code>:</p>

<pre><code>my_struct(double)
my_struct(double&amp;)
my_struct(const double&amp;)
</code></pre>

<p>It is important to note such a constructor <em>cannot</em> mandate <em>explicit</em> use. We're implicitly constructing a temporary, and as such explicit mandate is off the reservation. </p>

<p>Anyway, again, none is found. Before giving up the compiler attempts to locate a constructor of <em>any</em> form that can convert from <code>double</code> to whatever the fundamental construction requires <em>and</em> said constructor supports implicit construction. In effect, something of the form</p>

<pre><code>my_struct(&lt;&lt;something that can be converted from a double&gt;&gt;)
</code></pre>

<p>And again, the constructor cannot be <code>explicit</code>. As it turns out, this search <em>does</em> find this:</p>

<pre><code>my_struct(char)
</code></pre>

<p>because <code>double</code> can be converted to <code>char</code> (albeit poorly and likely not what you want). The entire chain is a little (ok, a <em>lot</em>) more complicated than that, but that is the crux of it.</p>

<p>You can avoid this implicit construction by ensuring that constructor is only <code>explicit</code> in usage, but that is a double-edge sword, so care is required. Use of <code>explicit</code> can be somewhat harsh. Doing this:</p>

<pre><code>explicit my_struct(char)
</code></pre>

<p>will squelch the unintended implicit construction when converting <code>double</code> to <code>char</code>. But I warn you; it will also squelch the ability to do this:</p>

<pre><code>char x = 'a';
my_struct ms;
ms = x;
</code></pre>

<p>because now <code>my_struct</code> cannot be <em>implicitly</em> constructed <em>at all</em> from <code>char</code>, by conversion or otherwise. There are multiple ways around this, including defining a specific assignment operator for the type (takes a <code>double</code>) or a specific conversion constructor (takes a <code>double</code>). How you approach that I leave to you.</p>
",0
24626993,24626538,3,"<p>You have yourself a conversion constructor:</p>

<pre><code>my_struct(char c)
</code></pre>

<p>This means anything that can be converted to <code>char</code> can be used to implicitly create an object of <code>my_struct</code>.</p>

<p>In order to avoid this you can add <code>explicit</code> to your constructor:</p>

<pre><code>explicit my_struct(char c)
</code></pre>

<p>This way you can create an object from double like this:</p>

<pre><code>double a = my_initial_value;
my_struct ms2(a);
</code></pre>

<p>Also, always initialize your variables, otherwise types like <code>int</code>, <code>float</code>, pointers etc. will hold random values.</p>
",2
29902102,29902003,2,"<p>Your description of the problem is incredibly vague, but I can point out problems with your code:</p>

<ul>
<li><p>No <code>vector</code> copy constructor (causes double-deletes and crashes)</p></li>
<li><p>No <code>vector</code> copy assignment (causes double-deletes and crashes)</p></li>
<li><code>clear</code> is incorrectly calling <code>delete</code> (causes crashes and corruption) (you should match your single <code>new</code> of an array with a single <code>delete</code> of the array.  Don't loop over elements.</li>
<li><code>add</code> is writing past the end of the array  (causes crashes and corruption)</li>
<li>add is not exception safe</li>
</ul>

<p>You have to fix at least the first four.  The third and fourth are probably the causes of your hang.</p>
",0
29902130,29902003,1,"<p>You have a buffer overflow occurring.   </p>

<pre><code>T* temp = new T[size + 1]; // When size is 0, you allocate 1 space.
</code></pre>

<p>You then assign to the temp array, but in location <code>temp[1]</code>, which isn't a valid location because your array has only 1 element. This is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>, and that this point, your program is free to continue however it chooses. In this case, it seems to loop indefinitely.</p>

<pre><code>// add the new value in last index
temp[size + 1] = value; // When size is zero, your array is length '1', but
                        // you are accessing temp[1] which is outside the
                        // bounds of your allocated memory.
</code></pre>
",1
24756487,24756345,0,"<p>See inscribed comments with corrected version:</p>

<pre><code>class A
{
public:
void test();
};

class B: virtual public A // A is a virtual base class
{
};


class C : public A // C is a base class of A
{
} ;

class D: public B, public C // D has two base classes B and C
{
};
</code></pre>

<p>By virtue of inheritance, D gets two copies of A, one via B, another via C
You could have only one shared copy of A in D, if you would have declared:</p>

<pre><code>class C : virtual public A // C is a virtual base class of A
{
} ;
</code></pre>
",0
24759996,24759937,4,"<p>You're not allocating any memory for <code>StateTransition</code>, you want something like:</p>

<pre><code>StateTransition = new int[Nstates];
</code></pre>

<p>before your <code>for</code> loop in the ctor.</p>
",3
24760253,24759937,0,"<p><a href=""http://www-01.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzarg/flexible.htm"" rel=""nofollow"">Flexible array members</a> were a C99 feature which allowed you to do something like</p>

<pre><code>struct header {
    size_t len;
    unsigned char data[];
};
</code></pre>

<p>and, provided that you had a proper memory layout, you could access and write to the <code>data</code> array.</p>

<p>In your case you're not providing any memory for your <code>StateTransition</code> variable and thus overwriting some other stack data.</p>

<p>You had better doing something like</p>

<pre><code>class Trellis
{
private:
  int m;
  int Nstates;
  int *StateTransition; // Pointer

public:
  Trellis(); 
  Trellis(int M);
  ~Trellis();
};
Trellis::Trellis() : StateTransition(0) {
}
Trellis::Trellis(int M) : StateTransition(0)
{
  m = M;
  Nstates = pow(2, M - 1);

  StateTransition = new int[Nstates]; // Allocate memory

  for (int i = 0; i &lt; Nstates; i++)
  {
    StateTransition[i] = i;
  }
}

Trellis::~Trellis() {
    if(StateTransition != 0)
        delete[] StateTransition; // Always be a good citizen
}
</code></pre>

<p>And as for the <a href=""http://en.wikipedia.org/wiki/Rule_of_three"" rel=""nofollow"">rule of three</a>, you might also want to write a copy constructor.</p>
",1
24763321,24763221,1,"<p><a href=""http://ideone.com/B9ho2Q"" rel=""nofollow"">These fixes work</a></p>

<pre><code>template &lt;class T&gt; class MyClass {
protected:
    struct MyStruct
    {
    };

    MyStruct* GetElement(...) const;
}; // &lt;&lt; add semicolon

template &lt;class T&gt;
// Add typename
typename MyClass&lt;T&gt;::MyStruct* MyClass&lt;T&gt;::GetElement(...) const {
     // Add &lt;T&gt; ^^^
    return NULL;
}
</code></pre>

<p>Any type that depends on the template parameter must be specified with <code>typename</code>.</p>
",0
24763325,24763221,0,"<p>The return type of <code>GetElement</code> should be written as <code>typename MyClass&lt;T&gt;::MyStruct*</code>:</p>

<pre><code>template&lt;class T&gt;
typename MyClass&lt;T&gt;::MyStruct* MyClass&lt;T&gt;::GetElement(...) const
{

}
</code></pre>

<p>The <code>&lt;T&gt;</code> is necessary because <code>MyClass</code> is a <a href=""http://www.cprogramming.com/tutorial/templates.html"" rel=""nofollow noreferrer"">template class</a>.  <code>typename</code> is needed because <code>MyClass&lt;T&gt;::MyStruct</code> is a <a href=""https://stackoverflow.com/q/20368837/2555451"">dependent name</a>.</p>
",0
25516757,25516740,20,"<p>Valid indexes for <code>foo</code> are from <code>0</code> to <code>MAX-1</code> inclusive. <code>MAX</code> is past the end of the array.</p>

<p>Your loop runs up to, and including, <code>MAX</code>. This writes beyond the end of the array, corrupting the stack.</p>

<p>Either increase the array size to <code>MAX+1</code> so that <code>MAX</code> is in range; or change the loop condition to <code>i &lt; MAX</code> to stop before reaching <code>MAX</code>.</p>
",0
25460987,25460275,0,"<p>You have to make a difference between a <strong><em>const qualified type</em></strong> and a <strong><em>const qualified object</em></strong>.  </p>

<p>The standard  states in section <em>7.1.6.1: cv-qualifiers</em>: (cv = const or volatile)</p>

<blockquote>
  <p>A pointer or reference to a cv-qualified type need not actually point
  or refer to a cv-qualified object, but it is treated as if it does; a
  const-qualified access path cannot be used to modify an object even if
  the object referenced is a non-const object and can be modified
  through some other access path.</p>
</blockquote>

<p>If your pointer points to a non const object,  the casting away will enable you to modifiy the objet, but as someone told, you are lying to the user of your function.  </p>

<p>It your pointer points to a real const object (i.e. in const protected memory), the compiler will compile your code, but you might have a segmentation fault, typical for undefined behaviour.  </p>

<p>Here an example, using the fact that <em>""Ordinary string literal (...) has type ¡°array of n const char¡±, where n is the size of the string (...)""</em> (see standard, section 2.14.5):  </p>

<pre><code>char *my_realconst = ""This is a real constant string"";    // pointer does not claim that it points to const object 

(*my_realconst)++;  // Try to increment the first letter, will compile but will not run properly !! 
</code></pre>

<p>So if your function ProcessData() is legacy code that is only reading the data but has forgotten to mention a const in the parameter list,  your cast-away will work. If your function is however altering the data, it might work or it might fail, depending how the data poitned to was created !  </p>

<p>So try to avoid casting const away if you are not 100% sure of what the effects will be !  Better clone your object the hard way creating a temporary object and copying the content.  </p>
",0
25461090,25460275,2,"<blockquote>
  <p>My aim is to keep intact value of pValueData which is being passed as
  const char*</p>
</blockquote>

<p>That's impossible. Passing via <code>const</code> means it cannot be modified, except when it was originally not constant.</p>

<p>Example:</p>

<pre><code>char *ptr1 = new char[100]; // not const
char *ptr2 = new char[100]; // not const
int i = FunctionName(ptr1, ptr2, 123);
</code></pre>

<p>In this case, you could technically keep the <code>const_cast</code>. But what for? Just change your function parameters to take <code>char *</code>:</p>

<pre><code>int FunctionName(char *pValueName, char *pValueData, long iMaxValueSize)
{
  int iActualSiz = ProcessData(pValueData, iMaxValueSize);
  // ...
}
</code></pre>

<p>However, you most likely <em>want</em> to be able to pass constant strings. For example string literals:</p>

<pre><code>int i = FunctionName(""name"", ""data"", 123);
</code></pre>

<p>String literals are unmodifiable and thus require your function to take <code>char const *</code>. A later attempt to modify them causes undefined behaviour.</p>

<hr>

<p>As you can see, the error is in the general architecture and code logic. <strong>You want to modify something and at the same time you do not want to allow to modify it.</strong></p>

<p>The question is: What happens with your <code>pDataToStore</code> when <code>ProcessData</code> is done with it? Does the caller of <code>FunctionName</code> need to be aware of the modifications? Or is it just internal business of <code>FunctionName</code>?</p>

<p>If it's just internal business of <code>FunctionName</code>, then you can keep its signature intact and have <code>ProcessData</code> modify a copy of the passed data. Here is a <strong>simplified</strong> (not exception-safe, no error checks) example: </p>

<pre><code>int FunctionName(const char *pValueName, const char *pValueData, long iMaxValueSize)
{
   char *copy = new char[strlen(pValueData) + 1];
   strcpy(copy, pValueData):
   int iActualSiz = ProcessData(copy, iMaxValueSize);

   // ...

   delete[] copy;
}
</code></pre>

<p>The nice thing is that you can now massively improve the interface of <code>FunctionName</code> by hiding all the low-level pointer business. In fact, why use so many pointers at all when C++ standard classes can do all the work for you?</p>

<pre><code>int FunctionName(std::string const &amp;valueName, std::string const &amp;valueData, long maxValueSize)
{
   std::vector&lt;char&gt; copy(valueData.begin(), valueData.end());
   int actualSize = ProcessData(&amp;copy[0], maxValueSize);

   // ...
   // no more delete[] needed here
}
</code></pre>

<p>The <code>std::vector&lt;char&gt;</code> automatically allocates enough memory to hold a copy of <code>valueData</code>, and performs the copy. It fully automatically frees the memory when it is no longer needed, even if exceptions are thrown. And <code>&amp;copy[0]</code> (which in C++11 can be written as <code>copy.data()</code>) is guaranteed to yield a pointer to the internally used data, so that low-level C functions can modify the vector's elements.</p>

<p><em>(I've also taken the chance to remove the Microsoft-style Hungarian Notation. It's a failed experiment from the 90s, and you've even used it incorrectly, supposing that a leading <code>i</code> is supposed to indicate an <code>int</code>.)</em></p>

<hr>

<p>The bottom line is really:</p>

<p><strong>If you need a <code>const_cast</code> <em>anywhere</em> in your code to make it compile, then somewhere else there is at least either one <code>const</code> <em>missing</em> or one <em>too much</em>.</strong> A <code>const_cast</code> always makes up for a mistake in another piece of code. It is always a workaround and never a solution designed up front.</p>
",5
25460845,25460275,0,"<p>Well I have solved the issue by creating the heap memory.</p>

<pre><code>char *pDataToStore = new char[iMaxValueSize];
memcpy(pDataToStore, pValueData, iMaxValueSize*sizeof(char));
int iActualSiz = ProcessData(pDataToStore, iMaxValueSize);
...
....
delete []pDataToStore;
</code></pre>
",6
25461713,25460275,0,"<p>I propose you a small template to handle these kind of issues easily:  </p>

<pre><code>template &lt;typename T&gt;
class Buffer { 
    size_t sz;      // size
    T* addr;        // pointed
public: 
    Buffer(const T*source, size_t l) : sz(l), addr(new T[l]) { std::copy(source, source + l, addr);  }  // allocate and copy
    ~Buffer() { delete[]addr; }   // destroy memory 
    operator T* () { return addr; }  // convert to pointer
};
</code></pre>

<p>You may use your existing code almost as is:  </p>

<pre><code>Buffer&lt;char&gt; pDataToStore(pValueData, iMaxValueSize);  // create the automatic buffer
int iActualSiz = ProcessData(pDataToStore, iMaxValueSize);  // automatic use of pointer to buffer
cout &lt;&lt; ""modified copy: "" &lt;&lt; pDataToStore &lt;&lt; endl;
cout &lt;&lt; ""original:      "" &lt;&lt; pValueData &lt;&lt; endl;
</code></pre>

<p>The buffer will be automatically released once pDataToStore is no longer in scope. </p>

<p>If you have similar issues with <code>wchar_t</code> buffers or anything else, it will work as well.   </p>

<p>For explanations on the evil of casting away const, see my other answer </p>
",0
25483693,25483521,-1,"<p>You need a reference to a pointer. Try changing your signature to use <code>curl_accounts *&amp; tmp</code>, instead of <code>curl_accounts &amp;tmp</code>.</p>
",2
25712773,25712755,2,"<p>1) Figure out which UI framework suits your app/environment best, some examples include Qt, MFC or (might suffice for a simple window and progress bar control) plain win32 native APIs (assuming a Windows environment, GTK+ would be somewhat equivalent to the aforementioned libraries on a linux system). AFAIK allegro does not provide UI APIs but it's a graphics / image manipulation library. You could of course render your own controls with allegro but that would be even harder</p>

<p>2) Create a UI window with the progress bar control and put it into a separate thread (still, on a Windows platform this is accomplished by having the window creation and message dispatching on a separate thread)</p>

<p>3) Synchronize your progress bar with your work and make sure the window is unloaded when the loading is complete (i.e. the thread is rejoined and terminated)</p>
",0
25712834,25712755,1,"<p>As @Piotr S. already mentioned, you need threads. (You need to write your program in a parallel form.)</p>

<p>The threading model would look like this:</p>

<p>Shared memory: <code>percentCounter</code></p>

<p>Thread 1: Loading the bitmaps and fonts, updating <code>percentCounter</code></p>

<p>Thread 2: Displaying the loading bar</p>

<p>I'm not sure whether Allegro provides some thread functions. (As, e.g. SFML does)
Otherwise, if you use at least <code>C++11</code>, you use <code>std::thread</code> from the C++ standard library.</p>

<p>If you only want to show that the App is loading (and not ""Not responding""), you could also write a simple ""Loading"" to the screen, just before or between loading the bitmaps.</p>
",0
31545089,31544965,3,"<p>_T is a macro used to handle literal strings either as UNICODE or ANSI strings depending on your project's settings. If you want to support both, you have to code your getStringFromFile() function accordingly by returning a std::wstring under your UNICODE build and calling the .c_str() method to pass the value to the CreateWindowEx function.</p>
",0
31545067,31544965,3,"<p>You cannot call the function within the <a href=""https://stackoverflow.com/questions/4133144/t-macro-changes-for-unicode-character-data""><code>_T</code> macro</a></p>

<p>That macro expands to (possibly) append the <code>L</code> to the string <strong>literal</strong>. Your function returns a <code>std::string</code>, so you cannot modify it as if it were a literal.</p>

<p>To be clear, that would be like having the function</p>

<pre><code>int foo()
{
    return 5;
}
</code></pre>

<p>And trying to call it as</p>

<pre><code>foo().0
</code></pre>

<p>This will obviously not convert your <code>int</code> to a <code>double</code> just because you added the <code>.0</code> which will specify a double literal</p>
",0
31545074,31544965,5,"<p>You cannot use <code>_T()</code> like this. It's a macro that applies the <code>L</code> suffix to string literals, not a function that can be applied to arbitrary expressions.</p>

<p>You should start with the wide-string versions of those library types, which is essentially the equivalent of what you are trying to hack in with the <code>_T()</code>:</p>

<ul>
<li><code>std::wifstream</code></li>
<li><code>std::wofstream</code></li>
<li><code>std::wstring</code></li>
</ul>

<p>It also seems likely, as you are calling a Windows API function, that you will have to obtain a pointer to the string data rather than trying to pass an actual C++ string object.</p>

<ul>
<li><code>getStringFromFile().c_str()</code></li>
</ul>

<p>This'll give you the <code>wchar_t const*</code> that you need though, to be honest, I'm not entirely sure whether it's safe to do this with a temporary. It depends on what the preconditions are for <code>CreateWindowEx</code>.</p>

<p>Safest approach, IMO:</p>

<pre><code>std::wstring getStringFromFile()
{
    std::wifstream in(""in.txt"");
    std::wofstream out(""out.txt"");
    std::wstring line;

    while (std::getline(in,line)) {
       if (line.empty())
          line = ""http://www.google.com/"";
    }

    return line;
}

// ...

const std::wstring str = getStringFromFile();
CreateWindowEx(0, _T(""EDIT""),
               str.c_str(),
               WS_CHILD | WS_VISIBLE | WS_BORDER,
               260, 10,
               200, 20,
               hWnd, NULL, hInst, NULL
);
</code></pre>

<p>As a further complication, the <code>_T()</code> macro <em>only</em> applies the <code>L</code> suffix to string literals when your program has <code>UNICODE</code> defined. If you wish to support both Unicode and non-Unicode modes, you'll need to switch back to the original <code>std::string</code> etc when <code>UNICODE</code> is not defined. That being said, I've been led to believe that disabling <code>UNICODE</code> is rare nowadays. Still, I'm no Windows dev&hellip;</p>
",2
25467047,25467024,0,"<p>The inner loop is wrong, there you have <code>j++</code> as the loop condition. And as in the first iteration <code>j</code> will be zero (which in C++ is the same as <code>false</code>) the loop will not iterate at all. Besides, the inner loop is missing a semicolon, so it shouldn't even compile.</p>
",0
25467083,25467024,2,"<p>This works for me in GCC 4.9.0 with C++11:</p>

<p>Sample Code:</p>

<pre><code>#include &lt;iostream&gt;

int main() {
    int board[9][9];
    for (int i = 0; i &lt; 9; i++) {
        for (int j = 0; j &lt; 9; j++) {
            std::cin &gt;&gt; board[i][j];
        }
    }

    for (int i = 0; i &lt; 9; i++) {
        for (int j = 0; j &lt; 9; j++) {
            std::cout &lt;&lt; board[i][j];
        }
        std::cout &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

<p>You should change <code>C array</code> for <code>std::vector</code> or other container from <strong>STL</strong>, it provide a lot of benefice (automatic memory management, array bound check, etc...). If you could use C++11, the new range for loop is a big improvement too (syntactical and performance wise, it avoid error as off by one, incorrect bounds, etc...).</p>

<p>Here is a C++11 version:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    typedef std::vector&lt;int&gt; row_t;
    typedef std::vector&lt;row_t&gt; board_t;

    board_t board(9, row_t(9));
    for (auto&amp; row : board) {
        for (auto&amp; cell : row) {
            std::cin &gt;&gt; cell;
        }
    }

    for (const auto&amp; row : board) {
        for (auto cell : row) {
            std::cout &lt;&lt; cell;
        }
        std::cout &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
",2
28163333,28163303,3,"<p>The compiler is explicit : a reference member must be <em>initialized</em> in the member initialization list :</p>

<pre><code>Lexer::Lexer(std::istream&amp; inputstream) : input_stream(inputstream) {

}
</code></pre>
",0
26796500,26796462,0,"<p>You cannot access private members of a class directly outside member function of that class. That's the basic foundation of encapsulation.Although you can break encapsulation by using pointers.</p>

<p>Please put clarification as what your intention is?</p>
",1
26412415,26411919,0,"<p>One method is display all the characters, then a carriage return ('\r') and then reprint the line.<br>
This allows you to ""walk"" characters across.  <strong>This will only work on video terminals that do not advance a line upon receiving a CR.</strong>  </p>

<p>Another method would be to print 10 backspace characters, a space, then your 10 'c'.  This may not be as fast as the carriage return method above, but worth looking at.  </p>

<p>As others have said, you may want to look into a terminal library such as <em>ncurses</em>.  The library allows you to position the cursor on the screen, based on the terminal type.  This may require setting up the console window to emulate a terminal.</p>
",0
30697998,30697941,5,"<blockquote>
  <p>Why does the commenting/uncommenting lead to returning weird results.</p>
</blockquote>

<p>Not returning anything gives you undefined behavior:</p>

<blockquote>
<pre><code>6.6.3  The return statement                              [stmt.return]

...

Flowing off the end of a function is equivalent to a return with no value;
this results in undefined behavior in a value-returning function.
</code></pre>
</blockquote>
",1
25510029,25509834,1,"<p>About your commented line:</p>

<pre><code>*ptrX = *ptrY;    //LINE
</code></pre>

<p>In plain English it means:</p>

<p><em>Put the value of the memory location pointed to by ptrY into the memory location pointed to by ptrX.</em></p>
",0
25509861,25509834,7,"<blockquote>
  <p>I think its swapping the ""data"" instead of swapping the ""pointers"".</p>
</blockquote>

<p>You are correct.</p>

<blockquote>
  <p>I want to swap pointers without reference passing the pointers in the function.</p>
</blockquote>

<p>That's impossible.  Unless you pass by reference, changes made inside the function will not be seen by the caller.</p>
",3
25509938,25509834,2,"<ol>
<li><pre><code>template&lt;typename T&gt;
void swap(T &amp;a, T &amp;b){
    T backup=a;
    a=b;
    b=backup;
}
</code></pre></li>
<li><p><code>*ptrX = *ptrY;</code> means <em>variable, to which points <code>ptrX</code>, have to have same value as variable to which points <code>ptrY</code>.</em></p></li>
</ol>
",1
29195921,29195443,0,"<p>so I put a bit of code around your function.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

using namespace std;

void chk_ac_num(string &amp;ac_num, string a_num[], int cnt)
{
    // Declare variables
    int check=0;
    // Checking for 8 digit
    do
    {
        cout&lt;&lt;""Enter Desired Account Number (8 Digit):""&lt;&lt;endl;
        getline(cin, ac_num);
        check=ac_num.length();
        if(check==8)
        {
            for(int i=0;i&lt;cnt;i++)
            {
                if(ac_num==a_num[i]) // Checking same account number existed or not
                {
                    check=1;
                    cout&lt;&lt;""Account Number already exist, please enter another desired number !""&lt;&lt;endl;  // Same account number detected
                    break;
                }                }
            }
        }
        else
            if(check==0)
                system(""cls"");
            else
                cout&lt;&lt;""Please enter 8 digit number !""&lt;&lt;endl;
    }while(check!=8); // Loop it when the account number is existed or not valid
}

int main()
{
string acnum = ""12345678"";
string acnumarray[4] = (""12345670"", ""23456679"", ""98764432"", ""56565656"");
chk_ac_num(acnum, acnumarray, 4);

return 0;
}
</code></pre>

<p>It compiles fine for me under g++. I would suggest using curly bracket in your else block to prevent accidental behavior if you ever decide to expand those control blocks to be more than a single line long.  </p>

<p>edited to fix. Parens != Curly Brackets.</p>
",4
25516496,25516453,1,"<p>You have to declare the operator before its usage in the structure.</p>
",1
25516514,25516453,4,"<p>A friend declaration can only introduce a name into the immediately surrounding namespace.</p>

<p>If you want to befriend a function in any other namespace, then you'll need to declare that function, in its namespace, before the friend declaration. As the error message says.</p>

<p>In this case, you probably want the operator to be in <code>inner</code> rather than the global namespace. Argument-dependent lookup will still find it in an expression like <code>test_a + test_b</code>, even if it's not otherwise in scope.</p>
",0
25702447,25702308,0,"<p>Hint. Why don't you split the string in token? Then countdown every time there is a word as Mrs., Mr. ect..</p>

<p>Or replacing special words with white space then counting without problem.</p>

<pre class=""lang-cpp prettyprint-override""><code>std::string RemoveWords(const std::string&amp; source, const std::string&amp; chars) {
    std::string result="""";
    for (unsigned int i=0; i&lt;source.length(); i++) {
      bool foundany=false;
      for (unsigned int j=0; j&lt;chars.length() &amp;&amp; !foundany; j++) {
        foundany=(source[i]==chars[j]);
      }
      if (!foundany) {
        result+=source[i];
      }
    }
   return result;
}

int number_of_sentences = 0;
text = RemoveWords(text);
for(unsigned int i=0; i &lt;= text.length()-1; i++){
  if(text[i] == '.' || text[i] == '?' ||text[i] == '!'){
  ++number_of_sentences;
  }
}
return number_of_sentences;
</code></pre>

<p>The above solution will omit every character passed in the second argument string. For example:</p>

<pre><code>std::string result=RemoveWords(""Mrs. Rease will play to football. ByeBye"", ""Mrs."");
</code></pre>
",1
25702391,25702308,5,"<p>You can't do it. You would need a full natural language parser to handle it with any accuracy.</p>
<p>Discarding the words you mention won't solve the problem. Consider:</p>
<blockquote>
<p>I am impressed by that PhD. James was awarded.</p>
<p>I am impressed by that PhD. James was awarded it in 2001.</p>
</blockquote>
<p>It is only your understanding of the semantics of English that tells you that the first one is one sentence and the second one is two sentences. You wouldn't be able to tell the difference without thinking about the <em>meaning</em> of the words, though. You are trying to solve the problem at the purely syntactic level, but there isn't enough information in the text without considering semantics.</p>
<p>The best approximation would probably be to say that you get a new sentence whenever you get a &quot;.&quot;, &quot;!&quot; or &quot;?&quot; and the next word starts with a capital letter. But this would still be only approximately correct. It would get the first of these examples wrong, and the second one right.</p>
",1
25691604,25691524,1,"<p>Any reason you can't use <a href=""http://www.cplusplus.com/reference/istream/istream/get/"" rel=""nofollow""><code>int istream::get()</code></a> ?</p>

<p>It's a blocking call though. I'm sure there is a better way to do it, but the quickest hack I can think of is to spawn a thread (just before calling <code>get()</code>) that waits for 0.25 secs and then writes some 'timeout char' say 't' to teh stream.</p>
",4
25692620,25691524,1,"<p>You can use the <code>ncurses</code> library, putting the terminal in <code>cbreak()</code> (non-blocking) mode, and disabling input delay with <code>nodelay()</code>:</p>

<pre><code>WINDOW *window = initscr();
cbreak();
nodelay(window, TRUE);
</code></pre>

<p>Then the <code>getch()</code> function will not block, returning <code>ERR</code> if no character is ready, so you can poll it in a loop and <code>break</code> when your timeout has been reached.</p>

<p>However, this may also require that you use <code>ncurses</code> for screen output, which may be a dealbreaker.</p>
",0
27559911,27559836,0,"<p>Conversion operators help the programmer to convert one concrete type to another concrete type or primitive type implicity. Here is an example taken from <a href=""http://www.geeksforgeeks.org/advanced-c-conversion-operators/"" rel=""nofollow"">http://www.geeksforgeeks.org/advanced-c-conversion-operators/</a></p>

<p>The example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    // Default constructor
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i)
    {}

    // magnitude : usual function style
    double mag()
    {
        return getMag();
    }

    // magnitude : conversion operator
    operator double ()
    {
        return getMag();
    }

private:
    // class helper to get magnitude
    double getMag()
    {
        return sqrt(real * real + imag * imag);
    }
};

int main()
{
    // a Complex object
    Complex com(3.0, 4.0);

    // print magnitude
    cout &lt;&lt; com.mag() &lt;&lt; endl;
    // same can be done like this
    cout &lt;&lt; com &lt;&lt; endl;
}
</code></pre>
",0
26192066,26192020,2,"<pre><code>dp[i-1,j]
</code></pre>

<p>This does not access the element in the <code>i-1</code>th row and the <code>j</code>th column.</p>

<p>The expression inside the brackets is using the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a> which ignores <code>i-1</code> and evaluates to <code>j</code>.
So the expression is equivalent to <code>dp[j]</code>, which is certainly wrong; the array to which <code>dp[j]</code> refers cannot be converted to an <code>int</code>, and the above error message comes up because the compiler tried to decay the array to a pointer and convert that pointer to <code>int</code> (which of course doesn't work either).</p>

<p>You meant to write <code>dp[i-1][j]</code>.</p>
",0
26192073,26192020,2,"<p>The expression of form <code>[i,j]</code>, even though it looks similar to two-dimensional indexing (like in C# or Python), is unfortunately against intuition here: it uses the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a>. This operator will evaluate all expressions and return the result of the <em>last expression</em> as an ultimate result. So, effectively you are indexing your 2D array only once (<code>dp[i-1,j]</code> ~ <code>dp[j]</code>) which yields <code>int*</code> instead of <code>int</code>. </p>

<p>Use <code>dp[i-1][j]</code> instead.</p>
",0
26192033,26192020,5,"<p>Because of the declaration:</p>

<blockquote>
  <p>int dp[len1][len2];</p>
</blockquote>

<p><code>dp[i-1,j]</code> is an <em>array</em>, not an <em>element of the matrix</em>. (Here <code>comma operator</code> can be confusing, as <strong>@BartoszKP</strong> has explained.)</p>

<p>Perhaps</p>

<pre><code>minimu(dp[i-1,j]+1,dp[i,j-1]+1,dp[i-1][j-1]+k);
</code></pre>

<p>should be</p>

<pre><code>minimu(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+k);
//           ^          ^
</code></pre>

<p><strong>P.S.</strong> Please note that <code>int dp[len1][len2];</code> with non-const sizes is not valid according to C++ standard, as <strong>@Cheers and hth</strong> said.</p>
",0
25696111,25695787,0,"<p>This is a bit tricky, because as you should already know, floating-point numbers are often not exact, but rather some approximation of a number.  For example, <code>10.1</code> ends up as <code>10.09999...</code>.  A double has about 15 digits of precision, so 15 is the largest value your <code>sigfigs()</code> function could reasonably return.  And it will need to be overloaded for double and float, because of course float has only half as many digits of precision:</p>

<pre><code>int sigfigs(double x); // returns 1 to 15
int sigfigs(float x); // returns 1 to 7
</code></pre>

<p>Now there may be more clever mathematical ways to do this, but one idea is:</p>

<pre><code>int sigfigs(double x) {
  int mag = log10(fabs(x));
  double div = pow(10, mag);
  char str[20];
  int wrote = snprintf(str, sizeof(str), ""%.15g"", x/div);
  return std::count_if(str, str + wrote, isdigit);
}
</code></pre>

<p>This is definitely missing some cases, but I think captures the idea: we first normalize large/small numbers so that we end up with something close to 1, then we print it with a suitable format string to allow the maximum usable precision to be displayed, then we count how many digits there are.</p>

<p>There are notable boundary-condition bugs at <code>0</code>, <code>10</code>, etc., which are left as an exercise to correct.  Serendipitously, NAN produces 0 which is good; +/- infinity also produce 0.</p>

<p>One final note; this does not strictly conform to the usual definition of significant figures.  In particular, trailing zeros after a decimal place are not accounted for, because there is no way to do so given only a <code>double</code> or <code>float</code>.  For example, textual inputs of <code>10</code> and <code>10.00000</code> produce bitwise-identical results from <code>atof()</code>.  Therefore, if you need a complete solution conforming to the academic definition of sigfigs, you will need to implement a user-defined type containing e.g. a double and an int for the sigfigs.  You can then implement all the arithmetic operators to carry the sigfigs throughout your calculations, following the usual rules.</p>
",0
25696411,25695787,0,"<p>Are you trying to determine the number of bits of precision in a floating point number or the number of <a href=""http://en.wikipedia.org/wiki/Significant_figures"" rel=""nofollow"">significant figures</a> in a variable?  C and C++ do not generally specify the format to be used for <code>float</code> and <code>double</code>, but if you know the floating point format in which the number is stored and processed, you can determine the number of bits of precision.  Most hardware these days uses <a href=""http://en.wikipedia.org/wiki/IEEE_floating_point"" rel=""nofollow"">IEEE 754</a> format.  Looking through the definition would be a good place to start.</p>

<p>Number of significant figures is an entirely different question.  Definition of significant figures includes a notion of how many figures are actually meaningful, as opposed to the number of figures available due to the floating point representation.  For example, if you sample a voltage with a 12-bit A/D converter (and good enough analog design that all the bits are significant) then the data that you read will have 12 significant bits, and storing it in a format with higher precision does not increase the number of significant figures.  For example, you store it in a 16-bit integer or a 32-bit IEEE 754 floating point number, depending on what you plan to do with the data.  In either case you still only have 12 significant bits, even though a 32-bit float has a 24-bit mantissa.</p>

<p>Goldberg's <a href=""http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html"" rel=""nofollow"">What Every Computer Scientist Should Now About Floating-Point Arithmetic</a> pretty thoroughly covers the issue if significant figures and floating-point arithmetic. </p>
",0
25701418,25701381,39,"<p>It forces the array to decay to a pointer, as indirectly stated in ¡ì5.3.1 [expr.unary.op]/7:</p>

<blockquote>
  <p>The operand of the unary + operator shall have arithmetic, unscoped enumeration, or pointer type and the
  result is the value of the argument. Integral promotion is performed on integral or enumeration operands.
  The type of the result is the type of the promoted operand.</p>
</blockquote>

<p>You might not see it at first, but since an array is not one of the types listed, it must be converted to a pointer in order to fit. From there, the value of the pointer is returned.</p>

<p>In both cases, a <code>foo(const char *)</code> would be chosen over a <code>foo(const char(&amp;)[N])</code>. For some examples of useful things you can use unary plus for, see <a href=""https://stackoverflow.com/a/3182557/962089"">this answer</a>. Included are converting an enum type to an integer and getting around a linking issue. As you say, it can also be used for integral promotion. For example, <code>unsigned char byte = getByte(); std::cout &lt;&lt; +byte;</code> will print the numerical value and never the character.</p>

<hr>

<p>A straightforward example is:</p>

<pre><code>char a[42];
cout &lt;&lt; sizeof(a) &lt;&lt; endl;  // prints 42
cout &lt;&lt; sizeof(+a) &lt;&lt; endl; // prints 4
</code></pre>
",6
25701422,25701381,23,"<p>Unary <code>+</code> is not only defined for numeric types, but also for pointer types. It is not defined, however, for arrays.</p>

<p>So, <code>foo(+c)</code> forces <code>c</code> to be converted to a pointer to its first element. If <code>foo</code> is a function defined as taking a <code>char *</code>, that wouldn't be necessary: it would already happen implicitly. It can matter when you have overloads (possibly via a template function), though.</p>
",0
25706864,25706671,0,"<p><code>test[0][i]=0;</code> got the indices the wrong way around - it should be <code>test[i][0]=0;</code> to be consistent with the line before, <code>test[i]</code>.</p>

<p>All your other reasoning is fine.</p>
",0
28181390,28181364,6,"<p>You forgot to initialize <code>decval</code> to 0. It probably contains an arbitrary value which messes up  your result.</p>
",2
28181504,28181364,4,"<p>This code:</p>

<pre><code>(c[i] - '0') * pow(10, k);
</code></pre>

<p>Converts an <strong>integral</strong> type to <strong>floating point</strong>, performs floating-point math, then converts back to an <strong>integral</strong> type.  (See <a href=""https://stackoverflow.com/questions/13774912"">this question</a>)</p>

<p>You absolutely risk rounding errors along the lines of 59.99999 getting rounded down to 59.</p>

<p>Adjusting your logic to only use integer math will fix it.</p>

<pre><code>int multiplier = 1;
for(i = 0; i &lt; c.length(); i++, multiplier *= 10){
    decval += (c[i] - '0') * multiplier;
    ++k;
} 
</code></pre>
",0
28181732,28181364,0,"<p>Both Drew and nicebyte are correct in what they have pointed out. Just wanted to add that you can do this without <code>k</code>, an extra <code>multiplier</code> variable, calling <code>pow()</code>, or rounding issues:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;

using namespace std;

int main(int argc, char **argv)
{
    string c;
    int decval = 0, i;
    cout &lt;&lt; ""Please input your number starting from lowest value number to highest"" &lt;&lt; endl;
    cin &gt;&gt; c;
    //the for loop takes a backwards integer and makes it forwards.
    for( i=c.size()-1 ; 0&lt;=i ; --i ) decval = c[i] - '0' + 10*decval;
    cout &lt;&lt; decval &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Explanation of <code>for</code> loop:</p>

<p>Take the number <code>4321</code> for example. Start at the end of the string, and work backwards. I.e.</p>

<ol>
<li>After first loop, <code>decval = 1</code>.</li>
<li>After second loop <code>decval = 12</code>.</li>
<li>After third loop, <code>decval = 123</code>.</li>
<li>After fourth loop, <code>decval = 1234</code>.</li>
</ol>

<p>Each time you are multiplying decval by 10, and adding the new digit. By doing it this way, you don't have to multiply by 10 the first time, 100 the second time, 1,000 the third time, etc.</p>
",2
28181853,28181364,1,"<p>This is also a solution and is pretty simple I think:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

int main(int argc, char **argv)
{
    string str;

    cout &lt;&lt; ""Please input your number starting from lowest value number to highest"" &lt;&lt; endl;
    cin &gt;&gt; str;

    reverse(str.begin(), str.end());

    int number = stoi(str);

    cout &lt;&lt; number &lt;&lt; endl;

    return 0;
}
</code></pre>
",0
30159206,30159179,0,"<pre><code>void operator++(int y)
</code></pre>

<p>is a convention used by the compiler to distinguish this <em>postfix</em>  operator from the <em>prefix</em> version</p>

<pre><code>void operator++()
</code></pre>

<p>In this case, the <code>y</code> is just a dummy variable, you can just leave the name out and define the postfix as <code>void operator++(int)</code></p>

<p>On the other hand</p>

<pre><code>int &amp;operator[](float i)
</code></pre>

<p>is a different operator, and the <code>float</code> here is used as a real parameter (there is no prefix/postfix <code>operator[]</code>).   </p>
",0
31867361,31867271,1,"<p>Maybe something like this would work for you?</p>

<pre><code>struct CrazyAlienTorso : Generic, Bipedal, Tripleheaded {
    vector&lt;Generic*&gt; GetSockets() {
        vector&lt;Generic*&gt; v1 = Bipedal::GetSockets();
        vector&lt;Generic*&gt; v2 = TripleHeaded::GetSockets();
        v1.insert(v1.end(), v2.begin(), v2.end());
        return v1;
    }
}
</code></pre>
",0
31867929,31867271,1,"<p>There is no way (as far as I know, though they might be working on one for a later version of C++) to enumerate all of the direct bases of a class. Aside from that, though, Kupiakos' answer should work well. If you need to do this sort of thing a bunch of times and have tons of base classes that you need to incorporate, you can do a bit of template metaprogramming to get a slightly cleaner shortcut:</p>

<pre><code>template &lt;typename Base, typename... OtherBases&gt;
struct socket_collector {
    template &lt;typename Derived&gt;
    static void add_sockets(Derived* obj, vector&lt;Generic*&gt;&amp; sockets) {
        socket_collector&lt;OtherBases...&gt;::add_sockets(obj, sockets);
        auto new_sockets = static_cast&lt;Base*&gt;(obj)-&gt;GetSockets();
        sockets.insert(end(sockets), begin(new_sockets), end(new_sockets));
    }
};
template &lt;typename Base&gt; struct socket_collector&lt;Base&gt; {
    template &lt;typename Derived&gt;
    static void add_sockets(Derived* obj, vector&lt;Generic*&gt;&amp; sockets) {
        auto new_sockets = static_cast&lt;Base*&gt;(obj)-&gt;GetSockets();
        sockets.insert(end(sockets), begin(new_sockets), end(new_sockets));
    }
};
template &lt;typename... Bases, typename Derived&gt;
vector&lt;Generic*&gt; collect_sockets(Derived* obj) {
    vector&lt;Generic*&gt; sockets;
    socket_collector&lt;Bases...&gt;::add_sockets(obj, sockets);
    return sockets;
}

//...

vector&lt;Generic*&gt; CrazyAlienTorso::GetSockets() {
    return collect_sockets&lt;Generic, Bipedal, TripleHeaded&gt;(this);
}
</code></pre>

<p>Of course, the main question is what the intended use of <code>GetSockets</code> is: depending on the task that you're trying to accomplish, there might be a better way to structure the code that doesn't involve as much problematic OOP.</p>
",1
26208420,26208232,3,"<p>According to the <a href=""http://msdn.microsoft.com/en-us/library/bdd5392d.aspx"" rel=""nofollow"">msdn documentation</a> ""An __asm block can call only global C++ functions that are not overloaded.""</p>

<p>One solution is to add a helper function that you can call from asm. Something like:</p>

<pre><code>bool equalCharPtr(char const *str)const { return *this == str; }
</code></pre>

<p>Of course this is only for Visual C++. Other compilers may vary.</p>
",0
26199463,26199331,0,"<p>It seems that you need to just display the grade for each student. For that,you could use <code>if...else</code> just after you display the <code>average</code> of each student.</p>

<pre><code>if(average&gt;=90)
grade='A';
if(average&lt;90 &amp;&amp; average &gt;=80 )
grade='B';
if(average&lt;80 &amp;&amp; average &gt;=70)
grade='C';
// and so on...then print:
cout&lt;&lt;""Grade=""&lt;&lt;grade&lt;&lt;endl;
</code></pre>
",0
26202145,26202113,1,"<p>u can take the input string, change it all to upper\lower case and then check if it is ""YES"" or ""yes"". </p>

<p>for each char in input: tolower(c)</p>
",0
26202207,26202113,0,"<p>An easy way to do this is to first convert the user input to lowercase letters. And then compare it with a lower case yes or no.</p>

<pre><code>#include &lt;iostream&gt;
// This header contains to tolower function to convert letters to lowercase
#include &lt;cctype&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    string user_input;
    cin &gt;&gt; user_input;

    // Loop over each letter and change it to lowercase
    for (string::iterator i = user_input.begin(); i &lt; user_input.end(); i++){
        *i = tolower(*i);
    }

    if (user_input == ""yes"") {
        cout &lt;&lt; ""You said yes"" &lt;&lt; endl;
    } else {
        cout &lt;&lt; ""You did not say yes"" &lt;&lt; endl;
    }
}
</code></pre>
",0
26202330,26202113,0,"<p>you can try this:</p>

<pre><code>int main(void) 
{

    string option;
    cin&gt;&gt;option;
    transform(option.begin(), option.end(), option.begin(), ::tolower);
    if(option.compare(""yes"")==0){
      cout&lt;&lt;option;
    }
     return 0;
}
</code></pre>
",0
26205258,26205159,0,"<p>You have to understand that array in C++ starts from 0. So ""d"" shoud be equal 3. Also check if X and Y are in range of an array. D is in ASCII under decimal number 97.  </p>

<pre><code>   unsigned int boardWidth = 10;
   unsigned int boardHeight = 10;
   int X;
   int Y;
   char mid;
   cout &lt;&lt; ""Input coordinates"";
   cin &gt;&gt; mid;
   cin &gt;&gt; Y;
   X = static_cast&lt;int&gt;(mid) - 97;
   if (X &lt; boardWidth &amp;&amp; Y &lt; boardHeigth &amp;&amp; X &gt; 0 &amp;&amp; Y &gt; 0) {
      cout &lt;&lt; board[X][Y];
   }
</code></pre>
",2
26205221,26205159,0,"<p>This should be enough to get you started:</p>

<pre><code>char c;
cin &gt;&gt; c;          # If this is the character 'd',
int n = c - 96;    # then this will be the number 4.
</code></pre>

<p>See, if a byte contains <code>01100100</code>, then if we interpret it as a <em>number</em>, it's 100, but if we interpret it as a <em>character</em>, it's 'd'.</p>
",1
26232072,26232031,1,"<p>You can't <em>assign</em> arrays like that, but you can <em>initialise</em> them:</p>

<pre><code> char interface[20] = ""USB01"";
</code></pre>

<p>In C++ though you should be using proper C++ strings, i.e. <code>std::string</code>, not C-style <code>char *</code> strings:</p>

<pre><code> std::string interface;

 interface = ""USB01"";
</code></pre>
",3
26232095,26232031,1,"<p>The C++ language does not allow you to assign to arrays.</p>

<p>You can, however, initialize arrays. The syntax is similar, but the assignment operator is used in the same statement as the declaration:</p>

<pre><code>char interface[20] = ""USB01"";
</code></pre>

<p>However, in C++, one would typically use a standard container like <code>std::string</code> rather than C strings. These are far easier to use and do allow for natural assignments.</p>

<pre><code>std::string interface;
....
interface = ""USB01"";
</code></pre>

<p>Note that we don't need to decide up front how much space to reserve for the string. This is just one of the many benefits of using the standard string class.</p>
",1
31538089,31531914,5,"<p>Consider following example.</p>

<pre><code>namespace Gandalf{

    namespace Frodo{
         bool static hasMyPrecious(){ // _ZN7Gandalf5FrodoL13hasMyPreciousEv
            return true;
        }
    };

    bool static hasMyPrecious(){ // _ZN7GandalfL13hasMyPreciousEv
        return true;
    }
};

namespace Sauron{
    bool static hasMyPrecious(){ // _ZN5SauronL13hasMyPreciousEv
        return true;
    }
};

bool hasMyPrecious(){ // _Z13hasMyPreciousv
    return true;
}

int main()
{
    if( Gandalf::Frodo::hasMyPrecious() || // _ZN7Gandalf5FrodoL13hasMyPreciousEv
        Gandalf::hasMyPrecious()        ||  // _ZN7GandalfL13hasMyPreciousEv
        Sauron::hasMyPrecious()          || // _ZN5SauronL13hasMyPreciousEv
        hasMyPrecious()) // _Z13hasMyPreciousv
        return 0;

    return 1;
}
</code></pre>

<p>As per namespace in which function is <strong>declared</strong>, compiler generates unique identity of each function called Mangled Name which is nothing but encoding of namespace scope in which function is defined, function name, return type and actual parameters.  see comments. As you create calls to this functions each function call looks for same mangled signature, if not found Compiler reports error.  </p>

<p>Try Experimenting with clang -emit-llvm -S -c main.cpp -o main.ll if you are interested in internal working.</p>
",4
32471241,32470803,2,"<p>I wouldn't use a <code>map</code> in this case. With only 256 values, a simple array occupies only 1 kilobyte (assuming 4 bytes for each count). Even though the input might be sparse, so some elements of that array go unused, at only 1 K, you're unlikely to gain anything by using a different structure.</p>

<p>Once you've done the counting, transforming to an array of structures you can sort by the counts is pretty easy (or, if you really only need the one with the largest count, just do a linear scan for that one).</p>
",0
32471309,32470803,1,"<p>Correct your code</p>

<pre><code>void CharStatistic(string filename) {
    ifstream infile(filename);
    if (!infile.is_open()) return;    // Check if file opened correctly
    char x;
    map&lt;char, int&gt; count;
    while (infile &gt;&gt; x) count[x]++;
    for (auto it : count)    // Pull this out of the while loop
        cout &lt;&lt; it.first &lt;&lt; "" "" &lt;&lt; it.second &lt;&lt; endl;
}
</code></pre>

<p>To find the max occurrence</p>

<pre><code>int max = *max_element(count.begin(), count.end(), count.value_comp());
</code></pre>
",2
32470888,32470803,1,"<ul>
<li>Don't print the values of map every time in your loop.</li>
<li>To print the highest frequencies in order, dump your map content to 'std::vector' of std::pair' and sort it with a comparator comparing values based on second element of pair.</li>
<li>Finally display the sorted vector.</li>
</ul>
",3
27129095,27125303,1,"<p>Yes you can use the technique.</p>

<p>Common way how dynamic polymorphism (virtual inheritance) is implemented in C++ is with hidden vtable pointer member. That member is then present in all objects that have virtual functions. It is most typically located at very beginning of object. </p>

<p>If a virtual function is called for object then the program calls a function from that pointed at vtable. So if you manage to overwrite the beginning of object with your data then you can make the vtable pointer to point anywhere else and achieve that something else is executed instead of a virtual member function.</p>

<p>It is impossible to use that exploit if the program has no permission to write to executable memory (or to execute writable memory) but that is not the case with majority of widespread operating systems.</p>
",0
29489284,29489214,3,"<p>The line</p>

<pre><code>std::vector&lt;Basefptr&gt; poli1;
</code></pre>

<p>Tells the vector to hold objects of type <code>Basefptr</code>. When you</p>

<pre><code>poli1.push_back(base1);
poli1.push_back(derivada1);
</code></pre>

<p>The vector is creating new objects with a <code>Basefptr</code> constructor, that it owns itself. These are not the objects you created. </p>
",1
26411773,26411658,0,"<p>Try</p>

<pre><code>for (int i = NUM_ELEMENTS - 1; i &gt; 21; i--)
     cout &lt;&lt; ""Value: "" &lt;&lt; sumVal &lt;&lt; endl;
</code></pre>

<p>to</p>

<pre><code>for (i = 0; i &lt; NUM_ELEMENTS; ++i) {

    if(userVals[i] &gt; 21)
        cout &lt;&lt; ""Value: "" &lt;&lt; userVals[i] &lt;&lt; endl;
}
</code></pre>

<p>This line isnt needed as well, as you arent using it.</p>

<pre><code>int prntSel = 0;            // For printing greater than 21
</code></pre>
",3
26411803,26411658,3,"<p>Don't reinvent the wheel, <a href=""http://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning"" rel=""nofollow"">use standard algorithms</a>:</p>

<pre><code>std::copy_if(std::begin(userVals), std::end(userVals),
             std::ostream_iterator&lt;int&gt;(std::cout, ""\n""),
             [] (auto x) { return x &gt; 21; });
</code></pre>

<p>I improved the rest of your program as well:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

auto constexpr count = 8;

int main() {
    std::vector&lt;int&gt; numbers(count);

    std::cout &lt;&lt; ""Enter "" &lt;&lt; count &lt;&lt; "" integer values...\n"";
    std::copy_n(std::istream_iterator&lt;int&gt;(std::cin), numbers.size(), numbers.begin());

    std::copy_if(numbers.begin(), numbers.end(),
                 std::ostream_iterator&lt;int&gt;(std::cout, ""\n""),
                 [] (auto x) { return x &gt; 21; });

    auto sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    std::cout &lt;&lt; ""Sum: "" &lt;&lt; sum &lt;&lt; '\n';

    return 0;
}
</code></pre>

<p>See it <a href=""http://coliru.stacked-crooked.com/a/028716d3f43c9341"" rel=""nofollow"">live on Coliru</a>!</p>
",1
26411835,26411658,0,"<pre><code>#include &lt;iostream&gt;
  using namespace std;

  int main() {
  const int NUM_ELEMENTS = 8; // Number of elements
  int userVals[NUM_ELEMENTS]; // User numbers
  int i = 0;                  // Loop index
  int sumVal = 0;             // For computing sum
  int prntSel = 0;            // For printing greater than 21

  // Prompt user to populate array
  cout &lt;&lt; ""Enter "" &lt;&lt; NUM_ELEMENTS &lt;&lt; "" integer values..."" &lt;&lt; endl;


  for (i = 0; i &lt; NUM_ELEMENTS; ++i) {
     cin &gt;&gt; userVals[i];
  }

//  for (int i = NUM_ELEMENTS - 1; i &gt; 21; i--)
//     cout &lt;&lt; ""Value: "" &lt;&lt; sumVal &lt;&lt; endl;

  for( i = 0; i &lt; NUM_ELEMENTS; ++i )
  {
      if( userVals[ i ] &gt; 21 )
      {
          cout &lt;&lt; ""Value: "" &lt;&lt; i &lt;&lt; "" is "" &lt;&lt; userVals[ i ] &lt;&lt; endl;
      }
  }

  for (i = 0; i &lt; NUM_ELEMENTS; ++i) {
     sumVal = sumVal + userVals[i];
  }

  cout &lt;&lt; ""Sum: "" &lt;&lt; sumVal &lt;&lt; endl;

  return 0;
}
</code></pre>
",0
26411879,26411658,0,"<pre><code>for (int i = NUM_ELEMENTS - 1; i &gt; 21; i--)
     cout &lt;&lt; ""Value: "" &lt;&lt; sumVal &lt;&lt; endl;
</code></pre>

<p>Here you are printing the value of <code>sumVal</code>, not the value of the array in the position <code>i</code>. The line should be:</p>

<pre><code>cout &lt;&lt; ""Value: "" &lt;&lt; usersVals[i] &lt;&lt; endl;
</code></pre>

<p>Also that that your <code>for</code> is not doing what you think it does. <code>for</code> doesn't use the  condition you gave to decide if will execute the current iteration or not, it uses the condition to decide if the loop should continue or not. So when you put <code>i &gt; 21</code>, means that it will continue running  while <code>i</code> is bigger than 21. To achieve your goal, you should make a test (<code>if</code> statement) inside the loop. </p>

<p>The final result it would be:</p>

<pre><code>for (i = 0; i &lt; NUM_ELEMENTS; ++i) {
     if (usersVals[i] &gt; 21) {
       cout &lt;&lt; ""Value: "" &lt;&lt; usersVals[i] &lt;&lt; endl;
    }
}
</code></pre>
",0
26411946,26411658,2,"<p>Ok, I'm going to explain this to you and keep it simple. This loop</p>

<pre><code>    `for (int i = NUM_ELEMENTS - 1; i &gt; 21; i--)`
</code></pre>

<p>will never execute because in your first iteration you are checking if (NUM_ELEMENTS-1=7)>21. You are then decrementing i so this will take the series (6,5,4,...) and nothing would ever happen here.</p>

<p>If you have to sum the numbers greater than 21, which I presume is what you need then you will have to remove the above loop and modify your second loop to:</p>

<pre><code>for (i = 0; i &lt; NUM_ELEMENTS; i++) {
 if(userVals[i]&gt;21)
 sumVal = sumVal + userVals[i];
}
</code></pre>

<p>This way, you add the numbers in the array that are only greater than 21. The index of userVals is determined by the i variable which also acts as a counter.</p>
",0
26412103,26411658,1,"<p>You're on the right track. There's just a few things wrong with your approach. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int main() {
    const int NUM_ELEMENTS = 8;
    int userVals[NUM_ELEMENTS];
    int i = 0;
    int sumVal = 0;
    int prntSel = 0;
    int size = sizeof(userVals) / sizeof(int); // Get size of your array
                                               // 32/4 = 8 (ints are 4 bytes)
    cout &lt;&lt; ""Enter "" &lt;&lt; NUM_ELEMENTS &lt;&lt; "" integer values..."" &lt;&lt; endl;


    for (i = 0; i &lt; NUM_ELEMENTS; ++i) {
        cin &gt;&gt; userVals[i];
    }

    for(int i = 0; i &lt; size; i++) {
        if(userVals[i] &gt; 21) { // Is number &gt; 21?
            cout &lt;&lt; userVals[i] &lt;&lt; endl; // If so, print said number
            exit(0); // And exit
        }
        else
            sumVal += userVals[i]; // Else sum your values
    }

    cout &lt;&lt; ""Sum: "" &lt;&lt; sumVal &lt;&lt; endl;

    return 0;
}
</code></pre>
",0
30179506,30178322,1,"<p>With the code commented as you have it, turn() keeps calling itself with increasing values of x until you get to turn(8).</p>

<p>At that point, i gets set to '2' and j gets set to '2'.  Then, you call boardSwitch(2,2).</p>

<p>Your problem happens in boardSwitch().  Your for() loop keeps going until both i and j are equal to 3, ultimately resulting in a write to board[3][3].  This location doesn't exist, so you are just writing off the end of the variable -- at that point, anything could get clobbered.  In your case, cnt is getting overwritten.</p>

<p>The main point is that there is nothing to prevent you from writing off the end of an array in c/c++.  You just start writing to memory that isn't what you thought it was, and the program begins to behave unpredictably.</p>

<p>Ultimately you need to fix your logic.  One thing you might try in the meantime is creating a function to wrap writes to the array and perform bounds checking for you.  For example:</p>

<pre><code>    void writeToBoard(int i, int j, int value) {
        if (i &gt;= BOARDSIZE) {
            printf(""ERROR: Attempted to write outside array.\n"");
            return;
        } else if(j &gt;= BOARDSIZE) {
            printf(""ERROR: Attempted to write outside array.\n"");
            return;
        } else {
             board[i][j] = value;
        }             
    }
</code></pre>

<p>Then replace ALL writes to the array with calls to this function.</p>

<p>This would catch the problem when it happens in an easier to debug way.</p>

<p>Wrapping the board in an object, making that object private, and exposing this sort of thing as a member function is an excellent example of encapsulation.</p>

<p>An even better solution is to use standard library containers that do this thing for you (efficiently).  That isn't always an option, and it's good to know conceptually how this sort of thing works.  As a rule, though, there is very rarely a reason to implement your own bounds checked array.  That's why we have the standard library.</p>
",0
30697024,30695417,1,"<p>Yes, IMO, using numbers to represent Boolean values is poor programming practice.  </p>

<p>The practice is an ancient one for languages that don't have a Boolean type.  </p>

<p>A Boolean data type will help prevent issues where the program may be passing other values than 1 for <em>true</em> and a comparison is made for 1 rather than <em>not zero</em>.  </p>

<p>So comply with legacy code, if you must.  Promote the Boolean type and you will be rewarded (with fewer defects in your code).  </p>
",0
26802186,26800437,0,"<p>What I can understand from your question is that you want to reverse an array.</p>

<p>In the while loop within your code, you are trying to access the arr_exch array with index -1 which is causing the segmentation fault error.</p>

<p>You can try the below code which is working fine.</p>

<pre><code>#include &lt;iostream&gt;

const int length = 3;
// exch1() is another way for reversing a array.
void exch1(int arr_exch[]) {
    for (int i = 0; i &lt; length/2; i++) {
        int temp = arr_exch[i];

        arr_exch[i] = arr_exch[length - i - 1];
        arr_exch[length - i - 1] = temp;
    }
}
void exch(int arr_exch[]){
    int tmp = 0;
    int s = 0;
    int e = length - 1;

    while (e &gt; s){  
        tmp = arr_exch[s];
        arr_exch[s] = arr_exch[e];
        arr_exch[e] = tmp;
        s = s + 1;
        e = e - 1;
    }
}

int main()
{
    int arr[length];

    std::cout &lt;&lt; ""enter ""&lt;&lt; length &lt;&lt;"" integers:\n"";
    for (int counter = 0; counter &lt; length; counter++){
        std::cin &gt;&gt; arr[counter];
    }
    exch(arr);   //**&lt;--- here the error ""expected primary expression before ']' token.**
    for (int counter = 0; counter &lt; length; counter++){
        std::cout &lt;&lt; arr[counter] &lt;&lt; ""\t"";
    }
    return 0;
}
</code></pre>
",0
26800493,26800437,0,"<p>This a bit puzzle to me your code is not even compiling and you got segmentation fault. How come?</p>

<p>Anyway change this </p>

<pre><code>exch (arr[]);
</code></pre>

<p>to</p>

<pre><code>exch (arr);
</code></pre>

<p>You generally get segmentation fault while accessing invalid memory OR memory you are not allowed to access and this can only happen when you execute your code that means after successfully compiling your code.</p>
",0
28482031,28478915,0,"<p>You can't replace characters in string. What you should do is to use std::string as std::vector&lt; char > (because it's really similar).</p>

<p>You can assign letters to some place in your word:</p>

<blockquote>
  <p>word[2] = yourLetter;</p>
</blockquote>

<p>You dont even need to know what was in that place before, so you don't need to replace it - assigning is easier.</p>
",1
29456492,29455738,0,"<p>It's a member function, so the syntax for taking a pointer is</p>

<pre><code>&amp;Player::in_lock_range
</code></pre>

<p>This is only usable if it's a static member, since it must be callable with just a single argument. I'm guessing it isn't - presumably <code>mouseTarget</code> is a non-static data member of <code>Player</code>. In that case, you'll have to bind it to some player object:</p>

<pre><code>bind(&amp;Player::in_lock_range, std::ref(some_player), std::placeholders::_1)
</code></pre>

<p>or wrap it in a lambda:</p>

<pre><code>[&amp;](const Enemy&amp; e){return some_player.in_lock_range(e);}
</code></pre>

<p>The function should probably take its argument by constant reference rather than value; and you might want to simplify the return statements</p>

<pre><code>if (whatever) return true;
else return false;
</code></pre>

<p>to the more readable</p>

<pre><code>return whatever;
</code></pre>
",0
32957199,32957107,0,"<p>It¡¯s a non-member function, because the scalar is on the left. (<a href=""http://en.cppreference.com/w/cpp/numeric/complex/operator_arith3"" rel=""nofollow"">http://en.cppreference.com/w/cpp/numeric/complex/operator_arith3</a>).  You can cast the integer to double or <code>j.value_type</code>.</p>
",0
32957207,32957107,2,"<p>From <a href=""http://en.cppreference.com/w/"" rel=""nofollow"">cppreference</a> the overloads for <a href=""http://en.cppreference.com/w/cpp/numeric/complex/operator_arith3"" rel=""nofollow""><code>std::complex::operator+</code></a> are</p>

<pre><code>template&lt; class T &gt;
complex&lt;T&gt; operator+( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);

template&lt; class T &gt;
complex&lt;T&gt; operator+( const complex&lt;T&gt;&amp; lhs, const T&amp; rhs);

template&lt; class T &gt;
complex&lt;T&gt; operator+( const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);
</code></pre>

<p>When type deduction happens there is a conflict as it evaluates <code>T</code> to a <code>double</code> and an <code>int</code>.  Since <code>T</code> cannot be both it generates an error.</p>
",0
27494598,27494403,1,"<p>You are defined an ARRAY of 1000 pointers of InifitalInfo, but InitialInfo[0] never has been initialized.</p>

<p>Try this:</p>

<p><strong>Array of Objects</strong></p>

<pre><code>InitialInfo InfoBuckets[ARRAY_SIZE];

...

void Graph::InitialInsert(string source, string destination, int distance, int price, int index)
{
   InfoBuckets[index].sourceCity = source; 
   InfoBuckets[index].destinationCity = destination; 
   InfoBuckets[index].miles = distance; 
   InfoBuckets[index].cost = price; 
}   
</code></pre>

<p>or</p>

<p><strong>Array of pointers</strong></p>

<pre><code>InitialInfo *InfoBuckets[ARRAY_SIZE];

...

InfoBuckets[0] = new InitialInfo(); // You need create the object first before using

...

void Graph::InitialInsert(string source, string destination, int distance, int price, int index)
{
   InfoBuckets[index]-&gt;sourceCity = source; 
   InfoBuckets[index]-&gt;destinationCity = destination; 
   InfoBuckets[index]-&gt;miles = distance; 
   InfoBuckets[index]-&gt;cost = price; 
}
</code></pre>

<p>As @Roddy recomends, you must use smart pointers instead of new operators. You can read about in this <a href=""https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one"">link</a> .</p>
",4
31241035,31240981,4,"<p>You could use an array of pointers : </p>

<pre><code>Foo *array[10]; // array of 10 Foo pointers
</code></pre>

<p>It depends a lot on what you want to do though.</p>
",0
31241155,31240981,0,"<p>You could use an array of pointers, or even better, a <code>vector</code> of <em>smart pointers</em>:</p>

<pre><code>using namespace std;
class MyClass
{
    public:
        MyClass() {}
        void foo() {}
    ....
};
vector&lt;shared_ptr&lt;MyClass&gt;&gt; V;
V.push_back(make_shared&lt;MyClass&gt;());
V[0]-&gt;foo();
</code></pre>
",0
31241262,31240981,0,"<p>You can use <code>std::reference_wrapper</code> declared in header <code>&lt;functional&gt;</code>.
Here is a demonstrative program:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;

int main()
{
    int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; v( std::begin( a ), std::end( a ) );

    for ( int x : v ) std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; std::endl;

    std::for_each( v.begin(), v.end(), []( auto &amp;r ){ r.get() *= 2; } );

    for ( int x : a ) std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; std::endl;

    std::sort( v.begin(), v.end(), std::greater&lt;int&gt;() );

    for ( int x : v ) std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; std::endl;

    for ( int x : a ) std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>The program output is</p>

<pre><code>1 2 3 4 5 6 7 8 9 
2 4 6 8 10 12 14 16 18 
18 16 14 12 10 8 6 4 2 
2 4 6 8 10 12 14 16 18 
</code></pre>
",0
31307846,31307800,3,"<p>There are two ways that I can think of:</p>

<ol>
<li><p>Use a converting constructor.</p>

<pre><code>Length(float val);
</code></pre></li>
<li><p>Use an overloaded assignment operator.</p>

<pre><code>Length&amp; operator=(float val);
</code></pre></li>
</ol>

<p>If you add the converting constructor, you won't need the assignment operator.</p>
",0
31118387,31117830,1,"<p>Well, 'manual' recursion. </p>

<p>Following there is an idea for recursion. What is missing is file detection based on extension.</p>

<pre><code>void file_search_rec(const char *folder)
{
    char path[MAX_PATH] ;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;

    strcpy(path, folder) ;
    strcat(path, ""\\*"") ;
    FindFirstFile(path, &amp;FindFileData) ;
    if (FindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)
    {
        char subpath[MAX_PATH] ;
        strcpy(subpath, folder) ;
        strcat(subpath, FindFileData.cFileName) ;
        // here make the recursive call on subpath
        file_search_rec(subpath) ;
    }
}
</code></pre>
",4
28489888,28489828,3,"<p>In class Vect.h class Vect should contain</p>

<p><code>public:</code></p>

<p>instead of</p>

<p><code>Public:</code></p>

<p>C++ isn't known for it's case insensitivity...</p>
",0
28192738,28192009,0,"<p>As it is, <code>sock_val</code> doesn't change after you called your <code>Sock()</code> function. You should return <code>sock_val</code> or pass it by reference:</p>

<pre><code>int Sock()
{
    sock_val=socket(PF_INET,SOCK_STREAM,0);
    if (sock_val ==-1)
    {
        Error(""Starting Socket failed"");
        return -1;
    }
    else
    {
        printf(""Socket started"");
        return sock_val
    }
}
</code></pre>

<p>And it is the same for your <code>Bind()</code> function:</p>

<pre><code>int Bind(int sock_val, struct sockaddr *adress)
{
    bind_val=bind(sock_val,adress,sizeof(*adress));
    if (bind_val ==-1)
    {
       Error(""\nbind() failed"");
       return -1;
    }
    else
    {
       printf(""\nbind() succsesfull"");
       return bind_val;
    }
}
</code></pre>

<p>And then, use your functions as below:</p>

<pre><code>int sock_val = Sock();
if (sock_val != -1)
    int bind_val = Bind(sock_val, struct sockaddr *adress);
</code></pre>
",2
28201254,28201074,0,"<p>One thing I see is your class member <code>int bArray[80][24]</code> is being iterated through loops:</p>

<pre><code>for (int i = 0,x = 0; i &lt;= 80; i++, x++)
{
    for (int o = 0; o &lt;= 24; o++, x++)
    {
        p[x] = bArray[i][o];
    }
}
</code></pre>

<p>The problem with this is you're iterating through the loops 81 and 25 times respectively due to the &lt;= operands. This will index outside of your double array.</p>

<p>EDIT: This also means x is being iterated too many times considering the line:</p>

<p><code>int *p = new int[1920];</code></p>
",2
34202831,34202709,2,"<p>Use the <a href=""http://www.asciitable.com/"" rel=""nofollow"">ASCII table</a> to find the code of these characters.</p>
",4
30702879,30702759,3,"<p>Your code will block on <code>while(true)</code>. Please consider using <a href=""http://fr.cppreference.com/w/cpp/chrono"" rel=""nofollow"">std::chrono</a>.</p>

<pre><code>void game()
{
   int s = 0 , m = 0;
   char a[]=""Computers"";
   char b[10];
   auto start = chrono::steady_clock::now();
   while (strcmpi(a,b)!=0)
   {
      cout&lt;&lt;""Guess the word:"";
      gets(b);
   }
   auto time_elapsed = chrono::steady_clock::now() - start;
   cout&lt;&lt;""You got it correct!\n"";
   cout&lt;&lt;""Time taken : "" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;
                         (time_elapsed ).count() &lt;&lt; "" s""&lt;&lt;endl;
}
</code></pre>
",1
30702945,30702759,3,"<p>If all you want is the time taken, chuck your timer. Ask what time it is when the user starts, store it, and subtract the start time from the time when the user finishes.</p>

<pre><code>void game()
{
   int s = 0 , m = 0;
   char a[]=""Computers"";
   char b[10];
   time_t start = time(NULL); &lt;&lt;&lt;&lt; Modification here
   while (strcmpi(a,b)!=0)
   {
      cout&lt;&lt;""Guess the word:"";
      gets(b);
   }
   cout&lt;&lt;""You got it correct!\n"";
   time _t taken = time(NULL) - start;
   m = taken / 60; &lt;&lt;&lt;&lt; Modification here
   s = taken % 60; &lt;&lt;&lt;&lt; Modification here
   cout&lt;&lt;""Time taken : ""&lt;&lt; m &lt;&lt;':'&lt;&lt;s&lt;&lt;endl;
}
</code></pre>

<p>If allowed by the assignment, consider replacing <code>char</code>s a and b with <code>string</code>s a and b. The user cannot overflow the string and wreak havoc on your program the way they can with char arrays and <code>gets</code>.</p>

<pre><code>void game()
{
   int s = 0 , m = 0;
   std::string a =""Computers""; &lt;&lt;&lt;&lt; Modification here
   std::string b; &lt;&lt;&lt;&lt; Modification here
   time_t start = time(NULL); 
   do
   {
      cout&lt;&lt;""Guess the word:"";
      cin&gt;&gt; b; &lt;&lt;&lt;&lt; Modification here
   } while (a != b); &lt;&lt;&lt;&lt; Modification here. No sense testing b before you read b
   cout&lt;&lt;""You got it correct!\n"";
   time _t taken = time(NULL) - start;
   m = taken / 60; 
   s = taken % 60; 
   cout&lt;&lt;""Time taken : ""&lt;&lt; m &lt;&lt;':'&lt;&lt;s&lt;&lt;endl;
}
</code></pre>
",3
30703012,30702759,1,"<p>You can use the time.h header file to measure time elapsed.Your code can b like this:</p>

<pre><code>#include&lt;time.h&gt;
void game()
{ 
 int s = 0 , m = 0;
 char a[]=""Computers"";
 char b[10];
 clock_t start, end;
 double time_used;
// timer(s,m,true);  comment out this line
 start = clock();
 while (strcmpi(a,b)!=0)
  {
  cout&lt;&lt;""Guess the word:"";
  gets(b);
  }
  end = clock();
 time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
 timer(s,m,false);
 cout&lt;&lt;""You got it correct!\n"";
 cout&lt;&lt;""Time taken : ""&lt;&lt;time_used&lt;&lt;"" seconds""&lt;&lt;endl;
</code></pre>

<p>}</p>

<p>For more information on time.h header file see this <a href=""http://www.tutorialspoint.com/c_standard_library/time_h.htm"" rel=""nofollow"">link</a></p>
",0
30703164,30702759,9,"<p>You can use the chrono functions:</p>

<pre><code>#include &lt;chrono&gt;

using namespace chrono;

auto a = high_resolution_clock::now();

... what you want to measure ...

auto b = high_resolution_clock::now();

cout &lt;&lt; ""took "" &lt;&lt; duration_cast&lt;seconds&gt;(b - a).count() &lt;&lt; &lt;&lt; "" seconds"" &lt;&lt;  endl;
</code></pre>
",2
28172689,28040728,1,"<p>Another possible answer for this question</p>

<pre><code>string expense = """", date = """", type = """";
double amount = 0.0;
ofstream outfile; 
outfile.open (""Expense.txt"", std::ios_base::app);
if (!outfile)
{
cout &lt;&lt; ""File open fail"" &lt;&lt; endl;
exit(-1);
}
cout &lt;&lt; ""Please Enter Expense: "";
cin.ignore();
getline(cin, expense);
cin.clear();
cout &lt;&lt; ""Amount: "" &lt;&lt; endl;
cin &gt;&gt; amount;      
cin.clear();
cout &lt;&lt; ""Transaction Date: "" &lt;&lt; endl;
cin.ignore(100,'\n');
getline (cin, date);
outfile &lt;&lt; expense &lt;&lt; "":"" &lt;&lt; amount &lt;&lt; "":"" &lt;&lt; date &lt;&lt; ""\n"";
</code></pre>
",0
28172502,28135259,1,"<p>This will help your question... This code generates all positive value and negative value , if you want it to be specific, remove either totalPositive or totalNegative to suit your requirement</p>

<pre><code>std::ifstream file(""Expense.txt"");
std::string line;
double totalNegative = 0;
double totalPositive = 0;
while(std::getline(file, line))
{
    std::stringstream linestream(line);
    std::string data1;
    double data2;
    std::string data3;

    getline(linestream, data1, ':');
    linestream &gt;&gt; data2;

    if (data2 &gt; 0)
        totalPositive += data2;
    else
        totalNegative =- data2;
</code></pre>
",0
33571472,33571341,3,"<p>In the first example d3 is only in scope between the brackets. After the brackets are over it goes out of scope and thus does not display. Take a look at the concept of RAII and the associated concept of constructors and destructors.</p>

<p>P.S. We like to try and get a minimal example most of what you have is a bit noisy.</p>
",1
29463550,29463326,0,"<p>Of course it is not working.</p>

<p>At best, the behaviour is undefined, since <code>Arg()</code> is returning the address of a local variable <code>(arg)</code> that no longer exists for <code>main()</code>.   <code>main()</code> uses that returned address when it is not the address of anything that exists as far as your program is concerned.</p>

<p>There is also the incidental problem that <code>int arg[size]</code>, where <code>size</code> is not fixed at compile time, is not valid C++.  Depending on how exacting your compiler is (some C++ compilers reject constructs that are not valid C++, but others accept extensions like this) your code will not even compile successfully.</p>

<p>To fix the problem, have your function return a <code>std::vector&lt;int&gt;</code>  (<code>vector</code> is templated container defined in the standard header <code>&lt;vector&gt;</code>).   Then all your function needs to do is add the values to a local vector, which CAN be returned safely by value to the caller.</p>

<p>If you do it right, you won't even need to use a pointer anywhere in your code.</p>
",0
29463379,29463326,1,"<p>The problem is you are putting your result into a local array that is destroyed when the function ends. You need to dynamicaly allocate the array so that its life-span is not limited to the function it was created in:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int *Arr(int y, int size)
{
    // This local array will be destroyed when the function ends
    // int arg[size];

    // Do this instead: allocate non-local memory
    int* arg = new int[size];

    for(int i = size - 1; i &gt;= 0; i--)
    {
        arg[i] = y % 10;
        y = y / 10;
    }
    return arg;
}

int main()
{
    int *p = Arr(2587, 4);
    for(int j = 0; j &lt; 4; j++)
    {
        cout &lt;&lt; p[j] &lt;&lt; ""   "";
    }

    // You need to manually free the non-local memory
    delete[] p; // free memory

    return 0;
}
</code></pre>

<p><strong>NOTE:</strong></p>

<p>Allocating dynamic memory using <code>new</code> is to be avoided if possible. You may want to study up on <strong>smart pointers</strong> for managing it. </p>

<p>Also, in real <code>C++</code> code, you would use a container like <code>std::vector&lt;int&gt;</code> rather than a builtin array</p>
",5
28232044,28231754,0,"<p>Better do it in one loop:</p>

<pre><code>do {
    ch = getchar();
    int newnumber = 0;
    cout &lt;&lt; ""element("" &lt;&lt; i &lt;&lt; "") = "";
    cin &gt;&gt; newnumber;
    numbers.push_back(newnumber);
} while (Isnumber(ch)); // should probably be isdigit(ch)
</code></pre>

<p>And before asking similar questions read <a href=""http://www.cprogramming.com/tutorial/c++-tutorial.html"" rel=""nofollow noreferrer"">this</a> first (or buy a <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list#answers"">book</a>).</p>
",0
28231861,28231754,1,"<p>change this <strong><code>while (Isnumber(ch)){</code></strong>  into do-while loop.</p>

<pre><code>do{
  .....
}while (Isnumber(ch))
</code></pre>

<p>The error is because <strong>ch is declared and it is used before initialized</strong>. </p>

<p>Also include <code>#include &lt;stdio.h&gt;; for getchar();</code></p>
",7
28232802,28231754,0,"<p>Well I solved it using cin functions as below,</p>

<pre><code>#include ""stdafx.h""
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

int main(){
    vector&lt;int&gt; numbers(0);
    cout &lt;&lt; ""please enter you numbers :::\n''entering any characters but numbers is the end of entry''\n"";
    //char ch;
    int counter = 0;    
        do{         
            int newnumber = 0;
            cout &lt;&lt; ""element("" &lt;&lt; counter &lt;&lt; "") = "";
            counter++;
            cin &gt;&gt; newnumber;
            numbers.push_back(newnumber);
            if (cin.fail()){
                cout &lt;&lt; ""entered numbers are:\n"";
                for (vector&lt;int&gt;::iterator i = numbers.begin(); i != numbers.end(); i++)
                {
                    cout &lt;&lt; *i;
                    if (i != numbers.end()-1)cout &lt;&lt; "" - "";
                }               
            }
        } while (cin.good());
        getchar();
}
</code></pre>

<p>I removed one while loop.
and used cin.fail and cin.good to avoid using IsNumber. And it worked.</p>
",3
28224123,28218115,0,"<p>If you add an A or W suffix on these Windows API's, you must do so consistently: <code>STARTUPINFO</code> goes with <code>CreateProcess</code>, <code>STARTUPINFOA</code> with <code>CreateProcessA</code> and <code>STARTUPINFOW</code> with <code>CreateProcessW</code>.</p>

<p>The difference is what type of string you need, <code>""""</code> (A) or <code>L""""</code> (W). The versions without suffix are macros that expand to either A or W depending on compilation settings.</p>
",0
28249967,28249833,1,"<p>If you're passing a 2-D array to function <code>determ()</code> as</p>

<pre><code>int a[MAX][MAX];
determ(a, int n);
</code></pre>

<p>the function declaration should be:</p>

<pre><code>determ(int a[][MAX], int n) { .. }
</code></pre>

<p>In the above declaration number of rows need not be specified as we are not allocating the memory for the array hence can be ignored. Number of columns is required for the dimension of the array. </p>
",9
28249976,28249833,0,"<p>There is two ways:</p>

<p>1) Declare your function as is: </p>

<pre><code>int determ(int** a, int size, int n) {...} // 'size' aka 'MAX'
</code></pre>

<p>2) Use dynamic container such as std::vector:</p>

<pre><code>int determ(const vector&lt;vector&lt;int&gt;&gt;&amp; a, int n) {...}
</code></pre>
",6
28250179,28249833,0,"<p>You have a number of options:</p>

<ol>
<li><p>Use a compile time size like <code>MAX</code>, and declare your array parameter in terms of that:</p>

<pre><code>int determinant(int (*oMat)[MAX], int n) {
</code></pre>

<p>With that you are passing a pointer to the first element (= row) of your 2D array. The same can be done with the <code>std::array&lt;&gt;</code> template:</p>

<pre><code>int determinant(array&lt;array&lt;int, MAX&gt;, MAX&gt; *oMat, int n) {
</code></pre>

<p>However, in both cases <code>MAX</code> must be a compile time constant. You may pass <code>MAX</code> in as a template parameter, allowing different code to work on matrices of different size, but the problem remains that <code>MAX</code> needs to be a compile time constant.</p></li>
<li><p>If you want to work with a dynamic size in C++, you have two choices: First you can use a vector of vector</p>

<pre><code>int determinant(vector&lt;vector&lt;int&gt; &gt; *oMat, int n) {
</code></pre>

<p>This allows maximum flexibility, however, it does not enforce that the lines have the same size. <code>oMat</code> could be a ragged 2D array. The other way is to use a 1D array and calculate the indexes yourself:</p>

<pre><code>int determinant(int size, int *oMat, int n) {
    for(int i = 0; i &lt; size; i++)
        for(int j = 0; j &lt; size; j++)
            //Access the individual elements with
            oMat[size*i + j];
</code></pre></li>
<li><p>The third approach is to drop back to C, because in contrast to C++, C allows for true dynamic 2D arrays:</p>

<pre><code>int determinant(int size, int (*oMat)[size], int n) {
    for(int i = 0; i &lt; size; i++)
        for(int j = 0; j &lt; size; j++)
            //Access the individual elements with
            oMat[i][j];
</code></pre>

<p>You would create the array and call the function like this:</p>

<pre><code>int n = /*whatever*/;
int (*matrix)[n] = malloc(n*sizeof(*matrix));
fillMatrix(n, matrix);
determinant(n, matrix, n);
free(matrix);    //Don't forget the cleanup.
</code></pre></li>
</ol>
",3
28250019,28249833,2,"<p>You can pass an array by reference and have the function figure out the size of the matrix. To do this use a template as follows</p>

<pre><code>template &lt;int R&gt;
int determ(int (&amp;a)[R][R]) {
//now R is the number of rows
std::cout &lt;&lt; R &lt;&lt; std::endl;
// rest of code here
}
</code></pre>
",0
32416426,32416410,4,"<p>The <a href=""https://en.wikipedia.org/wiki/Semantics_%28computer_science%29"" rel=""nofollow"">semantics</a> of the ?<code>return</code> statement in C is to give control back to the caller with (if given) some returned value (result of the called function). You might read about <a href=""https://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow"">call stacks</a> and <a href=""https://en.wikipedia.org/wiki/Continuation"" rel=""nofollow"">continuations</a> to get a broader picture.</p>

<p>The ¡ì6.8.6.4 of draft <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow"">n1570</a> of the <a href=""https://en.wikipedia.org/wiki/C11_%28C_standard_revision%29"" rel=""nofollow"">C11</a> standard specifies:</p>

<blockquote>
  <p>A return statement terminates execution of the current function and returns control to
  its caller. A function may have any number of return statements.</p>
  
  <p>If a return statement with an expression is executed, the value of the expression is
  returned to the caller as the value of the function call expression. If the expression has a
  type different from the return type of the function in which it appears, the value is
  converted as if by assignment to an object having the return type of the function.</p>
</blockquote>

<p>In C++ things are different, since destructors (of all constructed local values in scope) are called. But no explicit statements after the <code>return</code>  gets executed.</p>

<p>The <a href=""http://open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf"" rel=""nofollow"">n3797</a> draft of <a href=""https://en.wikipedia.org/wiki/C%2B%2B14"" rel=""nofollow"">C++14</a> standard says in ¡ì6.6.3 notably:</p>

<blockquote>
  <p>A function returns to its caller by the return statement.</p>
  
  <p>A return statement with neither an expression nor a braced-init-list can be used only in functions that do not
  return a value, that is, a function with the return type cv void, a constructor (12.1), or a destructor (12.4).
  A return statement with an expression of non-void type can be used only in functions returning a value; the
  value of the expression is returned to the caller of the function. The value of the expression is implicitly
  converted to the return type of the function in which it appears. A return statement can involve the
  construction and copy or move of a temporary object (¡ì12.2).</p>
</blockquote>

<p>....etc.... (the destructor thing is explained elsewhere)</p>

<hr>

<p>C and C++ are different languages. You need to read relevant books or <a href=""http://www.cprogramming.com/"" rel=""nofollow"">websites</a> on C programming and/or on <a href=""http://stroustrup.com/programming.html"" rel=""nofollow"">C++ programming</a>. </p>

<p>Don't expect to be taught all the subtilities of <code>return</code> in a forum. Read books, then ask some <em>precise questions</em> with a <em>code sample</em>. Don't forget to test your code on your computer, e.g. by compiling it with all warnings and debug info (e.g. <code>gcc -Wall -Wextra -g</code> for C code, and <code>g++ -Wall -Wextra -g</code> for C++ code, if compiling with ?<a href=""http://gcc.gnu.org/"" rel=""nofollow"">GCC</a>...). Then <em>use the debugger</em> (e.g. <code>gdb</code>) to run your program step by step. Be afraid of <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>.</p>

<p>An <a href=""https://en.wikipedia.org/wiki/Optimizing_compiler"" rel=""nofollow"">optimizing compiler</a> won't always compile a <code>return</code> source statement into a <code>RET</code>  <a href=""https://en.wikipedia.org/wiki/Machine_code"" rel=""nofollow"">machine instruction</a>. It could inline the function call, or compile the <code>return</code>-s as jumps to a <a href=""https://en.wikipedia.org/wiki/Function_prologue"" rel=""nofollow"">function epilogue</a>.</p>

<p>The <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow"">ABI</a> and <a href=""https://en.wikipedia.org/wiki/Calling_convention"" rel=""nofollow"">calling conventions</a> dictate how a value gets returned. On <a href=""http://www.x86-64.org/documentation_folder/abi.pdf"" rel=""nofollow"">Linux/x86-64</a> it is often passed thru the <code>%rax</code> register (often, when your return a <code>struct</code> of two scalars, it gets returned thru two registers).</p>

<p>You could ask your compiler (e.g. with <code>g++ -O -Wall -fverbose-asm -S</code>) to produce assembler code, and look into it with an editor or pager.</p>

<p>C is a difficult language, and C++ is even more difficult. If you are learning programming, you might learn <a href=""http://schemers.org/"" rel=""nofollow"">Scheme</a> with <a href=""https://mitpress.mit.edu/sicp/"" rel=""nofollow"">SICP</a>. It has only expressions, and don't need any <code>return</code> <em>statement</em> (because it has no statement!) to return a value from a function.</p>
",7
30190646,30190398,0,"<p>Change your code to this and you will get 0 on moo</p>

<p>float T = 19.0<strong>f</strong> / 99.0<strong>f</strong>;
float moo = (99.0<strong>f</strong> * T) - 19.0<strong>f</strong>;</p>

<p>Also the value on moo without this is not 7.45, it is 7.45058e-08 which is almost zero.</p>
",2
30190761,30190398,0,"<p>Since any floating point numbers are represented in 2's complement notation in c++.you will usually get approximate values , while manipulating floating point values .So 7.450586e-008 is exact behaviour . If you need more precision use double.</p>
",0
28502282,28502107,0,"<p>You said:</p>

<blockquote>
  <p>I get an infinite loop when user does not enter a number</p>
</blockquote>

<p>Create a function that prints the prompt, tries to read the number, if reading doesn't succeed, clears the input stream and calls itself again.</p>

<pre><code>double readGrade(int gradeNum)
{
    double grade;
    cout &lt;&lt; ""Enter Grade "" &lt;&lt; gradeNum &lt;&lt;"" (From 0 to 100): "";
    if ( !(cin &gt;&gt; grade) )
    {
       // Clear the stream.
       cin.clear();

       // Discard everything up to the newline.
       cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');

       // Call the function again.
       return readGrade(gradeNum);
    }

    return grade;
}
</code></pre>

<p>Then, replace the following lines in main</p>

<pre><code>cout &lt;&lt; ""Enter Grade "" &lt;&lt; gradeNum &lt;&lt;"" (From 0 to 100): "";

cin &gt;&gt; grade;
</code></pre>

<p>by a call to <code>readGrade()</code>.</p>

<pre><code>grade = readGrade(gradeNum);
</code></pre>
",1
28502710,28502107,0,"<p>I have tweaked your GPA program in multiple places:</p>

<ol>
<li><p>added 2 varialbes to keep track of the subject being taken as input and to set a maximum number of subjects of 10.</p>

<pre><code>int maxSubjects = 10;
int currentSubject = 0;
</code></pre></li>
<li><p>Then checked condition <code>(currentSubject &lt; maxSubjects)</code> to make sure
number of subjects are not exceeded.</p></li>
<li><p>Changed calculation from <code>Total_GPA_multiply_HOURS = GPA * Hours;</code> to     <code>Total_GPA_multiply_HOURS += GPA * Hours;</code>, as we needed this value to get the persons actual GPA after getting input of all values.</p></li>
<li><p>Added a condition after the inner while loop to ensure outer while
loop is exited when 10 subjects are entered</p>

<pre><code>if (currentSubject == maxSubjects){
    break;
}
</code></pre></li>
<li><p>Added a line to print out the calculated GPA, <code>cout &lt;&lt; ""GPA: "" &lt;&lt; (Total_GPA_multiply_HOURS/gpa) &lt;&lt; endl;</code></p></li>
</ol>

<p>Here is the complete program:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;limits&gt;
using namespace std;

int main()
{
    cout &lt;&lt; "" - GPA Calculation Program -"" &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;
    string str;
    const double max = 100;
    const double min = 0;
    const double Hours = 3;
    int maxSubjects = 10;
    int currentSubject = 0;

    int gradeNum = 0;
    double grade;
    double GPA;

    bool True1 = true;
    bool True2 = true;
    bool True3 = true;
    bool True4 = true;

    double Total = 0.0;
    double  TotalGpa = 0.0;
    double gpa = 0.0;
    double  Total_GPA_multiply_HOURS = 0.0;

    while (True1 == true)
    {
        gradeNum++;
        True4 = true;
        currentSubject++;
        while (True4 == true &amp;&amp; (currentSubject &lt; maxSubjects))
        {
            True2 = true;
            cout &lt;&lt; ""Enter Grade "" &lt;&lt; gradeNum &lt;&lt; "" (From 0 to 100): "";
            cin &gt;&gt; grade;
            while (True2 == true)
            {
                if (grade &gt;= 90 &amp;&amp; grade &lt;= max)
                {
                    cout &lt;&lt; ""Your letter grade is A \n"";
                    GPA = 4;
                    gpa += 4;
                    Total_GPA_multiply_HOURS += GPA * Hours;
                    True2 = false;
                    True4 = false;
                    True3 = true;
                }
                else if (grade &gt;= 80 &amp;&amp; grade &lt;90)
                {
                    cout &lt;&lt; ""Your letter grade is B \n"";
                    GPA = 3;
                    gpa += 3;
                    Total_GPA_multiply_HOURS += GPA * Hours;
                    True2 = false;
                    True4 = false;
                    True3 = true;
                }
                else if (grade &gt;= 70 &amp;&amp; grade &lt;80)
                {
                    cout &lt;&lt; ""Your letter grade is C \n\n"";
                    GPA = 3;
                    gpa += 3;
                    Total_GPA_multiply_HOURS += GPA * Hours;
                    True2 = false;
                    True4 = false;
                    True3 = true;
                }
                else if (grade &gt;= 60 &amp;&amp; grade &lt;70)
                {
                    cout &lt;&lt; ""Your letter grade is D \n\n"";
                    GPA = 2;
                    gpa += 2;
                    Total_GPA_multiply_HOURS += GPA * Hours;
                    True2 = false;
                    True4 = false;
                    True3 = true;
                }
                else  if (grade &gt;= min &amp;&amp; grade &lt;60)
                {
                    cout &lt;&lt; ""Your letter grade is F \n\n"";
                    GPA = 0;
                    gpa += 0;
                    Total_GPA_multiply_HOURS += GPA * Hours;
                    True2 = false;
                    True4 = false;
                    True3 = true;
                }
                else if ((grade &lt; min || grade &gt; max) &amp;&amp; (grade &gt; -100000000 &amp;&amp; grade &lt; 100000000))
                {
                    cout &lt;&lt; ""*** ERROR: "" &lt;&lt; grade &lt;&lt; "" is INVALID grade\n"" &lt;&lt; "" Grade must be from 0 to 100! \n \n PLease enter a Grade and has to be from 0 to 100!\n\n\n"";
                    True2 = false;
                    True4 = true;
                }
                else
                {
                    cout &lt;&lt; ""*** ERROR: The input you have provided is not a number!\n Please enter a number from 1 to 100!\n\n\n"";
                    cin.fail();
                    cin.clear();
                    cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
                    True1 = false;
                    True2 = false;
                    True3 = false;
                    True4 = false;
                }
            }
        }
        if (currentSubject == maxSubjects){
            break;
        }
    }
    cout &lt;&lt; ""GPA: "" &lt;&lt; (Total_GPA_multiply_HOURS/gpa) &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Hope this helps.</p>
",0
31242346,31242281,1,"<p>In C++ the address with remain the same throughout the lifetime of the application.</p>
",0
31242364,31242281,5,"<p>This one particular object will have that same address for as long as it exists, yes. Objects do not move around in memory unless you move them yourself (or do so indirectly: for example, elements of a standard container being moved due to your manipulation of the container).</p>

<p>Provided that you are fully aware of all such occasions, <strong>you may safely use an object's address as its identity.</strong></p>

<p>That doesn't mean that other <code>foo</code>'s will have the same or even a similar address, even if created by the same code (say, in a function or loop). Just that one object created at that specific point in time.</p>
",5
31245682,31242281,0,"<p>In case of JAVA we can't free object on our own as in java we have garbage collector which take care of freeing the object which have no reference also known as dead objects ,but in c we have that provision so the answer to your question is yes.   </p>
",0
31159726,31159646,1,"<p>The compiler will not be able to convert the types automatically for you since they are not sufficiently related.</p>

<p>You <em>could</em> build a <em>cast operator</em> in the <code>Month</code> class. This would have the prototype</p>

<pre><code>operator DayInYear() const;
</code></pre>

<p>and returns a <code>DayInYear</code> object.</p>

<p>Then you could write <code>(DayInYear)m;</code> where <code>m</code> is a <code>Month</code> instance. </p>
",1
31159736,31159646,1,"<p>There are basically 2 ways.</p>

<p>Either make a constructor for <code>DayInYear</code> that takes a <code>Month</code> :</p>

<pre><code>class DayInYear:public Base
{
 public:
   DayInYear(Month m) { //Create a DayInYear from Month }
   ...
}
</code></pre>

<p>Or, create a cast operator in <code>Month</code> that provides a <code>DayInYear</code> :</p>

<pre><code>class Month:public Base
{
  public:
   operator DayInYear() const { //create a DayInYear  }
   ...
}
</code></pre>

<p>Or implement both.</p>

<p>This is a thing a lot of people get confused by when using C style casts:</p>

<pre><code>Month m;

DayInYear day1 = DayInYear(m); //DayInYear constructor

DayInYear day2 = (DayInYear)m; //Cast Operator
</code></pre>
",2
31161453,31159646,0,"<p>When you are saying you don't ""understand how the convert works"" I assume you are referring to this line of code:</p>

<pre><code>Base *arr[2] = {new DayInYear(100),new Month(20,4)};
</code></pre>

<p>With this line of code there is technically no conversions being made, instead this is the concept of polymorphism. In object oriented programming languages such as C++, polymorphism refers to the idea that a single object can take many different forms. In the example you showed above, DayInYear and Month are not really being converted to the Base type. Both these classes inherit from base and therefore they can be referred to as Base. All of the other data held by DayInYear and Month is still there, it is just unable to be accessed when being assigned to its superclass of Base. These objects, when assigned to its superclass Base, can only be interacted with as if they were Base objects, however behind the scenes they are still the objects you created them as. Polymorphism is the key idea here and a very important concept to understand with object oriented programming, you can check out the following link: <a href=""http://www.cplusplus.com/doc/tutorial/polymorphism/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/polymorphism/</a></p>

<p>Now as for you question on converting Month to DayInYear, I am unsure why you would want to do that. First of all it would make no sense for a Month to be a DayInYear since they are very different things. This would also result is a loss of data most likely since Month contains the month attribute, whereas DayInYear does not. If you feel that this conversion needs to be made however, you would have a couple choices. First is to have a constuctor in you DayInYear class that takes a Month as an argument to create a DayInYear object:</p>

<pre><code>DayInYear(Month month) { //Code that converts Month to DayInYear }
</code></pre>

<p>Another option is to use an assignment operator which would allow to to make a direct assignment of Month to DayInYear:
In your DayInYear class:</p>

<pre><code>DayInYear&amp; operator = (const Month&amp; month) { //code for assignment }
</code></pre>

<p>In main you could do this now:</p>

<pre><code>Month month(2, 3);
DayInYear dayInYear = month;
</code></pre>

<p>The final option you have is to use a type cast operator in your Month class:</p>

<pre><code>operator DayInYear() {//conversion code} 
</code></pre>

<p>This would allow for a cast between the two to be made.</p>

<p>Hope this helps.</p>
",0
29510854,29510626,0,"<blockquote>
<pre><code>std::vector&lt;double&gt;accountnumber;
</code></pre>
</blockquote>

<p>Using a <em>double</em> for account numbers does <strong>not</strong> seem a good choice to me: you may want to use a <code>std::string</code> instead.</p>

<p>For example: note that ""exact"" comparison between doubles is not possible (so searching for account numbers using doubles as keys is problematic); instead you can do that with strings.</p>

<p>So, assuming you use a <code>vector&lt;string&gt;</code> for account numbers, you can use <code>std::find()</code> to find a given account position in the vector, e.g.:</p>

<pre><code>auto it = find(accountNumbers.begin(), accountNumbers.end(),
               accountNumberToFind);

if (it != accountNumbers.end())
{ 
    ... Found, process it ...
}
</code></pre>

<p>Once you have the iterator to the found account, you can get the vector 0-based index from it using a simple pointer/iterator arithmetic like <code>(it - accountNumbers.begin())</code>.</p>

<p>Then, given this index, you can access the corresponding items in the other vectors.</p>

<p>However, from an object-oriented design perspective, I'd prefer defining a class for accounts, with several fields like account number, name, address, etc., and have a single <strong><code>vector&lt;Account&gt;</code></strong> (instead of several vectors of single account attributes).</p>
",0
29510916,29510626,0,"<p>There are some parts of your code that I'd suggest to revisit, however, according to you code, you can just do the following:</p>



<pre class=""lang-cpp prettyprint-override""><code>     void lookForAccount(){

     system (""cls"");
     for (int i = 1; i &lt;= 1; i++)
     {
        int temp;//variable to give to vector
        cout&lt;&lt;""Enter "" &lt;&lt; i &lt;&lt; "" Account Number you want to look for"";
        cin&gt;&gt;temp;
        for(int j = 0;j&lt;accountnumber.size();j++){
            if(accountnumber[j]==temp){
               cout&lt;&lt;""account number: ""&lt;&lt;accountnumber[j]&lt;&lt;"", name: ""&lt;&lt;names[j]&lt;&lt;""etc...""&lt;&lt;endl;
            }
        }
     }
     main ();
     }
</code></pre>

<p>Instead of this dummy method I'd anyway suggest to use iterators and std::find.</p>

<p>However, as pointed out in comments, this code is bug prone due to several reasons: handling account number by double is not the best choiche. Furthermore, I'd suggest to redesign your code to handle all the account information using a C++ objects.</p>
",0
31864997,31864927,4,"<p>The error is that your map pairs are not copyable, you need to iterate over references</p>

<pre><code>for(auto&amp; subject: SubjectList)
</code></pre>

<p>Or if you do not intend to mutate the elements, you should make them <code>const</code> as well</p>

<pre><code>for(auto const&amp; subject: SubjectList)
</code></pre>

<p>This is because each element of your <code>std::map</code> is a </p>

<pre><code>std::pair&lt;std::string, std::unique_ptr&lt;ListOfNumericLists&lt;int&gt;&gt;
</code></pre>

<p>So since there is a <code>std::unique_ptr</code> the elements are not copyable</p>
",0
31865003,31864927,2,"<pre><code>for(auto subject: SubjectList)
</code></pre>

<p>creates copies named <code>subject</code> of every key/value pair in the map. Since your value type is an <code>std::unique_ptr</code> which cannot be copied, the pair cannot be copied either. Thus the error.</p>

<p>Try</p>

<pre><code>for(const auto &amp;subject: SubjectList)
</code></pre>

<p>instead.</p>

<p>As a side note, the iterator loop works fine of course, since you not not even access, let alone try to copy, the contents of the map there.</p>
",0
30716042,30715632,2,"<p>im quite confused what you are doing oO</p>

<p>Is that what you are searching for?</p>

<pre><code>std::unorderd_map&lt;std::string, std::list&lt;std::string&gt;&gt; hash_map;

// fill map
....

// go to hash
std::string hash = ""whatever"";
std::unorderd_map&lt;std::string, std::list&lt;std::string&gt;&gt;::iterator itr;
itr = hash_map.find(hash);

// check if value exists
if(itr == hash_map.end())
   std::cout &lt;&lt; ""not in map ... "" &lt;&lt; std::endl;
else {
   // print everything
   const std::list&lt;std::string&gt; &amp; hash_list = (*itr).second;
   for(const std::string &amp; value : hash_list)
      std::cout &lt;&lt; value &lt;&lt; std::endl;

   // sry edit of course the delete
   hash_map.erase(itr);
}
</code></pre>
",4
34253578,34253544,1,"<p>You can't declare a class in a throw statement.  Declare the class first <del>(anonymously if you like, naming it via a typedef)</del>, then you can throw it.</p>

<p>Better is to name the exception class, but put it in the nameless namespace:</p>

<pre><code>namespace {
   class LocalException : public std::exception {
       const char *what() const noexcept override {
           return ""Custom exception"";
       }
    };
 }
    ....
    throw LocalException();
</code></pre>

<p>or, if you insist, you can create an object of anonymous class, and throw that.</p>

<pre><code>static class : public std::exception {
   const char *what() const noexcept override {
       return ""Custom exception"";
   }
 } LocalExceptionObject;
    ....
    throw LocalExceptionObject;
</code></pre>

<p><strong>Edit</strong> If you create a typedef, somebody can copy it, and it names the same class.  You have to create an object of the anonymous class, and then nobody can name it.</p>

<p>Having said that, I don't think having anonymous things is useful.  Far better to declare the class in a nameless namespace (so you know it is private), and just use it.</p>
",17
34257053,34253544,2,"<p>This is not an answer per-se, but some important information what will help you going forward:</p>

<p>First, throwing an anonymous exception is unlikely to be useful. Exceptions are caught by their type. If you can't name the type, you can't catch the exception explicitly - only by its base, in which case you may as well have just thrown the base.</p>

<p>Second (and this is important):</p>

<p>There's rarely a good reason to derive from <code>std::exception</code> directly. You should derive from one of the exception types defined in <code>&lt;stdexcept&gt;</code></p>

<p>these are:</p>

<p><code>std::runtime_error</code> - indicating that some runtime condition makes it impossible to perform the service <em>at the moment</em> (such as a missing file).</p>

<p><code>std::logic_error</code> - indicating that what was attempted will never be possible and the program is fundamentally in error in a way that could not be detected at compile time.</p>

<p>Handy reference here:</p>

<p><a href=""http://en.cppreference.com/w/cpp/header/stdexcept"" rel=""nofollow"">http://en.cppreference.com/w/cpp/header/stdexcept</a></p>
",0
29248811,29248447,1,"<p>Not sure I fully understand the question...
But if you want the last eight characters you could use:</p>

<pre><code>str.substr( str.length() - 8, 8 );
</code></pre>

<p>To convert a string to an int you can use:</p>

<pre><code>#include &lt;cstdlib&gt;

int i = atoi( str.c_str() );
</code></pre>

<p>Or to convert a character to an int you could use:</p>

<pre><code>int i = str[ 0 ] - '0';
</code></pre>
",3
29248923,29248447,0,"<p>To create a substring from the last 8 digits, use <code>string::length</code>:</p>

<pre><code>str.substr(str.length() - 8, 8)
</code></pre>

<p>Then, to convert that substring to int, use <a href=""http://www.cplusplus.com/reference/string/stoi/"" rel=""nofollow""><code>stoi</code></a>:</p>

<pre><code>int i = stoi(str.substr(str.length() - 8, 8));
</code></pre>
",0
29249466,29248447,1,"<p>Print remaining characters first using mod <code>%</code> operator.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string str=""12345678910111213141516171819202122232425262728293"";
    std::size_t sz = str.size();
    std::size_t i = 0;

    if(sz % 8) {
        cout&lt;&lt;str.substr(i, sz % 8) &lt;&lt; ' ' ;
        i += sz % 8;
    }    
    while(i&lt;str.length())
    {
       cout &lt;&lt; str.substr(i,8) &lt;&lt; ' ';
       i = i+8;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>

<p><KBD><a href=""http://ideone.com/lEra9F"" rel=""nofollow"">Live demo here</a></KBD></p>

<p>Now you can use <code>std::stringstream</code> or <code>std::stoi</code> to convert these strings into number.</p>

<pre><code>int strToNum(const string &amp;str)
{
    std::stringstream sstr(str);
    int ret;
    if( sstr &gt;&gt; ret ) {
        return ret;
    } else {
        // Error handling
        throw str + "" is not an integer"";
    }
}
</code></pre>
",0
29188983,29188927,2,"<p>You have messed up the function argument names.</p>

<pre><code>if (Operation == +)
{
    // ...
}
</code></pre>

<p>What is Operation? You pass the function a char with argument name</p>

<pre><code>charOperation
</code></pre>

<p>not
    Operation</p>

<p>You can't compare characters like that. You must do</p>

<pre><code>if(charOperation == '+')
</code></pre>

<p>and so on.</p>
",7
29207198,29206949,4,"<p>I think a solution could be:</p>

<pre><code>string QUESTIONS[50][4];

int x;
ifstream myFile;
myFile.open(""Questions.txt"");

getline(myFile, tempNum);
questionNum = stoi(tempNum);

for (int x = 0; x &lt; 50; x++)
{
getline(myFile, line1);
getline(myFile, line2);
getline(myFile, line3);
getline(myFile, line4);
getline(myFile, tempNum);
correctAns = stoi(tempNum);

QUESTIONS[x][0] = line1;
QUESTIONS[x][1] = line2;
QUESTIONS[x][2] = line3;
QUESTIONS[x][3] = line4;

}
</code></pre>

<p>You have increase x twice and the string array was no declared in the right order.</p>
",0
31169749,31169667,0,"<p>I won't call it overload , but compiler will generate two different functions based on template arguments.</p>
",0
31169750,31169667,2,"<p>You have two overloads of <code>foo</code> (really two function templates named <code>foo</code>). One takes one template type argument:</p>

<pre><code>template&lt;typename T&gt;
T foo();
</code></pre>

<p>And one takes two template type arguments:</p>

<pre><code>template&lt;typename T, typename U&gt;
std::pair&lt;T,U&gt; foo();
</code></pre>

<p>You are allowed to overload on different template arguments. You could even add overloads that take non-type arguments:</p>

<pre><code>template &lt;int I&gt;
void foo() {
    std::cout &lt;&lt; ""third"";
}
</code></pre>

<p>This is a separate, valid overload too. What you can't do is then separately add:</p>

<pre><code>template &lt;typename U&gt;
U* foo();
</code></pre>

<p>Because now you have two different function templates named <code>foo</code> that take a single template argument and there's no way for the compiler to know which one you meant - so now you have a guaranteed ambiguous overload. </p>
",4
31139910,31139063,6,"<p>The function returns a single value, it can't return more. In this case, it returns by reference the stream that it got as the first parameter, also by reference. The person's name and address are not returned, they are read from the stream and used to fill the <code>Person</code> instance <code>p</code> received by reference.</p>

<pre><code>// notice both parameters are references
std::istream &amp;read(std::istream &amp;is, Person &amp;person)
{
    is &gt;&gt; person.name; // read the name and store it in the person object
    getline(is, person.address); // read the address and store it in the person object
    return is; // return the stream reference
}

int main()
{ 
    Person p; 
    read(cin,p); // both params are sent by reference
    // so here the object p will have it's members properly filled
}
</code></pre>

<p>Returning the stream by reference as you do for your <code>read()</code> function doesn't make much sense in this situation. This is usually done for overloading operators for streams, e.g.:</p>

<pre><code>std::istream&amp; operator &gt;&gt;(std::istream &amp;is, Person &amp;person)
{
    is &gt;&gt; person.name;
    is &gt;&gt; person.address;
    return is;
}
</code></pre>

<p>In this case it is useful to return the stream because this way you can chain multiple calls, for example:</p>

<pre><code>Person p1, p2, p3;
std::cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; p3;
</code></pre>

<p>In your case this is not really useful and it would actually hurt readability if you chained the calls:</p>

<pre><code>Person p1, p2, p3;
read(read(read(cin, p1), p2), p3);
</code></pre>

<p>In this case it is much easier, both to write and to read, if you do it like this:</p>

<pre><code>Person p1, p2, p3;
read(cin, p1);
read(cin, p2);
read(cin, p3);
</code></pre>
",0
31159825,31159824,4,"<p>Here we should use virtual inheritance. This feature assures that there is only one instance of your virtually-inherited base class when you instantiate a subclass. For your example, this would look like:</p>

<pre><code>#include &lt;cstdio&gt;

class IBaseA
{
 public:
    virtual void DoA() = 0;
};

class IBaseB
{
public:
    virtual void DoB() = 0;
};

// The same interface, now based on multiple smaller interfaces
class IBig : virtual public IBaseA,  virtual public IBaseB
//              ^                       ^
{
};

class CBaseA: virtual public IBaseA
//              ^
{
public:
    virtual void DoA()
    {
        printf(""DoA\n"");
    }
};

class CBaseB: virtual public IBaseB
//              ^
{
public:
    virtual void DoB()
    {
        printf(""DoB\n"");
    }
};

// Inherit from base classes where the implementation is, and from IBig as 
// the instance of CBig is returned as IBig.
class CBig: public CBaseA, public CBaseB, public IBig
{
};

int main()
{
    CBig cb;
}
</code></pre>

<p>The above changes ensure that there are not extra declarations of DoA and DoB created when you inherit from IBaseA and IBaseB multiple times.</p>
",0
33006383,33006283,0,"<p>You already have one constructor.  Simply do the exact same thing with the other constructor, just with different parameters, like the requirements say to.</p>

<p>And you need to change your <code>displayMovieInfo()</code> standalone function into a method of the class, like the requirements say to.</p>

<p>Try this:</p>

<pre><code>// ch7movie
// By Kevin Mok

#include &lt;iostream&gt;
#include &lt;iomanip&gt; 
#include &lt;string&gt;

using namespace std;

class MovieData
{    
public:
    string title;
    string director;
    int yearReleased;
    int runningTime;
    double productionCost;
    double firstYearRevenue;

    // constructors
    MovieData(string titl, string dir, int yr, int rT);
    MovieData(string titl, string dir, int yr, int rT, double pC, double fyR);

    void displayMovieInfo();
    void displayMovieInfoAndCosts();
};

//Defining constructors

MovieData::MovieData(string titl, string dir, int yr, int rT)
{
    title = titl;
    director = dir;
    yearReleased = yr;
    runningTime = rT;
    productionCost = 0.0;
    firstYearRevenue = 0.0;
}

MovieData::MovieData(string titl, string dir, int yr, int rT, double pC, double fyR)
{
    title = titl;
    director = dir;
    yearReleased = yr;
    runningTime = rT;
    productionCost = pC;
    firstYearRevenue = fyR;
}

//Methods to display movie info

void MovieData::displayMovieInfo()
{
    cout &lt;&lt; ""----------------------------"" &lt;&lt; endl;
    cout &lt;&lt; ""Title: "" &lt;&lt; title &lt;&lt; endl;
    cout &lt;&lt; ""Director: "" &lt;&lt; director &lt;&lt; endl;
    cout &lt;&lt; ""Year Released: "" &lt;&lt; yearReleased &lt;&lt; endl;
    cout &lt;&lt; ""Running Time: "" &lt;&lt; runningTime &lt;&lt; "" minutes"" &lt;&lt; endl;
    cout &lt;&lt; ""----------------------------\n"" &lt;&lt; endl;
}

void MovieData::displayMovieInfoAndCosts()
{
    cout &lt;&lt; ""----------------------------"" &lt;&lt; endl;
    cout &lt;&lt; ""Title: "" &lt;&lt; title &lt;&lt; endl;
    cout &lt;&lt; ""Director: "" &lt;&lt; director &lt;&lt; endl;
    cout &lt;&lt; ""Year Released: "" &lt;&lt; yearReleased &lt;&lt; endl;
    cout &lt;&lt; ""Running Time: "" &lt;&lt; runningTime &lt;&lt; "" minutes"" &lt;&lt; endl;
    cout &lt;&lt; ""Production Cost: $"" &lt;&lt; setprecision(2) &lt;&lt; productionCost &lt;&lt; endl;
    cout &lt;&lt; ""First Year's Profit': $"" &lt;&lt; setprecision(2) &lt;&lt; firstYearRevenue - productionCost &lt;&lt; endl;
    cout &lt;&lt; ""----------------------------\n"" &lt;&lt; endl;
}

int main()
{
    MovieData movie1(""C++ in English"", ""JohnCna"", 2010, 120, 36500, 50000);
    MovieData movie2(""Great Programmer"", ""RKO"", 2013, 130, 36500, 100000);

    movie1.displayMovieInfo();
    movie1.displayMovieInfoAndCosts();

    movie2.displayMovieInfo();
    movie2.displayMovieInfoAndCosts();

    return 0;    
}
</code></pre>
",1
29491029,29490921,0,"<p>If you're just trying to write a <code>'T'</code> into the array, that's just assignment:</p>

<pre><code>relation[i][j] = 'T';
</code></pre>

<p><a href=""http://en.cppreference.com/w/c/string/byte/strstr"" rel=""nofollow""><code>strstr</code></a> is a method to find a substring in a string. It's only useful for its return-value, so even if you got your code to compile, it just wouldn't do anything. </p>
",3
29456754,29456601,1,"<p>you get this error because your arrays PipeI and PipeD are just one index long in their first brackets so its like </p>

<pre><code>PipeI[1][3]={0};
PipeD[1][6]={0};
</code></pre>

<p>if you thry to iterate through it you get the errors.
Arrays always have fixed size in c++.</p>
",0
29452675,29452524,3,"<p>I can't explain your error message, except that your code differs somehow from your description.</p>

<p>The following is essentially what you have described except that I added constructors (which are optional), picked names for the member functions, and added a driver program to test.   It works without error.</p>

<pre><code>#include &lt;iostream&gt;

class Parent
{
    public:
       Parent() : data_parent(0) {};
       void SetDataParent(int x) {data_parent = x;};
    protected:
        int data_parent;
};

class Child: public Parent
{
    public:
       Child() : Parent(), data_child(0) {};
       void SetDataChild(int x) {data_child = x;};
       int GetSum() const {return data_child + data_parent;};
    protected:
        int data_child;
};

int main()
{
    Child child;
    child.SetDataParent(42);
    child.SetDataChild(100);
    std::cout &lt;&lt; child.GetSum() &lt;&lt; '\n';
}
</code></pre>

<p>My guess is that you forgot to have <code>Child</code> inherit from <code>Parent</code>, making for a fairly tense family relationship.</p>
",1
29452890,29452524,0,"<p>Solved the problem. I did not realize that there was a difference between inheriting from a normal class and a template class. I needed to include </p>

<p><code>using Parent&lt;type&gt;::data_parent;</code></p>
",2
29455844,29455468,0,"<p>The reason that he program is not asking for your age is because it encountered</p>

<pre><code>return stoi(input);
</code></pre>

<p>A <code>return</code> statement is used to give the function a value ( or something else depending on the type of the function ) , and whenever a <code>return</code> is encountered, the function exits. </p>

<p>That's what's happening in your code, <code>main()</code> exits when it encounters that <code>return</code>.  </p>

<p>Now, this code will work as you expect it to if you remove </p>

<pre><code>int getInt(std::istream &amp; is);
std::string input;
std::getline(is,input);
return stoi(input);
</code></pre>

<p>from your code. You don't need that for your code to work here. ( It will compile and work without problems )</p>

<p>I assume you were expecting to make that into a function and use it to convert <code>age</code> into an integer. But it will work as a string here.</p>
",0
29461998,29461786,1,"<p>You can use <code>string::find</code> to perform a partial search of the string and store the value into a <code>size_t</code> variable. </p>

<p>Compare that to <code>std::string::npos</code> and increment count if they are not equal. </p>

<p>Here is an simple example using arrays not vector so you can learn and make modifications as required.</p>

<pre><code>int main() {

    string inputs[2] = {""stack overflow"", ""stack exchange""};
    string search_key = ""stack"";
    int count;

    for(int i = 0; i &lt;sizeof(inputs)/sizeof(inputs[0]); i++)
    {
        //npos returns -1. If substring is not found, find will return -1.
        //if substring is found, condition fails and count is incremented 
        if (inputs[i].find(search_key) != string::npos)
            count++;
    }

    cout &lt;&lt; count;

    return 0;
}
</code></pre>

<p><a href=""https://ideone.com/EiqeCA"" rel=""nofollow"">Here</a> is the link for the code above. You can see that the output is 2 as expected as the word <code>stack</code> occurs twice in the <code>inputs</code> array.</p>
",0
29484591,29484541,0,"<ol>
<li>Open the file using a <a href=""http://en.cppreference.com/w/cpp/io/basic_ifstream"" rel=""nofollow""><code>std::ifstream</code></a></li>
<li>Read each word, a <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow""><code>std::string</code></a>, from the file.</li>
<li>Add the read words to a <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector&lt;std::string&gt;</code></a>.</li>
<li>Write the contents of all the elements of the vector save the last one. Write a space between each of the elements being written.</li>
</ol>
",1
29501382,29500560,0,"<p>Do you want a quick and dirty solution or an elegant one?</p>

<p>For an elegant solution, I would:  </p>

<ul>
<li>Ditch the globals.</li>
<li>Read the entire file into memory before parsing it.</li>
<li>Generate an internal database for your data.</li>
<li>Write a few query functions that return a subset of your data.</li>
</ul>

<p>For your particular case, you could use a std::multimap &lt; LinkName, DateAndIP > to find all data relating to the link. DateAndIP could be a typedef to std::multimap &lt; Date, IP > . If you've never used multimap, this will be a good learning experience. Write your compare functions and use the find member function to return only what you're looking for.  </p>

<p>Good luck and happy coding!</p>
",1
29501251,29500560,0,"<p>This Part of the code shouldnt be written into your main() function.</p>

<pre><code>// the file is passed to this function
void fileinfo1(string filename) {

    //the user will input a link e.g www.espn.com
    cout &lt;&lt; ""What is the link name? "";

    cin &gt;&gt; Link_Name;

    // and also input date range (start-end)
    cout &lt;&lt; ""What is the starting date? "" ;

    cin &gt;&gt; Date_Accessed;

    cout &lt;&lt; ""What is the ending date? "" ;

    cin &gt;&gt; Date_Accessed;

    // Now, here's where I'm having trouble

    // I need to find the wwww.espn.com in my file based on the range date , so that i will be able to increment the number of hits

    unsigned int curLine = 0;
    while (getline(filename, line)) { // I changed this, see below
        curLine++;
        if (line.find(search, 0) != string::npos) {
            cout &lt;&lt; ""found: "" &lt;&lt; search &lt;&lt; ""line: "" &lt;&lt; curLine &lt;&lt; endl;
        }
    }

}
</code></pre>

<p>and you are using way to many global variables which are really not necessary. And you dident declare the variables line and search. This shoudnt even compile.</p>
",1
29491458,29491384,3,"<pre><code>func1(Base temp)
</code></pre>

<p>That is copying your object, it is not your original Derived  but a Base instance copy initialized from the derived.</p>

<p><code>func1(Base&amp; temp)</code> should work </p>
",0
29491461,29491384,1,"<p>It's because you pass an argument by value: <code>func1</code> param is <code>Base temp</code>, not <code>Base &amp;temp</code>.  So you construct a new, temporary object of class <code>Base</code>, so you call <code>Base::func2()</code> which prints 1.</p>
",0
29491473,29491384,1,"<p>you should try with:</p>

<pre><code>virtual void func1(Base&amp; temp){
        cout &lt;&lt; ""Class 1"" &lt;&lt; endl;
        temp.func2();
    }
</code></pre>

<p>this will prevent copying the object, preserving the hierarchy.</p>
",0
31307782,31307759,2,"<p>It's better to use the initializer list to initialize member variables, that's what it's there for. In the case of complex objects there may be an efficiency benefit too, since you can skip the default initialization. If the member doesn't have a default constructor, or is <code>const</code> or a reference, you will have no choice but to put it in the initializer list anyway.</p>

<p>I prefer to keep the body of a function as separate lines, in case I need to set a breakpoint on one.</p>
",0
32390885,32390728,2,"<p>No, you need to loop through each of the items in the old array and create new copies for the new array.</p>

<pre><code>for(int i = 0; i != size; ++i)
{
    pitems[i] = st.pitems[i]; //Assuming you have an equals operator for Item
}
</code></pre>

<p>And definitely do not do <code>pitems = st.pitems;</code> as this leaks the new array you made with <code>new Item[size + 1]</code> </p>
",0
32390898,32390728,3,"<p>Loop through them and copy them, not the pointer of the other class.</p>

<pre><code>Stack::Stack(const Stack &amp;st)
{
    this-&gt;size      = st.size;
    this-&gt;top       = st.top;
    this-&gt;pitems    = new Item[this-&gt;size + 1];
    for (auto i = 0; i &lt; this-&gt;size; ++i)
    {
        pitems[i] = st.pitems[i];
    }
}
</code></pre>

<p>As mentioned in the comment before, you currently have a memory leak.</p>
",0
30710467,30710428,9,"<p>Write an implicit conversion operator in <code>Complex</code> :</p>

<pre><code>class Complex {
public:
    operator double () const {
        //...
    }
};
</code></pre>
",0
29908016,29907946,2,"<p>The Error Your Getting is Because you are not implementing the method amer_bi::Option_Price. You Are Implementing the function Option_Price but not the method. As A result the linker is failing to find the methods implementation and raising a lnk2019 error. to implement a method of a class you either need to put the implementation in the class(marking the method as inline) or when implementing it out side the class refer to the name as amer_bi::Option_Price so that it knows what method to implement.
e.g.</p>

<pre><code>//.hpp file

class foo{

public:

//method prototype
void method();

};

//.cpp file

//what you need to be doing
void foo::method(){
    //method implementation
}

//what you are actually doing
void method(){
    //function implementation
}
</code></pre>
",4
29911326,29911013,1,"<p>You asked:</p>

<blockquote>
  <p>How would you write up something that would allow you to reuse this function but have a different output, Eg if its within X box then do X, if its in Y box then do Y</p>
</blockquote>

<ol>
<li>Write different functions that check whether the value is in X box or Y box.</li>
<li>Implement <code>withinRange</code> using the other functions.</li>
<li>Use the returned values of these functions to make decisions in the calling function(s).</li>
</ol>



<pre><code>bool withinXRange(int x1, int x2)
{
   return (cCoordx &gt; x1  &amp;&amp; cCoordx &lt; x2);
}

bool withinYRange(int y1, int y2)
{
   return (cCoordy &gt; y1  &amp;&amp; cCoordy &lt; y2);
}

bool withinZRange(int z1, int z2)
{
   return (cCoordz &gt; z1  &amp;&amp; cCoordz &lt; z2);
}

bool withinRange(int x1, int y1, int z1, int x2, int y2, int z2)
{
   return ( withinXRange(x1, x2) &amp;&amp;
            withinYRange(y1, y2) &amp;&amp;
            withinZRange(z1, z2) );
}
</code></pre>

<p>In the calling function:</p>

<pre><code>int x1 = &lt;some value&gt;;
int x2 = &lt;some value&gt;;

if ( withinXRange(x1, x2) )
{
    // Do something
}
</code></pre>
",0
33004702,33004681,2,"<p>You call new twice, but only delete once.</p>
",1
33004709,33004681,0,"<p>Obviously you haven't tried deleting <code>name</code> - the first <code>char</code> you allocate before resetting <code>name</code> to something else and losing all references to the initial block...</p>
",4
33004712,33004681,1,"<p>you do <code>char* name = new char;</code> </p>

<p>but then later you replace (forget) the value of <code>name</code> with <code>name = cname;</code></p>

<p>so that original <code>new char</code> is never deleted.</p>
",0
33004765,33004681,0,"<p>Just follow the code to see what gets allocated and freed:</p>

<pre><code>char *name = new char;       // Block 1, name references it
char *cname = new char[10];  // Block 2, cname references it
:
name = cname;                // name/cname now reference block 2 ***
delete [] name;              // free up block 2
</code></pre>

<p>You can see on the <code>***</code> line that you <em>lose</em> the pointer to block 1, hence there's your memory leak. Even if you <em>had</em> code which tried to free up block 1, you no longer have a reference to it after that point.</p>

<p>If you're going to lose all access to a memory block, you'd better free it up first:</p>

<pre><code>char *name = new char;       // Block 1, name references it
char *cname = new char[10];  // Block 2, cname references it
:
delete name;                 // free up block 1
name = cname;                // name/cname now reference block 2 ***
delete [] name;              // free up block 2
</code></pre>

<hr>

<p>As for your comment:</p>

<blockquote>
  <p>For some reason I was under the assumption that pointer initialized without a value points to NULL rather than a block of memory, and therefore doesn't need to be handled.</p>
</blockquote>

<p>What a pointer is initialised to if you don't specify, that depends on a couple of factors. However, it's irrelevant here because you <em>do</em> initialise it. If you want a pointer set to NULL, just do that:</p>

<pre><code>char *name = 0;  // not ""new char"".
</code></pre>
",0
30143759,30143504,1,"<blockquote>
<pre><code>10
hello world
</code></pre>
  
  <p><em>""i want this <code>10</code> to be removed and screen show just""</em></p>

<pre><code>hello world
</code></pre>
</blockquote>

<p>Unfortunately this cannot be solved just using C++ standard I/O facilities, because it heavily depends on your actually used terminal and its control character implementation options.</p>

<p>The default behavior of terminals is to <em>echo</em> the characters typed in from the user. Some terminal implementation allow you to control to hide the typed in characters (<em>switch off echo</em>). Alternatively you may have options to remove typed in characters using a backspace, or so.</p>

<p>If your current terminal supports these, there are basically 2 options:</p>

<ol>
<li>You switch off the input <em>echo mechanism</em>, before calling <code>cin&gt;&gt;n;</code></li>
<li>You immediately clear the last input made by <code>cin&gt;&gt;n;</code>, e.g. outputting the <code>'\b'</code> backspace character</li>
</ol>
",5
30158476,30158418,1,"<p>Its because your condition for the loop is <code>(c &lt; 5)</code> when c is not defined until the loop body. You either need to change <code>while (c &lt; 5)</code> to <code>while (f &lt; 5)</code> or define <code>c</code> outside of the loop body.</p>
",4
30170566,30170293,2,"<p>You need to add a class definition for <code>SystimaDieythynsis</code> and place it and the class definition for <code>Mihani</code> before the class definition for <code>Vehicle</code>.  Like so:</p>

<pre><code>class Mihani { 
    // ...
};

class SystimaDieythynsis {
    // ...
};

class Vehicle {
    // ...
};

// insert function definitions here
</code></pre>
",2
30206974,30206887,1,"<p>Sort the rolls and count the number of consecutive dice. If you have four then you have a small straight. If all five rolls are consecutive then you have a large straight.</p>
",0
31157294,31155004,0,"<p>Your include statements are wrong, or in the wrong order.
Apparently <code>Theron/Framework.h</code> contains some code that needs the full definition of class <code>EndPoint</code> but doesn't explicitly include the header <code>EndPoint.h</code> and instead only provides a forward declaration.</p>

<p>To fix this, you can either try to include <code>EndPoint.h</code> before including <code>Framework.h</code> or replace all your Theron includes with the <code>Theron/Theron.h</code> all-inclusive wrapper.</p>
",1
31544646,31544604,0,"<p>You read the input into a string (<a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow""><code>std::getline()</code></a>), then attempt to parse it. <a href=""http://en.cppreference.com/w/cpp/string/byte/strtof"" rel=""nofollow""><code>strtod()</code></a> checking if it parses as a double (via the end pointer). If that fails, <a href=""http://en.cppreference.com/w/cpp/string/byte/strtol"" rel=""nofollow""><code>strtol()</code></a> to check if it parses as an int. I <em>assume</em> you mean ""true"" / ""false"" for the bool so you'd do a string <code>==</code> on those. And if all that fails, use it as a verbatim string.</p>

<p>All that is highly fragile, of course. The user might enter decimal commas or decimal points. He might add a whitespace after ""true"". All that stuff...</p>

<p>If you are looking for <em>real</em> parsing, <a href=""http://www.boost.org/doc/libs/release/libs/spirit/doc/html/index.html"" rel=""nofollow"">Boost.Spirit</a> would be the place to look for, but that is very involved and more for production-level parsers so I doubt that is what you are looking for.</p>
",2
33532857,33532413,1,"<p>
First, although not causing a problem, you initialize an array with data and then overwrite it.  The code</p>

<pre class=""lang-cpp prettyprint-override""><code>int a[6] = {1,6,3,8,5,10};
</code></pre>

<p>can be replaced with</p>

<pre class=""lang-cpp prettyprint-override""><code>int a[6];
</code></pre>

<p>Also, as stated in the comments,</p>

<pre class=""lang-cpp prettyprint-override""><code>int odd[]={};
</code></pre>

<p>isn't valid.  You should either allocate a buffer as big as the main buffer (6 ints) or use a vector (although I personally prefer c-style arrays for small sizes, because they avoid heap allocations and extra complexity).  With the full-size buffer technique, you need a value like <code>-1</code> (assuming you intend to only input positive numbers) to store after the list of values in the arrays to tell your output code to stop reading, or store the sizes somewhere.  This is to prevent reading values that haven't been set.</p>

<p>I don't understand your problem when 4 is in the input.  Your code looks fine except for your arrays.</p>
",0
33532492,33532413,0,"<p>You can use <code>std::vector&lt; int &gt; odd;</code> and then call only <code>odd.push_back(elem)</code> whem <code>elem</code> is odd.</p>
",0
33532617,33532413,1,"<p>You've got an Undefined Behavior, so result may be any, even random, even formatted hard drive.</p>

<p><code>int odd[] = {}</code> is the same as <code>int odd[/*count  of elements inside {}*/] = {/*nothing*/}</code>, so it's <code>int odd[0];</code> </p>

<p>Result is not defined when you're accessing elements besides the end of array.
You probably have to think about correct odd/even arrays size, or use another auto-sizeable data structure. </p>
",0
31828598,31827407,3,"<p>Check the types of your variables: some of them are wrong.</p>

<p>The specific thing that's triggering the message is that you are trying to initialize the <em>string</em> <code>frequencyHighest</code> with a null pointer, as specified by the literal <code>0</code>. (i.e. it's trying to use the constructor that takes a C-style string and copies it into the newly constructed <code>std::string</code>)</p>

<hr>

<p>When your program is crashing and you don't know what's causing it, one easy thing you can often do is simply keep removing parts of your program until it stops crashing; then you know the crash is probably related to the parts you just removed.</p>

<p>You can usually pin the cause down very narrowly this way -- and even if you can't, it gives you a much better sample program to post when you're asking for help.</p>

<p>Although as the comments said, a debugger would have made it even more plain.</p>
",4
31883756,31883694,4,"<blockquote>
  <p>1) Why is only data type name mentioned but no variable of it is mentioned?</p>
</blockquote>

<p>Because the parameter is not used, so the name is not needed.</p>

<blockquote>
  <p>2) Why is it allowed only for templated functions but not for non-templated functions?</p>
</blockquote>

<p>Actually it <em>is</em> allowed on non-templated functions as well.</p>
",0
31883758,31883694,3,"<p>Actually that's not related to templates at all.</p>

<p>It's an unnamed parameter and it's perfectly legal when:</p>

<ul>
<li>declaring a method (so you have no body)</li>
<li>defining a method that won't use that argument</li>
</ul>

<p>Basically you can respect a signature without having a named argument at all costs, eg:</p>

<pre><code>float foo(float, int, float);

int main()
{
  float x = foo(10.0f, 5, 20.0f);
  return 0;
}

float foo(float a, int, float b)
{
  return a+b;
}
</code></pre>

<p>This can be useful in some specific circumstances, think about pure <code>virtual</code> methods or forward declaration of methods.</p>

<p>In a specific case it helps to suppress the <strong>unused parameter</strong> warning, for example:</p>

<pre><code>float foo(float a, int z, float b)
{
  return a+b;
}
</code></pre>

<p>This yields a warning with <code>-Wunused-parameter</code> but won't if you explicitly state that you won't use it by removing its name.</p>
",0
31172970,31172928,1,"<p>Maybe you want this?</p>

<pre><code>template &lt;template &lt;typename ...&gt; class C, typename ...Args&gt;
bool CompareVector(C&lt;Args...&gt; const * lhs, C&lt;Args...&gt; const * rhs)
{
    // ...
}
</code></pre>

<p>If you only want it to work for vectors:</p>

<pre><code>template &lt;typename T, typename A&gt;
bool CompareVector(std::vector&lt;T, A&gt; const * lhs, std::vector&lt;T, A&gt; const * rhs);
</code></pre>

<p>If you want it to work for arbitrary template classes whose first template argument is a template class with one argument (but <em>why</em>):</p>

<pre><code>template &lt;template &lt;typename ...&gt; class C,
          template &lt;typename&gt; class SP,
          typename T,
          typename Args...&gt;
bool CompareBizzare(C&lt;SP&lt;T&gt;, Args...&gt; const * lhs, /* ... */);
</code></pre>

<p>Note that none of your desired function arguments are specializations of a template that has template template parameters. The standard library does not contain any templates that take template template parameters (<a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf"" rel=""nofollow"">for now</a>).</p>
",3
31853422,31853294,1,"<p>What are you trying to do here:</p>

<pre><code>Student * student1 = createStudent(student1-&gt;name, student1-&gt;gpa);
</code></pre>

<p>This is <strong>totally wrong!</strong> You try to create a <code>Student</code> object with the fields of an object you try to create - don't you see logical error here?</p>

<p>The one of correct usages is:</p>

<pre><code>Student * student1 = createStudent(""Smith"", 4.0f);
</code></pre>

<p>You <strong>can't</strong> use objects which are not created yet and you do this which causes a error.</p>
",0
30701788,30700403,1,"<p>Let's treat this like two problems. </p>

<p>Problem 1: Reading in the file.</p>

<p>I've stripped out everything that isn't absolutely essential to reading the data in. </p>

<pre><code>char input[100]; //Used to check grammar

int main(int argc, char *argv[]) {

    ifstream fin(""input.txt"");  //Open input file
    while (fin&gt;&gt;input) {  //Store text in input[]
        cout&lt;&lt;""String read from file:  ""&lt;&lt;input&lt;&lt;endl;  //Show input text
    }
    return 0;
}
</code></pre>

<p>Nothing really wrong here, but you should seriously consider replacing <code>char input[100];</code> with <code>std::string input;</code> to save you headaches with large tokens. For example, watch what happens here:</p>

<pre><code>int main()
{
    stringstream stream(""1234567890""); // pack ten characters into stream
                                       // note: no whitespace.
    char snookums[] = ""snookums"";
    char array[5];
    cout &lt;&lt; snookums &lt;&lt; endl; // prove contents of snookums
    stream &gt;&gt; array; // read up to first whitespace from stream into array
    cout &lt;&lt; array &lt;&lt; endl;  // display what we read.  
    cout &lt;&lt; snookums &lt;&lt; endl; // oh dear. Now look at poor snookums!
    return 0;
}
</code></pre>

<p>output:</p>

<pre><code>snookums
1234567890
67890
</code></pre>

<p>Despite array being size 5, it contains all 10. Or does it? Nope. Sadly poor snookums got run over. This won't happen with strings.</p>

<p>For all we know <code>fin&gt;&gt;input</code>just read 30000 characters from a whitespace-free file, annihilated the rest of your program's memory, and the program died before printing out anything.</p>

<p>Anyway, your code leaves a few questions:</p>

<p>Are you actually able to open the file? You don't know, really. You never checked. </p>

<p>Was the file empty? Also don't know. You didn't tell us. This is one of the things folks are getting on about in the comments.</p>

<p>None of this fixes anything, but hopefully gives you a better idea what's going wrong.</p>

<pre><code>string input; // using string in case the data you're reading is incompatible 
              //with a 100 character char array. 

int main(int argc, char *argv[]) {

    ifstream fin(""input.txt"");  //Open input file
    if (fin.is_open()
    {
        while (fin&gt;&gt;input) 
        {  //Store text in input
            cout&lt;&lt;""String read from file:  ""&lt;&lt;input&lt;&lt;endl;  //Show input text
        }
    }
    else
    {
        cout &lt;&lt; ""Failed to open file."" &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>Once you know if you are actually reading in data, and if not, why not.</p>

<p>Problem 2: language parsing.</p>

<p>We can't help you here. No information was provided, but a few notes on coding style because they will help you ask future questions:</p>

<p><code>A()</code> is meaningless to everyone but you. Give it a descriptive name so that someone other than you has some hints about what it does. <code>A()</code> takes no parameters. I assume that's because it is operating on <code>input</code>. OK, but why not pass <code>input</code> in? The cost is minimal and it provides more information to readers. Note how commenters zeroed in on <code>A()</code> right away? That's fear. The good kind of fear. We have no [insert expletive here] clue what it is or what it does, so it is instantly scrutinized.</p>

<p><code>A(input)</code> reads to me as ""A does something to input."" I don't know what it does, but it does it to <code>input</code>. Unless the writer of the program has a history of doing silly stuff, it probably only does stuff to <code>input</code> and I don't have to fear this function nearly as much.</p>

<p><code>LanguageInterpreter()</code> tells me that a language interpreter was run. Not much, but if I'm looking tor a bug in the file reading code, I'm not likely to find it in there. Unfortunately it also tells me that LanguageInterpreter is feasting on global data and Crom only knows what sort of side effects it could have on the rest of the program.</p>

<p><code>LanguageInterpretter(input)</code> tells me a lot. For one thing it tells me that I can get on with my day because it has nothing to do with, or better have nothing to do with, the reading in of the data file. I'll check other places for bugs first.</p>
",3
30701956,30700403,0,"<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>string *s;

int main() 
{
	string input;
    ifstream fin(""input.txt""); 
	
	if(fin.is_open())
	{  
		while(getline(fin,input))
		{
			s=&amp;input;
			
			if (A() &amp;&amp; *s == '\0') /* error: no match for 'operator==' in '* s == '\000''*/



			{  //Testing the grammar
				cout&lt;&lt;""The string \""""&lt;&lt;*s&lt;&lt;""\"" is in the language.""&lt;&lt;endl;
			}
			else cout&lt;&lt;""The string \""""&lt;&lt;*s&lt;&lt;""\"" is not in the language.""&lt;&lt;endl;
			cout&lt;&lt;endl;  
			
			
		}
	}
    fin.close();  
	
    
    return 0;
}</code></pre>
</div>
</div>
</p>
",0
30706314,30706196,2,"<p>At first I ought to recommend you <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">the definitive stackoverflow c++ books list</a>. Read these books and get your skills grow. This also will prevent questions like this.</p>

<p>Your question needs very-very basic knowledges and answers may be too long and your problem can be solved by many different methods.</p>

<p>I can tell you one but you should not ask questions like this.</p>

<p><strong>Answer</strong></p>

<p>Your code contains a mistakes:</p>

<ol>
<li><p><code>return 0</code> before your other instructions (it should be the last). Now your program will just do nothing.</p></li>
<li><p>You should always compile C++ code with C++ compiler. <code>gcc</code> is not a <code>c++</code> compiler but <code>c</code> compiler - use <code>g++</code> instead.</p></li>
<li><p>Even if you correct 2 errors above, your <code>std::cout</code> call may fail because it does not flush the stream. You should also add <code>&lt;&lt; std::endl</code> to this call.</p></li>
</ol>
",0
30706330,30706196,0,"<p>Execute</p>

<pre><code>g++ test.cpp -o out
</code></pre>

<p>Instead of</p>

<pre><code>gcc text.cpp
</code></pre>
",0
30706436,30706230,2,"<p><code>std::string</code> is part of the <a href=""https://isocpp.org/std/the-standard"" rel=""nofollow"">C++ standard</a> (cfr. <em>[string.classes]</em>) so it is available with every C++-standard conforming implementation.</p>

<p>Be aware though that something might have changed from a major C++ version to another one, e.g. <a href=""http://en.cppreference.com/w/cpp/string/basic_string/front"" rel=""nofollow"">std::string::front</a>     (since C++11). If you want your codebase to be portable and consistent you should keep this in mind and also check for the highest available (for whatever reason, stability, policies, backward compatibility, etc..) C++ version you can target.</p>
",0
30706262,30706230,2,"<p><code>std::string</code> is part of the standard library and should be available on any conforming implementation.</p>
",0
34220504,34220223,0,"<p>Assuming that <code>x()</code> happens to be <code>public</code> (or <code>protected</code>) member the function effectively exposes an implementation: the is an <code>int</code> held somewhere. Whether that is good or bad depends on context and as it stands there is very little context.</p>

<p>For example, if <code>x()</code> were actually spelled <code>operator[](Key key)</code> and part of a container class with subscript operator like <code>std::vector&lt;T&gt;</code> (in which case <code>Key</code> would really be <code>std::size_t</code>) or <code>std::map&lt;Key, Value&gt;</code> the use of returning a [non-<code>const</code>] reference is quite reasonable.</p>

<p>On the other hand, if the advice is to have such functions for essentially all members in a class, it is a rather bad idea as this access essentially allows uncontrolled access to the class's state. Having access functions for all members is generally and indication that there is no abstraction, too: having setters/getters for members tends to be an indication that the class is actually just an aggregate of values and a <code>struct</code> with all <code>public</code> members would likely serve the purpose as well, if not better. Actual abstractions where access to the data matters tend to expose an interface which is independent of its actual representation.</p>
",0
34220509,34220223,0,"<p>In this example, the effect of returning a (non-const) reference is the same as if you made the variable public. Any encapsulation is broken. However, that is not a bad thing by default. A case where this can help a lot is when the variable is part of a complicated structure and you want to provide an easy interface to that variable. For example</p>

<pre><code>class Foo {
    std::vector&lt;std::list&lt;std::pair&lt;int,int&gt;&gt;&gt; values;
    public: 
        int&amp; getFirstAt(int i){
            return values[i].[0].first;
        }
};
</code></pre>

<p>Now you have an easy access to the first element of the first element at position <code>i</code> and dont need to write the full expression every time. </p>

<p>Or your class might use some container internally, but what container it is should be a private detail, then instead of exposing the full container, you could expose references to the elements:</p>

<pre><code>class Bar {
    std::vector&lt;int&gt; values;   // vector is private!!
    public:
       int&amp; at(int i){         // accessing elements is public
           return values.at(i);
       }
};
</code></pre>
",0
34220644,34220223,1,"<p>IMO, this code is not a good practice in terms of evolution. If you need to provide some changes checking, formatting, you have to refactor your class API which can become a problem with time.</p>

<ol>
<li>Having <code>set_x()</code> would be a way cleaner. Moreover, it will allow you to have checking mechanics in your setter. </li>
<li>a proper getter <code>get_x()</code> or <code>x()</code> could also apply some logic (format, anything...) before returning. In your case, you should return <code>int</code> instead of <code>int&amp;</code> since setter should be used for modification (no direct modification allowed).</li>
</ol>

<p>And truly speaking, this code doesn't really make sense... it returns a reference on a property making it fully modifiable. Why not having directly a public property then ? And avoid creating an additional method ?</p>

<p>Do you want control or not on your data? If you think so, then you probably want a proper getter and setter. If not, you probably don't need a method, just make it public.</p>

<p>To conclude, I would say you are right, because the way you see it would make it better over the time, prone to non-breaking change, better to read.</p>

<p>As the UNIX philosophy mentions : ""Rule of Clarity: Clarity is better than cleverness.""</p>
",0
34220896,34220223,0,"<p>In general such a  code confuses readers.</p>

<pre><code>obj.x() = 5;
</code></pre>

<p>However it is not rare to meet for example the following code</p>

<pre><code>std::vector&lt;int&gt; v = { 1, 0 };
v.back() = 2;
</code></pre>

<p>It is a drawback of the C++ language. </p>

<p>In C# this drawback was avoided by introducing properties.</p>

<p>As for this particular example it would be better to use a getter and a setter.</p>

<p>For example</p>

<pre><code>class Foo { 
    int x_;

    public:
    int get_value() const { return x_; }
    void set_value( int value ) { x_ = value; }
};
</code></pre>

<p>In this case the interface can be kept while the realization can be changed.</p>
",0
31219605,31219577,1,"<p><code>(ch != 'X')||(ch != 'x')</code> is always <code>true</code>, you probably means <code>&amp;&amp;</code> instead of <code>||</code>.</p>
",1
31219621,31219577,2,"<p>use</p>

<pre><code>    if ((ch != 'X') &amp;&amp; (ch != 'x'))
</code></pre>

<p>instead of</p>

<pre><code>  if ((ch != 'X')||(ch != 'x'))
</code></pre>

<p>Also instead of using <code>goto</code> you could use a loop</p>

<pre><code> cout &lt;&lt; ""enter a Character"" &lt;&lt; endl;
 cin &gt;&gt; ch;
 while(ch!='X' &amp;&amp; ch!='x')
 {
      cout &lt;&lt; ""Please Enter Right Number"" &lt;&lt; endl;
      cout &lt;&lt; ""enter a Character"" &lt;&lt; endl;
      cin&gt;&gt;ch;
 }
</code></pre>
",6
34236963,34236915,1,"<p>Since floating point numbers usually cannot be stored exactly, there are very small errors included in any result from computation on them.  When combined with the optimizer you can get some puzzling results, which your case is one.</p>

<p>In the first case, the compiler keeps the result of <code>a</code> and <code>d</code> in the FPU registers, which (on x86, in 32 bit code) have more precision than a double.  These long double values are then subtracted, giving you a slight difference.  When you add in the cout call, the <code>a</code> and <code>d</code> values are written out to memory (both rounding to the same number), then read back into the FPU registers to do the subtraction, which gives you the zero.</p>
",0
31117527,31117487,10,"<p>Your entire structure needs to be <code>if</code>-<code>else if</code>-<code>else</code>, like so:</p>

<pre><code>if(ch=='+')
    cout&lt;&lt;""The sum of the two numbers is: ""&lt;&lt;num1+num2&lt;&lt;endl;
else if(ch=='-')
    cout&lt;&lt;num2&lt;&lt;"" subtracted from ""&lt;&lt;num1&lt;&lt;"" is ""&lt;&lt;num1-num2&lt;&lt;endl;
else if(ch=='*')
    cout&lt;&lt;""When multiplied: ""&lt;&lt;num1*num2&lt;&lt;endl;
else if(ch=='/')
    cout&lt;&lt;num1&lt;&lt;"" divided by ""&lt;&lt;num2&lt;&lt;"" will be ""&lt;&lt;num1/num2&lt;&lt;endl;
else 
    cout&lt;&lt;""Wrong input. Try again."";
</code></pre>

<p>But is this the best way to do things? Probably not. Since you're just testing to see what <code>ch</code> is equal to, you can actually make use of another built-in C++ construct, the <code>switch</code> statement:</p>

<pre><code>switch (ch) {
  case '+':
    cout &lt;&lt; ""The sum of the two numbers is: "" &lt;&lt; num1+num2 &lt;&lt; endl;
    break;
  case '-':
    cout &lt;&lt; num2 &lt;&lt; "" subtracted from "" &lt;&lt; num1 &lt;&lt; "" is "" &lt;&lt; num1-num2 &lt;&lt; endl;
    break;
  case '*':
    cout &lt;&lt; ""When multiplied: "" &lt;&lt; num1*num2 &lt;&lt; endl;
    break;
  case '/':
    cout &lt;&lt; num1 &lt;&lt; "" divided by "" &lt;&lt; num2 &lt;&lt; "" will be "" &lt;&lt; num1/num2 &lt;&lt; endl;
    break;
  default:
    cout &lt;&lt; ""Wrong input. Try again."" &lt;&lt; endl;
    break;
}
</code></pre>
",0
31117557,31117487,6,"<p>In your original code, the <code>else</code> only applies to the last <code>if</code> statement. You need to chain your conditions:</p>

<pre><code>if(ch=='+')
    cout&lt;&lt;""The sum of the two numbers is: ""&lt;&lt;num1+num2&lt;&lt;endl;
else if(ch=='-')
    cout&lt;&lt;num2&lt;&lt;"" subtracted from ""&lt;&lt;num1&lt;&lt;"" is ""&lt;&lt;num1-num2&lt;&lt;endl;
else if(ch=='*')
    cout&lt;&lt;""When multiplied: ""&lt;&lt;num1*num2&lt;&lt;endl;
else if(ch=='/')
    cout&lt;&lt;num1&lt;&lt;"" divided by ""&lt;&lt;num2&lt;&lt;"" will be ""&lt;&lt;num1/num2&lt;&lt;endl;
else 
    cout&lt;&lt;""Wrong input. Try again."";
</code></pre>

<p>However, you are probably better off using a <code>switch</code> statement:</p>

<pre><code>switch (ch) {
case '+':
    cout&lt;&lt;""The sum of the two numbers is: ""&lt;&lt;num1+num2&lt;&lt;endl;
    break;
case '-';
    cout&lt;&lt;num2&lt;&lt;"" subtracted from ""&lt;&lt;num1&lt;&lt;"" is ""&lt;&lt;num1-num2&lt;&lt;endl;
    break;
case '*':
    cout&lt;&lt;""When multiplied: ""&lt;&lt;num1*num2&lt;&lt;endl;
    break;
case '/':
    cout&lt;&lt;num1&lt;&lt;"" divided by ""&lt;&lt;num2&lt;&lt;"" will be ""&lt;&lt;num1/num2&lt;&lt;endl;
    break;
default:
    cout&lt;&lt;""Wrong input. Try again.""; 
}
</code></pre>
",0
31117564,31117487,1,"<p><code>else</code> part will always be executed when <code>ch</code> is not equal to <code>/</code> because the else part is matched to <code>if(ch=='/')</code> only.Probably you want to use if else ladder or switch case.</p>
",0
31117625,31117487,0,"<p>The ""Else-statement"" is linked with the last ""if-statement"". So, if the non last if-statement avaliates to true, then the last one will avaliate to false, and this implies on true avaliation to else-statement. You can change your if-statement to ""else if"" (don't chage the first if-statement).</p>
",0
31150533,31150214,0,"<ol>
<li>There is copy-paste mistake in your code</li>
<li>In the problem description you say ""I added a menu to the program for the employee to be able to choose which item they want to do inventory for. I would like this menu to keep being displayed until ALL choices (items) have been accounted for"".<br><br>So whats the point to give them a choice to choose which item they would want to do inventory for if they MUST choose all the items before showing the result?<br><br>I suggest you remove the switch case and put the ""shirts"", ""pants"" and ""shoes"" items one by one. There is no need for switch case.</li>
</ol>
",5
31151997,31150214,0,"<p>I've scrapped the whole menu idea and added different loops and methods to make my code longer. I added a class that produces an order to be placed for the missing inventory items.
here is my final project completed. Thank you for all that tried to help!</p>

<pre><code>        //Name: Abdul Tabel
    //Inventory program

    #include &lt;iostream&gt; 
    #include &lt;iomanip&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;fstream&gt;
    #include &lt;cstdlib&gt;
    #include &lt;array&gt;
    #include &lt;list&gt;
    using namespace std; 


    // clothing item class declaration
    class Item
    {
        private: 
            double small;
            double medium;
            double large;
            string description;
        public: 
            void setDescription(string);
            void setSmall(double);
            void setMedium(double);
            void setLarge(double);
            string getDescription() const;
            double getRem() const;
            double getSmall() const;
            double getMedium() const;
            double getLarge() const;
            double allRem() const;
            bool orderMore(int);
            /*Item();*/
    };


    class Order
    {
        private:
            string description;
            string size;
            double qty;
            int OrderNumber;
        public:
            void setDescription(string);
            void setSize(string);
            void setQty(double);
            void setOrderNumber();
            string getDescription() const;
            string getSize() const;
            double getQty() const;
            int getOrderNumber() const;
    };

    //methods for Order class
        string Order::getDescription() const
        {
            return description;
        }

        string Order::getSize() const
        {
            return size;
        }

        double Order::getQty() const
        {
            return qty;
        }

        int Order::getOrderNumber() const
        {
            return OrderNumber;
        }

        void Order::setDescription(string x)
        {
            description = x;
        }

        void Order::setSize(string x)
        {
            size = x;
        }

        void Order::setQty(double x)
        {
            qty = x;  
        }

        void Order::setOrderNumber()
        {
            OrderNumber = (rand() % 900) + 100;
        }

    bool Item::orderMore(int Count)
    {
        bool returnValue = false;
        if (Count &lt; 5)
        {
            returnValue = true;
        }

        return returnValue;
    }

    //menu function
    void showMenu()
    {   
        cout &lt;&lt; ""Please enter the items remaining for the following items"" &lt;&lt; endl;
    }

        //assign value to small item
    void Item::setDescription(string x)
    {
        description = x;    
    }

    //assign value to small item
    void Item::setSmall(double number)
    {
        small = number; 
    }

    //assign value to medium item
    void Item::setMedium(double number)
    {
        medium = number;    
    }

    //assign value to large item
    void Item::setLarge(double number)
    {
        large = number; 
    }

    string Item::getDescription() const
    {
        return description;
    }


    //gets value from small variable
    double Item::getSmall() const
    {
        return small;
    }

    //gets value from medium variable
    double Item::getMedium() const
    {
        return medium;
    }

    //gets value from large variable
    double Item::getLarge() const
    {
        return large;
    }

    //gets total of reamining items
    double Item::allRem() const
    {
        return small + medium + large;
    }






    int main() 
    { 
        double number;
        std::array &lt;string,4&gt; itemType = {""shirts"", ""pants"", ""shoes"", ""coats""};

        //dynamic allocation of array size
        Item *items;
        items = new Item[itemType.size()];


        //for loop will iterate through all items in array
        showMenu();
        for(int i=0; i &lt; itemType.size(); i++)
        {
            items[i].setDescription(itemType[i]);
                        cout &lt;&lt; ""Enter how many small "" + itemType[i] + "" are left? "";
                        cin &gt;&gt; number;
                        items[i].setSmall(number);
                        cout &lt;&lt; ""Enter how many medium "" + itemType[i] + "" are left? "";
                        cin &gt;&gt; number;
                    items[i].setMedium(number);
                        cout &lt;&lt; ""Enter how many large "" + itemType[i] + "" are left? "";
                        cin &gt;&gt; number;
                    items[i].setLarge(number);
        }


        //being displaying inventory results
        cout &lt;&lt; endl &lt;&lt; ""\n*******************"";
        cout &lt;&lt; endl &lt;&lt; ""*Inventory results*"";
        cout &lt;&lt; endl &lt;&lt; ""*******************"" &lt;&lt; endl;

        // dynamically creates a list for the unknown orders
        list&lt;Order&gt; orders;

        // Output the quantitis entered back to the user and create orders for the ones that need orders.
        for(int i=0; i &lt; itemType.size(); i++)
        {
            cout &lt;&lt; endl &lt;&lt; ""There are "" &lt;&lt; items[i].getSmall() &lt;&lt; "" small "" &lt;&lt; items[i].getDescription() &lt;&lt; "" left. "";
            if (items[i].orderMore(items[i].getSmall()))
            {
                cout &lt;&lt; "" Automatically creating order for this product"";
                Order m;
                m.setDescription(items[i].getDescription());
                m.setQty(5-items[i].getSmall());
                m.setSize(""small"");
                m.setOrderNumber();   
                orders.push_front(m);
            }

            cout &lt;&lt; endl &lt;&lt; ""There are "" &lt;&lt; items[i].getMedium() &lt;&lt; "" medium "" &lt;&lt; items[i].getDescription() &lt;&lt; "" left."";
            if (items[i].orderMore(items[i].getMedium()))
            {
                cout &lt;&lt; "" Automatically creating order for this product"";
                Order m;
                m.setDescription(items[i].getDescription());
                m.setQty(5-items[i].getMedium());
                m.setSize(""medium"");
                m.setOrderNumber();   
                orders.push_front(m);
            }
            cout &lt;&lt; endl &lt;&lt; ""There are "" &lt;&lt; items[i].getLarge() &lt;&lt; "" large "" &lt;&lt; items[i].getDescription() &lt;&lt; "" left."";
            if (items[i].orderMore(items[i].getLarge()))
            {
                cout &lt;&lt; "" Automatically creating order for this product"";
                Order m;
                m.setDescription(items[i].getDescription());
                m.setQty(5-items[i].getLarge());
                m.setSize(""large"");
                m.setOrderNumber();   
                orders.push_front(m);
            }
            cout &lt;&lt; endl &lt;&lt; ""There are "" &lt;&lt; items[i].allRem() &lt;&lt; "" total "" &lt;&lt; items[i].getDescription() &lt;&lt; "" left."" &lt;&lt; endl;
        }

        cout &lt;&lt; endl &lt;&lt; ""\n*******************"";
        cout &lt;&lt; endl &lt;&lt; ""*  Order results  *"";
        cout &lt;&lt; endl &lt;&lt; ""*******************"" &lt;&lt; endl;

        list&lt;Order&gt;::iterator iter; //iterator is used to iterate through all objects in the list
        // loop for orders
        for (iter = orders.begin(); iter != orders.end(); iter++)
        {           
            cout &lt;&lt; endl &lt;&lt; ""Order placed for "" &lt;&lt; iter-&gt;getQty() &lt;&lt; "" "" &lt;&lt; iter-&gt;getSize() &lt;&lt; "" "" &lt;&lt; iter-&gt;getDescription() &lt;&lt; "" on order number: "" &lt;&lt; iter-&gt;getOrderNumber();
        }

        cin.get(); cin.get();
        return 0;
    }
</code></pre>
",0
31242254,31242205,0,"<p><code>ptr</code> will ""refers"" to first element of the array.</p>

<p>Every other element will be accessed by ""adding"" to base pointer address value, the size of the element multiplied by the index</p>
",0
31242256,31242205,0,"<p>The pointer is just a number representing the memory address of the start of the array. It does not contain any information about the array itself, so there is no limit on the size of the array it points to.</p>
",0
31242306,31242205,6,"<p>In this declaration</p>

<pre><code>int *ptr = arr;
</code></pre>

<p>pointer <code>ptr</code> is initialized by the address of the first element of array <code>arr</code>.</p>

<p>An expression like this <code>ptr[i]</code> is considered by the compiler like <code>*(ptr + i)</code> where <code>ptr + i</code> results in a pointer that points to the i-th element of array <code>arr</code></p>

<p>This has a consequence that instead of <code>ptr[i]</code> you can even write <code>i[ptr]</code> because in the both expressions there is used the same pointer arithmetic.</p>

<p>Try for example</p>

<pre><code>std::cout &lt;&lt; 6[""Hello CMan""] &lt;&lt; std::endl;
</code></pre>

<p>or</p>

<pre><code>std::cout &lt;&lt; &amp;6[""Hello CMan""] &lt;&lt; std::endl;
</code></pre>

<p>So using pointer <code>ptr</code> that points to the first element of array <code>arr</code> and the so-called pointer arithmetic you can access any element of array arr.</p>

<p>The pointer does not accomodate the array. The pointer and the array occupy different memory regions. But the pointer stores the address of the first element of the array.</p>
",0
31242354,31242205,0,"<p>The type of <code>ptr</code> is <code>int*</code> and sizeof therefore returns the number of bytes used to store a pointer in memory. It does not return the size of the array.</p>
",0
31243472,31242205,0,"<p>You can find the answer for this question (and may be more than that) in these bellow link:</p>

<p><a href=""https://stackoverflow.com/questions/18361111/are-a-a-a-a0-a0-and-a00-identical-pointers"">Are a, &amp;a, *a, a[0], &amp;a[0] and &amp;a[0][0] identical pointers?</a></p>

<p><a href=""https://stackoverflow.com/questions/492384/how-to-find-the-sizeofa-pointer-pointing-to-an-array"">How to find the &#39;sizeof&#39; (a pointer pointing to an array)?</a> </p>
",0
31222866,31222847,0,"<pre><code>string gradebook::getcouseName(){
</code></pre>

<p>Typo in function name here.</p>
",4
31234099,31230583,0,"<p>CoryKramer's suggestion was correct. <code>cin</code> will stop after the first whitespace. If you want to read a whole line, you use <code>getline</code>. I've made changes to your code to show this as well as renamed the function you use to get the sentence from the user. Also, you don't have to convert to a c-style string for this to work, a string works just fine.</p>

<pre><code>//Function prototypes.
void pause();
void getSentence(string&amp;);
int numWords(string&amp;);

int main()
{
    string userVal;
    getSentence(userVal);

    int fin = numWords(userVal);
    cout &lt;&lt; ""The number of words in the sentence is "" &lt;&lt; fin &lt;&lt; ""."" &lt;&lt; endl;

    pause();
    return 0;
}

void getSentence(string &amp;len)
{
    cout &lt;&lt; ""Please enter a sentence and I will tell you how many words it has: "" &lt;&lt; endl;
    getline(cin, len);
}

int numWords(string&amp; usStr)
{
    int wrdCount = 0,
        chrCount = 0,
        index = 0;
    while(index &lt; usStr.length())
    {
        ...
    }
    if(chrCount)
        wrdCount++;
    return wrdCount;
}
</code></pre>

<p>You also probably want to <code>#include &lt;string&gt;</code></p>
",2
31244916,31242280,0,"<p>There are three possible reasons:</p>

<ol>
<li>Contention</li>
<li>CPU starvation</li>
<li>Bugs in the implementation - peer-review the code, fix the bug</li>
</ol>

<p>With all of them a ""poor man profiler"" would be a reasonable tool to start from (unless you have VTune installed, which does the same but automatically): run <code>gstack</code> multiple times while running the app and look at stack traces, they may point towards where the time is spent.</p>
",0
32410201,32400329,0,"<p>Instead of ""C:>start"" use ""start"" or the full path to the program file. ""C:>"" is the command prompt.</p>
",0
34241529,34241473,2,"<blockquote>
  <p>i want to reset all temporary variables</p>
</blockquote>

<p>Why? This requirement appears to be entirely arbitrary.</p>

<p>Furthermore, it makes no sense, because C++ already does this for you: those variables are bound to the scope of the loop. Each time the loop iterates, you get new versions of the variables. The integers of one iteration are unrelated to the integers of the last iteration.</p>

<p>Of course to ""clear"" an integer in general you'd just set it to whatever you initialised it to, e.g. <code>0</code>.</p>

<p>By the way, that is not how we spell ""length"".</p>
",0
31864988,31864945,5,"<p><code>&amp;str</code> is the address of the pointer. You are changing the pointer as you iterate over the characters, but the pointer that you are changing is still located at the same spot.</p>

<p>Edit: change your <code>cout &lt;&lt; &amp;str &lt;&lt; endl;</code> to <code>cout &lt;&lt; ""pointer loc&lt;"" &lt;&lt; &amp;str &lt;&lt; ""&gt; pointer value&lt;"" &lt;&lt; (void*)str &lt;&lt; ""&gt;"" &lt;&lt; endl;</code> and see what it says.</p>
",4
31809505,31809388,3,"<p>The third argument can be a function object that is an object that can be used in the postfix expression of function call.</p>

<p>From the C++ Standard (20.9 Function objects)</p>

<blockquote>
  <p>1 A function object type is an object type (3.9) that can be the type
  of the postfix-expression in a function call (5.2.2, 13.3.1.1).231 A
  function object is an object of a function object type. In the places
  where one would expect to pass a pointer to a function to an
  algorithmic template (Clause 25), the interface is specified to accept
  a function object. <strong>This not only makes algorithmic templates work
  with pointers to functions, but also enables them to work with
  arbitrary function objects</strong></p>
</blockquote>

<p>Here is an example</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

int main()
{
    const size_t N = 10;
    int a[N] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    struct A
    {
        void operator()( int x ) const { std::cout &lt;&lt; x &lt;&lt; ' '; }
    };

    std::for_each( a, a + N, A() );
    std::cout &lt;&lt; std::endl;
}    
</code></pre>

<p>The program output is</p>

<pre><code>0 1 2 3 4 5 6 7 8 9
</code></pre>

<p>Here is temporary object <code>A()</code> of type <code>struct A</code> is a function object because it can be used in the postfix expression of function call due to the definition of the function call operator <code>in struct A</code>.</p>

<p>For example you can write</p>

<pre><code>std::cout &lt;&lt; A()( a[0] ) std::endl;
</code></pre>

<p>or</p>

<pre><code>A obj;
std::cout &lt;&lt; obj( a[0] ) std::endl;
</code></pre>

<p>As you see expression <code>obj( a[0] )</code> looks like a function call.</p>
",2
31809584,31809388,0,"<p>From <a href=""http://www.cplusplus.com/reference/algorithm/for_each/"" rel=""nofollow"">cplusplus.com</a> :</p>

<blockquote>
<pre><code>template&lt;class InputIterator, class Function&gt;
Function for_each (InputIterator first, InputIterator last, Function fn);</code></pre>
  
  <p><strong>Parameters</strong></p>
  
  <p><code>first</code>, <code>last</code><br>
  Input iterators to the initial and final positions in
  a sequence. The range used is <code>[first,last)</code>, which contains all the
  elements between first and last, including the element pointed by
  first but not the element pointed by last.</p>
  
  <p><code>fn</code><br>
  Unary function that
  accepts an element in the range as argument.<br>
  This can either be a function pointer or a move constructible function object.<br>
  Its return value, if any, is ignored.</p>
</blockquote>
",0
31899419,31899097,4,"<p>You are initializing your array of strings with zeros. That's an invalid initialization.</p>

<p>Interestingly, had you picked any other number, you'd get a clearer error message, telling you that you're doing an invalid conversion from int to const char* (which is a c-style string, and the closest valid input type std::string has a constructor for).
Unfortunately, the zero initialization is confusing your compiler to think you're actually assigning a pointer, which it may convert, but luckily it checks and sees that the pointer is NULL, and therefore bails out with the error message you saw: <code>basic_string::_S_construct null not valid</code>.</p>

<p>I took your code and removed all the SDL part, it compiled and reproduced the error.</p>

<p>I then replaced </p>

<pre><code>std::string rules[numAnts]={0};
</code></pre>

<p>with </p>

<pre><code>std::string rules[numAnts];
</code></pre>

<p>which uses the default constructor to create empty strings for all elements, and now it seems to work.</p>
",8
33547563,33547243,0,"<p>There are various problems with your code, the last one is the most serious:</p>

<p>This looks strange:</p>

<pre><code>WCHAR**processName = (WCHAR**)malloc(sizeof(WCHAR));
</code></pre>

<p>I suppose you want a pointer to WCHAR*, why dont you:</p>

<pre><code>WCHAR* processName;
</code></pre>

<p>and then:</p>

<pre><code>GetProcessImageNameFromPID::getProcessNameFromProcessID(4, &amp;processName);
                                                           ^~~~~ !!
</code></pre>

<p>What is the type of <code>processImageName</code>? What is the name of the process, if it contains non ASCII chars then your conversion code will give wrong characters.</p>

<p>Another is that code:</p>

<pre><code>*processName = allprocessName;
</code></pre>

<p>is making *processName equal to pointer which is dangling pointer after your function ends, it points to WCHAR array in:</p>

<pre><code>PROCESSENTRY32 pe32;
</code></pre>

<p>which is created on stack.</p>

<p>What you should do is make processName an array:</p>

<pre><code>WCHAR processName[MAX_PATH];
</code></pre>

<p>and inside your function copy process name from pe32 to this array.</p>
",2
32395666,32395413,0,"<pre><code>typedef int array[row][col];
</code></pre>

<p>What you are doing here is creating an alias for <code>int</code> that's called <code>array[row][col]</code>. Just remove the <code>typedef</code> and it will work just fine.</p>

<p><strong>Edit</strong>: Forgot about the other error</p>

<pre><code>void setValues(int (&amp;array)[row][col], int value)
</code></pre>

<p>It also works like this</p>

<pre><code>void setValues(int array[row][col], int value)
</code></pre>
",6
32458632,32458534,1,"<p>I do not see anything wrong about your code (except the formatting). This is the way you can initialize global variables in both C and C++ (complete, formatted example):</p>

<pre><code>#include &lt;iostream&gt;

void Initializer(double x, double y);

using namespace std;

double a, b;

void Initializer(double x, double y) {
    a = x;  // a and b are global variables.
    b = y;
}
int main() {
    Initializer(0.0, 4.0);
    cout &lt;&lt; a &lt;&lt; "" "" &lt;&lt; b &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Note that this line: <code>cout &lt;&lt; a &lt;&lt; "" "" &lt;&lt; b &lt;&lt; endl;</code> (together with the corresponding <code>include</code> and <code>using namespace std;</code>) is using C++ streams. The rest could also be compiled as C code. </p>

<p>It would also be more readable if you would provide doubles like that: <code>Initializer(0.0, 4.0);</code>.</p>
",4
32982542,32982460,1,"<p>you can use something like:</p>

<pre><code>int rowsinput;
do{
  cout &lt;&lt; ""Enter an odd number width: "";
  cin &gt;&gt; rowsinput; 
}while(rowsinput % 2 == 0)
</code></pre>
",1
32982560,32982460,0,"<p>Consider as a substitute </p>

<pre><code>while (!(cin &gt;&gt; rowsinput) ||  // bad, non-parsable input
       (rowsinput % 2 == 0) || // even number
       (rowsinput  &lt; 0))       // negative number
{
    cout &lt;&lt; ""Please enter an odd number width: "";
    cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
    cin.clear();
}
// input is good. Carry on with rest of program
</code></pre>

<p>This will loop until the user provides a valid integer, that integer is odd, and the integer is positive. If any of those conditions is not met, the user is prompted for more input, all current (bad) input is discarded, and any error conditions on the input stream are cleared.</p>

<p>Edit:</p>

<p>Requires an additional <code>#include &lt;limits&gt;</code> to get the numeric limits in the ignore call.</p>
",0
32982569,32982460,0,"<p>Add <strong>cin</strong> statement inside while loop as follows:</p>

<pre><code>while(rowsinput % 2 ==0)
{
    cout &lt;&lt; ""Please enter an odd number width: "";
    cin &gt;&gt; rowsinput;
}
</code></pre>

<p>Your final code will be as follows :</p>

<pre><code>cout &lt;&lt; ""Enter an odd number width: "";
cin &gt;&gt; rowsinput;
while(rowsinput % 2 ==0)
{
    cout &lt;&lt; ""Please enter an odd number width: "";
    cin &gt;&gt; rowsinput;
}
</code></pre>
",1
33019104,33019016,0,"<p>Read a line, verify if it matches the pattern <code>^[0..9]\]</code> and, if so, read the rest of the line as a CSV or parse the data you need (with sscanf maybe?)</p>
",2
32940021,32936678,0,"<p>Your add method doesn't work, if the item to insert goes at the end it is not inserted (because you are checking for curr == NULL before inserting). Since head is set to NULL when you create the list if(curr &amp;&amp; ...) won't ever be true and no item will be inserted.</p>
",2
32940548,32940501,0,"<p>Following will simply constructs new <code>rational</code> object and destroys, it won't assign your current object</p>

<pre><code> rational(x,y);
</code></pre>

<p>You need to assign the members of your class in overloaded <code>&lt;&lt;</code> operator</p>

<pre><code>input &gt;&gt; r.numer &gt;&gt; r.denom;
</code></pre>

<p>To actually perform validation or your entered data you <em>could</em> create separate function, which will be called before performing any calculations</p>

<pre><code> #include &lt;stdexcept&gt;

 bool rational::validate( ) const // private member function
 {
      return denom == 0  ? false : true ;     
 }

 friend istream&amp; operator&gt;&gt;( istream  &amp;input, rational &amp;r )
 {        

      input &gt;&gt; r.numer &gt;&gt;r.denom;

      if( !r.validate () )
             throw std::runtime_error(""Bad Input"") ;
      return input;

 }
</code></pre>

<p>You can call this validate in parameterized constructor too. Remember the second constructor will be called when you invoke with argument and use that object.</p>

<p>See <a href=""http://rextester.com/VCYBM30135"" rel=""nofollow""><em><code>here</code></em></a></p>
",1
32940763,32940501,0,"<p>With this statement,</p>

<pre><code>rational r1;
</code></pre>

<p>the default constructor of rational object r1 gets called.</p>

<pre><code>rational():numer(1),denom(1)
{

}
</code></pre>

<p>and you are printing:</p>

<pre><code>cout&lt;&lt;(r1+r2)&lt;&lt;endl; 
</code></pre>

<p>so, your result is 2, since default values are set to 1 each.</p>

<p>This does not work the way you expect it to:</p>

<pre><code>cin &gt;&gt; r1&gt;&gt; op&gt;&gt; r2;
</code></pre>

<p>you need to overload the stream operator >> for your object(class) and then add your logic there.</p>

<pre><code> friend istream&amp; operator&gt;&gt;( istream  &amp;input, rational &amp;r )
{ 

     //push the values into object
      input &gt;&gt; r.numer &gt;&gt;r.denom;    
}
</code></pre>
",2
32964648,32963735,1,"<p>Accessing the value of an uninitialised pointer - let alone dereferencing it - gives undefined behaviour.</p>

<p>The nature of undefined behaviour is that any result is permitted, but there is no requirement for anything in particular.   That word ""any"" is pretty wide ranging .... Emitting an error message is correct.   Not emitting an error message is correct.   Reformatting your hard drive and installing a different operating system is correct (although unlikely in practice).</p>
",0
32963818,32963735,1,"<p>I just compiled this in Visual studio , I got below error.May be the compiler that you choose does not have these checks? What is the compiler that you are using ?</p>

<pre><code>error C4700: uninitialized local variable 'Obj' used
</code></pre>
",1
32963847,32963735,4,"<p>Using an uninitialized pointer is <strong>undefined behaviour</strong>.  This means that the implementation can <em>do whatever it wants</em>, or <em>do nothing at all</em>.</p>

<p>The behaviour just isn't defined.</p>
",0
33006291,33006171,2,"<p>Your <code>main()</code> does not call any of the functions you have defined. It only consists of variable definitions.</p>

<p>Since this is C++, if your <code>main()</code> does not return explicitly, it will return a 0, which is what you see.</p>

<p>I am also not sure about your <code>int computePay()</code>: it doesn't seem to return any <code>int</code>, even though it should, probably? Or do you want it to be <code>void</code>?</p>
",2
33006300,33006171,0,"<p>There are multiple issues in your code:</p>

<p>1.) You're never calling any of your functions in <code>main()</code>. So all it does is creating some variables and end the program.
Try to add to main something like:</p>

<pre><code>userInput(Length, AuthorLevel);
</code></pre>

<p>or</p>

<pre><code>computePay(Length, AuthorLevel);
</code></pre>

<p>2.) Your functions <code>int computePay(int&amp; Length, char&amp; AuthorLevel)</code> &amp; <code>int main()</code> are declared as returning int, but you never return anything: This causes undefined behavior.
Just add <code>return 0;</code> at the end of the function - or change the type to float and return your <code>PayOut</code> variable.</p>

<p>3.) You missed the prototype for <code>int computePay(int&amp; Length, char&amp; AuthorLevel);</code> at the beginning, so you won't be able to call it from your main function.</p>

<p>4.) Your comutePay function will never return and cause a stack overflow - everytime in your loop you make a recursive call, which will never end.
you need to check the <code>Length</code> variable before your <code>comutePay</code> call</p>
",0
33563618,33562552,2,"<p>You can skip leading whitespace from a stream using <code>std::ws</code>. For example:</p>

<pre><code>std::cin &gt;&gt; std::ws;
</code></pre>

<p>This use of <code>&gt;&gt;</code> just invokes the <em>manipulator</em> <code>std::ws</code> on the stream. To meet the teacher's requirements you can invoke it directly:</p>

<pre><code>std::ws(std::cin);
</code></pre>

<p>Formatted input automatically skips whitespace. Note that should also <em>always</em> check whether input was successful:</p>

<pre><code>if (std::cin.get(TemporaryStorage)) {
    ...
}
</code></pre>
",3
33563648,33562552,6,"<p>As a preface, I want to state that this is a question <em>made by a student</em>, but unlike most of their type, it <em>is a quality question</em> that merits a quality answer, so I'll try to do it ;). I won't try to just answer your concrete question, but also to show you other slight problems in your code.</p>

<p>First of all, let's analyze your code step by step. More or less like what a debugger would do. Take your time to read this carefully ;)...</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;CTYPE.h&gt;
</code></pre>

<p>Includes headers <code>&lt;iostream&gt;</code> and <code>&lt;ctype.h&gt;</code> (the uppercase works because of some flaws/design-decisions of NTFS in Windows). I'ld recommend you to change the second line to <code>#include &lt;cctype&gt;</code> instead.</p>

<pre><code>using namespace std;
</code></pre>

<p>This is okay for any beginner/student, but <em>don't</em> get an habit of it! For the purposes of ""purity"", I would explicitly use <code>std::</code> along this answer, as if this line didn't existed.</p>

<pre><code>int ReadInt (unsigned short int &amp;UserIn);
</code></pre>

<p>Declares a function <code>ReadInt</code> that takes a reference <code>UserIn</code> to type <code>unsigned short int</code> and returns an object of type <code>int</code>.</p>

<pre><code>int main()
{
</code></pre>

<p>Special function <code>main</code>; no parameters, returns <code>int</code>. Begin function.</p>

<pre><code>    int Error;
    unsigned short int UserInput;
    char RepeatProgram;
</code></pre>

<p>Declares variables <code>Error</code>, <code>UserInput</code>, and <code>RepeatProgram</code> with respective types <code>int</code>, <code>unsigned short int</code>, and <code>char</code>.</p>

<pre><code>    do
    {
</code></pre>

<p>Do-while block. Begin.</p>

<pre><code>        Error=ReadInt(UserInput);
</code></pre>

<p>Assign return value of <code>ReadInt</code> of type <code>int</code> called with argument <code>UserInput</code> of type <code>int&amp;</code> to variable <code>Error</code> of type <code>unsigned short int</code>.</p>

<pre><code>        if (Error==0)
            std::cout &lt;&lt; ""Number is "" &lt;&lt; UserInput &lt;&lt; endl;
</code></pre>

<p>If <code>Error</code> is zero, then print out <code>UserInput</code> to standard output.</p>

<pre><code>        else if (Error==1)
            std::cout &lt;&lt; ""Illegal Data Entry\n"";

        else if (Error==2)
            std::cout &lt;&lt; ""Numerical overflow, number too big\n"";
</code></pre>

<p>Otherwise, if an error occurs, report it to the user by means of <code>std::cout</code>.</p>

<pre><code>        std::cout &lt;&lt; ""Continue?  n/N to quit: "";
        std::cin &gt;&gt; RepeatProgram;
</code></pre>

<p>Query the user if he/she wants to continue or quit. Store the input character in <code>RepeatProgram</code> of type <code>char</code>.</p>

<pre><code>        std::cout &lt;&lt; std::endl;
</code></pre>

<p>Redundant, unless you want to add padding, which is probably your purpose. Actually, you're better off doing <code>std::cout &lt;&lt; '\n'</code>, but that doesn't matters too much.</p>

<pre><code>    } while (RepeatProgram!='N' &amp;&amp; RepeatProgram!='n');
</code></pre>

<p>Matching expression for the do-while block above. Repeat execution of the given block if <code>RepeatProgram</code> is neither lower- or uppercase- letter <code>N</code>.</p>

<pre><code>}
</code></pre>

<p>End function <code>main</code>. Implicit return value is zero.</p>

<pre><code>int ReadInt (unsigned short int &amp;UserIn)
{
</code></pre>

<p>Function <code>ReadInt</code> takes a reference <code>UserIn</code> to <code>unsigned short int</code> and returns an object of type <code>int</code>. Begin function.</p>

<pre><code>    int Err=0;
    char TemporaryStorage;
    long int FinalNumber=0;
</code></pre>

<p>Declares variables <code>Err</code>, <code>TemporaryStorage</code>, and <code>FinalNumber</code> of respective types <code>int</code>, <code>char</code>, and <code>long int</code>. Variables <code>Err</code> and <code>FinalNumber</code> are initialized to <code>0</code> and <code>0</code>, respectively. But, just a single thing. Didn't the assignment said that the output number be stored in a <code>unsigned short int</code>? So, better of this...</p>

<pre><code>    unsigned short int FinalNumber = 0;
</code></pre>

<p>Now...</p>

<pre><code>    std::cout &lt;&lt; ""Enter a number: "";

    //std::cin.ignore(1000, !' '); this didn't work
</code></pre>

<p>Eh? What's this supposed to be? (<strong>Error</strong>: Aborting debugger because this makes no logic!**). I'm expecting that you just forgot the <code>//</code> before the comment, right? Now, what do you expect <code>!' '</code> to evaluate to other than <code>'\0'</code>? <code>istream::ignore(n, ch)</code>will discard characters from the input stream until either <code>n</code> characters have been discarded, <code>ch</code> is found, or the End-Of-File is reached.</p>

<p>A better approach would be...</p>

<pre><code>   do
       std::cin.get(TemporaryStorage);
   while(std::isspace(TemporyStorage));
</code></pre>

<p>Now...</p>

<pre><code>    std::cin.get(TemporaryStorage);
</code></pre>

<p>This line can be discarded with the above approach ;).</p>

<p>Right. Now, where getting into the part where you obviously banged your head against all solid objects known to mankind. Let me help you a bit there. We have this situation. With the above code, <code>TemporaryStorage</code> will hold the first character that is <em>not</em> whitespace after the do-while loop. So, we have three things left. First of all, check that <em>at least one digit</em> is in the input, otherwise return an error. Now, while the input is made up of digits, translate characters into integers, and multiply then add to get the actual integer. Finally, and this is the most... ahem... strange part, we need to avoid any overflows.</p>

<pre><code>    if (!std::isdigit(TemporaryStorage)) {
        Err = 1;
        return Err;
    }

    while (std::isdigit(TemporaryStorage)) {
        unsigned short int OverflowChecker = FinalNumber;

        FinalNumber *= 10; // Make slot for another digit
        FinalNumber += TemporaryStorage - '0'; '0' - '0' = 0, '1' - '0' = 1...

        // If an unsigned overflows, it'll ""wrap-around"" to zero. We exploit that to detect any possible overflow
        if (FinalNumber &gt; 65535 || OverflowChecker &gt; FinalNumber) {
            Err = 2;
            return Err;
        }

        std::cin.get(TemporaryStorage);
    }

    // We've got the number, yay!
    UserIn = FinalNumber;
</code></pre>

<p>The code is self-explanatory. Please comment if you have any doubts with it.</p>

<pre><code>    std::cout &lt;&lt; TemporaryStorage;//I'm only displaying this while I test my ideas to see if they are working or not, before I move onto the the next step

    cout &lt;&lt; endl;

    return Err;
</code></pre>

<p>Should I say something here? Anyway, I already did. Just remember to take that <code>std::cout</code>s out before showing your work ;).</p>

<pre><code>}
</code></pre>

<p>End function <code>ReadInt</code>.</p>
",14
33517149,33516074,0,"<p>I want to show you some more complicated soultion, but I would prefer this due to easier modification of acceptable answers. I hope you find it useful!
I also recommend to convert user input to lower case for keep the length of your <code>acceptable</code> vector low.</p>

<p>-EDIT- (thanks to <a href=""https://stackoverflow.com/users/2805305/bolov"">bolov</a>)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

std::vector&lt;std::string&gt; acceptable = {""yes"", ""no"", ""unsure""};

int main() {
  std::string message;
  while(std::end(acceptable) == std::find(std::begin(acceptable), std::end(acceptable), message))
    std::cin &gt;&gt; message;
}
</code></pre>

<p>You could use <code>std::map</code>, to map answer to user input as well. Probaply you should call <code>accpt.find(msg)</code> once, but I think it's not a big deal in this case :)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

std::map&lt;std::string, std::string&gt; accpt = {
  {""yes"", ""yes was given""},
  {""no"", ""no was given""},
  {""unsure"", ""unsure was given""}
};

int main() {
  std::string msg;
  while(accpt.find(msg) == accpt.end())
    std::cin &gt;&gt; msg;
  std::cout &lt;&lt; accpt.find(msg)-&gt;second;
}
</code></pre>
",4
33516503,33516074,2,"<p>A simple solution: make a loop that basically can loop forever, asking the same question again and againd, but break it on a valid answer:</p>

<pre><code>int main()
{
    string mood;

    while(1)
    {
        cout &lt;&lt; ""Are you feeling happy today?"" &lt;&lt; endl;
        cin &gt;&gt; mood;
        if (mood == ""yes"" || mood == ""Yes"")
        {
            cout &lt;&lt; ""Great! Glad you're happy!"" &lt;&lt; endl;
            break;
        }
        if (mood == ""no"" || mood == ""No"")
        {
            cout &lt;&lt; ""That's unfortunate, hope you feel better."" &lt;&lt; endl;
            break;
        }
        if (mood == ""unsure"" || mood == ""Unsure"")
        {
            cout &lt;&lt; ""At least you're alive!"" &lt;&lt; endl;
            break;
        }

        cout &lt;&lt; ""Please answer with 'yes', 'no' or 'unsure'"" &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
",0
33563967,33563951,2,"<p>change:</p>

<pre><code>cin&gt;&gt;Array[5];
</code></pre>

<p>to</p>

<pre><code>cin&gt;&gt;Array[i];
</code></pre>

<p>What is currently happening is that your array contains 4 uninitialized values, and the 5th value is overwritten 5 times. The uninitialised values are garbage values, which result in the large sum.</p>

<p>As mentioned in the comments, you should also realise that indexing is 0 based. So <code>Array[5]</code> is accessing out of bounds, which is undefined behavior.</p>
",4
33817694,33816263,1,"<p>The <code>PuTTY</code> message appears when you output the control character whose ASCII value is <code>5</code>, as described <a href=""https://stackoverflow.com/questions/12876699/putty-likes-to-print-itself-sometimes-in-my-command-line"">here</a>.</p>

<p>You output this character from the <code>player1_game</code> function which you call with <code>column == 6</code>:</p>

<pre><code>char** player1_game(int color, int column, char** array) {
    char j, c, r, y;
    j = column-1;
</code></pre>

<p>Now <code>j</code> is <code>5</code> and then later on you do:</p>

<pre><code>    cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;
</code></pre>

<p>Since <code>j</code> is a <code>char</code>, this outputs the character with ascii code <code>5</code>.  <code>5</code> is different to <code>'5'</code>. </p>

<p>To fix this you should declare <code>j</code> as <code>int</code> rather than <code>char</code>. <code>player2_game</code> has the same problem.  Didn't it seem odd to you that your output screens only show <code>i</code> when you tried to output both <code>i</code> and <code>j</code>?</p>

<hr>

<p>Your code contains a lot of other weird things and mistakes. Try to enable all the warnings on your compiler if possible. Some problems are:</p>

<ul>
<li><code>game == 1;</code> should be <code>game = 1;</code></li>
<li><code>while (game, color, column, array)</code> is nonsense; it should be <code>while(1)</code> and you need to put a <code>break</code> statement inside your loop when a player wins the game. Currently if player 1 wins you just go straight on to ask for player 2's move anyway</li>
<li>Your code is difficult to read because of magic numbers and use of pointers everywhere. If it's this hard to read it must be even harder for you to write it.</li>
<li>You never use the return value in the second call to <code>check_endgame(array);</code></li>
<li>The separate player1,player2 functions could be combined to a single function which takes the player number as a parameter. You could have a variable indicating whose turn it is, instead of copy-pasting chunks of code (e.g. as inside the <code>while</code> loop).</li>
<li>player1_game, player2_game should check that <code>column - 1</code> is not out of bounds before using it as array index</li>
<li>The lines <code>cout_column1();</code> and <code>cin &gt;&gt; column;</code> occur before the loop and at the end of the loop; instead of this, put them at the start of the loop. It's always good to avoid code duplication, and copy-pasting (as you clearly did with player1_game and player2_game) is a sign that things are not quite right.</li>
<li><p>A lot of functions return a <code>char **</code> unnecessarily and your code uses that return value which doesn't make much sense. Get rid of <code>char** array;</code> entirely and just use <code>board</code>, e.g.:</p>

<pre><code>underscores(board);
gameboard(board);
</code></pre></li>
</ul>

<p>Change all the functions returning <code>char **</code> to actually return <code>void</code></p>
",2
33571459,33571388,2,"<pre><code> float sum;
</code></pre>

<p><code>sum</code> is uninitialized in your program but then also used -</p>

<pre><code> for(i=0;i&lt;6;i++){
        sum=sum+numb[i];
</code></pre>

<p>Initialize it and then use it .</p>
",4
33571701,33571388,2,"<blockquote>
  <p>Is there a simple way that i just cant write a 6 digits number without spaces and do the same thing? </p>
</blockquote>

<p>Do something along the lines</p>

<pre><code>std::string input;

std::cout &lt;&lt; ""Enter a six digits number: "";
std::cin &gt;&gt; input;

if(input.size() == 6) {
    for(char C : input) {
 // for(size_t I = 0; I &lt; 6; ++I) // C++98 version
    // char C = input[I]; // C++98 version
       if(std::isdigit(C)) {
           int digit = C - '0'; // convert char to a number
           // do whatever you want with the digit
       }
       else {
           std::cout &lt;&lt; ""Error in input, "" &lt;&lt; C &lt;&lt; "" is not a digit"" &lt;&lt; std::endl;
           break;
       }
   }
}
else {
   std::cout &lt;&lt; ""Error: Enter exactly six digits please"" &lt;&lt; std::endl;
}
</code></pre>

<p><a href=""http://ideone.com/OnUpCO"" rel=""nofollow"">Demo</a></p>

<hr>

<p>You should note some points regarding your code sample:</p>

<ol>
<li><code>float</code> shouldn't be used to represent <em>digits</em> which are just integer numbers in the range 0 - 9. Use a <code>unsigned int</code> or so (<code>unsigned char</code> would suffice, but I don't want to add confusion).</li>
<li>If you want to have a <code>float</code> value to get the average, you need to cast the integer values participating in the calculations to <code>float</code></li>
<li>Always initialise variables at their point of definition.</li>
</ol>
",7
33571793,33571388,1,"<ol>
<li><code>sum</code> is not initialized when first used.</li>
<li>The compares both compare the first element (<code>numb[0]</code>) with itself. </li>
<li>In C++ you can declare variables where you need them. That makes code far more easy to read.</li>
<li>You are mixing <code>printf</code> and <code>cout</code></li>
<li>Your line breaks are at strange places...</li>
<li>What you read isn't a six digit number, but 6 numbers</li>
</ol>

<p><strong>EDIT</strong>: Ignoring point 6 of my list (working with 6 numbers)</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;
int main()
{
    cout &lt;&lt; ""Give a six digit number: "";

    //Read numbers
    float numb[6];
    for (int i = 0; i &lt; 6; i++) {
        cin &gt;&gt; numb[i];
    }

    //Print numbers
    cout &lt;&lt; ""The number you gave its : "";
    for (int i = 0; i &lt; 6; i++) {
        cout &lt;&lt; numb[i] &lt;&lt; "","";
    }
    cout &lt;&lt; endl;

    //Calculate sum
    float sum = 0;
    for (int i = 0; i &lt; 6; i++) {
        sum = sum + numb[i];
    }
    cout &lt;&lt; ""Sum is "" &lt;&lt; sum &lt;&lt; endl;

    //Calculate average
    float average = sum / 6;
    cout &lt;&lt; ""Average is "" &lt;&lt; average &lt;&lt; endl;

    //Calculate max
    float max = numb[0];
    for (int i = 1; i &lt; 6; i++) {
        if (max &lt; numb[i])
            max = numb[i];
    }
    cout &lt;&lt; ""Maximum is "" &lt;&lt;  max &lt;&lt; endl;

    //Calculate min
    float min = numb[0];
    for (int i = 1; i &lt; 6; i++) {
        if (min &gt; numb[i])
            min = numb[i];
    }
    cout &lt;&lt; ""Minimum is "" &lt;&lt; max &lt;&lt; endl;
}
</code></pre>
",5
33588729,33588680,3,"<p>From <a href=""http://en.cppreference.com/w/cpp/utility/initializer_list"" rel=""nofollow"">http://en.cppreference.com/w/cpp/utility/initializer_list</a>:</p>

<blockquote>
  <p>An object of type <code>std::initializer_list&lt;T&gt;</code> is a lightweight proxy object that provides access to an array of objects of type <code><strong><em>const</em></strong> T</code>.</p>
</blockquote>

<p>The elements of an <code>initializer_list</code> are <em>always</em> <code>const</code>, and thus <code>*carteRow_iterator</code> is <code>const</code>.</p>

<p>If you want a modifiable list of objects, use <code>std::vector</code> or <code>std::array</code>.</p>
",0
34225337,34225253,4,"<p>Your function exported from your DLL will be compiled with the C calling convention (__cdecl), but your typedef of the function pointer indicates that you expect to treat it as the Windows calling convention (CALLBACK is a macro for __stdcall). Mixing these two up imbalances the stack.</p>

<p>Either remove <code>CALLBACK</code> from the function pointer declaration, or declare your exported function with __stdcall.</p>
",2
34241559,34241507,2,"<p>A loop executes the same section of code zero or more times, depending on the loop's conditional.</p>

<p>If you carefully examine your code, you see that you are repeating essentially the same code, four times: calculate the remainder of a division by ten, integer division by ten, and some output.</p>

<p>So, it seems logical to simply write a loop that executes the same exact code, which only executes these operations one, but have the loop execute this section of code four times.</p>

<p>And that's how you do it.</p>
",0
34241794,34241507,1,"First you need to recognise part of code which repeat itself more times and that code put inside some loop(for,while,do-while) and declare how many times it will execute,mostly it is some bool expresion. In you case this part of code you need to put inside for,while or do-while loop:

<pre><code>digit = number % 10;
cout &lt;&lt; digit &lt;&lt; "", "";
number = number / 10;
</code></pre>

<p>for example:</p>

<pre><code>for(int i=0;i&lt;4;i++){
    digit = number % 10;
    if(i!=3)
        cout &lt;&lt; digit &lt;&lt; "", "";
    else
        cout &lt;&lt; digit;

    number = number / 10;
}
</code></pre>
",0
34241809,34241507,1,"<p>To get an equivalent output You can use for example do-while loop</p>

<pre><code>cout &lt;&lt; ""The digits are: "";

do
{
    cout &lt;&lt; number % 10;
} while ( ( number /= 10 ) &amp;&amp; cout &lt;&lt; "", "" );
</code></pre>

<p>Or</p>

<pre><code>do
{
    cout &lt;&lt; number % 10;

    number /= 10;

    if ( number ) cout &lt;&lt; "", "";
} while ( number );
</code></pre>

<p>If you want to output exactly four digits provided that the number indeed has four digits then you can write</p>

<pre><code>int i = 0;
do
{
    cout &lt;&lt; number % 10;

    number /= 10;

    if ( number ) cout &lt;&lt; "", "";
} while ( ++i &lt; 4 &amp;&amp; number );
</code></pre>
",0
34242896,34241507,1,"<p>Is there any specific reason you need to perform division on an integer? If you accept the user's input as a string it is possible to simply iterate over the characters contained e.g</p>

<pre><code>string val;
cin &gt;&gt; val;
int len = val.length();

for(int i = len-1; i &gt;= 0; --i){
  cout &lt;&lt; val[i]&lt;&lt;"","";
}
</code></pre>

<p>Of course if you know the number of digits beforehand you can easily do this using an int</p>

<pre><code>int val;
cin &gt;&gt; val;

for(int i = 0; i &lt; 4; ++i){
  int digit = val % 10;
  val /= 10;
  cout &lt;&lt; digit &lt;&lt; "","";
}
</code></pre>

<p>If you need to extend the solution to cover any arbitrary length int you would need a while loop with this condition</p>

<pre><code>while(val &gt; 0){
      int digit = val % 10;
      val /= 10;
      cout &lt;&lt; digit &lt;&lt; "","";
}
</code></pre>
",0
34259405,34258628,0,"<p>There are several issues with the code you posted, mostly due to undefined variables being called.</p>

<p><strong>1:</strong> For your search method, <code>counter</code> comes out of nowhere and is being used as a numeric limiter for the loop.</p>

<p><strong>2:</strong> Also within your search method, the 2D array <code>data</code> is also undefined, unless it is a global variable set from the <code>load_contacts</code> method that isn't being shown, so currently you're searching a 2D array that doesn't exist.</p>

<p><strong>3:</strong> Your <code>""Name not found""</code> message is in an <code>else</code> statement within the for loop in your method, therefore being executed every time a loop doesn't find the name. You may want to move that outside of the loop to print and then return an error number, maybe <code>-1</code> to handle later.</p>

<p><strong>4:</strong> Your <code>search</code> method is a return type of <code>int</code>, however in your <code>main</code> you are not assigning the returned value to any variable to be used, so if there is a successful search, nothing will happen.</p>

<p>If I'm incorrect with any of these, please tell me, but I would focus on the obvious errors first to see if they are causing the crashing.</p>
",0
