5486739,5486727,4,"<p><code>realloc</code> only goes one-level deep. It doesn't even know you're passing it a pointer-to-pointer, since its argument is converted to <code>void*</code>, its parameter type. As far as <code>malloc</code>, <code>realloc</code> and <code>free</code> are concerned, memory is just a flat array of bytes. If you store pointers in memory, that's you choice, but <code>malloc</code> doesn't care.</p>

<p>However, the memory leak doesn't occur until the <code>free(p1)</code>, which also does not recurse into the array of pointers. (<code>realloc</code> will still copy the pointers stored in the buffer, if the block is enlarged. When it's shrunk, you're in trouble.)</p>

<p>Also, your program's behavior is undefined because you don't check for error returns, and the following only works when <code>sizeof(char *) &lt; 10</code>:</p>

<pre><code>p1 = (char **) malloc ( 100 );

for ( i = 0; i &lt; 10; i ++ )
{
    p1[i] =  (char *) malloc(10);
    memcpy ( p1[i], ""1234567890"", 10 );
}
</code></pre>
",0
1998150,1998119,5,"<p>No, it is not guaranteed by the standard.  The standard says this about ""string literals"" (6.4.5p6):</p>

<blockquote>
  <p>It is unspecified whether these arrays are distinct provided their elements have the
  appropriate values.</p>
</blockquote>

<p><em>These arrays</em> refers to the array of <code>char</code> created from a literal string in translation phase 7.</p>

<p>Since you are using a macro, the code seen by the compiler is:</p>

<pre><code>if( strstr(""plaintext"", optarg) == ""plaintext"" )
</code></pre>

<p>When <code>optarg</code> is <code>""plaintext""</code>, the code reduces to</p>

<pre><code>if(""plaintext"" == ""plaintext"")
</code></pre>

<p>As mentioned above, this is not guaranteed to be true in C.</p>

<p>So, you must use <code>strcmp()</code> instead of checking the pointers for equality, or, as in the other answer, define a <code>char *</code> pointer to use instead of the macro.</p>
",0
1998157,1998119,6,"<p>Macros do simple textual replacement. The preprocessor replaces every occurrence of <code>PLAINTEXT_TARGET</code> with <code>""plaintext""</code>, after that the compiler looks at the result and compiles that.</p>

<p>So the compiler sees two string literals and it's not guaranteed that those won't be stored separately (see Alok's answer for the according quote from the standard). The code is indeed misleading, it would be more reasonable to declare <code>PLAINTEXT_TARGET</code> as a constant:</p>

<pre><code>const char* const PLAINTEXT_TARGET = ""plaintext"";
</code></pre>
",1
2589990,2589982,8,"<p><code>addr</code> is an array so you can't assign to it directly.</p>

<p>Change <code>addr = strncpy(addr, argv[2], 1023);</code> to <code>strncpy(addr, argv[2], 1023);</code></p>

<p>A pointer to what you passed in is returned, but this value isn't needed.  The call to <code>strncpy</code> alone will copy the string from <code>argv[2]</code> to <code>addr</code>.</p>

<hr>

<p>Note: I notice sometimes you pass in the address of your array and sometimes you pass in the array itself without the address of operator.  </p>

<p>When the parameter only asks for <code>char*</code>...</p>

<p>Although both will work passing in <code>addr</code> instead of <code>&amp;addr</code> is more correct. <code>&amp;addr</code> gives a pointer to a char array <code>char (*)[1023]</code> whereas <code>addr</code> gives you a <code>char*</code> which is the address of the first element. It usually doesn't matter but if you do pointer arithmetic then it will make a big difference. </p>
",2
2590000,2589982,0,"<p>an alternative is to use a char * instead:</p>

<pre><code>char *addr;

addr = strdup(argv[2]);
</code></pre>

<p>strdup is basically a shortcut that does a malloc and a strcpy, and you don't have to worry about the size of addr upfront.
Don't forget to free addr once you're done.<br>
Note that if argv[2] is NULL you will get a segfault.</p>
",1
2590008,2589982,1,"<p>The line</p>

<pre><code>addr = strncpy(addr, argv[2], 1023);
</code></pre>

<p>should be just</p>

<pre><code>strncpy(addr, argv[2], 1023);
</code></pre>

<p>note that strncpy doesn't null-terminate if the 1023 limit is reached so you should also have</p>

<pre><code>addr[1023] = `\0`;
</code></pre>

<p>though I suppose there's other assumptions made in the code as well.</p>
",0
2590027,2589982,5,"<p>You've gotten a couple of answers that address exactly what you asked. My advice would be to step back and just eliminate that step, as it's completely unnecessary. I'd change these lines:</p>

<pre><code>u_short port;                /* user specified port number */
char addr[1023];             /* will be a copy of the address entered by u */
struct sockaddr_in address;  /* the libc network address data structure */

port = atoi(argv[1]);
addr = strncpy(addr, argv[2], 1023);
bzero((char *)&amp;address, sizeof(address));  /* init addr struct */
address.sin_addr.s_addr = inet_addr(addr); /* assign the address */
address.sin_port = htons(port);            /* translate int2port num */
</code></pre>

<p>to something like this:</p>

<pre><code>struct sockaddr_in address = {0};

address.sin_port = htons(atoi(argv[1]));        
address.sin_addr.s_addr = inet_addr(argv[2]);
</code></pre>

<p>The existing code is doing a lot of unnecessary copying, making the code bigger and slower without accomplishing anything.</p>

<p>Edit: looking at it again, you should probably add a bit of error checking code (before what's above), something like:</p>

<pre><code>if (argc != 3) {
    fprintf(stderr, ""Usage: %s &lt;port_num&gt; &lt;address&gt;"", argv[0]);
    return EXIT_FAILURE;
}
</code></pre>
",0
3992286,3992273,4,"<p><a href=""http://projecteuler.net"" rel=""nofollow"">Project Euler</a> is pretty good. They have some simple challenges that may be suitable.</p>

<p>These won't really do much to teach them C, though. Text books are much better for that.</p>

<p>Additionally, you could have them write a program to balance chemical reaction equations. That would be good for I/O and simple math.</p>
",0
3992299,3992273,2,"<p>Given a text file with a whole bunch of pressure/temperature/mole count as input, and using the ideal gas law equation, output the values of the volume for the gases and output the entire set of data (P,V,T and n) into a nicely formatted output file.</p>

<p>Should cover file i/o, basic function usage, and string formatting. Has the potential to cover arrays and stucts as well.</p>
",0
3992300,3992273,0,"<p>This seems a really vague question but assuming I'm a chemistry student that is learning C I would like to write programs that allows me to define molecules and compounds starting from simple elements.</p>

<p>I really don't know how to explain it, but maybe define your <code>struct</code> for a nitrogen atom, one for oxigen atom and have a way to bind it to produce water.. or maybe mixing to different substances too see what will come out programmatically..</p>
",0
2614015,2613994,-1,"<p>Check out <a href=""http://www.ohloh.net/p/pqlib"" rel=""nofollow noreferrer"">PQLib</a>.</p>

<p>I use the standard C standard libraries. ;)</p>
",3
6362833,2613994,5,"<p>The <a href=""http://www.cs.princeton.edu/~rs/Algs3.c1-4/code.txt"" rel=""noreferrer"">source code</a> accompanying <a href=""http://www.cs.princeton.edu/~rs/"" rel=""noreferrer"">Robert Sedgewick</a>'s <a href=""http://amzn.com/0201314525"" rel=""noreferrer"">Algorithms in C, Parts 1-4 (Fundamental Algorithms, Data Structures, Sorting, Searching)</a> contains both a heap-based and a list-based implementation.  See Chapter 9 - Priority Queues and Heapsort.</p>
",0
4364060,4364044,4,"<p>The <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a> is best thought of as, well, an operator. Just like <code>+</code> is an operator, so that <code>2 + 3</code> is an expression (which happens to result in a value of <code>5</code>), so too <code>,</code> is an operator, and thus <code>0, 1</code> is a valid expression (which happens to result in a value of <code>1</code>, since that was the last operand).</p>
",0
4364099,4364044,18,"<p>The two loops given don't have the same meaning. By using the comma operator in that way, the author was able to specify code that should be executed every iteration, even if the loop itself is never entered. It's more like a <code>do ... while ()</code> loop, or something like the following:</p>

<pre><code> printf(""&gt; "");
 fgets(str, 100, stdin);
 while(!feof(stdin)) {
    ..
    ..

    printf(""&gt; "");
    fgets(str, 100, stdin);
 }
</code></pre>
",0
4364113,4364044,2,"<p>Your proposed modification is not equivalent. This is:</p>

<pre><code>while (1) {
  printf(""&gt; "");
  fgets(str, 100, stdin);
  if (feof(stdin)) { break; }
  ...
  ...
}
</code></pre>

<p>I would suggest instead breaking off the work into a function:</p>

<pre><code>int get_input(char* buffer, int size) {
  printf(""&gt; "");
  fgets(buffer, size, stdin);
  return !feof(stdin);
}

while (get_input(str, 100)) {
  ...
  ...
} 
</code></pre>
",0
4364118,4364044,2,"<p>Your second example has different behavior than the first, and has a bug.</p>

<p>If the line of code:</p>

<pre><code>fgets(str, 100, stdin);
</code></pre>

<p>fails because it was a read at the end of the file, then the remainder of the block will be executed.</p>

<p>In the first set of code, the <code>feof()</code> test occurs after the <code>fgets()</code> that causes the EOF condition, so the <code>while()</code> block will not be executed.</p>

<p>Since <code>fgets()</code> returns NULL if it has hit EOF (and hasn't read any data into the buffer), I might code the loop as:</p>

<pre><code>while (fgets(str, 100, stdin)) {
    printf(""&gt; "");

    // ...
}
</code></pre>

<p>which is still slightly different behavior (there will be one fewer ""> "" printed). If that were important, I'd put an extra instance of that <code>printf()</code> before the loop.</p>

<p>In general, since it tends to cause confusion, I'd avoid the comma operator except where it's really, really needed or where it won't cause confusion. For example, it's sometimes used in <code>for</code> loop clauses in a non-confusing manner to allow several variables to be updated on each loop iteration.</p>
",2
4170112,4170103,2,"<p>The simplest answer would be: it's not guaranteed to work.</p>

<p>Basically, you are corrupting the memory around the pointer.</p>
",0
4170113,4170103,3,"<p>This is 3 byte overflow. Overflow like this from stackoverflow logo, but on a heap not stack.</p>
",1
4170115,4170103,11,"<p>Because C has no range-checking of memory.  It allocates a byte, and then your assignment via the pointer overwrites it and the next three bytes. If you had allocated another bit of memory right after the first malloc, but before the assignment, you might have overwritten part of the heap (depending on how your malloc works).</p>

<p>This is why pointers can be very dangerous in C.</p>

<p>The %d in the format statement (plus the type of the variable) tells the compiler you are looking at an int, and accesses all four bytes.</p>

<p>Note that if you really had assigned the value to a char, e.g. char *ptr; *ptr = 100000;</p>

<p>then with some compilers (and assuming plain char is treated as signed but default) it would have printed out -96, not 255 (or 127).  This is because the compiler doesn't automatically limit the value to the highest value that can fit (127 in a signed char, 255 in an unsigned char), but instead it just overflows.  Most compilers will complain that you are trying to assign a constant value that overflows the variable.</p>

<p>The reason it is -96, is that 100000 % 256 is 160, but as a signed char it is output as -(256-160).</p>
",1
4170118,4170103,5,"<p>Short answer: you're invoking undefined behaviour by writing to memory that doesn't belong to you, so you never know what you might get. It might just work, it might crash, or it might do any number of other things. In this case, you're putting an <code>int</code> at the position that <code>ptr</code> references, which writes the first byte of the <code>int</code> into the 1-byte allocated region, and smashes whatever lived in the following three bytes. </p>

<p>When you read the value back with the <code>%d</code> format specifier, <code>printf</code> reads <code>sizeof(int)</code> bytes from memory to print them as an <code>int</code>. If you want to output just the value of one byte, you need to do something like:</p>

<pre><code>printf(""%d\n"", *(char*)ptr);
</code></pre>

<p>That is, tell the compiler that <code>ptr</code> refers to a <code>char</code>, then get that <code>char</code> value, which is promoted to an <code>int</code> in an argument list and subsequently output correctly by the <code>%d</code> specifier.</p>
",0
4170136,4170103,1,"<p>To answer your updated question; C ""sees"" *ptr i.e. contents of ptr where ptr points at an integer. So it reads an integer from that ptr. It has already forgotten that you only allocated one character. The two parts (allocation and then access) aren't linked by anything you've expressed in your code.</p>
",0
4170141,4170103,1,"<p>Generally, <code>malloc</code> will allocate memory with greater granularity than a single byte, so your request for a single byte will reserve a memory space rounded up to the nearest 8 bytes or something. You then write to this space, blithely going right past what you've reserved. Then you dereference the pointer, bringing back an <code>int</code>, and hand that to <code>printf</code> which happily prints it out.</p>

<p>As others have said, depending on this behavior is a bad, bad idea. Allocate exactly what you need and don't overrun your buffers.</p>
",0
3831486,3831238,2,"<blockquote>
  <p>I keep getting EXC_BAD_ACCESS on the
  line inside the while loop.</p>
</blockquote>

<pre><code>while (*filename != '.') 
{
  *(ext++) = *(--filename);               
} 
</code></pre>

<p>above you are treating 'ext' as a pointer, however 'ext' is declared as an array
if you want to use a pointer, then declare another pointer and point it to 'ext'</p>

<pre><code>while (*filename) {
  filename++;
}
</code></pre>

<p>in the above while loop you are moving the pointer 'filename' until it lands on '\0'
that's ok but instead you could start from the end of filename by position yourself on the last '.' like this:</p>

<pre><code>char *p = filename + strlen( filename ) - 1; // last char
</code></pre>

<p>then move forward</p>

<pre><code>while (*p != '.') --p;
</code></pre>

<p>now you p is where the '.' is</p>

<p>now copy from p + 1 </p>

<pre><code>strcpy( ext, p + 1 ); 
</code></pre>

<p>when you return you cannot return 'ext' because it doesn't exist outside the function body.</p>

<p>a way to do it is to either pass ext as an extra argument to the function where you allocate the 'ext' outside the function or use the heap allocate space for the extension</p>

<pre><code>char *getFileExt(char *filename,char *ext)
</code></pre>

<p>or even better</p>

<pre><code>char *getFileExt(char *filename,char *ext, size_t maxlen_ext)
</code></pre>

<p>or </p>

<pre><code>char *getFileExt(char *filename)
{
   char* ext = malloc( 10 );
...
</code></pre>
",0
3831280,3831238,2,"<pre><code>char* getFileExt(char *filename)
{
    while (*filename) filename++;
    while (*filename != '.') --filename;                 
    return filename;     
}
</code></pre>

<p>Or version with non crash if filename not contains <code>.</code></p>

<pre><code>char* getFileExt(char *filename) 
{
    char* _ext = filename;
    while (*_ext) _ext++;
    while (_ext &gt;= filename &amp;&amp; *_ext != '.') --_ext;                
    if (_ext &lt; filename) _ext = NULL;
    return ext;     
}
</code></pre>
",6
3831316,3831238,5,"<p>You should never return a pointer of a local array. The array data is lost when the function loses scope and the pointer will be dangling.</p>

<p>Besides, you cannot change the value of the array pointer. This is why you're getting the <code>EXC_BAD_ACCESS</code> error. You can either use an integer index or a <code>char *</code> pointer which points to the first entry.</p>

<p>By the way: There's a function <code>strrchr</code> (see <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strrchr/"" rel=""nofollow"">here</a>) that gives you the last occurance of a character in a string. You <em>can</em> return that resulting pointer, because it points to a valid position in the filename array which is also valid outside the function.</p>
",0
4901032,388602,6,"<p>If you're adventurous and open to a new web server, take a look at <a href=""http://gwan.com/en_faqs.html"" rel=""nofollow"">G-WAN</a>. It serves dynamic content with ANSI-C scripts. It's small, <a href=""http://gwan.com/index.html"" rel=""nofollow"">fast</a>, and free (though not open source). Browse the <a href=""http://gwan.com/en_developers.html"" rel=""nofollow"">running samples with source</a> to get a feel for G-WAN development.</p>

<p>If you spend time on the G-WAN site, you'll notice that its developer, Pierre Gauthier, has strong opinions about the state of software development today. Agree or disagree, his perspective is interesting given the increasing size and complexity of the tools we use everyday.</p>
",3
2095453,388602,1,"<p>Ignore the naysayers that say that C is not acceptable or advisable.  The assumption that they make is that they are writing your application.  This can be a good learning experience for you.</p>

<p>C has some very specific advantages over other modules.  You can easily write a  framework for it that does a lot of the heavy lifting for your application, without too much effort. </p>

<p>The danger is the safety and sanity of your code.   The advice that I have is to try Django or Rails and see how they 'do it', then take the best of their ideas back to C. </p>

<p>Your development time may be ""slower"", but on the other hand you will have intimate knowledge of your stack and framework.  </p>
",0
2613992,2613980,12,"<p><code>0 &amp;&amp; arr</code><br>
The above expression is <em>false</em> because of <code>0</code>, so <code>arr</code> is not checked unlike <code>1 &amp;&amp; arr</code> where <code>arr</code> has to be checked to evaluate the value for expression.</p>

<hr>

<p>You should try:</p>

<pre><code>int main(){
  int a = 0 &amp;&amp; printf(""a""); //printf returns number of characters printed, 1
  int b = 1 &amp;&amp; printf(""b"");
  return 0;
} 
</code></pre>
",0
2613995,2613980,4,"<p>Because of short circuit evaluation of boolean expressions. In the first example the left side of the &amp;&amp; operator evaluates to true so the right is evaluated. In the second case the left is false so the right is never evaluated.</p>
",0
1997659,1997632,7,"<p>There are <a href=""http://www.google.com/search?q=ansi+c+linear+algebra+library"" rel=""noreferrer"">so many</a>. </p>

<p>In particular, you might want to look at the <a href=""http://www.gnu.org/software/gsl/"" rel=""noreferrer"">GNU scientific library</a>. </p>

<p>Alternatively, you can just <a href=""http://www.edcc.edu/faculty/paul.bladek/Cmpsc142/matmult.htm"" rel=""noreferrer"">implement your own</a> matrix operations.</p>

<hr>

<p>Re cross platform: </p>

<p>GSL is very cross platform. According to the site, it compiles on around 12 operating systems (Solaris, Linux, darwin, various *BSDs and something called a SR8000 Super Technical Server). I would guess it could be compiled on embedded systems as well. For windows, you can either use cygwin or <a href=""http://gnuwin32.sourceforge.net/packages/gsl.htm"" rel=""noreferrer"">Gsl for Windows</a>.</p>

<p>Which platforms are you planning on using? </p>
",5
1997662,1997632,3,"<p><a href=""http://www.netlib.org/c/meschach/"" rel=""nofollow noreferrer"">Meschach</a> seems to be the only popular C-based matrix library. There are tons of C++ based matrix libraries however.</p>

<p>The main question however is for what purpose you need that library. If for mathematical linear algebra, you should rather find a linear algebra library, so you have all your operations in one place (BLAS based, for example <a href=""http://math.nist.gov/spblas/"" rel=""nofollow noreferrer"">spblas</a>). If however you need matrix3 and matrix4 types for 3D calculations, you should try to find one that is optimized for 3x3 or 4x4 operations, like <a href=""http://gandalf-library.sourceforge.net/"" rel=""nofollow noreferrer"">this one</a>).</p>
",0
2167239,2167235,6,"<p><code>0x06</code> and <code>6</code> (and <code>CHANNEL_UNACCEPTABLE</code>) are equivalent. So is <code>0x11</code> and <code>17</code> (and <code>USER_BUSY</code>). There is no distinction of hexadecimal or decimal to the computer.</p>

<p>(You <em>should</em> write <code>drop_and_release_call(23, CHANNEL_UNACCEPTABLE)</code> for clarity.)</p>
",1
2167242,2167235,3,"<p>The reason those definitions are made is so that you can call your function like this:</p>

<pre><code>drop_and_release_call(23, CHANNEL_UNACCEPTABLE);
</code></pre>

<p>If you really want to use the numbers, yes you can just pass them directly:</p>

<pre><code>drop_and_release_call(23, 0x06);
</code></pre>
",0
2167243,2167235,2,"<p>Yes, you can pass it in as an integer or unsigned integer type. These names are replaced by the C preprocessor to become the numbers they define. These numbers are valid integer literals.</p>

<p>It is customary to make ""enumerative"" types (like port number) unsigned. Flags too.</p>
",0
2167244,2167235,4,"<p>Yes, it's just an integer.</p>

<p>The hexadecimal aspect of it is only important when it's displayed for us to read.</p>
",0
2167245,2167235,2,"<p>C doesn't care whether it was in the code as base 16 or base 10... it will represent it as integer either way.  </p>

<p>The only time you really have to worry about bases is during input or output.  </p>
",0
2167381,2167235,1,"<p>The C compiler will parse the values as int. You need only 5 bits for the values you've listed, it will fit comfortably in a char.  But a char get promoted to an int in a function call anyway, you might as well use int.</p>
",0
7769712,599365,6,"<p>I'm a fan of xor hacks:</p>

<p>Swap 2 pointers without third temp pointer:</p>

<pre><code>int * a;
int * b;
a ^= b;
b ^= a;
a ^= b;
</code></pre>

<p>Or I really like the xor linked list with only one pointer. (http://en.wikipedia.org/wiki/XOR_linked_list)</p>

<p>Each node in the linked list is the Xor of the previous node and the next node.  To traverse forward, the address of the nodes are found in the following manner :</p>

<pre><code>LLNode * first = head;
LLNode * second = first.linked_nodes;
LLNode * third = second.linked_nodes ^ first;
LLNode * fourth = third.linked_nodes ^ second;
</code></pre>

<p>etc.</p>

<p>or to traverse backwards:</p>

<pre><code>LLNode * last = tail;
LLNode * second_to_last = last.linked_nodes;
LLNode * third_to_last = second_to_last.linked_nodes ^ last;
LLNode * fourth_to_last = third_to_last.linked_nodes ^ second_to_last;
</code></pre>

<p>etc.</p>

<p>While not terribly useful (you can't start traversing from an arbitrary node) I find it to be very cool.</p>
",0
7769764,599365,0,"<p>Using the otherwise pointless <strong>? :</strong> operator to initialise a const variable</p>

<p><code>const int bytesPerPixel = isAlpha() ? 4 : 3;</code></p>
",0
7770339,599365,0,"<p>I always liked dumb preprocessor tricks to make generic container types:</p>

<pre><code>/* list.h */
#ifndef CONTAINER_TYPE
#define CONTAINER_TYPE VALUE_TYPE ## List
#endif
typedef struct CONTAINER_TYPE {
    CONTAINER_TYPE *next;
    VALUE_TYPE v;
} CONTAINER_TYPE;
/* Possibly Lots of functions for manipulating Lists
*/
#undef VALUE_TYPE
#undef CONTAINER_TYPE
</code></pre>

<p>Then you can do e.g.:</p>

<pre><code>#define VALUE_TYPE int
#include ""list.h""
typedef struct myFancyStructure *myFancyStructureP;
#define VALUE_TYPE myFancyStructureP
#define CONTAINER_TYPE mfs
#include ""list.h""
</code></pre>

<p>And never write a linked list again.  If VALUE_TYPE is always going to be a pointer, then this is an overkill, since a void * would work just as well.  But there are often very small structures for which the overhead of indirection often doesn't make sense.  Also, you gain type checking (i.e. you might not want to concatenate a linked list of strings with a linked list of doubles, even though both would work in a void * linked list).</p>
",1
7770342,599365,3,"<p>Not specific to C, but I've always liked the XOR operator. One cool thing it can do is &quot;swap without a temp value&quot;:</p>
<pre><code>int a = 1;
int b = 2;

printf(&quot;a = %d, b = %d\n&quot;, a, b);

a ^= b;
b ^= a;
a ^= b;

printf(&quot;a = %d, b = %d\n&quot;, a, b);
</code></pre>
<p>Result:</p>
<blockquote>
<p>a = 1, b = 2</p>
<p>a = 2, b = 1</p>
</blockquote>
",3
7772660,599365,1,"<p>Fun with macros:</p>

<pre><code>#define SOME_ENUMS(F) \
    F(ZERO, zero) \
    F(ONE, one) \
    F(TWO, two)

/* Now define the constant values.  See how succinct this is. */

enum Constants {
#define DEFINE_ENUM(A, B) A,
    SOME_ENUMS(DEFINE_ENUMS)
#undef DEFINE_ENUM
};

/* Now a function to return the name of an enum: */

const char *ToString(int c) {
    switch (c) {
    default: return NULL; /* Or whatever. */
#define CASE_MACRO(A, B) case A: return #b;
     SOME_ENUMS(CASE_MACRO)
#undef CASE_MACRO
     }
}
</code></pre>
",0
7777551,599365,0,"<p>In C99 you can directly embed URLs into source code inside functions. Example:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv) {
    http://stackoverflow.com/
    printf(""Hello World"");
}
</code></pre>
",0
7789879,599365,0,"<p>I love empty if-else and while(0) operators.</p>

<p>For example:</p>

<pre><code>#define CMD1(X) do { foo(x); bar(x); } while (0)
#define CMD2(X) if (1) { foo(x); bar(x); } else
</code></pre>
",0
3444259,1406679,3,"<p>If you're lucky enough to be using Mac OS X you can use the following code:</p>

<pre><code>#define _DARWIN_C_SOURCE
#include &lt;sys/fcntl.h&gt;
.
.
.
char pathbuf[PATH_MAX];
if (fcntl(fd, F_GETPATH, pathbuf) &gt;= 0) {
    // pathbuf now contains *a* path to the open file descriptor
}
</code></pre>

<p>Note that the path you get back is not necessarily the one used to open the file... If there are hard links, especially, the path you get back will be <em>a</em> valid path to the file.</p>
",0
2204068,2204042,1,"<p>The best practice is to not presume anything about the system you're installing onto.  You can have the best of both worlds if you just let the user choose.  Make the command you call an application preference or require paths to be defined in the environment:</p>

<pre><code>PATH_TO_TOOL1=foo
PATH_TO_TOOL2=/usr/bin/bar
</code></pre>

<p>You can, of course, just fall back to a default of some kind if the variables aren't defined or the preference isn't set.  Writing your application to be more flexible is always the best choice!</p>
",1
2204072,2204042,3,"<p>Best practice is never to assume that you know your install directory at build time. Let your users decide where to install and work anyway.</p>

<p>This means that you will need to find out where your programs are located using some other mechanism. Consider using environment variables or command line parameters to allow the user to specify the actual path, if your platform does not provide you with the means to find out where the executables are located. You can use your knowledge of where you are normally installed as a fallback option.</p>

<p>For your actual question, in case you can build the absolute path to your program (using another mechanism than preprocessor directives) - use that. Otherwise, fall back to having the system find out for you.</p>
",1
2204078,2204042,1,"<p>You should definitely let the user specify the path with an environment variable to the installed binaries. Not all systems are the same and many people will want to put their execs in different places. </p>

<p>the best example I can think of is people doing a local install vs system install. If your program is installed in a home directory that user will have to set and env variable to say where the binaries are copied to.</p>
",0
2204079,2204042,1,"<p>If you're absolutely sure of the path names, and if they are not ""well-known"" commands (for example, POSIX shell utilities on Unix are ""well-known""), you should specify the pathname, otherwise don't specify the full path, or let the user control it by using an environment variable.</p>

<p>In fact, you may be able to write something like a function such as <code>int my_system(const char *);</code>, which does the prefixing of the path for you.  If later you determine that it was a bad idea, it's just a matter of making <code>my_system()</code> identical to <code>system()</code>.</p>
",0
2204158,2204042,0,"<p>I'm not sure if it's a best practice, but what I do in these cases is I write my C code to <strong>extend the <code>PATH</code> environment variable to include the installation directory at the end</strong>.  Then I just use the <code>PATH</code>.  That way, if the user's <code>PATH</code> wants to override where I believe the stuff was installed, it can&mdash;but if the software was installed in an out-of-the-way place, I&nbsp;can call it without forcing my users to put the directory on <code>$PATH</code> themselves.</p>

<p>Please note that the extended <code>PATH</code> lasts only as long as the C program runs; I'm not proposing changing the persistent <code>PATH</code>.</p>
",2
2126373,2126361,4,"<p>Exactly how are you testing that the function doesn't work?  Note that your function is returning <code>dest</code> which now points to the <em>end</em> of the destination buffer.  Is the calling function checking the returned pointer, or is it checking the pointer it passed as the destination buffer?</p>

<p>For similar reasons, the <code>printf</code> for <code>*dest</code> in your loop is useless; you've already incremented <code>dest</code> at that point, so it points to the next <em>unused</em> location. (The <code>printf</code> call for <code>source</code> also prints the <em>next</em> character to be copied, not the one you just copied.)</p>

<p>As an aside, it's unclear what you intend <code>size</code> to be.  If it's the number of bytes in the destination buffer, you could overflow the buffer when you write the NUL-terminator.</p>

<p>Oh, and you should check that you don't read past the end of <code>source</code>.</p>
",2
2126376,2126361,3,"<p>The problem is that the pointer which you are returning has been incremented and doesn't point to the begining. So, it shows as blank. Same appears to be the case for your for loop print also.</p>

<p>For Ex: </p>

<p>Let's say your initial destination address is 1000 and your source string size is 20, then your destnation returns 1020. But, it should actually be returning 1000.</p>

<p>Try storing the initial address of the destination in a local variable and returning that.</p>
",0
2278938,2278933,2,"<p>You have allocated memory for company structure, but haven't for emp structure</p>

<p>You have to allocate memory for <code>comp-&gt;person</code>: <code>comp-&gt;person = (struct emp*)malloc(sizeof(emp))</code></p>

<p>after that You can access memory stored in comp->person</p>
",0
2278939,2278933,2,"<p>Memory is not allocated for ""persons"" field of struct company structure. If you allocate memory for that it should be fine.</p>
",0
2278940,2278933,6,"<p>You need to allocate memory for <code>persons</code>:</p>

<pre><code>comp-&gt;persons = malloc( sizeof( struct emp ) * NumberOfPersonsYouExpectToHave );
</code></pre>

<p>and don't forget to free that memory later.</p>
",0
2598275,2598240,7,"<p>Enumeration values exist in the same namespace as the enumeration is defined. That is, in regards to <code>LAST_ENTRY</code>, it's similar (used <em>very</em> loosely here) to:</p>

<pre><code>enum options_e { /* ... */ );

// for the LAST_ENTRY value in options_e
static const int LAST_ENTRY = /* whatever */;

enum function_mode_e { /* ... */ );

// for the LAST_ENTRY value in function_mode_e
static const int LAST_ENTRY = /* whatever */;
</code></pre>

<p>As you can see, you're redefining <code>LAST_ENTRY</code>, hence the error. It's better to prefix your enum values with something to differentiate them:</p>

<pre><code>enum options_e
{
    options_e_acm = 0,
    options_e_anm,
    options_e_smd,
    options_e_LAST_ENTRY,
    options_e_ENTRY_COUNT = options_e_LAST_ENTRY // note this is redundant 
};

enum function_mode_e
{
    function_mode_e_play = 0,
    function_mode_e_record,
    function_mode_e_bridge,
    function_mode_e_LAST_ENTRY,

    function_mode_e_ENTRY_COUNT = function_mode_e_LAST_ENTRY
};
</code></pre>

<p>Though now you lose whatever you were going for before. (Could you clarify what that was?)</p>
",0
4012425,3956650,1,"<p>It looks like the <a href=""http://log4c.sourceforge.net/"" rel=""nofollow"">log4c</a> library comes with a directory structure</p>

<pre><code>/src
  /log4c.h
  /log4c
     /lots of *.h and *.c
</code></pre>

<p>So it's designed to include its headers as</p>

<pre><code> #include &lt;log4c.h&gt;
</code></pre>

<p>or</p>

<pre><code> #include &lt;log4c/logging_event.h&gt;
</code></pre>

<p>as you've done. It's important to do things this way; if, instead, you just write</p>

<pre><code> #include &lt;logging_event.h&gt;
</code></pre>

<p>and you distribute your library to someone who has a <em>different</em> <code>logging_event.h</code>, the files may get confused, and your poor user will end up including the wrong file.</p>

<p>So I recommend sticking with the directory structure that log4c uses. In your case:</p>

<pre><code>project_name/tools/log4c/inc/log4c/logging_event.h
</code></pre>

<p>etc. (as @Jander suggested). The proper way to add the include directory with gcc is <code>-I</code>:</p>

<pre><code>gcc -Iproject_name/tools/log4c/inc foo.c
</code></pre>
",0
3304840,3304836,7,"<p>It's certainly not possible with a macro.  The name of a macro must be an identifier.  The brace characters are punctuators, not identifiers.</p>
",3
3304843,3304836,1,"<p>I've seen this done (not that I endorse it...) with <code>#define BEGIN ...</code> and <code>#define END ...</code>.</p>

<p>e.g.</p>

<pre><code>void foo(void)
BEGIN
    stuff();
END
</code></pre>
",1
3304905,3304836,0,"<p>You can't change the way the compiler interprets {}'s. It's an assumption that they make to be able to syntaxically determine if the code is correct and what it is supposed to do. </p>

<p>If you indeed would like to do something like that, I suggest doing a search-and-replace on ""{"" ""{ MY_MACRO;""</p>
",0
3304909,3304836,1,"<p>Get rich-man's code coverage with the tools discussed in <a href=""https://stackoverflow.com/questions/459287/c-code-coverage-tool-running-on-command-line"">these</a> <a href=""https://stackoverflow.com/questions/1458186/open-source-c-code-coverage-tool-with-gui"">questions</a>, particularly <a href=""http://gcc.gnu.org/onlinedocs/gcc/Gcov.html"" rel=""nofollow noreferrer"">gcov</a>, which is part of GCC.</p>
",1
3570697,3570687,20,"<p>When you have an array or pointer, <code>p+x</code> is equivalent to <code>&amp;p[x]</code>. So <code>MY_STRING + 2</code> is equivalent to <code>&amp;MY_STRING[2]</code>: it yields the address of the third character in the string.</p>

<p>Notice what happens when you add 0. <code>MY_STRING + 0</code> is the same as <code>&amp;MY_STRING[0]</code>, both of which are the same as writing simply <code>MY_STRING</code> since a string reference is nothing more than a pointer to the first character in the string. Happily, then, the identity operation ""add 0"" is a no-op. Consider this a sort of mental unit test we can use to check that our idea about what <code>+</code> means is correct.</p>
",1
3570707,3570687,81,"<p>String literals exist in the fixed data segment of the program, so they appear to the compiler as a type of pointer.</p>

<pre><code>+-+-+-+-+-+--+
|1|2|3|4|5|\0|
+-+-+-+-+-+--+
 ^ MY_STRING
     ^ MY_STRING + 2
</code></pre>
",4
2042122,2042106,3,"<p>If possible, open the first file read-only, (<a href=""http://opengroup.org/onlinepubs/007908799/xsh/open.html"" rel=""nofollow noreferrer"">O_RDONLY</a>) in LINUX.  Then, if you try to open it again to write to it, you will get an error.</p>
",1
2042131,2042106,9,"<p>The best bet is not to use filenames as identities. Instead, when you open the file for reading, lock it, using whatever mechanism your OS supports. When you then also open the file for writing, also lock it - if the lock fails, report an error.</p>
",1
2042141,2042106,13,"<p>On linux, open both files, and use <code>fstat</code> to check if <code>st_ino</code> (edit:) and <code>st_dev</code> are the same. <code>open</code> will follow symbolic links. Don't use <code>stat</code> directly, to prevent race conditions.</p>
",2
2042156,2042106,0,"<p>You can use <a href=""http://linux.die.net/man/2/stat"" rel=""nofollow noreferrer"">stat</a> to get the file status, and check if the inode numbers are the same.</p>
",0
2042262,2042106,0,"<p>Maybe you could use the system() function in order to invoke some shell commands?</p>

<p>In bash, you would simply call:</p>

<pre><code>stat -c %i filename
</code></pre>

<p>This displays the inode number of a file. You can compare two files this way and if their inodes are identical, it means they are hard links. The following call:</p>

<pre><code>stat -c %N filename
</code></pre>

<p>will display the file's name and if it's a symbolic link, it'll print the file name it links to as well. It prints out only one name, even if the file it points to has hard links, so checking the symbolic link would require comparing inode numbers for the 2nd file and the file the symbolic links links to in order to make sure.</p>

<p>You could redirect stat output to a text file and then parse the file in your program.</p>
",3
5550934,5550915,3,"<p>You have a parenthesis mismatch error. Count the number of <code>(</code> and compare to the number of <code>)</code>.</p>

<p>The line should probably be:</p>

<pre><code>while (fgets(linebuffer, sizeof linebuffer, fp_infile) != NULL)
</code></pre>

<p>Note that you only need parens with <code>sizeof</code> when required by the argument's syntax; <code>sizeof</code> itself is an operator, not a function.</p>

<p>My manual and very kindergarten-like way of matching parenthesis, is to simply scan the line from left to right, while maintaining a count:</p>

<ul>
<li>Start at 0</li>
<li>When you find a <code>(</code>, increase the count</li>
<li>When you find a <code>)</code>, decrease the count</li>
</ul>

<p>When you reach the end of the line, if the count isn't back to 0, you have a mismatch. Very obvious, but quite efficient to quickly determine the existence of a mismatch.</p>
",0
5550943,5550915,2,"<p>You have an extra bracket. Try this:</p>

<pre><code>while ( fgets( linebuffer, sizeof(linebuffer), fp_infile ) != NULL )
</code></pre>
",0
3853204,3853183,5,"<p>In case Norman Ramsey doesn't notice this and answer, perhaps a pointer to one of his <a href=""http://www.cs.tufts.edu/~nr/pubs/gcra-abstract.html"" rel=""nofollow"">papers</a> would be in order.</p>

<p>Graph coloring is used primarily in static compilers (aka ahead of time compilers). For dynamic (Just In Time) compilers, you generally use something that gives results faster (e.g., a <a href=""http://www.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf"" rel=""nofollow"">linear scan</a> algorithm), even though it generally won't do as good of a job of register allocation.</p>
",0
3853266,3853183,1,"<p>As Jerry says, the compiler uses a register allocator. Register allocation is one of those simply defined, but hard, problems.</p>

<p>In the olden days, the compiler appreciated your help in solving the problem of which variables to put into registers and when. But today, the task is better understood and the compiler is too busy with program analysis to actually listen to what you have to say.</p>

<p>Unless optimization is completely turned off, your compiler will most likely ignore the <code>register</code> specifier.</p>
",2
3853295,3853183,1,"<p>Apart from the ones mentioned, GCC(4.5.x+) uses a <a href=""http://gcc-uk.internet.bs/summit/2003/Tree%20SSA%20-%20A%20New%20optimization%20infrastructure.pdf"" rel=""nofollow"">SSA-Tree based register allocator</a> (more detail in the <a href=""http://gcc.gnu.org/onlinedocs/gcc-3.0/gcc_17.html"" rel=""nofollow"">Passes section</a>), though here is a good sample of <a href=""http://compilers.cs.ucla.edu/fernando/projects/soc/"" rel=""nofollow"">SSA register allocation</a></p>
",1
3854034,3853183,0,"<p>You can specify a register keyword for a variable. But its upto the compiler to determine whether to put it into the register or not. Usually in static compilation graph coloring is used which produces efficient allocation. Whereas in dynamic (JIT) compilation a method called linear-scan allocation is preferred since graph coloring takes more time.<br>
Directed Acyclic Graphs (DAGs) can be used to produce optimal instruction sequences (or minimum register allocation sequence).<br>
For more thorough reading see: 1.<a href=""http://reports-archive.adm.cs.cmu.edu/anon/2009/CMU-CS-09-157.pdf"" rel=""nofollow"">Towards a More Principled Compiler:Register Allocation and Instruction Selection Revisited by David Ryan Koes</a><br>2. Principles of Compiler Design by Alfred V Aho</p>
",0
4245529,4245519,3,"<p>The problem is that the constants are not interpreted as long integers and the casting to long integer takes place only after the expression is calculated. You can cast them in the expression to solve this or simply define them as long constants. Also, long may not be enough, long long should be used instead if it is supported.</p>
",4
4245534,4245519,8,"<p>Overflow is ok, because you trying 34 bit number write to 32 bit variable (<code>long int</code>).</p>

<p>Use <code>long long int</code> and <code>%lld</code> in format string.</p>

<pre><code>#define     X   2527LL
#define     Y   2463LL
#define     Z   3072LL

main()
{
long long int c = X*Y*Z;
printf(""%lld"",c);
}
</code></pre>
",3
4245549,4245519,1,"<p>Yes, you are getting overflow. The answer will not fit into 32 bit signed integer, which long int is. You have to use 64 bit type, that is long long.</p>

<p>Also, you should do type casting, otherwise the intermediate calculation would overflow.</p>

<pre><code>#define     X   2527
#define     Y   2463
#define     Z   3072

main()
{
long long c = (long long)X*Y*Z;
printf(""%lld"",c);
}
</code></pre>
",2
2337983,2337972,0,"<p><s>It should throw an access violation on most architectures.</s> OK it's a 0 so it works, but if it was not 0 it would fail. It's undefined. You can't <code>free()</code> a stack allocated variable.</p>
",8
2337991,2337972,0,"<p>free() works on dynamically allocated memory, i.e., memory allocated with malloc, calloc, or realloc.  Also, it takes a pointer, and you are passing teh value of x. There is no reason to call it on stack allocated variables that will be freed when the stack unwinds and that behavior is undefined.  Always good to read the documentation.</p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/free/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/clibrary/cstdlib/free/</a></p>
",0
2337999,2337972,2,"<p>From the <code>free</code> man page:</p>

<blockquote>
  <p>free() frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(), calloc() or realloc(). Otherwise, or if free(ptr) has already been called before, undefined behaviour occurs. If ptr is NULL, no operation is performed.</p>
</blockquote>

<p>In your example, you're actually calling <code>free(0)</code>, since <code>free</code> accepts a pointer as an argument. You're essentially telling the runtime to free the memory at address 0, which has <em>not</em> been previously allocated by <code>malloc</code>. </p>

<p>Since '0' is NULL, nothing will happen. (Thanks to the comments for pointing out my silly error).</p>
",2
2338006,2337972,3,"<p>Have you tried turning your compiler's warning level up? For example <code>gcc -ansi -pedantic -W -Wall</code> reports:</p>

<p>tmp.c:6: warning: passing argument 1 of ¡®free¡¯ makes pointer from integer without a cast</p>

<p>The behaviour is undefined. Don't do it.</p>
",7
2338010,2337972,4,"<p>Freeing NULL (or 0) does nothing. It's a no-op.</p>
",0
2338011,2337972,12,"<p>In your case, it works because calling free(NULL) (i.e., free(0)) is a NOOP.  However, if you called it with any value other than 0 (NULL), the behavior would be undefined-- crashes and/or memory corruption are likely candidates.</p>

<p>EDIT: As others have pointed out later, free(x) (with x=0) and free(NULL) are not the same thing.  (Though it is often 0, the value of the NULL pointer is implementation-defined, and cannot be relied upon.)  Please see AndreyT's answer for a very good clarification.</p>
",3
2338124,2337972,14,"<p>No, the behavior is not defined. Moreover, the code is not supposed to compile. </p>

<p>Firstly, the code is not supposed to compile because it contains a constraint violation. The expression you are passing as an operand to <code>free</code> has <code>int</code> type. The parameter of <code>free</code> has <code>void *</code> type. The only case when an <code>int</code> value can be implicitly converted to <code>void *</code> type is when the <code>int</code> value is an Integral Constant Expression (ICE) with value <code>0</code>. In your case <code>x</code> is not an ICE, meaning that it is not implicitly convertible to <code>void *</code>. The only reason your code compiles is that for historical reasons (to support legacy code) your compiler quietly overlooks the constraint violation present in the <code>free(x)</code> call. I'm sure that if you elevate the level of warnings in your compiler, it will complain (at least with a warning). A pedantic compiler will immediately issue an error for <code>free(x)</code> call. Try Comeau Online, for example in C89/90 mode:</p>

<pre><code>""ComeauTest.c"", line 6: error: argument of type ""int"" is incompatible with parameter
          of type ""void *""
      free(x); 
           ^
</code></pre>

<p>(Also, did you remember to include <code>stdlib.h</code> before calling <code>free</code>?)</p>

<p>Secondly, let's assume that the code compiles, i.e. it is interpreted by the compiler as <code>free((void *) x)</code>. In this case a non-constant integral value <code>x</code> is converted to pointer type <code>void *</code>. The result of this conversion is implementation defined. Note, that the language guarantees that when an ICE with value of <code>0</code> is converted to pointer type, the result is a null pointer. But in your case <code>x</code> is not an ICE, so the result of the conversion is implementation-defined. In C there's no guarantee that you will obtain a null pointer by converting a non-ICE integer with value <code>0</code> to pointer type. On your implementation it probably just happened that <code>(void *) x</code> with non-ICE <code>x</code> equal to <code>0</code> produces a null pointer value of type <code>void *</code>. This null pointer value, when passed to <code>free</code>, results in a no-op, per the specification of <code>free</code>. </p>

<p>In general case though, passing such a pointer to <code>free</code> will result in undefined behavior. The pointers that you can legally pass to <code>free</code> are pointers obtained by previous calls to <code>malloc</code>/<code>calloc</code>/<code>realloc</code> and null pointers. Your pointer violates this constraint in general case, so the behavior is undefined.</p>

<p>This is what happens in your case. But, again, your code contains a constraint violation. And even if you override the violation, the behavior is undefined.</p>

<p><strong>P.S.</strong> Note, BTW, that many answers already posted here make the same serious mistake. They assume that <code>(void *) x</code> with zero <code>x</code> is supposed to produce a null pointer. This is absolutely incorrect. Again, the language makes absolutely no guarantees about the result of <code>(void *) x</code> when <code>x</code> is not an ICE. <code>(void *) 0</code> is guaranteed to be null pointer, but <code>(void *) x</code> with zero <code>x</code> is <em>not</em> guaranteed to be null pointer.</p>

<p><strong>This is covered in C FAQ</strong> <a href=""http://c-faq.com/null/runtime0.html"" rel=""nofollow noreferrer"">http://c-faq.com/null/runtime0.html</a> . For those interested in better understanding of why it is so it might be a good idea to read the entire section on null pointers <a href=""http://c-faq.com/null/index.html"" rel=""nofollow noreferrer"">http://c-faq.com/null/index.html</a></p>
",15
2340054,2337972,0,"<pre>  

free (0 );

""Calling free function with NULL value , will have no effect.""

</pre> 

<p>Actually it will make impact , when we are freeing the using memory. </p>

<p>Here x value is zero , So that it does not make any problem. If x has value other than </p>

<p>zero , in this case it may  get segmentation fault . Because x value might be using as a  </p>

<p>memory representation some other variables. </p>
",0
5560096,51561,2,"<p>There is an Eclipse plugin called includator which helps to manage include dependencies in C/C++ projects</p>

<p><a href=""http://includator.com/"" rel=""nofollow"">http://includator.com/</a></p>
",0
5188686,5187155,0,"<pre><code>// a comment saying what this does
if( goleft ) p-&gt;left = p-&gt;right-&gt;left; 
else         p-&gt;right = p-&gt;left-&gt;right;
</code></pre>

<p>I don't know what the comment should be because this code doesn't make any sense to me; it appears to disconnect <code>p</code> from its left or right successor and instead points it to itself, assuming that <code>p-&gt;right-&gt;left</code> and <code>p-&gt;left-&gt;right</code> are sensibly <code>p</code> itself. And the test doesn't make sense because you aren't ""going"" anywhere, you're modifying the list. What would make sense is</p>

<pre><code>Node* next = goleft? p-&gt;left : p-&gt;right;
</code></pre>

<p>My comment here is based on yours that this is a doubly-linked list. If instead it is a binary tree then the code makes a bit more sense, but then you're removing a node but not saving a link to it. As larsmans mentioned, this looks like a memory leak.</p>
",0
3741899,3741877,1,"<p>bitarray.o is compiled into an object file <code>everybit</code> <strong>BUT</strong> there is <strong><em>no reference</em></strong> in this line to <code>everybit</code> hence the undefined symbols...</p>

<pre><code>gcc -o everybit_harvey main.o ktiming.o bitarray_harvey.o tests.o -arch x86_64 -framework CoreServices
Undefined symbols:
  ""_bitarray_reverse"", referenced from:
      _test_reverse in tests.o
ld: symbol(s) not found
collect2: ld returned 1 exit status
make: *** [everybit_harvey] Error 1
</code></pre>

<p>What is <code>_harvey</code>referring to?</p>
",2
3123506,3123496,9,"<p>This has nothing to do with your code, but rather with your shell. If you want the shell to not glob wildcards then you will need to escape them, either with a backslash or with quotes.</p>

<pre><code>./foo \*
./bar '*'
</code></pre>
",0
3123509,3123496,4,"<p>Your shell interprets the '*' character as the list of all files in the current directory. The problem is not in your program but in the way you run it.</p>

<p>try:</p>

<p><strong>./a.out 2 3 4 + \*</strong></p>
",0
2833435,2833428,3,"<p>The result of <code>a,b,x,y</code> is <code>y</code> (because the comma operator evaluates to the result of its right operand) and y is 0, which is false.</p>
",0
2833438,2833428,2,"<p>The comma operator returns the last statement, which is <code>y</code>.  Since <code>y</code> is zero, the if-statement evaluates to false, so the <code>printf</code> is never executed.</p>
",0
2833439,2833428,1,"<p>Because expression <code>a,b,x,y</code> evaluates to <code>y</code>, which in turn evaluates to <code>0</code>, so corresponding block is never executed. Comma operator executes every statement and returns value of last one. If you want logical conjunction, use <code>&amp;&amp;</code> operator:</p>

<pre><code>if (a &amp;&amp; b &amp;&amp; x &amp;&amp; y) { ... }
</code></pre>
",0
2833442,2833428,11,"<p><a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow noreferrer"">Comma operator</a> - evaluates 1st expression and returns the second one. So <code>a,b,x,y</code> will return value stored in y, that is 0.</p>
",0
2833468,2833428,0,"<p>Others already mentioned that the comma operator returns the right-most value. If you want to get the value printed if ANY of these variables is true use the logical or:</p>

<pre><code>int main()
{
   int a=10,b=20;
   char x=1,y=0;
   if(a || b || x || y)
   {
      printf(""EXAM"");
   }
 }
</code></pre>

<p>But then be aware of the fact that the comma evaluates all expressions whereas the or operator stops as soon as a value is true. So with</p>

<pre><code>int a = 1;
int b;
if(a || b = 1) { ... }
</code></pre>

<p>b has an undefined value whereas with </p>

<pre><code>int a = 1;
int b;
if(a, b = 1) { ... }
</code></pre>

<p>b will be set to 1.</p>
",0
6085885,558009,2,"<p>Maybe you can try like this:</p>

<pre><code>#include&lt;stdio.h&gt;
char s[100];
system(""stty -echo"");
scanf(""%s"",s); /* Won't echo to screen while being typed */
system(""stty echo"");
printf(""You have entered:"");
printf(""%s\n"", s);
return 0;
}
</code></pre>

<p>In Linux, the system function ""stty -echo"" is to type in sth without echo. Hope this will help.</p>
",0
2325572,2325528,1,"<p>I believe that both the switch and the table-look up will be equivalent (although one should do some tests on the compiler being used). A modern C compiler will implement a big switch with a look-up table. The table look-up can be created more easily with a macro or a scripting language.</p>

<p>For both solutions the input A must be an integer. If this is not the case, one solution will be to implement a huge if-else statement.</p>

<p>If you have strings you can create two arrays - one for input and one for output  (this will be inefficient if they aren't of the same size). Then you need to iterate the contents of the input array to find a match. Based on the index you find, you return the corresponding output string.</p>
",2
2325575,2325528,7,"<p>If speed is ultra ultra necessary, then I would consider <a href=""http://www.gnu.org/software/gperf/"" rel=""nofollow noreferrer"">perfect hashing</a>. Otherwise I'd use an array/vector  of string to string pairs, created statically in sort order and use binary search. I'd also write a small test program to check the speed and memory constraints were met.</p>
",3
2325674,2325528,0,"<h3>Make a key that is fast to calculate, and hash</h3>
<p>If the table is pretty static, unlikely to change in future, you could have a look-see if adding a <em>few</em> selected chars (with fix indexes) in the &quot;key&quot; string could get unique values (value K). From those insert the &quot;value&quot; strings into a hash_table by using the pre-calculated &quot;K&quot; value for each &quot;key&quot; string.</p>
",0
2328425,2325528,0,"<p>Although a <em>hash</em> method is fast, there is still the possibility of collision (two inputs generating the same hash value).  A fast method depends on the data type of the input.  </p>

<p>For integral types, the fastest table lookup method is an array.  Use the incoming datum as an index into the array.  One of the problems with this method is that the array must account for the entire spectrum of values for the fastest speed.  Otherwise execution is slowed down by translating the original index into an index for the array (kind of like a hashing method).</p>

<p>For string input types, a nested look up may be the fastest.  One example is to break up tables by length.  The first array returns pointers to the table to search based on length, e.g. char * sub_table = First_Array[5] for a string of length 5.  These can be configured for specialized input data.</p>

<p>Another method is to use a B-Tree, which is a binary tree of ""pages"".  Behavior is similar to nested arrays.</p>

<p>If you let us know the input type, we can better answer your question.</p>
",0
5551504,5551427,5,"<p>You are copying the integer value (55) into the pointer <code>int_out</code>. Whatever lies at (the next 4 to 8 bytes at) address 55, it is unlikely to have the numerical value 55. Instead, try</p>

<pre><code>int int_in = 55;
int int_out;
store   ( storage_int, &amp;int_in, sizeof(int));
retrieve ( &amp;int_out, storage_int, sizeof(int));
assert  ( 55 == int_out);
</code></pre>

<p>Another problem with your code: in the <code>char_in</code>/<code>char_out</code> parts, you are only ever copying pointer values. This works (in this case), but is not likely what you really intended, or is it? If you really want to store the pointer, you can skip the <code>store</code> and <code>retrieve</code> part:</p>

<pre><code>char* str_in = ""hello, world"";     // Original value
void* generic_ptr = str_in;        // ... a pointer to which is stored in some data structure
char* str_out = generic_ptr;       // ... which can later be retrieved
</code></pre>

<p>will work as well. On the other hand: if you intend to store the actual content of the string, you have to copy it (like, with <code>_strdup</code> as in your second example), and save the pointer to the <em>copy</em> of the string:</p>

<pre><code>char* str_in = _strdup(""copy me"");
void* generic_ptr = str_in;         // Gets stored in your data structures
</code></pre>
",0
5551513,5551427,4,"<p>You're overwriting the pointer, then dereferencing it... if your code looked like this it would work... but that may not be what you're after.</p>

<pre><code>    int int_out;
    store   ( storage_int, &amp;int_in, sizeof(int));
    retrive ( &amp;int_out, storage_int, sizeof(int));
    assert  ( 55 == int_out);
</code></pre>

<p>or:</p>

<pre><code>    int *int_out;
    store   ( storage_int, &amp;int_in, sizeof(int));
    retrive ( &amp;int_out, storage_int, sizeof(int));
    assert  ( 55 == (int)int_out);
</code></pre>

<p>However, in the second case this is a bit dubious, because it assumes that both 'int' and 'int*' are the same size, so you're able to store one on top of the other when retrieving.  I believe this isn't the case on all systems.</p>
",0
5551553,5551427,1,"<p>Dirk is totally correct.
Another way to express this, is that there is no space allocated to put retrieved data in.</p>

<p>try:</p>

<pre><code>int_in = 55;
void* int_out = malloc (sizeof (int_in));
store   ( storage_int, &amp;int_in, sizeof(int));
retrieve ( int_out, storage_int, sizeof(int));
assert  ( 55 == *(int*)int_out);
</code></pre>

<p>Of course, you may want to use something other than malloc(), and there is no check to see if malloc() failed, but this should get you on the right track.</p>
",0
5551632,5551427,15,"<p>It's much better to use a union of all types you will need instead of <code>void*</code>, combined with an enumeration of the selected type.
If you don't have a finite list of types, then use a struct containing <code>void*</code> pointer and the size allocated at least.</p>

<p>For example:</p>

<pre><code>struct ANYTYPE
{
    enum {
      typUndefined,
      typInt,           // 1
      typUint,
      typString,
      typByteString,
      typLong,          // 5
      typFloat,
      typDouble,
    } iType;

    void* value;
};
</code></pre>

<p>This allows you to easily deallocate the memory correctly and make generic code that can analyze the type before acting on the value.
You have a similar option with union:</p>

<pre><code>struct ANYTYPE
{
    enum {
      typUndefined,
      typInt,           // 1
      typUint,
      typString,
      typLong
    } iType;

    union
    {
        int i;
        unsigned int u;
        char* s;
        long l;
    } value;
}
</code></pre>

<p>In a union, all elements are using same memory space and only one should be accessed. Via the enumeration, you know which element should be accessed. Of course you don't have OO protection like in C++, so you need to be sure you correctly set the enumeration everywhere you use this struct.</p>
",8
2944225,2943779,3,"<p>Personally, I like putting <code>const</code> on as many variables as possible ¨C I rarely change the value of a variable once assigned. (One notable exception are of course loop counters/iterators.)</p>

<p>At the very least, this significantly improves debuggability because it ensures that values cannot be changed. This makes tracking the state of the execution much easier. It also improves readability because it signals the <em>intent</em> of working with immutable values.</p>

<p>Consequently, I do the same for function parameters. After all, they behave like normal variables inside the function.</p>

<p>On the other hand, this confuses the hell out of many other programmers so in most collaborative projects I refrain from doing this; it would break consistency and be counter-productive.</p>
",0
2943793,2943779,1,"<p>The so called ""const correctness"" is very important especially if you are creating some module (dll for example) where other people will use it. It makes it much easier to understand the purpose of the function and helps prevent some odd bugs (among other things). So yes, i would definetly suggest using the const modifier where applicable.</p>

<p>EDIT: now looking closely at the function header, it seems that ""dest"" is something which the function has to change. Then declaring it as const seems odd.</p>
",1
2943806,2943779,4,"<p>People's opinion differ on this. I know some perfectly capable developers who write that const for any parameter that should <em>not</em> be changed locally in the function. Logically that is just consequent application of the const-correctness principle. </p>

<p>Whatever you do, however, you should omit the const in the function declaration in the header. The <code>const</code> should be part only in the function definition. C (and C++, too) has rules that make this compatible (i.e a <code>const</code> for a value parameter is ignored (when it affects the parameter only at its toplevel) for pure function declarations that don't have a body). The rationale is that such a <code>const</code> will not change anything with regard to the caller, and is thus an implementation detail of the called function. </p>

<p>This does not hold for your first parameter. Any capable developer i know will put that const there, because it's making an important guarantee to the caller of your function (that it won't change the data pointed to of what is passed in). The name of your parameter, however, seems a bit odd, because it indicates that the function <em>does</em> need to write into what is pointed to. </p>

<p>Notice that to be consequent, you would have to make the first parameter itself const too, like you did with the second parameter. Thus this would become (renaming it to ""source"" too, to avoid confusion). </p>

<pre><code>void do_something(const char * const source, const int size)
</code></pre>
",2
2944015,2943779,1,"<p>In my opinion there is no point in declaring const on anything else than a pointed area. Scalar parameters (and even pointers) are local copies with the exact same constraints as other local variables. They are in fact local variables and it's sometime appropriate to use them and modify them which may avoid unecessary copies of their values.</p>

<pre><code>char * strcat(char *d, const char *s)
{
  char *p = d;

  while(*p) p++;
  while(*s) *p++ = *s++;
  *p = 0;
  return d;
}


char * strcat(char *d, const char *s)
{
char *p = d;
const char *s2 = s;

  while(*p) p++;
  while(*s2) *p++ = *s2++;
  *p = 0;
  return d;
}
</code></pre>

<p>Is the second variant really better? I don't think so.</p>

<p>When using the old K&amp;R syntax it's more obvious that they are local variables of the function.</p>

<pre><code>char * strcat(d, s)
char *d;
const char *s;
{
...
</code></pre>
",0
4230928,4230870,0,"<p>Most compilers have a way to indicate that a structure should be packed tightly, without padding for alignment purposes.</p>

<p>I'm not familiar with your compiler, but explore the documentation for something like</p>

<pre><code>#pragma pack
</code></pre>

<p>before your structure definition.</p>
",0
4232235,4230870,1,"<p>If you want to access the byte-sized parts of a memory-mapped register, do the following:</p>

<pre><code>struct DeviceRegMap {
  volatile unsigned char byte0;
  volatile unsigned char byte1;
  volatile unsigned char byte2;
  volatile unsigned char byte3;
};

static struct DeviceRegMap *device = (struct DeviceRegMap *)(0xD0000000);
</code></pre>

<p>Now <code>device-&gt;byte0</code> points to <code>0xD0000000</code>, and <code>device-&gt;byte3</code> points to <code>0xD00000003</code>. Is that what you want?</p>
",1
2920737,2920721,1,"<p>Just perhaps the program is taking a little while to run... just perhaps.</p>

<p>Here's a possible issue: What happens when fgetc returns EOF (-1) ?</p>
",3
2920806,2920721,1,"<p><code>while(1 != (*rc)(a))</code></p>
",0
2920607,2920549,1,"<p>Fopen returns pointer.</p>

<p>Replace this:</p>

<pre><code>FILE fp1;
</code></pre>

<p>with</p>

<pre><code>FILE *fp1;
</code></pre>

<p>In main start.</p>
",0
2920615,2920549,0,"<p><code>strcpy</code> operates on pointers, but <code>array[count]</code> is a char. You haven't given enough information to tell what should be happening there. </p>

<p><code>cf</code> takes pointers to <code>char</code> but (in <code>BubbleSort</code>) you are passing it a pointer to <code>int</code>; yet in <code>main</code> you pass an array of <code>char</code> into <code>BubbleSort</code>. Perhaps you should change <code>BubbleSort</code> to take an array of <code>char</code> ?</p>

<p>You haven't included <code>&lt;stdlib.h&gt;</code>.</p>
",1
2920632,2920549,0,"<p>The line </p>

<pre><code>strcpy(array[count],d);
</code></pre>

<p>is trying to copy a string into a character.  You probably want to do something like (depending on what it is that you're trying to copy):</p>

<pre><code>array[count] = d[count];
</code></pre>

<p>I think you need to include stdlib.h.</p>
",0
2920640,2920549,2,"<pre><code>fsc1.c: In function ¡®ReadFile¡¯:
fsc1.c:19: warning: passing argument 1 of ¡®strcpy¡¯ makes pointer from integer without a cast
</code></pre>

<p>You should be passing <code>&amp;array[count]</code> as the first parameter, not <code>array[count]</code>. </p>

<pre><code>fsc1.c: In function ¡®Bubblesort¡¯:
fsc1.c:40: warning: passing argument 1 of ¡®cf¡¯ from incompatible pointer type
fsc1.c:40: warning: passing argument 2 of ¡®cf¡¯ from incompatible pointer type
</code></pre>

<p>I would call cf as <code>(*cf)(&amp;array[j], &amp;array[j+1])</code>, no need to worry about element size as compiler will take care of it.</p>

<pre><code>fsc1.c:43: warning: incompatible implicit declaration of built-in function ¡®malloc¡¯
fsc1.c:47: warning: incompatible implicit declaration of built-in function ¡®free¡¯
</code></pre>

<p>You need to <code>#include &lt;stdlib.h&gt;</code></p>

<pre><code>fsc1.c: In function ¡®main¡¯:
fsc1.c:80: error: incompatible types in assignment
</code></pre>

<p>fp1 should be declared as a <code>FILE *</code>.</p>

<pre><code>fsc1.c:82: warning: passing argument 1 of ¡®Bubblesort¡¯ from incompatible pointer type
</code></pre>

<p>Your array is a <code>char</code> array, whereas the first parameter of Bubblesort expecting an <code>int *</code>. I would change Bubblesort to take a <code>char *</code>.</p>
",0
5446555,5446281,0,"<p>In C, the result of a shift is implementation-dependent. With x86 processors, you can actually be sure that the shift operand is modulo-32 (in 32-bit mode). See page 3-623 of this document:</p>

<p><a href=""ftp://download.intel.com/design/intarch/manuals/24319101.pdf"" rel=""nofollow"">ftp://download.intel.com/design/intarch/manuals/24319101.pdf</a></p>

<p>""The destination operand can be a register or a memory location. The count operand can be an
immediate value or register CL. <strong>The count is masked to five bits</strong>, which limits the count range
to 0 to 31. A special opcode encoding is provided for a count of 1""</p>
",2
5446306,5446281,9,"<p>The result of a shift operation is undefined if the number of shifted bits is greater than <em>or equal</em> to the number of bits in the shifted value. So, shifting a 32-bit value by 32 isn't guaranteed to produce anything in particular.</p>
",2
5446314,5446281,4,"<p>Because in C the result is undefined if you shift an operand having a size of <code>x</code> bits by <code>x</code> bits. So for example <code>1 &lt;&lt; 32</code> is undefined (assuming <code>sizeof(int) == 4</code>)</p>
",0
2451809,52445,0,"<p>or you can look at ccan <a href=""http://ccan.ozlabs.org/"" rel=""nofollow noreferrer"">http://ccan.ozlabs.org/</a></p>

<p>but no, there really isn't any complete package, glib comes closest </p>
",0
6103570,52445,1,"<p>Glib does compensate it partially in form of various unicode, string types. If you add Gobject you could get some object programming even some garbage collection.</p>
",0
2422021,2422001,0,"<p>Usually the integer code for a new line ('\n') is 13. So you could do ( if (c == 13) ), but also note that windows files use 2 characters to define a new line '\r' and '\n'.  The integer character for '\r' is 10.  But basically yes you can keep 'c' as an int and just compare against 13.</p>
",4
2422086,2422001,1,"<p>Your code prints line numbers at the end of a line, right before printing the <code>'\n'</code>, because of the way you have written the loop.  Otherwise, your code should work.</p>

<p>If you want your code to print the line numbers at the beginning, you can do something like (untested):</p>

<pre><code>int line_num_printed = 0; /* indicating if we printed a line number */
int line = 1;

while ((c = fgetc(fp)) != EOF) {
    if (!line_num_printed) {
        printf(""LINE %d: "", line);
        line_num_printed = 1;
    }
    putchar(c);
    if (c == '\n'){
        line++;
        line_num_printed = 0;
    }
}
</code></pre>

<p>If there is something else that ""doesn't work"", you should post complete code and tell us what doesn't work.</p>

<p><em>Edit</em>: The proper way to check a character for a newline is to test against <code>'\n'</code>.  If the character came from a file, you should also make sure you open the file in text mode, i.e., without a <code>b</code> in the second argument to <code>fopen()</code>.</p>

<p>Also, you want <code>c</code> to be of type <code>int</code>, not <code>char</code>.  This is because in C, <code>EOF</code> is a small negative number, and if <code>char</code> is unsigned, comparing it against a negative number convert the value of <code>EOF</code> to a positive value (equal to <code>EOF + UCHAR_MAX + 1</code> most likely).  Therefore, you should <em>not</em> change <code>c</code> to <code>char</code> type.  If you do, the comparison <code>c != EOF</code> might be false even when <code>fgetc()</code> returns <code>EOF</code>.</p>
",0
5605405,435834,1,"<p>Well most people are suggesting system programming related things like OS Kernels , Device Drivers etc. These are difficult and Time consuming. Maybe the most fun thing to with C is console programming. Have you heard of the HAM SDK? It is a complete software development kit for the Nintendo GBA , and making games for it is fun. There is also the CC65 Compiler which supports NES Programming (Althought Not Completely). You can also make good Emulators. Trust Me , C is pretty helpful. I was originally a Python fan, and hated C because it was complex. But after yuoget used to it, you can do anything with C. Now I use CPython to embed Python in my C Programs(if needed) and code mostly in C. 
C is also great for portability , There is a C Compiler for like every OS and Almost Every Console And Mobile Device. Ive even seen one that supports some calculators!</p>
",0
2451779,2451742,1,"<p>Yes, the declaration you use will create an array of 5 elements, and only set one of them to the value '1'. The rest will be uninitialised (I believe).</p>

<p>What you want, I think, is a hash table or some other kind of associative container, which C does not have in it's standard library. You'll either have to write one yourself, or find one that someone else has written.</p>
",3
2451792,2451742,0,"<p>Yes memory is allocated when you declare an array, even though you dont initialize every element. If you want only one value stored you need a single variable, you can also Allocate memory dinamically but it requires a good knolewdge of pointers and memory allocation/management functions (malloc,realloc,free,etc.)</p>
",3
2451834,2451742,3,"<p>Let's ask Mr. Compiler!</p>

<pre><code>#include &lt;stdio.h&gt;
int main( int argc, char ** argv )
{
    int array[] = {[2] = 1, [590] = 2};
    printf(""sizeof(array) is %d bytes\n"", sizeof(array));
}
</code></pre>

<p>Survey says:</p>

<pre><code>$ gcc initsize.c
$ ./a.out
sizeof(array) is 2364 bytes
</code></pre>

<p>Yep! 591 * 4 = 2364.</p>

<p>Here, you've allocated a 591 element integer array on the stack. It <em>has</em> to be allocated; the compiler does not know what you may do with it (pass it to a library function it knows nothing about, for example). You told it the size is 591 elements, and it obeys...</p>

<p>P.S. There are <em>many</em> ""sparse matrix"" C libraries; just google for ""C library sparse matrix"". But, for a vector of 591 elements, they are total over-kill. Now, if you have 10,000 of such vectors, that's another story.</p>
",1
6118532,6118475,0,"<p>That statement will cause there to be somewhere in memory a sequence of bytes that looks something like this (assuming a <a href=""http://en.wikipedia.org/wiki/Endianness#Big-endian"" rel=""nofollow"">big-endian</a> processor and ignoring <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">structure padding</a> for simplicity's sake).</p>

<pre><code>Location    Contents
   N          0x00    // highest byte of 1
   N+1        0x00   
   N+2        0x00
   N+3        0x01    // lowest byte of 1
   N+4        0x00    // highest byte of 2
   N+5        0x00
   N+6        0x00
   N+7        0x02    // loweest byte of 2
   N+8        0xLL    // Highest byte of pointer to pointing to location 0xLLMMNNPP
   N+9        0xMM    
   N+10       0xNN    
   N+11       0xPP    // Lowest byte of pointer pointing to 0xLLMMNNPP
</code></pre>

<p>And then at location <code>0xLLMMNNPP</code> you will have the string data:</p>

<pre><code>   Location     Contents
   0xLLMMNNPP    0x49  // I
   0xLLMMNNPP+1  0x27  // '
   0xLLMMNNPP+2  0x6D  // m
   [and so on]
   0xLLMMNNPP+15 0x00  // the end-of-string terminator
</code></pre>

<p>In your program the structure doesn't really exist at all.  The structure only defines how the data is to be laid out in memory.  The compiler will remember that definition so it knows where to find the pieces of the structure given the start location of where structure data is sitting in memory.</p>
",1
6118542,6118475,0,"<p>Definition of <code>struct Somethings</code> is how you tell the compiler about a new type you created.  <code>struct Something thing</code> is how you create an object of that type.</p>

<p>When the program runs, all the objects are created, and after their scope is exited, they are all destroyed.  For the objects you create using dynamic allocation, it is left to you, or the program exiting, to destroy the objects and release the memory held by them.</p>

<p>It should help if you look at the memory layout of a C program to understand the runtime foot print of a program.</p>

<p>And, the struct definition you have given in the question is not terminated properly.</p>
",1
6118642,6118475,2,"<p>In practice, the answer to your question depends on exactly where you declare that line:</p>

<pre><code>struct Something thing = {1, 2, ""I'm a sentence...""};
</code></pre>

<p>At file scope, this declares <code>thing</code> with <em>static storage duration</em>, which means that it lives from program startup to program termination.  In this case, there is quite likely to be only one physical copy of the data, both in the compiled program on disk and in memory while the program executes.</p>

<p>Alternatively, within a function, this declares <code>thing</code> with <em>automatic storage duration</em>, which means that it lives only until the function returns.  In this case, there is still likely to be only one physical copy of the data in the compiled program, but while the program is executing there will be a second, temporary copy created each time the declaration of <code>thing</code> is reached, and destroyed each time that function returns.  (Note that this applies to the <code>1</code>, <code>2</code> and the pointer value stored in <code>thing.member3</code>, but not the string <code>""I'm a sentence...""</code> itself - there is still only ever one copy of that).  If the function is called recursively, then third, fourth, etc temporary copies of the data will be made.</p>
",2
2915218,2915037,1,"<p>If you insist on this specific interface (the position of the field is defined by the mask), then probably the only thing that can be changed/improved in your implementation is the cycle where you shift the value to the proper position (to align it with the mask). Basically, what you have to do is to find the <em>offset</em> expressed in the number of bits, and the shift the value left that number of bits. You used a plain cycle to perform that operation, and instead of explicitly calculating the offset in bits you simply shift the value left 1 bit at each iteration. This will work. However, it might be seen as inefficient, especially for fields that reside in the upper portion of the register, since they will require more iterations of the shifting cycle.</p>

<p>In order to improve the efficiency you can also use any of the rather well-known, potentially more efficient methods to calculate the offset value, as the ones described on <a href=""http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightLinear"" rel=""nofollow noreferrer"">this page</a>. I don't know whether this is worth the effort in your case though. It might make your code more efficient, but it might also make it less readable. Decide for yourself.</p>
",0
2915082,2915037,3,"<p>Why not just put both the mask and the value in the right place?</p>

<pre><code>#define BM_TEST_FIELD (0xfUL &lt;&lt; 16)
#define BM_TEST_VALUE (0xaUL &lt;&lt; 16)
#define mmioMaskInsert(reg, mask, value) \
   (*(volatile u32 *)(reg) = (*(volatile u32 *)(reg) &amp; ~(mask)) | value)
</code></pre>

<p>Then you can just use it like:</p>

<pre><code>mmioMaskInsert(reg, BM_TEST_FIELD, BM_TEST_VALUE);
</code></pre>

<p>For sure what you have there is very dangerous.  Register writing can often have side-effects, and these operations:</p>

<pre><code>mem_reg &amp;= ~(MASK);
mem_reg |= value;
</code></pre>

<p>are actually writing to the register twice, instead of once, like you probably intend to.  Also, why isn't a mask of 0 supported?  What if I want to write to the whole register (timer count match or something)?  Do you have a different macro for that operation?  If so, why not use it as part of this system?</p>

<p>Another note - it might be a good idea to apply the mask to the value before sticking it in the register, in case someone passes a value that has more bits than the mask does.  Something like:</p>

<pre><code>#define maskInsert(r, m, v) \
  (*(volatile u32 *)(r) = (*(volatile u32 *)r &amp; ~(m)) | ((v) &amp; ~(m)))
</code></pre>
",2
2915188,2915037,2,"<p>I would <em>consider</em> using bitfields to ""format"" bits for hardware, e.g.:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

struct myregister {
    unsigned upper_bits:12;
    unsigned myfield:4;
    unsigned lower_bits:16;
};

typedef union {
    struct myregister fields;
    uint32_t value;
} myregister_t;

int main (void) {
    myregister_t r;
    r.value = 0x12345678;
    (void) printf(""Register before: 0x%.8"" PRIX32 ""\n"", r.value);
    r.fields.myfield = 0xA;
    (void) printf(""Register after: 0x%.8"" PRIX32 ""\n"", r.value);
    return 0;
}
</code></pre>

<p><strong>Edit:</strong> Note the follow-up discussion in the comments. There are valid arguments against using bitfields, but, in my opinion, also benefits (especially in syntax, which I value greatly). One should decide based on the circumstances the code will be used in.</p>
",9
2916912,2915037,5,"<blockquote>
  <p>EDIT: in particular, I'm looking for a way to do reduce the run-time computing requirements. Is there a way
  to have the pre-processor compute the number of required left-shifts for the value?</p>
</blockquote>

<p>Yes:</p>

<pre><code>value *= ((MASK) &amp; ~((MASK) &lt;&lt; 1))
</code></pre>

<p>This multiplies <code>value</code> by the lowest set bit in <code>MASK</code>.  The multiplier is known to be a constant power of 2 at compile time, so this will be compiled as a simple left shift by any remotely sane compiler.</p>
",1
4019667,4019649,0,"<p>Well, what makes you think <code>stdin</code> will ever close? :)</p>

<p>You can use <code>isatty(STDIN_FILENO)</code> to determine if <code>stdin</code> is hooked up to user input. (If it is, the function returns non-zero.) If that's the case, you can alter your behaviour accordingly.</p>
",0
4020286,4019649,1,"<p>Write all of your output to a temporary file instead of <code>stdout</code>, then copy from this temporary file to <code>stdout</code> at the end of your program's execution.</p>
",0
4331452,4331439,12,"<p>The </p>

<pre><code>char *mystring =""love is alweys better yoe""
</code></pre>

<p>makes mystring read-only</p>

<p>you need to copy the string into a buffer before you can change it</p>

<p>e.g.</p>

<pre><code>char mystring[128];
strcpy( mystring , ""love is alweys better yoe"" );
</code></pre>
",0
4331460,4331439,10,"<p><strong>Stack allocation</strong></p>

<pre><code>char *mystring =""love is alweys better yoe"";
</code></pre>

<p>This creates a string literal in read-only memory, and you cannot subsequently write to it to change characters.</p>

<p>You should initialise your string like this instead:</p>

<pre><code>char mystring[] =""love is alweys better yoe"";
</code></pre>

<p>This will allocate a character array of size 26 bytes - 1 byte per character, terminated with a null character <code>\0</code>.</p>

<p>Note that if you attempt to write past the end of the buffer (i.e. beyond the <code>\0</code> character), you may be invading the memory allocated for other data in your program, and this can have undesirable consequences.</p>

<p><strong>Heap allocation</strong></p>

<p>The previous example allocates memory on the stack, and will be free'd at the end of the current level of scope (usually the function you are in).  If you want the memory to persist beyond the end of the function call, you need to allocate it on the heap like so:</p>

<pre><code>int bufferSize = 26;
char* mystring = malloc(bufferSize);
strncpy(mystring, ""love is alweys better yoe"", bufferSize);
</code></pre>

<p>And you will need to remember to <code>free</code> this memory when you are done with it:</p>

<pre><code>free(mystring);
</code></pre>

<p>If <code>free</code>ing from the calling function, you will need to return the <code>char*</code> pointer back to the caller, so it knows which memory location to <code>free</code>.  If you don't <code>free</code> this memory, your program will leak memory.</p>

<p><strong>Increasing size of string</strong></p>

<p>If you need to re-size the string after allocating memory for it, you can use <code>realloc</code>:</p>

<pre><code>char* mybiggerString = realloc(mystring, bufferSize + 10);
strncpy(mystring, ""I can fit more in this string now!"", bufferSize);
</code></pre>
",2
4331480,4331439,5,"<p>""in the char*"" is meaningless. You cannot change things that are ""in"" the pointer, because there is nothing ""in"" the pointer - it does not contain things. It points at things. That's why it's called a ""pointer"", not a ""container"".</p>

<p>When you write <code>char *mystring =""love is alweys better yoe"";</code>, you cause <code>mystring</code> to point at a <em>string literal</em>. This is a chunk of memory that is dedicated to holding the text. It is in a special area of memory that <strong>may not be changed</strong>. (The text is stored in the .exe file; in most implementations, the OS loads your .exe file into memory, and then points the pointer into that part of the loaded .exe. You may not change this memory because the OS forbids it - basically, to make it harder to create a virus.)</p>

<p>Solution: Use a modifiable chunk of memory. Write it this way: <code>char mystring[] = ""love is alweys better yoe"";</code>. The string literal will still exist in your program, but this instructs the program to make a buffer (in memory which may be changed) and copy the literal into the buffer. This buffer is exactly the same length as the literal, so you still <strong>may not append</strong> to the string - only change the existing characters, or cut it off (by writing a null byte somewhere in the middle).</p>
",3
4251543,4251519,0,"<pre><code>fprintf(fpout,""%X"",input_int);
</code></pre>
",0
4251548,4251519,0,"<p><a href=""https://stackoverflow.com/questions/772118/problem-writing-int-to-binary-file-in-c"">Problem writing int to binary file in C</a></p>
",0
4251582,4251519,0,"<p>Do you mean you just want two bytes in the file like <code>""\x20\x20""</code> and not as text as in <code>""0x2020""</code>?
Assuming your variable is short. <code>(sizeof(short) == 2)</code></p>

<p>First one: <code>fwrite((const void*)&amp;variable, sizeof(variable), 1, file);</code></p>

<p>Second one: <code>fprintf(file, ""%#06x"", variable);</code></p>
",1
4251592,4251519,3,"<p>This will write a short integer to a binary file.  The result is 2 bytes of binary data (Endianness dependent on the system).  </p>

<pre><code>int main(int argc, char* argv[])
{
   short i;
   FILE *fh;

   i = 1234;
   fh = fopen( argv[1], ""wb"" );
   fwrite( &amp;i, sizeof( i ), 1, fh );
   fclose(fh);

}
</code></pre>
",0
2321607,2321590,3,"<p>I prefer item 3 but it comes down to preference.</p>
",0
2321616,2321590,3,"<p>IMHO, the first way is better. It is much easier to read than number 3, because you don't need to know the signature of the function to understand what the parameters are.</p>

<p>For bigger data structures, I would go with number 2, i.e. use pointer such that you don't have to copy the values. But in this case, the difference is not significant, and I think that the */&amp; slightly reduce the readability.</p>
",7
2321626,2321590,2,"<p>Definitely #1. It makes the rest of the code much more readable, and using a pointer where a normal variable will do complicates the matter for no reason. The compiler will optimize away whatever microscopic performance gains you might get from #3.</p>
",2
2321657,2321590,4,"<p>Option 1 is clear but a bit wordy. I don't like 2 at all, and 3 is hard to understand. Personally I prefer to use structs for this sort of thing. </p>

<pre><code>typedef struct  {
   unsigned char whatever[2];
   unsigned char device_address;
   unsigned char register_address;
   unsigned char num_bytes;
   }  CMD;

CMD * pcmd = (CMD *)&amp;cmd[0];

// use the local variables:
if(num_bytes ¡Ü 0xFF) {
    do_stuff(pcmd-&gt;device_address, pcmd-&gt;register_address, pcmd-&gt;num_bytes);
</code></pre>
",7
2321752,2321590,0,"<p>I like 1 the most, it's much more readable than the others.</p>

<p>If performance is an important issue (i mean important like in ""we need every 0.01% speedup we can get""), you will have to benchmark cause it really depends on the compiler which sequence will end up in the fastest code (1 may have unnecessary copys, 2 may contain superflous loads due to pointer aliasing restrictions, 3 may lead to superflous loads if the register allocator is really messed up)</p>
",0
2322256,2321590,0,"<p>To me it depends on What You'll Be Doing with your buffer,</p>

<p>All things being equal though, I'd probably prefer to have the buffer be a struct (assume alignment warings) and, failing that, to directly index the buffer, although not with magic numbers.</p>
",0
2322162,2321590,1,"<p>If it were me I'd write this as #3 but with symbolic names for the array indices to improve readability:-</p>

<pre><code>#define DEVICE_ADDRESS 2
#define REGISTER_ADDRESS 3
#define NUM_BYTES 4

if (cmd[NUM_BYTES] &lt;= 0xFF) {
    do_stuff(cmd[DEVICE_ADDRESS], cmd[REGISTER_ADDRESS], cmd[NUM_BYTES]);
}
</code></pre>

<p>You can of course replace the macros with const ints, enums, etc. The reason why I like this option is that the other two options require the use of additional local variables. The compiler may or may not optimize these away depending on its implementation and your chosen level of optimization but they just seem like an unnecessary level of extra indirection to me.</p>
",0
2376946,2376858,1,"<p>Yes, you're looking for reading a binary file in C. 
Something like this:</p>

<pre><code>FILE* f;
char buf[MAX_FILE_SIZE];
int n;

f = fopen(""filename.bin"", ""rb"");
if (f)
{
    n = fread(buf, sizeof(char), MAX_FILE_SIZE, f);
}
else
{
    // error opening file
}
</code></pre>

<p>This reads a buffer of <em>bytes</em>. From it you can build your data. Reading multi-byte data directly is more tricky because you run into issues of representation and endianness.</p>

<p>Two key C functions are used:</p>

<ul>
<li><code>fopen</code> that opens a file in binary mode (the ""rb"" flag)</li>
<li><code>fread</code> that reads block data (useful for binary streams). Documented <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fread/"" rel=""nofollow noreferrer"">here</a>.</li>
</ul>
",2
2376960,2376858,1,"<p>If you want to process the sound samples, you would be best to use a library that interprets the sound data for you. For example <a href=""http://www.mega-nerd.com/libsndfile/"" rel=""nofollow noreferrer"">libsndfile</a>.</p>
",0
2376963,2376858,1,"<p>The best way IMHO would be to use a linked list with elements holding a large(1024 or more) fixed size char arrays.</p>
",0
3296598,3296535,0,"<p>I guess you ask why this function is better than directly computing <code>log(a+b)</code> by restoring <code>a</code> and <code>b</code>, summing them and computing <code>log()</code>:</p>

<pre><code> log( exp( log_a ) + exp( log_b ) )
</code></pre>

<p>In that case you need to compute exponent twice, and in the function you ask about exponent is computed only once. Since computing exponent is relatively time consuming that might be faster.</p>
",0
3296599,3296535,2,"<p>If you mean as opposed to <code>log(exp(log_a) + exp(log_b))</code>, then the benefit is pretty clear; the way you mention only has to calculate one log and one exp, while this way has to calculate two exps. That is far more costly than an extra addition/subtraction/if test.</p>
",0
3296603,3296535,2,"<p>Not really an answer, but a possible clue.</p>

<p>Numbers kept in ""log form"" can be multiplied or divided by simply adding or subtracting the numbers.  For example, <code>exp(log(a) + log(b))</code> is the same as <code>a * b</code>.  Or, using a = 41, b = 101, this would be <code>exp(3.71357 + 4.61512)</code>, which is <code>exp(8.32869)</code>, or <code>4140.98930</code>.  Obviously precision plays a part, and I truncated the numbers to 5 digits.  <code>41 * 101</code> is <code>4141</code>.</p>

<p>I haven't worked through your example code, nor is it immediately obvious to me why your code does things the way it does, but hopefully the above will be able to help you piece it together.</p>

<p><strong>EDIT:</strong> I ran some numbers through your example code.  If a = 41 and b = 101, and log_a = 3.71357 and log_b = 4.61512, then your example code computes <code>4.95582</code>, and <code>exp(4.95582)</code> is equal to <code>142.0</code>.  The ""simpler"" way to get this same result is <code>log(exp(log_a) + exp(log_b))</code>, but as others have pointed out, this way involves three expensive transcendental functions, whereas your example code requires only two (plus a trivial comparison).</p>
",0
3296605,3296535,7,"<p>The primary (brute force) alternative looks like:</p>

<pre><code>v = log(exp(log_a) + exp(log_b));
</code></pre>

<p>That has three transcendental function evaluations.</p>

<p>The computation shown uses just two transcendental functions - and should be quicker.</p>

<p>It may also be more stable numerically.</p>
",0
3296630,3296535,0,"<p>Others have posted good answers for why to do this at all. I'm wondering about the if/else part. Regardless of whether <code>log_a</code> or <code>log_b</code> is bigger, both expressions for <code>v</code> should be equivalent to <code>log(a+b)</code>. In each case <code>0 &lt; exp( ... ) &lt;= 1</code>, and <code>log(1+exp( ... ))</code> is a small positive number. For some reason I don't know this must be good.</p>
",0
3296688,3296535,5,"<p>Computers and logs don't always get along.  As has been alluded to by others, accuracy becomes a real problem.  <a href=""http://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/"" rel=""nofollow noreferrer"">This blog post</a> goes a long way toward explaining this phenomenon.  The article is about seemingly unnecessary library functions, and why they are actually very handy.</p>

<blockquote>
  <p>The function log1p computes log(1 + x).  How hard could this be to implement?</p>
</blockquote>

<p>There are all sorts of crazy rules and transforms you can use when dealing with logs/exponentials.  What I'm guessing is that the author used some of these rules to either make the calculation more accurate, more efficient, or both.  </p>
",1
3298471,3296535,0,"<p>If you're asking about the if/else, it's to avoid loss of precision. All arithmetic operations on floating point numbers (except for multiplication by powers of 2 and certain cases of addition/subtraction of numbers of the same exponent) destroy information, and good floating point code will choose the method with the least loss of precision.</p>
",0
3301186,3296535,3,"<p>Others have already mentioned the potential loss of precision, but in this case the problem is really <em>overflows</em>. Try this:</p>

<pre><code>double log_a = 100;
double log_b = 1000;
printf(""%f\n"", log_b+log(1+exp(log_a-log_b)));
printf(""%f\n"", log_a+log(1+exp(log_b-log_a)));
</code></pre>

<p>On a typical platform, the first one will print ""inf"" while the second one will print ""1000.000000"".</p>
",0
4151793,283205,1,"<p>This is a famous historical example (not something I did), but </p>

<pre><code>double d;      // d gets populated with a large number from somewhere
short s = d ;  // overflow
</code></pre>

<p><a href=""http://www.ima.umn.edu/~arnold/disasters/ariane.html"" rel=""nofollow"">led to</a> <a href=""http://www.youtube.com/watch?v=kYUrqdUyEpI"" rel=""nofollow"">the explosion and total loss</a> of <a href=""http://en.wikipedia.org/wiki/Ariane_5_Flight_501"" rel=""nofollow"">an Ariane V rocket</a>.</p>
",0
2094763,2094739,5,"<p>Why not do something like this?</p>

<pre><code>#if defined ( __linux__ )
    #define FUNC_REF __func__
#elif ( WIN32 )
    #define FUNC_REF __FUNCTION__
#endif

log_msg(stderr, ""Socket failed [ %s ] [ %s ] [ %d ]\n"",
    strerror(errno), FUNC_REF, __LINE__);
</code></pre>

<p>edit: you could of course avoid using a new constant by defining one to be the other (ie <code>#define __func__ __FUNCTION__</code> for the <code>WIN32</code> condition.)</p>
",2
2094774,2094739,5,"<p>Instead of doing this solution, I would use the recomended work around suggested by the GCC compiler.  Essentially define the following macro and use <code>__func__</code> everywhere</p>

<pre><code> #if __STDC_VERSION__ &lt; 199901L
 # if __GNUC__ &gt;= 2
 #  define __func__ __FUNCTION__
 # else
 #  define __func__ ""&lt;unknown&gt;""
 # endif
 #endif
</code></pre>

<p>Reference: <a href=""http://gcc.gnu.org/onlinedocs/gcc-3.4.0/gcc/Function-Names.html"" rel=""nofollow noreferrer"">http://gcc.gnu.org/onlinedocs/gcc-3.4.0/gcc/Function-Names.html</a></p>
",0
8373469,8369854,1,"<p>@MarkByers is right, but I'd make some more changes.  I'd:</p>

<ol>
<li>change <code>char *result;</code> to <code>char *result = NULL;</code>.</li>
<li>change <code>int length = (result) ? strlen(result) : 1;</code> to <code>int length = (result) ? strlen(result) : 0;</code>.</li>
<li>change <code>char* tmp = (char*)realloc(result, sizeof(char) * (strlen(s) + length - 1));</code> to <code>char* tmp = (char*)realloc(result, sizeof(char) * (strlen(s) + length + 1));</code>.</li>
<li>change <code>memcpy(&amp;(result[length-1]), s, strlen(s));</code> to <code>strcpy(result + length, s);</code>.</li>
<li>add <code>free(result);</code> before calling <code>throw_error</code> assuming that that exits the function (as throwing an exception would in C++).</li>
</ol>

<p>Reasons:</p>

<ol>
<li>Ensures that <code>result</code> is initialized so that the <code>realloc</code> call won't do something strange like try to extend or <code>free</code> random memory.</li>
<li>Ensures that <code>length</code> always gives the current <code>strlen</code> of the string stored in <code>result</code>.</li>
<li>Allocates enough space to store the original <code>length</code> characters in <code>result</code>, the new <code>strlen(s)</code> characters in <code>s</code>, and the terminating <code>NULL</code> byte.</li>
<li>Copies the string (even including the terminating <code>NULL</code> byte) without having to compute <code>strlen(s)</code> again.  We just need to skip the <code>length</code> string characters that were already stored.</li>
<li>Ensures that a problem with the <code>realloc</code> call won't leak the already-allocated memory.</li>
</ol>
",1
6881976,6881952,1,"<p>If you can't change the order, I would join them into the same struct as a union:</p>

<pre><code>struct type12 { union { struct type1 type1; struct type2 type2; } types; int type; };

void foo(struct type12 *data)
{
    if (data-&gt;type == 1)
         data-&gt;types.type1.c = 5
    else
         data-&gt;types.type2.c = 5;
}
</code></pre>

<p>Perhaps not a big improvement, but you can avoid the type casts...</p>
",2
6881986,6881952,0,"<p>Move the shared members into a seperate struct, and use that as the first member of the two types. This has the advantage that you don't have to test types (or even care about them) in order to read/write the shared data.</p>

<pre><code>#include &lt;stdio.h&gt;      
struct shared_data {
  int a;
  int c;
};
struct type1 {
  struct shared_data shared;
  char b[2];
};
struct type2 {
  struct shared_data shared;
  char b[4];
};

void foo(void *data)
{
     ((struct shared_data*)(data))-&gt;c = 5;
}    

int main(int argc, char** argv) {
    struct type1 a;
    struct type2 b;

    foo(&amp;a);
    foo(&amp;b);

    printf(""A: %d\nB: %d\n"", a.shared.c, b.shared.c);
}
</code></pre>

<p>Outputs </p>

<pre><code>A: 5
B: 5
</code></pre>
",3
4535578,4535570,11,"<p>Remove the semicolon from your INVALID_VALUE definition.</p>

<p>Macros are replaced lexically (character-by-character) with no understanding of the syntax around them.  Your macro INVALID_VALUE is set to <code>-999;</code>, so your if line expands the macro to:</p>

<pre><code>if (test==-999;)
</code></pre>

<p>which is invalid C syntax.</p>
",0
4535580,4535570,2,"<p>The semi colon at the end of </p>

<pre><code>#define INVALID_VALUE -999;
</code></pre>

<p>Classic.</p>
",0
4535581,4535570,6,"<p>You need to remove the <code>;</code> in <code>#define INVALID_VALUE -999;</code>. See <a href=""http://ideone.com/pnWam"" rel=""nofollow"">the fixed code</a>.</p>

<p>You could have worked towards this conclusion by understanding what the error message <code>expected ¡®)¡¯ before ¡®;¡¯ token</code> was telling you. It's telling you that it expected to find a <code>)</code> before the <code>;</code> token, but from inspecting the line alone you don't see a <code>;</code>. So maybe there's one in the definition of <code>INVALID_VALUE</code>? Look up at <code>#define INVALID_VALUE -999;</code> and there it is! Think it should be there, but not sure? So let's try remove it and see if it works. Success!</p>

<p><a href=""https://www.securecoding.cert.org/confluence/display/seccode/PRE11-C.+Do+not+conclude+macro+definitions+with+a+semicolon"" rel=""nofollow"">This page</a> goes and explains why you shouldn't conclude a <code>#define</code> with a semicolon, even if it is needed in the use of the macro. It's good to learn as much as possible from your mistake so that you don't make it again. Quote:</p>

<blockquote>
  <p>Macro definitions, regardless of
  whether they expand to a single or
  multiple statements should not
  conclude with a semicolon. If
  required, the semicolon should be
  included following the macro
  expansion. Inadvertently inserting a
  semicolon at the end of the macro
  definition can unexpectedly change the
  control flow of the program.</p>
  
  <p>Another way to avoid this problem is
  to prefer inline or static functions
  over function-like macros.</p>
  
  <p>In general, the programmer should
  ensure that there is no semicolon at
  the end of a macro definition. The
  responsibility for having a semicolon
  where needed during the use of such a
  macro should be delegated to the
  person invoking the macro.</p>
</blockquote>
",0
4535585,4535570,2,"<p>You do not need a semicolon after defining something. #define is actually a macro, and it will do an inline expansion on compile.</p>

<p>Thus,</p>

<pre><code>#define IDENTIFIER 10;
int j = IDENTIFIER;
</code></pre>

<p>will expand as:</p>

<pre><code>int j = 10;;
</code></pre>
",0
4535586,4535570,2,"<p>Change macro </p>

<p>from:</p>

<pre><code>#define INVALID_VALUE -999;
</code></pre>

<p>to</p>

<pre><code>#define INVALID_VALUE -999
</code></pre>

<p>Bye</p>
",0
4535612,4535570,3,"<h3>The C Preprocessor Macro Language is Distinct from C</h3>

<hr>

<p>The <strong><em>;</em></strong> in the macro definition should be removed.</p>

<p>This is an understandable mistake. If C were designed today, the macro language might be more integrated with the rest of C.</p>

<p>But on 16-bit machines in the early 1970's when C was invented, it was unwise to write an overly complicated program. It would end up useless as there would be no memory remaining to actually <em>run</em> the big masterpiece program, and even simple programs ran slowly.</p>

<p>So C was split into a rather simple macro preprocessor that was, originally, a completely separate program, and the compiler proper.  The preprocessor program made no attempt to parse C beyond understanding the lexical analysis model.</p>

<p>When 32-bit machines took over, the preprocessor was typically integrated into the parser, but naturally the language needed to remain the same.</p>
",0
2911193,2911089,7,"<p>'\0' is the way to go. It's a character, which is what's wanted in a string and has the null value.</p>

<p>When we say null terminated string in C/C++, it really means 'zero terminated string'. The NULL macro isn't intended for use in terminating strings.</p>
",4
2911196,2911089,41,"<p>To your first question:
I would go with Paul R's comment and terminate with <code>'\0'</code>. But the value <code>0</code> itself works also fine. A matter of taste. But don't use the MACRO <code>NULL</code>which is meant for pointers.</p>

<p>To your second question:
If your string is not terminated with<code>\0</code>, it might still print the expected output because following your string is a non-printable character in your memory. This is a really nasty bug though, since it might blow up when you might not expect it. <strong>Always</strong> terminate a string with <code>'\0'</code>.</p>
",0
2911251,2911089,14,"<p>Be <strong>very</strong> careful: NULL is a macro used mainly for pointers. The <em>standard</em> way of terminating a string is:</p>

<pre><code>char *buffer;
...
buffer[end_position] = '\0';
</code></pre>

<p>This (below) works also but it is not a big difference between assigning an integer value to a int/short/long array and assigning a character value. This is why the first version is preferred and personally I like it better.</p>

<pre><code>buffer[end_position] = 0; 
</code></pre>
",1
2911263,2911089,19,"<p>From the comp.lang.c FAQ: <a href=""http://c-faq.com/null/varieties.html"" rel=""noreferrer"">http://c-faq.com/null/varieties.html</a></p>

<p>In essence: <code>NULL</code> (the preprocessor macro for the null pointer) is not the same as <code>NUL</code> (the null character).</p>
",1
7677447,7677406,10,"<p>The syntax is somewhat funny.</p>

<pre><code>int foo(int a, int b) []
{
    ...
}
</code></pre>

<p>But it's not allowed anyway.  See n1256 6.7.5.3 paragraph 1, ""Function declarators"".</p>

<blockquote>
  <p>A function declarator shall not specify a return type that is a function type or an array type.</p>
</blockquote>

<p>You can return pointers to arrays:</p>

<pre><code>int (*foo(int a, int b)) []; // Weird syntax, n'est-ce pas?
</code></pre>

<p>But you might as well just return a pointer instead, since the following are equivalent:</p>

<pre><code>int array[] = { ... };
int *x = array, (*y)[] = &amp;array;
x[0];
(*y)[0]; // same as above, just with more cumbersome syntax
</code></pre>

<p>Typically, if a function needs to return an array of <code>int</code>, you either return the pointer or pass the pointer in.  One of the following:</p>

<pre><code>int *func(int a, int b); // Allocated by func
void func(int a, int b, int *array); // Allocated by caller
void func(int a, int b, int **array); // Allocated by func
</code></pre>

<p>The ""struct-hack"" also works for arrays that have a fixed size:</p>

<pre><code>struct { int arr[50]; } array_struct;
struct array_struct func(int a, int b);
</code></pre>

<p>But this is not recommended unless the array is small.</p>

<p><strong>Rationale:</strong></p>

<p>Arrays are often large, and often have a size not known until runtime.  Since parameters and return values are passed using the stack and registers (on all ABIs I know of), and the stack has a fixed size, it is somewhat dangerous to pass such a large object around on the stack.  Some ABIs also don't gracefully handle large return values, potentially causing extra copies of return values to be generated.</p>

<p>The following code can also be dangerous:</p>

<pre><code>void func(...)
{
    int arr[BIG_NUMBER]; // potential for stack overflow
    int *ptr = alloca(sizeof(int) * BIG_NUMBER); // potential for stack overflow
}
</code></pre>
",3
7677455,7677406,4,"<p>In C passing arrays by value is not directly supported (even when you write <code>int []</code> as a parameter is actually interpreted as <code>int *</code>), if I remember correctly it's some sort of artifact of the passage from BCPL to C.</p>

<p>That being said, you can actually return arrays encapsulating them into <code>struct</code>s:</p>

<pre><code>struct
{
    int value[20]
} foo(int a, int b)
{
    /* ... */
}
</code></pre>

<p>(this trick obviously works also for parameters)</p>
",0
7677570,7677406,0,"<p>First, recall that arrays in C are really just syntactic sugar around pointers to blocks of memory. So C isn't restricting the functionality of the language by forcing the use of the former notation (See the example which follows).</p>

<p>Also, they may have made this choice to prevent early programmers from writing code like this:</p>

<pre><code>char *itoa(int n){
    char retbuf[25];
    sprintf(retbuf, ""%d"", n);
    return retbuf;
}
</code></pre>

<p><a href=""http://c-faq.com/~scs/cclass/int/sx5.html"" rel=""nofollow"">ref</a></p>

<p>Which looks simple enough, but what happens to the memory <code>retbuf</code> points to at the end of the function? Can the calling functions trust the data in the pointer it gets back?</p>
",0
2036810,2036756,0,"<ol>
<li>Semantically correct<br/></li>
<li>It <b>IS</b> an array of pointers, so you have to allocate pointer-sized elements, and size of pointer is <code>sizeof(void*)</code> which is equal to <code>sizeof(man*)</code><br/></li>
<li><code>man ***men;</code></li>
<li>Yes, it is. Should be <code>man **men[10];</code></li>
</ol>
",0
2036889,2036756,1,"<ul>
<li>2: These are two examples that do the same thing: <code>sizeof(*men6) == sizeof(man*)</code>!</li>
<li>3: Same as the men5 example, but multidimensional.</li>
<li>4: The men4 example is not quite correct. As far as I understand what it should mean, that example must read:</li>
</ul>

<hr>

<pre><code>man ***men4; // 10x10 multidimensional
men4 = malloc(10 * sizeof(man**));
for (i = 0; i &lt; 10; i++)
{
    men4[i] = malloc(10 * sizeof(man*));
    for(j = 0; j &lt; 10; ++j)
        men4[i][j] = malloc(sizeof(man));
}    
strcpy(men4[3][3]-&gt;name, ""john"");
printf(""*** %s ***\n"", men4[3][3]-&gt;name);
</code></pre>
",0
2037552,2036756,1,"<p>First, your these two cases</p>

<pre><code>// dynamic multidimensional array of structures
man **men4;
men4 = malloc(10 * sizeof(man*));
for (i = 0; i &lt; 10; i++)
    men4[i] = malloc(10 * sizeof(man*));
</code></pre>

<p>and</p>

<pre><code>// dynamic array of pointers to structure
man **men6;
men6 = malloc(10 * sizeof(*men6));
men6[3] = &amp;john;
printf(""*** %s ***\n"", men6[3]-&gt;name);
</code></pre>

<p>are conceptually the same.  In both cases, you have a pointer to a pointer to <code>man</code>.  You are using those pointers differently.  Also, the first one has an error. Instead of:</p>

<pre><code>    men4[i] = malloc(10 * sizeof(man*));
</code></pre>

<p>you should have written:</p>

<pre><code>    men4[i] = malloc(10 * sizeof(man));
</code></pre>

<p>because each <code>men4[i]</code> is of type ""pointer to <code>man</code>"".  That error is why I usually prefer my <code>malloc()</code> calls to be of the form:</p>

<pre><code>a = malloc(N * sizeof *a);
</code></pre>

<p>So, your call would have become:</p>

<pre><code>men4[i] = malloc(10 * sizeof *men4[i]);
</code></pre>

<p>This is less error-prone.</p>

<p>So, the answer to your question (2) is, you should have use <code>sizeof(man *)</code> only when allocating for <code>men4</code>, but not inside the loop.  (Or, you now know a better way to call <code>malloc()</code>, so the call outsize the loop becomes <code>men4 = malloc(10 * sizeof *men4);</code>.)</p>

<ol>
<li>It is all correct, except for the <code>malloc()</code> call as mentioned above.</li>
<li>See above.</li>
<li>You want an array of pointers to struct.  To get an array, you need <code>[]</code>, since it is a pointer to a pointer that you want (multidimensional), you want two <code>**</code>.  So you get: <code>man **(men7[10]);</code>, but since <code>[]</code> binds more tightly than <code>*</code> anyway, you can write it as <code>man **men7[10];</code>.</li>
<li><code>men4</code> is not a multidimensional array nor an array of pointers.  It is a pointer to a pointer to <code>man</code>.  When you allocate memory for <code>men4</code>, you allocate space for 10 pointers to <code>man</code>.  Then, each pointer is allocated space for 10 <code>man</code>.  The fact that you can index <code>men4</code> as a multidimensional array is a result of such allocation.  In your loop, each <code>men4[i]</code> could have been allocated space for different number of <code>man</code> values if you would have liked, something which is impossible to do with multidimensional arrays.</li>
</ol>

<p>Pointers are not arrays.  Arrays are not pointers.  Please read all the questions and answers in <a href=""http://c-faq.com/aryptr/index.html"" rel=""nofollow noreferrer"">section 6 of the C FAQ</a> for details.</p>
",0
5559027,5558994,20,"<p>There is no benefit in user code, it's just ugly. In the second example, the <code>HuffCode_</code> isn't even necessary since the <code>struct</code> type is already named by the <code>typedef</code>.</p>

<p>The only places where this can be useful are:</p>

<ol>
<li>When <code>StructName</code> is already in use, <code>StructName_</code> gives a different name (but you should really come up with a better name).</li>
<li>Identifiers in the C standard library that are not defined by the standard shouldn't conflict with user code identifiers. Therefore, C library writers use the <code>_</code> prefix in the hopes that users will not use that. Unfortunately, some users do.</li>
<li>In very old compilers, it may be useful to give the <code>struct</code> a different name than is used in the <code>typedef</code>. You need both the <code>typedef</code> and the other name if you're building a linked structure (<a href=""https://stackoverflow.com/questions/4698600/whats-the-syntactically-proper-way-to-declare-a-c-struct/4698618#4698618"">example</a>).</li>
</ol>
",1
5559030,5558994,2,"<p>I use a variant of the second example:</p>

<pre><code>typedef struct huffcode {
... } HuffCode;
</code></pre>
",0
5559054,5558994,7,"<p>A lot of the time in straight C, people like to typedef their structs so that they don't look so ugly. So they name the struct itself something ugly, and the typedef something clean. Usually the convention I've seen in the GNU world is:</p>

<pre><code>typedef struct mytype_t
{
    int field;
    char field2;
} mytype;
</code></pre>
",3
4008479,4008472,2,"<p>Go to <code>Project -&gt; Edit Active Executable</code> and add your arguments on the <code>Arguments</code> tab.</p>
",0
4169289,4169263,5,"<p>No - <code>freopen()</code> is not redundant.  It lets you open a file as standard input, for example, which otherwise you could not rely on achieving.</p>

<p>If you have to call a function (for which you don't have the source code, so you can't fix it) that reads on a particular file stream (typically standard input) or writes on a particular file stream (typically standard output) but you don't want the function to read from or write to the file that is connected there in your program, then you can use <code>freopen()</code> to fix things so that the function sees what it expects but gets the information from where you want - or writes it where you want.</p>
",3
4169697,4169263,6,"<p>According to <a href=""http://www.opengroup.org/onlinepubs/9699919799/functions/freopen.html"" rel=""noreferrer"">POSIX</a> (see application usage section), <code>freopen</code> was originally added to C to facilitate changing <code>stdin</code> and <code>stdout</code> to binary mode. I suspect if you dig through the ANSI/ISO rationale documents you can find support for that statement. As POSIX documents, this usage is pointless on POSIX systems (where text and binary mode are required to behave identically) and actually harmful due to a bug in the specification which leads to file truncation if followed strictly.</p>

<p>As for practical uses, here are some I can think of:</p>

<ul>
<li>replacing <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> before executing external programs - but it's not clear to me whether POSIX requires <code>freopen</code> to reuse the same file descriptor number as the original <code>FILE</code> had or not, so I'm not sure this is guaranteed to work. I always simply use <code>open</code> and <code>dup2</code> for this purpose.</li>
<li>a logging library that takes a <code>FILE *</code> from the caller might use <code>freopen</code> to put it in append mode to ensure all data is written at the end even if another program writes to the log file.</li>
<li>if you've already passed around and stored <code>FILE *</code> pointers to a number of components in your program and you find yourself later needing to support swapping out the file (for instance, log rotation comes to mind), <code>freopen</code> is a lot easier than tracking down everywhere the <code>FILE *</code> was stored and hacking in code to update every instance or wrapping the <code>FILE *</code> in your own structure that lets you swap it out.</li>
</ul>

<p>The usefulness of all these is limited by the bad behavior or <code>freopen</code> on failure; the <code>FILE *</code> becomes invalid and unrecoverable, so if any part of the program might still be using it, you have to find a way to prevent further access or immediately <code>exit</code>. Similarly, <code>freopen</code> is not thread-safe for the same reason; should it fail, accessing the file from any other thread results in undefined behavior.</p>
",1
2434424,2404962,2,"<p>The question you are asking is an <em>aesthetic</em> one. The things one person considers ""good"" or ""beautiful"" or ""moderately interesting"" vary so widely from person to person that I don't think a best answer for this can be found.</p>

<p>I know many people who would find the picture you have posted in your question to be disgusting and without merit, riddled with the ideas of the socio-political straitjacket that is city-planning.  However, <em>I</em> think it looks interesting.</p>
",3
2434361,2404962,0,"<p>In the spirit of totally shattering my own (admittedly arbitrary rules, I've gone right ahead and created an answer myself!</p>

<p>The code uses some very simple bezier curve code I threw together last night, and while the answer is less that compellingly interesting, it's still a bit fun. The code for the beziers can be found <a href=""http://totlandweb.info/bezier.h"" rel=""nofollow noreferrer"">here</a> and <a href=""http://totlandweb.info/bezier.c"" rel=""nofollow noreferrer"">here</a>.</p>

<p>In addition to editing the snip field, I also added, of course, </p>

<pre><code>#include ""bezier.h""
</code></pre>

<p>It doesn't work very well without this line. ;)</p>

<pre><code>/// NO EDITING ABOVE THIS LINE; EXCEPT AS NOTED

Bezier *path = newBezier(newPoint(rand() % width,rand() % height), newPoint(rand() % width,rand() % height), newPoint(rand() % width,rand() % height), newPoint(rand() % width,rand() % height));

float t;
Point *point = NULL;

for (t = 0.0; t &lt;= 1.0; t += 0.00000006) {
  point = bezierPoint(path, t, point);

  int32_t x = point-&gt;x, y = point-&gt;y;

  if (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height)
    imageBuffer[y][x] = 255;
}

destroyPoint(point);

/// NO EDITING BELOW THIS LINE
</code></pre>
",0
7483682,810129,3,"<p><em>The C Programming Language</em> (K&amp;R) by Brian W. Kernighan and Dennis M. Ritchie gives a detailed explanation of this.</p>

<p>Second Edition, Page 104:</p>

<blockquote>
  <p>5.5 Character Pointers and Functions</p>
  
  <p>A <em>string constant</em>, written as</p>

<pre><code>""I am a string""
</code></pre>
  
  <p>is an array of characters. In the internal representation, the array is terminated with the null character <code>'\0'</code> so that programs can find the end. The length in storage is thus one more than the number of characters between the double quotes.</p>
  
  <p>Perhaps the most common occurrence of string constants is as arguments to functions, as in</p>

<pre><code>printf(""hello, world\n"");
</code></pre>
  
  <p>Where a character string like this appears in a program, access to it is through a character pointer; <code>printf</code> receives a pointer to the beginning of the character array. That is, a string constant is accessed by a pointer to its first element.</p>
  
  <p>String constants need not be functions arguments. If <code>pmessage</code> is declared as </p>

<pre><code>char *pmessage;
</code></pre>
  
  <p>then the statement</p>

<pre><code>pmessage = ""now is the time"";
</code></pre>
  
  <p>assigns to <code>pmessage</code> a pointer to the character array. This is <em>not</em> a string copy; only pointers are involved. C does not provide any operators for processing an entire string of characters as a unit.</p>
  
  <p>There is an important different between these definitions:</p>

<pre><code>char amessage[] = ""now is the time""; /* an array */
char *pmessage = ""now is the time""; /* a pointer */
</code></pre>
  
  <p><code>amessage</code> is an array, just big enough to hold the sequence of characters and <code>'\0'</code> that initializes it. Individual characters within the array may be changed by <code>amessage</code> will always refer to the same storage. On the other hand, <code>pmessage</code> is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string contents.</p>

<pre><code>          +---+       +--------------------+
pmessage: | o--------&gt;| now is the time \0 |
          +---+       +--------------------+

          +--------------------+
amessage: | now is the time \0 |
          +--------------------+
</code></pre>
  
  <p>We will illustrate more aspects of pointers and arrays by studying versions of two useful functions adapted from the standard library. The first function is <code>strcpy(s,t)</code>, which copies the string <code>t</code> to the string <code>s</code>. It would be nice just to say <code>s = t</code> but this copies the pointer, not the characters.To copy the characters, we need a loop. The array version is first:</p>

<pre><code>/* strcpy: copy t to s; array subscript version */
void strcpy(char *s, char *t)
{
    int i;

    i = 0;
    while((s[i] = t[i]) != '\0')
        i ++;
}
</code></pre>
  
  <p>For contrast, here is a version of <code>strcpy</code> with pointers:</p>

<pre><code>/* strcpy: copy t to s; pointer version 1 */
void strcpy(char *s, char *t)
{
    while((*s = *t) != '\0')
    {
        s ++;
        t ++;
    }
}
</code></pre>
  
  <p>Because arguments are passed by value, <code>strcpy</code> can use the parameters <code>s</code> and <code>t</code> in any way it pleases. Here they are conveniently initialized pointers, which are marched along the arrays a character at a time, until the <code>'\0'</code> that terminates <code>t</code> has been copied to <code>s</code>.</p>
  
  <p>In practice, <code>strcpy</code> would not be written as we showed it above. Experienced C programmers would prefer</p>

<pre><code>/* strcpy: copy t to s; pointer version 2 */
void strcpy(char *s, char *t)
{
    while((*s++ = *t++) != '\0')
        ;
}
</code></pre>
  
  <p>This moves the increment of <code>s</code> and <code>t</code> into the test part of the loop. The value of <code>*t++</code> is the character that <code>t</code> pointed to before <code>t</code> was incremented; the postfix <code>++</code> doesn't change <code>t</code> until  after this character has been fetched. In the same way, the character is stored into the old <code>s</code> position before <code>s</code> is incremented. This character is also the value that is compared against <code>'\0'</code> to control the loop. The net effect is that characters are copied from <code>t</code> to <code>s</code>, up to and including the terminating <code>'\0'</code>.</p>
  
  <p>As the final abbreviation, observe that a comparison against <code>'\0'</code> is redundant, since the question is merely whether the expression is zero. So the function would likely be written as</p>

<pre><code>/* strcpy: cope t to s; pointer version 3 */
void strcpy(char *s, char *t)
{
    while(*s++ = *t++);
}
</code></pre>
  
  <p>Although this may seem cryptic as first sight, the notational convenience is considerable, and the idiom should be mastered, because you will see if frequently in C programs.</p>
  
  <p>The <code>strcpy</code> in the standard library (<code>&lt;string.h&gt;</code>) returns the target string as its function value.</p>
</blockquote>

<p>This is the end of the relevant parts of this section.</p>

<p>PS: If you enjoyed reading this, consider buying a copy of K&amp;R - it is not expensive.</p>
",0
7484818,810129,16,"<pre><code>while(*s++ = *t++);
</code></pre>

<p>Why do people think it is equivalent to:</p>

<pre><code>while (*t) {
    *s = *t;
    s++;
    t++;
}
*s = *t; /* if *t was 0 at the beginning s and t are not incremented  */
</code></pre>

<p>when it obviously isn't.</p>

<pre><code>char tmp = 0;
do {
   tmp = *t;
   *s = tmp;
   s++;
   t++;
} while(tmp);
</code></pre>

<p>is more like it</p>

<p><strong>EDIT:</strong> Corrected a compilation error. The <code>tmp</code> variable must be declared outside of the loop.</p>
",7
2046291,2046278,2,"<p>You're starting with uninitialized memory. </p>

<pre><code>man memset
</code></pre>
",0
2046297,2046278,4,"<p>You have not initialized the lexicographical_values array. You can initialize it by doing:</p>

<pre><code>int lexicographical_values[20] = {};
</code></pre>

<p>Every time you see <em>big numbers</em> in the output, check for uninitialized variables.</p>
",4
2046356,2046278,0,"<p>You have not initialized the char_array with anything, so most likely it has garbage (depends on compiler options and platforms) so, you do a <code>strlen(char_array)</code> and at this point we're not sure what we're going to get out of it. If you initialize it with 0s (like: <code>char char_array[100] = {0};</code> then <code>strlen</code> will return 0 and you'll never enter the loop.</p>

<p>Maybe you're looking for <code>sizeof()</code> here?</p>

<p>Oh, yes, forgot to mention that you need to initialize the second array also as was already pointed out.</p>
",0
3866474,3866446,10,"<p>Have you tried the standard library? It should be implemented on any system that has an ISO compliant C runtime.</p>
",0
3866665,3866446,1,"<p>For anything not found in the standard library, GLib is a good first place to look along with other libraries built to interact with it. It offers for example threads, mutexes and IPC that you won't be able to write portably using plain standard libraries, and you can use many more GNU libraries that follow the same conventions up to a full GUI in GTK+. GLib supports the usual popular operating systems.</p>
",0
3867582,3866446,4,"<p>Yes; the <em>ISO Standard C library</em>.  It may not cover all the functionality you want, but that is exactly because it <em>is</em> generic, and as such is also <em>lowest common denominator</em>.  It only supports features that can reasonably be expected to exist on <em>most</em> hardware, including embedded systems.</p>

<p>The way to approach this is perhaps to specify the range of target platforms you need to support, and then the application domains (e.g. GUI, networking, multi-threading, image processing, file handling etc.), and then select the individual cross-platform libraries that suit your needs.  There is probably no one library to fulfil all your needs, and in some cases no common library at all.</p>

<p>That said, you will always be better served in this respect by embracing C++ where you can use any C library as well as C++ libraries.  Not only is the C++ standard library larger, but libraries such as Boost, wxWidgets, ACE cover a broader domain spectrum too.  Another approach is to use a cross-platform language such as Java, which solves the problem by abstracting the hardware to a virtual machine.  Similarly .NET/Mono and C# may provide a solution for suitably limited set of target platforms.</p>

<p><strong>Added following comment:</strong>
Hardware abstraction in a real-machine targeted language (as opposed to a VM language such as Java or CLR based languages) is provided by the operating system, so what you perhaps need is a common operating system API.  POSIX is probably the closest you will get to that, being supported on Linux, Unix, OSX (which is Unix), QNX, VxWorks, BeOS and many others; but not importantly Windows.  One way of using POSIX on Windows is to use Cygwin. Another is to use a VM to host a POSIX OS such as Linux.</p>
",1
3868547,3866446,0,"<p>If the C standard library is not sufficient for your needs, a minimal hyperportable subset of POSIX might be the target you want to code to. For example, the main non-POSIX operating system Windows still has a number of functions with the same names as POSIX functions which behave reasonably closely - <code>open</code>, <code>read</code>, <code>write</code>, etc.</p>

<p>Documenting what exactly a ""hyperportable subset of POSIX"" includes, and which non-POSIX operating systems would conform to such a subset, is a moderately difficult task, which would be quite useful in and of itself for the sake of avoiding the plague of ""<em>MyCompanyName</em> portable runtime"" products which appear again and again every few years and unnecessarily bloat popular software like Firefox and Apache.</p>
",0
4527110,4527081,8,"<p><code>0L</code> is an integral constant expression with the value of zero.  When used as a pointer, such a constant expression is a null pointer constant.  That's exactly what the sentence you cite says (C99 6.3.2.3/3):</p>

<blockquote>
  <p>An integer constant expression with the value <code>0</code>, or such an expression cast to type <code>void *</code>, is called a null pointer constant.</p>
</blockquote>

<p>This is followed immediately by a statement that a null pointer constant can be converted to a null pointer:</p>

<blockquote>
  <p>If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.</p>
</blockquote>

<p>Why do you think that <code>0</code> is not usable as a null pointer constant?</p>
",2
4527128,4527081,-3,"<p>You can set all builtin POD types to the literal constant 0 without casting.</p>
",2
4527172,4527081,2,"<p>Absolutely <em>any</em> integral constant expression with zero value will be treated by the compiler as a null-pointer constant. <code>0L</code> is a perfectly valid null-pointer constant, so the code is absolutely valid.</p>
",0
7188967,7188919,2,"<p>The issue is that it's promoted to an int <strike>when you pass it into printf's varags</strike> - as in Dietrich's answer - when you negate it.</p>

<p>Unfortunately you'll need to strip it down to a byte to pass in, i.e. <code>(~n &amp; 0xff)</code>.</p>
",7
7188981,7188919,0,"<p>My guess is that <strong>all</strong> your passed <code>char</code>s are interpreted as 32 bit integers, but, in the first 4 cases the output is the same. Only in the last one it shows it's ugly face :)</p>

<p>You have to mask out all other bits in order to gain a character like result as in the first 4 examples.</p>
",3
7189004,7188919,10,"<p>Integer types are promoted when they are used in arithmetic operations (this has nothing to do with <code>printf</code>, by the way).</p>

<p>So, for example,</p>

<pre><code>unsigned char x = 0xff;
int y = ~x; // x is promoted to 0x000000ff, then changed to 0xffffff00
unsigned char z = ~x; // truncated back to 0x00
</code></pre>

<p>Integer promotion causes various problems:</p>

<pre><code>unsigned char x = 1;
if (x &lt;&lt; 8)
    puts(""x &lt;&lt; 8 is true""); // does print
x &lt;&lt;= 8;
if (x)
    puts(""x &lt;&lt;= 8 is true""); // does not print
</code></pre>

<p>The two ways to truncate things are casting and masks.  Use whatever you prefer.</p>

<pre><code>unsigned char x = 0xab;
printf(""x = %02x\n"", (unsigned char) x);
printf(""x = %02x\n"", x &amp; 0xff);
</code></pre>

<p>Integer promotion doesn't always happen, and it's not the only kind of implicit cast.  It's also a bit subtle and the exact rules are difficult to remember.  You only <em>really</em> need to worry about it if you're working with 64-bit numbers, because <code>1U &lt;&lt; 32</code> could end up being <code>0</code> or <code>1</code> or something else entirely.  (It's often <code>1</code> on x86).</p>
",5
7195108,7188919,0,"<p>1) You have specified width as %5x but there is a rule regarding width specifier in C. If the width of the number to be printed is more than the assigned width, the  width specifier is ignored. So in the last column the number content cant be represented in the assigned width 5 so width limit has been ignored.Why width is greater than 5 i have explained in 3rd point. Now in 2nd point i tell %x vs unsigned char .</p>

<p>2) See friend you have declared variable 'n' as an unsigned char but you have used %x which is for unsigned hexadecimal int. So at the time of printing the value of n is promoted or technically you can say typecasted as an unsigned hexadecimal integer. It is not only in the case of unsigned char and %x. You should try dirrerent combinations on your compiler just like 
int a=-5;
printf(""%d   %u"",a,a); 
now you will get -5 by %d and for %u you will get some other interpretaion dependent on compiler properties whether it is 16-bit or 32-bit.
now if you try
unsigned int a=-5;
printf(""%d    %u"",a,a); 
result will be still same as previous. in first case you write int a=5 and in the second case you write unsigned int =5 but result is dependent on the interpretation so this is like such.</p>

<p>This is about typecasting or you can say about interpretation by the compiler. when you say %x You yourself say to compiler that interpret it as a unsigned hexadecimal int. i hope its clear now, in case its not i suggest you to run little different programs and that too on many compilers. Programs like int x=7; printf(""%f ""x); etc etc .. you will surely get the point. Now i explain the out of the last column why its like fffffffe.</p>

<p>3) We consider the first run of the loop. here n=0x1. In a 32-bit compiler it will be represented in memory as 0000 0001 as char is provided 1 byte of memory.But afterwards when you typecast it as a unsigned hexadecimal integer the interpertation in a 32-bit compiler  is 0000 0000 0000 0000 0000 0000 0000 0001  Well if you declare int n=1 or you declare unsigned int n=1 or you declare int n=0x1. the representation will be same. even if you use unsigned char n=1 the rightmost digit will be 1 and all others zero although the number of zeros may be less. Now in your looping statement by denoting %x you tell compiler to interpret the content as a unsigned hexadecimal int, so compiler provides it space as an hexadecimal and you do this opertion ""~n"" now by performing this operation the bit representation becomes like this 1111 1111 1111 1111 1111 1111 1111 1110. (caution-Remember that printf(""%d"",~n); case is different than printf(""%d"",n++); in the n++ case the value of variable in the memory gets updated too. but using printf(""%d"",~n) is similar using printf(""%d"",n+8).) So as per this new representaion of bits all bits are 1 except the rightmost. Now when it gets printed it gets printed like fffffffe. simple!</p>

<p>4)You have written "" but it seems like it's being cast to a signed 32 bit value and sign extended by the %5x specifier."" hmmm %x is not for signed hexadecimal int %x is for unsigned hexadecimal int so no point of assuming that minus sign got truncated.</p>

<p>5)In your progam you have used '~n' now just check different versions like this '-~n' or
 '-n' . this is for experiment purpose.</p>
",0
4661594,4661358,1,"<p>Well pointers on your environment are 8 bytes wide, and your <code>int</code>s are also 8 bytes wide by the looks of it. Judging by the error when trying to use <code>-m32</code> with gcc, I'd hazard a guess that you have the x86_64
version of glibc-devel installed and need to additionally install the x86 (32-bit) version.</p>

<p>Could you post the output from <code>ldd &lt;your_compiled_program&gt;</code>, too?
Let us know if this is (not) the case.</p>
",0
4661698,4661358,0,"<p>Running your code, I get 24,8 under a 64-bit build and 12,4 under a 32-bit build: MacOS X 10.6.6 (Intel Core 2 Duo), GCC 4.5.2, Valgrind 3.6.0.</p>

<h3>32-bit</h3>

<pre><code>$ gcc -m32 -g -o vg vg.c
$ valgrind vg
==69827== Memcheck, a memory error detector
==69827== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==69827== Using Valgrind-3.6.0 and LibVEX; rerun with -h for copyright info
==69827== Command: vg
==69827== 
12
4
==69827== 
==69827== HEAP SUMMARY:
==69827==     in use at exit: 4,416 bytes in 8 blocks
==69827==   total heap usage: 9 allocs, 1 frees, 6,948 bytes allocated
==69827== 
==69827== LEAK SUMMARY:
==69827==    definitely lost: 0 bytes in 0 blocks
==69827==    indirectly lost: 0 bytes in 0 blocks
==69827==      possibly lost: 0 bytes in 0 blocks
==69827==    still reachable: 4,416 bytes in 8 blocks
==69827==         suppressed: 0 bytes in 0 blocks
==69827== Rerun with --leak-check=full to see details of leaked memory
==69827== 
==69827== For counts of detected and suppressed errors, rerun with: -v
==69827== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
$
</code></pre>

<h3>64-bit</h3>

<pre><code>$ gcc -m64 -g -o vg vg.c
$ valgrind vg
==69840== Memcheck, a memory error detector
==69840== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==69840== Using Valgrind-3.6.0 and LibVEX; rerun with -h for copyright info
==69840== Command: vg
==69840== 
24
8
==69840== 
==69840== HEAP SUMMARY:
==69840==     in use at exit: 4,184 bytes in 2 blocks
==69840==   total heap usage: 3 allocs, 1 frees, 9,248 bytes allocated
==69840== 
==69840== LEAK SUMMARY:
==69840==    definitely lost: 0 bytes in 0 blocks
==69840==    indirectly lost: 0 bytes in 0 blocks
==69840==      possibly lost: 0 bytes in 0 blocks
==69840==    still reachable: 4,184 bytes in 2 blocks
==69840==         suppressed: 0 bytes in 0 blocks
==69840== Rerun with --leak-check=full to see details of leaked memory
==69840== 
==69840== For counts of detected and suppressed errors, rerun with: -v
==69840== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
$
</code></pre>

<p>Of course, valgrind is a red herring; the same results are printed with less verbosity around them without valgrind.</p>
",0
4661392,4661358,0,"<p>You are likely building on a 64-bit platform.  8 byte pointers.  If you build it with <code>-m32</code> it will build as a 32-bit application.</p>
",9
2073256,2073195,4,"<p>You need a structure or simply put a user-defined data structure. Something like:</p>

<pre><code>struct rainfall_t {
   double x, y; /* location */
   double monthly_rainfall[ 12 ];
};
</code></pre>

<p>In C, arrays are homogeneous i.e. they can store data of a single type only. Even for multi-dimensional arrays. You possibly cannot have an array for all the data you describe without first wrapping it up in a <code>struct</code>.</p>

<p>You could then create an array of <code>rainfall_t</code> and use it as you wish:</p>

<pre><code>struct rainfaill_t db[ 100 ]; /* a DB of 100 locations */
</code></pre>

<p>You should also look up dynamically allocated memory in case you do not know up front how many locations you will have to deal with.</p>
",0
2073259,2073195,2,"<p>I think more than array you would first need a structure to store the information you have mentioned. You require an array of structure than a 3 dimenensional array.</p>

<pre><code>struct RainfallDB
{
double XCord;
double YCord;
double Mnths[12];
};
</code></pre>

<p>Now in the function you can declare an array like this.</p>

<pre><code>struct RainFallDB raininfo[100];
</code></pre>

<p>This will store the information of 100 records. If you dont know how many records user would like to store you can create a linklist out of the structure and dynamically allocate using malloc. </p>

<p>Hope this helps.</p>
",0
2073269,2073195,0,"<p>Yes, use structs for the job</p>

<pre><code>struct myRainfallRecord {
     double x;
     double y;
     double **monthlyrainfall;
}
</code></pre>

<p>and have an array of myRainfallRecords. Monthlyrainfall can be malloc'd using malloc(12*sizeof(double)) when you fill in the value of the struct.</p>
",1
2073272,2073195,2,"<p>You really don't want to use a 3D array for this - C is not good at dealing with multi-dimensional arrays. Also, it is much easier to deal with names rather than array indexes, so instead, create a struct:</p>

<pre><code>typedef struct {
   double x, y;
   double rainfall[12];
} places;
</code></pre>

<p>and then create a 1-dimensional array of them:</p>

<pre><code>places p[100];   // 100 places
</code></pre>
",0
2073281,2073195,0,"<p>In a multidimensional array the higher dimensions are composed of lower-dimensioned arrays.</p>

<p>So, only your final array will contain anything other than an array.</p>

<p>It seems like you don't really need that third dimension, right? </p>

<p>So:</p>

<pre><code>rfd[][14] = { 
                   { X_coord, Y_coord, rain, rain, rain, ... },
                   { X_coord, Y_coord, rain, rain, rain, ... },
                   { X_coord, Y_coord, rain, rain, rain, ... },
};
</code></pre>

<p>You will need a parallel array for the place names. This is why one would normally use a structure for this type of data.</p>

<pre><code>char *places[] = { ""Spain, the plains"", ... };
</code></pre>

<p>(OR, <code>struct Rain { char *place, double x,y; double rain[12]; };</code>)</p>
",0
2336359,2336295,9,"<p>When working on architectures with segmented memory (like x86 real mode), one can distinguish three types of pointer addresses (examples for x86 in segment:offset notation):</p>

<ul>
<li><p><strong>near</strong></p>

<p>Only stores the offset part (which is 16-bit) - when resolving such a pointer, the current data segment offset will be used as segment address.</p></li>
<li><p><strong>far</strong></p>

<p>Stores segment and offset address (16 bit each), thus defining an absolute physical address in memory.</p></li>
<li><p><strong>huge</strong></p>

<p>Same as far pointer, but can be normalized, i.e. <code>0000:FFFF + 1</code> will be wrapped around appropriately to the next segment address.</p></li>
</ul>

<p>On modern OSes this doesn't matter any more as the memory model is usually flat, using virtual memory instead of addressing physical memory directly (at least in ring 3 applications).</p>
",2
2336317,2336295,5,"<p>Because you're using near pointers vs. <a href=""http://en.wikipedia.org/wiki/Far_pointer"" rel=""nofollow noreferrer"">far pointers</a>.  A far pointer requires two 16 bit addresses, in this case.</p>

<p>(The ""huge"" specifier is a non-standard far pointer syntax, for handling some specific far pointer cases...)</p>
",4
6083879,6083853,1,"<p>Since you want an array of bytes then <code>char**</code> is wrong ¨C that's a pointer to a pointer to <code>char</code>. You want <code>char*</code> for an array, but if it's fixed length I'd declare it as <code>char list[20]</code>.</p>

<p>It seems like you want to write something like this:</p>

<pre><code>char list[20];
for (int i = 0; i &lt; 20; i++) {
    list[i] = 'a';
}
</code></pre>

<p>Or if you want heap allocation use</p>

<pre><code>char *list = malloc(20);
</code></pre>

<hr>

<p>Since we are reduced to guessing, I think that you meant to say that <code>*list</code> is an array of bytes.  In which case the code would be like so:</p>

<pre><code>char **list = get_list_from_somewhere();
*list = malloc(20);
for (int i = 0; i &lt; 20; i++) {
    *list[i] = 'a';
}
</code></pre>
",6
6083880,6083853,0,"<p>How did you initialize your <code>list</code>? </p>

<pre><code>char** list;
</code></pre>

<p>doesn't work in this case you'll have to have something like</p>

<pre><code>char* list[20];
</code></pre>

<p>or dynamically allocated.</p>
",0
6083902,6083853,2,"<p>In C, a pointer can be used to represent an array, and a single string is an array of <code>char</code>, or in other words, a <code>char *</code>. This means that a <code>char **</code> is an array of strings. So if you want to put characters into the first string (assuming that memory has already been allocated to it), you should use <code>list[0][i] = 'a';</code> in the first loop - i.e., put <code>'a'</code> into position <code>i</code> of the <code>0</code>th string.</p>

<p>Another way of interpreting a <code>char **</code> (which is the one I suspect is the one you're supposed to use) is that it is a pointer that points to a pointer that points to an array of <code>char</code>. In that case, you can use the ""outer"" pointer to modify what the inner pointer points to; this can be used to first allocate the string and then write to it:</p>

<pre><code>*list = malloc(21); // Allocate 21 bytes and make the pointer that 'list' points to refer to that memory
for (int i = 0; i &lt; 20; i++) {
    (*list)[i] = 'a';
}
(*list)[20] = '\0'; // Also, you need the null terminator at the end of the string
</code></pre>

<p>In memory, this looks like this:</p>

<pre><code>list ---&gt; (another pointer) ---&gt; |a|a|a|a|a|a|...|a|a|\0|
</code></pre>
",0
6083971,6083853,1,"<pre><code>char** list
</code></pre>

<p>Isn't a 'array of bytes' its a 'pointer to a pointer pointing to char' which you can think of as a 'list of lists of char'.  Also if you define it this way, you need to malloc enough memory to hold the data.</p>

<p>When you write:</p>

<pre><code>list[i] = 'a';
</code></pre>

<p>Its messing up memory because your placing a char 'a' in a location specified to hold a pointer.  Actually in most compilers character literals are of type int so your actually storing an int form of 'a' as a pointer to a memory location which can cause all sorts of memory corruption.  </p>

<p>If you want 'list' to be on the stack then define it as:</p>

<pre><code>char list[20]
</code></pre>

<p>If you want 'list' to be in the heap then define it as:</p>

<pre><code>char* list;
list = malloc(sizeof(char) * 20);
</code></pre>

<p>In either case access it as:</p>

<pre><code>list[i]
</code></pre>

<p>Also its not safe to assume the size of int being equivalent to the size of a pointer as you to have done in your second example.  At least i think thats what you were trying to do. </p>

<p>Additionally if your storing raw bytes from a data stream or something of that sort you should likely be using 'unsigned char' not 'char' and for more safety use 'int8_t' as you can't always guarantee that 'char' is 8 bits although it is on the majority of platforms.</p>
",0
2223467,2197715,0,"<p>Extern struct works as well as extern, at least when the extern is in the header file and the actual struct is in a cpp file that includes that header. I don't think ""extern struct"" is necessary so much as just ""extern"".</p>
",0
2197820,2197715,9,"<p>I'm assuming b is another source file. You can so something like:</p>

<p>file: file.h</p>

<pre><code>#ifndef _FILE_H_
#define _FILE_H_
 struct emp {
 char name[100];
 };
#endif
</code></pre>

<p>file: a.c</p>

<pre><code>#include ""file.h""    
extern struct emp e; // declare struct var as extern.

int main() {

        printf(""Name = %s\n"",e.name);

        return 0;
}
</code></pre>

<p>file: b.c</p>

<pre><code>#include ""file.h""    
struct emp e = {""stackoverflow""}; // struct var defined here.
</code></pre>

<p>On running:</p>

<pre><code>$ gcc *.c &amp;&amp; ./a.out
Name = stackoverflow
</code></pre>

<p>You question is very unclear and you are <em>not new</em> on SO.</p>
",4
6126181,6126149,5,"<pre><code>n*7 == (n&lt;&lt;3) - n
</code></pre>

<p>Not sure if that will be better then normal multiplication by 7 though</p>
",5
6126182,6126149,2,"<p>It's likely either</p>

<pre><code>n*7
</code></pre>

<p>or</p>

<pre><code>(n&lt;&lt;3) - n
</code></pre>
",3
6126216,6126149,12,"<p>Assuming your compiler isn't terrible, <code>n*7</code>.</p>
",1
6126245,6126149,1,"<p>oh you were so close!</p>

<p>= (n &lt;&lt; 3 - n) </p>

<p>= n * 8 - n</p>

<p>= n(8 - 1)</p>

<p>= n * 7</p>
",2
6126276,6126149,5,"<p>The correct answer is a combination of</p>

<pre><code>a) n*7
</code></pre>

<p>because this is exactly the kind of micro-optimization that the compiler is perfectly capable of figuring out on its own.</p>

<pre><code>b) the interviewer has a poor understanding of modern optimizing compilers
</code></pre>

<p>Alternatively, if the interviewer isn't clueless, an answer different than a) above suggests that the interviewee does not understand optimizing compilers and is thus a poor candidate for the job. :-/</p>
",0
6126508,6126149,7,"<p>No forbidden operators (<code>+</code>, <code>-</code>, <code>*</code>, or <code>/</code>) used :)</p>

<pre><code>/* multiply by 7 without using the forbidden operators */
/* if `n` is larger than `INT_MAX / 7`
** or smaller than `INT_MIN / 7`
** the behaviour is undefined. */
int mult7(int n) {
  int n7 = n;
  n7 *= 7;
  return n7;
}
</code></pre>
",2
6127323,6126149,5,"<p>The best answer I can come up with is to write ""+"" operation using while loop and bitwise operators per each bit. Something like this:</p>

<pre><code>
int add(int x, int y) {
  int a, b;
  do {
    a = x & y; b = x ^ y; x = a &lt&lt 1; y = b;
  }while(a);
  return b;
}
</code></pre>

<p>And then sum up n, n &lt;&lt; 1, n &lt;&lt; 2.</p>

<p>""+"" is easy to write with while loop, if you can come up with way to write ""-"" with while loop (which i am not sure how to do exactly) than you can do (n &lt;&lt; 3) - n.</p>

<p>source:http://geeki.wordpress.com/2007/12/12/adding-two-numbers-with-bitwise-and-shift-operators/</p>
",1
6127355,6126149,0,"<pre><code>int main()
   {
        int i;
        int x;
        int n;
        x = n;
        for (i = 2; i &lt; 8; i++)
        {
             n += x;
        }
        return 0;
    }
</code></pre>

<p>EDIT: converted to c (i think) and realized there is no .= in c so had to switch to +=. Still not the same as + technically but a bit questionable. </p>

<p>I know it uses the ++ but that certainly not the same as ""+"" and .= avoids the stipulation.</p>
",3
6126588,6126149,10,"<p>Meets almost all your requirements :)</p>

<pre><code>#include &lt;stdio.h&gt;

int mult7(int i)
{
    int res;
    __asm__(""imull  $7, %1, %0"" : ""=r"" (res) : ""r"" (i));
    return res;
}

int main()
{
    printf(""%d"", mult7(12)); //output: 84
    return 0;
}
</code></pre>
",2
6126612,6126149,1,"<p>Assuming that the interviewer is looking for a shift-and-add kinda answer, I guess you could use:</p>

<pre><code>int ans = (num&lt;&lt;2) + (num&lt;&lt;1) + num;
</code></pre>

<p>I guess this a crude way of testing if the interviewee knows of this particular algo.</p>
",0
6127179,6126149,2,"<p>Maybe this is a valid answer as well : <code>pow(10, log10(n) + log10(7))</code></p>
",1
2614799,2614779,0,"<p>Your variables i &amp; j aren't initialized. What do do mean by <code>(i=0) &amp;&amp; (j=0)</code>?
The compiler will make a shortcut and only assign <code>i=0</code> j remains uninitialized with the effect you described.</p>
",0
2614789,2614779,18,"<p><code>j</code> never gets initialised, because of the <a href=""http://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""nofollow noreferrer"">short-circuiting behaviour</a> of <code>&amp;&amp;</code>.  Since <code>(i=0)</code> evaluates to false, <code>(j=0)</code> never gets executed, and hence <code>j</code> gets a random value.  In the first example, that just happens to be zero.</p>

<p>You should say <code>i=0, j=0</code> to achieve what you want.</p>

<p>The <code>i++ &amp;&amp; j++</code> has the same problem; it should be <code>i++, j++</code>.</p>

<p>Also, this:</p>

<pre><code>char somestring[3] = ""abc"";
</code></pre>

<p>is reserving one too few bytes, because of the trailing NUL character in the string - you need four bytes.  But if you're not going to modify the string, you don't need to specify the number of bytes - you can simply say this:</p>

<pre><code>char *somestring = ""abc"";
</code></pre>

<p>instead.</p>
",3
2614791,2614779,1,"<p><code>for((i=0) &amp;&amp; (j=0)...</code> seems to be incorrect already.<br>
<code>i=0</code> has already value of 0, so the evaluation of <code>j=0</code> is not needed, so it is skipped.</p>

<p><code>(i++) &amp;&amp; (j++)</code> seems to be incorrect for the very first iteration, too, by the same reason.</p>
",0
2614792,2614779,2,"<p>If you use &amp;&amp;, only the first argument gets evaluated if it's false. i=0 is false, so j doesn't get set to 0. You should use the komma operator:</p>

<pre><code>for((i=0) , (j=0); count &gt; 0; i++, j++){ [...]
</code></pre>
",0
2614793,2614779,0,"<p>You are using <code>(i==0) &amp;&amp; (j==0)</code> to initialise both variables in your loop.</p>

<p>However, a property of &amp;&amp; is that if the first operand evaluates to FALSE (i.e. 0), the second operand is never executed. So, as i is 0, j is left uninitialised. In your first run, you were simply <em>lucky</em> that it happened to contain the value 0.</p>
",0
3070119,3070105,2,"<p>You have a typo here:</p>

<pre><code>  while(isdigit([s++i] = c = getch()));
</code></pre>

<p>Change it to:</p>

<pre><code>  while(isdigit(s[++i] = c = getch()));
</code></pre>
",5
3070161,3070105,1,"<p>At first glance, I thought it was incomplete as well, but then I noticed the following key line:</p>

<pre><code>return (bufp &gt; 0) ? buf[--bufp] : getchar();
</code></pre>

<p>On the off chance you weren't aware, the a ? b : c syntax is a ternary statement meaning ""if a is true, execute b, else execute c"". In this case, what happens is that, if <code>bufp</code>, the count of characters in the array <code>buf</code>, is greater than 0, <code>getch()</code> will decrement <code>bufp</code> and return the last character in the buffer (meaning the buffer actually acts as a stack, since <code>ungetch()</code> adds characters to the tail of the buffer rather than the head). If there are no characters in <code>buf</code> (i.e. <code>bufp</code> &lt;= 0), the function calls <code>getchar()</code> and returns the value obtained from that. Aside from that, I don't see where your confusion could be coming from, unless your problem really does stem from that typo that Paul R mentioned and everything before this sentence is pointless.</p>
",1
3070162,3070105,1,"<p>getchar() reads and eliminates from stdin. What you read is lost iff you are not keeping it.
this is where the pop and push functions getch() and ungetch() com into play. in getop you have a small parser with a look-ahead of 1 (one character in advance).</p>

<p>getop()</p>

<ul>
<li>skip blanks and tabs</li>
<li>if c is no digit and no dot, return this character</li>
<li>read over numbers and dot and more numbers</li>
<li>if read character is not a number, push it back and leave function</li>
</ul>
",0
3352409,3352304,1,"<p>You can use <a href=""http://linux.die.net/man/3/strtok"" rel=""nofollow noreferrer""><code>strtok</code></a><code>()</code> with a delimiter set of <code>{}</code> (and whatever else you need). A sequence of two or more contiguous delimiter characters in the parsed string is considered to be a single delimiter, plus you can modify the delimiter set between successive calls. Also note that strtok() modifies the string given to it.</p>

<p>edit: I realised this is not quite enough for your 2nd requirement.</p>
",0
3352443,3352304,0,"<p>I've used <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strtok/"" rel=""nofollow noreferrer"">strtok()</a> for this. This doesn't work for the strings with escaped characters, but I think it can be modified to understand them. It isn't that trivial though. Hopefully this will give you some help. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void) {
    char str[] = ""{Job Started}{Job Running}{Job Running}{Job Finished}"";
    char* pch;
    pch = strtok(str,""{}"");
    while(pch!=NULL) {
        printf(""%s\n"",pch);
        pch = strtok(NULL,""{}"");
    }
    return 0;
}
</code></pre>

<p>Delnan has a point there. String manipulation is way too difficult and vulnerable to failures in pointer handling in C. If C isn't mandatory for your project, you should definitely use some other language.</p>
",1
3352474,3352304,0,"<p>If you want to extend its functionality you could take a look at the <a href=""https://rads.stackoverflow.com/amzn/click/com/0201545411"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Eric Robert's</a> <code>scannerADT</code>. It's very straightforward to use and you could add a <code>setDelimiter</code> method to it.</p>

<p><a href=""http://www.google.com/codesearch/p?hl=en#nb_LDb38snw/trunk/src/scanADT/scanadt.c&amp;d=3"" rel=""nofollow noreferrer"">Here</a> are the .c and .h for it.</p>
",0
3352525,3352304,1,"<p>writing your own function to tokenize this should be pretty simple, especially if you know where the string is coming from (and don't need to worry about strange user input, for example <code>{a}{</code>, <code>{{{{{</code>, <code>}a{</code>, <code>{blah}    {blah}</code>).</p>

<p>something like [written quickly and untested!!]:</p>

<pre><code>int tokenize(char* inp, char** outp)
{
    char i = inp;
    int currentToken = 0;

    if(*i == 0)
        return 0;

    outp = (char**)malloc(sizeof(char*) * (strlen(inp) / 2));// allocate a buffer that can hold the maximum # of tokens.
    outp[0] = i;

    while(*i != 0)
    {
        switch(*i)
        {
            case '{':
                // start a new token
                tokenCount = tokenCount + 1;
                outp[currentToken] = i;
                break;
            case '}':
                // skip this character. we assume there is a { coming next.
                break;
            case '\\':
                i = i + 1;
                if(*1 == 0)
                    break;
                // intentional fall-through
            default:
                *outp[currentToken] = *i;
                break;
        }
        if(*i == 0)
            break;
        i = i + 1;
    }

    return currentToken + 1;
}
</code></pre>
",0
3352533,3352304,0,"<pre><code>char **
split( char **result, char *tmp, const char *src, const char *delim, size_t len)
{
   int i=0;
   char *p=NULL;
   for(i=0; i&lt;len; i++) 
      result[i]=NULL;
   if(!*src)
      return result;
   strcpy(tmp, src);
   for(i=0, p=strtok(tmp, delim); p!=NULL; p=strtok(NULL, delim), i++ )
   {
      result[i]=p;
   }
   return result;
}
</code></pre>

<p>This example does not destroy the original string, you pass in a working string.</p>
",0
3352619,3352304,0,"<pre><code>char *tokenizer(char *ptr) {
    char *str = ptr;
    char *aux = ptr;

    while (*ptr) {
        if ( *ptr == '\\' &amp;&amp; ( *(ptr + 1) == '{' || *(ptr + 1) == '}') ) {
            *aux++ = *(ptr + 1);
            ptr += 2;
        }
        else if ( *ptr == '{') {
            ++ptr;
        }
        else if ( *ptr == '}' ) {
            *aux++ = ( *(++ptr)  != '\0' ) ? ',' : '.';
        }
        else {
            *aux++ = *ptr++;
        }
    }
    *aux = '\0';
    return str;
}
</code></pre>
",1
3352963,3352304,0,"<p>If that one is your only scanning/tokenizing problem you will probably better go with the solution you already have or implement FSM as Ferruccio sugggested.</p>

<p>If you have other similar problems, on the other hand, you might look for a tool or library that could help you with that.  Someone suggested lex but you could set up for a regular expression library too.</p>

<p>Given a string matching library you could write something like:</p>

<pre><code>pmx_t ret;

ret = pmxMatchStr(src,""&amp;e\\&amp;K{(&lt;*!}&gt;)}&amp;K{(&lt;*!}&gt;)}&amp;K{(&lt;*!}&gt;)}&amp;L"")));
if (ret) {
  printf(""%.*s, %.*s, %.*s\n"",pmxLen(ret,1),pmxStart(ret,1),
                              pmxLen(ret,2),pmxStart(ret,2),
                              pmxLen(ret,3),pmxStart(ret,3)
}
</code></pre>

<p>(also handle spaces before or between the <code>{...}</code> and eats up the end of the line)</p>

<p>Yes, the example is a shameless promotion of my <a href=""http://code.google.com/p/c-libutl/"" rel=""nofollow noreferrer"">library (pmx)</a> but the same concept is applicable using one of the many others that you could find googling for regexp or regular expression libraries in C.</p>
",0
3352656,3352304,5,"<p>You can use a simple finite state machine:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    char *src = ""{Job Started}{Job \\{ID1\\} Running}{Job \\{ID2\\} Running}{Job Finished}"";

    char token[100] = {}, *dst = token, ch;

    int state = 0;
    while ((ch = *src++) != 0) {
        switch (state) {
            case 0:
                if (ch == '{') state = 1;
                break;
            case 1:
                switch (ch) {
                    case '}':
                        printf(""token: %s\n"", token);
                        dst = token;
                        *dst = 0;
                        state = 0;
                        break;
                    case '\\':
                        state = 2;
                        break;
                    default:
                        *dst++ = ch;
                        *dst = 0;
                }
                break;
            case 2:
                *dst++ = ch;
                *dst = 0;
                state = 1;
                break;
        }
    }
}
</code></pre>
",0
3352768,3352304,0,"<p>You can use <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/sscanf/"" rel=""nofollow noreferrer"">sscanf</a>. You may want to create appropriate delimiters using the reference in the link.</p>

<p>/* sscanf example */</p>

<pre><code>#include &lt;stdio.h&gt;

int main ()
{
  char sentence []=""Rudolph is 12 years old"";
  char str [20];
  int i;

  sscanf (sentence,""%s %*s %d"",str,&amp;i);
  printf (""%s -&gt; %d\n"",str,i);

  return 0;
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>Rudolph -&gt; 12
</code></pre>

<p><a href=""http://www.opengroup.org/onlinepubs/000095399/functions/strtok.html"" rel=""nofollow noreferrer"">Strtok</a> and <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/strtok.html"" rel=""nofollow noreferrer"">strtok_r</a>(reentrant version of strtok) can be used to parse the string too.</p>

<p>PS: I am copying my example here from another question with similar requirements</p>
",0
3166247,3159644,1,"<p>I rather suggest also using gettimeofday() system call to retrieve the seed to be used to feed srand().</p>

<p>Something like</p>

<pre>
<code>
struct timeval tv;
...
gettimeofday(&tv, NULL);
srand(tv.tv_usec);
...
</code>
</pre>

<p>This approach can add more entropy in your pseudo number generation code.
IMHO of course</p>

<p>Ciao ciao</p>
",0
5557583,5557512,0,"<p>Start with this:</p>

<pre><code>int main() {     
   int i = 55;     
   int j = 65;    
   printf(""%d\n"", 
          compare_int ( &amp;i, &amp;j);   

   return 0;

} 

int compare_int(const void *left, const void *right)
</code></pre>

<p>would also be a something to consider as well.</p>
",2
5558270,5557512,2,"<p>I think I understand what you're struggling with. I'm going to interpret this question as why are </p>

<pre><code>int *l = (int*)left;
int *r = (int*)right;
</code></pre>

<p>these lines necessary.</p>

<p>They're necessary because C is basically assembly. When you use a type in C, you're telling it how large you expect the field to be in terms of memory. The void type is exactly that - a type of totally undefined length. A void pointer is a pointer to a variable of <em>any</em> type. Actually, any pointer can point to any type, but when you dereference it you'll only read up to the size of that type. </p>

<p>Now the type <code>void</code> doesn't have a size. So you can't dereference a void pointer, because C doesn't know ""where to stop"" when reading the value. </p>

<p>So a good way to think of it is not <code>int* x</code> is a integer pointer but <code>x</code> is a pointer and the data it points to is an int of size 4 bytes (or whatever). By contrast <code>void* y</code> is a pointer and the data it points to is of unknown size and type.</p>

<p>A cast is used so that you know the size of the memory you're supposed to be reading once you've dereferenced your pointer. </p>

<p>See also the explanation from <a href=""http://www.cplusplus.com/doc/tutorial/pointers/"" rel=""nofollow"">cplusplus.com</a>:</p>

<blockquote>
  <h1>void pointers</h1>
  
  <p>The void type of pointer
  is a special type of pointer. In C++,
  void represents the absence of type,
  so void pointers are pointers that
  point to a value that has no type (and
  thus also an undetermined length and
  undetermined dereference properties).</p>
  
  <p>This allows void pointers to point to
  any data type, from an integer value
  or a float to a string of characters.
  But in exchange they have a great
  limitation: the data pointed by them
  cannot be directly dereferenced (which
  is logical, since we have no type to
  dereference to), and for that reason
  we will always have to cast the
  address in the void pointer to some
  other pointer type that points to a
  concrete data type before
  dereferencing it.</p>
</blockquote>

<p>How could you fix this? Stop using <code>void*</code>, basically. Your function is called <code>compare_int</code> yet it accepts theoretically any type and attempts to cast it. This is what other commentors / people answering mean when they say ""what are you trying to do here?"" The <code>void*</code> trick is very useful sometimes (for example when you want to be able to use a callback function pointer and let the programmer pass any arguments. <code>CreateThread</code> on windows works like this) but here, just for comparing two integers? It's overkill.</p>
",1
5136397,5136393,20,"<p>Yes, you are absolutely right that the memory location <strong><em>could</em></strong> change. But it doesn't have to :). In each iteration the old variable is ""destroyed"" and a new one is ""created"" at the same place. Although any decent compiler would optimize the unnecessary ""actions"" away</p>
",3
5136398,5136393,6,"<p>Yes, the variable is new each time around, but at the end of the block any new variables on the stack are released again.</p>

<p>Hence next time around the stack pointer is back exactly where it was.  NB: this behaviour is common, but <em>not guaranteed</em> by the standards.</p>
",0
5136468,5136393,0,"<p>The scoping rules for variables only describe the scope in which you have the right to access a local variable: from the definition to the end of its block.</p>

<p>This rule says nothing about the moment that space is reserved for it. A common strategy for that is to reserve space for all variables that will be needed for an invocation of a function at once, at the beginning of the function.</p>

<p>So when execution crosses a definition of a variable, usually nothing particularly has to be done, not a single instruction. On the other hand this leaves the value of that variable to whatever was found there previously. So the importance of initializing to a known state, as you did in your example with the <code>= 10</code>.</p>
",0
5136506,5136393,5,"<p>It's a compiler optimization. Because the local variable is going out of scope and a variable of the exact same type is about to be created, it's reusing the memory address. It's important to note that this is still a ""fresh"" or ""new"" variable as far as your program is concerned.</p>

<p>Compare the following code snippets and output:</p>

<pre><code>for (i = 0; i &lt; 3; i++) {
    int n = 0;
    printf(""%p %d\n"", (void *)&amp;n, n++);
}
</code></pre>

<pre>
0x7fff56108568 0
0x7fff56108568 0
0x7fff56108568 0
</pre>

<pre><code>for (i = 0; i &lt; 3; i++) {
    static int n = 0;
    printf(""%p %d\n"", (void *)&amp;n, n++);
}
</code></pre>

<pre>
0x6008f8 0
0x6008f8 1
0x6008f8 2
</pre>
",0
4178876,4178869,10,"<p>There is no such mechanism; the return code is expected to be a byte. If you want to output a string from your program then use something like <code>printf()</code> and command substitution in the shell script to capture it.</p>
",5
4178877,4178869,7,"<p>You cannot.</p>

<p>The best thing you could do is writing the string somewhere (on standard output, standard error or some file); then the shellscript will get your string from there.</p>

<p>Standard output (thus using just a <code>printf</code>) is probably the best solution, since it will be very easy from your C program print the string, and very easy for the shellscript getting that data:</p>

<p>From shell script:</p>

<pre><code>STRING=""$( ./your_program argv1 argv2 )""
</code></pre>
",0
4178878,4178869,5,"<p>There is not way to return a string from <code>main()</code>. Maybe the program itself should print the string ?</p>
",0
4178879,4178869,4,"<p>Just output the string you want to return to standard output with <code>printf</code>.  Then in your script, do something like this:</p>

<pre><code>SOMESTRING=""`./yourprogram`""
</code></pre>

<p>The backticks will capture the output of the program, which will be the string you printed.</p>
",0
4178882,4178869,1,"<p>You can't, but you don't need to either.  You return a stat code from main, but you can always re-direct the output and capture it in your shell script.</p>
",0
4179033,4178869,0,"<p>You have to print the string to <code>stdout</code> and use the shell's command substitution to read the result:</p>

<pre><code>""`command`""
</code></pre>

<p>or:</p>

<pre><code>""$(command)""
</code></pre>

<p>Either way, you should use the enclosing double-quotes as above. Note that this method has a potentially-serious problem that it removes all training newlines from the command's output. If you need to preserve the exact output, try:</p>

<pre><code>output=""$(command ; echo x)""
output=""${output%x}""
</code></pre>

<p>Since OP mentioned that this is for a password, another piece of advice: once you've read a password into a shell variable, <strong>never</strong> pass it on the command line to other programs. Command lines are usually world-readable. Instead of something like</p>

<pre><code>wget ""http://$user:$pass@host/foo""
</code></pre>

<p>try something like</p>

<pre><code>wget -i - &lt;&lt; EOF
http://$user:$pass@host/foo
EOF
</code></pre>

<p>Here-files as in this example are useful with a number of programs which need to take passwords from scripts.</p>
",0
4178920,4178869,0,"<p>You cannot - you can only return an integer.</p>

<p>Remember that C was developed alongside Unix. Unix programs return an integer value which is intended as a status code. If a program was to return string(s) it would write them to stdout, and then the user (or a script) would pipe it into something useful.</p>

<p>MS DOS also had number-only status values.</p>
",0
2999763,2998983,3,"<p>Simply put, \0 is the same as 0, so if you have a zero in your array your code will mistake that for the array's end:</p>

<pre><code>int arr[] = {30, 450, 14, 5, 0, 10, '\0'};
                             ^ this is the end of the array
</code></pre>

<p>Edit: note that by ""end of the array"" I mean the conceptual end of the array as defined by your algorithm, rather than the actual extents of the data laid out in memory by the C programming language.</p>
",0
7480807,7480697,1,"<p>If you want the values to be unique, they should belong to a single enumeration.  Separate enumerations can have overlapping sets of values without causing any problems to the normal C program.</p>

<p>If you really have a a good reason for needing disjoint sets of values across enumerations, then I guess you should define a conventional 'last member' of each enumeration, and use that to start the next one:</p>

<pre><code>typedef enum transfer_states_e {
    /* Call transfer bind/supervised */
    STATE_TRANSFER_IDLE = 1,
    STATE_INIT_BLIND,
    STATE_INIT_SUPERVISED,
    STATE_INVOKE_BLIND,
    STATE_INVOKE_SUPERVISED,
    STATE_TRANSFER_LAST = STATE_INVOKE_SUPERVISED
} transfer_states_e;

typedef enum states_e {
    /* Initial state */
    STATE_IDLE = STATE_TRANSFER_LAST + 1,
    STATE_NULL,
    .
    .
    .
    STATE_LAST = ...
} states_e;
</code></pre>

<p>Anything else is not going to work well when you need a new (transfer) state.  Of course, that will immediately change all previous values.  And if you claim your software will never change, I've got a bridge in Brooklyn to sell you.</p>
",0
7480838,7480697,3,"<p>There is no need to have enum values be unique across your project, unless a single address or variable might contain a value belonging to more than one enum. This is fairly unlikely, but it might be a sanity measure.</p>

<p>Enum values might be encoded in hex format for ease of debugging on projects that do network communication, as applications like Wireshark tend to show hexadecimal output. More likely, it is just the programmer's personal preference.</p>
",0
2597778,2597752,2,"<p>Usually libraries are versioned, not just ""the same name"".</p>

<p>You'll have a file in your <code>/usr/lib</code> directory for each version:</p>

<pre><code>/usr/lib/libFLAC.so.8.2.0
/usr/lib/libFLAC.so.8.2.1
/usr/lib/libFLAC.so.8.2.2
</code></pre>

<p>Then you symlink the major library versions to the latest minor version:</p>

<pre><code>/usr/lib/libFLAC.so.8 -&gt; /usr/lib/libFLAC.so.8.2.2
</code></pre>

<p>The benefit of this is that API changes will add new files and update the symlinks, but if I need to specify a specific API version number, the file is still right there.</p>

<p>This isn't set in stone, so do whatever works for your release process :)</p>
",3
2597781,2597752,1,"<p>Symlinks are a very good way to handle this.  I would do something slightly differently.  I would create a directory structure like:</p>

<pre><code>/usr/CSAPI/lib_v1
/usr/CSAPI/lib_v2
</code></pre>

<p>and in each of these I would put the actual files.  I would then create a separate directory:</p>

<pre><code>/usr/CSAPI/lib
</code></pre>

<p>which only contains symlinks to the actual files in <code>lib_v1</code>, <code>lib_v2</code>, etc.</p>

<p>This way <code>lib</code> has the most current version, but if you need, you can use a previous version by simply changing your LD_LIBRARY_PATH.</p>
",0
3706906,3706893,7,"<p>I would loop through an array of function pointers, call the functions in the loop, then if that function returned false, perform the corresponding <code>uninit_*</code> function.</p>

<p>Here's an example:</p>

<pre><code>void (*inits[5]) (void);
void (*uninits[4]) (void);

int main(void) {
   inits[0] = init_A;
   inits[1] = init_B;
   inits[2] = init_C;
   inits[3] = init_D;
   inits[4] = init_E;

   uninits[0] = uninit_A;
   uninits[1] = uninit_B;
   uninits[2] = uninit_C;
   uninits[3] = uninit_D;

   for(int i = 0; i &lt; 5; i++) {
      if((*inits[i])() != TRUE) {
         int j = (i &lt; 4) ? i : 4; 
         while(j--) {
             (*uninits[j])();
         }
         break;
      }
   }
   return 1;
}
</code></pre>
",5
3706919,3706893,24,"<pre><code>if(init_A() != TRUE) {
    goto EndA;
}
if(init_B() != TRUE) {
    goto EndB;
}
if(init_C() != TRUE) {
    goto EndC;
} 
if(init_D() != TRUE) {
    goto EndD;
}
if(init_E() != TRUE) {
    goto EndE;
} 
...
return;
EndE: uninitD();
EndD: uninitC();
EndC: uninitB();
EndB: uninitA();
EndA: return;
</code></pre>
",6
3706935,3706893,6,"<pre>
BOOL a = FALSE, b = FALSE, c = FALSE, d = FALSE, e = FALSE;

if ( (a = init_A())  &&  (b = init_B())  &&  (c = init_C())  && (d = init_D())  && (e = init_E()) )
{
}
else
{
    if ( e ) uninit_E();
    if ( d ) uninit_D();
    if ( c ) uninit_C();
    if ( b ) uninit_B();
    if ( a ) uninit_A();
}
</pre>

<p>uninit functions are called in direct order, as in your code. If reverse order is required, just change this.</p>
",3
3706948,3706893,4,"<p>If your <code>uninit_*</code> functions can detect whether or not they need to do anything you can simply:</p>

<pre><code>if (!init_A() || !init_B() || !init_C() || !init_D() )
{
  uninit_C();
  uninit_B();
  uninit_A();
  return FALSE;
}
</code></pre>
",1
3706963,3706893,8,"<p>This is quite a common problem, where the ""init"" steps correspond to things like <code>malloc()</code> or <code>lock()</code>, and the ""uninit"" steps correspond to things like <code>free()</code> and <code>unlock()</code>.  It is particularly an issue when resources have to be deallocated in strictly the reverse order in which they were allocated.</p>

<p>This is one case where the use of <code>goto</code> is justified:</p>

<pre><code>int somefunc()
{
    int retval = ERROR;

    if (init_A() != TRUE)
        goto out_a;

    if (init_B() != TRUE)
        goto out_b;

    if (init_C() != TRUE)
        goto out_c;

    if (init_D() != TRUE)
        goto out_d;

    if (init_E() != TRUE)
        goto out_e;

    /* ALL STARTED OK */
    /* ... normal processing here ... */
    retval = OK;

    uninit_E();
  out_e:
    uninit_D();
  out_d:
    uninit_C();
  out_c:
    uninit_B();
  out_b:
    uninit_A();
  out_a:
    return retval;
}
</code></pre>
",1
3707108,3706893,2,"<p>Limited understanding of C at work here, if you do decide to downvote, please tell me why.</p>

<pre><code>#include &lt;stdio.h&gt;

int init_a() { return 1; }; // succeed
int init_b() { return 1; }; // succeed
int init_c() { return 0; }; // fail

void uninit_a() { printf(""uninit_a()\n""); }
void uninit_b() { printf(""uninit_b()\n""); }
void uninit_c() { printf(""uninit_c()\n""); }

typedef struct _fp {
        int (*init)();
        void (*uninit)();
} fp;

int init() {
        fp fps[] = {
                (fp){&amp;init_a, &amp;uninit_a},
                (fp){&amp;init_b, &amp;uninit_b},
                (fp){&amp;init_c, &amp;uninit_c}
        };

        unsigned int i = 0, j;
        for(; i &lt; sizeof(fps) / sizeof(fp); ++i) {
                if(!(*fps[i].init)()) {
                        for(j = 0; j &lt; i; ++j) {
                                (*fps[j].uninit)();
                        }
                        return -1;
                }
        }
        return 0;
}

int main() {
        init();
        return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>uninit_a()
uninit_b()
</code></pre>

<p>This is the same order that the code in original post would be executed in, but you may want to reverse it (inner loop).</p>
",2
3707656,3706893,2,"<p>What you perhaps are looking for is <em>""scope bound resource management""</em>. C++ traditionally does that with constructors/destructors. But there is a way to do that differently (in C99 as well as in C++) by abusing the <code>for</code>-statement a bit. I wrote something up upon this line here: 
<a href=""https://gustedt.wordpress.com/2010/08/14/scope-bound-resource-management-with-for-scopes/"" rel=""nofollow noreferrer"">scope bound resource management with for scopes</a>. </p>
",0
3707141,3706893,1,"<p>I've not got a compiler to try this out. But something like this might work?</p>

<pre><code>int (*init[])() = {init_A, init_B, init_C, init_D, init_E};
int (*uninit[])() = {uninit_A, uninit_B, uninit_C, uninit_D, uninit_E};

int main()
{
  initfunction(init, 0)
  return 0;
}

void initfunction((*init[])(), pos)
{
  if(init[pos]() == TRUE)
    initfunction(init, pos++)
  else
    return;

  uninit[pos]();
}
</code></pre>
",1
3707150,3706893,4,"<p>Is that ""reverse order""? For me reverse order is like this:</p>

<pre><code>void uninit(int from) {
    switch (from) {
        /* ... */
        case 3: uninit_C(); /* fall_through */
        case 2: uninit_B(); /* fall_through */
        case 1: uninit_A(); /* fall_through */
        case 0: break;
    }
}
</code></pre>

<p>And the init process would go like this</p>

<pre><code>    int count = 0;
    if (init_A()) {
        count++;
        if (init_B()) {
            count++;
            if(init_C()) {
                count++;
                if(init_D()) {
                    count++;
                    if(init_E()) {
                        count++;
                    }
                }
            }
        }
    }
    if (count == 5) /* ALL OK */;
    uninit(count);
</code></pre>
",1
3712273,3706893,1,"<pre><code>int X = 0;
if(init_A() == TRUE) {
  X++;
  if(init_B() == TRUE) {
    X++;
    if(init_C() == TRUE) {
      X++;
      if(init_D() == TRUE) {
        X++;
        if(init_E() == TRUE) {
          X++;
          /* ALL STARTED OK */    
        }
      }
    }
  }
}

/* You said reverse order which I took to mean this,
 * though your did not do it this way. */
switch (X) {
  case 5:
      return SUCCESS;
  case 4:
    uninit_D();
  case 3:
    uninit_C();
  case 2:
    uninit_B();
  case 1:
    uninit_A();
    return FAILURE;
}
</code></pre>

<p>Something I find myself doing to prevent myself from making errors in code like this is:</p>

<pre><code>static int do_A(void);
static int do_B(void);
static int do_C(void);
static int do_D(void);

static int do_A(void) {
   if (init_A() == FALSE) {
      return FALSE;
   }
   if (do_B() == FALSE) {
      uninit_A();
      return FALSE;
   }
   return TRUE;
}    

...

static int do_D(void) {
    return init_D();
}
</code></pre>

<p>All of the other do_ functions should look similar to do_A.</p>
",0
2424259,2424228,3,"<pre><code>%*[^=]
</code></pre>

<p>The <code>[^=]</code> means match a string which contains no <code>=</code>. <del>This is a <a href=""http://www.opengroup.org/onlinepubs/9699919799/functions/fscanf.html"" rel=""nofollow noreferrer"">POSIX extension</a>.</del> The <code>*</code> means discard the matched result.</p>

<p>(BTW, to correctly get <code>chan</code> you need <code>sscanf(channels, ""%*[^=]= [%d]"", &amp;chan);</code>.)</p>
",1
2933850,2933725,1,"<p>There's always <a href=""http://en.wikipedia.org/wiki/Static_code_analysis"" rel=""nofollow noreferrer"">static code analysis</a>.
Edit: <a href=""http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis"" rel=""nofollow noreferrer"">List of tools for static code analysis</a></p>
",1
2933896,2933725,13,"<p>Although you could simply use another strlcpy function as another post recommends, or use <code>snprintf(dest, len, ""%s"", src)</code> (which always terminates the buffer), here are the things I noticed looking at your code:</p>

<pre><code>size_t s_strlcpy(char *dest, const char *src, const size_t len)
{
    size_t i = 0;
</code></pre>

<p>No need to make <code>len</code> const here, but it can be helpful since it checks to make sure you didn't modify it.</p>

<pre><code>    /* Always copy 1 less then the destination to make room for the nul */
    for(i = 0; i &lt; len - 1; i++)
    {
</code></pre>

<p>Oops.  What if len is 0?  <code>size_t</code> is usually unsigned, so (size_t)0 - 1 will end up becoming something like <code>4294967295</code>, causing your routine to careen through your program's memory and crash into an unmapped page.</p>

<pre><code>        /* only copy up to the first nul is reached */
        if(*src != '\0') {
            *dest++ = *src++;
        }
        else {
            break;
        }
    }

    /* nul terminate the string */
    *dest = '\0';
</code></pre>

<p>The above code looks fine to me.</p>

<pre><code>    /* Return the number of bytes copied */
    return i;
}
</code></pre>

<p>According to <a href=""http://en.wikipedia.org/wiki/Strlcpy"" rel=""nofollow noreferrer"">Wikipedia</a>, <code>strlcpy</code> returns <code>strlen(src)</code> (the actual length of the string), not the number of bytes copied.  Hence, you need to keep counting the characters in <code>src</code> until you hit <code>'\0'</code>, even if it exceeds <code>len</code>.</p>

<p>Also, if your for loop terminates on the <code>len - 1</code> condition, your function will return <code>len-1</code>, not len like you'd expect it to.</p>

<hr>

<p>When I write functions like this, I usually prefer to use a start pointer (call it S) and end pointer (call it E).  S points to the first character, while E points to one character <em>after</em> the last character (which makes it so E - S is the length of the string).  Although this technique may seem ugly and obscure, I've found it to be fairly robust.</p>

<p>Here's an over-commented version of how I would write strlcpy:</p>

<pre><code>size_t s_strlcpy(char *dest, const char *src, size_t len)
{
    char *d = dest;
    char *e = dest + len; /* end of destination buffer */
    const char *s = src;

    /* Insert characters into the destination buffer
       until we reach the end of the source string
       or the end of the destination buffer, whichever
       comes first. */
    while (*s != '\0' &amp;&amp; d &lt; e)
        *d++ = *s++;

    /* Terminate the destination buffer, being wary of the fact
       that len might be zero. */
    if (d &lt; e)        // If the destination buffer still has room.
        *d = 0;
    else if (len &gt; 0) // We ran out of room, so zero out the last char
                      // (if the destination buffer has any items at all).
        d[-1] = 0;

    /* Advance to the end of the source string. */
    while (*s != '\0')
        s++;

    /* Return the number of characters
       between *src and *s,
       including *src but not including *s . 
       This is the length of the source string. */
    return s - src;
}
</code></pre>
",3
2933733,2933725,2,"<p>Yes, unit testing. Check with lots of randomly generated strings.</p>

<p>Looks fine to me, though.</p>
",2
2933734,2933725,3,"<p>Why don't you use something like memccpy() instead of rolling your own?  You just have to terminate with a null byte, but it's easier and generally faster to augment a standard function than to start from scratch.</p>

<p>Some architectures will heavily optimize or even use assembly for string functions to squeeze good performance out of them.</p>

<p>Without building or debugging:</p>

<pre><code>str = memccpy (dest, src, '\0', len);
if(str)
    *str = '\0';
</code></pre>
",4
2933944,2933725,2,"<p>I would suggest that <a href=""http://en.wikipedia.org/wiki/White_box_testing"" rel=""nofollow noreferrer"">White-box testing</a> is useful for a function like this (a form of unit testing).</p>
",0
2934621,2933725,2,"<p>There is the DRY principle ""don't repeat yourself"".  In other words do not create new code to do something that is already a done deal - check in the standard C library as the example above (WhilrWind) shows.</p>

<p>One reason is the testing mentioned.  The standard C library has been tested for years, so it is a safe bet it works as advertised.</p>

<p>Learning by playing around with code is a great idea, keep on trying.</p>
",1
2934627,2933725,1,"<p>I think it's a mistake to rely so much on the length, and doing arithmetic on it.</p>

<p>The <code>size_t</code> type is unsigned. Consider how your function will behave if called with a 0-sized destination.</p>
",0
2934643,2933725,4,"<p>IMHO, just barrow the <a href=""http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libc/string/strlcpy.c?rev=1.11"" rel=""nofollow noreferrer"">original strlcpy</a>, which Ignacio Vazquez-Abram tersely stated. OpenBSDs code is battletested and the license terms rock ;).</p>

<p>As to your code, something I would add to what has already been said by others, is just a matter of personal taste:</p>

<pre><code>/* only copy up to the first nul is reached */
if(*src != '\0') {
    *dest++ = *src++;
}
else {
    break;
}
</code></pre>

<p>I would have written this like this:</p>

<pre><code>if(*src == '\0') {
    break;
}
*dest++ = *src++;
</code></pre>

<p>Both because it reduces on the amount of unnecessary code people need to read, and because it is my 'style' to consistently write that way, instead of <code>if (ok) { do } else { handle error }</code>. The comment above the if is also redundant (see comment above the for loop).</p>
",1
2934668,2933725,2,"<blockquote>
  <p>Unit testing?
  Is this good enough for production?</p>
</blockquote>

<p>Probably for a ""simple"" function like this it may be sufficient, although the only real way to test a function is to try and break it.</p>

<p>Pass to it NULL pointers, 10k character long strings, negative values of len, somehow corrupted data, and so on. In general think: if you were a malicious user trying to break it, how would you do that?</p>

<p>See the link in my response <a href=""https://stackoverflow.com/questions/2843394/why-should-i-be-using-testing-frameworks-in-php/2843414#2843414"">here</a></p>
",0
4430198,4430156,3,"<p>You cannot dynamically create new functions in C. Since it's a compiled language, and the compiler is not part of the standard runtime, all code must be statically defined at compile-time.</p>
",1
4430460,4430156,1,"<p>It looks like you're trying to do currying in C (cue clippy :-). I think this is technically possible in C. You're not trying to create new functions. You're trying to create alternative bindings to an existing function. It's pretty simple in C++, but without the syntactic sugar made possible by template metaprogramming (specifically functors and bindings), you would have to do all that stuff manually. Your other approach seems more reasonable.</p>
",0
4430476,4430156,4,"<p>You could basically emulate closures &amp; currying by instead of ""returning a function"" you return a struct that has the function pointer plus the bound variables. With a couple of #defines it may even look halfway sane.</p>

<p>OTOH, when you use a particular language, you should stick to its idioms. Closures are not the strong point of C. I suggest that you don't try to be overly generic in C code, if in doubt just use a switch(){}.</p>
",0
4430401,4430156,0,"<p>I'm guessing this function of yours would traverse a list of LEX_DFA_ARC_T and return the ""func"" member of a matching element?</p>

<p>There's no reason why that shouldn't work. After all a function pointer such as node_transition_func is still just a pointer. That said it may not be the best solution.</p>

<p>However I am a little confused as to whether my guess is correct because of the other things you say. Perhaps a little more context might help us answer you.</p>
",0
3865494,3865486,6,"<p>Bitwise inclusive or:</p>

<blockquote>
  <p>The bitwise-inclusive-OR operator compares each bit of its first operand to the corresponding bit of its second operand. If either bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.</p>
</blockquote>

<p><a href=""http://msdn.microsoft.com/en-us/library/17zwb64t.aspx"" rel=""nofollow"">Source</a>.</p>
",0
3865497,3865486,16,"<p>One bar by itself means ""bitwise OR""   (as opposed to the double bar which means ""Logical OR"")</p>

<pre><code> 1 | 1 == 1
 0 | 1 == 1
 1 | 0 == 1
 0 | 0 == 0
 true || true  == true
 false || true == true


 01 | 10 == 11
 01 || 10 == true
</code></pre>

<p>However, the vertical bars in your sample, as far as I can tell, are syntax errors.   It looks like the author is going for ""absolute value"", which would use vertical bars ¨C in writing or pseudo-code ¨C but not in any computer language I know of.</p>
",4
3865498,3865486,3,"<p>It is a <a href=""http://www.cprogramming.com/tutorial/bitwise_operators.html"" rel=""nofollow"">bitwise OR operator</a>. </p>
",0
3865525,3865486,16,"<pre><code>if (!pFCT-&gt;FBMap(| ( VBQNum - 1 ) / 8 |) &amp; (1 &lt;&lt; (7 - ( ( VBQNum - 1 ) % 8))))) { stuff }
/*              ^^^   syntax error   ^^^                               */
</code></pre>

<p>I guess whoever showed you the line in question meant absolute value</p>

<pre><code>if (!pFCT-&gt;FBMap(abs( ( VBQNum - 1 ) / 8 )) &amp; (1 &lt;&lt; (7 - ( ( VBQNum - 1 ) % 8))))) { stuff }
/*              ^^^^^^                  ^^^                            */
</code></pre>

<hr>

<p>Oh! A single vertical bar means <strong>bitwise or</strong>.</p>
",0
3865526,3865486,5,"<p>It is a bitwise OR.
Essentially it takes the two values and ORs each of the corresponding bits in their binary representations:</p>

<pre><code>10010001
01001010
--------
11011011
</code></pre>

<p>If either operand's bit is a 1, the answer's bit in that place is a one. If neither are 1s, the answer has a 0 there.</p>
",0
3865550,3865486,2,"<p>Dale said he knew it meant ""or"" with two operands.  His question is what it means when used as a unary operator.  Short answer is that it doesn't mean anything in C/C++.  </p>

<p>In some languages (like Verilog for coding hardware) this is an or-reduction, which result in a 1 if any bit is one.</p>

<p>So I think this is a syntax error unless the is something funny going on overloading the parentheses that I can't get my head around.  </p>
",0
3865693,3865486,1,"<p>Your code is not valid C, unless put in a specific (and quite artificial) context. Operator <code>|</code> is a binary operator. It is a bitwise-or, as you seem to know already. By itself, it cannot be used the way it is used in your code.</p>

<p>If one wanted to force this code to compile as C code, one'd probably have to define <code>FBMap</code> as a macro. Something like</p>

<pre><code>#define FBMap(x) something_else(abs(0 x 0))
</code></pre>

<p>thus trying to emulate the mathematical ""absolute value"" operator <code>| |</code>. Your call will expand into</p>

<pre><code>pFCT-&gt;something_else(abs(0 | ( VBQNum - 1 ) / 8 | 0))
</code></pre>

<p>thus making the application of <code>|</code> operator valid.</p>

<p>But even after that you'd need <code>something_else</code> to be a function pointer in that <code>*pFCT</code> struct, since the call looks awfully as a C++ method call. Your question is tagged C, so the only way to make it work in C is to introduce a function pointer member into the struct.</p>
",4
2270615,2270604,2,"<p>Yes, your interpretation is correct. Except that be careful with what you call ""acts like a global"". It acts like a global only in the sense that it retains values between calls, but it's not globally visible, but still only in the function that declared it.</p>

<p>Also see <a href=""https://stackoverflow.com/questions/572547/what-does-static-mean-in-a-c-program/572550#572550"">this question</a>.</p>
",1
2270616,2270604,4,"<p>If I understand your interpretation, it is accurate.</p>

<p>Inside a function static means ""<em>allocate data segment memory so the value persists between function calls and so that all function instances (think, recursion or threads) share the same actual storage</em>.""</p>

<p>This matters a lot if a previous value is used in a later function call or if a reference is leaked out of the function by an external call or by returning a pointer.</p>
",0
2270618,2270604,2,"<p>It doesn't make it a global.  Its still a local variable it just retains its value during successive calls.</p>
",0
2270621,2270604,1,"<p>That's correct.  One more aspect to keep in mind is that if your code is multi-threaded, all the threads will share the same copy of the variable, so it is technically possible that the original designer used that variable as a cross-thread communication mechanism.  I don't advocate that technique, but I can't rule it out without more information.</p>
",2
4095858,4095733,3,"<p><code>State</code> by itself is not a valid identifier in your snippet.</p>

<p>You need <code>enum State</code> or to typedef the <code>enum State</code> to another name.</p>

<pre><code>enum State {
    IDLE_ST,
    START_ST,
    RUNNING_ST,
    STOPPED_ST,
};

/* State g_current_state = State.IDLE_ST; */
/* no State here either ---^^^^^^         */
enum State g_current_state = IDLE_ST;
</code></pre>

<p>/* or */</p>

<pre><code>typedef enum State TypedefState;
TypedefState variable = IDLE_ST;
</code></pre>
",0
4095896,4095733,19,"<p>There are two ways to do this in straight C. Either use the full <code>enum</code> name everywhere:</p>

<pre><code>enum State {
    IDLE_ST,
    START_ST,
    RUNNING_ST,
    STOPPED_ST,
};
enum State g_current_state = IDLE_ST;
</code></pre>

<p>or (this is my preference) <code>typedef</code> it:</p>

<pre><code>typedef enum {
    IDLE_ST,
    START_ST,
    RUNNING_ST,
    STOPPED_ST,
} State;
State g_current_state = IDLE_ST;
</code></pre>

<p>I prefer the second one since it makes the type look like a first class one like <code>int</code>.</p>
",0
4095897,4095733,2,"<p>So there are 2 problems:</p>

<ol>
<li>Missing <code>;</code> after <code>enum</code> definition.</li>
<li>When declaring the variable, use <code>enum State</code> instead of simply <code>State</code>.</li>
</ol>

<p>This works:</p>

<pre><code>enum State {
    IDLE_ST,
    START_ST,
    RUNNING_ST,
    STOPPED_ST,
};

enum State g_current_state;
</code></pre>
",0
4095747,4095733,2,"<p>Missing semicolon after the closing brace of the <code>enum</code>. By the way, I really do not understand why missing semicolon errors are so cryptic in gcc.</p>
",1
2420799,2420780,19,"<p><code>\xXX</code> is the syntax for inserting characters in hex format. so yours would be:</p>

<pre><code>strncpy( ptr, ""\x63\x61\x74"", 100 - 1);
</code></pre>

<p>You don't need to put in a <code>\x00</code> since having quotes automatically null-delimits the string.</p>
",0
2420802,2420780,2,"<pre><code>strncpy( ptr, ""\x63\x61"" , 100 - 1 );
</code></pre>

<p><code>0x63</code> is an integer hexadecimal literal; The C compiler parses it as such within code. But within a string it is interpreted as a sequence of characters <code>0,x,6,3</code>.
The literal for the <code>char</code> with value 63 hex. is <code>'\x63'</code>, and within strings you must use this notation.
<code>""c\x63""</code> is the literal for a <em>zero-terminated</em> string, irrespective of the characters within the quotes (or of the notation by which you denote them), so no, you don't need to append a trailing zero manually.</p>
",0
2420939,2420780,6,"<p>Note, you only need \ inside the "" "" string</p>

<pre><code>char cat[4];
cat[0] = 0x63;
cat[1] = 0x61;
cat[2] = 0x74;
car[3] = 0x00;

char cat[] = ""\x63\x61\x74""; // note the \0 is added for you

char cat[] = { 0x63, 0x61, 0x74, 0x00 };
</code></pre>

<p>Are all the same</p>
",3
2437874,2437849,0,"<p>Store 01011 first. You'll get value 00001011. Then when you want to store three more bits, perform a left shift by three positions (you'll get 01011000) and make OR with 00000101, you'll get 01011101. However, doing it this way you have to know definitely that you had only five bits filled after first assignment. </p>
",0
2437879,2437849,0,"<p>Obviously, you'll need to resize the array as it grows. Dynamic memory allocation/reallocation is a way to go, probably. Pay attention to choosing a right reallocation strategy.</p>

<p>Apart from that, you may want to look at C++ STL containers if you are not limited only to C.</p>
",0
2442670,2437849,0,"<p>You should write an abstract data type called <code>bitstream</code> for this purpose. It could have the following interface:</p>

<p>This is file <code>bitstream.h</code>:</p>

<pre>
#ifndef BITSTREAM_H
#define BITSTREAM_H

typedef struct bitstream_impl bitstream;
struct bitstream_impl;

/**
 * Creates a bit stream and allocates memory for it. Later, that memory
 * must be freed by calling bitstream_free().
 */
extern bitstream *bitstream_new();

/**
 * Writes the lower 'bits' bits from the 'value' into the stream, starting with
 * the least significand bit (""little endian"").
 *
 * Returns nonzero if the writing was successful, and zero if the writing failed.
 */
extern int bitstream_writebits_le(bitstream *bs, unsigned int value, unsigned int bits);

/**
 * Writes the lower 'bits' bits from the 'value' into the stream, starting with
 * the most significand bit (""big endian"").
 *
 * Returns nonzero if the writing was successful, and zero if the writing failed.
 */
extern int bitstream_writebits_be(bitstream *bs, unsigned int value, unsigned int bits);

/**
 * Returns a pointer to the buffer of the bitstream.
 *
 * The returned pointer remains valid until the next time that one of the
 * bitstream_write* functions is called. The returned buffer must not be
 * modified. All bits in the buffer that have not yet been written are zero.
 * (This applies only to the last byte of the buffer.) Each byte of the buffer
 * contains at most 8 bits of data, even if CHAR_BITS is larger.
 */
extern unsigned char *bitstream_getbuffer(const bitstream *bs);

/**
 * Returns the number of bits that have been written to the stream so far.
 */
extern unsigned int bitstream_getsize(const bitstream *bs);

/**
 * Frees all the memory that is associated with this bitstream.
 */
extern void bitstream_free(bitstream *bs);

#endif
</pre>

<p>Then you need to write an implementation for this interface. It should be in a file called <code>bitstream.c</code>. This is left as an excercise.</p>

<p>To use the bitstream should then be pretty simple:</p>

<pre>
#include ""bitstream.h""

static void
die(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

int main(void)
{
    bitstream *bs;
    unsigned char *buf;

    bs = bitstream_new();
    if (bs == NULL)
        die(""bitstream_new"");

    if (!bitstream_writebits_be(bs, 0x000b, 5))
        die(""write 5 bits"");

    if (!bitstream_writebits_be(bs, 0x0005, 3))
        die(""write 3 bits"");

    if (bitstream_getsize(bs) != 8)
        die(""FAIL: didn't write exactly 8 bits."");

    buf = bitstream_getbuffer(bs);
    if (buf[0] != 0x005dU)
        die(""FAIL: didn't write the expected bits."");

    bitstream_free(bs);
    return 0;
}
</pre>
",0
7477879,1961173,9,"<p><strong>Conventional Method:</strong> (not recommended if you are working on image processing)</p>

<pre><code>/* median through qsort example */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ELEMENTS 6

int values[] = { 40, 10, 100, 90, 20, 25 };

int compare (const void * a, const void * b)
{
  return ( *(int*)a - *(int*)b );
}

int main ()
{
  int n;
  qsort (values, ELEMENTS, sizeof(int), compare);
  for (n=0; n&lt;ELEMENTS; n++)
  {   printf (""%d "",values[n]); }
  printf (""median=%d "",values[ELEMENTS/2]);
  return 0;
}
</code></pre>

<p>However, are two functions to calculate median the fastest way without sorting the array of candidates. The following are at least 600% faster than conventional ways to calculate median. Unfortunately they are not a part of C standard Library or C++ STL.</p>

<p><strong>Faster Methods:</strong></p>

<pre><code>//===================== Method 1: =============================================
//Algorithm from N. Wirth¡¯s book Algorithms + data structures = programs of 1976    

typedef int_fast16_t elem_type ;

#ifndef ELEM_SWAP(a,b)
#define ELEM_SWAP(a,b) { register elem_type t=(a);(a)=(b);(b)=t; }

elem_type kth_smallest(elem_type a[], uint16_t n, uint16_t k)
{
    uint64_t i,j,l,m ;
    elem_type x ;
    l=0 ; m=n-1 ;
    while (l&lt;m) {
    x=a[k] ;
    i=l ;
    j=m ;
    do {
    while (a[i]&lt;x) i++ ;
    while (x&lt;a[j]) j-- ;
    if (i&lt;=j) {
    ELEM_SWAP(a[i],a[j]) ;
    i++ ; j-- ;
    }
    } while (i&lt;=j) ;
    if (j&lt;k) l=i ;
    if (k&lt;i) m=j ;
    }
    return a[k] ;
}

    #define wirth_median(a,n) kth_smallest(a,n,(((n)&amp;1)?((n)/2):(((n)/2)-1)))

//===================== Method 2: =============================================
//This is the faster median determination method.
//Algorithm from Numerical recipes in C of 1992

elem_type quick_select_median(elem_type arr[], uint16_t n)
{
    uint16_t low, high ;
    uint16_t median;
    uint16_t middle, ll, hh;
    low = 0 ; high = n-1 ; median = (low + high) / 2;
    for (;;) {
    if (high &lt;= low) /* One element only */
    return arr[median] ;
    if (high == low + 1) { /* Two elements only */
    if (arr[low] &gt; arr[high])
    ELEM_SWAP(arr[low], arr[high]) ;
    return arr[median] ;
    }
    /* Find median of low, middle and high items; swap into position low */
    middle = (low + high) / 2;
    if (arr[middle] &gt; arr[high])
    ELEM_SWAP(arr[middle], arr[high]) ;
    if (arr[low] &gt; arr[high])
    ELEM_SWAP(arr[low], arr[high]) ;
    if (arr[middle] &gt; arr[low])
    ELEM_SWAP(arr[middle], arr[low]) ;
    /* Swap low item (now in position middle) into position (low+1) */
    ELEM_SWAP(arr[middle], arr[low+1]) ;
    /* Nibble from each end towards middle, swapping items when stuck */
    ll = low + 1;
    hh = high;
    for (;;) {
    do ll++; while (arr[low] &gt; arr[ll]) ;
    do hh--; while (arr[hh] &gt; arr[low]) ;
    if (hh &lt; ll)
    break;
    ELEM_SWAP(arr[ll], arr[hh]) ;
    }
    /* Swap middle item (in position low) back into correct position */
    ELEM_SWAP(arr[low], arr[hh]) ;
    /* Re-set active partition */
    if (hh &lt;= median)
    low = ll;
    if (hh &gt;= median)
    high = hh - 1;
    }
    return arr[median] ;
}
#endif
</code></pre>

<p>In C++ I make these <strong>templated functions</strong> and if the numbers are increasing or decreasing (one direction) for such functions use <strong>int8_fast_t; int16_fast_t; int32_fast_t; int64_fast_t; uint8_fast_t; uint16_fast_t; types instead of regular [stdint.h] types (e.g. uint16_t; uint32_t, etc)</strong> </p>
",1
6344261,6344192,8,"<pre><code>k = 0;
max = array[k];

for (i = 0; i &lt; N * N; ++i)
{
    if (array[i] &gt; max)
    {
        max = (int)array[i];
        k = i;
    }
}
</code></pre>

<p>Should work !</p>
",3
3918485,3918229,5,"<pre><code>static void rotate_left(uint8_t *d, uint8_t *s, uint8_t bits)
{
   const uint8_t octetshifts = bits / 8;
   const uint8_t bitshift = bits % 8;
   const uint8_t bitsleft = (8 - bitshift);
   const uint8_t lm = (1 &lt;&lt; bitshift) - 1;
   const uint8_t um = ~lm;
   int i;

   for (i = 0; i &lt; 4; i++)
   {
       d[(i + 4 - octetshifts) % 4] =
           ((s[i] &lt;&lt; bitshift) &amp; um) | 
           ((s[(i + 1) % 4] &gt;&gt; bitsleft) &amp; lm);
   }
}   
</code></pre>

<p>Obviously</p>
",2
3918281,3918229,1,"<p>While keeping in mind plain C the best way is</p>

<pre><code>inline void circular_left_shift(char *chars, short shift) {
    __int32 *dword = (__int32 *)chars;
    *dword = (*dword &lt;&lt; shift) | (*dword &gt;&gt; (32 - shift));
}
</code></pre>

<p>Uhmm, <code>char</code> is 16 bits long, was not clear for me. I presume <code>int</code> is still 32 bit.</p>

<pre><code>inline void circular_left_shift(char *chars, short shift) {
    int i, part;
    part = chars[0] &gt;&gt; (16 - shift);
    for (i = 0; i &lt; 3; ++i)
        chars[i] = (chars[i] &lt;&lt; shift) | (chars[i + 1] &gt;&gt; (16 - shift));
    chars[3] = (chars[3] &lt;&lt; shift) | part;
}
</code></pre>

<p>Or you could just unwind this cycle.</p>

<p>You could dig further into asm instruction <code>ror</code>, on x86 it's capable of performing such shift up to 31 bits left. Something like a</p>

<pre><code>MOV CL, 31
ROR EAX, CL
</code></pre>
",3
3918309,3918229,-1,"<p>Use <code>union</code>:</p>

<pre><code>typedef union chr_int{
   unsigned int  i;
   unsigned char c[4];
};
</code></pre>

<p>It's safer (because of pointer aliasing) and easier to manipulate.</p>

<p>EDIT: you should have mention earlier that your char isn't 8 bits. However, this should do the trick:</p>

<pre><code>#define ORIG_MASK 0x81010102
#define LS_CNT 1

unsigned char a[4] = { 
    ((ORIG_MASK &lt;&lt;  LS_CNT      ) | (ORIG_MASK &gt;&gt; (32 - LS_CNT))) &amp; 0xff,
    ((ORIG_MASK &lt;&lt; (LS_CNT +  8)) | (ORIG_MASK &gt;&gt; (24 - LS_CNT))) &amp; 0xff,
    ((ORIG_MASK &lt;&lt;  LS_CNT + 16)) | (ORIG_MASK &gt;&gt; (16 - LS_CNT))) &amp; 0xff,
    ((ORIG_MASK &lt;&lt; (LS_CNT + 24)) | (ORIG_MASK &gt;&gt; ( 8 - LS_CNT))) &amp; 0xff
};
</code></pre>
",3
2078124,2078112,7,"<p>The type is not standard, but is supported on your compiler.</p>

<p>Symbols that begin with an underscore or contain two underscores are reserved by the standard for your compiler's implementation.</p>

<p>See <a href=""https://stackoverflow.com/questions/224397/why-do-people-use-double-underscore-so-much-in-c"">Why do people use __(double underscore) so much in C++</a> (The question is about C++ but the reason is the same)</p>
",2
3061529,3061508,6,"<p>Why not:</p>

<pre><code>if (!*pos) 
  return NULL;
if ((*pos)-&gt;flags == FLAGS)
  return blah;
</code></pre>

<p>The original code (comments removed) is:</p>

<pre><code>if (!pos)
    return NULL;
if (!*pos)
    return BIO_new(BIO_s_null());
if (!*pos || ((*pos)-&gt;flags == ASN1_STRING_FLAG_CONT))
    return BIO_new(BIO_s_mem());
return BIO_new_mem_buf((*pos)-&gt;data, (*pos)-&gt;length);
</code></pre>

<p>If the tests were for some dubious security reason, shouldn't the third test be:</p>

<pre><code>if ( pos &amp;&amp; *pos &amp;&amp; ((*pos)-&gt;flags == ASN1_STRING_FLAG_CONT))
</code></pre>

<p>which of course gets ridiculous the further into the function you get. Also, a cursory inspection reveals  that this style is not used elsewhere in the file, so I think we can write this off to a minor programmers boo-boo.  </p>
",3
3061558,3061508,2,"<p>Ignoring the first two lines of each which make the test redundant, the two forms don't do the same thing.</p>

<pre><code>if (!*pos || ((*pos)-&gt;flags == FLAGS))
   // reached if *pos is NULL or the flags are set
   return blah;

if (*pos &amp;&amp; ((*pos)-&gt;flags == FLAGS))
   // reached if *pos is not NULL and the flags are set 
   return blah;
</code></pre>

<p>The || form would cause the function to return blah if it was reached with *pos is NULL.</p>

<p>(since the code follows a statement which makes the function return NULL if *pos is NULL the test is probably redundant, assuming pos points at normal memory rather than a volatile) </p>
",1
3061577,3061508,2,"<p>Seems like the first line obsoletes the first condition of the second, but it's still a good practice to leave checks for not-null before dereferencing, in case earlier code is ever removed, or if code that modifies pos (sets it to NULL) is ever placed between these sections. (one significant disadvantage of <code>return</code> in the middle of a function here...) </p>

<p>Other than that, there should be no difference with any optimizing compiler, but the code may convey the idea better: <code>return blah</code> either if *pos is NULL, or if flags are FLAGS; despite earlier condition that singles out pos==NULL, in this place of execution logic may allow it to be NULL as well and perform the return as described instead of skipping this place.</p>

<p>Imagine:</p>

<pre><code> if (!*pos)
   return NULL;

  /* code added later here */
  if(foo) 
    pos = baz;   // added latter; baz can be NULL
  /* more code... */

 if (!*pos || ((*pos)-&gt;flags == FLAGS))
   return blah;
</code></pre>

<p>This will still behave correctly, control returned if pos==NULL, only different return.</p>

<p>Any change to the later condition will modify the behavior:</p>

<pre><code> if (*pos &amp;&amp; ((*pos)-&gt;flags == FLAGS))
   return blah;
 crash();
</code></pre>
",4
3062123,3061508,1,"<p>Seeing such a code, efficiency is not the right question
to ask.
I don't like either of the versions. I'd go for</p>

<pre>
if (!*pos)
  return NULL;
else if((*pos)->flags == FLAGS)
  return blah;
</pre>

<p>Clean, unambiguous, efficient.</p>
",0
3940264,3940253,9,"<p><code>sizeof(length)</code> goes in the field. </p>

<p>It is preferable over using <code>sizeof(int)</code> in case you ever change the type of <code>length</code> in the future.</p>

<p><code>sizeof</code> expresses the, well, size of a data type in multiples of <code>sizeof(char)</code>, which is always 1.</p>
",8
3940269,3940253,2,"<p>sizeof is your friend.</p>

<pre><code>write(fd, &amp;length, sizeof(int));
</code></pre>
",0
3940313,3940253,2,"<p>sizeof(int)  = 4 (on Linux, 32 &amp; 64 Bit x86-Architecture)<br />
sizeof(long) is 4 on 32 Bit, 8 on 64 Bit (on Linux, x86-32/64-Architecture)<br />
Dunno about Windows.<br /></p>
",4
3940315,3940253,0,"<pre><code>write(fd, &amp;length, sizeof(length));
</code></pre>

<p>You can use <code>sizeof</code> with variable names or type names. In this case you could have done <code>sizeof(int)</code>. </p>

<p>The <code>write</code> function takes the address of the memory zone you want to write, so you use the <code>&amp;</code> (address of) operator. You don't have to do it for the string because you already have a pointer (<code>char*</code>).</p>
",0
7179200,7179174,9,"<p>Comparison is unsupported for the same reason <code>memcmp</code> fails.</p>
<p>Due to padding fields the comparison would fail in unpredictable ways which would be unacceptable for most programmers. Assignment changes the invisible padding fields, but these are invisible anyway, so nothing unexpected there.</p>
<p>Obviously, you may ask: so why doesn't it just zero-fill all the padding fields ? Sure that would work but it would also make all programs pay for something they might not need.</p>
<h3>EDIT</h3>
<p><a href=""https://stackoverflow.com/users/129570/oli-charlesworth"">Oli Charlesworth</a> notes in the comments that you may be asking: &quot;why doesn't the compiler generate code for member-by-member comparison&quot;. If that is the case, I must confess: <strong>I don't know</strong> :-). The compiler would have all the needed information if it would only allow comparing complete types.</p>
",5
7179506,7179174,5,"<p>Auto-generate comparison operator is bad idea. Imagine how comparison would work for this structure:</p>

<pre><code>struct s1 {
   int len;
   char str[100];
};
</code></pre>

<p>This is pascal like string with maximum length 100</p>

<p>Another case</p>

<pre><code>struct s2 {
   char a[100];
}
</code></pre>

<p>How can the compiler know how to compare a field? If this is a NUL-terminated string, the  compiler must use strcmp or strncmp. If this is char array compiler must use memcmp.</p>
",6
3179742,3179645,51,"<p>If you're after the difference between the two, just think of them as:</p>

<ul>
<li><strong>char*</strong> is a pointer that points to a location containing a value of type char that can also be changed. The pointer's value can be changed, i.e. the pointer can be modified to point to different locations.</li>
<li><strong>const char*</strong> is a pointer, whose value can be also changed, that points to a location containing a value of type char that <strong>cannot</strong> be changed.</li>
</ul>
",6
3179770,3179645,27,"<p><code>const char *</code> means ""pointer to an unmodifiable character."" It's usually used for strings of characters that shouldn't be modified.</p>

<p>Say you're writing this function:</p>

<pre><code>int checkForMatch(const char * pstr)
</code></pre>

<p>You've promised (through the function signature) that you <em>will not change</em> the thing pointed to by <code>pstr</code>. Now say part of checking for a match would involve ignore the case of letters, and you tried to do it by converting the string to upper case before doing your other checks:</p>

<pre><code>strupr(pstr);
</code></pre>

<p>You'll get an error saying you can't do that, because <code>strupr</code> is declared as:</p>

<pre><code>char * strupr(char* str);
</code></pre>

<p>...and that means it wants to be able to write to the string. You can't write to the characters in a <code>const char *</code> (that's what the <code>const</code> is for).</p>

<p>In general, you can pass a <code>char *</code> into something that expects a <code>const char *</code> without an explicit cast because that's a safe thing to do (give something modifiable to something that doesn't intend to modify it), but you <em>can't</em> pass a <code>const char *</code> into something expecting a <code>char *</code> (without an explicit cast) because that's not a safe thing to do (passing something that isn't meant to be modified into something that may modify it).</p>

<p>Of course, this is C, and you can do just about anything in C, including explicitly casting a <code>const char *</code> to a <code>char *</code>&nbsp;&mdash; but that would be a really, <strong><em>really bad idea</em></strong> because there is (presumably) some reason that the thing being pointed to by the pointer is <code>const</code>.</p>
",19
3179886,3179645,1,"<p>Probably I'm too picky. In my book, the character(s) pointed to by a const char* can possibly be changed but not via the const char*. A const char * can point to modifiable storage. Example:</p>

<pre><code>char a[] = ""abracadabra"";
const char * ccp = &amp;a[0]; // ccp points to modifiable storage.
*&amp;a[0] = 'o'; // This writes to a location pointed to by const char* ccp
</code></pre>

<p>So, my wording is:</p>

<p>A char * is a pointer that be changed and that also allows writing through it when dereferenced via * or [].</p>

<p>A const char * is a pointer that be changed and that does not allow writing through it when dereferenced via * or [].</p>
",2
1997604,1997587,0,"<pre><code>int isnumeric( char *str )
{
    double d;
    return sscanf(str, ""%lf"", &amp;d);
}
</code></pre>
",1
1997606,1997587,13,"<p>This should do it.  It converts the string to floating point using <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/strtod/"" rel=""noreferrer"">strtod</a> and checks to see if there is any more input after it.</p>

<pre><code>int isfloat (const char *s)
{
     char *ep = NULL;
     double f = strtod (s, &amp;ep);

     if (!ep  ||  *ep)
         return false;  // has non-floating digits after number, if any

     return true;
}
</code></pre>

<p>To distinguish between <code>float</code>s and <code>int</code>s is trickier.  A regex is one way to go, but we could just check for floating chars:</p>

<pre><code>int isfloat (const char *s)
{
     char *ep = NULL;
     long i = strtol (s, &amp;ep);

     if (!*ep)
         return false;  // it's an int

     if (*ep == 'e'  ||
         *ep == 'E'  ||
         *ep == '.')
         return true;

     return false;  // it not a float, but there's more stuff after it
}
</code></pre>

<p>Of course, a more streamlined way to do this is to return the type of the value and the value together.</p>
",4
1997853,1997587,0,"<p>If your goal is to find the data type a given string can fit in, you can do something like this:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;float.h&gt;
#include &lt;limits.h&gt;
#include &lt;errno.h&gt;
#include &lt;math.h&gt;

/* If a floating-point number is +/- F_EPS from an integer,
   consider it to be an integer */
#define F_EPS 1e-7

enum datatype {
    TYPE_INT,
    TYPE_LONG,
    TYPE_FLOAT,
    TYPE_DOUBLE,
    TYPE_INVALID
};

enum datatype findtype(const char *s)
{
    char *eptr;
    double d;
    double diff;

    errno = 0;

    d = strtod(s, &amp;eptr);
    if ((d == 0 &amp;&amp; eptr == s) || errno == ERANGE)
        return TYPE_INVALID;

    diff = d - floor(d+0.5);
    if (d &lt;= INT_MAX &amp;&amp; d &gt;= INT_MIN &amp;&amp; diff &lt;= F_EPS)
        return TYPE_INT;

    if (d &lt;= LONG_MAX &amp;&amp; d &gt;= LONG_MIN &amp;&amp; diff &lt;= F_EPS)
        return TYPE_LONG;

    if ((d &gt; 0 &amp;&amp; (d &gt; FLT_MAX || d &lt; FLT_MIN))
                || (d &lt; 0 &amp;&amp; (d &lt; -FLT_MAX || d &gt; -FLT_MIN)))
        return TYPE_FLOAT;

    return TYPE_DOUBLE;
}
</code></pre>

<p>The idea is that you read the number as a <code>double</code>, and then check to see if it is in the range for different types.  You can change <code>F_EPS</code> above to control the tolerance.</p>
",0
3074760,3074755,4,"<p>It sounds like you want it as a numeric type, which is going to be difficult (it's too large to fit in an int or a long). In theory you could just do:</p>

<pre><code>const char* original = ""sip:12387654345443222118765@xxx.xxx.xxx.xxx"";
long num = strtoul(original + 4, NULL, 10);
</code></pre>

<p>but it will overflow and <code>strtoul</code> will return -1. If you want it as a string and you know it's always going to be that exact length, you can just pull out the substring with <code>strcpy</code>/<code>strncpy</code>:</p>

<pre><code>const char* original = ""sip:12387654345443222118765@xxx.xxx.xxx.xxx"";
char num[24];
strncpy(num, original + 4, 23);
num[23] = 0;
</code></pre>

<p>If you don't know it's going to be 23 characters long every time, you'll need to find the @ sign in the original string first:</p>

<pre><code>unsigned int num_length = strchr(original, '@') - (original + 4);
char* num = malloc(num_length + 1);
strncpy(num, original + 4, num_length);
num[num_length] = 0;
</code></pre>
",7
3074767,3074755,1,"<p>Have a look into the strtok or strtok_r functions.</p>
",3
3074769,3074755,2,"<p>Use a regular expression :)</p>

<pre><code>#include &lt;regex.h&gt;
regcomp() // compile your regex
regexec() // run your regex
regfree() // free your regex
</code></pre>

<p>:)</p>
",5
3074782,3074755,5,"<p>There are lots of ways to do it, if the string is well-formatted you could use <code>strchr()</code> to search for the <code>:</code> and use <code>strchr()</code> again to search for the <code>@</code> and take everything in between.</p>

<p>Here is another method that looks for a continuous sequence of digits:</p>

<pre><code>char *start = sipStr + strcspn(sipStr, ""0123456789"");
int len = strspn(start, ""0123456789"");

char *copy = malloc(len + 1);

memcpy(copy, start, len);
copy[len] = '\0'; //add null terminator

...
//don't forget to
free(copy);
</code></pre>
",0
3074896,3074755,1,"<p>Here is something that will deal with a variable width substring, which doesn't care about the starting position of the substring. For instance, if string was <code>iax2:xxx@xx.xx.xx.xx</code>, it would still work. It will, however return NULL if either delimiter can't be found.</p>

<p>It uses <code>strchr()</code> to find the delimiters, which lets us know where to start copying and where to stop. It returns an allocated string, the calling function must <code>free()</code> the returned pointer.</p>

<p>I'm pretty sure this is what you want?</p>

<p><strong>Note: Edited from original to be more re-usable and a bit saner.</strong></p>

<pre><code>#include &lt;stdio.h&gt;                                                                              
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char *extract_string(const char *str, const char s1, const char s2)
{
    char *ret = NULL, *pos1 = NULL, *pos2 = NULL;
    size_t len;

    if (str == NULL || s1 &lt; 0 || s2 &lt; 0)
        return NULL;

    pos1 = strchr(str, s1);
    pos2 = strchr(str, s2);
    if (! pos1 || ! pos2)
        return NULL;

    len = ((pos2 - str) - (pos1 - str) - 1);
    ret = (char *) malloc(len + 1);
    if (ret == NULL)
        return NULL;

    memcpy(ret, str + (pos1 - str) + 1, len);
    ret[len] = '\0';

    return ret;
}

int main(void)
{
    const char *string = ""sip:12387654345443222118765@xxx.xxx.xxx.xxx"";
    char *buff = NULL;

    buff = extract_string(string, ':', '@');
    if (buff == NULL)
        return 1;

    printf(""The string extracted from %s is %s\n"" , string, buff);

    free(buff);

    return 0;
}
</code></pre>

<p>You could easily modify that to not care if the second delimiter is not found and just copy everything to the right of the first. That's an exercise for the reader.</p>
",0
3187169,3187149,5,"<p>No, since the stream used in C doesn't maintain state the way the stream object does.</p>

<p>You need to specify with e.g. <code>printf()</code> using a suitable formatting code.</p>
",1
3187185,3187149,22,"<p><code>printf (""%5d"", 42);</code></p>

<p>Will print 42 using 5 spaces. Read the man pages of printf to understand how character padding, overflow and other nuances work.</p>

<p>EDIT:
Some examples -</p>

<pre><code>int x = 4000;
printf (""1234567890\n"");
printf (""%05d\n"", x);
printf (""%d\n"", x);
printf (""%5d\n"", x);
printf (""%2d\n"", x);
</code></pre>

<p>Gives the output</p>

<pre><code>1234567890
04000
4000
 4000
4000
</code></pre>

<p>Notice that the <code>%2d</code> was too small to handle the number passed to it, yet still printed the entire value.</p>
",2
3188405,3187149,3,"<p>Another option is to define the format string as a variable:  </p>

<pre><code>char print_format[] = ""%5d""; printf(print_format, 42);
</code></pre>

<p>The above is similar to C++ <code>setw</code>, in that you can set the contents of the variable before printing.  Many occasions require dynamic formatting of the output.  This is one method to achieve it.</p>
",0
3231665,3231639,5,"<p>By writing <code>bla++</code>, you're changing <code>bla</code> to point to the next pointer.</p>

<p>At the end, <code>bla[0]</code> (which is equivalent to <code>*bla</code>) has been incremented 10 times and will point the memory location immediately after the allocated block.</p>

<p>You could fix this by writing <code>bla -= 10</code> after the loop.</p>

<p>However, the best way to fix it is to not increment <code>bla</code> at all, and instead write </p>

<pre><code> *(bla + i) = calloc(10,sizeof(char));
</code></pre>

<p>Alternatively, you could declare a second pointer (<code>char** currentBlah = blah</code>) and increment it instead, then print <code>blah[0]</code>, which will still point to the original memory location.</p>
",3
3231668,3231639,1,"<p>The problem is that your allocation loop uses <code>bla</code> to iterate through the array of pointers, so at the end of that loop, <code>bla</code> points to just after the end of the array rather than the beginning.  You need a loop like:</p>

<pre><code>for (p=bla; p &lt; bla+size; p++) { 
        *p = calloc(size, sizeof(char)); 
        strncpy(*p, ""aaaaa"", size); 
} 
</code></pre>
",0
3231672,3231639,0,"<p>The problem is that in the first case you've moved the bla pointer past the end of the array (the last bla++) so when you access the first you are actually accessing past the last</p>
",0
2911183,2910826,1,"<p>Consider this file (Export_Macro.h)</p>

<pre><code>#ifndef EXPORT_MACRO_H
#define EXPORT_MACRO_H

#ifdef _WINDOWS
    #ifdef I_WANT_TO_EXPORT_MACROS
        #define EXPORT_MACRO __declspec(dllexport)
    #else
        #define EXPORT_MACRO __declspec(dllimport)
    #endif
#else
    #define EXPORT_MACRO
#endif

#endif // EXPORT_MACRO_H
</code></pre>

<p>In your source code do this:</p>

<pre><code>#include ""Export_Macro.h""
...
// for functions you want to export outside the DLL (Dynamic Link Library)/so (Shared Object)
EXPORT_MACRO void printHello( char * text);
</code></pre>

<p>This works for me pretty well.</p>

<p>A more complete explanation and export macro you can find <a href=""http://gcc.gnu.org/wiki/Visibility"" rel=""nofollow noreferrer"">here</a>.</p>

<p><strong>Later edit:</strong> This should work in Unix and Windows without any big problems.</p>
",3
2910886,2910826,1,"<p>Ideally, if you don't want users calling the <code>printHi()</code> function, it should not be visible to them.  If that's not feasible, use a convention to indicate which names are intended to be called by the user and which are not.  Classically, that is done with leading underscores, but that can lead to various conflicts.  So, if you have a naming convention for your library, you might use <code>pfx_GlobalName()</code> for documented, user-callable functions and <code>pfxInternalName()</code> for undocumented functions, or the reverse, or some faintly similar convention.  You can then simply tell users that direct calls to the undocumented functions are not supported and any use of them is liable to break at a future release (or the function may be renamed or whatever).  And occasionally make changes to make it clear that you mean what you say.</p>

<p>So, if the hidden function can fit in the same source module as the public functions that are documented, do hide them.  If you can't, use a naming convention to indicate that the hidden functions are not for end-user use.</p>

<p>You can control the visibility of symbols with symbol maps and things with GCC; it is fiddly, though.</p>
",1
2910891,2910826,5,"<p>You can use two separate header files:</p>

<p>In <code>libprinthello.h</code>:</p>

<pre><code>#ifndef LIBPRINTHELLO_H /* These are include guards */
#define LIBPRINTHELLO_H

void printHello(char * text); 

#endif
</code></pre>

<p>In <code>libprinthi.h</code>:</p>

<pre><code>#ifndef LIBPRINTHI_H
#define LIBPRINTHI_H

void printHi();

#endif
</code></pre>

<p>In <code>libprinthello.c</code>:</p>

<pre><code>#include ""libprinthi.h""
#include ""libprinthello.h""

void printHello(char * text)  
{  
    printHi();  
    printf(""%s"", text);  
}  
</code></pre>

<p>In <code>libprinthi.c</code>:</p>

<pre><code>#include ""libprinthi.h""

void printHi()    
{    
    printf(""Hi\n"");    
}    
</code></pre>

<p>Then the user code includes only <code>libprinthello.h</code>, and you keep <code>libprinthi.h</code> away from the user, making <code>printHi()</code> invisible to them (the user code would also link against the shared library):</p>

<pre><code>#include ""libprinthello.h""

int main()
{
    printHello(""Hello World!\n"");
    return 0;
}
</code></pre>
",0
2910909,2910826,3,"<p>If you put the definition of printHi in libprinthello.c,
you can simply declare it static and it will only
be accessible to the other functions defined in that
same file.  If you want to put the definition in its
own translation unit there is no portable way to make
it hidden to users of the library, but you can 
hide it in implementation specific ways.  For
example, with gcc you can use
&#95;&#95;attribute&#95;&#95;((visibility(""hidden""))).
However, simply leaving the declaration out of
the public header file should be sufficient to keep
users of the library from using the function.</p>
",0
2046280,2046260,0,"<p>A good start may be the <em>localtime(3)</em> and <em>mktime(3)</em> functions. Alternatively, you can implement the relevant date arithmetic from scratch. Then, simply, generate the first line of the calendar (find the weekday that corresponds to January 1st, then print taht in the right place, followed by the rest of the week), then print all but the last lines, then print the last line.</p>

<p>Depending on if you want a calendar paginated by month or not, this MAY be better done ona per-month instead of a per-year basis.</p>
",0
2046283,2046260,3,"<p>In general, when you have a big problem like this one, you want to break it down into little problems that are easier to solve. </p>

<p>Here's one possible little problem to start with: if you know how many days there are in a month, and what weekday the first of the month falls on, could you output a calendar for that month?</p>
",0
2046294,2046260,1,"<p>The hardest part is determining which day of the week the year starts on.</p>

<p><a href=""http://en.wikipedia.org/wiki/Calculating_the_day_of_the_week"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Calculating_the_day_of_the_week</a></p>

<p>But even without that knowledge, when I first implemented this, I used a reference date (for example, you know that today, January 11, 2010 is a Monday) and counted days from there. (Just keep in mind that leap years have an extra day, and that leap years are every 4 years except every 100 years except every 400 years.)</p>

<p><a href=""http://en.wikipedia.org/wiki/Leap_year"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Leap_year</a></p>
",0
2046295,2046260,4,"<p>It might help you to understand the mathematics of the calendar.  If the fabulous book <a href=""http://emr.cs.uiuc.edu/home/reingold/calendar-book/index.shtml"" rel=""nofollow noreferrer"">Calendrical Calculations</a> is not in your university library, they may be able to get you a reprint of the article by the same authors in <em>Software&mdash;Practice &amp; Experience</em>.  And ask your prof to request the book for the library.</p>
",0
2046310,2046260,0,"<p>Well, first figure out the algorithmic part of your problem - given a year, find what day Jan 1st is. </p>

<p>After this, just note the number of days in each month (store it in an array, say <code>num_days[]</code>), and the note the number of months in a year and an array of strings for the months.</p>

<p>For e.g. the outermost loop iterates over the months. Say, iterate <code>for(i=0;i&lt;NumMonths;++i)</code>. Then, for each month, print the string, e.g. <code>month[i]</code>, then a newline. </p>

<p>Then, with simple tabs, print Sun Mon Tue ..., and another newline.</p>

<p>Then using the day Jan 1st corresponds to (call it <code>FirstDay</code>), insert spaces, and start with that day. Keep printing the dates and newlines  till you hit <code>max_month[i]</code> which is <code>31</code> (for January). Store the name of day of the last day of the previous month and just reiterate treating that day as <code>FirstDay</code>.</p>
",0
2046317,2046260,0,"<p>You need a couple pieces to start. First, you need a formula that computes the day of the week for January 1 of whatever year is entered. You'll also need a formula to determine if the year is a leap year. Both of these formulae are easily found with a simple Google search. The third item you need is a simple array containing the number of days in each of the 12 months for a non-leap year.</p>

<p>Once you have these things, its trivial to determine the week day for each month of the year. Make sure to account for February 29 in a leap year.  From there, you just need to create a function that primts out the monthly calendar in a form that looks similar to the calendar hanging on the wall. Try sketching out the desired layout on paper first and use that as a template for creating the appropriate format statements.</p>
",0
2046319,2046260,0,"<p>Might check out the <a href=""http://rudy.ca/doomsday.html"" rel=""nofollow noreferrer"">doomsday</a> algorithm.  This would get you certain ""dooms days"" like Jan 31 is a doomsday, for 2008, that was a saturday.  You can work backwords from there</p>
",0
2046336,2046260,1,"<p>Does this code qualify? :-)</p>

<pre><code>char command[]=""cal 2010"";
sprintf(command,""cal %d"",argv[1]);
system(command);
</code></pre>

<p>It assumes a Unix machine with <em>cal</em> in the path.</p>
",0
2046482,2046260,0,"<p>Basically, there are two approaches:</p>

<ol>
<li><p>The easy / pragmatical way: Solve the task, and forget about everything else. Here you may check documentation for <code>mktime()</code> (you'll find an example based on mktime below..).</p></li>
<li><p>The scientific / engineering way: Learn to know how it works! You can start at the <a href=""http://en.wikipedia.org/wiki/Gregorian_calendar"" rel=""nofollow noreferrer"">great wikipedia article about the gregorian calendar</a>. Read it, understand it, and write code that implements the underlying algorithms (which are <strong>known</strong>, no rocket science, it is possible). This will improve your skills a lot (in fact, you really should do such a thing, maybe not the calender but another topic, it will give you a big leap in understanding <em>all</em> things).</p></li>
</ol>

<p>Now some pragmatic code to start with. <code>mktime()</code> has a great feature: it knows the calender details, and it accepts e.g. a date ""2010-01-60"" and will convert it into February 29th, 2010. But, this will only work for dates after 1970. It will not work for earlier dates (though I am not 100% sure, but it shouldn't work, because unix time starts at January 1st, 1970, but try with other dates, maybe <code>mktime()</code> is not restricted to unix time).</p>

<p>Pseudo-Code, this prints each day on a single line (YYYY-MM-DD):</p>

<pre><code>void print_cal( int year ) {
    static char weekdays[] = { ""Sun"", ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat"" };
    struct tm tm;
    for( int day=0; day&lt;365; ++day ) {
        memset( &amp;tm, 0, sizeof(tm) );
        tm.tm_year = year - 1900;
        tm.tm_mday = day;
        mktime( &amp;tm ); // modifies tm

        printf( ""%04d-%02d-%02d, %s\n"", tm.tm_year, tm.tm_mon+1, tm.tm_mday, weekdays[tm.tm_wday] );
    }
}
</code></pre>

<p>This code ignores leap years. You still have to adjust it to be correct for leap years! Also the result is not very pretty yet, just one line per day.</p>

<p>EDIT: added output of weekdays.</p>
",0
3725722,3725670,3,"<p>The preprocessor will - among other things - recursively replace all <code>#include</code> directives by the code of these headers included. (Basically, it's a dumb text replacement machine.) The result, a source file with all included headers recursively copied into it, is called a <em>translation unit</em>. Effectively, this is what your compiler sees (although modern compilers often mesh together different stages of the translation process in order to be faster).<br>
You can have multiple translation units contribute to a single resulting program. (In fact, with anything above 50 lines of code, that's pretty much the standard.) </p>

<p>When you are <em>defining</em> functions in headers (as opposed to only <em>declaring</em> them), and the headers with these definitions are then included in multiple source files that are to be linked to some executable, then the linker will find multiple definitions of the same functions, and give up emitting a nasty error message. </p>
",3
3725823,3725670,1,"<p>It all boils down to ""project management"".</p>

<p>In every project all functions must be named uniquely <em>(exceptions notwithstanding)</em> so that the linker can complete the program by generating calls to the right functions.</p>

<p>In a small project (like your ""work"" project above) it's easy to see there's no duplication of code, but as time goes by and your project grows things get harder to manage. If several of your '.c' files <code>#include ""work.h""</code>, each of them will get a copy of the function definition <code>DoWork</code>.  If you put the function definition in a '.c' file ot it's own and a declaration in a '.h' file, there will be no misshaps.</p>

<p><strong>function declaration</strong>: tell the compiler how to use the function<br>
<strong>function definiton</strong>: tell the compiler what the function does</p>
",0
3720075,3720034,16,"<p>Because the system <code>memory.h</code> is shadowing your <code>memory.h</code>, causing the <code>#include</code> to succeed without declaring your types.  Several possible fixes:</p>

<ul>
<li>Rename your file -- probably for the best in any case, to reduce potential confusion.</li>
<li>Include your file via a prefix subdirectory (e.g., <code>#include &lt;myproj/memory.h&gt;</code>).</li>
<li>Move your file into the same directory as the source file, allowing the <code>#include</code> precedence rules for filenames wrapped in <code>""</code> to take effect.</li>
<li>Ensure that your C pre-processor include path options place your project header path prior to the system header paths.</li>
</ul>
",3
6612884,3720034,3,"<p>This answer is really late, but I encountered a similar problem. </p>

<p>I think your problem is related to a typo in your <strong>.h</strong> file where you declare a struct <strong>mm</strong>emory. If you remove that extra 'm' it should work.</p>
",1
2089503,2089464,1,"<p>Here's an explanation of those two concepts</p>

<p><em>The const keyword specifies that the pointer cannot be modified after initialization; the pointer is protected from modification thereafter.</em></p>

<p><em>The volatile keyword specifies that the value associated with the name that follows can be modified by actions other than those in the user application. Therefore, the volatile keyword is useful for declaring objects in shared memory that can be accessed by multiple processes or global data areas used for communication with interrupt service routines.</em></p>

<p>It comes from <a href=""http://msdn.microsoft.com/en-us/library/145yc477.aspx"" rel=""nofollow noreferrer"">here</a></p>
",0
2089508,2089464,1,"<p>A const pointer (i.e. <code>const char* s = ..</code>) points to data that can <em>not</em> be modified. A volatile pointer (i.e.<code>volatile char* s = ...</code>) hints the compiler not to cache the data the pointer refers to in CPU registers, or elsewhere. Instead, they're reread from their original memory location every time they're needed. This is needed if the contents of the data might change outside the compiler's scope, for example through a second thread modifying it. </p>

<p>Be careful, <code>const char*</code> and <code>char* const</code> are different things, same for the <code>volatile</code>qualifier. If you're unsure, look them up.</p>
",0
2089510,2089464,2,"<p>Normally, <code>const</code> or <code>volatile</code> applies to the pointee, not the pointer itself.</p>

<p><code>const</code> means you're not allowed to modify the pointee via that pointer. </p>

<p><code>volatile</code> means somebody/something else might modify the pointee, even though your code doesn't. It also means that writing to the variable might do something more than just store a value to be retrieved the next time that variable is used. As a result, any time your code reads or writes a volatile value, the compiler is obliged to generate code that reads from (or writes to) actual memory, not just (for example) allocates a register for temporary use, and reads/writes the register.</p>

<p>Edit: Note that even though you're not allowed to modify the data via a <code>const</code> pointer, the data may still be modified by other means. In fact, there are times that you can have a pointee that's both <code>const</code> <em>and</em> <code>volatile</code>, which means you can't change it, but somebody else might.</p>
",1
2089523,2089464,15,"<p>The difference really comes down to the difference between <code>const</code> and <code>volatile</code>. The only things these two concepts have in common is syntax. <code>const</code> is compiler-enforced and says ""the programmer can not change this."" <code>volatile</code> says ""this data might be changed by someone else"" and so the compiler will not make any assumptions about that data. Without <code>volatile</code> the compiler might say ""I put this data from memory into a register, and since I haven't done anything to that data, I'm sure it's the same and I don't need to read it into the register again."" When the data is marked as <code>volatile</code> the compiler won't make such an assumption (because someone else might have changed the data) and so it will reread the data into the register.</p>

<p>Now, are you asking for the difference between</p>

<pre><code>int *const p;
</code></pre>

<p>and </p>

<pre><code>int *volatile q;
</code></pre>

<p>or the difference between</p>

<pre><code>const int* p;
</code></pre>

<p>and</p>

<pre><code>volatile int* q;
</code></pre>

<p>In the former case: <code>p</code> is a pointer to an <code>int</code> and where that pointer points can not be changed by the programmer whereas <code>q</code> is a pointer to an <code>int</code> and where that pointer points could be changed by someone other than the programmer so the compiler makes no assumptions about that pointer.</p>

<p>So:</p>

<pre><code>int *const p = (int*)malloc(sizeof(int));
int *volatile q = (int*)malloc(sizeof(int));
*p = 17; // legal;
p = (int*)malloc(sizoef(int)); // not legal
*q = 17; // legal;
q = (int*)malloc(sizeof(int)); // legal
</code></pre>

<p>In the latter case: <code>p</code> is a pointer to an <code>int</code> and what <code>p</code> is pointing to can not be changed by the programmer whereas <code>q</code> is a pointer to an <code>int</code> and what <code>q</code> is pointing to could be changed by someone other than the programmer so the compiler makes no assumptions about that data.</p>

<pre><code>int i = 17;
int j = 34;
const int *p = &amp;i;
volatile int *q = &amp;i;
*p = 51; // not legal
p = &amp;j; // legal
*q = 51; // legal
q = &amp;j; // legal
</code></pre>
",1
2532292,2532289,4,"<p>Files only have a single read pointer. You're going to cause a ridiculous number of race conditions if you try to have multiple threads reading from the same file. Instead have a single thread be responsible for reading the file, parsing the line, and dispatching jobs.</p>
",0
2532318,2532289,1,"<p>You should do all the file reading in one thread and then if you really need to do ""parallel programming"" (homework assignment ?) you can then have separate threads accessing different parts of the data that you have read into memory via your file-reading thread.</p>
",0
2638350,2637856,0,"<p>Another macro not already mentioned here: You don't need to give the type if you give the temporary variable instead. Additionally the comma operator is useful here to avoid the do-while(0) trick. But usually I don't care and simply write the three commands. On the other hand a temporary macro is useful if a and b are more complex.</p>

<pre><code>#define SWAP(a,b,t) ((t)=(a), (a)=(b), (b)=(t))

void mix_the_array (....)
{
    int tmp;
    .....
    SWAP(pointer-&gt;array[counter+17], pointer-&gt;array[counter+20], tmp);
    .....
}

#undef SWAP
</code></pre>
",0
2637860,2637856,25,"<p>You need to define it yourself.</p>
<ol>
<li><p>C doesn't have templates.</p>
</li>
<li><p>If such function does exist it would look like <code>void swap(void* a, void* b, size_t length)</code>, but unlike <code>std::swap</code>, it's not type-safe.</p>
</li>
<li><p>And there's no hint such function could be inlined, which is important if swapping is frequent (in C99 there's <code>inline</code> keyword).</p>
</li>
<li><p>We could also define a macro like</p>
<pre><code> #define SWAP(a,b,type) {type ttttttttt=a;a=b;b=ttttttttt;}
</code></pre>
<p>but it shadows the <code>ttttttttt</code> variable, and you need to repeat the type of <code>a</code>. (In gcc there's <code>typeof(a)</code> to solve this, but you still cannot <code>SWAP(ttttttttt,anything_else);</code>.)</p>
</li>
<li><p>And writing a swap in place isn't that difficult either ¡ª it's just 3 simple lines of code!</p>
</li>
</ol>
",1
2637861,2637856,18,"<p>There is no equivalent in C - in fact there can't be, as C doesn't have template functions. You will have to write separate functions for all the types you want to swap.</p>
",6
2637908,2637856,13,"<p>You can do something similar with a macro if you don't mind using a gcc extension to the C language, <code>typeof</code>:</p>

<pre><code>#include &lt;stdio.h&gt;

#define SWAP(a, b) do { typeof(a) temp = a; a = b; b = temp; } while (0)

int main(void)
{
    int a = 4, b = 5;
    float x = 4.0f, y = 5.0f;
    char *p1 = ""Hello"";
    char *p2 = ""World"";

    SWAP(a, b); // swap two ints, a and b
    SWAP(x, y); // swap two floats, x and y
    SWAP(p1, p2); // swap two char * pointers, p1 and p2

    printf(""a = %d, b = %d\n"", a, b);
    printf(""x = %g, y = %g\n"", x, y);
    printf(""p1 = %s, p2 = %s\n"", p1, p2);

    return 0;
}
</code></pre>
",10
2639501,2637856,1,"<p>Check your compiler documentation.  The compiler may have a <code>swapb</code> function for swapping bytes and my provide other similar functions.  </p>

<p>Worst case, waste a day and write some generic swap functions.  It won't consume a significant amount of your project's schedule.</p>
",0
4233114,4232842,7,"<p>A different way to do it in C++:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;

int main()
{
    std::string someData = ""this is some data that'll get written to each file"";
    int k = 0;
    while(true)
    {
        // Formulate the filename
        std::ostringstream fn;
        fn &lt;&lt; ""file"" &lt;&lt; k &lt;&lt; "".txt"";

        // Open and write to the file
        std::ofstream out(fn.str().c_str(),std::ios_base::binary);
        out.write(&amp;someData[0],someData.size());

        ++k;
    }
}
</code></pre>
",0
4232858,4232842,2,"<pre><code>FILE *img;
int k = 0;
while (true)
{
    // here we get some data into variable data
    char filename[64];
    sprintf (filename, ""file%d.txt"", k);

    file = fopen(filename, ""wb"");
    fwrite (data, 1, strlen(data) , file);
    fclose(file );
    k++;

            // here we check some condition so we can return from the loop
}
</code></pre>
",0
4232862,4232842,2,"<p>so create the filename using sprintf:</p>

<pre><code>char filename[16]; 
sprintf( filename, ""file%d.txt"", k );  
file = fopen( filename, ""wb"" ); ...
</code></pre>

<p>(although that is a C solution so the tag is not correct)</p>
",0
4232864,4232842,21,"<pre><code>int k = 0;
while (true)
{
    char buffer[32]; // The filename buffer.
    // Put ""file"" then k then "".txt"" in to filename.
    snprintf(buffer, sizeof(char) * 32, ""file%i.txt"", k);

    // here we get some data into variable data

    file = fopen(buffer, ""wb"");
    fwrite (data, 1, strlen(data) , file);
    fclose(file );

    k++;

    // here we check some condition so we can return from the loop
}
</code></pre>
",0
5590616,1677918,0,"<p>Both are L values so can't b changed.....
leads to Segmentation Fault or any Runtime Logical error</p>

<p>so it is safe to use</p>

<pre><code>p=q;
</code></pre>

<p>as now p starts pointing to  the string to which q is pointing</p>
",0
4374485,4373839,9,"<p>It defines i to be of 1 bit width.
If i:x is given then it defines i to be x bits wide.</p>
",0
2265648,2265598,0,"<p>This looks like at least one include file is missing where size_t is defined. Whichever that might be, on Linux look in <code>/usr/include</code> ... well, might be in <code>unistd.h</code>, so include that.</p>

<p>The other stuff might just result from the first error, hard to tell with the information provided here.</p>
",2
2265738,2265598,0,"<p>Looks like Pro*C error message.</p>

<p>Check <code>sys_include</code> parameter in your <code>$ORACLE_HOME/precomp/admin/pcscfg.cfg</code> file (or whichever config file is used by <code>proc</code> - <code>proc</code> tells it on startup). This parameter must include correct path to system headers.</p>

<p><strong>EDIT</strong> BTW while you are on this file, it makes sense to change value of <code>PARSE</code> parameter to <code>PARTIAL</code> (don't remember what was default) - it will tell Pro*C to be more relaxed about C syntax.</p>
",2
6655691,6655608,1,"<p>The reason there is a standard library is that you should not need to know the exact implantation details of these functions.  The code that implements the library calls at some point has to use nonstandard system calls which have to deal with issues you may not be concerned with.  If you are learning C make sure you can understand other C programs besides the stdlib once you get a little more advance look at the stdlib, but it still won't make alot of sense until you understand the system calls involved. </p>
",0
6655712,6655608,26,"<p><code>_IO_getc_unlocked</code> is an inlinable macro. The idea is that you can get a character from the stream without having to call a function, making it hopefully fast enough to use in tight loops, etc.</p>

<p>Let's take it apart one layer at a time. First, what is <code>_IO_BE</code>?</p>

<pre><code>/usr/include/libio.h:# define _IO_BE(expr, res) __builtin_expect ((expr), res)
</code></pre>

<p>_IO_BE is a hint to the compiler, that <code>expr</code> will <em>usually</em> evaluate to <code>res</code>. It's used to structure code flow to be faster when the expectation is true, but has no other semantic effect. So we can get rid of that, leaving us with:</p>

<pre><code>#define _IO_getc_unlocked(_fp) \
  ( ( (_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end ) \
    ? __uflow(_fp) : *(unsigned char *)(_fp)-&gt;_IO_read_ptr++) )
</code></pre>

<p>Let's turn this into an inline function for clarity:</p>

<pre><code>inline int _IO_getc_unlocked(FILE *fp) {
  if (_fp-&gt;_IO_read_ptr &gt;= _fp-&gt;_IO_read_end)
    return __uflow(_fp);
  else
    return *(unsigned char *)(_fp-&gt;_IO_read_ptr++);
}
</code></pre>

<p>In short, we have a pointer into a buffer, and a pointer to the end of the buffer. We check if the pointer is outside the buffer; if not, we increment it and return whatever character was at the old value. Otherwise we call <code>__uflow</code> to refill the buffer and return the newly read character.</p>

<p>As such, this allows us to avoid the overhead of a function call until we actually need to do IO to refill the input buffer.</p>

<p>Keep in mind that standard library functions can be complicated like this; they can also use extensions to the C language (such as <code>__builtin_expect</code>) that are NOT standard and may NOT work on all compilers. They do this because they need to be fast, and because they can make assumptions about what compiler they're using. Generally speaking your own code should not use such extensions unless absolutely necessary, as it'll make porting to other platforms more difficult.</p>
",6
6655778,6655608,0,"<p>The definition of getchar() redefines the request as a specific request for a character from stdin.</p>

<p>The definition of _IO_getc() does a sanity check to make sure that the FILE* exists and is not an End-Of-File, then it locks the stream to prevent other threads from corrupting the call to _IO_getc_unlocked().</p>

<p>The macro definition of _IO_getc_unlocked() simply checks to see if the read pointer is at or past the end of file point, and either calls __uflow if it is, or returns the char at the read pointer if it is not.</p>

<p>This is standard stuff for all stdlib implementations. You are not supposed to ever look at it. In fact, many stdlib implementations will use assembly language for optimal processing, which is even more cryptic.</p>
",0
6655833,6655608,2,"<p>I can highly recommend <a href=""https://rads.stackoverflow.com/amzn/click/com/0131315099"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer""><em>The Standard C Library</em></a> by P.J. Plauger.  He provides background on the standard and provides an implementation of every function.  The implementation is simpler than what you'll see in glibc or a modern C compiler, but does still make use of macros like the <code>_IO_getc_unlocked()</code> you posted.</p>

<p>The macro is going to pull a character from buffered data (which could be the ungetc buffer) or read it from the stream (which may read and buffer multiple bytes).</p>
",0
6655863,6655608,4,"<p>Going from pseudo-code to real code we can break it down:</p>

<pre><code>if (there is a character in the buffer)
  return (that character)
else
   call a function to refill the buffer and return the first character
end
</code></pre>

<p>Let's use <a href=""http://en.wikipedia.org/wiki/%3F%3a"" rel=""nofollow"">the ?: operator</a>:</p>

<pre><code>#define getc(f) (is_there_buffered_stuff(f) ? *pointer++ : refill())
</code></pre>

<p>A bit closer:</p>

<pre><code>#define getc(f) (is_there_buffered_stuff(f) ? *f-&gt;pointer++ : refill(f))
</code></pre>

<p>Now we are almost there. To determine if there is something buffered already, it uses the file structure pointer and a read pointer within the buffer</p>

<pre><code> _fp-&gt;_IO_read_ptr &gt;= _fp-&gt;_IO_read_end ?
</code></pre>

<p>This actually tests the opposite condition to my pseudo-code, ""is the buffer empty"", and if so, it calls <code>__uflow(_fp) // ""underflow""</code>, otherwise, it just reaches directly into the buffer with a pointer, gets the character, and then increments the pointer:</p>

<pre><code>? __uflow (_fp) : *(unsigned char *) (_fp)-&gt;_IO_read_ptr++)
</code></pre>
",0
3453467,3452661,2,"<p>The <code>*</code> operator in a declaration <em>always</em> binds to the declarator; the line</p>

<pre><code>void * malloc (size_t number_bytes);
</code></pre>

<p>is parsed <em>as though</em> it had been written</p>

<pre><code>void (*malloc(size_t number_bytes));
</code></pre>

<p>It's an accident of C syntax that you can write <code>T *p;</code> or <code>T* p;</code> or even </p>

<pre>
T             *                     p; 
</pre>

<p>but all of them are parsed as <code>T (*p);</code> -- the whitespace makes no difference in how the declarations are interpreted.</p>
",0
3452669,3452661,10,"<p>When you use an asterisk to get the value of an address it is called the <a href=""http://en.wikipedia.org/wiki/Dereference_operator"" rel=""nofollow noreferrer"">dereference operator</a>. For example:</p>

<pre><code>int x = *something;
</code></pre>

<p>In the example in your question the asterisk has a different meaning because it is part of a type, not part of an expression. It is used to specify that the return type is a pointer (in your specific example, a void pointer).</p>

<p>The extra space does not mean anything and is ignored by the compiler. It is there only to aid readability.</p>
",0
3452670,3452661,0,"<p>The same thing, but with some whitespace added.</p>
",0
3452675,3452661,1,"<p>C ignores extraneous whitespace, so <code>""* ""</code> should have the same effect as <code>""*""</code>.</p>

<p>If you want more clarification, please post a code example.</p>
",0
3452676,3452661,0,"<p>Check out this article on <a href=""http://www.cplusplus.com/doc/tutorial/pointers/"" rel=""nofollow noreferrer"">Pointers</a></p>

<p>Those two lines do the exact same thing.</p>
",0
3452733,3452661,0,"<p>In your <code>void * malloc(...)</code> example, <code>void *</code> is the type. <code>malloc</code> returns a pointer to void, which is just a pointer that needs to be cast to a particular type in order to be useful.</p>
",0
3452749,3452661,13,"<pre><code>int* foo == int *foo == int * foo == int  *   foo
</code></pre>

<p>The whitespace does not make any difference to the compiler.</p>
",2
2603052,2603039,19,"<p>There is a distinction between <code>'a'</code> and <code>""a""</code>:</p>

<ul>
<li><code>'a'</code> means the value of the character <code>a</code>.</li>
<li><code>""a""</code> means the address of the memory location where the string <code>""a""</code> is stored (which will generally be in the data section of your program's memory space). At that memory location, you will have two bytes -- the character <code>'a'</code> and the null terminator for the string.</li>
</ul>
",1
2603066,2603039,6,"<p>You can't compare strings with <code>==</code> in C. For C, strings are just (zero-terminated) arrays, so you need to use string functions to compare them. See the man page for <a href=""http://linux.die.net/man/3/strcmp"" rel=""noreferrer"">strcmp()</a> and <a href=""http://linux.die.net/man/3/strncmp"" rel=""noreferrer"">strncmp()</a>.</p>

<p>If you want to compare a character you need to compare to a character, not a string. <code>""a""</code> is the string <code>a</code>, which occupies two bytes (the <code>a</code> and the terminating null byte), while the character <code>a</code> is represented by <code>'a'</code> in C.</p>
",3
2603069,2603039,124,"<p>You want to use <code>strcmp() == 0</code> to compare strings instead of a simple <code>==</code>, which will just compare if the pointers are the same (which they won't be in this case).</p>

<p><code>args[i]</code> is a pointer to a string (a pointer to an array of chars null terminated), as is <code>""&amp;""</code> or <code>""&lt;""</code>.</p>

<p>The expression <code>argc[i] == ""&amp;""</code> checks if the two pointers are the same (point to the same memory location).</p>

<p>The expression <code>strcmp( argc[i], ""&amp;"") == 0</code> will check if the contents of the two strings are the same.</p>
",3
2603079,2603039,8,"<pre><code>if (args[i] == ""&amp;"")
</code></pre>

<p>Ok, let's disect what this does. </p>

<p>args is an array of pointers. So, here you are comparing <code>args[i]</code> (a pointer) to <code>""&amp;""</code> (also a pointer). Well, the only way this will every be true is if somewhere you have <code>args[i]=""&amp;""</code> and even then, <code>""&amp;""</code> is not guaranteed to point to the same place everywhere. </p>

<p>I believe what you are actually looking for is either <code>strcmp</code> to compare the entire string or your wanting to do <code>if (*args[i] == '&amp;')</code> to compare the first character of the <code>args[i]</code> string to the <code>&amp;</code> character</p>
",0
2603201,2603039,5,"<ol>
<li><p><a href=""http://blog.llvm.org/2010/04/amazing-feats-of-clang-error-recovery.html"" rel=""noreferrer"">clang</a> has advantages in error reporting &amp; recovery.</p>

<pre><code>$ clang errors.c
errors.c:36:21: warning: result of comparison against a string literal is unspecified (use strcmp instead)
        if (args[i] == ""&amp;"") //WARNING HERE
                    ^~ ~~~
            strcmp( ,     ) == 0
errors.c:38:26: warning: result of comparison against a string literal is unspecified (use strcmp instead)
        else if (args[i] == ""&lt;"") //WARNING HERE
                         ^~ ~~~
                 strcmp( ,     ) == 0
errors.c:44:26: warning: result of comparison against a string literal is unspecified (use strcmp instead)
        else if (args[i] == ""&gt;"") //WARNING HERE
                         ^~ ~~~
                 strcmp( ,     ) == 0
</code></pre>

<p>It suggests to replace <code>x == y</code> by <code>strcmp(x,y) == 0</code>.</p></li>
<li><p><a href=""http://www.gnu.org/software/gengetopt/gengetopt.html#Audience"" rel=""noreferrer"">gengetopt</a> writes command-line option parser for you.</p></li>
</ol>
",0
3443883,1564701,40,"<p>There is no way to do this directly in C89. You would have to use a set of macros to create such an expression.</p>

<p>In C99, it is allowed to declare struct-or-union literals, and initializers to scalars can be written using a similar syntax. Therefore, there is one way to achieve the desired effect:</p>

<pre><code>#include &lt;stdio.h&gt;

void f(const int *i) {
    printf(""%i\n"", *i);
}

int main(void) {
    f(&amp;(int){1});
    return 0;
}
</code></pre>
",3
2233323,2233304,1,"<p>You can loop over them, if the character is rejected go to next character (or return if no more chacters). If it is not rejected push it into the array. That would create a copy of the characters, but unless your string is gigantic it is not a problem. If it is, my answer wont suffice :)</p>

<p>Another variant would be a function that reads the string until it hits a valid character and returns it. To get the next character call the function again. The function needs to maintain an index variable passed to it though. If the end of the string is reached you would need to indicate it somehow.</p>
",1
2233324,2233304,4,"<p>Just iterate through the string and only copy the characters you're interested in, maintaining an index of the current position in the new array.</p>
",0
2233371,2233304,2,"<p>strtok() does this easily if </p>

<ol>
<li>the code is used in a single thread</li>
<li>You don't mind if the source string is changed in the process.</li>
</ol>
",3
4251095,4251081,-1,"<p>You're comparing an int to a bool. That's bad style to begin with, and some compilers will complain.</p>

<p>Maybe you mixed up <code>!</code> and <code>~</code>? <code>!invPktNum</code> will return false if invPktNum is non-false, and true if it's false. I'm pretty sure you meant <code>~invPktNum</code>.</p>
",1
4251097,4251081,2,"<p><code>!(0xFE)</code> is <code>0</code>. Maybe what you wanted was <code>~(0xFE)</code>?</p>
",0
4251099,4251081,3,"<p>Unary <code>!</code> is logical-NOT.  If the operand is <code>0</code> the result is <code>1</code>, otherwise the result is <code>0</code>.  This means that <code>!invPktNum</code> is <code>0</code>, so the <code>if</code> expression is true.</p>

<p>You are probably looking for unary <code>~</code>, which is bitwise-NOT.</p>

<hr>

<p>By the way, it may appear in a debugger as if the second <code>return 1;</code> is being executed rather than the first, because the compiler may have reordered the code and combined those two <code>return 1;</code> statements together (particularly if optimisation is enabled).</p>
",0
4251106,4251081,7,"<p>The compiler has folded the two <code>return 1</code> cases into the exact same code.  Both <code>if</code> tests branch to the same assembly instruction.  Each instruction can only be tagged with a single line number for the debugger, so you see that strange behavior.  If you compile with <code>-g</code> and <em>without</em> <code>-O</code> (or even more explicitly use <code>-O0</code>) it will make distinct cases and things will be more clear.</p>
",1
4251113,4251081,0,"<p>Check compiler optimizations are definitely disabled for debug mode. (Just to be different to everybody else)</p>
",0
4232247,4232214,1,"<p>Yes, you can open lots of sockets!  However, you shouldn't need separate sockets for sending and receiving, a TCP socket is bi-directional once it's opened.
As for your error, if you're using two machines, there could be a firewall preventing the server from connecting to your client.  You might try using telnet to try to connect to the same port.</p>
",2
2031384,1345506,2,"<p>I might get flamed for this, but I learnt C using Dan Gookin's <a href=""http://www.amazon.co.uk/C-Dummies-Dan-Gookin/dp/0764570684/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1262991374&amp;sr=1-1"" rel=""nofollow noreferrer"">C for Dummies</a>. The book is funny, well-written and very, very good. It's a bit short on ""meaty stuff"", so if you're already a programmer, it's probably too basic for you, but for the beginner, I have yet to see a book as good as this one. </p>

<p>I learnt C from this book first, and followed that up with the K&amp;R book already mentioned, which is also excellent, if a bit terse and dense.</p>
",0
2574907,2574906,6,"<p>This is a <a href=""http://en.wikipedia.org/wiki/Function_pointer"" rel=""nofollow noreferrer"">pointer to a function</a> that takes a <code>const char*</code> and returns <code>void</code>.</p>

<p>For more information, see <a href=""http://www.cprogramming.com/tutorial/function-pointers.html"" rel=""nofollow noreferrer"">here</a>.</p>
",0
2574908,2574906,3,"<p>It's a function pointer.  The function is called <code>parse_arg_function</code>, it accepts a <code>const char*</code> argument, and it returns <code>void</code>.</p>

<p>In the case you've shown, the function pointer is essentially being used as a callback.  Inside that function, it might be used along the lines of</p>

<pre><code>// ...
for (int i = 0; i &lt; argc; i++)
{
    parse_arg_function(argv[i]);
}
// ...
</code></pre>

<p>You might want to read over <a href=""http://www.newty.de/fpt/fpt.html"" rel=""nofollow noreferrer"">this function pointer tutorial</a> for a more in-depth discussion.</p>
",0
2574911,2574906,1,"<p><a href=""http://www.newty.de/fpt/index.html"" rel=""nofollow noreferrer"">This</a> is a good introduction on function pointers. Think of them as the address of the code pertaining to a function in memory. </p>
",0
2574917,2574906,1,"<p>When in doubt about what a declaration means in C, you can <a href=""http://cdecl.ridiculousfish.com/?q=void+(*+parse_arg_function)(const+char*)"" rel=""nofollow noreferrer"">ask cdecl</a>:</p>

<blockquote>
  <p>declare parse_arg_function as pointer to function (pointer to const char) returning void</p>
</blockquote>
",0
2574920,2574906,1,"<p>This is a function from the <a href=""http://ffmpeg.org"" rel=""nofollow noreferrer"">ffmpeg</a> library. Quote from the <a href=""http://cekirdek.pardus.org.tr/~ismail/ffmpeg-docs/cmdutils_8c.html#1e1cd70de83229e9d469b4d63c6097d4"" rel=""nofollow noreferrer"">online documentation</a> about ffmpeg:</p>

<blockquote>
  <p><i>parse_arg_function</i> &nbsp; Name of the function called to process every argument without a leading option name flag. NULL if such arguments do not have to be processed.</p>
</blockquote>

<p>In other words: when you want to do some processing yourself for each argument, you can give your own function. Otherwise, just use <code>NULL</code>.</p>
",0
5101006,2425167,-4,"<p>Include <code>stdlib.h</code> in your header, and then call <code>abort();</code> in any place you want to exit your program. Like this:</p>

<pre><code>switch(varName)
{
    case 1: 
     blah blah;
    case 2:
     blah blah;
    case 3:
     abort();
}
</code></pre>

<p>When the user enters the switch accepts this and give it to the case 3 where you call the <code>abort</code> function. It will exit your screen immediately after hitting enter key.</p>
",1
2425223,2425167,176,"<p>Try using <code>exit(0);</code> instead. The <a href=""http://man7.org/linux/man-pages/man3/exit.3.html"" rel=""noreferrer""><code>exit</code></a> function expects an integer parameter. And don't forget to <code>#include &lt;stdlib.h&gt;</code>.</p>
",1
2425227,2425167,86,"<p>The <code>exit</code> function is declared in the stdlib header, so you need to have</p>

<pre><code>#include &lt;stdlib.h&gt;
</code></pre>

<p>at the top of your program to be able to use <code>exit</code>.</p>

<p>Note also that <code>exit</code> takes an integer argument, so you can't call it like <code>exit()</code>, you have to call as <code>exit(0)</code> or <code>exit(42)</code>. 0 usually means your program completed successfully, and nonzero values are used as error codes.</p>

<p>There are also predefined macros <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code>, e.g. <code>exit(EXIT_SUCCESS);</code></p>
",2
2425231,2425167,13,"<p><code>exit(int code);</code> is declared in <code>stdlib.h</code> so you need an</p>

<pre><code>#include &lt;stdlib.h&gt;
</code></pre>

<p>Also:<br>
- You have no parameter for the <code>exit()</code>, it requires an <code>int</code> so provide one.<br>
- Burn this book, it uses <code>goto</code> which is (for everyone but linux kernel hackers) bad, very, <em>very</em>, VERY bad.</p>

<p>Edit:<br>
Oh, and</p>

<pre><code>void main()
</code></pre>

<p>is bad, too, it's:</p>

<pre><code>int main(int argc, char *argv[])
</code></pre>
",2
2425250,2425167,14,"<p>Try <a href=""http://man.openbsd.org/exit.3"" rel=""noreferrer"">man exit</a>.</p>

<hr>

<p>Oh, and:</p>

<pre><code>#include &lt;stdlib.h&gt;

int main(void) {
  /*  ...  */
  if (error_occured) {
    return (EXIT_FAILURE);
  }
  /*  ...  */
  return (EXIT_SUCCESS);
}
</code></pre>
",2
4151367,4151350,3,"<p>Yes, it is valid. If you do that, then the structure type is hidden in the enclosing scope and <code>t</code> refers only to the declared variable.</p>
",0
4151372,4151350,0,"<p>yes because each thing lives in a different place in the compilers understanding. </p>

<pre><code>t t;
</code></pre>

<p>The compiler is expecting a type when it encounters the first t and it has a type called t. </p>

<p><strong>Edit: To address comments.</strong></p>

<p>I'm not talking about scope.</p>

<p>But since I've not written a compiler (only interpreters) I don't know the term. The compiler is expecting a token at the first t to be a type, it also knows what type have been declared up to that point. Since it see a name that refers to a type it's happy. Whereas if a token that wasn't a type was found there then it would rightly signal an error.</p>
",2
4151398,4151350,1,"<blockquote>
  <p><code>fun()
  {
    t t;
  }</code></p>
  
  <p>is this valid ?</p>
</blockquote>

<p>No it is not. Return type of <code>fun()</code> is missing  and implicit <code>int</code> return type is deprecated.</p>

<p>However <code>void fun(){ t t ;}</code> is syntactically valid. </p>
",0
4151481,4151350,0,"<p>parser first gets the data type and maintains a different table and later part as the variable name. So it works absolutely.</p>
",0
4151426,4151350,3,"<p>Yes, but why would you want to? If you want bugs and errors to thrive in your project, then go right ahead and name variables after types.</p>
",1
3182119,3182102,8,"<p>These values go nowhere. You can not retrieve them. In fact, most are optimized out by the compiler.</p>

<p>That entire fragment can be simplified to atoi(""232"") because function calls usually can't be optimized out.</p>
",1
3182121,3182102,4,"<p>Those particular expressions are useless. On the other hand, this is allowed because some expressions have side effects(and perhaps return values), and sometimes only the side effect is needed.</p>
",0
3182128,3182102,2,"<p>Expressions that don't have side effects aren't particularly useful.
Usually you find a function call at those places, and the function body
actually causes some state change in the program.</p>

<p>Languages have lots of silly ways to do nothing.  Consider the C statement:</p>

<pre><code>  ;
</code></pre>

<p>It doesn't do anything.</p>
",0
3182130,3182102,2,"<p>Are you asking if this:</p>

<pre><code>int main() {
   1;
}
</code></pre>

<p>is valid C code? If so, yes it is, and always has been.</p>
",4
3182149,3182102,1,"<p>The comma operator evaluates expressions in order and returns the value of the last one. It's only useful if the previous expressions perform side effects like assignment.</p>

<p>So far as I can tell, the use of comma here is superfluous, and the expressions' values are being thrown away - you can't retrieve them. Unless you're writing these lines in the context of a special C interpreter...?</p>
",6
3182165,3182102,2,"<p>The same happens every time you call <code>printf(3)</code> without checking its return value, which is <strong>discarded</strong>. The function call though might have side-effects (<code>printf(3)</code> certainly does), so the instructions to execute it are still generated. Most modern compilers will remove most of the statements you listed given appropriate optimization flags.</p>

<p>If you really want to see what happens, compile your source to assembly (<code>-S</code> option for GCC) with (say <code>-O2</code>) and without optimization and trace the instructions.</p>
",1
3182202,3182102,1,"<p>From a functional point of view, all those expressions' results are lost. If good optimizations are at work, they are not computed at all. But let us suppose they are. In this case ""where"" the results are available depends on how the compiler translated the code, a fact that can be considered unpredictable.</p>

<p>On x86 machines, you can think that integer results and pointer results are stored into eax (that then will be trashed), but it is just a supposition; if it is true for a specific compiler and code, it could be not for another compiler or if you change a bit the code. It could also happen that the values are pushed on the stack, which then it's incremented again, so that, until it is not reused, you can find the value on the stack. Same arguments as for <code>eax</code> can be done.</p>

<p>The part tied through the comma are someway different. Things like <code>a, b</code> are read as ""execute a, discard any result and then execute b"", so that the result of a is lost ""by definition"" (of course, looking at the asm code, you could also in this case find that it is still available somewhere, but likely it is indeed not after b is evaluated)</p>
",2
3571226,3571212,1,"<p>Theres no good way to do this portably, as far as I know, other than to use a library like <code>ncurses</code>, which provides the <code>getch(void)</code> function.</p>

<p>Note: It appears <code>getchar(void)</code> from <code>stdio.h</code> waits until the enter key is pressed then feeds your the characters,s o it won't work.</p>
",6
3571332,3571212,3,"<p>In Windows <code>&lt;conio.h&gt;</code> provides function <code>_getch(void)</code> which can be used to read keystroke without echo-ing them (print them yourself if you want).</p>

<pre><code>#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;

int main( void )
{
   int ch;

   puts( ""Type '@' to exit : "" );
   do
   {
      ch = _getch();
      _putch( ch );
   } while( ch != '@' );

   _putch( '\r' );    // Carriage return
   _putch( '\n' );    // Line feed  
}
</code></pre>
",1
3571400,3571212,7,"<p>In unix/posix, the standard way of doing this is to put the input into non-canonical mode with tcsetattr:</p>

<pre><code>#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
    :
struct termios attr;
tcgetattr(0, &amp;attr);
attr.c_lflag &amp;= ~ICANON;
tcsetattr(0, TCSANOW, &amp;attr);
</code></pre>

<p>See the termios(3) man page for more details (and probably more information than you wanted to know).</p>
",0
2227358,2227272,1,"<p>I'm not sure what you are looking for, but this could be of some help, its in Unix:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;bstring.h&gt;          /* bzero(), bcopy() */
#include &lt;unistd.h&gt;           /* read(), write(), close() */
#include &lt;errno.h&gt;
#include &lt;sys/signal.h&gt;

int obtain_socket(int port);
void show_message(int sd);
void close_down(int sigtype);


#define PORT 2001          /* default port for server */
#define SIZE 512           /* max length of character string */

int ssockfd;     /* socket for PORT; global for close_down() */

int main()
{
  int sd, client_len;
  struct sockaddr_in client;

  signal(SIGINT, close_down);    /* use close_down() to terminate */

  printf(""Listen starting on port %d\n"", PORT);
  ssockfd = obtain_socket(PORT);
  while(1) {
    client_len = sizeof(client);
    if ((sd = accept(ssockfd, (struct sockaddr *) &amp;client, 
                        &amp;client_len)) &lt; 0) {
      perror(""accept connection failure"");
      exit(4);
    }
    show_message(sd);
    close(sd);
  }
  return 0;
}


int obtain_socket(int port)
/* Perform the first four steps of creating a server:
   create a socket, initialise the address data structure,
   bind the address to the socket, and wait for connections. 
*/
{
  int sockfd;
  struct sockaddr_in serv_addr;

  /* open a TCP socket */
  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
    perror(""could not create a socket"");
    exit(1);
  }

  /* initialise socket address */
  bzero((char *)&amp;serv_addr, sizeof(serv_addr));
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  serv_addr.sin_port = htons(port);

  /* bind socket to address */
  if (bind(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) {
    perror(""could not bind socket to address"");
    exit(2);
  }

  /* set socket to listen for incoming connections */
  /* allow a queue of 5 */
  if (listen(sockfd, 5) == -1) {
    perror(""listen error"");
    exit(3);
  }
  return sockfd;
}


void show_message(int sd)
/* Print the incoming text to stdout */
{
  char buf[SIZE];
  int no;

  while ((no = read(sd, buf, SIZE)) &gt; 0)
    write(1, buf, no);    /* write to stdout */
}


void close_down(int sigtype)
/* Close socket connection to PORT when ctrl-C is typed */
{
  close(ssockfd);
  printf(""Listen terminated\n"");
  exit(0);
}
</code></pre>
",3
2228887,2227272,0,"<p>For Linux you have the <a href=""http://tldp.org/HOWTO/Serial-Programming-HOWTO/"" rel=""nofollow noreferrer"">Serial Programming HOWTO</a>.</p>
",0
2378767,2378755,2,"<p>There's nothing wrong with your code. It's a bit excessive and ""talkative"" when it comes to generating and storing the number, and has magic constants where none are needed, but it should produce the wanted result.</p>

<p>The loop could be shortened to:</p>

<pre><code>for (i = 0; i &lt; sizeof iv; i++)
     iv[i] = (char) rand();
</code></pre>

<p>Of course the randomness will be limited by whatever implementation of a <a href=""http://en.wikipedia.org/wiki/Pseudorandom_number_generator"" rel=""nofollow noreferrer"">PRNG</a> your compiler and/or library is using.</p>
",1
2378769,2378755,2,"<p>You can directly assign the return value of rand() mod 256 to the array elements:</p>

<pre><code>char iv[8];
int i;
srand(time(NULL));
for (i = 0; i &lt;8; i++)
  iv[i] = rand()%256;
</code></pre>

<p>This way can see some -ve numbers in the <code>iv</code> array when you try to print it as an integer. 
Lets say <code>rand()%256</code> gave 255, which is <code>1111 1111</code>. Clearly the most significant bit of this is set, so when you try to print it as an integer it will be interpreted as a -ve number.</p>

<p>To avoid getting -ve numbers you'll have to declare the iv as an array of unsigned char:</p>

<pre><code>unsigned char iv[8];
</code></pre>
",1
2379447,2378755,0,"<p>If you are using it as an Initiazation vector ( I guessed it seeing the variable named <code>iv</code> ) then it probably has to be unsigned as most cryptographic libraries expect a byte-array of eight unsigned values.</p>
",0
2378859,2378755,5,"<p>You should use <code>unsigned char</code> for the array, not <code>char</code>.  The former is guaranteed to be able to hold the values from 0 to (at least) 255, but the latter <em>may</em> not be able to hold numbers greater than 127.</p>
",5
2379641,2378755,0,"<p>U should print using %u not %d. %u is the printf unsigned symbol, so it want take the sign bit into account, and print all the numbers as positive numbers.</p>
",0
2379281,2378755,0,"<p>looks like ur solution could be something like this,</p>

<pre><code>char myrand[8];
int *my1,*my2;
my1 = (int*)(myrand);
my2 = (int*)(myrand+4);
srand(time(NULL));
my1 = rand() % 0xffffffff;
my2 = rand() % 0xffffffff;
</code></pre>

<p>works faster you see.
BTW I assume that int here is 4 bytes :-)</p>
",0
2382699,2378755,0,"<p>Is this for use in a cryptographic algorithm? If so, you maybe shouldn't use rand(), it's not good enough for most cryptographic purposes.</p>
",2
2921168,2921159,2,"<p>What type is array?  It sounds like you're using it incorrectly.</p>

<p><strong>If you have an array of ints:</strong></p>

<pre><code>printf(""%i \n"",array[k]);
</code></pre>

<p>Note %i and %d are synonymous for output.</p>

<p><strong>If you have an array of strings:</strong></p>

<p><code>%s</code> is for strings of the type <code>char*</code>.  That means to use <code>%s</code> you have to be sure each element of your array holds its own null terminated string each of type <code>char*</code>.   Make sure the strings are arrays of chars with a 0 termination.</p>
",5
2921175,2921159,5,"<p>What is the type of <code>array</code>? If it is an array of <code>int</code>'s, you should print it with a format of <code>%d</code>, not <code>%s</code>.</p>

<pre><code>printf(""%d\n"", array[k]);
</code></pre>

<hr>

<p><strong>If <code>array</code> is an array of <code>int</code>:</strong></p>

<p>If you use <code>%s</code>, the <code>printf</code> function will treat <code>array[k]</code> as a string (<code>char*</code>), therefore will <em>dereference</em> the value print out the characters there. But 123 (0x7b) is an invalid address, so the system will kill the executable with a SEGFAULT.</p>

<p>Please enable all warnings while you compile. The compiler is able to see the type error and warn you.</p>

<hr>

<p>Edit: But <code>array</code> is an array of <code>char</code>.... It can only hold 1 string logically, not 5. To print it you use</p>

<pre><code>printf(""%s \n"", array); // cannot index.
</code></pre>

<p>You'd better revise the structure of your code.</p>
",5
2921250,2921159,0,"<p>Are you certain that it is the printf loop where the segmentation fault occurs?  If all the numbers did print out as you say then it is possible something after it is the cause of the segmentation fault.</p>

<p>Add a printf(""Made it to here.\n""); line after the loop make certain.</p>
",0
2921328,2921159,0,"<pre><code>printf(""%s \n"",array[k]);
</code></pre>

<p>array[k] is a character, not a character pointer, so would need to be printed with %c, not %s. Otherwise it will attempt to dereference an address in the first 256 bytes of memory int he futile search for a string to print.</p>
",0
2378679,2378656,1,"<p>You need to allocate the memory for gRow *row ; 
Then it will work fine, I hope. </p>
",1
2378682,2378656,3,"<p>Note that strtok modifies the string - if your txt pointer is pointing at a read-only string (e.g. a const string literal) then you will get an exception.</p>
",0
2378684,2378656,1,"<p><code>strtok</code> modifies the string given to it. If you don't have the right to modify it, you might get a Segmentation Fault. <code>strdup</code> prevents that by copying the string.</p>
",0
2378686,2378656,1,"<p><a href=""http://www.cplusplus.com/reference/clibrary/cstring/strtok/"" rel=""nofollow noreferrer""><strong>strtok</strong></a> modifies its first argument.</p>

<p>In case 1 looks like you were passing a pointer to char constant which could not be modified.</p>

<p>and in case 2 you were passing a modifiable copy of it returned by <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/strdup.html"" rel=""nofollow noreferrer""><strong>strdup</strong></a>.</p>
",2
2082009,2081980,0,"<p>You're mixing things here -- you essentially have an array of fixed-size structs; you can't really turn that into a linked-list type structure in-place.  To do what you want to do, each time you find one to remove, you will have to copy the rest of the list into the previous position.</p>
",0
2082010,2081980,2,"<p>What do you mean by ""may be one I need to skip""? I'm assuming you have an array of structs, and there are some elements of this array you want to remove?</p>

<p>Arrays have to be contiguous. So, generally, there are two ways to do this - depending on how your code is structured one or the other may be easier.</p>

<ol>
<li><p>Swap the element you want to eliminate with the first element in the array, then increment the pointer to the first element in the array, and decrement the count of elements in the array</p></li>
<li><p>Swap the element you want to eliminate with the last element in the array, then decrement the count of elements in the array</p></li>
</ol>

<p>Of course, this is for appearances only. Don't let these pointer operations mess up your memory management.</p>
",0
2082012,2081980,0,"<p>What you describe doesn't make sense.</p>

<p>In which structs would you do the overwrite of the pointer? Must be something making them special - can't you use the same specialty for just skipping them in the loop?</p>

<pre><code>struct linux_dirent {
    unsigned long   d_ino;
    unsigned long   d_off;
    unsigned short  d_reclen;
    char        d_name[1];
};
</code></pre>

<p>Are you skipping some <code>d_ino</code>? Which ones?</p>
",5
2082251,2081980,1,"<p>Here's some untested code modeled after <a href=""http://www.sgi.com/tech/stl/remove_if.html"" rel=""nofollow noreferrer"">remove_if</a> from C++:</p>

<pre><code>typedef struct linux_dirent64 dirent;

/* example predicate function - modify as needed */
/* returns nonzero if the file should be filtered out */
int has_foo_prefix(const dirent* ent)
{
  return !strncmp(ent-&gt;d_name, ""foo"", 3);
}

/* given a predicate, moves ""good"" entries to front, returns new end */
typedef int (*predicate)(const dirent*);
dirent* filter(dirent* array, dirent* end, predicate pred)
{
  for (dirent* slow = array, fast = array; fast &lt; end; fast++) {
    if (!pred(*fast)) { /* keep this entry */
      if (fast != slow) { /* need to move this entry forward */
        memcpy(slow, fast, sizeof(dirent));
      }
      slow++;
    }
  }
  return slow;
}

/* example call */
dirent* array = ..., end = ...;
end = filter(array, end, has_foo_prefix);
</code></pre>

<p>The idea is that the unwanted elements of the array are overwritten step by step with the wanted ones, leaving only the wanted ones at the front of the array, which then effectively has a new (usually smaller) size.  It's O(n) and does minimal allocation.</p>

<p>There is one important bug in my code which I'm leaving unaddressed for now: the variable length nature of the array elements.  If a longer element needs to replace a shorter one, this is a problem.  And in any case the code I wrote needs more pointer-twiddling to advance through the array correctly, but I'm leaving it as-is to be built upon.  I'll note that as you advance through the array and skip some elements, you will see this problem less and less because of the extra space given by the ""bad"" elements.  So the running time may not be worse than in the simplistic version unless the input is pathological.</p>
",0
2444926,2444900,1,"<p>By default, <code>stdout</code> is line buffered, so you may want to end your debugging print calls with newlines:</p>

<pre><code>fprintf(stdout, ""workder: %d\n"", worker);
</code></pre>

<p>If you don't want a newline, you can flush the stream yourself:</p>

<pre><code>fprintf(stdout, ""workder: %d"", worker);
fflush(stdout);
</code></pre>
",0
2421835,2421825,6,"<p>C89 has implicit function declarations. If you use a function without declaring it, the compiler assumes it is <code>int prn()</code>. When this turns out to be wrong (because the return types differ), it's letting you know.</p>

<p>Note that the empty argument list in a function declaration means ""parameters not specified"", not ""no parameters"". It's then your responsibility to make sure that the input parameters match between the caller and the callee (which they don't, here), and you might get no help at all from the compiler with that.</p>

<p>In C99 this ""feature"" was removed. I think it was only ever really in C89 for compatibility with ancient C code. There was a time C didn't have function prototypes at all, you always just had to get it right on your own.</p>
",0
2421838,2421825,11,"<p>In C99 it should give an <em>undeclared function</em> error.</p>

<p>In C89/90 declaring functions is not mandatory. If an undeclared function is called, the compiler will assume that it returns <code>int</code> and it will pass arguments to it after subjecting them to so called <em>default argument promotions</em>. In other words, the compiler will try to <em>deduce</em> what that function is from the actual call. If later the function is defined differently from what the compiler deduced, the behavior is undefined. Normally compilers will complain about it with a warning. </p>

<p>This is what you observe in your case. When the compiler sees the <code>prn(e)</code> call it assumes that <code>prn</code> is <code>int prn(int)</code> function. But later it discovers that it is actually a <code>void prn(double, int)</code>. The mismatch is causing the warning.</p>

<p>In this case you are lucky in a sense that the call to undeclared function takes place in the same translation unit where the function is defined. So the compiler has a chance to compare the call and the definition and issue a warning about the conflict. If <code>prn</code> was defined in some other translation unit, the compiler would never have a chance to compare the two, so you'd have a full-fledged undefined behavior on your hands.</p>
",0
2519305,2519271,6,"<p>main.c has a few minor problems - it should be something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

static int var;

extern void foo();
extern void bar();

int main(void)
{
    foo();
    bar();
    printf(""%d\n"", var);
    return 0;
}
</code></pre>

<p>It should build OK like this:</p>

<pre><code>$ gcc -Wall main.c foo.c bar.c -o main
</code></pre>

<p>and the result should be:</p>

<pre><code>$ ./main
0
</code></pre>
",4
2519323,2519271,4,"<p>I would expect it to compile and print 0 (though if you want to compile it as C++, you'll have to add declarations for <code>foo()</code> and <code>bar()</code>, and in either C or C++, you might get a warning that <code>main()</code> should really return an int).</p>

<p>Since <code>var</code> is defined as static in each of the three files, you really have three separate variables that all happen to have the same name. Perhaps it's easiest to think of each file as defining a struct that contains its static variables. What you've done is called <code>foo()</code>, which increments <code>foo.var</code>. Then you've called <code>bar()</code>, which increments <code>bar.var</code>. Then you've printed out <code>main.var</code>, which was initialized to zero, and never modified.</p>
",0
2519398,2519271,0,"<p>This compiles for me (although with a warning about the return type from <code>main()</code>).</p>

<p>The result, in terms of what <code>main()</code> will print, is undetermined because you have not initialized the value of <code>var</code> in main.c. The most likely result when the compiler is invoked without optimizations is zero because the OS will have zeroed the physical memory supplied to the process for data storage (the OS does this to avoid leaking confidential data between processes).</p>

<p>The static qualifier to the <code>var</code> variable definitions means that the variable is not visible outside the source file it is defined in. It also means that each of the three <code>var</code> variables gets its own storage location.</p>

<p>If we add a <code>printf(""[module name] *var=%p\n"", &amp;var)</code> to <code>foo()</code>, <code>bar()</code> and <code>main()</code> respectively to print the address of the memory location that stores those three variables you should get something like this:-</p>

<pre><code>foo() *var=0x8049620
bar() *var=0x8049624
main() *var=0x8049628
</code></pre>

<p>Note that each variable gets its own storage location. The code in each source file will access the version of var that is specific to to that source file. Using <code>static</code> like this in .c files is typically used to implement the concept of information hiding in C.</p>
",0
2519464,2519271,0,"<p>The code (as it is) will compile and result will be 0 (as Jerry explains) because <code>static</code> variable will have file scope.</p>

<p>But, if you include <code>foo.c</code> and <code>bar.c</code> in <code>main.c</code>, and compile as  </p>

<pre><code>gcc main.c
</code></pre>

<p>then the result will be <code>2</code> because there will only be one global variable <code>var</code>.</p>
",0
2227277,2227254,3,"<p>The underlying type of the objects pointed by both the source and destination pointers are irrelevant for <code>memcpy</code>; The result is a binary copy of the data.</p>

<p>The function does not check for any terminating null character in source - it always copies exactly num bytes. My guess is you are not adding a terminating null and trying to access it as a string.</p>
",0
2227315,2227254,0,"<p>I suppose that if char has 2 bytes if you memcpy to a byte array you might be getting 8 bytes, that is 2 bytes for each char.</p>

<p>I am however rusty at this C/C++ things. So hopefully somebody with more experience will give you a better answer.</p>
",0
2227342,2227254,1,"<p>C does not have any kind of boundary check on its data types.</p>

<p>So what you are probably ""seeing"" when debugging the code is that it shows you 8 bytes in the array. As someone else says, you might be trying to view it as a string and do not have a terminating zero byte. This is quite normal in C, and it is one of the aspects of the language that makes it very hard to understand.</p>

<p>I can recommend you read a good introduction to memory and pointer handling under C, or switch to a managed language like C#, VB.NET, Java, Perl, Python etc.</p>
",0
2227371,2227254,0,"<p>The problem is you have a char array of 4 bytes and you writing full 4 bytes during memcpy without leaving any space for the terminating null character. Declare your array as 5 bytes and initialize it all to null (which you are already doing) and everything should be fine.</p>
",0
2227385,2227254,6,"<p>C strings are 0-terminated.  This means that if you want to have a string of length <code>n</code> in C, you need <code>n+1</code> <code>char</code>s for it:</p>

<pre><code>char hello[5] = ""hello"";
</code></pre>

<p>is not a string, because <code>hello</code> has space for 5 <code>char</code>s, and it doesn't end with <code>0</code>.</p>

<pre><code>char hello[6] = ""hello"";
</code></pre>

<p>is a string, and has 6 characters: <code>h</code>, <code>e</code>, <code>l</code>, <code>l</code>, <code>o</code>, <code>0</code>.</p>

<p>To be able to use string related functions in C, you need the terminating 0.</p>

<p>So, change your code to have:</p>

<pre><code>char strRoh[5]={'\0'};
char strTheta[5]={'\0'};
char strTimeStamp[7]={'\0'};
char strNMDump[49]={'\0'};
</code></pre>

<p>Note that in C, when you do:</p>

<pre><code>char hello[] = ""hello"";
</code></pre>

<p>the compiler does the counting for you, and makes <code>hello</code> an array of size 6 (one terminating 0):</p>

<pre><code>printf(""%zu\n"", sizeof hello);
</code></pre>

<p>will print 6.</p>
",1
5145914,5145881,2,"<p>This doesn't make a whole lot of sense.</p>

<p>Values that are not pointers cannot be ""freed"", they are values, they can't go away.</p>

<p>If I do:</p>

<pre><code>int c = 1;
</code></pre>

<p>The variable 'c' is not a pointer, it cannot do anything else than contain an integer value, to be more specific it can't NOT contain an integer value. That's all it does, there are no alternatives.</p>

<p>In practice, the literals will be compiled into the generated machine-code, so that somewhere in the code resulting from the above will be something like</p>

<pre><code>load r0, 1
</code></pre>

<p>Or whatever the assembler for the underlying instruction set looks like. The '1' is a part of the instruction encoding, it can't go away.</p>
",0
5146038,5145881,2,"<p>Make sure you distinguish between <strong>values</strong> and <strong>pointers to memory</strong>.  Pointers are themselves values, but a special kind of value that contains an address to memory.</p>

<p>With <code>char* hello = ""hello"";</code>, there are two things happening:</p>

<ul>
<li>the string <code>""hello""</code> and a null-terminator are written somewhere in memory</li>
<li>a variable named <code>hello</code> contains a value which is the address to that memory</li>
</ul>

<p>With <code>int i = 0;</code> only one thing happens:</p>

<ul>
<li>a variable named <code>i</code> contains the value <code>0</code></li>
</ul>

<p>When you pass around variables to functions their values are always copied.  This is called <strong>pass by value</strong> and works fine for primitive types like <code>int</code>, <code>double</code>, etc.  With pointers this is tricky because only the address is copied; you have to make sure that the contents of that address remain valid.</p>

<p>Short answer: yes. <code>1</code> and <code>'a'</code> stick around due to <strong>pass by value</strong> semantics and <code>""hello""</code> sticks around due to <strong>string literal allocation</strong>.</p>
",2
5146109,5145881,1,"<p>Stuff like <code>1</code>, <code>'a'</code>, and <code>""heyapple!""</code> are called <em>literals</em>, and they get stored in the compiled code, and in memory for when they have to be used. If they remain or not in memory for the duration of the program depends on where they are declared in the program, their size, and the compiler's characteristics, but you can generally assume that yes, they are stored <em>somewhere</em> in memory, and that they don't <em>go away</em>.</p>

<p>Note that, depending on the compiler and OS, it may be possible to change the value of literals, inadvertently or purposely. Many systems store literals in read-only areas (CONST sections) of memory to avoid nasty and hard-to-debug accidents.</p>

<p>For literals that fit into a memory word, like <code>int</code>s and <code>char</code>s it doesn't matter how they are stored: one repeats the literal throughout the code and lets the compiler decide how to make it available. For larger literals, like strings and structures, it would be bad practice to repeat, so a reference should be kept.</p>

<p>Note that if you use macros (<code>#define HELLO ""Hello!""</code>) it is up to the compiler to decide how many copies of the literal to store, because macro expansion is exactly that, a substitution of macros for their expansion that happens before the compiler takes a shot at the source code. If you want to make sure that only one copy exists, then you must write something like:</p>

<pre><code>#define HELLO ""Hello!""
char* hello = HELLO;
</code></pre>

<p>Which is equivalent to:</p>

<pre><code>char* hello = ""Hello!"";
</code></pre>

<p>Also note that a declaration like:</p>

<pre><code>const char* hello = ""Hello!"";
</code></pre>

<p>Keeps <code>hello</code> immutable, but not necessarily the memory it points to, because of:</p>

<p>char <em>h = (char</em>) hello;
   h[3] = 'n';</p>

<p>I don't know if this case is defined in the C reference, but I would not rely on it:</p>

<p>char* hello = ""Hello!"";
   char* hello2 = ""Hello!""; // is it the same memory?</p>

<p>It is better to think of literals as unique and constant, and treat them accordingly in the code.</p>

<p>If you do want to modify a <em>copy</em> of a literal, <a href=""https://www.securecoding.cert.org/confluence/display/seccode/STR30-C.+Do+not+attempt+to+modify+string+literals"" rel=""nofollow"">use arrays instead of pointers</a>, so it's guaranteed a different copy of the literal (and not an alias) is used each time:</p>

<pre><code>char hello[] = ""Hello!"";
</code></pre>

<p>Back to your original question, the memory for the literal <code>""heyapple!""</code> will be available (will be referenceable) as long as a reference is kept to it in the running code. Keeping a whole module (a loadable library) in memory because of a literal may have consequences on overall memory use, but that's another concern (you could also force the unloading of the module that defines the literal and get all kind of strange results).</p>
",2
3180442,3180419,9,"<p>Plain C doesn't have namespaces, so you need to leave out the <code>::</code> global namespace specifiers. Those would only be valid in C++.</p>

<p>The <code>L</code> in front of the string specifies that this is a wide character string. If your project doesn't use wide characters, leave out the <code>L</code> to get a normal character string. If you need to support both variants you can also use the <code>_T</code> macro: <code>_T(""..."")</code> expands to the correct variant of string literal depending on your project settings.</p>
",7
3180443,3180419,3,"<p>I'm pretty sure that you can't use <code>::</code> as part of an identifier name in the C programming language.  This looks more like some bizarre, bastardized usage of C++.  IIRC, <code>::</code> by itself in front of an identifier specified that this was in the global or file scope (to avoid potentially clashing with, say, methods in a class).</p>
",1
3181048,3180419,2,"<p>It's not C, it's C++.  Drop the double colons (or compile it as C++).</p>

<p>Also, the string constant uses wide characters.  Drop the L in front of the open quote.</p>
",1
3184925,3180419,0,"<p>So, I guess your question is more about getting the result you want than the reason for the code not compiling :)</p>

<p>Now you've got it working, the DeviceIoControl() call will be filling in the <a href=""http://msdn.microsoft.com/en-us/library/bb968801%28VS.85%29.aspx"" rel=""nofollow noreferrer"">STORAGE_DEVICE_NUMBER</a> structure you're passing to it with the results you want. So, you should find that <code>info.DeviceType</code> now holds the device type, <code>info.DeviceNumber</code> holds the device number, and <code>info.PartitionNumber</code> the partition number.</p>

<p>Test for success before using the returned values. I'd maybe try it on the C: drive rather than the D: drive, as you're doing at the moment, until I was sure it was working; at least you know you've pretty much always got a C: drive in Windows :)  So, use <code>\\\\.\\c:</code> rather than <code>\\\\.\\d:</code>.</p>

<p>Anyway, untested, but:</p>

<pre><code>if (::DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &amp;info, sizeof(info), &amp;bytesReturned, NULL))
{
    std::cout &lt;&lt; ""Device: "" &lt;&lt; info.DeviceNumber &lt;&lt; 
                 "" Partition: "" &lt;&lt; info.PartitionNumber &lt;&lt; std::endl;
} else {
    std::cerr &lt;&lt; ""Ooops. The DeviceIoControl call returned failure."" &lt;&lt; std::endl;
}
</code></pre>

<p>...obviously, you'd need a <code>#include &lt;iostream&gt;</code> for this to work, as I'm dumping the values using iostream, but you can print these out however you want, or message box them, bearing in mind you're already bringing in windows.h.</p>

<p>Bear in mind it's been a decade or so since I did any Windows C++ work, but maybe this'll get you going...</p>
",0
2271512,2271408,6,"<p>You must use a mix of tzset() with time/gmtime/localtime/mktime functions.</p>

<p>Try this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;time.h&gt;

time_t makelocal(struct tm *tm, char *zone)
{
    time_t ret;
    char *tz;

    tz = getenv(""TZ"");
    setenv(""TZ"", zone, 1);
    tzset();
    ret = mktime(tm);
    if(tz)
        setenv(""TZ"", tz, 1);
    else
        unsetenv(""TZ"");
    tzset();
    return ret;
}

int main(void)
{
    time_t gmt_time;
    time_t local_time;
    struct tm *gmt_tm;

    gmt_time = time(NULL);
    gmt_tm = gmtime(&amp;gmt_time);
    local_time = makelocal(gmt_tm, ""CET"");

    printf(""gmt: %s"", ctime(&amp;gmt_time));
    printf(""cet: %s"", ctime(&amp;local_time));

    return 0;
}
</code></pre>

<p>Basically, this program takes the current computer day as GMT (time(NULL)), and convert it to CET:</p>

<pre><code>$ ./tolocal 
gmt: Tue Feb 16 09:37:30 2010
cet: Tue Feb 16 08:37:30 2010
</code></pre>
",0
3843655,3843641,8,"<pre><code>#include &lt;limits.h&gt;
/* ... */
printf(""This machine's pointers to void, in a program ""
       ""compiled with the same options as this one and ""
       ""with the same compiler, use %d bits\n"",
    (int)sizeof (void*) * CHAR_BIT);
</code></pre>
",6
3843722,3843641,8,"<p>If by ""some code in C"" you mean standard C code, then the answer is no, it is not possible. For a C program, the ""world"" it can see is created entirely by the implementation (by the compiler). The compiler can emulate absolutely any ""world"", completely unrelated to the underlying hardware. </p>

<p>For example, you can run a 32-bit compiler on a 64-bit machine and you will never be able to detect the fact that this is a 64-bit machine from your program. </p>

<p>The only way you can find out anything about the machine is to access some non-standard facilities, like some OS-specific API. But that goes far beyond the scope of C language.</p>

<p>Needless to add, the already suggested in other answers methods based on <code>sizeof</code> and other standard language facilities do not even come close detect the bit-ness of the machine. Instead they detect the bit-ness of the platform provided by the compiler implementation, which in general case is a totally different thing.</p>
",5
3843729,3843641,1,"<p>The pointer size</p>

<pre><code>sizeof (void *) * CHAR_BIT
</code></pre>

<p>is a good indicator, but might be misleading on more exotic architectures (eg if the size of the address bus is no multiple of the word size) and only represent the execution environment (which might be different from the actual hardware - see <a href=""https://stackoverflow.com/questions/3843641/32-bit-or-64-bit-using-c-code/3843722#3843722"">AndreyT's answer</a>).</p>

<p>During the preprocessing phase, the best you can do within the framework of the C language is something like</p>

<pre><code>UINTPTR_MAX == UINT64_MAX
</code></pre>

<p>The same limitations as above apply.</p>
",0
3843759,3843641,0,"<p>Yes, if running on an x86 processor use the CPUID instruction:</p>

<p><a href=""http://en.wikipedia.org/wiki/CPUID"" rel=""nofollow"">http://en.wikipedia.org/wiki/CPUID</a></p>
",3
3844907,3843641,1,"<p>There is no such thing as 32 bit or 64 bit environments, this is just too much of an oversimplification. You have several characteristics of integer, pointer, and float sizes that come into play if you want to write a portable application.</p>

<p>The size of your different integer types can be checked with the appropriate macros such as <code>UINT_MAX</code> etc, pointer size by <code>UINTPTR_MAX</code>. Since there might be padding bits, to deduce the width of the types you should print something like <code>(unsigned long long)(T)-1</code> where <code>T</code> is an unsigned type.</p>
",0
2038682,2038619,1,"<p>A module is generally a unit of functionality, like a class or a set of functions.  The .h file is just a header, containing method signatures, but no implementation.  The implementation is found in the corresponding .c file.</p>

<p>At compile time, code that uses those functions only needs to import the header file; the implementation can be compiled separately and is linked afterwards in a linker step.</p>

<p><strong>Edit</strong>: here is a link to the Wikipedia article on header files:  <a href=""http://en.wikipedia.org/wiki/Header_file"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Header_file</a></p>
",0
2038735,2038619,2,"<p>It is generally a good idea to declare one class per header (.h or .hpp) and implement its content in one .cpp file. In case of C, you group the functions by what they do or the context they are used in and also declare them in one header and implement in one .c file. For instance: math, such as square roots, trigonometry stuff (sine, cosine, tangent), powers, perhaps also min/max functions (although they're beter off as macros in most cases) would reside in their very own .h/.c or .hpp/.cpp pair of files.</p>

<p>Of course, you <em>can</em> ignore this completely and stuff all your code in a single .c(pp) file, no header at all. It'll just become completely unreadable :).</p>
",0
2039133,2038910,2,"<p>Others have answered your question.  The technique of declaring <code>ptr</code> inside <code>struct String</code> with zero size is called ""<a href=""http://c-faq.com/struct/structhack.html"" rel=""nofollow noreferrer"">the struct hack</a>"", and <a href=""http://home.datacomm.ch/t_wolf/tw/c/c9x_changes.html"" rel=""nofollow noreferrer"">wasn't portable until C99</a> (although it was widely used even before C99, and seems to work everywhere).  The idea is that <code>ptr</code> uses 0 bytes, so if you have a pointer to <code>ptr</code>, and want one to the original struct, you would use the <code>STRING</code> macro.  You are subtracting the size of the <code>struct</code> from the address of the <code>ptr</code> member, and thus getting the start address of the <code>struct</code>.</p>

<p>A better way to get the start address of a <code>struct</code> given a pointer to any of its members is to use <code>offsetof()</code> macro defined in <code>stddef.h</code>.  <code>offsetof(struct type, member)</code>, as the name implies, gives the offset of <code>member</code> in <code>struct type</code>:</p>

<pre><code>#define STRING(x) ((String *)(((char *)(x) - offsetof(struct String, ptr))))
</code></pre>

<p>Then you can do:</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct String {
    int length;
    int capacity;
    unsigned check;
    char ptr[0];
} String;

#define STRING(x) ((String *)(((char *)(x) - offsetof(struct String, ptr))))

int main(void)
{
    String *s = malloc(sizeof *s + 100);
    String *t;
    char *mystring = s-&gt;ptr;
    t = STRING(mystring);
    assert(t == s);
    return EXIT_SUCCESS;
}
</code></pre>

<p><code>offsetof()</code> is defined in <code>stddef.h</code>.</p>

<p>Note that in C99, ""struct hack"" would declare <code>ptr</code> inside the <code>struct</code> as:</p>

<pre><code>char ptr[];
</code></pre>

<p>i.e., without a size.</p>
",0
2038932,2038910,8,"<p>You're casting <code>s</code> to a <code>String *</code>. Then you're subtracting one from it (making it point to the previous whatever).</p>

<p>Anything more specific would need to know the definition of <code>String</code> - but (WILD SPECULATION) I would guess the application uses dual VB/C-style strings (null terminated, preceded by the length), and this function changes it from a form suitable for C functions (pointer to the first character) into one usable for the other type (pointer to the length).</p>
",3
2038946,2038910,0,"<ul>
<li>(String*) = type cast to pointer to String object,</li>
<li>s = the string,</li>
<li>-1 = point to one String object's length before in the memory block</li>
</ul>

<p>Don't know why the macro is made this way. Possibly the definition of String requires this, but that's just a wild guess.</p>
",2
2039020,2038910,5,"<p>Mechanically, the macro works as others have already described it.  Semantically, though, you can think of this as a form of casting from <code>char *</code>s to <code>String *</code>s.</p>

<p>The <code>String</code> structure is the header of a counted string, ie, one where you know the total length without having to scan for a NUL byte.  This particular version also keeps the total allocated.  You would create one as follows:</p>

<pre><code>struct String *str = malloc(sizeof(*s) + maxlen);
str-&gt;length = 0;
str-&gt;capacity = maxlen;
str-&gt;checked = /* ??? */;
</code></pre>

<p>There should be some assorted functions around somewhere to manipulate these counted strings.</p>

<p>The macro itself is a hack to go from a plain <code>char *</code>, assumed to point to the first character of the a <code>String</code> as allocated above, back to a <code>String *</code>.  It would be used something like this:</p>

<pre><code>/* allocate str as above */
char *s = str-&gt;p;
</code></pre>

<p>Now, through a chain of function calls or returns, you somehow loose track of the String structure containing <code>s</code>, and you need to find it again.  You write:</p>

<pre><code>String *str2 = STRING(s);
</code></pre>

<p>This is not a particularly good way to implement a counted string in C, but it demonstrates a technique that one sees from time to time.</p>
",1
2039158,2039138,0,"<p><code>src</code> is a <code>char *</code>; length is an <code>int</code>.  The compiler is therefore treating this line as similar to:</p>

<pre><code>length = (int) (src - 2 * sizeof(int));
</code></pre>

<p>I'm not sure what's confusing to you about the warning, and I'm also confused about what your code is trying to do.  My suggestion, then, is to try the following test code, and see what it prints:</p>

<pre><code>void test(void) {
    char *foo = ""hello\n"";

    printf(""%s\n"", foo);
    printf(""%d\n"", (int) foo);
    printf(""%s\n"", foo+1);
    printf(""%d\n"", ((int) foo) + 1);
}
</code></pre>

<p>you'll note that arithmetic makes more sense in one use of the pointer than in the other.</p>
",0
2039159,2039138,0,"<p><code>src - 2 * sizeof(int)</code> is pointer arithmetic - the result of that expression is another <code>char*</code> pointer. You're trying to assign a <code>char*</code> to <code>length</code>, which is an <code>int</code>, and that's why you're getting the error. I don't know what this function is supposed to do, but if you really wanted to you could cast the value to an <code>int</code>: <code>length = (int)(src - 2 * sizeof(int))</code>. But again, I don't see the use in your function.</p>
",0
2039161,2039138,0,"<p>Sure. </p>

<p><code>src</code> is a pointer; <code>2 * sizeof(int)</code> is an integer value.</p>

<p>While it is indeed legal </p>

<ol>
<li><p>to subtract two pointers from one another (the result being the differences in their addresses, as an <s>integer</s> integral type, perhaps <s><code>size_t</code></s><code>ptrdiff_t</code>), and also</p></li>
<li><p>to subtract an integer from a pointer (the result being a pointer to a location a bit before that pointer),</p></li>
</ol>

<p>it is not legal to try to assign the result from (2) to an integer variable (<code>length</code>).</p>
",2
2039172,2039138,1,"<p>I suspect you have a string struct like this:</p>

<pre><code>struct string {
    int length;
    int somethingelse; /* thanks alok */
    char *str;
}
</code></pre>

<p>and this function is trying to access the length field when given a pointer to the str? Am I correct? I imagine this is what isOurs checks for (to make sure it's not any old string). In which case, you want this:</p>

<p><strike><code>length = (*((int*)(src - 2))) * sizeof(int);</code></strike></p>

<pre><code>int utstrlen(char* src){
    int length=0 ;
    if(isOurs(src) ==1){
          length = *((int*)(src - (2 * sizeof(int)))); /* from str moveback 2 ints worth*/
    }
    else {
        //return strlen(src) ?
    }
    return length;
}
</code></pre>

<p>But ideally you wouldn'd do that. It's not portable or maintainable. What happens if the compiler inserts padding you don't know about? The C99 standard says it will not put padding between the 0 sized array and the previous field, but there's nothing to stop it going mad with the other ones (if you have a mixture of types, for instance).</p>

<p>What happens if someone comes along later and inserts more data into the structure? Naturally, they'd have to put it before the field str, as the 'struct hack' works by having it at the end. Ideally you should be using offsetof() to do this, which is a standard macro. Alok provides a better solution here and 
<a href=""https://stackoverflow.com/questions/2038910/ugly-macro-interpretation-just-1-line/2039133#2039133"">Ugly Macro Interpretation (just 1 line)</a></p>

<p>edit (it seems in the 2 minutes it took me to type that new last paragraph, Alok's offsetof() answer has been accepted over this one ;) ) </p>
",6
2039230,2039138,3,"<p>Based upon your <a href=""https://stackoverflow.com/questions/2038910/ugly-macro-interpretation-just-1-line"">previous question</a>, you want</p>

<pre><code>length = *((int *)(src - 2 * sizeof(int)));
</code></pre>

<p>although that assumes no padding.  A better way would be to use <code>offsetof()</code>:</p>

<pre><code>String *beg = (String *)(src - offsetof(struct String, ptr));
length = beg-&gt;length;
</code></pre>

<p>I am assuming you are using the struct from your previous question.</p>
",0
5556716,5556694,1,"<p>The term for what you're looking for is Preprocessor Directives.</p>

<p><code>#ifndef</code> doesn't need to be followed by a filename, for example it's common to see <code>#ifdef WINDOWS</code> or <code>#ifndef WINDOWS</code>, etc.</p>
",1
5556748,5556694,0,"<p><code>#ifndef</code> means ""if not defined"". It is commonly used to avoid multiple <code>include</code>'s of a file.</p>
",0
5556761,5556694,5,"<p>Header files will often use logic like this to avoid being included
more than once. The first time a source file includes them, the name
isn't defined, so it gets defined and other things are done.
Subsequent times, the name is defined, so all that is skipped.</p>
",3
5557207,5556694,-1,"<p>Tom Zych: ""Header files will often use logic like this to avoid being included more than once.""</p>

<p>This is true but it really is only necessary for ""public"" headers, like headers for library functions, where you don't have any control over how the headers are included.</p>

<p>This trick is unnecessary for headers used in projects where you have control over how things are included. (If there's a use for them outside of public headers, it's not a common one).</p>

<p>If you avoid using them in ""private"" headers, you'll more likely include headers in a less haphazard way.</p>
",0
5557394,5556694,2,"<p>The one you posted, in particular, is called an <a href=""http://en.wikipedia.org/wiki/Include_guard"" rel=""nofollow"">Include Guard</a>.</p>
",0
2182405,2182103,2,"<p>Perhaps it doesn't <em>feel</em> safe because of the magic happening behind the scenes. The C runtime and/or the OS itself is actively tracking the memory returned by malloc including its size and location. See though it feels like you are passing a typeless pointer back to free(), you in fact passing back a reference to an object the memory manager is actively tracking.</p>
",0
2182522,2182103,3,"<p>In C it is perfectly safe, because there are no destructors to call.</p>

<p>The memory system keeps track of the size of allocations.</p>

<p>In C++ you must delete the same type you <em>new</em>, including using the <code>delete[]</code> operator to delete new'ed arrays.</p>

<p>This is just to make sure destructors are called.</p>
",0
2182108,2182103,44,"<p>Yes.</p>

<p>malloc returns <code>void *</code> and free takes <code>void *</code>, so some of your casts are meaningless, and you're always freeing a <code>void *</code> even if you're starting with some other sort of pointer.</p>
",0
2182109,2182103,0,"<p>yes it is safe.</p>
",0
2182112,2182103,6,"<p>Yes -- <code>free</code> takes a pointer to void, so when you call it, the pointer is (implicitly) cast to a pointer to void in any case.</p>

<p>The rest of your code isn't quite so safe:</p>

<pre><code>void* p = (void*)malloc(sizeof(foo));
</code></pre>

<p>You should <em>not</em> cast the return from malloc (in C). This can cover up the mistake of forgetting to <code>#include &lt;stdlib.h&gt;</code></p>
",0
2182113,2182103,3,"<p>Yes.  The function prototype for <code>free</code> is even:</p>

<pre><code>void free(void *ptr);
</code></pre>
",0
2182116,2182103,18,"<p>Yes, it's safe. When allocating memory, the runtime library keeps track of the size of each allocation. When you call free(), it looks up the address, and if it finds an allocation for that address, the correct amount of memory is freed (the block that was allocated at that address).</p>
",0
4002485,4002442,1,"<p>I'd recommend you start with a book on C. It's not a good idea to learn a new language in constant comparison with a previous one, you end up learning what's different and not what's new and unique.</p>

<p>Take a look at Kernighan and Ritchie's book, or Deitel &amp; Deitel's. They will both strike you as overly basic at first, but you'll end up with a much more solid knowledge of the language.</p>

<p><strong>edit</strong>: a friend of mine right here suggests you also find something on data structures and algorithms after you've grasped the language, since you'll be working in an environment with no objects.</p>

<p>Hope it helps!</p>
",0
4002491,4002442,4,"<p>Don't try to learn C from C++ books/web sites.  Start with something aimed only at C.  A great place is <a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">The C Programming Language</a>.  It's the original and still one of the best programming language books out there.</p>

<p>Learning C is going to be a struggle because it's a different kind of language.  It's a procedural language, not an object oriented language.  It will be good to stretch your brain in learning it.  You'll likely also learn a lot more about the way your OS works because it's down much closer to the metal. </p>

<p>Note also that it's a much less complex language and thus is missing a lot of the niceties of a modern language.  There is no BCL/.Net Framework.  As you noticed, there is no string class (although there are string functions).</p>
",1
4002499,4002442,0,"<p>I'll answer you question, but first: Going from C# to C is like going from a plastic toothbrush to a wooden one... I see no advantage.</p>

<p>So:</p>

<p>Namespaces - No, there aren't any in C. This is a C++/C# feature. You should be able to compensate with prefixes. (namespace_myClass).</p>

<p>As for classes, I don't know how to help you. I am a C++ programmer (not C), but C does have struct, though I don't know if you can have member functions.</p>

<p>Header files and includes are syntactically the same. For example:</p>

<pre><code>#include &lt;Windows.h&gt;
</code></pre>

<p>gives you windows functionality. Note that, you may need to link in libraries for many header files, like openGL.</p>

<p>And what will we do without string? You could make your own, or you can manually manage C strings (char*) with the C functions such memcpy, ect...</p>

<p>Farewell and goodluck!</p>
",2
4002526,4002442,0,"<p>C++ is a superset of C. So anything you can do in C, you can do in C++.</p>

<p>I think it is a good idea to learn C. It will make you have to deal with memory and resource management, structured programming vs object-oriented, a it has a much smaller standard library as well (compared to C#). </p>
",2
4002621,4002442,0,"<p><a href=""http://publications.gbdirect.co.uk/c_book/"" rel=""nofollow"">http://publications.gbdirect.co.uk/c_book/</a></p>

<p><a href=""http://www.coronadoenterprises.com/tutorials/c/c_topics.html"" rel=""nofollow"">http://www.coronadoenterprises.com/tutorials/c/c_topics.html</a></p>

<p><a href=""http://www.cyberdiem.com/vin/tutorials/"" rel=""nofollow"">http://www.cyberdiem.com/vin/tutorials/</a></p>

<p>try the above links</p>
",0
5526260,5526249,4,"<p>The first example is recommended but also you need to put this line as the last one in the main()</p>

<pre><code>return 0;
</code></pre>

<p>which returns zero to the system indicating that everything went alright.</p>
",2
5526271,5526249,0,"<p>Both code example will have the same behavior once it is compiled.</p>

<p>The first example is more close to standard C 89. It's just missing a return statement (that is optional in C 99).</p>

<p>Compiler may start complaining if you chose a strict compliance to C 89.</p>
",2
5526374,5526249,2,"<h2>1. main() return type</h2>

<h3>- For managed applications:</h3>

<p>In managed environments, such as an operating system, each application should return it's status to the OS on exit. For example in Unix, application will return 0 on success and some non-zero value in case of an error occurred. </p>

<p>To do that in your application, you should specify that <code>main()</code> function will return integer: <code>int main()</code></p>

<p>So, you normally would write:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
      printf (""Hello World!\n"");
      getch();

      return 0;
}
</code></pre>

<p>However, (as pointed out already) <code>return 0;</code> is optional, and compiler will automatically add this statement in the end of <code>main()</code> function if <code>main()</code> is specified to return <code>int</code> value.</p>

<h3>- For non-managed applications:</h3>

<p>Non-managed applications, ones that are not managed by OS or some kind of environment, do not need (and cannot) report it's status, because there is nowhere to report.</p>

<p>Examples of such non-managed application would be:</p>

<ul>
<li>application in small embedded systems, where there is usually no OS, and there is only one application running (so it has nowhere to report).</li>
<li>OS kernel itself - it is the top level application that is the managing environment itself.</li>
</ul>

<p>Moreover, these applications usually never exit and run in the loop until the power is shut down.</p>

<p>In these cases (although sometimes non-managed applications don't have <code>main()</code> at all), <code>void</code> should be the return type of <code>main()</code> function:</p>

<pre><code>#include &lt;stdio.h&gt;

void main(void)
{
      printf (""Hello World!\n"");

      while (1);
}
</code></pre>

<h2>2. main() arguments</h2>

<p>In managed environments application can not only return it's status on exit, it can also input some parameters on launch.</p>

<p>For example, in Unix you would use GCC compiler with some parameters:</p>

<pre><code>gcc -std=c99 -pedantic hello.c -o /tmp/hello
</code></pre>

<p>in this case we launch GCC with some textual parameters such as <code>-std=c99</code> wich sais that the program should be compiled according to C99 standard.</p>

<p>To be able to input parameters in your program you can declare:</p>

<pre><code>int main(int argc, char *argv[])
</code></pre>

<p>You can read <a href=""http://publications.gbdirect.co.uk/c_book/chapter10/arguments_to_main.html"" rel=""nofollow"">here</a> more about it.</p>

<p>However, if you don't want to input any arguments, you can leave it <code>void</code>:</p>

<pre><code>int main(void)
</code></pre>

<h2>3. Dropped out types (implicit type declaration)</h2>

<p>Sometimes you can find programs where input or output types are not declared at all:</p>

<pre><code>int main()
</code></pre>

<p>or</p>

<pre><code>main(int argc, char *argv[])
</code></pre>

<p>or even just</p>

<pre><code>main()
</code></pre>

<p>This is very sloppy programming style and it is strongly discouraged in C. In case there is no input arguments, or function does not return any value you should explicitly specify <code>void</code>. If you don't specify any type for function or arguments, compilers will always assume <code>int</code>. That means that <code>main()</code> will be transformed by compiler to <code>int main()</code>. </p>

<p>(<code>int</code> is the default type in C, because language designers, Kernighan or Ritchie assumed that it will be the most used type, and decided to allow to dropp type declaration in case of <code>int</code>s)</p>
",9
2458287,2458259,2,"<p>For a constant value, the required calculation is going to be constant too. So, I recommend you calculate the value using your [desktop calculator / MATLAB / other] then hard-code it in your C code.</p>
",1
2458313,2458259,3,"<p>You can get high-precision math from specialized libraries, but if all you need is 5 significant digits then the built-in <code>float</code> and <code>double</code> types will do fine. Let's go with <code>double</code> for maximum precision.</p>

<p>The negative 7<sup>th</sup> power is just 1 over your number to the 7<sup>th</sup> power, so...</p>

<pre><code>double k = 1.2345678;  // your constant, whatever it is
double ktominus7 = 1.0 / (k * k * k * k * k * k * k);
</code></pre>

<p>...and that's it!</p>

<p>If you want to print out the value, you can do something like</p>

<pre><code>printf(""My number is: %9.5g\n"", ktominus7);
</code></pre>
",5
2458322,2458259,-3,"<p>you can use log to transform small numbers into larger numbers and do your math on the log transformed version. it's kind of tricky but it will work most of the time.  you can also switch to python which does not have this problem as much.</p>
",3
2458353,2458259,0,"<p><a href=""http://en.wikipedia.org/wiki/Long_double"" rel=""nofollow noreferrer"">long double</a> offers the best precision in most cases and can be statically allocated and re-used to keep waste to a minimum. See also <a href=""http://en.wikipedia.org/wiki/Quadruple_precision"" rel=""nofollow noreferrer"">quadruple precision</a>. Both change from platform to platform. Quadruple precision says the left most bit (1) continues to dictate signedness, while the next 15 bits dictate the exponent. IEEE 754 (i.e binary128) if the links provided aren't enough, they all lead back to <code>long double</code> :)</p>

<p>Simple shifting should take care of the rest, if I understand you correctly?</p>
",0
2458470,2458259,1,"<p>In the realm of computer floating-point formats, five significant digits is not a lot. The 32-bit IEEE-754 floating-point type used for <code>float</code> in most implementations of C has 24 bits of precision, which is about 7.2 decimal digits. So you can just use floating-point with no fear. <code>double</code> usually has 53 bits of precision (almost 16 decimal digits).  Carl Smotricz's answer is fine, but there's also a <code>pow</code> function in C that you can pass <code>-7.0</code> to.</p>

<p>There are times when you have to be careful about numerical analysis of your algorithm to ensure you aren't losing precision with intermediate results, but this doesn't sound like one of them.</p>
",0
3939676,3939575,6,"<p>No, and for good reason. Demanding reentrancy of <code>malloc</code>, even if only for special <code>_r</code> functions, would impose massive performance costs and likely precludes many high-performance implementations to begin with. Why do you need reentrancy? If you're trying to allocate memory from a signal handler, you might use <code>mmap</code>, but a better approach would be moving as much code as possible out of the signal handler and using the signal handler itself only to set a flag that will get picked up by another part of your program after the signal handler returns.</p>
",3
5450119,5450097,4,"<p>Structure layout is a compiler implementation detail, affected by the default packing.  Endianness <em>normally</em> only affects the order of the bytes in a structure member value, not the layout.  Check the small print in the compiler manual or use sizeof and the offsetof macro to experiment.</p>

<p>The layout you documented in your question is indeed very common for a 32-bit LE compiler.</p>
",0
5450132,5450097,7,"<p>I think you'll find <a href=""https://stackoverflow.com/questions/281045/do-class-struct-members-always-get-created-in-memory-in-the-order-they-were-decla"">this question</a> useful. The endianess is usually relevant for a word in the memory, not to the whole structure.</p>
",0
5450220,5450097,1,"<p>The structure members will be in the order declared, with padding inserted as necessary so each field is properly aligned for its type and with padding inserted as necessary at the end such that in an array each subsequent structure is properly aligned and begins immediately after the end of the previous structure. It is also possible (but unlikely) that additional unnecessary padding will be inserted between any two elements or at the end.</p>

<p>Each field itself will be stored as appropriate for the type on the compiler and architecture, e.g. the int 10 would be stored as the bytes <code>0a 00 00 00</code> on a normal little-endian machine with 32-bit ints.</p>
",0
2074716,2074216,1,"<p>Arrays are not first-class objects in C; when you pass an array as a function parameter, the type of the array expression is implicitly converted from ""N-element array of T"" to ""pointer to T"", and its value is set to point to the first element in the array[1].  </p>

<p>In the context of a function parameter declaration, <code>int a[]</code> is the same as <code>int *a</code> (but this is true <em>only</em> in the context of a function parameter declaration); your <code>searchHaystack</code> function receives two pointers to char, which correspond to the first elements of the respective arrays.  The debugger doesn't show you the whole array, because in the context of the function they are not arrays.  </p>

<p>Also, <strong>NEVER, NEVER, NEVER USE<code>gets()</code></strong>.  Ever.  It <em>will</em> introduce a point of failure in your code.  Use <code>fgets()</code> instead.  C does no bounds checking on arrays.  If you call <code>gets()</code> for a buffer sized to hold 10 characters, and the user types in 100 characters, <code>gets()</code> will happily store those extra 90 characters in the memory following your buffer, potentially clobbering something important and leading to a crash or worse (buffer overruns are a common exploit for malware; the Morris worm exploited a call to <code>gets()</code> in sendmail).  </p>

<p>The warning is coming from you using <code>==</code> instead of <code>=</code> to assign your loop counters.  </p>

<ol>
<li>The exceptions to this rule are when the array expression is an operand of either the <code>sizeof</code> or address-of (<code>&amp;</code>) operators, or when the array is a string literal being used to initialize another array in a declaration.</li>
</ol>
",0
2074246,2074216,1,"<p>These are character arrays not strings.  In C string are of type char * and you have to allocate the memory for them.</p>

<p>Of course when you say varname[5] that is the same as saying *(varname+5)</p>

<p>Basically you are going to have to learn about pointers to use strings in C.</p>

<p><em>EDIT</em></p>

<p>As pointed out below (and above by me) you can use character arrays like strings in C.   HOWEVER, my point is that if you don't learn a little bit about pointers you are going to be in big trouble.</p>

<p>For example:</p>

<ul>
<li><p>Not being able to view the string in the debugger.</p></li>
<li><p>Not putting a null as the last character in the array and having crazy random bugs</p></li>
<li><p>Forgetting that you only allocated X bytes for the array and going over the end</p></li>
</ul>

<p>etc.</p>

<p>If you don't understand how pointers work in C, it is really hard -- if not impossible to work with the language.</p>

<p>I expect the prof will cover it next week.</p>
",1
2074253,2074216,2,"<p>Actually, the entire array IS being passed, the debugger only shows the first char by default because in C, the system does not know the size of an array.  It is something the program has to keep track of.  Since you are using strings though, which are typically null terminated, try setting the watch variable ""(char*)cHaystack"" (without quotes) and see what the debugger shows then.</p>

<p>Also, assignment statements should have one = sign, not the double == sign.  So:</p>

<pre><code>for (iCntr = 0; ...
</code></pre>

<p>Should be used, NOT:</p>

<pre><code>for (iCntr == 0; ...
</code></pre>

<p>Same with the other for loops.</p>
",1
2074254,2074216,1,"<p>You're starting the loop with iCntr == 0
This is a comparison, so it does <strong>not</strong> set iCntr to zero.</p>

<p>Use iCntr = 0 (a single equals sign)</p>
",0
2074272,2074216,0,"<p>The warning is probably caused by </p>

<pre><code>iCntr == 0,iCntr2 == 1, iCntr == iOffset
</code></pre>

<p>I guess you were going, in fact, for:</p>

<pre><code>iCntr = 0,iCntr2 = 1, iCntr = iOffset
</code></pre>

<p>As for passing the arrays, you could do something like ( using pointers ):</p>

<pre><code>void searchHaystack(char* cHaystack, int cHaystackSize, char* cNeedle, int cNeedleSize )
...
  for (iCntr = 0; iCntr &lt; cHaystackSize &amp;&amp; cHaystack[iCntr] != '\0'; ++iCntr )
</code></pre>
",0
2074289,2074216,1,"<p>The values are passed properly, but your expectation of how your debugger should display them is incorrect. As already mentioned, there is no <code>string</code> type in C. Instead, C uses <code>char*</code> variables -- pointers to characters; your <code>char[]</code> are equivalent to <code>char*</code>.</p>

<p><em>You</em> know that the pointed-to character is the first character in a longer string, but the debugger doesn't. It displays the character that the pointer points to -- which <em>you</em> know to be the first of a longer string. The debugger, however, only knows it's a <code>char*</code>, and there must be a <code>char</code> to be pointed at, so it displays that <code>char</code>.</p>
",0
5504212,5504195,4,"<p>You are using a post-increment operator which means the final check for <code>i &lt;= n</code> happens before <code>i</code> is incremented for the final time. In other words, when <code>i</code> is 5 your code:</p>

<pre><code>check if i &lt;= 5 -&gt; true

increment i -&gt; i is now 6

execute loop -&gt; executes for i = 6

check if i &lt;= 5 -&gt; false (i is now 6)
</code></pre>

<p>You should change to:</p>

<pre><code>while(++i &lt;= n)
</code></pre>
",2
5504228,5504195,0,"<p><code>i++</code> returns the value of <code>i</code> and only then increments <code>i</code>. (As opposed to <code>++i</code> which first incerements <code>i</code> and returns incremented value)</p>
",0
5504234,5504195,0,"<p>That's how <code>i++</code> works. you need <code>++i</code></p>
",0
5504280,5504195,0,"<p>You are doing one extra iteration of the loop.</p>

<p>Instead of <code>(i++&lt;=n)</code>, what you really want is making it <code>(i&lt;=n)</code> and then add the <code>i++;</code> after the <code>ret*=1</code>.</p>

<p>This is actually much more cleanly done using a for-loop IMHO.</p>
",0
5504291,5504195,3,"<p>Try to do one thing per statement.</p>

<pre><code>int factorial(int n)
{
    int i = 1, ret = 1;
    while(i&lt;=n)
    {
        i++;
        ret *= i;
    }
    return ret;
}
</code></pre>

<p>Check the differences between the versions above and below this text.</p>

<pre><code>int factorial(int n)
{
    int i = 1, ret = 1;
    while(i&lt;=n)
    {
        ret *= i;
        i++;
    }
    return ret;
}
</code></pre>
",0
2169532,2169509,3,"<p>In terms of code simplicity, you might want to check out the <code>realloc()</code> function; you can allocate an initial array of some size, and if the user enters too many numbers call <code>realloc()</code> to get yourself a bigger array and continue from there.</p>

<p>You don't, however, actually <em>need</em> to keep the numbers as you go along at all, at least if you only care about the average:</p>

<pre><code>int input;
int sum = 0;
int count = 0;
int average;

while (1) {
    scanf(""%d"", &amp;input);
    if (input &lt; 0) {
        break;
    }
    sum += input;
    count++;
}

average = sum / count;
</code></pre>
",3
2169539,2169509,0,"<p>Use a dynamic array data structure, like Vector in Java (java.util.Vector).</p>

<p>You can implement such a dynamic array yourself easily:</p>

<ul>
<li>allocate array of size N</li>
<li>as soon as you need more elements than N, allocate a new bigger array (e.g. with size N+10), copy the content of the old array into the new array and set your working reference to the new array and your array size variable N to the new size (e.g. N+10). Free the old array.</li>
</ul>
",5
2169541,2169509,2,"<p>Basically you start with a dynamically allocated array with a fixed size, and then allocate a new array that is bigger (say, twice as big as initial size) and copy the stuff from the old array to the new one whenever you run out of space.</p>

<p>For the second part of the problem, keep a counter of the number of items the user entered and use it when averaging.</p>

<p>Something like <a href=""http://fydo.net/gamedev/dynamic-arrays"" rel=""nofollow noreferrer"">this</a>.</p>
",0
2169543,2169509,3,"<p>If you're trying to compute an average, then you don't need to save the numbers. Save yourself the work of worrying about the array. Simply accumulate (add) each number to a single total, count each number, then divide when you're done. Two variables are all that you need.</p>

<p>With this method, you aren't in any risk of overflowing your array, so you can use a while loop... while (temp != -1)</p>
",0
2126443,2126411,0,"<p>Yes, the code you think is wrong:</p>

<pre><code>while (curr != NULL){//I think this is wrong
    if ((curr -&gt; left) == NULL){
        curr = curr -&gt; right;
    }
    else{
        curr = curr -&gt; left;
    }   
}
</code></pre>

<p>is wrong.  You are navigating curr to some part of your tree regardless of your current node.</p>

<p>You probably want to change your inner if to something like:</p>

<pre><code>if (p-&gt;freq &lt; curr-&gt;freq)
</code></pre>
",2
2127525,2126411,0,"<p>I don't know exactly what you are doing with this while-loop.</p>

<pre><code>while (curr != NULL){//I think this is wrong
    if ((curr -&gt; left) == NULL){
        curr = curr -&gt; right; // Why to go right here?!, isn't this an empty node?
    }
    else{
        curr = curr -&gt; left;
    }   
}
</code></pre>

<p>If I am looking for the nearest empty (NULL) left node, I will do this</p>

<pre><code>while (curr != NULL){
    if ((curr -&gt; left) == NULL){//The left node is NULL. Great, I found empty node.
        curr = NULL;
    }
    else{ //hmmm, left node is not empty. Lets go left for more nodes. 
        curr = curr -&gt; left;
    }   
}
</code></pre>

<p>But like this, searching will be going left-only. after some inserts the tree will not be balanced.</p>

<p>If you give more details, it will be more clear.</p>
",0
6352177,6352165,0,"<pre><code>printf(""%.2f"", 2.3678);   /* prints 2.37 */
</code></pre>
",3
6352178,6352165,3,"<p>Include the <code>math.h</code> header file and do this:</p>

<pre><code>float f;
f = 2.3678;
f = floor(f * 100) / 100;
// f = 2.36
</code></pre>
",4
6352976,6352165,0,"<p>Try this:</p>

<pre><code>f=f*100;
f=(int)f;
f=f/100;
</code></pre>
",0
3563039,3563022,1,"<p>You are only dealing with chars and char pointers. None of the char pointers are valid strings as they are not null terminated.</p>

<p>Try defining a string and see what it looks like. </p>
",0
3563044,3563022,3,"<p>If it were a ""string"" instead of a char, you would do something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

void AFunc (char *myStr, int *myNum) {
    myStr[0] = 'p'; // or replace the lot with strcpy(myStr, ""pax"");
    myStr[1] = 'a';
    myStr[2] = 'x';
    myStr[3] = '\0';
    *myNum = 9;
}

int main (void) {
    char someString[4];
    int n = 6;

    AFunc(someString, &amp;n);

    printf(""%s %d"", someString, n);
    return 0;
}
</code></pre>

<p>which outputs:</p>

<pre><code>pax 9
</code></pre>

<p>A ""string"" in C is really an array of characters terminated by the <code>\0</code> (NUL) character.</p>

<p>What the above code does is to pass in the address of the first character in that array and the function populates the four characters starting from there.</p>
",3
3563061,3563022,1,"<pre><code>    But what if the string was more than one char? How would the code look 
differently? Thanks for any help
</code></pre>

<p>Ofcourse, you would modify the other characters as well, but in the exact same way you did the first time. </p>

<ol>
<li>Declare a char array and pass its address</li>
<li>Modify values at those address</li>
</ol>

<p>A char array would be a more clear term for a string.</p>
",1
3563130,3563022,3,"<p>In C, a pointer to <code>char</code> isn't necessarily a string.  In other words, just because you have <code>char *x;</code>, it doesn't mean that <code>x</code> is a string.</p>

<p>To be a string, <code>x</code> must point to a suitably allocated region which has a <code>0</code> in it somewhere.  The data from the first character that <code>x</code> points to and up to the <code>0</code> is a string.  Here are some examples of strings in C:</p>

<pre><code>char x[5] = {0}; /* string of length 0 */
char x[] = ""hello""; /* string of length 5, the array length being 6 */
char *x = ""hello""; /* string of length 5.  x is a pointer to a read-only buffer of 6 chars */

char *x = malloc(10);
if (x != NULL) {
    strcpy(x, ""hello""); /* x is now a string of length 5.  x points
                           to 10 chars of useful memory */

}
</code></pre>

<p>The following are not strings:</p>

<pre><code>char x[5] = ""hello""; /* no terminating 0 */
char y = 1;
char *x = &amp;y; /* no terminating 0 */
</code></pre>

<p>So now in your code, <code>AFunc</code>'s first parameter, even though is a <code>char *</code> isn't necessarily a string.  In fact, in your example, it isn't, since it only points to a memory that has one useful element, and that's not zero.</p>

<p>Depending upon how you want to change the string, and how the string was created, there are several options.</p>

<p>For example, if the <code>myStr</code> points to a writable memory, you could do something like this:</p>

<pre><code>/* modify the data pointed to by 'data' of length 'len' */
void modify_in_place(char *data, size_t len)
{
    size_t i;
    for (i=0; i &lt; len; ++i)
        data[i] = 42 + i;
}
</code></pre>

<p>Another slightly different way would be for the function to modify <code>data</code> until it sees the terminating <code>0</code>:</p>

<pre><code>void modify_in_place2(char *data)
{
    size_t i;
    for (i=0; data[i]; ++i)
        data[i] = 42 + i;
}
</code></pre>
",0
2038415,2038397,3,"<p>You have to declare it in your header file as</p>

<p>extern char error[];</p>

<p>and in your code file (.c file) , declare it</p>

<p>char error[1024];</p>

<p>You are allocating it twice</p>
",3
2038446,2038397,-1,"<p>Why not use function like this:</p>

<p>in .h:</p>

<pre><code>char* GetErr();
</code></pre>

<p>and in .cpp:</p>

<pre><code>char* GetErr() { return error; }
</code></pre>

<p>Try to avoid global variables. In file scope its pretty safe, but if you try to use it trough many files it can cause big errors.</p>
",4
2196940,2196917,3,"<p>Here's a hack:</p>

<pre><code>// hack.c
int last_exit;

// hack.h
extern int last_exit;
#define exit(x) (exit)(last_exit = (x))
</code></pre>

<p>Won't work for <code>return</code>, but, hey, it's portable!</p>

<p>On a more maintainer-friendly note, you may want to consider writing some form of wrapper to do something similar to this for you. Hacking around how GCC implements <code>exit()</code> sounds like a maintenance nightmare. Better to write a few helper functions that exit for you, and maybe even mask them with macros if you're into that kind of thing. With a macro you might even be able to replace <code>return</code> calls, if you always call <code>return</code> with parenthesis. Though this sounds like even more of a maintenance nightmare.</p>
",4
2530059,2530040,2,"<p>A control-M isn't stored as a multiple key sequence in a text file.  It's generally stored as the ascii value 13, or 0x0d in hexadecimal.</p>

<p>So, your statement would be:</p>

<p>if (char[i] == 0x0d)</p>

<p>or</p>

<p>if (char[i] == '\x0d')</p>
",0
2530061,2530040,0,"<p>If you have a mutable array of <code>char</code> then if you need to remove a given character you'll need to move all the characters after the removed character up one place, not just assign a 'blank' to the given character.</p>

<p>It's probably easiest to do this with pointers.</p>

<p>E.g. (in place transformation):</p>

<pre><code>extern char *in;
char *out = in;

while (*in)
{
    if (*in != '\r')
        *out++ = *in;

    in++;
}

*out = '\0';
</code></pre>
",0
3932297,3932272,4,"<p>GNU <code>cpp</code> takes various <code>-d</code> options to output macro and define data. See their man pages for more details.</p>
",0
3932364,3932272,4,"<p>for gcc, you can use one of the following:</p>

<p>-dCHARS CHARS is a sequence of one or more of the following characters, and must not be preceded by a space. Other characters are interpreted by the compiler proper, or reserved for future versions of GCC, and so are silently ignored. If you specify characters whose behavior conflicts, the result is undefined.</p>

<p><code>M'
Instead of the normal output, generate a list of</code>#define' directives for all the macros defined during the execution of the preprocessor, including predefined macros. This gives you a way of finding out what is predefined in your version of the preprocessor. Assuming you have no file foo.h, the command
               touch foo.h; cpp -dM foo.h</p>

<p>will show all the predefined macros.</p>

<p>If you use -dM without the -E option, -dM is interpreted as a synonym for -fdump-rtl-mach. See Debugging Options. </p>

<p><code>D'
Like</code>M' except in two respects: it does not include the predefined macros, and it outputs both the <code>#define' directives and the result of preprocessing. Both kinds of output go to the standard output file.
</code>N'
Like `D', but emit only the macro names, not their expansions. </p>

<p><code>I'
Output</code>#include' directives in addition to the result of preprocessing. </p>

<p><code>U'
Like</code>D' except that only macros that are expanded, or whose definedness is tested in preprocessor directives, are output; the output is delayed until the use or test of the macro; and `#undef' directives are also output for macros tested but undefined at the time.</p>
",0
2287278,2287259,0,"<p>I'm not a C programmer, but if <code>static</code> in C means anything like it does in other languages I use STATIC STRUC, meaning that the structure is common amongst all instances of this class.</p>

<p>Say I had a class variable called Z. The usual behaviour is that the value of this variable is specific to a particular instance of a classs, but when it is static, all instances of the class share the same value of Z at all times.</p>

<p>I don't know how this applies to C, isn't C object-less?</p>
",0
2287281,2287259,1,"<p>static tells that a function or data element is only known within the scope of the
current compile. </p>

<p>In addition, if you use the static keyword with a variable that is local to a function, it allows the last value of the variable to be preserved between successive calls to that function.</p>

<p>So if you say:</p>

<pre><code>static struct ...
</code></pre>

<p>in a source file no other source files could use the struct type. Not even with an extern declaration. But if you say:</p>

<pre><code>struct ...
</code></pre>

<p>then other source files could access it via an extern declaration.</p>
",0
2287292,2287259,3,"<p>Outside a function, static makes whatever it's applied to have file scope. For example:</p>

<pre><code>int a_function(int x) { ... }
</code></pre>

<p>This function will have global linkage, and can be accessed by any other object file. You just have to declare it to use it, as is usually done in a header file:</p>

<pre><code>int a_function(int x);
</code></pre>

<p>However, if you use static in the definition, then the function is visible only to the source file where it is defined:</p>

<pre><code>static int a_function(int x) { ... }
</code></pre>

<p>In that case, other object files can't access this function. The same applies to variables:</p>

<pre><code>static int x;
</code></pre>

<p>This makes x a global variable, visible only within it's source file. A ""static struct"" by itself doesn't do anything, but consider this syntax:</p>

<pre><code>struct {
    int x;
    int y;
} p1, p2;
</code></pre>

<p>This declares two global variables (p1 and p2), each of an ""anonymous"" struct type. If you append static:</p>

<pre><code>static struct {
    int x;
    int y;
} p1, p2;
</code></pre>

<p>Then static applies to p1 and p2, making them visible only within their source file.</p>
",0
2838368,2838350,5,"<p>I would use the macro. It's more common and more idiomatic, and runs into fewer problems crossing translation units (i.e. you don't have to worry about declaring the macro static).</p>

<p>Additionally, by using a function pointer, you prevent inlining on most compilers.</p>

<p>Finally, with the function pointer, it's possible for clients to do this:</p>

<pre><code>int evil(const int bgr) { /* Do something evil */ }

bgr2rgb = evil
</code></pre>

<p>Sure, they probably don't want this, but it's possible there could be a variable named similar to <code>bgr2rgb</code> down the line where it only takes one typo....</p>

<p>The macro is safer, though I would define it this way -- there's no need for a function-like macro here:</p>

<pre><code>#define bgr2rgb rgb2bgr
</code></pre>
",3
2838448,2838350,6,"<p>Another possibility would be to just have the second function call the first and let the compiler worry about optimizing it (by inlining or generating a tail call).</p>
",1
4359535,4359500,2,"<p>It is possible to write it without the typedef but casts to function pointers without typedef are very ugly.</p>

<pre><code>int (*testFuncPtr)(void);
</code></pre>

<p>Casting to this function pointer would be done using</p>

<pre><code>(int (*)(void))
</code></pre>
",5
4359588,4359500,1,"<p>Well, it certainly is not the best way to include machine code into your C program. Use inline assembly. Since you metnion Ubuntu, I will mention that <strong>gcc</strong> is perfectly able to do that.</p>

<p>See <a href=""http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html"" rel=""nofollow"">http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a> for a start.</p>
",0
4359592,4359500,4,"<p>Best way to put assembly code in a C source file would be to use inline assembly.  Here's a good <a href=""http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html"" rel=""nofollow"">starting point</a>.  Example:</p>

<pre><code>int main(void)
{
 int x = 10, y;

 asm (""movl %1, %%eax;""
      ""movl %%eax, %0;""
  :""=r""(y) /* y is output operand */
  :""r""(x)  /* x is input operand */
  :""%eax""); /* %eax is clobbered register */
}
</code></pre>
",0
3305010,3305003,12,"<p>sprintf with formatting codes like %02d will give you two decimal places.</p>

<p>here's an example of the command
sprintf( string, ""file.%d"", file_number );</p>

<p>Here it puts the string ""file.2"" into the variable named string, assuming that 2 was in the variable named file_number.</p>

<p>you can use multiple like so:
sprintf(str, ""%02d/%02d/%4d"",day,month,year);</p>

<p>Look up the specs on sprintf for other kinds of formatting like floating point significant digits.</p>
",3
3305021,3305003,2,"<pre><code>printf(""%02d"", 9);
</code></pre>
",0
3305046,3305003,3,"<p>Along with <code>""%02d""</code> you can use <code>""%2.2d""</code> if you prefer. The latter style is handy when/if the actual width is in a variable so you do something like this:</p>

<pre><code>int width = 2;
int value = 9;

printf(""%*.*d"", width, width, value);
</code></pre>
",1
6894466,6860327,0,"<p>We are trying to avoid if statements to make code more readable.</p>

<pre><code>UINT A, B = 1;
bool fResult = false;

fResult = (A == B);

return(fResult);
</code></pre>

<p>And if there must be an condition to act on (not) equality, see this example.</p>

<pre><code>UINT A, B = 1;
bool fResult = false;

fResult = (A == B);

if(fResult)
{
  doThis();
}
else
{
  doThat();
}

return(fResult);
</code></pre>
",1
6349222,6349196,0,"<p><code>new</code> is a keyword. Choose a different variable name.</p>
",2
6349253,6349196,1,"<p>I believe the problem with <code>current = new;</code>  is that you are changing your local copy of <code>current</code>. After the function is done, this modification is not visible.</p>

<p>I suspect you want something like:</p>

<pre><code>static void binary_tree_insert_recursive(BinaryNode **current, BinaryNode **new)
{
    if (*current == NULL || (*current)-&gt;key == (*new)-&gt;key) {
    *current = *new;
    /* ... */
</code></pre>

<p>Well explained in the <a href=""http://c-faq.com/ptrs/passptrinit.html"" rel=""nofollow"">C FAQ</a>.</p>
",3
6349271,6349196,0,"<p>all that <code>current = new</code> does is make it so that the variable <code>current</code> points at the thing that <code>new</code> is pointing at. No copying takes place, and the function has no effect on that codepath.</p>
",0
6349281,6349196,1,"<p><code>current</code> is a pointer to a node. When you pass it to <code>binary_tree_insert_recursive</code> from <code>binary_tree_insert</code> the <em>value</em> of the pointer is passed.  So although it is changed inside the called function, the change is not reflected in the calling function.  You need to modify the function to take the <em>address</em> of the pointer you wish to change:</p>

<pre><code> static void binary_tree_insert_recursive(BinaryNode **current, BinaryNode *new)
 {
         if (*current == NULL || (*current)-&gt;key == new-&gt;key)  {
             *current = new; 
</code></pre>
",0
6102890,6102861,6,"<p>You're not initializing the new elements correctly.</p>

<p>Add <code>n-&gt;next = NULL;</code> to the <code>createNode</code> function.</p>
",8
6102898,6102861,0,"<p>Well, there's the fact that you have <code>insertTail</code> in the main but <code>addTail</code> in the code.</p>
",0
6102954,6102861,0,"<p>You're using 'malloc' which does NOT clear(fill with zeros) the memory space it allocates before it hands it back toyour.  In your first case(adding the head), addTail simply makes the newly allocated node the list head, complete with a very probably non-null 'next' field.  </p>

<ol>
<li>Try using calloc(1, sizeof(node))</li>
</ol>
",0
2169271,2169261,1,"<p>One method can do some comparisons with 'A', 'Z'.</p>

<p>The other method can use a pre-computed lookup table.</p>

<p>It's the first suggestion mentioned on the Wikipedia page for <a href=""http://en.wikipedia.org/wiki/Space-time_tradeoff"" rel=""nofollow noreferrer"">time-space tradeoffs</a>.</p>
",0
2169274,2169261,3,"<p>The classic trade-off is speed versus memory: either compute a result, or look it up in a table.</p>

<p>It should not be hard to figure out how these would look, for the <code>isupper()</code> function.</p>

<p>A few things make it perhaps unexpectedly complicated on today's mainstream CPU:s, though:</p>

<p>A table to support ASCII needs 128 bits, or 256 bits if you don't want to mask off the topmost bit yourself, assuming an 8-bit <code>char</code>. This is only 32 bytes, but that is probably still more than code that exploits the sequential nature of the ASCII mapping. Large code size is generally bad for performance, since it affects cache efficiency and generally exposes the large difference in bandwidth between today's CPU:s and their memory subsystems.</p>

<p>Code using explicit comparisons to compute the result, without exploiting the sequential mapping, will be pretty large, larger than the corresponding look-up table. This is not typical; it's easier to see the difference in the speed-versus-memory trade-off for cases where the code to compute a value is more compact than the look-up table.</p>
",0
2169285,2169261,0,"<p>You can save both space and time, actually. Upper case characters are contiguous in the ASCII table, so you just have to do this (this doesn't handle locales obviously, but I doubt that is the point of your exercise):</p>

<pre><code>BOOL isUpper(char c)
{
    return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z');
}
</code></pre>
",0
2169291,2169261,0,"<p>Upper case characters are ASCII hex 0x41 through 0x5A.  That means bit 0x40 is always set.  If you are sure that the argument is an ASCII character, you can just return:</p>

<p>(c &amp; 0x40);</p>
",2
2169293,2169261,13,"<h3>Original answer</h3>

<p>One version uses an array initialized with appropriate values, one byte per character in the code set (plus 1 to allow for EOF, which may also be passed to the classification functions):</p>

<pre><code>static const char bits[257] = { ...initialization... };

int isupper(int ch)
{
    assert(ch == EOF || (ch &gt;= 0 &amp;&amp; ch &lt;= 255));
    return((bits+1)[ch] &amp; UPPER_MASK);
}
</code></pre>

<p>Note that the 'bits' can be used by all the various functions like <code>isupper()</code>, <code>islower()</code>, <code>isalpha()</code>, etc with appropriate values for the mask.  And if you make the 'bits' array changeable at runtime, you can adapt to different (single-byte) code sets.</p>

<p>This takes space - the array.</p>

<p>The other version makes assumptions about the contiguity of upper-case characters, and also about the limited set of valid upper-case characters (fine for ASCII, not so good for ISO 8859-1 or its relatives):</p>

<pre><code>int isupper(int ch)
{
    return (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z');  // ASCII only - not a good implementation!
}
</code></pre>

<p>This can (almost) be implemented in a macro; it is hard to avoid evaluating the character twice, which is not actually permitted in the standard.  Using non-standard (GNU) extensions, it can be implemented as a macro that evaluates the character argument just once.  To extend this to ISO 8859-1 would require a second condition, along the lines of:</p>

<pre><code>int isupper(int ch)
{
    return ((ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) || (ch &gt;= 0xC0 &amp;&amp; ch &lt;= 0xDD));
}
</code></pre>

<p>Repeat that as a macro very often and the 'space saving' rapidly becomes a cost as the bit masking has a fixed size.</p>

<p>Given the requirements of modern code sets, the mapping version is almost invariably used in practice; it can adapt at run-time to the current code set, etc, which the range-based versions cannot.</p>

<hr>

<h3>Extended answer</h3>

<blockquote>
  <p>I still can't figure out how UPPER_MASK works. Can you explain it more specifically?</p>
</blockquote>

<p>Ignoring issues of namespaces for symbols in headers, you have a series of twelve classification macros:</p>

<ul>
<li><code>isalpha()</code></li>
<li><code>isupper()</code></li>
<li><code>islower()</code></li>
<li><code>isalnum()</code></li>
<li><code>isgraph()</code></li>
<li><code>isprint()</code></li>
<li><code>iscntrl()</code></li>
<li><code>isdigit()</code></li>
<li><code>isblank()</code></li>
<li><code>isspace()</code></li>
<li><code>ispunct()</code></li>
<li><code>isxdigit()</code></li>
</ul>

<p>The distinction between <code>isspace()</code> and <code>isblank()</code> is:</p>

<ul>
<li><code>isspace()</code> ¡ª?<em>space (<code>' '</code>), form feed (<code>'\f'</code>), new-line (<code>'\n'</code>), carriage return (<code>'\r'</code>), horizontal tab (<code>'\t'</code>), and vertical tab (<code>'\v'</code>)</em>.</li>
<li><code>isblank()</code> ¡ª <em>space (<code>' '</code>), and horizontal tab (<code>'\t'</code>)</em>.</li>
</ul>

<p>There are definitions for these sets of characters in the C standard, and guidelines for the C locale.</p>

<p>For example (in the C locale), either <code>islower()</code> or <code>isupper()</code> is true if <code>isalpha()</code> is true, but that need not be the true in other locales.</p>

<p>I think the necessary bits are:</p>

<ul>
<li><code>DIGIT_MASK</code></li>
<li><code>XDIGT_MASK</code></li>
<li><code>ALPHA_MASK</code></li>
<li><code>LOWER_MASK</code></li>
<li><code>UPPER_MASK</code></li>
<li><code>PUNCT_MASK</code></li>
<li><code>SPACE_MASK</code></li>
<li><code>PRINT_MASK</code></li>
<li><code>CNTRL_MASK</code></li>
<li><code>BLANK_MASK</code></li>
</ul>

<p>From these ten masks, you can create the other two:</p>

<ul>
<li>ALNUM_MASK = ALPHA_MASK | DIGIT_MASK</li>
<li>GRAPH_MASK = ALNUM_MASK | PUNCT_MASK</li>
</ul>

<p>Superficially, you can also use <code>ALPHA_MASK = UPPER_MASK | LOWER_MASK</code>, but in some locales, there are alphabetic characters that are neither upper-case nor lower-case.</p>

<p>So, we can define masks as follows:</p>

<pre><code>enum CTYPE_MASK {
    DIGIT_MASK = 0x0001,
    XDIGT_MASK = 0x0002,
    LOWER_MASK = 0x0004,
    UPPER_MASK = 0x0008,
    ALPHA_MASK = 0x0010,
    PUNCT_MASK = 0x0020,
    SPACE_MASK = 0x0040,
    PRINT_MASK = 0x0080,
    CNTRL_MASK = 0x0100,
    BLANK_MASK = 0x0200,

    ALNUM_MASK = ALPHA_MASK | DIGIT_MASK,
    GRAPH_MASK = ALNUM_MASK | PUNCT_MASK
};

extern unsigned short ctype_bits[];
</code></pre>

<p>The data for the character set; the data shown is for the first half of ISO 8859-1, but is the same for the first half of all the 8859-x code sets.  I'm using C99 designated initializers as a documentary aid, even though the entries are all in order:</p>

<pre><code>unsigned short ctype_bits[] =
{
    [EOF   +1] = 0,
    ['\0'  +1] = CNTRL_MASK,
    ['\1'  +1] = CNTRL_MASK,
    ['\2'  +1] = CNTRL_MASK,
    ['\3'  +1] = CNTRL_MASK,
    ['\4'  +1] = CNTRL_MASK,
    ['\5'  +1] = CNTRL_MASK,
    ['\6'  +1] = CNTRL_MASK,
    ['\a'  +1] = CNTRL_MASK,
    ['\b'  +1] = CNTRL_MASK,
    ['\t'  +1] = CNTRL_MASK|SPACE_MASK|BLANK_MASK,
    ['\n'  +1] = CNTRL_MASK|SPACE_MASK,
    ['\v'  +1] = CNTRL_MASK|SPACE_MASK,
    ['\f'  +1] = CNTRL_MASK|SPACE_MASK,
    ['\r'  +1] = CNTRL_MASK|SPACE_MASK,
    ['\x0E'+1] = CNTRL_MASK,
    ['\x0F'+1] = CNTRL_MASK,
    ['\x10'+1] = CNTRL_MASK,
    ['\x11'+1] = CNTRL_MASK,
    ['\x12'+1] = CNTRL_MASK,
    ['\x13'+1] = CNTRL_MASK,
    ['\x14'+1] = CNTRL_MASK,
    ['\x15'+1] = CNTRL_MASK,
    ['\x16'+1] = CNTRL_MASK,
    ['\x17'+1] = CNTRL_MASK,
    ['\x18'+1] = CNTRL_MASK,
    ['\x19'+1] = CNTRL_MASK,
    ['\x1A'+1] = CNTRL_MASK,
    ['\x1B'+1] = CNTRL_MASK,
    ['\x1C'+1] = CNTRL_MASK,
    ['\x1D'+1] = CNTRL_MASK,
    ['\x1E'+1] = CNTRL_MASK,
    ['\x1F'+1] = CNTRL_MASK,

    [' '   +1] = SPACE_MASK|PRINT_MASK|BLANK_MASK,

    ['!'   +1] = PUNCT_MASK|PRINT_MASK,
    ['""'   +1] = PUNCT_MASK|PRINT_MASK,
    ['#'   +1] = PUNCT_MASK|PRINT_MASK,
    ['$'   +1] = PUNCT_MASK|PRINT_MASK,
    ['%'   +1] = PUNCT_MASK|PRINT_MASK,
    ['&amp;'   +1] = PUNCT_MASK|PRINT_MASK,
    ['\''  +1] = PUNCT_MASK|PRINT_MASK,
    ['('   +1] = PUNCT_MASK|PRINT_MASK,
    [')'   +1] = PUNCT_MASK|PRINT_MASK,
    ['*'   +1] = PUNCT_MASK|PRINT_MASK,
    ['+'   +1] = PUNCT_MASK|PRINT_MASK,
    [','   +1] = PUNCT_MASK|PRINT_MASK,
    ['-'   +1] = PUNCT_MASK|PRINT_MASK,
    ['.'   +1] = PUNCT_MASK|PRINT_MASK,
    ['/'   +1] = PUNCT_MASK|PRINT_MASK,

    ['0'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['1'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['2'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['3'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['4'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['5'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['6'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['7'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['8'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,
    ['9'   +1] = DIGIT_MASK|PRINT_MASK|XDIGT_MASK,

    [':'   +1] = PUNCT_MASK|PRINT_MASK,
    [';'   +1] = PUNCT_MASK|PRINT_MASK,
    ['&lt;'   +1] = PUNCT_MASK|PRINT_MASK,
    ['='   +1] = PUNCT_MASK|PRINT_MASK,
    ['&gt;'   +1] = PUNCT_MASK|PRINT_MASK,
    ['?'   +1] = PUNCT_MASK|PRINT_MASK,
    ['@'   +1] = PUNCT_MASK|PRINT_MASK,

    ['A'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK|XDIGT_MASK,
    ['B'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK|XDIGT_MASK,
    ['C'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK|XDIGT_MASK,
    ['D'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK|XDIGT_MASK,
    ['E'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK|XDIGT_MASK,
    ['F'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK|XDIGT_MASK,
    ['G'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['H'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['I'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['J'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['K'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['L'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['M'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['N'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['O'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['P'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['Q'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['R'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['S'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['T'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['U'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['V'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['W'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['X'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['Y'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,
    ['Z'   +1] = ALPHA_MASK|UPPER_MASK|PRINT_MASK,

    ['['   +1] = PUNCT_MASK|PRINT_MASK,
    ['\\'  +1] = PUNCT_MASK|PRINT_MASK,
    [']'   +1] = PUNCT_MASK|PRINT_MASK,
    ['^'   +1] = PUNCT_MASK|PRINT_MASK,
    ['_'   +1] = PUNCT_MASK|PRINT_MASK,
    ['`'   +1] = PUNCT_MASK|PRINT_MASK,

    ['a'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK|XDIGT_MASK,
    ['b'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK|XDIGT_MASK,
    ['c'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK|XDIGT_MASK,
    ['d'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK|XDIGT_MASK,
    ['e'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK|XDIGT_MASK,
    ['f'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK|XDIGT_MASK,
    ['g'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['h'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['i'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['j'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['k'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['l'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['m'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['n'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['o'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['p'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['q'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['r'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['s'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['t'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['u'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['v'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['w'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['x'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['y'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,
    ['z'   +1] = ALPHA_MASK|LOWER_MASK|PRINT_MASK,

    ['{'   +1] = PUNCT_MASK|PRINT_MASK,
    ['|'   +1] = PUNCT_MASK|PRINT_MASK,
    ['}'   +1] = PUNCT_MASK|PRINT_MASK,
    ['~'   +1] = PUNCT_MASK|PRINT_MASK,
    ['\x7F'+1] = CNTRL_MASK,

    ...continue for second half of 8859-x character set...
};

#define isalpha(c)  ((ctype_bits+1)[c] &amp; ALPHA_MASK)
#define isupper(c)  ((ctype_bits+1)[c] &amp; UPPER_MASK)
#define islower(c)  ((ctype_bits+1)[c] &amp; LOWER_MASK)
#define isalnum(c)  ((ctype_bits+1)[c] &amp; ALNUM_MASK)
#define isgraph(c)  ((ctype_bits+1)[c] &amp; GRAPH_MASK)
#define isprint(c)  ((ctype_bits+1)[c] &amp; PRINT_MASK)
#define iscntrl(c)  ((ctype_bits+1)[c] &amp; CNTRL_MASK)
#define isdigit(c)  ((ctype_bits+1)[c] &amp; DIGIT_MASK)
#define isblank(c)  ((ctype_bits+1)[c] &amp; BLANK_MASK)
#define isspace(c)  ((ctype_bits+1)[c] &amp; SPACE_MASK)
#define ispunct(c)  ((ctype_bits+1)[c] &amp; PUNCT_MASK)
#define isxdigit(c) ((ctype_bits+1)[c] &amp; XDIGT_MASK)
</code></pre>

<p>As already noted, the names here are actually in the namespace reserved for users, so if you looked in a <code>&lt;ctype.h&gt;</code> header you'd find more cryptic names and they'd probably all start with one or two underscores.</p>
",5
3989635,3989607,3,"<p><code>static</code> and <code>extern</code> are mutually exclusive. If you want to access your <code>static char var1</code> from a different file, you'll have to remove the <code>static</code> and just make it a regular global. You don't need <code>volatile</code> at all.</p>

<p>Alternatively, you can make an accessor function that returns the value of <code>static char var1</code> and use that from your other module.</p>

<p>Side note: externs and exported function prototypes should generally go in header files.</p>
",0
3989643,3989607,3,"<p>No!  The whole point of <code>static</code> (in this context) is that you're stating that the variable is only visible from this translation module.</p>

<p>If you don't want this behaviour, then don't declare it as static.  Put <code>char var1 = 0;</code> in your source file, and <code>extern var1;</code> in the associated header file.</p>

<p>More generally, don't do this at all.  Accessing global variables between source files is probably a recipe for disaster.</p>
",0
2319774,2319766,21,"<pre><code>int my_negate(int x)
{
    return x == 0 ? 1 : 0;
}
</code></pre>
",5
2319785,2319766,7,"<p><code>!e</code> can be replaced by <code>((e)?0:1)</code></p>
",0
2319818,2319766,0,"<p>If you want to overload an operator, the proper prototype is:</p>

<pre><code>bool operator!();
</code></pre>

<p>I'm not a big fan of overloading operators, but some people like their syntactic sugar.
EDIT: This is C++ only! Put it in the definition of your class.</p>
",3
2319821,2319766,5,"<p>Remember the bang operator '!' or exclamation mark in english parlance, is built into the programming language as a means to negate.</p>

<p>Consider this ternary operator example:</p>

<pre>
(some condition) ? true : false;
</pre>

<p>Now, if that was negated, the ternary operator would be this</p>

<pre>
(some condition) ? false : true;
</pre>

<p>The common area where that can get some programmers in a bit of a fit is the <code>strcmp</code> function, which returns 0 for the strings being the same, and 1 for two strings not the same:</p>

<pre>
if (strcmp(foo, ""foo"")){

}
</pre>

<p>When really it should be:</p>

<pre>
if (!strcmp(foo, ""foo"")){
}
</pre>

<p>In general when you negate, it is the opposite as shown in the ternary operator example...</p>

<p>Hope this helps.</p>
",3
2319850,2319766,3,"<p>C considers all non-zero values ""true"" and zero ""false"".  Logical negation is done by checking against zero.  If the input is exactly zero, output a non-zero value; otherwise, output zero.  In code, you can write this as <code>(input == 0) ? 1 : 0</code> (or you can convert it into an <code>if</code> statement).</p>

<p>When you ask how to ""make your own ! method"", do you mean you want to write a function that negates a logic value or do you want to define what the exclamation-point operator does?  If the former, then the statement I posted above should suffice.  If the latter, then I'm afraid this is something that can't be done in C.  C++ supports operator overloading, and if doing this is a strict necessity then I would suggest looking there.</p>
",0
2320076,2320036,2,"<p>Hey, it was exactly three clicks.
google -> 1.st result - wiki/Parity_bit -> external link -> 
<a href=""http://graphics.stanford.edu/~seander/bithacks.html#ParityNaive"" rel=""nofollow noreferrer"">http://graphics.stanford.edu/~seander/bithacks.html#ParityNaive</a></p>
",0
3911465,3911459,4,"<p><strong>test</strong> is also a command line application: </p>

<blockquote>
  <p>test - check file types and compare values</p>
</blockquote>

<p>The proper way of executing your little app would be:</p>

<p><strong>./test > output</strong></p>
",3
5511048,5511002,2,"<p>Your linker is trying to find a function like:</p>

<pre><code>char * ToLowerSTR(char *)
</code></pre>

<p>but you have defined your function to take <code>WCHAR</code> as argument.<br>
Look at the declaration of your function and see if it says <code>WCHAR*</code> or <code>char*</code></p>
",0
5511099,5511002,1,"<p>The error is due to your header file declaring a <code>char * ToLowerSTR(char *)</code> whereas your cpp file has a different function, <code>char * ToLowerSTR(WCHAR *)</code></p>

<p>In order to correctly convert, you need to pass the length of the WCHAR buffer to your <code>ToLowerStr</code> function (Why ToLower btw, what is it supposed to do?). You cannot use <code>sizeof</code> on the passed <code>WCHAR *</code> - that'll give you the size of a pointer, not the length of the buffer it points to.</p>

<pre><code>bool charToWChar(char const * Source, wchar_t * Dest, size_t DestLen) {
  return MultiByteToWideChar(CP_ACP, 0, Source, -1, Dest, DestLen) != 0;
}
</code></pre>

<p>Then call it like this:</p>

<pre><code>char const * myString = ""abc"";
wchar_t Buffer[100];
charToWChar(myString, Buffer, 100);
</code></pre>
",0
5511108,5511002,1,"<p>What Default said, plus: OMG, you're putting stuff into where <code>str</code> points, without pointing it in the right direction (like <code>new</code> or <code>malloc</code>) first..!</p>
",0
2632358,2632343,0,"<p>You should use sprintf to create a string:</p>

<pre><code>sprintf(s, ""Dice rolled: %d and %d"", dice1, dice2)
</code></pre>
",0
2632414,2632343,2,"<p>The problem is that C really doesn't support strings as a data type, so you will need to simulate strings using character arrays. For example:</p>

<pre><code>int die1, die2; /* need to be set somehow */
wchar_t dice[100];

wsprintf(dice, L""Dice: %d and %d"", die1, die2);
MessageBox(NULL, dice, L""Dice Rolled:"", MB_OK | MB_ICONEXCLAMATION);
</code></pre>
",1
6947157,6947131,5,"<p><b><a href=""http://c2.com/cgi/wiki?UndefinedBehavior"" rel=""nofollow"">Undefined Behaviour</a></b>.</p>

<p>You're attempting to read an <code>int</code> (the <code>""%d""</code> in the scanf call) into an object of type <code>char</code> (the <code>c</code>). Don't do that!</p>
",1
6947162,6947131,-1,"<pre><code>scanf(""%d"",&amp;c);
</code></pre>

<p>should be </p>

<pre><code>scanf(""%c"",&amp;c);
</code></pre>

<p>btw. It will ask you to input value for c in every iteration and then it will print one value of i. What are you getting?</p>
",0
6947174,6947131,-1,"<blockquote>
  <p>What's the reason of the strange output?</p>
</blockquote>

<p>It's because you havn't used scanf properly. When you use ""%d"", you have to give scanf a pointer to an int, but you gave it a pointer to a char.</p>

<p>Change your <code>char c</code> to <code>int c</code></p>

<p>(You should also check functions for errors. e.g. scanf will return EOF on end of input. It will also return the count of assigned values. Since you have given it 1 value, <code>&amp;c</code> , you should check that scanf returns 1. If it does not,  something bad might have happened)</p>
",0
6947201,6947131,0,"<p>You are reading into <code>c</code> but printing <code>i</code>, so you will see 01234.  You probably mean to print <code>c</code>.  But that's not enough.  <code>c</code> should be declared int because you are reading with format <code>""%d""</code>, which expects an int.  Either use format <code>hhd</code> or change <code>c</code> to type int</p>
",0
6947443,6947131,4,"<p>This program exhibits <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>: The type of <code>&amp;c</code> (char *) does not correspond to the type of the scanf arg (<code>%d</code> wants a signed int *).</p>

<p>What is probably happening is that the scanf is writing 4 bytes to the memory location starting at the address of <code>c</code>. Which is only 1 byte long, so the other 3 bytes overwrite the first 3 bytes of <code>i</code>'s value. On a little-endian system, that would effectively set <code>i</code> to whatever integer value you enter shifted right by 8 bits.</p>

<p>But, of course, the behavior is undefined. Next time you compile this code, it <em>could</em> do something completely different. A different compiler, or the same compiler with different options, could keep <code>i</code> in a register (where scanf cannot overwrite it) (but it might instead smash the return address on the stack, causing a crash when the program ends), or it could put the values on the stack in the opposite order (same deal), or it could leave 4 bytes on the stack for <code>c</code> (causing no unexpected behavior), or it could detect the situation and abort with an error, or it could even <a href=""http://www.catb.org/jargon/html/N/nasal-demons.html"" rel=""nofollow"">make demons fly out of your nose</a>.</p>
",0
4522691,4522672,2,"<p>No. There is only size of the argument that function is expecting and it is obviously a size of a pointer (4 on i386, or 8 on x86_64 etc). Also, see <a href=""http://en.wikipedia.org/wiki/Calling_convention"" rel=""nofollow"">calling convention</a> wiki. </p>
",0
4522699,4522672,2,"<p>You're not passing an integer literal constant to <code>foo</code>; you're passing a <code>void *</code>, which is defined to have size <code>sizeof(void *)</code>.</p>

<p>More generally, if you do pass an integer constant expression as an argument to a function, then there are two possibilities:</p>

<ul>
<li>you have a prototype for the function; in this case, the integer constant expression is converted to the declared type of the corresponding argument before the function call.</li>
<li>you do not have a prototype for the function, or it is a variadic argument; in this case, the argument will be passed as an <code>int</code>.  (<strong>caf</strong> correctly notes that this does not apply to integer constant expressions with higher rank than <code>int</code>, like <code>35U</code> or <code>-17L</code>).</li>
</ul>
",1
2184701,2184631,0,"<p>I think you should include all of the code in your switch if you want us to check it for you.</p>

<p>You should probably show all of the code full stop.  What does p point to, for e.g.?</p>

<p>Edit: following Patrick's extra code</p>

<p>Hi Patrick,</p>

<p>You never actually use your val variable.  I suspect this is not what you want.  You're getting the behaviour you see because (presumably) your stack is initialised to zeros and so your '+' is adding 1 to 0 and then pushing 1 back onto the stack.  I'm not sure you're using strtol correctly.</p>

<p>Cheers,
Dan</p>
",0
2184736,2184631,1,"<p>You need to check if the <code>endptr</code> is the same as the input pointer, to determine if no conversion took place:</p>

<pre><code>if(endptr == s)
{
  /* no integer found */
}
</code></pre>
",0
2186201,2184631,1,"<p>Incase of the +, *, / cases, just do one pop and use val directly instead of the second pop. I guess that will make your code work.</p>
",0
2185192,2184631,1,"<p>It looks like the integer on the same line as the operator doesn't get pushed onto the stack, only the single value appears to be pushed.  Also, no need to call atoi() when pushing the found integer, use val since it's the result of strtol().</p>

<p>The easy fix is to move the default behavior out of the switch, <strong>push(val)</strong> prior to the switch statement and removing the default should do the trick.</p>
",0
2423609,2423524,3,"<p>Let me highlight the problem:</p>

<pre><code>while (n &gt; 1)
{
    ...
    n--;
}
...
for (i = 1; i &lt;= n; i++)
{
    printf(""%d"", test[0][i]);
}
</code></pre>

<p>By the time the second loop starts <code>n</code> is one, and the <code>printf</code> is executed only once, so that you print the value of <code>test[0][1]</code> and only that.</p>

<p>The value of <code>test[0][1]</code> is overwritten many times (as many as the number of leaf nodes in the tree) in <code>Assign_Code</code>:</p>

<pre><code>void Assign_Code(node* tree, int c[], int n)
{
    if ((tree-&gt;left == NULL) &amp;&amp; (tree-&gt;right == NULL))
    {
        ...
        for (i = 0; i &lt; n; i++)
        {
             test[0][i+1]=c[i];
        }
    }
    ...
}
</code></pre>

<p>Now, because of the way you are traversing the tree the last time <code>test[0][1]</code> is overwritten is for a Huffman code that has a '0' as first character.</p>
",1
2423653,2423524,0,"<blockquote>
<pre><code>you can store the n value to some temporary variables, after you get the
</code></pre>
  
  <p>values. </p>

<pre><code>Then use the temporary variable in your for loop condition. 
</code></pre>
</blockquote>

<pre><code>scanf(""%d"", &amp;n); 
int temp = n ; 
for (i = 1; i &lt;= temp ; i++)
{
    printf(""%d"", test[0][i]);
}
</code></pre>
",0
2423681,2423524,0,"<p>As a side note:</p>

<pre><code>  node* create(char a[], int x)
{
    node* ptr;
    ptr = (node *) malloc(256*sizeof(node));  // &lt;--- This is wrong
    ptr-&gt;freq = x;
    strcpy( ptr-&gt;value , a);
    ptr-&gt;right = ptr-&gt;left = NULL;
    return(ptr);
}
</code></pre>

<p>There is no reason to allocate 256 times the size of node to store one node. You are creating a node and storing it in an array of pointers to nodes. Allocate one node there, like this:</p>

<pre><code>malloc (sizeof (node)); or malloc ((sizeof (*ptr));
</code></pre>
",0
5554723,5554685,1,"<p>In your scanf function, you don't need to take the address of your variables.  Try:</p>

<pre><code>void getletters(char *one, char *two) {
    scanf(""%c %c"", one, two); // one and two are already pointers...
}
</code></pre>
",0
5554728,5554685,1,"<pre><code>void getletters(char *one, char *two) {
   scanf(""%c %c"",&amp;one, &amp;two"");
}
</code></pre>

<p>You accept pointers-to-char, then use the <code>&amp;</code> operator to get pointers-to-pointers-to-char, then provide them to a function expecting pointers-to-char.</p>

<p>You also have a typo in it.</p>

<p>Instead, write:</p>

<pre><code>void getletters(char *one, char *two) {
   scanf(""%c %c"",one, two);
}
</code></pre>
",0
5554746,5554685,0,"<p>Try this</p>

<pre><code>void getletters(char *one, char *two) {
    scanf(""%c %c"",one, two);

    /* if i pint one and two here, they are correct). */ 
}
</code></pre>

<p>one and two are already pointers in getLetters so no need to pass their address to scanf</p>

<p>Moreover in main, you are trying to pass pointers to printf function this is wrong you have to pass arguments by values:</p>

<pre><code>printf(""your letters are %c and %c"", *pone, *ptwo);
</code></pre>
",0
5554788,5554685,0,"<p>Try this.</p>

<pre><code>#include &lt;stdio.h&gt;
void getletters(char *one, char *two) {
    scanf(""%c %c"",one, two);
}

int main (int argc, char const* argv[])
{
    char one, two;
    getletters(&amp;one, &amp;two);
    printf(""your letters are %c and %c\n"",one, two); /* These are coming out as the wrong characters */ 
    return 0;
}
</code></pre>
",0
5554791,5554685,0,"<pre><code>scanf(""%c %c"",&amp;one, &amp;two"");
</code></pre>

<p>What type of argument does the conversion specifier <code>%c</code> expect? Compare this to the type of <code>&amp;one</code> and <code>&amp;two</code>.</p>
",0
3695362,3693479,5,"<p>See the answer given by Larry Jones <a href=""http://groups.google.com/group/comp.std.c/browse_frm/thread/5c1686a4338eaaa4/0e7c7ce3950aa2fb?lnk=gst&amp;q=snwprintf#0e7c7ce3950aa2fb"" rel=""noreferrer"">here</a>.</p>

<p>Essentially, <code>swprintf</code> was added in C95 while <code>snprintf</code> was added in C99 and since many implementations already returned the number of required characters (for <code>snprintf</code>) and it seemed a useful thing to do, that was the behavior that was standardized.  They didn't think that behavior was important enough to break backwards compatibility with <code>swprintf</code> by adding it (which was added without that behavior several years earlier).</p>
",4
5497562,5497513,4,"<p>The problem is that the language syntax demands a integer value between the [ ]. SOME_ARRAY_SIZE is still a variable (even if you told the compiler nobody is allowed to vary it!)</p>
",2
5497564,5497513,1,"<p>You can do this in C99, and some compilers prior to C99 also had support for this as an extension to C89 (e.g. gcc). If you're stuck with an old compiler that doesn't have C99 support though (e.g. MSVC) then you'll have to do it the <em>old skool</em> way and use a <code>#define</code> for the array size.</p>

<p>Note that that above comments apply only to such declarations at local scope (i.e. automatic variables). C99 still doesn't allow such declarations at global scope.</p>
",8
5497577,5497513,0,"<p>i just did a very quick test with my Xcode and Objective C file I currently had open on my machine and put this in the .m file:</p>

<pre><code>const int arrs = 6;
const int arr[arrs];
</code></pre>

<p>This compiles without any issues.</p>
",0
5497584,5497513,5,"<p>Well, in C++ the semantics are a bit different. In C++ your code would work fine. You must distinguish between 2 things, <code>const</code> and <code>constant expression</code>. Const means simply, as you described, that the value is read-only. constant expression, on the other hand, means the value is known compile time and is a compile-time constant. The semantics of const in C are always of the first type. The only constant expressions in C are literals, that's why <code>#define</code> is used for such kind of things.</p>

<p>In C++ however, any const object initialized with a constant expression is in itself a constant expression.</p>

<p>I don't know exactly WHY this is so in C, it's just the way it is</p>
",0
5497594,5497513,2,"<p>The <code>const</code> keyword is basically a read-only indication. It does not, really, indicate the underlying value will not change, even though that is the case in your example.</p>

<p>When it comes to pointers, this is more clear:</p>

<pre><code>void foo(int const * p)
{
  if (*p == 100)
  {
    bar();
    /* Here, the compiler can not assume that *p is 100 */
  }
}
</code></pre>

<p>In this case, a compiler should not accept the code in your example, as it requires the array size to be constant. If it would accept it, the user could later run into trouble when porting the code a more strict compiler.</p>
",1
2219034,2219001,60,"<p>Like so:</p>

<pre><code>ImmutablePoint *make_immutable_point(int x, int y)
{
  ImmutablePoint init = { .x = x, .y = y };
  ImmutablePoint *p = malloc(sizeof *p);

  if (p == NULL) abort();
  memcpy(p, &amp;init, sizeof *p);

  return p;
}
</code></pre>

<p>(Note that unlike C++, there is no need to cast the return value of <code>malloc</code> in C, and it is often considered bad form because it can hide other errors).</p>
",9
2219042,2219001,12,"<p>If this is C and not C++, I see no solution other than to subvert the type system.</p>

<pre><code>ImmutablePoint * make_immutable_point(int x, int y)
{
  ImmutablePoint *p = malloc(sizeof(ImmutablePoint));
  if (p == NULL) abort();

  // this 
  ImmutablePoint temp = {x, y};
  memcpy(p, &amp;temp, sizeof(temp));

  // or this
  *(int*)&amp;p-&gt;x = x;
  *(int*)&amp;p-&gt;y = y;

  return p;
}
</code></pre>
",1
2219045,2219001,2,"<p>If you insist on keeping the const in the structure, you are going to have to do some casting to get around that:</p>

<pre><code>int *cheat_x = (int *)&amp;p-&gt;x;
*cheat_x = 3;
</code></pre>
",2
2219051,2219001,1,"<p>I like <a href=""https://stackoverflow.com/questions/2219001/how-to-initialize-const-members-of-structs-on-the-heap/2219034#2219034"">caf's approach</a>, but this occured to me too</p>

<pre><code>ImmutablePoint* newImmutablePoint(int x, int y){ 
   struct unconstpoint {
      int x;
      int y;
   } *p = malloc(sizeof(struct unconstpoint));
   if (p) { // guard against malloc failure
      *p.x = x;
      *p.y = y;
   }
   return (ImmutablePoint*)p;
}
</code></pre>
",3
5491873,5491789,1,"<p>The semantic is the same, but for an external programmer, it is easier and immediate to understand: the second function takes an array as argument. It could not be as immediate for the first one.</p>
",0
5491898,5491789,5,"<p>There is no difference for the C compiler. There is a difference for the programmer that reads the code though.</p>

<p>Here, arr is a pointer to an integer (possibly for returning the result from the function):</p>

<pre><code>foo(int* arr) {}
</code></pre>

<p>Here, arr is a pointer to the first integer in an array (possibly for passing a list of numbers in and/or out of the function):</p>

<pre><code>foo(int arr[]) {}
</code></pre>

<p>Also, specifying the return type of the function would help.</p>
",0
5491807,5491789,12,"<p>No, there is no difference between the two.</p>
",0
5491816,5491789,-1,"<p>You will have to dereference values to the first one...</p>
",3
3287094,2161304,1,"<p>You must declare the function before using.
Remember these 4 basic parts while dealing with functions.</p>

<ol>
<li>Declaration</li>
<li>Call</li>
<li>Definition</li>
<li>Return</li>
</ol>
",0
3167369,3167351,8,"<p>if the compiler is treating it as a '.c' file, the <code>int i</code> declaration needs to before any executable lines, speficically, before the <code>printf</code>.</p>

<p>EDIT, now that you showed the error message:</p>

<p>The compiler does not consider <code>SIZE</code> as a constant when compiling main.  You could use <code>#define SIZE 5</code> as a work-around.</p>

<p>According to K&amp;R 2nd Ed. : </p>

<blockquote>
  <p>""The purpose of <code>const</code> is to announce objects that may be placed in read-only
  memory. ... Except that it should diagnose
  explicit attempts to change <em>const</em>
  objects, a compiler may ignore [the
  const] qualifier"".</p>
</blockquote>

<p>So declaring <code>const int SIZE = 5</code> does not make <code>SIZE</code> a <em>constant-expression</em>, which is what an array size specifier requires.</p>
",6
3167374,3167351,3,"<p>try this:</p>

<pre><code>char array[] = {'A', 'B', 'C', 'D', 'E'};
</code></pre>
",1
3167398,3167351,5,"<p>Try replacing </p>

<pre><code>const int SIZE = 5;
</code></pre>

<p>with </p>

<pre><code>#define SIZE 5
</code></pre>

<p>Most C compilers don't allow declaring static arrays whose sizes are contained in variables (i.e. the array size is determined at runtime).</p>
",2
3167460,3167351,15,"<p>Array size in C89/90 language must be specified by an integral <em>constant expression</em> (in general true for C99 as well). A <code>const int</code> object in C is not a <em>constant expression</em>, which is why you can't use it to specify array size. Note: this is one prominent difference between C and C++.</p>

<p>In C language the term <em>constant</em> refers to <em>literal</em> constants, i.e. <code>5</code>, <code>10.2</code>, <code>0xFF</code>, <code>'a'</code> and so on (enum constants are also <em>constants</em>, to be precise). <code>const int</code> object, once again, is not a <em>constant</em> in C and cannot be used to build constant expressions.</p>

<p>If you want to pre-declare a named constant to be used as array size in C, you have to use either <code>#define</code> or <code>enum</code>. The same applies to case labels, bit-field sizes and every other context requiring a constant expression. </p>

<p>See <a href=""https://stackoverflow.com/questions/2308194/shall-i-prefer-constants-over-defines/2308364#2308364"">this</a> for more details.</p>
",7
3419351,3419236,0,"<p>mod is a pretty expensive operation, particularly for saving a 32-bit int. You probably just want to memcpy. If you're worried about portability throw in a htonl:</p>

<pre><code>#include&lt;string.h&gt;

uint32_t x = 12;
char data[4];
memcpy(data, &amp;x, sizeof(x)); 
</code></pre>

<p>To go the other way you can just reverse it:</p>

<pre><code>memcpy(&amp;x, data, sizeof(x));
</code></pre>
",0
3419439,3419236,0,"<p>You could always try a union:</p>

<pre><code>typedef union {
    int      i;
    uint8_t  bytes[sizeof(int)];
} int_u;
</code></pre>

<p>You can use this to turn an <code>int</code> into bytes or vice versa.  Be mindful of endian-ness issues, however, if you are using this to transport data between platforms.</p>
",0
3419259,3419236,7,"<p>For unsigned data:</p>

<pre><code>val = (data[2] &lt;&lt; 8) | data[3];
</code></pre>

<p>For signed data:</p>

<pre><code>val = ((data[2] &lt;&lt; 8) &amp; 0xff00) | (data[3] &amp; 0xff);
</code></pre>
",4
3419269,3419236,-3,"<p>Simply iterate through the elements and do a Int.Parse</p>
",1
3419276,3419236,0,"<p>Easy way:</p>

<pre><code>int myint = mybyte[0]&lt;&lt;24+mybyte[1]&lt;&lt;16+mybyte[2]&lt;&lt;8+mybyte[3];
</code></pre>

<p>Assuming that's your bit order, and they're all unsigned.  You may have to cast the bytes into ints in order to make sure they don't wrap (11001100 -> 11001100,0000000 instead of 11001100).</p>

<p>A far stranger way (though probably faster) would be something questionable legal with pointers:</p>

<pre><code>int * myintp= mybyte;
int myint = *myintp;
</code></pre>

<p>I've not tested this at all, but it should theoretically work, assuming that the lengths work out, etc.  It's still probably not a good idea.</p>
",3
2910301,2910286,1,"<p>The <a href=""http://www.sco.com/developers/gabi/1998-04-29/ch4.symtab.html"" rel=""nofollow noreferrer"">ELF definition</a> actually gives C macros for doing this:</p>

<pre><code>#define ELF_ST_BIND(i)   ((i)&gt;&gt;4)
#define ELF_ST_TYPE(i)   ((i)&amp;0xf)
</code></pre>

<p>(Note that these expect that you have defined the <code>st_info</code> field as <code>unsigned char</code>, not just <code>char</code>).</p>
",0
3174606,3174593,2,"<p>This requirement usually means you want to ensure that casual passers-by cannot see what the user typed as a password by accident.  This might be by turning off the echo (this is what Unix usually does) or by echoing asterisks or something similar instead of the actual characters entered by the user.</p>

<p>The C standard alone does not help here.  You have to define the environment in which you are going to be running.  The techniques used in a GUI application are different from those used in a command line application.</p>

<p>Many versions of Unix provide a <code>getpass()</code> function, but it is not defined in POSIX.  As mentioned, it saves the terminal mode, turns off echoing, reads characters (normally discarding anything after the 8th character) and then reinstates the terminal mode before returning.</p>
",0
3573935,3573815,1,"<p>It's a pretty  inefficient algorithm. The complexity is O(n<sup>2</sup>). You could do better, by using a sorted sequence.</p>

<p>What you have is obviously buggy, but the idea seems clear. For every new value (next <code>i</code>) it is checked, if that value is already among unique values stored so far. That's what the inner loop is for. If the match is found, <code>order[i] = y</code> and the next <code>i</code> should be checked, so you can <code>break</code>. If the match is not found for current <code>y</code> however, you need to check next <code>y</code>. Only after all <code>y</code> were checked, you know the value is unique, so the part in the else clause should be moved outside the inner loop. I think the fixed version should look like this:</p>

<pre><code>unique[0] = pairs[0];
order[0] = 0;
num_unique = 1;

// Skip first, we just did it:
for (i = 1; i &lt; num_pairs; i++) {

    // Check if what we have is already the same
    for (y = 0; y &lt; num_unique; y++) {

        if (unique[y].vertex == pairs[i].vertex &amp;&amp; unique[y].normal == pairs[i].normal) {
            /*  A new pair was found to be the same; put the old unique index in order;
                keep num of unique items same: */
            order[i] = y;
            break;
        }
    }
    if(y == num_unique){
    /* No match was found in the inner loop,
       so y reached num_unique. You could use a flag
       to indicate this, which might be more readable*/

        /*  A new pair was unique; copy it in unique pairs and increment number
            of unique items; put in order the new number */
        unique[num_unique] = pairs[i];
        order[i] = num_unique;
        num_unique++; // it follows since it was already incremented to 1 in the beginning.
    }
}
</code></pre>
",1
2089646,2089610,1,"<p>Your problem is that your function <code>FillArray</code> is only modifying its argument <code>a</code>, which is not visible to its caller, since argument passing in C is by value. You will need some way to have the recursive calls tell the spot in <code>arr</code> to which to add the elements. One simple way to do this would be to add a parameter, say, <code>index</code> that gives the first index in <code>arr</code> to which to add an element, and return from <code>FillArray</code> the number of elements added so that you can properly update <code>index</code> after calling <code>FillArray</code> recursively and to return the total number of elements added.</p>
",0
2089650,2089610,1,"<p><code>FillArray</code> is declared as returning an <code>int</code>, but you do not have a return value in the <code>else</code> case.</p>

<p>You can use this return value to denote the number of elements filled in; this way, you know where to place the current element in-order.</p>

<pre><code>int FillArray(int a, SearchTree T, int arr[]) {
    int count = 0;

    if (T) {
        count += FillArray(a, T-&gt;Left, arr);
        arr[a + count++] = T-&gt;Element;
        count += FillArray(a + count, T-&gt;Right, arr);
    }

    return count;
}
</code></pre>
",2
2089652,2089610,0,"<p>gotta pass a by reference </p>
",3
2425023,2425013,1,"<p><a href=""http://www.opengroup.org/onlinepubs/007908799/xsh/pthread.h.html"" rel=""nofollow noreferrer"">pthreads</a></p>
",0
2425041,2425013,2,"<p>On Linux use <a href=""http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html"" rel=""nofollow noreferrer"">pthreads</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;

void *print_message_function( void *ptr );

int main(int argc, char *argv[])
{
     pthread_t thread1, thread2;
     char *message1 = ""Thread 1"";
     char *message2 = ""Thread 2"";
     int  iret1, iret2;

    /* Create independent threads each of which will execute function */

     iret1 = pthread_create( &amp;thread1, NULL, print_message_function, (void*) message1);
     iret2 = pthread_create( &amp;thread2, NULL, print_message_function, (void*) message2);

     /* Wait till threads are complete before main continues. Unless we  */
     /* wait we run the risk of executing an exit which will terminate   */
     /* the process and all threads before the threads have completed.   */

     pthread_join( thread1, NULL);
     pthread_join( thread2, NULL); 

     printf(""Thread 1 returns: %d\n"",iret1);
     printf(""Thread 2 returns: %d\n"",iret2);
     exit(0);
}

void *print_message_function( void *ptr )
{
     char *message;
     message = (char *) ptr;
     printf(""%s \n"", message);
}
</code></pre>
",3
2425329,2425013,2,"<p>Check <a href=""http://msdn.microsoft.com/en-us/library/kdzttdcb(VS.80).aspx"" rel=""nofollow noreferrer"">_beginthread</a> for Windows and <a href=""https://computing.llnl.gov/tutorials/pthreads/"" rel=""nofollow noreferrer"">posix threads</a> for linux</p>
",0
2837373,2837362,1,"<p>By looking at them. Header files are usually in /usr/include and you can easily browse that folder.</p>

<p>However, some functions might be in different header files depending on the system (linux/bsd/other unixes).</p>
",0
2837379,2837362,7,"<p>Here: <a href=""http://www.gnu.org/s/libc/manual/html_node/index.html"" rel=""nofollow noreferrer"">http://www.gnu.org/s/libc/manual/html_node/index.html</a></p>

<p>If you are writing C on Linux, your standard C library is nearly always the GNU C library. All standard C functions are present in this library, and the link above is to extensive documentation for them.</p>

<p>If you are planning to use libraries other than the standard C library, you should find their documentation as well.</p>
",1
2840532,2837362,3,"<p>And don't forget, if you know the name of a function you can type <code>man 3 funcname</code> for help on that function, including the name of the header file it appears in.  Use the <code>3</code> to specify the C Library Function section of the manual.  If you forget it and there's a command-line program (section 1) or system call (section 2) with the same name, you'll get that page instead.</p>
",0
2945206,2945200,0,"<p>I'm pretty sure you're supposed to do ""char *"" not ""char []""</p>
",1
2945209,2945200,5,"<p>Use <code>char text[]</code> or <code>char* text</code>, not <code>char[] text</code>.</p>
",1
2945214,2945200,2,"<p>The line:</p>

<pre><code>void echo (char [] text )
</code></pre>

<p>should be:</p>

<pre><code>void echo (char text [])
</code></pre>

<p>And you need:</p>

<pre><code>#include &lt;string.h&gt;
</code></pre>

<p>to get the declaration of the <code>strlen</code> function.</p>
",0
2945319,2945200,0,"<p>Clearly the syntax</p>

<p><code>char[] var;</code></p>

<p>is a javaism. In C it should be <code>char var[]</code>. Moreover you must add <code>#include &lt;string.h&gt;</code></p>
",0
2125280,2125263,2,"<p>*x means that x is a pointer to a memory location of type size_t.</p>

<p>You can set the location with x = &y;
or set the value were x points to with: *x = 0;</p>

<p>If you need further information take a look at: <a href=""http://boredzo.org/pointers/"" rel=""nofollow noreferrer"">Pointers</a></p>
",0
2125307,2125263,10,"<p>How about a tutorial on <a href=""http://www.geekpedia.com/tutorial44_Understanding-Pointers.html"" rel=""nofollow noreferrer"">understanding pointers</a>?</p>

<p>In this case however, the pointer is probably used to modify/return the value. In C, there are two basic mechanisms in which a function can return a value (please forgive the dumb example):</p>

<p>It can return the value directly:</p>

<pre><code>float square_root( float x )
{
    if ( x &gt;= 0 )
        return sqrt( x );
    return 0;
}
</code></pre>

<p>Or it can return by a pointer:</p>

<pre><code>int square_root( float x, float* result )
{
    if ( x &gt;= 0 )
    {
        *result = sqrt( result );
        return 1;
    }
    return 0;
}
</code></pre>

<p>The first one is called:</p>

<pre><code>float a = square_root( 12.0 );
</code></pre>

<p>... while the latter:</p>

<pre><code>float b;
square_root( 12.00, &amp;b );
</code></pre>

<p>Note that the latter example will also allow you to check whether the value returned was real -- this mechanism is widely used in C libraries, where the return value of a function usually denotes success (or the lack of it) while the values themselves are returned via parameters.</p>

<p>Hence with the latter you could write:</p>

<pre><code>float sqresult;
if ( !square_root( myvar, &amp;sqresult ) )
{
   // signal error
}  
else
{ 
   // value is good, continue using sqresult!
}
</code></pre>
",0
2125308,2125263,2,"<p>The prototype means that the function takes one integer arg and one arg which is a pointer to a size_t type. size_t is a type defined in a header file, usually to be an unsigned int, but the reason for not just using ""unsigned int* x"" is to give compiler writers flexibility to use something else.</p>

<p>A pointer is a value that holds a memory address. If I write </p>

<p>int x = 42;</p>

<p>then the compiler will allocate 4 bytes in memory and remember the location any time I use x. If I want to pass that location explicitly, I can create a pointer and assign to it the address of x:</p>

<p>int* ptr = &x;</p>

<p>Now I can pass around ptr to functions that expect a int* for an argument, and I can use ptr by dereferencing:</p>

<p>cout &lt;&lt; *ptr + 1;</p>

<p>will print out 43.
There are a number of reasons you might want to use pointers instead of values. 1) you avoid copy-constructing structs and classes when you pass to a function 2) you can have more than one handle to a variable 3) it is the only way to manipulate variables on the heap 4) you can use them to pass results out of a function by writing to the location pointed to by an arg</p>
",2
2125312,2125263,1,"<p><code>size_t *x</code> means you are passing a pointer to a size_t 'instance'.</p>

<p>There are a couple of reasons you want to pass a pointer.</p>

<ol>
<li>So that the function can modify the caller's variable.  C uses pass-by-value so that modifying a parameter inside a function does not modify the original variable.</li>
<li>For performance reasons.  If a parameter is a structure, pass-by-value means you have to copy the struct.  If the struct is big enough this could cause a performance hit.  </li>
</ol>
",0
2125315,2125263,0,"<p>There's a further interpretation given this is a parameter to a function.</p>

<p>When you use pointers (something*) in a function's argument and you pass a variable you are not passing a value, you are passing a reference (a ""pointer"") to a value. Any changes made to the variable inside the function are done to the variable to which it refers, i.e. the variable outside the function.</p>

<p>You still have to pass the correct type - there are two ways to do this; either use a pointer in the calling routine or use the &amp; (addressof) operator. </p>

<p>I've just written this quickly to demonstrate:</p>

<pre><code>#include &lt;stdio.h&gt;

void add(int one, int* two)
{
    *two += one;
}

int main()
{
    int x = 5;
    int y = 7;
    add(x,&amp;y);

    printf(""%d %d\n"", x, y);

    return 0;
}
</code></pre>

<p>This is how things like scanf work.</p>
",2
2125366,2125263,2,"<p><a href=""http://cslibrary.stanford.edu/106/"" rel=""nofollow noreferrer"">Pointer Basics</a></p>

<p><a href=""http://cslibrary.stanford.edu/102/PointersAndMemory.pdf"" rel=""nofollow noreferrer"">Pointers And Memory</a></p>
",0
2125698,2125263,0,"<pre><code>int square( int y, size_t* x );</code></pre>

<p>This <strong>declares</strong> a <em>function</em> that <em>takes two arguments</em> - an integer, and a pointer to unsigned (probably large) integer, and <em>returns</em> an integer.  </p>

<p><code>size_t</code> is unsigned integer type (usually a <code>typedef</code>) <a href=""http://www.cplusplus.com/reference/clibrary/cstring/size_t/"" rel=""nofollow noreferrer"">returned by <code>sizeof()</code> operator</a>.  </p>

<p><code>*</code> (star) signals pointer type (e.g. <code>int* ptr;</code> makes <code>ptr</code> to be pointer to integer) when used in declarations (and casts), or <em>dereference</em> of a pointer when used at <a href=""http://www.embedded.com/story/OEG20010518S0071"" rel=""nofollow noreferrer"">lvalue or rvalue</a> (<code>*ptr = 10;</code> assigns ten to memory pointed to by <code>ptr</code>). It's just our luck that the same symbol is used for multiplication (Pascal, for example, uses <code>^</code> for pointers).</p>

<p>At the point of function declaration the names of the parameters (<code>x</code> and <code>y</code> here) don't really matter. You can define your function with different parameter names in the <code>.c</code> file. The caller of the function is only interested in the types and number of function parameters, and the return type.  </p>

<p>When you define the function, the parameters now name <em>local</em> variables, whose values are assigned by the caller.</p>

<p>Pointer function parameters are used when passing objects <a href=""http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/cplr233.htm"" rel=""nofollow noreferrer"">by reference</a> or as <em>output parameters</em> where you pass in a pointer to location where the function stores output value.</p>

<p>C is beautiful and simple language :)</p>
",0
2626783,2626755,1,"<p>You should use</p>

<p>tkn++</p>

<p>rather than </p>

<p>*tkn++</p>
",3
2626795,2626755,0,"<p>Just use <a href=""http://linux.die.net/man/3/strlcpy"" rel=""nofollow noreferrer""><code>strlcpy(3)</code></a> instead of hand-coding the copy (hint - you are forgetting string zero terminator):</p>

<pre><code>strlcpy( array, tkn, MAX );
</code></pre>
",2
2626910,2626755,2,"<p>In this line:</p>

<pre><code>    while ((*tkn != 0) &amp;&amp; (tkn != NULL))
</code></pre>

<p>you need to reverse the conditions.  If <code>tkn</code> is a null pointer, you will crash when the first term is evaluated.  If you need to check a pointer for validity, do so before dereferencing it.</p>

<pre><code>    while (tkn != NULL &amp;&amp; *tkn != '\0')
</code></pre>

<p>The extra parentheses you added do no harm but are not necessary.  And although <code>0</code> is a perfectly good zero, the <code>'\0'</code> emphasizes that <code>*tkn</code> is a character.  Of course, given the prior <code>tkn != NULL</code> condition in the if statement, there is no real need to repeat the check in the while loop.</p>

<hr>

<p>Working code based on yours - some work left to do for subsequent tokens in the string, for example...</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

enum { MAX = 20 };
char *tkn;
char array[MAX];
char str[2*MAX];

void tokenize(void)
{
    int i = 0;

    array[0] = '\0';

    tkn = strtok(str, "" "");         // get token 1
    if (tkn != NULL)
    {
        printf(""token1: "");
        while (tkn != NULL &amp;&amp; *tkn != '\0' &amp;&amp; i &lt; MAX - 1)
        {
            putchar(*tkn);
            array[i++] = *tkn++;
        }
        *tkn = '\0';
        putchar('\n');
    }
}

int main(void)
{
    strcpy(str, ""abc def"");
    tokenize();
    printf(""token = &lt;&lt;%s&gt;&gt;\n"", array);
    strcpy(str, ""abcdefghijklmnopqrstuvwxyz"");
    tokenize();
    printf(""token = &lt;&lt;%s&gt;&gt;\n"", array);
    return(0);
}
</code></pre>

<p>Sample output:</p>

<pre><code>token1: abc
token = &lt;&lt;abc&gt;&gt;
token1: abcdefghijklmnopqrs
token = &lt;&lt;abcdefghijklmnopqrs&gt;&gt;
</code></pre>

<hr>

<p>Asked:</p>

<blockquote>
  <p>But what if I am taking in a string 'abc 3fc ghi' and I want to use just '3fc' in another function that say converts it from ascii to hex? How do I just use say tkn2 for 3fc and get that only using a pointer? ¨C patrick 9 mins ago</p>
</blockquote>

<p>That's where it gets trickier because <code>strtok()</code> has a moderately fiendish interface.</p>

<p>Leaving <code>tokenize()</code> unchanged, let's redefine <code>str</code>:</p>

<pre><code>char *str;
</code></pre>

<p>Then, we can use (untested):</p>

<pre><code>int main(void)
{
    char buffer[2*MAX];
    strcpy(buffer, ""abc 3fc ghi"");
    str = buffer;
    tokenize();
    printf(""token = &lt;&lt;%s&gt;&gt;\n"", array); // ""abc""
    str = NULL;
    tokenize();
    printf(""token = &lt;&lt;%s&gt;&gt;\n"", array); // ""3fc""
    str = NULL;
    tokenize();
    printf(""token = &lt;&lt;%s&gt;&gt;\n"", array); // ""ghi""
    return(0);
}
</code></pre>

<p>Clearly, this relies on knowing that there are three tokens.  To generalize, you'd need the tokenizer to tell you when there's nothing left to tokenize.</p>

<p>Note that having <code>tkn</code> as a global is really unnecessary - indeed, you should aim to avoid globals as much as possible.</p>
",1
2626982,2626755,0,"<p>Although <code>tkn</code> itself is a global variable, you also have to make sure that <em>what it points to</em> (ie. <code>*tkn</code>) is still around when you try to use it.</p>

<p>When you set <code>tkn</code> with a line like:</p>

<pre><code>tkn = strtok (str,"" "");
</code></pre>

<p>Then <code>tkn</code> is pointing to part of the string that <code>str</code> points to.  So if <code>str</code> was pointing to a non-static array declared in a function, for example, and that function has exited - then <code>*tkn</code> isn't allowed any more.  If <code>str</code> was pointing to a block of memory allocated by <code>malloc()</code>, and you've called <code>free()</code> on that memory - then accessing <code>*tkn</code> isn't allowed after that point.</p>
",0
2538005,2537985,0,"<p>Both will have the same character value.</p>
",1
2538016,2537985,3,"<p>What they will fetch is a char-sized chunk of memory located 2 char-sized steps (2 bytes here) after the beginning of each, or after the address in memory to which each var points. This happens to be 'L' i the example, but this is not the same address in memory.</p>

<p>So yes, in the example given, they will fetch the same character.</p>
",6
2538017,2537985,2,"<p>Yes.</p>

<p>p[2] is equivalent to *(p+2)</p>

<pre><code>HELLO
  ^
*(p+2)
</code></pre>

<p>Should be noted, that the first ""HELLO"" will probably be  stored in a writable memory page, while the second ""HELLO"" will probably be stored in a read only page. This is very closely related to the compiler / platform you are on.</p>
",0
2538028,2537985,0,"<p>I guess it depends on the compiler you use, but the answer is probably no.</p>

<p>By the way, you can test this easily by comparing the addresses of the two characters. If they differ, then: no.</p>

<p>Anyway, you shouldn't rely on this ;)</p>
",0
2538123,2537985,2,"<p>In both cases they will fetch an <code>'L'</code>. However, it isn't the same <code>'L'</code>. They are stored in different places. That means if you compare their pointers, they will not be equal.</p>
",0
2325365,2325359,4,"<p>For making HTTP requests I recommend libcurl, which is the library that almost everybody seems to be using.</p>

<p><a href=""http://curl.haxx.se/libcurl/"" rel=""nofollow noreferrer"">http://curl.haxx.se/libcurl/</a></p>
",2
2325382,2325359,0,"<p>What about using a client like <a href=""http://www.dyndns.com/"" rel=""nofollow noreferrer"">dyndns</a>? I'm not sure using a C program would be such a good idea for that purpose; it's a system administration task and using scripting for this would work best, unless you have a specific need in mind.</p>
",0
2325454,2325359,1,"<p>What operating system? Linux? Windows? Does the program need to be cross-platform? The reason I ask is that it influences whether you should use a library, or TCP/IP sockets, given that the request will be very simple.</p>

<p>Also, why not use Perl, or better yet, wget? You could schedule a task in windows, or a cronjob in unix, to <code>wget <a href=""http://yoururl/path?pcname=%60uname%60"" rel=""nofollow noreferrer"">http://yoururl/path?pcname=`uname`</a></code> or similar..</p>
",1
2938138,2938131,0,"<p>You're continually writing over an array (<code>a_array</code>) at the same position, then storing the address into <code>a_result[i]</code> (<code>a_result</code> is an array of pointers).  Thus, at the end, every element of <code>a_result</code> contains an identical address (of <code>a_array</code>), and <code>a_array</code> itself has the values written by the last iteration.</p>

<p>Worse, accessing the contents of <code>a_array</code> (including through the pointers in <code>a_result</code>) outside the for loop is undefined behavior.  That storage can only be used within the loop body.</p>

<p>In contrast, you're allocating new heap memory for <code>b_array</code> (which is not in fact an array) every iteration, and storing this (new) pointer into <code>b_result</code>.  Thus, you don't overwrite old values.</p>
",1
2938142,2938131,3,"<pre><code>for (i = 0; i &lt; 10; i++)
{
    char a_array[10];
    ...
    a_result[i] = a_array;
}
</code></pre>

<p>You are declaring an array on stack in the <code>for</code> loop's scope. This means the array will become invalid once you leave the for loop. That is, the stuff inside <code>a_result</code> is invalid.</p>

<p>For on-stack vairables, the compiler will reuse the same memory area for <code>a_array</code> in every loop (which is not for <code>b_array</code> since a fresh memory will be received from heap by <code>malloc</code>). Hence for your case, <code>a_result</code> just has 10 copied of the same invalid pointer. </p>

<hr>

<p>If you want a copy of the content that array, make the type of <code>a_result</code> to be</p>

<pre><code>char a_result[10][10];
</code></pre>

<p>and use</p>

<pre><code>memcpy(a_result[i], a_array, sizeof(a_result[i]));
</code></pre>

<p>to copy into the result.</p>
",1
2938147,2938131,0,"<p>The array </p>

<pre><code> char a_array[10];
</code></pre>

<p>goes out of scope at the end of every loop iteration and is then effectively recreated at the same memory location. You end up with a bunch of pointers pointing to the last re-creation, which contains the ""jjjjjj"" string.</p>
",0
2386596,2386571,2,"<p>No, this is not possible in C without providing a string lookup table of some sort that could link variables with their names. </p>
",0
2386616,2386571,2,"<p>Yes you are right , this is possible in some other language but not in C , 
since abc is a container which resides in a location (for ex: 1000) and hello is one more 
container which resides in another location ( for ex : 2000 ) , so we have no contact between 
these two arrays , </p>

<p>we cannot make a value ( strings ) to point some other value. 
so finally THIS IS NOT AT ALL POSSIBLE. </p>
",0
2386638,2386571,0,"<p>It is not possible in C. It can be done in java by reflection in some cases.</p>
",0
2386640,2386571,1,"<p>It's impossible in C, unlike in more dynamic languages like Perl or Python. However, it's important to keep in mind that even in those languages this isn't recommended. I haven't seen a snippet of code putting this to a good use yet. The <code>eval</code> methods available in dynamic languages are used sparingly, and not for dynamically grabbing variable names.</p>
",0
2386656,2386571,1,"<p>As soon as the C compiler has figured out where to store the underlying pointers, it forgets about the name you gave it. The dynamic languages solve it with a data structure like a hash map which allows you to store the pointers (value) under a key (the name).</p>

<p>Another option is to read in the debug information. This is only available if you compile your code with <code>-g</code> (gcc) or some other, compiler specific option. Note that the debug format is not standardized, so you'll need to figure out what your compiler uses and how to work with it.</p>
",0
2386792,2386571,0,"<p>POSIX has several functions that allows you to do it, assuming variable <code>hello</code> is global and isn't static:</p>

<pre><code>void *handle = dlopen(NULL, RTLD_NOW);
// error handling omitted

printf(""%s variable contains value %s"", abc, (char *)dlsym(handle, abc));
</code></pre>

<p><code>dlsym()</code> return value is casted to <code>char *</code> to suppress warning when using compilers that check format string for <code>printf</code>-alike functions.</p>

<p>And you need to make sure you've specified correct compiler options, e.g. <code>-rdynamic -ldl</code> in case of GCC.</p>
",0
2839794,2839790,5,"<p>If you are reading into a numeric variable, it can't really have the value 'q', so your test won't work. If you want to write code like this, you should read user input into a string, check to see if the string contains ""q"" and if not convert it to an integer.</p>
",5
2839796,2839790,-1,"<p>you exit the program by typing the ascii value for 'q' not q/</p>
",0
2839800,2839790,0,"<p>Cute. Entering <code>'q'</code> causes the scanf to fail, with <code>input</code> left at whatever the last value was. This broken loop continues to the end of the range. The test <code>input=='q'</code> never succeeds, of course.</p>
",0
2839804,2839790,3,"<p><code>scanf</code> has a return value. Use it to test if scanf was actually able to parse anything. In your scenario, 'q' will never be stored in the variable <code>input</code>, being it as a char or numerical representation. You cannot read ""q"" as ""%d"" and therefore scanf will silently fail.</p>

<p>Test for the return value of scanf to decide for a <code>break</code>.</p>
",2
2839807,2839790,1,"<p>scanf %d does not understand 'q'. You can check the return value of scanf though - if it returns 0 the user did not enter a valid number.</p>

<p>If only q and not other non-numeric strings should terminate the loop, read into a string and check if it's q and if not convert it to an int with atoi().</p>
",0
2841311,2839790,0,"<p>scanf will return 0 in your code when the input character does not match the conversion specification. But, the <strong>next call</strong> to scanf will resume searching immediately after the last converted character. Therefore, you can try the below code:</p>

<pre><code>#include &lt;stdio.h&gt;

int arr[100];
int count=0;
int max=100;


int main(){
   int i, input, ret;
   char end; 
   printf(""Enter integer values one by one, q to quit.\n"");
   for(i=0;i&lt;max;i++)
   {
      ret = scanf(""%d"",&amp;input);
      if (!ret)
      {
         scanf(""%c"", &amp;end);
         if ( end == 'q')
            break;
         else
           continue;
      }
      arr[i]=input;
      count++;
   }
   printf(""You entered %d values.\n"",count);
   return 0;
}
</code></pre>

<p>By doing this, you can make sure that control does not come out of the loop unless you enter q and only legitimate values are copied to the array.</p>
",0
2839815,2839790,0,"<p>:)
Let me modify this program like this:</p>

<pre><code>#include &lt;stdio.h&gt; 

int arr[100]; 
int count=0; 
int max=100; 


int main(){ 
 int i, input; 
 printf(""Enter integer values one by one, -1 to quit.\n""); 
 for(i=0;i&lt;max;i++){ 
  scanf(""%d"",&amp;input); 
  arr[i]=input; 
  if(input==-1)break; 
  count++; 
 } 
 printf(""You entered %d values.\n"",count); 
 return 0; 
}
</code></pre>

<p>You can't use a numeric var to get a char value.
If you change it just like this, it will work. 
:)</p>
",0
3134768,3134757,13,"<p>Since the states are related elements I think is better to have an enum defining them.</p>
",0
3134776,3134757,8,"<p>I prefer enum. They are more compact and are 'safer'. You can also imply order in an enum, which might be helpful in a state machine. #defines should be avoided if possible, since they will overwrite all occurrences in source, which can lead to some unintended actions which are difficult to debug.</p>
",0
3134777,3134757,2,"<p><code>#define</code> directives can have lots of unintended consequences and don't follow common scoping rules. Use enums when you have related data.</p>

<p>More information: <a href=""http://www.embedded.com/columns/programmingpointers/9900402?_requestid=341945"" rel=""nofollow noreferrer"">http://www.embedded.com/columns/programmingpointers/9900402?_requestid=341945</a> [C++ material, but still marginally relevant]</p>
",6
3134790,3134757,3,"<p>If <code>enum</code> is supported by your compiler, then that would be preferred.  Failing that, by all means, use <code>#define</code>.  All C++ compilers and modern C compilers should support <code>enum</code>, but older compilers (particularly ones targeting embedded platforms) may not support <code>enum</code>.</p>

<p>If you must use <code>#define</code> make sure to define your constants with parentheses, to avoid preprocessor errors:</p>

<pre><code>#define RED_STATE    (1)
#define YELLOW_STATE (2)
#define GREEN_STATE  (3)
</code></pre>
",0
3134812,3134757,9,"<p>There's no definitive answer. <code>enum</code> offers you scoping and automatic value assignment, but does not give any control over the constant type (always <code>signed int</code>). <code>#define</code> ignores scoping, but allows you to use better typing facilities: lets you choose the constant type (either by using suffixes or by including an explicit cast into the definition). </p>

<p>So, choose for yourself what is more important to you. For a state machine, <code>enum</code> might be a better choice, unless you have a good reason to control the type.</p>
",6
3134828,3134757,0,"<p><code>enum</code> is great when you have exclusive options, but you can't use them to define bitfield flags, like this:</p>

<pre><code>#define SQ_DEFAULT 0x0
#define SQ_WITH_RED 0x1
#define SQ_WITH_BLUE 0x2

void paint_square(int flags);
</code></pre>

<p>Then you can paint red-blue square with:</p>

<pre><code>paint_square(SQ_WITH_RED | SQ_WITH_BLUE);
</code></pre>

<p>...which you can't with <code>enum</code>.</p>
",9
3134870,3134757,51,"<p>Technically it doesn't matter. The compiler will most likely even create identical machine code for either case, but an enumeration has three advantages:</p>

<ol>
<li><p>Using the right compiler+debugger combination, the debugger will print enumeration variables by their enumeration name and not by their number. So ""StateBlahBlup"" reads much nicer than ""41"", doesn't it?</p></li>
<li><p>You don't have explicitly give every state a number, the compiler does the numbering for you if you let it. Let's assume you have already 20 states and you want to add a new state in the middle, in case of defines, you have to do all renumbering on your own. In case of enumeration, you can just add the state and the compiler will renumber all states below this new state for you.</p></li>
<li><p>You can tell the compiler to warn you if a switch statement does not handle all the possible enum values, e.g. because you forgot to handle some values or because the enum was extended but you forgot to also update the switch statements handling enum values (it will not warn if there's a <code>default</code> case though, as all values not handled explicitly end up in the default case).</p></li>
</ol>
",4
2943797,2943785,15,"<p>strlen() returns up to but not including the terminating NUL, so you will need to add 1 to its return in your malloc().  myValue thus ends up unterminated.</p>

<pre><code>myValue = malloc((strlen(inValue) + 1) * sizeof(char));
</code></pre>
",0
2943816,2943785,1,"<p>You shouldn't cast the return type from a malloc call. And always include stdlib.h.</p>

<pre><code>myValue = malloc((strlen(inValue) + 1) * sizeof(char));
</code></pre>

<p>Hope that helps,</p>
",2
2944441,2943785,2,"<p>strcpy(myValue, inValue) function copies the contents of the string inValue appended with the string terminated control char '\0' to the memory block allocated by malloc.</p>

<p>Once strlen(inValue) returns the length of the string excluding '\0' control char, the area to be allocated by malloc(strlen(inValue) * sizeof(char)) is not large enough to receive strcpy(myValue, inValue).</p>

<p>So, the '\0' char is copied to a not allowed memory location, overwriting another program data, and may cause segment fault, BAD ACCESS, GPF or something else just like giving no error message and showing unpredicted results, depending on the  compiler/operating system/platform.</p>

<p>On your case, you got a correct result just after the execution of strcpy, but a little bit later the string seemed to be corrupted, because the '\0' has been copied to a memory location that does not belong to the block allocated to myValue, and the owner of that block could have just change it, and your string will lose its end suffix. So a program error or just trash may be showed if you try to print myValue again after that.</p>

<p>To correct your code, the area to be allocated must be increased, as showed on the code bellow.</p>

<p>Just one more thing... in your example you wrote strcpy(mValue, inValue) instead of strcpy(myValue, inValue), but i think you have mistyped while writing the post.</p>

<pre><code>myValue = (char*)malloc((strlen(inValue) + 1) * sizeof(char));

strcpy(myValue, inValue);
</code></pre>
",0
7775170,7775138,17,"<p>C doesn't have default arguments, and if you're programming in C++ you should use <code>std::string</code> and <code>remove_if</code> from <code>&lt;algorithm&gt;</code>.</p>

<p>You definitely <em>can</em> make this more efficient, by eliminating the calls to <code>strlen</code>, which are turning an O(N) algorithm into an O(N<sup>2</sup>) algorithm, and are totally unnecessary -- you're scanning the string anyway, so just look for the NUL yourself.</p>

<p>You can also make this more C-idiomatic, by using two pointers instead of array indexing.  I'd do it like this:</p>

<pre><code>void strip_char(char *str, char strip)
{
    char *p, *q;
    for (q = p = str; *p; p++)
        if (*p != strip)
            *q++ = *p;
    *q = '\0';
}
</code></pre>
",1
7775172,7775138,10,"<p>First of all, <code>i&lt;strlen(str)</code> is always an inefficient idiom for looping over a string. The correct loop condition is simply <code>str[i]</code>, i.e. loop until <code>str[i]</code> is the null terminator.</p>

<p>With that said, here's the simplest/most concise algorithm I know:</p>

<pre><code>for (size_t i=0, j=0; s[j]=s[i]; j+=!isspace(s[i++]));
</code></pre>

<p><strong>Note:</strong> My solution is for the question as written in the subject (whitespace) as opposed to the body (particular character). You can easily adapt it if needed.</p>
",4
2094024,2093711,1,"<p>This works also:</p>

<pre><code>/*
 * code.c
 */
#include &lt;stdio.h&gt;

void printArray(int **iXArray, int iSize);

int main() {
    int array1[] = {7, 9, 3, 18};
    int *array2[] = {array1 + 0, array1 + 1, array1 + 2, array1 + 3};

    printArray(array2, 4);

    return 0;
}

// This should print the values in array1
void printArray(int **iXArray, int iSize) {
    int iCntr;
    for (iCntr = 0; iCntr &lt; iSize; iCntr++) {
            printf(""%d "", *iXArray[iCntr]);
    }
    printf(""\n"");
}
</code></pre>

<p>Pointer arithmetics works perfectly.</p>
",0
2093736,2093711,9,"<p>Try this: </p>

<pre><code>void printArray(int **iXArray, int iSize) ...
</code></pre>

<p>In your example you provide an array of (int*) so reference it as one, you must tell the compiler to expect an array of pointers.</p>

<p>By default passing an array is by reference. If you change the array's content, it changes at the callee's side aswell. The pointer itself is passed by value, so changing the value of the iXArray parameter (<code>iXArray = (int**)123;</code>) will not change the <code>array2</code> pointer at the callee's side.</p>

<p>If you want to pass the array by value, will need to wrap it in a value type:</p>

<pre><code>typedef struct {
  int A[123];
} Array;

Array incrementArray(Array array, int count) {
    for (int i=0; i&lt;count; i++) {
        array.A[i]++;
    }
    return array;
}
</code></pre>
",2
2093768,2093711,5,"<p>You are passing an array of pointers to int:</p>

<pre><code>void printArray(int *ixArray[], int iSize)
</code></pre>
",0
2093800,2093711,0,"<p>Regarding the ""stay untouched"".  You are passing things by reference so the way to keep them from being edited is to make them const.  You have a couple different options based on what part you don't want to change. However, that won't let you change them <em>in</em> you function.  What it sounds like is you want a pass-by-value which you can't get in C++ using arrays unless you make your own manual copy.</p>
",0
2093833,2093711,0,"<p>This seems to work without making array1 editable by printArray.</p>

<pre><code>/*
 * code.c
 */
#include &lt;stdio.h&gt;

void printArray(int *iXArray[], int iSize);

int main() {
    int array1[] = {7, 9, 3, 18};
    int *array2[] = {&amp;array1[0], &amp;array1[1], &amp;array1[2], &amp;array1[3]};

    printArray(array2, 4);

    return 0;
}

// This should print the values in array1
void printArray(int *iXArray[], int iSize) {
    int iCntr;
    for (iCntr = 0; iCntr &lt; iSize; iCntr++) {
        printf(""%d "", *iXArray[iCntr]);
    }
    printf(""\n"");
}
</code></pre>
",0
3429728,3429698,6,"<p>Type conversions works step by step. Your expression can be viewed as</p>

<pre><code>a = (b * 1000);
</code></pre>

<p>in the <code>b * 1000</code>, the compiler (let's pretend it's stupid) doesn't know you are going to store it into a <code>long long</code>. Since both <code>b</code> and 1000 are <code>int</code>s, the result will be an <code>int</code> also. How big <code>a</code> is doesn't matter here.</p>

<p>You could avoid the cast by making 1000 a <code>long long</code>.</p>

<pre><code>a = b * 1000LL;
</code></pre>

<p>Edit: For your edit 2:</p>

<ul>
<li><code>a</code> is a <code>long long</code>, <code>b</code> is an <code>int</code>, <code>3</code> is an <code>int</code>.</li>
<li>Therefore, <code>a * 3</code> is a <code>long long</code></li>
<li>Therefore, <code>b + a*3</code> is a <code>long long</code></li>
<li>But a cast is not needed in <code>c = b+a*3</code>, as a arithmetic operands are implicitly convertible to each other.</li>
</ul>
",2
7511013,7510718,2,"<p>shouldn't it be</p>

<pre><code>struct Player *player = malloc(sizeof(struct Player));
</code></pre>
",2
7511099,7510718,3,"<p>Your scanf call is likely the problem:</p>

<pre><code>scanf(""%s"", &amp;ch);
</code></pre>

<p>You seem to want a single character, but you're reading a string.  It'll put the first character in ch, but keep going from there and overwrite whatever's next on the stack.</p>

<p>You should probably just use <code>fgetc(stdin)</code> or another function that reads a single character, if a single character is what you want.</p>
",0
7510782,7510718,1,"<p>Weird thing like that are usually caused by writing to unallocated memory. (Usually writing beyond the end of an array.)</p>

<p>I didn't look at your code, but search for things like that. Then run your program under <code>valgrind</code>.</p>
",4
7510988,7510718,5,"<p>I suspect the problem is your use of scanf. You say you want to read a zero-terminated string, but you stuff it into a single char. The way the variables are laid out on the stack causes the terminating zero-byte to end up as the first char in player->name.</p>

<p>Try typing ""buffer overflow"" instead of ""y"", and you should get ""player uffer overflow go ..."".</p>

<p>If you want to stick with scanf, you want to make sure you pass it a proper string and set a limit on the size of the target buffer. For reading one char, try fgetc.</p>

<p><strong>Edit:</strong>
The above is of course not quite right... It is a buffer overflow, but it is the pointer of the player struct that is being overwritten. By lucky coincidence you get to a valid address that points to a zero-byte. By typing more, you will most likely get a crash instead.</p>
",0
2625515,2346501,7,"<p>If you need to change these values in order to get your QA tests to run, then that is not too much of a problem.  However, requiring a customer to do this in order for the program to run should (IMHO) be avoided.  If nothing else, create a wrapper script that sets these values and launches the application so that users will still have a one-click application launch.  Setting these from within the program would be the preferable method, however.  At the very least, have the program check the limits when it is launched and (cleanly) error out early if the limits are too low.</p>

<p>If a software developer told me that I had to mess with my stack and descriptor limits to get their program to run, it would change my perception of the software.  It would make me wonder ""why do they need to exceed the system limits that are apparently acceptable for every other piece of software I have?"".  This may or may not be a valid concern, but being asked to do something that (to many) can seem hackish doesn't have the same professional edge as an program that you just launch and go.</p>

<p>This problem seems even worse when you say ""this is not a situation where they MIGHT run out, under normal load our programs WILL run out and seg fault"".  A program exceeding these limits is one thing, but a program that doesn't gracefully handle the error conditions resulting from exceeding these limits is quite another.  If you hit the file handle limit and attempt to open a file, you should get an error indicating that you have too many files open.  This shouldn't cause a program crash in a well-designed program.  It may be more difficult to detect stack usage issues, but running out of file descriptors should never cause a crash.</p>

<p>You don't give much details about what type of program this is, but I would argue that it's not safe to assume that users of your program will necessarily have adequate permissions to change these values.  In any case, it's probably also unsafe to assume that nothing else might change these values while your program is running without the user's knowledge.</p>

<p>While there are always exceptions, I would say that in general a program that exceeds these limits needs to have its code re-examined.  The limits are there for a reason, and pretty much every other piece of software on your system works within those limits with no problems.  Do you really need that many files open at the same time, or would it be cleaner to open a few files, process them, close them, and open a few more?  Is your library/program trying to do too much in one big bundle, or would it be better to break it into smaller, independent parts that work together?  Are you exceeding your stack limits because you are using a deeply-recursive algorithm that could be re-written in a non-recursive manner?  There are likely many ways in which the library and program in question can be improved in order to ease the need to alter the system resource limits.</p>
",5
2625718,2346501,1,"<p>As you have to support a large number of different systems i would consider it wise to setup certain known to be good values for system limits/resources because the default values can differ wildly between systems.</p>

<p>The default size for pthread stacks is for example such a case. I recently had to find out that the default on HPUX11.31 is 256KB(!) which isn't very reasonable at least for our applications.</p>

<p>Setting up well defined values increases the portability of an application as you can be sure that there are X file descriptors, a stack size of Y, ... on every platform and that things are not just working by good luck.</p>

<p>I have the tendency to setup such limits from within the program itself as the user has less things to screw up (someone always tries to run the binary without the wrapper script). To optionally allow for runtime customization environment variables could be used to override the defaults (still enforcing the minimum limits).</p>
",1
2658733,2346501,0,"<p>A small tip : If you plan to run the application over 64 bit processor, then please be careful about setting stacksize unlimited. Which in 64 Bit Linux system give -1 as stacksize.</p>

<p>Thanks
Shyam</p>
",0
3048338,3048309,1,"<p>I think this is what you are describing:</p>

<pre><code>u_char newVar[frame_body_len];
memcpy(newVar, frame_body, frame_body_len);
</code></pre>

<p>It creates a new array that contains just the frame body less the headers and the checksum.</p>

<p>EDIT:  I just remembered C might not allow declaring an array of a non-literal size.</p>

<pre><code>u_char *newVar = (u_char *)malloc(frame_body_len);

if (newVar != NULL)
{
    memcpy(newVar, frame_body, frame_body_len);
}
else
{
    /* handle allocation error here */
}
</code></pre>
",1
3048374,3048309,1,"<p>Your <code>frame_body</code> is just a pointer to the start of the frame, pointing into an existing buffer where the data is. </p>

<p>That's fine, you can just pass that around together with your <code>frame_body_len</code> and have everyone that cares about the data only inspect the data starting from <code>frame_body</code> and don't care about anything beyond <code>frame_body_len</code> - which is what you'll have to do anyhow. </p>

<p>Thus, you don't really need to have a <code>frame_body</code> that doesn't include the trailing checksum.</p>

<p>If you do need such a buffer, e.g. dynamically allocated, you'll have to make space for the data, and copy the data there:</p>

<pre><code>u_char *frame_body = malloc(frame_body_len);
if(frame_body == NULL) {
   //deal with error
}

memcpy(frame_body,&amp;packet[radio_hdr-&gt;len + wifi_hdr_len],frame_body_len );
</code></pre>
",0
4352870,4352857,14,"<p>A comma operator is a sequence point : each comma separated expression are evaluated from left to right. The result has the type and value of the right operand. Functionally, your example is equivalent to (the much more readable ?) :</p>

<pre><code>else
{
    *pbuf++ = '%';
    *pbuf++ = to_hex(*pstr &gt;&gt; 4);
    *pbuf++ = to_hex(*pstr &amp; 15);
}
</code></pre>

<p>Here is another example that the standard provides for the comma operator (6.5.17) :</p>

<blockquote>
  <p>In the function call</p>

<pre><code>f(a, (t=3, t+2), c)
</code></pre>
  
  <p>the function has three arguments, the
  second of which has the value 5.</p>
</blockquote>
",0
4352872,4352857,12,"<p>From Wikipedia:</p>

<p>In the C and C++ programming languages, the comma operator (represented by the token ,) is a binary operator that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator, and acts as a sequence point.</p>

<p>The use of the comma token as an operator is distinct from its use in function calls and definitions, variable declarations, enum declarations, and similar constructs, where it acts as a separator.</p>

<p>In this example, the differing behavior between the second and third lines is due to the comma operator having lower precedence than assignment.</p>

<pre><code>int a=1, b=2, c=3, i;   // comma acts as separator in this line, not as an operator
i = (a, b);             // stores b into i                                ... a=1, b=2, c=3, i=2
i = a, b;               // stores a into i. Equivalent to (i = a), b;     ... a=1, b=2, c=3, i=1
i = (a += 2, a + b);    // increases a by 2, then stores a+b = 3+2 into i ... a=3, b=2, c=3, i=5
i = a += 2, a + b;      // increases a by 2, then stores a = 5 into i     ... a=5, b=2, c=3, i=5
i = a, b, c;            // stores a into i                                ... a=5, b=2, c=3, i=5
i = (a, b, c);          // stores c into i                                ... a=5, b=2, c=3, i=3
</code></pre>

<p>Link: <a href=""http://en.wikipedia.org/wiki/Comma_operator"">http://en.wikipedia.org/wiki/Comma_operator</a></p>
",1
4352898,4352857,0,"<p>Why it shouldn't work? It sets <code>%</code>, <code>to_hex(*pstr &gt;&gt; 4)</code>, <code>to_hex(*pstr &amp; 15)</code> to sequential memory block addressed by <code>pbuf</code>. The equivalent code may be the following:</p>

<pre><code>else {
  *pbuf = '%';
  *(pbuf + 1) = to_hex(*pstr &gt;&gt; 4);
  *(pbuf + 2) = to_hex(*pstr &amp; 15);
  pbuf += 3;
}
</code></pre>
",0
2910505,2910462,0,"<pre><code>top = NULL;    ==&gt; initialised to NULL
 g -&gt; visited[v] = TRUE;   
 push(v);   
 printf(""%d"", v);   
 while (top != NULL) ===&gt; top is NULL always ( previous assignment is NULL). 
                          Loop is not entered at all ! ?
</code></pre>
",3
2279576,2279543,3,"<p>Do you want to check if point belongs to a circle or in some subregion in the circle?  </p>

<p>To check if point belongs to the circle you can simply check if the distance from this point to the circle center is less then circle radius. </p>

<pre><code>if ((point.x - center.x)*(point.x - center.x) + 
           (point.y - center.y)*(point.y - center.y) &lt; radius*radius)
  // point is inside circle 
</code></pre>
",1
6636148,6636061,0,"<p>Before you do this:</p>

<pre><code>for( j=i;j&lt;list-&gt;size-1;j++ ) s3-&gt;delete_tail( s3 );
</code></pre>

<p>you should check for list->size = 0.  That's likely the problem.</p>
",1
6636150,6636061,1,"<blockquote>
  <p>Conditional jump or move depends on
  uninitialised value(s)</p>
</blockquote>

<p>This means that you are using a value that has not been initialized. Now let's look at your two loops:</p>

<p>Error free:</p>

<pre><code>for( j=i;j&gt;=0;j-- ) s3-&gt;delete_tail( s3 );
</code></pre>

<p>Error: </p>

<pre><code>for( j=i;j&lt;list-&gt;size-1;j++ ) s3-&gt;delete_tail( s3 );
</code></pre>

<p>If the error goes away due to a change in syntax, then the error <strong>must</strong> be present here. The only differences are that one contains <code>list-&gt;size</code>, while the other doesn't. </p>

<p>What does this mean in the context of the error? list->size hasn't been properly assigned a value or initialized, which is why you get the conditional jump error. So look at your initializing functions and see what's the issue.</p>

<p>Also, here is some extra advice. You have:</p>

<pre><code>i=0
....
j=0
</code></pre>

<p>And in your loops you have <code>j=i</code>, which is just making things confusion. Just make your function:</p>

<pre><code>j=0;
for (j; j &gt;=0; j--)
</code></pre>

<p>which makes the code clearer. Move <code>i=0</code> where it's needed, or delete it if it isn't used. </p>
",0
6636190,6636061,0,"<p>I read through a portion of your repository code and tried to keep track of what you are doing. There is a major problem here:</p>

<pre><code>void clone_list( MatrixList *from, MatrixList *to ) {
  if( from-&gt;head == NULL ) {
    to = NULL;
  } else {
    *to = *from;
    to-&gt;head = 0;
    to-&gt;tail = 0;
    to-&gt;size = 0;
    Node *old; 
    for( old=from-&gt;head;old!= NULL;old=old-&gt;next ) {
      Matrix *m_copy = clone_matrix(old-&gt;M);
      to-&gt;append( to,m_copy );
    }
  }
}
</code></pre>

<p>The first if part with to = NULL will change nothing of your return value, because you only assign it locally. If you need to change the pointer, then make the parameter a MatrixList **to and then do a *to = NULL. But I think it may also make sense to only write do a to->size = 0 (and check to for beeing NULL before).</p>

<p>If from was NULL, then list->size will be undefined later, because you dont initialize it before, what means it could have every possible value.</p>
",0
2436884,2436864,5,"<p><code>n=256;</code> converts the signed integer value <code>256</code> to <code>uint8_t</code>, then assigns it to <code>n</code>. This conversion is defined by the standard to take the value modulo-256, so the result is that <code>n</code> is set to <code>0</code>.</p>

<p>Not sure where you can find a table, but the rules for integer conversions are at 6.3.1.3:</p>

<blockquote>
  <p>1 When a value with integer type is
  converted to another integer type
  other than _Bool, if the value can be
  represented by the new type, it is
  unchanged.</p>
  
  <p>2 Otherwise, if the new type is
  unsigned, the value is converted by
  repeatedly adding or subtracting one
  more than the maximum value that can
  be represented in the new type until
  the value is in the range of the new
  type.49)</p>
  
  <p>3 Otherwise, the new type is signed
  and the value cannot be represented in
  it; either the result is
  implementation-defined or an
  implementation-defined signal is
  raised</p>
</blockquote>

<p>As AndreyT points out, this doesn't cover what happens when an out-of-range value occurs during a calculation, as opposed to during a conversion. For unsigned types that's covered by 6.2.5/9:</p>

<blockquote>
  <p>A computation involving unsigned
  operands can never overflow, because a
  result that cannot be represented by
  the resulting unsigned integer type is
  reduced modulo the number that is one
  greater than the largest value that
  can be represented by the resulting
  type.</p>
</blockquote>

<p>For signed types, 3.4.3/3 says:</p>

<blockquote>
  <p>EXAMPLE An example of undefined behavior is the behavior on integer overflow.</p>
</blockquote>

<p>(indirect, I know, but I'm too lazy to keep searching for the explicit description when this is the canonical example of undefined behavior).</p>

<p>Also note that in C, the integer promotion rules are quite tricky. Arithmetic operations are always performed on operands of the same type, so if your expression involves different types, there are a list of rules to decide how to choose what type to do the operation in. Both operands are promoted to this common type. It's always at least an int, though, so for a small type like <code>uint8_t</code>, arithmetic will be done in an <code>int</code> and converted back to <code>uint8_t</code> on assignment to the result. Hence for example:</p>

<pre><code>uint8_t x = 100;
uint8_t y = 100;
unsigned int z = x * y;
</code></pre>

<p>results in 10000, not 16 which would be the result if z were a <code>uint8_t</code> too.</p>

<p><i>Also, is it acceptable to use C99's PRI* macros? How are they named?</i></p>

<p>Acceptable to whom? I don't mind, but you might want to check whether your compiler supports them or not. GCC does in the earliest version I have lying around, 3.4.4. They are defined in 7.8.1.</p>

<p>If you don't have a copy of the C standard, use this: <a href=""http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf"" rel=""nofollow noreferrer"">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf</a>. It's a ""draft"" of the standard, released some time after the standard was published and including some corrections.</p>
",0
2436890,2436864,2,"<p>The behavior is described in the standard.</p>

<p>(*) <strong>Unsigned</strong> integer types implement modulo arithmetic. The modulo is equal to 2^N where N is the number of the value-forming bits in the type. This means that unsigned types ""wrap around"" on overflow (at both ends). If the maximum value of the type is 255, then 256 will turn into the next value after the wrap, which is 0. </p>

<p>The only exception from this behavior for unsigned types is when you convert a floating-point value to unsigned type. In case of overflow the behavior is undefined.</p>

<p>(*) <strong>Signed</strong> integer types are different. If the overflow occurs during <em>conversion</em> from floating-point type, the behavior is undefined (same as with unsigned types). If the overflow occurs during <em>conversion</em> from other integer type the result is implementation defined. If the overflow occurs during an arithmetic operation, the behavior is undefined.</p>

<p>(*) <strong>Floating-point</strong> types cause undefined behavior on overflow during conversion.</p>
",0
2445615,2445604,10,"<p>You're not linking with the <code>wsock32.lib</code> library.</p>
",0
3077477,2416302,0,"<p>Err, ANSI/ISO C doesn't include sockets.</p>
",0
2380005,2379986,5,"<p>The specifier for <code>unsigned long</code> is <code>lu</code>. That for <code>unsigned short</code> is <code>hu</code>. You invoke UB by not using the proper specifiers.</p>
",6
2380056,2379986,0,"<p>There are a number of problems with your code - here is a fixed version which should behave correctly.</p>

<pre><code>#include &lt;stdio.h&gt;

unsigned short func1(void); // NB: function prototype !

int main(void)
{
  unsigned long int L = 0;
  unsigned short K = 0;

  L = func1();
  printf(""%lu"", L);
  K = L; 
  printf(""%u"", K);

  return 0;
}

unsigned short func1(void)
{
   unsigned short i = 0;

   // Algorithm Logic!!!

   return i; // returns 0
}
</code></pre>
",3
2607427,2607381,2,"<p>There are <a href=""http://www.winprog.org/tutorial/bitmaps.html"" rel=""nofollow noreferrer"">lots</a> of <a href=""http://www.functionx.com/visualc/views/DisplayBitmap.htm"" rel=""nofollow noreferrer"">good</a> <a href=""http://www.ucosoft.com/how-to-draw-bitmap-from-a-bmp-file.html"" rel=""nofollow noreferrer"">tutorials</a> on the <a href=""http://www.google.com/search?q=draw+bitmap+win32"" rel=""nofollow noreferrer"">web</a>.</p>
",0
7209982,7209950,2,"<p>It just sets the enum to the value 1.  It is probably intended to indicate that the values are to be powers of 2.  The next one would maybe be assigned <code>1 &lt;&lt; 1</code>, etc.</p>
",0
7209999,7209950,4,"<p>The value of <code>SomeOptionKeys</code> is one, this is a useful representation when working with flags:</p>

<pre><code>typedef enum {
  flag1 = 1 &lt;&lt; 0, // binary 00000000000000000000000000000001
  flag2 = 1 &lt;&lt; 1, // binary 00000000000000000000000000000010
  flag3 = 1 &lt;&lt; 2, // binary 00000000000000000000000000000100
  flag4 = 1 &lt;&lt; 3, // binary 00000000000000000000000000001000
  flag5 = 1 &lt;&lt; 4, // binary 00000000000000000000000000010000
  // ...
} SomeOption;
</code></pre>

<p>Whit way each flag has only one bit set, and they could be represented in a bitmap.</p>

<p>Edit:</p>

<p>Although, I have to say, that I might be missing something, but it seems redundent to me to use enums for that. Since you lose any advantage of enums in this configuration, you may as well use <code>#define</code>:</p>

<pre><code>#define flag1 (1&lt;&lt;0)
#define flag2 (1&lt;&lt;1)
#define flag3 (1&lt;&lt;2)
#define flag4 (1&lt;&lt;3)
#define flag5 (1&lt;&lt;4)
</code></pre>
",0
7210023,7209950,9,"<p>It looks like it defines an enumerated type that is supposed to contain a set of flags. You'd expect to see more of them defined, like this:</p>

<pre><code>typedef enum {
  FirstOption = 1 &lt;&lt; 0,
  SecondOption = 1 &lt;&lt; 1,
  ThirdOption = 1 &lt;&lt; 2
} SomeOption;
</code></pre>

<p>Since they are defined as powers of two, each value corresponds to a single bit in an integer variable. Thus, you can use the bitwise operators to combine them and to test if they are set. This is a common pattern in C code.</p>

<p>You could write code like this that combines them:</p>

<pre><code>SomeOption myOptions = FirstOption | ThirdOption;
</code></pre>

<p>And you could check which options are set like this:</p>

<pre><code>if (myOptions &amp; ThirdOption)
{
  ...
}
</code></pre>
",2
7210042,7209950,1,"<p>&lt;&lt; is the left shift operator.  In general, this is used when you want your enums to mask a single bit.  In this case, the shift doesn't actually do anything since it's 0, but you might see it pop up in more complex cases.</p>

<p>An example might look like:</p>

<pre><code>typedef enum {
   OptionKeyA = 1&lt;&lt;0,
   OptionKeyB = 1&lt;&lt;1,
   OptionKeyC = 1&lt;&lt;2,
} OptionKeys;
</code></pre>

<p>Then if you had some function that took an option key, you could use the enum as a bitmask to check if an option is set.</p>

<pre><code>int ASet( OptionKeys x){
   return (x &amp; OptionKeyA);
}
</code></pre>

<p>Or if you had a flag bitmap and wanted to set one option:</p>

<pre><code>myflags | OptionKeyB
</code></pre>
",0
2541520,2541506,0,"<p>The code contains no instructions to write into the output files.  It only writes to stdout.</p>
",0
2541525,2541506,4,"<p>You're checking <code>i % 2</code>, not <code>num % 2</code>. I'm not even sure what <code>i</code> does in this example¡ªperhaps you're planning on using it later.</p>

<pre><code>while (fscanf(dog, ""%d"", &amp;num) != EOF) {
    if (num % 2 == 0) {
        printf(""even = %d\n"", num);
    }
    else if(num != 0) {
        printf(""odd = %d\n"", num);
    }
}
</code></pre>

<p>I imagine the code to write these numbers to the files will come later, once you've fixed this bug.</p>
",1
2541527,2541506,0,"<p>The <code>printf</code> function writes to the screen (more correctly, it writes to ""standard output"", but that is usually the screen). You want to write to a file. You have opened files called <code>feven</code> and <code>fodd</code>. To write to them, you would use the <code>fprintf</code> call, which works like <code>printf</code> except it takes an extra (left-most) argument, which is the <code>FILE*</code> that you want to write to, e.g.</p>

<pre><code>FILE *fmyfile = fopen(""myfile.txt"", ""w"");
fprintf(fmyfile, ""The magic number is %d!"", 3);
</code></pre>

<p>Also, your results are incorrect, but that's an unrelated problem.</p>
",0
2541532,2541506,0,"<p>In addition to the <code>printf</code>/<code>fprintf</code> problem, in any decent modern compiler, that code should be generating a warning that you're not assigning any initial value to <code>i</code>.</p>
",2
8394551,8394452,1,"<p>There is no consistent address between operating systems and architectures for the text section or any other section.  Additionally position independent code and address space layout randomizations make these values even inconsistent on the same machine for some systems.</p>
",0
8394560,8394452,4,"<p>There is a good explanation here of how Linux virtual memory works when allocating storage for a particular program.
<a href=""http://www.ualberta.ca/CNS/RESEARCH/LinuxClusters/mem.html"" rel=""nofollow"">ua alberta - linux memory allocation</a> </p>

<p>The designers of the compiler/linker tool chain need to allocate an arbitary address for particular blocks of memory. In order to make it easier for other components of the tool chain like debuggers and profilers they always allocatate the same block to the same addresses. The actual addresses chosen are completely arbitrary.  </p>

<p>When the program is loaded the virtual address will be mapped to some random piece of free memory (this is mostly done in hardware). This mapping is done on a per process basis to several programs can address virtual address x'0848000' but be pointed at different ""real"" memory addresses.</p>
",1
8394628,8394452,2,"<p>It all depends on the implementation on the particular machine.For a linux machine the behaviour will be different than that from windows machine.
Note however that the virtual memory addresses need to start at some fixed address in order to make life easier for debuggers.However the real addresses will be different depending on the pages available in RAM.
If you look the output of readelf -S more carefully you will notice you will notice subtracting the offset from the address indeed gives you 0x0848000.
As i had mentioned earlier this <strong>magic number 0x0848000</strong> will depend on the type of executable format.
here is the output i get on my ubuntu 32 bit machine:</p>

<pre><code>readelf -S ~/a.out
There are 29 section headers, starting at offset 0x1130:

Section Headers:
[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
[ 0]                   NULL            00000000 000000 000000 00      0   0  0
[ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1
[ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4
[ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4
[ 4] .gnu.hash         GNU_HASH        0804818c 00018c 000020 04   A  5   0  4
[ 5] .dynsym           DYNSYM          080481ac 0001ac 000050 10   A  6   1  4
[ 6] .dynstr           STRTAB          080481fc 0001fc 00004c 00   A  0   0  1
[ 7] .gnu.version      VERSYM          08048248 000248 00000a 02   A  5   0  2
[ 8] .gnu.version_r    VERNEED         08048254 000254 000020 00   A  6   1  4
[ 9] .rel.dyn          REL             08048274 000274 000008 08   A  5   0  4
[10] .rel.plt          REL             0804827c 00027c 000018 08   A  5  12  4
[11] .init             PROGBITS        08048294 000294 000030 00  AX  0   0  4
[12] .plt              PROGBITS        080482c4 0002c4 000040 04  AX  0   0  4
[13] .text             PROGBITS        08048310 000310 00018c 00  AX  0   0 16
[14] .fini             PROGBITS        0804849c 00049c 00001c 00  AX  0   0  4
</code></pre>
",0
3075774,2935822,0,"<p>The sleep function is not in the ANSI C standard; if you're talking about the <code>sleep</code> function (with lowercase s), it's the POSIX function, which still has a resolution of 1 second. Instead, probably you're talking about the Windows API <code>Sleep</code> function (uppercase S), which has 1 ms resolution, but that isn't intended to be used when high precision is needed.</p>

<p>If you are on Windows, the suggestion that has been given to you is correct, you should use multimedia timers, that are specifically designed for soft-realtime needs such as multimedia playback.</p>
",0
2935888,2935822,1,"<p>I developed this function for Linux and MacOSX machines. I hope it may help you.</p>

<p>// t => mili seconds</p>

<pre><code>void Wait(unsigned long t)
{
#if defined(_LINUX) || defined(__APPLE__)
    time_t secs;
    long   milisecs,
           nanosecs;
    struct timespec waittime;

    secs     = t / 1000L;
    milisecs = t - (secs * 1000L);
    nanosecs = milisecs * 1000000L;
    waittime.tv_sec   = secs;
    waittime.tv_nsec  = nanosecs;

    nanosleep(&amp;waittime, NULL);
#else      
    struct timeval timeout;

    timeout.tv_sec  = 0;
    timeout.tv_usec = t * 1000L;

    select(0, NULL, NULL, NULL, &amp;timeout);
#endif
}
</code></pre>
",1
2512987,2512981,2,"<p>Yes, definitely.  <code>int</code>, in particular, is particularly prone to that: old 8-bit and 16-bit architectures invariably had 16-bit <code>int</code>s, while today's 32-bit and 64-bit ones invariably use 32-bit <code>int</code>s.  That's how <code>int</code> is defined to <em>be</em> -- the ""natural"" size of integers for the architecture you're compiling for!</p>
",3
2512988,2512981,5,"<p>It's definitely the case that <code>float</code>, <code>int</code>, and <code>char</code> may be of different sizes on different devices, yes.  It's implementation-defined by your C compiler.  All you can count on for really portable code is that:</p>
<pre><code>sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long)
</code></pre>
<p>And that <code>sizeof(char) == 1</code>.  There are a bunch of types in C99 that are of specific bit sizes, those may be useful to you if you need to keep type size portable from architecture to architecture.</p>
<p>Edit:  I looked up the information in the spec.  Section 5.2.4.2.1, &quot;Sizes of integer types&quot;, is what you're looking for:</p>
<blockquote>
<p>...implementation-defined values shall be equal or greater in magnitude (absolute value) to those shown...</p>
<pre><code>UCHAR_MAX         255 // 2^8 - 1
USHRT_MAX       65535 // 2^16 - 1
UINT_MAX        65535 // 2^16 - 1
ULONG_MAX  4294967295 // 2^32 ? 1
</code></pre>
</blockquote>
<p>And so on...</p>
",1
2512996,2512981,0,"<p>As others have said, it's a complete YES. However, there's also the part about endianness which nobody has mentioned. Different architectures can store the bytes that make up a type in different orders as well.</p>
",0
2910673,2910660,1,"<ol>
<li> Define __HEADERS in the ifndef.
<li> Put declarations, not definitions, in your headers:
</ol>

<pre><code>// header

extern int x;

 // implementation

int x = 10;
</code></pre>

<p>3.&nbsp;2.c has the include wrong.</p>

<p>So:</p>

<pre><code>// headers.h

#ifndef __HEADERS
#define __HEADERS
    extern int x;
#endif
</code></pre>

<p>// 1.c</p>

<pre><code>#include ""headers.h""

int x = 10;

main ()
{
}
</code></pre>

<p>// 2.c</p>

<pre><code>#include ""headers.h""
fun () {}
</code></pre>

<p>You can define x anywhere.  Just make it one place.</p>
",0
2910682,2910660,1,"<p>This is a classic case where you want either the variable declared or declared-and-defined.</p>

<p>If you define it in both source files, you <em>will</em> get a double-definition linker error. One way to handle this is to only set <code>__HEADERS</code> for one of the source files so that it is the one where the variable is defined.</p>

<p>All other source files get the declaration only.</p>

<pre><code>&gt;&gt;headers.h
    #ifndef __HEADERS
        int x = 10;
    #else
        extern int x;
    #endif

&gt;&gt;1.c
    #define __HEADERS
    #include ""headers.h""
    int main (void) {
        return 0;
    }

&gt;&gt;2.c
    #include ""headers""
    void fun (void) {
    }
</code></pre>

<p>Of course, it's best to leave definitions out of header files altogether in case you accidentally define <code>__HEADERS</code> in two source files. Try:</p>

<pre><code>&gt;&gt;headers.h
    extern int x;

&gt;&gt;1.c
    #include ""headers.h""
    int x = 10;
    int main (void) {
        return 0;
    }

&gt;&gt;2.c
    #include ""headers""
    void fun (void) {
    }
</code></pre>
",0
2910689,2910660,5,"<p>The linker complains because there will be multiple definitions of <code>x</code> once it puts all the object files together to create the executable. You have two different source files including the same header file, and that header file defines a variable <code>x</code> having a value of 10, so you end up with two definitions of <code>x</code> (one in 1.c and another in 2.c).</p>

<p>To avoid multiple definition linker errors, put this in a header file (for example <code>globals.h</code>):</p>

<pre><code>#ifndef GLOBALS_H
#define GLOBALS_H

/* 
 * The ""extern"" keyword means that this variable is accessible everywhere
 * as long as this declaration is present before it is used. It also means
 * that the variable x may be defined in another translation unit. 
 */
extern int x;

#endif
</code></pre>

<p>Then put this in <strong>one</strong> source file:</p>

<pre><code>#include ""globals.h""

int x = 10; 
</code></pre>
",1
2910707,2910660,1,"<p>#include works exactly the same as if you copied and pasted the text from the header file.</p>

<p>Consider it in that way and you will see that you have therefore put the line <code>int x=10</code> into <strong>both</strong> your source files.</p>

<p>A fixed version is below:</p>

<pre><code>&gt;&gt;headers.h
#ifndef __HEADERS
#define__HEADERS
extern int x;  // extern tells the compiler it will be linked from another file
#endif
-----------------
&gt;&gt;1.c
#include ""headers.h""
int x = 10;  // must have it in ONE file for linking purposes
main ()
{
}
---------------------
&gt;&gt;2.c
#include ""headers""
fun () {}
</code></pre>
",0
2916463,2916170,7,"<p>if you don't want to execute a shell command you can (as you mentioned) use the settimeofday,  i would start by reading the <a href=""http://www.manpagez.com/man/2/settimeofday/"" rel=""noreferrer"">MAN page</a>, or looking for some examples</p>

<p>here's an example:</p>

<pre><code>#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

int main(int argc, char *argv[])
{
    struct timeval now;
    int rc;

    now.tv_sec=866208142;
    now.tv_usec=290944;

    rc=settimeofday(&amp;now, NULL);
    if(rc==0) {
        printf(""settimeofday() successful.\n"");
    }
    else {
        printf(""settimeofday() failed, ""
        ""errno = %d\n"",errno);
        return -1;
    }

    return 0;
}
</code></pre>

<p>Shamelessly ripped From <a href=""http://publib.boulder.ibm.com/infocenter/iseries/v5r3/index.jsp?topic=/apis/settod.htm"" rel=""noreferrer"">IBMs documentation</a>,  the <code>struct timeval</code> struct holds the number of seconds (as a <code>long</code>) plus the number of microseconds (as a <code>long</code>) from 1 January 1970, 00:00:00 UTC (Unix Epoch time).  So you will need to calculate these numbers in order to set the time.  you can use these <a href=""http://linux.die.net/man/3/timercmp"" rel=""noreferrer"">helper functions</a>, to better handle dealing with the timeval struct.</p>
",2
2950253,2950232,1,"<p>Declare the functions in header files and then implement them in .c files. Now you can <code>#include</code> the header files into any program that uses the functions and then link the program against the object files generated from the .c files.</p>
",0
2950284,2950232,1,"<p>Say you have a file with a function that you want to use elsewhere:</p>

<pre><code>int func2(int x){
/*do some stuff */
return 0;
}
</code></pre>

<p>what you would do is split this up into a header file and a source file. In the header file you just have the function declaration, this tells the compiler that that function does exist, even if it is in a different file. The header might be called func2.h might look like this:</p>

<pre><code>#ifndef HEADER_FUNC2_H
#define HEADER_FUNC2_H
int func2(int x);
#endif /*HEADER_FUNC2_H*/
</code></pre>

<p>The #ifndef HEADER_FUNC2_H part is to make sure that this only gets used once so that there are no multiple definitions going on. 
then in the source func2.c file you have the actual function itself:</p>

<pre><code>int func2(int x){
/*do some stuff */
return 0;
}
</code></pre>

<p>and in any other file now that you use func2 you have to include the header. You do this with #include ""func2.h"". So for example if we wanted to call func2 from randomfile.c it would be like this:</p>

<pre><code>#include ""func2.h""
/* rest of randomfile.c */
func2(1);
</code></pre>

<p>Then the last step is to link the object file that contains the function with the compiler when you compile.</p>
",0
2950297,2950232,4,"<p>Most definitely! What you're describing are header files. You can read more about this process <a href=""http://gcc.gnu.org/onlinedocs/cpp/Header-Files.html"" rel=""nofollow noreferrer"">here</a>, but I'll outline the basics below.</p>

<p>You'll have your functions separated into a header file called <code>functions.h</code>, which contains the following:</p>

<pre><code>int return_ten();
</code></pre>

<p>Then you can have a <code>functions.c</code> file which contains the definition of the function:</p>

<pre><code>int return_ten()
{
    return 10;
}
</code></pre>

<p>Then in your <code>main.c</code> file you can include the <code>functions.h</code> in the following way:</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""functions.h""

int main(int argc, char *argv[])
{
    printf(""The number you're thinking of is %d\n"", return_ten());

    return 0;
}
</code></pre>

<p>This is assuming that your <code>functions.h</code> file is in the same directory as your <code>main.c</code> file.</p>

<p>Finally, when you want to compile this into your object file you need to link them together. Assuming you're using a command-line compiler, this just means adding the extra definition file onto the end. For the above code to work, you'd type the follow into your cmd: <code>gcc main.c functions.c</code> which would produce an a.out file that you can run.</p>
",11
2950320,2950232,0,"<p>If you want to reuse functions across multple programs, you should place them in a library and link it with the rest of your code.</p>

<p>If you want to share the same definitions (e.g. macros, types, ...) you can place them in a header file and include them with <code>#include</code>.</p>

<p>Please refrain from directly ""#include"" function code into a source file, it's a bad practice and can lead to very problematic situations (especially if you are a beginner, as your tag suggests).</p>

<p>Consder that normally when you have a set of functions you want to share and reuse, you will need both! You will usually end up with a <code>myfuncs.lib</code> (or <code>libmyfuncs.a</code>) library and a <code>myfuncs.h</code> header.</p>

<p>In the programs where you want to reuse your existing functions, you will include the header and link against the library. </p>

<p>You can also look at how to use dynamic libraries once you have mastered the usage of static libraries.</p>
",0
2627136,2627112,10,"<p>Consider the macro:</p>

<pre><code>#define HINSTANCE ""hDll""
</code></pre>

<p>and its use:</p>

<pre><code>HINSTANCE hDll;   //DLL¾ä±ú 
</code></pre>

<p>after preprocessing it would look like:</p>

<pre><code>""hDll"" hDll;
</code></pre>

<p>which clearly is an error as it makes <code>hDll</code> undeclared as <code>""hDll""</code> is not a valid type.</p>
",1
2627151,2627112,2,"<p>remove</p>

<pre><code>#define HINSTANCE ""hDLL""
</code></pre>

<p>To remove C4627 warning, move up <code>#include ""stdafx.h""</code> to the top (to be the first #include) as indicated by <a href=""https://stackoverflow.com/users/187599/mike-dinsdale"">Mike Dinsdale</a>'s <a href=""https://stackoverflow.com/questions/2627112/whats-wrong-in-my-c-program/2627304#2627304"">answer</a>. This will probably solve error for <code>LoadLibrary</code>, <code>GetProcAddress</code>, and <code>FreeLibrary</code>:</p>

<pre><code>#include ""stdafx.h"" // moved up
#include &lt;iostream&gt;
#include &lt;jni.h&gt;
#include ""Hello.h""
#include ""windows.h""
</code></pre>
",0
2627304,2627112,2,"<p>Could it be a pre-compiled header issue?  With some project settings VC++ will skip stuff before the <code>#include ""stdafx.h""</code>, which I think might be the cause of the C4627 warnings you're getting.  Have you tried moving <code>#include ""stdafx.h""</code> before your other <code>#include</code>s?</p>
",0
2091832,2091825,3,"<p>Yes. It's called <code>strstr</code>, related to <code>strpos</code> like (pseudo-code):</p>

<pre><code>strpos(str, target) {
   res = strstr(str, target); 
   if (res == NULL) return false;
   else             return res - str;
}
</code></pre>
",1
2091835,2091825,16,"<p>The function you are looking for might be either strstr or strchr. You then need to include string.h. There is no strpos in the POSIX interface.</p>
",0
2431823,2431692,1,"<p>Generally such operations with memory are very platform-dependant.</p>

<p>Main problem is that due to data aligning variables in memory can be located not where you expect them to.</p>
",0
2431855,2431692,0,"<p>Apart from already mentioned problems your code also violates the strict aliasing rule, therefore its behavior is undefined.</p>
",0
2431805,2431692,2,"<p>this has to do with structure packing.  by adding the <code>tm</code> field to the sSpecificData, you are changing it from a structure that has a natural alignment of int (4 bytes), to something that has a natural alignment of what appears to be 8 bytes. </p>

<p>so with <code>tm</code> as part of <code>sSpecificData</code>, the structure <code>sMyData</code> is effectively this</p>

<pre><code>typedef struct {
   int                    m_Id;
   // 4 bytes of padding inserted to align sSpecificData on an 8 byte boundary.
   sSpecificData          m_Data; // with tm, this has a alignment of 8
} sMyData;
</code></pre>

<p>this explains what you are seeing.  To fix this, you can add an explicit padding value to sMyData AND to sData. </p>

<pre><code>typedef struct
{
   int                 m_Id;
   int                 m_padding;
   sDataBuffer         m_Data; // this accepts structures with an alignment of up to 8 
} sData;

typedef struct {
   int                    m_Id;
   int                    m_padding;
   sSpecificData          m_Data; // with tm, this has a alignment of 8
} sMyData;
</code></pre>

<p>Or you can use <code>#pragma pack(4)</code> (if your c compiler supports it) to force the padding to be left out of sMyData, but this will result in <code>tm</code> being misaligned which isn't a good idea.  see this related question.</p>

<p>a very similar question came up today about C#, but the issues are the same, (the syntax for specifying packing is different though)
<a href=""https://stackoverflow.com/questions/2428168/size-of-structures-in-net/2428231#2428231"">Size of structures in .NET</a></p>
",0
2654744,2654706,4,"<p>Why not use the <code>wc</code> (word count) program? Just pipe your output to <code>wc -w</code> and you're done.</p>
",0
2655118,2654706,2,"<p>Your word count program is always using <code>argv[1]</code> as the input file.  If you want to support reading from stdin or a given file, then you would need to change what you use for your input based on the number of arguments given to your program.</p>

<pre><code>std::streambuf* buf;
std::ifstream infile;
if (argc &gt; 1)
{
    // Received an argument, so use it as a source file
    infile.open(argv[1]);
    if (!infile)
    {
        perror(""open"");
        return 1;
    }
    buf = infile.rdbuf();
}
else
{
    // No arguments so use stdin
    buf = std::cin.rdbuf();
}

std::istream input(buf);
while (!input.eof())
{
    ...
}
...
</code></pre>
",0
4252219,4252161,1,"<p><a href=""http://snippets.dzone.com/posts/show/2750"" rel=""nofollow"">http://snippets.dzone.com/posts/show/2750</a></p>

<p>That shows a quick snippet on simulating a mouse click. From there you can look into the other functions in the Xlib library. </p>

<p>Also there's a tool that does the same things you're talking about, you might want to take a look at its source if you want to know more about it. </p>

<p><a href=""http://www.semicomplete.com/projects/xdotool/"" rel=""nofollow"">http://www.semicomplete.com/projects/xdotool/</a></p>
",0
8302589,8302547,8,"<p><code>__USE_GNU</code> is an internal macro, so you shouldn't define it yourself.</p>

<p>But you may define <code>_GNU_SOURCE</code>, either in your code, or when compiling (using the <code>-D</code> option).</p>

<p>I think defining this one will help to make <code>TEMP_FAILURE_RETRY</code> available.</p>
",5
3312043,3311993,0,"<p>I'm reasonably certain there's no requirement about initialization of padding. Just for example, it would be entirely legal for an implementation to add padding to <em>every</em> struct, and have it store a tag telling what type of structure it is to support run-time type checking. In such a case, most structs would contain padding that was always non-zero.</p>
",0
3312112,3311993,2,"<p>Quoting from the C99 standard, ""Representation of types"", 6.2.6:</p>

<blockquote>
  <p>When a value is stored in an object of
  structure or union type, including in
  a member object, the bytes of the
  object representation that correspond
  to any padding bytes take unspecified
  values.</p>
</blockquote>

<p>In short, it is not specified by the language; it's up to the C compiler/interface implementor.</p>
",0
3750610,3750592,12,"<pre><code>while(*(str++)) ++len;
</code></pre>

<p>is same as:</p>

<pre><code>while(*str) {
 ++len;
 ++str;
}
</code></pre>

<p>is same as:</p>

<pre><code>while(*str != '\0') {
 ++len;
 ++str;
}
</code></pre>

<p>So now you see when <code>str</code> points to the <code>null</code> char at the end of the string, the test condition fails and you stop looping.</p>
",1
3750612,3750592,0,"<p>Once <code>*(str++)</code> returns 0, the loop exits. This will happen when <code>str</code> points to the last character of the string (because strings in C are 0 terminated).</p>
",0
3750619,3750592,10,"<ol>
<li>C strings are terminated by the <code>NUL</code> character which has the value of <code>0</code></li>
<li>0 is <code>false</code> in C and anything else is <code>true</code>.</li>
</ol>

<p>So we keep incrementing the pointer into the string and the length until we find a <code>NUL</code> and then return.</p>
",3
3750634,3750592,2,"<p>You need to understand two notions to grab the idea of the function : </p>

<p>1¡ã) A C string is an array of characters. </p>

<p>2¡ã) In C, an array variable is actually a pointer to the first case of the table. </p>

<p>So what strlen does ? It uses pointer arithmetics to parse the table (++ on a pointer means : next case), till it gets to the end signal (""\0"").</p>
",2
3750650,3750592,0,"<p>Correct, <code>str++</code> increases the counter and returns the previous value. The asterisk (<code>*</code>) dereferences the pointer, i.e. it gives you the character value.</p>

<p>C strings end with a zero byte. The <code>while</code> loop exits when the conditional is no longer true, which means when it is zero.</p>

<p>So the <code>while</code> loop runs until it encounters a zero byte in the string.</p>
",0
3913128,3913119,2,"<p>If you're on a unixy style system memmap and memcpy might give you neat solution.</p>
",0
3913140,3913119,2,"<p>You can use </p>

<pre><code>size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );
</code></pre>

<p>function.</p>

<pre><code>ptr - pointer to you memory segment.
size - size of memory to write.
stream - file you writing to.
</code></pre>

<blockquote>
  <p>Will my ""datastructures"" survive as ""charachters"", or do I need to write it in some sort of binary / hexa data-mode? Or is it a stadard way of doing this?</p>
</blockquote>

<p>when you open file - use 'b' character in ""mode"" param</p>
",0
3913152,3913119,12,"<p>This problem is called ""<a href=""https://secure.wikimedia.org/wikipedia/en/wiki/Serialization"" rel=""nofollow noreferrer"">serializing</a>"" and can range from trivial to really complicated. If your data structure is self contained, for instance a bunch of pixels in an array and you know the array dimensions, you can just dump the data out and then read it back.</p>

<p>If you have for instance linked lists, or pointers of any kind, in your data, then those pointers will not point to anything valid once you read them back. This is where a more formal approach to serializing starts to make sense.</p>

<p>This can range from saving as file formats, use databases, convert to XML or other hierarchical format and so on. What is an OK solution depends completely on what kind of data you have, and what types of operations you are doing on it plus how <i>often</i> you plan to write and then read back from disk. (Or network. Or whatever you are doing.)</p>

<p>If what you have is a trivial blob of data, and you just want to write it out the simplest way possible, use <a href=""https://secure.wikimedia.org/wikipedia/en/wiki/C_file_input/output"" rel=""nofollow noreferrer"">fwrite()</a>:</p>

<pre><code>fwrite(my_pointer, MEMORY_SIZE, 1, fp);
</code></pre>

<p>and then <a href=""https://secure.wikimedia.org/wikipedia/en/wiki/C_file_input/output"" rel=""nofollow noreferrer"">fread()</a> to read the data back.
Also see a related (more or less related depending on how advanced your needs are) <a href=""https://stackoverflow.com/questions/371371/serialize-data-structures-in-c"">serializing question on StackOverflow</a>.</p>

<p>Proper <a href=""https://secure.wikimedia.org/wikipedia/en/wiki/Serialization"" rel=""nofollow noreferrer"">serialization</a> also solves <a href=""https://secure.wikimedia.org/wikipedia/en/wiki/Endianness"" rel=""nofollow noreferrer"">the problems that appear</a> when different kinds of CPUs are supposed to be able to read data from each other. Proper serialization in C is lot more complicated than in other languages. In Lisp for instance, all data and code is already serialized. In Java, there are methods to help you serialize your data. The properties of C that makes it a suitable language for high performance and systems programming also makes it tougher to use for some other things.</p>
",1
3913186,3913119,1,"<p>The proper way of doing that is to use a serialisation library.</p>

<p>Whether you really need that depends on the complexity of your data. If the data you need to write out does not contain any pointers of any kind, then you could just use <code>fwrite</code> to write the data out and <code>fread</code> to read it back in. Just make sure that you have opened the file with the data in binary mode.</p>

<p>If the data to serialise contains pointers, you are way better of using an external library written for this purpose, as the library will ensure that the pointers get written in such a way that they can be properly reconstructed later.</p>
",0
3913226,3913119,2,"<p>As long as the data you are dumping out contains no pointers, just dumping it out like that will work. (HINT: Use the calls that can write long sequences of data all in one go to cut time.) The only thing to watch out for is if you're writing out integers or floating point numbers and reading them back in on a machine with a different architecture (e.g., big endian instead of little endian). That might or might not be a concern for you.</p>

<p>But if you've got pointers inside, you've got a problem. The problem is that you cannot (well, cannot easily) guarantee that you'll get the data loaded back at the same position in the receiving process's virtual memory space. What's more, if you have data that has pointers to things that you're not saving (e.g., a stray <code>FILE*</code>) then you've got to think about what to do to resynthesize a valid replacement at that point. Such serialization is deeply non-trivial, and requires writing code that has knowledge of exactly what you're saving and loading.</p>

<p>There is a way to simplify serialization a little when you've only got pointers within the contiguous data being saved and are always going to restore on the same architecture. Dump out the memory as before, but put a prefix descriptor on that says at least the length of the data and the number of pointers within, then also save (at the end) a table of exactly where (as offsets within the data) the pointers are and where the start of all the data was. You can then restore by reading the data in and performing address arithmetic to correct all the pointers, i.e., you can work out what offset relative to the start of the original data they were pointing to ¨C as a <code>char*</code>, not the original type ¨C and make sure that they point to the same offset relative to the address of the whole data after reloading. This is a somewhat gross hack and is formally not the most portable thing ever, but within the constraints outlined at the beginning of this paragraph I'd expect it to work. However you'll also have a really non-portable serialization format; <em>do not count on it <strong>at all</strong> for any sort of persistent archival use!</em></p>
",0
2537013,2534993,0,"<p>First, <code>ln</code> isn't properly initialized in the sample <code>removeStudent()</code>, so calling <code>ln-&gt;compareTo</code> will probably cause a segfault. Hopefully, <code>ln</code> is properly initialized in your actual code.</p>

<p>To define an ordering on the strings, you can first define what's known in database circles as a ""collation"": an ordering on characters. You can implement the collation as a function (called, say, <code>chrcmp</code>), or inline within your string comparison function. The important thing is to define it.</p>

<p>Generally speaking, an ordering on a type induces a <a href=""http://en.wikipedia.org/wiki/Lexicographical_order"" rel=""nofollow noreferrer"">lexicographic order</a> on sequences of that type: to compare two sequences, find the first place they differ; the lesser sequence is the one with the lesser element at that position. </p>

<p>More formally, suppose sequences are indexed starting at 0. let <strong>a</strong> and <strong>b</strong> be sequences of the base type of lengths <strong>m</strong> and <strong>n</strong>, respectively. The lexicographic order a ¡Ü b is:</p>

<ul>
<li>a &lt; b where a<sub>i</sub> R b<sub>i</sub> and a<sub>j</sub>=m<sub>j</sub> for all 0 ¡Ü j &lt; i</li>
<li>a &lt; b if a is a prefix of b</li>
<li>a=b if m=n and a<sub>i</sub>=b<sub>i</sub> for all 0 ¡Ü i &lt; m</li>
</ul>

<p>Where ""a is a prefix of b"" means m &lt; n and a<sub>i</sub> = b<sub>i</sub> for all 0 ¡Ü i &lt; m.</p>

<p>The advantage of this approach is you can write a comparison function that will work with any <a href=""http://c2.com/cgi/wiki?HomogenousContainer"" rel=""nofollow noreferrer"">homogeneous</a> sequence type: strings, lists of strings, arrays of integers, what-have-you. If you specialize the comparison function for null-terminated strings, you don't need to worry about the cases for prefixes; simply have '\0' be the least character in the collation.</p>

<p>From a general comparison function (called, say, <code>lexiCompare</code>), you can define </p>

<pre><code>lexicCompareString (a, b):
    return lexicCompare(a, b, chrcmp)
</code></pre>

<p>and set a String's <code>compareTo</code> member to <code>lexicCompareString</code>.</p>
",0
2535115,2534993,1,"<p>Try comparing the following pairs of strings:</p>

<p>""ABC"" vs ""DEF""</p>

<p>""ADF"" vs ""BBB""</p>

<p>""ABC"" vs ""CBA""</p>

<p>What results do you get? More importantly, why? How do these results compare to what you want to get?</p>

<p>(You should first work it out in your head. Work out the values of c1 and c2 for each step of the comparison loop.)</p>
",2
2914551,2914486,1,"<p>You cannot be sure in ANSI C that the underlying system provides accuracy in milliseconds. However to achieve maximum detail you can use the <code>clock()</code> function which returns the time since process startup in ticks where the duration of a tick is defined by <code>CLOCKS_PER_SEC</code>:</p>

<pre><code>#include &lt;time.h&gt;

double elapsed; // in milliseconds
clock_t start, end;

start = clock();

/* do some work */

end = clock();
elapsed = ((double) (end - start) * 1000) / CLOCKS_PER_SEC;
</code></pre>

<p>From GNU's <a href=""http://www.cs.utah.edu/dept/old/texinfo/glibc-manual-0.02/library_19.html#SEC310"" rel=""nofollow noreferrer"">documentation</a>.</p>
",2
2914610,2914486,0,"<p>The ANSI C clock() will give you <strong>precision</strong> of milliseconds, but not the accuracy, since that is dependent on window's system clock, which has accuracy to 50msec or somewhere around that range.  If you need something a little better, then you can use Windows API <a href=""http://msdn.microsoft.com/en-us/library/ms644904%28VS.85%29.aspx"" rel=""nofollow noreferrer"">QueryPerformanceCounter</a>, which has its own caveats as well.</p>
",0
2914621,2914486,2,"<p>You can't do it with portable code prior to C11.</p>
<p>Starting with C11, you can use <code>timespec_get</code>, which will <em>often</em> (but doesn't necessarily) provide a resolution of milliseconds or better. Starting from C23, you can call <code>timespec_getres</code> to find out the resolution provided.</p>
<p>Since you're using Windows, you need to start out aware that Windows isn't a real-time system, so nothing you do is really guaranteed to be accurate. That said, you can start with <code>timeBeginPeriod(1);</code> to set the multimedia timer resolution to 1 millisecond. You can then call <code>timeGetTime()</code> to retrieve the current time with 1 ms resolution. When you're done doing timing, you call <code>timeEndPeriod(1)</code> to set the timer resolution back to the default.</p>
",0
8380354,8380348,3,"<p>You can't; you'll need to use something like <code>memset</code> if the values are all the same (and each element is a byte big), or a simple for-loop if they're not a byte big and if the numbers can be calculated. If the values cannot be calculated at runtime, you'll need to do each one by hand like <code>a[x] = y;</code>.</p>

<p>The reason they are called ""initialiser lists"" is because they can be used to <em>initialise</em> something, and initialisation by definition only happens once.</p>
",0
8380361,8380348,1,"<p>You cannot do that. An array can only be <em>initialized</em> from a brace expression in a declarator-initializer. You assign arrays.</p>

<p>In C89 there wasn't even such a thing as a ""temporary array"", though as of C99 these exist by virtue of <a href=""http://drdobbs.com/184401404"" rel=""nofollow"">compound literals</a> (see @Dave's answer).</p>
",1
8380374,8380348,14,"<p>If your c compiler supports compound literals, you can use <code>memcpy</code>:</p>

<pre><code>memcpy(a, (int[]){3, 2, 1}, sizeof a);
</code></pre>

<p>If you don't plan to stick any variables in there (you can; isn't C99 amazing?), <code>(int[])</code> can be replaced by <code>(const int[])</code> to put the literal into static memory.</p>
",4
8380956,8380348,1,"<p>Here's a non-portable way of doing it that, strictly speaking, can also involve undefined behavior:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  int a[3] = { 1, 2, 3 };
  printf(""%d,%d,%d\n"", a[0], a[1], a[2]);
  // assuming ints are 4-bytes-long, bytes are 8-bit-long and
  // the byte order in ints is from LSB to MSB (little-endian):
  memcpy(a, ""\x03\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00"", sizeof(a));
  printf(""%d,%d,%d\n"", a[0], a[1], a[2]);
  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>1,2,3
3,2,1
</code></pre>
",1
8381699,8380348,4,"<p>compound literal is part of ANSI C (C99). Since it is part of the language, any compiler claiming to be conforming to C99 must support this:</p>

<p>memcpy(a, (int[]){3, 2, 1}, sizeof a);</p>

<p>gcc can be invoked as ""gcc -Wall -W -std=c99 -pedantic"" to specify the standard.</p>

<p>Since it is more than 11 years since C99, I think it's safe and probably a good idea to start using the new capabilities the language provides.</p>

<p>compound literals are discussed in section 6.5.2.5 of <a href=""http://people.freebsd.org/~green/c9x-draft.txt"" rel=""nofollow"">n869.txt</a></p>
",0
2590318,2590314,0,"<p>One reason: if you use <code>sort</code> to sort an array of structs, and you have a comparison function for the two structs, you'll need to cast the void pointers to pointers to the structs to access members of the struct.</p>
",0
2590322,2590314,13,"<p>You can cast a <code>void*</code> to another pointer in <em>both</em> languages. Perhaps you meant implicitly.</p>

<p>It's very convenient in C to not have to be explicit about it. In C++ we have templates, so to write generic code there's no need for <code>void*</code> casting and whatnot. In C there is no choice. A generic container has to hold <code>void*</code> to objects, and it's much easier to repeatedly say <code>mydata* d = node;</code> then it is <code>mydata* d = (mydata*)node;</code>.</p>

<p>So it's pretty much like you said. In C type safety in general didn't receive as much emphasis as it did in C++, especially when it came to <code>void*</code> because it was suppose to be a simple generic pointer to whatever. There's no need for that in C++, so better make it explicit when you're dealing with it.</p>
",0
2590544,2590314,1,"<blockquote>
  <p>What are the possible reasons for [casting a <code>void *</code> pointer in C]?  Isn't this a giant hole in type safety?</p>
</blockquote>

<p>It's the only possible way to support polymorphism, aka generic programming.  There's no other way to make, e.g., a generic hash table.  Polymorphism in C is wildly unsafe, but it's the only polymorphism there is.</p>

<p>Be glad that C++ has parametric polymorphism (one of the many functions of templates).</p>
",0
2028477,2028457,8,"<p>You're printing the value of the pointer <code>raw_buf</code>, not the memory at that location:</p>

<pre><code>sprintf(str_buf,""0x%x"",raw_buf[0]);
</code></pre>

<p>As Andreas said, <code>str_buf</code> is also not big enough.  But: no need for a second buffer, you could just call <code>printf</code> directly.</p>

<pre><code>printf(""0x%x"",raw_buf[0]);
</code></pre>
",1
2028480,2028457,2,"<p><code>str_buf</code> has a maximum size of 1 (<code>char str_buf[1];</code>), it should at least 5 bytes long (4 for XxXX plus the \0).</p>

<p>Moreover, change</p>

<pre><code>sprintf(str_buf,""0x%x"",raw_buf);
</code></pre>

<p>to</p>

<pre><code>sprintf(str_buf,""0x%x"",*raw_buf);
</code></pre>

<p>otherwise you'll print the address of the <code>raw_buf</code> pointer, instead of its value (that you obtain by <em>dereferencing</em> the pointer).</p>

<p>Finally, make sure both raw_buf is <code>unsigned</code>. The standard specified that the signness of chars (where not explicitly specified) is implementation defined, ie, every implementation decides whether they should be signed or not. In practice, on most implementations they are signed by default unless you're compiling with a particular flag. When dealing with bytes always make sure they are unsigned; otherwise you'll get surprising results should you want to convert them to integers.</p>
",0
2028529,2028457,5,"<p>I think that you are overcomplicating things and using non-portable constructs where they aren't really necessary.</p>

<p>You should be able to just do:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv)
{
    if (argc &lt; 2)
        return 1; /* TODO: better error handling */

    FILE* f = fopen(argv[1], ""rb"");

    /* TODO: check f is not NULL */

    /* Read one byte */    
    int first = fgetc(f);

    if (first != EOF)
        printf(""first byte = %x\n"", (unsigned)first);

    /* TODO else read failed, empty file?? */

    fclose(f);

    return 0;
}
</code></pre>
",0
2028582,2028457,5,"<p>Less is more...</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[]) {
    int fd;
    unsigned char c;

    /* needs error checking */
    fd = open(argv[1], O_RDONLY);
    read(fd, &amp;c, sizeof(c));
    close(fd);

    printf(""&lt;0x%x&gt;\n"", c);
    return 0;
}
</code></pre>

<ol>
<li><code>seek</code>ing is not needed </li>
<li>if you want to read a byte use an <code>unsigned char</code></li>
<li><code>printf</code> will do the format</li>
</ol>
",1
2921353,2921316,2,"<p>It's certainly a questionable construct.  A design that depends on this behavior is probably a poor design.</p>

<p>You've tagged this as C++, but C++ (intelligently, IMO) <em>doesn't</em> allow you to jump inside a loop where a variable was declared in the first part of the for statement:</p>

<pre><code>int main()
{
    int q = 5;

    goto inner;

    for (int i = 0; i &lt; 4; i++)
    {
        q *= 2;
inner:
        q++;
        std::cout &lt;&lt; q &lt;&lt; std::endl;
    }    
}
</code></pre>

<p>g++ output:</p>

<pre>
l.cpp: In function ¡®int main()¡¯:
l.cpp:12: error: jump to label ¡®inner¡¯
l.cpp:7: error:   from here
l.cpp:9: error:   crosses initialization of ¡®int i¡¯
</pre>

<p>Initializing <code>i</code> <em>before</em> the loop allows the program to compile fine (as would be expected).</p>

<p>Oddly, compiling this with <code>gcc -std=c99</code> (and using <code>printf</code> instead) <em>doesn't</em> give an error, and on my computer, the output is:</p>

<pre>
6
13
27
55
</pre>

<p>as would be expected if <code>i</code> were initialized <em>outside</em> the loop.  This might lead one to believe that <code>int i = 0</code> might be simply ""pulled out"" of the loop initializer during compilation, but <code>i</code> is still out of scope if tried to use outside of the loop.</p>
",5
2921409,2921316,2,"<p>If you've ever coded in Assembler (ASM), then you'll know that GOTOs are pretty standard, and required, actually. The C Language was designed to be very close to ASM without actually being ASM. As such, I imagine that ""GOTO"" was kept for this reason.</p>

<p>Though, I'll admit that GOTOs are generally a ""bad idea, mmmkay?"" in terms of program flow control in C and any other higher level language.</p>
",3
2921461,2921316,0,"<p>From <a href=""http://en.wikipedia.org/wiki/Duff%27s_device"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Duff%27s_device</a></p>

<blockquote>
  <p>In computer science, Duff's device is an optimized  implementation of a serial copy that uses a technique widely applied in assembly language for loop unwinding.</p>
</blockquote>

<p>...</p>

<blockquote>
  <p><strong>Reason it works</strong>
  <br />The ability to legally jump into the middle of a loop in C.</p>
</blockquote>
",0
2608382,2608348,2,"<p>Because pointer arithmetic works in units of the type pointed to. For example:</p>

<pre><code>int* p_num = malloc(10 * sizeof(int)); 
int* p_num2 = p_num + 5;
</code></pre>

<p>Here, <code>p_num2</code> does not point five <em>bytes</em> beyond <code>p_num</code>, it points five <em>integers</em> beyond <code>p_num</code>. If on your machine an integer is four bytes wide, the address stored in <code>p_num2</code> will be twenty bytes beyond that stored in <code>p_num</code>. The reason for this is mainly so that pointers can be indexed like arrays. <code>p_num[5]</code> is exactly equivalent to <code>*(p_num + 5)</code>, so it wouldn't make sense for pointer arithmetic to always work in bytes, otherwise <code>p_num[5]</code> would give you some data that started in the middle of the second integer, rather than giving you the sixth integer as you would expect.</p>

<p>In order to move a specific number of <em>bytes</em> beyond a pointer, you need to cast the pointer to point to a type that is guaranteed to be exactly 1 byte wide (a <code>char</code>).</p>

<p>Also, you have an error here:</p>

<pre><code>printf(""\nSIZE : [%d]\nSIZE : [%d]\n"", size);
</code></pre>

<p>You have two format specifiers but only one argument after the format string.</p>
",0
2608384,2608348,2,"<p><strong>If I don't use the char* pointer, the output is 1 - WHY?</strong><br>
Because <code>operator-</code> obeys the same pointer arithmetic rules that <code>operator+</code> does. You incremented the <code>sizeof(MyStruct)</code> when you added one to the pointer, but without the cast you are dividing the byte difference by <code>sizeof(MyStruct)</code> in the <code>operator-</code> for pointers.</p>

<p>Why not use the built in <code>sizeof()</code> operator?</p>
",1
2608385,2608348,2,"<p>Because you want the size of your struct in bytes. And pointer arithmetics implicitly uses type sizes.</p>

<pre><code>int* p;
p + 5; // this is implicitly p + 5 * sizeof(int)
</code></pre>

<p>By casting to char* you circumvent this behavior.</p>
",2
2608390,2608348,1,"<p>Pointer arithmetic is defined in terms of the size of the type of the pointer. This is what allows (for example) the equivalence between pointer arithmetic and array subscripting -- <code>*(ptr+n)</code> is equivalent to <code>ptr[n]</code>. When you subtract two pointers, you get the difference as the number of items they're pointing at. The cast to <code>pointer to char</code> means that it tells you the number of chars between those addresses. Since C makes <code>char</code> and <code>byte</code> essentially equivalent (i.e. a byte is the storage necessary for one char) that's also the number of bytes occupied by the first item.</p>
",0
2287143,2287122,1,"<p>If you are using gcc, add the <code>-Werror</code> flag.</p>
",3
2287184,2287122,2,"<p>If using gcc, I think the option combination you need is <code>-fstrict-aliasing -Wstrict-aliasing=3 -Werror=strict-aliasing</code>. See <a href=""http://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Warning-Options.html#index-Wno_002dstrict_002daliasing-316"" rel=""nofollow noreferrer"">this text</a> for documentation of the <code>strict-aliasing</code> option.</p>
",1
4235502,4235480,4,"<p>If they're at the end, truncate the file at the appropriate length. If they're not then you'll need to rewrite the file.</p>
",1
4235505,4235480,1,"<p>Your way is pretty inefficient for large files, since you would have to copy ""the rest of the file"" some bytes further to the beginning, which costs much. I would rather record the ""current sending position"" somewhere outside of the file and update that information. That way, you don't have to copy the rest of the file so often.</p>
",13
4235507,4235480,1,"<p>There is no straightforward way to delete bytes from the beginning of a file.  You will have to start from where you want to trim the file, and read from there to the end of the file, writing to the start of the file.</p>

<p>It might make more sense to just track how many bytes you have already written to the file in some other file.</p>
",0
4235511,4235480,1,"<p>you should use an index which points to the beginning of the data you haven't sent yet.
It is not necessary to delete what you have sent, just pass them, when you send the whole file delete it.</p>
",0
4236862,4235480,0,"<p>If the char's are one after the other than why dont you give a try to <strong>fseek();</strong></p>
",0
3480917,3480882,0,"<p>The function is getting a 'raw' buffer of data, and the line:</p>

<pre><code>usbRequest_t    *rq = (void *)data;
</code></pre>

<p>is just creating a pointer to that buffer to access it using the data layout specified by the <code>usbRequest_t</code> struct.</p>

<p>There's absolutely nothing expensive about this operation - the compiler will likely not even actually create a new pointer variable in an optimized build.</p>

<p>On there other hand, there may well be portability concerns, but that might not be important for your particular application.</p>
",0
3480919,3480882,0,"<p>Question 1: Since <code>data</code> is <code>uchar *</code>, you need to cast it to another type.  You could cast it directly to <code>usbRequest_t *</code> if you wanted to.</p>

<p>Question 2: The address of <code>rq-&gt;bRequest</code> takes as much time to calculate as the address of <code>data[2]</code>.  In both cases, you take a pointer off of the stack and add a fixed offset to it.  Using the struct pointer results in clearer code.</p>
",0
3480920,3480882,0,"<p>your first line (<em>rq = (void</em>) ..) is telling the compiler to treat the 8 bytes passed as a usbRequest_t</p>

<p>presumably this is a packet from a device or network and the code wants to look at it as though it matched the structure</p>

<p>yes it creates a pointer - but what will almost certainly happen in the generated code is that the address of the first byte is simply loaded into a register. So there is no overhead</p>

<p>conversely your suggestion of rq->bRequest == something will actually copy the data - which is a (v small for 8 bytes) overhead</p>

<p>This is a very common technique for mapping structs onto serialized data streams</p>
",0
3480934,3480882,0,"<p>Regarding your claim that the code is inefficient, I see little or no difference between accessing <code>data[x]</code> and <code>rq-&gt;x</code>.  In both cases, the code starts with a base-address, and offsets a few bytes (apparently to a maximum of 8 bytes).  </p>

<p><code>[Base Address] + [Offset]</code> is going to be the same, regardless of if you do it by array or by structure.  And if simple additions are the source of inefficiency in your program, you have much bigger problems.</p>
",0
2629509,2629455,1,"<p>Are you actually looking for the implementation of C in the standard library?
Each compiler and OS typically comes with their own implementation (just the headers are relatively standard).</p>

<p>You can see instructions on downloading the sources for GNU C here:
<a href=""http://www.gnu.org/software/libc/resources.html"" rel=""nofollow noreferrer"">http://www.gnu.org/software/libc/resources.html</a></p>
",0
2629474,2629455,6,"<p><code>time.h</code> is a header from the C standard library.</p>

<p>You will find implementations of the various functions this header provides in the c library implementation of your system.
For instance, the implementation for the <code>difftime</code> function in the <code>libc</code> used for <a href=""http://www.netbsd.org"" rel=""noreferrer"">NetBSD</a> can be found in <a href=""http://nxr.netbsd.org/xref/src/lib/libc/time/difftime.c"" rel=""noreferrer"">src/lib/libc/time/difftime.c</a>.</p>
",0
2629476,2629455,0,"<p><code>time.h</code> is a C standard header, so it describes functions from the C standard library with which it came. For instance, GNU <code>libc</code></p>
",0
2629486,2629455,1,"<p>You can find an implementation in the GNU libc library. There isn't a single time.c file. Each function (to a first approximation) lives in its own compilation unit.</p>
",0
2629490,2629455,4,"<p>For GNU libc, see <a href=""http://sourceware.org/git/?p=glibc.git;a=tree;f=time;h=c950c5d4dd90541e8f3c7e1649fcde4aead989bb;hb=master"" rel=""nofollow noreferrer"">http://sourceware.org/git/?p=glibc.git;a=tree;f=time;h=c950c5d4dd90541e8f3c7e1649fcde4aead989bb;hb=master</a></p>
",0
3481772,3481765,9,"<p>You need this in the top of hud.c, and any other .c file you use them from:</p>

<pre><code>extern struct TextSize tsize;
extern char buff[50];
</code></pre>

<p>The <code>extern</code> keyword tells the compiler that the ""actual"" variables already exist, in some other unit (file), and the linker will fix it all up for you in the end.</p>

<p>If you're doing this on a large scale in a project, consider how you might encapsulate globals in one place, and create a shared .h file that declares these things as ""extern"" for all the places that you use them from.</p>
",5
3482336,3481765,2,"<p>use ""extern char buff[50];"" in the files where you have not initialized the buff and want to use it. This tells that the declaration is done in other files and you are using it in this file.</p>
",0
2127038,2127012,4,"<p>Look at libcurl especially <a href=""http://curl.haxx.se/libcurl/c/httpput.html"" rel=""nofollow noreferrer"">the example for http put</a></p>

<p>Or <a href=""http://www.webdav.org/neon/"" rel=""nofollow noreferrer"">libneon</a>. PUT is in <a href=""http://svn.webdav.org/repos/projects/neon/trunk/src/ne_basic.c"" rel=""nofollow noreferrer"">ne_basic.c</a>.</p>
",0
3910343,3910279,6,"<p>If I understood correctly, you want to have all processes reading lines from a single file. I don't recommend this, it's kinda messy, and you'll have to a) read the same parts of the file several times or b) use locking/mutex or some other mechanism to avoid that. It'll get complicated and hard to debug.</p>

<p>I'd have a master process read the file, and assign lines to a subprocess pool. You can use shared memory to speed this up, and reduce the need for data-copying IPC; or use threads.</p>

<p>As for examples, I answered a question about forking and IPC and gave a code snippet on an example function that forks and returns a pair of pipes for parent-child communication. Let me look that up (...) here it is =P <a href=""https://stackoverflow.com/questions/3884103/can-popen-make-bidirectional-pipes-like-pipe-fork/3884402#3884402"">Can popen() make bidirectional pipes like pipe() + fork()?</a></p>

<p><strong>edit</strong>: I kept thinking about this =P. Here's an idea:</p>

<ul>
<li><p>Have a master process spawn subprocesses with something similar to what I showed in the link above.</p></li>
<li><p>Each process starts by sending a byte up to the master to signal it's ready, and blocking on <code>read()</code>.</p></li>
<li><p>Have the master process read a line from the file to a shared memory buffer, and block on <code>select()</code> on its children pipes.</p></li>
<li><p>When <code>select()</code> returns, read one of the bytes that signal readiness and send to that subprocess the offset of the line in the shared memory space.</p></li>
<li><p>The master process repeats (reads a line, blocks on select, reads a byte to consume the readiness event, etc.)</p></li>
<li><p>The children process the line in whatever way you need, then send a byte to the master to signal readiness once again.</p></li>
</ul>

<p>(You can avoid the shared memory buffer if you want, and send the lines down the pipes, though it'll involve constant data-copying. If the processing of each line is computationally expensive, it won't really make a difference; but if the lines require little processing, it may slow you down).</p>

<p>I hope this helps!</p>

<p><strong>edit 2 based on Newba's comments:</strong></p>

<p>Okay, so no shared memory. Use the above model, only instead of sending down the pipe the offset of the line read in the shared memory space, send the whole line. This may sound to you like you're wasting time when you could just read it from the file, but trust me, you're not. Pipes are orders of magnitude faster than reads from regular files in a hard disk, and if you wanted subprocesses to read directly from the file, you'll run into the problem I pointed at the start of the answer.</p>

<p>So, master process:</p>

<ul>
<li><p>Spawn subprocesses using something like the function I wrote (link above) that creates pipes for bidirectional communication.</p></li>
<li><p>Read a line from the file into a buffer (private, local, no shared memory whatsoever).</p></li>
<li><p>You now have data ready to be processed. Call select() to block on all the pipes that communicate you with your subprocesses.</p></li>
<li><p>Choose any of the pipes that have data available, read one byte from it, and then send the line you have waiting to be processed in the buffer down the corresponding pipe (remember, we had 2 per child process, on to go up, one to go down).</p></li>
<li><p>Repeat from step 2, i.e. read another line.</p></li>
</ul>

<p>Child processes:</p>

<ul>
<li><p>When they start, they have a reading pipe and a writing pipe at their disposal. Send a byte down your writing pipe to signal the master process you are ready and waiting for data to process (this is the single byte we read in step 4 above).</p></li>
<li><p>Block on <code>read()</code>, waiting for the master process (that knows you are ready because of step 1) to send you data to process. Keep reading until you reach a newline (you said you were reading lines, right?). Note I'm following your model, sending a single line to each process at a time, you could send multiple lines if you wanted.</p></li>
<li><p>Process the data.</p></li>
<li><p>Return to step 1, i.e. send another byte to signal you are ready for more data.</p></li>
</ul>

<p>There you go, simple protocol to assign tasks to as many subprocesses as you want. It may be interesting to run a test with 1 child, n children (where n is the number of cores in your computer) and more than n children, and compare performances.</p>

<p>Whew, that was a long answer. I really hope I helped xD</p>
",6
3910491,3910279,0,"<p>Since each of the processes is going to have to read the file in its entirety (unless the log lines are all of the same length, which is unusual), there really isn't a benefit to your proposal 2.</p>

<p>If you are going to split up the work into 3, then I would do:</p>

<ul>
<li>Measure (stat()) the size of the log file - call it N bytes.</li>
<li>Allocate the range of bytes 0..(N/3) to first child.</li>
<li>Allocate the range of bytes (N/3)+1..2(N/3) to the second child.</li>
<li>Allocate the range of bytes 2(N/3)+1..end to the third child.</li>
<li>Define that the second and third children must synchronize by reading forward to the first line break after their start position.</li>
<li>Define that each child is responsible for reading to the first line break on or after the end of their range.</li>
<li>Note that the third child (last child) may have to do more work if the log file is growing.</li>
</ul>

<p>Then the processes are reading independent segments of the file.</p>

<p>(Of course, with them all sharing the file, then the system buffer pool saves rereading the disk, but the data is still copied to each of the three processes, only to have each process throw away 2/3 of what was copied as someone else's job.)</p>

<hr>

<p>Another, more radical option:</p>

<ul>
<li>mmap() the log file into memory.</li>
<li>Assign the children to different segments of the file along the lines described previously.</li>
</ul>

<p>If you're on a 64-bit machine, this works pretty well.  If your log files are not too massive (say 1 GB or less), you can do it on a 32-bit machine too.  As the file size grows above 1 GB or so, you may start running into memory mapping and allocation issues, though you might well get away with it until you reach a size somewhat less than 4 GB (on a 32-bit machine).  The other issue here is with growing log files.  AFAIK, mmap() doesn't map extra memory as extra data is written to the file.</p>
",0
3910569,3910279,0,"<p>Use a master and slave queue pattern.</p>

<ul>
<li>The master sets up the slaves which sit waiting on a queue for work items.  </li>
<li>The master then reads the file line by line.
<ul>
<li>Each line then represents a work item that you put on the queue<br>
with a function pointer of how do the work.</li>
<li>One of the <strong>waiting</strong> slaves then takes the item of the queue</li>
<li>A slave processes a work item.</li>
<li>When a slave has finished it rejoins the work queue.</li>
</ul></li>
</ul>
",0
2437563,1838196,2,"<p>Cheating, but follows your rules...</p>

<pre><code>int mystrlen( char *s)
{
    return strchr( s, '\0') - s;
}
</code></pre>
",0
3049656,3049396,0,"<p>Also, please check the return value of <code>malloc()</code> calls. As well, please do not cast the return value of <code>malloc()</code> in the C programming language.</p>
",0
3049407,3049396,5,"<p>Try <code>scanf(""%d"", &amp;(nextnode-&gt;value));</code></p>
",0
3049412,3049396,0,"<p>It should be the address of the value:
<code>scanf(""%d"", &amp;(nextnode-&gt;value));</code></p>

<p>Generally speaking, as a comment on your code, avoid to repeat the code known as copy-paste antipattern. Re-use it at maximum. Usually if you find yourself in the situation to repeat code, create a small function.</p>
",0
3049427,3049396,2,"<pre><code>    scanf(""%d"", nextnode-&gt;value);
</code></pre>

<p>You need to pass a pointer to the value member to keep scanf() happy.  Fix:</p>

<pre><code>    scanf(""%d"", &amp;nextnode-&gt;value);
</code></pre>

<p>Perhaps one lesson to learn from this is to <em>never</em> mix up data entry code with data structure modification code.</p>

<p>Btw: please don't use unnecessary parentheses.  You'll never learn the precedence rules if you do.</p>
",0
3049442,3049396,1,"<p>First, you have a bug.</p>

<p>One of the lines should be:</p>

<p><code>scanf(""%d"", &amp;(nextnode-&gt;value));</code></p>

<p>And sorry to say this, but your code is horrible!</p>

<ul>
<li><p>Use a better name than <code>entrynode</code>. If it is a linked list, why don't you just call it that?</p></li>
<li><p>I suggest you implement a method of the following signature:</p>

<p>bool addnode(struct entrynode *entry, int value);</p></li>
<li><p>The return value lets you know if the addition was successful.</p></li>
<li><p>You have a lot of code duplication. Try to remove that.</p></li>
<li><p>Use the above method <em>after</em> making a call to printf and scanf.</p></li>
</ul>

<p>It makes me shudder to see printf and scanf littered within data structure insert methods and redundant copies of code littered in if then elses.</p>
",1
2914300,2914292,7,"<p>You are overindexing revBuffer.  It is size 5, which means you can index it from 0 to 4, but the first index you use in it in your loop is 5.</p>
",1
2914313,2914292,6,"<p>The number you are converting has six digits - the buffer you are using is only big enough to hold 4 plus a null terminator. Make the buffer bigger.</p>
",0
2914328,2914292,2,"<p>While your excercise is helpful you should keep in mind that there also is:</p>

<pre><code>std::reverse(buffer, buffer + 5);
</code></pre>
",0
2914344,2914292,0,"<p>For a start, you're trying to use a buffer that's 5 characters long to store a 6 digit number.</p>
",0
2914359,2914292,2,"<p>In addition to what others have said, It doesn't appear that a null terminator will be placed in the last character of revBuffer even after you fix all your indexing issues. You will need to be sure to do </p>

<pre><code>revBuffer[strlen(buffer)] = '\0';
</code></pre>

<p>This is also frought with problems because it assumes that buffer is properly terminated :)</p>
",0
3852383,3851029,0,"<p>Firstly, as all the others have said, there is no portable way to know the size in allocation unless you keep this information.</p>

<p>All that matters is the implementation of the standard C library. Most libraries only keep the size of memory allocated to a pointer, which is usually larger than the size your program requests. Letting the library keep the requested size is a bad idea because this costs extra memory and at times we do not care about the requested size.</p>

<p>Strictly speaking, recording the requested size is NOT a feature of a compiler. It seems to be sometimes because a compiler may reimplement part of the standard library and override the system default. However, I would not use a library recording requested size because it is likely to have bigger memory footprint due to the reason I said above.</p>
",0
2658914,2658674,1,"<p>In child block, you don't need to close fds 1,2,and 3. dup2() will close oldfd if necessary.</p>

<p>In parent block, you shouldn't be closing the pipe fds before reading and writing to them!</p>

<p>For multiple pipes, use non-blocking IO or select()</p>
",1
2658937,2658674,1,"<p>Your code looks a bit off.  Specifically here:</p>

<pre><code>    do {
        read(newSock, linha, 1024);
        /* Escreve o buffer no pipe */
        write(input[1], linha, strlen(linha));
        close(input[1]);
        while ((d = read(output[0], buffer, 255))) {
            //buffer[d] = '\0';
            write(newSock, buffer, strlen(buffer));
            puts(buffer);
        }
        write(newSock, ""END"", 4);

    } while (strcmp(linha, ""quit"") != 0);
</code></pre>

<p>You close <code>input[1]</code> after the first iteration of the outside do/while loop but need that descriptor for each iteration.</p>

<p>Also, if the inner while loop, you will keep reading until you get EOF.  But since the program is still open, you won't get EOF until the program ends.  So you need to find some other way to know that the program has given you back all your input.</p>
",1
3076868,3076799,0,"<p>If you actually want to change a character between uppercase and lowercase, you should not do it this way.  Use <a href=""http://www.cplusplus.com/reference/clibrary/cctype/toupper/"" rel=""nofollow noreferrer"">toupper()</a>/<a href=""http://www.cplusplus.com/reference/clibrary/cctype/tolower/"" rel=""nofollow noreferrer"">tolower()</a> instead.  By using those routines your intent is much more clear, and any locale specific differences on what is an upper/lowercase character are taken into account.</p>
",0
3076816,3076799,2,"<p>The U means that '1' is an unsigned int, as opposed to a potentially signed int.</p>

<p>See <a href=""http://icecube.wisc.edu/~dglo/c_class/constants.html"" rel=""nofollow noreferrer"">here</a>.</p>

<p>As to the other problem; I'd speculate that the - in CLR_FLAG is causing the problem; try using a '~' (bit-wise not). Have not tested this though.</p>
",0
3076826,3076799,2,"<p>The problem is in this line:</p>

<pre><code>#define CLR_FLAG(N, F) ( (N) &amp;= -(F) )
</code></pre>

<p>The <code>CLR_FLAG</code> macro does a bitwise-and of <code>N</code> and <code>-F</code>.  That is, <code>N</code> and minus-<code>F</code>.  What you really want to do is use the bitwise one's complement of <code>F</code>:</p>

<pre><code>#define CLR_FLAG(N, F) ( (N) &amp;= ~(F) )
</code></pre>

<p>Note that now I use <code>~F</code>.  The <code>~</code> operator performs bitwise <code>not</code>.</p>
",0
6281645,6281560,4,"<p>You handle it just like the <code>struct</code>, by giving it a name and using a pointer for the <code>typedef</code>:</p>

<pre><code>typedef union intconverter *IntConverter;
</code></pre>

<p>The traditional term for things like your <code>ChannelOBJ</code> and <code>IntConverter</code> is <em>opaque handle</em>.  Opaque handles are not exactly object-oriented (since you will not have inheritance, virtual functions, etc.), but they are a good way of separating interface from implementation (i.e. providing encapsulation).</p>
",1
3415267,3413925,2,"<p>My choice would be to use the same model as <a href=""http://en.wikipedia.org/wiki/Fread"" rel=""nofollow noreferrer"">fread()</a> and turn the interface into a stream of sorts.</p>

<p>i.e. </p>

<ul>
<li>either fill the buffer up or put all the items in it and return the number of items actually read</li>
<li>maintain some sort of state so that subsequent calls only get unread items</li>
<li>return 0 once all the items have been read</li>
<li>return a negative number if an error occurs.</li>
</ul>
",0
3418682,3413925,2,"<p>Ok, your basic requirement is to Query a resource, and cache the returned data in memory, to avoid multiple accesses.</p>

<p>That means you will have to allocate memory within your program to store all of the data.</p>

<p>Problem #1 is to populate that cache. I will assume that you have that figured out, and there is some function get_resource();</p>

<p>problem #2 is how to design an api to allow client/user code to interact with that data.</p>

<p>In your example you you are using an array allocated by the client, as the cache, hoping to solve both problems with 1 buffer, but this doesn't solve the problem in all cases ( hence your posting ). So you really need to separate the 2 problems.</p>

<p>Model number #1 is to provide iterator / cursor functionality</p>

<pre><code>iterator = get_something();  // Triggers caching of data from Resource
data = get_next_single_something( iterator );
status = release_something( iterator );

// The logic to release the data could be done automagically in get_next, 
// after returning the last single_something, if that is always the use case.
</code></pre>

<p>Model #2 is to return the Whole object in a malloced buffer, and let the client manage the whole thing</p>

<pre><code>data_type *pData=NULL;
unsigned size = get_something( &amp;pData ); // Triggers caching of data from Resource
process( size, pData );
free( pData );
pData=NULL;
</code></pre>

<p>Model #3. If you are married to the client array, you can use Model #1 to return multiple values at once, <strong><em>but</em></strong> if there are more values, then get_something() will have to build a cache, and the client will still have to iterate.</p>
",2
3413938,3413925,0,"<p>Can you do a check on how many elements the resource has? If so I'd do that then copy the array to an array as large as the resource.</p>

<p>or perhaps copying the array to an array double its size when you're reaching near the end?</p>

<p><a href=""http://www.devx.com/tips/Tip/13291"" rel=""nofollow noreferrer"">http://www.devx.com/tips/Tip/13291</a></p>
",1
3413943,3413925,5,"<p>One option is to not modify the array at all and instead return the needed size as the return result. The caller must then call your function again with an array of at least this size.</p>
",4
3413963,3413925,0,"<p>That depends on how your program should handle that situation, I guess.</p>

<p>One approach could be to fill the array to it's maximum, and return the <em>total</em> number of elements which are available. That way the caller could check if he needs to call the function again (see Mark Byers answer).</p>

<p>Logic behind that:</p>

<pre><code>- Creates array with 100 items
- Calls your function and gets 150 returned
- Increases the array size or creates a second one
  and calls your function again with that array
- Repeats that unless the returned item count is
  equal or less the array size
</code></pre>
",1
3413977,3413925,2,"<p>Use <code>realloc</code> .
<a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/realloc/"" rel=""nofollow noreferrer"">Reference link</a> .</p>
",4
3414050,3413925,1,"<p>allocate array dynamically i.e using malloc() and then, in the function, either use realloc() or free the previous list and allocate another, fill it and return the new size. For the second approach you can use the return value for returning new size but to update the callers address of array you will need to change the function to accept int** instead of int*</p>
",2
3482421,3482311,5,"<p>This is pretty much the right approach - with two tweaks.</p>

<p>Firstly, instead of <em>adding</em> a constant <code>BUFF_CHUNK_SIZE</code>, it's usually better to <em>multiply</em> it by a fixed amount.  This means that your number of reallocs on a long string of length N becomes proportional to <code>log N</code> rather than <code>N</code> - meaning that the time spent in <code>realloc()</code> is proportional to <code>N log N</code> rather than <code>N</code><sup><code>2</code></sup>.  It doesn't really matter what the constant is - 1.5 might be a good choice (<code>n += n / 2;</code>).</p>

<p>Secondly, in a longer program you should really check for <code>realloc()</code> failing.</p>
",2
3482448,3482311,0,"<p>realloc was right, but you should use a char as token-separator?!</p>

<pre><code>#define BUFF_CHUNK_SIZE 4
#define TOKSEP "";""

char *getOneToken(char *s,size_t n)
{
  int c;
  char *p=s;
  while( p-s &lt; n-1 &amp;&amp; !feof(stdin) &amp;&amp; ((c=getchar())=='\n'?c=getchar():1) )
    if( isalnum(c) )
      *p++=c;
  *p=0;
  return s;
}

main() 
{
  char *buffer=calloc(1,1),
        tok[BUFF_CHUNK_SIZE+1];

  while( *getOneToken(tok,sizeof tok) )
  {
    buffer=realloc(buffer,strlen(buffer)+strlen(tok)+2);
    if( *buffer ) strcat(buffer,TOKSEP);
    strcat(buffer,tok);
  }

  puts(buffer);
  free(buffer);
  return 0;
}
</code></pre>
",0
2124985,2124957,2,"<p>I assume you want to store it in the memory, then you can use a combination of struct and array.</p>

<p>Something like will following will do:</p>

<pre><code>typedef struct {
    int number;
    char* name; // You can use an array instead char name[MAX_FAULT_NAME_LENGTH]
    int timestamp;
} fault_entry;

fault_entry fault_log[10];
</code></pre>

<p>Of course this is hand-waving. If you want to store it to a file, you need to serialize. You need to think about what data-type to use for date/time and name. But it should help you get started.</p>
",4
2124994,2124957,0,"<p>You should use an array of the struct type such as</p>

<pre><code>#define NAME_MAXLEN 20
struct fault {
     int number;
     time_t time;
     char name[NAME_MAXLEN];
};

struct fault faults[10];
</code></pre>

<p>];</p>
",0
2125000,2124957,0,"<p>Something along the lines of:</p>

<pre><code>typedef struct fault
{
    int number;
    char *name;
    char *date;
} fault;

fault faults[10];

faults[0].number = 1;
faults[0].name = ""Fault Number 1"";
faults[0].date = ""Today's Date"";

/*etc*/

printf(""%d\n"", faults[0].number);
printf(""%s\n"", faults[0].name);
printf(""%s\n"", faults[0].date);
</code></pre>

<p>You will need to decide what time type to use of course. Here, i've used a string.</p>
",0
2125005,2124957,2,"<p>A log usually implies some kind of more permanent storage, which might mean that it should be written to a file. If so, then a structure is not necessarily required.  It could be implemented as a function that accepts the required information and generates the other information (e.g., time/date). </p>

<p>But if it is indeed more of a temporary type of storage, then it could be stored in a simple circular array.  Keep an index of the current position in the array and write to that position.</p>

<pre><code>typedef struct {
   int faultNumber;
   char faultName[50];  // length should probably be a #define
   char faultDate[20];  // date in C could be stored in some kind of char array.
                        // or it could be something representing results of something
                        // like a time_t result.
} LOG_ENTRY;

LOG_ENTRY LOGS[10];
int iCurPos = 0;
</code></pre>

<p>Then add an entry at the current position and increment iCurPos and loop it back to 0 when it hits the end.</p>
",0
2386270,2386222,1,"<p>for windows there is a tool called cacls, but it behaves differently than chmod, so you would better to read docs: <a href=""http://technet.microsoft.com/en-us/library/bb490872.aspx"" rel=""nofollow noreferrer"">http://technet.microsoft.com/en-us/library/bb490872.aspx</a></p>
",0
2386283,2386222,1,"<p>The Win32 API has a function named <code>SetFileAttributes</code> for managing file attributes, among them permissions. </p>

<p>Here's an <a href=""http://msdn.microsoft.com/en-us/library/aa365522%28VS.85%29.aspx"" rel=""nofollow noreferrer"">example from MSDN</a>.</p>
",1
2386344,2386222,1,"<p>The security model in Windows NT-based systems is very different from the Unix one that the overwhelming majority of Linux systems use.  They work from ACLs (Access Control Lists) and can get very ornate in terms of who gets what permission where.  Further they apply to almost every (perhaps even every?) object in the Win32 API, not just files.  (This doesn't apply to the pathological FAT file systems if memory serves.)</p>

<p>I would recommend <a href=""http://www.google.com/search?hl=en&amp;q=Win32+Security+Model&amp;btnG=Search&amp;aq=f&amp;aqi=&amp;aql=&amp;oq="" rel=""nofollow noreferrer"">looking closely at how the Win32 security model works</a> before you start messing with tools like cacls (the closest to chmod you're going to find) because you can hurt your system pretty badly if you mess with permissions without understanding them.  It's a whole lot more complex than vanilla Linux.</p>
",0
5610203,5610191,5,"<p>First, compilers do care about the <code>f</code> suffix. <code>1.0</code> is a double. <code>1.0f</code> is a float. For instance:</p>

<pre><code>printf(""%.15f %.15f\n"", 0.1f, 0.1);
</code></pre>

<p>produces <code>0.100000001490116 0.100000000000000</code> (note that the second number is not the real 0.1 any more than the first, it is just closer to it).</p>

<p>This matters not only to determine what numbers can and cannot be represented but also to determine the type of the operations this constant is involved in. For instance:</p>

<pre><code>printf(""%.15f %.15f\n"", 1.0f/10.0f, 1.0/10.0);
</code></pre>

<p>produces the same output as before. What is important to notice here is that 1 and 10 are both representable exactly as <code>float</code> as well as as <code>double</code>. What we are seeing is not rounding taking place at the literal level, but the type of the operation being decided from the type of the operands.</p>

<p>Compilers are not being lenient about your examples. They are strictly applying rules that you can find in <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow"" rel=""nofollow"">the relevant standard</a>, especially sections 6.3.1.4 and 6.3.1.5.</p>
",0
5610204,5610191,1,"<p>The first one divides a float by an int, which always results in a float (as does dividing an int by a float). This float result is then converted into an int to be stored in <code>i</code>.</p>

<p>The second one takes the float that resulted from the operation, and assigns it to a float variable, preserving the floatness.</p>

<p>There are two separate issues here: How literals with or without suffixes are interpreted by the compiler, and the result of operations performed on mixed numeric types.</p>
",0
5610230,5610191,0,"<p>The type of literals is important in other contexts, for example (assuming <code>f</code> is a <code>float</code>):</p>

<pre><code>f = f + 1.0;     // Cast `f` to double, do a double-precision add, and case the result back.

f = f + 1.0f;    // Single-precision addition.
</code></pre>

<p>Note that some compilers provide a relaxed mode, where both of them will generate the same code.</p>
",0
6271034,6271028,2,"<p>Because of precedence (that's just how C works).</p>

<p><strong><a href=""http://c-faq.com/ptrs/unopprec2.html"" rel=""nofollow"">C FAQ on the * exact * subject</a></strong></p>

<blockquote>
  <p>The postfix ++ and -- operators
  essentially have higher precedence
  than the prefix unary operators.
  Therefore, *p++ is equivalent to
  *(p++);</p>
</blockquote>
",0
6271040,6271028,3,"<p>Operator precedence. The <code>++</code> operator ""binds more tightly"" than the <code>*</code> operator. </p>

<p>Here's the table, in order of precedence.
<a href=""http://isthe.com/chongo/tech/comp/c/c-precedence.html"" rel=""nofollow"">http://isthe.com/chongo/tech/comp/c/c-precedence.html</a></p>

<p>This is not compiler dependent. It will always behave this way.</p>
",0
6271041,6271028,4,"<p>It has to do with operator precedence. The <code>*</code> operator has a lower precedence than <code>++</code> so it occurs last.</p>

<p>Here's a Wikipedia chart that lists all the operators: <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence"" rel=""nofollow"">http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence</a></p>

<p>You can see in the chart that postfix <code>++</code> has a precedence of 2 while <code>*</code> dereference has a precedence of 3. (The numbers are slightly backwards, as lower numbers have higher precedence).</p>
",0
6271050,6271028,2,"<p>because of <a href=""http://www.cppreference.com/wiki/language/operator_precedence"" rel=""nofollow"">operator precedence</a></p>

<p>the postfix ++ has a higher precedence than the * operator. It's not compiler dependent.</p>

<p>*ptr += 1 will increase the value pointed to by ptr by one (or call the appropriate overloaded operator)
*ptr % 8 will calculate the remainder of the value pointed to by ptr divided by 8
*ptr / 8 will calculate the division of the value pointed to by ptr and 8</p>
",0
6271057,6271028,1,"<p>From <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence"" rel=""nofollow"">wikipedia</a>:</p>

<blockquote>
  <p>For the ISO C 1999 standard, section 6.5.6 note 71 states that the C grammar provided by the specification defines the precedence of the C operators</p>
</blockquote>

<p>This means that the operator precedence is governed by C standard.</p>
",0
6271060,6271028,1,"<p>The differences seem confusing. Is this, perhaps, compiler dependent?</p>

<p>No, the precedence of operators is defined in the c lang spec.
And and so *prt++ is always deferencing the pointer before the post-increment occurs.</p>
",0
3349727,3349677,0,"<p>See what are the things you enjoy doing in real life and try to use them in an application. For example if you like games, try to make a game or if you need an idea, remake a classic. If you like accounting, try to make an accounting application with a proper interface. If you are not passionate about the idea, then you'll probably get tired after a while and throw it away. </p>

<p>BTW, I think you're on a good path and I like the decisions you have made so far.</p>
",1
3349728,3349677,14,"<p>Here's some ideas for you to try:</p>

<ol>
<li>Store a file containing hashes of every file in your music directory, and report on changes.</li>
<li>Solve a Sudoku in the shortest possible time.</li>
<li>Send a file using TCP to another computer. (Write both server and client).</li>
<li>A program that broadcasts a list of public files (configured in a text file) over UDP, and then accepts TCP connections to download them.</li>
<li>A command line POP3 client.</li>
<li>Write a memory allocator, and hook into <code>malloc</code>.</li>
</ol>

<p>Congratulations on deciding to learn C. It is the most powerful language on Earth, and will give you the foundation you need to kick some programming butt.</p>
",0
3350365,3349677,0,"<p>Write a compiler for a subset-of-C.</p>
",0
3349873,3349677,1,"<p>The way to learn C would be to try out POSIX compliant samples from any operating system book.</p>
",0
3350662,3349677,1,"<p>My seven step guide to finding something code wise to do :)</p>

<ol>
<li>find something you like or enjoy(preferably IT related)</li>
<li>find a problem with it, or some way to improve it, else goto Step 1</li>
<li>split the problem into logical parts, these will represent functions and structures, use a piece of paper if it helps you visualize the problem(this is what I some times do)</li>
<li>devise your plan of attack, ie: how will you implement what you came up with in Step 3</li>
<li>Code, Learn, Test, Learn, Debug, Learn, Improve, Learn and Code &amp; Learn some more</li>
<li>Done, but not really, this is when you review what you've made, marvel in all its glory, and learn from all its mistakes and problems. see what parts you enjoyed, what parts you hated and what parts you can still learn more from.</li>
<li>goto Step 1, using the knowledge gained from Step 6 (and all the other steps along the way)</li>
</ol>

<p>If you run out of things to do and want to be productive in a commercial sense, see if you can talk to people who work with computers/IT systems/etc as a daily occurrence in their job and see what happens them and try develop ideas that could improve their productivity and/or the ease with which they can perform their task(s), who knows, you may end up with some extra knowledge and some extra cash </p>
",0
3351102,3349677,0,"<p>There are some Artificial Intelligence competitions that are both practical and fun. These will help you learn the language, encourage your understanding of any sample code, basic debugging and implementation of common algorithms.</p>

<p>Most importantly it's fun, so it keep will keep you motivated to keep learning.</p>

<p>For instance a few months ago I enjoyed the Google AI challenge: <a href=""http://csclub.uwaterloo.ca/contest/"" rel=""nofollow noreferrer"">http://csclub.uwaterloo.ca/contest/</a></p>

<p>Good luck and enjoy :)</p>
",0
5883424,5883358,2,"<p>If you just want to avoid the actual if/else, using the <code>? :</code> operator:</p>

<pre><code>return value &lt; 0 ? 0 : (value &gt; 0xff ? 0xff : value);
</code></pre>

<p>However, in terms of efficiency this shouldn't be any different.</p>

<p>In practice, you shouldn't worry about efficiency with something so trivial as this. Let the compiler do the optimization.</p>
",3
5883468,5883358,-1,"<p>One way to make it efficient is to declare this function as inline to avoid function calling expense. you could also turn it into macro using tertiary operator but that will remove the return type checking by compiler.</p>
",0
5883578,5883358,2,"<p>You can do it without explicit <code>if</code> by using <code>?:</code> as shown by another poster or by using interesting properties of <code>abs()</code> which lets you compute the maximum or minimum of two values.</p>

<p>For example, the expression <code>(a + abs(a))/2</code> returns <code>a</code> for positive numbers and <code>0</code> otherwise (maximum of <code>a</code> and <code>0</code>).</p>

<p>This gives</p>

<pre><code>unsigned char clip(short value)
{
  short a = (value + abs(value)) / 2;
  return (a + 255 - abs(a - 255)) / 2;
}
</code></pre>

<p>To convince yourself that this works, here is a test program:</p>

<pre><code>#include &lt;stdio.h&gt;

unsigned char clip(short value)
{
  short a = (value + abs(value)) / 2;
  return (a + 255 - abs(a - 255)) / 2;
}

void test(short value)
{
  printf(""clip(%d) = %d\n"", value, clip(value));
}

int main()
{
  test(0);
  test(10);
  test(-10);
  test(255);
  test(265);
  return 0;
}
</code></pre>

<p>When run, this prints</p>

<pre><code>clip(0) = 0
clip(10) = 10
clip(-10) = 0
clip(255) = 255
clip(265) = 255
</code></pre>

<p>Of course, one may argue that there is probably a test in <code>abs()</code>, but <code>gcc -O3</code> for example compiles it linearly:</p>

<pre><code>clip:
    movswl  %di, %edi
    movl    %edi, %edx
    sarl    $31, %edx
    movl    %edx, %eax
    xorl    %edi, %eax
    subl    %edx, %eax
    addl    %edi, %eax
    movl    %eax, %edx
    shrl    $31, %edx
    addl    %eax, %edx
    sarl    %edx
    movswl  %dx, %edx
    leal    255(%rdx), %eax
    subl    $255, %edx
    movl    %edx, %ecx
    sarl    $31, %ecx
    xorl    %ecx, %edx
    subl    %ecx, %edx
    subl    %edx, %eax
    movl    %eax, %edx
    shrl    $31, %edx
    addl    %edx, %eax
    sarl    %eax
    ret
</code></pre>

<p>But note that this will be much more inefficient than your original function, which compiles as:</p>

<pre><code>clip:
    xorl    %eax, %eax
    testw   %di, %di
    js      .L1
    movl    $-1, %eax
    cmpw    $255, %di
    cmovle  %edi, %eax
.L1:
    rep
    ret
</code></pre>

<p>But at least it answers your question :)</p>
",2
5883721,5883358,2,"<p>You could do a 2D lookup-table:</p>

<pre><code>unsigned char clamp(short value)
{
  static const unsigned char table[256][256] = { ... }

  const unsigned char x = value &amp; 0xff;
  const unsigned char y = (value &gt;&gt; 8) &amp; 0xff;
  return table[y][x];
}
</code></pre>

<p>Sure this looks bizarre (a 64 KB table for this trivial computation). However, considering that you mentioned you wanted to do this on a GPU, I'm thinking the above could be a texture look-up, which I believe are pretty quick on GPUs.</p>

<p>Further, if your GPU uses OpenGL, you could of course just use the <code><a href=""http://www.opengl.org/sdk/docs/manglsl/xhtml/clamp.xml"" rel=""nofollow"">clamp</a></code> builtin directly:</p>

<pre><code>clamp(value, 0, 255);
</code></pre>

<p>This won't type-convert (there is no 8-bit integer type in GLSL, it seems), but still.</p>
",2
5883729,5883358,0,"<p>Assuming a two byte short, and at the cost of readability of the code:</p>

<pre><code>clipped_x =  (x &amp; 0x8000) ? 0 : ((x &gt;&gt; 8) ? 0xFF : x);
</code></pre>
",1
5883976,5883358,3,"<p>You write that you want to avoid branching on the GPU. It is true, that branching can be very costly in a parallel environment because either both branches have to be evaluated or synchronization has to be applied. But if the branches are small enough the code will be faster than most arithmetic. The <a href=""http://developer.download.nvidia.com/compute/cuda/3_2_prod/toolkit/docs/CUDA_C_Best_Practices_Guide.pdf"" rel=""nofollow"">CUDA C best practices guide</a> describes why:</p>

<blockquote>
  <p>Sometimes, the compiler may [..]
  optimize out if or switch statements
  by using branch predication instead.
  In these cases, no warp can ever
  diverge. [..]</p>
  
  <p>When using branch predication none of
  the instructions whose execution
  depends on the controlling condition
  gets skipped. Instead, each of them is
  associated with a per-thread condition
  code or predicate that is set to true
  or false based on the controlling
  condition and although each of these
  instructions gets scheduled for
  execution, only the instructions with
  a true predicate are actually
  executed. Instructions with a false
  predicate do not write results, and
  also do not evaluate addresses or read
  operands.</p>
</blockquote>

<p>Branch predication is fast. Bloody fast! If you look at the intermediate PTX code generated by the optimizing compiler you will see that it is superior to even modest arithmetic. So the code like in the answer of davmac is probably as fast as it can get.</p>

<p>I know you did not ask specifically about CUDA, but most of the best practices guide also applies to OpenCL and probably large parts of AMDs GPU programming.</p>

<p>BTW: in virtually every case of GPU code I have ever seen most of the time is spend on memory access, not on arithmetic. Make sure to profile! <a href=""http://en.wikipedia.org/wiki/Program_optimization"" rel=""nofollow"">http://en.wikipedia.org/wiki/Program_optimization</a></p>
",1
5884167,5883358,0,"<p>You should time this ugly but arithmetic-only version.</p>

<pre><code>unsigned char clamp(short value){
  short pmask = ((value &amp; 0x4000) &gt;&gt; 7) | ((value &amp; 0x2000) &gt;&gt; 6) |
    ((value &amp; 0x1000) &gt;&gt; 5) | ((value &amp; 0x0800) &gt;&gt; 4) |
    ((value &amp; 0x0400) &gt;&gt; 3) | ((value &amp; 0x0200) &gt;&gt; 2) |
    ((value &amp; 0x0100) &gt;&gt; 1);
  pmask |= (pmask &gt;&gt; 1) | (pmask &gt;&gt; 2) | (pmask &gt;&gt; 3) | (pmask &gt;&gt; 4) |
    (pmask &gt;&gt; 5) | (pmask &gt;&gt; 6) | (pmask &gt;&gt; 7);
  value |= pmask;
  short nmask = (value &amp; 0x8000) &gt;&gt; 8;
  nmask |= (nmask &gt;&gt; 1) | (nmask &gt;&gt; 2) | (nmask &gt;&gt; 3) | (nmask &gt;&gt; 4) |
    (nmask &gt;&gt; 5) | (nmask &gt;&gt; 6) | (nmask &gt;&gt; 7);
  value &amp;= ~nmask;
  return value;
}
</code></pre>
",0
5884176,5883358,1,"<p>How about:</p>

<pre><code>unsigned char clamp (short value) {
    unsigned char r = (value &gt;&gt; 15);          /* uses arithmetic right-shift */
    unsigned char s = !!(value &amp; 0x7f00) * 0xff;
    unsigned char v = (value &amp; 0xff);
    return (v | s) &amp; ~r;
}
</code></pre>

<p>But I seriously doubt that it executes any faster than your original version involving branches.</p>
",0
2268756,2268725,7,"<p>The approach you take will depend on the possible range of values. You certainly have some internal knowledge of the possible range, and you may only be interested in conversions within a more narrow range.</p>

<p>So, suppose you are only interested in the integer value. In this case, I would just assign the number to an <code>int</code> or <code>long</code>, at which point the problem becomes fairly obvious.</p>

<p>Or, suppose the range won't include any large exponents but you are interested in several digits of fraction. To get three digits of fraction, I might say <code>int x = f * 1000;</code>, convert x, and then insert the decimal point as a string operation.</p>

<p>Failing all of the above, a float or double has a sign bit, a fraction, and an exponent. There is a hidden <code>1</code> in the fraction. (The numbers are normalized until they have no leading zeroes, at which point they do one more shift to gain an extra bit of precision.) The number is then equal to the fraction (plus a leading '1') * 2 ** exponent. With essentially all systems using the IEEE 754 representation you can just use <a href=""http://en.wikipedia.org/wiki/IEEE_754-1985"" rel=""noreferrer""><strong>this Wikipedia IEEE 754 page</strong></a> to understand the format. It's not <em>that</em> different from just converting an integer.</p>

<p>For single precision, once you get the exponent and fraction, the value<sup>Note 1</sup> of the number is then (frac / 2<sup>23</sup> + 1) * 2<sup>exp</sup>, or frac * 2<sup>exp - 23</sup> + 2<sup>exp</sup>.</p>

<p>Here is an example that should get you started on a useful conversion:</p>

<pre><code>$ cat t.c
#include &lt;stdio.h&gt;

void xconvert(unsigned frac)
{
  if (frac) {
    xconvert(frac / 10);
    printf(""%c"", frac % 10 | '0');
  }
}

void convert(unsigned i)
{
  unsigned sign, exp, frac;

  sign = i &gt;&gt; 31;
  exp  = (i &gt;&gt; (31 - 8)) - 127;
  frac = i &amp; 0x007fffff;
  if (sign)
    printf(""-"");
  xconvert(frac);
  printf("" * 2 ** %d + 2 ** %d\n"", exp - 23, exp);
  printf(""\n"");
}

int main(void)
{
  union {
     float f;
     unsigned i;
  } u;

  u.f = 1.234e9;
  convert(u.i);
  return 0;
}
$ ./a.out
1252017 * 2 ** 7 + 2 ** 30
</code></pre>

<hr>

<p><sup>Note 1. In this case the fraction is being converted as if the binary point was on the right instead of the left, with compensating adjustments then made to the exponent and hidden bit.</sup></p>
",0
2268950,2268725,-1,"<p>Even in an embedded system, you'd be hard pressed to beat the performance of ftoa.  Why reinvent the wheel?</p>
",1
2576728,2576726,7,"<p><code>int *(*pfp) ();</code></p>

<p>Creates a pointer to a function that returns int*.  The function pointer name is<code>pfp</code>.</p>

<p>Here's an example:</p>

<pre><code>int* myFunc(void)
{
   return NULL;
}


int main(int argc, char**argv)
{
  int *(*pfp) (void);
  pfp = myFunc;
  return 0;
}
</code></pre>

<p>Note: Since the parameters of the function pointer is not (void) that you gave, that means that the parameter list is not specified in C.  In C++ it would mean that it's a function with no parameters exactly.</p>
",1
2576731,2576726,0,"<p><code>pfp</code> is a pointer to a function that takes no parameters (or indeterminate parameters in C) and returns a pointer to an <code>int</code>.</p>

<p>Using the 'clockwise-spiral' rule is an effective way to decipher complex C declarations (at least I find it effective):</p>

<ul>
<li><a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow noreferrer"">http://c-faq.com/decl/spiral.anderson.html</a></li>
</ul>
",0
2576738,2576726,0,"<p>Use <a href=""http://www.cdecl.org/"" rel=""nofollow noreferrer"">http://www.cdecl.org/</a> for these things, if you're not sure.</p>
",0
2576750,2576726,4,"<p>Brian's explained the ""what"", but if you're curious as to the why, here's an excerpt from Dennis Ritchie's <a href=""http://cm.bell-labs.com/cm/cs/who/dmr/chist.html"" rel=""nofollow noreferrer"">The Development of the C Language</a>:</p>

<blockquote>
<p>The second innovation that most clearly distinguishes C from its predecessors is this fuller type structure and especially its expression in the syntax of declarations. NB offered the basic types int and char, together with arrays of them, and pointers to them, but no further ways of composition. Generalization was required: given an object of any type, it should be possible to describe a new object that gathers several into an array, yields it from a function, or is a pointer to it.</p>

<p>For each object of such a composed type, there was already a way to mention the underlying object: index the array, call the function, use the indirection operator on the pointer. Analogical reasoning led to a declaration syntax for names mirroring that of the expression syntax in which the names typically appear. Thus,</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;int i, *pi, **ppi;</code>
<p>declare an integer, a pointer to an integer, a pointer to a pointer to an integer. The syntax of these declarations reflects the observation that i, *pi, and **ppi all yield an int type when used in an expression. Similarly,</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;int f(), *f(), (*f)();</code>
<p>declare a function returning an integer, a function returning a pointer to an integer, a pointer to a function returning an integer;</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;int *api[10], (*pai)[10];</code>
<p>declare an array of pointers to integers, and a pointer to an array of integers. In all these cases the declaration of a variable resembles its usage in an expression whose type is the one named at the head of the declaration.</p>
</blockquote>

<p>For more info, read Steve Friedl's ""<a href=""http://unixwiz.net/techtips/reading-cdecl.html"" rel=""nofollow noreferrer"">Reading C type declarations</a>"" or Eric Giguere's ""<a href=""http://www.ericgiguere.com/articles/reading-c-declarations.html"" rel=""nofollow noreferrer"">Reading C Declarations: A Guide for the Mystified</a>"".</p>
",0
3447744,3447735,1,"<p>Simplest possible approach - use sprintf (or snprintf, if you have it):</p>

<pre><code>unsigned char a[SOMESIZE]
int n = 1234;
sprintf( a, ""%d"", n );
</code></pre>

<p>Or if you want it stored in binary:</p>

<pre><code>unsigned char a[sizeof( int ) ];
int n = 1234;
memcpy( a, &amp; n, sizeof( int ) );
</code></pre>
",5
3448314,3447735,0,"<p>I understand the problem as converting a number to a string representation (as Neil does).</p>

<p>Below is a simple way to do it without using any lib.</p>

<pre><code>int i = 0;
int j = 0;
do {a[i++] = '0'+n%10; n/=10;} while (n);
a[i--] = 0;
for (j&lt;i; j++,i--) {int tmp = a[i]; a[i] = a[j]; a[j] = tmp;}
</code></pre>

<p>The question probably needs some clarification as others obviously understood you wanted the underlying bytes used in internal representation of int (but if you want to do that kind of thing, you'd better use some fixed size type defined in  instead of an int, or you won't know for sure the length of your byte array).</p>
",0
3447931,3447735,0,"<p>Warning: untested code.</p>

<p>This should be an endianness-agnostic conversion. It goes from low to high. There's probably a more efficient way to do it, but I can't think of it at the moment.</p>

<pre><code>#include &lt;limits.h&gt; // CHAR_BIT, UCHAR_MAX

int num = 68465; // insert number here
unsigned char bytes[sizeof(int)];
for (int i=0; i&lt;sizeof(int); i++)
{
    bytes[i] = num &amp; UCHAR_MAX;
    num &gt;&gt;= CHAR_BIT;
}
</code></pre>

<p>I'm posting this mostly because I don't see another solution here for which the results don't change depending on what endianness your processor is.</p>
",1
3447956,3447735,11,"<p>Or if you know what you are doing:</p>

<pre><code>int n = 12345;
char* a = (char*)&amp;n;
</code></pre>
",0
3448584,3447735,1,"<p>This could work</p>

<pre><code>int n=1234;    
const int arrayLength=sizeof(int);
unsigned char *bytePtr=(unsigned char*)&amp;n;

for(int i=0;i&lt;arrayLength;i++)
{
   printf(""[%X]"",bytePtr[i]);
}
</code></pre>

<p>Take care of order that depends on endianness</p>
",0
7476932,7476902,3,"<pre><code>buf[offset] = htonl(c);
buf[4] = htonl(x);
buf[8] = htonl(y);
buf[12] = htonl(w);
</code></pre>

<p>this is broken. you should declare array of <code>int</code>egers. Reason is that <code>buf[i] = x</code> meants put a byte at i-th cell, and if it doesn't fit then truncate. That is what is happening.</p>
",3
7489458,7476902,2,"<pre><code>*((int *)(buf + offset)) = htonl(c);
*((int *)(buf + 4)) = htonl(x);
*((int *)(buf + 8)) = htonl(y);
*((int *)(buf + 12)) = htonl(w);
</code></pre>

<p>This is how you should have written the assignment snippet. This way you tell what 'buf + offset' is pointing to is a pointer to type 'int' and you would want to dereference now what this 'int *' is pointing to. </p>

<p>Simply assigning buf[x] = integer; translates to *((char *)(buf + x)) = integer. And since you are doing htonl(), I am taking a guess that your values c,x,y,w are such that they are &lt; 65535  making the higher 32 bits 0 which is what is filled into buf when you do htonl(c/x/y/w).</p>

<p>HTH</p>
",0
4008879,4008871,3,"<p>The name is <a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language_%28book%29"" rel=""nofollow"">The C Programming Language</a>.</p>
",1
4008883,4008871,6,"<p>It shifts the bits in the integer 1 <code>var</code> positions to the left. So in effect it calculates 2 to the power of <code>var</code>.</p>

<p>See <a href=""http://en.wikipedia.org/wiki/Bit_shift#Shifts_in_C.2C_C.2B.2B.2C_C.23_and_Java"" rel=""noreferrer"">the article on bit shifts on wikipedia</a>.</p>
",0
4008884,4008871,4,"<p>That's the <code>left bitwise shift operator</code>.</p>

<p>The other <code>bitwise shift operator</code> is <code>&gt;&gt;</code>.</p>
",0
4008886,4008871,3,"<p>It is the left shift operator.</p>

<p>You might want to read about <a href=""http://en.wikipedia.org/wiki/Bitwise_operation#Shifts_in_C.2C_C.2B.2B.2C_C.23_and_Java"" rel=""nofollow"">bitwise operations</a>, and more specifically, <a href=""http://www.cs.umd.edu/class/spring2003/cmsc311/Notes/BitOp/bitshift.html"" rel=""nofollow"">bitshift operators</a>.</p>
",0
4008887,4008871,1,"<p><code>&lt;&lt;</code> is a bit manipulation operator. Specifically <code>&lt;&lt;</code> performs left shift operation. This achieves the effect of multiplying the underlying value by power of 2.</p>

<p>More information could be found at: <a href=""http://en.wikipedia.org/wiki/Bit_manipulation"" rel=""nofollow"">http://en.wikipedia.org/wiki/Bit_manipulation</a></p>
",0
4008888,4008871,5,"<p>That is a ""left bit shift"" operator.  In your example, it shifts 0000..00001 left ""var"" places.  So if var is 1, this is the same as ""1 &lt;&lt; 1"" which shifts 0001 to 0010, which is 2.  If var was 2 the answer would be 0100 (4), etc.  If this isn't making sense, you'll need to read up on binary arithmetic.</p>
",0
2846631,2846625,1,"<p><s>You are incrementing the character, not the pointer. Change *s++ to simply s++.</s> In addition, you have forgotten to forward-declare your function ""is_in"". One other note: you should probably make your string a ""const char*"" instead of ""char*"", and, IMHO, explicit comparison with '\0' and using indexes is clearer:</p>

<pre><code>#include &lt;stdio.h&gt;

int is_in(const char*, char);
int main(int argc, char* argv[]){
    const char* str=""some text"";
    printf(""%d"",is_in(s,'t'));
    return 0;
}

int is_in(const char* str, char c){
    int idx=0;
    while ( str[idx] != '\0' ){
        if ( str[idx] == c ){
            return 1;
        }
        idx++;
    }
    return 0;
}
</code></pre>
",4
2846632,2846625,6,"<p>Have you tried putting the is_in function above main?</p>
",3
2279401,2279379,122,"<p>A char in C is already a number (the character's ASCII code), no conversion required.</p>

<p>If you want to convert a digit to the corresponding character, you can simply add '0':</p>

<pre><code>c = i +'0';
</code></pre>

<p>The '0' is a character in the ASCll table. </p>
",5
2279416,2279379,18,"<p>Just assign the <code>int</code> to a <code>char</code> variable.</p>

<pre><code>int i = 65;
char c = i;
printf(""%c"", c); //prints A
</code></pre>
",1
2279435,2279379,36,"<p>You can try atoi() library function.
Also sscanf() and sprintf() would help.</p>

<p>Here is a small example to show converting integer to character string:</p>

<pre><code>main()
{
  int i = 247593;
  char str[10];

  sprintf(str, ""%d"", i);
  // Now str contains the integer as characters
} 
</code></pre>

<p>Here for another Example</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
   char text[] = ""StringX"";
   int digit;
   for (digit = 0; digit &lt; 10; ++digit)
   {
      text[6] = digit + '0';
      puts(text);
   }
   return 0;
}

/* my output
String0
String1
String2
String3
String4
String5
String6
String7
String8
String9
*/
</code></pre>
",4
5194041,5193633,5,"<p>This should do it:</p>

<pre><code>#include &lt;stdint.h&gt;

void write_64bit_zero_to(void *address)
{
  *((uint64_t *) address) = 0;
}
</code></pre>

<p>if your platform doesn't provide <code>stdint.h</code>, I'm sure it has something similiar as long as the architecture actually supports 64-bit integers (which, of course, you've said that it does). See <a href=""http://linux.die.net/man/3/uint64_t"" rel=""nofollow"">this page</a> for more talk about the type.</p>
",2
2612704,2612693,6,"<p>Your error is: -5 in two's complement is not <code>10000101</code>. In 32-bit it is: <code>11111111111111111111111111111011</code></p>

<p>6, is:</p>

<p><code>00000000000000000000000000000110</code></p>

<p>The sum is:</p>

<pre><code>  11111111111111111111111111111011
+ 00000000000000000000000000000110
  --------------------------------
  00000000000000000000000000000001
</code></pre>

<p>I recommend you read <a href=""http://en.wikipedia.org/wiki/Signed_number_representations"" rel=""nofollow noreferrer"">this Wikipedia page</a> about signed number representation. Modern CPUs use two's complement.</p>
",1
2612706,2612693,2,"<pre><code>#include&lt;stdio.h&gt;
    main()
    {
            char a,b,c;
            a=6;
            b=-5;
            c=a+b;
            printf(""%d %d %d \n"", a,b,c);
    }

    /*
     *
     *  Here 6 value as = 00000110
     *       -5 value will be treated as complement of 5.
     *
     *       Actual 5 value is 00000101
     *       Complement of 5 is 11111010
     *        Then we need to add 1 to the complement of 5
     *        So that time value is 11111011
     *
     *        Now we need to add 5 and 6
     *
     *        00000110
     *        11111011
              ---------
              00000001
    */ 
</code></pre>
",0
2612721,2612693,2,"<p>You seem to be a bit confused about how negative values are stored on the computer. What you have there is called ""sign and magnitude"". Since arithmetic is difficult with sign and magnitude numbers (as you've experienced!), basically all computers use ""two's complement."" This is easily calculated by following two steps:</p>

<ol>
<li>Flip all bits (that is, take the complement)</li>
<li>Add one</li>
</ol>

<p>Doing that, <code>0000101</code> becomes <code>1111011</code> (in 8 bits, for simplicity). Then addition is easy:</p>

<pre><code>  1111011 = -5
+ 0000110 =  6
 ________ |
  0000001 =  1
</code></pre>

<p>Which is 1, as expected.</p>
",0
2612736,2612693,6,"<p>It seems that you're confusing the concepts of 2's complement and sign-bit, and bitwise-or and addition in C.</p>

<p>(And who would expect 6 + (-5) ¡Ù 1¡­)</p>

<hr>

<h2>(1) 2's complement and sign-bit</h2>

<p>On most architectures negative numbers are implemented as a <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">2's complement</a> of its magnitude. While the C standard does not mandate 2's complement being used, it is the most popular one. In 2's complement, the negative of <code>x</code> is constructed as <code>~x + 1</code>, e.g.</p>

<pre><code>  5   = 0000 0101
 ~5   = 1111 1010    # ~x means 1's complement, a.k.a. bitwise-NOT
 ~5+1 = 1111 1011    # +1 means add 1 to the integer.
</code></pre>

<p>This is the binary representation of -5. The highest bit of the integer is called the <em>sign bit</em> because it determines the sign of the integer. All negative integers in 2's complement has sign bit = 1. <strong>But just flipping the sign bit doesn't negate the number.</strong> It is merely an indicator that the number is negative or not.</p>

<hr>

<h2>(2) Bitwise-or and addition in C</h2>

<p><code>+</code> means integer addition in C and all other practical languages, because integer addition much more useful than bitwise-or. So although OR is widely written as <code>+</code> in logical proofs, no programming languages recognize <code>+</code> for bitwise-OR.</p>

<p>In C a <code>char</code> is just a signed integer which is exactly 1-byte long. The behavior is same as all other kinds of signed integers. You have to use <code>|</code> for bitwise-OR.</p>

<pre><code>  0000 0110               0000 0110
+ 1000 0101             | 1000 0101
¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª             ¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª¡ª             
  1000 1011               1000 0111
       ^^--- note the carry ---^^
</code></pre>
",1
2609567,2609536,1,"<p>This works, but only if it's okay to assume that elevation is insignificant. Depending on how exact you need to be, someone on a high mountaintop will experience sunrise (or sunset) slightly before (or after) somebody at sea level. For instance, if you're standing on Mount Everest, sunrise and sunset are shifted apart by ~16 minutes, relative to sea level (source: back of the envelope math).</p>

<p>Note that the more extreme your latitude, the starker the contrasts between longer summer days and longer winter nights. Some places on Earth receive sunlight all 24 hours of the day during summer and are shrouded in darkness all 24 hours of the night. These places don't have a daily ""dawn"" or ""dusk"", although you could pick the times halfway in between when the sun is lowest and highest in the sky.</p>
",2
2609609,2609536,0,"<p>This doesn't work.  An easy way to prove this to yourself is that at the poles, the elevation of the sun doesn't change as you rotate your body, so going east or west by 6 degrees won't affect your times.</p>

<p>If you're closer to the equator, this calculation will probably be more accurate, but I don't think it's ever perfect.</p>
",2
2609620,2609536,3,"<p>The code that you link to uses a constant (90.833) in the <code>calcHourAngle*</code> methods.  If you look at <a href=""http://www.zetatalk4.com/docs/Latitude_Determination/Rise_Set_And_Twilight_Definitions_2004.pdf"" rel=""nofollow noreferrer"">these definitions</a> of sunrise/sunset, you will notice that same 90.833 constant under Technical Definitions and Computational Details.  A little further down, under civil twilight, the similar constant of 96 is used.  Perhaps changing that constant would get what you are looking for?</p>
",1
2609627,2609536,2,"<p>i don't have a comment on your code, but you can use the following site to verify the output from your program: <a href=""http://aa.usno.navy.mil/data/docs/RS_OneYear.php"" rel=""nofollow noreferrer"">http://aa.usno.navy.mil/data/docs/RS_OneYear.php</a></p>
",0
7383861,7383844,7,"<p>It is used to specify bit fields.  The size of the field is given in bits.  The layout is compiler-specific.</p>
",4
2910988,2910810,9,"<p>A good rule to follow is: ""Don't <em>define</em> things in header files"". <em>Declare</em> all you want but definitions should be restricted to non headers. A <em>declaration</em> is simply a notification that something exists. A <em>definition</em> actually defines what it is.</p>

<p>The rationale behind this guideline is to prevent exactly the situation you're seeing - having things define twice (or more) because header files are included into multiple compilation units.</p>

<p>To avoid this, you could use something like:</p>

<pre><code>myprog.h:
    extern int myVar;     // a declaration.

myprog.c:
    #include ""myprog.h""
    int myVar = 7;        // a definition.

otherbit.c:
    #include ""myprog.h""
    int fn (void) {
        myVar = 12;
        return myVar;
    }
</code></pre>

<p>The definition above will only end up in <code>myprog.o</code>, you won't get another copy in <code>otherbit.o</code> to cause you problems at link time.</p>

<p>Leaving aside that proper encapsulation would make these global variables a very bad idea, that's the way I'd do it.</p>

<p>The <em>encapsulated</em> way of doing it would be something like this:</p>

<pre><code>myprog.h:
    int getMyVar (void);
    void setMyVar (int);

myprog.c:
    #include ""myprog.h""
    static int myVar = 7;
    int getMyVar (void) { return myVar; }
    void setMyVar (int n) {
        // Error checks on n here.
        myVar = n;
    }

otherbit.c:
    #include ""myprog.h""
    int fn (void) {
        setMyVar (12);
        return getMyVar();
    }
</code></pre>

<p>Encapsulation is basically information hiding. It means you should expose as <em>little as possible</em> of your inner working to get the job done, lest you open yourself up the possibility of other code sneaking in under the covers and either invalidating your assumptions (see below) or making it harder to change your inner workings later.</p>

<p>A classic example is if you want the <code>myVar</code> variable restricted to the range 0 through 359 inclusive (say an angle). With encapsulation you could simply use:</p>

<pre><code>void setMyVar (unsigned int n) { myVar = n % 360; }
</code></pre>

<p>and <em>never</em> have to worry about it being invalid. You can safely assume, memory corruption aside, that <code>myVar</code> will always be within the range desired. You would not have that certainty if some rogue piece of user code could come in and just do:</p>

<pre><code>myVar = 32767;
</code></pre>

<p>without you knowing it. You would either have to cater for values outside your desired range or force it to the valid range at the start of all your functions:</p>

<pre><code>myVar = myVar % 360;
</code></pre>

<p>That's poor coding practice, and totally unnecessary.</p>
",1
3928645,3928620,3,"<p>string literals are read-only, you can't change them.</p>

<p>Use e.g. <code>char p[] = ""onnm"";</code></p>
",0
3930321,3928620,1,"<p>You are able to code like this because of the ""an inconsistency in the language standard"" of C.
e.g.,</p>

<pre><code>const char const_buff[] = { 'o','n', 'n', 'm', '\0' }; // OK

char* pArray = const_buff;            // not OK
</code></pre>

<p>In the same line it should have not allowed you to compile, </p>

<pre><code>char *p = ""onnm"";
</code></pre>

<p>But you are able to compile, so allowing you to do the the mistake of changing a read-only string.</p>

<pre><code>++ * ( p++)
</code></pre>
",0
6603245,6597707,0,"<p><strong>To what accuracy?</strong>  My first impulse would be to simply use <a href=""http://en.wikipedia.org/wiki/Stirling%27s_approximation"" rel=""nofollow"">Stirling's approximation</a>.</p>
",0
6603669,6597707,0,"<p>There's no way I'm going to implement factorial for longs (bigger than ints) not to say above that.. It's totally pointless. No matter how fast my biginter library is.</p>

<p>32bit -> 4G, product of the numbers just from 1G till 4G.. well, lets just get a quick (under)estimation for the number of digits: 3G * 9 = 27G. rough estimation for the storage for that: 2^10=1024, so for 3 digits you need 1.25 bytes.. that's 11.25G. remember, this was a serious underestimation... </p>
",2
2607892,2607853,1,"<p>To accommodate both K&amp;R and ANSI C function declaration styles. Take a look at <a href=""http://en.wikipedia.org/wiki/C_(programming_language)"" rel=""nofollow noreferrer"">Wikipedia article about C evolution</a>.</p>
",0
2607896,2607853,3,"<p>The source code you linked to explains it:</p>

<blockquote>
  <p>00009  * If _ANSI ends up being defined, a macro<br>
  00010  *<br>
  00011  *      _PROTOTYPE(function, params)<br>
  00012  *<br>
  00013  * is defined.  This macro expands in different ways, generating either<br>
  00014  * ANSI Standard C prototypes or old-style K&amp;R (Kernighan &amp; Ritchie)<br>
  00015  * prototypes, as needed.  Finally, some programs use _CONST, _VOIDSTAR etc<br>
  00016  * in such a way that they are portable over both ANSI and K&amp;R compilers.<br>
  00017  * The appropriate macros are defined here.  </p>
</blockquote>

<p>Old-style K&amp;R prototypes have the argument <em>names</em> first, then the types:</p>

<pre><code>int foobar (x, y)
    int x;
    float *y;
{
    /* code */
}
</code></pre>

<p>ANSI standard prototypes combine them both at the beginning:</p>

<pre><code>int foobar (int x, float *y) {
    /* code */
}
</code></pre>

<p>The <code>_PROTOTYPE</code> macro creates an appropriate signature of either type depending on whether or not <code>_ANSI</code> is defined. In this specific case, K&amp;R signatures are used for function implementations, but the function declarations either include or omit their arguments depending on whether <code>_ANSI</code> is defined.</p>

<p>It is worth noting that K&amp;R-style declarations date from 1978 and most C code currently available will use modern ANSI style signatures. It is rare that you need to support both.</p>
",1
2607905,2607853,5,"<p>Because as the header block says, they didn't know if an ANSI compiler or K&amp;R was going to be used, and this marco allows them to keep the parameters in an ANSI build, and throw them away in a K&amp;R build.</p>

<pre><code>00033   /* Keep everything for ANSI prototypes. */
00034   #define _PROTOTYPE(function, params)    function params
</code></pre>

<p>verse</p>

<pre><code>00045   /* Throw away the parameters for K&amp;R prototypes. */
00046   #define _PROTOTYPE(function, params)    function()
</code></pre>

<p>which means </p>

<pre><code>00483   _PROTOTYPE( void _exit, (int _status)    );
</code></pre>

<p>becomes under ANSI:</p>

<pre><code>void _exit(int _status);
</code></pre>

<p>and under K&amp;R:</p>

<pre><code>void _exit();
</code></pre>
",0
3838587,3838565,8,"<p>Use <code>fork()</code> to create a new process and then use <code>system()</code> (or any <code>exec</code> function) in it. The original process will then be able to continue executing.</p>
",0
3838588,3838565,6,"<p>You might want to use <code>popen</code>. It creates new processes and allows you to redirect the process output to your own process.</p>
",0
3839192,3838565,7,"<p>The answer depends on what your real goal is. You don't say what platform you're on, and I know very little about Windows, so this only covers your options on linux/unix.</p>

<ol>
<li><p>You just want to spawn another program, and don't need to interact with it. In this case, call <a href=""http://linux.die.net/man/3/fork"" rel=""noreferrer""><code>fork()</code></a>, and then in the child process run <a href=""http://linux.die.net/man/3/execve"" rel=""noreferrer""><code>execve()</code></a> (or related function).</p></li>
<li><p>You want to interact with another program. In this case, use <a href=""http://linux.die.net/man/3/popen"" rel=""noreferrer""><code>popen()</code></a>.</p></li>
<li><p>You want part of your program to run as a subprocess. In this case, use <code>fork()</code>, and call whatever functions you need to run in the child.</p></li>
<li><p>You need to interact with part of your program running as a subprocess. Call <a href=""http://linux.die.net/man/3/pipe"" rel=""noreferrer""><code>pipe()</code></a> so you have a file descriptor to communicate through, then call <code>fork()</code> and use the file descriptor pair to communicate. Alternatively, you could communicate through a socket, message queue, shared memory, etc.</p></li>
</ol>
",2
3838668,3838565,3,"<p>If in windows, use the <code>ShellExecute()</code> function from the Windows API.</p>

<p>If in Unix, go for <code>fork()</code> then <code>system()</code> as mentioned.</p>
",0
3838701,3838565,12,"<p>I think that a quick and dirty action is to call sytem(command &amp;). the &amp; will spawn the new process. </p>
",2
5460485,5460426,1,"<p>If you want to set the Nth bit in a character to 1, you need to <code>OR</code> it with the value <code>1</code> shifted to the left by N positions:</p>

<pre><code>c |= 1 &lt;&lt; N;
</code></pre>
",0
5460487,5460426,3,"<p>Pretty vague question, I would suggest you brush up on bitwise operators. This should point you in the right direction.</p>

<p><a href=""http://www.cprogramming.com/tutorial/bitwise_operators.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/bitwise_operators.html</a></p>
",0
5460497,5460426,2,"<p>Since you requested for idea and not exact implementation:</p>

<p>Here is what you can do,</p>

<p>Iterate over each bit and set it as required.</p>

<p>You can set the nth bit (0 indexed as follows)</p>

<pre><code>byteVal = byteVal | (1&lt;&lt;N);
</code></pre>
",0
5460519,5460426,1,"<p>Say you want to check the nth bit of a char:</p>

<pre><code>int checkBit(char c, int n) {
    return c &amp; (1 &lt;&lt; n);
}
</code></pre>

<p>To set the nth bit:</p>

<pre><code>void setBit(char *c, int n) {
    *c |= 1 &lt;&lt; n;
}
</code></pre>
",0
5460533,5460426,1,"<p>Sure, simply resort to binary operations. The following function should do exactly what you want, but with a simple interface:</p>

<pre><code>char set8 (char ch, int index) {
   if (index &gt;= 1 &amp;&amp; index &lt;= 8) {
        return (char)(ch | (1 &lt;&lt; index - 1));
   }
   return ch;
}

int n = 0;

set8(n, 1); // Returns 1
set8(n, 2); // Returns 2
set8(n, 3); // Returns 4

...

set8(n, 9); // Returns n (0)
</code></pre>

<p>The function uses bitwise-OR to toggle the specified bit. If the index specified is outside the range of a byte (8 bits), then it simply returns the character passed in.</p>
",0
2937850,2935436,-1,"<p>add more detail in the question</p>

<pre><code>job_queue[i] = job
</code></pre>

<p>just assign a function to the function pointer array</p>

<p>as can not assign function pointer array directly to pthread_create</p>
",1
2938021,2935436,-1,"<p>After placing function pointer array <code>(* job_queue[(int)arg])();</code> at the end
it can successfully call function with the following result even if i add a infinite loop and a sleep in <code>func1</code>, it will not block at <code>func1</code></p>

<p>now i am working on how to replace existing running function with a new function using <code>pthread_cleanup_push</code> and <code>pop</code></p>

<ul>
<li>workserver number: 0 func1 run</li>
<li>workserver number: 2 func3 run</li>
<li>workserver number: 1 func2 run</li>
<li>workserver number: 0 func1 run</li>
<li>workserver number: 2 func3 run</li>
<li>workserver number: 1 func2 run</li>
<li>workserver number: 2 workserver</li>
<li>number: 0 func3 run func1 run</li>
<li>workserver number: 1 func2 run</li>
<li>workserver number: 0 workserver</li>
<li>number: 2 func1 run func3 run</li>
<li>workserver number: 1 func2 run</li>
<li>workserver number: 2 workserver</li>
<li>number: 0 func3 run func1 run</li>
<li>workserver number: 1 func2 run</li>
<li>workserver number: 0 workserver</li>
<li>number: 2 func1 run func3 run</li>
<li><p>workserver number: 1 func2 run</p>

<p>while(true)
{
    printf(""workserver number: %d\n"", (int)arg);</p>

<pre><code>status = pthread_mutex_lock(&amp;data.mutex);

//pthread_cleanup_push(

if(status != 0)
     printf(""%d lock mutex"", status);
data.value = 1;
status = pthread_cond_signal(&amp;data.cond);
if(status != 0)
    printf(""%d signal condition"", status);
status = pthread_mutex_unlock(&amp;data.mutex);
if(status != 0)
    printf(""%d unlock mutex"", status);

(* job_queue[(int)arg])();
sleep(1);
void (* clean)(void *);
clean = NULL;
/*
for(int i=0; i&lt;4; i++)
{
    if(idle[i] == 0)
    {
        if(fp[(int)arg] != NULL)
        {
            idle[running_number[(int)arg]] = 0; // replace its running job
            clean = fp[(int)arg];
            fp[(int)arg] = job_queue[i];
            pthread_cleanup_push(clean, NULL);
            (*fp[(int)arg])();
            pthread_cleanup_pop(1);

            idle[i] = 1;
        }
        else
        {
            fp[(int)arg] = job_queue[i];
            idle[i] = 1;
            running_number[(int)arg] = i;
            (*fp[(int)arg])();
        }
    }
}*/
</code></pre>

<p>}</p></li>
</ul>
",0
6618797,6618697,6,"<p>You haven't allowed for the null that terminates strings, so you have classic buffer overflows.</p>

<p>You also do not need to copy the names <em>three</em> times.  Your current code is:</p>

<pre><code>int L1 = strlen( A-&gt;name );
int L2 = strlen( B-&gt;name );
int len = L1 + L2;
char *Ap = (char*)malloc(L1*sizeof(char)); strcpy(Ap,A-&gt;name);
char *Bp = (char*)malloc(L2*sizeof(char )); strcpy(Bp,B-&gt;name);
char *c = (char*)malloc(sizeof(char)*(len + 2));
c[0] = '('; strcat(c, Ap); strcat(c, Bp); c[len+1] = ')';
ret-&gt;name = (char*)malloc(sizeof(char)*(len + 2));
strcpy(ret-&gt;name, c);
ret-&gt;R = A-&gt;R; ret-&gt;C = B-&gt;C;
ret-&gt;dim = ret-&gt;R*ret-&gt;C;
free(Ap); free(Bp); free(c);
</code></pre>

<p>This should be:</p>

<pre><code>int   L1 = strlen(A-&gt;name);
int   L2 = strlen(B-&gt;name);

ret-&gt;name = (char *)malloc(L1 + L2 + sizeof(""()""));  // That adds 3
sprintf(ret-&gt;name, ""(%s%s)"", A-&gt;name, B-&gt;name);

ret-&gt;R   = A-&gt;R;
ret-&gt;C   = B-&gt;C;
ret-&gt;dim = ret-&gt;R * ret-&gt;C;
</code></pre>

<p>This eliminates <code>Ap</code>, <code>Bp</code> and <code>c</code> altogether, and avoids the buffer overflow problems.  I'm not sure I'd slam the two names together like you do, but that's your choice.</p>

<hr>

<p>Apparently, this isn't sufficient of a problem...there are other issues too.</p>

<pre><code>void clone_list( MatrixList *from, MatrixList *to ) {
    if (from-&gt;head == NULL) {
        to = NULL;
    } else {
        Node *tmp = from-&gt;head;
        while( tmp != NULL ) {
            Matrix *m_copy = (Matrix*)malloc(sizeof(Matrix*));
            char *c_copy = (char*)malloc(sizeof(char*)*strlen(tmp-&gt;M-&gt;name));

            strcpy(c_copy,tmp-&gt;M-&gt;name);
            m_copy-&gt;name=c_copy;
            m_copy-&gt;R=tmp-&gt;M-&gt;R;
            m_copy-&gt;C=tmp-&gt;M-&gt;C;
            m_copy-&gt;concat_matrices = concat_matrices;

            to-&gt;append( to,m_copy );
            tmp = tmp-&gt;next;
        }
    }
}
</code></pre>

<p>The first assignment zeroes the local pointer; it doesn't do a thing to the <code>MatrixList</code> passed in as the target.  This should presumably be:</p>

<pre><code>if (from-&gt;head == 0)
{
    *to = *from;
}
</code></pre>

<p>This does a wholesale structure copy, but sets the head and tail to null, and the function pointers are all fine - they can be shared.  Assuming that the <code>size</code> in <code>from</code> was correctly zero, it will be correct in <code>to</code> too.  (Again, this is probably not the code you are exercising.)</p>

<p>The next problem is with the memory allocation:</p>

<pre><code>Matrix *m_copy = (Matrix*)malloc(sizeof(Matrix*));
</code></pre>

<p>This allocates one pointer's worth of memory, not one Matrix's worth.  Use either of these:</p>

<pre><code>Matrix *m_copy = (Matrix *)malloc(sizeof(*m_copy));
Matrix *m_copy = (Matrix *)malloc(sizeof(Matrix));
</code></pre>

<p>That is a major source of your trouble (and one which <a href=""http://valgrind.org/"" rel=""nofollow noreferrer""><code>valgrind</code></a> will find easily).</p>

<hr>

<p>When the <code>+1</code> gets forgotten once, it gets forgotten many times, but this time it doesn't cause problems unless the name is the empty string because you multiply by 4 or 8 (32-bit or 64-bit) because of the <code>sizeof(char *)</code> instead of the intended <code>sizeof(char)</code>.</p>

<pre><code>char *c_copy = (char*)malloc(sizeof(char*)*strlen(tmp-&gt;M-&gt;name));
strcpy(c_copy,tmp-&gt;M-&gt;name);
</code></pre>

<p>This should probably be:</p>

<pre><code>m_copy-&gt;name = (char *)malloc(strlen(tmp-&gt;M-&gt;name) + 1);
strcpy(m_copy-&gt;name, tmp-&gt;M-&gt;name);
</code></pre>

<p>I'd probably use a name like <code>old</code> instead of <code>tmp</code>.  I am also remiss in not reminding previously that you should religiously check every return from every memory allocation.  Or use a set of cover functions for the memory allocation routines which do the check for you (often called <code>xmalloc()</code> or <code>emalloc()</code>, etc.).</p>

<p>The code below that does not seem to copy the <code>dim</code> member across, which is a bug if you ever depend on it.</p>

<p>I'm not entirely happy that you seem to rely on the <code>to</code> list being appropriately initializes before calling <code>clone_list()</code>.  In particular, the <code>head</code>, <code>tail</code> and <code>size</code> members are not zeroed here, and the function pointers are not set.  I'd be happier to see something like:</p>

<pre><code>*to = *from;  // Copy function pointers
to-&gt;head = 0;
to-&gt;tail = 0;
to-&gt;size = 0;
Node *old = from-&gt;head;
for (Node *old = from-&gt;head; old != NULL; old = old-&gt;next)
{
    Matrix *m_copy = clone_matrix(old-&gt;M);
    to-&gt;append(to, m_copy);
}
</code></pre>

<p>Or even:</p>

<pre><code>matrixlist_initialize(to);
Node *old = from-&gt;head;
for (Node *old = from-&gt;head; old != NULL; old = old-&gt;next)
{
    Matrix *m_copy = clone_matrix(old-&gt;M);
    to-&gt;append(to, m_copy);
}
</code></pre>

<p>The <code>clone_matrix()</code> function looks like:</p>

<pre><code>Matrix *clone_matrix(const Matrix *old)
{
    Matrix *m_copy = (Matrix*)malloc(sizeof(*m_copy));

    m_copy-&gt;name = (char*)malloc(strlen(old-&gt;name)+1);

    strcpy(m_copy-&gt;name, old-&gt;name);
    m_copy-&gt;R   = old-&gt;R;
    m_copy-&gt;C   = old-&gt;C;
    m_copy-&gt;dim = old-&gt;dim;
    m_copy-&gt;concat_matrices = concat_matrices;
    return(m_copy);
}
</code></pre>

<hr>

<p>I downloaded a version your code and it now seems to work, more or less.  You should be compiling with at least <code>-Wall</code> as a compiler option; I refuse to compile with anything less and usually use <code>-Wextra</code> too.  I make too many simple-to-spot mistakes not to make full use of the compiler, and while you are learning, you will too.  (I've only been coding in C for just over a quarter century; the compiler still catches typos and other silly mistakes, but I seldom have big problems once the code is compiling.)</p>

<p>When I turned on <code>-Wall</code>, there was a problem with the (unused) <code>perm()</code> function because it doesn't return a value even though it says it will, and there was a problem because the correct definition for <code>main()</code> with arguments is <code>int main(int argc, char **argv)</code> and you were missing one of the stars.  Other than that, it seems to be working OK now - you can continue with your development.</p>

<p>There is a function in POSIX called <code>strdup()</code> which duplicates a string reliably.  It is useful and avoids the off-by-one mistakes.</p>

<p>You should review the use of <a href=""https://stackoverflow.com/questions/1804486/should-i-use-include-in-headers/1804719#1804719"">headers</a>.  They are for declarations, primarily.  If you explicitly use <code>inline</code> (your code doesn't yet), it can be appropriate to include <code>inline</code> functions in a header, but otherwise, function bodies should not be in headers.  They should be in source files (<code>.c</code> suffix).  Each header should contain the minimum necessary information for the code that uses the functionality provided by the source to use.  It should not include extraneous headers, but it should include all necessary headers.  In <code>matrix.h</code>, you include <code>&lt;stdio.h&gt;</code> which is unnecessary.  And if you removed the code, neither <code>&lt;string.h&gt;</code> nor <code>&lt;stdlib.h&gt;</code> would be needed either.</p>
",7
6618799,6618697,2,"<pre><code>    int L1 = strlen( A-&gt;name );
    int L2 = strlen( B-&gt;name );
    int len = L1 + L2;
    char *Ap = (char*)malloc(L1*sizeof(char)); strcpy(Ap,A-&gt;name);
    char *Bp = (char*)malloc(L2*sizeof(char )); strcpy(Bp,B-&gt;name);
</code></pre>

<p>I'm willing to bet that your <code>strcpy(3)</code> calls here have written outside the bounds of the memory you've allocated: <code>strlen(3)</code> does NOT account for the <code>'\0'</code> terminator at the end of C strings, so your <code>*Ap</code> and <code>*Bp</code> are allocated one-byte-too-short.</p>

<p>Because this is <em>so</em> common it is an easy pattern to find bugs:</p>

<pre><code>int len = strlen(s);
char *new = malloc(len); /* FAIL */
</code></pre>

<p>If I don't see a <code>+ 1</code> in the <code>malloc(3)</code> call, it's almost certainly a bug. :) I prefer to see:</p>

<pre><code>int len = strlen(s);
char *new = malloc(len + 1);
</code></pre>

<p>rather than:</p>

<pre><code>int len = strlen(s) + 1;
char *new = malloc(len);
</code></pre>

<p>If you follow the former, I think it is far easier to spot the <em>wrong</em> cases when you forget the <code>+ 1</code>. I think the latter one is too easy to overlook the wrong ones amidst a sea of correct ones.</p>

<p>Similarly, your <code>c</code> and <code>ret-&gt;name</code> have been allocated too short.</p>

<p>But, I think there is a far easier answer:</p>

<pre><code>void concat_matrices( Matrix *A, Matrix *B, Matrix *ret ) {
        int len = strlen(A-&gt;name) + strlen(B-&gt;name) + 2 + 1; /* parens + NUL */
        ret-&gt;name = malloc(len);
        sprintf(ret-&gt;name, ""(%s%s)"", A-&gt;name, B-&gt;name);
        ret-&gt;R = A-&gt;R; ret-&gt;C = B-&gt;C;
        ret-&gt;dim = ret-&gt;R*ret-&gt;C;
}
</code></pre>

<p>Use <code>sprintf(3)</code> to build the string in one fell swoop. You only need to allocate one string, and that's the one you intend to <em>keep</em>, which will reduce memory fragmentation due to frequent allocate / deallocate cycles. But the most important reason for the re-write is I think this new version is easier to read. Note I broke my rule about the <code>+ 1</code> here -- clarity is improved by adding together <em>all</em> the memory required in one line.</p>

<p><strong>Update</strong></p>

<p>Your <code>clone_list()</code> function suffers from the same problem:</p>

<blockquote>
<pre><code>Matrix *m_copy = (Matrix*)malloc(sizeof(Matrix*));
char *c_copy = (char*)malloc(sizeof(char*)*strlen(tmp-&gt;M-&gt;name));

strcpy(c_copy,tmp-&gt;M-&gt;name);
</code></pre>
</blockquote>

<p>Your <code>m_copy</code> looks fine, because it is a binary object and the size is known exactly. But <code>c_copy</code> is allocated one byte too short -- it is not long enough to contain the <code>'\0'</code> byte that is copied into place with the <code>strcpy(3)</code> call immediately following. This routine too is scribbling over unallocated memory.</p>
",4
3191802,3191787,3,"<p>The <code>sizeof</code> of the parameter is not the character count of the string pointed to, because the parameter, despite its declaration form, is merely a pointer but not an array. Use <code>strlen</code> instead and notice that it does not include the terminating <code>\0</code> in its returned value (as opposed to <code>sizeof</code> when applied to a string array). </p>

<p>The string <code>""989010""</code> looks like a palindrome if you only take the first 3 characters of it, <code>""989""</code>. Since <code>sizeof</code> applied to a pointer yields <code>4</code> on your machine, it's only those first three characters that are inspected. </p>
",4
4163812,4163800,5,"<p>Since you attempt to read an integer (<code>%d</code>) with <code>scanf</code> and store it in a <code>char</code> variable, there is a memory overflow: a <code>char</code> is 1 byte while an <code>int</code> is (usually) 4. The result is that the memory area after the variables <code>M</code>, and then <code>Q</code>, gets overwritten. And this happens to affect <code>count</code> too.</p>

<p>Declare your variables as <code>int</code> to avoid this (or explicitly read <code>char</code> values with <code>scanf</code> - but if you want to multiply values, it is better to start with <code>int</code>s right away, to at least mitigate the risk of integer overflow).</p>
",0
4163819,4163800,3,"<p>Don't lie to the compiler.</p>

<p>You first said M is a char</p>

<pre><code>char A,M,...
</code></pre>

<p>and then tried to use it as an int</p>

<pre><code>scanf(""%d"",&amp;M);
</code></pre>

<p>Don't do that!</p>

<p>Either declare M (and the other variables) as int, or scanf a char</p>
",2
2653756,2653726,1,"<p>You'd have to find alternative libraries for string and memory handling, or code them up yourself. Considering all those libs, save for conio, are standard, I can't find a purpose for omitting them.</p>
",2
2074164,2054150,0,"<p>Interesting tangent to this question - I think I know a sort of clever answer to the question ""How many bits are set in this value""</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

uint8_t NumBitsSet(uint32_t value){
   uint8_t num_bits_set = 0;
   while(value != 0){
     value = value &amp; (value-1);
     num_bits_set++;
   }

   return num_bits_set;
}

int main(int argc, char *argv[]){
  uint32_t value = 2147483648;
  printf(""numbits set in %x = %d"", value, NumBitsSet(value));
  return 0;
}
</code></pre>

<p>You can use this as a basis for determining if <em>exactly</em> one bit is set, though you have to make a special check for zero.</p>

<pre><code>uint8_t exactly_one_bit_set = (value &amp; (value-1)) == 0 ? 1 : 0;
</code></pre>

<p>The trick here is that if a value has one bit set then one less than that value will have all the bits below that bit set and that bit cleared. and-ing those two things together will be always be zero.</p>
",0
2420694,2420685,7,"<p>The order of evaluation of arguments in a function call is unspecified.  The compiler can evaluate them in whichever order it might decide on.</p>

<p>From the C99 standard 6.5.2.2/10 ""Function calls/semantics"":</p>

<blockquote>
  <p>The order of evaluation of the function designator, the actual arguments, and
  subexpressions within the actual arguments is unspecified, but there is a sequence point
  before the actual call.</p>
</blockquote>

<p>If you need to ensure a particular ordering, using temporaries is the usual workaround:</p>

<pre><code>int i; 
for(i=0;i&lt;5;i++) {
    int tmp = i;
    int tmp2 = i++;

    res(tmp2,tmp);
}
</code></pre>

<p>Even more important (since it results in undefined behavior, not just unspecified behavior) is that you generally can't use an operand to the increment/decrement operators more than once in an expression.  That's because:</p>

<blockquote>
  <p>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored. (6.5/2 ""Expressions"")</p>
</blockquote>
",0
2420698,2420685,3,"<p>As per the standard: The order of argument evaluation is unspecified. Further, note that there are no sequence points (sort of mile-posts) when arguments are evaluated. Hence, modifying the same variable as part of the argument, more than once evokes undefined behavior. This is a <a href=""http://c-faq.com/expr/evalorder2.html"" rel=""nofollow noreferrer"">FAQ 3.2</a>. The code you have posted thus has ambiguous behavior.</p>

<p>It may be of surprise as to why the standard leaves this as unspecified: The simple reason being that this allows the compiler to perform some optimizations. (See discussion related to Q2 of <a href=""http://www.gotw.ca/gotw/056.htm"" rel=""nofollow noreferrer"">GOTW #56</a>.)</p>

<p>In most implementations though, this is determined by what is known as the calling convention. The calling convention not only determines the order, but also imposes the responsibility of cleaning up the stack either on the caller or the callee. </p>

<p>Also note, <code>main</code> always returns an <code>int</code>.</p>
",0
3571060,3571033,6,"<p>You probably use a hash of the values, maintaining a list of the hashes and the corresponding values, and only add a new pair to the <code>values_unique</code> array (which the question <s>does</s> originally did not declare as an array) if it is not found via the hash.  If the list is large, the speed up from hashing instead of searching through the entire list sequentially can be quite significant.</p>
",2
3571100,3571033,0,"<p>I know it's fairly annoying to suggest a different language but using C++ stl would be trivial.</p>

<pre><code>set&lt;values_t&gt; mySet();

for(int i=0; i &lt; number_of_values; i++)
{
    mySet.insert(values[i]);
}

values_t * values_unique = new values_t[mySet.size()];

int j=0;

for(set&lt;values_t&gt;::iterator i = mySet.begin(); mySet.end() != i; i++)
{
    values_unique[j] = *i;
    j++
}
</code></pre>
",1
3571192,3571033,1,"<p>It'll be something like this (Haven't been coding in C for long time, and code isn't tested):</p>

<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;

typedef struct {
  int value1;
  int value2;
} values_t;
values_t* values;
size_t values_size = 100;
values_t* values_unique;
size_t values_unique_size;
int valcmp(const values_t* a, const values_t* b)
{
    //a &lt; b -&gt; -1
    //a == b -&gt; 0
    //a &gt; b -&gt; 1
    return (a-&gt;value1 == b-&gt;value1) ? ((a-&gt;value2 == b-&gt;value2) ? 0 : ((a-&gt;value2 &lt; b-&gt;value2) ? -1 : 1)) : ((a-&gt;value1 &lt; b-&gt;value1) ? -1 : 1);
}
int main(void)
{
    values = malloc(values_size * sizeof(values_t));
    values_unique = malloc(values_size * sizeof(values_t));
    //fill the values table
    memcpy(values_unique, values, values_size * sizeof(values_t));
    qsort(values_unique, values_size, sizeof(values_t), valcmp);
    int i;
    //hopefully values_size &gt; 0
    for(i = 1, values_unique_size = 1; i &lt; values_size; ++i)
        if(valcmp(&amp;values_unique[i], &amp;values_unique[values_unique_size - 1]) != 0)
            values_unique[values_unique_size] = values_unique[i];
}
</code></pre>

<p>Same in c++:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

vector&lt;pair&lt;int,int&gt; &gt; V, V_unique;

int main()
{
    V_unique = V;
    sort(V_unique.begin(), V_unique.end());
    V_unique.resize(unique(V_unique.begin(), V_unique.end()) - V_unique.begin());
}
</code></pre>
",0
6105094,2745775,2,"<p>Seatest is the one I wrote for myself and open sourced.  The goal is to be simple, and to have a clean syntax.   </p>

<p><a href=""http://code.google.com/p/seatest/"" rel=""nofollow"">http://code.google.com/p/seatest/</a></p>

<p>a kind of basic simple test would be...</p>

<pre><code>#include ""seatest.h""
//
// create a test...
//
void test_hello_world()
{
    char *s = ""hello world!"";
    assert_string_equal(""hello world!"", s);
    assert_string_contains(""hello"", s);
    assert_string_doesnt_contain(""goodbye"", s);
    assert_string_ends_with(""!"", s);
    assert_string_starts_with(""hell"", s);
}

//
// put the test into a fixture...
//
void test_fixture_hello( void )
{
    test_fixture_start();      
    run_test(test_hello_world);   
    test_fixture_end();       
}

//
// put the fixture into a suite...
//
void all_tests( void )
{
    test_fixture_hello();   
}

//
// run the suite!
//
int main( int argc, char** argv )
{
    run_tests(all_tests);   
    return 0;
}
</code></pre>
",0
2091692,2091681,0,"<p>If you are have implemented a C program and you want to execute a script, you want to use a fork().  Unless you are willing to consider embedding the script interpreter in your program, you have to use fork() (system() uses fork() internally).</p>

<p>If you are running out of resources, most likely, you are not reaping your children.  Until the parent process get the exit code, the OS needs keeps the child around as a 'zombie' process.   You need to issue a <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/waitpid.html"" rel=""nofollow noreferrer"">wait()</a> call to get the OS to free up the final resources associated with the child.</p>
",0
2091694,2091681,0,"<p>A simple way is to use <code>popen</code> ( <a href=""http://www.opengroup.org/onlinepubs/007908799/xsh/popen.html"" rel=""nofollow noreferrer"">http://www.opengroup.org/onlinepubs/007908799/xsh/popen.html</a>), which returns a <code>FILE*</code>.</p>
",0
2091696,2091681,1,"<p>Here is some code for capturing the output of program; it uses exec() instead of system(), but that is straightforward to accomodate by invoking the shell directly:</p>

<p><a href=""https://stackoverflow.com/questions/1761950/how-can-i-implement-tee-programmatically-in-c/1761960#1761960"">How can I implement &#39;tee&#39; programmatically in C?</a></p>

<pre><code>void tee(const char* fname) {
    int pipe_fd[2];
    check(pipe(pipe_fd));
    const pid_t pid = fork();
    check(pid);
    if(!pid) { // our log child
        close(pipe_fd[1]); // Close unused write end
        FILE* logFile = fname? fopen(fname,""a""): NULL;
        if(fname &amp;&amp; !logFile)
                fprintf(stderr,""cannot open log file \""%s\"": %d (%s)\n"",fname,errno,strerror(errno));
        char ch;
        while(read(pipe_fd[0],&amp;ch,1) &gt; 0) {
                //### any timestamp logic or whatever here
                putchar(ch);
                if(logFile)
                        fputc(ch,logFile);
                if('\n'==ch) {
                        fflush(stdout);
                        if(logFile)
                                fflush(logFile);
                }
        }
        putchar('\n');
        close(pipe_fd[0]);
        if(logFile)
                fclose(logFile);
        exit(EXIT_SUCCESS);
    } else {
        close(pipe_fd[0]); // Close unused read end
        // redirect stdout and stderr
        dup2(pipe_fd[1],STDOUT_FILENO);  
        dup2(pipe_fd[1],STDERR_FILENO);  
        close(pipe_fd[1]);  
    }
}
</code></pre>
",0
2091705,2091681,0,"<p>You can try <a href=""http://www.opengroup.org/onlinepubs/007908799/xsh/popen.html"" rel=""nofollow noreferrer""><code>popen()</code></a>, but your fundamental problem is running too many processes.  You have to make sure your commands finish, otherwise you will end up with exactly the problems you're having.  <code>popen()</code> internally calls <code>fork()</code> anyway (or the effect is as if it did).</p>

<p>So, in the end, <em>you</em> have to make sure that the program you want to run from your threads exits ""soon enough"".</p>
",0
2091716,2091681,0,"<p>You want to use a sequence like this:</p>

<pre><code>Call pipe once per stream you want to create (eg. stdin, stdout, stderr)
Call fork
in the child
   close the parent end of the handles
   close any other handles you have open
   set up stdin, stdout, stderr to be the appropriate child side of the pipe
   exec your desired command
   If that fails, die.

in the parent
   close the child side of the handles
   Read and write to the pipes as appropriate
   When done, call waitpid() (or similar) to clean up the child process.
</code></pre>

<p>Beware of blocking and buffering.  You don't want your parent process to block on a write while the child is blocked on a read; make sure you use non-blocking I/O or threads to deal with those issues.</p>
",0
3050139,3050132,2,"<p><code>=</code> is the assigning operator, not the comparing operator. You are looking for <code>==</code>.</p>
",0
3050143,3050132,12,"<p>You should use single quotes for chars and do double equals for equality (otherwise it changes the value of c)</p>

<pre><code>if( c &gt;= 'A' &amp;&amp; c &lt;= 'Z'  || c == ' ' || c == ',') {
</code></pre>

<p>Furthermore, you might consider something like this to make your boolean logic more clear:</p>

<pre><code>if( (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')  || c == ' ' || c == ',') {
</code></pre>

<p>Although your boolean logic structure works equivalently (&amp;&amp; takes precedence over ||), things like this might trip you up in the future.</p>
",1
3050146,3050132,4,"<p>equality is <code>==</code>, <code>=</code> is assignment. You want to use <code>==</code>. Also <code>""""</code> is a <code>char*</code>, single quotes do a character. </p>

<p>Also, adding some parens to your condition would make your code much easier to read. Like so </p>

<pre><code> ((x == 'c' &amp;&amp; y == 'b') || (z == ',') || (z == ' '))
</code></pre>
",0
7381069,7381000,7,"<p>Where to start....</p>

<ol>
<li>NAME_MAX and PATH_MAX actually exist... you shouldn't define these yourself.</li>
<li>Dirent actually exists (<a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/dirent.h.html"" rel=""noreferrer"">struct dirent</a> from <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/dirent.h.html"" rel=""noreferrer"">dirent.h</a>), so use the existing <code>struct dirent</code>.</li>
<li>You aren't using braces consistently (always use braces), making your code unreadable.</li>
<li>You should be including &lt;dirent.h&gt;, not ""dirent.h"" (unless you have a specific reason to do so).</li>
<li>You need to forward-declare your functions before you use them.</li>
</ol>

<p>Also, in the future, it would be helpful to know:</p>

<ol>
<li>Your compiler.</li>
<li>Your operating system.</li>
<li>The errors emitted by your compiler.</li>
</ol>

<p>As the above can make it much easier to resolve your issues. More importantly, though, you mentioned that you are learning ""K&amp;R C"". Note that ""K&amp;R C"" predates the standardization of the C programming language by the International Standards Organization (ISO). Since K&amp;R C, there have been several iterations of ISO C: ISO C 1989 (a.k.a. C89), ISO C 1990 (a.k.a. C90), and ISO C 1999 (a.k.a. C99). I strongly suggest you teach yourself from a more up-to-date book.</p>

<p>Also, if you are targetting UNIX, I strongly recommend you get comfortable with the UNIX Manual Pages. The <a href=""https://chrome.google.com/webstore/detail/fngkomobalnoppphmglonpdgoonpdafh"" rel=""noreferrer"">UNIX Manual Pages chrome extension</a> makes it really easy to access the <a href=""http://pubs.opengroup.org/onlinepubs/009695399/"" rel=""noreferrer"">official IEEE Std. 1003.1 POSIX manual pages</a>. I strongly suggest you look at those to understand what standard functions are available, what is expected of the inputs, what is guaranteed of the outputs, and how they may fail.</p>
",6
7381156,7381000,2,"<p>Your specific problem is your homebrew <code>Dirent</code>. <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/readdir.html"" rel=""nofollow""><code>readdir</code></a> actually returns a <code>struct dirent *</code> and its layout does not necessarily match your <code>Dirent</code>, in particular there are probably more members before the <code>d_name</code>. So, when you look at your <code>dp-&gt;name</code> to get the name you probably end up trying to read some non-string as a string and that gives you nonsense; everything falls apart once you get nonsense.</p>

<p>So fix up everything that Michael Aaron Safyan mentioned, turn up your compiler's warning flags (<code>-Wall -Werror</code> is a good starting place for gcc), and your program should start working.</p>
",3
7381163,7381000,2,"<p>The problem is obvious when you look at the compiler warnings. At least on my system GCC gives:</p>

<pre><code>x.c: In function ¡®dirwalk¡¯:
x.c:58:16: warning: assignment from incompatible pointer type
</code></pre>

<p>This is the <code>while ((dp = readdir(dfd)) != NULL) {</code> line. As Michael has pointed out, <code>struct dirent</code> already exists and this is what is returned by <code>readdir</code>. You are using a custom, incompatible structure, this causes you to get garbage instead of file/dir names.</p>

<p>The quickest fix to make it work is to get rid of <code>Dirent</code> and use <code>struct dirent</code> instead.</p>
",0
7381195,7381000,5,"<p>The structure <code>Dirent</code> defined in your example probably doesn't match <code>struct dirent</code> for your system (it doesn't on mine).</p>

<p>On a Linux system the following will fix the problem:</p>

<pre><code>/* dirwalk: apply fn to all files in dir */
void dirwalk(char *dir, void (*fcn)(char *))
{
    char name[MAX_PATH];
    struct dirent *dp;

    DIR *dfd;

    if ((dfd = opendir(dir)) == NULL) {
            fprintf(stderr, ""dirwalk: can't open %s\n"", dir);
            return;
    }

    while ((dp = readdir(dfd)) != NULL) {
            if (strcmp(dp-&gt;d_name, ""."") == 0
                            || strcmp(dp-&gt;d_name, "".."") == 0)
                    continue;
            if (strlen(dir)+strlen(dp-&gt;d_name)+2 &gt; sizeof(name))
                    fprintf(stderr, ""dirwalk: name %s/%s too long\n"",
                                    dir, dp-&gt;d_name);
            else {
                    sprintf(name, ""%s/%s"", dir, dp-&gt;d_name);
                    (*fcn)(name);
            }
    }
    closedir(dfd);
}
</code></pre>

<p>The <code>readdir</code> function is system-specific, so you should consult the documentation for yours. On a Linux system you can type <code>man 2 readdir</code> in a terminal to see the online manual for the <code>readdir</code> function.</p>
",4
3457958,3457947,4,"<p>this is C89. in C99 you may declare them anywhere.</p>
",1
8306316,8306231,1,"<p>The <code>define</code> needs to be in a header file which you include in your malloctest.c file, that way the right malloc,free will be called. As it is now there is no effect since the define only works in mymalloc.</p>

<p>Just do a header with</p>

<pre><code>#define malloc(x) debug_malloc(x,__FILE__,__LINE__)
#define free(x) debug_free(x,__FILE__,__LINE__)
</code></pre>

<p>plus prototypes and include in malloctest.c</p>
",1
3437363,3437353,-1,"<p>Let's look at it piece by piece.</p>

<p><code>&amp;a</code> means the address of a.  So, it gets the address of the address of the integer 10.<br>
<code>&amp;a+1</code> is the next pointer over from that.  So it's the thing stored after the variable <code>a</code> in memory.  Bad idea.<br>
<code>&amp;a-1</code> is the thing stored before <code>a</code> in memory.  Again, bad idea.</p>

<p><code>*(a+1)</code> is the thing at the location pointed to by a, plus one integer.  That would be <code>a[1]</code>, or 20.<br>
<code>*(ptr-1)</code> is <code>a</code>, because <code>ptr</code> is <code>&amp;a+1</code>, so <code>ptr-1</code> is <code>&amp;a</code>.  It's the pointer value of <code>a</code>.  Printing it as <code>%d</code> is a mistake.  If you were to say <code>**(ptr-1)</code>, you'd get a more-meaningful <code>10</code> from the <code>printf</code>.<br>
<code>*(t+1)</code> is also <code>a</code>, as per the above but with the pluses and minuses switched.</p>
",8
3437401,3437353,4,"<p>All the problems come from the use of <code>&amp;a</code>, which is a pointer to ""an array of five integers"", so that pointer arithmetic (when you think in terms of addresses) gets ""scaled"" by <code>sizeof(a)</code> (which might e.g. be 20 if <code>int</code> are 4 bytes and the compiler needs no padding for alignment purposes -- reasonable hypotheses, though far from certain of course.</p>

<p>So, after</p>

<pre><code>int *ptr = (int *)(&amp;a+1);
int *t = (int *)(&amp;a -1);
</code></pre>

<p><code>ptr</code> is a pointer to int at the memory address ""sizeof(a) more than the address a"", and <code>t</code> similarly for ""sizeof(a) less than the address of a"".  Therefore...:</p>

<pre><code> printf(""%d  %d  %d \n"", *(a+1), *(ptr-1), *(t+1));
</code></pre>

<blockquote>
  <p>What should be the result?</p>
</blockquote>

<p>Quite possibly a segmentation violation, otherwise <code>20</code> followed by two completely arbitrary integer values.  Since <code>ptr</code> and <code>t</code> are pointers to <code>int</code>, the address arithmetic scaling for their <code>-1</code> and <code>+1</code> does <strong>not</strong> compensate that done on <code>&amp;a</code> (the scaling in terms of memory addresses is by <code>sizeof(int)</code>, not <code>sizeof(a)</code>!), so <code>ptr-1</code> and <code>t+1</code> are pointing to (alleged;-) <code>int</code>s that are respectively ""a few <code>int</code>s after the end of <code>a</code>"" and ""a few <code>int</code>s before the start of <code>a</code>"".</p>

<p>There's no way to know whether at those arbitrary addresses there is any memory which the process is allowed to address (whence the possibility for segmentation violatons), and, if any accessible memory <em>is</em> there, what its contents ""seen as an <code>int</code>"" might possibly be.</p>

<p><strong>Edit</strong>: @caf points out that <code>ptr - 1</code> is <em>not</em> invalid -- it correctly points to the last element of <code>a</code>; so the output (unless there's a segmentation fault, which @NullUserException thinks is very unlikely but on this point we disagree;-) would start with <code>20 50</code> before the third, ""arbitrary"" junk.  Point is, per the C standard, it <strong>is</strong> valid to compute (though not to use) the pointer ""just one past the end"" of an array, <strong>and</strong> the sizeof an array <strong>must</strong> be exactly that array's length time the sizeof its elements (padding is allowed for an element's type, if needed, and if so it shows in the element's own sizeof, but not for the <em>array</em> as a whole).  Subtle, but important;-).</p>
",16
3437403,3437353,0,"<p>""What should be the result""?</p>

<p>Next time you want to know what a tiny code snippet like this should do, check this out:
<a href=""http://ideone.com/4fCud"" rel=""nofollow noreferrer"">http://ideone.com/4fCud</a></p>

<p>The result I got out of that was:</p>

<blockquote>
  <p>20  50  134520820</p>
</blockquote>

<p><strong>Edit:</strong></p>

<p>When you run a program, see output like this, and find yourself asking, ""where did <em>that</em> value come from?"" you may have run into undefined behavior.</p>

<p>In this case the third value doesn't point to where you might think it would point.  It is reading uninitialized memory (most likely), memory owned by code that is in your process space, but outside your program (a library you loaded, or the C runtime), or memory that simply has nothing to do with this program (less likely, because of protected memory).</p>
",5
3437416,3437353,6,"<p>Since the type of <code>a</code> is <em>array-of-5-<code>int</code>s</em>, that means that the type of <code>&amp;a</code> is <em>pointer-to-array-of-5-<code>int</code>s</em>.</p>

<p>When you add or subtract 1 from a pointer, you ask it to point to the next or previous object of that type in memory.  So <code>&amp;a+1</code> is creating a pointer to the array-of-5-<code>int</code> immediately after <code>a</code> in memory (which doesn't exist), and <code>&amp;a-1</code> is creating a pointer to the array-of-5-<code>int</code> immediately before <code>a</code> in memory (which also doesn't exist).  In memory, it looks like this (where each cell represents one <code>int</code>):</p>

<pre><code>Address:    &amp;a-1                      &amp;a                      &amp;a+1
Contents:  | ?  | ?  | ?  | ?  | ?  | 10 | 20 | 30 | 40 | 50 | ?  | ?  | ?  | ?  | ?  |
</code></pre>

<p>When <code>a</code> is used in the expression <code>*(a+1)</code>, it is converted to a pointer to its first element - so a pointer-to-<code>int</code> pointing at the <code>10</code> value.  Adding one to it then makes a pointer pointing at the next <code>int</code> - <code>a+1</code> points at the <code>20</code> value.  <code>*(a+1)</code> then fetches that value, so the first number printed is 20.</p>

<p>As <code>ptr</code> is also a pointer-to-<code>int</code>, that means that <code>ptr - 1</code> creates a pointer to the <code>int</code> immediately before <code>ptr</code> - in this case, it'll be pointing at the 50.  So the second number printed is 50.</p>

<p>Similarly, <code>t + 1</code> creates a pointer to the <code>int</code> immediately after <code>t</code> - in this case, it's the second <code>?</code> in the above diagram.  This is an uninitialised value - it could print anything at all, or even crash the program.</p>

<pre><code>Address:    &amp;a-1                      &amp;a                       &amp;a+1
            t    t+1                  a   a+1            ptr-1 ptr
Contents:  | ?  | ?  | ?  | ?  | ?  | 10 | 20 | 30 | 40 | 50  | ?  | ?  | ?  | ?  | ?  |
</code></pre>
",3
3245513,3245509,15,"<p>Assuming you mean the pair of characters, <code>\n</code>, as opposed to a newline character:</p>

<pre><code>printf(""\\n"");
</code></pre>
",0
3245517,3245509,5,"<p><code>printf(""\\n"");</code> <a href=""http://msdn.microsoft.com/en-us/library/h21280bw(VS.80).aspx"" rel=""nofollow noreferrer"">Escape sequence</a> <code>\\</code> represents <code>\</code></p>
",1
3245521,3245509,3,"<p>How about</p>

<pre><code>#error ""\\n""
</code></pre>
",0
3245525,3245509,6,"<p>Depends what you need.</p>

<p>Either:</p>

<pre><code>printf(""\\n""); /* prints \n */
</code></pre>

<p>or:</p>

<pre><code>printf(""\n"");  /* prints newline */
</code></pre>
",0
3245529,3245509,3,"<p>You can use <code>\\n</code> to print <code>\n</code></p>

<pre><code>printf( ""\\n""  );
</code></pre>

<blockquote>
  <p>\n</p>
</blockquote>
",0
3245571,3245509,0,"<pre><code>putchar('\\');
putchar('n');
</code></pre>
",1
3245677,3245509,-1,"<p>You can use escape char <code>\</code> <code>printf(""\\n"");</code></p>
",0
3249882,3249820,0,"<p>I agree with Steven's comment but as a hint, since you need to count occurrences you'll need to iterate through the entire thing anyway.</p>
",0
3249891,3249820,3,"<p>With a text editor.</p>

<p>Notepad++ is quite nice, but really anything will do.</p>
",2
3249896,3249820,0,"<p>A simple solution is to declare an array of numeric counts and using the number read as the index.  You may have to offset the index if you deal with negative numbers:</p>

<pre><code>unsigned int number_counts[1000] = {0};

//...

number_counts[num]++;

// or 
number_counts[num + 500]++;
</code></pre>

<p>If you are using a linked list, add a <em>count</em> field and increment that.</p>
",0
2928619,2928575,0,"<p>From the man-page:</p>

<p>time_t time(time_t *t);</p>

<p>""If t is non-NULL, the return value will also be stored in the memory pointed to by t.""</p>

<p>I guess it's just legacy stuff.</p>
",1
2928621,2928575,1,"<p>Most examples I've seen pass <code>NULL</code>. I likewise see no benefit in passing a meaningful pointer, especially since <code>time_t</code> is pretty much always just an integral type.</p>
",0
2928650,2928575,8,"<p>The benefit would be that you do not have to copy the data into another structure after calling 'time'. </p>

<p>If you are e.g. preparing a buffer of data to send to another application/server you would have to copy the data, which is additional overhead. By passing a pointer into your data structure you could put it right in the correct place in one shot.</p>

<p>Of course if your only use for the data is to convert it to another format such as a text printf, then it is more efficient to call it with NULL and save the additional storage required by your first example.</p>

<p>Lastly since the time function uses a single location for storage of it's internal time structure the first method would be more thread-safe, although I cannot remember of the top of my head if 'time' is in fact thread safe.</p>
",0
2931731,2928575,0,"<p>Pointer to time_t value passed as a function argument -- 
IMO that is one reason why the syntax exists.</p>

<pre><code>time_t *foo(time_t *dest)
{
     time(dest);
     /* do something with dest here */
     return dest;
}
</code></pre>
",0
4729388,4728996,1,"<p>Finally I found the error....</p>

<p>msdn says</p>

<blockquote>
  <p>You can use fseek to reposition the
  pointer anywhere in a file. The
  pointer can also be positioned beyond
  the end of the file. fseek clears the
  end-of-file indicator and negates the
  effect of any prior ungetc calls
  against stream.</p>
  
  <p>When a file is opened for appending
  data, the current file position is
  determined by the last I/O operation,
  not by where the next write would
  occur. If no I/O operation has yet
  occurred on a file opened for
  appending, the file position is the
  start of the file.</p>
  
  <p><strong>For streams opened in text mode, fseek has limited use, because
  carriage return¨Clinefeed translations
  can cause fseek to produce unexpected
  results.</strong> The only fseek operations
  guaranteed to work on streams opened
  in text mode are:</p>
  
  <p>Seeking with an offset of 0 relative
  to any of the origin values. Seeking
  from the beginning of the file with an
  offset value returned from a call to
  ftell.</p>
</blockquote>

<p>once fopen call is modified from ""r"" to ""rb"" it worked fine....</p>

<p>thanks</p>
",0
4729171,4728996,9,"<p>According to <a href=""http://cplusplus.com/reference/clibrary/cstdio/fpos_t/"" rel=""noreferrer"">the cplusplus.com description of <code>fpos_t</code></a>:</p>

<blockquote>
  <p><code>fpos_t</code> objects are usually created by a call to <code>fgetpos</code>, which returns a reference to an object of this type.  The content of a <code>fpos_t</code> is not meant to be read directly, but only to use its reference as an argument in a call to <code>fsetpos</code>.</p>
</blockquote>

<p>I think that means that in theory the value of an <code>fpos_t</code> could be arbitrarily positive or negative, so long as the implementation treats it correctly.  For example, <code>fpos_t</code> could be some offset from the <em>end</em> of the file rather than the beginning, in which case negative values make sense.  It also could be some weird bit-packed representation that would use each bit, including the sign bit, to encode some other information about the file position.</p>
",1
4609744,4606297,1,"<p>Wrapping the list struct in another struct is a good way to handle this.  There should not be any extra runtime overhead or memory usage because the alignment and padding requirements should be exactly the same for the inner and outer structs (since the outer structs' alignment and padding come only from the inner struct).</p>

<p>As far as the functions/methods that work on them you can use <code>inline</code> to do away with any overhead that would be incurred for cases where a stack or queue function is just a simple renaming (or a special calling) or a list function.</p>

<pre><code>inline void queue_dispose(queue **Q, void (*free_content)(void *)) {
      list_dispose(&amp;&amp;(*Q-&gt;base), free_content);
}
</code></pre>

<p>This will make sure that you get the same level of type checking, but without runtime over head or extra code.  You shouldn't run into problems unless you are using pointers to these functions, and if you are then you can include a regular implementation for them as well.</p>

<p>You should notice that putting a node pointer in the list struct as the sole member was already an application of the same thing as wrapping a list up in a stack or queue structure.</p>
",0
4607027,4606297,0,"<p>If you¡¯re OK with less type-checking by the compiler, you could use <code>typedef</code>s rather than wrapping structures, <em>e.g.</em>,<br>
<code>typedef struct queue list</code><br>
<code>#define queue_create list_create</code><br>
or<br>
<code>inline queue *queue_create() {return (queue *) list_create</code><br>
¡ªthis latter option is requires C99 or extensions to C89.</p>

<p>If you have the <code>inline</code> keyword, you can also wrap the operation in a macro:</p>

<pre><code>#define WRAP_LIST(wrapper)                                  \
    struct wrapper {linked_list *root;};                    \
    inline struct wrapper *wrapper ##_create {              \
        ¡­                                                   \
        tmp_queue-&gt;base = list_create();                    \
        ¡­                                                   \
    }                                                       \
    ¡­                                                       \
    typedef struct wrapper wrapper
// note lack of ¡®;¡¯ at end of last line

WRAP_LIST(queue);
WRAP_LIST(stack);
</code></pre>

<p>(Or use C++.)</p>
",0
4611461,4606297,1,"<p>This approach is fine, except that there is no need for the <code>linked_list</code> structure - it is an unnecessary level of indirection.  A list is entirely described by its head pointer, so you only need to include the head pointers in your stack and queue:</p>

<pre><code>typedef struct queue
{
    list_node *queue_head;
} queue;

typedef struct stack
{
    list_node *stack_head;
} stack;
</code></pre>

<p>Seperate structs are quite appropriate - for example, a stack only needs a head pointer, but a queue is more efficient if it has both a head and tail pointer to the list.</p>
",1
2048892,2048854,4,"<p>Follow the following algo and implement it.</p>

<ol>
<li>Run a loop for all the letters in
string.</li>
<li>Store the first character in a temp
char variable.</li>
<li>For each change in character
initialize a counter with 1 and
print the count of previous
character and then the new letter.</li>
</ol>
",0
2048909,2048854,0,"<p>Something like this:</p>

<pre><code>void so(char s[])
{
        int i,count;
        char cur,prev;

        i = count = prev = 0;
        while(cur=s[i++])
        {
                if(!prev)
                {
                        prev = cur;
                        count++;
                }
                else
                {
                        if(cur != prev)
                        {
                                printf(""%c%d"",prev,count);
                                prev = cur;
                                count = 1;
                        }
                        else
                                count++;
                }
        }

        if(count)
                printf(""%c%d"",prev,count);
        printf(""\n"");
}
</code></pre>
",0
2048925,2048854,1,"<p>Damn, thought you said C#, not C.  Here is my C# implementation for interest's sake.</p>

<pre><code>    private string Question(string input)
    {
        var output = new StringBuilder();
        while (!string.IsNullOrEmpty(input))
        {
            var first = input[0];
            var count = 1;
            while (count &lt; input.Length &amp;&amp; input[count] == first)
            {
                count++;
            }

            if (count &gt; input.Length)
            {
                input = null;
            }
            else
            {
                input = input.Substring(count);
            }
            output.AppendFormat(""{0}{1}"", first, count);
        }

        return output.ToString();
    }
</code></pre>
",4
2531303,2531295,1,"<p>Use the Modulus operator:</p>

<pre><code> remainder = 163 % 10; // remainder is 3
</code></pre>

<p>It works for any number too:</p>

<pre><code>  remainder = 17 % 8;  // remainder is 1, since 8*2=16
</code></pre>

<p>(This works for both C and C#)</p>
",0
2531304,2531295,1,"<p>With the <a href=""http://en.wikipedia.org/wiki/Modular_arithmetic"" rel=""nofollow noreferrer"">modulus</a> operator (<code>%</code>):</p>

<pre><code>15 % 12 == 3
17 % 8 == 1
</code></pre>
",2
2531306,2531295,4,"<p>It looks like homework so I won't give you code, but I suggest you research the <a href=""http://en.wikipedia.org/wiki/Modulo_operation"" rel=""nofollow noreferrer"">modulo operator</a> and how this could be used to solve your assignment.</p>
",0
2321691,2253166,0,"<p>My guess is that you have a integer and you're attempting to convert it to binary?</p>

<p>And the ""answer"" is ABCDEFG, but your ""answer"" is GFEDCBA?</p>

<p>If so, I'd double check the endian of the machine you're doing it on and the machine the ""answer"" came from. </p>
",0
7813343,7813316,-1,"<p>Yeah, that's a function that returns a pointer to an <code>int</code>. It would be a bit easier to get if it were written as <code>int* x();</code>.</p>
",1
7813344,7813316,2,"<p>This is a function declaration. pmg explained the difference between a function declaration and a function prototype in his comment.</p>

<p>The function returns a pointer to a variable which has int as data type.</p>
",0
7813363,7813316,9,"<p>In C, that would be a declaration of a function returning a pointer-to-int and takes an unspecified number of arguments. The declaration of a function that takes no arguments would be <code>int *x(void);</code></p>
",3
2531357,2531351,5,"<p>divide by 10 in a loop and take the modulo?  </p>
",0
2531469,2531351,0,"<p>It turns out that you do actually want to use a string. What you want to do is read a string as input and then break it down into the various segments. You would find the first 3 digits and turn it into an integer in n1, then read the next 2 digits and turn them into n2, etc.</p>
",0
3482027,3482023,1,"<p>It's undefined behavior, so the only real explanation is ""It does some things on one machine and other things on other machines"".  </p>

<p>Also, what's with the K&amp;R function syntax?</p>

<p>EDIT: The <code>printf</code> guess was wrong.  As far as the syntax, read K&amp;R 2nd Edition (the cover has a red ANSI stamp), which uses modern function syntax (among other useful updates).</p>
",4
3482034,3482023,2,"<p>There is a problem there, in that you declare 'array' as an array of length 1 but you write 3 values to it. It should be at least 'array[3]'. Without that, you are writing to unallocated memory, so anything could happen.</p>

<p>The reason it outputs '3' there without the fix is that it is outputting the value of the global 'index' variable, which is the next int in memory (in your case - as I said anything could happen). Even though you do overwrite this with your <code>put(10)</code> call, the index value is used in as the index in the assignment and then post-incremented, which will set it back to 2 - it then gets set to 3 at the end of the <code>put(100)</code> call and subsequently output via printf.</p>
",2
3482078,3482023,0,"<p>To expand on what has been said, accessing out-of-bounds array members results in undefined behavior. Undefined behavior means that literally <a href=""http://www.catb.org/jargon/html/N/nasal-demons.html"" rel=""nofollow noreferrer"" title=""anything"">anything</a> could happen. There is no way to exploit undefined behavior unless you're deep into esoteric platform-specific hacks. Don't do it.</p>

<p>If you do want a ""dynamic array"", you'll have to take care of it yourself. If your requirements are simple, you can just <code>malloc</code> and <code>realloc</code> a buffer. If your needs are more complicated, you might want to define a struct that keeps a separate buffer, a size, and a count, and write functions that operate on that struct. If you're just learning, try it both ways.</p>

<p>Finally, your function declaration syntax is valid, but archaic. That form is rarely seen, and virtually unheard of in new code. Declare <code>put</code> as:</p>

<pre><code>int put(int x) {¡­}
</code></pre>

<p>And always declare <code>main</code> as:</p>

<pre><code>int main(int argc, char **argv) {¡­}
</code></pre>

<p>The names of <code>argc</code> and <code>argv</code> aren't important, but the types are. If you forget those parameters, demons could fly out of your nose.</p>
",3
2659810,2659741,2,"<p>You could use <a href=""http://msdn.microsoft.com/en-us/library/ms724265.aspx"" rel=""nofollow noreferrer"">ExpandEnvironmentStrings</a>.</p>
",2
2391462,2391287,0,"<p>or use more generic function to write a single bit into buffer (char array)
`</p>

<pre><code>void setBitAt( char* buf, int bufByteSize, int bitPosition, bool value )
{
    if(bitPosition &lt; sizeof(char)*8*bufByteSize)
    {
        int byteOffset= bitPosition/8;
        int bitOffset = bitPosition - byteOffset*8;

        if(value == true)
        {
             buf[byteOffset] |=  (1 &lt;&lt; bitOffset);
        }
        else
        {
             buf[byteOffset] &amp;= ~(1 &lt;&lt; bitOffset);;
        }
    }
}
</code></pre>

<p>`</p>
",0
2391657,2391287,1,"<p>Are you asking, ""How to convert an [u]int-stream into a byte-string?""</p>

<p>Then you can try this:</p>

<pre><code>1. Pick next integer x = uint[i]
2. Get four bytes out of it as
 b4 = x &amp; 0xFF000000
 b3 = x &amp; 0x00FF0000
 b2 = x &amp; 0x0000FF00
 b1 = x &amp; 0x000000FF
3. Write the four bytes into the stream s, e.g.
 s &lt;&lt; b4 &lt;&lt; b3 &lt;&lt; b2 &lt;&lt; b1;
4. i += 1
5. Go to 1
</code></pre>
",0
2391443,2391287,1,"<p>write a function of converting a numbers into an string ( character array ) 
steps : 
      1.divide a integer number by 2 and store the modulus value in a character array.
      2.subtract the quotient value with an integer and store the result in the same integer
      3. keep on doing the step 1 and 2  until the integer value becomes zero. </p>

<p>Hope that this would be the simple conversion program</p>
",0
3719178,3719150,3,"<p>Operator precedence is hurting you.</p>

<p>The macro is expanded by the pre-processor such that </p>

<pre><code>  i=4/4*4;
  j=64/4*4;
</code></pre>

<p>which is equivalent to:</p>

<pre><code>  i=(4/4)*4;
  j=(64/4)*4;
</code></pre>
",0
3719183,3719150,2,"<p><code>j = 4/square(4) == 4/4*4 == 1*4 == 4</code></p>
",0
3719185,3719150,5,"<p>When you write <code>i=4/square(4)</code>, the preprocessor expands that to <code>i = 4 / 4 * 4</code>.<br>
Because C groups operations from left to right, the compiler interprets that as <code>i = (4 / 4) * 4</code>, which is equivalent to <code>1 * 4</code>.</p>

<p>You need to add parentheses, like this:</p>

<pre><code>#define square(x) ((x)*(x))
</code></pre>

<p>This way, <code>i=4/square(4)</code> turns into <code>i = 4 / ((4) * (4))</code>.<br>
You need the additional parentheses around <code>x</code> in case you write <code>square(1 + 1)</code>, which would otherwise turn into <code>1 + 1 * 1 + 1</code>, which is evaluated as <code>1 + (1 * 1) + 1</code>, or <code>3</code>.</p>
",0
3719186,3719150,4,"<pre><code>i=4/square(4);
</code></pre>

<p>expands to </p>

<pre><code>i=4/4*4; 
</code></pre>

<p>which equivalent to</p>

<pre><code>i=(4/4)*4;
</code></pre>
",0
3719192,3719150,1,"<p>Manually expand the macro in the code, and it will be clear. That is, replace all the square(x) with exactly x*x, in particular don't add any parentheses.</p>
",0
3719193,3719150,32,"<p><code>square</code> is under-parenthesized: it expands textually, so</p>

<pre><code>#define square(x) x*x
   ...
i=4/square(4);
</code></pre>

<p><strong>means</strong></p>

<pre><code>i=4/4*4;
</code></pre>

<p>which groups as <code>(4/4) * 4</code>.  To fix, add parentheses:</p>

<pre><code>#define square(x) ((x)*(x))
</code></pre>

<p>Still a very iffy <code>#define</code> as it evaluates <code>x</code> twice, so <code>square(somefun())</code> calls the function twice and does <em>not</em> therefore necessarily compute a square but rather the product of the two successive calls, of course;-).</p>
",1
3719196,3719150,1,"<p>define is just a text macro</p>

<pre><code>main()
{
      int i,j;
      i=4/ 4 * 4;  // 1 * 4
      j=64/4 * 4; // 16 * 4
      printf(""\n %d"",i);
      printf(""\n %d"",j);
      printf(""\n %d"",square(4));
      getch();
}
</code></pre>
",0
3719199,3719150,1,"<p>It's a macro! So it returns <em>exactly</em> what it substitutes.</p>

<pre><code>i = 4/4*4;   Which is 4...
j = 64/4*4;   Which is 16...
</code></pre>

<p>Try this for your macro:</p>

<pre><code>#define square(x) ((x)*(x))
</code></pre>
",0
3719204,3719150,1,"<p>Because of operator precedence in the expression after the preprocessor - you'll need to write </p>

<pre><code>#define square(x) (x*x)
</code></pre>
",0
3719207,3719150,1,"<p>As the other answers say, you're getting burned by operator precedence.  Change your square macro to this:</p>

<pre><code>#define square(x) (x*x)
</code></pre>

<p>and it'll work the way you expect.</p>
",0
3719230,3719150,3,"<p>That's because the compiler replaces it with:</p>

<pre><code>i=4/4*4; 
j=64/4*4;
</code></pre>

<p>i = (4/4)*4 = 1*4 = 4.</p>

<p>j = (64/4)*4 = 16*4 = 64.</p>
",0
3745137,3745129,1,"<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);
</code></pre>
",0
3745141,3745129,8,"<p>There's no such command built into the language. Sockets need to be used but they are platform dependent.</p>
",2
3745155,3745129,1,"<p>On <a href=""http://msdn.microsoft.com/en-us/library/ms741394%28v=VS.85%29.aspx"" rel=""nofollow noreferrer"">Winsock</a>, that would be <code>connect()</code>, but socket needs to be created first.</p>
",0
3745210,3745129,6,"<p>There's no single C ""command"" (rather, function) to ""open"" a connection to a remote host.</p>

<p>First, you need a socket, this is provided by the <code>socket()</code> function (see your documentation for relevant header files). Then, you need to call <code>connect()</code> to establish the connection. However, that requires that all host names have been resolved, so you may have had to call <code>gethostbyname()</code> or similar, to turn a hostname into an IP address.</p>
",0
3228355,3228330,9,"<p>main.c:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    #include ""include.h""

    return EXIT_SUCCESS;
}
</code></pre>

<p>include.h:</p>

<pre><code>#include ""nested.h""
</code></pre>

<p>nested.h:</p>

<pre><code>printf(""yes.\n"");
</code></pre>
",4
3228343,3228330,14,"<pre><code>#include &lt;stdio.h&gt;
int main() {
  puts(""Yes"");
  return 0;
}
</code></pre>
",0
8403577,8403540,6,"<p>Actually you <strong>do</strong> have to free <code>mStack</code> <em>somewhere</em> or you will leak memory. If <code>StackDestroy</code> doesn't do it for you, you'll have to do it yourself later.</p>

<p>When designing an API that allocates and frees stuff think of a few things:</p>

<ul>
<li>Did the client allocate the object ? Perhaps he should also free it. Is it possible he passed an object that wasn't obtained via <code>malloc</code> ?</li>
<li>Can the client do useful things with the object beyond the demise of our object ?</li>
</ul>

<p>In your case the client doesn't even know about the existence of <code>mStack</code> (technically you could use opaque objects) so, since <em>you</em> allocate it, you should also free it.</p>
",2
2203150,2203116,1,"<p>Yes, a union does overlap members, so changing one can have the side-effect of changing another.  That's kind of the point.</p>
",0
2203151,2203116,0,"<p>You seem to be laboring under a misapprehension.</p>

<p>Assigning a new value of a different type <em>does</em> overwrite the existing data.</p>
",0
2203158,2203116,0,"<p>It's nothing more than a way to <em>view</em> or <em>interpret</em> the memory underlying the union structure. i.e. are these 4 bytes an integer, or a pointer, or contribute to a double etc ? (for example). Consequently, writing to your int will affect your pointer value, or your double.</p>

<p>And yes - writing a value in will overwrite the previous value - just like a normal struct (or anything else).</p>
",2
2203161,2203116,3,"<p>I think you might be confused about what a <code>union</code> is.</p>

<p>These MSDN pages <a href=""http://msdn.microsoft.com/en-us/library/y9zewe0d.aspx"" rel=""nofollow noreferrer"">here (c)</a> and <a href=""http://msdn.microsoft.com/en-us/library/5dxy4b7b.aspx"" rel=""nofollow noreferrer"">here (C++)</a> go into more detail but basically a union is a mechanism where <em>the same memory address</em> can be referenced in different ways depending on the circumstances:</p>

<pre><code>union sign   /* A definition and a declaration */
{
    int svar;
    unsigned uvar;
} number;
</code></pre>

<blockquote>
  <p>This example defines a union variable
  of type sign and declares a variable
  named number that has two members:
  svar, a signed integer, and uvar, an
  unsigned integer. This declaration
  enables the current value of number to
  be stored as either a signed value or
  an unsigned value. The tag that is
  associated with this union type is
  sign.</p>
</blockquote>
",0
2203164,2203116,3,"<p>You are right. Memory <em>is</em> overwritten since all elements share the same space. Take a look at this:</p>

<pre><code>union foo{
    int i;
    char[4] carr;
};
</code></pre>

<p>Assuming integer is 4 bytes and char is 1 byte, if you modify the integer, all the four elements of the char array will be modified.</p>

<p>I would strongly suggest writing your own small code (with appropriate <code>printf</code>s) to understand the working of union. You will learn faster that way.</p>
",0
2203218,2203116,0,"<p><strong>They are overwritten</strong>, i.e. every time you assign one union member you change the other. That is actually the intent of the union in C - to be able to have different <em>typed</em> views on the <em>same bits in memory</em>. Classic example is checking the <a href=""http://en.wikipedia.org/wiki/Endiannes"" rel=""nofollow noreferrer"">endiannes</a> of the platform at runtime (silly but illustrative):</p>

<pre><code>union duo
{
    uint16_t short_;
    uint8_t  bytes[2];

} the_duo;

/* will assign either bytes[0] or bytes[1]
 * depending on the architecture */
the_duo.short_ = 1;

if ( the_duo.bytes[0] )
    printf( ""little endian\n"" );
else if ( the_duo.bytes[1] )
    printf( ""big endian\n"" );
else
    printf( ""where am i?\n"" );

</code></pre>
",0
3248702,3248658,0,"<p>Yes, deleting the file from the FS has nothing to do with what your C program will see.  And any malloc that isn't freed is freed at program termination.  FYI, it's kinda dangerous to be writing C code without understanding those basics, you may want to do some reading or try something like python or even java that will hide those responsibilities from you first.</p>

<p>But you should understand stack, heap, virtual memory, and i/o, and pass by value vs pass by reference (pointer) to start being effective in C.  Understand what a buffer overflow is.  There's a lot to learn.</p>
",3
3248738,3248658,0,"<p>When a program is terminated, the OS will free up all the resources it allocated the program. In your case, the memory leak would be within the program's allocated memory, and after it's finished, the OS will reclaim all that memory that was ""leaked"".</p>
",0
3248741,3248658,0,"<p>Also you should note here that when you allocate memory in a multi-process environment and don't free the memory and continue execution, it results in <strong>serious</strong> performance degradation of the system. This leaves other process less memory for allocation as your process will have eaten up the memory and not freed it.
Hence its always advised to free the memory after use. We should not wait till the process has finished execution.</p>
",0
3248679,3248658,4,"<p>A memory leak will only continue as long as the program is running. Once the program exits, the operating system should free up the memory for you, even if you didn't. There is no need to delete any files from your haddisk.</p>

<p>I believe you are confused about the differences between storing something on disk and in memory.</p>

<p>For example, when you have <code>int x = 4;</code>, <code>x</code> is stored in RAM. This is not the same place your files, such as word documents, are stored. If you reboot your computer, this <code>x</code> is lost. Also, when your program stops running, the operating system cleans up the space that <code>x</code> was taking up.</p>

<p>When a program is leaking memory, it is basically taking up more RAM than it actually needs, and as time goes on it will bloat in size. However, once the program stops running, the operating system cleans it all up since it is no longer being used. There are no permanent effects.</p>
",0
4616712,4616687,0,"<p>Pointer error. You're trying to read/write an undefined pointer - do a find and replace for free(x) -> free(x);x=NULL.</p>

<p>Edit: Should also check for assignment; are you doing anything like this?</p>

<pre><code>int *a;
a++;
</code></pre>
",0
4533650,4533435,2,"<p>You have several issues in your code besides the one Tim already found:</p>

<blockquote>
  <p>printf(""Enter a directory
  %s\n"",userd);</p>
</blockquote>

<p>uses an uninitialized variable.</p>

<pre><code>printf(""the dir is %s\n"",*userd);
</code></pre>

<p>Even unnecessary dereferences the uninitialized variable.</p>

<p>The code around <code>scandir(""."",&amp;namelist,0,alphasort);</code> looks ok (at first sight).</p>
",0
4533689,4533435,1,"<p>First of all you ask the user for some input, and then (simply speaking) use the directory the program exists. I think you want to do something else and that is</p>

<p><code>int i = scandir( userd, &amp;namelist , 0 , alphasort);</code></p>

<p>I wonder what happen if someone enters data bigger than <code>20</code> (which is the size of <code>userd</code>) <code>;)</code></p>

<p>AFAIK the <code>free(namelist); and free(namelist[j]);</code> you do are alright since you have double pointer and <code>malloc()</code> is done inside the <code>scandir()</code> But not terminating the program after <code>i&lt;0</code> is a bit bad since it would just jump to <code>free(namelist);</code> which would yield <code>undefined behaviour</code> (In my computer : <code>*** glibc detected *** free(): invalid pointer:</code>). You can as well add the <code>free()</code> only in the <code>else</code> part.</p>

<p>This is the code I think you are looking for :</p>

<pre><code>#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;

int main()
{
    char userd[20];
    int i,j;
    struct dirent ** namelist;
    //struct stat statBuf; //Unused
    printf(""Enter a directory : "",userd);
    scanf(""%s"",userd);
    printf(""the dir is %s\n"",userd);

    //Uncomment this if you want the directory from the User Input
    //i = scandir( userd, &amp;namelist , 0 , alphasort); 
    i = scandir( ""."" , &amp;namelist , 0 , alphasort);

    //printf(""enter a directory name : "");
    printf(""scandir returned i=%d\n"",i);

    if (i &lt; 0)
    {
        perror(""Scandir failed to open directory I hope you understand \n"");
        return -1;
    }
    else
    {   

        for( j=0 ; j&lt;i ; j++)
        {
            printf(""j=%d i=%d %s\n"",j,i,namelist[j]-&gt;d_name);
            free(namelist[j]);
        }
        free(namelist); 
    }

    return 0;
}
</code></pre>
",0
4533484,4533435,1,"<pre><code>scanf(""%s"",&amp;userd); 
</code></pre>

<p>Should be</p>

<pre><code>scanf(""%s"", userd);
</code></pre>
",0
3690890,3690867,1,"<p>It is possible to place a terminator at the end, but the end result might be Hello World! and a long string of garbage after that.</p>

<p>Bytes are always chars. If you wanted to accept only printable characters (which the garbage at the end might contain, anyway) you could read the input one character at a time and check if each byte's value is between <code>0x20</code> and <code>0x7E</code>.</p>

<p>Although that's only guaranteed to work with ASCII strings...</p>
",1
3690892,3690867,8,"<p><code>read()</code> returns the number of characters that were actually read into the buffer (or &lt;0 in the case of an error). Hence the following should work:</p>

<pre><code>int n;
char *var = malloc(100 + 1);
n = read(0, var, 100);
if(n &gt;= 0)
   var[n] = '\0';
else
   /* error */
</code></pre>
",0
2951710,2951704,4,"<p>The <code>malloc</code> function should only be used if you need the struct to live past the lifetime of the current function.  The <code>malloc</code> function will allocate memory off of the heap which allows it to be long lived.  This is useful if you need to store items after the exiting of the function (in a shared list for instance).  </p>

<p>It also introduces extra overhead including ...</p>

<ul>
<li>Forcing more error checking into your code</li>
<li>Separation of allocation and initialization of the structure</li>
<li>Overhead in the process to track the memory</li>
</ul>

<p>On the other hand the second syntax allocates the memory on the stack.  This is beneficial because the memory here is automatic in the sense that you don't have to think about it.  The memory is freed so to speak when the function exits.  Additionally it allows for a single statement for allocation and initialization.  </p>

<p>The one exception to this rule is for structs which are big enough to potentially cause the stack to overflow.  The stack is a limited resource and big structs can cause it to be exhasted.  The heap generally speaking has more room and can easily accommodate these larger structures.  </p>
",2
2951711,2951704,6,"<p>It is not the same memory, the former is allocated on heap and the latter is allocated on stack.</p>

<p>Heap enables you to manually control the creation and deletion, with all pros and cons: you may pass the pointer to others, but you have to delete it also.</p>

<p>Whenever the second is at all possible, it is preferred.</p>
",5
2951782,2951704,1,"<p>In addition to the other very useful answers, there is one more key difference.</p>

<p>The malloc() method leaves the structure members uninitialized.  You have to initialize them in a separate step.</p>
",0
2951801,2951704,3,"<p>Firstly, the first variant does not <em>initialize</em> any structure. It simply allocates a block of raw memory sufficient to hold an object of <code>struct Cat</code> type. The memory remains uninitialized (contains garbage). The second variant does initialize each field in the structure to a specific value.</p>

<p>Secondly, the first variant creates a nameless [and uninitialized] <code>struct Cat</code> object with <em>allocated</em> storage duration. The object will live until you explicitly deallocate it with <code>free</code> (or until the program ends). The second variant creates a named object <code>cat</code> with <em>automatic</em> storage duration - it will be deallocated automatically at the end of its declarative region (at the end of the containing block).</p>

<p>Thirdly, in practice the two variants create objects in different kinds of memory. The first variant creates the object in the heap, while the second variant will typically create it on the stack.</p>

<p>As for when to use one or another, there are quite a few answers here on SO to that question. <a href=""https://stackoverflow.com/questions/2715198/c-pointer-objects-vs-non-pointer-objects"">This thread</a> has some answers and plenty of links.</p>
",0
2951805,2951704,2,"<p>The difference (among other points already said) is that you do not initialize at all the structure in the first case (malloc); you just get the memory to hold it. In the second case, you have the memory and the initialization.</p>
",1
2513189,2513173,1,"<p>The <code>{</code> appear after the if() condition. And } should come after <code>fscanf(dog, ""%d"", &amp;number[i]);</code></p>

<pre><code>if(i%2!=1){
    i++;
    fprintf(feven, ""%d"", even);
    fscanf(dog, ""%d"", &amp;number[i]);
}else {
    i%2==1;
    i++;
}
</code></pre>
",0
2513199,2513173,1,"<pre><code>{ if (i % 2 != 1)
        i++;
}

fprintf(feven, ""%d"", even);
fscanf(dog, ""%d"", &amp;number[i]);
else
{
    i % 2 == 1;
    i++;
}
</code></pre>

<p>Should be:</p>

<pre><code>if (i % 2 != 1)
{
    i++;
    fprintf(feven, ""%d"", even);
    fscanf(dog, ""%d"", &amp;number[i]);
}
else
{
    i % 2 == 1; //BTW this doesn't do anything.
    i++;
}
</code></pre>

<p><strong>EDIT:</strong> I've taken a few liberties so this might not be exactly your intent but it should be close enough.  You need to work on a lot of small things which hopefully looking at the code will help with.  Remember to understand what the functions do.  And walk before you run.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char *argv[])
{
    int number;

    // check to make sure that all the file names are entered

    if (argc != 4)
    {
        printf(""Usage: %s &lt;inputfile&gt; &lt;even_outputfile&gt; &lt;odd_outputfile&gt;\n"", argv[0]);
        exit(1);
    }

    FILE *dog   = fopen(argv[1], ""r"");
    FILE *feven = fopen(argv[2], ""w"");
    FILE *fodd  = fopen(argv[3], ""w"");

    // check whether the file has been opened successfully

    if (dog == NULL)
    {
        printf(""File %s cannot open!\n"", argv[1]);
        exit(1);
    }

    if (feven == NULL)
    {
        printf(""File %s cannot open!\n"", argv[2]);
        exit(1);
    }

    if (fodd == NULL)
    {
        printf(""File %s cannot open!\n"", argv[3]);
        exit(1);
    }


    while (fscanf(dog, ""%d"", &amp;number) == 1)
    {
        if (number % 2 == 0)
            fprintf(feven, ""%d "", number);
        else
            fprintf(fodd, ""%d "", number);
    }

    fprintf(feven, ""\n"");
    fprintf(fodd, ""\n "");

    fclose(dog);
    fclose(feven);
    fclose(fodd);
}
</code></pre>
",6
2513319,2513173,1,"<p>first </p>

<pre><code>int i=0,even,odd;
int number[i];
</code></pre>

<p>means the length of Array number is 0.
you should write</p>

<pre><code>if (argc != 3) {
    printf(""Usage: executable in_file  output_file\n"");
    exit(0);
}

FILE *dog = fopen(argv[1], ""r"");
FILE *feven= fopen(argv[2], ""w"");
FILE *fodd= fopen (argv[3], ""w"");
int num;
while (fscanf(dog, ""%d"", &amp;num) != EOF)
{
    if(num % 2 == 0)
    {
        fprintf(feven, ""%d"", num);
    }else
    {
        fprintf(fodd, ""%d"", num);
    }
}
fclose(feven);
fclose(fodd);
fclose(dog);
</code></pre>
",1
4178814,4178804,1,"<p>Question answer:</p>

<p>What you posted is the correct code.</p>

<p>Elaboration:</p>

<p>If it ""doesn't seem to work"", perhaps the problem does not lie at this location in your code. If you would post a more complete example of what you have, the code's expected behavior and actual behavior, we may be able to help you.</p>
",0
4178821,4178804,26,"<p>What do you mean with <em>empty</em>?</p>

<p>When a C program is executed, variables that you don't explicitly initialize have got unpredictable values.</p>

<p>You need to set all of your array cells to NULL (or to 0, or to whatever value represents emptyness in your program logic) and then you can check it in the way you did:</p>

<pre><code>int *array[3] = { NULL, NULL, NULL }; // array of three ""empty"" pointers

...

for( i = 0; i &lt; 3; ++ i ) {
  if( array[i] == NULL ) {
    // i-th cell is ""empty""
  }
}
</code></pre>
",3
4178838,4178804,1,"<p>Assuming that <code>array</code> is indeed an array of pointers, the single line of code provided should indeed verify that element at index <code>i</code> is NULL.</p>

<p>Note however that if you array is not properly initialized (ie: provide an initial value to <strong>each cell</strong>), the array most probably contains garbage and your condition will most probably end up being false.</p>
",0
2447599,2447580,0,"<p>If it's a console application, you could use writeline that takes a string and displays it:</p>

<pre><code>Console.WriteLine(sizeof(int));
Console.WriteLine(sizeof(int));
Console.WriteLine(sizeof(float));
Console.WriteLine(sizeof(double));
Console.WriteLine(sizeof(char));
Console.WriteLine(sizeof (167));
Console.WriteLine(sizeof(3.1415926));
Console.WriteLine(sizeof(¡®$¡¯));
</code></pre>
",7
2447602,2447580,3,"<p>Sure. You can use the following code. I'm answering in C since that's what the question asked for, despite the C# tag. If you really want C#, someone else will have to help.</p>

<pre><code>#include &lt;stdio.h&gt;
int main (void) {
    // Use %zu for size_t if your compiler supports it.
    printf(""sizeof(int)       = %d\n"",sizeof(int));
    printf(""sizeof(float)     = %d\n"",sizeof(float));
    printf(""sizeof(double)    = %d\n"",sizeof(double));
    printf(""sizeof(char)      = %d\n"",sizeof(char));
    printf(""sizeof(167)       = %d\n"",sizeof(167));
    printf(""sizeof(3.1415926) = %d\n"",sizeof(3.1415926));
    printf(""sizeof('$')       = %d\n"",sizeof('$'));
    return 0;
}
</code></pre>

<p>This outputs (on my system):</p>

<pre><code>sizeof(int)       = 4
sizeof(float)     = 4
sizeof(double)    = 8
sizeof(char)      = 1
sizeof(167)       = 4
sizeof(3.1415926) = 8
sizeof('$')       = 4
</code></pre>

<p>Keep in mind that this gives you the values in terms of bytes which, under the C standard, are <em>not</em> necessarily 8 bits. You should examine CHAR_BITS from <code>limits.h</code> to see how many bits are in a byte.</p>
",20
2448975,2447580,1,"<p>Something like</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    printf(""sizeof(int) = %ul\n"", (unsigned long) sizeof(int));
}
</code></pre>

<p>with a lot of similar lines will do.  Save, compile, and run.</p>

<p>One common mistake is <code>printf(""sizeof(int) = %d"", sizeof(int));</code>, but this is a mismatch.  The result of <code>sizeof()</code> is <code>size_t</code>, which is an unsigned integral type that's big enough to hold any possible object size.  The <code>%d</code> specifier asks for an <code>int</code>, which is a signed integral type that's convenient for calculation.  It's not all that rare for <code>size_t</code> to be bigger than <code>int</code>, and then you're passing arguments of a size that the function doesn't expect, and that can be bad.</p>
",2
2454893,2454830,-2,"<p>I'll give you a clue, without answering your homework directly.</p>

<p>Bit masks.</p>
",2
2454898,2454830,1,"<p>Try:</p>

<pre><code>    long p1 = n/10000000000;
    long p2 = n%100000000000/10000;
    long p3 = n%10000/10;
    long p4 = n%10;
    printf(""%03ld-%06ld-%03ld-%01ld\n"",p1,p2,p3,p4);
</code></pre>
",2
2456156,2454830,0,"<p>If you actually can't use strings, you're going to need to do is to go through each digit in turn and use <code>putchar('0' + x);</code> where <code>x</code> is the current digit..</p>
",0
7380606,7380591,5,"<p>Try including <a href=""http://pubs.opengroup.org/onlinepubs/7908799/xsh/unistd.h.html"" rel=""noreferrer"">unistd.h</a>. I see in the documentation that the header has most of the system calls.</p>
",0
7380607,7380591,10,"<p>You should probably use <code>unistd.h</code> instead.
Check the man page for the call you're trying to make, as it is system dependent and can vary.</p>
",0
7380611,7380591,4,"<p>Try including <code>sys/syscall.h</code>.</p>

<p>EDIT: note that the other answers are probably what you really want, as <code>unistd.h</code> has wrappers for most of the syscalls you want.</p>
",0
3706735,3706704,44,"<p>It's the declaration of a function taking an <code>int</code> and a pointer to a function (taking <code>int</code> returning void) and returning a pointer to a function (taking <code>int</code> and returning void).</p>

<hr>

<p><strong>Explanation, or guide to interpretation</strong></p>

<p>You can interpret by treating everything in parentheses as a single entity and then working inwards using the ""declaration follows usage"" rule.</p>

<p>void <strike>(*signal(int sig, void (*func)(int)))</strike>(int);</p>

<p>The entity in the brackets looks like a function taking <code>int</code> and returning <code>void</code>.</p>

<p>Stripping away the outer part:</p>

<pre><code>*signal(int sig, void (*func)(int))
</code></pre>

<p>So, <code>signal</code> takes some parameters and returns something that can be dereferenced (due to the leading <code>*</code>) to form a function taking <code>int</code> and returning <code>void</code>.</p>

<p>This means <code>signal</code> is a function returning a pointer to a function (taking <code>int</code> and returning <code>void</code>).</p>

<p>Looking at the parameters it takes an <code>int</code> (i.e. <code>sig</code>) and <code>void (*func)(int)</code> which is a pointer to a function (taking <code>int</code> and returning <code>void</code>).</p>
",4
3706767,3706704,0,"<p>Returning pointer to a function which 
takes an:</p>

<ul>
<li>integer as first argument argument and </li>
<li>a pointer to a function (which takes an int and returns void) as an argument as a second argument. </li>
</ul>

<p>And takes an integer argument.</p>
",0
3707425,3706704,9,"<p>This is one of the classical examples of how convoluted C declarations can become.<br/>
To understand this declaration, it usually helps to introduce a typedef:</p>
<pre><code>typedef void (*sighandler_t)(int);
sighandler_t signal(int sig, sighandler_t func);
</code></pre>
<p>The typedef declares a pointer to a function (taking an int parameter and returning nothing).
The function <code>signal</code> can now be seen as a function that takes two parameters (an int and a pointer to a function) and returns a pointer to a function.</p>
<p>This can also be derived from the original declaration, but it takes a bit of practice. The usual way is to start at the identifier that names the outermost entity (<code>signal</code> is this case):</p>
<blockquote>
<p><code>signal</code> is a ...</p>
</blockquote>
<p>Then you read right until you find an unmatched closing parenthesis or the end of the declaration: <code>void (*<em>signal</em><s>(int sig, void (*func)(int)</s>)(int)</code></p>
<blockquote>
<p><code>signal</code> is a function taking ... returning ...</p>
</blockquote>
<p>Now you can choose between parsing the parameters first, or the return value first. I will do the return value first. For that, you read backwards to find the matching open parenthesis: <code>void <s>(<em></s><em>signal( /</em> ... */ )</em><s>)</s>(int)</code></p>
<blockquote>
<p>`signal is a function taking ... returning a pointer to ...</p>
</blockquote>
<p>Reading back and forth this way you get at successive stages:</p>
<blockquote>
<p>`signal is a function taking ... returning a pointer to a (function taking ... returning ...)</p>
<p>`signal is a function taking ... returning a pointer to a (function taking ... returning void)</p>
<p>`signal is a function taking ... returning a pointer to a (function taking an int and returning void)</p>
<p>`signal is a function taking two parameters: (an int) and (a pointer to a function taking an int and returning void), and returning a pointer to a (function taking an int and returning void)</p>
</blockquote>
",0
4096165,4096091,2,"<p><strong>Note</strong>: 0x11111111 doesn't mean 8 bits all set to 1. It's an hexadecimal number of 4 bytes, where any byte is set to 0x11.</p>

<p>0xFF is a single byte (8 bit) where any bit is set to 1.</p>

<p>Then, to achieve what you want you could use some MACROs to isolate the bits you need:</p>

<pre><code>#define TOKEN1(x)  ((x)&gt;&gt;7)
#define TOKEN2(x)  ( ((x)&gt;&gt;3) &amp; (0xFF&gt;&gt;5) )
#define TOKEN3(x)  ( ((x)&gt;&gt;5) &amp; (0xFF&gt;&gt;5) )
</code></pre>

<p><em>Didn't test it.</em></p>

<p>Another idea, could be that of putting in an union a char and a struct using bitfield chars</p>

<pre><code>union {
    struct { char a:3; char b:4; char c:3; };
    char x;
};
</code></pre>

<p>This way you can use x to edit the whole octet, and a, b and c to access to the single tokens...</p>

<p><strong>Edit</strong>: 3+4+3 != 8.</p>

<p>If you need 10 bits you should use a short instead of a char. If, instead, some of those bits are overlapping, the solution using MACRO will probably be easier: you'll need more than one struct inside the union to achieve the same result with the second solution...</p>
",0
4096200,4096091,0,"<p>Do you mean, if we ""concatenate"" octets as octet2.octet1, we will get 000000[111][1111][111]?</p>

<p>Then you may use bit operations:</p>

<ul>
<li>"">>"" and ""&lt;&lt;"" to shift bits in your value,</li>
<li>""&amp;"" to mask bits</li>
<li>""+"" to combine values</li>
</ul>

<p>For example, ""middle"" value (which is 4-bits-length) may be received in the following way:</p>

<pre><code>middle = 15 &amp; (octet1 &gt;&gt; 3);
</code></pre>
",0
4096205,4096091,0,"<pre><code>assert(CHAR_BIT == 8);
unsigned int twooctets = (octet2 &lt;&lt; 8) | (octet1); /* thanks, Jonas */
unsigned int bits0to2 = (twooctets &amp; /* 0b0000_0000_0111 */ 0x007) &gt;&gt; 0;
unsigned int bits3to6 = (twooctets &amp; /* 0b0000_0111_1000 */ 0x078) &gt;&gt; 3;
unsigned int bits7to9 = (twooctets &amp; /* 0b0011_1000_0000 */ 0x380) &gt;&gt; 7;
</code></pre>
",1
4096307,4096091,9,"<p>In a kind of <a href=""http://ruby-doc.org/core/classes/Fixnum.html#M001072"" rel=""nofollow"">pseudocode</a></p>

<pre><code>octet1 = 0b11111111
octet2 = 0b00000011
word = octet1 | octet2&lt;&lt;8
n1 = word &amp; 0b111
n2 = word&gt;&gt;3 &amp; 0b1111
n3 = word&gt;&gt;7 &amp; 0b111
</code></pre>
",4
4096114,4096091,1,"<p>You can use boolean opeations to get and set the individual values.</p>

<p>It's unclear which bits of your octets apply to which values but you only need <code>&amp;</code> (bitwise AND), <code>|</code> (bitwise OR), <code>&lt;&lt;</code> (left shift) and <code>&gt;&gt;</code> (right shift) to do this.</p>
",0
4096130,4096091,0,"<p>Bitfields could be one option.  You may need to pad your struct to get the bits to line up the way you want them to.</p>

<p>Refer to <a href=""https://stackoverflow.com/questions/3429802/bitfields-in-c"">Bitfields in C++</a> or search StackOverflow for C++ and bitfields or you can use bitwise operators as outline in the other answers.</p>
",0
4096138,4096091,3,"<pre><code>  oct2|  oct1
000011|1 1111 111
    ---- ---- ---
     7   0xf   7
</code></pre>

<p>Just a hint,(assuming it is homework)</p>
",0
4096146,4096091,1,"<p>Start from writing a packing/unpacking functions for your 2-byte hybrids.</p>

<p>If you so the work with C/C++ - you may use the intrinsic support for this:</p>

<pre><code>struct Int3 {
    int a : 3;
    int b : 4;
    int c : 3;
};
</code></pre>
",0
4096439,4096091,3,"<p>No need to put the two bytes together before extracting bits we want.</p>

<pre><code>#include &lt;stdio.h&gt;

main()
{
    unsigned char octet1 = 0b11111111;
    unsigned char octet2 = 0b00000011;
    unsigned char n1 = octet1 &amp; 0b111;
    unsigned char n2 = (octet1 &gt;&gt; 3) &amp; 0b1111;
    unsigned char n3 = (octet1 &gt;&gt; 7) | (octet2 + octet2);

    printf(""octet1=%u octet2=%u n1=%u n2=%u n3=%u\n"",
              octet1, octet2, n1, n2, n3);

}
</code></pre>
",5
4098003,4096091,4,"<p>Hi here is a method that is tested and compiled using VC++9  </p>

<pre><code>#pragma pack( 1 )

union 
{
    struct 
    {
        unsigned short val1:3;
        unsigned short val2:4;
        unsigned short val3:3; 
        unsigned short val4:6; 
    } vals;
    struct 
    {
        unsigned char octet1:8;
        unsigned char octet2:8;
    } octets;
    short oneVal;
} u = {0xFFFF};

unsigned char octet1 = 0xFF;  //1 1111 111
unsigned char octet2 = 0x03;  //000000 11
//000000 111 1111 111 0 7 15 7
u.octets.octet1 = octet1;
u.octets.octet2 = octet2;
cout &lt;&lt; ""size of u.vals:"" &lt;&lt; sizeof(u.vals)&lt;&lt; endl;
cout &lt;&lt; ""size of u.octets:"" &lt;&lt; sizeof(u.octets)&lt;&lt; endl;
cout &lt;&lt; ""size of u.oneVal:"" &lt;&lt; sizeof(u.oneVal)&lt;&lt; endl;
cout &lt;&lt; ""size of u:"" &lt;&lt; sizeof(u)&lt;&lt; endl;
cout &lt;&lt; endl;

cout &lt;&lt; ""Your values:"" &lt;&lt; endl;
cout &lt;&lt; ""oneVal in Hex: 0x"";
cout.fill( '0' );
cout.width( 4 );
cout&lt;&lt; hex &lt;&lt; uppercase &lt;&lt; u.oneVal &lt;&lt; endl;
cout &lt;&lt; ""val1: "" &lt;&lt; (int)u.vals.val1 &lt;&lt; endl;
cout &lt;&lt; ""val2: "" &lt;&lt; (int)u.vals.val2 &lt;&lt; endl;
cout &lt;&lt; ""val3: "" &lt;&lt; (int)u.vals.val3 &lt;&lt; endl;
cout &lt;&lt; ""val4: "" &lt;&lt; (int)u.vals.val4 &lt;&lt; endl;
cout &lt;&lt; endl;

octet1 = 0xCC;  //1 1001 100
octet2 = 0xFA;  //111110 10
//111110 101 1001 100 62 5 9 4
u.octets.octet1 = octet1;
u.octets.octet2 = octet2;

cout &lt;&lt; ""Some other values:"" &lt;&lt; endl;
cout &lt;&lt; ""oneVal in Hex: 0x"";
cout.fill( '0' );
cout.width( 4 );
cout&lt;&lt; hex &lt;&lt; uppercase &lt;&lt; u.oneVal &lt;&lt; endl;
cout &lt;&lt; dec;
cout &lt;&lt; ""val1: "" &lt;&lt; (int)u.vals.val1 &lt;&lt; endl;
cout &lt;&lt; ""val2: "" &lt;&lt; (int)u.vals.val2 &lt;&lt; endl;
cout &lt;&lt; ""val3: "" &lt;&lt; (int)u.vals.val3 &lt;&lt; endl;
cout &lt;&lt; ""val4: "" &lt;&lt; (int)u.vals.val4 &lt;&lt; endl;
cout &lt;&lt; endl;

octet1 = 0xCC;  //1 1001 100
octet2 = 0xFA;  //111110 10
//111110 101 1001 100 62 5 9 4
u.oneVal = ( (( unsigned short )octet2 ) &lt;&lt; 8 ) | ( unsigned short )octet1;
cout &lt;&lt; ""Some thing diffrent asignment:"" &lt;&lt; endl;
cout &lt;&lt; ""oneVal in Hex: 0x"";
cout.fill( '0' );
cout.width( 4 );
cout&lt;&lt; hex &lt;&lt; uppercase &lt;&lt; u.oneVal &lt;&lt; endl;
cout &lt;&lt; dec;
cout &lt;&lt; ""val1: "" &lt;&lt; (int)u.vals.val1 &lt;&lt; endl;
cout &lt;&lt; ""val2: "" &lt;&lt; (int)u.vals.val2 &lt;&lt; endl;
cout &lt;&lt; ""val3: "" &lt;&lt; (int)u.vals.val3 &lt;&lt; endl;
cout &lt;&lt; ""val4: "" &lt;&lt; (int)u.vals.val4 &lt;&lt; endl;
cout &lt;&lt; endl;
</code></pre>

<p>Also note that I uses <strong>#pragma pack( 1 )</strong> to set the structure packing to 1 byte.</p>

<p>I also included a way of assigning the two octets into the one short value.  Did this using bitwise shift ""&lt;&lt;"" and bitwise or ""|""</p>

<p>You can simplify the access to u by dropping the named structures. But I wanted to show the sizes that is used for the structures.  </p>

<p>Like this:</p>

<pre><code>union 
{
    struct 
    {
        unsigned short val1:3;
        unsigned short val2:4;
        unsigned short val3:3; 
        unsigned short val4:6; 
    };
    struct 
    {
        unsigned char octet1:8;
        unsigned char octet2:8;
    };
    short oneVal;
} u = {0xFFFF};
</code></pre>

<p>Access would now be as simple as</p>

<pre><code>u.oneVal = 0xFACC;
</code></pre>

<p>or </p>

<pre><code>u.octet1 = 0xCC;
u.octet2 = 0xFA;
</code></pre>

<p>you can also drop either oneVal or octet1 and octet2 depending on what access method you like.</p>
",3
3304152,3304133,5,"<p>You need to terminate the input to your program (i.e. trigger the EOF test).</p>

<p>You can do this on most unix terminals with Ctrl-D or Ctrl-Z at the start of a new line on most windows command windows.</p>

<p>Alternately you can redirect stdin from a file, e.g.:</p>

<pre><code>myprogram &lt; test.txt
</code></pre>

<p>Also, you should give main a return type; implicit <code>int</code> is deprecated.</p>

<pre><code>int main(void)
</code></pre>
",2
3304162,3304133,1,"<p>Your programs will only output after seeing an end of file (EOF). Generate this on UNIX with CTRL-D or on Windows with CTRL-Z.</p>
",0
3304167,3304133,0,"<p>Pressing Enter on your keyboard, adds the character <code>\n</code> to your input.  In order to and the program and have it print out the number of characters you would need to add an 'End of File' (EOF) character.</p>

<p>In order to inject an EOF character, you should press <code>CTRL-D</code> in Unix or <code>CTRL-Z</code> on Windows.</p>
",0
3304168,3304133,1,"<p>You wait for an EOF character (end of file) here. This will only happen in two scenarios:</p>

<ul>
<li><p>The user presses Ctrl+Break (seems to work on Windows here, but I wouldn't count on this).</p></li>
<li><p>The user enters a EOF character (can be done with Ctrl+Z for example).</p></li>
</ul>

<p>A better way to do this would be to check for a newline instead.</p>
",0
3304176,3304133,0,"<p>You do realize that newline is a normal character, and not an EOF indicator? EOF would be Ctrl-D or Ctrl-Z on most popular OSes.</p>
",0
4601421,4601193,3,"<pre><code>int find(char *t, int len){
}
</code></pre>

<p>might give a warning that function should return a value.</p>

<p>and if you add:</p>

<pre><code>char* value = ""hello world"";
int rt = find(value, strlen(value));
</code></pre>

<p>It should work fine if the code is in a single file (as already pointed by Michael in comments) else you will have to specify the prototype of <code>find</code> function before calling it from a separate file.</p>
",2
4601204,4601193,0,"<ol>
<li><p>There is a syntax error in your call, no <code>;</code> after <code>value = ""hello world""</code></p></li>
<li><p>Did you <code>#include &lt;string.h&gt;</code>?</p></li>
</ol>
",1
7452363,7410271,0,"<p>Just add another <code>getchar()</code> call:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  printf(""Press any key to continue. "");
  fflush(stdout);
  getchar();
  return 0;
}
</code></pre>

<p>It actually doesn't return until you type a full line or it hits EOF but it should be good enough.</p>
",0
7452593,7410271,1,"<p>These:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
cin
cout
</code></pre>

<p>are C++-specific.  They simply don't exist in C.  Remember that C and C++ are two different languages.</p>

<p>The fact that your window is closing when the program terminates is a function of the development system you're using.  If you run the program from a command prompt, that won't happen -- or there may be an option in your IDE to tell it to keep the window open until you close it explicitly.  But if you don't want to do that, J.F. Sebastian's solution is a good one.</p>

<p>Another hint: take a look at the <code>isalpha()</code> and <code>isdigit()</code> functions in <code>&lt;ctype.h&gt;</code>.</p>
",0
5570761,5570714,0,"<p>No, since the standard C library doesn't have a concept of threads, the functions it defines can't be.</p>
",7
5570771,5570714,2,"<p>Malloc may be thread-safe.  The standard doesn't require it, but many C compilers are used in systems whose applications requires thread safety, and your particular compiler's library may be thread safe, or offer a thread safe option.  I don't know about iOS.</p>

<p>Memmove (or any other kind of block move) is not thread safe, any more than an assignment statement is thread safe.</p>
",2
5570859,5570714,6,"<p>In an implementation that provides threads, <code>malloc</code> will normally be thread safe (i.e., it will take steps to assure the heap doesn't get corrupted, even if <code>malloc</code> gets called from multiple threads). The exact way it will do that varies: some use a single heap, and internal synchronization to ensure against corruption. Others will use multiple heaps, so different threads can allocate memory simultaneously without collisions.</p>

<p><code>memmove</code> will normally be just like if you did assignments in your own code -- if you're sharing a buffer across threads, it's your responsibility to synchronize access to that data.</p>
",0
5570976,5570714,3,"<p>You should be using a mutex (<a href=""http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSLock_Class/Reference/Reference.html#//apple_ref/occ/cl/NSLock"" rel=""nofollow"">NSLock</a>) as a protective barrier around accessing your buffer.  Take a look at <a href=""http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html"" rel=""nofollow"">Synchronization</a> in Apple's <a href=""http://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/Multithreading.pdf"" rel=""nofollow"">Threading Programming Guide</a>.</p>
",0
5571142,5570714,1,"<p>Since the current C standard does not specify threads, it has nothing to say about thread safety. Whenever you have threads, you're dealing with a system that has placed further requirements, beyond the basic C language standard's requirements, on how the standard library functions behave. I'm not sure what requirements iOS makes, but POSIX and Windows both require <code>malloc</code> to be thread-safe, and I'd find it hard to believe any system designed after the mid 90s would not make this requirement.</p>

<p>Note that the upcoming C1x standard will specify threads, and if the implementation has threads, then <code>malloc</code> will be required to be thread-safe.</p>
",0
3429419,3429405,4,"<p>You can use a <a href=""http://publications.gbdirect.co.uk/c_book/chapter6/bitfields.html"" rel=""nofollow noreferrer"">bitfield</a> to store your 4 bits, however, unless you've several of them adjacent in a struct, you won't save any space over storing the value in a byte.</p>
",2
3429425,3429405,7,"<p>Consider using a <code>char</code>. Yeah, it's 8-bits, but you can use the bit shift operators (<code>&lt;&lt;</code> and <code>&gt;&gt;</code>) to store values in the other 4 bits.</p>

<p><strong>Edit:</strong> Per the comments below, an <code>unsigned char</code> is, in fact, preferable over <code>char</code> to avoid issues with the sign bit.</p>
",1
3429428,3429405,0,"<p>The term for a half byte is a nibble. So here:</p>

<pre><code>struct two_nibbles {
  unsigned a :4;
  unsigned b :4;
}
</code></pre>

<p>You have to name your two variables <code>x.a</code> and <code>x.b</code> (but change <code>x</code> to whatever), but you'll save a little space. You might want to check, though - I think the compiler would make sure that <code>sizeof(struct two_nibbles) == sizeof(char)</code> but it might not, so you might have to add more nibbles to make it worth the space.</p>
",3
3429454,3429405,3,"<p>You can't really have one 4-bit variable, but you can have 8-bit variables that store two 4-bit values, but you have to access them with a temp, meaning you don't save any space unless you have more than two:</p>

<pre><code>uint8_t var_both;
uint8_t temp = (var_both &gt;&gt; 4) &amp; 0x0F; // For first value
temp = var_both &amp; 0x0F; // For second value
</code></pre>
",0
3429796,3429405,2,"<p>As Chris Lutz specified, you can define the amount of bits that a variable uses by adding a colon and the size of it: <code>unsigned char myOneBitVariable:1;</code> and for your case 'unsigned char MyFourBitVariable:4'. I'd like to point out how <b>extremely difficult</b> this is and <b>why you should avoid it</b>.</p>

<p>Most modern compilers will align the space for your variables in your struct. The most general case today is 4 bytes or even 8 bytes but that varies from platform to platform and compiler to compiler. Some compilers allow you to specify the alignment of the data and its members. On GCC the keyword is <code>__attribute__((aligned(x)))</code> and on MSVC it's <code>__declspec(align(x))</code>. In most cases you will also need to specify how much the compiler should pack the structures. MSVC has the <code>#pragma pack(x)</code>directive: <a href=""http://msdn.microsoft.com/en-us/library/2e70t5y1(VS.80).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/2e70t5y1(VS.80).aspx</a>. You can also read about MSVC alignment here: <a href=""http://msdn.microsoft.com/en-us/library/83ythb65(VS.80).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/83ythb65(VS.80).aspx</a>. GCC has its own implementation called <code>__attribute__ ((__packed__)</code>, which you might have to search around for.
An example that doesn't give you what you want, using Microsoft's compiler:</p>

<pre><code>
#ifndef _MSC_VER
#error This alignment solution / packing solution is only valid on MSC
#endif /* ifndef _MSC_VER */

#define M_ALIGN(x)    __declspec(align(x))

struct S64Bits
{
    unsigned char MyOneBitVariable:1;
    int My32BitInt;
};

// MSVC specific implementation of data-packing in a type.
#pragma pack(1)
struct S32Bits
{
    D_ALIGN(1) int My16BitVariable:16;
    D_ALIGN(1) unsigned char Padding8Bits;
    D_ALIGN(1) unsigned char MyOneBitVariable1:1;
    D_ALIGN(1) unsigned char MyOneBitVariable2:1;
    D_ALIGN(1) unsigned char MyOneBitVariable3:1;
    D_ALIGN(1) unsigned char MyOneBitVariable4:1;
    D_ALIGN(1) unsigned char MyFourBitVariable:4;
};
#pragma pack(pop)
</code></pre>

<p>'sizeof(S64Bits)' should be 8, which it is. 'sizeof(S32Bits)' should be 4, <b>it isn't</b>. On msvc the latter is 6 bytes. The behavior is also compiler-specific and often have compiler-unique directives. This kind of behavior almost never gives you what you want. I often use a macro to make sure that structures that I require to be of a certain size really are:</p>

<pre><code>
#define TEST_TYPE_SIZE(Type, Size) assert(sizeof(Type) == Size);
</code></pre>

<p>That I will use below all my data-types where I try to specify the exact size of them. However, relying on a structure being any size other than sizeof(mystructure) is coding that will likely lead to difficult to debug errors. Alignment-compiler directives are best suited to be used to align data to cache-line size and similar efficiency issues. </p>

<p>Karl Bielefeldt provides a good natural solution of storing 4-bit values into an uint8 using bit shift operations, use those instead.</p>
",7
3429819,3429405,0,"<p>Are you ever going to want to take the address of the 4-bit values? If so, you need to store them in a ""proper"" data type, such as a char.</p>
",0
8236624,8236410,2,"<p>I think your problem is here:</p>

<pre><code>if (scanf(""%*[ \n\t]%c"", &amp;type) == 0)
</code></pre>

<p>You're trying to check if you're out of characters to read, so you want to check if <code>scanf</code> returns <code>EOF</code> (which is <code>-1</code>, but just use the <code>EOF</code> constant). If you break when you see <code>EOF</code> returned you'll drop out of the loop as soon as you end input to the process (<kbd>Ctrl</kbd>+<kbd>D</kbd> on Linux, I believe <kbd>Ctrl</kbd>+<kbd>Z</kbd> <kbd>Enter</kbd> on Windows)</p>
",1
8236641,8236410,2,"<p>If your data is line-oriented, you would probably do better with reading lines using <code>fgets()</code> or possibly <code>getline()</code> from POSIX 2008, and then using <code>sscanf()</code> to parse the lines.</p>
",0
3429141,3428758,1,"<p>I've used #line and #error to create a temporary *.c file that you compile and let your IDE give you a browsable list of errors found by some 3rd party tool.</p>

<p>For example, I piped the output file from PC-LINT into a perl script which converted the human readable errors to #line and #error lines. Then compiled this output, and my IDE lets me step through each error using F4. A lot faster that manually opening up each file and jumping to a particular line.</p>
",0
3428768,3428758,17,"<p>It's generally used by automated code generation tools (like <code>yacc</code> or <code>bison</code>) to set the line number to the value of the line in the actual source file rather than the <code>C</code> source file.</p>

<p>That way, when you get an error that says:</p>

<pre><code>a += xyz;
     ^ No such identifier 'xyz' on line 15 of foo.y
</code></pre>

<p>you can look at line 15 of the actual source file to see the problem.</p>

<p>Otherwise, it says something ridiculous like <code>No such identifier 'xyz' on line 1723 of foo.c</code> and you have to manually correlate that line in your auto-generated <code>C</code> file with the equivalent in your real file. Trust me, unless you want to get deeply involved in the internals of lexical and semantic analysis (or you want a brain haemorrhage), you don't want to go through the code generated by <code>yacc</code> (<code>bison</code> may generate nicer code, I don't know but nor do I really care since I write the higher level code).</p>

<p>It has two forms as per the C99 standard:</p>

<pre><code>#line 12345
#line 12345 ""foo.y""
</code></pre>

<p>The first sets just the reported line number, the second changes the reported filename as well, so you can get an error in line 27 of <code>foo.y</code> instead of <code>foo.c</code>.</p>

<hr>

<p>As to ""the programmer put it in purely for the sheer joy of lying to the compiler"", no. We may be bent and twisted but we're not usually malevolent :-) That line was put there by <code>yacc</code> or <code>bison</code> itself to do you a favour.</p>
",10
3428770,3428758,5,"<p>The only place I've seen this functionality as being useful is for generated code.  If you're using a tool that generates the C file from source defined in another form, in a separate file (ie: the "".y"" file), using <code>#line</code> can help the user know where the ""real"" problem is, and where they should go to correct it (the .y file where they put the original code).</p>
",0
3428782,3428758,2,"<p>The purpose of the #line directive is mainly for use by tools - code generators can use it so that debuggers (for example) can keep context of where things are in the user's code or so error messages can refer the user to the location in <em>his</em> source file.</p>

<p>I've never seen that directive used by a programmer manually putting it in - and I;m not sure how useful that would be.</p>
",0
3428854,3428758,2,"<p>It has a deeper purpose. The original C preprocessor was a separate program from the compiler. After it had merged several .h files into the .c file, people still wanted to know that the error message is coming from line 42 of stdio.h or line 17 of main.c. Without some means of communication, the compiler would otherwise have no way to know which source file originally held the offending line of code.</p>

<p>It also influences the tables needed by any source-level debugger to translate between generated code and source file and line number.</p>

<p>Of course, in this case, you are looking at a file that was written by a tool (probably named yacc or bison) that is used to create parsers from a description of their grammar. This file is not really a source file. It was created from the real source text.</p>

<p>If your archaeology is leading you to an issue with the parser, then you will want to identify what parser generator is actually being used, and do a little background reading on parsers in general so you understand why it doing things this way at all. The documentation for yacc, bison, or whatever the tool is will likely also be helpful.</p>
",2
3076908,2565375,0,"<p>I guess, the problem is not atoi, should be something else. Please check pointers, debug step by step, etc.</p>
",0
7499393,7499310,2,"<pre><code>memcpy(originalData+6, replacingData, strlen(originalData)-6)
</code></pre>

<p>Although, it should be noted that this makes the assumption that <code>originalData</code> is always greater than 6 characters long and that <code>replacingData</code> is longer than 6 characters shorter than <code>originalData</code>.</p>
",5
4173622,4173610,2,"<p>You will have an easier time if you start out with an array with the integers 0-9 (or whatever your range is) and then randomly shuffle it.   There's an example of how to do the shuffling <a href=""http://benpfaff.org/writings/clc/shuffle.html"" rel=""nofollow"">here</a>.</p>
",4
4173627,4173610,1,"<p>You would basically want to randomize an array [0, 1, ..., 9]. Here's a C++ example, should be easy to transform to C:</p>

<ul>
<li><a href=""http://www.fredosaurus.com/notes-cpp/misc/random-shuffle.html"" rel=""nofollow"">http://www.fredosaurus.com/notes-cpp/misc/random-shuffle.html</a></li>
</ul>
",0
4173638,4173610,10,"<p>It seems more a problem of shuffling that of randomization.</p>

<p>A good start is the <strong>Fisher-Yates shuffle</strong> which starts with the sorted array of elements and generate a random permutation:</p>

<pre><code>int size = 10;
int *elements = malloc(sizeof(int)*size);

// inizialize
for (int i = 0; i &lt; size; ++i)
  elements[i] = i;

for (int i = size - 1; i &gt; 0; --i) {
  // generate random index
  int w = rand()%i;
  // swap items
  int t = elements[i];
  elements[i] = elements[w];
  elements[w] = t;
}
</code></pre>
",5
4173647,4173610,-1,"<p><s>
+ Put all your numbers in the result array<br>
+ from N down to 2<br>
+ ---- shuffle N elements<br>
+ return array</p>

<p>Example</p>

<pre><code>fillarray(arr, 10);
for (n = 10; n &gt; 1; n++) shufflearray(arr, n);
/* done */
</code></pre>

<p></s></p>

<hr>

<p>Edit --- thanks downvoter! I didn't even realize I was doing too much work up there</p>

<ul>
<li>Put all your numbers in the result array</li>
<li>from N down to 2</li>
<li>---- swap element N with a random element from 1 to N</li>
<li>return array</li>
</ul>
",0
3552708,3552693,1,"<p>Why are you passing a pointer to an array?  Have you tried</p>

<pre><code>func(float *floats)
{
  func2(floats);
}

func2(float *floats)
{
  floats[0] = 2;
}
</code></pre>
",2
3552715,3552693,3,"<p>because 'floats' is a bad pointer.  Sure, you declared the pointer, but you haven't allocated any memory, so wherever it happens to point will be invalid.  </p>

<p>Also, the address of a float** is a float***, which is not what your function calls for.</p>
",2
3552857,3552693,0,"<p>Say you have these 2 funcs, like you posted:</p>

<pre><code>void func2(float** floats) {
 *floats[1] = 1.0;
}
void func(float** floats) {
 func2(floats);
}
</code></pre>

<p>Then you have the following code:</p>

<pre><code>float* floats;
func(&amp;floats);
</code></pre>

<p>What happens? First, <code>floats</code> is a <code>float *</code>, and since it's not assigned, it points to a random memory location, say <code>0xBADD</code>. If you write to here, you're liable to screw something up.</p>

<p>The address of <code>floats</code>, <code>&amp;floats</code> is another memory location pointing to where it is on the stack, say <code>0x1000</code>. This is passed to <code>func</code>, which is then verbatim passed to <code>func2</code>.</p>

<p>What does <code>func2</code> do? It tries to write something in the location <code>*floats[1]</code>. I'm not sure what happens first, the bracket or the star, so let's take both cases:</p>

<p><code>*(floats[1])</code>: First you find what <code>floats[1]</code> is. Since <code>floats</code> is the memory location of the initial <code>floats</code> variable, this is <code>0x1000</code>. <code>floats[1]</code> would be <code>0x1004</code>, since pointers are 4 bytes wide assuming a 32-bit system. Then you try to dereference this pointer, which is the value of whatever is in memory location <code>0x1004</code>. This could be anything, like <code>0xBAD2</code>, so trying to write a float value there most likely causes a segfault.</p>

<p><code>(*floats)[1]</code>. Here you first dereference <code>floats</code>, which gets you <code>0xBADD</code>, of type <code>float *</code>. You then try to write a value into <code>0xBADD + 4</code>, or <code>0xBAE1</code>. This is memory that hasn't been allocated for you, so writing there will likely cause a segfault.</p>

<p>Either way, you're messing with memory that isn't yours, thus leading to a segfault.</p>
",1
7215866,7215818,10,"<p>Both should compile.</p>

<p>Both <code>int i;</code> and <code>static int i;</code> are <em>tentative definitions</em> in C as they do not have an initializer and are not <code>extern</code>. You are allowed multiple tentative declarations and at most one non-tentative definition for any object in a translation unit so long as the definitions don't conflict in type or linkage.</p>

<p>ISO/IEC 9899:1999 6.9.2:</p>

<blockquote>
  <p>A declaration of an identifier for an object that has file scope without an initializer, and without a storage-class specifier or with a storage-class specifier <code>static</code>, constitutes a <em>tentative definition</em>. If a translation unit contains one or more tentative definitions for an identifier, and the translation unit contains no external definitions for that identifier, then the behavior is exactly as if the translation unit contains a file scope declaration of that identifier, with the composite type as of the end of the translation unit, with an initializer equal to 0.</p>
</blockquote>
",1
3927839,3927760,0,"<p>have a look at the fgets specification, better:</p>

<pre><code>while( fgets(line, MAXBUF, fp)!= NULL) {
                puts(line); 
            }
</code></pre>

<p>or</p>

<pre><code>while( fgets(line, MAXBUF, fp) ) {
                puts(line); 
            }
</code></pre>
",1
3927969,3927760,1,"<p>The following is what you want to do:</p>

<pre><code>char line[MAXBUF];
char *result;

while((result = fgets(line, MAXBUF, fp)) != NULL) {
      printf(""%s"", line);
}
</code></pre>

<p>The fgets inputs the line (retaining the newline).  You are checking result, which is correct.  Theoretically, result should equal line.  The printf doesn't have a '\n' because the newline character is retained from the fgets (see the manpage).</p>
",0
2319703,2319565,3,"<p>++a means increment a first, and then return evaluate the expression. (a changes, and the expression evaluates as a + 1)</p>

<p>a++ means evaluate a (so, erm, a), and then increment it. So a is passed, but the value of a is then (ie afterwards) changed to a+1.</p>
",1
2319620,2319565,3,"<p>None of the outputs can really qualify as unexpected. All the arguments to a function are evaluated before entry to the function itself -- but the order of their evaluation relative to each other is unspecified, so all of these results are allowed. Officially, your <em>last</em> one (that has two separate instances of incrementing <code>a</code>) has undefined behavior, so it doesn't have to do anything sensible at all.</p>
",7
2319621,2319565,1,"<p>Function parameters are not evaluated in a defined order in C. Therefore one cannot tell beforehand if <code>a</code> or <code>a++</code> will be evaluated first when calling <code>printf</code>.</p>

<p>See <a href=""https://stackoverflow.com/questions/376278/parameter-evaluation-order-before-a-function-calling-in-c/376288#376288"">Parameter evaluation order before a function calling in C</a></p>
",0
2319625,2319565,2,"<p>You are invoking undefined behaviour by referencing both 'a' and 'a++' in the argument list.</p>

<p>It is not defined which order the arguments are evaluated in.  Different compilers may choose different orders.  A single compiler can choose different orders at different times.</p>

<p>Do not do it!</p>
",0
2319644,2319565,9,"<p>Nothing goes ""from right to left"" in function argument evaluation. When function arguments are evaluated, the order of evaluation is unspecified and there are no sequence points between evaluating separate arguments. This means that there's absolutely no temporal ordering in this process. The arguments can be evaluated in any order, and the process of their evaluation can be intertwined in any way.</p>

<p>However, your code suffers from even worse problems. All three statements that call <code>printf</code> produce undefined behavior (UB) because they either make an attempt to modify the same object (<code>a</code>) twice without a sequence point between the modifications (the third call), or they attempt to modify an object and read it for an independent purpose (the first and the second call). So, it is too early to even mention the order of evaluation. Your code's behavior is undefined.</p>
",0
3512965,3512915,0,"<p>First of all, you have two arrays of chars.  Now, in C, arrays of chars are often used to store strings, but you are not doing that.  These are not strings at all, so forget all about the string functions in the library.</p>

<p>What you actually have are two arrays of tiny integers, so you handle them as you would an int array.</p>

<pre><code>#include &lt;stdio.h&gt;           
#include &lt;stdlib.h&gt;          

 int main() 
 { 
   char *hours; 
   char *strl; 
   int i;
   int j;
   char last;
   /* I'm going to assume the the values in hours are sorted. */
   hours={0,0,0,0,1,1,2,2,2,5,5,10,10,10,10,10,.,.,.,23} 

   strl=calloc(100,sizeof(char)); 

   j = 0;
   last = hours[0];
   for(i=1; i &lt; 100; ++i) // I'm going to assume hours has 100 items
   {
       if (hours[i] != last)
       {
           strl[j++] = last;
           last = hours[i];
        }
   }
   strl[j++] = last;    // UPDATE (Thanks, Matthew)
 }

/*    printf(""%s "",strl; 
    You'll need a different way of printing you results */
} 
</code></pre>
",5
3513000,3512915,0,"<p>You probably want to do something more like:</p>

<pre><code>char *dst = strl;
char *cur = hours;
char prev = '\0';
while(*cur) {
  if(*cur != last) {
    prev = *dst = *cur;
    dst++;
  }
  cur++;
}
</code></pre>

<p>Oh yea and as noted by others, your arrays aren't terminated with <code>'\0'</code>, so standard string functions don't work (And for that matter neither will my loop).</p>

<p>Second none of the standard C library functions do what you want... I'll leave it up to you to fix my loop. (Note it only works if the array is sorted)</p>
",1
3513002,3512915,0,"<p>As James said, you can't use string functions because your arrays aren't NUL-terminated.  Even if you could, strcmp would always return non-zero (specifically negative), and <code>*strl</code> would always be 0, which means the inner if always fails.  Finally <code>strcpy</code> does not eliminate any duplicates.  If your array is sorted, you can do this by checking for duplicate consecutive values.  Otherwise, you can use a hash set/hash table like <a href=""http://library.gnome.org/devel/glib/unstable/glib-Hash-Tables.html"" rel=""nofollow noreferrer"">GHashTable</a>.</p>
",1
3456155,3456138,5,"<p>You'll hear a beep from your PC's internal speaker (not the external speakers or headphones you may have attached).</p>
",2
3456158,3456138,6,"<p><code>\a</code> does in fact trigger the system chime. It's the escape sequence for the ASCII <code>BEL</code> character.</p>
",0
3456161,3456138,11,"<p>Have a look at this wikipedia entry: <a href=""http://en.wikipedia.org/wiki/Bell_character"" rel=""noreferrer"">bell character</a>:</p>

<p><em>In the C Programming Language (created in 1972), the bell character can be placed in a string or character constant with \a ('a' stands for ""alert"" or ""audible"" and was chosen because \b was already used for backspace).</em></p>
",2
3456167,3456138,60,"<p>ASCII character 7 is the BELL character, and it's represented in C as <code>\a</code>. Some terminals will produce a beep when this character is output on the terminal; nowadays, many don't. (I'm looking at you, Ubuntu.)</p>
",6
3456174,3456138,3,"<p>\a is the C representation of the ASCII audible alert (""bell"") control character.
On an old-school serial terminal, outputting that character produced a ""beep"" sound. Your terminal emulator may or may not implement this feature.</p>
",0
3456213,3456138,29,"<p>Back in the dark ages when <a href=""http://en.wikipedia.org/wiki/ASCII"" rel=""noreferrer"">ASCII</a> was codified out of the ashes of <a href=""http://en.wikipedia.org/wiki/Baudot_code"" rel=""noreferrer"">BAUDOT</a>, a <a href=""http://en.wikipedia.org/wiki/ASR-33_Teletype"" rel=""noreferrer"">terminal</a> was a large chunk of iron that hammered ink onto paper, often included a paper tape punch and reader, and interpreted keystrokes to generate an asynchronous serial signal at a few hundred baud with spinning wheels and relays.</p>

<p>In case an operator fell asleep to the soothing noises of it hammering out text, it had an actual bell it could ring. The character coded 007 in octal, 0x07 in hex, or as <code>\a</code> in a C character or string constant rang the bell when received.</p>

<p>As terminals became smaller and implemented with few or no moving parts, the physical bell was replaced by a beeper.</p>

<p>Exactly what your terminal emulator (aka a Console Window in Windows, xterm or something similar in Unix) does when it is asked to display that control character is not well standardized today. It ought to make a noise or flash the window, but your mileage will vary.</p>
",0
3456550,3456138,3,"<p>Apart from all the answers you've got, take into account that your program won't probably compile. Here is the fixed version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    printf(""\a"");
    return EXIT_SUCCESS;
}
</code></pre>

<p>The most important change is that system headers must be surronded with &lt; and >, instead of quotes. Also, it is better to know that the main() function always returns an int (to the operating system), and that this int is coded in two constants, EXIT_SUCCESS, and EXIT_FAILURE, in the header stdlib.h</p>
",4
3456327,3456138,2,"<p>Try something simpler:</p>

<pre><code>printf(""hello\tworld"");
printf(""hello\nworld"");
</code></pre>

<p>and see what happens. </p>

<p>Your example with the BELL char, as others have pointed out, probably won't work on today's toasters^H^H^H^H^H^H^H^H computers; most terminals redirect the 'bell' character to either be discarded or to flash the terminal briefly. </p>

<p>And believe me, you want to keep it that way for the night-coding sessions :)</p>
",0
2593828,2593814,-3,"<p>You might malloc the tp variable. If you don't malloc there is no guarantee that the memory is actually yours. Don't forget to free the memory when you are finished. </p>
",5
2593875,2593814,7,"<p>Following line</p>

<pre><code>tokens.mnem = ""load""
</code></pre>

<p>assigns <code>mnem</code> to address of string literal, which is typically located in read-only data segment, so changing this memory with <code>strncpy()</code> or any other function will fail.</p>
",0
2593884,2593814,9,"<p>The problem is that tp->mnem is pointing to a string literal, which is generally allocated in a read-only segment of memory.  Therefore it's illegal to overwrite it.  Most likely what you need to do instead is something like this:</p>

<pre><code>Tokens tokens;
tokens.label = """";
tokens.mnem  = strdup(""load"");
tokens.operand = """";
</code></pre>

<p>This will give you a dynamically allocated block of memory for mnem, which you can then write into as much as you like.  Of course, you have a couple of other problems too:  first, you'll need to remember to release that memory with <code>free</code> later; second, you'll have to be aware of the size of the buffer you've allocated so that you don't overwrite it.</p>

<p>If you know that the contents of <code>mnem</code> will never exceed 4 bytes, then you might instead change your structure declaration like so:</p>

<pre><code>typedef struct tok  {
    char* label;
    char mnem[5]; // note: +1 byte for a NULL terminator
    char* operand;
}Tokens;
</code></pre>

<p>Then, you'd initialize it like this:</p>

<pre><code>Tokens tokens;
tokens.label = """";
strcpy(tokens.mnem, ""load"");
tokens.operand = """";
</code></pre>

<p>This relieves you of the responsibility of managing the memory for <code>mnem</code>, although you still have some risk of overrunning your buffer.</p>
",2
2593889,2593814,2,"<p>You're calling <code>strncpy()</code> without having allocated the buffer spacem, just like Shadow said.</p>

<p>The literal string <code>""load""</code> you set the <code>mnem</code> member to in the initializer is not overwritable.</p>

<p>If you want to be able to change the string stored, and the size is reasonable, it might be easiest to just change the declaration of the struct field to <code>char mnem[5];</code>.</p>

<p>Also, please note that <code>strncpy()</code> has quite weird semantics. Check if you have <code><a href=""http://en.wikipedia.org/wiki/Strlcpy"" rel=""nofollow noreferrer"">strlcpy()</a></code>; it's a better function.</p>
",0
2593893,2593814,3,"<p>The problem is you've assigned string literals to the members of your <code>Tokens</code> structure and are trying to overwrite that memory (specifically, the <code>mnem</code> field) in <code>tokenise</code>.</p>

<p>Most modern OSes will allocate memory for string literals from a special read-only section of your program's address space.  If you try to write to that memory, then your program will die with a segfault.</p>

<p>This is why the type of a string literal is <code>const char *</code>, not <code>char *</code>.  Your compiler should warn you when you try to assign these to the fields of <code>tokenise</code>.</p>

<p>If you want to overwrite the memory later, you need to allocate the memory dynamically using <code>malloc</code> or change the members of the <code>Tokens</code> structure to fixed-length arrays, then copy the initial value into the allocated memory.  Of course if you allocate the memory dynamically you need to <code>free</code> it later too.</p>
",0
2593896,2593814,2,"<p>You're getting a segmentation fault because this line:</p>

<pre><code>strncpy(tp -&gt; mnem, line, 4);
</code></pre>

<p>Is trying to copy four characters from 'line' into a location occupied by a string literal as assigned here:</p>

<pre><code>tokens.mnem = ""load"";
</code></pre>

<p>The string literal is stored in a special text part of your program and may not be modified.</p>

<p>What you need to do is allocate a buffer of your own into which the string will be copied:</p>

<pre><code>tokens.mnem = (char*) malloc (bufferSize);
</code></pre>

<p>And free the buffer when you are done using it.</p>
",0
2593980,2593814,0,"<p>This line is questionable:</p>

<pre><code>strncpy(tp -&gt; mnem, line, 4);
</code></pre>

<p>You are relying on a function that returns a pointer to memory that is not allocated. The return of <code>*tokenise()</code> is undefined. Its returning a pointer to memory that could contain all kinds of stuff, and that you don't have permission to modify.</p>

<p>It <em>should</em> return an allocated pointer.</p>
",0
3121137,3120863,1,"<p>All references to <code>buf[i]</code> should be <code>l_buf[i]</code>.  buf[i] is indexing from a void pointer (not what you want), but l_buf [i] is indexing from a char pointer.</p>
",0
3121665,3120863,1,"<p>I believe there is at least one problem with the solution as proposed and that is there is no check to ensure you don't run off the end of the memory buffer in getString(). So one way to avoid this in your read code would be to add an explicit NULL to the end of the buffer like so</p>

<pre><code>char *buf = malloc (sizeof(char) * (size + 1));
if (!buf)
   return NULL;

if (fread (buf, sizeof(char), size, fp) != size) {
    free (buf);
    return NULL;
}
buf[size] = `\0`;
</code></pre>

<p>And then in your string extraction function add the a NULL check to the line termination tests, something like this:</p>

<pre><code>for (i = in; l_buf[i] != '\0' &amp;&amp; (l_buf[i] == '\n' || l_buf[i] == '\r'); i++);
if (l_buf[i] == '\0') {
    /* Never saw the start of a line before the buffer ran out */
    return NULL;
}

for (j = i; l_buf[i] != '\0' &amp;&amp; l_buf[j] != '\n' &amp;&amp; l_buf[j] != '\r'; j++);
if (i == j) {
    return NULL;
}
</code></pre>

<p>There is another potential problem but as you didn't say whether you were running on UNIX or Windows or cared about portability here I can't be sure. The proposed code doesn't deal with line terminations that include both `\r' and '\n'.</p>

<p>I would also suggest to make the function re-entrant by replacing the global start position index with a parameter like so:</p>

<pre><code>char *getString (void *buf, int *in) { ...
</code></pre>

<p>Then just update that pointer in getString() like so:</p>

<pre><code>*in = j;
</code></pre>
",3
2607388,2607358,-1,"<p>Put your function declarations in a .h file and your implementation in a .c file. Compile the .c file into a .o file (.obj on Windows) and link it together with your code.</p>

<p>For the implementation of string.h functions, get the GNU libc source.</p>
",1
2607611,2607358,4,"<p><a href=""https://code.ohloh.net/search?s=memmove.c"" rel=""nofollow noreferrer"">Here's memmove</a> from Ohloh's code search.</p>
",2
3482961,3482948,2,"<p>Usually, header files contain declarations, source files contain code.</p>

<p>So, if in source file <code>A.c</code> you need a function implemented in source file <code>B.c</code>, you just include <code>B.h</code> to have its declaration.</p>
",0
3482966,3482948,90,"<p>There is no <em>technical</em> difference. The compiler will happily let you include a <code>.c</code> file, or compile a <code>.h</code> file directly, if you want to.</p>

<p>There is, however, a huge <em>cultural</em> difference:</p>

<ul>
<li><p><em>Declarations</em> (prototypes) go in <code>.h</code> files. The <code>.h</code> file is the <em>interface</em> to whatever is implemented in the corresponding <code>.c</code> file.</p></li>
<li><p><em>Definitions</em> go in <code>.c</code> files. They <em>implement</em> the interface specified in the <code>.h</code> file.</p></li>
</ul>

<p>The difference is that a <code>.h</code> file can (and usually will) be <code>#include</code>d into multiple compilation units (<code>.c</code> files). If you <em>define</em> a function in a <code>.h</code> file, it will end up in multiple <code>.o</code> files, and the linker will complain about a multiply defined symbol. That's why definitions should not go in <code>.h</code> files. (Inline functions are the exception.)</p>

<p>If a function is defined in a <code>.c</code> file, and you want to use it from other <code>.c</code> files, a declaration of that function needs to be available in each of those other <code>.c</code> files. That's why you put the declaration in a <code>.h</code>, and <code>#include</code> that in each of them. You could also repeat the declaration in each <code>.c</code> file, but that leads to lots of code duplication and an unmantainable mess.</p>

<p>If a function is defined in a <code>.c</code> file, but you <em>don't</em> want to use it from other <code>.c</code> files, there's no need to declare it in the header. It's essentially an implementation detail of that <code>.c</code> file. In that case, make the function <code>static</code> as well, so it doesn't conflict with identically-named functions in other files.</p>
",6
3482968,3482948,15,"<blockquote>
  <p>What should be in headers and what should be in the source files?</p>
</blockquote>

<p>Typically headers contain one or more of the following:</p>

<ul>
<li>Function declaration (except statics)</li>
<li>Variable declaration (typically global)</li>
<li>User defined type declaration (read <code>struct</code>, <code>union</code> etc.)</li>
<li>Macro definition</li>
</ul>

<p>Source files on the other hand have:</p>

<ul>
<li>Function/variable definition</li>
<li>Static function declaration and definition (you don't want to expose these to your clients)</li>
<li>Variable definition</li>
<li>Some prefer to define inline functions (C99) in a header</li>
</ul>

<blockquote>
  <p>How do I implement this separation?</p>
</blockquote>

<p><em>The One Definition Rule is your friend.</em></p>

<p>Remember, if you are writing a library, this is what your client gets to see. So, be helpful and provide all the information you can for them to use your library. The source files are typically compiled and supplied in binary form.</p>

<p>And by the way, C does not have the concept of classes. </p>
",2
3483021,3482948,2,"<p>There is little fundamental difference between .c and .h files (though some compilers may refuse to compile a raw .h file). The difference is more by convention.</p>

<p>Typically the .h file provides the API and the .c provides the implementation.</p>

<p>Therefore the .h file would contain only things needed by other source files to access the facilities provided by your .c file. So the .h files would provide the function prototypes of global functions, declarations of global variables (if you really must have them), and the structures and other types used by them. (Don't expose a structure if the only a pointer to the structure is required by the API.)</p>

<p>In-line functions are also often included in .h files but some coding guidelines prefer the use of a separate extension (e.g. .inl)</p>

<p>All other function implementations, the definition and initialisation of variables and declarations of local (static) variables and functions would be in the .c file.</p>
",0
5480883,5480866,2,"<p>I suppose you are asking not how to do it (since you demonstrate it), but why is it possible?</p>

<p>The answer is that there is a difference between a program on disk (a file) and a program in memory.</p>

<p>When you run a program, typically, it is copied into RAM and run from there since the CPU only has direct access to execute things in RAM. This copy is conceptually independent from the file on disk and may remain in RAM even if the file is removed.</p>

<p>However, some OSes do not allow a file to be deleted if it represents a running application, for example Windows.</p>
",3
5480885,5480866,5,"<p>In Unix at least (and that includes Linux and Mac OS X), if you remove a file while somebody has it open, i doesn't actually go away until the program that had it open either closes the file or terminates.</p>
",0
3480861,3479657,0,"<p>Here's a small program that uses <code>strtok()</code> to parse lines with comma separated values.  It may help you see what's going on (such as the problem with empty fields that Gilles brought up).  It'll also help you see what happens with blank lines.</p>

<p>Compile it and feed it example data, either with the keyboard or by redirecting a data file to it:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char* myGetLine( char* buf, size_t bufSize, FILE* strm)
{
    char* result = fgets( buf, bufSize, strm);

    int len = result ? strlen(result) : 0;

    if (len &amp;&amp; result[len - 1] == '\n') {
        // get rid of the pesky newline
        result[len - 1] = '\0';
    }

    return result;
}

int main(void)
{
    char line[80];

    while (myGetLine( line, sizeof(line), stdin)) {
        int i = 0;
        char* token = NULL;

        printf( ""%s\n"", line);

        token = strtok( line, "","");
        while (token != NULL) {
            printf( ""token %d: \""%s\""\n"", i, token);
            ++i;
            token = strtok( NULL, "","");
        }

        printf( ""%s\n"", ""enter a new line (or EOF)"");
    }

    return 0;
}
</code></pre>
",0
3480869,3479657,0,"<p>My suggestion is to write a line stripping function that removes any whitespace from the beginning and end of a line.  Run every line through this function before processing it.  Now, any blank lines should just end up being a single <code>'\0'</code> character.</p>

<p>Line stripping functions are easy to write, all you need is a pair of pointers and <code>isspace()</code> from <code>ctype.h</code>.</p>
",0
3857224,3857204,3,"<p>There is no way to reference a concrete (non-pointer) type before it's defined in C.  You must use a pointer + a type declaration or actually define the type before it can be consumed.  </p>
",0
3857227,3857204,7,"<p>Do it like:</p>

<pre><code>typedef struct user user;

typedef struct
{
  //userList contains users
  user * list;
  int count;
} userList;

struct user
{
  unsigned long id;
  //userList defined above
  userList friends;
};
</code></pre>
",0
3857262,3857204,3,"<p>A struct definition can be an <em>incomplete structure or union type</em> by just defining or typedef'ing the struct tag. This can be used to declare pointers.</p>

<p>To declare an actual object, though, it can't be an incomplete type.</p>

<p>So, order your declarations so that the forward reference is the pointer and the backwards reference is the object.</p>
",0
3008880,3008866,3,"<p>This is called a <a href=""http://en.wikipedia.org/wiki/Quine_%28computing%29"" rel=""nofollow noreferrer"">Quine</a>.</p>

<p>Wikipedia has an <a href=""http://en.wikipedia.org/wiki/Quine_%28computing%29#C"" rel=""nofollow noreferrer"">example in C</a>.</p>
",0
3008894,3008866,2,"<p>More examples than you could possibly need can be found at <a href=""http://www.nyx.net/~gthompso/self_c.txt"" rel=""nofollow noreferrer"">http://www.nyx.net/~gthompso/self_c.txt</a>.</p>
",0
3008898,3008866,0,"<p><a href=""http://www.google.ca/search?sourceid=chrome&amp;ie=UTF-8&amp;q=quine+program"" rel=""nofollow noreferrer"">Google</a> for <a href=""http://en.wikipedia.org/wiki/Quine_(computing)"" rel=""nofollow noreferrer"">quine</a> programs.</p>
",0
2934943,2934783,0,"<pre><code>#include &lt;stdio.h&gt;

int main (int argc, const char * argv[]) {
    char out = printf(""teststring"");
    printf(""%d\n"", out);

    return 0;
}
</code></pre>

<p>Assuming that you want to assign ""out"" to a function (as I think you've said somewhere):</p>

<pre><code>#include &lt;stdio.h&gt;

int main (int argc, const char * argv[]) 
{
    char *out = NULL;

    out = funcReturns(""teststring"");

    printf(""%s\n"", out);

    return 0;
}
</code></pre>

<p>If you allocate the memory inside the function that returns ""teststring"" then I think you need to make the return value static.  For example (code untested):</p>

<pre><code>char *funcReturns(char *returnStr)
{
    static char *returnThis = NULL;

    returnThis = strdup(returnStr);

    return returnThis;
}
</code></pre>
",3
2935797,2934783,0,"<pre><code>int printf ( const char * format, ... );
</code></pre>

<p>On success, the total number of characters written is returned.</p>

<p>When you execute this:</p>

<pre><code>char out = printf(""teststring"");
</code></pre>

<p>The string ""teststring"" will be printed on your screen, and the value 10 will be
atrib to variable out.</p>

<p>Notice that the print cursor will be kept on the current line at the end of ""teststring"", once you did not put sufix '\n' on the end of string.</p>

<p>So, when you execute printf(""%d\n"", out); on the next line, the program will print the value 10 just after ""teststring"", and you will see ""teststring10 on your screen.""</p>

<p>If you really want to get rid of the 10 just remove the line printf(""%d\n"", out); from your code...</p>

<pre><code>int main (int argc, const char * argv[]) {
    int out = printf(""teststring\n"");
    /* printf(""%d\n"", out); */

    return 0;
}
</code></pre>
",1
2934796,2934783,0,"<p>the 10 is because of the</p>

<pre><code>printf(""%d\n"", out);
</code></pre>

<p>printf return the number of characters written to the output stream
the length of ""teststring"" which is 10 assigned to ""out""
and the n you print the value of out - so 10 is printed.</p>
",4
2935877,2934783,5,"<p>Lets look at your code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (int argc, const char * argv[]) {
    char out = printf(""teststring"");
    printf(""%d\n"", out);

    return 0;
}
</code></pre>

<p>And change it:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (int argc, const char * argv[]) {
    const char *str = ""teststring"";

    int out = printf(""%s"", str);
    printf(""\nPrintf wrote %d bytes when printing %s\n"", out, str);

    return 0;
}
</code></pre>

<p>Compile / run the edited version and you should immediately see the difference. Modify the length of <code>str</code> then compile and run it again.</p>

<p>Now, just a tiny change to your original code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (int argc, const char * argv[]) {
    char out = printf(""teststring\n"");
    printf(""%d\n"", out);

    return 0;
}
</code></pre>

<p>You can see now, you are printing two different things, and <code>out</code> has become 11, since a newline was added. Nothing is actually trailing here. Then change <code>%d</code> to <code>%c</code> (the correct format specifier for <code>out</code> in your example) and notice the difference. ASCII (11) is a vertical tab (see <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">here</a>). YTMV (your terminal may vary). Here, you printed a character, not a character representation of an integer.</p>

<p>The actual <em>type</em> that <code>printf()</code> returns is <code>int</code>, which is an integer. The reason for this is so that you know exactly how many bytes <code>printf()</code> actually printed. This typical for that family of functions, but more useful for functions like <code>snprintf()</code> so you can know if it could not print the entire length of any given format to a buffer. Note that the return type is <strong><em>signed</em></strong>, it can be negative, so the storage type you pick to store its value matters quite a bit, especially if you work with that value while assuming that its greater than or equal to zero.</p>

<p>Here is a <a href=""http://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output"" rel=""nofollow noreferrer"">handy tutorial</a> to format specifiers you can use with the <code>printf()</code> family of functions. More importantly, check the return type of the functions that you are using.</p>

<p>I also suggest <a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language_(book)"" rel=""nofollow noreferrer"">spending some quality time with this book</a>, be sure to work through the exercises as time permits. Its the best self-study course in C and the exercises are fun. When you get a solid grasp of C, work through the exercises again .. then compare your answers, its eye opening :)</p>
",0
2934857,2934783,0,"<pre><code>int main(int argc, char *argv[])
{
    const char *str = ""This is a constant string"";

    printf(""%s\n"", str);

    return 0;
}</code></pre>

<p><code>%s</code> is the format specifier for a string. <code>%d</code> is the format specifier for a decimal representation of an integer. <code>printf</code> will return the number of characters written to the output.</p>
",0
2424241,2424179,2,"<p>An input function will be secure/safe(not allow buffer overflow) if it takes the length of the buffer as an arguments so that the function does not read more char than the buffer can hold.</p>

<p>Of the function you've listed fgets() and read() take the buffer length as argument and can be considered safe.</p>
",0
2424271,2424179,0,"<p>Seems like you are simply asking how to read in a file. Google was helpful for me:</p>

<p><a href=""http://www.cprogramming.com/tutorial/cfileio.html"" rel=""nofollow noreferrer"">http://www.cprogramming.com/tutorial/cfileio.html</a></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx</a></p>

<p>Read around or expand your question so we can answer you better.</p>
",2
2456095,2456086,97,"<p>This type of evaluation is called <a href=""http://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""noreferrer"">short-circuiting</a>. 
Once the result is 100% clear, it does not continue evaluating.</p>

<p>This is actually a common programming technique.
For example, in C++ you will often see something like:</p>

<pre><code>if (pX!=null &amp;&amp; pX-&gt;predicate()) { bla bla bla }
</code></pre>

<p>If you changed the order of the conditions, you could be invoking a method on a null pointer and crashing. A similar example in C would use the field of a struct when you have a pointer to that struct.</p>

<p>You could do something similar with or:</p>

<pre><code>if(px==null || pX-&gt;isEmpty()} { bla bla bla }
</code></pre>

<p>This is also one of the reasons that it is generally a good idea to avoid side effects in an if condition.</p>

<p>For example suppose you have: </p>

<pre><code>if(x==4 &amp;&amp; (++y&gt;7) &amp;&amp; z==9)
</code></pre>

<p>If <code>x</code> is <code>4</code>, then <code>y</code> will be incremented regardless of the value of <code>z</code> or <code>y</code>, but if <code>x</code> is not <code>4</code>, it will not be incremented at all.</p>
",1
2456415,2456086,43,"<p>The operators <code>&amp;&amp;</code> and <code>||</code> guarantee that the left-hand side expression will be fully evaluated (and all side effects applied) before the right-hand side is evaluated. In other words, the operators introduce a sequence point.  </p>

<p>Additionally, if the value of the expression can be determined from the lhs, the rhs is not evaluated.  In other words, if you have an expression like <code>x &amp;&amp; y</code>, and x evaluates to 0 (false), then the value of the expression is false regardless of y, so y is not evaluated.  </p>

<p>This means that expressions like <code>x++ &amp;&amp; x++</code> are well-defined, since <code>&amp;&amp;</code> introduces a sequence point.  </p>
",0
3704677,3704624,20,"<pre><code>:( #include &lt;string.h&gt; :(
#include ""stdafx.h""
</code></pre>

<p>Fun quirk of the MSVC compiler, it generates the exact same error when you compile it like that.  Yes, not a lot of 'fun'.  It skips everything to find the stdafx.h precompiled header include directive.  The string.h doesn't actually get included.  Fix:</p>

<pre><code>#include ""stdafx.h""
#include &lt;string.h&gt;
</code></pre>

<p>Always put the stdafx.h include first.</p>
",10
2934804,2934785,0,"<p>Look up <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strtok/"" rel=""nofollow noreferrer"">strtok</a> and tokenizing. </p>

<p>Make sure you think about several things, such as figuring out the length of the array you need (memory management), keeping track of where in the array you are, etc.</p>
",0
2934848,2934785,1,"<p>Use something like this.
And if you want a reentrant code, see <code>man strtok_r</code></p>

<pre><code>#define MAX_BUFFER 200

float Read(FILE* pFile)
{
    char line[MAX_BUFFER];

    while(fgets(line, MAX_BUFFER, pFile) != NULL)
    {
        char* ptr = strtok(line, "" "");

        while(ptr != NULL)
        {
            printf(""2.5f "", (float)atof(ptr));
            ptr = strtok(NULL, "" "");
        }

        printf(""\n"");
    }
}
</code></pre>

<p>Note that you wrote line[50] but read 200 in fgets(), that is, a
potential buffer overflow.
'i' isn't even declared and pFile is never used.</p>
",3
2367798,2367505,1,"<p>Your question is somewhat unclear. What exactly do you have? Do you have an array with elements holding the individual bits of your value? Then you need to compose the real value out of those bits, like</p>

<pre><code>bit[0] = 0;
bit[1] = 0;
bit[2] = 1;
unsigned int value = (bit[0]) | (bit[1]&lt;&lt;1) | (bit[2]&lt;&lt;2);
</code></pre>

<p>Or do you have a value you want to display as binary? Then you need to convert from a value to a binary representation by extracting the individual bits and displaying the appropriate character. Unfortunately no binary presentation modifier is available for standard functions using format strings (as <code>%x</code> is for hexadecimal strings).</p>

<p>Or do you have a string represenation of a value in binary format? In this case you might want to look at <a href=""http://linux.die.net/man/3/strtoul"" rel=""nofollow noreferrer"">strtoul</a>, which can convert string representations of values to their value for a range of number bases, including the base 2.</p>

<p>In general, a number in C does not have a binary, hexadecimal or whatever format. A number is a number, and the only format it does have (apart from the representation on the real machine) is simply its length and whether it is signed or unsigned (I'm leaving out floating point numbers here). ""Binary"", ""hexadecimal"", ""decimal"" and the like are only representations of the same value for the reader -- i.e., the human. The value on the machine is absolutely identical regardless of that representation.</p>

<pre><code>binary = newState[i-2], newState[i-1], newState[i]; // but if I did this, bin = 0, not 001.
</code></pre>

<p>This is an expression that uses the <a href=""http://c-faq.com/~scs/cclass/int/sx4db.html"" rel=""nofollow noreferrer"">comma operator</a>. You can't concatenate values or strings like that in C. </p>
",0
2367568,2367505,0,"<p>if you want to hold array of binary values you can use <code>int</code> for that. So you automatically get the number.  getting the values is also easy to bet ith bit you call <code>(x &amp; (1 &lt;&lt; i))</code></p>
",2
6606908,6590593,1,"<pre><code>void main()

{

   clrscr();

   int in[10][10];
   int out[10][10];

   int row,column,i,j;
   printf(""enter row"");
   scanf(""%d"",&amp;row);
   printf(""Enter column"");
   scanf(""%d"",&amp;column);
   //storing values in matrix
   for(i=1;i&lt;=row;i++)
   {
      for(j=1;j&lt;=column;j++)
      {
        printf(""Enter (%d,%d)th value"",i,j);
        scanf(""%d"",&amp;in[i-1][j-1]);
      }
   }
   //show stored values
   printf(""\ninput is\n\n"");
   for(i=0;i&lt;row;i++)
   {
      for(j=0;j&lt;column;j++)
      {
        printf(""%d\t"",in[i][j]);
      }
      printf(""\n"");
   }
   //show transposed value. it is also stored in out matrix
   printf(""\nOutput is\n\n"");
   for(i=0;i&lt;column;i++)
   {
      for(j=0;j&lt;row;j++)
      {
        printf(""%d\t"",in[j][i]);
        out[i][j]=in[j][i];
      }
      printf(""\n"");
   }

   getch();

}
</code></pre>

<p>//////////////////////////////////////</p>

<p>input matrix is stored in in[][] matrix and output matrix stored in out[][] matrix.
this program will work for any matrix with row and column below 10 if we increase the matrix variable value ,it will work for larger matrix also .</p>
",0
2644574,2644476,5,"<blockquote>
  <p>what's the difference between ""\x"" in
  the beginning of a char to 0x in the
  beginning of char</p>
</blockquote>

<p>The difference is that 0x12 is used for specifying an <em>integer</em> in hexadecimal, while ""\x"" is used for <em>string literals</em>. An example:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
  int ten = 0xA;
  char* tenString = ""1\x30"";
  printf(""ten as integer: %d\n"", ten);
  printf(""ten as string: %s\n"", tenString);
  return 0;
}
</code></pre>

<p>The printf's should both output a ""10"" (try to understand why).</p>

<blockquote>
  <p>when casting char to (unsigned), not
  (unsigned char) - what does it mean?
  why (unsigned)'\xFF' != 0xFF?</p>
</blockquote>

<p>""unsigned"" is just an abbreviation for ""unsigned int"". So you're casting from char to int. This will give you the numeric representation of the character in the character set your platform uses. Note that the value you get for a character is platform-dependent (typically depending on the default character encoding). For ASCII characters you will (usually) get the ASCII code, but anything beyond that will depend on platform and runtime configuration.</p>

<p>Understanding what a cast from one typ to another does is very complicated (and often, though not always, platform-dependent), so avoid it if you can. Sometimes it is necessary, though. See e.g. <a href=""https://stackoverflow.com/questions/1942159/need-some-clarification-regarding-casting-in-c"">need-some-clarification-regarding-casting-in-c</a></p>
",2
2911879,2911839,-1,"<p>Because there is a difference between a declaration and a definition. <code>int i;</code> does nothing more than introducing a name. <code>int i = 10;</code> on the other hand defines <code>i</code>, hence, a place in the memory must be reserved to store the value it corresponds to. But it is impossible for the compiler to know which value corresponds to <code>i</code> as you want to associate two memory locations with the name <code>i</code>.</p>

<p>This is under the assumption that you link these files against eachother, which is not entirely clear from your explanation.</p>
",3
2911904,2911839,3,"<p>You may be interested in this question and the answers. Keywords: ""tentative definition"".</p>

<p><a href=""https://stackoverflow.com/questions/1490693/tentative-definitions-in-c99-and-linking"">Tentative definitions in C99 and linking</a></p>
",0
2911978,2911839,1,"<p>Assuming you really want an <strong>independent</strong> variable called i in each of these two files, you need to prefix them with <code>static</code> in order to give them <a href=""http://publications.gbdirect.co.uk/c_book/chapter4/linkage.html"" rel=""nofollow noreferrer"">internal linkage.</a></p>

<pre><code>static int i = 10;
</code></pre>

<p>If you want i to be the same variable in both files, so changes in one affect the other, use the answers you were <a href=""https://stackoverflow.com/questions/2910660/how-do-i-avoid-this-linking-error"">given 3 hours ago</a> when you asked a variant of the question. If it is to be shared, you need to define the variable in one place.</p>

<p>As to why it didn't cause an error without the init, I think that's because you weren't using the variable until it needed initializing and so the compiler ignored it.</p>
",0
2384046,2384016,2,"<p>Is that really all?</p>

<pre><code>char buf[1];
buf[0] = char(1);
</code></pre>

<p>If you want bit masking then it would be something like</p>

<pre><code>enum Enum
{
    MASK_01 = 0x1,
    MASK_02 = 0x2,
    MASK_03 = 0x4,
    MASK_04 = 0x8,
};

char buf[4];
buf[0] = Enum::MASK_01;
buf[1] = Enum::MASK_02;
buf[2] = Enum::MASK_03;
buf[3] = Enum::MASK_04;
</code></pre>

<p>If you provide information on what you are actually trying to do, we may be able to help you more.</p>

<p><b>EDIT:</b> Thanks for the extra information. Does this help:</p>

<pre><code>enum Enum
{
    BIT_0000000000000001 = 0x0001,
    BIT_0000000000000010 = 0x0002,
    BIT_0000000000000100 = 0x0004,
    BIT_0000000000001000 = 0x0008,
    BIT_0000000000010000 = 0x0010,
    BIT_0000000000100000 = 0x0020,
    BIT_0000000001000000 = 0x0040,
    BIT_0000000010000000 = 0x0080,
    BIT_0000000100000000 = 0x0100,
    BIT_0000001000000000 = 0x0200,
    BIT_0000010000000000 = 0x0400,
    BIT_0000100000000000 = 0x0800,
    BIT_0001000000000000 = 0x1000,
    BIT_0010000000000000 = 0x2000,
    BIT_0100000000000000 = 0x4000,
    BIT_1000000000000000 = 0x8000,
};


int main( int argc, char* argv[] )
{
    char someArray[8];
    memset( someArray, 0, 8 );

    // create an int with the bits you want set
    int combinedBits =  BIT_0000000000000001|
                        BIT_0000000000000010|
                        BIT_1000000000000000;

    // clear first two bytes
    memset( someArray, 0, 2 );

    // set the first two bytes in the array
    *(int*)someArray |= combinedBits;

    // retrieve the bytes
    int retrievedBytes = *(int*)someArray;

    // test if a bit is set
    if ( retrievedBytes &amp; BIT_0000000000000001 )
    {
        //do something
    }
}
</code></pre>

<p>Now the naming of the enums is intentionally intense for clarity. also you may notice that there are only 16 bits in the enum, instead of a possible 32 for an int. This is because you mentioned the first two bytes. Using this method, only the first two bytes of the array will be changed, using those enums. Im not sure if this code would be messed up by endianess, so you will have to make sure you test on your own machines. HTH.  </p>
",1
2384050,2384016,1,"<p>You put bits in a character array using C or C++ the way you put anything into anything else -- they're all bits anyway.</p>

<p>Since <code>sizeof(char) == 1</code> by definition, you can only put 8 bits per element of the array.</p>

<p>If you need help with how to twiddle bits, that's an entirely different issue and has nothing to do with <code>char</code>s and arrays.</p>
",0
2384119,2384016,2,"<p>Maybe this more generic code will give you the idea:</p>

<pre><code>void setBitAt( char* buf, int bufByteSize, int bitPosition, bool value )
{
    if(bitPosition &lt; sizeof(char)*8*bufByteSize)
    {
        int byteOffset= bitPosition/8;
        int bitOffset = bitPosition - byteOffset*8;

        if(value == true)
        {
            buf[byteOffset] |=  (1 &lt;&lt; bitOffset);
        }
        else
        {
            buf[byteOffset] &amp;= ~(1 &lt;&lt; bitOffset);;
        }
    }
}

//use it as follow:
char chArray[16];
setBitAt(chArray,16*sizeof(char),5,true); //to set bit at pos 5 to 1
</code></pre>
",0
2437554,2384016,0,"<p>C doesn't support binary literals, so you'll have to represent the value as hex.</p>

<pre><code>char *p;

*p++ = 0x10;
*p++ = 0xFE;
</code></pre>

<p>Take a look at the functions <code>hton()</code> and <code>htonl()</code> for converting multi-byte values to network-byte-order.</p>
",0
2914232,2912136,0,"<p>First of all, <strong>do not</strong> use leading underscores for variable or function names; such names are reserved for the implementation.</p>

<p>Everyone else has pointed out the right way to initially allocate the vector:</p>

<pre><code>static void engine_allocate_vec(event_callback **vec)
{
  *vec = malloc(sizeof **vec * initial_vecsize);
}
</code></pre>

<p>Notice a couple of things.  First of all, I do not cast the result of <code>malloc</code>.  It isn't necessary (as of C89, anyway; earlier versions of C require a cast, as does C++), and it can potentially suppress a compiler diagnostic if you forget to include <code>stdlib.h</code> or otherwise don't have a prototype for <code>malloc</code> in scope.  Second of all, I'm calling sizeof on the expression <code>**vec</code>, not the type; since the type of the expression <code>**vec</code> is<code>event_callback</code>, <code>sizeof **vec</code> returns the same result as <code>sizeof (event_callback)</code>.  This helps cut down on visual clutter, and it avoids a somewhat common bug that creeps in when someone changes the type of the variable, but doesn't carry that change through to the <code>sizeof</code> expression in the malloc call, such as</p>

<pre><code>double *f; /* was originally declared as float, later changed to double */
...
f = malloc(sizeof (float) * size); /* type change not carried through */
</code></pre>

<p>Note that <code>sizeof</code> does not evaluate its operand (unless it's a VLA), so you don't have to worry about calling it on an uninitialized pointer expression.</p>

<p>This helps you create the initial vector.  However, you'd like to be able to extend the vector as necessary when registering more than <code>initial_vecsize</code> callbacks, right?  If so, let me suggest the following:</p>

<pre><code>static int engine_allocate_vec(event_callback **vec, 
  size_t *currentSize, 
  size_t extent)
{
  int success = 0;
  /**
   * Assign the result of realloc to a temporary; realloc returns NULL
   * on failure, and we don't want to risk losing our pointer to the
   * previously allocated memory.  Similarly, we don't update *currentSize
   * unless the call succeeds.  Note that realloc(NULL, size) is equivalent
   * to malloc(size).
   */
  event_callback *tmp = realloc(*vec, sizeof *tmp * (*currentSize + extent));
  if (tmp != NULL)
  {
    *vec = tmp;
    *currentSize += extent;
    success = 1;
  }
  return success;
}
</code></pre>

<p>Then your register function becomes:</p>

<pre><code>/**
 * Adding vector_count variable to keep track of the number
 * of items in the vector as opposed to the physical size
 * of the vector.
 */
static size_t vector_count = 0;

void register_callback_event(event_callback func)
{
  if (!vec)
  {
    /**
     * Initial vector allocation
     */
    if (!engine_allocate_vec(&amp;vec, &amp;vecsize, initial_vecsize))
    {
      /* allocation failed; treating this as a fatal error */
      exit(0);
    }
  }
  else if (vector_count == vecsize)
  {
    /**
     * Need to extend the vector to accomodate 
     * the new callback.  Double the vector size (i.e.,
     * extend it by the current vector size)
     */
    if (!engine_allocate_vec(&amp;vec, &amp;vecsize, vecsize))
    {
      /* extension failed - treating this as a fatal error*/
      free(vec);
      exit(0);
    }
  }

  vec[vector_count++] = func;
}
</code></pre>
",1
2912170,2912136,1,"<p>At the line:</p>

<pre><code>vec[vecsize++] = func; //error here!  
</code></pre>

<p>What happens if <code>vecsize</code> is <code>&gt;= initial_vecsize</code> ?</p>

<p>Also <code>__engine_allocate_ve</code> doesn't work since it only modifies the local copy of <code>vec</code>, you have to change the signature to a <code>**</code> and pass the argument with <code>&amp;</code>.</p>

<p><code>static void __engine_allocate_vec(engine_callback** vec)</code></p>

<p><code>__engine_allocate_vec(&amp;vec);</code></p>
",2
2912176,2912136,3,"<p>The allocation function should be:</p>

<pre><code>static void __engine_allocate_vec(engine_callback** vec) {  
    *vec =  malloc(sizeof(engine_callback) * initial_vecsize);  
}  
</code></pre>

<p>and then:</p>

<pre><code>if (!vec)  
    __engine_allocate_vec(&amp;vec);  
</code></pre>

<p>Note that the pointer type mismatch in your original allocate function would have been caught if you had omitted the cast. also, don't use names containing double underscores in your code - they are meant for the implementation's use.</p>
",0
2912196,2912136,0,"<p>You seem to be <code>malloc</code>-ing based on <code>sizeof(engine_callback*)</code> rather than <code>sizeof(engine_callback)</code> ...</p>
",0
2912218,2912136,0,"<p>Your <code>__engine_allocate_vec</code> function is creating space for new <code>engine_callback</code>s, but it's not doing anything useful with that pointer. (It's changing its local version of vec, which was passed by value -- so the changes don't make it back to the caller.  And the argument's name hides the global's name, so that's not getting set either.) So when it returns, your pointer's still null.</p>

<p>Try something like this...</p>

<pre><code>static void __engine_allocate_vec(engine_callback** vec) {
    *vec = (engine_callback*) malloc(sizeof(engine_callback) * initial_vecsize);
}
</code></pre>

<p>Then in register_event_callback, pass <code>&amp;vec</code> to the function instead of <code>vec</code>.</p>

<p>Or, make the function void and let it set the global itself.  Nah, forget i said that.</p>
",0
2935014,2935009,4,"<p>This is not defined.</p>

<p>You can find the Committee Draft from May 6, 2005 of the C-standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow noreferrer"">here</a> (pdf)</p>

<p>See section <code>6.5 Expressions</code>:</p>

<blockquote>
  <p>2    Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored.</p>
</blockquote>

<p>and the example:</p>

<blockquote>
  <p>71)    This paragraph renders undefined statement expressions such as</p>
  
  <p>i = ++i + 1; </p>
  
  <p>a[i++] = i;</p>
</blockquote>
",11
2935016,2935009,1,"<p>The answer is actually <em>undefined</em>.</p>
",0
2935027,2935009,-1,"<p>Answer in <em>undefined</em> because you've got some situations in which the parser doesn't know how to parse the code..</p>

<p>is <code>a+++b</code>: <code>a + ++b</code> or <code>a++ + b</code>?</p>

<p>Think the fact that usually white space is just ignored when lexing the source code. It may depends upon implementation of the compiler (and some other languages with same <code>++</code> operators may choose to give priority to one instead of another) but in general this is not safe.</p>

<p>For example in Java your code line gives 37 as the answer, because it chooses to bind <code>++</code> operators in a specific way according to precedence, but it's just a choice..</p>
",5
7511242,7511225,5,"<p>In C, you have to declare all of your local variables first, at the beginning of the scope. You should move the <code>struct Player cpu;</code> declaration on the line right after <code>struct Player player;</code></p>
",0
7511325,7511225,1,"<p>In addition to @Didier, you can make a .cpp file instead of .c with the content you have and the compiler will run well</p>
",0
7511372,7511225,0,"<p>What you have written is valid C++ but not valid C. Change your filename to main.cpp and it should build just fine in Visual Studio.</p>
",0
6669011,6668920,4,"<blockquote>
  <p>would I be correct in assuming that the C specification makes no claims as to the ""atomicity"" of these operations.</p>
</blockquote>

<p>Yes. The current standard (both C99 and C89, IIRC) makes no claims about atomicity. That is definitely platform-specific, and probably depends on the compiler as well.</p>

<p>Why is it necessary for these operations to be atomic, if I may ask?</p>
",3
6669016,6668920,0,"<p>Regardless of what the standard specifies, 80x86 pointer arithmetic and assignments on ""huge"" pointers was not atomic, but pointer increments and assignments are apt to be composed of an atomic read and an atomic write on all platforms where ""int"" is 32 bits or larger <i>or</i> where a pointer is the same size as an 'int' (some embedded platforms have things like 16 bit int but 24-bit pointer).  The read-modify-write sequence is almost never going to form an atomic unit on any multi-processor architecture, however, unless one takes explicit measures to make it behave as such.</p>
",0
6669024,6668920,0,"<p>There is never a guarantee of atomicity unless explicitly documented.  Under the current C standard, that means that <strong>no</strong> portable code can guarantee atomicity -- atomic operators are necessarily platform-specific.</p>

<p>As @ninjalj notes in his comment, C1x will add atomic operators.</p>
",0
6669108,6668920,1,"<p>C standard have no atomic operations at all. However there are some GCC built-ins <a href=""http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html"" rel=""nofollow"">described here</a>, and there are some in <a href=""http://www.open-std.org/JTC1/sc22/wg21/docs/papers/2007/n2427.html#DiscussOperations"" rel=""nofollow"">C++0X stanard</a>. And you always can use POSIX or other multithreading library or inline assembler in your code.</p>
",0
3019426,2993763,1,"<p>The argument against VLAs runs that because of the absolute badness of overflowing the stack, by the time you've done enough thinking/checking to make them safe, you've done enough thinking/checking to use a fixed-size array:</p>

<p>1) In order to safely use VLAs, you must know that there is enough stack available.</p>

<p>2) In the vast majority of cases, the way that you know there's enough stack is that you know an upper bound on the <code>size</code> required, and you know (or at least are willing to guess or require) a lower bound on the stack available, and the one is smaller than the other. So just use a fixed-size array.</p>

<p>3) In the vast majority of the few cases that aren't that simple, you're using multiple VLAs (perhaps one in each call to a recursive function), and you know an upper bound on their <em>total</em> size, which is less than a lower bound on available stack. So you could use a fixed-size array and divide it into pieces as required.</p>

<p>4) If you ever encounter one of the remaining cases, in a situation where the performance of <code>malloc</code> is unacceptable, do let me know...</p>

<p>It may be more convenient, from the POV of the source code, to use VLAs. For instance you can use <code>sizeof</code> (in the defining scope) instead of maintaining the size in a variable, and that business with dividing an array into chunks might require passing an extra parameter around. So there's some small gain in convenience, sometimes.</p>

<p>It's also easier to miss that you're using a humongous amount of stack, yielding undefined behavior, if instead of a rather scary-looking <code>int buf[1920*1024]</code> or <code>int buf[MAX_IMG_SIZE]</code> you have an <code>int buf[img-&gt;size]</code>. That works fine right up to the first time you actually handle a big image. That's broadly an issue of proper testing, but if you miss some possible difficult inputs, then it won't be the first or last test suite to do so. I find that a fixed-size array reminds me either to put in fixed-size checks of the input, or to replace it with a dynamic allocation and stop worrying whether it fits on the stack or not. There is no valid option to put it on the stack and <em>not</em> worry whether it fits...</p>
",0
3441743,3441700,0,"<p>Don't include <code>\n</code> in your <code>scanf()</code> format string, this might cause your program to wait for two enters.</p>

<p>So in <code>report_fun()</code> change</p>

<pre><code>scanf(""%d\n"",&amp;pos);
</code></pre>

<p>to</p>

<pre><code>scanf(""%d"",&amp;pos);
</code></pre>

<h3>Update</h3>

<p>In <code>main()</code> you call <code>report_fun</code>() in the child process instead of the parent. You might want to reverse the <code>if (cpuid == 0)</code> test.</p>

<p>And please, use <code>int main(void)</code> instead of <code>void main()</code> and end your main function with <code>return 0;</code>.  </p>
",1
3866393,3866352,1,"<p>Look at <a href=""http://linux.die.net/man/2/stat"" rel=""nofollow"">stat</a>. It will provide you with the information you want; all you have to do is interpret it.</p>

<p><strong>Edit:</strong> A brief example.</p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

#define TRUE 1
#define FALSE 0

int is_dir(char *path)
{
    struct stat dir_stats;

    stat(path, &amp;dir_stats);
    if (S_ISDIR(dir_stats.st_mode))
        return TRUE;
    return FALSE;
}
</code></pre>

<p>For the list of files in the directory, use <a href=""http://linux.die.net/man/2/readdir"" rel=""nofollow"">readdir</a>.</p>
",4
3867280,3866352,1,"<p>The word directory doesn't even appear in the C standard. This is an OS concept.</p>
",0
2923622,2923366,2,"<p>This happens because your number is -infinite.</p>

<p>Try to print the numbers without the length specifier 12.2 (use just %lf ). In this case, the output will be:
-1.#INF00 (or something like that).</p>
",0
3437784,3437697,0,"<p>It's machine dependent, but this usually works one of two ways:</p>

<pre><code>union {
    unsigned char b [8];
    long long     i;
} v;
v .i = seq_gen_value;
for (int j = 0;  j &lt; 8;  ++j)
    printf (""%d, "", v .b [j]);
</code></pre>

<p>On a little endian machine (x86, vax, etc.) the bytes come out with the least significant first.  On a big endian machine, they come out with the most significant first.</p>

<hr>

<p>By the way, it would be more useful to encode the ""magic numbers"" so that they can be more easily understood what they mean.  For example, instead of <code>1976943448883713</code>, write it as <code>0x7060504030201</code>.</p>
",1
3437814,3437697,0,"<p>I think that your function do something like </p>

<pre><code>return 1976943448883713 + 8 * 2260630401189896
</code></pre>

<p>And I think your question is not clear enough, like what array you want to return each its number? If you want to return array temp_data, it very easy. You can do that by <br></p>

<pre><code>int next_exp_data(unsigned long long int expected_data, unsigned long long int temp_data[])
{
  int i=0;
  unsigned long long int seq_gen_value=1976943448883713;
  temp_data[0]=seq_gen_value;
  for(i=0;i&lt;10;i++)
  { 
     printf(""%llu"",temp_data[i]);
     putchar('\n');
     expected_data=temp_data[i]; 
     temp_data[i+1]=temp_data[i] +2260630401189896;
  }
  return (expected_data);
}   
</code></pre>

<p>Call this function with the second params is a array int with size 10.
And another thing, I don't think that this function need the 1st param, because it's not be used within the function, so you can remove that from functions params list<br></p>

<pre><code>int next_exp_data( unsigned long long int temp_data[])
{
  int i=0;
  unsigned long long int expected_data;
  unsigned long long int seq_gen_value=1976943448883713;
  temp_data[0]=seq_gen_value;
  for(i=0;i&lt;10;i++)
  { 
     printf(""%llu"",temp_data[i]);
     putchar('\n');
     expected_data=temp_data[i]; 
     temp_data[i+1]=temp_data[i] +2260630401189896;
  }
  return expected_data; //dont use (expected_data), it will make things slower.
} 
</code></pre>
",2
3438469,3437697,1,"<p>Comparing numbers in C is done using ==, !=, &lt;= , >= , &lt;, or >.</p>

<p>I didn't read your code as it's horrible formatted and doesn't seem relevant to your question as posed in the title.</p>
",0
7162892,7153946,1,"<p>I figured it out, following a comment by R.. further above who pointed me in the direction of ASLR.</p>

<p>I was unfamiliar with ASLR stack protection. What I describe is due to ASLR scrambling the memory address space to prevent prediction of the location of variables relative to it. ASLR has long been default switched on in LINUX kernels it appears.</p>

<p>To see what I meant, get su privileges, then enter (the precise integer to send might vary based on your distro; on mine it is 0, and the default 2. Also better confirm the file only contains 1 integer by first looking at it, as it does on my system):</p>

<pre><code>cd /proc/sys/kernel
export OLD=$(less randomize_va_space) // save old value to restore after
echo 0 &gt;  randomize_va_space  // 0 == turn off ASLR
</code></pre>

<p>Then run my little program again: it will report back the address I expected (around 0xbffffiii). After, obviously, restore old protection using</p>

<pre><code>echo $OLD &gt; randomize_va_space
</code></pre>

<p>Many thanks for everyone who spend some of their time trying to help.</p>
",0
4246501,4246445,1,"<p><code>const Foo * * foo</code> (or <code>Foo const * * foo</code>) is a pointer to a pointer to a const Foo.</p>

<p><code>Foo * const * foo</code> is a pointer to a const pointer to a Foo.</p>

<p><code>Foo * * const foo</code> is a const pointer to a pointer to a Foo.</p>
",1
4246507,4246445,0,"<p>In <code>const Foo **foo</code>, it's the actual <code>Foo</code> object which is const. So you can change <code>foo</code>, and you can change <code>*foo</code>, but you can't change <code>**foo</code>.</p>

<p>For <code>const Foo ***foo</code>, you can change <code>foo</code>, <code>*foo</code> and <code>**foo</code>, but not <code>***foo</code>.</p>

<p>For <code>Foo **const foo</code>, you can change <code>*foo</code> and <code>**foo</code>, but not <code>foo</code> itself.</p>
",0
4246477,4246445,8,"<p>You could use <a href=""http://www.cdecl.org/"">cdecl</a> to understand what a C declaration means.</p>

<pre><code>const int **foo;
declare foo as pointer to pointer to const int
</code></pre>

<p>thus you can change pointers, but not the value they're pointing to.</p>

<pre><code>int * const * const foo;
declare foo as const pointer to const pointer to int
</code></pre>

<p>this, instead, is a cosnt pointer, pointing to a const pointer, to a non-const int: you cannot change pointed value, but it can be changed.</p>

<hr>

<p>C uses the <a href=""http://c-faq.com/decl/spiral.anderson.html"">Clockwise/Spiral Rule</a>, in a case where you have only modifiers at the left side of the variable (of foo) you read stuff going from right to left:</p>

<pre><code>int(5) *(4) const(3) *(2) const(1) foo;
</code></pre>

<p><code>foo</code> is a constant(1) pointer(2) to constant(3) pointer(4) to an integer(5).</p>

<pre><code>int(6) const(5) *(4) const(3) *(2) const(1) foo;
const(6) int(5) *(4) const(3) *(2) const(1) foo; // [same as above]
</code></pre>

<p>In this case <code>foo</code> is a constant(1) pointer(2) to constant(3) pointer(4) to a constant(5) integer(6) [or to an integer(5) which is constant(6)].</p>
",0
4247403,4246445,0,"<p>Read types from the inside out. Starting from <code>foo</code>, <code>const Foo **foo;</code> reads <code>*</code> (pointer) to a <code>*</code> (pointer) to <code>const Foo</code> (a Foo object you're not allowed to modify). <code>Foo **const foo;</code> reads <code>const</code> (non-modifiable) <code>*</code> (pointer) to <code>*</code> (pointer) to <code>Foo</code> (a Foo object).</p>
",0
4247548,4246445,3,"<p>The <code>const</code> applies to the expression <code>**foo</code>; thus, <code>foo</code> and <code>*foo</code> are writable, but <code>**foo</code> is not.  </p>

<p>Some other examples:</p>

<pre><code>const Foo * const *foo;  // foo is writable, *foo and **foo are not
Foo * const * foo;       // foo and **foo are writable, *foo is not
Foo * const * const foo; // **foo is writable, foo and *foo are not
const Foo * const * const foo; // none of the expressions are writable
</code></pre>
",0
4248136,4246445,1,"<p>The easiest way to write such type expressions, I think, is to have the <code>const</code> always apply to the left. The one you gave can also be written:</p>

<pre><code>Foo const**foo;
</code></pre>

<p>Here the <code>const</code> only applies to what is left, thus <code>Foo</code>.</p>

<pre><code>Foo *const* foo;
</code></pre>

<p>Here on the left is <code>Foo*</code></p>

<pre><code>Foo const*const* foo;
</code></pre>

<p>is then <code>((Foo const)*const)*</code>.</p>

<p>When you in turn want to read such an expression, interchange the <code>const</code> and the bare type if necessary to have the <code>const</code> on the right.</p>
",1
6371872,6371831,7,"<p>You're looking for <a href=""http://www.gnu.org/s/libc/"" rel=""nofollow"">glibc</a>, rather than gcc.</p>
",0
6371917,6371831,7,"<p>You need to get the source code of the associated C library, probably <a href=""http://www.gnu.org/s/libc/"" rel=""noreferrer"">glibc</a> or <a href=""http://www.eglibc.org"" rel=""noreferrer"">eglibc</a> in your case.</p>

<p>In the /usr/include/ folder, only the headers of the libc are present, along with some linux kernel headers in the linux/ subfolder.</p>
",0
6372002,6371831,3,"<ul>
<li>.h files never contains code (well, at least they should. Macros are exceptions)</li>
<li>the basic C functions are either in glibc or linux kernel</li>
<li>gcc, linux and glibc code are huge beasts, if you are a beginning beginner, you should go for simpler things</li>
<li>you probably should take a simple library, one that offer a few tools, on a narrow subject. </li>
<li>then go for linux and glibc (or uclibc)</li>
</ul>

<p>I personnaly learnt many interesting stuff by reading microcontroller system libraries such as <a href=""http://www.nongnu.org/avr-libc/"" rel=""nofollow noreferrer"">http://www.nongnu.org/avr-libc/</a>, but this depends on what you need to do, and it requires a microcontroller to run it.</p>

<p>An idea: depending of what you're looking for, you could go for busybox: it is a reimplementation of many usefull system commands, you can learn a lot from it and running it do not require a dedicated computer.</p>

<p>Update: i asked a question related to glibc functions that got a few very interesting answers from my not-guru p.o.v: 
<a href=""https://stackoverflow.com/questions/6356123/where-to-find-select-source-code-in-glibc-source"">where to find select() source code in glibc source?</a></p>
",2
3437700,3437656,2,"<p>That because of the function scanf width param ""%c"", after the 1st time loop, at line <code>scanf(""%d"",&amp;c);</code>, like <strong>+</strong>, there's a <strong>end-line</strong> character in the input stream, then the second loop, scanf get the <strong>end-line</strong> character as the input and parse it to <strong>a</strong>;
To fix this, you can add a <code>scanf(""%c"");</code> line right after <code>scanf(""%d"",&amp;c);</code></p>
",4
3437816,3437656,2,"<p><code>scanf(""%d"",...</code> will read a number (skipping whitespace beforehand) but leave the newline on the input stream. <code>scanf(""%c"",...</code> will read the first character, and does not skip whitespace.</p>

<p>One simple modification is to use</p>

<pre><code>scanf("" %c"", &amp;a);
</code></pre>

<p>This will tell scanf to skip any whitespace before the character.</p>
",0
3440131,3437656,0,"<p>have a look at
<a href=""https://stackoverflow.com/questions/3439385/scanf-error-in-c-while-reading-a-character"">scanf error in c while reading a character</a></p>
",0
6351481,6351457,5,"<p>That code is creating a Node structure on the stack. As soon as you leave the function that node is destroyed. The pointer is the same because it is pointing to the same local variable on the stack each time. The solution is to allocate space on the heap for the variable with something like <a href=""http://msdn.microsoft.com/en-us/library/6ewkz86d.aspx"" rel=""nofollow"">malloc</a>:</p>

<pre><code>malloc( sizeof( Node ) )
</code></pre>

<p>You can then use the returned pointer in the way you have. Don't forget to <a href=""http://msdn.microsoft.com/en-us/library/we1whae7.aspx"" rel=""nofollow"">free</a> the nodes when you're done.</p>
",1
6351483,6351457,3,"<p>Your function does create a new <code>Node</code>, but only as a local variable.  When your <code>add()</code> function returns, it vanishes.  If you're calling <code>add()</code> in a loop, the address of the <code>Node</code> object on the stack is always going to be the same.</p>

<p>To make your new <code>Node</code> persistent, you will need to allocate some persistent memory for it - check out <a href=""http://linux.die.net/man/3/malloc"" rel=""nofollow""><code>malloc(3)</code></a> and <a href=""http://linux.die.net/man/3/free"" rel=""nofollow""><code>free(3)</code></a>.  A quick example:</p>

<pre><code>Node *node1 = malloc(sizeof(Node));
</code></pre>

<p>You will need to keep track of the <code>node1</code> pointer so as not to introduce a memory leak.  You can use <code>free(3)</code> later to destroy the allocation.</p>
",0
6351487,6351457,1,"<p><code>node1</code> is a local variable, so it gets recreated on every call to the function, and destroyed on every return.</p>
",0
6351488,6351457,1,"<p>node1 is local to your add function - if you want it to persist outside of that function, then allocate off the heap using malloc</p>
",0
6351498,6351457,1,"<p>A new <code>Node</code> is not created by the line <code>Node node1;</code>.  This line merely declares a variable whose scope is limited to the lifetime of the function (that is, the variable is placed on the stack).  When the function returns, <code>node1</code> no longer exists.</p>

<p>Since you are calling <code>add()</code> in a tight loop, what is probably happening is that each call to <code>add()</code> is getting assigned the same stack range and <code>node1</code> just happens to have the same address every time the function is called.</p>

<p>If each invocation of <code>add()</code> needs to have a unique <code>node1</code> with a unique address, then you will want to dynamically allocate the object with <code>malloc</code>.</p>
",0
4744180,4743836,4,"<p>See here for ASCII table : <a href=""http://web.cs.mun.ca/~michael/c/ascii-table.html"" rel=""nofollow"">http://web.cs.mun.ca/~michael/c/ascii-table.html</a></p>

<p>And why it printing 5 :- </p>

<p>Actually its '5' not 5. Your code is printing character 5 not decimal 5. When you use %c to print value of an integer variable, printf convert integer value with character equivalent (as you have seen in ASCII table).</p>

<p>You can try this code (or you should write your own)
<code><pre>
void main()
{
    int num;
    printf(""Printing ASCII values Table...\n\n"");
    num = 1;
    while(num&lt;=255)
    {
       // here you can see how %c and %d works for same variable
       printf(""\nValue:%d = ASCII Character:%c"", num, num); 
       num++;
     }
    printf(""\n\nEND\n"");
}
</pre> 
</code></p>

<p>Happy coding.</p>
",0
4743848,4743836,3,"<p>Why are you formatting it as %c
Use %d</p>

<blockquote>
  <p>printf(""there are %d  total pets
  are"",total_pets);</p>
</blockquote>
",0
4743852,4743836,2,"<p>why are you using <code>%c</code>. use <code>%d</code></p>

<pre><code>%c single character
%d and %i both used for integer type
%u used for representing unsigned integer
%o octal integer unsigned
%x,%X used for representing hex unsigned integer
%e, %E, %f, %g, %G floating type
%s strings that is sequence of characters
</code></pre>
",0
4743855,4743836,1,"<p>%c is to print a character. Try changing it to %d for the integer value.</p>

<p>What you are printing is the integer value interpreted as a character.</p>
",0
4743856,4743836,2,"<p>Because 53 is the place in the ascii chart where '5' sits.</p>

<p>Use %d in your printf instead.</p>
",0
4743857,4743836,1,"<p>You need to change the <code>%c</code> to a <code>%d</code>.</p>
",0
4743858,4743836,10,"<p>Use <code>%d</code> in place of <code>%c</code> in the <code>printf</code>.</p>

<p>The value of <code>total_pet</code> is <code>53</code>. When you use <code>%c</code> in <code>printf</code> you are trying to print the character whose <a href=""http://bestofthisweb.com/blogs/wp-content/uploads/2009/11/ascii_table2.jpg"" rel=""nofollow"">ASCII</a> value if <code>53</code> which happens to be <code>5</code>.</p>
",0
4743870,4743836,2,"<p><code>%c</code> is the character specifier so <code>printf(""there are %c total pets are"",total_pets);</code> prints the ascii character with the value 53, which is the <code>5</code> character.</p>
",0
2942844,2942773,2,"<p>Modern ethernet cards can compute the checksum in hardware, so TCP stacks tend to offload the job to the card. As a result, it is quite common for the checksum to be invalid in Wireshark.</p>

<p>Side note: There is an option in Wireshark to validate the checksum:</p>

<pre><code>Edit
  Preferences
    Protocols
      TCP
        Validate the TCP checksum if possible
</code></pre>

<p>Turn this off to stop Wireshark nagging you about the checksum.</p>
",1
2942877,2942773,0,"<p>Is this actually causing a problem - i.e. does the packet with ""bad checksum"" get dropped or processed incorrectly? Or are you just worried about the ""bad checksum"" notification? If the packets are processed OK, this may be just checksum offloading and it's nothing to worry about.</p>

<p><a href=""http://www.wireshark.org/docs/wsug_html_chunked/ChAdvChecksums.html"" rel=""nofollow noreferrer"">Wireshark documentation</a> says:</p>

<blockquote>
  <p>If the received checksum is wrong, Wireshark won't even see the packet, as the Ethernet hardware internally throws away the packet.</p>
</blockquote>
",2
2944990,2942773,0,"<p>Hey, answering in her name.
The GET and ACK are separated, and yes the GET request is sent completely, this being said based on the fact that the packets are sent by Firefox or Wget. we do not create the packets, nor the responses of the server (which is an Apache).</p>

<p>Our code just runs in the middle. we have a 3rd machine besides the Client and the Server, and all of the three are Virtual Machines (in VMWare Server [NAT, Client = Ubuntu; Server = Fedora]). it has 2 NIC's (each one connected to each subnet accordingly) and it's goal is to change the Source IP and Source Port fields (in both directions of network traffic).</p>

<p>Thanks for the explanation about TCP checksum offload, which is guessed to happen by wireshark, but in my opinion is not the case because the error appears in the server side too (not 100% sure if that rules out the possibility, thoughts?).
If I'm right, what could be the reason for the checksum's incorrectness?</p>

<p>Here is a link to the current code:
<a href=""http://rapidshare.com/files/393704745/13.5.10.tar.gz"" rel=""nofollow noreferrer"">http://rapidshare.com/files/393704745/13.5.10.tar.gz</a></p>

<p>Thanks a lot,
Aviv.</p>

<p>If it's better as a code in here, there you go:</p>

<pre><code>




#include ""./main.h""


int main(int argc, char **argv)
{
    pcap_t *pcapInt, *pcapExt;                      /* pcap descriptor */
    u_char *intPacket, *extPacket;
    int i;
    struct pcap_pkthdr intPkthdr, extPkthdr;
    char errbuf[PCAP_ERRBUF_SIZE];
    struct bpf_program filter_code;
    bpf_u_int32 intLocalNet, intNetmask, extLocalNet;

    for(i=0;i to quit\n"");

    /* read the configuration file and store it's data in an array */
    LIBXML_TEST_VERSION
    xmlNode *cur_node = xmlDocGetRootElement(xmlReadFile(((argv[1]) != NULL ? argv[1] : ""conf.xml""), NULL, 0));
    strcpy(config.filter, """");

    XMLtoConf(cur_node);
    strcat(config.filter, "" and not src host 192.168.191.137"");
    printf(""FILTER: %s\n"", config.filter);


    /* get network number and mask associated with the internal capture device */
    if (pcap_lookupnet(config.intNIC, &intLocalNet, &intNetmask, errbuf) == -1) {
        fprintf(stderr, ""Couldn't get netmask for device %s: %s\n"",
            config.intNIC, errbuf);
        intLocalNet = 0;
        intNetmask = 0;
    }

    /* open internal capture device */
    pcapInt = pcap_open_live(config.intNIC, SNAP_LEN, 1, 1000, errbuf);
    if (pcapInt == NULL) {
        fprintf(stderr, ""Couldn't open device %s: %s\n"", config.intNIC, errbuf);
        exit(EXIT_FAILURE);
    }
    /* open external capture device */
    pcapExt = pcap_open_live(config.extNIC, SNAP_LEN, 1, 1000, errbuf);
    if (pcapExt == NULL) {
        fprintf(stderr, ""Couldn't open device %s: %s\n"", config.extNIC, errbuf);
        exit(EXIT_FAILURE);
    }

    /* make sure we're capturing on an Ethernet device [2] */
    if (pcap_datalink(pcapInt) != DLT_EN10MB) {
        fprintf(stderr, ""%s is not an Ethernet\n"", config.intNIC);
        exit(EXIT_FAILURE);
    }
    if (pcap_datalink(pcapExt) != DLT_EN10MB) {
        fprintf(stderr, ""%s is not an Ethernet\n"", config.extNIC);
        exit(EXIT_FAILURE);
    }

    /* compile the internal filter expression */
    if (pcap_compile(pcapInt, &filter_code, config.filter, 1, intLocalNet) == -1) { //adsvfhakdhvkahdvkadh
        fprintf(stderr, ""Couldn't parse filter %s: %s\n"",
            argv[1], pcap_geterr(pcapInt));
        exit(EXIT_FAILURE);
    }
    /* compile the external filter expression */
    if (pcap_compile(pcapExt, &filter_code, NULL, 1, extLocalNet) == -1) { //adsvfhakdhvkahdvkadh
        fprintf(stderr, ""Couldn't parse filter %s: %s\n"",
            argv[1], pcap_geterr(pcapExt));
        exit(EXIT_FAILURE);
    }

    /* apply the compiled internal filter */
    if (pcap_setfilter(pcapInt, &filter_code) == -1) {
        fprintf(stderr, ""Couldn't install filter %s: %s\n"",
            argv[1], pcap_geterr(pcapInt));
        exit(EXIT_FAILURE);
    }
     //apply the compiled external filter 
    if (pcap_setfilter(pcapExt, &filter_code) == -1) {
        fprintf(stderr, ""Couldn't install filter %s: %s\n"",
            argv[1], pcap_geterr(pcapExt));
        exit(EXIT_FAILURE);
    }
    while (1 == 1)
    {     
        intPacket = (u_char*)pcap_next(pcapInt, &intPkthdr);
        extPacket = (u_char*)pcap_next(pcapExt, &extPkthdr);
        if (intPacket != NULL)
        {
            sniff(intPacket,0);
        } 
        if (extPacket != NULL)
        {
            sniff(extPacket,1);
        } 
    }

    printf(""\nCapture complete.\n"");
    /* cleanup */
    pcap_freecode(&filter_code);
    pcap_close(pcapInt);
    return (EXIT_SUCCESS);
}

int isStrBlank(unsigned char *s)
{
  if (!s || strcmp((char *)s, """") == 0) return 1;

  while(*s) {
    if ( (' ' != *s) && ('\n' != *s) && ('\r' != *s) && ('\t' != *s)) return 0;
    ++s;
  }
  return 1;
}

static void XMLtoConf(xmlNode* node)
{
     /*
     * this initialize the library and check potential ABI mismatches
     * between the version it was compiled for and the actual shared
     * library used.
     */
    LIBXML_TEST_VERSION
    xmlNode *cur_node = node;
    int i,flag=0;
    for (; cur_node; cur_node = cur_node->next) {
        if (cur_node->type == XML_ELEMENT_NODE) {
                //if (isStrBlank(cur_node->children->content) == 1) continue;

                if (strcmp((char *)cur_node->name, ""subnet_address"") == 0){
                    strcat(config.filter, ""src net "");
                    strcat(config.filter,(char *)cur_node->children->content);
                }
                //printf(""1: %s"", config.filter);
                if (strcmp((char *)cur_node->name, ""NIC"") == 0){
                    if (strcmp((char *)cur_node->parent->name, ""internal"") == 0){
                        config.intNIC = strdup((char *)cur_node->children->content);
                    }
                    else{
                        config.extNIC = strdup((char *)cur_node->children->content);
                    }
                }
                for (i = 0; strncmp((char *)cur_node->name, ""machine_"", 8) == 0; i++){

                    strcat(config.filter, "" and not"");
                    strcat(config.filter, "" src host "");
                    flag=1;
                    strcat(config.filter, (char *)cur_node->children->content);
                    cur_node = cur_node->next;
                }


        }
        XMLtoConf(cur_node->children);
    }
    /*
     *Free the global variables that may
     *have been allocated by the parser.
     */
    xmlCleanupParser();
    /*
     *  If device is NULL, that means the user did not specify one and is
     *  leaving it up libpcap to find one.
     */
}


void sniff(const u_char *packet , int flag)
{
    int i,x,tcpOpen=0;
    int protocol=-1; // 0- tcp, 1- udp, 2 -icmp
    tcp = (struct sniff_tcp*)(packet + 34); //skipping the ethernet and IP layers
    udp = (struct sniff_udp *)(packet + 34); //skipping the ethernet and IP layers
    ip = (struct sniff_ip *)(packet + SIZE_ETHERNET);
    icmp = (struct sniff_icmp *)(packet+ 34);
    ether = (struct sniff_ethernet *)(packet);

    printf(""/n1--%d/n"",IP_HL(ip)*4);
    //if(ntohs(tcp->th_sport) == 80 || ntohs(tcp->th_dport) == 80)
        //{

        if(ip->ip_p==IP_TYPE_TCP )
        {
            protocol = 0;
            payload_s = ntohs(ip->ip_len) - TH_OFF(tcp)*4 - IP_HL(ip)*4;

            if (payload_s)
                payload = (char* )(packet + SIZE_ETHERNET + TH_OFF(tcp)*4 + IP_HL(ip)*4);
            else
                payload = NULL;

        }
        else if(ip->ip_p == IP_TYPE_UDP){
            protocol = 1;
            payload_s = ntohs(ip->ip_len) - ntohs(udp->udp_len) - IP_HL(ip)*4;

            if (payload_s)
                payload = (char* )(packet + SIZE_ETHERNET + ntohs(udp->udp_len) + IP_HL(ip)*4);
            else
                payload = NULL;
        }
        else if(ip->ip_p == IP_TYPE_ICMP)
        {
            protocol = 2;
            payload_s = ntohs(ip->ip_len) - 8 - IP_HL(ip)*4;

            if (payload_s)
                payload = (char* )(packet + SIZE_ETHERNET + 8 + IP_HL(ip)*4);
            else
                payload = NULL;
        }   


            if(flag == 0)// we got a packet from the internal
            {
                if( ip->ip_p == IP_TYPE_TCP)
                {
                    for(i=0;iip_p)
                                if(nTable[i].ip_src.s_addr == ip->ip_src.s_addr)
                                    if(nTable[i].ip_dst.s_addr == ip->ip_dst.s_addr)
                                        if(ntohs(nTable[i].srcPort) == ntohs(tcp->th_sport))
                                            if(ntohs(nTable[i].dstPort) == ntohs(tcp->th_dport))
                                            {
                                                printf(""we are in an open connection \n"");
                                                changeSrcPacket(packet ,(i+2000)%8000 ,protocol);
                                                tcpOpen = 1;
                                                break;
                                            }
                    }           
                }
                if(tcpOpen == 0)
                {
                    for(i=0;iip_p == IP_TYPE_UDP ||ip->ip_p == IP_TYPE_TCP    )
                        {
                            if(nTable[i].free==0)
                            {
                                nTable[i].free=1;
                                nTable[i].ip_src = ip->ip_src;
                                nTable[i].ip_dst = ip->ip_dst;
                                nTable[i].srcPort = tcp->th_sport;
                                nTable[i].dstPort = tcp->th_dport;
                                nTable[i].protocol = ip->ip_p;
                                //printf(""index : %d  ipsrc : %s  srcport : %d\n"",i,inet_ntoa(nTable[i].ip_src),ntohs(nTable[i].srcPort));
                                ////////////change packet and send it with the src ip of the nat machine 
                                ///////////and the src port is (i+2000)%8000
                                changeSrcPacket(packet ,(i+2000)%8000 ,protocol);
                                break;
                            }
                        }
                        else
                        {
                            if(icmpTable[i].free == 0)
                            {
                                icmpTable[i].free=1;
                                icmpTable[i].ip_src = ip->ip_src;
                                icmpTable[i].ip_dst = ip->ip_dst;
                                icmpTable[i].protocol = ip->ip_p;
                                icmpTable[i].icmp_type = icmp->icmp_type;
                                icmpTable[i].icmp_id1 = icmp->icmp_id1;
                                changeSrcPacket(packet ,-1 ,protocol);
                                break;
                            }
                        }
                    }
                }
            }
            else // flag = 1
            {
            // we got a packet from the external. we want to send it to the right 
            // place in the internal

            //nTable[(tcp->th_dport-2000)%8000];

            //printf(""dst: %d , src: %d \n"",ntohs(tcp->th_dport),ntohs(tcp->th_sport));

                if(ip->ip_p== IP_TYPE_ICMP)
                {
                    changeDstPacket (packet,-1,protocol);
                }
                else
                {
                    for(x=0;xip_p == IP_TYPE_TCP)
                        {
                            if(((int)(ntohs(tcp->th_dport))-2000)%8000 == x && nTable[x].free == 1)
                            {
                                changeDstPacket (packet,x,protocol);
                                break;
                            }
                        }
                        else
                        {
                            if(((int)(ntohs(udp->udp_destport))-2000)%8000 == x && nTable[x].free == 1)
                            {
                                changeDstPacket (packet,x,protocol);
                                break;
                            }

                        }
                    }   
                }       
            // we create a packet with thw same src ip and port as we got
            // and only the dst port and ip will be the ones that are 
            //saved in nTable[(tcp->th_dport-2000)%8000]
            // now if it is in udp we will put 0 in nTable[(tcp->th_dport-2000)%8000].free


            }

}

void changeSrcPacket(const u_char *packet , int srcPort, int protocol)
{
    libnet_t *l;
    libnet_ptag_t ipv, ptag, popt,icmp;
    char errbuf[LIBNET_ERRBUF_SIZE];
    uint32_t nat_adder;

     size_t ip_hlen=IP_HL(ip)*4;
     size_t ip_len=ntohs(ip->ip_len);

    size_t tcp_len = ip_len - ip_hlen;

    printf(""\n%d %d %d %d"",IP_HL(ip),ip_hlen,ip_len,tcp_len);


    icmp = ptag = ipv = LIBNET_PTAG_INITIALIZER;


     nat_adder = libnet_name2addr4(l,""192.168.191.137"",LIBNET_DONT_RESOLVE);

     l = libnet_init(LIBNET_RAW4,config.extNIC, errbuf);

     if(protocol == 0)//TCP
     {

         if(TH_OFF(tcp)*4 > TCP_HEADER_SIZE)
         {
                options = (char*)packet + 54;
                options_s = TH_OFF(tcp)*4 - TCP_HEADER_SIZE;
                popt = libnet_build_tcp_options((u_int8_t*)options,options_s, l,0);     
         }

         ptag = libnet_build_tcp(
          srcPort, // source port
          ntohs(tcp->th_dport), // dest port
          htonl(tcp->th_seq), // sequence number
          ntohl(tcp->th_ack), // ack number
          tcp->th_flags, // flags
          ntohs(tcp->th_win), // window size
          0, // checksum
          ntohs(tcp->th_urp), // urg ptr
          TH_OFF(tcp)*4, // total length of the TCP packet
          (u_int8_t*)payload, // response
          payload_s, // response_length
          l, // libnet_t pointer
          ptag // ptag
          );


          printf(""%d, %d, %d, %d, %d\n"", TH_OFF(tcp)*4, IP_HL(ip)*4, payload_s, ntohs(ip->ip_len),TH_OFF(tcp)*4);
            if(ptag==-1)
             {
                fprintf(stderr, ""Error building TCP header: %s\n"",libnet_geterror(l));
                exit(1);
             }

    if (libnet_do_checksum(l, (u_int8_t*)ip,IPPROTO_TCP, TH_OFF(tcp)*4) udp_destport), /* destination port */
                udp->udp_len, /* packet length */
                0, /* checksum */
                (u_int8_t*)payload, /* payload */
                payload_s, /* payload size */
                l, /* libnet handle */
                ptag); /* libnet id */

          if(ptag==-1)
          {
             fprintf(stderr, ""Error building UDP header: %s\n"",libnet_geterror(l));
             exit(1);
          }

     }

   // if(protocol == 2)//ICMP
     //{
        ///add functions of icmp
     // icmp = libnet_build_icmpv4_echo(
        //ICMP_ECHO, /* type */
        //0, /* code */
        //0, /* checksum */
        //icmp->icmp_id1, /* id */
        //icmp->icmp_seq1, /* sequence number */
        //payload, /* payload */
        //payload_s, /* payload size */
        //l, /* libnet context */
        //icmp); /* ptag */

        //if (icmp == -1)
        //{
        //  fprintf(stderr, ""Can't build ICMP header: %s\n"",
        //  libnet_geterror(l));

        //}
    // }


       ipv = libnet_build_ipv4(
                                                /* total length */
                   ntohs(ip->ip_len),
                    ip->ip_tos,                          /* type of service */
                    ntohs(ip->ip_id),                        /* identification */
                    ntohs(ip->ip_off),                          /* fragmentation */
                    ip->ip_ttl,                         /* time to live */
                    ip->ip_p,                /* protocol */
                    0,                          /* checksum */
                    nat_adder,                     /* (Nat) source */
                    ip->ip_dst.s_addr,                     /* destination */
                   NULL,                       /* payload */
                   0,                          /* payload size */
                    l,                          /* libnet handle */
                    0);                         /* ptag */

        if(ipv == -1)
        {
            fprintf(stderr,""Error building IP header: %s\n"", libnet_geterror(l));
            exit(1);
        }

        /*if (libnet_do_checksum(l, (u_int8_t*)l, IPPROTO_IP, ntohs(ip->ip_len) + payload_s) th_flags == 0x01)
            {
                nTable[index].fin++;
            }
            if(tcp->th_flags == 0x11 && nTable[index].fin == 1)
            {
                nTable[index].fin++;
            }
            if(tcp->th_flags == 0x10 && nTable[index].fin == 2)
            {
                nTable[index].free = 0; 
                nTable[index].fin = 0;
            }
        }


         // Fix IP header checksum
  //  ip->ip_sum = 0;
    if (libnet_do_checksum(l, (u_int8_t*)ip,IPPROTO_IP, IP_HL(ip)*4) th_sport),ntohs(nTable[index].srcPort));
    printf(""src ip : %s    dst ip: %s\n"",inet_ntoa(ip->ip_src), inet_ntoa(nTable[index].ip_src));

    ptag = ipv = LIBNET_PTAG_INITIALIZER;

    if(protocol == 0 || protocol == 1) // udp or tcp
    {

        if(nTable[index].free == 1)
        {
            l = libnet_init(LIBNET_RAW4,config.intNIC, errbuf);

            if(protocol == 0 ) //TCP
            {

                if(TH_OFF(tcp)*4 > TCP_HEADER_SIZE)
                {
                     options = (char*)packet + 54;
                     options_s = TH_OFF(tcp)*4 - TCP_HEADER_SIZE;
                     popt = libnet_build_tcp_options((u_int8_t*)options,options_s, l,0);

                }

                  ptag = libnet_build_tcp(
                  ntohs(tcp->th_sport), // source port
                  ntohs(nTable[index].srcPort), // dest port
                  ntohl(tcp->th_seq), // sequence number
                  ntohl(tcp->th_ack), // ack number
                  tcp->th_flags, // flags
                  ntohs(tcp->th_win), // window size
                  0, // checksum
                  ntohs(tcp->th_urp), // urg ptr
                  TH_OFF(tcp)*4, // total length of the TCP packet
                  (u_int8_t*)payload, // response
                  payload_s, // response_length
                  l, // libnet_t pointer
                  ptag // ptag
                  );

                  if(ptag==-1)
                  {
                    fprintf(stderr, ""Error building TCP header: %s\n"",libnet_geterror(l));
                    exit(1);
                  }
            }

            if(protocol == 1)// UDP
            {
                ptag = libnet_build_udp(
                    ntohs(udp->udp_srcport), /* source port */
                    ntohs(nTable[index].srcPort), /* destination port */
                    udp->udp_len, /* packet length */
                    0, /* checksum */
                    (u_int8_t*)payload, /* payload */
                    payload_s, /* payload size */
                    l, /* libnet handle */
                    ptag); /* libnet id */

                if(ptag==-1)
                {
                    fprintf(stderr, ""Error building UDP header: %s\n"",libnet_geterror(l));
                    exit(1);
                }
            }
        }
    }
    if(protocol == 2) // ICMP
    {
        for(i=0;i icmp_type)
                    if(icmpTable[i].ip_dst.s_addr == ip->ip_src.s_addr)
                        if(icmpTable[i].icmp_id1 == icmp->icmp_id1)
                        {
                            index = i;
                            break;
                        }

        }

        ///add functions of icmp

    }

              ipv = libnet_build_ipv4(
                                                        /* total length */
                            ntohs(ip->ip_len),
                            ip->ip_tos,                          /* type of service */
                            ntohs(ip->ip_id),                        /* identification */
                            ntohs(ip->ip_off),                          /* fragmentation */
                            ip->ip_ttl,                         /* time to live */
                            ip->ip_p,                /* protocol */
                           0,                           /* checksum */
                            ip->ip_src.s_addr,                     /* (Nat) source */
                            nTable[index].ip_src.s_addr,                     /* destination */
                            NULL,                       /* payload */
                            0,                          /* payload size */
                            l,                          /* libnet handle */
                            0);                          /* ptag */
               if(ipv == -1)
              {
                fprintf(stderr,""Error building IP header: %s\n"", libnet_geterror(l));
                exit(1);
              }   

            /*if (libnet_do_checksum(l, (u_int8_t*)l, IPPROTO_IP, ntohs(ip->ip_len) + payload_s) th_flags == 0x01)
                    {
                        nTable[index].fin++;
                    }
                    if(tcp->th_flags == 0x11 && nTable[index].fin == 1)
                    {
                        nTable[index].fin++;
                    }
                    if(tcp->th_flags == 0x10 && nTable[index].fin == 2)
                    {
                        nTable[index].free = 0; 
                        nTable[index].fin = 0;
                    }
                }
                else
                {
                    nTable[index].free = 0; 
                    nTable[index].fin = 0;
                }
            }


            if ( libnet_write(l) == -1 )
                      fprintf(stderr, ""Error writing packet: %s\n"",libnet_geterror(l));
            libnet_destroy(l);

}
</code></pre>
",1
4158893,4158841,3,"<p>If I understand your question correctly, you are asking how to iterate the variables <code>d1</code>, <code>d2</code>, <code>d3</code> in sequence, based on the name of the variable and the value of <code>i</code>.</p>
<p>So, while you cannot do that directly, it sounds like what you are looking for is a <a href=""http://cprogramminglanguage.net/c-for-loop-statement.aspx"" rel=""nofollow noreferrer"">for loop</a> that loops over an <a href=""http://www.exforsys.com/tutorials/c-language/c-arrays.html"" rel=""nofollow noreferrer"">array</a>.</p>
",1
4143288,4143000,13,"<p>Probably much faster than using log or int-to-string conversion and without using any library functions is this:</p>

<pre><code>int nDigits(int i)
{
  if (i &lt; 0) i = -i;
  if (i &lt;         10) return 1;
  if (i &lt;        100) return 2;
  if (i &lt;       1000) return 3;
  if (i &lt;      10000) return 4;
  if (i &lt;     100000) return 5;
  if (i &lt;    1000000) return 6;      
  if (i &lt;   10000000) return 7;
  if (i &lt;  100000000) return 8;
  if (i &lt; 1000000000) return 9;
  return 10;
}
</code></pre>

<p><strong>EDIT</strong> after Jeff Yates concerns:</p>

<p>For those who worry about int sizes different from 32-bits
(similar to pmg's solution but still faster because multiplication is faster than division :-)</p>

<pre><code>#include &lt;limits.h&gt;

#define PO10_LIMIT (INT_MAX/10)


int nDigits(int i)
{
  int n,po10;

  if (i &lt; 0) i = -i;
  n=1;
  po10=10;
  while(i&gt;=po10)
  {
    n++;
    if (po10 &gt; PO10_LIMIT) break;
    po10*=10;
  }
  return n;
}
</code></pre>
",7
4143011,4143000,5,"<p>Use logarithms base 10:</p>

<pre><code>int length = (int)floor(log10((float)number)) + 1; // works for &gt;0
</code></pre>
",0
4143035,4143000,24,"<p>use</p>

<pre><code>int d = (value == 0 ? 1 : (int)(log10(value)+1));
</code></pre>

<p>Note that this doesnt work for negative numbers, you'll have to use</p>

<pre><code>int d = (value == 0 ? 1 : ((int)(log10(fabs(value))+1) + (value &lt; 0 ? 1 : 0)));
</code></pre>

<p>which adds 1 for the minus sign, if <code>value</code> is negative.</p>
",3
4143148,4143000,2,"<p>A more general solution, especially if you want to know the length for purposes of printing with <code>printf()</code> variants is:</p>

<pre><code>snprintf(NULL, 0, ""%d"", myint);
</code></pre>

<p>The return value should tell you the length of the string that would be printed.</p>
",2
4143587,4143000,5,"<p>Here's another option</p>

<pre><code>int nDigits(unsigned i) {
    int n = 1;
    while (i &gt; 9) {
        n++;
        i /= 10;
    }
    return n;
}
</code></pre>

<p>This is faster than using <code>log10</code>, but slower than Curd's option with the cascading tests. However it doesn't assume <code>int</code>s are 32 bits :-)</p>
",0
3314407,3314396,0,"<p>In C you must declare your function before another function that uses it. So...</p>

<pre><code>void prints(char **menu)
{
    int a;
    while(*menu)
    {
        printf(""%s"", **menu);
        menu ++;
    }

    a = 0;
}

void main(void)
{
    char *menu[] = {""data"", ""coming"", ""here""};
    prints(**************); // here 
    printf(""\n"");
}
</code></pre>

<p>That, or you can forward declare the function:</p>

<pre><code>void prints(char **menu);

void main(void)
{
    char *menu[] = {""data"", ""coming"", ""here""};
    prints(**************); // here 
    printf(""\n"");
}

void prints(char **menu)
{
    int a;
    while(*menu)
    {
        printf(""%s"", **menu);
        menu ++;
    }

    a = 0;
}
</code></pre>
",4
3314410,3314396,0,"<p>You can either move the <code>prints</code> function above <code>main</code>, or you can put a prototype for <code>prints</code> above main, like so:</p>

<pre><code>void prints(char **menu);
</code></pre>

<p>Then, you can call <code>prints</code> from <code>main</code> just like any other function...</p>
",0
3314437,3314396,4,"<p>Here is a version with several issues fixed:</p>

<pre><code>#include &lt;stdio.h&gt;

// declare function before using it
void prints(char **menu)
{
    // make sure parameter is valid
    if (menu != NULL)
    {
        while(*menu)
        {
            // spaces so they don't run together
            // pass *menu not **menu to printf
            printf(""%s  "", *menu);
            menu ++;
        }
    }
}

// proper return type for main()
int main(void)
{
    // array terminator added
    char *menu[] = {""data"", ""coming"", ""here"", NULL};

    prints(menu); // here

    printf(""\n"");

    // return with no error
    return 0;
}
</code></pre>
",1
3856431,3856152,1,"<p>I think you should follow the <a href=""http://en.wikipedia.org/wiki/Principle_of_least_astonishment"" rel=""nofollow"">Principle Of Least Astonishment</a></p>

<blockquote>
  <p>The POLA states that, when two
  elements of an interface conflict, or
  are ambiguous, the behaviour should be
  that which will least surprise the
  user; in particular a programmer
  should try to think of the behavior
  that will least surprise someone who
  uses the program, rather than that
  behavior that is natural from knowing
  the inner workings of the program.</p>
</blockquote>

<p>If your code is for internal consumption only, you may get away with it, though. So it really depends on the people your code will impact :)</p>
",0
3856455,3856152,0,"<p>You need to go on a case by case basis.  Think about the API and what you need to return.  If your function only needs to return success or failure, I'd say give it an explicit type of bool (C99 has a bool type now) and return true for success and false for failure.  That way things like:</p>

<pre><code>if (!doSomething())
{
    // failure processing
}
</code></pre>

<p>read naturally.  </p>

<p>In many cases, however, you want to return some data value, in which case some specific unused or unlikely to be used value must be used as the failure case.  For example the Unix system call <code>open()</code> has to return a file descriptor.  0 is a valid file descriptor as is theoretically any positive number (up to the maximum a process is allowed), so -1 is chosen as the failure case.</p>

<p>In other cases, you need to return a pointer.  NULL is an obvious choice for failure of pointer returning functions.  This is because it is highly unlikely to be valid and on most systems can't even be dereferenced.</p>
",2
3856642,3856152,0,"<p>One of the most important considerations is whether the caller and the called function or program will be updated by the same person at any given time.  If you are maintaining an API where a function will return the value to a caller written by someone who may not even have access to your source code, or when it is the return code from a program that will be called from a script, only violate conventions for very strong reasons.</p>

<p>You are talking about passing information across a boundary between different layers of abstraction.  Violating the convention ties both the caller and the callee to a different protocol increasing the coupling between them.  If the different convention is fundamental to what you are communicating, you can do it.  If, on the other hand, it is exposing the internals of the callee to the caller, consider whether you can hide the information.</p>
",0
3856180,3856152,4,"<p>It is fine as long as you document it well.</p>
",0
3856195,3856152,10,"<p>""Your program should follow an existing convention if an existing convention makes sense for it.""</p>

<p>Source: <a href=""http://www.gnu.org/software/libc/manual/html_mono/libc.html#Exit-Status"" rel=""nofollow"">The GNU C Library</a></p>
",0
3856207,3856152,9,"<p>By deviating from such a widely known convention, you are creating a high level of technical debt. Every single programmer that works on the code will have to ask the same questions, every consumer of a function will need to be aware of the deviation from the standard.</p>

<p><a href=""http://en.wikipedia.org/wiki/Exit_status"" rel=""nofollow"">http://en.wikipedia.org/wiki/Exit_status</a></p>
",0
3856221,3856152,0,"<p>It is a convention only.  I have worked with many api that abandon the principle when they want to convey more information to the caller.  As long as your consistent with this approach any experienced programmer will quickly pick up the standard. What is hard is when each function uses a different approach IE with win32 api.  </p>
",0
3856228,3856152,2,"<p>I think it ultimately depends on the customers of your code.</p>

<p>In my last system we used more or less the same coding system as yours, with ""0"" meaning ""I did nothing at all"" (e.g. calling Init() twice on an object). This worked perfectly well and everybody who worked on that system knew this was the convention.</p>

<p>However, if you are writing an API that can be sold to external customers, or writing a module that will be plugged into an existing, ""standard-RC"" system, I would advise you to stick to the 0-on-success rule, in order to avoid future confusion and possible pitfalls for other developers.</p>

<p>And as per your PS, when in Rome, do like the romans do :-)</p>
",0
3856229,3856152,7,"<p>I think you're overstating the status of this mythical ""rule"". Much more often, it's that a function returns a nonnegative value on success indicating a result of some sort (number of bytes written/read/converted, current position, size, next character value, etc.), and that negative values, which otherwise would make no sense for the interface, are reserved for signalling error conditions. On the other hand, some functions need to return unsigned results, but zero never makes sense as a valid result, and then zero is used to signal errors.</p>

<p>In short, do whatever makes sense in the application or library you are developing, but aim for consistency. And I mean consistency with external code too, not just your own code. If you're using third-party or library code that follows a particular convention and your code is designed to be closely coupled to that third-party code, it might make sense to follow that code's conventions so that other programmers working on the project don't get unwanted surprises.</p>

<p>And finally, as others have said, whatever your convention, <strong>document it!</strong></p>
",0
3857560,3856152,1,"<p>There is nothing wrong with doing it that way, assuming you document it in a way that ensures others know what you're doing.</p>

<p>However, as an alternative, if might be worth exploring the option to return an enumerated type defining the codes. Something like:</p>

<pre><code>enum returnCode {
    SUCCESS, FAILURE, NO_CHANGE
}
</code></pre>

<p>That way, it's much more obvious what your code is doing, self-documenting even. But might not be an option, depending on your code base.</p>
",0
3856242,3856152,0,"<p>In my opinion (and that's the opinion of someone who tends to do out-of-band error messaging thanks to working in Java), I'd say it is acceptable <strong>if</strong> your functions are of a kind that require strict return-value processing anyway.</p>

<p>So if the return value of your method has to be inspected at all points where it's called, then such a non-standard solution might be acceptable.</p>

<p>If, however, the return value might be ignored or just checked for success at some points, then the non-standard solution produces quite some problem (for example you can no longer use the <code>if(!myFunction()) ohNoesError();</code> idiom.</p>
",0
3856269,3856152,0,"<p>What is your problem? It is just a convention, not a law. If your logic makes more sense for your application, then it is fine, as long as it is well documented and consistent.</p>
",0
3856306,3856152,0,"<p>On Unix, exit status is unsigned, so this approach won't work if you ever have to run your program there, and this will confuse all your Unix programmers to no end.  (I looked it up just now to make sure, and discovered to my surprised that Windows uses a signed exit status.)  So I guess it will probably only <em>mostly</em> confuse your Windows programmers.  :-)</p>

<p>I'd find another method to pass status between processes.  There are many to choose from, some quite simple.  You say ""at the cost of a few WTF's on the programmers side"" as if that's a small cost, but it sounds like a huge cost to me.  Re-using an int in C is a miniscule benefit to be gained from confusing other programmers.</p>
",1
2428147,2428131,3,"<p>It is system specific, but there is commonly <code>execve</code> or something like that and there is always <code>system(""/path/to/program"");</code> that you can use that is also system specific</p>
",1
2428158,2428131,3,"<p>Have you looked into using <code>fork()</code> and <code>exec()</code>?
Fork will split a process, exec lets you start a new program from one of the instanaces that was <code>fork</code>'d.</p>

<p>First hit on google:</p>

<p><a href=""http://www.yolinux.com/TUTORIALS/ForkExecProcesses.html"" rel=""nofollow noreferrer"">http://www.yolinux.com/TUTORIALS/ForkExecProcesses.html</a></p>

<p>As others have mentioned, the details may vary depending on what OS you are using.</p>
",0
2428235,2428131,0,"<p>In addition to an explicit <code>fork</code>/<code>exec</code> and <code>system</code>, there is <code>popen</code>. (All in a unixish environment).</p>

<p>You'll get better help if you are more explicit about what your operating environment is and how you need to interact with the daughter process.</p>
",0
2428272,2428131,0,"<p>The <a href=""http://msdn.microsoft.com/en-us/library/ms682425%28VS.85%29.aspx"" rel=""nofollow noreferrer"">CreateProcess</a> function is the way to go in Windows.</p>

<p>You can use the <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/system.html"" rel=""nofollow noreferrer"">system()</a> function to literally make commands against the console, but I don't remember if it blocks or not.</p>

<p>For linux look into <a href=""http://linux.about.com/library/cmd/blcmdl3_execl.htm"" rel=""nofollow noreferrer"">execv</a>. <a href=""http://www.gidforums.com/t-3369.html"" rel=""nofollow noreferrer"">This page</a> has a linux parent launching a child application example in linux include a communications pipe between the two..</p>

<p>Also, <a href=""http://manpages.courier-mta.org/htmlman2/execve.2.html"" rel=""nofollow noreferrer"">execve</a> will launch by executable filename.</p>
",0
2581205,2434676,0,"<p>Consider reading more content on the ""concepts"" of programming than purely syntax:</p>

<ul>
<li><a href=""https://rads.stackoverflow.com/amzn/click/com/0321344758"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Don't Make Me Think by Steve Krug</a></li>
<li><a href=""https://rads.stackoverflow.com/amzn/click/com/0735619670"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Code Complete: A Practical Handbook of Software Construction</a> </li>
</ul>

<p>Join a mailing list/newsletter/magazine/podcasts for programmers in your area of expertise:
<a href=""http://www.drdobbs.com/cpp/;jsessionid=XVZEO0SKOCRRBQE1GHPCKH4ATMY32JVN"" rel=""nofollow noreferrer"">http://www.drdobbs.com/cpp/;jsessionid=XVZEO0SKOCRRBQE1GHPCKH4ATMY32JVN</a></p>

<p>Visit StackOverflow.com and try to solve issues periodically to give yourself a mental challenge and help others.</p>
",0
2434683,2434676,2,"<p>""read"" <strong>and practice</strong> what you read which is the best way.</p>
",0
2434696,2434676,7,"<p>Peter Norvig has <a href=""http://norvig.com/21-days.html"" rel=""noreferrer"">some ideas about that</a></p>
",2
2434702,2434676,6,"<p>Try to implement a few non-trivial algorithms. I do not know what examples are included in the books, but you might try to write</p>

<ul>
<li>An algebratic calculator. Input ""sin(2) + 5! * 3^(1/2)"" and you get 208.755394335 as an output.</li>
<li>A syntax-highliting text editor from scratch.</li>
<li>Write a PNG (or any other image or sound format) encoder/decoder from scratch.</li>
<li>Write an image editor (for instance flood fill is not entirely trivial)</li>
<li>...</li>
</ul>
",1
2434706,2434676,13,"<blockquote>
  <p><strong>most of which are generally really boring</strong></p>
</blockquote>

<p>Learn something you find interesting, then the rest will fall into place.</p>
",0
2434708,2434676,18,"<p>What would really help you learn is to <b>start a project</b>. It could be anything, implementing a chat client/server, a unix shell, a simple program to store grocery lists, whatever. The point is by picking something that you are interested in and working to implement it, you will be surprised how much you learn along the way, and you won't want to quit because you are working on something meaningful to you.</p>

<p>Basically, you will only learn so much by reading. To gain true knowledge you will need to work through <em>real</em> problems.</p>
",3
2434713,2434676,1,"<p>I find practicing much more useful at learning concepts than reading about them. Often what I'll do is determine a problem I want to solve with software, then go about it by <em>attempting</em> the problem. I will utilize resources along the way, but its really more useful to try what you read, rather than read every book on the subject. </p>

<p>Also, <a href=""https://stackoverflow.com/questions/tagged/code-golf"">Code Golf</a> is a good way to find fun programs to attempt. </p>
",1
2434714,2434676,2,"<p>You need to challenge yourself with a bigger, more complex project. Working through code snippets, as most book examples tend to, will not get you far past the chapter exercises. </p>

<p>You're working on being a book-smart developer. Do something real world and become street-smart!</p>
",0
2434718,2434676,1,"<p>Code Hello World, then code Hello World distributed over a network, or in 3d, or using a database. Don't think things are too trivial until you've done them. Implement algorithms to make sure you know how. Do code you think is fun.</p>
",0
2434728,2434676,0,"<p>Do it.  There isn't a shortcut to being a ""great"" developer - like any other craft, it takes lots of time and practice and patience.  Just do it.</p>
",0
2434741,2434676,26,"<p><a href=""https://i.stack.imgur.com/MpJ3S.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MpJ3S.png"" alt=""Learn to Program in 21 days""></a>
<a href=""https://abstrusegoose.com/249"" rel=""nofollow noreferrer"">From Abstruse Goose</a></p>

<p>Also, <a href=""https://norvig.com/21-days.html"" rel=""nofollow noreferrer"">Teach Yourself Programming in Ten Years</a></p>
",1
2434755,2434676,2,"<p>Code Golf and Project Euler are good - but they are more about problem solving and maths than programming.</p>

<p>Find an Opensource project (probably not the Linux kernel) that you are interested in, download the source and try and use it. Ideally something that is a library rather than an application so you have to learn how to read it to use it with your own stuff.</p>

<p>Don't worry - It only takes about 10 years to become a good programmer.</p>
",0
2434772,2434676,0,"<p>If you're interested in security, try coding a web application with security in mind. If you create something like a forum you'll not only learn about a number of security concerns, but also how to use multiple technologies like databases, web servers, and a new language and potentially new style besides C. And then when you're done with your project, compare the code to other similar software. If you get stuck on your project you can also look at similar projects to see what they do. And it can be as simple or as complicated as you want it to be.</p>

<p>Web programming may be different from systems programming in a lot of ways, but both share many security concerns.</p>
",0
2434784,2434676,0,"<p>Learning to program is like learning to speak a foreign language.  Initially it is very frustrating and often boring.  It is only after you gain a degree of fluency in a given language that you find your productivity increases.  Along the same vein, just learning the rules is not enough.  As with language learning, if you don't use it, and use it often, it will be hard to retain and keep your interest up.</p>

<p>What works for one person doesn't always work for another. Code golf may work for you, or you may find it tedious for example. Personally I like doing something that has genuine value, but that is me.  Experiment a little with different types of coding projects, perhaps code golf, perhaps open source projects, producing a game, etc. Sometimes just trying to figure out how to answer other people's questions helps. Eventually you'll find what works for you. Just remember, studying is not enough, you have to apply those studies.</p>
",0
2434795,2434676,0,"<p>Some project ideas:</p>

<ul>
<li>Small database projects: contact list, DVD collection, etc.  Emphasizes file I/O, searchable data structures, etc.</li>
<li>Simple calculator: Emphasizes interactive I/O, parsing, tree-like structures, etc.</li>
<li>Simple NNTP (Usenet) or chat client: Networking and protocols</li>
</ul>
",0
2436673,2434676,0,"<p>You can only learn the language, when you are using it. Simple examples or exercises will never give you the deep insight into the language. I personally also found the exercises at the end of a chapter boring and unworldly, so I didn't do them. As other state find a project you are interested in. This can be anything, starting from a simple board game up to a video cutting system. If you found out what would be interesting for you, take a look on how you can accomplish it. You will need to use some helping libraries, for the UI and also for the backend. And then start to work!
(Of course the project should be doable for you, hence don't take an aim like 'writing a better word processor than Winword'.)</p>

<p>Another way is to dig for an OSS project that you are interested in and where you are missing some features. Implement those! The great benefit is that you get a source review that is probably tougher then from any teacher. Once you learned those coding styles, you probably already forgot about the language itself.</p>
",0
2439885,2434676,4,"<p>You say you're interested in security.  Go look up some exploits and try to understand them.  Better yet, try to find an exploit yourself, for a known (better: unknown) vulnerability.</p>

<p>Write an NNTP client, or an SMTP server, or client, and use it to send your mail.  Many of these internet protocols are simple enough to not be very difficuly to implement (most of the text-based protocols), yet nuanced enough to be interesting, and they have the connection to the real world that makes it more satisfying than a ""hello world"" program.</p>

<p>Or how about writing a linux kernel module?  They're not that hard to write, there's just a bit of a barrier to entry (lots to learn before you can have your ""black triangle"").  Make a character device that returns an endless stream of the last byte you wrote to it (call it /dev/fortytwo if you like).  Then make sure it will work when two processes use it simultaneously.</p>

<p>Look for some project with crappy code but friendly community, and clean some of it up.  GCC and the kernel would be bad choices here :)</p>
",1
2439896,2434676,0,"<p>Start a project and finish it. Put it online, make it open source, get feedback.</p>
",0
2442454,2434676,0,"<p>You might find reading <em>Code Complete 2</em> helpful. It is a good book on programming practices.</p>

<p>.</p>
",0
2448866,2434676,2,"<p>Go to work. 
Seriously, find a <strong>job</strong> for a beginner and let someone with a bigger knowledge guide You (if You have luck) or check the codebase for a useful hints (if You have smaller luck). </p>

<p>In other way, You can start a <strong>project</strong> for Yourself as some of folks suggested and improve Your knowledge as the opportunity arises. </p>

<p>However, I wouldn't mix both of these worlds - don't start by agreeing a deal for a money - You will probably be prone to under/over-estimating time cost, won't have a good knowledge of bigger solutions, etc. It's better to have someone to guide You or have more time to learn things. </p>

<p>Ah, and btw. - <strong>read books</strong> (CC2, some design patterns books, ""Clean code"" are a good place to start with and great reference-books for the whole career) and <strong>blogs</strong> (You'll know it when You see it). </p>
",0
4536744,4536724,2,"<p>You're not initializing the somepath variable - it has an undefined value unless the malloc() executes (i.e. for empty folders). You should initialize it to NULL at the place of definition.</p>
",0
4536745,4536724,3,"<p>In your code, you are not guaranteed to allocate memory and assign it to <code>somepath</code> (you also fail to free somepath except for the last iteration of the loop). You should put your <code>free(somepath)</code> statement at the end of the for-loop, and you should initialize <code>somepath</code> to NULL both at the very beginning of the function and at the start of each for loop to avoid similar careless errors. </p>
",2
4536748,4536724,1,"<p>You do not initialize somepath to 0 (NULL), but you could under some circumstances release the value.  This means you release a random value - which is not a good idea.</p>
",2
3846253,3846240,6,"<p>Apparently <code>*(cra+3)</code> is a <code>char</code> of value <code>'\xdd'</code>. Since a <code>char</code> is signed, it actually means -35 (<code>0xdd</code> in 2's complement), i.e. 0x...fffffdd. Restricting this to 16-bit gives 0xffdd, i.e. 65501.</p>

<p>You need to make it an <code>unsigned char</code> so it gives a number in the range 0¨C255:</p>

<pre><code>num = (unsigned char)cra[3];
</code></pre>

<hr>

<p><sub><strong>Note:</strong><br>
1. the signedness of <code>char</code> is implementation defined, but usually (e.g. in OP's case) it is signed.<br>
2. the ranges of <code>signed char</code>, <code>unsigned char</code> and <code>unsigned short</code> are implementation defined, but again commonly they are -128¨C127, 0¨C255 and 0¨C65535 respectively.<br>
3. the conversion from <code>signed char</code> to <code>unsigned char</code> is actually -35 + 65536 = 65501.</sub></p>
",2
3846257,3846240,0,"<p><code>cra</code> is just a pointer.</p>

<p>It hasn't been allocated any space, by way of <code>malloc</code> or <code>calloc</code>. So its contents are undefined . <code>*(cra + 3)</code> will evaluate to the contents of the location 3 bytes ahead of the location <code>cra</code> (assuming <code>char</code> occupies 1 byte). I believe that its contents are also undefined.</p>

<p><code>unsigned short</code> takes up 2 bytes, atleast on my system. Hence it can hold values from <code>0</code> to <code>65536</code>. So, your output is within its defined range</p>
",0
3846265,3846240,2,"<p><code>char</code> is allowed to be either signed or unsigned - apparently, on your platform, it is signed.</p>

<p>This means that it can hold values like -35.  Such a value not within the range representable by <code>unsigned short</code>.  When a number out of range is converted to an unsigned type, it is brought into range by repeatedly adding or subtracting one more than the maximum value representable in that type.</p>

<p>In this case, your <code>unsigned short</code> can represent values up to 65535, so -35 is brought into range by adding 65536, which gives 65501.</p>
",1
3846294,3846240,0,"<p><strong>unsigned short</strong> has a range of (at least) <strong>0 .. 65535</strong> (<a href=""http://www.cplusplus.com/doc/tutorial/variables/"" rel=""nofollow"">link</a>), the <strong>%u</strong> format specifier prints an <strong>unsigned int</strong> with a range of (commonly) <strong>0 .. 4294967295</strong>. Thus, depending on the value of <em>cra</em>, the output appears to be completely sensible.</p>
",0
5162081,5162060,1,"<pre><code>for (x=0;x&lt;9;x++) {
    printf(""Enter rows:"");
    scanf(""%i"",&amp;x);
   // printf(""%i\n"",my_data[x][y]);
}
</code></pre>

<p>What happens here is that you change the value of <code>x</code>. You do not save anything on the array.</p>

<p>Similarly for <code>y</code></p>

<p>Also you should iterate from <code>0</code> to <code>6</code> (inclusive)</p>

<p>Try</p>

<pre><code>int i;
for(i = 0 ; i &lt; 7 ; i++)
{
     scanf(""%d"" , &amp;my_data[0][x]);
}
</code></pre>

<p>Or :</p>

<pre><code>int row , col;
for (row=0; row&lt;7; row++) 
{
    for (col=0; col&lt;7; col++) 
    {
        scanf(""%d"" , &amp;ticTacToeBoard[row][col]);
    }
}
</code></pre>

<p>What you see is the values that your array has when it was declared. The reason for that is when you declare a variable in <code>C</code> without initializing it, as in your case, your program just uses enough memory to store your data into the memory but does not set that memory to <code>0</code>, hence seeing what the contents of the memory are from previous usage.</p>
",1
5162111,5162060,4,"<p>Several issues right away:</p>

<ul>
<li>The array is 7x7, you want it to be <code>int my_data[8][8]</code>;</li>
<li>Instead of using the number for the size of the array over and over, define a constant <code>#define FOO 8</code></li>
<li>The loops are not properly bounded, should be <code>for (x=0;x&lt;8;x++)</code>. (again, see my note on using a defined constant for the size)</li>
<li>You are not saving the value to the array, you are saving it to the iterator variable.</li>
<li>With two separate for loops you will not be able to fill the entire table, reconsider this structure because you will likely have to use nested loops.</li>
</ul>
",0
5162114,5162060,0,"<p><code>int my_data[7][7];</code> is a 7 x 7 array.  Use <code>int my_data[8][8];</code> for 8 x 8.  </p>
",0
5162122,5162060,2,"<p>You can use one loop nested in the other:</p>

<pre><code>#define SIZE 8

for (i = 0; i &lt; SIZE; i++) {
    for (j = 0; j &lt; SIZE; j++) {
        printf(""(%d,%d): "", i+1, j+1);
        scanf(""%d"", &amp;value);
        array[i][j] = value;
    }
}
</code></pre>
",0
5162225,5162060,-1,"<p><code>my_data</code> is an array with space for 49 <code>int</code>, not 64!</p>

<p>In your for loops you are changing the loop control variable itself by using <code>scanf</code> with its address!</p>

<p>I think you want:</p>

<pre><code>#include &lt;stdio.h&gt;

#define ROWS 8
#define COLUMNS 8

int main(void) {
  int my_data[ROWS][COLUMNS];
  int rows[ROWS];
  int cols[COLUMNS];
  size_t i, row, col;

  /* input rows */
  printf(""Enter rows: "");
  fflush(stdout);
  for (i = 0; i &lt; ROWS; i++) scanf(""%d"", &amp;rows[i]);

  /* input columns */
  printf(""Enter cols: "");
  fflush(stdout);
  for (i = 0; i &lt; COLUMNS; i++) scanf(""%d"", &amp;cols[i]);

  /* calculate sums */
  for (row = 0; row &lt; ROWS; row++) {
    for (col = 0; col &lt; COLUMNS; col++) {
      my_data[row][col] = rows[row] + cols[col];
    }
  }

  /* print results */
  for (row = 0; row &lt; ROWS; row++) {
    for (col = 0; col &lt; COLUMNS; col++) {
      printf(""%d "", my_data[row][col]);
    }
    puts("""");
  }

  return 0;
}
</code></pre>
",0
4171515,4171496,1,"<p>Not with ANSI C, but for Win have a look at:</p>

<pre><code>#include &lt;Urlmon.h&gt;
HRESULT URLDownloadToFile();
</code></pre>
",1
4171521,4171496,4,"<p>cURL (libcurl) would be the easy option:<br/>
<a href=""https://stackoverflow.com/questions/1636333/download-file-using-libcurl-in-c-c"">Download file using libcurl in C/C++</a> <br/>
<a href=""https://stackoverflow.com/questions/2162022/downloading-all-files-in-directory-using-libcurl"">Downloading all files in directory using libcurl</a> <br/>
<a href=""http://curl.haxx.se/"" rel=""nofollow noreferrer"">http://curl.haxx.se/</a><br/><br/>
If your software is based on Microsoft Windows, then you can also use Wininet APIs:<br/>
<a href=""http://msdn.microsoft.com/en-us/library/aa385473.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/aa385473.aspx</a><br/></p>
",0
4171672,4171496,1,"<p>C has no ""built in functions"" at all, they are <em>all</em> provided by libraries.  Networking is not supported in the <em>standard library</em>; you need a networking library of which there are many, some of which are standard for particular operating systems, but tend to be low level, such as BSD Sockets or the similar WinSock API.</p>

<p>I strongly suggest however that you <em>do not</em> us a floating point value to represent version number, and simply compare the version string.  This avoids fp precision and conversion issues, and allows flexible version number formatting such as ""1.0.1"" or ""1.0a"" or whatever.</p>
",0
2599981,2599974,5,"<p><code>size_t</code> is the return type of the <code>sizeof</code> operator and is used to describe memory sizes. In the case of <code>memset</code>, it specifies the number of bytes (n) in the memory block (s) that should be set to the given value (c).</p>

<p>The size in bits of <code>size_t</code> varies based on the address space of the target platform. It does not always correlate to the register size. For example, in a segmented memory architecture the <code>sizeof (size_t)</code> can be smaller than the <code>sizeof (void *)</code>. Typically, <code>size_t</code> would be 4 bytes on a 32-bit machine, 8 bytes on a 64-bit machine, etc.</p>
",8
2599984,2599974,2,"<p><code>size_t</code> is the type used to denote the size of objects. In C sizes of integer types (<code>int</code>, <code>long</code>, etc.) are implementation-dependent and you need to use the right type on each compiler implementationp so that the size is big enough to store all possible values.</p>

<p>The headers that will come with the platform SDK will have a <code>typedef</code> that will map <code>size_t</code> to the right integer type. So you write <code>memset()</code> once and it compiles right on every implementation.</p>
",0
2599997,2599974,1,"<p>size_t is a type suitable for representing the amount of memory a data object requires. It is an unsigned integer type (generally, typedef unsigned int size_t;).</p>

<p>Read <a href=""http://bytes.com/topic/c/answers/220206-what-size_t"" rel=""nofollow noreferrer"">this</a> link for more information.</p>
",1
2600018,2599974,-2,"<p><code>size_t</code> is guaranteed to be large enough to hold a pointer on all platforms.</p>
",11
8387112,8387059,2,"<p><code>inet_addr</code>, <code>inet_aton</code>, <code>inet_ntoa</code>, there are quite a few functions, try looking up the documentation.</p>
",0
3020087,3020060,0,"<p>Probably you would want to convert it to string first (so you can easily work with digits of a number). And then apply whatever usual string algorithms you want.</p>
",0
3020089,3020060,4,"<p>if its just for repeating occurances in decimal within the same number :-</p>

<pre><code>int contains_repeat(int x)
{
    int occurances = 0;
    while(x&gt;0)
    {
          if(occurances &amp; 1 &lt;&lt; (x % 10)) return 1;
          occurances |= 1 &lt;&lt; (x % 10);
          x = x / 10;
    }
    return 0;
}
</code></pre>

<p>if its all the same</p>

<pre><code>int all_the_same(int x)
{
    int digit = x%10;
    while(x&gt;0)
    {
        if(x%10 != digit) return 0;
        x = x/10;
    }
    return 1;
}
</code></pre>

<p>if you want it for a different base, just pass ""int base"" in and use base instead of 10.</p>
",0
3020101,3020060,2,"<p>Example:   </p>

<pre><code>if (4444 % 1111 == 0) // all digits are the same
</code></pre>
",0
8444746,8444512,2,"<p><code>%s</code> matches a sequence of bytes that are not white-space characters. So it will stop on any whitespace.</p>

<p>Assuming your input is tab separated, this may work</p>

<p><code>sscanf(line, ""%ld\t%ld\t%[^\t]\t%[^\t]\t%[^\t]"", &amp;a, &amp;b, &amp;c, &amp;d, &amp;e);</code></p>

<p>But please limit number of characters that can be read with %[^\t] or there will be potential buffer overflow. Also check for return value of sscanf() to make sure it filled all the parameters before relying on them.</p>
",0
8444545,8444512,5,"<p>This will read up until a newline:</p>

<pre><code>char a[123];
sscanf(line, ""%[^\n]"", a);
</code></pre>

<p>If you also wanted it to read up until a tab, you can change it to: <code>""%[^\t\n]""</code></p>

<p>Since it seems you've already read this string into the buffer <code>line</code>, an alternative to <code>sscanf</code> is <code>strtok</code>, which will return pointers to tokens of <code>line</code> (separated by spaces, tabs, whatever).</p>
",0
5191363,5191322,0,"<p>Pointer means you pass the address of the variables instead of the value.</p>

<p>You can then dereference(get the value pointed to by this address) and perform operations using that value.</p>

<p>If you pass a variable by value, that is without using &amp;, a new copy will be created inside the function. Any changes done, will not be visible outside the function. If you pass pointers, then manipulations done to the content of the pointer will be visible outside the function.</p>

<p>On last note, pointers are complex to understand for new programmers. You better read tutorials and spend some time thinking about how things are working.</p>
",0
5191369,5191322,0,"<p>This is example of function where you pass by reference that is you pass the location of actual variable instead of making a copy of it and passing.so in you function p is basically pointing to y which is 15 and q is pointing to z=25 .It should be easy from there on to find the answer. *p= (15+25)-(15) *q=15.So y=25 z=15 .</p>
",0
5191407,5191322,0,"<p>First of all you have to know about the pointer...</p>

<p>Pointer is a variable that contain memory address of another variable...</p>

<p>In above program...you have declared 2 variables y and z... and you have created a function 
namely function(&amp;y,&amp;z).... means ...it sends the reference (memory address) of y and z to the funcion...function(*p,*q)</p>

<p>so *p contain 15 and *q contain 25... </p>

<p>*p=(*p+*q) means y= 15+25 which is 40....</p>
",0
5191431,5191322,0,"<p>Variable, like y and z in your program, have ranges. They exist only in a limited logical space. For instance, y and z only ""exists"" in main ; that's why they're called ""local variable"". Would you write :</p>

<pre><code>int x,y;

void main
{
  // Stuff 
}
</code></pre>

<p>x and y would be global variables, that any function in this file could access. Since global variable make things harder to debug, when you need to access variable declared in a function, you can use pointer (it's only one of the uses of pointers, useful in your example).</p>

<p>When you give parameters to a function, by default, those parameters are copies, not the original. So, function(int p, int q) creates two new variables : you can do whatever you want to q and p, the x and z would not change.</p>

<p>When you use pointers, you create a special variable, containing the adress of the variable. You can get the adress of any variable with the ""&amp;"" sign. This is why, to call function(int* p, int* q) you need to write function(&amp;y, &amp;z). </p>

<p>To access the content of a pointer, you need to use the * sign in front of the pointer. Beware ! If you don't do this, you're not modifying the variable the pointer is pointing to, but the adress of the pointer (in your case, that would not be useful ; but in array manipulation, for instance, it can be very useful).</p>

<p>So, your function gets the adresses of two variables, and then do some computing. 
This function does two things :</p>

<ul>
<li>It computes something and give the result ;</li>
<li>During the computing, it gives to q the value of p, so z's value becomes y's value in the main.</li>
</ul>

<p>Do some printf in your main, checking the value of your variables, before and after the function. Do it with a function using pointers and another one that does not use them, and it'll be much clearer to you.</p>

<p>And add a ""int"" in front of your function, since it returns something.</p>
",0
5191490,5191322,7,"<p>This program invokes undefined behavior.  It both modifies and uses the value of <code>*q</code> without a sequence point between.</p>

<p>C99 standard, Section 6.5, paragraph 2:</p>

<blockquote>
  <p>Between the previous and next sequence point an object shall have its stored value
  modified at most once by the evaluation of an expression. Furthermore, the prior value
  shall be read only to determine the value to be stored.</p>
</blockquote>

<p><code>*q</code> is read in the sub-expression <code>(*p + *q)</code>, and this is not done to determine the value to store in the sub-expression <code>(*q = *p)</code>.</p>

<p>The intent appears to be to swap the two values pointed to, but a completely reasonable alternate interpretation also exists: evaluate <code>(*q = *p)</code> first, then <code>(*p + *q)</code> (which would equal <code>*p + *p</code> thanks to the assignment).  This would result in <code>*p</code> being assigned <code>*p + *p - *p</code>, or just <code>*p</code>.  As a result, <code>z</code> would be assigned the value of <code>y</code> (15), while <code>y</code> would remain 15.</p>

<p>I must emphasize that because this is undefined, your compiler can do pretty much whatever it wants, not just limited to this interpretation or swapping the two.</p>
",2
5191534,5191322,0,"<p>wnoise's answer is correct with but if you want to understand why you have such results below you can find reasoning.</p>

<p>this is not a pointer challenge but rather operator precedence. </p>

<p>Just treat <code>*p</code> and <code>*q</code> as You would use <code>y</code> &amp; <code>z</code></p>

<p>and with this code:
  <code>return(*p = (*p + *q) - (*q = *p));</code>
remember that result of assigment is assigned value thus with <code>*p = y = 15</code> and <code>*q = z = 25</code></p>

<p>you have:</p>

<p><code>return(*p = (15 + 25) - (*q = *p));</code></p>

<p><code>return(*p = 40 - (*q = 15));</code> //*q -> z becomes 15</p>

<p><code>return(*p = 40 - 15);</code> </p>

<p><code>return(*p = 25);</code> // *p -> y becomes 25</p>

<p><code>return(25);</code> </p>
",0
6662435,6662283,2,"<p>You don't say what types the three variables are. They have to be <code>int</code>.</p>

<p>The following code works as expected on my computer:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  int n, p1, p2;
  scanf(""%d %d %d"", &amp;n, &amp;p1, &amp;p2);
  printf(""%d %d %d\n"", n, p1, p2);
  return 0;
}
</code></pre>

<p>Here is the output:</p>

<pre><code>$ gcc x.c
$ ./a.out 
10 3 5
10 3 5
</code></pre>
",0
2933815,2933764,1,"<p>If the executing module isn't relocated at runtime, you could probably try to check if your EIP lies between two function addresses in your function symbols.</p>
",1
3584937,3584705,11,"<p>10x30:</p>

<pre><code>int(*array)[30] = malloc((sizeof *array) * 10);
</code></pre>

<p>15x20:</p>

<pre><code>int(*array)[20] = malloc((sizeof *array) * 15);
</code></pre>

<p>Resizing to 20x25:</p>

<pre><code>int(*array2)[25] = realloc(array, (sizeof *array2) * 20);
</code></pre>

<p>The outer dimension (10, 15, 20) can be determined at runtime, because it's not need as part of index calculations by the compiler. The inner dimension (30, 20, 25) needs to be known at compile time. Hope it helps. </p>

<p>Note that unlike the array-of-pointer solutions, this one can be handled as a single block of memory, because it allocates everything in a single chunk of memory like a real declared array:</p>

<pre><code>memcpy(somewhere, array2, sizeof(int) * 20 * 25); // (sizeof *array2) * 20
</code></pre>

<p>It ultimately depends on your usecase, though.</p>

<hr>

<p>Since some people have difficulties understanding the actions taken by an index operation to <code>array</code>, let's what Clang gives us for an index expression in the following code </p>

<pre><code>int main() {
  int(*array)[10] = malloc((sizeof *array) * 5);
  array[4][9] = 0;

  int(*array1)[10][5] = malloc((sizeof *array1) * 20);
  array1[19][9][4] = 0;
}
</code></pre>

<p>It's a nice compiler, which can print its AST in an easily readable manner</p>

<pre><code>  // array[4][9] = 0;
  (BinaryOperator 0xba62cc0 &lt;line:5:3, col:17&gt; 'int' '='
    (ArraySubscriptExpr 0xba62c80 &lt;col:3, col:13&gt; 'int'
      (ImplicitCastExpr 0xba62c60 &lt;col:3, col:10&gt; 'int *' &lt;ArrayToPointerDecay&gt;
        (ArraySubscriptExpr 0xba62c20 &lt;col:3, col:10&gt; 'int [10]'
          (DeclRefExpr 0xba62bdc &lt;col:3&gt; 'int (*)[10]' Var='array' 0xba62a00)
          (IntegerLiteral 0xba62c00 &lt;col:9&gt; 'int' 4)))
      (IntegerLiteral 0xba62c40 &lt;col:12&gt; 'int' 9))
    (IntegerLiteral 0xba62ca0 &lt;col:17&gt; 'int' 0))

  // array1[19][9][4] = 0;
  (BinaryOperator 0xba630b8 &lt;line:8:3, col:22&gt; 'int' '='
    (ArraySubscriptExpr 0xba63078 &lt;col:3, col:18&gt; 'int'
      (ImplicitCastExpr 0xba63058 &lt;col:3, col:15&gt; 'int *' &lt;ArrayToPointerDecay&gt;
        (ArraySubscriptExpr 0xba63018 &lt;col:3, col:15&gt; 'int [5]'
          (ImplicitCastExpr 0xba62ff8 &lt;col:3, col:12&gt; 'int (*)[5]' &lt;ArrayToPointerDecay&gt;
            (ArraySubscriptExpr 0xba62fa0 &lt;col:3, col:12&gt; 'int [10][5]'
              (DeclRefExpr 0xba62f5c &lt;col:3&gt; 'int (*)[10][5]' Var='array1' 0xba62db0)
              (IntegerLiteral 0xba62f80 &lt;col:10&gt; 'int' 19)))
          (IntegerLiteral 0xba62fc0 &lt;col:14&gt; 'int' 9)))
      (IntegerLiteral 0xba63038 &lt;col:17&gt; 'int' 4))
    (IntegerLiteral 0xba63098 &lt;col:22&gt; 'int' 0)))
</code></pre>

<p>Note that each array subscript expression takes a pointer, adds the value of the index, and yields the addressed element. If that subelement is an array, it is decayed to a pointer to its first element. This is really not actually different than the steps done for a declared array</p>

<pre><code>int main() {
  int array[5][10] = { };
  array[4][9] = 1;
}
</code></pre>

<p>Yields a very similar AST, with just the most inner expression first being decayed to a pointer to its first element</p>

<pre><code>  // array[4][9] = 1;
  (BinaryOperator 0xbf9f7e8 &lt;line:5:3, col:17&gt; 'int' '='
    (ArraySubscriptExpr 0xbf9f7a8 &lt;col:3, col:13&gt; 'int'
      (ImplicitCastExpr 0xbf9f788 &lt;col:3, col:10&gt; 'int *' &lt;ArrayToPointerDecay&gt;
        (ArraySubscriptExpr 0xbf9f748 &lt;col:3, col:10&gt; 'int [10]'
          (ImplicitCastExpr 0xbf9f728 &lt;col:3&gt; 'int (*)[10]' &lt;ArrayToPointerDecay&gt;
            (DeclRefExpr 0xbf9f6cc &lt;col:3&gt; 'int [5][10]' Var='array' 0xbfa81f0))
          (IntegerLiteral 0xbf9f6f0 &lt;col:9&gt; 'int' 4)))
      (IntegerLiteral 0xbf9f768 &lt;col:12&gt; 'int' 9))
    (IntegerLiteral 0xbf9f7c8 &lt;col:17&gt; 'int' 1)))
</code></pre>
",8
3584752,3584705,0,"<blockquote>
  <p>second, can i increase number of rows
  or cols without creating a new
  increased array and copying all data
  to it?</p>
</blockquote>

<p>No, you can't change the size of an array.
What you can do is use pointers and realloc to do so.</p>
",0
3584765,3584705,3,"<pre><code>// first allocate the 20 rows, that contain pointers to int 
// (if the matrix contains int type values)
int **a = malloc(20 * sizeof(int *));

// now loop for each row and allocate data for the actual values
int i;
for(i = 0; i &lt; 20; i++) {
    a[i] = malloc(10 * sizeof(int));
}
</code></pre>

<p>For increasing the size of the matrix you can use <code>realloc</code> although it would probably be easier to regenerate the matrix of different size and copy the values over.</p>
",2
3584809,3584705,4,"<p>While <code>malloc()</code> does not directly support multi-dimensional arrays, there are workarounds, such as:</p>

<pre><code>int rows = 10;
int cols = 30;
int *array = malloc(rows * cols * sizeof(int));

// Element (5,6)
int x = 5;
int y = 6;
int element = array [ x * cols + y ];
</code></pre>

<p>While this isn't directly a 2D array, it works, and in my opinion it's the simplest. But if you want to use the <code>[][]</code> syntax instead, you would have to make pointers to pointers, for instance:</p>

<pre><code>int rows = 10;
int cols = 30;
// Rows
int **array = malloc(rows * sizeof(int*));
// Cols
int i;
for(i = 0; i &lt; rows; i++)
  array[i] = malloc(cols * sizeof(int));

// Element (5,6)
int x = 5;
int y = 6;
int element = array[x][y];
</code></pre>
",4
3584904,3584705,0,"<p>A 2D array is an 1D array of 1D arrays. As an array is simply a pointer, an array of arrays is an array of pointers. So, you use <code>malloc</code> to allocate an array of pointers (each representing a collumn), then use it again to allocate the individual arrays (each representing a row).</p>

<p>To expand/shrink the array, you use <code>realloc</code><a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/realloc/"" rel=""nofollow noreferrer"">(reference)</a>. Here's an example code:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int** alloc_matrix(int w, int h) {
    int** matrix;

    matrix = (int**) malloc(sizeof(int*) * h);
    for(int i = 0; i &lt; h; i++) {
        matrix[i] = (int*) malloc(sizeof(int) * w);
    }

    return matrix;
}

void realloc_matrix(int*** matrix, int new_w, int new_h) {
    *matrix = (int**) realloc((void *)*matrix, sizeof(int*) * new_h);

    for(int i = 0; i &lt; new_h; i++) {
        (*matrix)[i] = (int*) realloc((void *)(*matrix)[i], sizeof(int) * new_w);
    }
}

int main(int argc, char* argv[]) {
    // Allocating matrix
    int** m = alloc_matrix(10, 15);

    // Filling with some data
    for(int y = 0; y &lt; 15; y++) {
        for(int x = 0; x &lt; 10; x++) {
            m[y][x] = y * x; // Notice the index is [y][x] - NOT [x][y]!
        }
    }

    // Printing
    for(int y = 0; y &lt; 15; y++) {
        for(int x = 0; x &lt; 10; x++) {
            printf(""%d\t"", m[y][x]); // Notice the index is [y][x] - NOT [x][y]!
        }
        printf(""\n"");
    }

    // Reallocating
    realloc_matrix(&amp;m, 20, 10);

    // Filling with some data
    for(int y = 0; y &lt; 10; y++) {
        for(int x = 0; x &lt; 20; x++) {
            m[y][x] = y * x; // Notice the index is [y][x] - NOT [x][y]!
        }
    }

    // Printing
    for(int y = 0; y &lt; 10; y++) {
        for(int x = 0; x &lt; 20; x++) {
            printf(""%d\t"", m[y][x]); // Notice the index is [y][x] - NOT [x][y]!
        }
        printf(""\n"");
    }
}
</code></pre>

<p>I'm sorry if I've got anything wrong. My C-fu is kinda rusty :)</p>
",0
6353182,6353173,8,"<p>You could use <code>break</code> statement there.</p>

<p>This will exit the loop and start control beneath the loop body.</p>
",0
6353200,6353173,0,"<p>Make a condition inside the loop where you want to end that..
Otherwise use <strong>break</strong> or <strong>exit</strong> like statements...</p>
",0
6353207,6353173,0,"<p>try this code:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
int main()
{
    int a;
    for(a=1 ; a&lt;=10; a++)
    {
         printf(""%d"",a); 
    }
    getch();
}
</code></pre>
",2
6353208,6353173,1,"<p>I guess this is what you are asking here...</p>

<p><strong>EDIT</strong></p>

<pre><code>int main()
{
   int a;
   a=0;
   for(;;)
   {
        if(a&gt;10)
        break;
        printf(""%d"",a);
        a++
   }
   getch();
}
</code></pre>
",1
6353258,6353173,2,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;

int main()
{
    int a = 0;
    for(;;)
       if ((++a) &lt;= 10)
         printf(""%d"",a);
       else
         break;
    getch();
}
</code></pre>
",1
6353441,6353173,0,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
int main()
{
    int a;
    a=1;
    m:
    for(;;)
    {
         if(a&lt;=10)
         {
      printf(""%d\n"",a); 
      a++;
      } 
      if(a&lt;10)
      {
      goto m;
}
         }
         getch();
    }
</code></pre>
",1
7457220,7457163,1,"<p>There is no single implementation of <code>strtol</code>.  I doubt that any implementation is susceptible to the kind of attack you describe; the obvious implementation would just traverse the sequence of digits without storing them all at once.  (Note that the digit sequence can be arbitrarily long due to leading <code>0</code>s.)</p>

<p>If you want to see the code for an implementation, you can download the glibc version <a href=""ftp://ftp.gnu.org/gnu/glibc/"" rel=""nofollow"">here</a>; <code>strtol()</code> is in <code>stdlib/strtol.c</code>.</p>
",0
7457284,7457163,-1,"<p>Well if you want to see the strtol you can see this by University  of California</p>

<pre><code>/* 
 * strtol.c --
 *
 *  Source code for the ""strtol"" library procedure.
 *
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the
 * above copyright notice and the following two paragraphs appear in
 * all copies of this software.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN ""AS IS"" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */
static const char rcsid[] = ""$Header$ SPRITE (Berkeley)"";

#include &lt;ctype.h&gt;

extern unsigned long int strtoul(char *string, char **endPtr, int base);

/*
 *----------------------------------------------------------------------
 *
 * strtol --
 *
 *  Convert an ASCII string into an integer.
 *
 * Results:
 *  The return value is the integer equivalent of string.  If endPtr
 *  is non-NULL, then *endPtr is filled in with the character
 *  after the last one that was part of the integer.  If string
 *  doesn't contain a valid integer value, then zero is returned
 *  and *endPtr is set to string.
 *
 * Side effects:
 *  None.
 *
 *----------------------------------------------------------------------
 */

long int
strtol(
    char *string,       /* String of ASCII digits, possibly
                 * preceded by white space.  For bases
                 * greater than 10, either lower- or
                 * upper-case digits may be used.
                 */
    char **endPtr,      /* Where to store address of terminating
                 * character, or NULL. */
    int base            /* Base for conversion.  Must be less
                 * than 37.  If 0, then the base is chosen
                 * from the leading characters of string:
                 * ""0x"" means hex, ""0"" means octal, anything
                 * else means decimal.
                 */
)
{
    register char *p;
    int result;

    /*
     * Skip any leading blanks.
     */
    p = string;
    while (isspace(*p)) {
    p += 1;
    }

    /*
     * Check for a sign.
     */
    if (*p == '-') {
    p += 1;
    result = -1*(strtoul(p, endPtr, base));
    } else {
    if (*p == '+') {
        p += 1;
    }
    result = strtoul(p, endPtr, base);
    }
    if ((result == 0) &amp;&amp; (endPtr != 0) &amp;&amp; (*endPtr == p)) {
    *endPtr = string;
    }
    return result;
}
</code></pre>
",1
7457938,7457163,4,"<blockquote>
  <p>However, strtol is also required to discard as many whitespace characters as necessary until the first non-whitespace character is encountered. So could it not be attacked with an endless whitespace string even if it is smart about reading digits?</p>
</blockquote>

<p>As <code>strtol</code> works on a string already in memory you would have had to store (and read from an attacker) an ""endless"" amount of whitespace (or forgotten to NUL-terminate your string) before even feeding it to strtol. </p>

<p>Since an implementation can keep calculate the maximum number of digits there can ever be in a valid string it doesn't have to keep going, as you suspect.</p>

<p>DOS attacks can occur with faulty implementations though, check out <a href=""http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/"" rel=""nofollow"">this</a> related case (this was in java and PHP when reading doubles, but the same could occur in a C or C++ implementation). </p>
",0
3742780,3742739,4,"<p>UTF-8 is a superset of ASCII. The character codes 0-127 (i.e. the ASCII characters) are directly mapped to the binary values 0-127. If you want to convert UTF-8 to ASCII, you can simply remove all bytes that are >= 128. This means that non-ASCII characters will be ignored in the converted string - if that is what you want.</p>

<p>Mind that for UTF-8 decoding, you need to detect characters that are encoded as multiple bytes. The number of bytes is the number of '1' bits left of the leftmost '0' bit, and this only applies to bytes >= 128. For example, 11000000 is the first byte of a character that was encoded to two bytes (it has two significant '1' bits). That means you also have to remove the following byte.</p>

<p>As the bytes that belong to a multi-byte-encoded character are always >= 128, you can just forget about the paragraph above :)</p>
",1
3017378,3017359,0,"<p>Ptr doesn't point to anything and probably doesn't even compile, since [4] is outside the bounds of either the [3] or the [4] of the original array.</p>

<p>If you need to find arr[1][2] then you need int (*ptr)[4] = arr[1]; int m = ptr[2];</p>
",5
3018230,3017359,1,"<p>Multi-dimensional arrays are really one dimensional arrays with a little syntaxic sugar.
The initialization you had for ptr wasn't an address. It should have been</p>

<pre><code>int *ptr[4] = { &amp;arr[0][0], &amp;arr[1][0], &amp;arr[2][0], &amp;arr[3][0]};
</code></pre>

<p>You can also leave the 4 out and just use</p>

<pre><code>int *ptr[] = { &amp;arr[0][0], &amp;arr[1][0], &amp;arr[2][0], &amp;arr[3][0]};
</code></pre>

<p>I made a few modifications to your code below. Note the two sections with the printf. They should help to demonstrative how the values are actually laid out in memory.  </p>

<pre><code>#define MAJOR 3
#define MINOR 4
int arr[MAJOR][MINOR]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};

int (*ptr)[4];
int *p = &amp;arr[0][0];

// init ptr to point to starting location in arr
for(i = 0; i &lt; MAJOR; i++) {
    ptr[i] = &amp;arr[i][0];
}

// print out all the values of arr using a single int *
for(i = 0; i &lt; MAJOR * MINOR; i++) {
    printf("" %d"", *(p + i) );
}

for(i = 0; i &lt; MAJOR; i++) {
  for(j = 0; j &lt; MINOR; j++) {
     printf( "" %d"", *(p + i * MAJOR + j) );
  }
  printf(""\n"");
}
</code></pre>
",0
2608926,2608899,2,"<p>One possible way is...</p>

<pre><code>#include &lt;stdio.h&gt;

void call(int *a) 
{
    int b;

    if (&amp;b &gt; a) 
        printf(""Stack grows up.\n"");
    else 
        printf(""Stack grows down.\n"");
}

int main () 
{
    int a;
    call(&amp;a);
    return 0;
}
</code></pre>
",11
2608933,2608899,0,"<p>Brute force approach is to fill your memory with a known value say 0xFF. Push some items on the stack. Do a memory dump. Push some more items on the stack. Do another memory dump.</p>
",0
2608965,2608899,4,"<p>This is <em>very</em> platform-dependent, and even application-dependent.</p>

<p>The code posted by Vino only works in targets where parameters are passed on the stack AND local variables are allocated from the stack, in that order. Many compilers will assign fixed memory addresses to parameters, or pass parameters in registers. While common, passing parameters on the stack is one of the least efficient ways to get data into and out of a function.</p>

<p>Look at the disassembly for your compiled app and see what code the compiler is generating. If your target has native stack manipulation commands (like PUSH and POP) that the compiler is using, then the CPU datasheet/reference manual will tell you which direction the stack is growing. However, the compiler may choose to implement its own stack, in which case you'll have to do some digging. </p>

<p>Or, read the stack pointer, push something on the stack, and read the stack pointer again. Compare the results of the first and second read to determine the direction in which the pointer moves.</p>

<p>For future reference: if you include some details about your target architecture (embedded? PC? Linux, Windows? GCC? VC? Watcom? blah blah blah) you'll get more meaningful answers.</p>
",0
2609477,2608899,0,"<p>Create function with many local variables.<br>
Turn off optimizations.
Either print the assembly language..
  Or when debugging, display as mixed source and assembly language.
  Note the stack pointer (or register) before the function is executed.
  Single-step through the function and watch the stack pointer.</p>

<p>In general, whether a compiler uses incrementing or decrementing stack pointers is a very minor issue as long as the issue is consistent and working.  This is one issue that rarely occupies my mind.  I tend to concentrate on more important topics, such as quality, correctness and robustness.</p>

<p>I'll trust the compiler to correctly handle stack manipulation.  I don't trust recursive functions, especially on embedded or restricted platforms.</p>
",0
2528644,2528638,0,"<p>You should replace your int with long int, and prefix the constants with L</p>

<p>Like this:</p>

<pre><code>long long unsigned int barcode;
barcode = 100000000LL;
printf(""Barcode is %li"", barcode);
</code></pre>
",4
2528663,2528638,0,"<p>Change the datatype to <code>long</code> as shown here</p>

<pre>
long barcode, a, b, c;
scanf(""%ld"", &barcode);
a = barcode / 1000000000000L;
b = barcode / 100000000000L % 10;
c = barcode / 10000000000L % 10;
</pre>
",0
2528666,2528638,4,"<p>Use long longs instead of ints for integer values of that size, with the LL literal suffix:</p>

<pre><code>long long barcode, a, b, c;
scanf(""%lld"", &amp;barcode);
a = barcode / 1000000000000LL;
b = barcode / 100000000000LL % 10;
c = barcode / 10000000000LL % 10;
</code></pre>
",1
2528753,2528638,0,"<p>(if you like an answer, perhaps you could select one?)</p>

<p>Also, you might consider placing the barcode in a string instead. This way you can access the first 3 digits that you need more easily (if that is what you roughly want - note: you do want c to be the first two digits after the first digit, correct?)</p>

<pre><code>char barcode[14];
int a, b, c;
scanf(""%s"", &amp;barcode);
a = (int) (barcode[0] - '0');
b = (int) (barcode[1] - '0');
c = b * 10 + (int)(barcode[2] - '0');
</code></pre>
",0
2908240,2908198,10,"<pre><code>warning: suggest parentheses around comparison in operand of '&amp;'
</code></pre>

<p>Well, how about adding them ? Change <code>n&amp;1</code> to <code>(n&amp;1)</code>. Always ask for warnings.</p>
",3
2908242,2908198,5,"<p>The <code>==</code> operator has higher precedence than the <code>&amp;</code> operator, so your <code>if (n&amp;1 == 0)</code> statement is not doing what you expect!</p>

<p>(and the <code>if (n&amp;1 == 1)</code> statement works only by coincidence that <code>1 == 1</code> evaluates to 1 ;)</p>
",0
2908253,2908198,2,"<p>Operator precedence. <code>n &amp; 1 == 0</code> is equivalent to <code>n &amp; (1 == 0)</code></p>
",0
2908256,2908198,2,"<p>It is a problem related to the order of execution. Try to use if ((n&amp;1) == 0) in all_odd_2 and everything will work.</p>
",0
3424188,3424079,1,"<p>Most simply you use . when operating on a Struct itself and -> when operating on a pointer to a struct.</p>

<p>To show in code:</p>

<pre><code>  struct s myStruct;
  myStruct.num = 5;
</code></pre>

<p>Is valid, but:</p>

<pre><code>  struct s myStruct;
  myStruct-&gt;num = 5;
</code></pre>

<p>Is invalid as myStruct is not a pointer.</p>

<pre><code>  struct s *myStruct;
  myStruct-&gt;num = 5;
</code></pre>

<p>Would be valid.</p>

<p>The -> operator is actually a shorthand for (*myStruct).num; </p>
",0
3424189,3424079,1,"<p>The C language, unlike many other languages allows variables to have objects (here structs) as values and also pointers to objects as values. Depending on which type of variable is used, ""."" or ""->"" have to be used respectively.</p>
",0
3424190,3424079,2,"<p><strong>[.]</strong> operates on a object of a structure. Once a object of a particular structure is declared the [.] operator can be used to directly operate with the members.</p>

<p><strong>[->]</strong> operates on a pointer to the object of a structure. This is a dereference operator that is used exclusively with pointers to objects with members. Thus enabling us to access members to the object to which we have a reference.</p>

<p>Based of the declaration you can use these operators.</p>
",0
3424228,3424079,0,"<p>The operator a->b, canonically, means (*a).b .
So, unlike ""."", it will dereference it's first argument.</p>

<p>I could be wrong on this point, but my understand is that it's not ""officially"" part of C (you specifically mention C in the question). It's a C++ construct that most C compiler vendors have added to C. However, I must admit that I haven't kept up with changes to C, so I could be completely wrong there.</p>

<p>In C++ there are further differences. The ""->"" operator is overloadable, where as the ""."" is not.</p>
",2
3424096,3424079,2,"<p>you're using a dot when accessing object's members, and the arrow -> when accessing members through the pointer to an object</p>
",0
3424110,3424079,2,"<p><code>-&gt;</code> is to a struct pointer what <code>.</code> is to a struct.</p>

<pre><code>struct Data data;
data.content = 1;

struct Data* pData = &amp;data;
pData-&gt;content = 2;
</code></pre>
",0
3424115,3424079,17,"<p><code>.</code> is used when you have a struct, and <code>-&gt;</code> is used when you have a pointer to a struct. The arrow is a short form for dereferencing the pointer and then using <code>.</code>: <code>p-&gt;field</code> is the same as <code>(*p).field</code>.</p>
",1
3424117,3424079,2,"<p>Ah, I just came across the same question, when looking at locale settings. One is for accessing the attributes through the pointer and one is for the dereferenced struct:</p>

<pre><code>#include &lt;locale.h&gt;

int main (void) {

    struct lconv *locale_ptr; 
    locale_ptr = localeconv();
    printf(""Currency symbol: %s\n"", (*locale_ptr).currency_symbol);
}
</code></pre>

<p>is equivalent to:</p>

<pre><code>int main (void) {

    struct lconv *locale_ptr; 
    locale_ptr = localeconv();
    printf(""Currency symbol: %s\n"", locale_ptr-&gt;currency_symbol);
}
</code></pre>
",0
3424124,3424079,7,"<p>They are almost the same thing. The only difference is that ""->"" takes a pointer to a struct on the left side while ""."" takes a struct; ""->"" deferences (i.e. follows) the pointer before accessing the struct member. So,</p>

<pre><code>struct foo bar;
bar.x = 0;
</code></pre>

<p>is the same as:</p>

<pre><code>struct foo bar;
struct foo *diddly = &amp;bar;
diddly-&gt;x = 0;
</code></pre>
",0
4524835,4524824,8,"<p><code>char *str= ""hello"";</code></p>

<p>String literal <code>""Hello""</code> is stored in <code>const</code> region of memory(on most common implementations) and has static storage duration. Any attempt to modify the content would invoke UB i.e <code>str[0]='c'</code> would cause segfault on most implementations.</p>

<p>ISO C99 <code>2.13.4/1</code> says</p>

<blockquote>
  <p>An ordinary string literal has type ""array of n const char"" and static storage duration.</p>
</blockquote>

<p><code>'static storage duration' in 3.7.1/1:</code></p>

<blockquote>
  <p>The storage for these objects shall last for the duration of the program.</p>
</blockquote>

<hr>

<blockquote>
  <p>Is it required to release the memory allocated to string <code>""str""</code>, in the below program ?</p>
</blockquote>

<p>Nopes! That would be UB too because the string is not dynamically allocated.</p>
",3
4524871,4524824,3,"<p>String constants are not allocated on the ""heap"" - where the memory that you need to <code>free()</code> is allocated. They are allocated in another special segment, and there's no way to actually ""free"" this memory - i.e. make it useful for something else in the program. <code>free(str)</code> would either lead to a crash (segmentation fault) or if your C library is smart enough it would produce an error notifying you about memory corruption. </p>

<p>You should <code>free()</code> only values that you allocated with <code>malloc()</code> or return values from functions that are specifically described by the manual as returning <code>malloc()</code>ed result that you have to free. Leave the rest alone.</p>
",0
4524895,4524824,0,"<p>If you disassemble executable of your code (for ex using gdb) you will be able to see that ""hello"" is pushed to the stack. Therefore having a scope of lifetime of the function.</p>
",2
4526592,4524824,1,"<p>Most of the other answers are pretty complete already, but one thing that hasn't been stressed enough is addressing use of <code>free</code>. The <em>only</em> pointers you're <em>ever</em> allowed to pass to <code>free</code> are those obtained via <code>malloc</code>, ""as if via <code>malloc</code>"" (some library functions are documented as returning such pointers), or via one of the other <code>malloc</code>-related functions (<code>calloc</code>, <code>realloc</code>, or on POSIX, <code>posix_memalign</code>).</p>

<p>It's not a matter of whether you ""need to"" <code>free</code> your string. The much more important thing is that you're not allowed to <code>free</code> it. At best (if your C library is very kind to you) it will detect your attempt to <code>free</code> a string literal and immediately abort your program. If you're unlucky, you'll silently corrupt memory, and either crash much later when it's hard to track down the root cause, or maybe overwrite important data with corrupt nonsense the next time you click ""save"" in your application.</p>
",0
3071976,3071890,28,"<p>You might put something like the following into <code>a.c</code> and then extern it from <code>b.c</code>.  </p>

<p>In a.c:</p>

<pre><code>int a[] = {1, 2, 3};
const int lengthofa = sizeof( a ) / sizeof( a[0] );
</code></pre>

<p>And then in b.c:</p>

<pre><code>extern int a[];
// the extern (thanks Tim Post) declaration means the actual storage is in another 
// module and fixed up at link time.  The const (thanks Jens Gustedt) prevents it
// from being modified at runtime (and thus rendering it incorrect).
extern const int lengthofa;

void somefunc() {
  int i;
  for ( i = 0; i &lt; lengthofa; i++ )
    printf( ""%d\n"", a[i] );
}
</code></pre>
",2
3071978,3071890,1,"<p>The compiler does not have enough information when compiling b.c to determine the size of the array.  That information is only in a.c where your initializer list is in scope.</p>

<p>You will have to communicate the size somehow.  One method is to define an int const with the size and extern that as well.  Another possibility would be to use a sentinel (a value outside your valid data range) to indicate the end of the array.</p>
",0
3072000,3071890,0,"<p>in my opinion if you don't have definition and define with sizeof a in one file it doesn't compile.</p>

<p>Files are compile and stored as *.obj / *.a files. You can use arrays from another files thanks to extern declaration which will be check in linking process, after compilation.</p>

<p>You want to declare define (preprocesor must help here with this. It is run before compilator).</p>

<p>so before compilation you won't get array from another file...</p>
",0
3072067,3071890,16,"<p>If you want your array size to be accessible as a compile-time constant, then you have no other choice but to specify array size explicitly in the <code>extern</code> declaration of the array</p>

<pre><code>extern int a[9];
</code></pre>

<p>In this case it becomes your responsibility to make sure that array size is consistent between the <code>extern</code> declaration and definition. You can use a manifest constant for that, but still it is going to be your responsibility to make sure that the number of initializers between the <code>{}</code> and the declared size are the same.</p>

<p>If you don't care to have the array size as a compile-time constant, then you can do what Mark Wilkins suggests in his answer.</p>
",1
3852823,3852796,2,"<p>C itself has no concept of segments (nor far pointers), this will be a feature of the underlying implementation or architecture (which you haven't specified). Segmented architectures and near/far/tiny pointers are ancient things from the 8086 days - most code nowadays (with the possible exception of embedded stuff) gives you a flat memory model where you don't have to worry about that.</p>

<p>All the standard states is that the actual characters of the string will be characters that you are not allowed to modify.</p>

<p>For what it's worth (which isn't much). my implementation stores the string itself in memory marked read-only (this may or may not be a code segment, you can easily have other segments marked read-only) and <code>p</code> (the address of the first of those characters) is placed on the stack at runtime.</p>

<p>If you run your compiler to produce the assembler output:</p>

<pre><code>gcc -S qq.c
</code></pre>

<p>you'll see something like (in <code>qq.s</code> in my case):</p>

<pre><code>        .file   ""qq.c""
        .def    ___main;        .scl    2;      .type   32;     .endef
        .section .rdata,""dr""
LC0:
        .ascii ""mystring\0""
        .text
.globl _main
        .def    _main;  .scl    2;      .type   32;     .endef
_main:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $8, %esp
        andl    $-16, %esp
        movl    $0, %eax
        addl    $15, %eax
        addl    $15, %eax
        shrl    $4, %eax
        sall    $4, %eax
        movl    %eax, -8(%ebp)
        movl    -8(%ebp), %eax
        call    __alloca
        call    ___main
        movl    $LC0, -4(%ebp)
        movl    $0, %eax
        leave
        ret
</code></pre>

<p>You can see from that, it's in its own section <code>rdata</code> (read-only data), not in the <code>text</code> section.</p>

<p>A possible disadvantage of placing it into <code>text</code> would be that things like DEP (data execute protection) would be much harder. </p>

<p>You want both code and read-only data to be read-only, but you also want code to be executable - you <em>don't</em> generally  want read-only data to be executable.</p>
",2
3852828,3852796,1,"<p>The string will probably be stored in the text segment, where it will be read-only.</p>

<p>You can say 'p is a far pointer' if it pleases you to do so, but the term has no real significance any more.  In the days of yore (when the mighty 80286 was the in thing in CPUs), then a 'far pointer' had some significance - and basically meant a pointer that did not fit in a single 16-bit address register.  You needed an address segment register as well as the address register to deal with the incredible 1 MB of addressable space.  These days, in most system (other than (some) embedded systems), that is no longer of relevance.</p>
",0
3550186,3550171,1,"<p>Don't try to modify string constants.  Use an array instead.</p>

<pre><code>char[] a = ""z.x.f.t.e.a"";
</code></pre>

<p>etc.</p>
",0
3550189,3550171,1,"<p><code>a</code> is a pointer to a string literal (which you cannot modify).  Change its definition.</p>

<pre><code>int main(int argc, char* argv[]){
    char a[] = ""z.x.f.t.e.a""; /* will be on the stack */
    char* b = ""."";
    updateStr(a,b);
    return 0;
}
</code></pre>
",0
3550195,3550171,2,"<p><code>char *a = ""blah"";</code> declares a pointer to a string literal.  These cannot be altered (well, the result is undefined).  You may want to try <code>char a[] = ""blah"";</code> instead, as this gives you a character array.</p>
",0
2932654,2932626,1,"<p>The parameter str is a char.  strlen expects a char const * argument.  From the context it would seem you need to change the prototype to char *str.</p>

<p>EDIT: You will also need to change the function return type to char *.</p>
",0
2932665,2932626,2,"<p>The second line is a problem:</p>

<pre><code>str = printf(""%x"", str);
</code></pre>

<p><code>printf</code> outputs text to <code>stdout</code>, and returns an integer representing the number of characters that it output, not the actual value that was printed. You should replace this line with a call to <code>sprintf</code> instead, to load the output into <code>str</code>:</p>

<pre><code>sprintf(str, ""%x"", str);
</code></pre>

<p>You can read about the various standard output functions here: <a href=""http://www.gnu.org/s/libc/manual/html_node/Formatted-Output-Functions.html"" rel=""nofollow noreferrer"">Formatted Output Functions</a></p>

<p>Note that <code>sprintf</code> returns the number of characters that it stored into <code>str</code>, so you can actually use this to check whether you need to add the <code>0</code>, instead of using <code>strlen</code> at all, like this:</p>

<pre><code>if (sprintf(str, ""%x"", str) == 1)
{
...
</code></pre>
",1
2932674,2932626,2,"<p>I don't know exactly what hex8 encoding is, but it looks like you're trying to turn a <code>char</code> into a two-byte hex string?  In that case, you don't need anything as complicated as you have there.  Just do something like this:</p>

<pre><code>char hexstring[3];
char character = 'f';

sprintf(hexstring, ""%02x"", character);
</code></pre>

<p>After that code fragment, <code>hexstring</code> will be <code>""66""</code>.  If you have a whole string, something like this should work (assuming you've allocated appropriate memory before calling the function):</p>

<pre><code>void string2hex(char *hex, char *in)
{
    while (*in)
    {
       hex += sprintf(hex, ""%02x"", *in);
       in++;
    }
}
</code></pre>
",2
5480480,5480473,5,"<p><a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/strtol.3.html"" rel=""noreferrer"">strtol()</a></p>
",0
5480488,5480473,0,"<p>Consider looking at the <code>strtoul()</code> or <code>atoi()</code> functions in libc to convert a string to an integer.</p>
",1
5480493,5480473,2,"<p><code>atoi()</code> will convert string into integer.</p>
",1
5480523,5480473,2,"<p>The other answers offer you a way to convert the number to an integral datatype to perform your comparison, which is a better general solution (and what I would use first), but in this case we can cheat:</p>

<ol>
<li>Skip through leading whitespace in the string.</li>
<li>If the first character is a <code>'-'</code>, it's a negative number, and it's less than zero. Return false. If the character is a <code>'+'</code>, skip it.</li>
<li>Skip any leading <code>'0'</code> characters.</li>
<li>If the next character is a digit that is not <code>'0'</code>, you've got a positive number, which is greater than zero. Return true.</li>
<li>If the next character is a <code>'.'</code>, skip it and repeat steps 3-4.</li>
<li>If you get here, then all the digits were zero. Zero isn't greater than zero, so return false.</li>
</ol>

<p>Of course, if you need (or expect) to do more than compare the string to a value, go ahead and convert it with your favorite variation of <code>strtol</code>.</p>
",0
5480526,5480473,0,"<p>if it is hw, your teacher most likely wants to go char by char, so take the ascii value and subtract '0' from it.</p>

<p>If it is longer then a single digit, go char by char, taking the result and multiplying it by 10^i, and adding it to the total</p>

<p>*i is the ith char</p>
",0
3250269,3250249,6,"<p>It is deterministic, it will return the same values every time.</p>
",4
3250330,3250249,0,"<p>As Code Clown has mentioned the code is deterministic. It would give you the same output on same ""compiler"".</p>

<p>C standard doesn't specify order of evaluation of method call arguments. So which of the two calls to method foo will get called first is up to the compiler to decide.</p>
",0
3250295,3250249,4,"<p><code>counter()</code> will return a different number each time you call it because <code>i</code> is global. However, a global variable only keeps it value during an execution. If you restart the program, it gets the value 1 and starts again!</p>
",0
3250311,3250249,10,"<p>I guess what you <em>might</em> have in mind is that the evaluation order of function parameters is not standardized in C. Since <code>counter()</code> will return a different result on each call, and the result of <code>foo(2, 3)</code> is different from that of <code>foo(3, 2)</code>, compiling and executing this code may give you different results <em>on different platforms</em>.</p>

<p>On the same platform, however, it is deterministic, as others have explained well. <strong>[Update]</strong> (To be precise: once compiled into an executable on a specific platform with specific compiler options, all executions will produce the same output. However, as commenters pointed out, it <em>might</em> even produce different output on the same platform when built with different compilation options.)<strong>[/Update]</strong></p>
",5
3250319,3250249,1,"<p>The code is deterministic but what it prints may depend on the compiler because <code>foo</code>  may receive 2,3 or 3,2.</p>
",0
3250520,3250249,0,"<p>The function foo() is not referentially transparent. Referential transparency means the function should return the same value when called on same input. For this to happen the function has to be pure, that is it should not have any side effects.</p>

<p>C language doesn't guarantee a function to be pure, one has to manage it oneself by:</p>

<ul>
<li>not storing the formal arguments of a method inside a local static field</li>
<li>not depending on value of global variable</li>
</ul>

<p>(there are many ways to make a function referentially opaque, these are more common)</p>

<p>Here subsequent calls to counter() result in different values so it is referentially opaque.</p>
",0
3250521,3250249,7,"<p>Strictly speaking, the code in question <em>might</em> give different results even when compiled on the same platform with the same compiler and settings.  The order in which function arguments are evaluated is unspecified.  The C standard defines ""unspecified behavior"" as</p>

<blockquote>
  <p>use of an unspeci?ed value, or other behavior where this International Standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance (C99 ¡ì3.4.4/1).</p>
</blockquote>

<p>The important part is that ""in any instance"" the implementation might do something different, so, for example, your compiler <em>could</em> emit code that randomly selects the order in which to evaluate the arguments.</p>

<p>Obviously, it is <em>highly unlikely</em> that any implementation would evaluate the arguments to a function differently during different runs of the same program.</p>

<p>The point is that you should never rely on the order in which function arguments are evaluated; in a correct program, it should not matter.</p>
",1
3251214,3250249,3,"<p>Several answers have indicated that while different platforms might give different results, the result is deterministic on a given platform.</p>

<p><strong>This is not correct</strong></p>

<p>The C99 Standard says (6.5/3 Expressions):</p>

<blockquote>
  <p>Except as specified later (for the function-call (), &amp;&amp;, ||, ?:, and comma operators), the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.</p>
</blockquote>

<p>So, the order of evaluation of the parameters in the call to <code>foo()</code> is not specified by the standard.  The order that the 2 calls to <code>counter()</code> cannot be counted on.  A particular compiler could order the calls differently depending on:</p>

<ul>
<li>the optimizations the compiler is asked to perform</li>
<li>the exact set of code (include files, slightly or significantly different source code in the translation unit, whatever)</li>
<li>the day of the week the program is built</li>
<li>a random number</li>
</ul>

<p>While it's unlikely that things other than the optimizations used, differences in other compiler options, or differences in the translation unit will result in a different ordering of the argument evaluation (since there probably wouldn't be much reason for the compiler to generate different output), the fact is you simply can't depend on the ordering.</p>

<p>In fact, it's even OK (as far as the standard is concerned) for the order of evaluation of the call to be made differently each time <code>foo()</code> is invoked. For example, say your example program looked like (to make what's happening when more obvious):</p>

<pre><code>#include &lt;stdio.h&gt;

int i = 1;

int counter1(){
     i = i * 3;
     printf( ""counter1()\n"");
     return i;
}

int counter2(){
     i = i * 5;
     printf( ""counter2()\n"");
     return i;
}

int foo(int i, int j){
    return i + j;
}

int main(){
   int x;
   for (x=0; x&lt;2; ++x) {
       printf(""%d\n"", foo(counter1(), counter2()));
   }

   return 0;
}
</code></pre>

<p>It would be perfectly valid for the output to look like any of the following (note there's at least one additional possibility):</p>

<p>Possibility 1:</p>

<pre><code>counter1()
counter2()
18
counter1()
counter2()
270
</code></pre>

<p>Possibility 2:</p>

<pre><code>counter1()
counter2()
18
counter2()
counter1()
300
</code></pre>

<p>Possibility 3:</p>

<pre><code>counter2()
counter1()
20
counter2()
counter1()
300
</code></pre>

<p>It would be OK (even if very weird) for the compiler to evaluate the arguments differently each time that line of code is executed, but it's permitted by the fact that the order is unspecified by the standard.</p>

<p>While it's highly unlikely that the evaluation would be 'randomized', I do think that such difficult to control things as the optimization level (or other compiler settings), the precise version/patch level of the compiler, or even the exact code that surrounds the expressions could cause the compiler to chose to a different evaluation path.</p>

<p>Relying on the order of evaluation of function arguments, even on a particular platform, is flirting with danger.</p>

<p>As a side note, this is one of the reasons that having hidden side-effects in a function is something to avoid if possible.</p>
",0
6352247,3369588,0,"<p>Passing a pointer to va_list works fine in 32 bit system. You can even fetch one parameter a time in the sub-routine.
But it doesn't seem to work in 64 bit system, will produce a segment fault at va_arg().</p>
",0
3050851,3050841,8,"<p>It equals <code>sizeof a</code></p>
",1
3050855,3050841,0,"<p>Have ever heard about <a href=""http://en.wikipedia.org/wiki/Sizeof"" rel=""nofollow noreferrer"">sizeof</a>.
It must help.</p>
",0
3050857,3050841,0,"<p>Enough to 10 floats. It depends of implementation. In most implemetations of C compilers float is 4 bytes long, so it will be at least 4 * 10 bytes. In C there is <code>sizeof</code>, use it!</p>
",2
3052586,3050841,3,"<p>Look for a C manual (<em>sizeof</em> keyword):</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  float a[10];

  printf(""sizeof float %d\n"", sizeof(float) );
  printf(""sizeof array %d\n"", sizeof(a) );
  printf(""array size %d\n"", sizeof(a)/sizeof(a[0]) ); // sizeof(a[0]) is the same with sizeof(float)
  return 0;
}
</code></pre>

<p>Hope it is not too hard.</p>
",0
2655381,2654823,0,"<p>You can use sizeof(int), but you can never assume how large an int is.  The C specification doesn't put any assumptions on the size of an int, except that it must be greater or equal to the size of a short (which must be greater or equal to the size of a char).</p>

<p>Often the size of an int aligns to the underlying hardware.  This means an int is typically the same as a word, where a word is the functional size of data fetched off the memory bus (or sometimes the CPU register width).  It doesn't have to be the same as a word, but the earliest notes I have indicated it should be the preferred size for memory transfer (which is typically a word).</p>

<p>In the past, there have been 18 bit ints (PDP-8) and 24 bit ints (PDP-15).  There have been architectures with 36 bit word sizes (PDP-11) but I can't recall what their int size turned out to be.</p>

<p>On Linux platforms, you can peek in</p>

<pre><code>#include &lt;sys/types.h&gt;
</code></pre>

<p>to get the actual bit count for each type.</p>
",0
2654832,2654823,0,"<p>Try the <code>INT_MAX</code> constant in limits.h</p>
",7
2654843,2654823,0,"<p>Do you want to require it to be 4 bytes?</p>

<p>If you just want to see the size of int as it is compiled on each platform then you can just do <code>sizeof(int)</code>.</p>
",1
2654846,2654823,21,"<p>C99 doesn't say much about this, but you can check whether <code>sizeof(int) == 4</code>, or you can use fixed size types like uint32_t (32 bits unsigned integer). They are defined in <code>stdint.h</code></p>
",3
2654854,2654823,0,"<p><code>sizeof (int)</code> will return the number of bytes an <code>int</code> occupies in memory on the current system.</p>
",0
2654866,2654823,8,"<p>If you are using C99 and require integer types of a given size, include <code>stdint.h</code>. It defines types such as <code>uint32_t</code> for an unsigned integer of exactly 32-bits, and <code>uint_fast32_t</code> for an unsigned integer of at least 32 bits and ¡°fast¡± on the target machine by some definition of fast.</p>

<p>Edit: Remember that you can also use bitfields to get a specific number of bits (though it may not give the best performance, especially with ¡°strange¡± sizes, and most aspects are implementation-defined):</p>

<pre><code>typedef struct {
    unsigned four_bytes:32;
    unsigned two_bytes:16;
    unsigned three_bits:3;
    unsigned five_bits:5;
} my_message_t;
</code></pre>

<p>Edit 2: Also remember that <code>sizeof</code> returns the number of <code>char</code>s. It's theoretically possible (though very unlikely these days) that <code>char</code> is not 8 bits; the number of bits in a <code>char</code> is defined as <code>CHAR_BIT</code> in <code>limits.h</code>.</p>
",2
2655332,2654823,0,"<p>I assume you want something beyond just the obvious <code>sizeof (int) == 4</code> check.  Likely you want some compile-time check.</p>

<p>In C++, you could use <code>BOOST_STATIC_ASSERT</code>.</p>

<p>In C, you can make compile-time assertions by writing code that tries to create negatively-sized arrays on failure or that tries to create <code>switch</code> statements with redefined cases.  See this stackoverflow question for examples: <a href=""https://stackoverflow.com/questions/174356/ways-to-assert-expressions-at-build-time-in-c"">Ways to ASSERT expressions at build time in C</a></p>
",0
2657376,2654823,0,"<p>I found last night that visual studio 2008 doesn't support C99 well, and it doesn't support stdint.h. BUT they have their own types. here is a example:</p>

<pre><code>#ifdef _MSC_VER 
typedef __int8  int8_t;
typedef unsigned __int8 uint8_t;
typedef __int16 int16_t;
typedef unsigned __int16 uint16_t;
typedef __int32 int32_t; 
typedef unsigned __int32 uint32_t; 
typedef __int64 int64_t; 
typedef unsigned __int64 uint64_t; 
#else 
#include &lt;stdint.h&gt; 
#endif 
</code></pre>
",0
8276543,8276523,2,"<p>The <code>sizeof</code> for the struct is not the same as the sum of the sizes of all the elements - this is especially the case with bitfields.</p>

<p>Typically, the struct needs to be padded to a certain size and alignment. (Which apparently is 2 on Tc/Tc++ and 4 in Linux.)</p>

<p>So although there's only 9 bits in use, it's being padded out to the word-size.</p>

<p><strong>EDIT :</strong></p>

<p>Note that the C standard does not specify how much padding is done. And therefore, you are getting different results from two different compilers.</p>
",0
8276546,8276523,1,"<p>Your structure size is rounded up to machine word. Think about it - how else can it be stored (and addressed) in memory or in a register?</p>
",1
2650592,2650580,5,"<p>You're comparing apples to oranges.</p>

<p>A pointer holds a value which is the address of another variable. An array is a contiguous collection of items. They aren't the same.</p>

<p>If you clarify your question, we could give you a better answer. As it stands, it's pretty meaningless.</p>
",0
2650613,2650580,0,"<p>In my testing (a few years back) I found the exact opposite - an array reference was faster than a pointer.  I think this was with MSVC 6.0. It all depends on the assembly code the compiler decides to generate, and it's quite arbitrary.</p>

<p>To clarify, I was comparing something like the following:</p>

<pre><code>for (int i = 0;  i &lt; length;  ++i)
    sum += p[i];

for (int i = 0;  i &lt; length;  ++i)
    sum += *p++;
</code></pre>
",0
2650901,2650580,1,"<p>They aren't. According to the C standard, <code>a[x]</code> is just syntactic sugar for <code>*(a+x)</code>.
In fact, modern processors can produce sometimes faster code if <code>a[x]</code> is used instead of raw pointer arithmetic as some static analyses can compute more information in this case, enabling more aggressive optimizations. The reason is the easier alias analysis.</p>
",0
8281566,8281543,8,"<p>Yes, you can call <code>exit(EXIT_FAILURE)</code> anywhere in your program.</p>

<p>Notice that <code>exit</code> is related to <a href=""http://linux.die.net/man/3/atexit"" rel=""noreferrer"">atexit</a>. See also <a href=""http://linux.die.net/man/2/_exit"" rel=""noreferrer"">_Exit</a> (which is rarely useful)
and <a href=""http://linux.die.net/man/3/abort"" rel=""noreferrer"">abort</a></p>
",1
8281570,8281543,4,"<p>Yes, you can call <code>exit</code> from anywhere to terminate the program. Feel free to use it anywhere you think that your program should not continue.</p>

<p>Also instead of using generic <code>EXIT_FAILURE</code>, you might want to devise your own error codes so that you can give a little more info to the caller than just ""Something went wrong"". and use that with <code>exit</code> (remember you can call it with any 8-bit value, not just <code>EXIT_FAILURE</code> or <code>EXIT_SUCCESS</code>). For instance, 0 might be success, 1 might be input read failure, 2 might be input formatting error, and so on.</p>
",2
8281738,8281543,11,"<p>The return type <code>int</code> of <code>main</code> is effectively the return value that the calling process sees. The general idea is that your <code>main</code> does this as any other function namely <code>return EXIT_FAILURE</code>. Whenever possible you should use this direct approach.</p>

<p>The function <code>exit</code> can be used to shortcut all this and to return to the caller from any other function than <code>main</code>. But the return value of a function that uses <code>exit</code> has nothing to do with the fact that it might to a preliminary exit through <code>exit</code>. So you don't have to change any prototype of your functions.</p>

<p>Your other assumptions seem to be correct, and your use of <code>exit</code> to terminate an invalid invocation looks valid to me.</p>
",0
2592942,2592893,8,"<pre><code>  char* f(int i) {
            int i; 
</code></pre>

<p>Error 1: the local 'i'  parameter shadows the 'i' argument to the function</p>

<pre><code>        char buffer[20];
        switch ( i ) {
</code></pre>

<p>Error 2: You use the local 'i' variable, which is not initialized.</p>

<pre><code>                1: strcpy( buffer, ""string1"");
                2: strcpy( buffer, ""string2"");
                3: strcpy( buffer, ""string3"");
                default: 
                strcpy(buffer, ""defaultstring"");
        }
        return buffer;
</code></pre>

<p>Error 3:  You return a pointer to an element in a local array, that pointer is not valid when the function returns. 'buffer' has gone out of scope.</p>
",0
2592964,2592893,2,"<p>There are 3 big problems:</p>

<ol>
<li><code>int i</code> is declared both as a function parameter and a local automatic variable. Remove the <code>int i;</code> statement on line 2.</li>
<li>The <code>case</code> keyword must proceed each value in a switch statement (e.g. <code>case 1:</code> instead of <code>1:</code>).</li>
<li>You are returning a pointer to an automatic variable. The <code>char buffer[20];</code> variable is placed on the stack and is no longer valid after the function returns. Instead you should allocate memory on the heap and return a pointer to that.</li>
</ol>

<p>Corrected function using <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/strdup.html"" rel=""nofollow noreferrer"">strdup</a> instead of <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/strcpy.html"" rel=""nofollow noreferrer"">strcpy</a>:</p>

<pre><code>char * f(int i) {
    switch (i) {
    case 1:
        return strdup(""string1"");
    case 2:
        return strdup(""string2"");  
    case 3:
        return strdup(""string3"");
    default:
        return strdup(""defaultstring"");
    }
}
</code></pre>
",0
2593007,2592893,1,"<p>There are a few problems here</p>

<ol>
<li><p>You're redeclaring i on line 2. i is already the parameter to the function. You don't need to redeclare it.</p></li>
<li><p>Your syntax for the switch statement is incorrect. The correct syntax is something like this: <code>case 1: /* do stuff */ break; case 2: /* do other stuff */ break;</code></p></li>
<li><p>You're attempting to return a pointer to a stack-allocated buffer. This will cause subtle problems, as there are no guarantees about that memory not being clobbered after the function returns. What is the purpose of the strcpys? If you just want to return those strings, just return those strings!</p></li>
</ol>

<p>Here's what I'd do:</p>

<pre><code>char* f(int i) {
        char buffer[20];
        switch ( i ) {
                case 1: return ""string1"";
                case 2: return ""string2"";
                case 3: return ""string3"";
                default: return ""defaultstring"";
        }
        return buffer;
}
</code></pre>
",0
2593101,2592893,1,"<ol>
<li><p>You dont need a local int i if you have a int i given to you.</p>
</li>
<li><p>Instade of</p>
<p><code>1: blabla;</code></p>
</li>
</ol>
<p>you will need</p>
<pre><code>case 1: blabla; break;
</code></pre>
<p>(for 1: 2: and 3: but not for the default)</p>
<p>3.I'm not sure about this (didn't do C for a long time) but I think the buffer will be empty after the end of the function. So you will have to pass down a char array (and the size) then change it. In that case you dont need do return anything.</p>
",0
2592912,2592893,1,"<p>You have a parameter <code>i</code> and you are declaring a local variable <code>i</code>.</p>

<p>Be declaring a local variable with the same name as a parameter you can no longer access both.  you should change the local variable name, or the parameter name.</p>
",0
2592914,2592893,6,"<p>Well, for one thing, you're missing the 'case' declaration in your switch statement as well as the breaks at the end of the statement.  Try changing your code to this:</p>

<pre><code>    char* f(int i) {
            int i; 
            char buffer[20];
            switch ( i ) {
                    case 1: strcpy( buffer, ""string1""); break;
                    case 2: strcpy( buffer, ""string2""); break;
                    case 3: strcpy( buffer, ""string3""); break;
                    default: 
                    strcpy(buffer, ""defaultstring""); break;
            }
            return buffer;
    }
</code></pre>

<p>Also, you're overriding your parameter <code>i</code> with a local variable named <code>i</code>.  So remove that:</p>

<pre><code>    char* f(int i) {
            char buffer[20];
            switch ( i ) {
                    case 1: 
                         strcpy( buffer, ""string1""); 
                         break;
                    case 2: 
                         strcpy( buffer, ""string2""); 
                         break;
                    case 3: 
                         strcpy( buffer, ""string3""); 
                         break;
                    default: 
                         strcpy(buffer, ""defaultstring""); 
                         break;
            }
            return buffer;
    }
</code></pre>

<p>Finally, you are returning a char pointer that points to a local statically declared character array named <code>buffer</code>.  <code>buffer</code> falls out of scope as soon as the pointer to its first element is returned (what your return statement does).  What that means is you end up with a pointer to a variable that no longer exists.  To fix this, you can pass a pointer to buffer into the function, like this:</p>

<pre><code>    void f(char *buffer, int i) {
            switch ( i ) {
                    case 1: 
                         strcpy( buffer, ""string1""); 
                         break;
                    case 2: 
                         strcpy( buffer, ""string2""); 
                         break;
                    case 3: 
                         strcpy( buffer, ""string3""); 
                         break;
                    default: 
                         strcpy(buffer, ""defaultstring""); 
                         break;
            }
    }
</code></pre>

<p>That last version should work, provided you make sure that <code>buffer</code> is long enough to accept the string.  If you really want to make it safe, take in <code>buffer</code>'s length as well and check that against the length of the string you are copying.</p>
",0
2592916,2592893,1,"<p>You declare a local variable <code>i</code>, which shadows the <code>i</code> parameter to the function.</p>
",0
2592925,2592893,2,"<p>A couple fixes applied here</p>

<pre><code>    const char* f(int i) {
            switch ( i ) {
                    case 1: return ""string1"";
                    case 2: return ""string2"";
                    case 3: return ""string3"";
            }
            return ""defaultstring"";
    }
</code></pre>
",2
2592926,2592893,1,"<p>It does shadow a parameter. i is the function argument, then is declared inside function. Also, you can't declare an array on stack (char buffer[20]) then return it. It (buffer) goes out of scope as soon as the function exits.</p>
",0
2592929,2592893,1,"<p>The problem is exactly what it's telling you. Right at the beginning you have:</p>

<pre><code>char* f(int i) {
        int i; 
</code></pre>

<p>The second line defines a variable named <code>i</code> -- which ""shadows"" (hides) the <code>i</code> that was passed as a parameter. When you do your <code>switch</code> on the value of <code>i</code>, you're doing it on the (uninitialized) value of the local variable, instead of the parameter you received.</p>

<p>You've also defined <code>buffer</code> local to <code>f</code>, so returning it is a problem -- it no longer exists by the time it's been returned. Given that what you're putting into it is any one of a number of string literals, you'd be better off returning the string literals directly:</p>

<pre><code>char const *f(int i) { 
    switch (i) { 
        case 1: return ""string 1"";
        case 2: return ""string 2"";
        case 3: return ""string 3"";
        default: return ""default string"";
    }
}
</code></pre>

<p>Alternatively, you could use an array of strings:</p>

<pre><code>char const *f(int i) { 
    char *strings[] = {"""", ""string 1"", ""string 2"", ""string 3""};
    if (i&gt;0 &amp;&amp; i&lt;3) 
        return strings[i];
    return ""default string"";
}
</code></pre>
",0
2592931,2592893,1,"<p>You are returning a local variable - that can only end in tears.</p>
",1
3557254,3557227,2,"<pre><code>long long unsigned n = 0x000000000076fba1;
printf(""%0x0.16llx\n"", n);
</code></pre>
",3
3557694,3557227,0,"<pre><code>#ifdef __int64   
printf(""%#018I64x\n"", n); /* for MSVC+MinGW */
#else
printf(""%#018llx\n"", n);  /* other compiler with ""unsigned long long"" support */
#endif
</code></pre>
",4
3126725,3126696,6,"<p>It's a simple heuristic problem. You already have the right idea. For a start, if you want to use int (and that's probably a good idea in your case to avoid fp-precision headaches and the need to use a separate fmod), you'll have to scale the floating-point input and your modulo/divisors by 100. Also to cut down on some redundancy, consider using a function like:</p>

<pre><code>// returns number of units and subtracts unit_size * result
// from val
int units(int* val, int unit_size)
{
    int num = *val / unit_size;
    *val %= unit_size;
    return num;
}

printf(""No. of P1000 bill: %d\n"",units(&amp;x, 1000 * 100) );
printf(""No. of P500 bill: %d\n"",units(&amp;x, 500 * 100) );
printf(""No. of P200 bill: %d\n"",units(&amp;x, 200 * 100) );
etc.
</code></pre>

<p>That should cut down on redundant code a little bit. Maybe not worth getting too fancy for it and I suspect this is homework. Complete solution:</p>

<pre><code>// returns number of units and subtracts unit_size * result
// from val
int units(int* val, int unit_size)
{
    int num = *val / unit_size;
    *val %= unit_size;
    return num;
}

int main()
{
    printf(""Enter input: "");

    float amount;
    scanf(""%f"",&amp;amount);
    int x = (int)(amount * 100.0 + 0.5);

    printf(""No. of P1000 bill: %d\n"", units(&amp;x, 1000 * 100) );
    printf(""No. of P500 bill: %d\n"", units(&amp;x, 500 * 100) );
    printf(""No. of P200 bill: %d\n"", units(&amp;x, 200 * 100) );
    printf(""No. of P100 bill: %d\n"", units(&amp;x, 100 * 100) );
    printf(""No. of P50 bill: %d\n"", units(&amp;x, 50 * 100) );
    printf(""No. of P20 bill: %d\n"", units(&amp;x, 20 * 100) );
    printf(""No. of P10 coin: %d\n"", units(&amp;x, 10 * 100) );
    printf(""No. of P5 coin: %d\n"", units(&amp;x, 10 * 100) );
    printf(""No. of P1 coin: %d\n"", units(&amp;x, 1 * 100) );
    printf(""No. of 25 cents: %d\n"", units(&amp;x, 25) );
    printf(""No. of 1 cent: %d\n"", units(&amp;x, 1) );

    return 0;
}
</code></pre>

<p>[Edit] If you have trouble understanding pointers, then just do it the way you wrote without using the units function but modify it accordingly to read in a float and multiply by 100 as in the example above.</p>

<p>[Edit] Requested:</p>

<pre><code>int main()
{
    printf(""Enter input: "");

    float amount;
    scanf(""%f"",&amp;amount);
    int x = (int)(amount * 100.0 + 0.5); // x stores the user input in cents

    int y = x / 100000; // 1000 dollars is 100,000 cents
    printf(""\nNo. of P1000 bill: %d"",y);
    x = x % 100000;

    ...

    y=x / 25; // we're working with cents, so 25 = 25 cents
    printf(""\nNo. of 25 cents: %d"",y);    
    x = (x % 25);

    ...
}
</code></pre>
",14
3126734,3126696,2,"<p>Scan the user's value into a <code>float</code>, then separate the dollars and cents into two <code>int</code> values.</p>

<p>The coins required for the cents value should then be very easy to calculate, using the same method you've already used (except dividing/mod by 25 for 25 cents, 1 for 1 cent etc.)</p>
",7
3929688,3929547,2,"<p><em>Problem 1</em></p>

<p>After this code, the variable <code>line</code> contains a line of text, including the newline character from the end of the string</p>

<pre><code>while(fgets(line,sizeof line,stdin) != NULL)
{
</code></pre>

<p>This is why you are getting the ""extra"" newlines.  The ASCII value for newline is less than the ASCII value for 'A'.  That is why the newlines end up at the beginning of each string, once you've sorted the characters.  E.g. ""computer\n"" becomes ""\ncemoprtu"".</p>

<p>To solve this, you can strip the newlines off the end of your strings, after the for-loop</p>

<pre><code>if(i &gt; 0 &amp;&amp; word[i-1] == '\n')
{
  word[i-1] = '\0';
  line[i-1] = '\0';
  --i;
}
</code></pre>

<p>...</p>

<pre><code>printf(""%s %s\n"",line,word); /* notice the addition of the newline at the end */
</code></pre>

<p>This happens to solve problem 2, as well, but please read on, to see what was wrong.</p>

<p><em>Problem 2</em></p>

<p>After the loop </p>

<pre><code>for (i=0; line[i] != '\0'; i++) { /* */ }
</code></pre>

<p>The string <code>word</code> will not be null-terminated (except by blind luck, since it is ready random uninitialized memory).  This is why you get the ""ter"", because that is part of the data you left behind when you copied the word ""computer"" to <code>word</code>.</p>

<p><em>Problem 3</em></p>

<p>After the loop</p>

<pre><code>for (i=0; line[i] != '\0'; i++) { /* */ }
</code></pre>

<p>The value of <code>line[i] != '\0'</code> will always be false.  This means that this code will do nothing</p>

<pre><code>while (line[i] != '\0')
  i++;
</code></pre>

<p>It might make the problem more obvious if I replace the for-loop and the while-loop with basically identical code, using goto:</p>

<pre><code>i=0;
begin_for_loop:
if(line[i] != '\0')
{
  {
    word[i]=line[i];
  }
  i++;
  goto begin_for_loop;
}

begin_while_loop:
if(line[i] != '\0')
{
  i++;
  goto begin_while_loop;
}
</code></pre>

<p>(btw, most professional programmers will do anything from laugh to yell at you if you mention using goto :)  I only am using it here to illustrate the point)</p>

<p>A tip I find handy is to draw out my arrays, variables etc on a piece of paper, then trace through each line of my code (again, on paper) to debug how it works.</p>
",9
3225018,3225016,10,"<p>The first example has a wild (not explicitly initialized) pointer.  Since it's not an automatic variable, it is set to 0, which clearly is not memory you own.  You can see this by printing it out with:</p>

<pre><code>printf(""%p\n"", p)
</code></pre>

<p>As for the second, C99 ¡ì6.9.2 actually gives this as an example:</p>

<blockquote>
  <p>EXAMPLE 2 If at the end of the
  translation unit containing </p>
  
  <p>int i[];</p>
  
  <p>the array i still has incomplete type,
  the implicit initializer causes it to
  have one element, which is set to zero
  on program startup.</p>
</blockquote>

<p>In general, objects with tentative definition (no initializer) are initialized with 0, which for an array means a 1-element array with element value 0.</p>
",3
3225036,3225016,0,"<p>Your first example causes a segmentation fault because you are dereferencing NULL. You never initialize <code>p</code> with a value, and <em>because it's a global</em> it will be NULL. Thus, you dereference NULL, and boom.</p>

<p>I'm not sure how the second example is valid - gcc notes that it is assuming <code>q</code> to be a 1-element array, which is why that won't blow up.</p>
",0
3225063,3225016,3,"<p><code>*p = 1;</code> causes Segmentation fault because it was not allocated any memory before the assignment.</p>

<p><code>*q = 1;</code>works because the compiler (gcc 4.2.1 on Mac OS X) warns that q[] is assumed to have one element.</p>
",0
3861506,3860943,24,"<p>It is possible for an implementation to meet the interface requirements for <code>fgetc</code> and <code>fputc</code> even if <code>sizeof(int) == 1</code>.</p>

<p>The interface for <code>fgetc</code> says that it returns the character read as an <code>unsigned char</code> converted to an <code>int</code>. Nowhere does it say that this value cannot be <code>EOF</code> even though the expectation is clearly that valid reads ""usually"" return positive values. Of course, <code>fgetc</code> returns <code>EOF</code> on a read failure or end of stream but in these cases the file's error indicator or end-of-file indicator (respectively) is also set.</p>

<p>Similarly, nowhere does it say that you can't pass <code>EOF</code> to <code>fputc</code> so long as that happens to coincide with the value of an <code>unsigned char</code> converted to an <code>int</code>.</p>

<p>Obviously the programmer has to be very careful on such platforms. This is might not do a full copy:</p>

<pre><code>void Copy(FILE *out, FILE *in)
{
    int c;
    while((c = fgetc(in)) != EOF)
        fputc(c, out);
}
</code></pre>

<p>Instead, you would have to do something like (not tested!):</p>

<pre><code>void Copy(FILE *out, FILE *in)
{
    int c;
    while((c = fgetc(in)) != EOF || (!feof(in) &amp;&amp; !ferror(in)))
        fputc(c, out);
}
</code></pre>

<p>Of course, platforms where you will have real problems are those where <code>sizeof(int) == 1</code> and the conversion from <code>unsigned char</code> to <code>int</code> is not an injection. I believe that this would necessarily the case on platforms using sign and magnitude or ones complement for representation of signed integers.</p>
",3
3861540,3860943,10,"<p>I remember this exact same question on comp.lang.c some 10 or 15 years ago. Searching for it, I've found a more current discussion here:</p>

<p><a href=""http://groups.google.de/group/comp.lang.c/browse_thread/thread/9047fe9cc86e1c6a/cb362cbc90e017ac"" rel=""noreferrer"">http://groups.google.de/group/comp.lang.c/browse_thread/thread/9047fe9cc86e1c6a/cb362cbc90e017ac</a></p>

<p>I think there are two resulting facts:</p>

<p>(a) There can be implementations where strict conformance is not possible. E.g. sizeof(int)==1 with one-complement's or sign-magnitude negative values or padding bits in the int type, i.e. not all unsigned char values can be converted to a valid int value.</p>

<p>(b) The typical idiom <code>((c=fgetc(in))!=EOF)</code> is not portable (except for CHAR_BIT==8), as EOF is not required to be a separate value.</p>
",1
3860982,3860943,3,"<p><s>Would it not be sufficient if a nominal <code>char</code> which shared a bit pattern with <code>EOF</code> was defined as non-sensical? If, for instance, CHAR_BIT was 16 but all the allowed values occupied only the 15 least significant bits (assume a 2s-complement of sign-magnitude int representation). Or must everything representable in a <code>char</code> have meaning as such? I confess I don't know.</p>

<p>Sure, that would be a weird beast, but we're letting our imaginations go here, right?</s></p>

<p>R.. has convinced me that this won't hold together. Because a hosted implementation must implement <code>stdio.h</code> and if <code>fwrite</code> is to be able to stick integers on the disk, then <code>fgetc</code> could return any bit pattern that would fit in a <code>char</code>, and that must not interfere with returning EOF. QED.</p>
",3
3861959,3860943,1,"<p>You are assuming that the EOF cannot be an actual character in the character set.
If you allow this, then sizeof(int) == 1 is OK.</p>
",5
3861283,3860943,2,"<p>I'm not so familiar with C99, but I don't see anything that says <code>fgetc</code> must produce the full range of values of <code>char</code>. The obvious way to implement stdio on such a system would be to put 8 bits in each <code>char</code>, regardless of its capacity. The requirement of <code>EOF</code> is</p>

<blockquote>
  <p><code>EOF</code></p>
  
  <p>which expands to an integer
  constant expression, with type int and
  a negative value, that is returned by
  several functions to indicate
  end-of-file, that is, no more input
  from a stream</p>
</blockquote>

<p>The situation is analogous to <code>wchar_t</code> and <code>wint_t</code>. In 7.24.1/2-3 defining <code>wint_t</code> and <code>WEOF</code>, footnote 278 says</p>

<blockquote>
  <p><code>wchar_t</code> and <code>wint_t</code> can be the same integer type.</p>
</blockquote>

<p>which would seem to guarantee that ""soft"" range checking is sufficient to guarantee that <code>*EOF</code> is not in the character set.</p>

<h2>Edit:</h2>

<p>This wouldn't allow binary streams, since in such a case <code>fputc</code> and <code>fgetc</code> are required to perform no transformation. (7.19.2/3) Binary streams are not optional; only their distinctness from text streams is optional. So it would appear that this renders such an implementation noncompliant. It would still be perfectly usable, though, as long as you don't attempt to write binary data outside the 8-bit range.</p>
",7
3861289,3860943,2,"<p>I think you are right. Such an implementation cannot distinguish a legitimate unsigned char value from EOF when using <code>fgetc</code>/<code>fputc</code> on binary streams.</p>

<p>If there are such implementations (<a href=""http://www.dsprelated.com/groups/code-comp/show/591.php"" rel=""nofollow"">this thread</a> seems to suggest there are), they are not <em>strictly</em> conforming. It is possible to have a <em>freestanding</em> implementation with <code>sizeof (int) == 1</code>.</p>

<p>A freestanding implementation (C99 4) only needs to support the features from the standard library as specified in these headers: &lt;float.h&gt;, 
&lt;iso646.h&gt;, &lt;limits.h&gt;, &lt;stdarg.h&gt;, &lt;stdbool.h&gt;, &lt;stddef.h&gt;, and 
&lt;stdint.h&gt;. (Note no &lt;stdio.h&gt;). Freestanding might make more sense for a DSP or other embedded device anyway.</p>
",2
3867416,3860943,1,"<p>The TI C55x compiler I am using has a 16bit char and 16bit int and <em>does</em> include a standard library.  The library merely assumes an eight bit character set, so that when interpreted as a character as char of value > 255 is not defined; and when writing to an 8-bit stream device, the most significant 8 bits are discarded: For example when written to the UART, only the lower 8 bits are transferred to the shift register and output.</p>
",4
3575883,3575836,0,"<p>Well, <code>cd /home/myaccount</code> will change the current directory before <code>my-script</code> is launched, which means that <code>my-script</code> will not know where it originally was. Maybe you can look at the <code>OLDPWD</code> environment variable, but that will not tell you if you switched dir just before you ran <code>my-script</code> or a long time before that.</p>

<p>Or maybe I misunderstood you. Maybe you are looking for argv[0]?</p>

<pre><code>int main(int argc, char *argv[]) {
  printf(""%s\n"", argv[0]);
}
</code></pre>
",1
3575998,3575836,-1,"<p>besides argv[0], you can try getcwd() to get the path </p>
",1
3576393,3575836,0,"<p>Fabio,</p>

<p>If you run a 'C script' then you have a process which has executed (interpreted or compiled on-the-fly) this .c source code file.</p>

<p>When you will try to identify the 'starting point or origin of the script' you will find the parent process path and name.</p>

<p>There is no way to execute a C script from the position of its source code file - <strong>unless</strong> the parent process is actually compiling the C source code file into an executable file (which can then be stored at any place where the parent process has access).</p>

<p>Hope is clarrifies this issue.</p>
",0
3576068,3575836,6,"<p><code>readlink(""/proc/self/exe"", buffer, buffer_size)</code></p>

<p>This will get you the location of the executable under Linux.  <code>man 2 readlink</code></p>

<p>If you are not using Linux you can try examining <code>argv[0]</code> and see if that is the location of the currently running program, but it is entirely possible to run a program with a different <code>argv[0]</code> than the path to the program; it could be either the executable name, relative path, or even something that has nothing at all to do with the program being run.</p>

<p>A last effort to determine this could be to search for the program in the <code>PATH</code>, and assume that if it is there then that was how it was run.  I wouldn't trust this very much, though.</p>

<p>The best solution is to not write a program that relies on this type of information.</p>
",0
2654489,2654409,4,"<p>If you'd use indentation on your code you could spot the problems a lot easier:</p>

<pre><code>int main()
{
    char i,input[30],close,open;
    for(i=0;i&lt;='.';i++) // why i &lt;= '.'? maybe you mean int i and input[i] != '.'...
    {
        printf(""enter equation"");
        scanf(""%c"",input[i]); // you need &amp;input[i]. In fact, I think what you need is scanf(""%s"", input); but outside of this for loop...
        if(input[i]=='(')
            input++; // Do you mean input[i]++?
        input[i]=open; // this isn't inside the if condition. Use brackets if you want it to be
        else if(input[i]==')') // won't compile because there's no matching if
            input[i]--;
        input[i]=close; // not inside the else. Also, what is close and open? You don't initialize them
        else if(open[i]==close[i]) // open and close are not arrays. You can't use them like this
        {
            printf(""paranthesis are balance"");
        }
        else
            printf(""paranthesis are not balance"");
    }

    getch();
    return 0;
}
</code></pre>

<p>There's a lot wrong. I suggest reading a tutorial. <a href=""http://www.java2s.com/Tutorial/C/CatalogC.htm"" rel=""nofollow noreferrer"">This one</a>, for example. You can google for more with ""C tutorial""</p>
",0
2654541,2654409,0,"<p>The technique I'd use is to go through the input, keeping a counter of parentheses.  For each '(', increment the counter.  For each ')', decrement the counter and check if it's negative (to spot things like ""())(()"", which has the same number of left and right parens, but aren't balanced).  If the counter goes negative at any point, the parens are unbalanced, otherwise they're balanced if the counter is zero at the end.</p>

<p>Frankly, I completely fail to understand what you're trying to accomplish with the above code, and I've got a lot of experience at reading student C code, so all I can give you is algorithmic advice.</p>
",0
4603511,4603469,1,"<p><code>int</code> is the required return type for <code>main</code> per the C standard.</p>
",3
4603519,4603469,2,"<p>With C you are always required to specify your output type. So the <code>int</code> is always required (with some compilers, <code>void</code> will work too).</p>

<p>The ""normal"" minimal version is this:</p>

<pre><code>int main(int argc, char **argv){
    return 0;
}
</code></pre>

<p>Depending on your system you could also have a <code>char **envp</code> and <code>char **apple</code> there aswell.</p>

<p><a href=""http://en.wikipedia.org/wiki/Main_function_(programming)#C_and_C.2B.2B"" rel=""nofollow"">http://en.wikipedia.org/wiki/Main_function_(programming)#C_and_C.2B.2B</a></p>
",8
4603557,4603469,0,"<p>The int is a return code.  I believe C defaults to returning 0.  Generally speaking a return of 0 means successful completion of program while 1,2,3... would be error codes.  It is often used by programs that want to test if the program ran successfully.</p>
",0
4603583,4603469,0,"<p><code>int</code>is the return type for the function, in this case the <code>main()</code>. As you know, you always need to specify the return type of a function in C (it could be <code>void</code>; there you don't need to return anything)!</p>

<p>When your function has a return type (<code>int</code>, for example), you are obligated to put a return sentence (<code>return 0;</code>, for example). In C, is a ""standard"" to return 0 when a function executed correctly. Also, when you run your program, you can obtain the value returned after the execution (in this case it will be 0). If the execution of your program would terminate erroneously, then you could return any other value (-1, 1, 2, etc.) and it is easier for you to detect the error and debug it.</p>
",0
3054042,3053999,0,"<p>Your only real option off the top of my head is either to write your own routine, or use the ctime() function defined in POSIX.1/C90. ctime() is certainly worth looking into, but if your date is not in the right timezone already, you will run into issues.</p>

<p>EDIT: I didn't think about using localtime as mentioned by Jerry below. Converting it to a struct tm does give you more possibilities including what he mentions, and strptime().</p>
",1
3054052,3053999,71,"<p>Use <code>localtime</code> to convert the <code>time_t</code> to a <code>struct tm</code>. You can use <code>strftime</code> to print the desired data from that.</p>

<pre><code>char buff[20];
time_t now = time(NULL);
strftime(buff, 20, ""%Y-%m-%d %H:%M:%S"", localtime(&amp;now));
</code></pre>
",6
5611753,5611724,35,"<p>The problem is that <code>(TOTAL_ELEMENTS-2)</code> is an unsigned value. When you make the comparison <code>d &lt;= (TOTAL_ELEMENTS-2)</code>, both values are converted to unsigned values, and the result is false.</p>

<p>In your second example, <code>x</code> is signed so there is no problem.</p>
",1
5611792,5611724,8,"<p>The <code>sizeof</code> operator yields a result of type <code>size_t</code>. In the first version, you are comparing an <code>int</code> (signed) against a <code>size_t</code> (unsigned).</p>

<p>In the second version, you convert the <code>size_t</code> expression to an <code>int</code> by assigning it, and hence both operands of the comparison are of the same type.</p>
",0
3184177,3184084,2,"<p>Any point on the surface of your box will have at least one coordinate equal to 0.5 or -0.5, and all others will be -0.5 &lt;= c &lt;= 0.5.</p>

<p>So, find the coordinate with the largest absolute value, and then scale the vector to make that coordinate equal to +/- 0.5.</p>

<p>Something like this might work:</p>

<pre><code>if (fabs(x) &gt; fabs(y) &amp;&amp; fabs(x) &gt; fabs(z))
    y *= 0.5 / fabs(x)
    z *= 0.5 / fabs(x)
    x *= 0.5 / fabs(x)
else if (fabs(y) &gt; fabs(z))
    x *= 0.5 / fabs(y)
    z *= 0.5 / fabs(y)
    y *= 0.5 / fabs(y)
else
    x *= 0.5 / fabs(z)
    y *= 0.5 / fabs(z)
    z *= 0.5 / fabs(z)
</code></pre>
",3
3177559,3177539,14,"<p>You must have a different definition of ""error"" to me :-) What gets printed the first two times you call your <code>f</code> function? I get</p>

<pre><code>1 -1216175936 134513787
1  2          134513787
1  2          3
</code></pre>

<p>for my three function calls.</p>

<p>What you're seeing is a holdover from the very early days of C when people played footloose and fancy-free with their function calls.</p>

<p>All that is happening is that you are calling a function <code>f</code> and it's printing out three values from the stack (yes, even when you only give it one or two). What happens when you don't provide enough is that your program will most likely just use what was there anyway, usually leading to data issues when reading and catastrophic failure when writing.</p>

<p>This is perfectly compilable, though very unwise, C. And I mean that in a very real, ""undefined behaviour"", sense of the word (referring specifically to C99: ""If the expression that denotes the called function has a type that does not include a prototype, ... if the number of arguments does not equal the number of parameters, the behaviour is undefined"").</p>

<p>You should really provide fully formed function prototypes such as:</p>

<pre><code>void f(int,int,int);
</code></pre>

<p>to ensure your compiler picks up this problem, and use ellipses (<code>...</code>) in variable parameter functions.</p>

<hr>

<p>As an aside, what usually happens under the covers is that the calling function starts with a stack like:</p>

<pre><code>12345678
11111111
</code></pre>

<p>and pushes (for example) two values onto a stack, so that it ends up like:</p>

<pre><code>12345678
11111111
2
1
</code></pre>

<p>When the called function uses the first three values on the stack (since that's what it wants), it finds that it has <code>1</code>, <code>2</code> and <code>11111111</code>.</p>

<p>It does what it has to do then returns and the calling function clears those two values off the stack (this is called a caller-makes-good strategy). Woe betide anyone who tries this with a callee-makes-good strategy :-) although that's pretty unusual in C since it makes variable argument functions like <code>printf</code> a little hard to do.</p>
",12
3177562,3177539,3,"<blockquote>
<pre><code>int f();
</code></pre>
</blockquote>

<p>In C this declares a function which take a variable number of arguments i.e. it's equivalent to the following in C++</p>

<pre><code>int f(...);
</code></pre>

<p>To check this use the following instead of <code>int f();</code></p>

<pre><code>int f(void);
</code></pre>

<p>This will cause the compiler to complain.</p>

<p>Please note: A C linker quirk is also involved here...the C linker does not validate the arguments being passed to a function at the point of invocation and simply links to the first public symbol with the same name. Thus the use of f() in main is allowed because of the declaration of <code>int f()</code>. But the linker binds the function f(int, int, int) during link time at the invocation sites. Hope that makes some sense (please let me know if it doesn't)</p>
",11
3177566,3177539,4,"<p>This declaration:</p>

<pre><code>int f();
</code></pre>

<p>...tells the compiler ""<code>f</code> is a function that takes some fixed number of arguments, and returns <code>int</code>"".  You then try to call it with one, two and three arguments - C compilers are conceptually one-pass (after preprocessing), so at this point, the compiler doesn't have the information available to argue with you.</p>

<p>Your actual implementation of <code>f()</code> takes three <code>int</code> arguments, so the calls which only provide one and two arguments invoke undefined behaviour - it's an error which means that the compiler isn't required to give you an error message, and <em>anything</em> could happen when you run the program.</p>
",5
3177675,3177539,1,"<p>It runs fine since <code>int f()</code> means what other answer has already said: it means unspecified number of arguments. This mean you can call it with the number of arguments that you want (also more than 3), without the compiler saying anything about it.</p>

<p>The reason why it works ""under the cover"", is that arguments are pushed on the stack, and then accessed ""from"" the stack in the <code>f</code> function. If you pass 0 arguments, the <code>i, j, k</code> of the function ""corresponds"" to values on the stack that, from the function PoV, are garbage. Nonetheless you can access their values. If you pass 1 argument, one of the three <code>i j k</code> accesses the value, the others get garbage. And so on.</p>

<p>Notice that the same reasoning works if the arguments are passed in some other way, but anyway these are the convention in use. Another important aspect of these conventions is that the callee is not responsible for adjusting the stack; it is up to the caller, that knows how many argument are pushed for real. If it would be not so, the definition of <code>f</code> could suggest that it has to ""adjust"" the stack to ""release"" three integer, and this would cause a crash of some kind.</p>

<p>What you've written is fine for the current standard (on gcc compiles with no warnings even with <code>-std=c99 -pedantic</code>; there's a warning, but it's about the missing <code>int</code> in front of the <code>f</code> definition), even though many people finds it disgusting and call that an ""obsolescent feature"". For sure, your usage in the example code does not show any usefulness, and likely it can help busting bugs a more binding usage of prototypes! (But still, I prefer C to Ada)</p>

<p><strong>add</strong></p>

<p>A more ""useful"" usage of the ""feature"" that does not trigger the ""undefined behaviour"" issue, could be</p>

<pre><code>#include&lt;stdio.h&gt;
int f();

int main()
{

    f(1);
    f(2,2);
    f(3,2,3);
}

int f(int i,int j,int k)
{
  if ( i == 1 ) printf(""%d\n"", i);
  if ( i == 2 ) printf(""%d %d\n"", i, j);
  if ( i == 3 ) printf(""%d %d %d\n"", i, j, k);
}
</code></pre>
",7
3178411,3177539,0,"<p>When you compile the same program using g++ compiler you see the following errors - </p>

<pre><code>g++ program.c
program.c: In function `int main()':
program.c:2: error: too many arguments to function `int f()'
program.c:6: error: at this point in file
program.c:2: error: too many arguments to function `int f()'
program.c:7: error: at this point in file
program.c:2: error: too many arguments to function `int f()'
program.c:8: error: at this point in file
program.c: At global scope:
program.c:12: error: ISO C++ forbids declaration of `f' with no type
</code></pre>

<p>Using gcc with option -std=c99 just gives a warning</p>

<p>Compile the same program with the same standard which g++ is having by default, gives the following message:</p>

<pre><code>gcc program.c -std=c++98
cc1: warning: command line option ""-std=c++98"" is valid for C++/ObjC++ but not for C
</code></pre>

<p>My answer then would be or c compilers conform to a different standard which is not as restrictive as the one which c++ conforms to. </p>
",0
3178640,3177539,0,"<p>In C a declaration has to declare at least the return type. So</p>

<pre><code>int f();
</code></pre>

<p>declares a function that returns the type <code>int</code>. This declaration doesn't include any information about the parameters the function takes. The definition of the function is</p>

<pre><code>f(int i,int j,int k)
{

    printf(""%d %d %d"",i,j,k);
}
</code></pre>

<p>Now it is known, that the function takes three <code>int</code>s. If you call the function with arguments that are different from the definition you will not get a compile-time error, but a runtime error (or if you don't like the negative connotation of error: ""undefined behavior""). A C-compiler is <strong>not</strong> forced by the standard to catch those inconsistencies.</p>

<p>To prevent those errors, you should use proper function prototypes such as</p>

<pre><code>f(int,int,int);           //in your case
f(void);                  //if you have no parameters
</code></pre>
",0
6120804,6120738,1,"<p>You could loop over all chars in your string, and check for some characters you need to manipulate. A simple draft could look like:</p>

<pre><code>char *str = ""some-text"";
char *p = str;

while ( *p ) {
 char ch = *p++;
 switch( ch ) {
   case '-': manip1(ch);
   ...
  }
}
</code></pre>
",2
3927366,3927311,4,"<p>From the <code>fgets(3)</code> man page:</p>

<blockquote>
  <p>DESCRIPTION</p>

<pre><code>  fgets() reads in at most one less than size characters from stream  and
  stores  them  into  the buffer pointed to by s.  Reading stops after an
  EOF or a newline.  If a newline is read, it is stored into the  buffer.
  A '\0' is stored after the last character in the buffer.
</code></pre>
  
  <p>...</p>
  
  <p>RETURN VALUE</p>
  
  <p>...</p>

<pre><code>  gets() and fgets() return s on success, and NULL on error or  when end
  of file occurs while no characters have been read.
</code></pre>
</blockquote>

<p>From that, it can be inferred that a <code>size</code> of <code>1</code> will cause it to read an empty string. Experimentation here confirms that.</p>

<p>Incidentally, a <code>size</code> of <code>0</code> appears to not modify the buffer at all, not even putting in a <code>\0</code>.</p>
",1
3927689,3927311,4,"<p>Yes.  Besides passing 1 (as noted by Ignacio), <code>fgets</code> doesn't do any special handling for embedded nulls.  So if the next character in the <code>FILE *</code> is NUL, <code>strlen</code> will be 0.  This is one of the reasons why I prefer the POSIX <a href=""http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html"" rel=""nofollow"">getline</a> function.  It returns the number of characters read so embedded nulls are not a problem.</p>
",0
6133580,6133548,5,"<p>This should work fine:</p>

<pre><code>void foo(char (*c)[10]);
</code></pre>
",0
6133594,6133548,1,"<p>You should be able to pass it simply as you're declaring it:</p>

<pre><code>void foo(char (*c)[10]);
</code></pre>

<p>And call it as:</p>

<pre><code>foo(c);
</code></pre>

<p>This is the best post on this subject: <a href=""https://stackoverflow.com/questions/1810083/c-pointers-pointing-to-an-array-of-fixed-size"">C pointers : pointing to an array of fixed size</a></p>
",0
6133637,6133548,1,"<p>Define the function as:</p>

<pre><code>void foo(char (*c)[10])
{
    for (int i = 0; i &lt; sizeof(*c); i++)
        printf(""%d: %c\n"", i, (*c)[i]);
}
</code></pre>

<p>Use the function as:</p>

<pre><code>int main(void)
{
    char a[10] = ""abcdefghi"";
    char (*c)[10] = &amp;a;
    foo(c);
    return(0);
}
</code></pre>
",0
4340331,4340292,0,"<p>See <a href=""https://stackoverflow.com/questions/1070497/c-convert-hex-string-to-signed-integer"">C++ convert hex string to signed integer</a> and if you're in a pure C environment, make sure to scroll down.</p>
",7
4340335,4340292,4,"<p>One way to do it might be:</p>

<pre><code>if (sscanf(input, ""x%x"", &amp;a) == 0) {
    /* matching failed */
}
</code></pre>

<p>If your input uses a real hex specifier (like ""0xFFFF"") you can just use %i:</p>

<pre><code>if (sscanf(input, ""%i"", &amp;a) == 0) {
    /* matching failed */
}
</code></pre>
",0
4340352,4340292,1,"<p>One way:</p>

<pre><code>#include &lt;stdlib.h&gt;

int main()
{
   char *p=""xFFFF"";
   long lng=strtol(&amp;p[1], (char **)0, 16);
   printf(""%ld\n"", lng);
   return 0;
}
</code></pre>
",0
4340357,4340292,2,"<p>You can use strtol function</p>

<pre><code>char *ptr;
long a = strtol( input, &amp;ptr, 16 );
</code></pre>
",3
4339464,4339412,22,"<p><code>__VA_ARGS__</code> is only for macros; variadic functions are rather different. You need to use <a href=""http://www.cplusplus.com/reference/clibrary/cstdarg/va_start/""><code>va_start</code></a>, <code>va_arg</code> and <code>va_end</code> from <code>stdarg.h</code> to handle them.</p>

<p>First, your function needs at least one named parameter, e.g.:</p>

<pre><code>void COMMON_Print(const char* fmt, ...)
</code></pre>

<p>Then you can define a <code>va_list</code> and use <code>va_start</code> to set it:</p>

<pre><code>va_list args;
va_start(args, fmt);
// your code here
va_end(args);
</code></pre>

<p>Now you can use <code>args</code> to access the arguments; calling <code>va_arg(args, TYPE)</code> will return the next variadic argument, so you can just keep calling that until you've read all the arguments.</p>

<p>If you're just trying to call <code>printf</code>, there's a printf variant called <code>vprintf</code> that takes the <code>va_list</code> directly:</p>

<pre><code>vprintf(fmt, args);
</code></pre>

<p>There is no easy way to call one variadic function from another; you need something like <code>vprintf</code> that takes the whole <code>va_list</code></p>
",3
4339477,4339412,4,"<p>What you are looking for is the <a href=""http://en.wikipedia.org/wiki/Ellipsis_%28programming_operator%29#C_and_C.2B.2B"" rel=""nofollow"">Ellipsis</a> operator.</p>
",0
4339479,4339412,7,"<p><code>__VA_ARGS__</code> is for macros only.</p>
<p>Chaining the variable number of argument to another function can't be done directly. Instead you have to
pass a va_list , and the function you're calling have to take a va_list. Luckily there's a variation of printf that does this, your function have to be written this way:</p>
<pre><code>void COMMON_Print(char *format,...)
{    
  va_list args;
  va_start(args,format);
  vprintf(format,args);
  va_end(args);
}
</code></pre>
",3
4339447,4339412,47,"<p>Each of the <code>?printf</code> functions has a corresponding <code>v?printf</code> function which does the same thing but takes a <code>va_list</code>, a variable argument list.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void COMMON_Print(char *format, ...)
{
    va_list args;

    va_start(args, format);
    vprintf(format, args);
    va_end(args);
}
</code></pre>

<p><strong>Side note:</strong> Notice that <code>va_start</code> takes the name of the last argument before the <code>...</code> as a parameter. <code>va_start</code> is a macro which does some stack-based magic to retrieve the variable arguments and it needs the address of the last fixed argument to do this.</p>

<p>As a consequence of this, there has to be at least one fixed argument so you can pass it to <code>va_start</code>. This is why I added the <code>format</code> argument instead of sticking with the simpler <code>COMMON_Print(...)</code> declaration.</p>

<p><strong>See:</strong> <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/vprintf/"" rel=""noreferrer"">http://www.cplusplus.com/reference/clibrary/cstdio/vprintf/</a></p>
",1
3908660,3908639,5,"<p>The code is simply checking for errors.  <code>fseek()</code> returns 0 on success and non-zero on failure.  <code>ftell()</code> returns -1 on failure.</p>

<p>As far as ""why would the location be zero?"" - the <code>fseek()</code> call is requesting to seek from the end of the file (<code>SEEK_END</code>).  Zero bytes from the end of the file is.. the end of the file.  So</p>

<pre><code>fseek( fp, 0L, SEEK_END )
</code></pre>

<p>is a request to move the file pointer to the end of the file.</p>

<p>The code is performing the following steps:</p>

<ol>
<li>open the file</li>
<li>seek to the end</li>
<li>get the position of the file pointer (which, since we're at the end tells you how many bytes are in the file - note, strictly speaking the file needs to be opened with binary access, for example using ""rb"", for this to be true)</li>
</ol>

<p>The code is complicated somewhat by the error handling.  Many books and articles leave out the error handling for exactly that reason. However, that has it's own drawback of teaching people to ignore error conditions.</p>
",0
3908663,3908639,2,"<p>-1 can happen if there's some unknown error, like an I/O error trying to read the file. You'll find that <code>C</code> uses this -1 special value since it doesn't have a true exception mechanism like more modern languages do, so this is just a way to say, ""hey, something bad happened here."".</p>

<p>Refer <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/ftell/"" rel=""nofollow"">here</a> for more info on ftell. </p>

<p>""If an error occurs, -1L is returned, and the global variable errno is set to a positive value. This value can be interpreted by perror.""</p>
",2
3908673,3908639,0,"<p>Google is your friend:</p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fseek/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstdio/fseek/</a></p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/ftell/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstdio/ftell/</a></p>

<p>I/O functions have good error potential, so it's a good practice to check the return values.</p>

<p>Yes, and there's also the POSIX syntax, that requires that <code>fseek()</code> returns the new position instead of error code.</p>
",0
3908677,3908639,1,"<p>Those conditions are there just as a safeguard in case something bad happens. Even if you know that the file exists and all parameters are right, something could go wrong with the disk, for example. It's just good practice to always check for error conditions so that you don't blindly continue only to figure out much later that something has gone wrong.</p>
",0
3908686,3908639,0,"<p><code>fseek</code> returns only a success or failure indication, it does not return the position that the file pointer ended up at.  It returns <code>0</code> on success, which is the standard success return for many library functions.</p>

<p>In the case of <code>ftell</code> it will return the current file position of the file pointer if it doesn't have an error, so a simple return of 0 on success and non-zero on failure doesn't work.  So the <code>ftell</code> function returns <code>-1</code> when a failure happens.  This is the standard error return for functions which return a number that has a meaning.</p>

<p>If you look, the code complains about an error of some kind when an error condition happens according to the information I just gave you.</p>
",0
3910658,3908639,0,"<p>Return values for standard C functions can be strange at times, because many of the functions return an int that has significance, and so it cannot use the same int return value to indicate an error.</p>

<p>In the case of ftell, it returns the current offset of your file pointer. If your file pointer is at the beginning of the file then it is at offset 0. Therefore 0 is a valid offset and cannot be used to indicate an error. So they use -1 instead.</p>

<p>fseek is an instruction. It could return void, but they decide to return something more meaningful. By using 0 for success and non-zero for failure, they can return different non-zero values to indicate different errors.</p>

<p>Incidentally the code is calculating the size of the file by going to the end then asking for the current location. You will sometimes do this if you want to load the file into memory and need to know how many bytes to allocate.</p>
",0
3304962,3304705,0,"<p>I don't agree with the tables idea, because I was trying it and realized that even though ""BA"" in ASCII would contain 5 consecutive 0's for 'B' and 5 consecutive 0's for 'A', they will not add together for 10 consecutive 0's.  As a matter of fact, there would be 5 consecutive 0's maximum.  (This was in reference to a simple ""counting bits in a table idea.""  Chris Dodd has since expounded on how a table could be used accurately.) </p>

<p>I would use an algorithm like this: </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

// Assumes Little Endian architecture
int mostConsecutiveBits(char str[], int length) {
    int currentConsecutiveBits=0; 
    int maxConsecutiveBits=0; 
    char currentBit;
    char lastBit=0; 
    char currentChar=str[0];
    int charCtr,bitCtr; 

    for (charCtr=length-1; charCtr&gt;=0; charCtr--) {

        currentChar=str[charCtr];

        for (bitCtr=0; bitCtr&lt;8; bitCtr++) {
            currentBit=currentChar &amp; 1;

            if (currentBit!=lastBit) {
                maxConsecutiveBits=max(maxConsecutiveBits,currentConsecutiveBits);
                currentConsecutiveBits=1; 
                lastBit=currentBit;
            }
            else {
                currentConsecutiveBits++;
            }

            currentChar=currentChar&gt;&gt;1; 

        }
        maxConsecutiveBits=max(maxConsecutiveBits,currentConsecutiveBits);
    }

    return maxConsecutiveBits; 
}   


int main (int argc, char * const argv[]) {
    cout &lt;&lt; mostConsecutiveBits(""AB"",2);
    return 0;
}
</code></pre>

<p>In this algorithm, I assume the bitstream is represented as 8-bit characters. For each character, I look at the very last bit with a bitwise AND.  If it's the same as the last bit, then I up the consecutive bit count, otherwise, I reset the count because the bits are no longer consecutive.  I then use a bitwise shift operation to move the next bit in the character over for observation.  Hope this helps!</p>

<p>My answer is effectively a duplicate of David Underhill's answer. :) </p>
",6
3304716,3304705,6,"<p>One simple way would be to simply loop over the bits, and keep track of the number of bits in a row which have had the same value, and the maximum that this value has reached.</p>

<p>Here's a simple C function which does just this:</p>

<pre><code>int num_conseq_matching_bits(int n) {
    int i, max, cur, b, prevb;
    prevb = n &amp; 1; /* 0th bit */
    cur = 1;
    max = 1;
    for(i=1; i&lt;32; i++) {
        b = (n &gt;&gt; i) &amp; 1; /* get the i'th bit's value */
        if(b == prevb) {
            cur += 1;
            if(cur &gt; max)
                max = cur;
        }
        else {
            cur = 1; /* count self */
            prevb = b;
        }
    }
    return max;
}
</code></pre>
",8
3304841,3304705,3,"<p>You can form a look up table to do it quickly for you.  The bigger the table, the faster the lookup.  2x256 entry tables can do 8 bits at a time with a little bit twiddling.  Add a 1s version of the table and start adding entries.  That's probably how I'd go about it.</p>
",0
3306378,3304705,2,"<p>To use the table idea, you need something like</p>

<pre><code>static struct {
    int lead;  /* leading 0 bits */
    int max;   /* maximum 0 bits */
    int trail; /* trailing 0 bits */
} table[256] = { ....data.... };

int mostConsecutiveBits(unsigned char *str, int length, bool count_ones) {
    int max = 0; /* max seen so far */
    int trail = 0; /* trailing 0s from previous bytes */
    while (length-- &gt; 0) {
        int byte = *str++;
        if (count_ones)
            byte ^= 0xff;
        if (table[byte].max &gt; max)
            max = table[byte].max;
        if (trail + table[byte].lead &gt; max)
            max = trail + table[byte].lead;
        if (byte)
            trail = table[byte].trail;
        else
            trail += 8;
    }
    return max;
}
</code></pre>

<p>initializing the table is straight-forward, but depends on your bit- and byte-ordering (little endian or big endian).</p>
",0
3306442,3304705,0,"<p>Since you didn't wrote what is bit string (regular int, byte array or char string I've assumed that it's char array</p>

<pre><code>int maxConsBits(char *pStr,char cChar)
{
    char curChar;
    int curMax = 0;
    int max = 0;
    while (pStr)
    {
       if (*pStr == cChar)
       {
          curMax++;
          if (curMax &gt; max)
          {
             max = curMax;
          }
       }
       else
       {        
           curMax = 0;
       }
       pStr++;
   }
   return max;
}
</code></pre>
",0
3311489,3304705,0,"<p>Posting from iPhone withbig fingers.</p>

<p>If ones, then invert.</p>

<p>Loop over the input using a leadz function.  For each iteration, shift the input to the left.  Continue until you reach the end of the input.  Note that you need to compare the original input length with the cumulative leadz counts.  </p>

<p>Also, as an optimization, you can early abort when the remaining input length is less than the largest leadz you have seen.</p>

<p>There are many fast leadz algorithms online.</p>
",0
3248699,3248118,12,"<p>C chooses to not initialize variables to some automatic value for efficiency reasons. In order to initialize this data, instructions must be added.  Here's an example: </p>

<pre><code>int main(int argc, const char *argv[])
{
    int x;
    return x;
}
</code></pre>

<p>generates:</p>

<pre><code>pushl %ebp
movl  %esp, %ebp
subl  $16, %esp
movl  -4(%ebp), %eax
leave
ret
</code></pre>

<p>While this code:</p>

<pre><code>int main(int argc, const char *argv[])
{
   int x=1;
   return x;
}
</code></pre>

<p>generates:</p>

<pre><code>pushl %ebp
movl  %esp, %ebp
subl  $16, %esp
movl  $1, -4(%ebp)
movl  -4(%ebp), %eax
leave
ret
</code></pre>

<p>As you can see, a full extra instruction is used to move 1 into x.  This used to matter, and still does on embedded systems.</p>
",8
3248707,3248118,5,"<p>IIRC, Thompson or Richie did an interview some years ago where they said the language definition purposely left things vague in some places so the implementers on specific platforms had leeway to do things that made sense (cycles, memory, etc) <em>on that platform</em>.  Sorry I don't have a reference to link to.</p>
",1
3249008,3248118,7,"<p>Garbage values are not really stored anywhere. In fact, garbage values do not really exist, as far as the abstract language is concerned.</p>

<p>You see, in order to generate the most efficient code it is not sufficient for the compiler to operate in terms of <em>lifetimes of objects</em> (variables). In order to generate the most efficient code, the compiler must operate at much finer level: it must ""think"" in terms of <em>lifetimes of values</em>. This is absolutely necessary in order to perform efficient scheduling of the CPU registers, for one example.</p>

<p>The abstract language has no such concept as ""lifetime of value"". However, the language authors recognize the importance of that concept to the optimizing compilers. In order to give the compilers enough freedom to perform efficient optimizations, the language is intentionally specified so that it doesn't interfere with important optimizations. This is where the ""garbage values"" come into picture. The language does not state that garbage values are stored anywhere, the language does not guarantee that the garbage values are stable (i.e. repeated attempts to read the same uninitialized variable might easily result in different ""garbage values""). This is done specifically to allow optimizing compilers to implement the vital concept of ""lifetime of value"" and thus perform more efficient variable manipulation than would be dictated by the language concept of ""object lifetime"".</p>
",0
3248933,3248118,3,"<p>C was designed to be a relatively low-level language so that it could be used for writing, well, low-level stuff like operating systems. (in fact, it was designed so that UNIX could be written in C) You can simply think of it as assembly code with readable syntax and higher-level constructs. For this reason, C (minus optimizations) does exactly what you ask it to do, nothing more, nothing less.</p>

<p>When you write <code>int x;</code>, the compiler simply allocates memory for the integer. You never asked it to store anything there, so whatever was in that location when your program started stays as such. Most often, it turns out that the pre-existing value is ""garbage"".</p>

<p>Sometimes, an external program (for eg. a device driver) may write into some of your variables, so it is unnecessary to add another instruction to initialize such variables.</p>
",1
2652185,2652147,2,"<p>There is no difference. You can always serialize/deserialize signed integers as if they are unsigned, the difference is only in the interpretation of the bits, not in the bits themselves.</p>

<p>Of course, this only holds true if you know that the unsigned and signed integers are of the same size, so that no bits get lost.</p>

<p>Also, you need to be careful (as you are) that no intermediary stage does any unplanned sign-extension or the like, the use of <code>unsigned char</code> for individual bytes is a good idea.</p>
",1
2652972,2652147,0,"<p>Do you want something like this? It would be helpul (as Vicki asked) if you could provide what you have and what you want to get.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main (void)
{
    union{
        long int intu32;
        char octets[4];
    } u;
    u.intu32 = 255;

    printf(""(%d)(%d)(%d)(%d)\n"", (int) u.octets[3], (int) u.octets[2], (int) u.octets[1], (int) u.octets[0]);

    printf(""intu32:%lu\n"", u.intu32);

    return 0;
}
</code></pre>
",3
2652343,2652147,0,"<p>You are probably confused that it is common practise (and applied in ix86 processors) to encode negative values using twos complement encoding. This means that the hex notation of 4 byte -1 is <code>0xffffffff</code>. The reason this encoding is used is that by taking into account automatic overflow adding 2 <code>0x00000002</code> to -1 will yield the correct result (<code>0x00000001</code>).</p>
",1
3690490,3689435,1,"<p>The simple answer is:</p>

<pre><code>static char * Foo;
#include ""log.c""
#include ""library.c""
</code></pre>

<p>Which makes <code>Foo</code> visible in log.c and library.c simply by virtue of the ""declare before use"" rule. </p>

<p>However what you really need to know is that this is <em>nasty</em> code!  You have committed at least two <em>sins</em>; <a href=""http://www.eetimes.com/discussion/break-point/4025723/A-pox-on-globals"" rel=""nofollow noreferrer"">Use of global variables</a> and failure to understand the use <a href=""http://www.cprogramming.com/compilingandlinking.html"" rel=""nofollow noreferrer"">separate compilation and linking</a>.</p>
",1
3689442,3689435,3,"<p>Add its declaration to some .h file that is included in both .c files. Define it in one of the files.</p>

<p>Of course, it can't be declared <code>static</code> for this to work since the <code>static</code> keyword is a promise that the name won't be needed outside of that particular module.</p>

<p>For example, in <code>prog.h</code>:</p>

<pre><code>extern char *Foo;
</code></pre>

<p>in <code>prog.c</code>:</p>

<pre><code>#include ""prog.h""
#include ""log.c""
#include ""library.c""

char * Foo;         // make sure that Foo has a definition

// some code probably wants to make Foo have a value other than NULL
</code></pre>

<p>in <code>log.c</code>:</p>

<pre><code>//... other includes
#include ""prog.h""    // and now Foo is a known name

// some code here is using the global variable Foo
</code></pre>

<p>Now, for the bad news.</p>

<p>Doing this sort of thing creates a coupling between the <code>prog.c</code> and <code>log.c</code> modules. That coupling adds to the maintenance cost of your application as a whole. One reason is that there is no way to prevent other modules from using the global variable also. Worse, they might be using it completely by accident, because its name is insufficiently descriptive.</p>

<p>Worse, globals make it much more difficult to move from single-threaded programs to multi-threaded programs. Every global variable that might be accessed from more than one thread is a potential source of really hard to diagnose bugs. The cure is to guard information that must be global with synchronization objects, but overused that can result in an application where all the threads are blocked except the one that is currently using the global, making the multi-threaded application effectively single threaded.</p>

<p>There certainly are times when the inter-module coupling implied by global variables is acceptable. One use case is for general purpose application-wide options. For instance, if your application supports a <code>--verbose</code> option that makes it chatter while it works, then it makes sense for the flag that is set by the option and tested throughout the code would be a global variable.</p>

<p>There are certainly questions at SO that delve deeply into the pitfalls of globals and will provide guidance on their sensible use.</p>
",0
3689458,3689435,1,"<p>You want extern. When you extern a variable name you're making a ""promise"" that the variable will exist when you link. You want to give it storage in a .c file but extern it in a header. That way it's just instantiated once, in the .c's object file. You don't want to have two different .o's using the same name to refer to different locations in memory. (As noted above it's nearly always bad form to require something like this for a library.)</p>

<p>So in a common header you'd have</p>

<p>common.h</p>

<pre><code>extern Foo bar;
</code></pre>

<p>Then in prog.c</p>

<p>Foo bar;</p>

<p>And when you included common.h in log.c you could access bar from prog.c</p>

<p>Note that static is very different in C than in Java. In Java it's global to an Class and available for anyone, even without an instance of the class. In C static means that variable is not visible outside of the compilation unit. </p>
",0
3689462,3689435,2,"<p>It is aconventional to include the library source code in your main program:</p>

<pre><code>#include ""log.c""
#include ""library.c""
static char * Foo;
</code></pre>

<p>(The semi-colon is needed.)</p>

<p>However, given that is what you are doing, if ""log.c"" needs to see the declaration, you could simply do:</p>

<pre><code>static char * Foo;
#include ""log.c""
#include ""library.c""
</code></pre>

<p>Now the static declaration is visible to ""log.c"" (and ""library.c"").</p>

<p>If you go for a more conventional setup, then you would have the code in ""log.c"" access a global variable declared in an appropriate header (rather than a file static variables).  However, such dependencies (where a library file depends on a global variable) are a nuisance.  The main program (or some piece of code) has to provide the variable definition.  It would be better to have the code in ""log.c"" define the variable, and the (presumed) header ""log.h"" would declare the variable, and then the main program would set the variable accordingly.  Or, better, the code in ""log.c"" would provide a function or several functions to manipulate the variable, and the header would declare those functions, and the main program would use them.</p>
",0
3249632,3249611,1,"<p>Think this through.  You have one sum you're accumulating, and you have a series of values.  Each value can be generated from the previous one by adding the index.  So why do you have nested loops?</p>
",0
3249641,3249611,9,"<p>No need for recursion, just look at the math:</p>

<pre><code>1 + (1+2) + (1+2+3) + ... + (1+2+3+...+n)
</code></pre>

<p>is equal to</p>

<pre><code>1*n + 2*(n-1) + 3*(n-2) + ... + n
</code></pre>
",4
3249645,3249611,10,"<ol>
<li>You are not initialising <code>sum</code>. Initialise it with <code>0</code>.</li>
<li>You shouldn't be adding <code>n</code> at each step, but <code>j</code>.</li>
</ol>

<p>Of course, this is to fix your current code. There are better approaches to solving the problem, which others have already mentioned.</p>

<p><strong>Edit</strong>:</p>

<p>Just for fun, here's a formula that allows you to solve the problem in <code>O(1)</code>:</p>

<p>Your sum is equal to <code>n*(n + 1)*(2*n + 1) / 12 + n*(n + 1) / 4</code>.</p>

<p>This is obtained by writing it as a sum and using the fact that the sum of the first <code>n</code> consecutive squares is <code>n(n + 1)(2n + 1) / 6</code> and the sum of the first <code>n</code> positive ints is <code>n(n + 1)/2</code>. +1 if you can find a nicer form of the formula.</p>
",5
3249654,3249611,0,"<p>You never initialize <code>sum</code>, so you're adding everything to a random garbage value.  Stick <code>sum = 0;</code> before your loops</p>
",0
3249706,3249611,1,"<p>Doing it iteratively, like you tried:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int i, t, n, sum;
    printf(""Please enter an integer, n = "");
    scanf(""%d"", &amp;n);
    t = sum = 0;
    for (i = 1; i &lt;= n; ++i) {
        t += i;
        sum += t;
    }
    printf(""sum = %d\n"", sum);
    return 0;
}
</code></pre>

<p>But there's a closed-form formula as IVlad suggested.</p>
",0
3249711,3249611,0,"<p>Start with the math, see if you can find some pattern.</p>

<pre><code>if n = 0 , res = 0?
if n = 1 , res = 1
if n = 2 , res = 1 + (1+2) 
if n = 3 , res = 1 + (1+2) + (1+2+3)
</code></pre>

<p>for each n, res is ??</p>
",3
3249788,3249611,0,"<p>Try this:</p>

<pre><code>int main(void)
 {
   int total=1;
   int sumtotal = 0;
   int n=5;

   for(int i=1; i&lt;=n; i++)
     {
       total+=i;
       sumtotal+=total;
     }
   //sumtotal should give you 1+(1+2)+(1+2+3)
   return 0;
 }
</code></pre>
",0
3249834,3249611,5,"<p>Not what you expected, but this <strong>is</strong> the best solution ;)</p>

<pre><code>int calculate (int n) {
  return (2*n + 3*n*n + n*n*n) / 6;
}
</code></pre>
",1
3695840,3695820,1,"<p><code>NULL</code> is should be synonymous with <code>0</code>. It's more correctly used to indicate a null pointer.</p>

<p>In this case the code will actually be:</p>

<pre><code>for (i = 0; i &lt;= 5)
{
    count++;
    i += 2;
}
</code></pre>
",2
3695841,3695820,21,"<p>For C, ""NULL"" is traditionally defined to be (void *)0 - in other words, it's a pointer alias to address 0.  For C++, ""NULL"" is typically defined to be ""0"".  The problem with NULL in C++ and C is that it's not type safe - you can build bizarre constructs like the one you included in your code sample.</p>

<p>For C++, the language designers fixed this in C++0x by adding a new ""nullptr"" type which is implicitly convertable to any pointer type but which cannot be converted to an integer type.</p>
",2
3695842,3695820,2,"<p><code>NULL</code>?has most of its meaning when dealing with pointers. When dealing with integers, you would be better off using simply zero.</p>

<p>Strictly speaking, <code>NULL</code> is simply the value zero with a fancy name, but the most important part about it is indeed its fancy name. It exists because it's less ambiguous to write <code>int* p = NULL;</code> than <code>int* p = 0;</code>. Since we know <code>NULL</code> is a pointer, we're sure that I really meant <code>p</code> to be a pointer.</p>

<p>So, when you deal with pointers and want to represent the <em>address</em> <code>0</code>, use <code>NULL</code>. And when you deal with numbers and want to represent the <em>number</em> <code>0</code>, use <code>0</code>. (In your example, you should use <code>0</code> instead of <code>NULL</code>.)</p>
",0
3695847,3695820,0,"<p>NULL is defined as 0 by C. In your program, it counts from 0 to 5 (counting every 2nd number). That's why count is 3 (i = 0, 2, 4).</p>

<p>NULL shouldn't be used this way. NULL should be used with pointers.</p>
",0
3695868,3695820,3,"<p><code>NULL</code> is just a macro defined in <code>stdio.h</code> or a file that stdio includes. It can variously be defined as some variation of zero.</p>

<p>If you run your code through the C pre-processor (usually <code>cc -E</code>) you can see what it translates to on your implemnentation:</p>

<pre><code>void main(){
    int i;
    static int count;
    for(i=((void *)0); i&lt;=5 ;){
       count++;
       i+=2;
    }
    printf(""%d"",count);
}
</code></pre>

<p>which is not only an unnecessary use of <code>NULL</code> but is wildly un-idiomatic C code, more ordinary would be:</p>

<pre><code>int main(){
    int i;
    int count = 0;
    for(i = 0; i &lt;= 5; i += 2){
       count++;
    }
    printf(""%d\n"",count);
    return 0;
}
</code></pre>
",2
3695876,3695820,0,"<p>The type of <code>NULL</code> and the type of <code>i</code> are different, but <code>C</code> forgives you :)</p>

<p><code>C</code> is (mostly) not a ""type-safe"" language. I mean: it lets you mix types which other languages would complain.</p>

<p>With <code>C</code> you can add <code>chars</code> to <code>doubles</code>, you can multiply <code>chars</code> and <code>ints</code>, ...</p>

<p>What you are doing is assigning a <code>null pointer constant</code> (of type <code>void *</code>) to an <code>int</code>. <code>C</code> allows that, but <strong>you need to be very careful when mixing types</strong> like this.</p>

<p>The result of assigning the null pointer constant to an int is the same as assigning <code>0</code> to it. So you start your loop with <code>i</code> being <code>0</code>.</p>

<p>A static auto variable, in the absence of an initializer, is initialized to <code>0</code>. This happens to the variable <code>count</code> in your program.</p>

<p>So, the loop goes first (<code>count</code> becomes 1) with <code>i</code> being 0, then <code>i</code> becomes 2.<br>
Now the loop goes (<code>count</code> becomes 2) with <code>i</code> being 2, then <code>i</code> becomes 4.<br>
Now the loop goes (<code>count</code> becomes 3) with <code>i</code> being 4, then <code>i</code> becomes 6.<br>
And the loop terminates ... and you print the value of <code>count</code>.</p>

<hr>

<p><strong>Notes</strong></p>

<ul>
<li>to be Standard compliant <code>main</code> should be declared <code>int main(void)</code></li>
<li>you should output a newline after every complete line ( <code>printf(""%d\n"", count);</code> )</li>
<li>and you should <code>return 0;</code> to indicate successful completion of your program to the Operating System</li>
</ul>
",0
3696036,3695820,0,"<p>Don't confuse the idea of a NULL pointer in c with that of a nullable type or quantities in some dynamic languages. There are similar, but have distinct uses and meaning.</p>

<p>In c the concept of NULL is only used natively in the context of pointer where it is a pointer to a <em>known invalid</em> memory location (often, but not always, represented by zero).</p>

<p>This is not (quite) the same as a type or variable which can represent non-setness. Note that types like this can be defined-and-managed by the user in c, but they are not supplied by the language.</p>
",0
5574860,5574841,5,"<p>In C++ you have to say</p>

<pre><code>int *a = (int*)malloc(sizeof(*a));
</code></pre>

<p>because casting a <code>void*</code> into an <code>int*</code> isn't implicitly done by the compiler.</p>

<p>Better yet, just use <code>new</code> and <code>delete</code>:</p>

<pre><code>int *a = new int();
</code></pre>
",6
2841331,2841324,1,"<p>Try scanning for a string into a buffer and then searching that string for your number with sscanf().</p>
",4
2841368,2841324,3,"<p>If <code>scanf()</code> can't read the input, it actually doesn't read it, so it reads the same input over and over again in your example. You can discard the invalid input like this:</p>

<pre><code>while(scanf(""%d"",&amp;numOfPlayers)!=1){
  scanf(""%s"");
  printf(""Please enter the right number of players\n"");
}
</code></pre>
",3
2841438,2841324,1,"<p>From the comp.lang.c FAQ: <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">Why does everyone say not to use <code>scanf</code>? What should I use instead? </a></p>
",0
2604562,2604453,0,"<p><em>Always</em> check return values of functions. Maybe <code>stat()</code> failed and you get <code>st_gid</code> 0 just because there was 0 before.</p>

<p>For me the program works good.</p>
",0
6139020,6138968,2,"<p>It is indeed a fact. In fact, the compiler turns off const optimizations (few as there are) the moment it sees you casting away <code>const</code>, treating it like any other variable.</p>
",0
6139036,6138968,0,"<p>You are programming in C and its always like that. While playing with pointers you need to be careful always.</p>
",1
6139040,6138968,13,"<p>It's C. You can do a lot of things that are stupid, causes undefined behavior, is compiler/platform dependent etc.</p>

<p>casting away the const modifier is one of them. You are able to do so, but you get little guarantees as to what the result will be.</p>

<p>You could even cast it to just about anything, at your own risk.</p>

<pre><code> *(float *)ptr_to_const_char = 2.18;
</code></pre>

<p>However, const is not useless.</p>

<ul>
<li>It provides documentation, a programmer reading code where a pointer is declared const 
can assume he can/should not modify what the pointer points to</li>
<li>It can enable the compiler to do further optimizations</li>
</ul>

<p>Just keep in mind that C does not protect you against yourself or others, it also gives you the ability to not honor the type system.</p>
",0
6139048,6138968,0,"<p>I believe you want </p>

<pre><code> char * const ptr_to_const_char
</code></pre>

<p>which is a constant pointer, not a pointer to a constant.</p>

<p>But that may only work in C++.</p>
",3
6139161,6138968,0,"<p>Modifying the content of a variable defined as const using such means is clearly UB. Avoid that.</p>
",0
6139277,6138968,2,"<p><code>const</code> does not protect a variable. In fact, <code>const</code> does not even mean the variable will never change.</p>

<p>What it means is that <strong>you</strong>, the programmer, declare that <strong>you</strong> won't be writing to that part of memory. A memory-mapped input-only pin on a microchip might be represented by a variable qualified <code>const</code>, but it can still change if the voltage on the pin changes. (In fact, it will most likely be declared <code>const volatile</code>, which blew my mind the first time I saw it.) But the <code>const</code> means that you aren't allowed to write to it.</p>

<p>So if you break that promise ¡ª that you have no intention of writing to it ¡ª well then yes, of course that'll mess things up.</p>
",0
2919110,2918613,0,"<p>Both type casts will have higher priority than the addition, so you will add to a Elf_Section_Header* using pointer arithmetics.
Presumably you want:</p>

<p><code>Elf_Section_Header *sectionHeader = (Elf_Section_Header *)((char *)fileHeader + fileHeader-&gt;offset);</code></p>
",0
3431431,3431408,3,"<p>The numbers in brackets are the indices of the initializers.  This is a C99 feature.</p>

<p>Given that your example code does use this blemish, the reason you receive the output you do is that ""foo"" is stored in <code>names[3]</code>, while <code>NULL</code> is stored in <code>names[2]</code>.  Your program crashes when it attempts to <code>puts(names[2])</code> which is the same as <code>puts(NULL)</code>.</p>

<p>Your loop would otherwise iterate to 16 or 32 iterations -- you are dividing by <code>sizeof(char)</code> for the array element size, and you mean to use <code>sizeof(char *)</code>.</p>

<p>Better to use this macro:</p>

<pre><code>#define DIMENSION_OF (a) (sizeof(a)/sizeof(a[0]))
</code></pre>

<p>I suggest never using any C99-specific features, such as these ""designated initializers.""</p>

<p>There is a reason that most of the answers you received on this question were confused as to why your loop only output two strings rather than four.  That reason is that C99 is not widely recognized by other programmers.</p>

<p>There are several reasons that most programmers aren't familiar with C99's more distinctive features.  A frequently cited reason is that C99 is more incompatible with C++ than ANSI C, and makes the possibility of future conversion to C++ more difficult.  My personal complaint with C99 also makes extensions to ANSI C which are superfluous.  An example of a superfluous addition is the example from C99 that you have provided.  Don't use ""designated inits.""  Do refer to the American National Standards Institute C Standard.  Do not refer to the International Standards Organization C99 document.</p>

<p>Most of the features which are ""nice to have"" form C99 were already available as extensions in all major compilers.  Declaring a variable in the for-init-statement is an example of a non-ANSI-C-standard feature which is widely supported.  The <code>complex</code> built-in type is an example of a non-ANSI-C-standard feature that is not widely supported.</p>
",34
3431436,3431408,4,"<p>The following definition shows how you can use designated initializers to skip over elements of the array that you don't want to initialize explicitly:</p>

<pre><code>static int number[3] = { [0] = 5, [2] = 7 };
</code></pre>

<p>The array number contains the following values: number[0] is 5; number[1] is implicitly initialized to 0; number[2] is 7.</p>

<p>Heath below, describes the effect of your for loop, so I will not repeat.</p>
",0
3431455,3431408,2,"<p>It declares names to be an array (whose size is determined by the compiler) of pointers to char, with initialization that also determines the size of the array; the initialization ""decides"" explicitly the index of specific pointer; e.g. man is at index 0, foo at index 3... The final size is given by the bigger index, and all values with indexes not explicitly given are set to null.</p>

<p>It should be <code>sizeof(char *)</code> as already said. The loop prints the content; if the number of elements in the array is 3, the index must go from 0 to 2, (2&lt;3 but 3&lt;3 is false) since index-base in C is 0.</p>
",0
5126470,5126353,6,"<p>Since malloc just gives back a block of memory you could add extra information in the block telling how many elements are in the array, that is one way around if you cannot add an argument that tells the size of the array</p>

<p>e.g.</p>

<pre><code>char* ptr = malloc( sizeof(double) * 10 + sizeof(char) );
*ptr++ = 10;
return (double*)ptr;
</code></pre>

<p>assuming you can read before the array in PHP, a language which I am not familiar with.</p>
",1
5126363,5126353,27,"<p>You can't. You have to pass the length as a parameter to your function. The size of a pointer is the size of a variable containing an address, this is the reason of 4 ( 32 bit address space ) you found. </p>
",0
5126419,5126353,2,"<p>Here you see the dangers of C: a ptr just points to memory and has no way of knowing what supposed size is. You can just increment and increment and the OS might complain eventually, or you crash your program, or corrupt other ones. You should always specify the size, and check bounds yourself!</p>
",0
5126939,5126353,2,"<p>This is similar to <a href=""https://stackoverflow.com/q/5056372/524368"">Using pointer for crossing over all elements in INTEGER array</a></p>

<p><a href=""https://stackoverflow.com/questions/5056372/using-pointer-for-crossing-over-all-elements-in-integer-array/5056869#5056869"">See my answer here</a></p>
",1
5114457,5114396,9,"<p>What happens with <code>-std=gnu99</code>?  It looks like the <code>d_type</code> field is non-standard (see <a href=""http://www.gnu.org/s/libc/manual/html_node/Directory-Entries.html"" rel=""noreferrer"">the GNU libc manual page ""Directory Entries""</a>) and so the enum that represents the directory entry types is disabled in strictly compliant mode.  It looks like you need to define <code>_BSD_SOURCE</code> (or <code>_GNU_SOURCE</code>) to get the type values.</p>
",1
4667460,4621151,6,"<p>Well, the real winner is the one who wrote this small code you provided, but you can slightly modify it to remove the exit:</p>

<pre><code>main(c){read(0,&amp;c,1)?c-41&amp;&amp;main(c-40&amp;&amp;(c%96&lt;27||main(c),putchar(c))):0;}
</code></pre>

<p>I tried and it works.</p>
",7
4677175,4621151,15,"<p>Here's a way to reduce the code down to <strong>76</strong> chars:</p>

<pre><code>main(c){read(0,&amp;c,1)?c-41&amp;&amp;main(c-40&amp;&amp;putchar(c,c%96&gt;26&amp;&amp;main(c))):exit(0);}
</code></pre>

<p>A longer, commented version for clarity:</p>

<pre><code>int main(int c)
{
   if (read(0,&amp;c,1)) {          /* read char */
       if (c-41) {              /* if not ')' */
           if (c-40) {          /* then if not '(' */
               if (c%96&gt;26) {   /* then if operator (not alphabet or &lt;LF&gt;) */
                   main(c);     /* recurse */
               }
               putchar(c);      /* print */
           }
           main(c);             /* recurse */
       }        
   } else exit(0);              /* end program */
}
</code></pre>
",1
4622298,4621151,6,"<p>I'm not out to break any records but I'll post this anyway:</p>

<pre><code>#define x(z) while(p&gt;##z s)putchar(*p--);
main(c){
int s[9],*p=s-1;
for(;read(0,&amp;c,1);){
isalpha(c)?putchar(c):c=='('?(c=0):c==')'?(c=1):isdigit(c)?:(*++p=c);
if(c==0){x()main(0);}
if(c==1) break;}
x(=)return 0;}
</code></pre>

<p><strong>Edit:</strong> Fixed correctness issues pointed out by kuszi's comment.</p>
",2
2938904,2938895,2,"<p>First declaration declares an array, while second - a pointer. </p>

<p>If you're interested in difference in some particular aspect, please clarify your question.</p>
",0
2938916,2938895,10,"<p><code>char a[]=""string"";</code> //<code>a</code> is an array of characters.</p>

<p><code>char *p=""string"";</code>// <code>p</code> is a string literal having static allocation. Any attempt to modify contents of <code>p</code> leads to Undefined Behavior since string literals are stored in read-only section of memory.</p>
",0
2938921,2938895,2,"<p>No difference. Unless you want to actually write to the array, in which case the whole world will explode if you try to use the second form. See <a href=""http://c-faq.com/decl/strlitinit.html"" rel=""nofollow noreferrer"">here</a>.</p>
",0
2938924,2938895,29,"<p>The first one is array the other is pointer.</p>

<p>The array declaration ""<code>char a[6];</code>"" requests that space for six characters be set aside, to be known by the name ""<code>a.</code>""  That is, there is a location named ""<code>a</code>"" at which six characters can sit. The pointer declaration ""<code>char *p;</code>"" on the other hand, requests a place which holds a pointer.  The pointer is to be known by the name ""<code>p,</code>"" and can point to any char (or contiguous array of chars) anywhere.</p>

<p>The statements</p>

<pre><code>char a[] = ""hello"";
char *p = ""world"";
</code></pre>

<p>would result in data structures which could be represented like this:</p>

<pre><code>   +---+---+---+---+---+---+
a: | h | e | l | l | o |\0 |
   +---+---+---+---+---+---+
   +-----+     +---+---+---+---+---+---+
p: |  *======&gt; | w | o | r | l | d |\0 |
   +-----+     +---+---+---+---+---+---+
</code></pre>

<p>It is important to realize that a reference like x[3] generates different code depending on whether x is an array or a pointer. Given the declarations above, when the compiler sees the expression a[3], it emits code to start at the location ""a,"" move three past it, and fetch the character there.  When it sees the expression p[3], it emits code to start at the location ""p,"" fetch the pointer value there, add three to the pointer, and finally fetch the character pointed to.  In the example above, both a[3] and p[3] happen to be the character 'l', but the compiler gets there differently.  </p>

<p>You can use search there are tons of explanations on the subject in th internet.</p>
",2
2938980,2938895,1,"<p>One difference is that sizeof(a)-1 will be replaced with the length of the string at compile time.  With p you need to use strlen(p) to get the length at runtime.  Also some compilers don't like char *p=""string"", they want const char *p=""string"" in which case the memory for ""string"" is read-only but the memory for a is not.  Even if the compiler does not require the const declaration it's bad practice to modify the string pointed to by p (ie *p='a').  The pointer p can be changed to point to something else.  With the array a, a new value has to be copied into the array (if it fits).</p>
",0
3292250,3292209,1,"<p>You're saying two different things in your question.  First, you say you want to pass the address of the array, but in the code you appear to be trying to pass the address of a particular element.  One of the features of C is that an array will automatically turn into pointer to the array's first element when you use it in certain contexts.  That means these two calls are 100% equivalent:</p>

<pre><code>function(array);
function(&amp;array);
</code></pre>

<p>To get the address of a particular array element, you can do two things.  One is as you've shown above:</p>

<pre><code>function(&amp;array[10]);
</code></pre>

<p>And the second is just do the pointer arithmetic directly:</p>

<pre><code>function(array + 10);
</code></pre>

<p>In the first case the <code>&amp;</code> is required, since as you mentioned in your question the <code>[]</code> causes the pointer to be dereferenced - the <code>&amp;</code> undoes that operation.  What you appear to be confused about are the real semantics of the <code>[]</code> operation.  It both does pointer arithmetic and then dereferences the result - you're not getting an address out of that.  That's where the <code>&amp;</code> comes in (or just using <code>array + 10</code> directly).</p>
",3
3292266,3292209,8,"<p><code>*(record + i)</code> is not in fact an address.  <code>record</code> is an address, and so is <code>(record + i)</code>, but <code>*(record + i)</code> is the <em>value stored at the address represented by</em> <code>(record + i)</code>.  Therefore, calling <code>function(record[i])</code> is the same as <code>function(*(record + i))</code>, which will pass the <em>value</em> of the array element to the function, not a pointer.</p>

<p>The syntax <code>&amp;record[i]</code> is not taking the address of an address.  It is taking the address of <code>record[i]</code>, which is an object.  The braces have a higher precedence than the ampersand, so <code>&amp;record[i]</code> is equivalent to <code>&amp;(record[i])</code>.  You can think of it as expanding to <code>&amp;(*(record + i))</code> and then simplifying to <code>(record + i)</code>.</p>

<p><strong>Update:</strong>
To address your question from the comment, an array ""decays"" into a pointer if you reference the name of the array by itself.  If you add square brackets <code>[]</code>, you will get a <em>value</em> from within the array.  So, for your example, say you have an array of structures:</p>

<pre><code>struct A {
    ...
    char abc[10];
    ...
} record[10];
</code></pre>

<p>Then, you would have:</p>

<ul>
<li><code>record[i]</code> - an object of type <code>struct A</code> from the <code>record</code> array</li>
<li><code>record[i].abc</code> - the <code>abc</code> array inside a particular <code>record</code> object, decayed to a pointer</li>
<li><code>record[i].abc[k]</code> - a specific character from the string</li>
<li><code>&amp;record[i].abc[0]</code> - one way of creating a pointer to the string</li>
</ul>

<p>The notation <code>record[i]-&gt;abc</code> that you mention in your comment cannot be used, since <code>record[i]</code> is an object and not a pointer.</p>

<p><strong>Update 2:</strong>
In regards to your second comment, the same rules described above apply regardless of how you nest the array within a structure (and whether you access that structure directly or through a pointer).  Accessing an array using <code>arrayname[index]</code> notation will give you an item from the array.  Accessing an array using <code>arrayname</code> notation (that is, using the array name by itself) will give you a pointer to the first element in the array.  If you need more details regarding this phenomenon, here are a couple of links that explain arrays and the way that their names can decay into pointers:</p>

<ul>
<li><a href=""http://boredzo.org/pointers/"" rel=""nofollow noreferrer"">http://boredzo.org/pointers/</a></li>
<li><a href=""http://www.ibiblio.org/pub/languages/fortran/append-c.html"" rel=""nofollow noreferrer"">http://www.ibiblio.org/pub/languages/fortran/append-c.html</a></li>
<li><a href=""http://c-faq.com/aryptr/index.html"" rel=""nofollow noreferrer"">http://c-faq.com/aryptr/index.html</a></li>
</ul>
",3
3292272,3292209,0,"<p>You are passing by value which means a copy of the variable is sent to the function. In the 2nd case you are passing by reference. </p>

<p>In the second case you are directly modifying the contents at the address of the array plus index.</p>

<p>Check this simple <a href=""http://www.math.cam.ac.uk/undergrad/catam/ccatsl/manual/node50.html"" rel=""nofollow noreferrer"">example</a> to know the exact difference.</p>
",0
3292297,3292209,0,"<p>Your function's signature is probably</p>

<pre><code>void function(table *); // argument's type is pointer to a table 
</code></pre>

<p>When you pass <code>record[i]</code>, you pass a table object.
In order to pass a pointer to a table, you have to pass <code>&amp;record[i]</code>, like you did.</p>
",1
3292426,3292209,0,"<p>Your function is expecting a pointer to the structure. This arguement can be an individual instance of that structure or it could be an element in the array of the give structure. Like</p>

<pre><code>struct myStruct {
     int a, b;
     long cL, dL;
     char e;
} struc1, struc2, record[20];
</code></pre>

<p>and function's prototype will be</p>

<pre><code>function( struct myStruct *ptr);
</code></pre>

<p>Now you can pass the structure to function:</p>

<pre><code>function( &amp;struct1 );
// or
function( &amp;record[ index] );
</code></pre>

<p>Now your confusion arises because of the misconception that syntax <code>array[i]</code> can also be treated as a pointer like we can do with the name of the <code>array</code>. </p>

<p><code>record</code> - name of the array- gives the address of the first member of the array, (pointers also point to memory addresses) hence it can be be passed to the function. But <code>record[index]</code>, it is different. <br/></p>

<p>Actually, when we write <code>record[ index]</code> it gives us the value placed there which is not a pointer. Hence your function which is accepting a pointer, does not accept it.</p>

<p>To make it acceptable to the function, you will have to pass the address of the elements of the array i.e</p>

<pre><code>function( &amp;record[ index ] );
</code></pre>

<p>Here <code>&amp;</code> operator gives the address of the elements of the array.</p>

<p>Alternatively, you can also use:</p>

<pre><code>function( record + index  );
</code></pre>

<p>Here, as we know <code>record</code> is the address of the first element, and when we add <code>index</code> in it, it gives the address of the respective element using pointer arithmetic.</p>

<p>Hope it was helpful.</p>
",3
8217303,8217275,7,"<p>The rules are that the condition is evaluated before choosing which alternative to evaluate. Since part of the evaluation is the <code>++</code>, the increment will occur before the assignment (if the assignment occurs at all).</p>

<p>As @caf comments, there is a sequence point after the controlling expression. So, while (as David Thornley points out) the order of expression evaluations can be rearranged by the compiler (particularly side effect evaluations), the rearranging cannot cross sequence points.</p>
",5
8218428,8217275,1,"<p>Well, I've tested this practically (good thing printf returns int) with:</p>

<pre><code>int ucNum = 4;
ucNum++ &gt;= 3 ? printf(""%d"", ucNum) : 1;
</code></pre>

<p>Since the condition is true, it goes to the printf which prints 5. So definitely ucNum is incremented between the evaluation of the condition and the choosing of the return value.</p>
",1
8218532,8217275,1,"<p>You're looking for 6.5.15/4 in the C Standard.  The first expression is completely evaluated, including side effects, before the selected one of the other two.  This is not compiler-dependent, except in the sense that some compilers may be broken.</p>
",0
7811872,7811726,1,"<p>Here's a total stab in the dark...</p>

<p>A Google search picked up <a href=""http://www.opensource.apple.com/source/gcc/gcc-5484/gcc/config/rs6000/darwin-ldouble.c"" rel=""nofollow"">this header from Apple</a>. It looks like its part of <code>libgcc</code> (which is not Apple specific, that's just Apple's implementation), and that its used for doing <code>long double</code> arithmetic in software. Try adding <code>-lgcc</code> to your build process.</p>

<p><a href=""http://gcc.gnu.org/onlinedocs/gcc/Link-Options.html"" rel=""nofollow"">According to the GCC manual</a>, you can also explicitly force static or shared linkage of libgcc with either of these options: <code>-shared-libgcc</code> or <code>-static-libgcc</code>.</p>

<p><strong>Edit:</strong> As Nemo has pointed out, if you use <code>gcc</code> to link instead of manually invoking <code>ld</code> yourself, as <code>libgcc</code> will then be linked automatically. </p>
",1
4531716,4530709,1,"<p>Try <code>scandir</code> which reads the whole directory at once and can sort the names for you.</p>
",1
4530795,4530709,0,"<p>It is a Filesystem decision in what order it gives you the files or directories. If you want to display them sorted, you must first query all entries then sort them.</p>
",3
3303467,3303411,6,"<p>string literals are not const in C; in C++ they are.</p>

<p>edit: to clear up any confusion about my comment, I am referring to the type, not the ability to actually change them.  </p>
",2
3303468,3303411,16,"<p>It is a K&amp;R legacy.  Fixing it would break a million programs.</p>
",0
3303744,3303411,4,"<p>The GNU compiler (and the Intel C compiler as well, iirc) will emit a warning, if <code>-Wwrite-string</code> is used:</p>

<pre><code>$ gcc -Wall -Wwrite-strings -o foo /tmp/foo.c
/tmp/foo.c: In function 'main':
/tmp/foo.c:12: warning: passing argument 1 of 'somefunc' discards qualifiers from pointer target type
/tmp/foo.c:3: note: expected 'char *' but argument is of type 'const char *'
</code></pre>

<p>Concerning VS2010, I can't help you.</p>
",1
3303511,3303411,7,"<p>What Hans Passant said. const was added as part of the ANSI standard on 1989, so anything from before that didn't have const.</p>
",1
3303685,3303411,11,"<p>gcc: Use the flag <code>-Wwrite-strings</code></p>

<p>PS. gcc manual explains why this isn't part of -Wall. Anyway, as always, you should find a combination of -W flags that suits your particular needs and coding style. For example, in a recent project I have used something like this: <code>-Werror -Wall -Wextra -Wformat=2 -Winit-self -Wswitch-enum -Wstrict-aliasing=2 -Wundef -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-qual -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wold-style-definition -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls -Wnested-externs -Winline -Wdisabled-optimization -Wunused-macros -Wno-unused</code></p>
",0
3305747,3305735,16,"<h2>Pseudo code</h2>

<pre><code>while c = getchar:
    if c is blank:
        c = getchar until c is not blank
        print blank
    print c
</code></pre>

<h2>C</h2>

<p>You can substitute use of <a href=""http://linux.die.net/man/3/isblank"" rel=""noreferrer""><code>isblank</code></a> here if you desire. It is unspecified what characters contrive blank, or what blank value is to be printed in place of others.</p>

<p>After many points made by Matthew in the comments below, this version, and the one containing <code>isblank</code> are the same.</p>

<pre><code>int c;
while ((c = getchar()) != EOF) {
    if (c == ' ') {
        while ((c = getchar()) == ' ');
        putchar(' ');
        if (c == EOF) break;
    }
    putchar(c);
}
</code></pre>
",13
3305763,3305735,23,"<p>Look at your program as a machine that moves between different states as it iterates over the input.</p>

<p>It reads the input one character at a time. If it sees anything other than a blank, it just prints the character it sees. If it sees a blank, it shifts to a different state. In that state, it prints one blank, and then <em>doesn't</em> print blanks if it sees them. Then, it continues reading the input, but ignores all blanks it sees--until it hits a character that isn't a blank, at which point it shifts back to the first state.</p>

<p>(This concept is called a <em>finite state machine</em>, by the way, and a lot of theoretical computer science work has gone into what they can and can't do. <a href=""http://en.wikipedia.org/wiki/Finite-state_machine"" rel=""noreferrer"">Wikipedia</a> can tell you more, though in perhaps more complicated detail than you're looking for. ;))</p>
",1
4246486,4246453,2,"<p>Because %x formats the given value into hexadecimal.</p>

<p>In facts, 0x32 (hex) == 50 (decimal).</p>

<p>This is a good <a href=""http://www.pixelbeat.org/programming/gcc/format_specs.html"" rel=""nofollow"">primer</a> for reference.</p>
",0
4246595,4246453,5,"<p>From the <code>printf(3)</code> manual page:</p>
<h1>The flag characters</h1>
<p>The character % is followed by zero or more of the following flags:</p>
<p># ¡ª The value should be converted to an  &quot;alternate  form&quot;.   For  o conversions,  the  first  character of the output string is made zero (by prefixing a 0 if it was not zero already).  For x and X conversions, a nonzero result has the string &quot;0x&quot; (or &quot;0X&quot; for X conversions) prepended to it.  For a, A, e, E, f, F,  g,  and  G conversions,  the  result  will  always contain a decimal point, even if no digits follow it (normally, a decimal  point  appears in  the  results  of those conversions only if a digit follows). For g and G conversions, trailing zeros are not removed from the result  as  they would otherwise be.  For other conversions, the result is undefined.</p>
<p>Other flags omitted...</p>
<p>Thus, %# prepends &quot;0x&quot; to the output since the output format is <code>x</code>. The 0 is there to use <code>0</code> (zeros) for padding. Then the number 4 says the total number of characters to print is four. Had the number 4 been exchanged with 10, the output would have been <code>0x00000032</code> ¨C a total of 10 characters.</p>
",2
4246473,4246453,5,"<p>50 decimal is 32 hexadecimal.</p>

<p>Apart from that, the <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/printf/"" rel=""nofollow"">documentation</a> should tell you all you need to know.</p>
",0
4232904,4232627,1,"<blockquote>
  <p>Any way to retreive the memory amount currently allocated for the pointer value?</p>
</blockquote>

<p>Not in the sense you're looking for, no.</p>

<p>In the language sense, the amount of memory allocated for the pointer value (in question) is, of course, <code>sizeof(unsigned char *)</code>. This (again, of course) does in no way correlate with the size of the memory block the pointer is pointing to. A pointer simply holds no such information.</p>

<p>If you (for some reason) cannot pass the size information alongside with the pointer, you must decide a value of <code>unsigned char</code> to signify the end of the memory block (and assign that value to the end of the memory block). (This is how strings work in C). The only way to find the length of the block is to loop through the values.</p>

<p>Why do you have a pointer to unsigned char, if it really points to char? By the way, <code>char buff</code> is hardly a buffer, as it only holds a single value of char.</p>
",0
4232637,4232627,2,"<p>If you really have a single character:</p>

<pre><code>char buff = (char)*ptr;
</code></pre>

<p>If you have a string which i assume as you are talking about looping over characters:</p>

<pre><code>char *buff = strdup(ptr);
</code></pre>
",1
3549557,3549529,5,"<p>Just ANSI C does not have the ability to do GUI applications. You need to use GUI libraries to perform mouse interactions.</p>

<p>Libraries such as Windows API, XWindows (there are tons more, these are the ""core"" basic libraries) are what you need.</p>

<p>What platform are you developing on?</p>
",2
3418649,3417912,0,"<p>If I understand the question right...</p>

<p>Your NONPORTABLE CONVERSION error is because</p>

<pre><code>word[j]=pre;
</code></pre>

<p>is trying to assign a <code>char*</code> to a <code>char</code>. </p>

<p>You didn't say what didn't work about your <code>strcpy()</code>, but I'm assuming, given the code shown, that you hadn't allocated any memory for <code>char *word</code>, and were trying to copy into NULL.  Instead,</p>

<pre><code>  word=(char*)malloc(strlen(pre)+1);
  if (word) strcpy(word,pre);
</code></pre>
",1
3418004,3417912,1,"<p>If you want word to be an array of strings, then it should be declared as :</p>

<pre><code> char **word; //and allocated accordingly
</code></pre>

<p>If you want word to just be a copy of pre, you should have something more like </p>

<pre><code> word[j] = pre[j]; // in a loop, but using strcpy or strncpy would be just as good...
</code></pre>
",0
3845253,3819233,1,"<p>Replace your <strong>two</strong> printfs with</p>

<pre><code>printf(""Error restoring the reference stream position @ line %d\n"", __LINE__);
</code></pre>

<p>I suspect the error does not come from where you thing it comes from.</p>
",0
3417419,3407526,0,"<pre><code>enum {OUT,ADD};
void processline(int action,int hour,float val)
{
    static int lasthour,z;
    static float vals[25];
    static int nums[25];
    if( OUT==action )
    {
        if(lasthour)
        {
            int i;
            for(i=1;i&lt;=z;++i)
                printf(""%.2f; %d; "",vals[i],nums[i]);
            printf(""%d; %.2f\n"",*nums,*vals);
            lasthour=z=0;memset(vals,0,sizeof vals);memset(nums,0,sizeof nums);
        }
        return;
    }
    if( hour!=lasthour )
        ++z,lasthour=hour;
    vals[z]+=val;
    nums[z]++;
    *vals+=val;
    *nums+=1;
}
main()
{
    char z[100],lastday[20]="""";
    FILE *f=fopen(""test.txt"",""rt"");
    while( fgets(z,sizeof z,f) )
    {
        char a[100],b[100];
        float fl;
        if( 3==sscanf(z,""%[^ ]%[^;];%f"",a,b,&amp;fl) )
        {
            if( strcmp(lastday,a) )
            {
                if(*lastday)
                    printf(""%s; "",lastday),processline(OUT,0,0);
                strcpy(lastday,a);              
            }
            processline(ADD,atoi(b),fl);
        }
    }
    if(*lastday)
        printf(""%s; "",lastday),processline(OUT,0,0);
    fclose(f);
    return 0;
}
</code></pre>

<p>should work.
How many Perl-LoCs needed?!</p>
",1
2831124,2831050,2,"<p><a href=""http://www.doxygen.nl"" rel=""nofollow noreferrer"">Doxygen</a> does this pretty well (here are some <a href=""http://www.doxygen.nl/results.html"" rel=""nofollow noreferrer"">examples</a>). ctags does this too but I haven't really played with it much aside from using it in vim. I'm sure the tags file can be made parseable.</p>
",0
2831224,2831050,1,"<p>You can try <a href=""http://www.grok2.com/code_comprehension.html#cscope"" rel=""nofollow noreferrer"">CScope</a></p>

<p>More info <a href=""http://cscope.sourceforge.net/"" rel=""nofollow noreferrer"">here</a></p>
",0
2831782,2831050,0,"<p>The Unix <strong>nm</strong>(1) on the binary may be helpful. And I used <strong>cxref</strong> about 15 years ago.</p>
",0
2831803,2831050,1,"<p>Not sure this will help you but that would be easy to do with Cil from <a href=""http://www.eecs.berkeley.edu/~necula/cil/index.html"" rel=""nofollow noreferrer"">http://www.eecs.berkeley.edu/~necula/cil/index.html</a> the problem is you will need to learn OCaml to use it. (Some people might consider that a feature.)</p>
",0
3431157,3430729,1,"<p>30 characters:</p>

<pre><code>main(){exit(!printf(""%m\n""));}
</code></pre>

<p>29 characters:</p>

<pre><code>main(){exit(!printf(""%m
""));}
</code></pre>
",2
3431213,3430729,0,"<p>I made it in 0 (zero) characters:</p>

<pre><code> cat src.c

 (empty)
</code></pre>

<p>the resulting executable:</p>

<pre><code>rbo@deneb ~
$ ./src
SUCCESS
</code></pre>

<p>and the command line:</p>

<pre><code>rbo@deneb ~
$ echo x&gt;&gt;src.c &amp;&amp; gcc -Dx=""int main(){return puts(\""SUCCESS\"");}"" -o src src.c
</code></pre>

<p>But this of course still creates a source file with on character, as <a href=""https://stackoverflow.com/users/409157/pedro-rodrigues"">Pedro</a> has pointed out below. Without any source file, the command would be (in a Unix environment):</p>

<pre><code>rbo@deneb ~
echo 'int main(){return puts(""SUCCESS"");}'|gcc -ansi -o src -xc -
</code></pre>

<p>which is even shorter than the above. In the original description, there's no restriction stated how to solve it, but the OP adds in a later comment he can't change the command line. If this is true, then this is <em>not really</em> a <strong>Code Golf</strong> ;-)</p>

<p>Regards</p>

<p>rbo</p>
",2
3430739,3430729,6,"<pre><code>main(){puts(""Success"");}
</code></pre>

<p>24 characters.</p>

<ul>
<li>in C, if you omit the return type, it is implicitly <code>int</code></li>
<li>if main() does not contain a return statement, then the return value of main is 0</li>
</ul>

<p><strong>UPDATE:</strong>
All right, the return from main <em>can be omitted in every version of C</em>, but only C99 defines the return value <em>to be 0 if omitted</em>. C99 also disallows implicit declarations.</p>

<p><strong>UPDATE:</strong> 
I have faint memory that somebody pulled this off for a similar problem: He/She somehow encoded most of the program in the <strong>file name</strong> so that the __FILE__ macro could be used in the program code to inject the code. I don't know if this is within the rules for OP's competition, but it should make an interesting exercise anyway.</p>
",5
3430746,3430729,0,"<p>Here's a simple one in 24 chars...</p>

<pre><code>main(){puts(""Success"");}
</code></pre>

<p>Neither the <code>int</code> return type for <code>main()</code> nor the <code>return</code> statement are strictly necessary...</p>
",2
3430787,3430729,5,"<p>The problem statement is very vague, it look like it needs to compile with <code>gcc -ansi</code> and return 0 when run. Best I could come up was this:</p>

<pre><code>main(){exit(!puts(""Success""));}
</code></pre>

<p>32 characters counting the final newline (can you omit that?). Adding <code>int</code> to <code>main()</code> puts it at 36 characters.</p>

<h3>Edit</h3>

<p>This probably won't be allowed:</p>

<pre><code>/* Filename: Success */
main(){exit(!puts(__FILE__));}
</code></pre>

<p>Compile with <code>gcc -x c -ansi Success</code> and it will save you another character!</p>

<p>And what about this one character solution:</p>

<pre><code>C
</code></pre>

<p>Just compile with <code>gcc -ansi -DC='int main(void){puts(""Success"");return 0;}'</code>.</p>
",5
3431354,3430729,5,"<h1>26 characters</h1>
<pre><code>main(){brk(printf(&quot;%m&quot;));}
</code></pre>
",8
3431382,3430729,3,"<p><strong><a href=""http://www.spoj.pl/SHORTEN/ranks/SUCCESS/"" rel=""nofollow noreferrer"">26</a></strong></p>

<pre><code>main(){j0(!printf(""%m""));}
</code></pre>
",3
3430870,3430729,0,"<p>Making it smaller relies on doing things which are not portable or strictly valid C. On a POSIX environment with lax enforcement of the rules, you can do (18 characters):</p>

<pre><code>main(){perror(0);}
</code></pre>

<p>But unless <code>int</code> and pointers have the same size, this will break. Adding 1 extra character and taking advantage of the fact that real-world POSIX systems have <code>long</code> and pointer types the same size:</p>

<pre><code>main(){perror(0L);}
</code></pre>

<p>I don't think you can make it any smaller.</p>
",3
3430871,3430729,1,"<pre><code>int main(){perror(0);}
</code></pre>
",1
6352879,6352870,22,"<p>I don't personally <em>like</em> this solution, but:</p>

<pre><code>char * letters = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"";
for (char * ptr = letters; *ptr != 0; ++ptr) {
    char ch = *ptr;
    ...
} 
</code></pre>
",8
6352881,6352870,-2,"<pre><code>for (ch = 'A';ch &lt;= 'z';ch++) {

}
</code></pre>

<p>This will also include a few characters such as '[' and ']'...</p>
",0
6352888,6352870,-1,"<p>It's pointless, just use one for loop. The variables are mainly used as counters, or boundaries for the loop so it knows when to terminate. Just make one loop. Two loops are completely unnecessary. </p>
",1
6352891,6352870,24,"<pre><code>for (char ch = 'A' ; ch &lt;= 'z' ; ch == 'Z' ? ch = 'a' : ++ch )
{
}
</code></pre>

<p>Should work -- though please, please, don't inflict this on your fellow developers.</p>
",6
6352892,6352870,3,"<p>You can do it in a nested loop (two loops, but only one body):</p>

<pre><code>for (start = 'A'; start &lt;= 'a'; start += 'a' - 'A') {
    end = start + 'Z' - 'A';
    for (ch = start; ch &lt;= end; ++ch) {
         /* body */
    }
}
</code></pre>
",6
6352901,6352870,3,"<p>Well, the obvious question is why? ...and the second question is do you care about non-ASCII character sets (as your two loops will fail for EBCDIC), but the quick and dirty way of connecting the two is</p>

<pre><code>for (ch = 'A'; ch &lt;= 'z'; ch++) {
    if (ch &gt; 'Z' &amp;&amp; ch &lt; 'a') ch = 'a';
     :
</code></pre>
",1
6352903,6352870,2,"<pre><code>const char diff = 'a' - 'A';
for (ch = 'A' ; ch &lt;= 'Z' ; ch++ )
{
  char small_ch = ch + diff;
 //... 
}
</code></pre>
",4
6353547,6352870,1,"<p>Try this:</p>

<pre><code>        for (int i = 0; i &lt; 52; ++i)
            printf(""%c\n"", 'A' + i + ('a' - 'Z' - 1) * (i/26));
</code></pre>
",2
6352912,6352870,0,"<pre><code>for (int i=0;i&lt;26;++i) {

     char ch = 'A' + i;
     // Logic for Uppercase letters.

     char ch1 = 'a' + i;
     // Logic for Lowercase letters.

}
</code></pre>
",3
6353834,6352870,0,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
int main()
{
    int i;
    char e;
    for(i=65;i&lt;=122;i++)
    {
                        if(i&lt;91||i&gt;96)
                        {
                            e=i;
                        printf(""%c\n"",e);
                        }
                        }

    getch();
}
</code></pre>
",0
6356138,6352870,0,"<pre><code>for (char ch = 'A'; ch &lt;= 'z'; ch = ch == 'Z'?'a':ch+1) {
       //loop body
}
</code></pre>

<p>This approach is similar to Billy's, but with a slightly less nasty loop-increment statement.  I wouldn't mind inflicting this on a fellow dev, though I might write the increment statement as a function to clarify if the increment statement got any more complex:</p>

<pre><code>char nextChar(char c) { return c == 'Z' ? 'a' : c+1; }

for (char ch = 'A'; ch &lt;= 'z'; ch = nextChar(ch)) {
       //loop body
}
</code></pre>
",2
6355601,6352870,0,"<p>A straightforward solution is</p>

<pre><code>int i;
for(i = 0; i &lt; 52; i++){
  char ch = i + (i &lt; 26? 'A' : 'a');
  /* do something with ch */
}
</code></pre>

<p>although I prefer, especially in sensible languages that allow nested functions,</p>

<pre><code>for(ch = 'A'; ch &lt;= 'Z'; ch++)
  dosomething(ch);
for(ch = 'a'; ch &lt;= 'z'; ch++)
  dosomething(ch);
</code></pre>

<p>P.S. Kobe, I see in one of your comments that your reason for the loops is to check whether a character is a letter ... but looping is a horrid way to do that. You could simply do</p>

<pre><code>if(('A' &lt;= c &amp;&amp; c &lt;= 'Z') || ('a' &lt;= c &amp;&amp; c &lt;= 'z')){
    /* c is a letter */
}
</code></pre>

<p>or, considerably better,</p>

<pre><code>#include ctype.h
...
if(isalpha((unsigned char)c)){
    /* c is a letter */
}
</code></pre>

<p>(To understand why that cast is needed, read the isalpha man page and the C language standard. This is one of several abominable aspects of C.)  </p>
",0
6355949,6352870,-1,"<pre><code>void main()
{   
    char ch;

    for(ch= 65 ; ch &lt;= 122 ; ch++)
    {
        if ( ch&gt;=91 &amp;&amp; ch&lt;=96)
        continue;                     //hey check this out if this helps
        printf(""%c \n"",ch);
    }

}
</code></pre>
",0
3485724,3485708,6,"<p>Argument 4 is <code>client_sock</code>, which is the argument that gets passed to <code>accept_request</code>. It is expected to be a pointer, but since it's just passed through to your function, it can be an integer without doing any harm. Just cast it to <code>void*</code> to remove the warning.</p>

<p>On the other hand, the third argument <code>accept_request</code> should be a function pointer accepting <code>void*</code> and returning <code>void*</code>. You shouldn't have to cast it to <code>void*</code>. It would be best to change the declaration of <code>accept_request</code> to match the specification.</p>

<pre><code>void *accept_request( void *client_sock );
</code></pre>
",0
3485743,3485708,4,"<p>I assume client_sock is defined as ""int client_sock"". In this case you should write the following:</p>

<pre><code>if (pthread_create(&amp;newthread , NULL, (void * ) accept_request, &amp;client_sock) != 0) {
</code></pre>

<p>Then in accept_request (which, btw, should be a function taking a pointer) you will do like:</p>

<pre><code>void *accept_request( void *client_sock_addr ) {
   int client_sock = *((int*) client_sock_addr);
}
</code></pre>

<p>Converting an int to an (void*) might not be portable (as data sizes of int and void* are not necessarily the same). Of course, it might work on your current compiler...</p>

<p>Thanks jiles for pointing this: Depending on the rest of the code, the value at that address might change (for example if you have a loop around the accept construct and 2 accepts arrive before one thread is created). The nicest way to do it is indeed allocate memory with malloc like </p>

<pre><code>int *client_sock_addr=malloc(sizeof(int)); 
*client_sock_addr = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len);        
if (pthread_create(&amp;newthread , NULL, (void * ) accept_request, client_sock_addr) != 0) {
        perror(""pthread_create"");
}
</code></pre>

<p>And then in the function do:</p>

<pre><code>void *accept_request( void *param ) {
   int *client_sock_addr = (int*) client_sock_addr;
   int client_sock = *client_sock_addr;

   // Before exiting the thread
   free(client_sock_addr);
}
</code></pre>
",3
3486497,3485708,0,"<p>This is simply because you are not respecting the signature of <code>pthread_create</code>:</p>

<pre><code>int pthread_create(pthread_t *restrict thread,
              const pthread_attr_t *restrict attr,
              void *(*start_routine)(void*), void *restrict arg);
</code></pre>

<p>As you can see the third argument should be a function pointer so the correct cast would be to <code>(void *(*)(void*))</code> and for <code>client_sock</code> which will be the argument to <code>start_routine</code> you have to take the address like that <code>&amp;client_sock</code></p>
",0
3483267,3482893,-1,"<p>a string-literal <code>""Hellow\0""</code> is equal to <code>""Hellow""</code></p>

<p>if you define</p>

<pre><code>t[7] = ""Hellow"";
s[7] = ""Dad"";
</code></pre>

<p>your example is defined and crashes not.</p>
",1
3482926,3482893,2,"<p>About the first question.</p>

<p>If you're lucky your program will crash.</p>

<p>If you are not it will keep on running and overwrite memory areas that shouldn't be touched (as you don't know what's actually in there). This would be a hell to debug...</p>

<p>About the second question.</p>

<p>Both <code>char* s</code> and <code>char *s</code> do the same thing. It's just a matter of style.</p>

<p>That is, <code>char* s</code> could be interpreted as ""<code>s</code> is of type <code>char</code> pointer"" while <code>char *s</code> could be interpreted as ""<code>s</code> is a pointer to a <code>char</code>"". But really, syntactically it's the same.</p>
",1
3482928,3482893,2,"<p>As you correctly point out, passing <code>s[3]</code> as the first argument is going to overwrite some memory that could well be used by something else. At best your program will crash right there and then; at worst, it will carry on running, damaged, and eventually end up corrupting something it was supposed to handle.</p>

<p>The intended way to do this in C is to never pass an array shorter than required.</p>

<p>By the way, it looks like you've swapped <code>s</code> and <code>t</code>; what was meant was probably this:</p>

<pre><code>void strcpy(char *t, char *s) {
    int i = 0;

    while ((t[i] = s[i]) != '\0')
        i++;
}
</code></pre>

<p>You can now copy <code>s[4]</code> into <code>t[7]</code> using this amended <code>strcpy</code> routine:</p>

<pre><code>char t[] = ""Hellow"";
char s[] = ""Dad"";

strcpy(t, s);
</code></pre>

<p>(edit: the length of <code>s</code> is now fixed)</p>
",1
3482943,3482893,1,"<p>That example does nothing, you're not invoking strcpy yet. But if you did this:</p>

<pre><code>strcpy(s,t);
</code></pre>

<p>It would be wrong in several ways:</p>

<ul>
<li>The string <strong>s</strong> is not null terminated. In C the only way strcpy can know where a string ends is by finding the '\0'. The function may think that <strong>s</strong> is infinite and it might corrupt your memory and make the program crash.</li>
<li>Even if was null terminated, as you said the size of <strong>s</strong> is only 3. Because of the same cause, strcpy would write memory beyond where <strong>s</strong> ends, with maybe catastrophic results.</li>
</ul>

<p>The workaround for this in C is the function strncpy(dst, src, max) in which you specify the maximum number of chars to copy. Still beware that this function might generate a not null terminated string if <strong>src</strong> is shorter than <strong>max</strong> chars.</p>
",1
3482955,3482893,1,"<p>I will assume that both <code>s</code> and <code>t</code> (above the function definition) are arrays of char.</p>

<blockquote>
  <p>how do I know that after copying, other data that was after s[] in the memory wasn't deleted?</p>
</blockquote>

<p>No, this is worse, you are invoking undefined behavior and we know this because the standard says so. All you are allowed to do after the three elements in <code>s</code> is compare. Assignment is a strict no-no. Advance further, and you're not even allowed to compare.</p>

<blockquote>
  <p>and one more question please: char <em>s is identical to char</em> s?</p>
</blockquote>

<p>In most cases it is a matter of style where you stick your asterix except if you are going to declare/define more than one, in which case you need to stick one to every variable you are going to name (as a pointer).</p>
",0
4164405,4164399,5,"<p>If you don't need to make any modifications to the string then you can just give the original pointer plus 1, otherwise you will need to copy.</p>
",0
4164417,4164399,1,"<p>Nothing magical about it. A pointer to a string, like a pointer to an array, is just the address of the first element.</p>

<p>Basic pointer arithmetic, take your existing pointer, increment it (<code>p++</code>), and you have a pointer to the ""tail"" of your string.</p>
",0
4164433,4164399,4,"<p>You can just make a char* that points to the index you need.</p>

<pre><code>char *p = ""100110000111001100010001100011001100100"";
char *tail = &amp;p[1]; //&amp;p[1] is the same as p+1
printf(""p = %s\ntail = %s\n"",p,tail);
</code></pre>
",0
6354864,6354846,6,"<p>The size of the struct includes padding bytes between is members due to packing alignment, which is compiler- and architecture-dependent (see <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86"" rel=""nofollow noreferrer"">here</a> for an example)</p>

<p><strong>Update:</strong> Not surprisingly, this question is a dupe. For a better answer, see <a href=""https://stackoverflow.com/q/119123/50079"">Why isn&#39;t sizeof for a struct equal to the sum of sizeof of each member?</a>.</p>
",0
5475751,5475721,1,"<p>On linux, the programs banner and figlet can do what you want. Look them up on google.</p>
",0
3429044,3429033,0,"<p>Your numbers are large, so use a 64-bit unsigned integer data type, such as <code>unsigned long long</code>. You won't be able to deal with numbers greater than <code>2**64</code> without adopting a new scheme. Print hex values using <code>printf(""%x"", value)</code>.</p>

<p>You can look at GNU GMP library for arbitrarily large integers.</p>
",0
3429049,3429033,1,"<p>This will generate 1000 bytes of random hexadecimal numbers. (Or rather, the ASCII representation of 1000 hexadecimal digits.)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv) {
    int i;
    for (i=0; i&lt;1000; i++) {
        printf(""%x"", rand()%16);
    }
    printf(""\n"");
    return EXIT_SUCCESS;
}
</code></pre>

<p>If you wanted to store them in a buffer to compare with something else later, you might want to look at <code>sprintf</code> instead of <code>printf</code>. For that, you really need to understand how strings are allocated and used in C first.</p>

<p><strong>EDIT</strong>: This might be more what you're after. It reads hexadecimal digits from standard input (which can be redirected from a file if desired) and checks to see if they follow the pattern that you described.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv) {
    int expected_number = 7;
    unsigned int read_number;
    while (1 == scanf(""%2x"", &amp;read_number)) {
        if (expected_number != read_number) {
            fprintf(stderr, ""Expected %02x but got %02x.\n"", expected_number, read_number);
        }
        expected_number--;
        if (expected_number == -1) expected_number = 15;
    }
    return EXIT_SUCCESS;
}
</code></pre>
",5
3429645,3429630,6,"<p><code>sizeof array / sizeof *array</code> is a way of finding out how many elements are in an array. (Note that it must be an array rather than a pointer.) I'm not sure how that's related to your function pointer question.</p>

<p>Function pointers are used to store a reference to a function so that it can be called later. The key thing is that a function pointer needn't always point to the same function. (If it did, you could just refer to the function by name.)</p>

<p>Here's an example based on your code (although I could provide a better one if I knew what your code was supposed to do.</p>

<pre><code>char *s1 = ""String one"";
char *s2 = ""String two"";

void f(char *a, void *b) {
    /* Do something with a and b */
}
void g(char *a, void *b) {
    /* Do something else with a and b */
}

struct xx {
    char *a;
    void (*func)(char *a, void *b);
    void *b;
}

struct xx ppp[] = { {s1, f, NULL}, {s2, g, NULL} };

int main(int argc, char **argv) {
    for (int i = 0; i &lt; (sizeof ppp / sizeof *ppp); i++) {
        ppp[i].func(ppp[i].a, ppp[i].b);
    }
}
</code></pre>
",6
3429696,3429630,2,"<blockquote>
  <p>When do we actually go for function pointers? specially like the one below.</p>
</blockquote>

<p>You use function pointer when you want to make something more abstract.
By example, suppose your application has a graphical toolbox with a certain number of buttons. Every button corresponds to an instance of a certain struct.</p>

<p>The button structure can contain a function pointer and a context:</p>

<pre><code>typedef struct {
    void (*press_button) (void *context);
    void *context;
    /* Here some other stuff */
} Button;
</code></pre>

<p>When the user clicks the button, the event is something like</p>

<pre><code>void event_click (Button *b)
{
    b-&gt;press_button(b-&gt;context);
}
</code></pre>

<p>The point in doing this is that you can use always the same structure for each button:</p>

<pre><code>Button * create_button (void (*callback) (void *), void *context, /* other params */
{
    Button *ret = malloc(sizeof(Button));
    if (ret != NULL) {
        ret-&gt;callback = callback;
        ret-&gt;context = context;
        /* Assign other params */
    }
    ...
    return ret;
}
</code></pre>

<p>So when you build your toolbox you probably do something like</p>

<pre><code>Button * toolbox[N];
toolbox[0] = create_button(function1, (void *)data, ...);
toolbox[1] = create_button(function2, (void *)something, ...);
...
toolbox[N-1] = create_button(functionN, (void *)something_else, ...);
</code></pre>

<p>Also when you create some function pointer, always carry some contxt information (like I did with the <code>context</code> field of the struct). This allows you to avoid global variables, thus you can get a robust and reentrant code!</p>

<p><strong>Note</strong>:
This method is awesome, but if you deal with C++ you may prefer to use object orientation and replace callbacks with derivaton from abstract classes. By doing this you also don't need to carry the context, since the class will do it for you.</p>

<p><strong>Edit in answer of first comment</strong>:</p>

<blockquote>
  <p>The current code I am going through is related to file IO. setting an environment variable and creating symbolic links between files, copying data from one file to another, etc. I am not understanding why do we need to call these functions at run time using function pointers. we can as well call them directly.</p>
</blockquote>

<p>In fact you can do what you need without using function pointers. If I do understand well your problem, you are trying to understand someone else's code, which is doing what you listed with function pointers.</p>

<p>Personally I don't use this feature unless I need it but if you post here some additional code maybe we can try to understand it better.</p>
",1
3429721,3429630,3,"<p>There are two major uses (that I know of) for function pointers in C.</p>

<h2>1. Callbacks</h2>

<p>You have some sort of event-driven framework (a GUI is one of the easiest examples), and the program wants to react to events as they happen. Now you <em>can</em> do that with an event pump, like</p>

<pre><code>while (event *e = get_one_event()) {
  switch (e-&gt;type) {
    case EVT_CLICK:
      ...
  }
}
</code></pre>

<p>but that gets tiring after a while. The other major alternative is callbacks. The program defines a bunch of functions to handle different events, and then registers them with the library: ""when event X happens, call function Y"" -- so of course, the library is going to receive a function pointer, and call it at the relevant time.</p>

<h2>2. Objects (function tables / vtables)</h2>

<p>If you've done OO in most other languages, this should be fairly easy for you to picture. Imagine an object as a struct that contains its members and then a bunch of function pointers (or, maybe more likely, its members and a pointer to another struct representing its class, that contains a bunch of function pointers). The function pointers in the table are the object's methods. GLib/GObject is a big user of this technique, as is the Linux kernel (<code>struct file_operations</code>, <code>struct device_driver</code>, <code>struct bus_type</code>, and many many more). This lets us have an arbitrary number of objects with different behavior, without multiplying the amount of code. </p>
",0
2935960,2935955,11,"<p>Yes, you can use a <code>void*</code> to point to anything, and then cast it to the proper type when needed (that's how <code>malloc</code> and such can work).</p>

<p><code>void*</code> is basically ""pointer to an arbitrary block of memory"".</p>
",0
2935962,2935955,0,"<p>There are varying degrees of type safety, but since C is a strongly typed language, it's actually on the safer end of the spectrum. That won't stop you from doing what you propose. The example you give is syntactically valid, and could be used to implement the system you describe. Keep in mind, though, that if you go ahead and try to reinvent the wheel by creating your own VM, you're very unlikely to beat the performance of existing languages like Ruby and Java.</p>
",4
2935975,2935955,0,"<p>The good news: someone else thought of that. See Variant. (for example <a href=""http://en.wikipedia.org/wiki/Variant_type"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Variant_type</a> and <a href=""http://msdn.microsoft.com/en-us/library/x295h94e(VS.80).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/x295h94e(VS.80).aspx</a> .) The bad news: those of us who worked with them generally came to hate them.</p>
",0
2935976,2935955,8,"<p>If you know the range of types you want to support, this could easily be done with a <code>union</code> to avoid casts all over the place:</p>

<pre><code>struct Value
{
    ValueType type;
    union
    {
        int*        iptr;
        char*       sptr;
        float*      fptr;
        struct map* mptr;

        /* ... */

        void* vptr; /* catch all, extensions */

    } ptrs;
};
</code></pre>
",4
2935981,2935955,2,"<p>Sure it is. You will only need a big switch on <code>type</code> to distinguish the type of a particular value. The best type to use for your field <code>type</code> will probably be an enum with a constant for each of the types of your language, like so:</p>

<pre><code>typedef enum type {
    Integer,
    String,
    /* and so on... */
} ValueType;
</code></pre>

<p>Also remember you have to cast the <code>void*</code> pointer to a particular type before using it.</p>
",0
2936088,2935955,0,"<p>It's okay to write that code, but maybe you've to design your ""language"" (ok, interpreter :) ) before other things.</p>

<p>Btw, I suggest you to read the <a href=""http://www.planetpdf.com/codecuts/pdfs/ooc.pdf"" rel=""nofollow noreferrer"">object oriented programming in c book</a>.
When you've understood the main concepts, you can look at the implementation of <a href=""http://svn.python.org/view/python/trunk/Include/object.h?view=markup"" rel=""nofollow noreferrer"">Python Objects</a>, so that you can think about how methods interact with objects and how they are stored, and so on.</p>

<p>Bye bye!</p>
",0
2936127,2935955,0,"<p>Check out <a href=""http://ccan.ozlabs.org/info/typesafe_cb.html"" rel=""nofollow noreferrer"">CCAN's type safe callbacks</a> for macros that help you avoid bad casts. I know you aren't writing a callback, but lots of callbacks look like this:</p>

<pre><code>void my_callback(void *context)
</code></pre>

<p>And several types may be cast to <code>(void *)</code> and passed to <code>context</code>. Casting within that function gets tricky, especially if the callback launches a thread that takes a single <code>(void *)</code> argument.</p>

<p>Anyway, you might find some useful bits if you follow the link.</p>
",0
4660640,4660620,3,"<p>C doesn't have methods. You're trying to define a function in a function. You can't declare a function inside main().</p>

<p>You also have studentName declared twice inside defineNewStudent(), once as the first parameter, and you declare something with the same name inside it.</p>

<p>Also assigning studentName.course = course won't work. You would have to do something like</p>

<p>strncpy(studentName.course, course, sizeof(studentName.course));</p>

<p>You have to define the function before it's use. You can either move the entire thing before main which is what I would do, or you could include just it's prototype before main which here would be:</p>

<pre><code>void defineNewStudent(char studentName[20], int age, char gender, char course[30]);
</code></pre>
",4
4661057,4660620,0,"<p>I agree with Carl. You actually have to define the function before you use it and for that either you put your function above main() or put a function prototype before main:</p>

<p>void defineNewStudent(char studentName[20], int age, char gender, char course[20]);</p>

<p>main()
...rest of code</p>

<p>And you will have one more problem due to the fact the parameter and a local variable of your function have same name which will give a compiler error.
Also there are functions in C and not methods(which are in JAVA/C++ etc)</p>
",0
4660682,4660620,2,"<p>You have a few problems - nesting functions is probably a bad idea, for one.  Take <code>defineNewStudent()</code> and put it outside of <code>main()</code>.  Depending on where you put it (before or after <code>main()</code>), you may also need a function prototype before the call site in <code>main()</code>.</p>

<p>Also, you need to change the array parameter declarations for <code>defineNewStudent()</code> to look like <code>char parameterName[20]</code>, instead of what you have there.</p>

<p>You're also going to have some problems with <code>studentName</code> being the name of two different variables, with trying to copy a string using simple assignment, and with <code>""Software Engineering""</code> being too big to fit in your arrays.</p>

<p>And as @arsenm mentions in his answer, C doesn't have methods.</p>
",0
4660864,4660620,1,"<p>The error seems to be because the struct <code>student</code> is only defined inside the function <code>main</code>. You're trying to use it in the <code>defineNewStudent</code> function, but that struct is not defined there. Define the struct at the global scope.  </p>

<p>The warning is because you're trying to call the <code>defineNewStudent</code> function before you actually declare it, and the compiler still doesn't know about it at that point. You can declare the function before you try to use it.</p>

<pre><code>// define the student struct at global scope
struct student
{
    int age;
    char gender;
    char course[20];
};

// declare the function (it can still be defined later)
void defineNewStudent(char studentName[20], int age, char gender, char course[20]);

int main (int argc, const char * argv[])
{
   defineNewStudent(""Jarryd"", 24, 'M', ""Software Engineering"");

   return 0;
}

void defineNewStudent(char studentName[20], int age, char gender, char course[20])
{
    // you already have a variable called studentName,
    // you can't have two variables with the same name
    struct student studentData;
    studentData.age = age;
    studentData.gender = gender;
    studentData.course = course;

    printf(""%s is %d.\n Gender: %c.\n Course: %s.\n"", 
         studentName, 
         studentData.age, 
         studentData.gender,
         studentData.course
    );
}
</code></pre>

<p>EDIT:</p>

<p>to define an instance of a struct in C you need the <code>struct</code> keyword, so in the example it should be</p>

<pre><code>struct student studentData;
studentData.age = age;
studentData.gender = gender;
studentData.course = course;
</code></pre>

<p><strong>If it were c++</strong>, you could drop the <code>struct</code> keyword:</p>

<pre><code>student studentData;
studentData.age = age;
studentData.gender = gender;
studentData.course = course;
</code></pre>

<p>optionally in C, you can typedef the struct to an alias to make it easier to define instances of it:</p>

<pre><code>typedef struct student
{
    int age;
    char gender;
    char course[20];
} StudentStruct;

// define it like this in the function:
StudentStruct studentData;
</code></pre>
",7
2844799,2844470,0,"<p>Example code follows:</p>

<pre><code>void addMatrix(unsigned int size, double const * const a, double const * const  b, double * const res) {
   int i;
   for (i = 0; i &lt; size * size; ++i)
       res[i] = a[i] + b[i];
}

double findThirdSmallest(unsigned int size, double const * const input) {
   //save the three smallest values inside res
   double res[3];
   int i;
   for (i = 0; i &lt; 3; ++i) {
       res[i] = LDBL_MAX;
   }
   for (i = 0; i &lt; size * size; ++i) {
       int j;
       for (j = 0; j &lt; 3; ++j) {
           if (input[i] &lt; res[j]) {
               int k;
               for (k = 2; k != j; --k) {
                   res[k] = res[k - 1];
               }
               res[j] = input[i];
               break;
           }
       }
   }
   return res[2];
}
</code></pre>

<p>EDIT: Changing the type and the size of the matrix will be your work.</p>
",1
2844492,2844470,0,"<ul>
<li>First decide how to represent the matrix (hint: use an array of arrays)</li>
<li>Then figure out how to add two matrices - this is simple</li>
<li>Then, how do you find the 3rd smallest element in a sequence? There are many ways! Is efficiency especially important for you? What algorithmic complexity is required?</li>
</ul>
",2
2844504,2844470,0,"<p>If you are trying to access SIMD instructions, I don't believe there is an approach that will do both at the same time.  If you are not trying to do use SIMD, then just keep a temp array of the three smallest values (like a priority queue) that is updated each time a sum is computed in the matrix.  </p>

<p>If this were C++, the priority queue could be kept in a functor object used by the STL algorithms.</p>
",1
5464196,5464183,15,"<p>""C++"" is a string literal stored in <strong>read only location</strong> and hence cannot be modified. With this -</p>

<pre><code>char* t=""C++""; // t is pointing to a string literal stored in read only location
</code></pre>

<p>Instead, you should have -</p>

<pre><code>char t[] = ""C++"" ;  // Copying the string literal to array t
</code></pre>

<p>to actually do -</p>

<pre><code>t[1] = 'p' ;
</code></pre>
",1
5464240,5464183,0,"<p>Some versions of the standard runtime library require a <code>\n</code> to cause the output to appear.</p>

<pre><code>printf(""%s\n"",t);
</code></pre>
",4
5466477,5464183,9,"<p>There are several other problems with your code.</p>

<ol>
<li><p>Pointers are usually used to point to data that already exists, so you can use it like this</p>

<p>char arr[] = ""C++"";</p>

<p>char* t = &amp;arr[0];</p></li>
</ol>

<p>Also modifiable,</p>

<pre><code>t[1] = 'p';

t[2] = 'p';
</code></pre>

<p>of course there is a special way of using string ¡ª¡ª let the pointer point to a string constant. Just the way you used:</p>

<pre><code>char *t = ""C++"";   // you cannot modify it in most operating systems
t[1] = 'p';
t[2] = 'p';
</code></pre>

<p>There is a better way of using it, which is more portable and easy to understand:</p>

<pre><code>const char* t=""C++""; 
</code></pre>

<p>2.You code have many place that is not in c standard</p>

<pre><code>#include &lt;stdio.h&gt; // You'd better add a space between, for this is a good coding convention
#include &lt;conio.h&gt; // only supported by vc/vs in windows, you can use getchar() instead

int main()  // main returns int
{
    char* t = ""C++"";

    t[1] = 'p';
    t[2] = 'p';
    printf(""%s\n"", t);  // it's a good habit to add a '\n' when printing a string
    getchar();   // getchar() is supported by c standard library 

    return 0; // return 0 here
}
</code></pre>

<p>3.about printing string</p>

<p>Linux is line-buffered(ignore this if you are using windows :P) &amp; for easier to read in console, you'd better add a '\n' at the end of you printed string:</p>

<pre><code>printf(""%s\n"",t);
</code></pre>

<p>If you don't want to have a carriage return after a string. In windows use just as you like:</p>

<p><code>printf(""%s"",t);</code></p>

<p>In Linux, you should add a fflush() in stdlib.h.</p>

<pre><code>printf(""%s"",t);
fflush(stdout);
</code></pre>
",3
2918609,2918512,1,"<p>You can use pic2plot which is part of GNU plotutils. You need log/trace what talks to what, to a file and then you can render it with pic2plot. I've done this for a python program, but there is no reason why you can't do that with a C program.</p>

<p><a href=""https://i.stack.imgur.com/FuNSe.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FuNSe.gif"" alt=""sequence diagram""></a><br>
<sub>(source: <a href=""http://www.umlgraph.org/doc/seq-eg.gif"" rel=""nofollow noreferrer"">umlgraph.org</a>)</sub>  </p>

<p>see <a href=""http://www.umlgraph.org/"" rel=""nofollow noreferrer"">http://www.umlgraph.org/</a></p>
",0
2918668,2918512,1,"<p>I strongly recommend to use doxygen with the following options:</p>

<pre><code>EXTRACT_ALL            = YES
CALL_GRAPH             = YES
CALLER_GRAPH           = YES
GRAPHICAL_HIERARCHY    = YES
</code></pre>

<p>You will get a very nice call and caller graphs of functions which can help a great deal with understanding the code. A call graph is more common and useful for C code than a sequence chart.</p>

<p><a href=""http://pedro.larroy.com/files/example.png"" rel=""nofollow noreferrer"">call graph http://pedro.larroy.com/files/example.png</a></p>
",0
3425796,3425776,0,"<p>This required for a compiler to conform to the C standard.</p>

<p>The reason for the design choice is likely that having random garbage in your uninitialized variables makes errors much harder to detect.</p>
",0
3011497,3011483,3,"<p>There is no portable way to accomplish this.  It depends entirely on what platform you are using and what calling convention is used.  </p>

<p>That said, the <em>size</em> of the code in <code>main()</code> shouldn't ordinarily have any impact on the layout of the stack because the code is not located on the stack.</p>

<p>The best way to get <code>argv</code> from a function called from <code>main()</code> is to have that function take a <code>const char**</code> as a parameter and pass the <code>argv</code> into it.</p>
",0
8419723,8419697,4,"<p>If you've written beyond the bounds of a buffer somewhere, you may have corrupted the heap, in which case all bets are off.</p>

<p>I suggest using e.g. Valgrind to check that you haven't done something like this.</p>
",6
8419751,8419697,0,"<p><code>malloc</code> returns NULL when the calling process cannot allocate anymore memory, perhaps because a <a href=""http://linux.die.net/man/2/mmap"" rel=""nofollow"">mmap</a> system call fails because you reached some limits, like those set by <a href=""http://linux.die.net/man/2/setrlimit"" rel=""nofollow"">setrlimit</a></p>

<p>An individual process can reach its limit even if some memory is available to other processes.</p>

<p>You can use <code>strace</code> to trace the system calls and find out which one is failing.</p>

<p>And be sure to compile with <code>gcc -Wall -g</code> (and use the debugger <code>gdb</code>).</p>
",0
3917495,3917112,0,"<p>Ulrich Drepper has an excellent paper that covers cache behaviour among other things related to the memory system of modern computers. It's at <a href=""http://www.akkadia.org/drepper/cpumemory.pdf"" rel=""nofollow"">http://www.akkadia.org/drepper/cpumemory.pdf</a>.</p>
",0
3917119,3917112,8,"<p>He is right by <a href=""http://en.wikipedia.org/wiki/Locality_of_reference"" rel=""nofollow"">locality of reference</a> (specifically spatial locality). Nearby addresses will be prefetched/cached to speed up access. Thus, if you hit memory address <code>p</code>, then memory address <code>p + 1</code> and other nearby addresses will be prefetched and cached to speed up access to them whereas accessing <code>p + 1000</code> will likely require another trip across the memory bus.</p>

<p>(By the way, the layout that you describe is <a href=""http://en.wikipedia.org/wiki/Row-major_order"" rel=""nofollow"">row-major order</a>. Some languages (e.g., Fortran) use <a href=""http://en.wikipedia.org/wiki/Row-major_order#Column-major_order"" rel=""nofollow"">column-major order</a>.)</p>
",0
3917141,3917112,1,"<p>Processors make the assumption that if you retrieve a chunk of memory that you're likely to need other nearby data soon, and so prefetch a bit of extra into the cache.  Cache hits are very fast, so code that takes advantage of this will be faster than code which doesn't.  This is why it's faster to traverse nearby data members than jumping around. (So, yes, he's right)</p>
",0
3917176,3917112,1,"<p>Yup, it's true. In my experience, you can roughly halve performance by traversing the matrix the wrong way around.</p>

<p>The reason is that most of your hardware is built around a lot of assumptions of how it will <em>probably</em> be used, and then they use this knowledge to achieve better performance. In this case, the relevant principle is ""Spatial Locality"", the concept that ""if you recently needed address N, then you'll probably need the contents of address N+1 soon"".</p>

<p>Your RAM is designed to transfer memory in bursts for that reason. When you ask for one word of data, it starts loading a larger contiguous chunk of memory, so that it's ready for when you <em>probably</em> ask for it a moment later.</p>

<p>And the CPU itself does the same. Its cache is arranged on the same principle. It stores entire cache lines (typically 16 or 32 bytes, if memory serves) instead of individual bytes or words. That way, when you request a single byte, the entire cache line is read into cache, so that nearby data is also available should you need it.</p>

<p>If you traverse your matrix column by column, then each memory access is to an address far away from the previous one, so there is no spatial locality, and so both the CPU cache and your RAM fail to predict what data they should prefetch, and your end up waiting for data to be transferred to you all the time.</p>
",0
3917203,3917112,1,"<p>See <a href=""http://en.wikipedia.org/wiki/Row-major_order"" rel=""nofollow"">Row-major order</a>.</p>

<p>In the C language members are stored row by row. Caching means that when <code>*i</code> is accessed, <code>*(i+1)</code> is likely to be in the cache, so it is quicker.</p>

<p>The importance of mentioning the C language is because not all languages are like that. Famously, Fortran uses column-major order. So you will sometimes find a row-major matrix called <em>C-contiguous</em>, while a column-major one is called <em>Fortran-contiguous</em>.</p>
",0
7778101,7778087,4,"<p>*s dereferences into a char, which in the loop, a zero (0, or '\0') will act as false, terminating the loop, all other non-zero characters keep it as true.</p>
",0
7778105,7778087,3,"<p>The char (<code>*s</code>) gets cast to int, for conditions it holds that any integer != 0 is interpreted as <code>true</code>, so the loop ands when a <code>'\0'</code> char is encountered.</p>
",0
7778108,7778087,0,"<p>s is a pointer on a string.<br>
The end of a string is detected by a 0 value</p>
",0
7778110,7778087,1,"<p>Because the loop itself modifies <code>s</code> (with <code>*s++</code>), the while condition can examine it each time around the loop, and it will eventually terminate, when the pointer points to a nul character.</p>
",0
7778112,7778087,1,"<pre><code>while (*s)
</code></pre>

<p>while the character pointed by s is not zero (that is, if we did't reach the end of the string)</p>

<pre><code>putchar(*s++);
</code></pre>

<p>it can be thought as </p>

<pre><code>putchar(*s);      // write the character pointed by s
s += 1;          // go to next one
</code></pre>
",1
7778116,7778087,4,"<p>Logical expressions in C evaluate to false if they are 0, otherwise they evaluate to true. Thus your loop will terminate when <code>*s</code> is equal to 0. In the context of a <code>char</code> that is when the null-terminating character is encountered.</p>

<p>Note that <code>++</code> has a higher precedence than pointer dereferencing <code>*</code> and so the <code>++</code> is bound to the pointer rather than the <code>char</code> to which it points. Thus the body of your loop will call <code>putchar</code> for the character that <code>s</code> points to, and then increment the pointer <code>s</code>.</p>
",0
4329998,4329974,-1,"<p>On the last iteration of that <code>for</code> loop, <code>i</code> will index into the last position of the string. But you're adding the value of <code>start</code> (1 in this case) to <code>i</code> and <em>then</em> indexing into the string - meaning you're likely getting an index out-of-bounds error on that last loop iteration.</p>

<p>The fix (assuming I've correctly diagnosed the problem): initialize <code>i</code> to <code>start</code> instead of adding <code>start</code> to <code>i</code>.</p>
",3
4330008,4329974,1,"<p>The most obvious error is that you need to include a prototype in your code...</p>

<pre><code>char * substr(char *string, int start, int length);

main()
...
</code></pre>

<p>Otherwise your program will not be aware that substr has been defined (as a function) below the main code.</p>
",1
4330009,4329974,1,"<p>First, the return type of <code>main</code> is <code>int</code>.  Second, you have to declare functions before they're used. Either reorder <code>main</code> and <code>substr</code>, or put a prototype for <code>substr</code> in before your <code>main</code> definition. Third, temp is not initialized.  You either need to <code>malloc()</code> space for it, or allocate a static buffer (not on the stack).</p>
",3
4330010,4329974,0,"<p>Compiler issues:
No prototype for substr. Your compiler will probably let this go if you aren't compiling with strict ansi/iso standards.</p>

<p>Some runtime issues:
You didn't allocate any space for *temp. When you declare a local variable without initializing it, it holds a garbage value. Since temp is a pointer to a character, temp's content is a pointer to some address which most probably doesn't belong to you. </p>
",0
4330013,4329974,5,"<p>Here are the errors I see:</p>

<h2>Use of uninitialized pointer</h2>

<p>In <code>substr</code> you declare <code>char *temp;</code> and then use it without initializing it to anything.  This is not a compile-time error, but this program will almost certainly crash when you run it, since <code>temp</code> will effectively point to a random memory address.  This is a case of <em>undefined behavior</em>, and C is chock full of it.  Undefined behavior will come out of nowhere and eat your pets if you aren't careful.</p>

<p>Consider <code>malloc()</code>ing some memory, or having your function receive a pointer to a buffer where it can write the portion of the string.</p>

<h2>Use of function not yet declared</h2>

<p>In C you must declare functions before they are used, or at least declare their prototype.  Above <code>main()</code>'s declaration, add this line:</p>

<pre><code>char * substr(char *string, int start, int length);
</code></pre>

<h2>No use of <code>const</code> where it makes sense</h2>

<p>When assigning a string literal to a <code>char*</code>, that variable should be declared <code>const</code>.  So change</p>

<pre><code>char *string = ""abcdefghi"";
</code></pre>

<p>to</p>

<pre><code>const char *string = ""abcdefghi"";
</code></pre>

<p>You will have to change your function prototype to</p>

<pre><code>char * substr(const char *string, int start, int length)
</code></pre>

<p>which is what it should have been in the first place.</p>

<p><strong>Added 2010-12-02:</strong></p>

<h2><code>substr()</code> does not add terminating null character</h2>

<p>The <code>substr()</code> function, while algorithmically correct in every other sense, does not add a terminating null character to the new string.  This will cause <code>printf()</code> and every other string-using function (like <code>strlen()</code>, <code>strcpy()</code>, etc.) to run off the end of the string into unallocated heap memory, or stack memory (depending on how you resolve the ""uninitialized pointer"" issue).</p>

<p>To fix this, add this line immediately after the <code>for</code> loop, and before the <code>return</code> statement:</p>

<pre><code>temp[i] = '\0';
</code></pre>

<p>Note that this should not be added <em>in</em> the for loop, as that would have the effect of creating a string with zero length.</p>
",2
2933404,2933400,11,"<p>You can limit the length by setting the precision in the format specifier:</p>

<pre><code>printf(""%.8s"", str);
</code></pre>

<p>This will print <em>up to</em> eight characters from the null-terminated string pointed-to by <code>str</code>.  If the length of <code>str</code> is less than eight characters, then it will print the entire string.</p>

<p>Note that the format specifier for a null-terminated string is <code>%s</code>, not <code>%c</code> (<code>%c</code> is to print a single <code>char</code>), and that <code>printf</code> returns an <code>int</code> (the total number of characters printed), not a <code>char</code>.</p>
",3
2936424,2933400,0,"<p>No </p>

<p>That is incorrect.  tabular printing ""%8s"" pads up to say 8 spaces, as in the example given. It does not truncate.  ISOC99.  If this is a windows only thing, okay, MS ignores the world on lots of things.  If the length of the string is longer than the tabulation then the full string prints.  See:</p>

<pre><code>int main()
{
  char tmp[]=""123456789"";
  printf(""1  %1s\n"", tmp);
  printf(""2  %2s\n"", tmp);
  printf(""4  %4s\n"", tmp);
  printf(""8  %8s\n"", tmp);
  printf(""16 %16s\n"", tmp);
  printf(""32 %32s\n"", tmp);
  return 0;
}
</code></pre>

<p>output from  gcc 3.4.2 on Solaris 5.9:</p>

<pre><code>&gt; ./a.out                   
1  123456789                       
2  123456789                       
4  123456789                       
8  123456789                       
16        123456789                
32                        123456789
</code></pre>

<p>sprintf() will duplicate and truncate a string then it can be sent to printf.  Or if you don't care about the source string:</p>

<pre><code>char * trunc(char *src, int len)
{
    src[len]=0x0;
    return src;
}
</code></pre>

<p>References: INTERNATIONAL STANDARD ?ISO/IEC ISO/IEC 9899:TC2, WG14/N1124 Committee Draft ¡ª May 6, 2005</p>
",1
4737178,4737137,7,"<p>Change:</p>

<pre><code> scanf(""%s"",&amp;file_name);
</code></pre>

<p>to:</p>

<pre><code> scanf(""%s"", file_name);
</code></pre>

<p>You also need to change:</p>

<pre><code> printf(""%s"",a[i]);
</code></pre>

<p>to:</p>

<pre><code> printf(""%d"", a[i]);
</code></pre>

<p>(and while you're at it, change <code>void main</code> to <code>int main</code>).</p>
",3
4737185,4737137,1,"<pre><code>scanf(""%s"",&amp;file_name);
</code></pre>

<p>you don't have to pass a pointer to <code>file_name</code> since it's already a pointer. Change this line to:</p>

<pre><code>scanf(""%s"", file_name);
</code></pre>
",0
8389128,8389096,3,"<p>That's how pointer arithmetic works in C. Adding 'X' to a pointer actually means adding the size of the pointee X times to the starting memory location.</p>

<p>I think you can probably cast to a temporary <code>char *</code> and back, but I can't think of a reason.</p>
",1
8389152,8389096,1,"<p>If you have:</p>

<pre><code>T *p;
p += n;
</code></pre>

<p>then this is (roughly) equivalent to:</p>

<pre><code>T *p;
char *p2 = (char *)p;
p2 += n * sizeof(T);
p = (T *)p2;
</code></pre>

<p>In other words, the compiler effectively does multiplication for you.</p>
",0
8389157,8389096,1,"<p>When you add an integer to a pointer, the value of the pointer increases by the value of the integer times the size of the type pointed to by the pointer. If <code>sizeof(FILE_DIRECTORY_INFORMATION)</code> is 48, then adding one to a pointer shifts it by 48, adding 2 - by 2*48, and so on.</p>
",0
8403207,8403152,3,"<p>You should just pass the array directly. A function taking a <code>const</code> pointer just means that for that function, the argument will be a constant pointer. It doesn't say anything about if the data is const or not const at the point the call is made.</p>

<p>That said, it sounds strange that the code as posted should crash.</p>

<p>Do note that <code>fgets()</code> will keep the newline/linefeed character(s) from the input, which is probably not what <code>gethostbyname()</code> expects to see.</p>
",0
5587154,5587121,21,"<p>You need to change the destination pointer each time you call <code>memcpy</code>.</p>

<p>For example, suppose you have 4 bytes in <code>mainbuf</code> now. Next you receive 10 bytes. Here is how to append it:</p>

<pre><code>memcpy(mainbuf + 4, otherbuf, 10);
</code></pre>
",0
5587177,5587121,4,"<p>memcpy replaces memory, it does not append. If you want to use memcpy, your code will need to be a little more complex.</p>

<p>void * memcpy ( void * destination, const void * source, size_t num );</p>

<p>When you pass in mainbuf, you are passing the same destination address each time. You need to increment the destination address everytime you use memcpy so that it places it in subsequent memory, instead of overwriting the same string each time.</p>

<p>Try using strcat instead, it is designed to concatenate strings together, which sounds like what you want to do. Make sure you check you have enough memory left before you use it, so you don't encounter memory issues.</p>
",0
5587360,5587121,1,"<p>The description of the problem sounds like the appropriate use of <code>strcat</code>.  Strcat must be handled with care since it can easily write beyond the bounds of a buffer.  For that reason, here are variations like <code>strncat()</code> which can prevent buffer overruns¡ªif used correctly.</p>
",0
3485240,3485224,4,"<p>You're missing a null character to terminate the string. From Wikipedia's article on <a href=""http://en.wikipedia.org/wiki/Strcpy#strncpy"" rel=""nofollow noreferrer"">strncpy</a>.</p>

<blockquote>
  <p>strncpy writes exactly the given number of bytes, either only copying the start of the string if it is too long, or adding zeros to the end of the copy to fill the buffer. It was introduced into the C library to deal with fixed-length name fields in structures such as directory entries. Despite its name it is not a bounded version of strcpy, <strong>it does not guarantee that the result is a null-terminated string</strong>. The name of the function is misleading because strncat and snprintf are respectively bounded versions of strcat and sprintf. </p>
</blockquote>

<p>Adding the null character makes your program work:</p>

<pre><code>strncpy(rr, p1, nlen);
*(rr+nlen) = '\0';   // this line
printf(""%s\n"", rr);
</code></pre>

<p>I think your code could have a risk of a buffer overflow because <code>nlen</code> could in theory be greater than 200. Though this is not an issue in the program in your question because the input string is so short.</p>

<p>You might also want to look at <a href=""http://en.wikipedia.org/wiki/Strncat"" rel=""nofollow noreferrer"">strncat</a> which can be used to copy a string including the null character.</p>

<blockquote>
  <p>An alternative from the standard C library that will always append one null byte is to use strncat with an initially empty string as the destination.</p>
</blockquote>
",1
5555171,5555148,5,"<p>Are you including the header file from more than one place? Use a guard in the header file, if so.</p>

<p>For example, in Tilemap.h:</p>

<pre><code> #ifndef TILEMAP_H
 #define TILEMAP_H

 // header file contents

 #endif /* TILEMAP_H */
</code></pre>
",1
5555175,5555148,2,"<p>Stick some inclusion guards on your headers.</p>

<p>Your type definition is appearing more than once in your compilation unit.</p>
",0
5555180,5555148,2,"<p>You included the header file twice.</p>

<p>In my own code, I wrapped all header files with</p>

<pre><code>#ifndef HEADER_FILE_NAME
#define HEADER_FILE_NAME

#endif
</code></pre>

<p>to avoid such errors.</p>
",0
3933572,3933551,-2,"<p>Well a character constant is only one byte...</p>
",3
3933587,3933551,2,"<p>Along with other people's responces more somewhat related information can be found at <a href=""https://stackoverflow.com/questions/2172943/size-of-character-a-in-c-c"">this question</a>.</p>
",0
3933943,3933551,4,"<p>A character literal, such as <code>'a'</code>, will be treated as an integer literal, such as <code>97</code> or <code>0x61</code>.  C compilers tend to want every integer to be stored in an <code>int</code> unless told otherwise, so <code>sizeof('a')</code> will probably be <code>sizeof(int)</code>.</p>

<p>You should notice, though, that the value of <code>'a'</code> is less than 127 so it can be stored in a char (which has a maximum value of either 127 or 255 depending on if it is signed or unsigned on your compiler).  This is the same as being able to:</p>

<pre><code>unsigned long long x = 0;
unsigned int y = x;
</code></pre>

<p><code>y</code> is assigned from a <code>x</code> whose type is bigger than <code>y</code>'s type, but <code>x</code>'s value is well within those which <code>y</code> can represent, so no data is lost when the top bits (all 0s) are chopped off.</p>
",0
3864994,3864964,9,"<p>None of the code snippets would compile because you haven't declared/defined the functions before using them. </p>

<p>Furthermore even if you add the declarations above <code>main()</code> the behaviour of the snippets would still be undefined because you are using the returned value of a <code>non-void</code> function having no <code>return</code> statement.</p>
",2
3864997,3864964,5,"<p>You aren't returning sum in your add function.  </p>
",2
3865004,3864964,1,"<p><code>printf(""%d"",p);</code> is printing some garbage that <code>p</code> points to.
You should <em>return</em> <code>sum</code> from <code>add</code>:</p>

<pre><code>return sum;
</code></pre>
",0
3865046,3864964,1,"<p>Just by luck, or rather because you compiled them without optimization. ;-)</p>

<p>The results are actually undefined, and depend on the compiler and compilation options. In your setup the function add() happened to leave something on the stack at the place where main() expected a return value. Try with optimization and you will see the difference.</p>
",0
3112327,3112315,4,"<p>=, +=, etc, operators that have '=' in them, is right associated.</p>

<p>All others are left-associated.</p>
",1
3112331,3112315,2,"<p>Here's a <a href=""http://www.cppreference.com/wiki/operator_precedence"" rel=""nofollow noreferrer"">table of C++ operator precedence</a>.</p>

<p>The operator precedence and associativity are the same in C and C++ (modulo operators that don't exist in the former).</p>
",2
3112560,3112315,0,"<p>Read the standards</p>

<p>EDITED: I don't have the standards myself, but I've found <a href=""http://en.wikibooks.org/wiki/C_Programming/Reference_Tables"" rel=""nofollow noreferrer"">this link</a> supposed to be based on the standard.</p>

<p>Also, quoting Kernighan &amp; Ritchie:</p>

<blockquote>
  <p>Arithmetic operators associate left to
  right.</p>
  
  <p>Expressions connected by &amp;&amp; or || are
  evaluated left to right, and
  evaluation stops as soon as the truth
  or falsehood of the result is known.
  Most C programs rely on these
  properties.</p>
  
  <p>Operators Associativity</p>
  
  <p>() [] -> . left to right</p>
  
  <p>! ~ ++ -- + - * (type) sizeof right to left</p>
  
  <p>* / % left to right</p>
  
  <p>+ - left to right</p>
  
  <p>&lt;&lt; >> left to right</p>
  
  <p>&lt; &lt;= > >= left to right</p>
  
  <p>== != left to right</p>
  
  <p>&amp; left to right</p>
  
  <p>^ left to right</p>
  
  <p>| left to right</p>
  
  <p>&amp;&amp; left to right</p>
  
  <p>|| left to right</p>
  
  <p>?: right to left</p>
  
  <p>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= >>= right to left</p>
  
  <p>, left to right</p>
  
  <p>Unary &amp; +, -, and * have higher precedence than the binary forms.</p>
</blockquote>
",1
4093908,4093893,1,"<p>You are opening the same file for writing twice. All bets are off at that point.</p>
",0
4093909,4093893,0,"<p>I think it is because you opened c.dat through fs=fopen first and then some lock is not allowing ""a"" to be written, as it would require the file to be opened again.</p>
",0
4093934,4093893,1,"<p><em>You didnt specify the unerlying OS, but on win</em> and *nix systems file buffers are shared between processes, so :</p>

<pre><code>    putc('a',fp); 
    putc('1',fs);
</code></pre>

<p><em>are writing to exactly the same address in the same buffer
if you reversed the order of the putc statements you will end up with an 'a' in the file.</em>*</p>

<h2><strong>NOT</strong></h2>

<p>Just goes to show how tricky this all is. I have tried this and what affects the output is the order in which the files are opened -- the first open always takes precedence.</p>
",1
4093942,4093893,2,"<p>For a start, you don't <code>close()</code> a file that you opened with <code>fopen()</code>, you have to <code>fclose()</code> it. You're mixing two levels of abstraction here, file handles and file pointers.</p>

<p>On top of that, I think you'll find that the two file pointers are maintaining independent file offsets and buffers. Whichever one closes the file last will write their data last, overwriting the other.</p>

<p>Change the order of your <code>fclose()</code> statements and you should see what I mean:</p>

<pre><code>#include&lt;stdio.h&gt;
int main (void) {
    FILE *fp,*fs;
    fs=fopen(""c.dat"",""w"");
    fp=fopen(""c.dat"",""w"");
    fputc('a',fp);
    fputc('1',fs);
    fclose(fp);    // Try changing these
    fclose(fs);    //    two around.
    return 0;
}
</code></pre>

<p>I did that and consistently got the contents based on the last file closed.</p>

<p>And, before you say that you should have gotten <code>a</code> because <code>fp</code> was the last one you closed, you did <em>not</em> close <code>fp</code> (with an <code>fclose()</code>).</p>

<p>What you <em>did</em> do was try to <code>close()</code> a file handle that was almost certainly invalid, because file <em>handles</em> are generally relatively small values (e.g., <code>0</code>, <code>1</code>, <code>2</code>) while file <em>pointers</em> are generally relatively large values (e.g., <code>0xdeadbeef</code>, <code>0xcaf3f00d</code>).</p>

<p>So the closure of both those files was left up to the C runtime environment when you exited (and that would most likely have done it in a deterministic way, which is why you always got the same value in the file).</p>
",1
3572729,3572688,0,"<p>You have no definition for <code>struct k</code> visible from <code>a.c</code>. Put the definition in a header file and include it from all three source files.</p>
",0
3572777,3572688,0,"<p><code>struct k</code> is a description of <em>how to build</em> an object. It is not an object. <code>extern</code> operates on objects. </p>

<p>Usually <code>struct</code> blocks are placed in a header, or <code>.h</code> file.</p>

<p><code>j</code> is an object of type <code>k</code>. It should be declared <code>extern</code> in either <code>1.c</code> or <code>2.c</code>.</p>

<p>Functions which are used among multiple files, like variables, should be declared before use.</p>

<p>Putting it all together, you might want</p>

<pre><code>//a.c---

#include &lt;stdio.h&gt;
#include ""k.h"" /* contains definition of struct k */

extern int c;
extern k j;

extern void fun1();
extern void fun2();

int main()
{
  extern int a,b;
  fun1();
  fun2();
  c=10;
  printf(""%d\n"",c);

  j.id=89;
  j.m=43;
  printf(""\n%d\t%f"",j.id,j.m);
}
</code></pre>
",2
3572786,3572688,0,"<p>Some of your concepts are wrong. Please check this <a href=""https://stackoverflow.com/questions/1433204/what-are-extern-variables-in-c"">link</a>.</p>

<p>To access a variable as extern you have to first define it, which you have not done in your case. </p>
",0
3581084,3572688,-1,"<p>The <code>extern</code> modifier changes the <em>linkage</em> of the variable that you are declaring or defining.  In C, only variable names can have linkage - not types, like <code>struct k</code>.</p>

<p>If you wish to access the internals of a <code>struct</code> type, it must be fully defined in the same source file.  The usual way to accomplish this for types that are shared between source files is to place the definition of the <code>struct</code> into a header file, which is included with <code>#include</code> into each source file.</p>
",0
3852498,3852480,3,"<p>One problem with global variables is that wherever they are used, you may not have <a href=""http://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29"" rel=""nofollow"">referential transparency</a>.    And it is a good thing to know that given certain input a function will produce certain output for several reasons.</p>

<p><a href=""http://c2.com/cgi/wiki?GlobalVariablesAreBad"" rel=""nofollow"">This page is a good resource</a> for several other reasons why global variables are bad though too. </p>
",0
3852504,3852480,0,"<p>Although C gives you complete freedom to declare everything global it will help you with your coding and maintenance if you think in terms of ""<a href=""http://en.wikipedia.org/wiki/Abstract_data_type"" rel=""nofollow"">abstract data type</a>"" which can be implemented in procedural languages as well. </p>

<p>Essentially, instead of making all data as static global to all modules, you can make data global in a particular module. </p>
",0
3852510,3852480,1,"<p>Use global variables if its extremely needed. If you have something that's needed on a global scope, then feel free.</p>
",0
3852534,3852480,2,"<p>Usually most programmers expect the functions to be <code>pure</code>, meaning that the output of a function will be completely determined by its input. By giving them states you can introduce much confusion for others that will be using your code. This reffers to the <code>static</code> variables declared in functions.</p>

<p>And for real global variables (those declared outside of functions), it's what Ruel said. Be careful although about multithreading.</p>
",0
3852948,3852480,1,"<p>Rectifying the situation caused by a yucky mess of globals is like normalizing the design of a relational database schema.</p>

<p>There is always the option of lumping all the globals into one big struct and pass that struct around. But then, what's the point?</p>

<p>You would like to group them into structs and then you start discovering, ""hey I need this info in the other struct too because one silly function needs it."" Then you thought you solved the problem by merging the two structs. Then you found that finally, you're still stuck with a big piece of struct.</p>

<p>Why? Because like database normalisation, your struct normalization has to be done in concert, in conspiracy with the processes (aka your functions). You should construct an entity relationship about your information. Even though you are not writing using an oop language, you should still use systems-analysis methods bordering on oop. The difference between a programmer-analyst and a plain vanilla programmer is that a programmer-analyst performs rigorous data and process analysis of the project. Whereas, the plain vanilla programmer does happy-go-lucky programming.</p>

<p>For example, I would like to write a routine to control the printers in the company. There are</p>

<ul>
<li>old ribbon-impact teletypes (holy cow!),</li>
<li>dot-matrix (do they still use those?),</li>
<li>colour-jets,</li>
<li>grey-jets,</li>
<li>grey-lasers and,</li>
<li>colour-lasers</li>
<li>fax/scan combos of jets and lasers.</li>
</ul>

<p>And these are the functionality</p>

<ul>
<li>find an appropriate printer for a job request</li>
<li>reroute a job from a failed printer</li>
<li>a job request can from a schedule, a desktop or a fax server</li>
<li>route a scanner output to a fax server</li>
<li>scan for ink, pigment levels for replacement</li>
<li>for obsolete ribbon types, predict ribbon replacement</li>
<li>maintain maintenance schedule</li>
</ul>

<p>The simple approach is to have all the information placed into a huge pool of globals and then extern them all over the place. The advantage is you have the freedom to write functions unrestricted - restricted only by your ability to remember where all the variables are. Or the ability of someone else to find them.</p>

<p>Or, you could simplify your life and learn the simple tricks of entity normalization. Remember, entity is not just the data but the process/functions as well. At the end of such an exercise, you would begin to wonder in amazement how you could have survived thus far in life without an oop language like c++.</p>

<p>Let me exemplify below with a simplistic (perhaps, incomplete) implementation. When you plan your project in ER, and document it, it makes your programming and enhancement a lot easier. During this age of agile engineering, you have to be able to release usable partial implementation of a project. e.g., you would tell your project manager the following milestones</p>

<ul>
<li>Week1 : Usable Printer routing for inkjet and laser printers</li>
<li>Week2 : Usable Printer routing for archaic impact printers</li>
<li>week3 : Usable scan jobs</li>
<li>week5-7 : Usable fax jobs</li>
<li>week8 : Half-baked job rerouting</li>
<li>week9 : 90% baked job rerouting</li>
<li>week9-11 : half-baked maintenance</li>
</ul>

<p>With the schema of your information and processes drawn out, you will have a clear idea what constitutes a usable release and what to do on next iteration. With a well-planned schema, you would find it emotionally impossible to use globals. You would even then have a schema of globals rather than have them unstructured. Reserve globalising a structure for information that absolutely and necessarily require a single point of access - like a database pool, start-up flags to avoid starting up processes that are already started, etc.</p>

<p>Then, unless you are writing embedded or kernel code, you would very soon be moving to C++, guaranteed.</p>

<pre><code>struct Printer{
  id,
  printType,
  location,
  *maintenance,
  *driver
}

struct Job{
  type,
  requestor,
  location
}

struct Location{
  building,
  floor,
  suite,
  lane
}

struct PrintType{
  ink,
  colour
}

struct JobStatus{
  job,
  location,
  endStatus
}

struct Maintenance{
  inkLevel,
  schedule
}

union InkLevel{
  HPDeskJetInk,
  HPLaserJetInk,
  OlivettiFabric,
  BrotherCellophane,
  etc, etc
}

enum Ink{
  FABRICImpact,
  CELLOPHANEImpact,
  INKJet,
  LASER
}

enum Colour{
  GREY,
  COLOUR
}

enum EndStatus{
  PRINTING,
  COMPLETED,
  FAILED,
  REROUTED
}

/* print will look at Job to determine the appropriate location */
JobStatus* print(job);

/* a callback to requestor indicating completion status */
JobStatus* printCallback();

/* a fax send event detected and fax function will find the appropriate server for the Job */
JobStatus* fax(job);

/* a photocopy to file job */
JobStatus* scan(job);

Maintenance* maintain(Printer);
</code></pre>
",0
3856528,3852480,-6,"<p>It's bad to use any global variables in any language.</p>
",1
3845410,3845402,2,"<p>Because they're unnecessary.  Preprocessor directives only exist on one line, unless you explicitly use a line-continuation character (for e.g. a big macro).</p>
",0
3845412,3845402,3,"<p>Because Preprocessor directives are lines included in the code of our programs that are not program statements but directives for the preprocessor.</p>

<p>These preprocessor directives extend only across a single line of code. As soon as a newline character is found, the preprocessor directive is considered to end. That's why no semicolon (;) is expected at the end of a preprocessor directive. </p>
",0
3845413,3845402,7,"<p>The reason is that preprocessor directives don't use semicolons. This is because they use a line break to delimit statements. This means that you cannot have multiple directives per line:</p>

<pre><code>#define ABC #define DEF // illegal
</code></pre>

<p>But you can have one on multiple lines by ending each line (except the last) with a \ (or /, I forget).</p>
",0
3845421,3845402,3,"<p>Preprocessor directives are a different language than C, and have a much simpler grammar, because originally they were ""parsed"", if you can call it that, by a different program called <code>cpp</code> before the C compiler saw the file.  People could use that to pre-process even non-C files to include conditional parts of config files and the like.</p>

<p>There is a Linux program called ""unifdef"" that you can still use to remove some of the conditional parts of a program if you know they'll never be true.  For instance, if you have some code to support non-ANSI standard compilers surrounded by <code>#ifdef ANSI/#else/#end</code> or just <code>#ifndef ANSI/#end</code>, and you know you'll never have to support non-ANSI any more, you can eliminate the dead code by running it through <code>unifdef -DANSI</code>.</p>
",0
3845452,3845402,1,"<p>and if you use <code>#define MACRO(para) fun(para);</code> it could be WRONG to put an semikolon behind it.</p>

<pre><code>if (cond) 
  MACRO (par1);
else
  MACRO (par2);
</code></pre>

<p>leads to an syntactical error</p>
",0
3846473,3845402,2,"<p>During compilation, your code is processed by two separate programs, the pre-processor and the compiler. The pre-processor runs first.</p>

<p>Your code is actually comprised of two languages, one overlaid on top of another. The pre-processor deals with one language, which is all directives starting with ""#"" (and the implications of these directives). It processes the ""#include"", ""#define"" and other directives, and leaves the rest of the code untouched (well, except as side effect of the pre-processor directives, like macro substitutions etc.).</p>

<p>Then the compiler comes along and processes the output generated by the pre-processor. It deals with ""C"" language, and pretty much ignores the pre-processor directives.</p>

<p>The answer to your question is that ""#include"" is a part of the language processed by the pre-processor, and in this language "";"" are not required, and are, in fact, ""extra tokens"".</p>
",0
3016756,3016625,1,"<p>Use a debugger, for example, <a href=""http://www.gnu.org/software/gdb/documentation/"" rel=""nofollow noreferrer"">GDB</a>.</p>

<p>Shameless plug - take a look at <a href=""http://www.fetissov.org/public/gdb/"" rel=""nofollow noreferrer"">my GDB intro presentation</a> at <a href=""http://www.nycbug.org"" rel=""nofollow noreferrer"">New York City BSD User Group</a> - there are plenty of examples of Fibonacci stack traces there.</p>
",0
3845424,3845415,2,"<p>I case of <code>""...""</code> compiler first search the header file in your local directory where 
your .c file presents</p>

<p>while in case of <code>&lt;...&gt;</code> compiler only search in header file folder </p>
",0
3845425,3845415,7,"<p>The second version is specified to search first in an implementation defined location, and afterwards if the file is not found, search in the same place as the <code>&lt;...&gt;</code> version, which searches in the paths usually specified by the <code>-I</code> command line option and by built-in include paths (pointing to the location of the standard library and system headers). </p>

<p>Usually, implementations define that location to be relative to the location of the including file.</p>
",0
3845430,3845415,13,"<p><code>&lt;stdio.h&gt;</code> searches in standard C library locations, whereas <code>""stdio.h""</code> searches in the current directory as well.</p>

<p>Ideally, you would use <code>&lt;...&gt;</code> for standard C libraries and <code>""...""</code> for libraries that you write and are present in the current directory.</p>
",3
3845434,3845415,2,"<p><code>#include &lt;something.h&gt;</code> is meant for system headers, while <code>#include ""something.h""</code> is for headers of your own program. System headers are searched for in usual system directories (and those included with <code>-I</code> argument), which your headers are searched for in current directory and then the same locations as system headers.</p>

<p>see <a href=""http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC6"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC6</a></p>
",0
3845436,3845415,2,"<p>For the compilers I've used, ""..."" starts looking for the include file in the same directory as the source file that is being compiled, then the include path. Includes with &lt;...> start in the include path, skipping the current die unless it is in the include path.</p>
",0
3845439,3845415,2,"<p>Normally standard header files are enclosed by &lt; > and other user specific files are specifed with "" . </p>
",0
3845440,3845415,3,"<p>The &lt;> tell the compiler to look for the file in the libraries' headers and """" tell it to look around among your application's headers.</p>

<p>As for why both of them works for you, maybe your compiler also looks for the filename in the library headers in case it didn't find one among yours.</p>
",0
3845495,3845415,0,"<p><code>&lt;stdio.h&gt;</code> refers to a header (not a <em>header file</em>)<br>
<code>""stdio.h""</code> refers to a source file.</p>

<p>Headers need not exist phisically in the implementation; the way they are identified is implementation-defined (usually the headers are files on specific directories)</p>

<p>When the directive uses <code>""</code>, the source file is searched in an implementation-defined manner and, if not found, the directive is reprocessed as if it was written with <code>&lt;</code> and <code>&gt;</code> in the first place.</p>
",4
3845514,3845415,0,"<p>The difference is that header files made by the developer are enclosed by """". Header files that are already in the system are enclosed with &lt;>. Even the &lt;> headers need the -I directive if the directories that are placed are not in the search path of the compiler.</p>

<p>Bottom line: Your headers with """", system headers with &lt;></p>
",0
3845536,3845415,3,"<p>You use #include  when you want to say: ""look for a file with this name in the system's include directory"". You use #include ""doublequoted"" when you want to say: ""look for a file with this name in my own application's include directory; however, if it can't be found, look in the system's include directory"".</p>
",0
7489489,7489464,6,"<p><code>char *string</code> creates a variable which <em>can</em> hold a pointer to a string, but it is not set here.  So it points to a random location which, when accessed, segfaults.</p>

<p>To be useful, either allocate some memory and assign that to the pointer:</p>

<pre><code>char *string = malloc(1000);  // big enough for string
</code></pre>

<p>or, do it all at once:</p>

<pre><code>char string[1000];
</code></pre>

<p>Ideally, instead of using a hardcoded constant (like my example <code>1000</code>) use a symbolic constant, or better yet, find out how long the string needs to be and then use that.</p>
",3
7489506,7489464,2,"<p>There are several problems with your code, which I highlighted:</p>

<p>-you don't allocate memory for the string</p>

<p>-you try to access an array element which is out of bounds</p>

<p>-you forgot to decrement n, so you'll have an infinite loop</p>

<p>Remember that arrays in C are 0-based.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main (int argc, char **argv)
{
        char *string = malloc(100); //forgot to allocate memory
        int n;
        printf(""Enter a string\n"");
        scanf(""%s"",string);
        printf(""\n"");
        n = strlen(string);
        printf(""%d"",n);
        while(n != 0)
        {
                n--; //forgot to decrement here, so infinite loop
                     //crash was also from here, string[n] is not a valid index
                printf(""%c"",string[n]);
        }
        return(0);
}
</code></pre>
",2
7489532,7489464,2,"<p><code>%s</code> with <code>scanf</code> does not allocate anything.  The caller is supposed to allocate.  Even if you <i>were</i> allocating something, since you don't know how big the string in the input stream is going to be, this is akin to doing <code>gets</code>, which is bad for security and stability reasons.</p>

<p>One of the simplest things you can do is have a pre-set constant amount of characters and use fgets:</p>

<pre><code>char string[256];

if (!fgets(string, sizeof(string), stdin))
{
   // TODO: handle error
}
</code></pre>

<p>This puts an artificial limit to the maximum size of the string.  Another approach would be to use dynamic memory.  Here's just a quick example that grows the buffer as-needed.</p>

<pre><code>char *buf = NULL;
size_t current_len = 0, current_alloc = 0;
int c = 0;
int should_continue = 1;

while (should_continue)
{
   // Read a character...
   c = fgetc(stdin);

   // If c is EOF or a newline, let's zero-terminate the buffer and terminate
   // the loop...
   if (c == EOF || c == '\n')
   {
      c = 0;
      should_continue = 0;
   }

   if (current_len + 1 &gt; current_alloc)
   {
      // Need to grow the buffer.
      void *newbuf;
      size_t newsize;

      newsize = current_alloc ? current_alloc * 2 : 256;
      newbuf = realloc(buf, newsize);
      if (!newbuf) { /* TODO: handle error */ }

      current_alloc = newsize;
      buf = newbuf;
   }

   // We've ensured capacity, now add the character.
   buf[current_len++] = c;
}

// TODO: use buf as string...

// Now free since we're done
free(buf);
</code></pre>

<p>As for reversing a string, this is just an example of a typical ""string manipulation, C-style"" way of doing things:</p>

<pre><code>// Reverse the string in-place...

void reverse(char *s)
{
   if (*s)
   {
      char *t = s + strlen(s) - 1;

      while (s &lt; t)
      {
         char u = *s;
         *s++ = *t;
         *t-- = u;
      }
   }
}
</code></pre>

<p>With this, after reading you can do:</p>

<pre><code>reverse(string);
puts(string);
</code></pre>
",2
7489537,7489464,0,"<p>Like @wallyk already said:</p>

<pre><code>char* string
</code></pre>

<p>is actually a pointer to a character. You must allocate memory for the string using either,</p>

<pre><code>malloc or calloc
</code></pre>

<p>so you can do something like:</p>

<pre><code>char* string;
string = (char*) malloc( 50 * sizeof(char) );
</code></pre>

<p>which will allocate 50 characters for string. If your string is more than 50 characters, simply allocate appropriately. </p>

<p>Another way to do this is instead of creating a pointer, you can (not dynamically) allocate memory as follows:</p>

<pre><code>char string[50]
</code></pre>

<p>That will also allocate 50 characters to string. </p>
",0
7494973,7489464,-1,"<p>You have declared the string as <code>char *</code> and you didn't assign the address, so it points to the variable address.</p>
",0
3840045,3839914,3,"<p>The behavior is undefined, meaning the compiler is free to handle the situation in any way it sees fit.  As far as the language standard is concerned, both Turbo C and gcc are doing the ""right"" thing.  </p>
",1
3839934,3839914,4,"<p>This is undefined behavior.</p>

<p>With an optimizing compiler, these 3 values might be optimized out as they are not used. It will print garbage.</p>
",0
3839951,3839914,0,"<p>In MingW-GCC: 3 garbage values.</p>

<p>In VC++ 2010: 0, 0, and a garbage value.</p>
",0
3839954,3839914,2,"<p>If there are insufficient arguments for the format, the behavior is undefined.</p>
",0
3839957,3839914,10,"<p>This code just shows that <em>Turbo C</em> is poor at optimizing code and puts everything on the stack, while <em>gcc</em> is more aggressive and keeps it in registers or throws it away all together because these three variables have no purpose.</p>

<p>Anyway, calling <em>printf</em> with a pattern that requires three arguments without providing these arguments, is a mistake.</p>

<p><strong>Update:</strong></p>

<p>As an explanation: I'm assuming that <em>printf()</em> will always take its argument from the stack since it's a function with a variable argument list. Or does anybody know any other calling convention for functions like <em>printf()</em>? Futhermore, I'm assuming there's no need to put anything else on the stack as there are no other variables. So this mistaken call of <em>printf</em> will print whatever is on top of the stack in <em>main()</em>. But there might be other architectures and calling conventions where my assumpations don't hold.</p>
",2
3840472,3839914,1,"<p>Your teacher is wrong, but not entirely.</p>

<p>Variables declared within a function are by default <code>auto</code> rather than <code>static</code>.</p>

<pre><code>int foo(void) {
    static int x;
    int y;
    auto int z;

    /* ...other code... */
}
</code></pre>

<p>This means that in the function above <code>y</code> is auto, just like z, even though the <code>auto</code> keyword is not used in its declaration.  The <code>auto</code> keyword is almost never used, by the way.  Many C (and C derivative language) programmers don't even know that <code>auto</code> is a keyword because it is used so infrequently.</p>

<p>Being an <code>auto</code> variable usually means that the variable is stored on the program's system stack or in registers or some mix of these.  It can be at different places at different times during the course of execution of the function, and local variables that are in registers are often pushed to the stack when another function is called.  Some local variables may even be optimized away, meaning that at some point the compiler was able to determine that a particular variable's future value was no longer needed to satisfy the input needs of the future code (or the variable doesn't change and its value is just encoded within instructions).  This complicates using debuggers on optimized code.</p>

<p>When you take the address of a local variable the compiler then tries to lock it down to a specific address (probably by storing it on the stack).</p>

<p>When most compilers look at your code they will see that the names of those local variables are not used after their declaration and may decide to just not store their values anywhere.  Even if it does store those values on the stack it may also push other values on the stack before setting up to call <code>printf</code>.  Just as the compiler does not have to keep the variables you named around it is also free to create it's own temporary variables.</p>
",0
3298037,3298004,6,"<p>You mean when entering input interactively?
In a windows shell, ctrl+z on a line on its own. In a *nix shell, ctrl+d. Or just put your input in a file and pipe it, then not only will eof be detected at the appropriate time but also you can automate your testing.</p>
",0
3298061,3298004,1,"<p>You should use CTRL+Z combination (or somehow input character with code 26, for example, by pressing ALT+2+6 on additional keyboard)</p>
",0
5508417,5508405,1,"<p>It translates to <code>chess = chess &amp; _board[i];</code> where &amp; is the bitwise AND operator.</p>
",0
5508418,5508405,4,"<p><code>&amp;=</code> is the compound <a href=""http://en.wikipedia.org/wiki/Bitwise_operation#AND"" rel=""nofollow"">bitwise AND</a> and assignment operator. What it does is that it takes the bits in <code>chess</code> (which is 8 bits as a <code>char</code>) and ANDs them with the corresponding bits of <code>_board[i]</code>. Then it assigns the results back to <code>chess</code>.</p>

<p>In effect, together with the loop this causes each bit of <code>chess</code> to be set if all of the values in <code>_board</code> has the corresponding bit set.</p>

<p>Further: since <code>_board</code> is 8 items times 8 bits, I 'll assume that each item represents a row and the bits of the item represent the columns a-h of that row. The presence of an 1 in a bit position represents <em>something</em> (we don't know what).</p>

<p>So the end result would be that <code>chess</code> contains an 1 in each of its 8 bits if and only if the <em>something</em> exists all rows on the corresponding column a-h of the chessboard.</p>
",2
5508419,5508405,1,"<p><code>&amp;=</code> is a combination AND and assignment.  Therefore <code>chess &amp;= _board[i]</code> is equivalent to <code>chess = chess &amp; _board[i]</code></p>
",0
5508420,5508405,0,"<p>It means take the bitwise <code>AND</code> of chess and _board[i] and set chess equal to that value.</p>
",0
5508428,5508405,6,"<p>The following statement:</p>

<pre><code>x &amp;= y
</code></pre>

<p>... is equivalent to:</p>

<pre><code>x = x &amp; y
</code></pre>

<p>... and, in the above, the ampersand (&amp;) is the ""bitwise and"".  The result of ""x &amp; y"" is a value that has a  1 in all the bits where both x and y have corresponding 1 bits, and everywhere else the bits are 0.</p>
",0
3060101,3060080,8,"<p>It declares <code>a</code> as a pointer to an array of 10 ints.</p>
",1
4597753,4597715,3,"<p>Convert to float before division</p>

<pre><code>h=((float)g)/600;
</code></pre>
",1
4597791,4597715,2,"<p>This is truncating to an integer: </p>

<pre><code> p=(g*100)/600;
</code></pre>

<p>Change that to </p>

<pre><code> p=(g*100)/600.0;
</code></pre>
",0
4597807,4597715,2,"<p>Since <strong>h</strong> is declared as an <code>int</code>, the line</p>

<pre><code>h=(g/600);
</code></pre>

<p>will use integer division, not floating point division.  Basically, this means that everything beyond the decimal point will be ignored.  For example, giving the example <code>450/600</code>, floating point division would give you <code>0.75</code>, whereas integer division would give you <code>0</code>.</p>

<p>The subsequent line</p>

<pre><code>p=(h*100);
</code></pre>

<p>takes this stored value of <strong>h</strong>, in this case <code>0</code>, and multiplies it by <em>100</em>.  Which is still <code>0</code>.</p>
",0
4597856,4597715,1,"<p>There are a <strong>lot</strong> of problems in this code.  </p>

<p>The percentage isn't being computed correctly because you're using integer math for the division; for example, if <code>g</code> is 500, the result of <code>g/600</code> would be 0, which gets assigned to <code>h</code> (also an integer). </p>

<p>There are several approaches:</p>

<ol>
<li><p>Change the types of <code>a</code> through <code>h</code> from <code>int</code> to <code>float</code> or <code>double</code> (and change the corresponding conversion specifiers from <code>%d</code> to <code>%f</code> in the <code>printf</code> and <code>scanf</code> calls);</p></li>
<li><p>Cast <code>g</code> as a float before dividing by 600, <em>or</em> divide g by 600.0 (<code>h</code> will still need to be typed as a float, or you can skip the that step and simply write <code>p = ((float) g / 600) * 100.0;</code></p></li>
</ol>

<p>As far as everything else:</p>

<ol>
<li><p>In a hosted implementation, <code>main</code> returns <code>int</code>, not <code>void</code>.  Unless your compiler documentation specifically says that <code>void main()</code> is supported, use <code>int main(void)</code> or <code>int main(int argc, char **argv)</code> instead, otherwise you are invoking undefined behavior;</p></li>
<li><p><strong>NEVER NEVER NEVER NEVER NEVER NEVER</strong> use <code>gets()</code>; it <em>will</em> introduce a point of failure in your program.  It was officially deprecated with C99, and is expected to be gone from the next version of the standard.  Use <code>fgets()</code> instead.  </p></li>
</ol>
",0
3846372,3846345,2,"<p>You're using</p>

<pre><code>#include ""glossary_demo.h""
</code></pre>

<p>which is basically injecting the contents of <code>glossary_demo.h</code> into your code at compile-time. Your <code>glossary_demo.h</code> file isn't valid C, which is why you're getting all those errors.</p>

<p>It sounds like <em>really</em> you want to load a text file at execution time, which is very different.</p>
",2
3846381,3846345,0,"<p>You have tagged your question <code>C</code>, but <code>class</code> can be used only in <code>C++</code>, not <code>C</code>. </p>

<p>Your error is from file <code>glossary_demo.h</code>, please show contents of that.</p>

<p>BTW, it must be</p>

<pre><code>#include &lt;stdio.h&gt; (not &lt;stido.h&gt;)
</code></pre>
",0
8305437,8304619,4,"<ol>
<li>It's normal that a macro definition doesn't show up in GDB. It's because GCC replaces each <code>PI</code> with the actual pi value.</li>
<li>Yes. In your case, it doesn't hurt. If the .h file contains a prototype(they are typically called declarations) that uses a type that are defined in somewhere else, you can simply <code>#include</code> in your header files</li>
<li>Yes. You can declare what ever function prototype you want and it won't do any harm in terms of the functionality of your program. Compiler won't even check the existence of the definitions of those functions unless you actually call them from somewhere else.</li>
</ol>
",2
8304635,8304619,2,"<p>I'd declare PI in the header file and include this header file to all source files</p>

<p>You should place function declarations, macros in your header file (and maybe some simple inline functions)
Implementation should be placed in .c files</p>

<p>// I edited answer to response to your comment</p>
",3
8304643,8304619,1,"<p>You could create a global variable.</p>

<pre><code>//file1.c
int my_global;


//file2.c
extern int my_global;
//code using my_global...
</code></pre>

<p>Note that usage of preprocessor is mostly discouraged. </p>

<p>Also note that M_PI define suggested by others is not available in the latest C standard (C99) so you cannot rely on it.</p>
",3
6631379,6631355,3,"<p>I think your specific problem is that you're not re-initialising <code>i</code> to 0 each time you start the inner loop.</p>

<p>This is a relatively simple bubblesort where the inner loop runs over the list of <code>N</code> items, <code>N</code> times (controlled by the outer loop) to get them sorted. But <em>your</em> inner loop runs over them once then seems to go off elsewhere, beyond the end of the array. That's unlikely to provide useful results :-)</p>

<p>Your more general issue is: why are you not using the language facilities to do this, specifically <code>qsort</code>? If you're trying to educate yourself on sorting, that's fine, but if you just want to sort, there's little point re-inventing the wheel.</p>

<p>For what it's worth, I prefer the following algorithm in bubble sort. It stops early if the list is sorted and it doesn't look at already sorted items:</p>

<pre><code>void sort_by_name(){
    int i, didSwap = 1, limit = numitems - 1;
    patient *temp;

    while (didSwap) {
        didSwap = 0;
        for (i = 0; i &lt; limit; i++) {
            if (strcmp (pRecords[i]-&gt;name, pRecords[i+1]-&gt;name) &gt; 0) {
                temp          = pRecords[i];
                pRecords[i]   = pRecords[i+1];
                pRecords[i+1] = temp;
                didSwap = 1;
            }
        }
        limit--;
    }
}
</code></pre>

<p>The <code>didSwap</code> variable controls when to exit. If you traverse the entire unsorted section without swapping then obviously, you're finished. The <code>limit</code> controls that unsorted section and reduces gradually since, after each pass, there's a greater already-sorted section at the end of the list (the higher elements bubble up to the end of the list, one per pass).</p>
",12
6631385,6631355,0,"<p>I think you are trying to implement bubble sort. The loop count variables seem to be a bit off.</p>

<pre><code>        for(;i&lt;counter-1;i++){
</code></pre>

<p>should be</p>

<pre><code>        for(i=counter-2;i&gt;=j; i--){
</code></pre>

<p>You must reset the i after every iteration of the 'j' loop. And work backwards to have the smallest number bubble up to the front.</p>
",0
5140914,5140862,9,"<p>With root1, you've declared a local instance of a node, and it will be on the stack. You don't initialise it, so it will contain garbage.</p>

<p>With root2, you've declared a global instance. The default startup code will clear the memory that globals occupy.</p>

<p>With root, it will exist on the heap, and will contain garbage. It is pure luck whether the memory occupied contains 0 or not. If you use calloc instead of malloc, it will clear the memory for you.</p>
",3
5140944,5140862,0,"<p>When you allocate a new node, its sons aren't NULLed by default. They get garbage values.<br>
In addition, the assert macro is disabled if at the moment of including assert.h a macro with the name NDEBUG has already been defined. This allows for a coder to include many assert calls in a source code while debugging the program and then disable all of them for the production version by simply including a line like:</p>

<pre><code>#define NDEBUG
</code></pre>

<p>at the beginning of its code, before the inclusion of assert.h.</p>

<p>For example:</p>

<pre><code>#undef NDEBUG  
#include &lt;assert.h&gt;
</code></pre>
",0
5140946,5140862,4,"<p>Case 1:</p>

<pre><code>struct node *root = (struct node *) malloc(sizeof(struct node));
assert(root-&gt;left == NULL);   /* not failed. Why? */ 
assert(root-&gt;right == NULL);  /* not failed. Why? */
</code></pre>

<p>This is a fluke and will generally fail. There's no guarantee that malloced memory from the heap will be zeroed - you need to <code>calloc</code> for that. That said, many debug runtime libraries I have seen will zero allocated memory so I can believe this works for you in debug mode. This may vary between debug and release modes.</p>

<p>Case 2:</p>

<pre><code>static struct node root2;
</code></pre>

<p>Global variables are zeroed by default. I think this is guaranteed behaviour so this is correct.</p>

<p>Case 3:</p>

<pre><code>struct node root1;
assert(root1.left == NULL);   /* this failed. Why? */
assert(root1.right == NULL);  /* this failed. Why? */
</code></pre>

<p>This is allocated on the stack and left uninitialised. Again there's no guarantee about the values you're left with here so you would expect this to fail.</p>
",0
6637793,6637598,1,"<p>If it can't open the file it prints a message, but then continues. Instead it should return from main.</p>

<pre><code>if (fp == NULL) {
    printf(""cannot open file\n\n"");
    return 1;
}
</code></pre>

<p>fscanf will return the number of items parsed, so it's probably safer to stop reading when the number returned &lt; 4 (not all the items could be read).</p>

<p>Presumably ""data.dat"" contains multiple records and each line has a line ending. This means that after reading the first record the next character in the file is the line ending for the ""risk:0.0"" line. You should end the fscanf template with <code>\n</code>.</p>

<p>This is because the second time it tries to parse the file, fscanf will see that character, which it isn't expecting (the fscanf template starts ""name:""), so it will stop reading, and you'll get only the first record.</p>
",1
6637825,6637598,1,"<p>You should change the ""name"" format specifier from <code>%s</code> to <code>%19s</code> to make it read at most 19 characters (+terminating '\0'). The way you have it now is a guaranteed failure in case someone gives you 20+ character name.</p>
",0
6637731,6637598,-1,"<blockquote>
  <p>Can someone tell me what I can do to get it working?</p>
</blockquote>

<p>I suggest you separate the functionality in different statements.<br>
Don't try to cram all of the program functionality in 1 statement.</p>

<p>Your big statement is doing 3 things:</p>

<ul>
<li>it is reading data from file</li>
<li>it is comparing the return value of <code>scanf</code> with <code>EOF</code></li>
<li>it is controlling when to stop reading</li>
</ul>

<p>I suggest you do (at least) 3 different statements for the 3 different actions.</p>

<p><em>Hint: comparing the return value of scanf only with EOF is a little too short</em></p>
",0
5561067,5561050,5,"<p>It is used to manipulate the minimum width of the numerical value printed, and it specifically means that the width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.  In other words, if you wanted to use a width that was stored in a variable, you could do this:</p>

<pre><code>int width = /* something */;
printf(""%*d"", width, value);
</code></pre>

<p>EDIT:  Oops!  Correct syntax for sprintf is:</p>

<pre><code>sprintf(buffer, ""%*d"", width, value);
</code></pre>
",2
5561074,5561050,1,"<p>It is similar to <code>%2d</code>, which is ""print a 2 length integer"", except the length is specified as a parameter (not sure the order). <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/sprintf/"" rel=""nofollow"">Reference</a></p>

<blockquote>
  <p>The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.</p>
</blockquote>
",0
5561081,5561050,3,"<p>In the case of sprintf, it means you'll pass two integers, one specifies the field width, and the other the value you're going to convert.</p>

<p>IOW:</p>

<pre><code>sprintf(buffer, ""%5d"", value);
</code></pre>

<p>is essentially the same as:</p>

<pre><code>sprintf(buffer, ""%*d"", 5, value);
</code></pre>

<p>Much like when you're passing values as widths as literals in the format string, you can specify both a width and a precision if you want, something like this:</p>

<pre><code>sprintf(buffer, ""%*.*d"", 5, 2, value);
</code></pre>

<p>It's also worth noting that with <code>scanf</code> and company, a ""*"" in the format string has a <em>completely</em> different meaning (to convert some input, but <em>not</em> assign the result to anything).</p>
",1
5561118,5561050,1,"<p>The * refers to a the width or spacing of the integer in this case. The * is a place holder that lets you specify the width as an argument preceding the argument to be formatted (the integer in this case)</p>

<pre><code>printf(""The integer will be printed 10 spaces to the right: %*d"", 10, 50);
</code></pre>
",0
3924699,3924674,3,"<p><code>*f2+=*f1+=a+=2.5;</code></p>

<p>Same old Undefined Behaviour.</p>
",6
3924709,3924674,3,"<p>It's undefined behavior because the value of <code>a</code> is modified more than once in that string of assignments.  So what you might expect is meaningless.</p>
",0
3924724,3924674,3,"<p>This is undefined behavior according to spec 6.5/2 because you modify an object more than once between sequence point:</p>

<blockquote>
  <p>Between  the  previous  and  next 
  sequence  point  an  object  shall 
  have  its  stored  value modified at
  most once by the evaluation of an
  expression.  Furthermore, the prior
  value shall be read only to determine
  the value to be stored.</p>
</blockquote>
",1
3924755,3924674,0,"<p>It seems that it's translated to </p>

<pre><code>*f2 += 2;
*f1 += 2;
  a += 2.5;
</code></pre>

<p>and that <code>+=</code> is not so transitive as <code>=</code>.</p>
",1
3924758,3924674,3,"<p>For an actual understanding of the issue here try <a href=""http://c-faq.com"" rel=""nofollow"">comp.lang.c FAQ</a> article on <a href=""http://c-faq.com/expr/seqpoints.html"" rel=""nofollow"">sequence points</a>.</p>
",1
3118232,3116469,0,"<p>I found <a href=""http://www.somacon.com/p112.php"" rel=""nofollow noreferrer"">this</a> googling. It involves some knowledge (not much) of <a href=""http://en.wikipedia.org/wiki/Inter-process_communication"" rel=""nofollow noreferrer"">IPC</a>. This works only for Windows. In unix this can be done in a similar manner by using the corresponding unix IPC.</p>

<p><strong>LATER EDIT:</strong> Found also <a href=""http://www.codeguru.com/FORUM/showpost.php?p=1909555&amp;postcount=2"" rel=""nofollow noreferrer"">this</a>. It counts the number of processes having a given process name (Windows only).</p>
",0
3118318,3116469,0,"<p>One way is to access your operating system's process list and count how many occurrences of the executable appear.  But that could be fooled by multiple copies of the executable with different names.</p>

<p>To make sure you count all occurrences regardless of executable name, you could create a global shared memory object (protected with synchronized access, of course) where each instance registers its process ID.  Then you can parse that list and validate against the OS process ID list in case any of the instances died before unregistering themselves.</p>
",0
3697969,3697961,9,"<p>You can't have a static variable in your function to point to the next element of <code>str</code>, because <code>position</code> is a global variable that is initialized once, and <code>str</code> may have different value every time you call a function.</p>

<p>What you need here is a loop that iterates over <code>str</code>,</p>

<pre><code>void func1(char *str) {
    char *p;
    for (p = str; /* some condition here */; ++p) {
        /* Do something here to this position */
    }
}
</code></pre>

<p><em>or</em> have a loop outside this function and pass <code>str</code> incremented by 1 every iteration.</p>

<pre><code>void func1(char *str) {
    /* Do something here to this position */
}

void func2() {
    char *str = ...;
    ...
    char *p;
    for (p = str; /* some condition here */; ++p) {
        func1(p);
    }
}
</code></pre>

<p>Of course, you can initialize a static to <code>NULL</code> first and use it to check if you started iterating over <code>str</code>, but that's poor style: too stateful and error prone, not reentrant and not thread-safe.</p>
",0
3697979,3697961,7,"<p>What you need to do is find some way to decide if you're at the beginning of the string, in which case you reset <code>position</code>, or not, in which case you increment it:</p>

<pre><code>/*
 * In this function, I want the static variable position to point to next element
 * of the str, every time I call this function.
 */
void function(char *str){

   static char *position;

   if (str) {
       position = str;
   } else {
       /* Do something here to this position */
       position += 1;
   }
 }
</code></pre>

<p>Now when <code>str</code> is <code>NULL</code>, the function assumes that you're continuing to work with the same string as before, and when it's not NULL, it assumes that you're working with a new string.</p>
",1
3698157,3697961,5,"<p>This isn't really the C way of doing things - it isn't re-entrant for a start -but if you absolutely must:</p>

<pre><code>/*
 * In this function, I want the static variable position to point to next element
 * of the str, every time I call this function.
 */
bool function(char *str){

   static char *last_str;
   static char *position;

   if (str != last_str)
       last_str = position = str;

   /* Do something here to this position */

   if (*position != '\0')
       ++position;
   else
       last_str = NULL;

   return *position != '\0';
 }
</code></pre>

<p>You can then do things like:</p>

<pre><code>while (more) {
   // do something
   more = function(string);
}
</code></pre>
",0
3698944,3697961,1,"<p>As others have mentioned, using a <code>static</code> variable here is a bad idea.  I will elaborate a bit on the error however:</p>

<p>In C, variables with static storage duration (global variables and <code>static</code> variables) are initialized before program startup.  This therefore requires that the initial values be known ahead of time and must be compile-time constants.</p>

<p>It's a bit different in C++, and perhaps this is the behavior you're expecting.  Variables with static storage duration there may be initialized dynamically.  For global variables, this means in some unspecified order during program startup; for <code>static</code> variables within functions, this means that they are initialized when the function is first executed.</p>
",0
3698349,3697961,1,"<pre><code>static char *position = str;
</code></pre>

<p>The real reason behind this error is that since <code>position</code> is as a global variable it can only be initialized with a compile time constant. You'll get the same error if you try</p>

<pre><code>#include &lt;stdio.h&gt;
int j = 9;
static int k = j + 3; /* Error */
int main(){}
</code></pre>

<p>Both <code>j</code> and <code>str</code> are not compile time constants, hence the error.</p>
",0
3700483,3697961,1,"<pre><code>void func1();

char str[10] = ""good"";

int main()
{
   func1();
   return 0;    
}

void func1()
{
   static char *pos = &amp;str[0];

   pos++;

   (pos) ? printf(""%s\n"",pos) : 0;  
}
</code></pre>

<p>This program will do. I wrote the string in global area with ReadWrite region that is global initialization region and assign the starting address of the string inside the function. first call print ""ood"", second call print ""od""...</p>
",0
3717588,3717563,5,"<p>If by ""separate the procedure"" you mean ""put the IncomeTAX() function in a different source code file"", than perhaps you are failing to declare it before use. Put this in before <code>main()</code>:</p>

<pre><code>extern double IncomeTAX(double);
</code></pre>

<p>Normally this would live in <code>IncomeTAX.h</code>, the header file.</p>

<p>The reason you need this declaration is that otherwise C will default to using <code>int</code>; which causes problems since it can be of a different size than <code>double</code>.</p>
",3
3717598,3717563,2,"<p>Declaration and automatic typing.  If you don't declare the procedure before you use it, it assumes that it's an integer type.  Putting them in the same file has the added effect of the definition serving as the declaration.  If you would simply declare the procedure in the main file as returning a double that would work as well when you separate them.</p>

<p>FWIW, there's something poetic about an IncomeTax function returning <em>double</em>...</p>

<pre><code>#include &lt;stdio.h&gt;

double IncomeTAX(double i);

int main(void)
{    
    double a, b;

    printf  (""Enter the annual income: "");
    scanf   (""%lf"", &amp;b);

    a = IncomeTAX(b);

    printf (""Income Tax is %.2lf\n"", a);    
}
</code></pre>
",0
3717601,3717563,-1,"<p>Where you have 15/100 is an error. These two numbers are integers, and therefore return an integer, 0. Replace with 0.15 / 0.15f.</p>
",1
3717608,3717563,3,"<p>In the absence of a prototype, the compiler tries to be helpful and guess the right types of return value and arguments to functions.</p>

<p>Sometimes it guesses wrong (especially when types are not <code>int</code>).</p>

<p>Solution: always use prototypes to your functions and create header files if you're going to separate functions.</p>
",2
3717616,3717563,0,"<p>I'm assuming that by ""separate the procedute"", you mean move the procedure in a separate file.</p>

<p>In this case, the problem is likely because you aren't declaring your procedure before you use it. If you don't declare your procedure, the compiler will assume that all arguments are of type <code>int</code>.</p>

<p>What you need to do is declare your procedure as follows, somewhere before you call it.</p>

<pre><code>double IncomeTAX(double i);
</code></pre>

<p>The usual convention is to add it to a header file; for instance, if your <code>IncomeTAX()</code> procedure is defined in <code>tax.c</code> you would declare it in <code>tax.h</code>, and then in the file that includes <code>main()</code>, you would add:</p>

<pre><code>#include ""tax.h""
</code></pre>
",0
6946299,6946245,0,"<p>First of all, that <code>strcpy</code> call will likely cause a segmentation fault (and <em>definitely</em> causes undefined behaviour) - you probably don't want <code>NULL</code> for the second parameter.  You don't need the cast for your call anyway:</p>

<pre><code>strcpy(gs_value.Name, """");
</code></pre>

<p>Will work fine, and is probably what you meant in the first place.  It may be that your compiler is <em>very</em> picky, and it's complaining about the cast from <code>unsigned char</code> to <code>char</code> - you can fix that by changing your structure appropriately.</p>
",3
3305297,3305274,15,"<p>It's because you're missing braces for your <code>while</code> loop. Without those braces, the only thing inside the <code>while</code> is the first <code>if</code> statement. That's why it's only counting blanks, because you go through the whole file doing that <em>one</em> <code>if</code> statement then, after exiting the loop, <code>c</code> is <code>EOF</code> so neither of the other two <code>if</code> statements will be true.</p>

<p>That was a tricky one, it's hard to see because the indentation looks like it should work but, unlike Python, the compiler doesn't use indentation to figure out where things are :-)</p>

<p>If you put a opening brace after the <code>while</code> and a closing brace before the <code>printf</code>, it should count everything.</p>

<p>In other words, this is what your compiler sees:</p>

<pre><code>while ((c = getchar()) != EOF) {
    if (c == ' ')
        ++b;
}
if (c == '\t')
    ++t;
if (c == '\n')
    ++nl;
</code></pre>

<p>whereas you want:</p>

<pre><code>while ((c = getchar()) != EOF) {
    if (c == ' ')
        ++b;
    if (c == '\t')
        ++t;
    if (c == '\n')
        ++nl;
}
</code></pre>
",11
3307844,3305274,0,"<p>I see a lot of ""always require braces"" here. That's fine, and it will prevent this from happening, but I tend to prefer to always use a good editor. Emacs, for example, will automatically indent C code to make this sort of thing very obvious. Your 2nd and third <code>if</code> statements wouldn't indent as far as they are.</p>

<p>Another alternative, if you dislike braces, is to use <code>else if</code> where you use <code>if</code>. Don't do that, but do understand it.</p>
",0
3911396,3911391,1,"<p>This works:</p>

<pre><code>#include &lt;stdio.h&gt;

int *top;
int a=1;
int main()
{
    top=&amp;a;
    printf(""%d\n"",*top);
}
</code></pre>

<p>You need to be sure not do global assignment like that. You can only do initialization, nothing else for global variables.</p>

<p>You also have not mentioned the other errors, please mention all errors, sometimes one error is based of another and when one is fixed the others get fixed. In this case it was:</p>

<blockquote>
  <p>Conflicting types for 'top'.</p>
</blockquote>
",0
3911418,3911391,4,"<p>I'm a bit surprised at the exact error message you got about it, but the problem (or at least one of the obvious problems) is that outside of a function, you're allowed to define and initialize variables, but you're <em>not</em> allowed to do a normal assignment -- that has to be done as part of executing a function. As such, your <code>top=&amp;a;</code> isn't allowed.</p>

<p>Another problem is that you have <code>main</code> returning <code>void</code>, where it should return an <code>int</code> (though most compilers will accept that without even a warning, not to mention an error message).</p>
",3
3911447,3911391,0,"<p>I honestly have no idea why that fails, but this works:</p>

<pre><code>#include &lt;stdio.h&gt;

int a = 1;
int* top = &amp;a;

void main()
{
    printf(""%d\n"", *top);
}
</code></pre>

<p>And remember: ALWAYS INITIALIZE YOUR POINTERS!!
If you're not going to assign them immediately, at least do something like this:</p>

<pre><code>int* top = 0;
</code></pre>
",0
3911451,3911391,0,"<p>Another option:</p>

<pre><code>#include &lt;stdio.h&gt;

int a=1;
int *top=&amp;a;

void main()
{
    printf(""%d\n"",*top);
}
</code></pre>
",0
3911495,3911391,3,"<p>Actually, from your original code: </p>

<pre><code>int *top;
int a=1;
top=&amp;a;
</code></pre>

<p>As others have mentioned - in global space you can declare, or declare and initialize. You can not do assignment.</p>

<p>What is actually happening in the line <code>top = &amp;a;</code> is that you are actually re-declaring a variable called <code>top</code>, and it defaults to the <code>int</code> type. The compiler should actually warn about creating a new variable named <code>top</code> that has the same name as a previously declared variable, as well as generate an additional warning that you are creating a variable of default type <code>int</code>. </p>

<p>In C, variables that are declared without a type default to <code>int</code>, and that would generate the error you see.</p>

<blockquote>
  <p>error C2440: 'initializing' : cannot convert from 'int *' to 'int'</p>
</blockquote>

<p>What this is really complaining about is that <code>top = &amp;a;</code> as in your code actually looks like <code>int top = &amp;a;</code> to the compiler, so you are trying to bind an <code>int*</code> to <code>int</code>.</p>
",0
3911497,3911391,6,"<p>You're actually tripping over the compiler's support for ancient C syntax.  The original C compiler allowed declarations without a type, defaulting it to int.  So outside of any function,</p>

<pre><code>foo;
</code></pre>

<p>would declare a global <code>int</code> variable called <code>foo</code>.  So when you say</p>

<pre><code>top = &amp;a;
</code></pre>

<p>it declares a global int variable called <code>top</code> and tries to initialize it with the address of <code>a</code>.  This gives you the two errors you see -- two conflicting declarations for <code>top</code> and an inability to convert an <code>int *</code> to an <code>int</code>.  Of course those same ancient C compilers would not give you the second error, happily converting the address to an int without complaint.</p>

<p>This also tells you why <code>int i; i = 100;</code> works --- its two declarations for <code>i</code> as a global <code>int</code> variable (which is ok, as they're the same type), and the second initializes it to <code>100</code> (which is ok as only one declaration has an initializer)</p>

<p>There's lots of fascinating stuff in Dennis Ritchie's <a href=""http://cm.bell-labs.com/cm/cs/who/dmr/chist.html"" rel=""nofollow"">The Development of the C Language</a></p>
",0
2948824,2948778,6,"<p>For integers, take the log10 of the number, round down, and add one.</p>

<p><strong>TEST:</strong></p>

<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int 
num_digits(unsigned long number)
{
    return (int)(floor(log10((double)number)) + 1.0);
}

int
main(int argc, char **argv)
{
    unsigned long test_numbers[] = {
        1, 9, 10, 99, 100, 999, 1000, 9999, 10000, 99999, 100000, 999999,
        123456789ul,
        999999999ul,
        0
    };

    unsigned long *ptr;
    for(ptr = test_numbers; *ptr; ptr++)
    {
        printf(""Number of digits in %lu: %d\n"", *ptr, num_digits(*ptr));
    }

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Number of digits in 1: 1
Number of digits in 9: 1
Number of digits in 10: 2
Number of digits in 99: 2
Number of digits in 100: 3
Number of digits in 999: 3
Number of digits in 1000: 4
Number of digits in 9999: 4
Number of digits in 10000: 5
Number of digits in 99999: 5
Number of digits in 100000: 6
Number of digits in 999999: 6
Number of digits in 123456789: 9
Number of digits in 999999999: 9
</code></pre>
",2
2948843,2948778,0,"<p>Two solutions for you!</p>

<pre><code>int digit_count(unsigned int n)
{
   if (n &lt; 10)
      return 1;
   else
      return (1 + digit_count(n / 10));
}
</code></pre>

<p>and</p>

<pre><code>   unsigned int n = 50;
   int i = 0;

HACK:
   i++;

   if (n &lt; 10)
   {
      printf(""Digits: %d\n"", i);
   }
   else
   {
      n /= 10;

      goto HACK;
   }
</code></pre>

<p>Don't hate me for the last one :(</p>
",5
2950925,2948778,1,"<p>One possible solutions, assuming 16-bit integer values and logical expressions evaluating to 0 or 1.  You could replace the conditions with <code>(u &gt; 99) ? 1 : 0</code> if you're worried about portability.</p>

<pre><code>int digits( unsigned u)
{
    return 1 + (u &gt; 9) + (u &gt; 99) + (u &gt; 999) + (u &gt; 9999);
}
</code></pre>
",0
7172370,7172352,2,"<p>The string is stored in read-only memory. The pointer itself is stored on the stack of <code>main</code>.</p>
",1
7172393,7172352,0,"<p>Your string sotred in the memory, and the pointer refer to the memory address wehere the string is stored. If you call this pointer it's return whit the memory address, and you can use this.</p>
",1
7172400,7172352,5,"<p>p is a local variable and typically resides on the stack.</p>

<p>The string is stored wherever the compiler decides to store it. Typically it will be in neither stack nor heap but rather in a read only area of the data segment of the executable image.</p>
",0
7178365,7172352,2,"<p>Unless your compiler documentation <em>explicitly</em> says that <code>void main()</code> is a legal signature, use <code>int main(void)</code> instead:</p>

<pre><code>int main(void)
{
  char *p = ""hello"";
  return 0;
}
</code></pre>

<p>Exactly where the memory for <code>p</code> and the string <code>""hello""</code> are allocated will vary with the implementation.  For both ELF and PE/COFF formats, the memory for <code>p</code> will be inside of the stack frame for <code>main</code> and the memory for <code>""hello""</code> will be in a read-only data segment (<code>.rdata</code> for PE/COFF, <code>.rodata</code> for ELF).  </p>
",0
4611804,4611791,7,"<p>There are only two guaranteed-to-work prototypes for the <code>main</code> function:  one takes no arguments (<code>int main(void)</code>), the other takes two arguments and looks like this:</p>

<pre><code>int main(int argc, char* argv[])
</code></pre>

<p><code>argc</code> is the number of arguments passed to the program, and <code>argv</code> is an array containing the arguments passed to the program.</p>

<p>If you want to pass an argument when you run the program (and not prompt the user for input), you will need to</p>

<ul>
<li>use the form of <code>main</code> taking arguments, </li>
<li>check to make sure <code>argc</code> is greater than one (<code>argv[0]</code> is the program name, or should be), </li>
<li>convert <code>argv[1]</code> from its string representation to an integer, using <code>strtol</code>, <code>sscanf</code>, or some other library function (avoid <code>atoi</code>: it provides no usable error reporting),</li>
<li>then use that integer.</li>
</ul>
",9
4611833,4611791,1,"<p>As you probably know, main() is a ""special"" function, which expects either 0 or two arguments: <code>int argc</code>, and <code>char **argv</code>, where <code>argc</code> is automagically assigned the number of arguments in the argument array <code>argv</code>. So, whatever arguments you pass to <code>main()</code> will be stored in argv, and that is from where you need to access your arguments.</p>

<p>This <a href=""http://www.crasseux.com/books/ctutorial/argc-and-argv.html"" rel=""nofollow"">link</a> should help. </p>
",0
4611863,4611791,0,"<p>Here is a correction to your code using the proper prototype for a Main with command line arguments.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char* argv[])
{
     if (argc &lt;= 1) 
     {
         printf(""No index given"");
         return 1;
     }
     int i = atoi(argv[1]); // convert string in argv[1] to integer
     int a = i*2;
     printf(""Mult by 2 %d"",a);
     return 0;
} 
</code></pre>
",7
4611864,4611791,1,"<p>The arguments you are passing into the program are text, and so main will receive them as strings. It splits the command line arguments by whitespace and passes them in as an array of strings, along with a number stating the number of parameters it is giving you. The program will always have at least one argument, the name of the file you ran the program as (which is in this case <code>""a""</code>). This string is always found at argv[0].</p>

<p>As the other answers stated, the correct signature for main is <code>int main(int argc, char* argv[])</code>. When you run <code>./a 10</code>, argc will be 2 and argv[1] will be the string <code>""10""</code>. You will need to convert this string to an integer to multiply it by 2, using something like <code>int i = atoi(argv[1]);</code> or <code>int i; sscanf(argv[1], ""%d"", &amp;i);</code>.</p>
",0
3444155,3444148,2,"<p>In C, as in as defined by the C standard? No.</p>

<p>In C, as in some specific implementation on a specific platform? Maybe.</p>
",6
3444229,3444148,11,"<p>Not in C as a language. In GCC as a compiler - look for <a href=""http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"" rel=""nofollow noreferrer""><code>__builtin_prefetch</code></a>.</p>

<p>You might be interested in reading <a href=""http://lwn.net/Articles/250967/"" rel=""nofollow noreferrer""><strong>What every programmer should know about memory</strong></a>.</p>

<h3>Edit:</h3>

<p>Just to clear some confusion - caches are physically separate memories in hardware, but not in software abstraction of the machine. A word in a cache is always associated with address in main memory. This is different from the CPU registers, which are named/addressed separately from the RAM.</p>
",2
3444337,3444148,2,"<p>As cache is a CPU concept and is meaningless for C language (and C language has targets processors that have no cache, unlikely today, but quite common in old days) definitely <strong>No</strong>.</p>

<p>Trying to optimize such things <em>by hand</em> is also usually a quite bad idea.</p>

<p>What you can do is keep the job easy for the compiler keeping loops very short and doing only one thing (good for instruction cache), iterate on memory blocks in the right order (prefer accesses to consecutive cells in memory to sparse accesses), avoid reusing the same variables for different uses (it introduces read-after-write dependencies), etc. If you are attentive to such details the program is more likely to be efficiently optimized by compiler and memory accesses be cached. </p>

<p>But it will still depend on actual hardware and even compiler may not guarantee it.</p>
",0
3444408,3444148,0,"<p>If you are trying to force something to be stored in the CPU cache, I would recommend that you avoid trying to do so unless you have an overwhelmingly good reason.  Manually manipulating the CPU cache can have all sorts of unintended consequences, not the least among them being coherency in multi-core or multi-CPU applications.  This is something that is done by the CPU at run-time and is generally transparent to the programmer and the compiler for a good reason.</p>

<p>The specific answer will depend on your compiler and platform.  If you are targeting a MIPS architecture, there is a <code>CACHE</code> instruction (assembly) which allows you to do CPU cache manipulations.</p>
",0
3444442,3444148,2,"<p>It depends on the platform, so if you were speaking to a company targetting current generation consoles, you would need to know the PowerPC data cache intrinsics/instructions. On various platforms, you would also need to know the false sharing rules. Also, you can't cache from memory marked explicitly as uncached.</p>

<p>Without more context about the actual job or company or question, this would probably be best answered by talking about what <strong>not</strong> to do to keep memory references in the data cache.</p>
",0
5536114,5536077,10,"<pre><code>volatile struct CalibrationPoints IntakeCalibrationPoints[10] = { { 0 } };
volatile struct CalibrationPoints DischargeCalibrationPoints[10] = { { 0 } };
</code></pre>

<p>This will initialise all elements to zero.</p>

<p>The reason that this works is that when you explicitly initialise at least one element of a data structure then all remaining elements which do not have initialisers specified will be initialised to zero by default.</p>
",6
5536118,5536077,1,"<p>You can use </p>

<pre><code>memset(IntakeCalibrationPoints, 0x00, sizeof( IntakeCalibrationPoints))
</code></pre>

<p>for example</p>
",0
5536122,5536077,1,"<p>you can try:</p>

<pre><code>struct CalibrationPoints struct;
memset ( struct, 0, sizeof(CalibrationPoints));
` 
</code></pre>
",0
5536146,5536077,2,"<p>First, I think you have a wrong notion of what 'intialize' means.</p>

<p>You see, when the system gives your program memory, it doesn't bother to clean up after the last program that used it. So, you can get zeroes, you can get seemingly random values, etc.</p>

<p>Now, your structures can't benefit from their data being randomly set, can they? So you initialize them: you give their members meaningful values, that make sense for your data. That can be all zeroes, or not. <strong>Initializing is setting a meaningful default</strong>, so to speak.</p>

<p>As for your question, you can use <code>memset()</code> to quickly zero-fill memory. Cheers! Hope I helped.</p>

<p><code>memset()</code>: <a href=""http://www.cplusplus.com/reference/clibrary/cstring/memset/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstring/memset/</a></p>
",0
6652643,6652533,1,"<p>You will have to first allocate memory for <code>structC</code> then you have to allocate memory to the pointers inside it (<code>*head</code>, <code>*tail</code>) and then you can assign value to <code>conn</code>.</p>

<p><em>So here is the detail on the 3 step procedure with explanation:</em></p>

<p><strong>Step 1:</strong></p>

<pre><code>structC *C = NULL;
C = (structC *) malloc(sizeof(structC));
</code></pre>

<p><code>C</code> is just a pointer to type <code>struct C</code> now, that means it just points to a memory of size of a pointer type somewhere on the stack. By using <code>malloc</code> what you are doing is allocating(reserving) a space of size <code>struct C</code> for it.</p>

<p><strong>Step 2:</strong></p>

<pre><code>   C-&gt;head= (structA *) malloc(sizeof(structA));
</code></pre>

<p>Now the pointer <code>head</code> inside the structure <code>C(structC)</code> again just points to a memory of size of an pointer, You need to allocate it a size of(<code>structA</code>) by using the malloc statement above.</p>

<p><strong>Step 3:</strong></p>

<p>Once <code>C-&gt;head</code> points to a memory big enough to hold a <code>strct A</code> you can now assign value of your choice to it.</p>

<pre><code>C-&gt;head-&gt;value_in_use = 100;
</code></pre>
",0
6652646,6652533,3,"<p>The first one in fact won't actually work.  You're trying to follow a head pointer from C, but you have no idea where that pointer points to (i.e. malloc is not recursive).</p>

<p>For the first case, you would need to do something like this:</p>

<pre><code>structC * c = malloc(sizeof(structC));
structB * b = malloc(sizeof(structB));
c-&gt;head = b;
c-&gt;tail = b;
b-&gt;next = NULL;
b-&gt;prev = NULL;
c-&gt;head-&gt;conn.value_in_use = 1;
</code></pre>

<p>Note that we do not have to allocate a structA separately, since there is one embedded in B.</p>
",2
6652675,6652533,0,"<p>I'm not really sure where to begin on this one. Note that <code>structA</code>, <code>structB</code>, and <code>structC</code> seem to represent different 'levels', so to speak, of your doubly-linked list implementation. <code>structA</code> represents the actual data or list members, <code>structB</code> represents a data member and its connections, and <code>structC</code> represents the entire list itself. Note also that <code>structC</code>  only contains <em>pointers</em> to values in the list. By allocating a <code>structC</code> as in your first code example, it will not contain any useful information or allocate space for members. You should immediately clear the memory because the pointers will not be valid. Thus, your first code example won't work. I would expect you would do something like (warning: untested code)</p>

<pre><code>structC* c = malloc(sizeof(structC)); // note: don't cast the pointer from malloc in C
structB* b = malloc(sizeof(structB)); // you now have a data member
memset(b, 0, sizeof(structB));
c-&gt;head = b;
c-&gt;tail = b;
b-&gt;conn.value_in_use = 1;
</code></pre>

<p>Now you have a list with one member in use.</p>
",0
6653480,6652533,0,"<p>You write to random memory in your second example, the adress-of operator (<code>&amp;</code>) is the culprit  (I'm surprised that error haven't been caught by the C-compiler). </p>

<p>In your third example, you just allocate memory for a <code>structA</code>, pointed to by <code>ua</code> that is not linked to anything resembling a tree structure. As you have implemented <code>structB</code>, memory for <code>conn</code> is part of the record, if memory for a <code>structB</code> is  allocated dynamically with <code>malloc</code>, then you get <code>conn</code> for free as part of the allocated memory. If a <code>structB</code> is created in static memory or on the stack as a ""normal"" (from the point of view of languages that don't use pointers or dynamic memory allocation) variable, then the record <code>conn</code> share that same memory.</p>

<p>I hope I didn't add to the confusion (sorry about my lacking English skills)</p>

<p>I can give you some good advice:</p>

<p>First: I recommend that you use more descriptive names as a start. Why not <code>root</code>, <code>node</code> and <code>data</code> for the structures.  </p>

<p>Second: I recommend reading a good beginners book about C. The C Programming language by Kernighan &amp; Ritchie is a classic, but don't deal much with pointers, it is reasonably easy to read for someone without any prior exposure to other programming languages, but not really a book to begin programming with. Pointers on C by Kenneth Reek concentrate on parts of C that is different from other programming languages, mainly pointers and the C memory model. Pointers on C also provide good implementations of basic data structures, like trees. As far as I know, there aren't any good articles on Internet for aspiring C programmers.</p>

<p>Third: Read a good book or web-page about data structures and the algorithms to use with them. I have seen some good web-pages about the subject, but I'm not able to find them now.</p>
",0
5614424,5614411,5,"<p>You want to do a strcpy and then a strcat:</p>

<pre><code>strcpy(concat, str1);
strcat(concat, str2);
</code></pre>

<p>strcat relies on there being a null terminator ('\0') to know where to begin. If you just malloc and strcat, it's going to do some nasty things.</p>

<p>And no, neither strcpy nor strcat will do any kind of implicit allocation or reallocation.</p>
",0
5614428,5614411,5,"<p>I would personally do the following:</p>

<pre><code>size_t length = strlen(str1) + strlen(str2) + 1;
char *concat = malloc(sizeof(char) * length);

if(concat == NULL)
{
    // error
}

snprintf(concat, length, ""%s%s"", str1, str2);
</code></pre>
",3
5614464,5614411,14,"<p>What <code>strcat(dest, src)</code> actually does is search for the a null byte starting at <code>dest</code> and going forward, and then write the <code>src</code> string there.</p>

<p>After <code>malloc</code>, the contents of memory are undefined, so your current code could do any number of things, most of them incorrect.  If you do <code>concat[0] = 0</code> before the <code>strcat</code>'s, then your code works but will have to search for the length of <code>str1</code> three times -- once for <code>strlen</code>, again for the first <code>strcat</code>, and last for the second <code>strcat</code>.</p>

<p>Instead though, I recommend using <code>memcpy:</code></p>

<pre><code>size_t len1 = strlen(str1), len2 = strlen(str2);
char *concat = (char*) malloc(len1 + len2 + 1);

memcpy(concat, str1, len1);
memcpy(concat+len1, str2, len2+1);
</code></pre>

<p>This takes advantage of the fact that you know from the start where you want the bytes of both strings to go, and how many there are.</p>
",2
3744902,3744899,5,"<p>Because C is not C++.</p>

<p>Because the C standard does not permit it.</p>

<p>Because it has no meaningful interpretation in C.</p>
",0
3744918,3744899,16,"<p>In C++, a struct is basically a class with all members public, so a static variable makes good sense there.</p>

<p>In C, a struct is a contiguous chunk of memory with fields. A static variable can not be created without changing that (as to implement a static you need to refer to a single memory location from all structs of that type), and that would be a big difference in complexity without much benefit.</p>
",2
7820693,7820586,0,"<p>The code looks ok, except for the very important fact that you are missing some headers.</p>

<p><code>strlen</code> is in <code>&lt;string.h&gt;</code>, and <code>malloc</code> is in <code>&lt;stdlib.h&gt;</code>.</p>

<p>Include those, turn on your compiler warnings (<code>-Wall</code> for GCC), change your <code>main</code> signature to:</p>

<pre><code>int main(void) { }
</code></pre>

<p>and actually return an int from it (or compile as C99, <code>std=c99</code> for GCC), and the problems should go away.</p>
",0
3559258,3559240,9,"<p>Try adding <code>-lm</code> to your linker command. Most of the math functions live in <code>libm</code> which needs to be explicitly linked in.</p>
",0
3559260,3559240,7,"<p>Link to libm.so, adding -lm to the compiler command line parameters.</p>
",2
6939769,6343514,1,"<p>For the above question answer is 4.<br>
Here you are type casting an integer pointer to a char pointer.<br>
That means now the integer pointer is holding chars.<br>
For the sizeof operator default argument is int.<br>
When you are passing like <code>sizeof((char *)(*p))</code> then it treats as <code>sizeof('a')</code>. This char a is promoted to an int. That's why you are getting 4.</p>
",0
6343533,6343514,6,"<p>No, you're asking for the size of a character <em>pointer</em> which is 4 in your implementation.</p>

<p>That's because you're casting the dereferenced <code>int</code> pointer <code>p</code> to a <code>char</code> pointer then asking for the size of that.</p>

<p>Breaking it down:</p>

<pre><code>sizeof((char *)(*p))
       |       \__/
       |         \_ Dereference p to get an int.
       \___________/
             \_____ Convert that to a char * (size = 4).
</code></pre>

<p>If you want to treat the first character of your <code>int</code> (which is, after all, a character array you've cast anyway), you should use:</p>

<pre><code>sizeof(*((char*)(p)))
</code></pre>

<p>That is the <code>int</code> pointer, cast back to a <code>char</code> pointer, and <em>then</em> dereferenced.</p>

<p>Breaking <em>that</em> down:</p>

<pre><code>sizeof(*((char *)(p)))
       | \________/
       |         \_ Get a char * from p (an int *)
       \___________/
             \_____ Dereference that to get a char (size = 1).
</code></pre>
",2
6343546,6343514,5,"<p>You are  getting the size of the result of the cast <code>(char *)</code>, which  is a char * with size of 4. Of course you could just have said:</p>

<pre><code> printf( ""%d"", sizeof(a[0]) );
</code></pre>

<p>and one rather wonders why you didn't?</p>
",0
6345285,6343514,0,"<p>Yes, on a 32 bit system the piece of code should show the size of <em>p to be 4.On a 16 bit it would show 2(not being highly used in application world these days, but can be a used in embedded world based on the requirement of a system).
You have done a cast to a char</em>, this will affect the data representation but not the memory occupied by the pointer pointing to your data.</p>
",0
3449724,3449318,2,"<p>When you say ""compiles and runs fine"" what you really mean is (a) that you are ignoring compiler warnings and (b) the code <em>appears</em> to ""run fine"". Your compiler should be generating several warnings, e.g.</p>

<pre><code>ub.c:2: warning: return type defaults to ¡®int¡¯
ub.c: In function ¡®main¡¯:
ub.c:3: warning: implicit declaration of function ¡®gets¡¯
ub.c:4: warning: implicit declaration of function ¡®puts¡¯
ub.c:5: warning: control reaches end of non-void function
</code></pre>

<p>Also if you try this on more than one platform you'll find that it will not always ""run fine"" - it may well print garbage and/or crash.</p>
",3
3449342,3449318,3,"<p>That's because you just called <code>gets()</code> with the correct parameter and the call to <code>puts()</code> finds the stack unchanged. On CPUs with many registers this will probably break unless <code>gets()</code> doesn't use the register which contains the first argument. Compile with optimization enabled, that might be enough.</p>

<p>If you put any function call between the two, it will break too.</p>

<p>A clean way with the same amount of code would be:</p>

<pre><code>puts(gets(&amp;i));
</code></pre>
",1
3449353,3449318,0,"<p>Your <code>gets(&amp;i)</code> function is actually getting the string. <code>puts()</code> has no effect in the order you declared both statements.</p>
",0
3449398,3449318,0,"<p>By stack magic that it is not surely working on every machine and implementation. The <code>puts();</code> simply means you pass no argument, but something is on the stack, and it is the pointer to the string (by chance indeed); <code>puts</code> takes it (it does not know that you pushed nothing on stack, it simply ""believes"" you did) and does it work. Since it is up to the caller to clean the stack, everything goes fine (if it would have been a callee task, there would be problems). The fact that it works is a ""chance"", (likely to occur, but something you can't trust too much); the fact that it compiles, is determined by standard or compiler that warn but do not stop compilation (likely you can add option to respect strictly a specific standard, and then the code could fail to be compiled)</p>
",0
3450238,3449318,5,"<p>Old versions of C had implicit types for variables and functions, and this code makes use of that and some other stuff.  It also was very lax about actually returning values.</p>

<pre><code>main(i) // i is implicitly an integer (the default type for old C), and normally named argc 
// int main(int i) or void main(int i)
{ // The stack (which lives in high memory but grows downward) has any arguments and
  // probably the environmental variables and maybe even other (possibly blank/filler)
  // stuff on it in addition to the return address for whatever called main and possibly
  // the argument i, but at this point that could either be on the stack just under the
  // return address or in a register, depending on the ABI (application binary interface)


// extern int gets(int) or extern void gets(int)
// and sizeof(int) is probably sizeof(char *)
 gets(&amp;i); // By taking the address of i even if it wasn't on the stack it will be pushed to
           // it so that it will have an address (some processors have addressable registers
           // but they are rarely used by C for many reasons that I won't go into).


           // The address of i is either also pushed onto the stack or put into a register
           // that the ABI says should be used for the first argument of a function, and
           // and then a call is made to gets (push next address to stack; jump to gets)

           // The function gets does what it does, but according to the ABI there are
           // some registers that it can do whatever it wants to and some that it must
           // make sure are the same as they were before it was called and possibly one
           // or more where it is supposed to store a return value.
           // If the address of i was passed to it on the stack then it probably would be
           // restricted from changing that, but if it was passed in a register it may
           // have just been luckily left unchanged.
           // Another possiblity is that since gets returns the string address it was
           // passed is that it returns that in the same location as the first argument
           // to functions is passed.  

 puts();   // Since, like gets, puts takes one pointer argument it will be passed this
           // this argument in the same way as gets was passed it's argument.  Since we
           // were somehow lucky enough for gets to not overwrite the argument that we
           // passed to it and since the C compiler doesn't think it has anything new to
           // pass to puts it doesn't change any registers' values or do too much to the
           // stack.  This leaves us in the situation where puts is called with the stack
           // and registers set up in the same way as they would be if it were passed the
           // address of i, just the same as gets.

   // The gets call with the stack variable's address (so an address high on the stack)
   // could have left main's return address intact, but also could have overwritten it
   // with garbage.  Garbage as main's return address would likely result in a jump to
   // a random location (probably not part of your program) and cause the OS to kill the
   // program (possibly with an unhandled SIGSEGV) which may have looked to you like a
   // normal exit.  Since puts appended a '\n' to the string it wrote and stdout is
   // line buffered by default it would have been flushed before returning from puts
   // even if the program did not terminate properly. 
}
</code></pre>
",0
3432884,3432796,0,"<p>For #1:</p>

<p>In C, struct's have a separate name space.  So if you wrote:</p>

<pre><code>struct foo { ... };
</code></pre>

<p>You then have to use <code>struct foo</code> to reference the type.  If you tried just <code>foo</code> after the above definition, the compiler would give an error as it doesn't know anything about that unqualified name.</p>

<p>A <code>typedef</code> gives a type an alternate name.  A <code>typedef</code> name does not need to be qualified, so once you do:</p>

<pre><code>typedef struct foo foo;
</code></pre>

<p>You can now use an unqualified <code>foo</code> to reference the type.  Since it's just an alternate name, you can now use <code>struct foo</code> and <code>foo</code> interchangeably. </p>

<p>For #2.</p>

<p>It's possible that if you changed <code>val</code> to a <code>void *</code> it could change the size of the entire structure.  Whether that makes a difference will depend on how you've written the rest of your code.</p>
",2
3432832,3432796,0,"<p>&lt;1>
in C you need to specify struct node for structs</p>

<pre><code>    struct node 
    {
...
    } node;
</code></pre>

<p>the last 'node' is variable of type struct node
e.g. </p>

<pre><code>node.val = 1;
</code></pre>

<p>and not a type.</p>

<p>if you want to use 'node' as a type you need to write</p>

<pre><code>typedef struct node { .. } node;
</code></pre>

<p>&lt;2>
if you use void* you will need a mechanism to handle what the pointers point to e.g. if void* points to an integer you need keep the integer either on the stack or the heap.</p>

<pre><code>node n;
int value = 1;
n.val = &amp;value; // pointing to a single integer on stack

int values[]={1,2,3};
n.val = values; // pointing to an array of integers on stack

void* ptr = malloc(sizeof(int));
n.val = ptr;  // pointing to a single (uninit) integer allocated on heap
int* ptrval = (int*)ptr; // setting an int ptr to the same memory loc.
*ptrval = value; // ptrval now points to same as n.val does
</code></pre>

<p>&lt;3> 
reverse(node* head)
head is a pointer to your list, *head is the content of what the pointer points to (first node below)</p>

<blockquote>
  <p>head->[node next]->[node next]->[node
  next]</p>
</blockquote>

<p>EDIT: rephrased and edited.
EDITx2: apparently the question got edited and a typedef was added so the question was altered.</p>
",5
3432840,3432796,0,"<p><code>*head</code> is the dereference of the pointer : ie the actual place in memory that is pointed to by the pointer <code>head</code>...</p>

<p>Think of <code>head</code> as a coat hanger and <code>*head</code> as the coat itself, if that helps.</p>

<p>ie:</p>

<pre><code>struct * coat c; //this is a coat hanger, not a coat
....
struct coat k = *c;//this is the coat itself, not a coat hanger 
</code></pre>
",1
4537127,4537113,2,"<p>This happens because irrespective of when the <code>0</code> input is given you print all <code>5</code> numbers:</p>

<pre><code>for (int i =0; i &lt; arraylength; i++ )
</code></pre>

<p>To fix this you can print only the number(s) user entered before entering a <code>0</code> by running a loop from <code>0</code> to <code>i</code>:</p>

<pre><code>for (int j =0; j &lt; i; j++ )
</code></pre>
",0
4537130,4537113,1,"<p>Those 2 numbers are the garbage that was left in the memory locations for the last 2 parts of your array. You never initialise those when you only input 3 numbers, so when you go through and print all 5 elements in the array, it prints whatever garbage was in the memory.</p>
",0
4537145,4537113,1,"<p>You print all integers in array which is size of arraylength = 5. So you get 5 integers in output. As you didn't initialize array, you get uninitilized values as 4th and 5th elements of array. You can use <code>memset(&amp;input, 0, arraylength*sizeof(int));</code> to set initials values in array to 0.</p>
",0
3997153,3996848,2,"<p>You will always run a separate process when running it with 'stop' argument.
You need to find the running daemon and sending it a signal to stop it. When your deamon is started (option 'start'), you might want to store its pid somewhere so that when it is started with 'stop' option, it can retrieve the pid of the daemon and send it a signal to stop it. You can also parse the process table to find your daemon, but that will be more complex.</p>
",3
3998532,3996848,1,"<p>In most Linux distributions that I've come across, daemons are started and stopped via init scripts rather than direct invocation.</p>

<p>For example, on my Ubuntu box I can start and stop wicd by means of:</p>

<p>/etc/init.d/wicd start
   /etc/init.d/wicd stop</p>

<p>... which I think is what you want to do.</p>

<p>As some other people have noted, to stop a running process you will need to stash its PID somewhere, and then use that PID to send it a signal later on.  You <em>could</em> implement this yourself in a script, but most Linux distros provide helper applications to take care of that for you e.g. start-stop-daemon(8) on Debian-derived platforms (Redhat distros have something similar, but I can't remember the application name off the top of my head).</p>

<p>So if it were me, I would write a script to handle the starting and stopping of your C daemon, and I would base that script on one of the others in /etc/init.d as ar mentioned above.</p>
",0
3998728,3996848,2,"<p>Have a look at the <code>killall</code> command.  The <code>start</code> within a script often just looks to see if an instance of the program already exists, and if it doesn't it starts it.  The stop often just sends a signal to the service using the <code>killall</code> command.</p>

<p>Similar things that you may be interested in are editing or replacing the configuration files for a daemon and then sending the daemon the SIGHUP signal telling it that it should reread its configuration.</p>

<p>Another related topic is sending a daemon a particular message by calling the daemon's executable with some particular options.  This is done this way because the interface that the messages are sent in can change and if it is the same program doing the sending and receiving it is hard to get out of sync.  The method of sending messages can vary as well (Unix Domain Sockets, named pipe, editing a configuration file and sending SIGHUP, just about anything you could imagine).  One other benefit of this is that the same input verification that the program uses when it runs as a daemon can be used before it sends the message, so if there is an error that the daemon would choke on the instance of the program that you are calling from the command line could go ahead and tell you on the terminal and refuse to pass this on to the daemon.</p>

<p>To find the PID of a running service either use a pid file (daemon creates a file in a certain location with its PID in it -- just like old lock files, or do it the same way that <code>killall</code> does -- look through <code>/proc</code> (which is platform specific).</p>
",2
3453072,3452988,2,"<p>I think you wanted a struct, not a union for _data_block. The recursive union makes my head turn inside out. You have more problems, but this line:</p>

<p><code>cur=(anyT*)&amp;head-&gt;the_type;</code></p>

<p>suggests that you think <code>&amp;head-&gt;the_type</code> is different from <code>&amp;head-&gt;next</code>, which it isn't.</p>
",0
7817859,7817814,4,"<p>If you have an ASCII string, create an int array of size 256. Then loop through the string and increment the value in the int array on position x. While x is the ASCII value of the character in your string you're looping through.</p>
",17
7818600,7817814,1,"<p>if i have any mistakes like syntax please excuse as im working on vb , Im unable to figure out where to put braces or brackets ,</p>

<p>and I belive strchr makes your task easier </p>

<pre><code> #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;

 int str_occ (char *pch ,char a)
 {
   int  i = 0;
   char *p;
   p=strchr(pch,a);
   while (p!=NULL)
   {
     i = i+1;
     p = strchr(p+1,a);
   }
   return i;
 }
</code></pre>

<p>To explain the code *pch is the string you have to pass ,char a is the alphabet you are searching to find how many times its occurring and int i returns the value of number of occurrences</p>

<p>say sample</p>

<pre><code> int main()  
{
  char a[]=""hello world"";
  int i;
  i=str_occ(a,'l');
  printf(""%d"",i);
}
 output is 3
</code></pre>

<p>You can make the code as per your requirements, keep caling the function inside a loop , I mean rotate your elements </p>
",4
8223439,8223404,4,"<p>Yes, it's expected. A type cast doesn't change the variable, it reinterprets the value in memory as a different type.</p>
",0
8223553,8223404,0,"<p>value is not going to change but you are doing misunderstanding in prinf statement</p>

<pre><code>#include&lt;stdio.h&gt;

main()
{
  int const i=1;
  float k;
  k=(float)i; 
  printf(""in decimal %d\n"",i);
  printf(""in float %f \n"",(float)i);
  printf(""k is %f \n"",k);
  return 0;
}
</code></pre>

<p>see its output is </p>

<pre><code>in decimal 1
in float 1.000000 
k is 1.000000 
</code></pre>

<p>see <a href=""http://codepad.org/A2FWkncK"" rel=""nofollow"">http://codepad.org/A2FWkncK</a></p>

<p><strong>your mistake</strong> </p>

<pre><code> k=(float)i; 
</code></pre>

<p><strong>this statement wil not change the value of i but it will cast the value of i in float and then assign to k</strong></p>

<pre><code> printf(""%f"",i);
</code></pre>

<p>here you are printing int value by %f so it will give you wrong value</p>
",0
8223562,8223404,3,"<p>A cast doesn't ""cast a variable"".</p>

<p>A cast applies to an expression, that is first your value is evaluated and then it is converted to the other type.</p>

<p>(Also, the rest of your code is, well, improvable. Please have a look into the allowed prototypes for <code>main</code> and always put a <code>\n</code> at the end of a <code>printf</code>.)</p>
",0
8223617,8223404,4,"<pre><code>printf(""%f"",i);
</code></pre>

<p>will interpret i as a float. If you look in memory, you will see that i doesn't change, but rather the memory it's located at is reinterpreted:</p>

<pre><code>  int const i=1;
     0x0012FF60  01 00 00 00 //memory location of i
  float k;
  k=(float)i; 
     0x0012FF60  01 00 00 00 //i still the same
  printf(""%f"",i);
</code></pre>
",0
8223662,8223404,0,"<p>You code does not change the value of the <code>const</code> variable <code>i</code>.  It converts that value to a <code>float</code> and stores the result in <code>k</code>, but leaves <code>i</code> unmolested.</p>

<p>Your <code>printf()</code> call has undefined behaviour, because you have used the <code>%f</code> format specifier with an <code>int</code> argument (when it requires a <code>double</code>).  The reason that this is manifesting as <code>1.000000</code> is likely because your architecture's calling convention passes floating point values in a different location to scalar values, and that floating point location happens to still contain the value of <code>k</code> from the prior conversion.</p>
",0
6348848,6348734,2,"<p>In <code>-1l &gt; 1ul</code> the <code>-1l</code> is promoted to <code>unsigned long</code>, and by definition and Standard, -1 cast to an <code>unsigned</code> type will be the largets value representable by that <code>unsigned</code> type.</p>

<p>I got my inspiration from memory of <a href=""https://stackoverflow.com/questions/1863153/why-unsigned-int-0xffffffff-is-equal-to-int-1/1863219#1863219"">this answer here</a> to a quite relevant question.</p>

<p>And after looking at the C99 draft I have lingering around, see for example 6.3.1.3(2), where it says the maximum value representable by the type will be added or subtracted from the original value until it fits in the new type. I must warn you that <code>char</code>, although it is an integer type, is treated special: it is implementation defined if <code>char</code> is signed or unsigned. But that is, strictly, beside the question at hand.</p>
",1
6348910,6348734,1,"<p>Implicit promotions are one of the most difficult things in the C language. If you have a C code expression looking like</p>

<p>if(-1l > 1ul)</p>

<p>then no ""integer promotions"" take place. Both types are of the same size, but different signedness. -1l will then be converted to unsigned long with a very large value. This is one of the rules in the ""usual arithmetic conversions"". </p>
",1
6348938,6348734,0,"<p>When you're learning C, if you have a question, just write yourself a simple program:</p>

<pre><code>#include &lt;stdio.h&gt;
main() {
  int si = -1;
  unsigned int ui = 1;
  if ( si &gt; ui ) printf(""-1l &gt; 1u\n"");
  else           printf(""-1l &lt;= 1u\n"");
}
</code></pre>

<p>You'll see that <code>-1l &gt; 1u</code> is shown for the output.</p>

<p>Because both <code>si</code> and <code>ui</code> have the same rank (they're both <code>int</code>s), the rule says that the negative value will be promoted to unsigned at set to <code>UINT_MAX</code> which is the largest possible unsigned value.</p>
",5
6348983,6348734,1,"<p>This is actually a conversion. Promotions go from types with less rank than an integer to integer.</p>

<p>The rules for integer conversions in C are somewhat complex. They are, as per ISO C99 ¡ì6.3.1.8 ?1:</p>

<blockquote>
  <p>Otherwise, the integer promotions are
  performed on both operands. Then the
  following rules are applied to the
  promoted operands:</p>
  
  <p>If both operands have the same type, then no further conversion is
  needed.</p>
  
  <p>Otherwise, if both operands have signed integer types or both have
  unsigned
        integer types, the operand with the type of lesser integer conversion
  rank is
        converted to the type of the operand with greater rank.</p>
  
  <p>Otherwise, if the operand that has unsigned integer type has rank
  greater or
        equal to the rank of the type of the other operand, then the operand
  with
        signed integer type is converted to the type of the operand with
  unsigned
        integer type.</p>
  
  <p>Otherwise, if the type of the operand with signed integer type can
  represent
        all of the values of the type of the operand with unsigned integer
  type, then
        the operand with unsigned integer type is converted to the type
  of the
        operand with signed integer type.</p>
  
  <p>Otherwise, both operands are converted to the unsigned integer type
        corresponding to the type of the operand with signed integer type.</p>
</blockquote>

<p>I'll try to explain them:</p>

<p>Try to convert to the larger type. When there is conflict between <code>signed</code> and <code>unsigned</code>, if the larger (including the case where the two types have the same rank) type is <code>unsigned</code>, go with <code>unsigned</code>. Otherwise, go with <code>signed</code> only in the case it can represent all the values of both types.</p>
",2
3454261,3453131,0,"<p>It will give you the number of bytes added by the <code>apple_Build_BundleSeedIDPrefToken()</code> function.  (The total number of bytes that have been filled in the <code>UART_BUF[]</code> array is one more than that, because that statement won't count the byte at <code>UART_BUF[0]</code>.)</p>

<p>In general, subtracting two pointers of type <code>T *</code> into an array of elements of type <code>T</code> gives you the difference as the number of <em>elements</em> (rather than the number of bytes).  (The result is undefined if either of the two pointers do not point to either an element within the same array, or the element just past the last one.)  The result itself has a signed integer type, <code>ptrdiff_t</code>, which is defined in <code>&lt;stddef.h&gt;</code>.</p>

<p>However, here, both pointers are pointing into the same array of <code>unsigned char</code>, so each element is a byte by definition.</p>

<p>So, the expression <code>lcl_ptr - (unsigned char *)&amp;UART1_BUF[1]</code> will give the number of bytes added by the function.  (Note that <code>&amp;UART_BUF[1]</code> is of type <code>unsigned char *</code> already, so the cast inside the expression is unnecessary.)</p>

<p>That expression is then cast to <code>unsigned char</code>, which could in theory truncate the result, although it clearly doesn't in the above example.</p>

<hr>

<p>I note that the code is a little odd, in that it assigns to <code>UART_BUF[1]</code> three times!</p>

<ol>
<li><code>UART1_BUF[1] = 0x00;</code> sets it to 0;</li>
<li><code>lcl_ptr = apple_Build_BundleSeedIDPrefToken(&amp;UART1_BUF[1]);</code> sets it to <code>0x0D</code> inside the called function;</li>
<li><code>UART1_BUF[1] = (unsigned char)(lcl_ptr - (unsigned char *)&amp;UART1_BUF[1]);</code> sets it to <code>0x0E</code>, as the function adds 14 bytes.</li>
</ol>

<hr>

<p>More generally, remember to be careful with pointer subtractions: expecting them to always give a number of bytes is a common mistake...</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;

int main(void)
{
    int array[4];
    int *start, *end;

    start = &amp;array[1];
    end = &amp;array[3];
    printf(""Difference (as int *): %d\n"", end - start);
    printf(""Difference (as char *): %d\n"", (char *)end - (char *)start);
    return 0;
}
</code></pre>

<p>gives (on a system where <code>sizeof(int)==4</code>):</p>

<pre><code>Difference (as int *): 2
Difference (as char *): 8
</code></pre>
",1
3453159,3453131,2,"<p>Yes, provided that the result fits in a byte - which, from the code sample, it will - and, by 'length of the array', you mean the number of bytes minus the packet header.</p>
",1
4665878,4659756,7,"<p>Difference :</p>

<pre><code>1.int i; // i is defined to be an integer type in the current function/file
2.extern int i; // i is defined in some other file and only a proto-type is present here.
</code></pre>

<p>Hence while compiling, the compiler(LDD) will look for the original definition of the variable and if it does'nt find, it'll throw an error 'undefined reference to `i'. </p>
",0
4241439,4241435,0,"<p>This should work:</p>

<pre><code>system(""pause"");
</code></pre>

<p>At the top of your program, include stdlib.h:</p>

<pre><code>#include &lt;stdlib.h&gt;
</code></pre>
",0
4241444,4241435,7,"<p>Just open a command prompt and run it, the way it's meant to be used.</p>

<p>Start -> Run -> cmd.exe</p>

<p>or Win+R -> cmd</p>
",0
4241446,4241435,3,"<p>Run the program from command prompt (Start-Run-cmd.exe)</p>
",0
4241451,4241435,1,"<p>Run it from the console, or in a batch file.</p>

<p>Start >> Run >> cmd.exe</p>

<p>Then the console window is already open.</p>
",0
4241452,4241435,0,"<p>You can open a command prompt window and navigate (the <code>cd</code> command) to the directory containing the .exe file.  Then, run the program by typing its name.  The window will not close after the program finishes running.</p>
",0
4241454,4241435,2,"<p>Make a batch file (*.bat), with the command you want to execute, followed by pause:</p>

<pre><code>myconsoleapplication.exe
pause
</code></pre>

<p>Save it, and run. The command window wil wait for enter to be pressed before closing.</p>
",0
4241475,4241435,0,"<p>You could execute this program from one of your own, redirecting stdio and adding your own pause after it terminates. I've done this with .NET but assume that it can be done through other means. Of course a batch file, as mentioned already, is wicked simpler.</p>
",0
3753689,3753672,11,"<p>It obviously isn¡¯t a very good book. The problem is that neither <code>argv</code> nor <code>envp</code> are initialized, so when you write to <code>argv[0]</code>, you¡¯re trying to overwrite some random location in memory.</p>

<p>Try something like this:</p>

<pre><code>#include &lt;unistd.h&gt;

int main() {
  char *filename = ""/bin/sh"";
  char *argv[2], *envp[1];

  argv[0] = filename;
  argv[1] = 0;

  envp[0] = 0;

  execve(filename, argv, envp);
}
</code></pre>

<p>This alternative initializes <code>argv</code> and <code>envp</code> on the stack, with enough space to contain two pointers and one pointer respectively.</p>

<p>In the code above, I¡¯ve made one additional change to repair an additional common (but, in this case, harmless) misunderstanding. The <code>\x00</code> that was at the end of <code>""/bin/sh\x00""</code> is redundant, since in C static strings are implicitly null-terminated. <code>""/bin/sh\x00""</code> is a string terminated by <em>two</em> nulls.</p>

<p>Alternatively, as pointed out by <a href=""https://stackoverflow.com/users/134633/caf"">caf</a>, here is a more compact example with exactly equivalent meaning:</p>

<pre><code>#include &lt;unistd.h&gt;

int main() {
  char *filename = ""/bin/sh"";
  char *argv[2] = { filename, 0 };
  char *envp[1] = { 0 };

  execve(filename, argv, envp);
}
</code></pre>
",3
3753694,3753672,0,"<p><code>char **argv</code></p>

<p><code>argv</code> is pointing to a memory location which you are not allowed to access/write to. It is something that is better known as a <a href=""http://en.wikipedia.org/wiki/Dangling_pointer"" rel=""nofollow noreferrer"">wild pointer.</a></p>
",0
3753697,3753672,3,"<p>You never allocate the ""arrays of pointers"" meant to go in <code>argv</code> and <code>envp</code>!  What book is it, that omits such crucial steps?!</p>

<p>Either add <code>argv = malloc(2 * sizeof(char*))</code> (and similarly for <code>envp</code>) before you start assigning to <code>argv[0]</code> and friends, or change <code>argv</code>'s and <code>envp</code>'s declarations to be arrays of pointers rather than pointers to pointers (the latter's quite a feasible approach, in this specific case, since you do know exactly how many pointers you need in each at the time you're writing the code -- dynamic allocation is therefore somewhat supererogatory;-).</p>
",2
3753704,3753672,0,"<p>Looks like you need to get a better book!  In this code <code>argv</code> is a pointer with no storage allocated to it and pointing at random memory (or probably <code>NULL</code>).  When you dereference it with <code>argv[0] = ...</code>, your code ends up trying to write to random memory.  Your variable declaration should be something more like:</p>

<pre><code>char *argv[3], *envp[1];
</code></pre>
",1
3753708,3753672,0,"<p>I have no idea where did you get this book, but it obviously sucks. <code>argv</code> is an <strong>uninitialized</strong> pointer, it holds a random address. Hence accessing it will most probably lead to the access violation.</p>
",0
3753836,3753672,0,"<p>Before using such multi-level pointers, I recommend reading up on dynamic memmory allocation in C.</p>

<p>Whenever you use pointers, you must also think whether you need to allocate space for the data that the pointers are going to point to (as also the pointers themselves, for multi-level pointers).</p>

<p>For example,</p>

<pre><code>char **bar; 
</code></pre>

<p>here, bar allocates space for 1 pointer-to-pointer, ie. enough space to store one address. This is not very useful without any additional data allocation.</p>

<p>In reality, you should be doing:</p>

<pre><code>char **bar = calloc( 2 , sizeof(char *) );
</code></pre>

<p>here, bar allocates space for 1 pointer-to-pointer, ie. again, space to store one address as bar, AND 2 consecutive locations for storing 2 more pointers, namely bar[0] &amp; bar<a href=""https://i.stack.imgur.com/E3LmN.png"" rel=""nofollow noreferrer"">1</a>.</p>

<pre><code>char bar[0]= calloc( 10 , sizeof(char) );
</code></pre>

<p>here, bar[0] allocates space for storing a string of size 10 - 1 (for \0 at end). </p>

<p>Now, if you do a string copy:</p>

<pre><code>strcpy(bar[0],""Hello!"");
</code></pre>

<p>the final memory map comes to: (addresses in circles, contents in blocks)
<img src=""https://i.stack.imgur.com/E3LmN.png"" alt=""alt text""></p>
",0
3753871,3753672,-1,"<p>Many of the people here are on the right track, but missing some of the numerous problems here.</p>

<pre><code>#include &lt;unistd.h&gt;

int main() {
  char filename[] = ""/bin/sh\x00"";
  char **argv, **envp; // arrays that contain char pointers

  argv[0] = filename; // only argument is filename - segmentation fault here
  argv[1] = 0;  // null terminate the argument array

  envp[0] = 0; // null terminate the environment array

  execve(filename, argv, envp);
}
</code></pre>

<p>The problems here are:<br>
<strong>1.</strong>  The pointer array of character strings is never initialized.  Pointers take up space too, and thus an array of pointers needs to use malloc in c.<br>
<strong>2.</strong>  Each character pointer in your pointer array needs its own malloc statement before use.<br></p>

<p>Here is the working code, with printouts to show you what is going on:</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
  unsigned int i=0;
  char filename[] = ""/bin/sh\x00"";
  char **argv; // arrays that contain char pointers

  argv=(char **)malloc(sizeof(char*));
  argv[0]=(char *)malloc(strlen(filename)*sizeof(char));
  strcpy(argv[0],filename);

  printf(""Arg 0 is %u chars long...\n"",strlen(argv[0]));
  printf(""Arg 0 is "");
  while (argv[0][i] != '\0') {
    printf(""%c"",argv[0][i]);
    i++;
  }
  printf(""!\n"");

  free(argv[0]);
}
</code></pre>
",3
3746699,3746693,7,"<p>Just because some things will compile, does not mean they will produce valid defined results.</p>

<p>You are creating an array of chars (80 of them) and then you are casting that as a function pointer and trying to run it.  Likely your program will crash but it's results are undefined.</p>
",0
3746702,3746693,2,"<p>You could probably make this code work as you want it to, but it will be very machine/compiler/system dependent.  The stuff you put into <code>yes</code> will need to be machine instructions, not C <em>or</em> assembly.  I'll try to work up an example.</p>

<p>Edit:  My few quick tests didn't turn up anything useful.  Too much memory protection/security/safety going on in Mac OS X I guess.  Your code could certainly be made to work in a less-protected environment - embedded systems, BIOS, etc.</p>
",0
3746705,3746693,2,"<p>On linux this won't work. You have to <code>mmap</code> a memory segment with the <code>PROT_EXEC</code> flag to be able to execute machine instructions like you want to do.</p>

<p>Don't forget that code pointers and data pointers are supposed to be incompatible.</p>
",1
3747463,3746693,4,"<p>As stated, this is not a useful thing to do, but it's not that far off from what just-in-time compilers do all day, or the OS's executable loader.</p>

<ul>
<li>As Carl says, you need to put <em>machine instructions</em> into the buffer, not C or assembly.

<ul>
<li>That means you get to do all of the work of complying with the ABI yourself.</li>
<li>That also means you get <em>no portability at all</em>.  Code that does this sort of thing has to be written N times - once for each CPU+OS combination you care about.  Just-in-time compilers usually have a fallback to a byte-code interpreter for not-yet-supported platforms.</li>
</ul></li>
<li>For security reasons, you can't just dump machine code into a buffer and jump to it; you have to tell the OS what you are doing.</li>
</ul>

<p>As it happens I have an example lying around.  This is only tested to work on (x86 or x86-64)/Linux.  If you wanted to make it do something more interesting, you would need to replace the <code>memset</code> with code that filled in the buffer with the machine code for a more interesting operation.</p>

<p>It <em>will not</em> work on any other CPU, because it hardwires the x86 machine encoding of the return instruction.  It <em>probably won't</em> work on any other x86 OS, either, because it ignores the portability minefield surrounding <code>mmap</code> and <code>mprotect</code> :-(</p>

<pre><code>#define _GNU_SOURCE 1
#include &lt;sys/mman.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

static void __attribute__((noreturn))
perror_exit(const char *msg)
{
    perror(msg);
    exit(1);
}
int main(void)
{
    /* allocate one writable page */
    size_t pagesize = getpagesize();
    void *rgn = mmap(0, pagesize, PROT_READ|PROT_WRITE,
                     MAP_PRIVATE|MAP_ANON, -1, 0);
    if (rgn == MAP_FAILED)
        perror_exit(""mmap"");

    /* fill it with return instructions */
    memset(rgn, 0xC3, pagesize);

    /* now switch the page from writable to executable */
    if (mprotect((caddr_t)rgn, pagesize, PROT_READ|PROT_EXEC))
        perror_exit(""mprotect"");

    /* now we can call it */
    ((void (*)(void))rgn)();
    return 0;
}
</code></pre>
",1
5131737,5131717,0,"<p>Since you want exactly four per line, just do this:</p>

<pre><code>printf(""%d %d %d %d %d %d %d %d\n"", x, y, x, y, x, y, x, y);
</code></pre>

<p>for as many lines as you want.</p>
",1
5131742,5131717,0,"<p>Let's say you have something like this:</p>

<pre><code>typedef struct point {
    int x;
    int y;
} point_t ;

#define NUM_OF_LINES 5
#define POINTS_PER_LINE 4

int main( void ) {
    point_t p[NUM_OF_LINES][POINTS_PER_LINE];

    //  fill points with valid data somehow

    // print points
    for (int i = 0; i != NUM_OF_LINES; i++) {
        for( int j = 0; j != POINTS_PER_LINE; j++ )
            printf(""%d %d "", p[i][j].x, p[i][j].y);

        printf(""\n"");
    }

}
</code></pre>
",1
5131949,5131717,0,"<pre><code>for (int i=0; i&lt;total_points; i++) {
    printf(""%d %d"", points[i].x, points[i].y);
    if (i % points_per_line == 0)
        printf(""\n"");
    else
        printf("" "");
}
</code></pre>

<p>...or, if you don't mind code that some might consider slightly ""tricky"":</p>

<pre><code>static char seps[] = {'\n', ' '};

for (int i=0; i&lt;total_points; i++)
    printf(""%d %d%c"", 
        points[i].x,
        points[i].y,
        seps[(i%points_per_line)==0]);
</code></pre>

<p>Either way, these obviously presume something like the normal definition of a point, something on the order of:</p>

<pre><code>typedef struct { 
    int x;
    int y;
} point;
</code></pre>
",7
5190590,5190553,29,"<p>like <a href=""http://linux.die.net/man/2/gethostname"" rel=""noreferrer"">gethostname()</a> ?</p>

<p>That's the name of the machine on which your app is running.</p>

<p>Or read from</p>

<pre><code>/proc/sys/kernel/hostname
</code></pre>

<p><strong>Update</strong></p>

<p>Simple example</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(void) {

    char hostname[1024];
    gethostname(hostname, 1024);

    puts(hostname);

    return EXIT_SUCCESS;
}
</code></pre>
",3
4519733,4519654,0,"<p>First there is probably a typo in </p>

<pre><code>  struct Employees // the s
</code></pre>

<p>You could simply pass the <code>emp</code> record as a pointer</p>

<pre><code>  emps[i] = createEmployee( &amp;emp );
</code></pre>

<p>And you have to allocate a new structure, that is returned to the caller</p>

<pre><code>  struct Employee *createEmployee(struct Employee *p)
  {
     struct Employee *newe = malloc(sizeof(struct Employee));
     memcpy(newe, p, sizeof(struct Employee));
     return newe;
  }
</code></pre>

<p>Assuming the structure contains <code>char [x]</code> and not <code>char *</code>.</p>

<p><em>Not tested.</em></p>
",0
4519693,4519654,2,"<p>This should do it:</p>

<pre><code>emps[i] = createEmployee(emp.first, emp.last, emp.title, emp.salary);
</code></pre>

<p>...but if you changed your function a little, it would be a lot better to use:</p>

<pre><code>emps[i] = createEmployee(emp);
</code></pre>

<p>Your <code>Employee</code> structure could be defined like so:</p>

<pre><code>struct Employee {
  char first[256];
  //...
};
</code></pre>

<p>...in which case 'first' is an array. Or, it could be defined as</p>

<pre><code>struct Employee {
  char *first;
  // ...
};
</code></pre>

<p>An array of chars and a pointer to a char are very similar beasts. But in the first case, you will automatically allocate 256 chars for the first name each time you create an <code>Employee</code>. In the second case, you have to allocate the memory manually, and duplicate it appropriately when copying, and remember to delete it as well.</p>

<p>Say your <code>createEmployee</code> method looks like:</p>

<pre><code>Employee *createEmployee(char * first, char * last, char * title, int salary);
</code></pre>

<p>If you take the first form of the <code>Employee</code> struct above, you might do:</p>

<pre><code>struct Employee *createEmployee(char * first, char * last, char * title, int salary) {
  struct Employee *retVal = (struct Employee *)malloc(sizeof(struct Employee));
  strcpy(retVal-&gt;first, first);
  strcpy(retVal-&gt;last, last);
  // etc
  return retVal;
}
</code></pre>

<p>In the second case, you might do:</p>

<pre><code>struct Employee *createEmployee(char * first, char * last, char * title, int salary) {
  struct Employee *retVal = (struct Employee *)malloc(sizeof(struct Employee));
  retVal-&gt;first = strdup(first);
  retVal-&gt;last = strdup(last);
  // etc
  return retVal;
}
</code></pre>

<p>Note that the second case makes deleting (and copying) quite tricky.</p>

<pre><code>void deleteEmployee(struct Employee *emp) {
  free(emp-&gt;first);
  free(emp-&gt;last);
  // etc
  free(emp);
}
</code></pre>

<p>...but for the first form, you just have to <code>free(emp)</code>.</p>
",5
4519697,4519654,2,"<p>This should work:    </p>

<pre><code>emps[i] = createEmployee(emp.first, emp.last, emp.title, emp.salary);
</code></pre>

<p>You must consider that the <code>emp</code> data structure is local to your function (for this case <code>main</code>). This might lead to very weird errors if you're using <code>emp</code> anywhere else, because the data allocated for <code>emp</code> will be gone once the function returns - so using any data from emp, such as <code>emp.first</code> and <code>emp.last</code>, might cause some issues.</p>

<p>One way to solve this would be to also allocate <code>emp</code> dynamically, and pass a reference of it anywhere you want - this is usually how it's done.</p>

<p>Another quick hacky way would be to dynamically allocate the stuff that will be lost, such as your pointers:</p>

<pre><code>emps[i] = createEmployee(strdup(emp.first), strdup(emp.last), strdup(emp.title), emp.salary);
</code></pre>

<p><a href=""http://linux.die.net/man/3/strdup"" rel=""nofollow"">strdup()</a> will duplicate the string you give it, and it will store it using <code>malloc()</code> (heap) so it won't be gone when the function returns.</p>
",13
3555812,3555748,0,"<p>remove the temp (cant see the point of it)</p>

<p>set max to some initial value (e.g. first element of the array)</p>

<p>and change if statement to:</p>

<pre><code>  if (nu[c]&gt; max)
             {
                  max = nu[c];

             }
</code></pre>
",0
3555817,3555748,0,"<p>This may not solve your question but <code>nu[c]</code> seems bad allocated to me since <code>c</code> value is undefined</p>
",0
3555891,3555748,1,"<p>You need a single for loop and not nested for loop. </p>

<ol>
<li>Get input using the first for loop</li>
<li>Assign first element of the input array to variable, call this max</li>
<li>Compare each element of the array using a for loop again</li>
<li><p>If you get a value greater than max then change max to this value using the below code</p>

<p>if(max&lt; a[i])
max=a[i];</p></li>
</ol>

<p>At the end of these steps you can get max value. </p>

<p>Try to put these steps into a C code and it should be fine. There are some problems with the code you have written. I have written a small snippet for you to get input for number of elements and store them into your array for floats.</p>

<pre><code>int number_of_elements;
printf(""Enter the number of elements:\n"");
scanf(""%d"", &amp;number_of_elements);
for(i=0;i&lt;number_of_elements;i++)
scanf(""%f"",&amp;a[i]);
</code></pre>
",0
3555942,3555748,1,"<p>Here's the code with some helpful pointers:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
        double temp[0];
        float max,min;
        float i;
        short c,j,k;                     // k isn't used anywhere.
        float sum=0;
        float nu[c];                     // c isn't set at this point so the
                                         //   runtime couldn't create an
                                         //   array anyway.

        printf(""Number of values :"");
        scanf(""%f"",&amp;i);

        for (c=1;i&gt;=c;c++)
        {
          printf(""values="");
          scanf(""%f"",&amp;nu[c]);
                                         // You should set min/max to nu[c]
                                         //   if c is 1 regardless.
          nu[c]=temp[0];                 // Why are you scanning into nu[c]
                                         //   then immediately overwriting?

          for (j = 0; i&gt;=j; j++)         // Why figure out the max *every*
          {                              //   time you enter a value?
             if (temp[0]&gt; nu[c])
             {
             //      nu[c]=temp[0];
                  max = temp[0];

             }
        }
        sum = sum + nu[c];
      }
      printf(""sum = %f \n"",sum);
      printf(""maximum value = %f\n"",max);
}
</code></pre>

<p>I'd also suggest you go back to <a href=""https://stackoverflow.com/questions/3547633/finding-sum-min-max-with-array/3547684#3547684"">my original answer</a> and create your code from that. It really is a much cleaner way of doing it than trying to fiddle around with arrays.</p>

<p>Let me emphasise that: <em>if you're using an array, you're doing it the hard way!</em></p>
",0
3556141,3555748,2,"<p>If you run your compiler with a -Wall (as you should always do), you should have seen the problems :</p>

<pre><code>gcc -Wall -o foo foo.c
foo.c: In function 'main':
foo.c:35:14: warning: unused variable 'k'
foo.c:33:14: warning: unused variable 'min'
foo.c:62:1: warning: control reaches end of non-void function
foo.c:37:4: warning: 'c' is used uninitialized in this function
</code></pre>

<p>Here is the source code of a program that works :</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
   float max = 0; // hypothesis : numbers keyed by the users are &gt; 0
   float min = 0; // hypothesis : numbers keyed by the users are &gt; 0
   int i, c;
   float sum = 0;
   float nu[100]; // hypothesis : no more than 100 numbers keyed by user
                  // hypothesis : float type is enough to store numbers keyed by user
   printf(""Number of values :"");
   scanf(""%d"",&amp;i);

   for (c = 0; c &lt; i; c++)
   {
         printf(""values="");
         scanf(""%f"",&amp;(nu[c]));

         if (nu[c] &gt; max) {
            max = nu[c];
         }

         if (min == 0) {
            min = nu[c];
         } else if(nu[c] &lt; min) {
            min = nu[c];
         }

         sum = sum + nu[c];
   }
   printf(""sum = %f \n"",sum);
   printf(""maximum value = %f \n"", max);
   printf(""minimum value = %f \n"", min);

   return 0;
}
</code></pre>
",2
3583294,3555748,1,"<p><strong>Or this</strong></p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)

{ 
 float temp;

 int val,i,j,k;

 double sum = 0;

 double number[val];

 printf(""Enter the number of values: "");

 scanf(""%d"", &amp;val);

 double number[val];

 for(i=1; i &lt;= val ;i++)
 { 
   printf(""enter a value: "");

   scanf(""%lf"", &amp;number[i]);

    sum = sum + number[i];

 }

 for(i=1;i&lt;=val;i++)

        {

  for(j=i+1;j&lt;=val;j++)

  {

   if(number[i] &gt; number[j])

   { 

    temp=number[i];

    number[i]=number[j];

    number[j]=temp;

    }

  }

 }

 printf(""Sum = %.lf\n"", sum);

 printf (""Maximum element: %f\n"",number[val]);  

 printf (""Minimum element: %lf\n"", number[1]);  

}
</code></pre>
",0
3567848,3567809,1,"<p><code>strcmp</code> compares the whole line in the passwd file with what you have entered. The passwd file contains more than just the user name on each line (look at a passwd file to see what I'm talking about).</p>
",1
3567850,3567809,3,"<p><code>strcmp</code> is a three-way comparator. It tells you if the strings are equal or if the first string is lexicographically less or greater than second.</p>

<p>Because of this, its results are a bit unintuitive when used as booelan values. It returns <code>0</code> when the strings match, which evaluates to false in an <code>if</code> statement. It returns nonzero values, usually -1 or 1, (all of which evaluate to true) when the strings are different.</p>

<p>If you want to test if two strings are the same, you should change</p>

<pre><code>if(strcmp(line,username))
</code></pre>

<p>to</p>

<pre><code>if(strcmp(line,username) == 0)
</code></pre>

<p>Also take note of Starkey's answer about the extra contents of lines in <code>/etc/passwd</code>. If you make only the change above, your program will always return ""not a valid user"".</p>
",2
3567852,3567809,2,"<p><code>strcmp</code> returns 0 (which is false) if the two strings are exactly equivalent, or a non-zero number (which is true) if the strings differ at all.</p>

<p>So firstly, you appear to have your if-test the wrong way around. Secondly, you need to test just the leading <code>n</code> characters, where <code>n</code> is the length of the username. Off the top of my head, I suggest you try replacing your if-test with:</p>

<pre><code>if (!strncmp(line, username, strlen(username))
</code></pre>
",0
3567885,3567809,6,"<p>Could you use <code>getpwent</code> for this task?</p>

<p>see: <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/getpwent.3.html"" rel=""nofollow noreferrer"">getpwent(3)</a> and <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/getpwent.html"" rel=""nofollow noreferrer"">opengroup's getpwent</a></p>

<ul>
<li><a href=""http://www.chemie.fu-berlin.de/chemnet/use/info/libc/libc_25.html#SEC452"" rel=""nofollow noreferrer"">Here's a generic example of usage</a>, and</li>
<li><a href=""http://www.chemie.fu-berlin.de/chemnet/use/info/libc/libc_25.html#SEC445"" rel=""nofollow noreferrer"">here's another - how to look up users</a>.</li>
</ul>

<p>and</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/1610203/unix-programming-not-sure-how-to-use-the-passwd-struct"">here's the <strong>Stackoverflow discussion</strong> on the topic</a></li>
</ul>

<p>Regards</p>

<p>rbo</p>
",0
3567900,3567809,3,"<p>Instead of trying to parse <code>/etc/passwd</code> manually, you might want to use <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/getpwnam.3.html"" rel=""nofollow noreferrer""><code>getpwnam</code></a> instead.</p>
",0
3570768,3567809,0,"<p>Aside from the fact that your <code>strcmp</code> test condition is wrong as others have already pointed out, lines in the passwd file contain more than just the username. You could use <code>strstr</code> to see if the name is present in a particular line.</p>

<pre><code>if(strstr(line, username) == line)
{
    /* valid user */
}
</code></pre>
",0
3314584,3286098,1,"<p>After taking the advice of everyone, I broke the 6GB file up into 4K chunks, parsed the hex bytes and was able to get what the byte locations which will help me later when I pull out MBR from a VMFS partition that has been dd imaged.  Here was the quick and dirty way of reading it per chunk:</p>

<p><strong>#define DEFAULT_BLOCKSIZE 4096</strong>
<br>...</p>

<pre><code>while((bytes_read = fread(chunk, sizeof(unsigned char), sizeof(chunk), fptr)) &gt; 0) {
    chunkptr = chunk;
    for(z = 0; z &lt; bytes_read; z++) {
        if (*chunkptr == pattern_buffer[current_search]) {
            current_search++;
            if (current_search &gt; (counter - 1)) {
                current_search = 0;
                printf(""Hex string %s was found at starting byte location:  %lld\n"",
                       hexstring, (long long int) (offsetctr-1));
                matches++;
            }
        } else {
            current_search = 0;
        }
        chunkptr++;
        //printf(""[%lld]: %02X\n"", offsetctr, chunk[z] &amp; 0xff);
        offsetctr++;
    }
    master_counter += bytes_read;
}
</code></pre>

<p>...</p>

<p>and here were the results I got...</p>

<pre><code>root@redbox:~/workspace/bytelocator/Debug# ./bytelocator -x BF1B0650 -i /data/images/sixgbimage.img 

Total size of /data/images/sixgbimage.img file:  6448619520 bytes
Parsing the hex string now: BF1B0650

Hex string BF1B0650 was found at starting byte location:  18
Hex string BF1B0650 was found at starting byte location:  193885738
Hex string BF1B0650 was found at starting byte location:  194514442
Hex string BF1B0650 was found at starting byte location:  525033370
Hex string BF1B0650 was found at starting byte location:  1696715251
Hex string BF1B0650 was found at starting byte location:  1774337550
Hex string BF1B0650 was found at starting byte location:  2758859834
Hex string BF1B0650 was found at starting byte location:  3484416018
Hex string BF1B0650 was found at starting byte location:  3909721614
Hex string BF1B0650 was found at starting byte location:  3999533674
Hex string BF1B0650 was found at starting byte location:  4018701866
Hex string BF1B0650 was found at starting byte location:  4077977098
Hex string BF1B0650 was found at starting byte location:  4098838010


Quick stats:
================
Number of bytes that have been read:  6448619520
Number of signature matches found:  13
Total number of bytes in hex string:  4
</code></pre>
",2
3286119,3286098,2,"<p>When <code>fread</code> fails, it sets <code>errno</code> to indicate why it failed.  What is the value of <code>errno</code> after the call to <code>fread</code> that returns zero?</p>

<p><strong>Update:</strong>
Are you required to read the entire file in one fell swoop?  What happens if you read in the file, say, 512MB at a time?</p>

<p>According to your comment above, you are using a 32-bit OS.  In that case, you will be unable to handle 6 GB at a time (for one, <code>size_t</code> won't be able to hold that large of a number).  You should, however, be able to read in and process the file in smaller chunks.</p>

<p>I would argue that reading a 6GB file into memory is probably not the best solution to your problem even on a 64-bit OS.  What exactly are you trying to accomplish that is requiring you to buffer a 6GB file? There's probably a better way to approach the problem.</p>
",3
3286224,3286098,4,"<p>If you're just going to be reading through the file, not modifying it, I suggest using <code>mmap(2)</code> instead of <code>fread(3)</code>. This should be much more efficient, though I haven't tried it on huge files. You'll need to change my very simplistic found/not found to report offsets if that is what you would rather have, but I'm not sure what you want the pointer for. :)</p>

<pre><code>#define _GNU_SOURCE
#include &lt;string.h&gt;

#include &lt;fcntl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;


int main(int argc, char* argv[]) {
    char *base, *found;
    off_t len;
    struct stat sb;
    int ret;
    int fd;
    unsigned int needle = 0x45004E00;

    ret = stat(argv[1], &amp;sb);
    if (ret) {
            perror(""stat"");
            return 1;
    }

    len = sb.st_size;

    fd = open(argv[1], O_RDONLY);
    if (fd &lt; 0) {
            perror(""open"");
            return 1;
    }

    base = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
    if (!base) {
            perror(""mmap"");
            return 1;
    }

    found = memmem(base, len, &amp;needle, sizeof(unsigned int));
    if (found)
            printf(""Found %X at %p\n"", needle, found);
    else
            printf(""Not found"");
    return 0;
}
</code></pre>

<p>Some tests:</p>

<pre><code>$ ./mmap ./mmap
Found 45004E00 at 0x7f8c4c13a6c0
$ ./mmap /etc/passwd
Not found
</code></pre>
",2
3286292,3286098,4,"<p>If this is a 32 bit process, as you say, then <code>size_t</code> is 32 bit and you simply <em>cannot</em> store more than 4GB in your process's address space (actually, in practice, a bit less than 3GB).  In this line here:</p>

<pre><code>bfr = (char*) malloc(sizeof(char) * size);
</code></pre>

<p>The result of the multiplication will be reduced modulo <code>SIZE_MAX + 1</code>, which means it'll only try and allocate around 2GB.  Similarly, the same thing happens to the <code>size</code> parameter in this line:</p>

<pre><code>result = fread(bfr, sizeof(char), size, fptr);
</code></pre>

<p>If you wish to work with large files in a 32 bit process, you <em>have</em> to work on only a part of them at a time (eg. read the first 100 MB, process that, read the next 100 MB, ...).  You can't read the entire file in one go - there just isn't enough memory available to your process to do that.</p>
",1
3286300,3286098,0,"<p>Have you verified that <code>malloc</code> and <code>fread</code> are actually taking in the right type of parameters? You may want to compile with the <code>-Wall</code> option and check if your 64-bit values are actually being truncated. In this case, <code>malloc</code> won't report an error but would end up allocating far less than what you had asked for.</p>
",0
4331187,4331163,0,"<p>Look at <code>va_start</code>, <code>va_arg</code>, <code>va_end</code>.  You will not be limited by two and three arguments.</p>
",2
4331197,4331163,0,"<p>You can just use <code>int(*)()</code>, and have some other parameter(s) that describe the function signature so that you can call it.  For example:</p>

<pre><code>typedef struct OptionValueStruct{
    const char *option_name;
    int (*func)(); /* actually takes some arguments */
    unsigned num_args; /* might need more fields to describe the args */
} OptionValueStruct_t;
</code></pre>

<p>...</p>

<pre><code>switch (value.num_args){
case 2: ((int (*)(char*, char**))value.func)(opt_name, opt_val);
case 3: ((int (*)(char*, char**, int))value.func)(opt_name, opt_val, a);
}
</code></pre>

<p>Another way would be to just declare the pointer func to match <code>parse3parameter</code>, and then always call it as if it took three arguments, and (on some platforms), the third argument will simply be ignored.  This is probably not portable though.</p>
",2
4331180,4331163,2,"<p>What are you really trying to do, and why?</p>

<p>Think about the code where you receive the function pointer. How are you going to know how to call it?</p>
",3
4356171,4356161,1,"<p>If stdin is line-buffered then you'll never see the keypresses, only the final result. The exact method for disabling line-buffering can be found in other answers here.</p>
",0
4356187,4356161,0,"<p>If you use the <code>&lt;conio.h&gt;</code> there is a <code>getch()</code> method which can catch that key, but it does not echo it IIRC, it's been a long time since faffing around with those... the neat thing about using that function, it is portable in the sense that under Unix and curses, there's an exact same function that does the same thing...</p>
",2
3583243,3547633,0,"<p><strong>Try this...</strong></p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)

    {   
        float temp;
        int val,i,j,k;
        double sum = 0;
        double max,min;


        printf(""Enter the number of values: "");
        scanf(""%d"", &amp;val);
        double number[val];

        for(i=0; i &lt; val ;i++)
        { 
            printf(""enter a value: "");
            scanf(""%lf"", &amp;number[i]);
            sum = sum + number[i];
        }

        min = number[0];
        max = number[0];

        for(j=0;j&lt;val;j++)
        {
            if(number[j] &lt; min)
            min = number[j];
        }


        for(k=0;k&lt;val;k++)
        {
               if(number[k] &gt; max)
            max = number[k];
        }

        printf(""Sum = %.lf\n"", sum);

        printf (""Maximum element: %.f\n"",max);  

            printf (""Minimum element: %.lf\n"",min);  

    }
</code></pre>
",0
3583623,3547633,0,"<p><strong>Or this</strong></p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)

{ 
 float temp;
 int val,i,j,k;

 double sum = 0;

 double number[val];

 printf(""Enter the number of values: "");

 scanf(""%d"", &amp;val);

 double number[val];

 for(i=1; i &lt;= val ;i++)

 { 

  printf(""enter a value: "");

  scanf(""%lf"", &amp;number[i]);

  sum = sum + number[i];

 }

 for(i=1;i&lt;=val;i++)

{


 for(j=i+1;j&lt;=val;j++)

  {

   if(number[i] &gt; number[j])

   { 

    temp=number[i];

    number[i]=number[j];

    number[j]=temp;

    }


}


 }

 printf(""Sum = %.lf\n"", sum);


 printf (""Maximum element: %f\n"",number[val]);  


        printf (""Minimum element: %lf\n"", number[1]);  

}
</code></pre>
",0
3547666,3547633,0,"<ul>
<li>Get rid of the line ""i=nu[]"". </li>
<li>Ensure you're initialising the array you pass in with the relevant number of elements</li>
</ul>
",0
3547670,3547633,0,"<p>You must at first input i:</p>

<pre><code>scanf(""%f"",&amp;i);
</code></pre>

<p>and then declare array:</p>

<pre><code>float nu[i];
</code></pre>
",5
3547684,3547633,10,"<p>In C, you need to specify the sizes of your arrays such as with <code>float nu[100];</code> but you're barking up the wrong tree if you think you need to store all those values. The minimum, maximum and sum can all be calculated on the fly without any need to go back and retrieve any previous numbers.</p>

<p>All you need to do is enter them one at a time and, for each:</p>

<ul>
<li>if it's the first or greater the the current high, set the current high to it.</li>
<li>if it's the first or less the the current low, set the current low to it.</li>
<li>add it to a sum.</li>
</ul>

<p>The sum by the way, should be initialised to zero to start with.</p>

<p>In terms of pseudo-code, start with this:</p>

<pre><code>set sum, high and low all to zero

scan ""number of values"" into count

for curr = one to count, inclusive:
    scan ""current number"" into num

    set sum to sum + num

    if curr is one, or num is less than low:
        set low to num

    if curr is one, or num is greater than high:
        set high to num

output ""Minimum = "" low
output ""Maximum = "" high
output ""Sum     = "" sum
</code></pre>

<p>And the best way to understand it is to get a (very non-tech) piece of paper and write up a table like this:</p>

<pre><code>+-----+------+-----+-----+-------+------+
| sum | high | low | num | count | curr |
+-----+------+-----+-----+-------+------+
|     |      |     |     |       |      |
|     |      |     |     |       |      |
|     |      |     |     |       |      |
|     |      |     |     |       |      |
|     |      |     |     |       |      |
+-----+------+-----+-----+-------+------+
</code></pre>

<p>Then run that program step-by-step through your head, entering or changing the values in that table as you go. You'll even be able to detect when you're using uninitialised values such as if you came across <code>set sum to sum + curr</code> if the <code>sum</code> column was empty.</p>

<p>You'll be surprised how quickly you begin to think like a computer, just hope it doesn't push all those social skills out of your head in the process :-)</p>
",0
3547726,3547633,0,"<p>If you dont know the array dimension before, use dynamic allocation.</p>

<p>replace</p>

<pre><code>float nu[];

i=nu[];

printf(""Number of values :"");
scanf(""%f"",&amp;i);
</code></pre>

<p>with:</p>

<pre><code>float *nu=0;
printf(""Number of values :"");
scanf(""%f"",&amp;i);
nu=malloc(i*sizeof*nu); if(!nu) fprintf(stderr,""not enough memory""),exit(1);
...
free(nu);
</code></pre>
",0
5494324,5494160,0,"<p>You say the first time through the loop, it works as you expect, but not the later iterations. I don't have a gcc compiler in front of me, so I can't test this, but would this work for you? </p>

<pre><code>fi_union.float_val = v1;
for( int i = 0; i &lt;= 35; i++ )
{
    printf( ""\n %f &gt;&gt; %*i = %16lX \t %20li \t %15f"", v1, 2, i, fi_union.val, fi_union.val, fi_union.float_val );
    fi_union.val = fi_union.val &gt;&gt; 1;
}
</code></pre>

<p>Looking at the operator precedence rules, your assignment to <code>fi_union.val</code> should work, but I'm guessing that's what's not working when <code>i &gt; 0</code>. Therefore, try to bypass it by using the union to replace the pointer aliasing.</p>
",1
5494397,5494160,3,"<p>Floating-point variables, according to IEEE 754, are composite data structures with three or four components: sign, exponent, mantissa and optionally a quiet NaN flag (embedded in the mantissa). Shifting the whole memory representation like you did in <code>fi_union.val = *(uint64_t*)(&amp;v1) &gt;&gt; i;</code> will not return anything meaningful.</p>

<p>So the expected results are indeed what you see, on the first iteration, when <em>i</em> = 0, no shifting is performed and the value returned is ok. When you start shifting bits in the memory representation of the float, you are trowing the sign bit over the exponent, the exponent bits over the mantissa, etc. This causes a mess.</p>

<p>If you want to inspect the contents of the memory representation of the floating-point number, use <code>&lt;ieee754.h&gt;</code> from glibc.</p>

<p>Something like this (not tested):</p>

<pre><code>#include &lt;ieee754.h&gt;
...
union ieee754_double x;

x.d = v1
printf(""sign: %u; mantissa: %llu; exponent: %u\n"",
    (unsigned) x.ieee.negative,
    ((unsigned long long) x.ieee.mantissa1 &lt;&lt; 20) | ((unsigned long long) x.ieee.mantissa0),
    (unsigned) x.ieee.exponent - IEEE754_DOUBLE_BIAS);
</code></pre>
",1
3839418,3836519,4,"<p>Using strtok() is the key:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main () {
    FILE * fl;
    long fl_size;
    char * buffer;
    size_t res;

    fl = fopen ( ""fruits.txt"" , ""r+"" );
    if (fl==NULL) {
        fprintf (stderr, ""File error\n""); 
        exit (1);
    }

    fseek (fl , 0 , SEEK_END);
    fl_size = ftell (fl);
    rewind (fl);

    buffer = (char*) malloc (sizeof(char)*fl_size);
    if (buffer == NULL) {
        fputs (""Memory error"",stderr); 
        exit (2);
    }

    res = fread (buffer,1,fl_size,fl);
    if (res != fl_size) {
        fputs (""Reading error"",stderr); 
        exit (3);
    }

    /*
     * THIS IS THE PART THAT IS IMPORTANT FOR THE QUESTION!!
     */
    char * strtok_res;
    strtok_res = strtok(buffer, ""::"");
    while (strtok_res != NULL)
    {
        printf (""%s\n"", strtok_res);
        strtok_res = strtok (NULL, ""::"");
    }
    /*
     * DONE!
     */



    fclose (fl);
    free (buffer);
    return 0;
}
</code></pre>
",0
3839608,3836519,1,"<p>If you can be sure that the file is formatted as</p>

<pre><code>:&lt;produce&gt;::&lt;description&gt;::&lt;produce&gt;::&lt;description&gt;:...
</code></pre>

<p>Then you could use a loop with this fscanf format:</p>

<pre><code>char produce[100], description[100];
if ((fscanf(file, "":%99[^:]::%99[^:]:"", produce, description) != 2)
{
    /* Handle read error or EOF */
}
</code></pre>
",0
3839021,3839010,1,"<p>You shouldn't use function names as variable names, ever, for any reason.</p>
",3
3839033,3839010,2,"<p>In your first code snippet, you declare a local variable <em>main</em>, which is in the <strong>local</strong> scope, so it has no effect on the <strong>global</strong> scope (where the <strong>main()</strong> function is declared)</p>

<p>In the second code snippet, you declare ""printf"" in global scope, where the <strong>printf()</strong> function lives, so you have a conflict.</p>
",1
3839062,3839010,2,"<p>In the second example, you have declared a local variable of type 'int' called 'printf'. This will take precedence over the global function of the same name. So the error is that the name 'printf' refers to an int, not a function.</p>

<p>In your first example, you override the global function name 'main' with a local variable called 'main'. If you had not done that, you would in fact be able to call the 'main' function from within the main function, and that would have worked. With your variable declaration, that is no longer possible as the local variable declaration takes precedence - but it's still perfectly usable in the variable form.</p>
",0
3839070,3839010,9,"<p>In your 1st example you ""hide"" the <code>main</code> function, replacing it with an <code>int</code> object.</p>

<p>In your 2nd example you ""hide"" the <code>printf</code> function, replacing it with an <code>int</code> object.
Trying to call an <code>int</code> is illegal.</p>

<pre><code>5(""foo""); /* illegal to call ""function"" 5 */
</code></pre>
",0
3997589,3997581,17,"<p>The array is passed as a pointer to the elements.</p>

<p>If I write:</p>

<pre><code>void doStuff(int *ptr)
{
  ptr[1] = 5;
}

int main()
{
  int arr[] = {0, 1, 2};
  doStuff(arr);
  printf(""%d %d %d\n"", arr[0], arr[1], arr[2]);
}
</code></pre>

<p>the output will be ""0 5 2"".  That's because C passes whatever is actually the parameter by value.  The parameter is a pointer to an int.  So a pointer to an int is passed by value.  Thus, doStuff gets a copy of a pointer to memory in main's stack frame.  When it dereferences that pointer with <code>ptr[1]</code>, it is following the pointer to main's memory and modifying the array there.</p>

<p>C can only pass by value, but it does so ""shallowly"".  If you ask it to pass an int *, it will pass an int *.  It only copies the value of the pointer, not the values of anything it points to.</p>

<p>If you want doStuff to get its own copy of the array, either wrap the array in a struct as others have suggested, or use memcpy to manually deep copy the array like this:</p>

<pre><code>void doStuff(int *ptr, int nElems)
{
  int myCopyOfTheArray[nElems];
  memcpy(myCopyOfTheArray, ptr, sizeof(int) * nElems);
  /* do stuff with the local copy */
}
</code></pre>

<p>Unlike using a struct, the memcpy approach works if nElems is only know at runtime.</p>
",4
3997621,3997581,1,"<p>An array in C may be treated as a pointer to the first element of the array. The pointer is passed by-value (you cannot modify the value passed in), but you can dereference it and modify the memory that it points at.</p>
",1
3997623,3997581,8,"<p>Arrays can't be passed by value in C. They get demoted to pointers. So the called function sees a pointer to the array (passed by reference) and operates on it. If you want to make a copy, you have to either do so explicitly, or put your array inside a struct (which can be passed by value to functions.)</p>
",0
3997630,3997581,1,"<p>Because when You pass a whole array to function You pass a pointer to that array, which means that You give function a place in memory where this array is located. So when You change the array in function You are changing the original array as well.</p>
",0
3997652,3997581,5,"<p>It is expensive to make a copy of a whole array, in general.  Back in the days when C was first created, it could easily exhaust the machine resources (stack in particular).</p>

<p>If you really want to pass an array, wrap it in a structure:</p>

<pre><code>struct wrap { int array[100]; };

int somefunc(struct wrap large) { ... }

void anotherfunc(void)
{
    struct wrap a;
    ...add data to array...
    printf(""%d\n"", somefunc(a));
}
</code></pre>
",0
3997673,3997581,3,"<p>""Pass by reference"" is a  red herring in C. All arguments to a function are ""passed by value"" only. In case of arrays, you pass the address of the first element in the form of a pointer. You can then use this pointer to refer to the desired memory location &amp; read or write values.</p>
",0
3997872,3997581,2,"<p>From the <a href=""http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf"" rel=""nofollow"">online C standard</a>:</p>

<blockquote>
<b>6.3.2.1 Lvalues, arrays, and function designators</b><br>
...<br>
3  Except when it is the operand of the <b>sizeof</b> operator or the unary <b>&</b> operator, or is a string literal used to initialize an array, an expression that has type ""array of type"" is converted to an expression with type ""pointer to type"" that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.
</blockquote>

<p>Assume the following code snippet:</p>

<pre><code>int a[10];
...
foo(a);
</code></pre>

<p>In the call to <code>foo</code>, the type of the <em>expression</em> <code>a</code> is ""10-element array of <code>int</code>"".  However, since the expression is not the operand of either the <code>sizeof</code> or <code>&amp;</code> operators, and since it isn't a string literal being used to initialize another array in a declaration, its type is implicitly converted (""decays"") from ""10-element array of <code>int</code>"" to ""pointer to <code>int</code>"", and its value will be the address of the first element in the array (i.e. <code>&amp;a[0]</code>).  </p>

<p>Therefore, what <code>foo</code> receives is a pointer to <code>int</code>, not an array.  Dereferencing or subscripting this pointer allows you to change the values of the array.  </p>

<p>This is a feature of the C language; arrays are not first-class objects.  In fact, in most circumstances (including subscripting) array <em>expressions</em> will be converted to pointer types.  </p>

<p>I keep emphasizing the word <em>expression</em> to distinguish between the actual array <em>object</em> (which is always and forever an array type) and any <em>reference</em> to that object in the code, which may be converted to a pointer type.  </p>
",0
3998548,3997581,3,"<p>I haven't really seen any answers yet cover the whole question yet. From what I see, it looks like the question asks something like this:</p>

<p>Given the following code:</p>

<pre><code>int a[5];

foo(a);
bar(a[0]);
</code></pre>

<p>Why can <code>foo</code> manipulate the original values while <code>bar</code> receives only a copy of the value being passed in?</p>

<p>This is because of the use of array notation: the <code>[]</code> operator dereferences the item it references in the array and passes in the value at that location. </p>

<p>So</p>

<pre><code>int a[5];
bar(a[0]);
</code></pre>

<p>is different than:</p>

<pre><code>int* a;
bar(a);
</code></pre>

<p>If you want to pass in a references to a specific item in an array, you need to use the <code>&amp;</code> operator:</p>

<pre><code>bar(&amp;a[5]);
</code></pre>
",0
3939976,3939896,-2,"<p>Problem with buffer - I think the remaining part (.5) remains on the buffer.
use <code>flushall();</code> after your <code>scanf(""%d..</code></p>
",2
3940007,3939896,5,"<p>When you <code>scanf(""%d"")</code> a value like <code>1.5</code> the scanning will stop at the decimal point and return 1.</p>

<p>The <em>next</em> time you call <code>scanf</code>, the pointer will <em>still</em> point to the decimal point and your scan will return immediately because there are no digits there to scan.</p>

<p>You should be checking the return value from <code>scanf</code> - it gives you the number of items successfully scanned which will be 1 initially for the <code>1</code> before the decimal point, and 0 from then on.</p>

<p>As an aside, <code>scanf</code> stands for ""scan formatted"" and I'll guarantee you won't find anything <em>more</em> unformatted than user input.</p>

<p>Investigate looking into <code>fgets</code> for line input. Here's a copy of a function I often use for such purposes:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define OK       0
#define NO_INPUT 1
#define TOO_LONG 2
static int getLine (char *prmpt, char *buff, size_t sz) {
    int ch, extra;

    // Get line with buffer overrun protection.
    if (prmpt != NULL) {
        printf (""%s"", prmpt);
        fflush (stdout);
    }
    if (fgets (buff, sz, stdin) == NULL)
        return NO_INPUT;

    // If it was too long, there'll be no newline. In that case, we flush
    // to end of line so that excess doesn't affect the next call.
    if (buff[strlen(buff)-1] != '\n') {
        extra = 0;
        while (((ch = getchar()) != '\n') &amp;&amp; (ch != EOF))
            extra = 1;
        return (extra == 1) ? TOO_LONG : OK;
    }

    // Otherwise remove newline and give string back to caller.
    buff[strlen(buff)-1] = '\0';
    return OK;
}
</code></pre>

<p>&nbsp;</p>

<pre><code>// Test program for getLine().

int main (void) {
    int rc;
    char buff[10];

    rc = getLine (""Enter string&gt; "", buff, sizeof(buff));
    if (rc == NO_INPUT) {
        // Extra NL since my system doesn't output that on EOF.
        printf (""\nNo input\n"");
        return 1;
    }

    if (rc == TOO_LONG) {
        printf (""Input too long [%s]\n"", buff);
        return 1;
    }

    printf (""OK [%s]\n"", buff);

    return 0;
}
</code></pre>

<p>Once you get a line in with that function, you can <code>sscanf</code> it to your heart's content, handling errors much easier.</p>
",1
3940010,3939896,3,"<p>What's happening is that <code>scanf</code> stops reading an integer when it sees the <code>'.'</code> character, and leaves it in the input buffer. Then subsequent calls to <code>scanf</code> fail because the next character is <code>'.'</code> and not something parseable as an integer.</p>

<p>How do you fix this? The first step is to forget you ever heard of <code>scanf</code> and always use <code>fgets</code> to read whole lines of input, then process them after you read them into a string buffer. You can use <code>sscanf</code> for this purpose, but a robust function like <code>strtol</code> would be a lot better.</p>
",0
3559432,3559404,-1,"<p>Here are the functions mentioned above</p>

<pre><code>#define MAX 100000000
void compare_1(void)
{
   unsigned long i;
   unsigned long j;
   printf(""%s\n"", __FUNCTION__);
   for(i=0;i&lt;MAX;i++)
   {
      j = rand()%100;
      switch(j)
      {
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
    case 10:
    case 11:
    case 15:
       break   ;
    default:
       break   ;
      }
   }
}


void unreg(void)
{
   int i;
   int j;
   printf(""%s\n"", __FUNCTION__);
   for(i=0;i&lt;MAX;i++)
   {
      j = rand()%100;
      switch(j)
      {
    default:
       break   ;
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
    case 10:
    case 11:
    case 15:
       break   ;
      }
   }
}
</code></pre>
",2
3561681,3559404,1,"<p>If your set really consists of numbers in the range 0 to 63, use:</p>

<pre><code>#define SET 0x.......ULL
if (num &lt; 64U &amp;&amp; (1ULL&lt;&lt;num &amp; SET)) foo();
else bar();
</code></pre>
",0
3560518,3559404,2,"<p>There is no way of <em>feeling</em> that one function is faster than the other. Do measurements (without the <code>printf</code>) and also compare the assembler that is produced (use the option <code>-S</code> to the compiler).</p>
",0
3559735,3559404,1,"<p>Here are some suggestions for optimizing a <code>switch</code> statement:</p>

<h2>Remove the <code>switch</code> statement</h2>

<p>Redesign your code so that a <code>switch</code> statement is not necessary.  For example, implementing virtual base methods in a base class.  Or using an array.  </p>

<p>Filter out common choices.  If there are many choices in a range, reduce the choices to the first item in the range (although the compiler may do this automagically for you.)  </p>

<h2>Keep choices contiguous</h2>

<p>This is very easy for the compiler to implement as a single indexed jump table.</p>

<h2>Many choices, not contiguous</h2>

<p>One method is to implement an associated array (key, function pointer).  The code <em>may</em> search the table or for larger tables, they could be implemented as a linked list.  Other options are possible.</p>

<h2>Few choices, not contiguous</h2>

<p>Often implemented by compilers as an <code>if-elseif</code> ladder.</p>

<h2>Profiling</h2>

<p>The real proof is in setting compiler optimization switches and profiling.</p>

<h2>The Assembly Listing</h2>

<p>You may want to code up some switch statements and see how the compiler generates the assembly code.  See which version generates the optimal assembly code for your situation.</p>
",5
8374869,8374862,5,"<p>Yes.     </p>

<pre><code>reg[DS] == 0x10
</code></pre>

<p>Unless you have redefined the macro <code>DS</code> somewhere else in the code.<br>
Macros are evaluated at pre-compilation. So if you defined <code>DS</code> as <code>5</code> then what goes to the compiler for compilation is <code>reg[5]</code>.    </p>

<p>Also, You cannot check a macro value at run-time because they do not exist at run-time, they are already substituted with whatever value they are defined as.</p>
",0
8374880,8374862,1,"<p>Your understanding that <code>reg[DS]</code> refers to the fifth (that is, the last) element of <code>reg</code> is correct.</p>

<p>If you think that a different element might be getting accessed, I'd make sure that you're not redefining <code>DS</code> to a different value else by accident, and that <code>DS</code> isn't clashing with a symbol defined by one of the headers that you're including.</p>

<p>Note that <code>DS</code> does not exist at run time. Even the compiler does not see get to see <code>DS</code>, since it will have been replaced with <code>5</code> by the preprocessor. This is what could be tripping up the debugger.</p>
",0
4156708,4156585,4,"<p>In e.g. Codewarrior, you can place labels around a function, e.g.</p>

<pre><code>label1:
void someFunc()
{
    /* code goes here. */
}
label2:
</code></pre>

<p>and then calculate the size like <code>(int)(label2-label1)</code>, but this is obviously very compiler dependent.  Depending on your system and compiler, you may have to hack linker scripts, etc.</p>
",3
4156596,4156585,14,"<p>There is no way in standard C to get the amount of memory occupied by a function.</p>
",5
4156604,4156585,1,"<p>There is no standard way of doing it either in C or C++. There might naturally exist implementation/platform-specific ways of doiung it, but I am not aware of any</p>
",0
4156920,4156585,5,"<p>Executables (at least ones which have debug info stripped) doesn't store function lengths in any way. So there's no possibility to parse this info in runtime by self. If you have to manipulate with functions, you should do something with your objects in linking phase or by accessing them as files from your executable. For example, you may tell linker to link symbol tables as ordinary data section into the executable, assign them some name, and parse when program runs. But remember, this would be specific to your linker and object format.</p>

<p>Also note, that function layout is also platform specific and there are some things that make the term ""function length"" unclear:</p>

<ol>
<li>Functions may have store used constants in code sections directly after function code and access them using PC-relative addressing (ARM compilers do this).</li>
<li>Functions may have ""prologs"" and ""epilogs"" which may may be common to several functions and thus lie outside main body.</li>
<li>Function code may inline other function code</li>
</ol>

<p>They all may count or not count in function length.</p>

<p>Also function may be completely inlined by compiler, so it loose its body.</p>
",1
4157205,4156585,2,"<p>There's no facility defined within the C language itself to return the length of a function; there are simply too many variables involved (compiler, target instruction set, object file/executable file format, optimization settings, debug settings, etc.).  The very same source code may result in functions of different sizes for different systems.  </p>

<p>C simply doesn't provide any sort of reflection capability to support this kind of information (although individual compilers may supply extensions, such as the Codewarrior example cited by sskuce).  If you need to know how many bytes your function takes up in memory, then you'll have to examine the generated object or executable file directly.  </p>

<p><code>sizeof func</code> won't work because the expression <code>func</code> is being treated as a pointer to the function, so you're getting the size of a pointer value, not the function itself.  </p>
",2
4158693,4156585,4,"<p>The start of the function is the function pointer, you already know that.</p>

<p>The problem is to find the end, but that can be done this way:</p>

<pre><code>#include &lt;time.h&gt;

int foo(void)
{
   int i = 0;
   ++i + time(0); // time(0) is to prevent optimizer from just doing: return 1;
   return i;
}

int main(int argc, char *argv[])
{
   return (int)((long)main - (long)foo);
}
</code></pre>

<p>It works here because the program has ONLY TWO functions so if the code is re-ordered (main implemented before foo) then you will get an irrelevant (negative) calculation, letting you know that it did not work this way but that it WOULD work if you move the foo() code into main() - just substract the main() size you got with the initial negative reply. </p>

<p>If the result is positive, then it will be correct -if no padding is done (yes, some compilers happily inflate the code, either for alignment or for other, less obvious reasons).</p>

<p>The ending (int)(long) cast is for portability between 32-bit and 64-bit code (function pointers will be longer on a 64-bit platform).</p>

<p>This is faily portable and should work reasonably well.</p>
",0
4007199,4007170,2,"<blockquote>
  <p>How do you convert a uint8_t to a
  uint16_t?</p>
</blockquote>

<p>By simply assigning:</p>

<pre><code>uint8_t  val_u8  = ...
uint16_t val_u16 = val_u8;
</code></pre>

<p>I think that the question you wanted to ask is ""how do you <em>combine</em> uint_8 to a uint_16?""</p>

<p><strike>
I am guessing that you may have problem in the line</p>

<pre><code>CO2Val = (buf[0]&lt;&lt;8)|buf[1];
</code></pre>

<p>if <code>buf[ 0 ]</code> is <code>uint8_t</code>. Cast it to <code>uint16_t</code> before doing the bit-shift to ensure room for the 8 bits (or else, the bits would ""fall off"" the MSB edge)</p>

<pre><code>uint16_t CO2Val = ( (uint16_t) buf[0] &lt;&lt; 8) | buf[1];
</code></pre>

<p></strike></p>
",1
4007244,4007170,1,"<p><strike>My guess is that you're really using C++, not C, and the <code>buf[0]&lt;&lt;8</code> etc. are exhibiting undefined behavior due to the shift size being at least the width of the type.</strike> In C, this would not happen, since arithmetic operands are always promoted at least to <code>int</code>.</p>

<p>Anyway, let's try some simpler, more legible code:</p>

<pre><code>packetBuffer.header[0] = co2Val/256;
packetBuffer.header[1] = co2Val;
packetBuffer.header[2] = humVal/256;
packetBuffer.header[3] = humVal;
packetBuffer.header[4] = tempVal/256;
packetBuffer.header[5] = tempVal;
</code></pre>

<p>and:</p>

<pre><code>CO2Val = buf[0]*256+buf[1];
HumVal = buf[2]%16*256+buf[3];
TempVal = buf[4]%64*256+buf[5];
</code></pre>

<p>I've left in place your truncation of the upper bits of <code>HumVal</code> and <code>TempVal</code>, but it might be better practice to instead check for out-of-range values and issue an error of some sort.</p>

<p><strong>Edit:</strong> Since OP clarified that the language is C, I'm unsure what is wrong. It seems we're still missing information. Perhaps looking at a dump of the buffers involved would be informative.</p>
",1
4238617,4238581,2,"<p>Consider</p>

<pre><code>for(i=0;i&lt;3;i++){ 
    for(j=0;j&lt;3;j++){ 
        fscanf(fp,""%d"",&amp;mat[i][j]); 
} 
printf(""%d\n"",mat[i][j]); //problem here  
</code></pre>

<p>being:</p>

<pre><code>for(i=0;i&lt;3;i++){ 
    for(j=0;j&lt;3;j++){ 
        fscanf(fp,""%d"",&amp;mat[i][j]); 
        printf(""%d "",mat[i][j]);
    }     
    printf(""\n"");
} 
</code></pre>

<p>What you posted prints outside the bounds of the array</p>
",1
4238631,4238581,1,"<p>You are trying to read integers into space allocated for characters - your <code>malloc()</code> operations are in terms of <code>sizeof(char *)</code> and <code>sizeof(char)</code> when you need to be using <code>int</code>.  This is going to cause problems.</p>

<p>You should review where your print is in relation to your scan; at the moment, you attempt to print only the last number in each row of data, but you need to think about what the value of <code>j</code> is at the point where the print appears.</p>

<p>You should probably also be checking the return status from <code>scanf()</code> to ensure that the data is valid.  You should probably also be closing the input file; although the program immediately exits at the moment, 'release resources you acquire' is a good discipline to get into.  The same comment could be applied to the dynamically allocated array, too (release what you allocate).</p>
",0
3297684,3297636,1,"<p><code>intcomp</code> is an ""Int Compare"" function. It is passed a pointer to 2 ints and returns 0 if they are the same, a positive value is x > y and a negative value is x &lt; y.</p>

<p><code>qsort</code> is passed a pointer to this function and calls it each time it wants to know how to sort a pair of values. </p>

<p>The docs for <code>qsort</code> should give you some more details.<br>
eg <a href=""http://www.cppreference.com/wiki/c/other/qsort"" rel=""nofollow noreferrer"">http://www.cppreference.com/wiki/c/other/qsort</a></p>
",1
3297686,3297636,1,"<p><code>qsort</code> is in <code>stdlib.h</code>, so include that file at the beginning. Note that <code>algorithm</code> and <code>iostream</code> aren't needed.</p>

<p><code>#include &lt;stdlib.h&gt;</code></p>
",1
3297687,3297636,4,"<p>the qsort() function requires a pointer with a particular signature.<br>
Your function has the wrong signature so it is complaining.</p>

<p>Your function has the signature:</p>

<pre><code>int intcomp(int *x,int *y)
</code></pre>

<p>While qsort requires the signature:</p>

<pre><code>int intcomp(void const* xp,void const* yp)
</code></pre>

<p>Please note the difference in the parameter types.</p>

<p>A corrected version of the function is:</p>

<pre><code>int intcomp(void const* xp,void const* yp)
{
  // Modified for C as the tag on the question changed:
  // int x = *static_cast&lt;int const*&gt;(xp);
  // int y = *static_cast&lt;int const*&gt;(yp);
  int x = *((int const*)(xp));
  int y = *((int const*)(yp));

  return x-y;
}
</code></pre>

<p>The function qsort() is passed a function pointer as the third parameter.<br>
This function pointer (in your case intcomp()) is used to compare values in the array passed. Each call provides pointers into the array. The result of the function should be:</p>

<pre><code>Less than 0:    if x is smaller than y
0:              If x is equal to y
Greater than 0: If x is larger than y
</code></pre>
",3
3297723,3297636,0,"<p>As Martin York mentioned, qsort needs a function which it will use to compare the values:</p>

<pre><code>void qsort( void *buf, size_t num, size_t size, int (*compare)(const void*, const void *) );
</code></pre>

<p>Here is a good example on how to use qsort: <a href=""http://www.cppreference.com/wiki/c/other/qsort"" rel=""nofollow noreferrer"">http://www.cppreference.com/wiki/c/other/qsort</a></p>

<p>Edit: Ri was faster....</p>
",0
3297846,3297636,1,"<p>First of all: the question is labeled C++ and you #include &lt;algorithm&gt; and &lt;iostream&gt;, but your code is 100% C.</p>

<p>Martin York already gave the answer how to correct the signature of the function you pass to qsort().</p>

<p>However, the ""true""(TM) C++ solution would be to use std::sort&lt;> instead of qsort!</p>

<pre><code>#include &lt;algorithm&gt;    
#include &lt;stdio.h&gt;    

bool intcomp(int a, int b) { return a&lt;b; }
int a[10000];    
int main(void){    
    int n=0;    
     while (scanf(""%d"",&amp;a[n])!=EOF)    
          n++;    
     std::sort(&amp;a[0], &amp;a[n], intcomp);
      for (int i=0;i&lt;n;i++)    
           printf(""%d\n"",a[i]);    
       return 0;    
}
</code></pre>

<p>Note that incomp() takes ints and not int pointers, and returns a bool. Just like operator&lt;() would.</p>

<p>Also note that in this case, you could forget the intcomp and just use std::sort(&amp;a[0], &amp;a[n]), which will use std::less&lt;>, which will use operator&lt;(int, int).</p>
",0
4147698,4147681,6,"<p>1290323123123 requires 41 bits to store, but that <code>long</code> probably is just 32-bit long, so the extra 9 bits are gone.</p>

<pre><code>1290323123123 = 0x12c6d405bb3
                  ^^^
                  excessive data that is chopped off

              =    0x6d405bb3

              = 1832934323
</code></pre>

<p>Use</p>

<pre><code>#include &lt;inttypes.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main () {
    int64_t x = 1290323123123LL;
//  ^^^^^^^                  ^^
    int len = snprintf(NULL, 0, ""%""PRId64, x);
//                                ^^^^^^^
    printf(""%""PRId64"" %d\n"", x, len);
//           ^^^^^^^^
    return 0;
}
</code></pre>

<p>to make sure the type is at least 64-bit long, so it can store that value completely (result: <a href=""http://www.ideone.com/BnTjJ"" rel=""nofollow"">http://www.ideone.com/BnTjJ</a>).</p>
",1
4147734,4147681,2,"<p>Your 'long' type can only hold 4 bytes.  The value you've assigned 'x' is greater than 4 bytes.  </p>

<pre>
Hex(1290323123123) = 12C 6D40 5BB3
Hex(1832934323 ) = 6D40 5BB3 
</pre>

<p>So the number it's outputting is the same as the lower 4 bytes of the number you're trying to print.</p>

<p>Some compilers may have larger 'long' types - prior to C99 and the introduction of types like <code>int64_t</code> I don't think there is one standard for (name, size) pairs.</p>
",0
5189519,5189071,0,"<p>Try</p>

<pre><code>char* strSth = ""something""; 
std::string strPart; 
strPart.assign(strSth+3,strSth+8);
std::cout &lt;&lt; strPart;
</code></pre>

<p>The result will be : ""ethin""</p>
",1
5189121,5189071,1,"<p>This Would do the Job Considering you want to print only ""<strong>ethin</strong>"" not ""<strong>ething</strong>"".</p>

<p><strong>As @Mahesh said in his comment you must give the start and end position from where you want to print characters to make your program more general.</strong></p>

<p><code>Char *p =""Something"";</code></p>

<p><code>char *temp=p;</code> //Considering you may require at some point on time the base address of your string.</p>

<p><code>temp=temp+3;</code></p>

<p><code>while(*temp!='g')</code></p>

<p><code>printf(""%c"",*temp++);</code></p>

<p>If you would be more specific about your requirement we can further help you.<strong>These are the basics of C language thus you must thoroughly study arrays,pointers in c.</strong></p>

<p><strong>EDIT:</strong> </p>

<p>I won't be able to give you the complete code as this would be against the Stackoverflow rules and moto which is like ""<strong>Technical Repository And Next To Heaven""</strong> for programmers.Thus i can only give you the logic.</p>

<p><strong>Keep on printing characters untill both start and end position becomes equal or their difference becomes zero.You can choose any of the above two methods.</strong> </p>
",2
5191818,5189071,26,"<p>You can use the <code>printf</code> precision specifier</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
  char s[] = ""something"";
  int start = 3;
  int len = 5;

  printf(""%.*s\n"", len, s + start);

  return 0;
}
</code></pre>

<p>Code also posted to codepad: <a href=""http://codepad.org/q5rS81ox"">http://codepad.org/q5rS81ox</a></p>
",0
5491044,5491026,3,"<p>This is K&amp;R (old) style, it works, but..</p>
",0
5491057,5491026,2,"<p>That's just old style, pre-ANSI C. The whole notion of function declarations with type parameters wasn't introduced until later!</p>
",0
5491079,5491026,3,"<p>That's just the old <a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language"" rel=""nofollow"">(K&amp;R)</a> way of declaring parameters in C.</p>

<pre><code>/* Old way of declaring parameters*/
void myFunc(a, b)
  int a; int b;
{
    ...
}
</code></pre>

<p>Nobody does it that way anymore, unless you need to compile your code on a <em>really</em> old compiler - so either sed was written with old compilers in mind, or that code is really old.</p>
",0
3998815,3998802,30,"<p>It explicitly means you ignore the return value, and did not just forget it.</p>
",4
7776636,7776621,1,"<p>To get a char, you'll want to use <code>%c</code>.</p>
",1
4909899,4909880,0,"<p>Pointer to pointer is initialized as array of pointers. So call <code>malloc(count * sizeof(ProcessInfo*))</code> to initialize it. This way you get array of pointers to ProcessInfo. Then call <code>malloc(sizeof(ProcessInfo))</code> many times to create particular <code>ProcessInfo</code> structures and put pointers to them to the array.</p>

<p>Also, user470379 is right that you don't need pointer to pointer just to change number of items in your array. But your idea is actually not bad either, you can stay with it if you want.</p>

<p>Also, since you are familiar with C#, I would recommend you to start with writing something like ArrayList in C. Then you can use it in many situations (like this one).</p>
",0
4909902,4909880,1,"<p>You don't need a double pointer to increase/decrease the size. Just use a normal pointer and <a href=""http://linux.die.net/man/3/realloc"" rel=""nofollow""><code>realloc</code></a>.</p>

<pre><code>struct ProcessInfo* processes = malloc(sizeof(struct ProcessInfo) * 2);
struct ProcessInfo* processes_tmp;

if (!processes) {
   /* bail */
}

/* do whatever with processes[0] and [1] */

processes_tmp = processes;
processes = realloc(processes, sizeof(struct ProcessInfo) * 5);
if (!processes) {
    free(processes_tmp);
    /* bail */
}

/* processes[0] and [1] are unchanged, and [2] [3] and [4] are now valid */
</code></pre>

<p>Then instead of having a <code>ProcessInfo_Allocate</code>, you could create a <code>ProcessInfo_Init</code> that would do most of the same except not allocating the memory:</p>

<pre><code>int ProcessInfo_Init(struct ProcessInfo *pi, int processId, char *processName, int priority, int executionTime)
{
    if (!pi) {
        return -1;
    }
    pi-&gt;ProcessId = processId;
    pi-&gt;ProcessName = processName;
    pi-&gt;Priority = priority;
    pi-&gt;ExecutionTime = executionTime;
    pi-&gt;EllapsedTime = 0;

    return 0;
}
</code></pre>
",0
4909922,4909880,0,"<p>First change your definition to:</p>

<pre><code>typedef struct Scheduler {
    struct ProcessInfo** Processes;
} Scheduler;
</code></pre>

<p>Then something like this:</p>

<pre><code>Scheduler *s;
s = malloc(sizeof(Scheduler));
if (s == NULL) {
  exit(-1);
}
s = memset(s, 0, sizeof(Scheduler));
/* Or enter your own memory allocation stuff here */
i = 0; /* Or use some other number */
s-&gt;Processes[i] = someProcessInfo;
</code></pre>
",2
4909925,4909880,1,"<pre><code>struct Scheduler s;
s.Processes = malloc(sizeof(struct ProcessInfo*) * size);
s.Processes[0] = ProcessInfo_Allocate(...);

// Add more items:
s.Processes = realloc(malloc(sizeof(struct ProcessInfo*) * (size + 1));
s.Processes[size] = ProcessInfo_Allocate(...);
size++;
</code></pre>

<p>Also see my example here:</p>

<p><a href=""https://stackoverflow.com/questions/4908296/array-of-c-structs/4908332#4908332"">Array of C structs</a></p>
",3
4909946,4909880,1,"<pre><code>size_t size = 10;//or what ever is the number of processes
struct ProcessInfo * process = (struct ProcessInfo *)malloc(size * sizeof(struct ProcessInfo));
if(!process)
    //perhaps stop program? Do something
Processes = &amp;process;
//later on
int i;
for(i = 0; i &lt; size; i++)
{
   printf(""Process id =%d"",Processes[i]-&gt;ProcesId);
   etc
}
</code></pre>
",0
3312259,3312239,7,"<p>You are accessing memory outside the bounds of the array; in C, there is no bounds checking done on array indices.</p>

<p>Accessing memory beyond the end of the array technically results in <em>undefined behavior</em>.  This means that there are no guarantees about what happens when you do it.  In your example, you end up overwriting the memory occupied by another variable.  However, undefined behavior can also cause your application to crash, or worse.</p>

<blockquote>
  <p>Is there a way to catch these errors?</p>
</blockquote>

<p>The compiler can catch some errors like this, but not many.  It is often impossible to catch this sort of error at compile-time and report a warning.</p>

<p>Static analysis tools can catch other instances of this sort of error and are usually built to report warnings about code that is likely to cause this sort of error.</p>
",2
3312267,3312239,0,"<p>i's location in memory is just past the end of A.  That's not guaranteed with every compiler and every architecture, but most probably wouldn't have a reason to do it any other way.  </p>

<p>Note that counting from 0 to 9, you have 10 elements.</p>
",0
3312301,3312239,2,"<p>C does not generally do bounds-checking, but a number of people have implemented bounds-checking for C. For instance there is a patch for GCC at <a href=""http://sourceforge.net/projects/boundschecking/"" rel=""nofollow noreferrer"">http://sourceforge.net/projects/boundschecking/</a>. Of course bounds-checking does have some overhead, but it can often be enabled and disabled on a per-file basis.</p>
",0
3312302,3312239,1,"<p>The array allocation of A is adjacent in memory to i and len.  Remember that when you address via an array, it's exactly like using pointers, and you're walking off the end of the array, bumping into the other stuff you put there.</p>

<p>C by default does not do bounds checking. You're expected to be careful as a programmer; in exchange you get speed and size benefits.</p>

<p>Usually external tools, like lint, will catch the problems via static code analysis. Some libraries, depending on compiler vendor, will add additional padding or memory protection to detect when you've walked off the end.</p>

<p>Lots of interesting, dangerous, and non-portable things reside in memory at ""random spots.""  Most of the house keeping for heap memory allocations occur in memory locations before the one the compiler gives you.</p>

<p>The general rule is that if you didn't allocate or request it, don't mess with it.</p>
",1
3312308,3312239,0,"<p>Array indexing starts from 0. Hence the size of array is equal to one less than the declared value. You are overwriting the memory beyond what is allowed. </p>

<p>These errors may not be reported as warnings but you can use tools like prevent, sparrow, Klockworks or purify to find such ""malpractices"" if i may call them that. </p>
",0
3313115,3312239,0,"<p>The short answer is that local variables are al-located on stack, and indexing is just like *(ptr + index). So it could happen that the room for int y[N] is adjacent to the room for another int x; e.g. x is located after the last y. So, y[N-1] is this last y, while y[N] is the int past the last y, and in this case, by accident, it happens you get x (or whatever in your practical example). But it is absolutely not a sure fact what you can get going past the bounds of an array and so you can't rely on that. Even though undetected, it's a ""index out of bound error"", and a source of bugs.</p>
",0
4243510,4243488,4,"<p>I think your question is going to be 'everything is *' and that's because of this part of your giant <code>if</code>: </p>

<p><code>if (s[j] = 'a'</code></p>

<p>That will always be true. You need the <code>==</code></p>

<p>Also you put <code>j++</code> too early - you'd skip characters because you immediately increment upon entering the loop.</p>
",0
4243534,4243488,4,"<p>By incrementing the <code>j</code> at the beginning you will lose the <code>0</code> index (the first character).</p>

<p>Since you want to return new data to the outside world (outside the function scope), you either allocate memory for the new data outside the function, and pass in a pointer of that data to this function, or you just allocate dynamic memory inside this function - remember to delete it.</p>

<p>One implementation would be:</p>

<pre><code>char *star_vowels(char s[]){
    // let's allocate memory for the new string.
    // its size should be strlen(s) + 1 (the ending char).
    char *final = malloc(strlen(s) + 1); 

    int j = 0;
    while (s[j] != 0){
        if (s[j] == 'a' || s[j] == 'e' || s[j] == 'i' || s[j] == 'o' || s[j] == 'u'){
            final[j] = '*';
        } else {
            final[j] = s[j];
        }
        j++;
    }
    final[j] = 0; // end the string
    return final;
}
</code></pre>

<p>Working example: <a href=""http://codepad.org/dd2w5cuy"" rel=""nofollow"">http://codepad.org/dd2w5cuy</a></p>
",1
4243542,4243488,6,"<p>This code has a number of things wrong with it.</p>

<p>1) <code>while (s[j] != '0')</code>
I'm fairly sure you want to be checking for the NUL character, not the character constant zero.  Change <code>'0'</code> to <code>'\0'</code></p>

<p>2) <code>j++</code>
you are incrementing j before you even look at the 0th index of your array.  If you had a vowel at s[0], this would be missed.  Move <code>j++</code> to the very bottom of the while loop, just before the ending brace.</p>

<p>3) <code>s[j] = 'a'</code>
You are using the assignment operator <code>=</code> here when you should be using the equality operator <code>==</code> instead.  Using the assignment operator is legal C code and thus will compile.  Unfortunately it will return true and you'll end up replacing all of your characters with asterisks</p>

<p>4) <code>putchar(j);</code>
You are attempting to output 'j' (your iterator) when you really want to be outputting s[j] (your character).</p>

<p>5) <code>return 0</code>
just like in #2, your return statement is in the wrong place.  You have it within the while loop when it should be <em>outside</em> of it.  The way you have it written, the while loop will only execute the first iteration before your function goes out of scope.</p>

<pre><code>int star_vowels(char s[]) {

    int j = 0;

    while (s[j] != '\0'){
        if (s[j] == 'a' || s[j] == 'e' || s[j] == 'i' || s[j] == 'o' || s[j] == 'u') {
            putchar('*');
        } else {
            putchar(s[j]);
        }
        j++;
    }
    return 0;
}
</code></pre>
",0
3930437,3930433,3,"<p>Use an array or pointer instead.  You would access it with, e.g. <code>foo[ind]</code>.</p>
",0
3930457,3930433,2,"<p>Use array:</p>

<pre><code>int foo[2] = {0, 0};
</code></pre>

<p>and then you can type</p>

<pre><code>do_work(foo[bar]);
</code></pre>
",0
3930465,3930433,1,"<p>To keep the original <code>foo1</code> and <code>foo2</code> variables, you can set up an array with pointers to those locations, and read/write to the vairables via the pointers in the array.</p>

<p>I.e.</p>

<pre><code>int *fooArray[2];
fooArray[0] = &amp;foo0;
fooArray[1] = &amp;foo1;
</code></pre>

<p>...then you can call your function with:</p>

<pre><code>do_work(*fooArray[bar]);
</code></pre>
",0
3930468,3930433,0,"<p>arrays are designed to hold values of homogeneous data types and nobody will use foo0, foo1 for this kind of requirement</p>
",0
3930483,3930433,0,"<p>Since you say you're not concerned with good or bad practice, you could implement the behaviour you want without introducing any new variables:</p>

<pre><code>if (bar == 0)
    do_work(foo0);
else if (bar == 1)
    do_work(foo1);
else
    puts(""Uh oh, unexpected bar value!"");
</code></pre>
",0
3930493,3930433,4,"<p>C doesn't work in the way that perhaps you are thinking. You cannot dynamically refer to the name of a variable at runtime like you may be used to in other languages.</p>

<p>That said, the name of the function's arguments is irrelevant. </p>

<pre><code>void do_work(int arg)
{
} 
</code></pre>

<p>You don't have to match up the name of <code>arg</code> with <code>foo0</code> or <code>foo1</code>. Now you can pass either variable into the function:</p>

<pre><code>int foo0, foo1;

if (some_condition)
  do_work(foo0);
else
  do_work(foo1);
</code></pre>

<p>Now the function <code>do_work</code> will be working on a copy of the variable passed. So if you change the variable's value inside the function, it will still remain the same outside the function. You can change that by returning a new value:</p>

<pre><code>int do_work(int arg)
{
  return arg + 1;
}

foo0 = do_work(foo0);
</code></pre>

<p>Lastly, it sounds like you want to use an array:</p>

<pre><code>int foo[2]; // create two ints: foo[0] and foo[1]

do_work(foo[0]);

int i = 1;
do_work(foo[i]);
</code></pre>
",0
3930520,3930433,4,"<p>By special request of @dreamlax:</p>

<p>1) declare these variables as </p>

<pre><code>__declspec( dllexport ) static int foo1;
__declspec( dllexport ) static int foo2;
</code></pre>

<p>2) Use <code>HANDLE this_module = GetModuleHandle(NULL);</code> to obtain the current module</p>

<p>3) Obtain the name of the needed variable:</p>

<pre><code>char vname[100];
sprintf(vname, ""foo%d"", bar);
</code></pre>

<p>4) Find it:</p>

<pre><code>int* fooX = (int*)GetProcAddress(this_module, vname);
</code></pre>

<p>5) And, finally, you can use it:</p>

<pre><code>  do_work(fooX);  // or *fooX, as you like
</code></pre>
",5
3930580,3930433,0,"<p>Here's a bad idea for you:</p>

<pre><code>#define foo0 foo[0]
#define foo1 foo[1]
#define foobar foo[bar]

int foo[2];
int bar;
</code></pre>
",0
3860931,3860919,8,"<p>Your second <code>printf</code> call is wrong.  It should be:</p>

<pre><code>printf(""baseMetadataPtr-&gt;message_ID: %p\n"", &amp;baseMetadataPtr-&gt;message_ID);
//         need to use %p for pointer ^     ^ need unary-&amp; operator
</code></pre>

<p>As written right now, the integer value of <code>message_ID</code> is being  printed.  You need to take the address of <code>baseMetadataPtr-&gt;message_ID</code>.  Also note that if you want to print a pointer, you should use the <code>%p</code> format specifier, not <code>%d</code> (which prints an integer).</p>

<p>The address of the first data member of a struct-type object will always be the same as the address of the struct-type object itself.  This is guaranteed because no padding is permitted at the beginning of a struct (padding is permitted between data elements or at the end of the struct, though).</p>
",4
3860938,3860919,0,"<p>This prints the memory address of the pointer:</p>

<pre><code>printf(""baseMetadataPtr: %d\n"", baseMetadataPtr); 
</code></pre>

<p>and this prints the memory address of the variable inside the struct:</p>

<pre><code>printf(""baseMetadataPtr-&gt;message_ID: %d\n"", &amp;baseMetadataPtr-&gt;message_ID); 
</code></pre>

<p>And that's why they are not neighbors.</p>
",0
3860940,3860919,0,"<p><code>baseMetadataPtr-&gt;message_ID</code> prints the <em>value</em> of the variable <code>message_ID</code>. Since you have not initialized it, it is containing garbage. To print its address you need to do <code>&amp;baseMetadataPtr-&gt;message_ID</code>. Also, you need to use the format specifier <code>%p</code> to print pointer values.</p>
",0
3860942,3860919,0,"<p>The first printf() prints the current value of the pointer, IE, what address it is pointing.</p>

<p>The second printf prints the value of the Metadata member message_ID.</p>

<p>To get what you want, try: printf(""baseMetadataPtr->message_ID: %d\n"", &amp;baseMetadataPtr->message_ID);</p>
",0
3862372,3860919,1,"<p>I like drawings. They help me ""see"" stuff</p>

<pre><code>struct Metadata *baseMetadataPtr;
baseMetadataPtr = malloc(100 * sizeof *baseMetadataPtr);
</code></pre>

<p>With that, and assuming a linear memory (the boxes below), and ignoring the space requirements for the different objects, we have</p>

<pre>
|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|...|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|...
   ^^^^^^^ baseMetadataPtr
  (of type (struct Metadata *))

   ******* ===========================>
|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|...|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|...
   ^^^^^^^ baseMetadataPtr             ^^^^^^ ^^^^^^^ ^^^^^^^ ^^^^^ ^^ ...
  (of type (struct Metadata *))        *baseMetadataPtr (struct Metadata)
                                               *(baseMetadataPtr+1)
                                                      baseMetadataPtr[2]

</pre>

<p>And, zooming in on the part on the left</p>

<pre>
   *baseMetadataPtr
|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|...
   ^^^ Message_ID (type (int))
       ^^^^^^^ Message_Len (type (size_t))
               ^^^^ ... other members, followed by another object of type (struct Metadata)
</pre>
",0
3917707,3917691,4,"<pre><code>void menu (int argc, char ** argv)
{
   speed(argc, argv); // this is how you call a function
}
</code></pre>

<p>For this to work either speed needs to be defined above menu, or a declaration of it needs to be before it or in a header.  Declaration of speed looks like</p>

<pre><code>void speed (int argc, char ** argv);
</code></pre>
",0
3918102,3917691,1,"<p>What Franco was talking about are called <em>function prototypes</em>. C parses (or compiles) your code from top down, so if it hits your call to <em>speed</em> before it hits your declaration of <em>speed</em> it complains. To workaround this, you need to create a <em>function prototype</em> as a <em>forward reference</em> to the function. Generally, it is good practice to write prototypes for all your functions at the top of your code, or in another file (aka the <em>header</em> file) and #include it.</p>

<pre><code>/* helloworld.h */
void speed (int , char **);
void menu (int , char **);



/* helloworld.c */
#include ""helloworld.h""
void menu (int argc, char **argv){
   speed (argc, argc);
}
</code></pre>
",0
3864158,3864135,0,"<p>No, you can not.  You can write a library that will be used from another program.  But everything must have a beginning, and 'main' is the beginning of a C program...</p>

<p>(On Windows, the Win32 API specifies a WinMain, but it's the same thing, with a different name.)</p>
",1
3864184,3864135,0,"<p>No, without the main method, the linker will not know where the start of the data segment in the program will start.</p>
",0
3724588,3724526,17,"<p>You can try:</p>

<pre><code>float RandomBetween(float smallNumber, float bigNumber)
{
    float diff = bigNumber - smallNumber;
    return (((float) rand() / RAND_MAX) * diff) + smallNumber;
}
</code></pre>
",0
3724597,3724526,5,"<p>You should be able to use something like:</p>

<pre><code>double x = ((double)rand()) / ((double)RAND_MAX) / 2.0 + 0.5;
</code></pre>

<p>The division by <code>RAND_MAX</code> gives you a value from 0 to 1, dividing that by two drops the range to 0 to 0.5, then adding 0.5 gives you 0.5 to 1. (inclusive at the low end and exclusive at the top end).</p>
",0
3724668,3724526,1,"<p>Some thing like bellow will help you.</p>

<pre><code>double random(double start, double end)
{
    double moduleValue = ((end - start) *10); //1.0 - .5 --&gt; .5 --&gt;&gt; 5
    double randum = rand() % moduleValue; // restrict the random to your range
    //if rendum == 2 --&gt; .2 + .5 --&gt; .7 in the range .5 -- 1.0

    return (randum / 10) + start; // make your number to be in your range
}
</code></pre>

<p>Test code for clarification</p>

<pre><code>#include &lt;stdio.h&gt;
#define RAND_NUMBER 14
#define INT_FLAG 10
int main (int argc, const char * argv[]) {
    // insert code here...
    double start = .5;
    double end = 1.0;

    double moduleValue = ((end - start) * INT_FLAG);

    int randum = (RAND_NUMBER / moduleValue);

    double result = ((double)randum/INT_FLAG) + start;
    printf(""%f"",result);
    printf(""Hello, World!\n"");
    return 0;
}
</code></pre>
",2
3486477,3486202,0,"<ol>
<li>If you really only need this to get
the maximum pair, this is really the
wrong strategy: too complicated and
unnecessarily slow. Just use a <code>for</code>
loop to run through your deck and
pick the largest pair that you have
seen so far.</li>
<li>Your comparison code for the cards
shows that you have not modularized
your program enough. If
you insist to code your cards in an
integer as it seems, don't use
shifts and alike to access the
different parts, but bitfields.</li>
</ol>
",0
3486291,3486202,1,"<p>One probable problem is at the end of the 'compare' loop:</p>

<pre><code>if(numpairs!=0)
    temp2=findwinner(hands[cd]);
</code></pre>

<p>Since 'cd' is out of range at the time, you get odd results.  You would have to explain more for us to be sure about what is right.</p>

<p>You should unit test your sort code.  The shift is not really necessary; the bit masking ensures that the values are monotonically increasing ignoring suit, which is presumably what is being shifted out.</p>

<hr>

<p>I've taken a look at the complete code (which is missing a pair of close braces before the function <code>findpairs()</code> is defined).  It doesn't need the <code>&lt;windows.h&gt;</code> header to compile, which is good.  The core code - that which shuffles the cards etc - seems to be solid enough.  There are lots of nit-picky changes I'd make, but it is OK.</p>

<p>One subtle detail: the card comparison routine doesn't sort the array '2H 2C 2S 2D 3S' so that the deuces are in any specific suit order.  This might matter later; the person with '2C 2S' might win over the person with '2D 2H' because 2S is ranked higher than any of the other deuces.  And if that's not the case, you still need to nail down what the rules are.  You also need to consider how many pairs there are in the hand '2H 2C 2S 2D 3S' - 6 would be a reasonable answer.</p>

<p>The <code>findpairs()</code> code has an interesting piece in the middle; I think you should be using a double loop, with the inner loop finding the end of the range of equal value cards.</p>

<p>The lines I originally highlighted are where your problems start - I don't think you've properly formulated how you determine the winner because you aren't keeping the necessary information.  The condition '<code>numpairs!=0</code>' is always true because <code>numpairs</code> is an array, and the pointer is never the null pointer.</p>

<p>Also, when the <code>findwinner()</code> function is called, <code>cd</code> is 6, and therefore the behaviour is undefined.  Since you immediately throw the returned value away, some of it doesn't matter.</p>

<p>Clearly, you need to work hard on:</p>

<ul>
<li>How to handle triples and quadruples</li>
<li>How to determine winners</li>
</ul>

<p>But your original question about using <code>qsort()</code> can be answered ""you are using it OK"".</p>

<p>I note, in passing, that there are places where you compare card values for equality with expressions like:</p>

<pre><code>if (values[(hands[hand][cd]&amp;0x3C)&gt;&gt;2] == values[(hands[hand][cd]&amp;0x3C)&gt;&gt;2])
</code></pre>

<p>There is no need to reference the <code>values</code> array in this.  It works OK, but it is unnecessary.</p>

<hr>

<p>Revised code - no determination of winner, but slightly neater in other respects.
Can be compiled with '-DVERBOSE_NAMES' to have cards printed out with long names.
Otherwise, it uses short names: 'AC' for ace of clubs, '2H' for deuce of hearts, 'TD' for ten of diamonds, and 'KS' for king of spades.  It requires a C99 (or C++) compiler because of the way it declares variables in loops and uses inline functions, etc.  (Tested: GCC 4.5.1 and G++ 4.5.1 on MacOS X 10.6.4.)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

enum { NUM_HANDS      =  5 };
enum { CARDS_PER_HAND =  7 };
enum { CARDS_PER_DECK = 52 };

typedef unsigned char card;
typedef unsigned char pairs;

static const char *values[]=
{
    ""Ace"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"",
    ""Seven"", ""Eight"", ""Nine"", ""Ten"", ""Jack"", ""Queen"", ""King""
};
#ifdef VERBOSE_NAMES
static const char *suits[] = { ""Hearts"", ""Diamonds"", ""Clubs"", ""Spades"" };
static const char *colour[]= { ""Black"", ""Red"" };
#endif /* VERBOSE_NAMES */

static void printcard(card c); /* Displays the value of a card*/
static void printdeck(card deck[CARDS_PER_DECK]); /* prints an entire deck of cards*/
static void filldeck(card deck[CARDS_PER_DECK]); /* Populates a deck of cards */
static void shuffle(card deck[CARDS_PER_DECK]); /* Randomizes the order of cards */
static int  compareface(const void* c1, const void *c2);
static pairs findpairs(card *hand); /* finds any pairs in a hand */

static inline int card_value(card c)  { return((c &amp; 0x3C) &gt;&gt; 2); }
static inline int card_suit(card c)   { return((c &amp; 0x03)); }
static inline int card_colour(card c) { return((c &amp; 0x40) ? 1 : 0); }

static void deal(card deck[CARDS_PER_DECK], card hands[NUM_HANDS][CARDS_PER_HAND])
{
    int i = 0;
    for (int cd = 0; cd &lt; CARDS_PER_HAND; cd++)
    {
        for (int hand = 0; hand &lt; NUM_HANDS; hand++)
            hands[hand][cd] = deck[i++];
    }
}

static void printhand(int num, card hand[CARDS_PER_HAND])
{
#ifdef VERBOSE_NAMES
    printf(""\tHand %i:\n"", num);
#else
    printf(""\tHand %i:"", num);
#endif /* VERBOSE_NAMES */
    for (int cd = 0; cd &lt; CARDS_PER_HAND; cd++)
    {
        printcard(hand[cd]);
    }
}

static void printhands(card hands[NUM_HANDS][CARDS_PER_HAND])
{
    int i;
    for (i = 0; i &lt; NUM_HANDS; i++)
    {
        printhand(i+1, hands[i]);
        putchar('\n');
    }
}

int main()
{
    card deck[CARDS_PER_DECK];
    card hands[NUM_HANDS][CARDS_PER_HAND];
    pairs numpairs[NUM_HANDS];

    printf(""(__)(__)(__)(__) CARD  GAME (__)(__)(__)(__)(__)\n"");
    printf(""(__)(__)(__)(__)(__)(__)(__)(__)(__)(__)(__)(__)\n\n"");
    printf(""\t====== Before Shuffling =====\n\n"");
    srand(time(NULL));  /* seed the random number generator */

    filldeck(deck);
    printdeck(deck);
    printf(""\t========== Shuffled Cards ========\n\n"");
    shuffle(deck);
    printdeck(deck);
    deal(deck, hands);
    printf(""\t============= Hands ===========\n\n"");
    printhands(hands);
    putchar('\n');

    printf(""\t============= Analysis ===========\n\n"");
    for (int hand = 0; hand &lt; NUM_HANDS; hand++)
    {
        qsort(hands[hand], CARDS_PER_HAND, sizeof(card), compareface);;
        printhand(hand+1, hands[hand]);
        numpairs[hand] = findpairs(hands[hand]);
    }

    return 0;
}

static pairs findpairs(card *hand)
{
    card pair = 0;
    pairs numpairs = 0;

    for (int cd1 = 0; cd1 &lt; CARDS_PER_HAND; cd1++)
    {
        for (int cd2 = cd1 + 1; cd2 &lt; CARDS_PER_HAND; cd2++)
        {
            if (card_value(hand[cd1]) == card_value(hand[cd2]))
            {
                numpairs++;
                pair = hand[cd1];
            }
        }
    }

    if (numpairs &gt; 0)
        printf(""    %d pairs - highest pair is: %s\n"", numpairs,
              values[card_value(pair)]);
    else
        printf(""    0 pairs\n"");
    return numpairs;
}

void filldeck(card deck[CARDS_PER_DECK])
{
    int i = 0;
    for (int suit = 0; suit &lt; 4; suit++)
    {
        for (int value = 0; value &lt; 13; value++)
        {
            deck[i] = suit | (value&lt;&lt;2);
            if (suit &lt; 2)
                deck[i] |= 0x40;  /*card is red, so do red stuff */
            i++;
        }
    }
}

void printdeck(card deck[CARDS_PER_DECK])
{
    for (int i = 0; i &lt; CARDS_PER_DECK; i++)
    {
        printcard(deck[i]);
        if ((i % 13) == 12)
            putchar('\n');
    }
    putchar('\n');
}

#ifndef VERBOSE_NAMES
static char abbr_card_value(card c)
{
    static const char abbr_values[] = ""A23456789TJQK"";
    return abbr_values[card_value(c)];
}
static char abbr_card_suit(card c)
{
    static const char abbr_suits[] = ""CDHS"";
    return abbr_suits[card_suit(c)];
}
#endif /* VERBOSE_NAMES */

void printcard(card c)
{
#ifdef VERBOSE_NAMES
    printf(""\t%s\t of  %-8s  is  %s\n"", values[card_value(c)], suits[card_suit(c)],
           colour[card_colour(c)]);
#else
    printf(""  %c%c"", abbr_card_value(c), abbr_card_suit(c));
#endif /* VERBOSE_NAMES */
}

void shuffle(card deck[CARDS_PER_DECK])
{
    for (int i = 0; i &lt; CARDS_PER_DECK; i++)
    {
        int rnd = rand() * 52.0 / RAND_MAX;
        card c = deck[rnd];
        deck[rnd] = deck[i];
        deck[i] = c;
    }
}

int compareface(const void* c1, const void *c2)
{
    card cd1 = *((card*) c1);
    card cd2 = *((card*) c2);

    cd1 = card_value(cd1);
    cd2 = card_value(cd2);

    if (cd1 &gt; cd2)
        return +1;
    else if (cd1 &lt; cd2)
        return -1;
    else
        return  0;
}
</code></pre>
",1
3432791,3432742,1,"<ul>
<li>You have a call to <code>print(deck)</code> in there immediately after <code>srand()</code> which uses the uninitialised <code>deck</code> array.</li>
<li><code>numpairs</code>, <code>findpairs</code>, and <code>handssorted</code> are undefined</li>
<li>you are printing the entire <code>deck</code> for each hand. Is that really what you intend?</li>
<li><code>onst</code> is not valid (presumably you meant <code>const</code>)</li>
<li><code>fillDeck()</code> is not filling in the <code>.color</code> member of each <code>Card</code></li>
<li>your shuffle algorithm is suspect. See <a href=""http://en.wikipedia.org/wiki/Fisher-Yates_shuffle"" rel=""nofollow noreferrer"">Fisher-Yates shuffle</a></li>
<li>in <code>print()</code>, you are using the <code>%c</code> format specifier with a <code>const char *</code> type</li>
</ul>
",0
3432824,3432742,1,"<p>This isn't an answer to your question (I'm not actually sure what you're asking), but I will point out that your shuffling algorithm is not random.</p>

<p>First, using <code>%</code> to limit <code>rand</code> to a range of values is usually a bad idea. (See <a href=""http://c-faq.com/lib/randrange.html"" rel=""nofollow noreferrer"">Q13.16 from the comp.lang.c FAQ</a>.)</p>

<p>Second, it looks like you might be trying to implement the <a href=""http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"" rel=""nofollow noreferrer"">Fisher-Yates shuffling algorithm</a>, but your implementation is wrong.  It's easy to see that your approach of swapping with previously-swapped elements is problematic; consider shuffling a deck of three elements { 0, 1, 2 }:</p>

<pre><code>First iteration     Second iteration
------------------------------------
{ 0, 1, 2 }         { 1, 0, 2 }
                    { 0, 1, 2 }
                    { 0, 2, 1 }
------------------------------------
{ 1, 0, 2 }         { 0, 1, 2 }
                    { 1, 0, 2 }
                    { 1, 2, 0 }
------------------------------------
{ 2, 1, 0 }         { 1, 2, 0 }
                    { 2, 1, 0 }
                    { 2, 0, 1 }
</code></pre>

<p>The first column represents the possible states of the deck after the first iteration (where you swap <code>deck[0]</code> with <code>deck[rand() % 3]</code>).</p>

<p>The second column represents the possible states of the deck after the second iteration (where you swap <code>deck[1]</code> with <code>deck[rand() % 3]</code>).  </p>

<p>There are 9 equally probable states---but this is obviously wrong since there should be only 3! = 6 permutations.  And indeed, several states are duplicated, which means that they have a higher probability of occurring. (Note that even if I had proceeded to the third iteration, you'd end up with 27 states for only 6 permutations, and since 27 is not divisible by 6, you'd clearly end up with some states occurring more than others.)</p>
",0
3434073,3432742,0,"<blockquote>
  <p>This is the way I expect the results to be for every hand</p>
</blockquote>

<p>Then assign statically to the hands the desired cards. In your model every card has already unique number from 0 to 51. If deck and hand are both set of numbers then the operation is as simple as removing number from one set and adding it to another.</p>

<p>You might want to implement functions to work with such <code>int</code> sets, representing deck, hands, etc.</p>

<blockquote>
  <p>j = rand() % 52;</p>
</blockquote>

<p>If you are serious into making a game, you might want to check <a href=""https://stackoverflow.com/questions/288739/generate-random-numbers-uniformly-over-entire-range"">how to generate random numbers from a range too</a>.</p>
",0
3577241,3577079,0,"<p>This code prints all the usernames from /etc/passwd.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{  
        char buffer[128];
        char* username;
        FILE* passwdFile;

        passwdFile = fopen(""/etc/passwd"", ""r"");
        while (fgets(buffer, 128, passwdFile) != NULL)
        {
                username = strtok(buffer, "":"");
                printf(""username: %s\n"", username);
        }
        fclose(passwdFile);
        return 0;
}
</code></pre>

<p>Modify to compare <code>username</code> to your input.</p>
",1
3577383,3577079,4,"<pre><code>#include &lt;pwd.h&gt;
...

struct passwd *e = getpwnam(userName);
if(e == NULL) {
   //user not found
} else {
  //found the user
}
</code></pre>

<p>See docs <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/getpwnam.html"" rel=""nofollow noreferrer"">here</a> and <a href=""http://www.opengroup.org/onlinepubs/000095399/basedefs/pwd.h.html"" rel=""nofollow noreferrer"">here</a></p>

<p>(If you actually want to authenticate the user as well, there's more work needed though )</p>
",0
3990312,3989790,0,"<p>You should separate your 2 problems in functions, like:</p>

<pre><code>void gethist(char *s, int *hist, int len)
{ /* words here breaks on spaces (' ') */
  char *t;
  for( t=strtok(s,"" "");t;t=strtok(0,"" "") )
    if(*t)
      hist[ strlen(t)&gt;len-1?len-1:strlen(t)-1 ]++;
}

void outhist(int *hist, int len)
{
  int i;
  for( i=1; i&lt;=len; ++i )
  {
    char *s = calloc(1,5+hist[i-1]);
    sprintf(s,""%03d|"", i);
    memset( s+4, 'X', hist[i-1]);
    puts(s);
    free(s);
  }
}
</code></pre>

<p>then its easy in your main:</p>

<pre><code>int main(void)
{
  int c, hist[11] = {};

  char *s = calloc(1,1);
  while ((c = getchar()) != EOF) {
    s = realloc( s, 2+strlen(s) );
    s[ strlen(s)+1 ] = 0;
    s[ strlen(s) ] = c;
  }

  gethist(s,hist,11); free(s);
  outhist(hist,11);

  return 0;
}
</code></pre>
",0
3989901,3989790,1,"<p>To histogram the word lengths, you are going to need to know the word lengths.</p>

<ul>
<li>How do you define a word?</li>
<li>How can you measure the length of a word? Can you do it one character at a time as you read the stream, or should you buffer the input an use <code>strtok</code> or something similar?</li>
</ul>

<p>You will need to accumulate data on how many occurrences of each length occur. </p>

<ul>
<li>How will you store this data?</li>
</ul>

<p>You will need to output the results in a pleasing form. This is fiddly but not hard.</p>
",0
3989912,3989790,3,"<p>I suggest you simplify the problem by solving it for the case of one word per line, so you can use <code>fgets</code>. Here's how to <a href=""https://stackoverflow.com/questions/3876091/c-flushing-stdin/3876176#3876176"">""eat up"" lines that are too long</a>.</p>

<p>Then, as often, the central data structure is the key to solving the problem. The data structure you need is an array used as frequency table:</p>

<pre><code>int freq[11];
</code></pre>

<p>In <code>freq[1]</code>, store the number of words/lines of length 1, in <code>freq[2]</code> those of length 2, etc., and in <code>freq[0]</code> those of length >10. You don't need to store the words since the rest of the program only needs their length. Writing out the histogram should be easy now.</p>

<p>I hope this isn't too much of a spoiler.</p>
",0
3989934,3989790,9,"<p>I loved the pseudo-code! Some good thinking there, but you're still not ordering your program right.</p>

<p>As you said yourself, you can't read the text, go back and print an X in a particular row. If we establish that it can't be done, then there's no choice but to know all the values of the histogram beforehand.</p>

<p>So you should think your program as having two parts (and you'll make this kind of division in practically every program you write): first, a part that will make calculations; and then a part that will output them in a certain format (the histogram).</p>

<p>This tip should get you started! If you need further help, comment below.</p>
",6
3990059,3989790,1,"<p>I will link the answer below but since you asked for details the key seems to be this</p>

<p>Use an ARRAY of lengths i.e have an array with each element initialised to zero assume MAX wordlength to be about 30...</p>

<p>*have a flag while in the word and increment a counter every time a whitespace is NOT   encountered</p>

<p>*once out of the word flag is set to ""out"" and the corresponding word length index item in the array is incremented i.e if word length counter is w_ctr use </p>

<pre><code>array[w_ctr]++
</code></pre>

<p>*use the array as a table of reference for each line in a loop to print each line in the histogram so you can use the array and will now be able to determine weather the 'X' in the histogram is to be inserted or not</p>

<p>EDIT: sorry i didn't read the question right but the idea is simpler for Vertical histograms and the same thing can be used.</p>

<p>after the last step just print the horizontal histogram until counter exceeds current wordlength being printed</p>

<pre><code>for(ctr=0;ctr&lt;array[current_wordlength];ctr++)
     printf('X');    
</code></pre>

<hr>

<p>End</p>

<hr>

<p>the original is here <a href=""http://users.powernet.co.uk/eton/kandr2/krx113.html"" rel=""nofollow"">http://users.powernet.co.uk/eton/kandr2/krx113.html</a></p>

<p>CLC-wiki is also a place see the comments for details.</p>
",2
3992239,3992157,3,"<p>Change the order of your condition in the while loops:</p>

<p>No:</p>

<pre><code>while(c = getchar()) != EOF &amp;&amp; state != OUT)
</code></pre>

<p>Yes:</p>

<pre><code>while(state != OUT &amp;&amp; c = getchar()) != EOF)
</code></pre>
",2
3992218,3992157,4,"<p>I think you need to break out of the loop immediately when you hit the <code>else state = OUT;</code> in the while loop.  You're consuming an extra char.</p>

<p>Try changing <code>else state = OUT;</code> to </p>

<pre><code>else {
    state = OUT;
    break;
}
</code></pre>

<p><strong>EDIT</strong> To elaborate on why this works, let's evaluate this code:</p>

<pre><code>  // 1. while loop conditional
  while ((c = getchar()) != EOF &amp;&amp; state != OUT) { // get next character in word
    // 2. conditional succeeded
    if (c != ' ' &amp;&amp; c != '\t' &amp;&amp; c != '\n') // if character is not whitespace...
      ++length; // ...add one to length
    else state = OUT; // otherwise word is over
  }
</code></pre>

<p>The while loop condition (1) is determined by calling getchar and then evaluating state.  If this condition succeeds, the code enters into the success block (2).  The problem is that you assign state = OUT in the else clause, but require the conditional to be evaluated again, which means you're going to call getchar, and then see that state == OUT.  In effect, you skip processing a character you consume.</p>

<p>Short circuiting deals with the order in which a conditional is evaluated.  Take a simple example:</p>

<pre><code>int foo = 0;
int bar == 1;

if (foo &amp;&amp; bar) { ... }
</code></pre>

<p>Since <code>foo</code> is false (0), there's no need to evaluate <code>bar</code> because a false value causes an &amp;&amp; to evaluate to false regardless of the rest of the conditions.  Similarly if we wrote:</p>

<pre><code>if (bar || foo) {...}
</code></pre>

<p>then there's no need to evaluate <code>foo</code> since <code>bar</code> is true, and a true value causes an || to evaluate to true regardless of the rest of the conditionals.  The ability to skip evaluating the rest of a condition is called short circuiting.</p>

<p>In your case, if you had swapped the order of the while loop condition to</p>

<pre><code>while (state != OUT &amp;&amp; (c = getchar()) != EOF) {
</code></pre>

<p>then state != OUT would evaluate to false, which would prevent evaluation of <code>c = getchar()</code> due to short circuiting.  <a href=""http://beginners-programming-tutorials.blogspot.com/2007/08/beginners-programming-tutorials-short.html"" rel=""nofollow"">Here's a tutorial</a> on it if you want to know more.  Hope that helps.</p>
",3
3995330,3994915,2,"<p>Simplest (but also least flexible and with some pitfalls is to use scanf):</p>

<pre><code>#include &lt;stdio.h&gt;

struct Record {
  int temperature;
  unsigned int pressure_segment;
  double slope;
  int offset;
};

int readRecord(FILE* f, Record* rec) {
  if (fscanf(f, 
             ""Temperature = %i Pressure Segment %u Slope = %lf Offset = %i\n"", 
             &amp;rec-&gt;temperature, 
             &amp;rec-&gt;pressure_segment, 
             &amp;rec-&gt;slope, 
             &amp;rec-&gt;offset) == 4) {
      return 0;
  } else {
    return -1;
  }

}

Record rec;
FILE* f = fopen(""your-file-name"", ""r"");
while (!feof(f)) {
  if (readRecord(f, &amp;rec) == 0) {
    printf(""record: t: %i p: %u s: %lf o: %u\n"", 
           rec.temperature, 
           rec.pressure_segment, 
           rec.slope, 
           rec.offset);
  }
}
fclose(f);
</code></pre>

<p>For any advanced use (read anything more than quick and dirty solutions) I recommend to use some of csv libraries scattered around internet.</p>

<p>EDIT: Version of readRecord for edited question (each record on a separate line). </p>

<pre><code>int readRecord(FILE* f, Record* rec) {
  if (fscanf(f, 
    ""Temperature = %i\nPressure Segment %u\nSlope = %lf\nOffset = %i\n"", 
    &amp;rec-&gt;temperature, 
    &amp;rec-&gt;pressure_segment, 
    &amp;rec-&gt;slope, 
    &amp;rec-&gt;offset) == 4) {
      return 0;
  } else {
    return -1;
  }
}
</code></pre>
",2
3439745,3439707,4,"<p>The array element content is ONE number. You are trying to extract A DIGIT out of it. Look for masking and shifting - the &amp; and >> operators.</p>

<p><strong>EDIT:</strong></p>

<p>A mask is a string of ""0""s and ""1""s that let you isolate bits of interest out of a number. A mask containing the hex digit 0xF is used to isolate individual hex digits in a number. For example:</p>

<p><code>num        = 0x4321 (= 0100_0011_0010_0001)</code><br>
<code>mask       = 0x00f0 (= 0000_0000_1111_0000)</code><br>
<code>num &amp; mask = 0x0020 (= 0000_0000_0010_0000)</code>  </p>

<p>Shifting a number effectively brings the required bit to a required position in a number. So, shifting a number to the right by n positions will bring bit #n to place #0.</p>

<p><code>num      = 0x4321 (= 0100_0101_0010_0001)</code><br>
<code>num &gt;&gt; 8 = 0x0043 (= 0000_0000_0100_0011)</code>  </p>

<p>Combine the two operations and you have your extracted digit!</p>
",0
5486898,5485199,2,"<p>Everyone loves this guide.</p>

<p><a href=""http://beej.us/guide/bgnet/"" rel=""nofollow"">http://beej.us/guide/bgnet/</a></p>

<p>It'll help you learn how to get to grips with networking programming in C very easily.</p>
",1
4352816,4352768,0,"<p>One way I can imagine is to use a linked list to implement such a scenario, if you need all the numbers entered before the user enters something which indicates the loop termination. (posting as the first option, because have never done this for user input, it just seemed to be interesting. <strong>Wasteful but artistic</strong>)</p>

<p>Another way is to do buffered input. Allocate a buffer, fill it, re-allocate, if the loop continues (<strong>not elegant, but the most rational for the given use-case</strong>).</p>

<p>I don't consider the described to be elegant though. Probably, I would change the use-case (<strong>the most rational</strong>).</p>
",0
4352820,4352768,3,"<p>Try to implement dynamic data structure such as a <a href=""http://en.wikipedia.org/wiki/Linked_list"" rel=""nofollow"">linked list</a></p>
",2
4352822,4352768,15,"<p>The way it's often done is as follows:</p>

<ul>
<li>allocate an array of some initial (fairly small) size;</li>
<li>read into this array, keeping track of how many elements you've read;</li>
<li>once the array is full, reallocate it, doubling the size and preserving (i.e. copying) the contents;</li>
<li>repeat until done.</li>
</ul>

<p>I find that this pattern comes up pretty frequently.</p>

<p>What's interesting about this method is that it allows one to insert <code>N</code> elements into an empty array one-by-one in amortized <code>O(N)</code> time without knowing <code>N</code> in advance.</p>
",1
4352852,4352768,5,"<p>Modern C, aka C99, has <a href=""https://secure.wikimedia.org/wikipedia/en/wiki/Variable-length_array"" rel=""noreferrer"">variable length arrays</a>, VLA. Unfortunately, not all compilers support this but if yours does this would be an alternative.</p>
",3
4352928,4352768,43,"<p>This can be done by using a pointer, and allocating memory on the heap using <code>malloc</code>.
Note that there is no way to later ask how big that memory block is. You have to keep track of the array size yourself.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char** argv)
{
  /* declare a pointer do an integer */
  int *data; 
  /* we also have to keep track of how big our array is - I use 50 as an example*/
  const int datacount = 50;
  data = malloc(sizeof(int) * datacount); /* allocate memory for 50 int's */
  if (!data) { /* If data == 0 after the call to malloc, allocation failed for some reason */
    perror(""Error allocating memory"");
    abort();
  }
  /* at this point, we know that data points to a valid block of memory.
     Remember, however, that this memory is not initialized in any way -- it contains garbage.
     Let's start by clearing it. */
  memset(data, 0, sizeof(int)*datacount);
  /* now our array contains all zeroes. */
  data[0] = 1;
  data[2] = 15;
  data[49] = 66; /* the last element in our array, since we start counting from 0 */
  /* Loop through the array, printing out the values (mostly zeroes, but even so) */
  for(int i = 0; i &lt; datacount; ++i) {
    printf(""Element %d: %d\n"", i, data[i]);
  }
}
</code></pre>

<p>That's it. What follows is a more involved explanation of why this works :)</p>

<p>I don't know how well you know C pointers, but array access in C (like <code>array[2]</code>) is actually a shorthand for accessing memory via a pointer. To access the memory pointed to by <code>data</code>, you write <code>*data</code>. This is known as dereferencing the pointer. Since <code>data</code> is of type <code>int *</code>, then <code>*data</code> is of type <code>int</code>. Now to an important piece of information: <code>(data + 2)</code> means ""add the byte size of 2 ints to the adress pointed to by <code>data</code>"".</p>

<p>An array in C is just a sequence of values in adjacent memory. <code>array[1]</code> is just next to <code>array[0]</code>. So when we allocate a big block of memory and want to use it as an array, we need an easy way of getting the direct adress to every element inside. Luckily, C lets us use the array notation on pointers as well. <code>data[0]</code> means the same thing as <code>*(data+0)</code>, namely ""access the memory pointed to by <code>data</code>"". <code>data[2]</code> means <code>*(data+2)</code>, and accesses the third <code>int</code> in the memory block.</p>
",2
4353045,4352768,2,"<p>Here's a sample program that reads <code>stdin</code> into a memory buffer that grows as needed.  It's simple enough that it should give some insight in how you might handle this kind of thing.  One thing that's would probably be done differently in a real program is how must the array grows in each allocation - I kept it small here to help keep things simpler if you wanted to step through in a debugger.  A real program would probably use a much larger allocation increment (often, the allocation size is doubled, but if you're going to do that you should probably 'cap' the increment at some reasonable size - it might not make sense to double the allocation when you get into the hundreds of megabytes).</p>

<p>Also, I used indexed access to the buffer here as an example, but in a real program I probably wouldn't do that.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;


void fatal_error(void);

int main( int argc, char** argv)
{
    int buf_size = 0;
    int buf_used = 0;

    char* buf = NULL;
    char* tmp = NULL;    

    char c;
    int i = 0;

    while ((c = getchar()) != EOF) {
        if (buf_used == buf_size) {
             //need more space in the array

             buf_size += 20;
             tmp = realloc(buf, buf_size); // get a new larger array
             if (!tmp) fatal_error();

             buf = tmp;
        }

        buf[buf_used] = c; // pointer can be indexed like an array
        ++buf_used;
    }

    puts(""\n\n*** Dump of stdin ***\n"");

    for (i = 0; i &lt; buf_used; ++i) {
        putchar(buf[i]);
    }

    free(buf);

    return 0;
}

void fatal_error(void)
{
    fputs(""fatal error - out of memory\n"", stderr);
    exit(1);
}
</code></pre>

<p>This example combined with examples in other answers should give you an idea of how this kind of thing is handled at a low level.</p>
",0
3433053,3433042,8,"<p>Try SIGUSR1 instead.</p>
",1
5520137,5520118,5,"<p>Yes, it just means multiply in this context. It's multiplying two #defined constant to make the first argument to the <code>nvm_eeprom_write_byte</code> function. </p>

<p>This code involves a lot of assumptions about memory address manipulation. Gotta be honest with you, if you don't know C, looking at EEPROM driver code probably isn't the simplest or safest way to start. </p>
",4
5520140,5520118,2,"<p>Yes, <code>*</code> means <code>multiply</code> in C.</p>

<p>Parenthesis in <code>#define</code> is a standard practice in C to prevent unexpected results when using compound statements (where operator precedence matters).</p>

<p>Consider the difference between</p>

<pre><code>#define FOO 1+2
int a = FOO*2
</code></pre>

<p>and</p>

<pre><code>#define FOO (1+2)
int a = FOO*2
</code></pre>
",2
3433089,3433079,2,"<p>The problem is the first line. You have to pass a function pointer, while it looks like you're calling the function, which happens to have a void return type. It also looks like you want C to have closures - you're trying to pass arguments to the signal handler function. This is not possible. You'll need to store those values in global variables, and declare your signal handler with the correct prototype for a signal handler.</p>
",0
6074307,6074279,1,"<pre><code>#include &lt;stdio.h&gt;
</code></pre>

<p>should be enough, but be careful because the structure's name is FILE (all uppercase) and not File. Finally, dont forget to close the file calling fclose()</p>
",5
6074311,6074279,2,"<p>The stdio file type is <code>FILE</code> (all uppercase).</p>
",0
6074522,6074279,8,"<p>Your logic should look something like this:</p>

<pre><code>fp = fopen( ""out_file.txt"", ""w"" ); // Open file for writing

while ( some condition )
{

    ... some calculations

    fprintf(fp, ""x = %f, y = %f, vx = %f, vy = %f, time = %f, "", x,y,vx,vy,time);
}

fclose(fp);
</code></pre>
",3
3991411,3991103,2,"<p>Your problem is that the <code>%c</code> conversion specifier doesn't cause <code>scanf()</code> to skip leading whitespace.  You need to handle the newline character that's still in the stream after reading your input.  </p>

<p>The input stream is empty when <code>scanf()</code> is called the first time through the loop, so it waits for you to type something.  You type <code>s</code> and hit the Enter key, so the input stream contains the characters <code>s</code> and <code>\n</code> (newline).  <code>scanf()</code> removes the <code>s</code> from the input stream and assigns it to <code>op</code>.  When <code>scanf()</code> is called the second time, the input stream is <em>not</em> empty; it still has the <code>\n</code> character in it, so <code>scanf()</code> reads it and assigns it to <code>op</code>, which causes the loop condition to fail, so your loop exits.  </p>

<p>There are several ways to get around this problem.  I'm going to recommend reading <em>strings</em> as opposed to individual characters using <code>fgets()</code>, as follows:</p>

<pre><code>char op[3] = {0}; // input character + newline character + 0 terminator

do
{
  printf(""?Sigues?"");
  if (fgets(op, sizeof op, stdin))
  {
    /**
     * Check for a newline character in the input.  If it's not there
     * then the user typed in too many characters.  In order to keep
     * the input stream from getting clogged up with bad input, read
     * until we find a newline character.
     */
    char tmp[3];
    char *newline = strchr(op, '\n');
    while (!newline &amp;&amp; fgets(tmp, sizeof tmp, stdin))
    {
      newline = strchr(tmp, '\n');
    }
  }
  else
  {
    printf(""Error while reading input\n"");
    op[0] = 0;
  }
} while (tolower(op[0]) == 's');
</code></pre>
",0
3991124,3991103,1,"<pre><code>op = getc(stdin);
</code></pre>
",2
3991160,3991103,1,"<p>scanf flushes only after reading a newline. it cant be done in platform independent way</p>
",0
3991544,3991103,0,"<p>You're seeing the line ""Sigues"" twice because there's a <code>\n</code> still in the input stream. If you type in a character and hit enter there are now two characters in your input stream. Your <code>scanf</code> formatter only specifies one char, so <code>scanf</code> reads in one char and then advances. However,  the next character in the stream is a <code>\n</code>, hence the exit from the loop on the second go.</p>

<p>NB. @eduffy's technique of <code>getc(stdin)</code> will do the exact same thing, there's still a <code>\n</code> in stdin. You need to advance past that <code>\n</code> somehow.</p>

<p>How about reading in your char, and then chomping the rest of the stream up to the <code>\n</code> char? I tried this and it works for me:</p>

<pre><code>char op;

do
 {
  printf(""?Sigues?"");
  scanf(""%c"",&amp;op);
  while(getchar() != '\n') continue;
}while(op=='s'|| op=='S');
</code></pre>
",0
3750663,3750633,3,"<p>Looks like you are compiling just the <code>main.c</code> file. </p>

<p>Make sure you compile as:</p>

<pre><code>gcc -Wall main.c display.c
</code></pre>

<p>and run it as:</p>

<pre><code>./a.out
</code></pre>
",2
3750687,3750633,1,"<p>gcc allows you to compile and link a trivial application (has only 1 .c file) in one step.</p>

<p>For applications with more than one .c file, you need to compile all the source (.c) files into object (.o) files. These then need to be linked together.</p>

<p>So you will need to compile each .c file </p>

<pre><code>gcc -c main.c
gcc -c display.c
</code></pre>

<p>and then link them using</p>

<pre><code>gcc -o display main.o display.o
</code></pre>

<p>This will create the binary <code>display</code></p>

<p>This can be automated with a <code>Makefile</code>. you then build the entire thing by just calling <code>make</code>.</p>
",1
3750688,3750633,0,"<p>display.c</p>

<pre><code>#include &lt;stdio.h&gt;

int display_options(void);
int display_price(void);
int display_options()
{
printf(""Welcome to the pizza parlor\n"");
printf(""What size pizza would you like? (in inches)"");

return 0;
}

int display_price()
{
printf(""Your pizza will cost 0.00\n"");

return 0;
}
</code></pre>

<p>Now include direct <code>display.c</code></p>

<p>in the main file instead of <code>display.h</code></p>
",0
3750691,3750633,1,"<p>Make sure that <code>#include ""display.h""</code> is also at the top of the <code>display.c</code> file. Since you are using Code::Blocks, it will automatically compile <code>main.c</code> and <code>display.c</code> for you once you do that.</p>
",1
3750767,3750633,0,"<p>In Code::Blocks, you need to make sure that <code>display.c</code> is in your project (if you haven't created a project, do so now) and that it's also included in one or more <em>build targets</em>. <code>debug</code> and <code>release</code> build targets are created by default, but nothing is added to a target unless you say so. When you create a new file or add an existing file to a project, the IDE should ask you which targets to add the file to. Select all of them and hit OK.</p>

<p>If your file is already in the project but not included in any target, go to <strong>Project | Properties | Build targets</strong> and make sure that the <strong>Build target files</strong> panel shows checkmarks beside both <code>main.c</code> and <code>display.c</code>.</p>
",3
5194081,5193570,8,"<p>Do you not consider just putting a table in? A hash table is also fine if there are lots of properties.</p>

<pre><code>int lookup(const char *name)
{
  typedef struct item_t { const char *name; int writable; int value; } item_t;
  item_t table[] = {
    { ""foo"", 0, FOO },
    { ""bar"", 1, BAR },
    { NULL, 0, 0 }
  };
  for (item_t *p = table; p->name != NULL; ++p) {
      if (strcmp(p->name, prop_name) == 0) {
          return p->value;
      }
  }
  return -EINVAL;
}</code></pre>
",6
3433998,3433448,0,"<blockquote>
  <p>int c,h_comp=0,race_length=0,o=0,i=0,Ti=0;</p>
</blockquote>

<p>After the fork() data segments would be forked too and the variables would stop being shared meaning that that:</p>

<pre><code>void hare_fun(int rh[])
{
 /*...*/
 h_comp=1;
}
</code></pre>

<p>would have no effect on that</p>

<pre><code>void turtle_fun()
{ 
 while(h_comp!=1 /* ... */)
 {
   /* ... */
 }
}
</code></pre>

<p>running in different process.</p>

<p>To get a piece of memory shared by the fork()ed processes:</p>

<ul>
<li>put all the fields you need to share into a struct, e.g. <code>struct the_struct</code>,</li>
<li>add a new global variable - pointer to the struct,</li>
<li>allocate memory for the struct using <code>mmap(0, sizeof(struct the_struct), PROT_READ|PTOT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code> somewhere at the <code>main()</code> before any <code>fork()</code>.</li>
<li>the memory created that way would be shared after <code>fork()</code>s.</li>
</ul>
",0
4143149,4143119,6,"<p>Those parameters correspond to the program's arguments and environment.  By passing NULL in for both, the caller is indicating that no arguments should be supplied to the program and no environment variables should be supplied either.</p>
",0
4143151,4143119,1,"<p>this code opens new shell.....
like when you execute any command the shell copies itself and executes the command.</p>
",0
3988299,3988275,34,"<p>try <a href=""http://opengroup.org/onlinepubs/007908775/xsh/fork.html""><code>fork()</code></a> ! (and join afterwards). That's the only feature involving quantum mechanics that I know of.</p>

<p><code>fork()</code> returns two distinct values at a time, which only the Schr?dinger's cat is capable of.</p>

<p><strong>NOTE:</strong> In a comment, Donal Fellows suggests:</p>

<blockquote>
  <p>You'll get more reliable behavior with <a href=""http://opengroup.org/onlinepubs/007908775/xsh/vfork.html""><code>!vfork()</code></a></p>
</blockquote>
",12
3988300,3988275,0,"<p>No, it's not possible. Either the first block or the else block will get executed; that is the nature of an <code>if</code> statement.</p>
",0
3988310,3988275,0,"<p>There's no way to execute both branches of an if/else without exploiting it with weird things. If a condition is true then the else won't get executed and viceversa.</p>

<p>They're absolutely mutually exclusive.</p>
",0
3988320,3988275,0,"<p>Not without iterating over it again.  I don't think you can do any Duff device like craziness in if statements.  I suppose you could use goto, you say just by writing the condition.</p>
",0
3988323,3988275,0,"<p>In a debugger you could step through the if block, then move execution to the else block to execute, but that's just a silly answer to what seems to me to be a silly question.</p>
",0
3988324,3988275,3,"<p>You can, but it's probably bad practice.  Seems the interviewer was testing your knowledge of the language.  Built with gcc 4.1.2.</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  if(!printf(""hello "")) {
    printf(""hello"");
  } else {
    printf(""world"");
  }

  return 0;
}
</code></pre>
",1
3988362,3988275,3,"<p>There is one possible way, it is not recommended.</p>

<pre><code>if(check==true)
{
 printf(""dont do this"");
 goto condition1;
}
else
{
 condition1: ////this is crazy
 printf(""Dont do this ever"");
}
</code></pre>
",3
3988377,3988275,-1,"<p>you could try :</p>

<pre><code>if()
{
printf(""hello"");
goto Found;
}
else
{
Found: printf(""world"");
}
</code></pre>
",0
3988435,3988275,16,"<p>If you can put in a macro definition as ""part"" of that condition...</p>

<pre><code>if (1
#define else if (1)
)
{
    printf(""hello"");
}
else
{
    printf(""world"");
}
</code></pre>

<p>Then that code will indeed print ""<code>helloworld</code>"". It's a horrible, dirty trick though; my soul is probably in trouble for mentioning it!</p>
",5
3988455,3988275,0,"<p>The easiest way I think is this:</p>

<pre><code>//if(.......)
{
    printf(""hello"");
}
//else
{
    printf(""world"");
}
</code></pre>
",2
3988500,3988275,7,"<p>It depends on the exact phrasing of the question.  As you describe it, the question <em>does not</em> ask you to execute both branches of the if statement.  It asks you to insert a condition that results in printing ""hello world"" without changing anything else.</p>

<p>If you have complete freedom in what you put in the condition, you can use this solution:</p>

<pre><code> if(printf(""hello "") == -1)
 {
     printf(""hello"");
 }
 else
 {
     printf(""world"");
 }
</code></pre>

<p>However, the solution uses ""printf"" in the condition, which is ruled out by one of the rules you gave.  What's not clear to me is whether the printf prohibition also applies to what you write in the condition.</p>

<p><strong>Note: Answer is edited to reflect the comments.  The original answer ignored the prohibition on print statements.</strong></p>
",4
3988532,3988275,0,"<p>Wouldn't this work?</p>

<pre><code>if (!printf(""hello"")){
   printf(""hello"");
}
else{
   printf("" world"");
}
</code></pre>
",2
3988558,3988275,37,"<p>This will work</p>

<pre><code>if(schrodingers_cat_is_dead())
{
    printf(""hello"");
}
else
{
    printf(""world"");
}
</code></pre>

<p>Unfortunately, as soon as you look at the output, not only will it collapse into the state of only producing ""hello"" or ""world"", but there's a 50% chance you will have murdered a cat.</p>
",2
6132628,6132591,4,"<p>Given a structure named <code>s</code> and a member named <code>m</code></p>

<pre><code>struct s * BaseS(byte *p)
{
     return (struct s *) (p - ((byte*) &amp;(((struct s *)0)-&gt;m)));
}
</code></pre>

<p>The idea is to get the offset of the member and subtract that from the pointer.</p>
",0
6132657,6132591,5,"<p>The Linux kernel code (GPLv2 licensed) includes a convenient <code>container_of()</code> macro:</p>

<pre><code>#define container_of(ptr, type, member) ({                      \
        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>

<p>It is used like this:</p>

<pre><code>static inline struct ext3_inode_info *EXT3_I(struct inode *inode)
{
    return container_of(inode, struct ext3_inode_info, vfs_inode);
}
</code></pre>

<p>@Richard's answer is excellent; the main difference is this code is parameterized to accept any <code>struct</code> and any member, and as a result is correspondingly more complicated.</p>
",1
6132697,6132591,8,"<p>Firstly, in order to pull that off you need to know the type of the enclosing struct <code>StructType</code> and the name of the member <code>member</code>. That must be a given. Without it, the problem has no solution.</p>

<p>Secondly, I don't know why other answers insist on reinventing the wheel (and engage into undefined and non-portable hacks on top of that) instead of using the standard <code>offsetof</code> macro. With <code>offsetof</code> the answer is</p>

<pre><code>StructType *pstruct = 
  (StructType *) ((char *) pmember - offsetof(StructType, member));
</code></pre>
",0
5582467,5582438,0,"<pre><code>a + b + c == c + b + a
</code></pre>

<p>The order does not matter.  </p>

<p>It is called <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C++"" rel=""nofollow"">operator precedence</a> </p>
",8
5582502,5582438,4,"<p>Let me throw this at you:</p>

<p><a href=""https://stackoverflow.com/questions/5473107/operator-precedence-vs-order-of-evaluation"">Operator Precedence vs Order of Evaluation</a></p>
",0
5582532,5582438,1,"<p>The structure of the equation in mathematical terms (in <code>a+(b*c)</code> we talk about <code>b*c</code> being evaluated ""first"") is not necessarily related to the order the compiler will evaluate the arguments</p>

<p>The actual order of execution in this instance is undefined IIRC. C only guarantees that the order of expressions separated by sequence points remains unchanged, and the + operator is not a sequence point.</p>

<p><em>Most</em> compilers will do what you expect - generating code that will evaluate a then b then c</p>
",2
5582542,5582438,2,"<p>The compiler is free to rearrange things, as long as the end result is the same.</p>

<p>For example:</p>

<pre><code>1 + b + 1
</code></pre>

<p>Can easily be transformed to:</p>

<pre><code>b + 2
</code></pre>
",2
5584108,5582438,1,"<p><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">n1256</a>:</p>

<blockquote>
<b>6.5 Expressions</b><br>
...<br>
3 The grouping of operators and operands is indicated by the syntax.<sup>74)</sup> Except as specified
later (for the function-call <code>()</code>, <code>&&</code>, <code>||</code>, <code>?:</code>, and comma operators), <b>the order of evaluation
of subexpressions and the order in which side effects take place are both unspecified</b>.
<br>...<br>
74) The syntax specifies the precedence of operators in the evaluation of an expression, which is the same
as the order of the major subclauses of this subclause, highest precedence first. Thus, for example, the
expressions allowed as the operands of the binary <code>+</code> operator (6.5.6) are those expressions defined in
6.5.1 through 6.5.6. The exceptions are cast expressions (6.5.4) as operands of unary operators
(6.5.3), and an operand contained between any of the following pairs of operators: grouping
parentheses <code>()</code> (6.5.1), subscripting brackets <code>[]</code> (6.5.2.1), function-call parentheses <code>()</code> (6.5.2.2), and
the conditional operator <code>?:</code> (6.5.15).<br><br>
Within each major subclause, the operators have the same precedence. Left- or right-associativity is
indicated in each subclause by the syntax for the expressions discussed therein.
</blockquote>

<p>Emphasis mine.  The expression <code>a + b + c</code> will be evaluated as <code>(a + b) + c</code>; that is, the <em>result</em> of <code>c</code> will be added to the <em>result</em> of <code>a + b</code>.  Both <code>a</code> and <code>b</code> must be evaluated before <code>a + b</code> can be evaluated, but <code>a</code>, <code>b</code>, and <code>c</code> can be evaluated in any order.    </p>
",0
5584702,5582438,0,"<p>I'll try and highlight the difference between what you consider to be the <em>order of evaluation</em> and what the compiler considers it to be.</p>

<p>Mathematically we say that in the expression <code>a + b * c</code>, the multiplication is evaluated before the addition. Of course it must be because we need to know what to add to <code>a</code>.</p>

<p>However, the compiler doesn't necessarily have to consider evaluating the expression <code>b * c</code> before it evaluates <code>a</code>. You might think that because multiplication has a higher precedence, then the compiler will look at that part of the expression first. Actually, there is no guarantee about what the compiler will decide to do first. It may evaluate <code>a</code> first, or <code>b</code>, or <code>c</code>. This behaviour is <em>unspecified</em> by the standard.</p>

<p>To demonstrate, let's look at the following code:</p>

<pre><code>#include &lt;iostream&gt;

int f() { std::cout &lt;&lt; ""f\n""; return 1; }
int g() { std::cout &lt;&lt; ""g\n""; return 2; }
int h() { std::cout &lt;&lt; ""h\n""; return 3; }

int main(int argc, const char* argv[])
{
  int x = f() + g() * h();
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p>Each function, <code>f()</code>, <code>g()</code> and <code>h()</code>, simply outputs the name of the function to the standard output and then returns 1, 2 or 3 respectively.</p>

<p>When the program starts, we initalise a variable <code>x</code> to be <code>f() + g() * h()</code>. This is exactly the expression we looked at earlier. The answer will of course be 7. Now, naively you might assume that multiplication happens first, so it'll go there  and it'll do <code>g()</code>, then multiply it by <code>h()</code>, then it'll do <code>f()</code> and add it to the previous result.</p>

<p>Actually, compiling this with GCC 4.4.5 shows me that the functions are executed in the order that they appear in the expression: <code>f()</code>, then <code>g()</code>, then <code>h()</code>. This isn't something that will necessarily happen the same in all compilers. It completely depends on how the compiler wants to do it.</p>

<p>If you're performing operations that are associative or commutative then the compiler is also free to swap around the mathematical groupings in the expression, but <strong>only if</strong> the result will be <em>exactly</em> the same. The compiler must be careful not to do any regroupings that may cause overflows to happen which wouldn't have happened anyway. As long as the result is as defined by the standard, the compiler is free to do what it likes.</p>
",0
3697869,3697860,1,"<p>No, the array indexer is going to return data the size of an unsigned char, not a single bit.  Use <code>byteArray[0] &amp; 1;</code> - masking the value so that you only get the first bit (depending on which end is the ""first""). The other end would be <code>&amp; 128</code>.</p>
",6
3697881,3697860,2,"<p>How (and why) do you store a byte in a byte array for this purpose? Its not necessary.</p>

<p>In any case, if you want to retrieve the first bit of a byte, all you have to do is one bit operation.</p>

<pre><code>unsigned char byte = &lt;some random value&gt;;  // your byte containing the value.
unsigned int first_bit = byte &amp; 1;  // for Least significant bit
</code></pre>

<p>The operation <code>byte &amp; 1</code> is a <a href=""http://en.wikipedia.org/wiki/Bitwise_operation#AND"" rel=""nofollow noreferrer"">bitwise AND operation</a>.</p>
",0
4557052,4556441,1,"<p>Not possible.  You always have to allocate the buffer used by sprintf/printf</p>
",0
4556474,4556441,5,"<p>Since data1 and data2 seem to be strings just use strlen() and allocate just the amount of memory you actually need.</p>

<pre><code>char *data = malloc(sizeof(char) * (strlen(data1) + strlen(data2) + 1));
</code></pre>
",3
4556596,4556441,4,"<p>Instead of <code>sprintf()</code> use <code>snprintf()</code> which will never overflow the buffer (you tell it how large the buffer is).  <code>snprintf()</code> will also tell you how big the buffer needs to be to avoid truncation of the result.</p>

<p>Note that MSVC doesn't have an <code>snprintf()</code> but includes the similar <code>_snprintf()</code>.  However that function has at least 2 differences from the standard:</p>

<ul>
<li>it might leave the result unterminated</li>
<li>it won't tell you how large of a buffer you need if it does truncate</li>
</ul>

<p>If you're using MSVC, you might want to consider using <a href=""http://www.jhweiss.de/software/snprintf.html"" rel=""nofollow"">Holger Weiss' <code>snprintf()</code> implementation</a> (which has a liberal license).</p>
",0
4556710,4556441,6,"<p>Many C runtime libraries (for instance, GNU's glibc and FreeBSD's (and NetBSD's and OpenBSD's and OS X's) libc) provide <a href=""http://www.gnu.org/s/libc/manual/html_node/Dynamic-Output.html"" rel=""noreferrer""><code>asprintf</code></a>, which combines <code>malloc</code> and <code>sprintf</code> into a single call.</p>

<pre><code>char *Data = NULL;
asprintf(&amp;data, ""%s %s"", Data1, Data2);
</code></pre>

<p>Assuming the return value indicates success, enough space has been dynamically allocated for the string, which you should <code>free</code> when no longer used.</p>
",2
4556750,4556441,0,"<p>The short answer is no.  </p>

<p>...But you don't need to allocate every single time your code is run.  Depending on whether or not your program is multi threaded, how frequently this section of code is going to be run and how big the biggest possible string you expect is, you are probably better off allocating the a single buffer of ""biggest possible size"" once and using a safe version of sprintf like snprintf to fill it. (Guards against overruns).  Or you could conditionally reallocate the buffer if the size you require exceeds the current buffer size.</p>

<p>For example, if you are using C++ and your code above lives inside a method, you could change your Data allocation line to:</p>

<pre><code>static char *Data = malloc(1024*1024);
</code></pre>

<p>The static keyword used within a method promises that your local variable will only be initialized once - the first time the line is invoked and will live beyond the scope of that method call.  </p>

<p>If you are using C, then your buffer could be a global (I'm not a fan of this), or you could pass a pointer to a locally scoped Data buffer around.  I'm sure real C programmers have better suggestions on how to do this kind of thing.</p>

<p>I know it seems inefficient to just have a giant buffer hanging around that you almost never take full advantage of, but it turns out that for most applications, the overhead of allocation is a much bigger issue than the possibility running out of heap space.</p>
",0
4520081,4520058,3,"<p>For scanf for a number you need to specify the pointer to the number not the number itself. I.e.</p>

<pre><code>scanf(""%d"", &amp;emp.salary);
</code></pre>

<p>There may be other problems, but that's the first one I saw.</p>
",6
4520083,4520058,0,"<p>This is how you're calling <code>scanf()</code>:</p>

<pre><code>scanf(""%s"", emp.salary);
</code></pre>

<p>This is how you're supposed to call <code>scanf()</code>:</p>

<pre><code>scanf(""%s"", &amp;emp.salary);  // note the address to the location you want
</code></pre>

<p><strong>EDIT:</strong> As AlstairG points out, your strings (the <code>char*</code> members) are pointers and thus have the address already.</p>
",1
4520103,4520058,0,"<p>don't know, if it's the only issue, but one trouble is :</p>

<p><em><strong>scanf(""%d"", emp.salary);</em></strong></p>

<p>Which is wrong (forgot address on salary with &amp;)</p>

<p>better try : <strong>scanf(""%d"", &amp;emp.salary);</strong></p>

<p>++</p>
",0
4520352,4520058,2,"<p>Your <code>printf()</code> arguments look off:</p>

<pre><code>        printf(""%s, %s, %s, %d"",
                p-&gt;first,
                p-&gt;last,
                p-&gt;salary,  // did you mean title here rather than salary?
                p-&gt;salary
        );
</code></pre>

<p>Also, you'll want to include new line character at the end of your format string:</p>

<pre><code>        printf(""%s, %s, %s, %d\n"",  // note the \n
        ...
</code></pre>

<hr>

<p>Your <code>createEmployee()</code> definition is also questionable:</p>

<pre><code>    p-&gt;salary, salary;  // did you mean p-&gt;salary = salary?
</code></pre>
",2
7157725,7157714,2,"<p><code>printf (""\n X = 0x%X \n"",x);</code></p>
",1
4596272,4596256,0,"<p>Read in the program, put it into a file, compile, link and execute it?</p>

<p>C isn't Perl if that is what you are looking for.</p>

<p>Frank</p>
",1
4596273,4596256,1,"<p>Yes.</p>

<p>But the details are complicated and depend on many things that you don't specify in your question.</p>

<ul>
<li>What language is the second program written in?</li>
<li>Why you want to do this will affect how it should be done</li>
<li>Are you looking to control the 2nd program in some advanced way?</li>
<li>etc.</li>
</ul>
",3
4596274,4596256,1,"<p>It's called an interpreter. Google for ""C interpreter"".</p>
",0
4596284,4596256,1,"<p>yes, with <a href=""http://it.wikipedia.org/wiki/Exec_%28Unix%29"" rel=""nofollow"">exec</a> on unix and <a href=""http://msdn.microsoft.com/en-us/library/bb762153%28v=vs.85%29.aspx"" rel=""nofollow"">ShellExecute</a> on windows </p>
",3
4596309,4596256,0,"<p>Yes. It is not only possible, but done all the time. UNIBASIC &amp; UNIBASIC DL4 are two of the languages that I've used that are written in C.</p>
",0
4163098,4162951,2,"<pre><code>int first_hex, second_hex;

sscanf(msg,""%02X%02X"", &amp;first_hex, &amp;second_hex);
</code></pre>

<p>Important: <code>first_hex</code> and <code>second_hex</code> must be of type <code>int</code> to be used like in this example.</p>

<p>And if I understand you right you want to do following:</p>

<pre><code>char *pIn=msg;
char *pOut=hex_msg;
while(*pIn)
{
    int hex;
    if (*(pIn+1)==0)
    {
      // handle format error: odd number of hex digits
      ...
      break;
    }
    sscanf(pIn, ""%02X"", &amp;hex);
    *pOut++=(char)hex;
    pIn+=2;
}
</code></pre>
",0
4162990,4162951,4,"<p><code>unsigned char msg[] = { 0x04, 0xFF };</code></p>

<p>As for conversion from string, you need to read the string, two chars at a time:</p>

<pre><code>usigned char result;
if (isdigit(string[i]))
  result = string[i]-'0';
else if (isupper(string[i]))
  result = string[i]-'A';
else if (islower(string[i]))
  result = string[i]-'a';
</code></pre>

<p>mutiply by 16 and repeat</p>
",2
4163022,4162951,3,"<p>Assuming your data is valid (ASCII, valid hex characters, correct length), you should be able to do something like.</p>

<pre><code>unsigned char *mkBytArray (char *s, int *len) {
    unsigned char *ret;

    *len = 0;
    if (*s == '\0') return NULL;
    ret = malloc (strlen (s) / 2);
    if (ret == NULL) return NULL;

    while (*s != '\0') {
        if (*s &gt; '9')
            ret[*len] = ((tolower(*s) - 'a') + 10) &lt;&lt; 4;
        else
            ret[*len] = (*s - '0') &lt;&lt; 4;
        s++;
        if (*s &gt; '9')
            ret[*len] |= tolower(*s) - 'a' + 10;
        else
            ret[*len] |= *s - '0';
        s++;
        *len++;
    }
    return ret;
}
</code></pre>

<p>This will give you an array of unsigned characters which you are responsible for freeing. It will also set the <code>len</code> variable to the size so that you can process it easily.</p>

<p>The reason it has to be ASCII is because ISO only mandates that numeric characters are consecutive. All bets are off for alphas.</p>
",0
7451179,5574914,1,"<p>If you are using different processes, use <code>(rand()+getpid())%range;</code>
I use it to test the same program with random values many times a second (If you make rand numbers, exit the program and run again very fast, the numbers will be the same)</p>
",0
5574922,5574914,8,"<p>Seed once at the beginning of main.  If you reseed too quickly during the same second, you will end up getting the same numbers.</p>
",0
5574932,5574914,30,"<p><code>srand(time(NULL))</code> should be run exactly once to intialise the PRNG.  Do this in Main when the application starts.</p>

<p><strong>Explanation:</strong></p>

<p>A PRNG (Pseudo-Random Number Generator) generates a deterministic sequence of numbers dependent on the algorithm used.  A given algorithm will always produce the same sequence from a given starting point (seed).  If you don't explicitly seed the PRNG then it will usually start from the same default seed every time an application is run, resulting in the same sequence of numbers being used.</p>

<p>To fix this you need to seed the PRNG yourself with a different seed (to give a different sequence) each time the application is run.  The usual approach is to use <code>time(NULL)</code> which sets the seed based on the current time.  As long as you don't start two instances of the application within a second of each other, you'll be guaranteed a different random sequence.  </p>

<p>There's no need to seed the sequence each time you want a new random number.  And I'm not sure about this, but I have the feeling that depending on the PRNG algorithm being used re-seeding for every new number may actually result in lower randomness in the resulting sequence.</p>
",1
5574935,5574914,5,"<p>Don't seed it every time, only at the beginning of your program.</p>

<p>Also, many books advice against using the C-lib standard random functions.  If you need good pseudo-random numbers, there's a good algorithm in Press et al., Numerical Recipes, 3rd. Edition.</p>
",1
5574938,5574914,4,"<p>I assume you call the <code>generateRandom</code> function from another function, <code>main</code> or something. </p>

<p>If you declare the seed inside the function, you'll reset the function. Resetting the function, will make the same numbers appear several times, the same second.</p>

<p>Moving <code>srand(time(NULL));</code> to main function will solve the problem.</p>
",0
5459447,5459236,1,"<p>Is that your exact code? I just compiled this program and it works fine:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main(int argc, char **argv)
{
    struct tm *tb;
    time_t lDate;

    time(&amp;lDate);
    if (lDate == -1) {
        perror(""time"");
        return 1;
    }

    tb = localtime(&amp;lDate);
    if (tb == NULL) {
        fprintf(stderr, ""localtime failed\n"");
        return 1;
    }

    printf(""Good\n"");
    return 0;
}
</code></pre>
",0
5459512,5459236,0,"<p>The code you posted in your comments works fine, up until you get to the if statement.  I'm not sure what you are trying to do here, but you have a <code>;</code> in <code>if (pArea);</code> that almost definitely should not be there (hard to tell since it's formatted horribly because you put it in a comment).  You are also returning 0 all the time, is that what you intended to do?</p>
",0
6089871,6089855,0,"<p>Yes, it can and often does. There is no way of matching up sends and receive calls  when using TCP/IP. Your program logic should test the return values of both send and recv calls in a loop, which terminates when everything has been sent or recieved.</p>
",0
6089875,6089855,1,"<p>The answer depends on the socket type, but in general, yes it's possible. For TCP it's the norm. For UDP I believe it cannot happen, but I'm not an expert on network protocols/programming.</p>
",0
6089932,6089855,4,"<p><code>TCP</code> is a <strong>stream oriented</strong> protocol. Not message / record / chunk oriented. That is, all that is guaranteed is that if you send a stream, the bytes will get to the other side in the order you sent them. There is no provision made by RFC 793 or any other document about the number of segments / packets involved.</p>

<p>This is in stark contrast with <code>UDP</code>. As @R.. correctly said, in <code>UDP</code> an entire message is sent in one operation (notice the change in terminology: <code>message</code>). Try to send a giant message (several times larger than the MTU) with TCP ? It's okay, it will split it for you.</p>

<p>When running on local networks or on localhost you will certainly notice that (generally) <code>one send == one recv</code>. Don't assume that. There are factors that change it dramatically. Among these</p>

<ul>
<li>Nagle</li>
<li>Underlying MTU</li>
<li>Memory usage (possibly)</li>
<li>Timers</li>
<li>Many others</li>
</ul>

<p>Of course, not having a correspondence between an a <code>send</code> and a <code>recv</code> is a nuisance and you can't rely on <code>UDP</code>. That is one of the reasons for <code>SCTP</code>. <code>SCTP</code> is a really really interesting protocol and it is <strong>message-oriented</strong>.</p>

<p>Back to <code>TCP</code>, this is a common nuisance. An equally common solution is this:</p>

<ul>
<li>Establish that all packets begin with a fixed-length sequence (say 32 bytes)</li>
<li>These 32 <strong>bytes</strong> contain (possibly among other things) the size of the <strong>message</strong> that follows</li>
<li>When you read any amount of data from the socket, add the data to a buffer specific for that connection. When 32 <strong>bytes</strong> are reached, read the length you still need to read until you get the message.</li>
</ul>

<p>It is really important to notice how there are really no messages on the wire, only bytes. Once you understand it you will have made a giant leap towards writing network applications.</p>
",0
3699290,3698302,0,"<p>Constants in C (you asked about that) are numerical constants (0, 1, 0x0, 0.1, 1.E-10, ...), integral character constants ('a', '\n', L'A', ...) and enumeration constants (that are of type <code>int</code>!). So the later are the only ones that can be defined by a program.</p>

<p>Variables that are qualified with the <code>const</code> attribute are not constants in the sense of C. (better read the <code>const</code> here as <code>unmutable</code> or <code>invariant</code>)</p>

<p>Macros are just textual replacements that are done during the preprocessing phase. Often standard library headers contain macros that expand to the suitable constant for the corresponding system. Such are e.g <code>NULL</code>, <code>false</code>, <code>true</code>, <code>INT_MAX</code>, <code>CHAR_BIT</code>, ...</p>
",0
3698312,3698302,7,"<p>A macro takes arguments and (typically) generates actual code, a #defined:d constant is merely a value:</p>

<p>For instance:</p>

<pre><code>#define MAX_NAME_LENGTH 32
</code></pre>

<p>versus</p>

<pre><code>#define MAX(a, b)   ((a) &gt; (b) ? (a) : (b))
</code></pre>

<p>Of course, it's often better to use actual language-level constants when possible:</p>

<pre><code>enum {
 MAX_NAME_LENGTH = 32
}
</code></pre>

<p>or</p>

<pre><code>const size_t MAX_NAME_LENGTH = 32;
</code></pre>

<p>These provide better testability, often work better with debuggers (since they're proper 1st-level symbols), and don't rely on text-substitution techniques.</p>
",2
8424349,8424329,0,"<p>You need some way of knowing the size.  Either explicitly (e.g. with a <code>size</code> argument or field in your data), or implicitly (e.g. with a null terminator).</p>
",1
8424352,8424329,2,"<p>You're probably looking for the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strcmp.html"" rel=""nofollow""><code>strcmp(3)</code></a> function.</p>

<p><strong>Update</strong></p>

<p>If your arrays are not of ASCII strings and may contain the <code>0x00</code> byte at any position without actually meaning anything, then you'll need the length as Oli points out, so you can use the <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/memcmp.html"" rel=""nofollow""><code>memcmp(3)</code></a> function:</p>

<pre><code>int memcmp(const void *s1, const void *s2, size_t n);
</code></pre>

<p><strong>Update #2</strong></p>

<p>Okay, now that we've established you <em>also</em> want the byte that differs, you'll need your own function. Something like this (untested):</p>

<pre><code>size_t cmp(const unsigned char *c1, const unsigned char *c2, ssize_t n) {
    ssize_t i;
    for (i=0; i&lt;n; i++) {
        if (c1[i] != c2[i])
            return i;
    }
    -1;
}
</code></pre>

<p>This will let you find the byte values for whichever bytes differ. Note the <code>-1</code> return in case of no difference. This limits you to comparing objects whose size fit entirely in a <code>ssize_t</code>, which is smaller than the <code>size_t</code> type -- but since you're comparing two of them, I figure each one gets half the process address space at most anyway.</p>
",6
4358054,4357923,0,"<p>In <code>main()</code> you have variable definitions appearing after code. This is permissible in C99 but not in C89, so if you're using an old C89 compiler, or something like MSVC which still doesn't support C99, then this is not going to compile. Move this block:</p>

<pre><code>int element;
int random_num[10000];
char line; //each number
int i=0;
</code></pre>

<p>up above the code before it so that your variable definitions precede any actual code.</p>
",0
4358129,4357923,1,"<p>It is <em>very</em> important that you read compiler error message from the top down.  You got 3 C2143 errors before you got the C2065 error.  It is typical that error messages get less accurate and informative, an earlier error may produce a slew of additional errors.  The first message complains about the <em>element</em> variable declaration.  Then you get additional errors for any line that contains <em>element</em> since the compiler couldn't properly parse the declaration.</p>

<p>Your compiler requires you to put all variable declarations <em>before</em> the code that uses them.  </p>

<p>Also note that you've got two declarations for the <em>i</em> variable.  And that <em>line</em> needs to be an array of char: <code>char line[20];</code>  Moving the file reading code into a separate function would be a rather good idea.</p>
",3
6629051,6054016,0,"<p>This one works: I took January 2006 as a reference. (It is a Sunday)</p>

<pre><code>int isLeapYear(int year) {

     if(((year%4==0)&amp;&amp;(year%100!=0))||((year%400==0))) 
        return 1;
     else 
        return 0;

 }

int isDateValid(int dd,int mm,int yyyy) {

    int isValid=-1; 
    if(mm&lt;0||mm&gt;12) {
        isValid=-1;
    }
    else {

    if((mm==1)||(mm==3)||(mm==5)||(mm==7)||(mm==8)||(mm==10)||(mm==12)) {
           if((dd&gt;0)&amp;&amp;(dd&lt;=31))
             isValid=1;
    }  else if((mm==4)||(mm==6)||(mm==9)||(mm==11)) {
         if((dd&gt;0)&amp;&amp;(dd&lt;=30))
             isValid=1;
    }  else {
             if(isLeapYear(yyyy)){
                 if((dd&gt;0)&amp;&amp;dd&lt;30)
                     isValid=1;
             } else {
                   if((dd&gt;0)&amp;&amp;dd&lt;29)
                     isValid=1;
             }
        }  



    }
               return isValid;



 }


int calculateDayOfWeek(int dd,int mm,int yyyy)  {

                if(isDateValid(dd,mm,yyyy)==-1) {
                    return -1;
                }

                 int days=0;
                  int i; 

                   for(i=yyyy-1;i&gt;=2006;i--) {
                         days+=(365+isLeapYear(i));

                     }
                     printf(""days after years is %d\n"",days);

                   for(i=mm-1;i&gt;0;i--) {

                       if((i==1)||(i==3)||(i==5)||(i==7)||(i==8)||(i==10)) {

                           days+=31;
                       }
                       else if((i==4)||(i==6)||(i==9)||(i==11)) {
                           days+=30;
                       } else {

                           days+= (28+isLeapYear(i));

                       }


                   }
                       printf(""days after months is %d\n"",days);

                   days+=dd;

                   printf(""days after days is %d\n"",days);

                   return ((days-1)%7);                


              }
</code></pre>
",0
8376038,6054016,1,"<p>This is my implementation. It's very short and includes error checking. If you want dates before 01-01-1900, you could easily change the anchor to the starting date of the Gregorian calendar.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argv, char** arv) {
    int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    char* day[] = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};   
    int d, m, y, i; 

    printf(""Fill in a date after 01-01-1900 as dd-mm-yyyy: "");
    scanf(""%d-%d-%d"",  &amp;d, &amp;m, &amp;y);

    // correction for leap year
    if (y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0))
        month[1] = 29;

    if (y &lt; 1900 || m &lt; 1 || m &gt; 12 || d &lt; 1 || d &gt; month[m - 1]) {
        printf(""This is an invalid date.\n"");
        return 1;
    }

    for (i = 1900; i &lt; y; i++)
        if (i % 4 == 0 &amp;&amp; (i % 100 != 0 || i % 400 == 0))
            d += 366;
        else
            d += 365;

    for (i = 0; i &lt; m - 1; i++) 
        d += month[i];

    printf(""This is a %s.\n"", day[d % 7]);
    return 0;
}
</code></pre>
",0
5476929,5476898,12,"<p>bit-shifting is defined only on unsigned types, for signed types it is implementation-defined.
And this is a useful refinement by R..</p>

<blockquote>
  <p>Strictly speaking, it is defined for
  signed types whenever the value is
  positive and the result does not
  overflow, and right shift is
  implementation-defined for negative
  values. Left shift, on the other hand,
  is undefined for negative values</p>
</blockquote>

<pre><code>©°©¤©¤©¤©Ð©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©´
©¦   ©¦ Unsigned     ©¦ Signed, positive                 ©¦ Signed, negative       ©¦
©À©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©È
©¦&lt;&lt; ©¦ well-defined ©¦ well-defined, except on overflow ©¦ undefined behaviour    ©¦
©¦&gt;&gt; ©¦ well-defined ©¦ well-defined                     ©¦ implementation-defined ©¦
©¸©¤©¤©¤©Ø©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¼
</code></pre>
",2
5476937,5476898,5,"<p>Because -1 is 1111111...111 in binary.  <code>a&gt;&gt;1</code> operation will ""sign extend"" the sign bit, so  you get 1111111...111 again.  </p>
",3
5476949,5476898,1,"<p>Most compilers choose to interpret <code>&gt;&gt;</code> on signed numbers to be arithmetic shift. Thus since the number is initially negative (i.e. the MSB bit is 1), after a right shift, that bit is replaced by another 1 to preserve the sign, ergo you end up with -1 as you started.</p>
",0
5476968,5476898,0,"<p>The <code>&gt;&gt;</code> operator on a signed value may perform an arithmetic or logical shift, depending on the compiler.  Arithmetic shifts retain the sign bit, so <code>-1</code> (which on a 2-s complement machine, which these days is pretty much the only variety you will encounter) will remain <code>-1</code> when right-shifted.  (Note that the C standard explicitly does not specify whether <code>&gt;&gt;</code> on a signed number is an arithmetic or logical shift.  It is always a logical shift on unsigned numbers, though.)</p>
",0
5477027,5476898,0,"<p>The definition of bit-shifting on signed values is implementation-dependent. Check your compiler's docs for how it handles it.</p>
",0
4521989,4521977,2,"<p>You should post the error and format your code correctly.</p>

<p>But your problem is that min is uninitialized.</p>

<p>That's obviously not your code though since that's not compliable.</p>
",0
4522004,4521977,1,"<p>Min needs to be initialized.  It is currently undefined.</p>

<p>In order to get the truncated integer division, all you would need to do is to initialize min and do the division.  The fact that it is dividing by and being placed into an int will cause the remainder part to drop.</p>
",0
4522042,4521977,0,"<p>This worked fine for me.... so as Falmarri,Joey, Mark said check your code !!
        <code>int q;
 int c = 64;
 int m = 20;
 q = c/m;
 printf(""output:%d"",q);</code></p>
",0
3572069,3572043,7,"<p>It tells you that the definition for the function 'AddALL' could not be found. Make sure that you include the object file that contains 'AddALL' when you compile/link.</p>
",1
3572070,3572043,8,"<p>It means that the linker (that is called <code>ld</code> in gcc) did not found the symbol <code>AddALL</code> in the specified object files. Basically, there is no body for that function or it's a variable declared as <code>extern</code> with no definition.</p>
",0
4537835,4537805,3,"<p>Make sure <code>prime_array[prime1_count]</code> is not zero.</p>
",0
3756490,3756439,3,"<p>Here's another issue.  </p>

<p>scanf returns the number of successful conversions from the standard input, or EOF.
But what happens when you input a blank line, or invalid input?</p>

<p>e.g. entering the following</p>

<pre><code>""50 80 60"" - this line OK
""garbage 3 7""  - scanf returns 2. 1st conversion fails. id[i] could contain anything.
</code></pre>

<p>What you want to do is modify your program to check that scanf returns 3 or EOF and not just EOF.
If it didn't return either of those then you need to print out an error ask for input again.</p>

<p>Since it's homework I'm going to let you work that bit out.</p>
",1
3756461,3756439,2,"<p>One of the issues is that you're truncating and doing integer division:</p>

<p><code>average[i]</code> is a float, but you're indirectly assigning it to <code>total</code>, which is an int, which causes truncating.  This also means you're later doing integer division.</p>

<p>Change <code>total</code> to be a float.</p>

<p>You're also not initializing it, so do:</p>

<pre><code>float total = 0;
</code></pre>
",3
3757468,3756439,0,"<p>Ok, the biggest problem was #define max was not equal to 10, this screwed up most of the answers.</p>
",0
6606841,6606774,1,"<p>parameters to main() are like arguments to any other method. They are part of the stack (depending on the processor, that could be in memory, or in a CPU register). In this case, when you call main(k+1), the result of k+1 is put on the stack before the recursive call is performed.</p>

<p><s>Note that the behavior of this is undefined since calling main() from within a C program is unspecified.</s></p>
",5
6606848,6606774,6,"<p>It'll typically be stored wherever parameters to other functions get stored -- which might be stack, register, or somewhere else entirely. Just for a few examples: on a SPARC, it'll almost certainly be a register; on an x86 (in 32-bit mode) it'll typically be the stack; on an IBM mainframe, it'll normally be in a stack frame that's dynamically allocated from the heap and linked together into a linked list that's constructed/destroyed FIFO fashion.</p>

<p>Also note that it can/does vary even on a single machine with a single compiler -- e.g., Microsoft VC++ can pass it on the stack or in a register depending on what compiler flag(s) you use. When/if you pass it in a register, it'll (probably) be pushed on the stack inside the function anyway (to allow the recursion).</p>

<p>As an aside, I'll also note that while <strike>your code</strike>calling <code>main</code> is perfectly legal C, you are not allowed to call <code>main</code> in C++.</p>

<p>Edit: As for the initial value, that first parameter is traditionally called <code>argc</code>, and tells you how many arguments were passed on the command line. If you invoke it (as you apparently have) with no command line, it should normally start out as <code>1</code> (the one argument being the name of the program itself, traditionally passed as <code>argv[0]</code>). If, for example, you invoked the program something like:</p>

<pre><code>prog a b c d e f g h i j k l m
</code></pre>

<p>It would normally exit without printing anything, because on the first entry to <code>main</code>, the parameter would be greater than 10 so the body of the <code>if</code> statement would never execute. </p>
",5
4359174,4359152,0,"<p><a href=""http://www.codeproject.com/KB/recipes/ReverseLinkedList.aspx"" rel=""nofollow"">http://www.codeproject.com/KB/recipes/ReverseLinkedList.aspx</a></p>

<p>It's also on Google.</p>
",0
5520832,5520823,4,"<p><code>fork()</code> is available on posix systems only.  It's certainly not available on windows.   Are you sure your operating system provides fork?</p>
",0
5520837,5520823,9,"<p>Normally, you also need the following to get <code>fork()</code>:</p>

<pre><code> #include &lt;unistd.h&gt;
</code></pre>

<p>However, you seem to be using Windows and <code>fork()</code> isn't available on Windows.  <a href=""http://msdn.microsoft.com/en-us/library/y23kc048%28v=vs.71%29.aspx"" rel=""nofollow"">This page</a> discusses a Windows work-around.</p>

<blockquote>
  <p>One of the largest areas of difference
  is in the process model. UNIX has
  fork; Win32 does not. Depending on the
  use of fork and the code base, Win32
  has two APIs that can be used:
  CreateProcess and CreateThread. A UNIX
  application that forks multiple copies
  of itself can be reworked in Win32 to
  have either multiple processes or a
  single process with multiple threads.
  If multiple processes are used, there
  are multiple methods of IPC that can
  be used to communicate between the
  processes (and perhaps to update the
  code and data of the new process to be
  like the parent, if the functionality
  that fork provides is needed). For
  more on IPC, see Interprocess
  Commuications.</p>
</blockquote>
",0
4156356,4156206,1,"<p>Yes.</p>

<p>However, I think the code there now is broken.</p>

<p>There is an array of 30 elements, where each element is 40 chars.</p>

<p>The code then loops over each of the 30 elements; for each element, it then loops over the first four chars, scanning a string (""%s"") into each char.  The second scanf will overwrite all but the first char of the first scanf, the third scanf will overwrite all but the first char of the first and second scanf, etc.</p>
",0
4156308,4156206,2,"<p>A few things:</p>

<pre><code>for(x=o;x&lt;30;x++)
</code></pre>

<p>Surely you meant <code>0</code> and not <code>o</code> there.  Who knows what <code>o</code> contains, but apparently not zero...</p>

<p>This:</p>

<pre><code>char std[30][40];
</code></pre>

<p>And this (corrected):</p>

<pre><code>for(x=0;x&lt;30;x++)
  for(y=0;y&lt;4;y++)
    scanf(""%s"", &amp;std[x][y]);
</code></pre>

<p>Do not match up.  You are declaring <code>std</code> in essence as an array of 30 strings, each 40 characters long.  But you are treating it as a 30x4 array of strings.  Something is not adding up.  Consider using this instead:</p>

<pre><code>for(x=0;x&lt;30;x++)
  scanf("" %s"", &amp;std[x][0]);
</code></pre>

<p>And yes, taking pointers to multidimensional arrays is just fine.  Array variables are actually just pointers anyway, so it's really just pointer math under the hood.</p>
",7
4156393,4156206,0,"<p>You want a structure.</p>

<p>A structure can hold several different types (char[] for student names; enum MaritalStatus for marital status; enum Gender for sex; etc ...) in a single object, eg</p>

<pre><code>enum MaritalStatus { MS_SINGLE, MS_MARRIED, MS_DIVORCED,
                     MS_WIDOWED, MS_UNKNOWN, MS_OTHER };
enum Gender { G_MALE, G_FEMALE, G_UNDECIDED, G_UNKNOWN, G_OTHER };
struct Student {
    char name[120];
    enum MaritalStatus maritalstatus;
    enum Gender gender;
    char residence[120];
    /* ... */
};
</code></pre>
",0
4157083,4156206,0,"<p>Several issues:</p>

<p>First of all, you've defined <code>std</code> as a 30-element array of 40-element arrays of <code>char</code>; IOW, you can store at most 30 strings of at most 39 characters (plus 0 terminator), not 120 strings.  </p>

<p>Secondly, to read into each of these strings, the call to scanf would simply be</p>

<pre><code>for (x = 0; x &lt; 30; x++)
  scanf(""%s"", std[x]);
</code></pre>

<p>The type of the <em>expression</em> <code>std[x]</code> is <code>char [40]</code>, or 40-element array of char.  However, there is a rule that when expressions of type ""N-element of T"" are encountered, they are implicitly converted (""decay"") to type ""pointer to T"" (the exceptions to this rule are when the array expression is an operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or if the array expression is a string literal being used to initialize another array in a declaration); thus, in this context, the type of the expression <code>std[x]</code> decays to type <code>char *</code>, or pointer to char, so you don't need to use the <code>&amp;</code> operator explicitly.  </p>

<p>The risk of using <code>scanf</code> like this is that it's possible for the user to type in more characters than the target buffer can hold; if the user types 100 characters, those extra 60 characters will be stored in the memory immediately past the end of the buffer, which may or may not cause problems later on.  You can get around this two ways: first, you can add a field width specifier to the <code>%s</code> conversion specification, like so:</p>

<pre><code>scanf(""%39s"", std[x]);
</code></pre>

<p>second, you can avoid using <code>scanf</code> completely and use <code>fgets</code> instead:</p>

<pre><code>fgets(std[x], sizeof std[x], stdin);
</code></pre>
",0
8288097,8287957,0,"<p>Take 2 functions double CDivide_real(a,b,c,d) and CDivide_imag(a,b,c,d) or pass a double-pointer-array to CDivide like CDivide(double *x[2],a,b,c,d), and then</p>

<pre><code>for (ii = 0; ii &lt;= len_freq; ii++) {
   double *a[]={&amp;complex_real[ii],&amp;complex_imag[ii]};
   CDivide( a, b0, 0, a0, freq[ii] );
} 
</code></pre>

<p>and in CDivide</p>

<pre><code>void CDivide( 
    double *x[2], double a, double b, double c, double d) 
{
    double divisor = c*c + d*d; 
    *x[0] = (a*c + b*d) / divisor; 
    *x[1] = (b*c - a*d) / divisor; 
}
</code></pre>
",0
8288374,8287957,1,"<p>The problem was the prototype for the CDivide function needs to reside in the file containing the CDivide and fn_v1p0 definitions, and not the file containing the main() function. Moving the prototype for CDivide to the file containing CDivide clears the error. Thanks to Adam Rosenfield for flushing out the issue with his comments in the question above.</p>
",0
5189500,5189458,0,"<p>I am confused about your question but I think you want
printf(""%d.%s\n"",someint,&amp;s[2]);</p>
",0
5189549,5189458,2,"<p>You want <code>printf(""%.*s\n"", someInt, &amp;s[2]);</code>. Consult the <a href=""http://manpages.debian.net/cgi-bin/man.cgi?query=printf&amp;apropos=0&amp;sektion=3&amp;manpath=Debian+6.0+squeeze&amp;format=html&amp;locale=en"" rel=""nofollow"">printf man page</a> for more details.</p>
",1
3838110,3837858,5,"<p>Yes, it's possible:</p>

<pre><code>#include &lt;stdio.h&gt;

#define else if (1)
int main(void)
{
    int test = 1;

    if (test == 1)
    {
        printf(""if\n"");
    }
    else
    {
        printf(""else\n"");
    }

    return 0;
}
#undef else
</code></pre>

<p>A note for newbies: Never do this in real life! Instead, think about your problem again...</p>

<p>What you probably wanted is :</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int one_condition = 1;
    int other_condition = 2;

    if ((one_condition == 1) || (other_condition == 2))
    {
        printf(""if\n"");
    }

    if ((one_condition != 1) || (other_condition == 2))
    {
        printf(""quasi-else\n"");
    }

    return 0;
}
</code></pre>

<p>You can replace the else-path by having another if-clause with negated conditions. This gives you the possibility to override it with a second condition.</p>
",0
3838129,3837858,2,"<p>Maybe you've misunderstood your problem.</p>

<p>If you want a code block to execute regardless of the condition, take it out of the if...else statement.</p>

<pre><code>void foofunc(int n)
{
     a = 44*n;
     if(a == 484)
     {
        //do something
     }
     else
     {
        //do something if a DOES NOT equal 484
     }

     //do something regardless of the outcome of the test.
}
</code></pre>

<p>In this example, ridiculous though it is, the last line is outside the condition statement, so will execute whether a == 484 or not, which seems to me to be the same as making c trigger your <code>else</code> block regardless of the <code>if</code> test succeeds.</p>

<p>Of course, else blocks are not mandatory, so if you don't care what happens if your condition fails, then simply don't have an else block.</p>

<pre><code>void foofunc(int n)
{
     a = 44*n;
     if(a == 484)
     {
        //do something
     }

     //do something regardless of the outcome of the test.
}
</code></pre>
",0
3837877,3837858,4,"<p>No, that is not possible (inside the same process).</p>
",1
3837882,3837858,9,"<p>No, there's no way to write a Schr?dinger if clause.</p>

<p>You might be able to execute both with a goto, but it would never pass a code review. </p>
",1
3837917,3837858,26,"<p><strong>Do not use! ;-)</strong></p>

<p>Yes, by <code>fork</code>ing.</p>

<pre><code>if ( fork() ) {
    printf(""if\n"");
}
else {
    printf(""else\n"");
}
</code></pre>

<p>There are no real use cases to prefer the above code, unless it is for parallel execution.</p>
",7
3837927,3837858,1,"<p>I assume you're trying to have both branches of this sort of statement execute?</p>

<pre><code>Dim X As Boolean
X = False
If X = True Then
    ...
Else
    ...
End If
</code></pre>

<p>You <em>could</em> get it to execute using GoTo ... but that goes against good programming practice.</p>

<pre><code>Dim X As Boolean
X = False
If X = True Then
    ...
    Goto ElseStuff
Else
    ElseStuff:
    ...
End If
</code></pre>

<p>Instead of that you should write separate procedures / functions to accomplish the behavior you'd like to have execute in both statements ... or simply put the code which should execute in all cases <strong>outside</strong> of the If block.</p>

<p>That would be functionally equivalent to using the GoTo, plus it makes it clear to anybody else.</p>
",1
3582991,3582472,0,"<pre><code>char buf[size*nmemb+1];
</code></pre>

<p>Is C99 not C89. For <strong>greater</strong> nmemb -> <strong>stackoverflow</strong>, better here also use a dyn. allocation</p>

<pre><code>char *buf = calloc(1,size*nmemb+1), *pbuf = buf;
size_t i = 0;
if( !buf )
  { error-handling needed }
...
free(buf);
</code></pre>
",0
3582490,3582472,2,"<p>Change <code>char test[];</code> to <code>char *test;</code></p>
",2
3582792,3582472,1,"<p>test=new test[size*nmemb+1];</p>

<p>This is C++ code, not C.
Change it to </p>

<pre><code>test = malloc(size*nmemb+1);
</code></pre>

<p>Also it is recommended to free it somewhere. Maybe at the end of main or before allocating it.</p>

<pre><code>free(test);
</code></pre>

<p>Good luck.</p>
",0
8459121,4204973,-1,"<p>Promod answer or his explanations is not correct </p>

<p>The correct method to remember is </p>

<p>Of all the pre operators -pre increment has highest priority </p>

<p>And of all the post increment  operations -post increment has least priority </p>

<p>Addition has lower priority than both pre and post increment operators </p>

<p>Now consider the fact that Pre increment falls in the category of Right to left </p>

<p>And Post increment falls in the class of Left to right </p>

<p>Taking the two cases into consideration one can work out the code </p>

<pre><code>i = 1;
i=i++ + ++i + ++i + i++;
</code></pre>

<p>To be not 14 but 12 </p>

<p>Middle two expressions are evaluated to 4 
then 4+4+4</p>

<blockquote>
  <p>""Postfix increment/decrement have high precedence, but the actual
  increment or decrement of the operand is delayed (to be accomplished
  sometime before the statement completes execution). ""</p>
</blockquote>

<p>This is the proof link 
<a href=""http://www.ideone.com/clone/jh2hi"" rel=""nofollow"">enter link description here</a></p>
",5
4544570,4544515,1,"<p>The exact problem is because of how you declared your function, specifically with the first parameter. The way you pass <code>Node</code> makes the <code>TreeNode</code> instance being passed as an <code>in/out</code> parameter; but the pointer itself is passed by value to the function and is considered an <code>in</code> parameter. Thus, when you attempt to modify the value of the pointer, by calling <code>malloc</code>, the modified value will not be passed back to the function caller. And since the function caller does not have access to the newly allocated memory, it won't be able to <code>free</code> it, and the memory block will be leaked.</p>

<p>Valgrind detects this and warns you properly; however, since it doesn't know the semantic of your code, it can only tell you that you need to delete the memory block allocated in the function.</p>

<p>The right fix, based on the intended semantic would be to pass <code>Node *</code> or <code>Node &amp;</code> to the function, which would allow you to manipulate the original value of the pointer, instead of the call stack copy.</p>
",0
4544579,4544515,1,"<p>You need to create a recursive deallocating function, but of course you would only do it when you really want to free up the memory. You can also delete, individual TreeNode, but implementation of that will be little bit more complicated.</p>

<p>Here is how you should free up the used memory when the tree is no longer required.</p>

<pre><code>void FreeUpTree(Node root)
{
if ( root == NULL ) return;
FreeUpTree(root-Left);
FreeUpTree(root-Right);
free(root-&gt;data);
free(root);
} 
</code></pre>
",0
4678357,4678333,8,"<p>It returns 0 if n is a power of 2 (NB: only works for <code>n &gt; 0</code>). So you can test for a power of 2 like this:</p>

<pre><code>bool isPowerOfTwo(int n)
{
    return (n &gt; 0) &amp;&amp; ((n &amp; (n - 1)) == 0);
}
</code></pre>
",0
4678368,4678333,1,"<p>It's a bitwise operation between a number and its previous number.  Only way this expression could ever be false is if n is a power of 2, so essentially you're verifying if it isn't a power of 2.</p>
",0
4678373,4678333,3,"<p>It checks if n is a power of 2: <a href=""https://stackoverflow.com/questions/1551500/what-does-the-bitwise-code-n-n-1-do"">What does the bitwise code &quot;$n &amp; ($n - 1)&quot; do?</a></p>
",0
4678376,4678333,68,"<p>It's figuring out if <code>n</code> is either 0 or an exact power of two.</p>

<p>It works because a binary power of two is of the form <code>1000...000</code> and subtracting one will give you <code>111...111</code>. Then, when you AND those together, you get zero, such as with:</p>

<pre><code>  1000 0000 0000 0000
&amp;  111 1111 1111 1111
  ==== ==== ==== ====
= 0000 0000 0000 0000
</code></pre>

<p>Any non-power-of-two input value (other than zero) will <em>not</em> give you zero when you perform that operation.</p>

<p>For example, let's try all the 4-bit combinations:</p>

<pre><code>     &lt;----- binary ----&gt;
 n      n    n-1   n&amp;(n-1)
--   ----   ----   -------
 0   0000   0111    0000 *
 1   0001   0000    0000 *
 2   0010   0001    0000 *
 3   0011   0010    0010
 4   0100   0011    0000 *
 5   0101   0100    0100
 6   0110   0101    0100
 7   0111   0110    0110
 8   1000   0111    0000 *
 9   1001   1000    1000
10   1010   1001    1000
11   1011   1010    1010
12   1100   1011    1000
13   1101   1100    1100
14   1110   1101    1100
15   1111   1110    1110
</code></pre>

<p>You can see that only <code>0</code> and the powers of two (<code>1</code>, <code>2</code>, <code>4</code> and <code>8</code>) result in a <code>0000/false</code> bit pattern, all others are non-zero or <code>true</code>.</p>
",3
4613715,4613191,0,"<p>Empty program is a program, isn't it?</p>

<p>Below is my no resource use program :)</p>

<hr>

<p>Also note that. Strictly speaking, a program really don't consume any resource until OS load it and make it run. When this happen we call it a Process.</p>
",0
4613945,4613191,1,"<p>Although there will be some memory allocated by OS when you launch a program, most people don't know that main() is not the real program entry point. mainCRTStartup is, at least on Windows console app. If you create a program with real entry point you will avoid heap initialization routines, command argument parsing, global variable initialization and so on.</p>

<p>So, in some sense, you can make a program that avoids heap management and stuff. But OS will still read it into memory.</p>

<p>See: <a href=""http://www.catch22.net/tuts/minexe"" rel=""nofollow"">http://www.catch22.net/tuts/minexe</a></p>
",0
4613212,4613191,4,"<p>No its not possible.  The code and stack must go somewhere and that will, nearly always, be in memory.</p>

<p>Ignoring that surely its pretty easy to just write an application that exits straight away.</p>
",2
4613220,4613191,35,"<p>All programs use memory.  When you run the program, the OS will set up an address space for the program, copy its arguments into its process space, give it a process ID and a thread, give it some file descriptors for I/O, etc.  Even if your program immediately terminates you still use up this memory and CPU time.</p>
",0
4613239,4613191,2,"<p>your response should be along the lines of enquiring as to 'why' you'd want to do such a thing. this would show a latitude for thinking beyond the question.</p>
",5
4613263,4613191,1,"<p>On the surface the question seems to have a simple answer: ""No, it can't be done."" @templatetypedef has given some reasons.</p>

<p>But perhaps the point of the question is to see how you address it. You might get ""marks"" for asking ""what kind of memory"" or for observing some of the points that @templatetypedef made. Or for showing the empty main() method given by @Mihran Hovsepyan and then explaining that some memory will be involved even in this minimal case.</p>
",0
4620035,4613191,0,"<p>The correct answer is that it's implementation-specific. An implementation could support null programs and the <code>execve</code> (or equivalent) mechanism could perform the equivalent of <code>_Exit(0)</code> when it encounters one, but in practice it doesn't.</p>
",0
3750644,3750558,1,"<p>All members of a union share the same storage space, enough to accommodate the alignment and size of the largest and most restrictive of the members. Normally, you'd also require a member in the structure to indicate what union member to use.</p>
",0
3724510,3724493,2,"<p>becouse you hide a variable in a scope - and that a good way to make mistakes. In small programs you could remember which variable is global/local - in more complicated don't.</p>
",0
3724515,3724493,3,"<p>The source code will be hard to understand, that's the problem, but it is legal.</p>
",0
3724536,3724493,2,"<p>You can declare variables either in functions (local variables), or outside functions (global variables). You should generally minimize the scope of a variable, as this makes the code easier to understand.</p>

<p>For example, if you're modifying the value of a global variable in one function, and call another function which, for unrelated reasons, also happens to modify that variable, the resulting code might do things that you're not expecting and which someone reading your code wouldn't expect (let alone if you were to then try parallelising that code...)</p>
",0
3724605,3724493,4,"<p>In C, variables are lexically scoped, which means that at any given point in your code, the <em>compiler</em> knows which actual variable is being referred to by a given name.  The problem is that if you have two variables named <code>foo</code>, (a) <em>you</em> might not remember which is which, and (b) you <em>can't</em> refer to the outer <code>foo</code> when you're in the inner <code>foo</code>'s scope.</p>

<p>In particular:</p>

<pre><code>void MyFunction()
{
    int foo = 1;
    printf(""%d"", foo); // prints ""1""

    // create a new scope...
    if (whatever)
    {
        int foo = 2;
        printf(""%d"", foo); // prints ""2""
        foo = 3;
        printf(""%d"", foo); // prints ""3""
    }

    printf(""%d"", foo); // prints ""1""
}
</code></pre>

<p>Now, just imagine that the <code>whatever</code> block were long and complicated... when you get to <code>foo = 3</code>, let's say the top of the block isn't on the screen, but <em>you</em> know that <code>MyFunction</code> has a function-wide variable named <code>foo</code>.  The only problem is that you're wrong, you're only setting the value of the ""inner"" <code>foo</code>.  From the compiler's point-of-view it's obvious... because the inner <code>foo</code> hides the outer one completely.  That's why it's considered a bad practice.</p>

<p>You may want to read <a href=""http://en.wikipedia.org/wiki/Scope_(programming)"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Scope_(programming)</a> to learn more about lexical scoping.</p>
",0
3724669,3724493,1,"<p>This is called <a href=""http://en.wikipedia.org/wiki/Variable_shadowing"" rel=""nofollow noreferrer"">variable shadowing</a>, it has its advantages for small things like constructors, but in the long run it can lead to problems:</p>

<ul>
<li>code is ambigous and thus hard to read and understand</li>
<li>the wrong variable might unintentionally be used, leading to hard to spot bugs</li>
<li>confusion may arise when your working with your own code</li>
</ul>

<p>bottom line: yes you can do it, but avoid it as much as possible, especially in big projects, as you probably will end up getting stabbed :P</p>
",0
4240456,4240442,0,"<p>Use the <code>exit()</code> function.</p>
",0
4240460,4240442,4,"<p>If the code is inside main, you can simply use <code>return</code> if somewhere else use <code>exit</code></p>
",1
4240461,4240442,0,"<p>At the risk of sounding too terse, <code>exit();</code></p>
",0
8388746,8388695,1,"<p>You can use <code>strtok</code>, as Martin Beckett said, which is recommended for portability. However, if your system has <code>strsep</code> available, I'd go with it. Its man page on BSD has the solution to your question in the examples section.</p>

<pre><code>#include &lt;string.h&gt;
int main()
{
    char input[] = "" a          322  4.1   5.2""; 
    char **ap, *argv[5], *inputstring = input;

    for (ap = argv; (*ap = strsep(&amp;inputstring, "" \t"")) != NULL;)
        if (**ap != '\0')
            if (++ap &gt;= &amp;argv[10])
                break;

    /* degubber output for `p argv':
     *
     * $1 = {
     *  0x1001009a1 ""a"",
     *  0x1001009ac ""322"",
     *  0x1001009b1 ""4.1"",
     *  0x1001009b7 ""5.2"",
     *  0x0
     * }
     */
}
</code></pre>
",3
8389547,8388695,0,"<pre><code>for(int i=0,j=0; str[i]; i++)
{
    if(str[i]==' ')
        continue;
    str2[j]=str[i];
    j++;
}
</code></pre>

<p>In the above code, <code>str</code> is your previous string and <code>str1</code> is the new.</p>
",0
8389074,8388695,0,"<p>Safest way to split a string (especially if you don't know what the string may contain) is <a href=""http://www.gnu.org/s/hello/manual/libc/Finding-Tokens-in-a-String.html"" rel=""nofollow"">strtok</a>.</p>

<p>You might also need to check how you are creating the string[] array in 'C'</p>
",1
8389961,8388695,2,"<p>What the original poster asked using <code>sscanf()</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(){
    // 5 elements, each of 32 bytes, 31 for characters the 32nd for storing \0
    char string[5][32];
    char* inputString=""a          322  4.1   5.2"";
    memset(string,0,sizeof(string));//to initialize to NULL, always be safe on C
    sscanf(inputString,""%s%s%s%s"",string[0],string[1],string[2],string[3]);
    printf(""res0= %s\n"",string[0]);
    printf(""res1= %s\n"",string[1]);
    printf(""res2= %s\n"",string[2]);
    printf(""res2= %s\n"",string[3]);
    return 0;
}
</code></pre>

<p>This will print:</p>

<pre><code>res0= a
res1= 322
res2= 4.1
res2= 5.2
</code></pre>
",5
4518292,4517246,0,"<p>I'm bored too. Here's a solution using recursion and Vladimirs subtraction trick:</p>

<pre><code>int find_dupe(int* array, int len)
{
    static int sum = 0;
    sum += array[0];

    if(len == 1)
        return sum - 45;

    return find_dupe(array+1, len-1);
}

int main()
{
    int array[10] = { 9, 2, 5, 8, 6, 7, 1, 3, 4, 2 };

    printf(""dupe: %i\n"", find_dupe(array, 10));

    return 0;
}
</code></pre>
",0
4517268,4517246,7,"<pre><code>int sum = 0;
for (int i = 9; i &gt;= 0; --i)
    sum+=array[i];
int repeatedNumber = sum - 45; // 45 = 1+...+9
</code></pre>

<p>This solution does use loop, but your condition is controversial - traversing array implies that the loop is used</p>
",4
4517272,4517246,3,"<p>Make an array of 10 bools. Each bool represent whetether its respective number already occurred. If you find bool while writing a true, the number is repeated.</p>
",5
4517981,4517246,8,"<p>The shortest answer has to be based on Vladimir's answer. There is no for loop, however it is also not expandable to variable size arrays. It is:</p>

<pre><code>int repeated_number = array[9]+array[8]+array[7]+array[6]+array[5]
                     +array[4]+array[3]+array[2]+array[1]+array[0]-45;
</code></pre>

<p>Sweet and simple, answers the question. I think, the problem is that all the people answering this question are to used to writing good sensible code that can handle variable situations, but this is a short simple question so deserves a short simple answer.</p>
",0
4518076,4517246,0,"<p>The Solution I give is from CommanderZ but the only difference is that I was bored and I do not want to go study so instead I did the code.</p>

<pre><code>int FindDuplicate(int index)
{
    static bool initialized = false;
    static bool Existance[10];
    if(!initialized)
    {
        for (int i = 0 ; i &lt; 10 ; i++)
            Existance[i] = false;
        initialized = true;
    }

    if(index == -1)
        return 0;

    if(Array[index] == true)
        return index;
    else
        Array[index] = true;

    return FindDuplicate(index - 1); //edit-fix

}
</code></pre>

<p>Also See this thread which might be a bit similar : <a href=""https://stackoverflow.com/questions/4234027/given-an-array-with-multiple-repeated-entries-fnd-one-repeated-entry-on-time-a"">Given an array with multiple repeated entries, fnd one repeated entry O(N) time and constant space</a></p>

<p>And this one too : <a href=""https://stackoverflow.com/questions/1151318/array-homework-question"">Array Homework Question</a></p>
",2
4521972,4517246,0,"<p>Try using a boolean array to indicate whether a value exists or not.  Use <code>true</code> to indicate the number exists.  </p>

<pre><code>int main(void)
{
  const unsigned int array_values[10] = {1, 2, 3, 3, 4, 5, 6, 7, 8, 9};
  bool               is_resident[10] = {false};
  bool               duplicate = false;
  unsigned int       index = 0;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  duplicate = duplicate || is_resident[array[index]];
  is_resident[array[index++]] = true;
  std::cout &lt;&lt; ""Duplicate found: "" &lt;&lt; (char *)(duplicate ? ""true"" : ""false"") &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p>The above code is not tested and specialized for this question.  This code has no other purpose in life in is not generalized.  </p>

<p><em>Note:  No loops were used or harmed in this example.</em><br>
<em>""There is always a third alternative."" -- Thomas Matthews</em></p>
",0
5496224,5496192,2,"<p>You have two option</p>

<ol>
<li>To read whole file, remove what you need and write it back</li>
<li>If the file is big, read file sequentially, remove given part, and move content after that forward</li>
</ol>
",2
5496228,5496192,2,"<p>No there is no such function that will let you do this directly on  a file.</p>

<p>You should load up the file content in memory and modify there and write back to file.</p>
",0
5496841,5496192,1,"<p>I don't feel like looking up all the io functions, so here's pseudo-c on how to implement option 2 of ArsenMkrt's answer</p>

<pre><code>char buffer[N]; // N &gt;= 1
int str_start_pos = starting position of the string to remove
int str_end_pos = ending position of the string to remove
int file_size = the size of the file in bytes
int copy_to = str_start_pos 
int copy_from = str_end_pos + 1

while(copy_from &lt; file_size){
    set_file_pos(file, copy_from)
    int bytes_read = read(buffer, N, file)
    copy_from += bytes_read
    set_file_pos(file, copy_to)
    write(buffer, file, bytes_read)
    copy_to += bytes_read
}
truncate_file(file,file_size - (str_end_pos - str_start_pos + 1))
</code></pre>

<p>something to that effect</p>
",0
4601162,4601140,-1,"<p>Change your <code>for</code> loop to be more like:</p>

<pre><code>#define BIT(x) (1U &lt;&lt; (x))

for (i = 31; i &gt;= 0; --i)
{
    if (x &amp; BIT(i)) {
        putchar('1');
    }
    else {
        putchar('0');
    }

}
</code></pre>
",1
4601168,4601140,1,"<p>You're printing the least significant bit first.  Change your for loop to count down:</p>

<pre><code>      for (int i = 31; i &gt;= 0; i--)
</code></pre>
",0
4601236,4601140,0,"<p><strong>EDIT:
Seem that I'm the one who overlooked desired output. So the solutions provided by others will work for the OP.</strong></p>

<hr>

<p>I'm surprised people overlooked the fact that endianness usually applies to byte level instead of bit, which make the plain index-based loop fail to provide required output.</p>

<p>for a decimal to big-endian byte, you need :</p>

<pre><code>while (num)
{
    big &lt;&lt;= 8;
    big |= num &amp; 0xFF;
    num &gt;&gt;= 8;
}
</code></pre>

<p>so in order to output little-endian integer into big-endian binaries, you need :</p>

<pre><code>// 'num' was 4-byte (int) data in little-endian format
while (num)
{
    // select required byte block
    unsigned char curByte = num &amp; 0xFF;

    // prints the byte binaries
    for(int iBit=7; iBit&gt;=0; --iBit)
    {
        unsigned char theBit = curByte &gt;&gt; iBit;
        if (theBit &amp; 0x1)
            putchar('1');
        else
            putchar('0');

    }

    // shifts to next byte block
    num &gt;&gt;= 8;
}
</code></pre>
",1
3853857,3852839,0,"<p>Here's a printf-free example ( old version: <a href=""http://codepad.org/vnjFj7Uh"" rel=""nofollow"">http://codepad.org/vnjFj7Uh</a> )</p>

<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

/* return the maximum of n values. if n &lt; 1 returns 0 */
/* lying to the compiler is not supported in this version, eg:         **
**    va_max(4, 8, 8, 8, 8, 8, 8, 8, 8)                                **
** or                                                                  **
**    va_max(4, 2, 2)                                                  **
/* is a bad way to call the function (and invokes Undefined Behaviour) */
int va_max(int n, ...) {
  int res;
  va_list arg;

  if (n &lt; 1) return 0;

  va_start(arg, n);
  n--;
  res = va_arg(arg, int);
  while (n--) {
    int cur = va_arg(arg, int);
    if (cur &gt; res) res = cur;
  }
  return res;
}

int main(void) {
  int test6 = va_max(6, 1, 2, 3, 4, 5, 6);
  int test3 = va_max(3, 56, 34, 12);
  if (test6 == 6) puts(""6"");
  if (test3 == 56) puts(""56"");
  return 0;
}
</code></pre>
",2
3852863,3852839,3,"<p>sure, look at common usages of printf:</p>

<pre><code>printf(""Error %d: %s"", errNum, errTxt);
</code></pre>
",2
3852956,3852839,2,"<pre><code>so ross$ expand &lt; variadic.c &amp;&amp; cc -Wall -Wextra variadic.c 
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void f(int, ...);
struct x { int a, b; } y = { 5, 6 };

int main(void) {
  float q = 9.4;
  f(0, 1.234, &amp;q, ""how now"", 123, &amp;y);
  return 0;
}

void f(int nothing, ...) {
  va_list ap;

  va_start(ap, nothing);
  double f = va_arg(ap, double);
  float *f2 = va_arg(ap, float *);
  char  *s   = va_arg(ap, char *);
  int    i    = va_arg(ap, int);
  struct x *sx = va_arg(ap, struct x *);
  va_end(ap);

  printf(""%5.3f %3.1f %s %d %d/%d\n"", f, *f2, s, i, sx-&gt;a, sx-&gt;b);
}
so ross$ ./a.out
1.234 9.4 how now 123 5/6
</code></pre>
",0
3856883,3852839,0,"<p>I made a function to unpack binary data using a varadic function,it takes different types based on
what you want ""encoded/decoded"".</p>

<p>You'd use it like:</p>

<pre><code>uint32_t a;
uint16_t b;
uint16_t c;
uint8_t *buf = ....;

depickle(buf,""sis"",&amp;a,&amp;b,&amp;c);
</code></pre>

<p>where 's' expects an uint16_t* and decodes 2 bytes from <code>buf</code> into <code>a</code> as little endian, 'i' says to decode 4 bytes as little endian into 'b'</p>

<p>Or to e.g. decode 4 bytes as big endian into a uint32_t:</p>

<pre><code>uint32_t a;
uint8_t buf[] = {0x12,0x34,0x56,0x78};
depickle(buf,""I"",&amp;a);
</code></pre>

<p>There's still an early version around <a href=""http://asgaard.homelinux.org/svn/rotekopp/pickle.c"" rel=""nofollow"">here</a>.</p>
",0
4677810,4677779,1,"<p>What's wrong with just modifying the code you have:</p>

<pre><code>int a[4];
for (i = 0; i &lt; 4; i++)
    a[i] = ((ip-&gt;ip_dst.s_addr)&amp;(0x0FF&lt;&lt;(i*8)))&gt;&gt;(i*8);
</code></pre>

<p>That should give them to you in <code>a[0]</code> and <code>a[1]</code>.</p>

<hr>

<p>The following code shows one way to do it. The IP address is reversed (<code>0x0b0280c0</code>) due to the x86 little-endian format:</p>

<pre><code>#include &lt;stdio.h&gt;
int main (void) {
    int i;
    unsigned int addr = 0x0b0280c0;
    int a[4];
    for (i = 0; i &lt; 4; i++)
        a[i] = ((addr)&amp;(0x0FF&lt;&lt;(i*8)))&gt;&gt;(i*8);
    printf (""%d %d %d %d\n"", a[0], a[1], a[2], a[3]);
    return 0;
}
</code></pre>

<p>It outputs:</p>

<pre><code>192 128 2 11
</code></pre>

<p>and you can see that the components are placed in the individual array elements.</p>
",0
7817698,7817667,1,"<p>You are most likely using the wrong gcc arguments - probably you are using the same ones you'd use for an executable program (where <code>main()</code> is required). The correct arguments depend on what kind of library you want to build (a static one or a dynamic (.so) one)</p>
",0
3853956,3853929,4,"<p>Well, you have allocated an array equivalent in size to:</p>

<pre><code>int a[5][3];
</code></pre>

<p>So to enter values you just do like this:</p>

<pre><code>a[0][0] = 1234;
</code></pre>

<p>Which would put a value into the first column of the first row and</p>

<pre><code>a[4][2] = 9999;
</code></pre>

<p>would put another value into the last column of the last row.</p>

<p>Since you are using malloc, you should also loop through a[i] from i = 0 to 4, and <code>free(a[i]);</code> and then <code>free(a);</code> or your program will leak memory.</p>
",0
3854081,3853929,3,"<p>All right... what you have here, basically, is a pointer-pointer, namely, the adress of an adress. You can use this kind of variable when dealing with arrays. </p>

<p>The first two lines of your code are equivalent to :</p>

<pre><code>int* a[5]; // Declaration of an array of 5 integer pointers (a[0] till a[4]).
</code></pre>

<p>A ""pure"" C code doesn't use variable for the size of an array, so you use the malloc when you want to edit dynamically the size of the array. </p>

<p>Meaning, if in your code, you are not going to change the size of your arrays, you are using a very complex way to achieve a very simple goal. You could just type :</p>

<pre><code>int a[5][3];
</code></pre>

<p>But if you do not know the size of your array, you have to use the mallocs (and then, free). What you are doing, basically, is : </p>

<ul>
<li>Declaring an array of array;</li>
<li>Allocating the memory for x number of POINTER to integer arrays;</li>
<li>For each of these POINTERS, allocating memory for y integers.</li>
</ul>

<p>Now that you have done this, you can use your arrays normally. For instance :</p>

<pre><code>a[1][0] = 1;
</code></pre>

<p>will mean : in the first array [1], the first row [0] is 1.</p>

<p>The only difference with a standard declaration like the one above, without the mallocs, is that since you allocated memory, you'll have to free it. Which is why you don't want to lose your variable a**. At the end of your function, the pointer-to-pointer variable will be destroyed, but not the memory you allocated.</p>
",0
7470831,7470750,0,"<p>This looks fine to me. It would be helpful to have more information. All I did was extract your example into a temp.c file and compile it using gcc -c temp.c. There were no errors.</p>

<p>On which OS is this?</p>

<p>Which build environment/compiler is this?</p>

<p>How are you building this? (commands used in the build environment)</p>

<p>I'm using gcc 4.4.3 on Ubuntu Linux 10.04.</p>

<h2>Edit 1:</h2>

<p>What happens if you cast car.buyer to an int?</p>

<blockquote>
  <p>printf(""value of car is .. %d\n"", (int ) car.buyer);</p>
</blockquote>

<h2>Edit 2:</h2>

<p>How about this to print your 1?</p>

<pre><code> #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;


typedef struct slot_car {
    int buyer;
} slot_car;



int main() {



    slot_car car;
    memset(&amp;car, 0, sizeof(car));
    car.buyer = 1;

    printf(""value of car is .. %d\n"", car.buyer);

    {
       int temp_ret;
       temp_ret = funct_to_print_value();
       printf(""end of function..%d\n"",temp_ret);
    }
    return 0;
}

int funct_to_print_value()
{
    printf(""you are in printlist function..\n"");
    slot_car car;
    printf(""value of car inside is %d\n"", car.buyer);

    return 1;
}

value of car is .. 1
you are in printlist function..
value of car inside is 134514096
end of function..1
cnorton@steamboy:~/scratch$ 
</code></pre>
",4
7470906,7470750,1,"<p>Since you declared car inside each function separately, they are separate (local) variables. You probably want to pass it from main to funct_to_print_value as a parameter instead. The warning is strange, but it is possible that the compiler detected the uninitiated value and gave this message because it is first used in printf.</p>
",0
4145096,4145062,2,"<p>What you can do is:</p>

<ul>
<li>create .h file</li>
<li>fork
<ul>
<li>if in child: execve</li>
<li>if in father: wait (or not, depends on what you want to do)</li>
</ul></li>
</ul>
",0
4145149,4145062,0,"<p>I would use a <code>Makefile</code>; your program would receive the header file at runtime, (perhaps check it?) then <code>execve()</code> the <code>make</code> command passing the name of the file. </p>

<p>However, this sounds very cumbersome; perhaps you are trying to achieve something with the wrong tool. Maybe you want to use some scripting first? Or write two separate programs..? What are you trying to do?</p>
",2
4145200,4145062,3,"<p><a href=""http://linux.die.net/man/3/dlopen"" rel=""nofollow"">dlopen</a> is a solution. It allows to load dynamic library at runtime.</p>

<ul>
<li>Compile your dummy program as a dynamic library.</li>
<li>Make use of dlopen on your .so</li>
<li>Call any function you need as if it has been linked by gcc (see dlsym).</li>
</ul>
",2
4151893,4151757,0,"<p>You could try the www.imagemagick.org libraries.</p>
",5
4151764,4151757,0,"<p>Here is a good primer which discusses some of the color space issues:
<a href=""http://www.fourcc.org/fccyvrgb.php"" rel=""nofollow"">http://www.fourcc.org/fccyvrgb.php</a></p>
",3
4155743,4155699,4,"<p>It crashes because it's in read-only memory. Try </p>

<pre><code>char string_labels[][6] = { ""one"", ""two"", ""three"", ""four"", ""five"" };
sprintf(string_labels[0], ""xxx"");
</code></pre>
",0
4155747,4155699,2,"<p>To do this, you need to use a character array, so that you actually have some runtime-writable space to modify:</p>

<pre><code>char string_labels[][20] = { ""one"", ""two"", ""three"", ""four"", ""five"" };

void myFunction(void)
{
    /* Printing works like before (could be improved, '5' is nasty). */
    for(i=0; i &lt; 5; i++)
    {
        printf(""%s\n"", string_labels[i]);
    }

    /* Now, modifying works too (could be improved, use snprintf() for instance. */
    sprintf(string_labels[0], ""xxx"");
}
</code></pre>
",0
4155810,4155699,0,"<p><code>string_labels</code> is an array of char pointers pointing to string literals. Since the string literals are read-only, any attempt to modify them leads to undefined behavior.</p>

<p>You can change the declaration of <code>string_labels</code> as below to make your <code>sprintf</code> work:</p>

<pre><code>char string_labels[][6] = { ""one"", ""two"", ""three"", ""four"", ""five"" };
</code></pre>
",0
4155814,4155699,0,"<p>Each of <code>string_labels[i]</code> points to a string literal, and attempting to modify the contents of a string literal invokes undefined behavior.  </p>

<p>You'll need to declare <code>string_labels</code> as an array of arrays of <code>char</code>, rather than as an array of pointers to <code>char</code>:</p>

<pre><code>#define MAX_LABEL_LEN ... // however big the label can get + 0 terminator

char string_labels[][MAX_LABEL_LEN]={""one"", ""two"", ""three"", ""four"", ""five""};
</code></pre>

<p>This declares a 5-element array (size taken from the number of initializers) of <code>MAX_LABEL_LEN</code> arrays of <code>char</code>.  Now you can write to the contents of <code>string_labels[i]</code>.  </p>
",0
4173114,4173090,0,"<p>In <code>C</code> comparisons have a value. 1 if true, 0 if false. Maybe you can use that instead of the forbidden <code>if</code></p>

<pre><code>(operator == '+') /* this is either 0 or 1 */
(operator == '-') /* this is either 0 or 1 */
(operator == '*') /* this is either 0 or 1 */
(operator == '/') /* this is either 0 or 1 */
</code></pre>
",4
4173188,4173090,1,"<p>As is remarked in the comments, the code is ridden with problems. Try this simple <code>switch-case</code> statement:</p>

<pre><code>switch(op) {
    case '*': printf(""%d"",a*b); break;
    case '/': printf(""%d"",a/b); break;
    case '+': printf(""%d"",a+b); break;
    case '-': printf(""%d"",a-b); break;
    default: printf(""Unknown operator.""); break;
}
</code></pre>

<p>You'll handle the rest, right?</p>

<p>[EDIT]</p>

<p>OK, I thought it was SUPPOSED to use a <code>switch-case</code>.</p>

<p>How about this:</p>

<pre><code>int result = 0;
result = (op == '*') ? a * b : result;
result = (op == '/') ? a / b : result;
result = (op == '+') ? a + b : result;
result = (op == '-') ? a - b : result;
printf(""%d"",result);
</code></pre>

<p>There's no <code>if-else</code> or <code>switch-case</code> :) You can also nest the statements if you wish (but that's unreadable).</p>
",2
4173191,4173090,4,"<p>The following should do the trick. It avoids using <code>if else</code> and <code>switch</code> by taking advantage of the fact that comparing the operator to either of <code>+</code>, <code>-</code>, <code>*</code> or <code>/</code> will return <code>1</code> for only one of the comparisons and <code>0</code> for the rest. Therefore the result is the sum of these comparisons, multiplied by the mathematic expression that corresponds to each operator:</p>

<pre><code>#include&lt;stdio.h&gt;

main(){
    float a,b,result;
    char oper [2];
    printf(""enter a value:"");
    scanf(""%f"",&amp;a);
    printf(""enter another value:"");
    scanf(""%f"",&amp;b);
    printf(""enter an operator:"");
    scanf(""%1s"", oper);
    result = (oper[0] == '+') * (a + b) +
             (oper[0] == '-') * (a - b) +
             (oper[0] == '*') * (a * b) +
             (oper[0] == '/') * (a / b);
    printf(""%4.2f %s %4.2f = %4.2f\n"", a, oper, b, result);
}
</code></pre>

<p>When saved to a file called <code>calculator.c</code> the following command will compile it:</p>

<pre><code>gcc calculator.c
</code></pre>

<p>The output will be called <code>a.out</code> and it can be run like this:</p>

<pre><code>./a.out
enter a value:24
enter another value:4
enter an operator:/
24.00 / 4.00 = 6.00
</code></pre>

<p>I've been using <code>gcc (GCC) 4.4.1 20090725 (Red Hat 4.4.1-2)</code> but I'm sure other versions will work just as well.</p>

<p>Let me know if I pass your assignment ;-)</p>
",10
4173133,4173090,1,"<p>You should be able to solve it by pushing the operator and values onto a stack, and then just ""execute"" the stack.</p>

<p>Since this probably is a homework, I leave you with the task to implement the it :)</p>
",3
4174959,4173090,2,"<p>Actually, I've thought of a solution that satisfies the condition of the assignment and isn't <em>totally</em> retarded.</p>

<p>You can create a function for each operation; it takes the two inputs as arguments and returns the result.  You can then create a table of pointers to those functions, indexed by the operator character.  </p>

<p>Then you can execute the function through the pointer.</p>

<pre><code>int multiply(int a, int b)
{
  return a * b;
}

/**
 * do the same for add, subtract, and divide
 */

int main(void)
{
  int a, b;
  char op;
  /** 
   * create an array of pointers to functions indexed by 
   * character values; we will only be using four of these entries,
   * but this allows us to index the array using the operator
   * character directly instead of having to do any mapping.
   * We're trading some unused space for simplicity.
   */
  int (*func_table[128])(int, int);

  /**
   * Set the table entries for each operator.
   */
  func_table['*'] = multiply;
  /**
   * Do the same for each of '-', '+', '/'
   */
  ... 

  /**
   * After reading in a, b, and the operator, execute
   * the function through the lookup table
   */
  result = (*func_table[op])(a, b);
</code></pre>

<p>Presto; no control structures.  </p>

<p>I was reluctant to post this for a couple of reasons.  First, it basically gives away the store.  Second, I doubt you've discussed function pointers in class yet.  I have no idea what your instructor expects; I doubt it's this.  </p>
",0
4236904,4173090,0,"<pre><code>void main()

{

    int a,b,sum,sub,pro,divide; /** sum is for addition,,sub is for subtraction,,pro is for product,,divide is for division**/
    char operator;
    clrscr();      
    printf(""enter a value:"");
    scanf(""%d"",&amp;a);      
    printf(""enter another value:"");
    scanf(""%d"",&amp;b);
    printf(""enter a operator:"");
    scanf(""%c"",&amp;operator);

    operator=='+'? printf(""%d,a+b""): ;
    //same goes for all the other operators

    getch();  

}
</code></pre>
",0
2340379,2340271,0,"<p>Here is a short C program:</p>

<pre><code>#include &lt;stdio.h&gt;
int main() {
  char buf[20];
  for (int i = 0; i &lt; 20; i++) {
    printf(""%d "", buf[i]);
  }
  printf(""\n""); return 0;
}
</code></pre>

<p>Think carefully about what it ought to print when you run it. </p>

<ul>
<li>Will it print the same thing every time you run it?</li>
<li>On every machine you run it on?</li>
</ul>

<p>Spoiler below:</p>

<pre><code>(spoiler padding)













.
</code></pre>

<p>Here's what I saw it print for one run: <code>0 0 0 0 0 0 0 0 -128 5 64 0 0 0 0 0 -16 -60 -55 31</code></p>

<p>The same bug afflicts both of our programs, but it might be easier to see in mine.</p>
",0
4236889,4228650,1,"<ol>
<li>First of all the first index to work
with will be '0',not 1.</li>
<li>wrong identifier for string,it
should be %s.</li>
<li>If you just want to iterate by
asking y/n then just change the
display message from yes/no to y/n
and also change that strange while
condition to check=='y'||check=='Y'.</li>
<li>The code will actually not work
after 5 iterations because you
initialized only 5 structures of
that type.Why don't you add that in
the loop?</li>
</ol>
",0
4531866,4531836,1,"<p>One standard solution is to have reference counters, that is every object that can possibly be referred by many other objects must have a counter that remembers how many of them are pointing it. This is done with something like</p>

<pre><code>typedef struct T_Object
{
    int refcount;
    ....
} Object;

Object *newObject(....)
{
    Object *obj = my_malloc(sizeof(Object));
    obj-&gt;refcount = 1;
    ....
    return obj;
}

Object *ref(Object *p)
{
    if (p) p-&gt;refcount++;
    return p;
}

void deref(Object *p)
{
    if (p &amp;&amp; p-&gt;refcount-- == 1)
        destroyObject(p);
}
</code></pre>

<p>Who first allocates the object will be the first owner (hence the counter is initialized to 1). When you need to store the pointer in other places every time you should store <code>ref(p)</code> instad, to be sure to increment the counter. When someone is not going to point to it anymore you should call <code>deref(p)</code>. Once the last reference to the object is gone the counter will become zero and the deref call will actually destroy the object.</p>

<p>It takes some discipline to get it working (you should always think when calling ref and deref) but it's possible to write complex software that has zero leaks using this approach.</p>

<p>A simpler solution that is sometimes applicable is having all your shared objects also stored in a separate list... you freely assign and change complex data structures pointing to these objects but you never free them during the normal use. Only when you need to throw everything away you deallocate those objects by using that separate list.
Note that this approach is possible only if you're not allocating many objects during the ""normal use"" because in that case delaying the destruction could be not viable.</p>
",2
3446798,3446781,1,"<p>you can use the <code>%s</code> format for this:</p>

<pre><code>snprintf(dst, 50, ""%s*"", dst);
</code></pre>

<p><strong>EDIT:</strong> This seems to have some undefined behaviors. The best thing would be to ask if it is really necessary to use <code>snprintf</code> instead of <code>strncat</code>.</p>
",6
3446812,3446781,2,"<p>The obvious solution:</p>

<pre><code>snprintf(dst,50,""%s*"",dst);
</code></pre>

<p><s>is inefficient, because it makes an unnecessary copy of <code>dst</code> (into itself).</s></p>

<p>invokes undefined behavior as R. pointed out, because the arguments may not overlap (from man snprintf(3) on MacOSX):</p>

<blockquote>
  <p>""[...]or those routines that write to
  a user-provided character string, that
  string and the format strings should
  not overlap, as the behavior is
  undefined.""</p>
</blockquote>

<p>Posix says:</p>

<ul>
<li><a href=""http://www.opengroup.org/onlinepubs/000095399/functions/printf.html"" rel=""nofollow noreferrer"">http://www.opengroup.org/onlinepubs/000095399/functions/printf.html</a></li>
</ul>

<blockquote>
  <p>""If copying takes place between
  objects that overlap as a result of a
  call to sprintf() or snprintf(), the
  results are undefined.""</p>
</blockquote>

<p><code>snprintf</code> returns the number of characters it has written, so you can do this instead:</p>

<pre><code> int k=snprintf(dst,50,str,""Come"");
 // make sure that we do not pass potential disastrous values to snprintf, because 
 // the size argument is unsigned (size_t, 50-52 is a large positive number!) 
 // and we want 50-k to be in the range 0-50
 // k&lt;0 means output error and k&gt;50 means ""output truncated"". There is no point in 
 // appending anything in these cases anyway. 
 if (k&lt;0 || k&gt;50) 
 {
  fprintf(stderr,""output error or buffer too small"");
 }    
 else k=snprintf(dst+k,50-k,""*"");
 // check k for truncation here.
</code></pre>

<p>And then there's always <code>strcat</code>...And just in case, you overlooked it. You can have the * attached right in the first place:</p>

<pre><code>main()
{
 char str[50] = ""Wel %s*""; //&lt;--!!!
[...]
</code></pre>
",4
3446847,3446781,2,"<p>This should work:</p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
 char str[50] = ""Wel %s"";
 char dst[50];
 int len;

 snprintf(dst,50,str,""Come"");

 //get size of current string
 len = strlen(dst);

 //add character to the end
 snprintf(dst + len, sizeof(dst) - len, ""*"");

 printf(""str = %s\n"",str);
 printf(""dst = %s\n"",dst);

 return 0;
}
</code></pre>
",7
3446887,3446781,0,"<p>All the information is already available to you:</p>

<pre><code>snprintf(dst + 8, sizeof(dst) - 8, ""%s"", ""*"");
</code></pre>

<p>You'd be better off doing:</p>

<pre><code>strncat(dst, ""*"", sizeof(dst) - strlen(dst) - 1);
</code></pre>
",1
4236891,4236886,2,"<p>you want:</p>

<pre><code>int main () 
{ 
    addEmployee(); 
    printEmployee(1); 

    return 0; 
} 
</code></pre>
",3
4236897,4236886,1,"<p>Change this:</p>

<pre><code>int main ()
{
    int addEmployee();
    int printEmployee();
    return 0;
}
</code></pre>

<p>To this:</p>

<pre><code>int main ()
{
    addEmployee();
    printEmployee();
    return 0;
}
</code></pre>

<p>You're re-declaring the functions instead of calling them.</p>

<p>You'll also have to change your <code>printEmployee</code> function to not accept an integer argument; it seems like it should just be using the same global variable as <code>addEmployee</code>. This is a bad idea though; global variables are generally to be avoided. <code>addEmployee</code> should probably return the employee ID, which you could store and then pass into <code>printEmployee</code>.</p>
",0
4236900,4236886,3,"<p>When you call a function you do not put the return type in front of the call.  The call is simply the name of the function and any parameters you are calling it with.  So your main function should look like this:</p>

<pre><code>int main() {
    addEmployee();
    printEmployee(1);

    return 0;
}
</code></pre>

<p>EDIT:  So in your <code>employee.c</code> file, you are trying to use <code>addEmployee()</code> to take a number of employees from the command line and store it in the variable <code>i</code> right?  And you want <code>printEmployee()</code> to tell you how many employees were entered?  Here's how you would do that.</p>

<pre><code>//employee.c
#include ""employee.h""
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int i;

int addEmployee(void)
{
    int numE;
    printf(""Please type in the number of your employees: "");
    scanf_s(""%d"", &amp;numE);
    i = numE;
}

int printEmployee()
{
    printf(""%d"", i);
    getchar();
    getchar();
}
</code></pre>

<p>Here's what I did. </p>

<p>First, I made <code>numE</code> a variable local to the addEmployee function that uses it.  Generally you should keep variable scope as small as possible.  That means keep them down to the lowest level they are used.  In this case, <code>numE</code> is only needed by <code>addEmployee()</code> so that's its scope.  </p>

<p>Second, I removed the parameter from <code>int printEmployee(int i)</code>.  It was overriding your <code>i</code> variable at the file level.  So you were storing the number read into <code>numE</code> in <code>i</code> but then when you entered <code>printEmployee()</code> you were creating a new, empty <code>i</code> that hid it.  When you called <code>printEmployee(1)</code> from main, you were passing the value 1 into <code>i</code> in <code>printEmployee(int i)</code>.  By removing the parameter, you stop hiding <code>employee.c</code>'s <code>i</code>. </p>

<p>Finally, I removed the returns.  A function doesn't have to return anything in C.  And if you are not going to use the return, then it's just an extra line of code to include it.</p>

<p>There's one more change you'll have to make to make this work, in your <code>lab6.c</code> file.  Remove the parameter from the call to <code>printEmployee()</code></p>

<pre><code>//lab6.c
#include ""employee.h""
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;


int main ()
{
    addEmployee();
    printEmployee();
    return 0;
}
</code></pre>

<p>Should work the way you expect it now.</p>
",2
4236914,4236886,4,"<p>Using</p>

<pre><code>int main ()
{
    int addEmployee();
    int printEmployee();
    return 0;
}
</code></pre>

<p>you're basically declaring 2 new functions with 0 arguments.</p>

<p>You're not calling your ""old"" functions.</p>

<p>This should work, as others have pointed out:</p>

<pre><code>int main ()
{
    int emp = addEmployee();
    printEmployee(emp);
    return 0;
}
</code></pre>

<p>Because you're calling <code>addEmployee()</code>, storing it's result to <code>emp</code> and then printing <code>emp</code> using <code>printEmployee</code>. Since <code>printEmployee</code> is declared with one parameter, you just put <code>emp</code> in and it will work.</p>
",0
4252230,4252154,0,"<p>Probably you can add a ""%*c"" in your scanf inside the play_game function also to drain out the newline character which you may be typing after you enter the number.</p>
",1
3995496,3995445,1,"<p>As with <em>all</em> floating point questions, some numbers can not be represented exactly. Get used to that, it's a fact of life :-)</p>

<p>With a 32-bit floating point value (for example), there are about four billion numbers that can be represented exactly. Unfortunately, in mathematics, even between <code>0</code> and <code>0.00000000000000000000001</code>, there are, hmm..., let me think, an <em>infinite</em> number of numbers.</p>

<p>One thing you <em>may</em> find helpful is to use doubles instead of floats - they have more bits in them so can represent more exact numbers. Beyond that, there are arbitrary precision libraries you can use if you want even more precision.</p>

<p>If you change your code to (including a decent <code>main</code>):</p>

<pre><code>int main (void) {
    char buffer[40];
    float x=1.2f,y=.2f;
    double xd=1.2,yd=.2;

    printf(""%f\n"",(x/y));
    printf(""%.30f\n"",(x/y));
    printf( ""%s\n\n"", gcvt( x/y, 30, buffer ) );

    printf(""%f\n"",(xd/yd));
    printf(""%.30f\n"",(xd/yd));
    printf( ""%s\n"", gcvt( xd/yd, 30, buffer ) );
}
</code></pre>

<p>you'll see this in action:</p>

<pre><code>6.000000
6.000000149011610162119723099750
6.00000014901161016211972309975

6.000000
5.999999999999999111821580299875
5.99999999999999911182158029987
</code></pre>

<p>You can see that the doubles are much closer to your desired value, but they're still not exact. IEEE754 doubles have about 16 digits of precision (single precision floats have about 7).</p>
",0
3998467,3995445,0,"<p>As paxdiabolo suggest, have a look into floating point computation to learn about what is going on. But also, my <code>man</code> page on that has an important hint:</p>

<blockquote>
  <p>This function is marked as LEGACY in
  POSIX.1-2001.  POSIX.1-2008 removes
  the specification of  gcvt(), 
  recommending the use of sprintf(3)
  instead (though snprintf(3) may be
  preferable).</p>
</blockquote>

<p>So just don't use it.</p>
",0
6270281,6269992,2,"<p>You wouldn't want to use a switch statement to determine where a value falls in a set of ranges.</p>

<p>If you want to generalize a bit, and avoid multiple if/else statements with hard coded conditions, you could create a map. i.e. you are essentially mapping a set of integers to a set of grades.</p>

<p>Below is a simple example that uses a table lookup to map scores to grades. You could also create a closed mathematical formula that maps scores to grades, and just compute the grade directly from the score, instead of looking it up via a table.  e.g. f(x) = floor(2*(x-50)/20) would map scores from [0,100] into integer grades in the range [0, 5]</p>

<pre><code>typedef struct
{
    int rangeLow;
    char grade;
} RangeToGradeMap;

RangeToGradeMap[] scoreToGradeMapping =
{
    { 90, 'A' }
    { 85, 'B' },
    { 70, 'C' },
    { 60, 'D' },
    { 0,  'F' },
};

char GradeLookup(int score)
{
    size_t N = sizeof(scoreToGradeMapping)/sizeof(RangeToGradeMap);

    for (size_t i = 0; i &lt; N; ++i)
    {
        if (score &gt;= scoreToGradeMapping[i].rangeLow)
        {
            return scoreToGradeMapping[i].grade;
        }
    }

    // If we got here, there was an error - we didn't find the range

    return '?';
}

int main(int argc, char** argv)
{
    char grade = GradeLookup(87);

    return 0;
}
</code></pre>
",2
6270022,6269992,3,"<p>No, the point of <code>switch</code> is to enumerate cases. You can put several different cases to do the same thing (the code will execute until the next <code>break</code>), but you have to enumerate the possibilities (or use <code>default</code> to cover <strong>all</strong> the possibilities other than the enumerated as a single case).</p>

<p>If you need to cover ranges - use <code>if</code>.</p>
",1
6270114,6269992,3,"<p><a href=""http://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/Case-Ranges.html#Case-Ranges"" rel=""nofollow"">Under <code>gcc</code> you can do this</a>:</p>

<pre><code>switch (value)
{
   case 1...3:
      //Do Something
      break;
   case 4...6:
      //Do Something
      break;
   default:
      //Do the Default
      break;
}
</code></pre>

<p>but the code is (obviously) not portable to other C compilers.</p>
",0
8441280,8441257,10,"<p>This is due to integer type-promotion.</p>

<p>Your <code>shorts</code> are being implicitly promoted to <code>int</code>. (which is 32-bits here) So these are sign-extension promotions in this case.</p>

<p>Therefore, your <code>printf()</code> is printing out the hexadecimal digits of the full 32-bit <code>int</code>.</p>

<p>When your <code>short</code> value is negative, the sign-extension will fill the top 16 bits with ones, thus you get <code>ffffcade</code> rather than <code>cade</code>.</p>

<hr>

<p>The reason why this line:</p>

<pre><code>printf(""\n%x"", endian(hex));
</code></pre>

<p>seems to work is because your macro is implicitly getting rid of the upper 16-bits.</p>
",0
8441373,8441257,2,"<p>You have implicitly declared <code>hex</code> as a signed value (to make it unsigned write <code>unsigned short hex</code>) so that any value over <code>0x8FFF</code> is considered to be negative. When printf displays it as a 32-bit <code>int</code> value it is sign-extended with ones, causing the leading <code>Fs</code>. When you print the return value of <code>endian</code> before truncating it by assigning it to <code>hex</code> the full 32 bits are available and printed correctly.</p>
",0
8441401,8441257,18,"<p>The placeholder <code>%x</code> in the format string interprets the corresponding parameter as <code>unsigned int</code>.</p>

<p>To print the parameter as <code>short</code>, add a length modifier <code>h</code> to the placeholder:</p>

<pre><code>printf(""%hx"", hex);
</code></pre>

<p><a href=""http://en.wikipedia.org/wiki/Printf_format_string#Format_placeholders"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Printf_format_string#Format_placeholders</a></p>
",0
4236465,4236261,2,"<p>In this code:</p>

<pre><code>char ** get_wanted_g_matrix(int pocetradek /*number of lines*/) // get wanted g matrix
{
    char ** string;
    printf(""Zadejte hledanou matici:\n"");
    int i = 0;
    if(( * string = (char ** )malloc(100 * sizeof(char *))) == NULL)
</code></pre>

<p>You dereference <code>string</code>, but it is uninitialized, so you're writing to a random location in memory.  Change that <code>* string</code> to just <code>string</code>.  The same applies here:</p>

<pre><code>if((* string = (char **)realloc(* string, 100 * ( i - 1 ) * sizeof(char *))) == NULL)
</code></pre>

<p>..and to the corresponding lines in <code>get_searched_g_matrix()</code> as well.</p>

<p>In this line:</p>

<pre><code>    if((i &gt; 1) &amp;&amp; (*string[i-1] != strlen(*string[i])))
</code></pre>

<p>You're passing a <code>char</code> to <code>strlen()</code>, when you should be passing a <code>char *</code>.  I suspect you mean just <code>strlen(string[i])</code>, but that line seems somewhat nonsensical.  The same problem is in <code>get_searched_g_matrix()</code> as well, as well as the first three calls to <code>strlen()</code> in <code>search()</code>.</p>

<p>Your <code>get_searched_g_matrix()</code> can fall off the end without returning a value - you need to consider what to return if <code>feof(stdin)</code> is not true.</p>

<p>In <code>main()</code>, your call to <code>search()</code> passes <code>char</code> values, but the function expects <code>char **</code>.  You probably mean:</p>

<pre><code>printf(""Matice nalezena %d krat.\n"", search( string1, string2 ));
</code></pre>

<p>(The above won't be sufficient to fix your code - you also appear to have some logic problems.  But it's a necessary start.)</p>

<p>In future, you should compile your code with a higher level of warnings enabled, then fix the problems that the compiler identifies (if you're using gcc, compile with <code>-Wall</code>).</p>
",0
4236372,4236261,1,"<p>Just some comments and style hints: </p>

<p>I'd say it's quite large for what it should do (and hard to follow), try simplifying it a bit. </p>

<p>1) Save vertical space, most people nowadays have wide screens, and it's quite annoing when you can't see the corresponding closing bracket.</p>

<p>1.1) It's very good that you check for error conditions, but try using something like </p>

<pre><code>void err(const char* msg){
    printf(""\n\nFATAL ERROR: %s\n"", msg);
    exit(1);
};
</code></pre>

<p>so that you can do </p>

<pre><code>if (!(x = malloc(sz))) 
    err(""Not enough memory!"");
</code></pre>

<p>1.2) While it's considered safer to use brackets for a signle statement in <code>if</code>, I'd suggest avoiding them when possible, or at least use fewer newlines. Brackets are for compiler, people preffer tabs.</p>

<p>2) There are several <code>while</code> statements in your <code>search</code> function that should be written as <code>for</code>s. </p>

<p>3) Why would you need two distinct functions to read the matrices? One would be enough. </p>

<p>4) As @caf pointed out, you have also errors in input functions. Test each function before going further. It takes years of experience before you can write the whole program at once.</p>
",0
5462757,5462702,0,"<p>there's a function called ctime which takes a unix long as a parameter that renders the time in ascii.</p>
",1
5462772,5462702,0,"<p>Assuming you are talking about 32 bit linux time then you may want to use the <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/gmtime.html"" rel=""nofollow"">gmtime</a> function.</p>

<p>If you want it as a string you can use <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/asctime.html"" rel=""nofollow"">asctime</a> to convert it to a nice readable format.</p>

<p>If its not linux time then give us more details!!</p>
",1
7804910,7804768,4,"<p>You can do this in one pass with something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main (void) {
    char str[] = ""p123h12p97h62p32h"";    // Input string.
    int found[256];                      // Assumes 8-bit char.
    char *src, *dst;                     // Source and destination pointers.

    // Output initial value and set found flags to false.

    printf (""Before: [%s]\n"", str);
    memset (found, 0, sizeof(found));

    // One loop, processing each source character in string.

    for (src = dst = str; *src != '\0'; src++) {
        // If not yet found, flag it found and transfer it, else do nothing.

        if (!found[(unsigned int)(*src)]) {
            found[(unsigned int)(*src)] = 1;
            *dst++ = *src;
        }
    }

    // Insert new end of string, then output it.

    *dst = '\0';
    printf ("" After: [%s]\n"", str);

    return 0;
}
</code></pre>

<p>This removes duplicates in one single pass, using two pointers that advance independently through the string:</p>

<pre><code>src
 |
 v
 p123h12p97h62p32h
 ^
 |
dst
</code></pre>

<p>The <code>src</code> pointer advances by one each iteration of the loop. A character is copied from <code>src</code> to <code>dst</code> and the <code>dst</code> pointer is advanced only if the character has not been seen before (using the <code>found</code> array). The output is:</p>

<pre><code>Before: [p123h12p97h62p32h]
 After: [p123h976]
</code></pre>

<p>Note the <code>""assumes 8-bit char""</code> comment - this is fine where you know the character set is ASCII (or any other 8-bit character set) but it may not be portable to more exotic implementations. You just have to ensure that there are enough elements in the <code>found</code> array for all of your characters. For example, a 10-bit <code>char</code> type would need 1024 elements (<code>2<sup>10</sup> = 1024</code>).</p>
",4
7804924,7804768,1,"<pre><code>void removeDuplicates(char* ptr)
{
    int exists[256] = {0};
    int end;
    int current = 0;
    int length = strlen(ptr);

    for(end = 0; end &lt; length; end++)
    {
        if (exists[ptr[end]]) break;

        exists[ptr[end]] = 1;
        ptr[current++] = ptr[end];
    }

    ptr[current] = '\0';
}

int main(int argc, char** argv)
{
    char str[256] = {0,};
    gets(str);
    removeDuplicates(str);
    printf(""%s\n"", str);
    return 1;
}
</code></pre>
",0
7805141,7804768,1,"<p>This is what I initially thought of doing. Micro-optimization to use up less memory for the ""char seen"" array, otherwise it's the same idea as posted by others.</p>

<pre><code>void removeDuplicates(char* src) {
    // Bitfield to remember which chars we 've seen, assumes 8-bit char type
    char bitfield[32] = { 0 }; // 32 * 8 = 256 bits

    char* dest = src; // initialize ""output"" ptr

    while(*src) {
        // Bitfield manipulation
        char ch = *src;
        int pos = ch &gt;&gt; 3; // ch / 8
        int bit = ch &amp; 0x7; // ch % 8
        char mask = 1 &lt;&lt; bit;

        // If char seen for first time, mark and write to ""output""
        if(!(bitfield[pos] &amp; mask)) {
            bitfield[pos] |= mask;
            *dest++ = ch;
        }
        ++src;
    }

    *dest = 0; // null terminator
}
</code></pre>

<p><strong><a href=""http://ideone.com/xUH2Q"" rel=""nofollow"">See it in action</a></strong>.</p>
",1
3724699,3724661,4,"<p>If your question was ""What does this output?"", why didn't you just type it in and test it?</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {
    int x=5,y=3;
    x = x + ~y + 1;
    printf (""%d\n"", x);
    return 0;
}
</code></pre>

<p>This outputs <code>2</code> <em>on my system.</em> How about yours?</p>

<hr>

<p>If you print out <code>y</code> and <code>~y</code>, you'll get <code>3</code> and <code>-4</code> respectively (on a two's complement architecture).</p>

<p>That's because, with two's complement, you can get the negative of a number by inverting all the bits then adding 1. So <code>~y + 1</code> (the tilde means ""invert all bits"") is effectively <code>-y</code>.</p>

<pre><code>   x + ~y + 1
=  x + (~y + 1)
=  x + (-y)
=  x - y
=  5 - 3
=  2
</code></pre>

<p><em>Aside:</em> I don't think that ISO actually mandates an underlying two's complement architecture for storing numbers so that may not work on <em>all</em> implementations. However, it's been a long time since I saw such a beast. And, to be honest, if you want to get the negative of a number, why wouldn't you just use <code>-y</code>?</p>
",2
4431927,4431882,0,"<p>Look at <code>realloc</code> function from the standard library.</p>
",0
4431928,4431882,0,"<p>Look up malloc?</p>
",0
4431942,4431882,7,"<p>Start with a small array of some size, then whenever you need to increase the size, use <a href=""http://opengroup.org/onlinepubs/007908775/xsh/realloc.html"" rel=""noreferrer""><code>realloc</code></a> to do so; it is common to double the size of the array whenever you resize it.</p>

<p>For example:</p>

<pre><code>int length = 5;
my_struct *array = NULL;

/* Initialization */
array = (my_struct *)malloc(length * sizeof(my_struct));

/* Use array[0] .. array[length - 1] */

/* When you reach the limit, resize the array */
length *= 2;
array = (my_struct *)realloc(array, length * sizeof(my_struct));
</code></pre>
",5
4431948,4431882,1,"<p>Do you mean dynamic size of an array? In that case you must allocate memory fitting for you needs. See <code>realloc</code></p>
",0
4435894,4431882,1,"<p>I have a dynamically growing string buffer implementation. You can get it from <a href=""http://varnam-project.git.sourceforge.net/git/gitweb.cgi?p=varnam-project/libvarnam;a=blob_plain;f=varnam-strbuf.c;hb=HEAD"" rel=""nofollow"">here</a>. It uses the same <code>malloc</code> and <code>realloc</code> technique. </p>
",0
4516530,4516524,0,"<p>Unless I'm crazy, C doesn't have a <code>boolean</code> type. Change the return type of <code>ch</code> to <code>int</code></p>

<p>Also, post your error message.</p>
",8
4516536,4516524,1,"<p>And googling wins again</p>

<p><a href=""http://c-faq.com/~scs/cgi-bin/faqcat.cgi?sec=bool"" rel=""nofollow"">Boolean Expressions and Variables : What is the right type to use for Boolean values in C? Is there a standard type? Should I use #defines or enums for the true and false values? </a></p>
",0
4516542,4516524,0,"<p>C does not have a built-in <code>boolean</code> type. A <code>bool</code> type is available in the <code>stdbool.h</code> header in the standard library in C99.</p>

<p><a href=""http://en.wikipedia.org/wiki/Stdbool.h"" rel=""nofollow"">http://en.wikipedia.org/wiki/Stdbool.h</a></p>
",1
4516546,4516524,1,"<p>Yes, the C99 standard has introduced the <code>_Bool</code> type</p>
<h3>Update</h3>
<p>Apparently <code>&lt;stdbool.h&gt;</code> also includes the prettier <code>bool</code> type in addition to the <code>true</code> and <code>false</code> macros.  Updated code to reflect this.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

bool ch(int);

int main(void)
{
    if(!ch('t'))
        printf(&quot;it's a character\n&quot;);
    return 0;
}

bool ch(int x)
{
    if (x &gt;= 48 &amp;&amp; x &lt;= 57)
        return true;
    else
        return false;
}
</code></pre>
<p>Click <a href=""http://ideone.com/DHQrp"" rel=""nofollow noreferrer""><strong>this link</strong></a> to see the compiled code's output</p>
",7
4516573,4516524,0,"<p>You've got more problems than just the type, however.  <code>if(x&gt;=48&amp;&amp;x&lt;=57)</code> doesn't mean what you think it does, and your printf is going to give you unexpected results too.</p>

<p>You're going to need these characters: ""(())\n"" and a bunch of whitespace.</p>

<p>Sorry to be a little cryptic but this looks like a homework problem.</p>
",0
4518200,4516524,0,"<p>The conditional statement <code>if (boolean_expression) return true; else return false;</code> can always be replaced by <code>return boolean_expression;</code> which I find a lot more readable.</p>

<p>Also, your naming is terrible, what does <code>ch</code> stand for? Since 48 is <code>0</code> and 47 is <code>9</code>, a better name would probably be <code>is_digit</code> or something. (And, as others have noted, C89 does not have a boolean type.)</p>

<pre><code>int is_digit(char c)
{
    return (c &gt;= '0') &amp;&amp; (c &lt;= '9');
}
</code></pre>

<p>The parenthesis are optional, but I think they make the code more readable.</p>

<p>And what do you mean by the output ""It's a character"" in main? Every <code>char</code> is a character, duh :)</p>
",0
2223552,2223541,90,"<p><code>//</code> comments are not allowed in old (pre 99) C versions, use <code>/**/</code> (or remove the <code>-ansi</code>, that is a synonym for the C89 standard)</p>
",2
2223558,2223541,25,"<p>See <a href=""http://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Comments.html"" rel=""noreferrer"">C++ comments</a> in GNU compiler documentation.</p>

<blockquote>
  <p>In GNU C, you may use C++ style comments, which start with <code>//</code> and continue until the end of the line. Many other C implementations allow such comments, and <strong>they are included in the 1999 C standard</strong>. However, C++ style comments are not recognized if you specify an <code>-std</code> option specifying a version of ISO C before <code>C99</code>, or <code>-ansi</code> (equivalent to <code>-std=c89</code>). </p>
</blockquote>

<p>(Emphasis is mine because some of the posts claim that <code>//</code> are not allowed in standard C whereas that is only true for pre-99 standards).</p>
",3
3747162,3747144,6,"<p>Your <code>get_number</code> function always returns 0, because you never assign anything to the <code>value</code> variable. I'm guessing you want:</p>

<pre><code>value = value*10 + (c - '0');
</code></pre>

<p>Instead of</p>

<pre><code>c = value;
</code></pre>

<p>To clarify:</p>

<p>You are reading a number digit by digit (with <code>getchar</code> you read a single character). So let's say you read the digits <code>1 2 3</code>:</p>

<p>When you read <code>1</code>, you do <code>value = value*10 + ('1' - '0')</code> meaning <code>value = 0 + 1 = 1</code>.</p>

<p>When you read <code>2</code>, you do the same and get <code>value = 1*10 + ('2' - '0')</code> meaning <code>value = 12</code>.</p>

<p>Same for <code>3</code>.</p>

<p>What you need to understand is that multiplying something by 10 adds a 0 at the end of that something. Adding a digit to something that ends with a zero replaces that 0 by that digit.</p>

<p>You must also understand that you are dealing with characters, which are actually integers. The character <code>'0'</code> is represented by an ASCII code of let's say <code>x</code>. <code>'1'</code> is represented by <code>x + 1</code> etc. If you were to print the value of <code>'0'+'3'</code> it would not be <code>3</code> as you'd expect. This is why we subtract <code>'0'</code> (which is <code>x</code>) from the characters, to get the actual digits.</p>

<p>Hope that clears some things up.</p>
",5
3747179,3747144,1,"<ol>
<li><p>Given the character corresponding to a digit, you need to get the digit itself. For example, you want to get the number 0, not the number 48 (the ASCII code for the character '0'). There's a trick for this if your characters are ASCII, which involves the fact that the digits start sequentially at '0', and the fact that you can 'subtract' characters from each other.</p></li>
<li><p>You need to build up the number using digits you've already entered. It would help if you had an operation that can move a digit to the 10s column, from the 10s column to the 100s column, and so on. Can you think of what that operation is?</p></li>
</ol>
",0
4243382,4243352,2,"<p>In your <code>print_repeat</code> code, you never increment <code>i</code> in your <code>while</code> loop, which would result in infinite loops.</p>
",0
4243424,4243352,3,"<p>Find the correct code below:</p>

<pre><code>    while (s[i] != '\0')
    { 
      for (j = 1; j &lt;= i+1; j++)
      { 
        putchar(s[i]); 
      } 
     i++;
   } 
</code></pre>

<p>The main problems were:
1. Not incrementing the variable i inside while loop
2. Variable j is not incremented correctly
3. There is semicolon right after the while which is incorrect.</p>

<p>Suggestion: try debugging your code. That will help you learn faster. </p>
",3
4243449,4243352,0,"<p>add ""i++;"" on the end of the while loop.</p>
",0
8425997,8425964,-1,"<p>Split the hex ip into octets (two hex digits at a time), and convert each octet to a decimal integer. </p>
",1
8426090,8425964,4,"<p>This is one possibility:</p>

<pre><code>#include &lt;stdio.h&gt;

int ip_hex_to_dquad(const char *input, char *output, size_t outlen)
{
    unsigned int a, b, c, d;

    if (sscanf(input, ""%2x%2x%2x%2x"", &amp;a, &amp;b, &amp;c, &amp;d) != 4)
        return -1;

    snprintf(output, outlen, ""%u.%u.%u.%u"", a, b, c, d);
    return 0;
}
</code></pre>
",3
8426097,8425964,3,"<p>You could use sscanf to pick the hexadecimal out of the original string as integers and then use sprintf to put them into another string in the proper format.</p>

<pre><code>sscanf(hexipstring, ""%2x%2x%2x%2x"", &amp;uint0, &amp;uint1, &amp;uint2, &amp;uint3);
sprintf(""%u.%u.%u.%u"", uint0, uint1, uint2, uint3);
</code></pre>

<p>Or something like that.  i'm never really sure with scanf, so read through some man pages.  The ""%2x"" should tell scanf to use 2 characters at most and interpret them as a hexadecimal number.</p>

<p>-edit: Caf's code is better since it checks for errors in sscanf and uses snprintf rather than sprintf.  More errorproof.  Use it instead of mine.</p>
",0
4437529,4437489,14,"<p>You don't <em>have</em> to include the header file. Its purpose is to let the compiler know all the information about <code>stdio</code>, but it's by no means necessary if your compiler is smart (or lazy).</p>

<p>You <em>should</em> include it because it's a good habit to get into - if you don't, then the compiler has no real way to know if you're breaking the rules, such as with:</p>

<pre><code>int main (void) {
    puts (7);       // should be a string.
    return 0;
}
</code></pre>

<p>which compiles without issue but rightly dumps core when running. Changing it to:</p>

<pre><code>#include &lt;stdio.h&gt;
int main (void) {
    puts (7);
    return 0;
}
</code></pre>

<p>will result in the compiler warning you with something like:</p>

<pre><code>qq.c:3: warning: passing argument 1 of ¡®puts¡¯ makes pointer
                 from integer without a cast
</code></pre>

<p>A decent compiler may warn you about this, such as <code>gcc</code> knowing about what <code>printf</code> is supposed to look like, even <em>without</em> the header:</p>

<pre><code>qq.c:7: warning: incompatible implicit declaration of
                 built-in function ¡®printf¡¯
</code></pre>
",0
4437820,4437489,9,"<p>How is this possible? In short: three pieces of luck.</p>

<p>This is possible because some compilers will make assumptions about undeclared functions. Specifically, parameters are assumed to be <code>int</code>, and the return type also <code>int</code>.  Since an <code>int</code> is often the same size as a <code>char*</code> (depending on the architecture), you can get away with passing <code>int</code>s and strings, as the correct size parameter will get pushed onto the stack.</p>

<p>In your example, since <code>printf</code> was not declared, it was assumed to take two <code>int</code> parameters, and you passed a <code>char*</code> and an <code>int</code> which is ""compatible"" in terms of the invocation.  So the compiler shrugged and generated some code that should have been about right.  (It really should have warned you about an undeclared function.)</p>

<p>So the first piece of luck was that the compiler's assumption was compatible with the real function.</p>

<p>Then at the linker stage, because <code>printf</code> is part of the C Standard Library, the compiler/linker will automatically include this in the link stage.  Since the <code>printf</code> symbol was indeed in the C stdlib, the linker resolved the symbol and all was well.  The linking was the second piece of luck, as a function anywhere other than the standard library will need its library linked in also.</p>

<p>Finally, at runtime we see your third piece of luck.  The compiler made a blind assumption, the symbol happened to be linked in by default.  But - at runtime you could have easily passed data in such a way as to crash your app.  Fortunately the parameters matched up, and the right thing ended up occurring.  This will certainly not always be the case, and I daresay the above would have probably failed on a 64-bit system.</p>

<p>So - to answer the original question, it really is essential to include header files, because if it works, it is only through blind luck!</p>
",0
4437889,4437489,0,"<p>As paxidiablo said its not necessary but this is only true for functions and variables but if your header file provides some types or macros (#define) that you use then you must include the header file to use them because they are needed before linking happens i.e during pre-processing or compiling</p>
",0
4438322,4437489,0,"<p>This is possible because when C compiler sees an undeclared function call (printf() in your case) it assumes that it has </p>

<pre>
<code>
int printf(...)
</pre>

<p></code> </p>

<p>signature and tries to call it casting all the arguments to int type. Since ""int"" and ""void *"" types often have same size it works most of the time. But it is not wise to rely on such behavior.</p>
",2
4438968,4437489,0,"<p>C supprots three types of function argument forms:</p>

<ol>
<li>Known fixed arguments: this is when you declare function with arguments: <code>foo(int x, double y)</code>.</li>
<li>Unknown fixed arguments: this is when you declare it with empty parentheses: <code>foo()</code> (not be confused with <code>foo(void)</code>: it is the first form <em>without</em> arguments), or <em>not declare</em> it at all.</li>
<li>Variable arguments: this is when you declare it with ellipsis: <code>foo(int x, ...)</code>.</li>
</ol>

<p>When you see standard function working then function definition (which is in form 1 or 3) is compatible with form 2 (using same calling convention). Many old std. library functions are so (as desugned to be), because they are there form early versions of C, where was no function declarations and they all was in form 2. Other function may be unintentionally be compatible with form 2, if they have arguments as declared in argument promotion rules for this form. But some may not be so.</p>

<p>But form 2 need programmer to pass arguments of same types everywhere, because compiler not able to check arguments with prototype and have to determine calling convention osing actual passed arguments.</p>

<p>For example, on MC68000 machine first two integer arguments for fixed arg functions (for both forms 1 and 2) will be passed in registers <code>D0</code> and <code>D1</code>, first two pointers in <code>A0</code> and <code>A1</code>, all others passed through stack. So, for example function <code>fwrite(const void * ptr, size_t size, size_t count, FILE * stream);</code> will get arguments as: <code>ptr</code> in <code>A0</code>, <code>size</code> in <code>D0</code>, <code>count</code> in <code>D1</code> and <code>stream</code> in <code>A1</code> (and return a result in <code>D0</code>). When you included <code>stdio.h</code> it will be so whatever you pass to it.</p>

<p>When you do not include <code>stdio.h</code> another thing happens. As you call fwrite with <code>fwrite(data, sizeof(*data), 5, myfile)</code> compiler looks on argruments and see that function is called as <code>fwrite(*, int, int, *)</code>. So what it do? It pass first pointer in <code>A0</code>, first int in <code>D0</code>, second int in <code>D1</code> and second pointer in <code>A1</code>, so it what we need.</p>

<p>But when you try to call it as <code>fwrite(data, sizeof(*data), 5.0, myfile)</code>, with <code>count</code> is of double type, compiler will try to pass <code>count</code> through stack, as it is not integer. But function require is in <code>D1</code>. Shit happens: <code>D1</code> contain some garbage and not <code>count</code>, so further behaviour is unpredictable. But than you use prototype defined in <code>stdio.h</code> all will be ok: compiler automatically convert this argument to int and pass it as needed. It is not abstract example as double in arument may be just result of computation involving floating point numbers and you may just miss this assuming result is int.</p>

<p>Another example is variable argument function (form 3) like <code>printf(char *fmt, ...)</code>. For it calling convention require last named argument (<code>fmt</code> here) to be passed through stack regardess of its type. So, then you call <code>printf(""%d"", 10)</code> it will put pointer to <code>""%d""</code> and number <code>10</code> on stack and call function as need.</p>

<p>But when you do not include <code>stdio.h</code> comiler will not know that <code>printf</code> is vararg function and will suppose that <code>printf(""%d"", 10)</code> is calling to function with <em>fixed</em> arguments of type pointer and int. So MC68000 will place pointer to <code>A0</code> and int to <code>D0</code> instead of stack and result is again unpredictable.</p>

<p>There may be luck that arguments was previously on stack and occasionally read there and you get correct result... this time... but another time is will fail. Another luck is that compiler takes care if not declared function may be vararg (and somehow makes call compatible with both forms). Or all arguments in all forms are just passed through stack on your machine, so fixed, unknown and vararg forms are just called identically.</p>

<p>So: do not do this even you feel lucky and it works. Unknown fixed argument form is there just for compatibility with old code and is strictly discouraged to use.</p>

<p>Also note: <code>C++</code> will not allow this at all, as it <em>require</em> function to be declared with known arguments.</p>
",0
4157038,4157010,5,"<p>Yep, explicitly passing a required parameter to a function is always better than passing it via a global variable. </p>

<p>In an embedded environment, you might have to consider that calling a function with a parameter might require the parameter to be pushed onto the stack and popped otherwise (unless the compiler optimizes and passes it in a register). But I wouldn't optimize based on this unless I have established (through measuring) that the speed gain is actually worth polluting the code.<br>
(And since your example is switching over input, which is usually coming at glacial speed compared to stack operations, this shouldn't be a problem here anyway.) </p>

<p>However, as Lars said in a comment, it would probably be better if those literal addresses were replaced by symbolic constants: </p>

<pre><code>volatile char* const A_base_address = (char *) 0xa0001000;
volatile char* const S_base_address = (char *) 0xa0001000;

switch (input) {
case 'S': 
    InitDevice(S_base_address);
    break;
case 'A': 
    InitDevice(A_base_address);
    break;
</code></pre>
",8
7775765,7775737,5,"<p>Did you <code>#include</code> a header file that properly defines <code>strsep()</code>? If not, then the traditional thing to do is assume that the function returns <code>int</code>, which is what's probably causing your issue.</p>
",2
7775770,7775737,5,"<p>I'd guess that your headers aren't declaring <code>strsep</code> at all since it is non-standard, that would lead the compiler to assume that it returns <code>int</code> and there's your error. Try adding <code>-D_BSD_SOURCE</code> to your compiler options (or isolate that to only apply to <code>string.h</code>. If that doesn't work, grep through the system headers (or the man pages) to figure out if there is a prototype for <code>strsep</code> anywhere and what sort of macro dance you need to get at it. As a last resort (assuming you have it in your libc) you can prototype it yourself.</p>

<p>Also, I think you can replace <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/strsep.3.html"" rel=""nofollow""><code>strsep</code></a> with the standard <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html"" rel=""nofollow""><code>strtok</code></a> with some modifications to the surrounding code. They serve the same purpose but do it with slightly different interfaces.</p>
",3
4171533,4171284,1,"<p>On Windows you can call the <a href=""http://msdn.microsoft.com/en-us/library/ms680650%28VS.85%29.aspx"" rel=""nofollow""><code>StackWalk64</code></a> function that is exported by <code>DBGHELP.DLL</code>. It is shipped with Debugging Tools for Windows (WinDbg) but according to <a href=""http://msdn.microsoft.com/en-us/library/ms679294%28VS.85%29.aspx"" rel=""nofollow"">this link</a>, ""The redistribution policies for these included DLLs were specifically designed to make it as easy as possible for people to include these files in their own packages and releases.""</p>
",0
4331986,4331970,0,"<p>Use <code>strrchr()</code> to find the last occurrence of '/' from the rear.  You will then have a pointer to the start of 'the end of the web address' if you add one to that returned pointer.</p>

<h3>Update</h3>

<p>Assuming your URL does not start with <code>http://</code>, this aught to work</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char url[] = ""www.bbc.co.uk/news/world-us-canada-11893886"";
    int  cnt;
    char host[100];
    char path[100];
    char request[100];

    strcpy(request, strrchr(url, '/'));

    strcpy(host, url);
    host[cnt = strcspn(url, ""/"")] = '\0';

    strcpy(path, &amp;url[cnt]);

    printf(""host: %s\npath: %s\nrequest: %s\n"", host, path, request);

    return 0;
}
</code></pre>

<h3>Output</h3>

<pre><code>$ ./a.out
host: www.bbc.co.uk
path: /news/world-us-canada-11893886
request: /world-us-canada-11893886
</code></pre>
",8
4333969,4331970,0,"<p>strrchr() returns the LAST instance of the character. He wants the FIRST instance after any http:// string.</p>

<p>The answer is simple:</p>

<p>char *address_start = strchr(in_string+8, '/');</p>

<p>If it's non NULl then there you are at the first / of the path.</p>

<p>Why +8? Because ""https://"" is 8 characters long and even if there is no ""http://"" at the beginning, no IP or web address is less than 8 characters. Even ""a.b.c.d"" is 7 characters long and I don't believe an IPv4 dotted numerical notation has any legal public address with all single digits. I might be wrong though. Might be worth validating the string to check it's long enough first.</p>

<p>Anyway, you can always pre-validate the string to see if it begins with ""http"" or not to determine the offset to start searching at.</p>
",11
4334077,4331970,1,"<p>Here's some code that does more than you want. Note that this modifies the original string - you may want to make copies instead:</p>

<pre><code>void split_request(char *request, char **protocol, char **addr, char **path)
{
  char *ptr = strstr(request, ""://"");

  if(NULL == ptr)
  {
    *protocol = NULL;
    *addr = request;
  }
  else
  {
    *protocol = request;
    *addr = ptr + 3;
    *ptr = '\0';
  }

  ptr = strchr(*addr, '/');
  if(NULL == ptr)
  {
    *path = NULL;
  }
  else
  {
    *path = ptr + 1;
    *ptr = '\0';
  }
}
</code></pre>

<p>Please excuse any typos/obvious errors. I'm typing this in a hurry as I have work to do :P
 It should get you started though.</p>
",4
4335942,4331970,0,"<blockquote>
<pre><code> I have modified your code to work the way you are expecting
</code></pre>
</blockquote>

<pre><code> main(int argc, char *argv[])
    {
    char *request,*host,*req;
     char *tok, *tempString;
    printf(""argv[1]: %s\n"", argv[1] );

    host = malloc(strlen(argv[1]));
     strcpy(host, argv[1]);
     host = strtok(host, ""/"");


     tempString = malloc(strlen(argv[1]));

     tok = strtok( NULL, ""\0"");
     printf(""sizeof(tok) %d\n"",strlen(tok));
      strncpy(tempString, tok,strlen(tok));

     while( tok ) {
      tok = strtok(NULL, ""\0"");
      if (tok != NULL) {
      strncat(tempString, tok,strlen(tok));
      }else {
       break;
      }
     }
     request = tempString;
     printf(""host: %s\n"", host);
     printf(""Path: %s\n"", request);
    }
    ~
</code></pre>

<blockquote>
  <p><strong>Output</strong></p>
</blockquote>

<pre><code>./tmp www.bbc.co.uk/news/world-us-canada-11893886/tmp.htmlargv[1]: www.bbc.co.uk/news/world-us-canada-11893886/tmp.html
sizeof(tok) 38
host: www.bbc.co.uk
Path: news/world-us-canada-11893886/tmp.html
bash-2.03$ 
</code></pre>

<p>~</p>
",1
5487271,5486886,2,"<p>You are searching in 5-char groups for the string ""Hello"". So you are looking at your file like this:</p>

<pre><code>hi He
llo t
his i
s my 
Hello
 to\n 
the H
ello 
world
</code></pre>

<p>Only one of those matches what you are looking for. You should probably read the file line-by-line (using a larger buffer, just in case), and search/replace on each line for your search text.</p>

<p>Additionally, you are exiting 0 on failure and 1 on success (which is backwards; 0 means success, anything else means failure, traditionally). And you are exiting after the first match, rather than continuing onward looking for more.</p>

<p>To read line by line and perform search/replace, do something like this:</p>

<pre><code>FILE *f = ...;
char buf[1024];
while (fgets(buf, sizeof(buf), f)) {
    char *pos;
    while ((pos = strstr(buf, search)) != NULL) {
        char temp = *pos;
        *pos = 0;
        fprintf(out, ""%s%s"", buf, replace);
        *pos = temp;
        buf = pos + strlen(search);
    }
    fprintf(out, ""%s"", buf);
}
</code></pre>

<p>This isn't ideal, as a long line (&gt; 1023 chars) will get cut into pieces, possibly in the middle of a search token, but it will work in most cases.</p>
",1
5489155,5486886,0,"<p>you have read line by line into a temporary character array, and use strstr to find the hello, then things will be faster.. 
check for strstr function.</p>
",0
5505324,5486886,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define BUF_LEN 100
#define STR_REQ ""Hello""
main()
{
    FILE * read_file, * write_file;
    read_file = fopen(""file_read.dat"", ""r"");
    if(read_file == NULL)
    {
        perror(""Unable to open file for reading"");
        exit(-1);
    }
    else
    {
        write_file = fopen(""file_write.dat"", ""w"");
        if(write_file == NULL)
        {
            perror(""Unable to open file for writing"");
            exit(-1);
        }
        else
        {
            char temp_buf[BUF_LEN], req_buf[BUF_LEN+strlen(STR_REQ)+10];
            char * index;
            while(!feof(read_file))
            {
                memset(temp_buf, 0, BUF_LEN);
                fscanf(read_file, ""%[^\n]"", temp_buf);
                fgetc(read_file);           /*To remove \n at last*/
                index = strstr(temp_buf, STR_REQ);
                if( index !=NULL )
                {

                    memset(req_buf, 0, BUF_LEN+strlen(STR_REQ)+10);
                    //strncpy(req_buf, temp_buf, index-temp_buf);
                    memcpy(req_buf, temp_buf, index - temp_buf);                /*This will copy upto the match*/

                    strcat(req_buf, ""Help "");                                           /*Copy the help word*/

                    strcat(req_buf, index+strlen(STR_REQ));

                }
                else
                {
                    strcpy(req_buf, temp_buf);
                }
                fprintf(write_file, ""%s\n"", req_buf);
            }

        }
    }
}
</code></pre>

<p>Have this code.. it should work... If you have any question you can ask me</p>
",0
7781492,7781487,1,"<p>Looks like you are dividing by zero in the following line</p>

<blockquote>
  <p>average =  sum/counter ;  </p>
</blockquote>

<p>counter is initially, definied as zero;</p>

<blockquote>
  <p>int counter = 0;  </p>
</blockquote>

<p>and updated here;</p>

<blockquote>
  <p>counter += counter;  // counter remains zero....</p>
</blockquote>

<p>did you mean to update counter by one instead? e.g.</p>

<blockquote>
  <p>counter += 1;</p>
</blockquote>
",0
7781493,7781487,6,"<p>Despite the name, a ""floating point exception"" actually happens when you <code>/</code> or <code>%</code> an integer by <code>0</code>. My guess is that it happens here:</p>

<pre><code>average =  sum/counter ;
</code></pre>

<p>because <code>counter</code> is still <code>0</code>. I think you meant</p>

<pre><code>counter += counter;
</code></pre>

<p>to be</p>

<pre><code>counter += 1;
</code></pre>

<p>Also, you might want to change the division to</p>

<pre><code>average =  (float)sum/counter ;
</code></pre>

<p>so it can happen as a fraction value rather than an integer.</p>
",0
4181756,4181698,2,"<p>If <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"" rel=""nofollow""><code>fopen</code></a> <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html#tag_03_176_04"" rel=""nofollow"">returns <code>NULL</code></a>, the open failed. <code>errno</code> will hold the <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html#tag_03_176_05"" rel=""nofollow"">failure code</a> and <a href=""http://www.opengroup.org/onlinepubs/9699919799/functions/strerror.html"" rel=""nofollow""><code>strerror(errno)</code></a> will return a short description of why the open failed.</p>

<pre><code>#include &lt;errno.h&gt;
#include &lt;string.h&gt;

...

int main(void)
{    FILE* inFile = NULL;
     char infileName[32] = {'\0'};
     gather_input(infileName); // infileName is an output parameter for this
     if (!(inFile = open_input_file(infileName))) {
         fprintf(stderr, ""Error opening '%s': %s\n"", 
                 infileName, strerror(errno));
     } else {
         // open successful
         ...
     }
}
</code></pre>

<h1>Off-topic</h1>

<p><code>gather_input</code> better make sure <code>infileName</code> is null-terminated to prevent buffer overflows. The simplest way to do this is to define the size of the file name buffer as a macro and set the last character to 0.</p>

<pre><code>#define FILENAMELEN 32
void gather_input(char infileName[]) {
    ...
    infileName[FILENAMELEN-1]=0;
}

 int main(void)
{    FILE* inFile = NULL;
     char infileName[FILENAMELEN] = {'\0'};
</code></pre>

<p>This isn't very flexible. You could instead pass the size of the file name buffer into <code>gather_input</code>. </p>

<pre><code>#define LENGTH(a) (sizeof(a) / sizeof(a[0]))
void gather_input(char infileName[], size_t len) {
    ...
    infileName[len-1]=0;
}

 int main(void)
{    FILE* inFile = NULL;
     char infileName[32] = {'\0'};
     gather_input(infileName, LENGTH(infileName)); // infileName is an output parameter for this
</code></pre>

<p>An alternative to setting the last character, if using standard string manipulation functions, is to use the <code>strl*</code> functions (<a href=""http://www.gratisoft.us/todd/papers/strlcpy.html"" rel=""nofollow""><code>strlcpy</code> and <code>strlcat</code></a>) rather than their unbounded cousins. If you aren't using <code>strl*</code>, you should be using <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/strncpy.html"" rel=""nofollow""><code>strncpy</code></a> and <a href=""http://www.opengroup.org/onlinepubs/009695399/functions/strncat.html"" rel=""nofollow""><code>strncat</code></a>.</p>
",14
4181738,4181698,2,"<ol>
<li><p>Have you checked that the file pointed to by inFilename exists on your HDD ?</p></li>
<li><p>Check the value of infileName in your debugger or put a printf statement to show the value on screen.  printf(""'%s'\n"", infileName);</p></li>
<li><p>Did you call fclose() on your file inside the open_input_file() call.  Maybe the file is still locked ?</p></li>
</ol>

<p>Edit:  I just checked the code.  I have modified your english_to_morse() function.  1. The <strong>while</strong> statement is easier to follow than the <strong>for</strong>.  2. fgetc() returns an int and not a char.</p>

<p>At the top of the initialise I added this.  This initialises every string in the array with and undefined string of "".??."".  This will make it easier to find strange bugs as everything in your array is at least initialised. </p>

<p>I have modified different sections of the code but you should be able to follow.</p>

<pre><code>    initialize_morse_alphanum (char morseStrings[91][6])
    {   
        for (int i=0;i&lt;91;i++)
            strcpy(morseStrings[i], "".??."");

        ....
        ....



    void 
    english_to_morse(FILE* inputFile, FILE* outputFile, char morseStrings[91][6])
    {   int convert;

        convert = fgetc(inputFile);
        while (convert != EOF)
        {   
            fputs(morseStrings[convert], outputFile);
            fputc(' ', outputFile);
            printf (""%s "", morseStrings[convert]);
            convert = fgetc(inputFile);
        }
    }


open_output_file (char* fileName)  //opens destination file to be written
{   FILE* handle = NULL;
    handle = fopen (fileName, ""w"");    &lt;---- Remove the * from filename
    return handle; }
</code></pre>

<p>Also, as mentioned in a different answer, it would be good to add some bounds checks to different areas of the code.  At the moment it is quite prone to crashing.  If my input file contains a lowercase 'a' (ascii 96) your program will be accessing memory that is out of bounds.  So you should add a line like if (convert >= '0' &amp;&amp; convert &lt;= 'Z') in there somewhere.  I will let you work that out.</p>
",6
4181749,4181698,0,"<p>Make sure that <code>gather_input</code> works properly. Could it be a problem because you're trying to read a file you're also writing on? In this case, try to close and open again the stream. </p>
",1
3831761,3829167,7,"<p>First of all, take a step back and ask why you need to return multiple values.  If those values aren't somehow related to each other (either functionally or operationally), then you need to stop and rethink what you're doing.  </p>

<p>If the various data items are part of a larger, composite data type (such as a mailing address, or a line item in a sales order, or some other type described by multiple attributes), then define a struct type to represent a <em>single value</em> of that composite type:</p>

<pre><code>struct addr { // struct type to represent mailing address
  char *name;
  int streetNumber;
  char *streetName;
  char *unitNumber; 
  char *city;
  char state[3];
  int ZIP;
};

struct addr getAddressFor(char *name) {...}

struct point2D {
  int x;
  int y;
};

struct polygon2D {
  size_t numPoints;
  struct point2D *points;
};

struct point2D getOrigin(struct polygon2D poly) {...}
</code></pre>

<p>Do <strong>not</strong> define a struct to collect random items that aren't somehow related to each other; that's just going to cause confusion for you and anyone who has to maintain your code down the road.  </p>

<p>If the data items are not functionally related, but are somehow <em>operationally</em> related (e.g. data plus a status flag plus metadata about the operation or items as part of a single input operation), then use multiple writable parameters.  The most obvious examples are the <code>*scanf()</code> functions in the standard library.  There are also the <code>strtod()</code> and <code>strtol()</code> functions, which convert a string representation of a number; they return the converted value, but they also write the first character that was not converted to a separate parameter:</p>

<pre><code>char *str = ""3.14159"";
double value;
char *chk;

value = strtod(str, &amp;chk);
if (!isspace(*chk) &amp;&amp; *chk != 0)
  printf(""Non-numeric character found in %s\n"", str);
</code></pre>

<p>You can combine these approaches; here's an example inspired by some work I'm currently doing:</p>

<pre><code>typedef enum {SUCCESS, REQ_GARBLED, NO_DATA_OF_TYPE, EMPTY, ERROR} Status;

typedef struct bounds {...} Bounds; 

tyepdef struct metadata {
  size_t bytesRead;
  size_t elementsRead;
  size_t rows;
  size_t cols;
} Metadata;

typedef struct elevations {
  size_t numValues;
  short *elevations;
} Elevations;

Elevations elevs;
Metadata meta;
Bounds b = ...; // set up search boundary

Status stat = getElevationsFor(b, &amp;elevs, &amp;meta);
</code></pre>

<p>The service that I request elevation data from returns a 1-d sequence of values; the dimensions of the array are returned as part of the metadata.  </p>
",0
4594453,4594433,0,"<p>No because your <code>return 0;</code> is inside the for loops.</p>
",0
4594455,4594433,3,"<p>No, it's not. You need to move the <code>return 0;</code> out of the two <code>for</code> loops, and have it be the last statement in <code>search</code>.</p>
",4
4594466,4594433,1,"<p>No. The <code>return 0;</code> statement should be placed on the line before the very last closing brace.</p>
",0
4594554,4594433,0,"<p>I think what you want is that :</p>

<pre><code>#include &lt;stdio.h&gt;

int search(int a[3][3],int x);

int main () 
{ 
    int Array[3][3]; // array of size 3*3 
    int i,j; //counters i,j 
    int result,number;

    for(i=0;i&lt;3;i++)
    {     printf(""\n"");
        for(j=0;j&lt;3;j++)
        {     
            printf("" Array[%d][%d]= "",i,j);
            scanf(""%d"", &amp;Array[i][j]);              //Fill The 3*3 array
        }
    }

    printf(""Enter The number you want:&gt;"");
    scanf(""%d"",&amp;number);

    result=search(Array,number);

    if(result)
        printf(""Number exists\n"");
    else
        printf(""Number does not exists\n"");

    return 0;
}

int search(int a[3][3],int x)
{
    int i,j; 
    for(i=0;i&lt;3;i++)
    {
        for(j=0;j&lt;3;j++)
        {
            if (x==a[i][j])
                return 1;
        }
    }
    return 0;
}
</code></pre>
",0
4595185,4594433,1,"<p>Your program is not running because the search algorithm returns 1 if and only if the search element is in array[0][0], otherwise it returns zero and you think that the element doesn't exists. All you need to do is return 0 after traversing the full multi-dimensional array.</p>

<p>You can look into above answers. They have given good solutions.</p>
",0
4596186,4594433,0,"<p>Jon gave you the answer you need, but there are some details to be aware of.</p>

<p>C's treatment of arrays is such that the <code>search</code> function doesn't receive a 3x3 array of <code>int</code>; rather, it receives a <em>pointer</em> to a 3-element array of <code>int</code>.  From the C language standard, draft <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">n1256</a>:</p>

<blockquote>
<b>6.3.2.1 Lvalues, arrays, and function designators</b><br>
...<br>
3 Except when it is the operand of the <code>sizeof</code> operator or the unary <code>&</code> operator, or is a string literal used to initialize an array, an expression that has type ¡®¡®array of type¡¯¡¯ is converted to an expression with type ¡®¡®pointer to type¡¯¡¯ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined. 
</blockquote>

<p>Thus, when you call <code>result = search(Array, number);</code>, the type of the expression <code>Array</code> is implicitly converted from a 3-element array of 3-element arrays of <code>int</code> (<code>int [3][3]</code>) to a pointer to a 3-element array of <code>int</code> (<code>int (*)[3]</code>).  In the context of a function parameter declaration, <code>T a[]</code> and <code>T a[n]</code> are synonymous with <code>T *a</code>.  You could change the function prototype to</p>

<pre><code>int search(int (*a)[3], int x)
</code></pre>

<p>and it would behave exactly the same.  </p>

<p>One consequence of this is that <code>search</code> can operate not just on 3x3 arrays, but on any Nx3 array.  You've written your function to assume that <code>a</code> is always 3x3; if you want to be able to handle arrays of different numbers of rows, you would need to pass in a separate parameter to specify the number of rows in the array:</p>

<pre><code>int search(int (*a)[3], size_t rows, int x)
{
  size_t i, j;
  for (i = 0; i &lt; rows; i++)
    for (j = 0; j &lt; 3; j++)
      if (a[i][j] == x)
        return 1;
  return 0;
}

int main(void)
{
  int fiveRowArray[5][3] = {{ 1, 2, 3}, { 4, 5, 6}, { 7, 8, 9},
                            {10,11,12}, {13,14,15}};
  int twoRowArray[2][3]  = {{ 1, 2, 3}, { 4, 5, 6}};
  int number;

  printf(""Gimme a number: "");
  fflush(stdout);
  scanf(""%d"", &amp;number);

  if (search(array, sizeof fiveRowArray / sizeof *fiveRowArray, number))
    printf(""Number exists in fiveRowArray\n"");
  else 
    printf(""Number does not exist in fiveRowArray\n"");

  if (search(array, sizeof twoRowArray / sizeof *twoRowArray , number))
    printf(""Number exists in twoRowArray \n"");
  else 
    printf(""Number does not exist in twoRowArray \n"");

  return 0;
}
</code></pre>

<p>The <code>sizeof arr / sizeof *arr</code> expression calculates the number of elements in the array by getting the total array size in bytes (<code>sizeof arr</code>) and dividing that by the number of bytes in an individual array element (<code>sizeof *arr</code> or <code>sizeof arr[0]</code>).  Note that this only works for expressions of array type; it will not work for pointers that are being treated as arrays (such as the expression <code>a</code> in the <code>search</code> function).  </p>

<p>If you want to handle different numbers of rows <em>and</em> columns, you'll have to take a different approach:</p>

<pre><code>int search(int *a, size_t rows, size_t cols, int x)
{
  size_t i, j;
  for (i = 0; i &lt; rows; i++)
    for (j = 0; j &lt; cols; j++)
      if (a[i * cols + j] == x)
        return 1;
  return 0;
}

int main(void)
{
  int fiveByThree[5][3] = {...};
  int twoByFour[2][4] = {...};
  ...
  if (search(&amp;fiveByThree[0][0], 
             sizeof fiveByThree / sizeof *fiveByThree,
             sizeof fiveByThree[0] / sizeof *fiveByThree[0],
             number))
  ...
  if (search(&amp;twoByFour[0][0],
             sizeof twoByFour / sizeof *twoByFour,
             sizeof twoByFour[0] / sizeof *twoByFour[0],
             number))
  ...
}
</code></pre>

<p>In this case, we explicitly pass a pointer to the first element in each array, so instead of receiving a pointer to an array of <code>int</code>, <code>search</code> receives a simple pointer to <code>int</code>, which we treat as a 1D array, and compute the offset manually as <code>i * cols + j</code>.  This code assumes that all elements in the 2D array are contiguous.  </p>

<p><strong>Edit</strong></p>

<p>Note that in C99, you can have what are called Variable Length Arrays (VLAs), where the array dimension can be specified by a runtime variable rather than a constant expression; this allows us to write the prototype as</p>

<pre><code>int search(size_t rows, size_t cols, int arr[rows][cols], int x)
</code></pre>

<p>and not mess with pointers.  </p>
",0
3854375,3854337,1,"<p><code>a</code> points to an array of <code>int</code> pointers. So each element of that array is of type <code>int*</code> not <code>int</code>. So you should be using <code>sizeof(int*)</code>.</p>

<p>this</p>

<pre><code>a = (int*)malloc(sizeof(int)*5);
</code></pre>

<p>should be</p>

<pre><code>a = malloc(sizeof(int*)*5);
                   ^
</code></pre>

<p>As <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/malloc/"" rel=""nofollow noreferrer"">malloc</a> in C returns a <code>void</code> pointer and C implicitly casts from and to <code>void*</code> there is no need of a cast.</p>

<p>You might want to read this:</p>

<p><a href=""https://stackoverflow.com/questions/953112/should-i-explicitly-cast-mallocs-return-value""><strong>Should I explicitly cast malloc()'s return value?</strong></a></p>
",1
3854393,3854337,1,"<pre><code>   a = (int*)malloc(sizeof(int)*5);
     ^
     |
Warning due to this
</code></pre>

<p><code>a</code> is a pointer to pointer to <code>int</code> i.e <code>int **</code>.</p>

<p>You are casting <code>malloc()</code>'s return value to <code>int*</code> and then assigning it to <code>int**</code> so the implicit conversion from <code>int*</code> to <code>int**</code> generates the warning. Moreover it should be <code>sizeof(int *)</code> inside first <code>malloc()</code> [as you are trying to allocate memory for a two dimensional array].</p>

<p>Try this :</p>

<pre><code>a=(int**)malloc(sizeof(int*)*5);
</code></pre>
",1
3854394,3854337,0,"<p>On line 6 you should have </p>

<pre><code>a = (int**) malloc(sizeof(int*) * 5)); 
</code></pre>
",0
3854423,3854337,5,"<p>Firstly, the memory allocation in your code is incorrect. The first <code>malloc</code> should look as follows</p>

<pre><code>a = (int **) malloc(sizeof(int *) * 5);
</code></pre>

<p>Your <code>a</code> is <code>int **</code>, as you declared it. You are casting the result of <code>malloc</code> to <code>int *</code>. <code>int *</code> and <code>int **</code> are those incompatible types the compiler is warning you about. To avoid such errors in the future, get rid of the bad habit of using types in statements. Types in C belong in <em>declarations</em>. <em>Statements</em> should be as type-independent as possible. The above <code>malloc</code> call would look much better this way</p>

<pre><code>a = malloc(5 * sizeof *a);
</code></pre>

<p>Note: no cast, no types mentioned. The second <code>malloc</code> would look as follows</p>

<pre><code>a[i] = malloc(3 * sizeof *a[i]);
</code></pre>

<p>I hope you see the pattern in accordance with which these <code>malloc</code> calls are built.</p>

<p>You also forget to deallocate memory for individual sub-arrays in your program (<code>a[i]</code> memory is never deallocated, while <code>a</code> memory is).</p>

<p>As for the program not showing the entered values... The first problem with broken <code>malloc</code> call is serious enough to prevent your program from working, but it still might appear to ""work"" on some platforms. On such platforms it should show the values. Are you sure you are not simply missing the output?</p>
",0
3854434,3854337,3,"<p>This code has several errors. First of all, the warning refers to the fact that you're trying to assign a pointer to integer (<code>int *</code>) to a variable (<code>a</code>) which is a pointer to a pointer to integer (<code>int **</code>), which you actually want to use as an array of arrays.</p>

<p>So, first correction, at line 8 it's not </p>

<pre><code>a=(int*)malloc(sizeof(int)*5);
</code></pre>

<p>but it is</p>

<pre><code>a=(int**)malloc(sizeof(int *)*5);
</code></pre>

<p>(that cast <em>in C</em> isn't strictly necessary, but being a C++ programmer I prefer to keep it like that)</p>

<p>Notice that also the expression in the <code>sizeof</code> changed, since what you want to allocate is not the space for five integers, but the space for five <em>pointers</em> to integers.</p>

<p>Then, at the end of the application, you're <code>free</code>ing just the space allocated with the first <code>malloc</code>, while you made other five allocations (one for each row). Thus, you could do the deallocation in the last cycle, just after displaying each row.</p>

<pre><code>for (i=0; i&lt;5; i++)
{
    for (j=0; j&lt;3; j++)
    {
        printf(""\nthe value enter  enter the [%d][%d] location = "",i,j);
        printf(""%d"",a[i][j]);
    }
    free(a[i]);
    a[i]=NULL;
}
free(a);
a=NULL;
</code></pre>

<p>Remember: for each <code>malloc</code> or <code>calloc</code>, you have to have it's corresponding <code>free</code>, otherwise you're leaking memory.</p>

<p>Here, after each deallocation, I set the corresponding pointer to <code>NULL</code> to throw away those old, now-invalid, pointers. Somebody say that this behavior can mask double-frees (since <code>free(NULL)</code> doesn't produce errors), but IMHO this is better than the alternative</p>

<p>One important detail: you're not checking the return value of <code>malloc</code>, which is quite bad. It's extremely unlikely that in such small programs allocations may fail, but, nonetheless, it's good practice to <em>always</em> check if the return value of <code>malloc</code> is <code>NULL</code>, and, in this case, handle the situation gracefully, usually releasing all the resources and shutting down the application.</p>

<p>By the way, <code>system(""clear"");</code> is ugly. You should use the platform-specific way to clean the screen, even better if enclosed in a function; on Linux with normal (X3.64) terminal emulators something like this could be ok:</p>

<pre><code>void ClearScreen()
{
    fputs(""\x1B[2J\x1B[1;1H"", stdout);
    fflush(stdout);
}
</code></pre>
",0
7798933,7798889,4,"<p>Keep in mind that there is both a seconds and micro-seconds field of that structure.  Therefore if you are simply subtracting the micro-seconds field, you could have a time that is later in seconds, but the microseconds field is less.  For instance, and end-time of 5 seconds, 100 microseconds will have a negative result compared to 4 seconds and 5000 microseconds with the subtraction method you're using.  In order to get the proper result, you have to take into account both the seconds and micro-seconds fields of the structure.  This can be done doing the following:</p>

<pre><code>long seconds = end.tv_sec - start.tv_sec;
long micro_seconds = end.tv_usec - start.tv_usec;

if (micro_seconds &lt; 0)
{
    seconds -= 1;
}

long total_micro_seconds = (seconds * 1000000) + abs(micro_seconds);
</code></pre>
",0
7798948,7798889,0,"<p>From <a href=""http://www.gnu.org/s/hello/manual/libc/Elapsed-Time.html"" rel=""nofollow"">The GNU C Library</a>:</p>

<blockquote>
  <p>Data Type: <strong>struct timeval</strong></p>
  
  <p>The <code>struct timeval</code> structure represents an elapsed time. It is declared in <code>sys/time.h</code> and has the following members:</p>
  
  <blockquote>
    <p><code>long int tv_sec</code></p>
    
    <blockquote>
      <p>This represents the number of whole seconds of elapsed time.</p>
    </blockquote>
    
    <p><code>long int tv_usec</code></p>
    
    <blockquote>
      <p>This is the rest of the elapsed time (a fraction of a second), represented as the number of microseconds. It is always less than one million.</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>The only thing you're subtracting is the microseconds in <code>tv_usec</code> above the full seconds value in <code>tv_sec</code>. You need to work with both values in order to find the exact microsecond difference between the two times.</p>
",0
7798956,7798889,3,"<p>maybe something along the lines of:</p>

<p><code>long t = (end.tv_sec*1e6 + end.tv_usec) - (start.tv_sec*1e6 + start.tv_usec);</code></p>
",0
5448523,5448492,3,"<p>May be you should use <code>double</code> or <code>float</code> type for matrix array.</p>
",2
5448526,5448492,2,"<p>You have an integer matrix, therefore you should use %d instead of %f / %.2f for scanning/printing</p>
",2
5448573,5448492,1,"<pre><code>float A[10][11];
</code></pre>

<p>but...</p>

<pre><code>void printMatrix(int numColumn, int numRow ,int matrix[numRow][numColumn]){
</code></pre>

<p>A <code>float</code> definition, but the method is expecting an <code>int</code> array. I'm stunned this compiled, but <code>gcc</code> threw off enough warnings that should give one pause:</p>

<pre><code>$ gcc -o 5448492 5448492.c 
5448492.c:30: warning: conflicting types for ¡®printMatrix¡¯
5448492.c:24: note: previous implicit declaration of ¡®printMatrix¡¯ was here
5448492.c: In function ¡®printMatrix¡¯:
5448492.c:37: warning: format ¡®%.2f¡¯ expects type ¡®double¡¯, but argument 2 has type ¡®int¡¯
</code></pre>

<p>Because C requires <strong>all but the first array index</strong> to be known at compile time, you can make the program function by declaring a prototype for <code>printMatrix()</code> that includes the <em>last</em> array index size. (I got it wrong in my comment. Sorry.)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void printMatrix(int numColumn, int numRow ,float matrix[][11]);

int main (int argc,char *argv[]) {

  int num;
  int i,j;
  float A[10][11];

  FILE *inputMatrix=fopen(""yourfile.in"",""r"");
  fscanf(inputMatrix,""%d"",&amp;num);
  int numRow=num;
  int numColumn=num+1;

  for(i=0;i&lt;numRow;++i){
     for(j=0;j&lt;numColumn;++j){
         fscanf(inputMatrix,""%f"",&amp;A[i][j]);
     }
  }
  fclose(inputMatrix);

  printMatrix(numColumn,numRow,A);

  return 0;
}


void printMatrix(int numColumn, int numRow ,float matrix[][11]){
   int i = 0, j = 0;
   printf(""nc: %i, nr: %i\n"",numColumn,numRow);
     for(i = 0 ; i &lt; numRow ; i++)
     {
       for(j = 0 ; j &lt; numColumn ; j++)
       {
         printf(""%f  "", matrix[i][j]);
       }
       printf(""\n"");
     }
     printf(""\n"");
}
</code></pre>

<p>And the output:</p>

<pre><code>$ ./5448492 
nc: 3, nr: 2
1.000000  1.000000  3.000000  
2.000000  2.000000  5.000000  
</code></pre>

<p>I fiddled with other stuff while tracking this one down (and standardized the indents at two spaces; it's awfully small, but consistency on non-favorite beats inconsistency every time), but I'm pretty sure the only thing I changed of substance was the prototype of the function to include the <em>last</em> array dimension.</p>
",9
5448691,5448492,1,"<p>SInce you use an array 10x11, <code>11</code> should be hard coded in other places as well. When passing a multidimensional array like this, all dimensions except the highest must be hard coded. Otherwise, you will get erroneous results.</p>

<p>The reason is that your functions think that the array has <code>numColumn</code> columns but the array in memory has actually 11 columns.</p>

<p>I would make these changes:</p>

<pre><code>include ...
...

-- note the *float** and the **[11]**
void printMatrix(int numColumn, int numRow ,float matrix[][11]);

int main (int argc,char *argv[]) {

  int num;
  int i,j;
  float A[10][11];  
...
}

-- note the *float** and the **[11]**
void printMatrix(int numColumn, int numRow ,float matrix[][11]){
...
}
</code></pre>
",0
4519203,4517188,0,"<p>void (*p) (void *a[],int n)
p is the variable name. Remove p from the above line
void ( * )(void *a[],int n) . So p is of this type. This is a pointer of a function. So p is a pointer to the function with that signature.
So p is a pointer to a function which return void and  takes array of 'void pointers' and int as the parameter.</p>

<p>void *(*p[]) (void *a, int n)
[] has more precedence than *.  So p is an array. remove p[] the above.
So p is an array of void( * )(void *a[],int n)</p>

<p>So here p is an array of pointers to function which return void and  takes array of 'void pointers' and int as the parameter.</p>
",1
4517325,4517188,8,"<pre>
<b>$</b> <a href=""http://manpages.debian.net/cgi-bin/man.cgi?query=cdecl&amp;sektion=1"" rel=""noreferrer"">cdecl</a>
void (*p) (void *a[],int n);
<b>declare p as pointer to function that expects (a as array of pointer to void, n as int) returning void;</b>
void *(*p[]) (void *a, int n);
<b>declare p as array of pointer to function that expects (a as pointer to void, n as int) returning pointer to void;</b>
</pre>
",1
3838126,3838079,7,"<p>Erm... no?!?</p>

<p>The function <code>main</code> and its arguments are defined by the C <em>language</em> standard. This has nothing to do with any library; it's always up to you to implement that function.</p>

<p>In common lingo, a ""C library"" is any function library that has a C interface, i.e. is usable by C programs.</p>

<p>The ""C standard library"", ""standard C library"" or ""standard library"" is the library containing the functions defined by chapter 7 of the C language standard. This includes (but is not limited to) the functions declared in the headers <code>&lt;stdio.h&gt;</code>, <code>&lt;string.h&gt;</code>, <code>&lt;stdlib.h&gt;</code> etc. etc.</p>

<p>The ""standard library"" for Linux, for example, is the GNU C library, or glibc. In addition to the functions from chapter 7 of the language standard, glibc contains many <em>additional</em> functions <em>not</em> defined there. This makes things a bit fuzzy. Those additional functions are part of glibc, but not part of the ""C standard library"".</p>

<p>You know, all bulldogs are dogs, but not all dogs are bulldogs. ;-)</p>
",0
4671722,4671528,2,"<p>Use fscanf() in a loop: first extract the number of repetitions N, then loop N times extracting your pattern.</p>

<p>If you're looking for something more professional or sophisticated, you might want to move away from the standard C library and towards a regex or parsing library, or something mentioned heere: <a href=""http://www.and.org/vstr/comparison"" rel=""nofollow"">http://www.and.org/vstr/comparison</a>.  While I won't go so far as to say you can't do string processing easily or well in C, it's not a strong point of the core language.</p>
",1
4433223,4433186,3,"<ul>
<li>Read all lines to an array of <code>char*</code> s,</li>
<li><p>define a string comparator function for <code>qsort</code> from <code>&lt;stdlib.h&gt;</code> header file:</p>

<pre><code>int compare(const void* a, const void* b) {
    return strcmp(*(const char**)a, *(const char**)b); 
}
</code></pre></li>
<li><p>Use <code>qsort()</code> on that array, using this <code>compare</code> function.</p></li>
</ul>
",3
4354272,4354251,1,"<p>One possible approach:</p>

<pre><code>const float centerX = 10, centerY = 10;
const float speed = 0.1;
const float max_angle = 10;
const float angleStep = 0.1;

for (float angle = 0; angle &lt; max_angle; angle += angleStep) {
    float radius = angle*speed;
    float sX = centerX+cos(angle)*radius;
    float sY = centerY+sin(angle)*radius;
    createPoint(sX,sY);
}
</code></pre>

<p>Substitute any drawing function for <code>createPoint</code> and play with the parameters.</p>

<p>One approach (similar to what's above) for <code>createPoint</code> would be:</p>

<pre><code>void createPoint(int x, int y) {
    gotoxy(x,y);
    putchar('*');
}
</code></pre>

<p>If you want to use a graphics library later, you can change just this method.</p>
",1
4374542,4374474,1,"<p>If you use fgets, you would need to use sscanf() after that to read integers.</p>
",1
5143012,5142982,2,"<p>You need a pointer to a pointer like this:</p>

<pre><code>void create_int(int **p)
{
    *p = (int *) malloc(sizeof(int));
}

int main()
{
    int *p = NULL;

    create_int(&amp;p);

    assert(p != NULL);  /* failed. why? I've allocated memory for it. */

    return 0;
}
</code></pre>
",0
5143013,5142982,7,"<p>You are not passing the pointer value back from the function. Try:</p>

<pre><code>void create_int(int **p) {
     *p = (int *) malloc(sizeof(int)); 
}  

int main() {
     int *p = NULL;      
     create_int(&amp;p);
     assert(p != NULL);  /* failed. why? I've allocated memory for it. */
     return 0;
} 
</code></pre>
",2
5143028,5142982,1,"<p>You need to send a pointer to a pointer to be able to assign a memory to it via a function</p>

<pre><code>void create_int(int **p)
{
   *p = (int*)malloc(sizeof_int));
}

int main()
{
    int* p = NULL;
    create_int(&amp;p);
    assert(p != NULL);
    return 0;
}
</code></pre>
",0
5143040,5142982,2,"<p>The variable <code>p</code> in the function <code>create_int</code> is a <strong>copy</strong> of the variable <code>p</code> in <code>main</code>. So any changes made to <code>p</code> in the called function does not get reflected in <code>main</code>. </p>

<p>To make the change get reflected in <code>main</code> you need to either:</p>

<p>Return the changed value:</p>

<pre><code>int* create_int(int *p) {
    p = malloc(sizeof(int));
    // err checking
    return p:
}
...
// in main:
p = create_int(p);
</code></pre>

<p>Or pass the address of <code>p</code> as:</p>

<pre><code>void create_int(int **p) {
    *p = malloc(sizeof(int));
    // err checking
}
...
// in main:
create_int(&amp;p);
</code></pre>
",0
5143048,5142982,2,"<p>As folks have pointed out, it's failing since you're not actually changing the pointer that the caller has.</p>

<p>A different way to think about the code might be to notice that it's basically wrapping <code>malloc()</code>, i.e. it's doing a memory allocation but with intelligence added. In that case, why not make it have the same prototype (=call signature) as <code>malloc()</code>? That makes it clearer in the caller's context what's going on, and easier to use:</p>

<pre><code>int * create_int(void)
{
  return malloc(sizeof (int));
}

int main(void)
{
  int *p = create_int();
  assert(p != NULL);
  return 0;
}
</code></pre>

<p>Also, in C you should never cast the return value of <code>malloc()</code> (see <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Do I cast the result of malloc?</a>).</p>
",3
5143075,5142982,0,"<p>Your code contains two pointers: one in the <code>create_int</code> function and another one in <code>main</code>. When you call <code>create_int</code>, a <strong>copy</strong> of the pointer in <code>main</code> is made and used, then <strong>eliminated</strong> when the <code>create_int</code> function returns. </p>

<p>So, any changes you did to the copy within <code>create_int</code> remain there and are not propagated back to <code>main</code>.</p>

<p>The only way to propagate changes between functions in C (aside from, obviously, returning new values) is to pass a pointer to the changed values. This way, while the pointer being passed will be copied, the value that it points to will be the same, so changes will apply.</p>

<p>Since you're trying to change a pointer, you need a pointer-to-pointer.</p>

<pre><code>void create_int(int **pp)
{
    // this changes the pointer that `p` points to.
    *pp = (int *) malloc(sizeof(int)); 
}

int main()
{
    int *p = NULL;

    // this sends a pointer to the pointer p in main        
    create_int(&amp;p); 

    assert(p != NULL);  

    return 0;
}
</code></pre>
",0
7819522,7819495,4,"<p>From C99 ¡ì7.20.4.3/3:</p>

<blockquote>
  <p>Next, all open streams with unwritten buffered data are ?ushed, <strong>all
  open streams are closed</strong>, and all ?les created by the tmpfile function
  are removed.</p>
</blockquote>

<p><a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/exit.html"" rel=""nofollow"">POSIX</a> (aligned with C99) spells it out better:</p>

<blockquote>
  <p>The exit() function shall then flush all open streams with unwritten
  buffered data and close all open streams.</p>
</blockquote>
",2
7819536,7819495,5,"<p>They are closed by the C runtime code which is automatically linked to your program - the code that calls your main() function also calls exit() after main() returns.</p>
",0
6101871,6101412,0,"<p>On some Operating Systems, the program's output is displayed in a window.  As soon as the program finishes, the window disappears.  </p>

<p>One method to prevent this is to prompt the User to press ""ENTER"" to continue or end the program.  </p>
",0
6102054,6101412,4,"<h1>Questions</h1>
<h2>cashTendered method</h2>
<p>You can't create a (simple) cashTendered method (as a void function) with the current layout because all of your variables are only visible inside the scope of the <code>main</code> function. You would need to either pass all of your data to the cashTendered method (making structs would make this significantly less painful- see below) or make all of your variables global (generally considered to be a bad idea, for a number of complicated reasons).</p>
<h1>Suggestions</h1>
<h2>Combining</h2>
<p>An item should be a struct, with members <code>price</code> and <code>quantity</code> (both should be <code>int</code>s: see &quot;Numeric Types&quot; below). Subtotal doesn't really need to be a member of the item structure, as it's a property of the total transaction and not the item.</p>
<h1>Mistakes</h1>
<h2>Numeric types</h2>
<p>You should really be using integers rather than floats for your prices, since you're not counting a <em>fractional amount</em> of dollars but an <em>integral number</em> of cents (all dollar prices should be multiplied by 100).</p>
<p>For example, when you mark a $10.00 item down by a third, you want your new price to be $6.66, not $6.666666666666. While printf will adjust your output to two places, it won't adjust your underlying math- it will report that somebody paying $6.66 won't be giving enough money (since they'll be short two-thirds of a cent).</p>
<p>There are other issues you'll run into since float is not a <a href=""http://en.wikipedia.org/wiki/Decimal_floating_point"" rel=""nofollow noreferrer"">decimal floating point</a> type (6.66 - (6.65 + 0.01) may not equal zero, for instance).</p>
",3
4596472,4596420,1,"<p>You're looking for the sum of (n! * 2^n) from 1 to y.  </p>

<pre><code>total variable is 0  
for 1 until y:  
multiply factorial(n) and pow(2, n) and add this to total
end of loop
print out total
</code></pre>
",0
4596473,4596420,1,"<p>I didn't do everything for you, but here is a basic outline.</p>

<p>You must finish it off.</p>

<pre><code>int answer = 0;
int n;
for(n=1; n &lt;= y; ++n)
{
    answer = answer + (n! * 2^n)*y;
}
</code></pre>
",5
4596894,4596420,1,"<p>I've a suspicion what one of the learning outcomes of this is and too much help here will give the game away.</p>

<p>I think i can safely say you need to break each part of the equation down to smaller solvable parts.</p>

<p>The three biggest parts are summation, N Factorial (N!) and 2 to the power N</p>

<p>The summation is effectively a loop with N starting at 1 and ending at y, so look for the C syntax to write a loop (hint there are two common types, while and for)</p>

<p>The other two are functions, if your allowed to use premade functions then plenty exist only a google away which will sort you out nicely, if not you'll have to write your own.</p>

<p>factorial is <code>n*(n-1)*(n-2)...(n-(n-2))*(n-(n-1))</code></p>

<p>so <code>4! = 4*3*2*1</code></p>

<p>a prime candidate for a <a href=""http://www.google.co.uk/search?q=recursion"" rel=""nofollow"">recursive function</a> or a function with a descending loop in it</p>

<p>2 to the power n is 2 multiplied by itself n times</p>

<p>so 2 to the power 2 = <code>2*2</code></p>

<p>2 to the power 3 = <code>2*2*2</code> and so on</p>

<p>Once again a loop looks like a good place to start with that.</p>

<p>After that its just a matter of using your two functions inside the loop, giving the user a way to input Y and testing with some numbers.</p>

<p>1,2,3 would be a good start as they're nice and easy to work out on a calculator.</p>

<p>All well and good so far I'd hope, -1 should make interesting things happen to every example I've seen posted so far, and that's before we start pushing the boat out with big numbers like 32.  </p>

<p>Edit:
Right, I've taken a look at your code, and it looks like your problem isn't in the implementation of your algorithm, its not reading the variable in correctly, outputing y just after you set it yields 0, so something isn't working quite right there.  Im not a c coder but i had a quick hack at it with some liberal googling and your non functional code and made it read an argument in then parse it to a double.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
double factorial(double x);
double Power_function(double y);

main(int argc, char *argv[]){
  double answer=0;
  double n;
  double y;
  y = atol(argv[1]);
  //printf(""%lf\n"",y);
  for (n=1;n&lt;=y;++n){
    answer=answer +factorial(n)*Power_function(n)*y;
  }

  printf(""The Answer is %0.2f\n"",answer);
  return 0;
}

double factorial(double x)
{
  double ans;
  if (x==0){
    ans = 1;
  }
  else
  {
    ans = x*factorial(x-1);
  }
  return ans;
}

double Power_function(double y){
  double ans;
  ans=pow(2,y);
  return ans;
}
</code></pre>

<p>So essentially your code with a different input method,</p>

<p>compiled using</p>

<p><code>gcc so.c -lm</code></p>

<p>executed as </p>

<p><code>./a.out 1</code>
yields <code>The Answer is 2.00</code></p>

<p><code>./a.out 2</code>
yields <code>The Answer is 20.00</code></p>

<p><code>./a.out 3</code>
yields <code>The Answer is 174.00</code></p>

<p>Pen and paper maths backs it up so your algorithm is sound so far!</p>

<p>Feed it some negative numbers and some huge numbers to see what it does from here!</p>
",2
4596991,4596420,0,"<p>First thing to do is to write down what you manually would do to work that equation out. Try out 1 to 5, for example, and see what you get.</p>
",0
6118805,6118689,2,"<p>Instead of this:</p>

<pre><code>    *compArray[arraySize - 1] = newComp;//set the newly created part of the array to newComputer
</code></pre>

<p>Try this:</p>

<pre><code>    (*compArray)[arraySize - 1] = newComp;//set the newly created part of the array to newComputer
</code></pre>

<p>This way you explicitly dereference compArray before subscripting. </p>
",3
7215132,7214950,13,"<pre><code>int noNesting = 0 /* /* */ + 1 // */
;
</code></pre>
",0
4375390,4375358,1,"<p>Well, how do you terminate your input? Entering an empty line won't help because line will be <code>""""</code> not <code>NULL</code>. Have you tried pressing Ctrl+Z in the console (if it's windows)?</p>
",1
4375413,4375358,3,"<p>Well for a start, I suggest reading the following about why you should avoid using <code>gets()</code>.  I suggest using <code>scanf()</code> or <code>fgets()</code> instead...</p>

<p><a href=""http://www.gidnetwork.com/b-56.html"" rel=""nofollow"">http://www.gidnetwork.com/b-56.html</a></p>

<p>then note that you're doing a loop to 100 taking input, and only after all 100 are you outputting.  So you'll need to enter 100 lines of input currently before you see anything...</p>
",1
4375417,4375358,2,"<p>You're not checking for an empty line.</p>

<p>You need something like:</p>

<pre><code>if('\0' == line[0])
{
    break;
}
</code></pre>

<p>And use fgets() not gets(). It's safer. However you then need to do:</p>

<pre><code>if('\n' == line[0] || '\r' == line[0])
{
    break;
}
</code></pre>
",0
4375422,4375358,4,"<p><code>gets</code> doesn't return NULL when you type an empty line, if that's what you tried to check for. It will still be an empty string. You'll need to check if the first character is a <code>\0</code> if you want to look for empty lines.</p>

<p>On a side note, <code>gets</code> is extremely unsafe since it will overrun your buffer if your line is too long and cause evil bugs. Use <code>fgets</code> instead, it lets you specify the size of your buffer. (Note that fgets will add a <code>\n</code> to the end of your string, even if it's an empty line.)</p>
",0
4327851,4327839,2,"<p>What you are observing is undefined behavior. Specifically, dereferencing <code>p</code> in <code>*++p=2</code> is forbidden as <code>i</code> is not an array with at least two members. In practice, your program is most likely attempting to write to whatever memory is addressed by <code>&amp;i + sizeof(int)</code>.</p>
",0
4327857,4327839,1,"<p>You are invoking <em>undefined behaviour</em> by writing to undefined areas on the stack. codepad.org has protection against programs that try to do disallowed things, and your undefined behaviour program appears to have triggered that.</p>

<p>If you try to do that on your own computer, your program will probably end up crashing in some other way (such as segmentation fault or bus error).</p>
",0
4327858,4327839,1,"<p>The expression<code>*++p</code> first moves the pointer <code>p</code> to point one <code>int</code> forward (i.e. the pointer becomes invalid), then dereferences the resulting pointer and tries to save the number 2 there, thus writing to invalid memory.</p>

<p>You might have meant <code>*p = 2</code> or <code>(*p)++</code>.</p>
",1
4327862,4327839,5,"<p>When you do <code>*p = &amp;i</code>, you make <code>p</code> point to the single integer <code>i</code>. <code>++p</code> increments <code>p</code> to point to the ""next"" integer, but since <code>i</code> is not an array, the result is undefined.</p>
",5
4327865,4327839,0,"<p>Your code accesses memory it does not own, and the results of that are undefined.  </p>

<p>All your code has the right to do as it is currently written is to read and write from an area memory of size <code>sizeof(int)</code> at <code>&amp;i</code>, and another of size <code>sizeof(int*)</code> at <code>&amp;p</code>.</p>

<p>The following lines all violate those constraints, by using memory addresses outside the range you are allowed to read or write data.</p>

<pre><code>*++p=2;

printf(""\n%d"",*p);
printf(""\n%d"",*(&amp;i+1));
</code></pre>
",0
4327884,4327839,0,"<p>Operator <code>++</code> modifies its argument, so the line <code>*++p=2;</code> assigns <code>2</code> to a location on the stack that probably defines the <a href=""http://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow"">call frame</a> <em>and</em> increments the pointer <code>p</code>. Once you messed up the call frame - all bets are off - you end up in corrupt state.</p>
",0
4515415,4515387,0,"<p>I think the problem is that sizeof(a) will return sizeof(char*) (the size of a poitner to a character) rather than the length of the character string a.
So it is only copying four characters.</p>
",1
4515424,4515387,0,"<p>Use strlen instead of sizeof. Sizeof of a pointer will be 4 on a 32 bits platform.</p>
",0
4515432,4515387,3,"<p>There are a number of problems here. First off, you cannot compare the contents of strings using <code>==</code> or <code>!=</code> in C - that compares the pointer values, so <code>a != ""a""</code> will always be TRUE. Also, <code>dir[strlen(dir)]</code> is always equal to <code>'\0'</code> by definition. And <code>sizeof(a)</code> is the size of a <code>char *</code> (i.e. 4), not the length of the data.</p>

<p>Your function should look something like this:</p>

<pre><code>int meltcheck( char *a )
{
    if( a != NULL &amp;&amp; strcmp( a, ""a"" ) != 0 ) {
        char dir[600];
        strcpy( dir, ""del "" );
        strcat( dir, a );
        printf( ""\ndtmeltcheck: %s\n"", dir );
        // system( dir );
        // note that you should be using the unlink() function here
    }
}
</code></pre>
",3
4515441,4515387,1,"<p>You can't use <code>sizeof</code> in this way on arrays passed as parameters to functions.</p>

<p>The reason is that when passing an array to a function in C, the array decays into a pointer to its first element.  As a result, when you take <code>sizeof(a)</code>, you get the size of the pointer, not the size of the array.  In this case, it is the same as <code>sizeof(char *)</code>, which on a 32-bit machine will be 4, as you observe.</p>

<p>You're also using <code>strncat</code> in a way it wasn't really intended, though.  The point of the third parameter is to prevent a buffer overflow if <code>strlen(a)</code> is longer than the amount of space in the buffer you're copying into, in this case, <code>dir</code>.  I think what you want is:</p>

<pre><code>strncat(dir, a, 595); /** 600 - ""dir "" - \0 = 595 */
</code></pre>

<p>Because there is room for 595 more characters in <code>dir</code>.</p>

<p>Also note that you can't compare C strings using <code>!=</code>.  Your <code>if</code> statement should use <code>strcmp</code> instead.</p>
",0
4012159,4012107,0,"<pre><code> /**Get projects directory from environment variable****************/
 /* You need to replace this line with wherever you want to get the
    file name from. Either request it from the user, pull it from a
    configuration file or read it from the command line */
 strcpy(pjects.arr, getenv(""Tech_Projects""));

  /* this line does absolutely nothing. strlen() relies on the string
     already being null-terminated */
  pjects.arr[strlen(pjects.arr)] = '\0';

  if (strcmp(inwashfile.arr, ""null"") != 0)
  {
    for (d=2;d&lt;inwashfile.len;d++)
    {
      tempfile.arr[d-2] = inwashfile.arr[d];
    }      
    memset(inwashfile.arr, '\0', 255);    

    strcpy(inwashfile.arr, pjects.arr);
    strcat(inwashfile.arr, tempfile.arr);

    inwashfile.len = strlen(inwashfile.arr);
    inwashfile.arr[inwashfile.len] = '\0';
    do_wash[0] = 'T';
  }
  else
  {
    do_wash[0] = 'F';
  }
printf(""3\n"");
  do_wash[1] = '\0';
</code></pre>
",1
4020318,4012107,0,"<p>It could be</p>

<pre><code>strcpy(pjects.arr, argv[ 1 ] );
</code></pre>

<p>and the directory named could be passed from the command line, e.g.</p>

<pre><code>$ myprogram /user/foo
</code></pre>
",0
4551997,4551969,1,"<p>Perhaps you are stripping the symbols? A command like the following might be the culprit:</p>

<pre><code>strip --strip-unneeded
</code></pre>
",1
6101243,6101187,4,"<p>You are looking for <code>sprintf()</code>, perhaps something like this:</p>

<pre><code>sprintf(buffer, ""%.4d-%.4d-%d"", w1, w2, w3);
</code></pre>

<p>where <code>w1</code>, <code>w2</code> and <code>w3</code> are integer variables holding values 2000, 3000 and 2 in your example.</p>
",6
5150981,5150962,3,"<pre><code>const char *str=""A C string"";
printf(""The first character is %c\n"",*str);
printf(""The second character is %c\n"",*(str+1));
</code></pre>
",2
4594257,4594235,9,"<p>If an array/aggregate is initialized somehow[edit: by use of a static initializer], the remaining unspecified entries are zeroed, yes.</p>
",0
4595307,4594235,3,"<p>Yes, the uninitialized array elements will be zeroes. Example:</p>

<p>If the initializer supplies too few elements, 0 is assumed for the remaining array elements:</p>

<pre><code>int v5[8] = { 1 , 2 , 3 , 4 };
</code></pre>

<p>is equivalent to </p>

<pre><code>int v5[] = { 1 , 2 , 3 , 4 , 0 , 0 , 0 , 0 };
</code></pre>
",0
5551150,5551137,2,"<p>You're looking for <code>stat</code> - <code>man 2 stat</code></p>
",0
5551191,5551137,1,"<p>Take a look a the stat function. It returns a structure with the permissions.</p>

<blockquote>
  <p>man 2 stat</p>
</blockquote>

<p>The structure is also called stat, and includes a protection field st_mode.</p>
",1
8437048,8437015,4,"<p>Add <code>fclose(fp);</code> before returning.</p>
",0
8437056,8437015,6,"<p>call <code>fclose(fp)</code> or <code>fflush(fp)</code> to make sure content of file buffer gets flushed to the file.</p>
",3
3555148,3555108,20,"<p>Is it </p>

<pre><code>scanf(""%[^\t\n]"",string);
</code></pre>
",4
3555183,3555108,2,"<p>I don't think this is possible with scanf().
If you know the number of words you want to read, you can read it with</p>

<pre><code>char str1[100], str2[100];
scanf(""%s %s"", str1, str2);
</code></pre>

<p>Note that this is a huge security loophole, since a user can easily enter a string that's longer than the allocated space.</p>

<p>If you don't know the number of words, you might have to rephrase your question. What do you need to read it for? Why don't you want to use gets(), why does it have to be scanf()?</p>
",4
4358401,4358383,4,"<p>Use <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fgets/"" rel=""nofollow""><code>fgets()</code></a> instead of <code>scanf()</code></p>
",1
4358407,4358383,0,"<p>Well <code>bookname</code> surly is some kind of char ;-)
Point is that <code>scanf</code> in this form stop on the first whitespace character.</p>

<p>You can use a different format string, but in this case, one probably should prefer using <code>fgets</code>.</p>

<p><code>scanf</code> really should be used for ""formatted"" input. </p>
",0
4359296,4358383,20,"<p>The <code>%s</code> conversion specifier causes <code>scanf</code> to stop at the first whitespace character.  If you need to be able to read whitespace characters, you will either need to use the <code>%[</code> conversion specifier, such as</p>

<pre><code> scanf(""%[^\n]"", bookname);
</code></pre>

<p>which will read everything up to the next newline character and store it to <code>bookname</code>, although to be safe you should specify the maximum length of bookname in the conversion specifier; e.g. if bookname has room for 30 characters counting the null terminator, you should write</p>

<pre><code> scanf(""%29[^\n]"", bookname);
</code></pre>

<p>Otherwise, you could use <code>fgets()</code>:</p>

<pre><code> fgets(bookname, sizeof bookname, stdin);
</code></pre>

<p>I prefer the <code>fgets()</code> solution, personally.  </p>
",1
4547751,4547712,0,"<p>I don't think you will see much performance difference in using 2 threads over one. Either way, you don't want both threads to read the file. Read the file first, then pass a COPY of the stream to the methods you want and process both. The threads will not have access to the same stream of data at the same time so you'll need to use 2 copies of the textfile.</p>

<p>P.S. It's possible that depending on the size of the file, you will actually loose performance using 2 threads.</p>
",0
4547863,4547712,2,"<p>If you asked in C++ I could give you a code example, but I havent done ANSI C in a very long time so I will give you the design and pseudo code.</p>

<p>Please keep in mind this is really bad pseudo code that is meant to give an example. I'm not questioning WHY you would want to do this. For all I know it could be an excercise with threads or because you ""feel like it"".</p>

<p><strong>Example 1</strong></p>

<pre><code>int integerCount = 0;
int lineCount = 0;

numericThread()
{
    // By flagging the file as readonly you should
    // be able to open it as many times as you wish
    handle h = openfile (""textfile.txt"". readonly);

    while (!eof(h)) {
          String word = readWord (h);
          int outInteger
          if (stringToInteger(word, outInteger)) {
                ++integerCount;
          }
    }
}

lineThread()
{
    // By flagging the file as readonly you should
    // be able to open it as many times as you wish
    handle h = openfile (""textfile.txt"". readonly);

    while (!eof(h)) {
          String word = readWord (h);
          if (word.equals(""\n"") {
                ++lineCount ;
          }
    }
}
</code></pre>

<p>If for some reason you aren't able to open the file twice in readonly you will need to maintain a queue for each thread, having the main thread put words into each threads queue. The threads will then pull from the queue.</p>

<p><strong>Example 2</strong></p>

<pre><code>int integerCount = 0;
int lineCount = 0;
queue numericQueue;
queue lineQueue;

numericThread()
{

    while (!numericQueue.closed()) {
          String word = numericQueue.pop();
          int outInteger
          if (stringToInteger(word, outInteger)) {
                ++integerCount;
          }
    }
}

lineThread()
{
    while (!lineQueue.closed()) {
          String word = lineQueue.pop();
          if (word.equals(""\n"") {
                ++lineCount ;
          }
    }
}

mainThread()
{
    handle h = openfile (""textfile.txt"". readonly);
    while (!eof(h)) {
          String word = readWord(h);
          numericQueue.push(word);
          lineQueue.push(word);
    }
    numericQueue.close();
    lineQueue.close();
}
</code></pre>
",0
4548052,4547712,2,"<p>There are lots of ways to do this.  You can make different design decisions depending on how fast or simple or elegant or overengineered you want this to be.  One way, as posted by Andrew Finnell is to have each thread open the file and read it completely independently.  In theory this isn't great because you are doing expensive IO twice but in practice it's probably fine because the OS has likely cached the contents of whichever read executes first. Double IO is still more expensive than average because it involves a lot of needless system calls, but again in practice it will be irrelevant unless you have a very large file.</p>

<p>Another model of how to do this would be for each thread to have an input queue, or a shared global queue.  The main thread reads the file and places each line in turn on the queue(s), and perhaps main doubles as one of your worker threads.  This is more complicated because access to the queue(s) must be synchronized, or some lockless queue implementation must be used. In the case of a shared global queue, there is less duplication of data but now the lifecycle of that data is more complicated.  </p>

<p>Just to point out how many ways such a simple thing can be done, you could go the overengineering route and make each thread generic.  Instead of placing data on the queue(s) you place both data (or pointers to data) and function pointers and let each thread execute the callback.  This kind of model might might sense if you plan on adding lots more kind of things to compute but want to limit the number of threads you will use.</p>
",0
7810837,7810814,1,"<p>It's called <strong>recursion</strong> and it can be very useful.  For instance traversing a tree.  Some math calculations also use recursion.</p>
",7
7810839,7810814,6,"<p>A while-loop would be more suitable. Recursion makes sense when, with each recursion, you are doing a <em>different</em> job -- typically a smaller one.</p>

<p>What this code is <em>really</em> doing is demonstrating function-local static variables: the <code>ivar</code> is only initialised in the <em>first</em> call of <code>main</code>. Each time you recurse, it is decremented despite the <code>ivar=5</code> statement.</p>

<p><code>main</code> has a special meaning. Idiomatically, it should <strong>initialise the environment</strong> and then call some other function which drives the application logic.</p>

<p>An optimising compiler might well transform that code into an iterative version anyway.</p>
",0
7810850,7810814,7,"<p>I would say it's rarely, if ever, a good idea to call the <code>main</code> function.  If you're going to recurse, create a function to do it.</p>
",2
7810899,7810814,3,"<p>This is not often seen (I've never seen it done before), very confusing, since main is supposed to be called once when the program starts and end when the program ends, and largely impractical in most real programs, since you would need to stop the subsequent calls to main() from parsing the command line again.</p>

<p>It's far more reasonable to just write a separate recursive function and call it from main and using ordinary function arguments instead of static variables.</p>
",0
7811155,7810814,8,"<p>In your example, it doesn't matter because it's a very small piece of code. But in the general case I think calling <code>main</code> is a bad idea for the following reasons:</p>

<ul>
<li><strong>Readability.</strong> When examining a program no one would assume that <code>main</code> will be called at one point. When you see that it is, you have to back track and reread the whole thing. Besides, <code>main</code> is not a meaningful name in the sense that it's not clear what the intent of the recursion is. So I'd write another function with a meaningful name to reflect this.</li>
<li><strong>Reusability.</strong> It's quite probable that a new function with a meaningful name will be useful in more than one place in a complex program.</li>
<li><strong>Command line arguments.</strong> At one point you may need command line arguments in your program. Even GUI programs need them (for file associations etc.). And you will need to refactor all your calls to main to take that into account.</li>
<li><strong>C++ compatibility.</strong> It's illegal in C++.</li>
</ul>
",1
4551712,4551696,6,"<p>You will probably will need to compile <em>each</em> .c file with -g to have a complete set of debugging symbols.</p>
",3
4614094,4614009,1,"<p>For the name, store the user input in a string. Traverse the string and say error if array elements are not 'a' to 'z' or 'A' to 'Z'. As for as age is considered, you can use char array or integer. While using integer if an user enters 'a' the ascii value of that will be taken. But if you use char array you can see only for digits and with a limit.</p>

<p>int main()</p>

<p>{</p>

<pre><code>char name[10],age[2];
int i;
printf(""Enter name and age \n"");
scanf(""%s %s"",name,age);
for(i=0; name[i]!=NULL; i++)
    if(isdigit(name[i]))
        printf(""Error, name in aplahbets\n"");
for(i=0; age[i]!=NULL; i++)
    if(isalpha(age[i]))
        printf(""Error, age in numbers\n"");

// Rest of your code Your code 
return 0;
</code></pre>

<p>}</p>
",1
4614110,4614009,1,"<p>Age is typically a natural number, ranging from 0 to 130. Depending on your application, a more realistic range might be 15 to 65. Take a look at your requirements.</p>

<pre><code>int IsNaturalNumber(const char* number)
{
    while(*number) {
        if(!isdigit(*number))
            return 0;
        ++number;
    }

    return 1;
}

char age[20+1] = { 0 };
if(!fgets(age, 20, stdin)) error(""EOF reached!"");
if(!IsNaturalNumber(age)) error(""Please enter a natural number!"");
int age_as_int = atoi(age);
if(age_as_int &lt; LOWER_AGE_BOUND || age_as_int &gt; UPPER_AGE_BOUND)
    error(""Age must be between %d and %d."", LOWER_AGE_BOUND, UPPER_AGE_BOUND);
</code></pre>

<p>Names are tricky. What is a proper name? A commonly used form is Salutation (Mr./Mrs./Miss), First name and Last/Family name. This covers a lot of cultures. Don't forget to take language into consideration. Mr. = Herr, Mrs. = Frau, Miss = Fr?ulein in German for instance. Also, some cultures prefer family names before first name in forms (Japan for instance). What are your requirements? Do you need to consider all cultures, or just a few?</p>
",2
4614650,4614009,0,"<p>The common way to do input validation is to read the input as a string into the program and then to validate it and convert to the expected type.</p>

<p>For names, there is not much useful validation you can do. You can (and should) check that the input does not exceed your expectations, but otherwise most input should be regarded as a valid name.</p>

<p>For age, there is a lot more validation you can do. First the input must be a valid integer and secondly, it must be within a certain range.</p>

<p>You could use the following functions:</p>

<pre><code>char* readString(char* buffer, size_t buflen)
{
  char* result;
  result = fgets(buffer, buflen, stdin);

  if ((result != NULL) &amp;&amp; 
      (strlen(result) == buflen-1) &amp;&amp;
      (result[buflen-2] != '\n'))
  {
    /* too long a line */

    /* read the remainder of the line, to clear the input buffers */
    while ((result != NULL) &amp;&amp; (result[strlen(result)-1] != '\n'))
    {
      result = fgets(buffer, buflen, stdin);
    }

    /* set result to NULL to indicate an error */
    result = NULL;
  }

  if (result != NULL)
  {
    /* strip the newline */
    result[strlen(result)-1] = '\0';
  }
}

bool readInt(int low, int high, int* value)
{
  char temp[80];

  if (readString(temp, 80))
  {
    char* endp;
    long result = strtol(temp, &amp;endp, 10);
    if ((*endp == '\0') &amp;&amp; (result &gt;= low) &amp;&amp; (result &lt;= high))
    {
      *value = result;
      return true;
    }
    else
    {
       return false;
    }
  }
  else
  {
    return false;
  }  
}
</code></pre>
",0
4516331,4516287,-1,"<p>At least you can use hash table to store squares. So search of (i^2+j^2) for each pair will be in O(1) and in overall algorithm will take O(n^2)</p>
",1
4516491,4516287,0,"<p>A variation of your approach that's O(n^2).</p>

<pre><code>def findPythagoreanTriplets(array):
  array = sorted(array)
  for i in range(len(array)):
    k = i + 2
    for j in range(i + 1, len(array)):
      while k &lt; len(array) and (array[k] ** 2 &lt; (array[i] ** 2 + array[j] ** 2)):
        k += 1
      if k &lt; len(array) and (array[k] ** 2 == (array[i] ** 2 + array[j] ** 2)):
        print ""%d^2 + %d^2 = %d^2"" % (array[i], array[j], array[k])
</code></pre>

<p>This is Python code, but converting to C shouldn't be hard. (Actually, this question seems language agnostic, so I'm not sure why you've got the c tag...)</p>

<p>This is assuming all of the inputs are non-negative. You could probably make it work for negative integers as well, but you'd need to sort by the squared value, not by the input value (for non-negative numbers they're the equivalent).</p>

<p>Instead of doing a binary search you just do a linear search for k, but you can pick up from where the previous j's search left off, so searching for k is ""free"".</p>
",0
4601944,4601691,0,"<pre><code>struct database {
     char name[25];
     int age[5];
     // in my opinion you should only keep dob, since age would have to be constantly updated
     int dob[10]; 
     struct database *next; 
     } TCel, *TList, **Alist;
</code></pre>

<p>The basic idea is that whenever you create a new cel, you use the 'next' pointer in order to chain it in the linked list. For instance you can add a new cell at the end of the list:</p>

<pre><code>AList InsEnd(AList aL, Info e)  
{ 
    TLista aux;
    // allocate cel and set the information inside it
    aux = AlocCel(e);                     
    if (!aux) return aL;               
    while (*aL != NULL) 
       aL = &amp;(*aL)-&gt;next; 
    // linking the node
    *aL = aux;                            
    return aL;                            
}
</code></pre>

<p>or</p>

<pre><code>TList InsEnd2(TList aL, Info e)
{
    TLista aux;
    aux = AlocCel(e);
    if(!aux) return aL;
    while(aL-&gt;next != NULL)
        aL = aL-&gt;next;
    // linking the node
    aL-&gt;next = aux;
    return aL;
}
</code></pre>
",2
4602333,4601691,0,"<p>I am not going to give you the code, but these link will surely help you.</p>

<p><a href=""http://en.wikipedia.org/wiki/Linked_list"" rel=""nofollow"">http://en.wikipedia.org/wiki/Linked_list</a></p>

<p><a href=""http://richardbowles.tripod.com/cpp/linklist/linklist.htm"" rel=""nofollow"">http://richardbowles.tripod.com/cpp/linklist/linklist.htm</a></p>

<p>Also its better to go back and refer the book (as pointed by David, in comments)</p>
",1
4666872,4666865,7,"<p>Because compilers are free to arrange the contents of the stack however they like.  Also, whatever happens to be ""at the top of the stack"" will be interpreted by <code>printf()</code> as a pointer; there could be any random junk at the corresponding storage location.</p>
",0
4666897,4666865,7,"<p>In your printf statement you specified a format specifier %s, which means to print a string. It will check the top of the stack and print the string present on top of stack</p>

<p>Stack arrangement is completely Compiler dependent</p>

<p>The __libc_start_main() function shall perform any necessary initialization of the execution environment, call the main function with appropriate arguments, and handle the return from main() and that was on the top of stack. And that is what you got as output</p>
",2
4666900,4666865,9,"<p>You're dealing with <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>, so you can't expect it to be consistent, nor follow any kind of pattern across compilers, architectures or even runs of the same program.</p>
",0
6115525,6115513,5,"<p>A will be one. This is called a post-increment. The variable i is only increased after being used. The opposite is called a pre-increment.</p>
",0
6115532,6115513,6,"<p><code>a==1</code>. And then, <code>i==2</code> </p>

<p>It would be <code>a==2</code> if you did <code>a=++i</code></p>
",0
6115548,6115513,2,"<p><code>a==1</code>, <code>i++</code> returns the value of <code>i</code> and then increments it. FYI, if you had <code>++i</code> the opposite would be true, <code>i</code> would be incremented and then the value would be returned.</p>
",0
6115551,6115513,2,"<pre><code>int i = 1;
</code></pre>

<p><code>i</code> now has the value 1.</p>

<pre><code>int a = i++;
</code></pre>

<p><code>a</code> has the value of <code>i++</code>, which is <code>1</code> (<code>i++</code> returns <code>1</code>, then it increases the value of <code>i</code> by <code>1</code>). <code>i</code> now increases with <code>1</code> and becomes <code>2</code>.</p>

<p>At this point, <code>a == 1</code>, <code>i == 2</code>.</p>
",0
5152438,5152310,6,"<p>The former starts to define (or declare, depending on what comes next) a function that returns a pointer to <code>int</code>. The latter is a syntax error. Neither are function pointers.</p>

<p>A function pointer needs to look like this:</p>

<pre><code>int (*fun)(void);
</code></pre>

<p>This declares a pointer to a function that returns <code>int</code>.</p>
",1
5152457,5152310,3,"<pre><code>int* fun(void);
</code></pre>

<p><code>fun</code> do not take any arguments but returns a pointer to an integer. And I think, second one is syntactically wrong. If you are trying to for a function pointer, then it should be -</p>

<pre><code>int (*fun)(void)= NULL;
</code></pre>

<p>Now, <code>fun</code> is pointer to a function that takes no arguments but returns an integer.</p>
",0
5455844,5454874,0,"<p>Try this.</p>

<pre><code>llnode*  listinsert(struct llnode *p) {
    struct llnode *prev = p;
    if( NULL == prev ) {
            prev = lalloc();
            prev-&gt;num= line;
            prev-&gt;next = NULL;
            return prev;
    }
    while(prev-&gt;next != NULL) {
        prev = prev-&gt;next;
    }
    prev-&gt;next = lalloc();
    prev = prev-&gt;next;
    prev-&gt;num = line;
    prev-&gt;next = NULL;
    return p;
}
</code></pre>
",5
5454894,5454874,2,"<p>In <code>listprint</code>, you are not checking if <code>p</code> is null before checking if <code>p-&gt;next</code> is null.</p>
",22
4898992,4898909,0,"<p>One option would be to use the Fiddler Web Debugger which is scriptable (C#).</p>

<p>Although it's a Win32 program, it can act as a proxy for any Linux machine. See <a href=""http://www.fiddler2.com/fiddler/help/hookup.asp#Q-NonWindows"" rel=""nofollow"">Debug traffic from another machine (even a Mac or Unix box)</a> for details.</p>

<p>There's also a native Linux app called <a href=""http://www.monkey.org/~dugsong/dsniff/"" rel=""nofollow"">dsniff</a> which can be used to log all HTTP traffic to a file.</p>
",0
4550890,4550864,2,"<p><strong>Option 1</strong>: use a combination of standard library functions such as <code>strtok()</code> and <code>atoi()</code>, or <code>sscanf()</code>. With these tools, you'll figure it out in no time!</p>

<p><strong>Option 2</strong>: roll out your own function! It's a nice thinking excerise :).</p>
",0
4551005,4550864,6,"<p>You are almost there!</p>

<p><code>sscanf()</code> requires you to give the format of the expected string to be parsed.</p>

<p>You have commas between numbers... Just try to add commas between the <code>%d</code>...</p>

<pre><code>  ""%d,%d,%d""
</code></pre>
",0
4669064,4669001,-1,"<pre><code>char currentChar,initChar;
initChar=myString[0];

//You should check if exits
currentChar=myString[1];

string noBracketString;
int cont=0;

while(currentChar!=initChar){
   noBracketString+=currentChar;
   cont++;
   currentChar=myString[cont];
}
//String without brackets
return noBracketString;
</code></pre>

<p>Hope Helps!</p>
",3
4669167,4669001,1,"<p>Here is one possible way to do it.  Not necessarily the most efficient and without complete error checking. </p>

<p><strong>Edit</strong> Updated based on comment to another post that makes it sound as if the brackets can be anywhere in the string.  This removes matching all matching brackets as long as there is a matching closing bracket for all of them.  It does <strong>not</strong> remove them all if a closing bracket is not found. The OP needs to do a bit of the homework.  It also does not check for proper balancing of brackets, which it is not clear to me if that is a requirement. </p>

<pre><code>// return 1 if a bracket is found
int RemoveBracket( char *str )
{
    char openbracket[] = {'[', '(', '{', '+', '\0' };
    char closebracket[] = {']', ')', '}', '+', '\0' };
    int start, end, j;
    char match = 0;

    // find open bracket
    start = 0;
    for ( ; str[start] &amp;&amp; !match; start++ ) {
        for ( j = 0; openbracket[j] &amp;&amp; !match; j++ ) {
            if ( str[start] == openbracket[j] ) 
                match = closebracket[j];
            }
        if ( match ) 
            break;
        }

    if ( match == 0 )
        // no open bracket found
        return 0;

    // find closing bracket 
    end = start + 1;
    for ( ; str[end]; end++ ) {
        if ( str[end] == match )
            break;
        }

    if ( !str[end] )
        // no closing bracket found
        return 0;

    // remove them
    memmove( str + start, str + start + 1, end - start - 1 );
    memmove( str + end - 1, str + end + 1, strlen( str + end ) );
    return 1;  // since we found one
}

void RemoveBrackets( char *str )
{
    // remove matching brackets.  
    while ( RemoveBracket(str ))
        ;
}

int main( int argc, char* argv[] )
{
    char str[50];
    strcpy( str, ""a[b(c)de]"" );
    RemoveBrackets( str );
    printf( ""%s\n"", str );
    strcpy( str, ""{not bracketed"" );
    RemoveBrackets( str );
    printf( ""%s\n"", str );
    strcpy( str, ""(paren)s"" );
    RemoveBrackets( str );
    printf( ""%s\n"", str );
    strcpy( str, ""abc+def+{gh}i"" );
    RemoveBrackets( str );
    printf( ""%s\n"", str );
}
</code></pre>
",3
4669227,4669001,0,"<p>Here's my solution:</p>

<pre><code>int main(int argc, char *argv)
{
    char *string = ""abc [def] ghi"";
    char *final = (char *) malloc(strlen(string) + 1);
    int length = 0;
    int count = 0;

    // process every single character of string
    for(count; count &lt;= strlen(string); count++) {
        // check if it has to be copied or not
        if(string[count] != '[' &amp;&amp; string[count] != ']') {
            // if it has, copy it and increase length of final
            final[length] = string[count];
            length += 1;
        }
    }

    // then 'throw away' unused memory
    final = (char *) realloc((void *) final, length);

    printf(""%s\n"", final);
}
</code></pre>

<p>And here's the output:</p>

<pre><code>blackbear@blackbear-laptop:~$ ./prova.out 
abc def ghi
</code></pre>

<p>Then add your I/O code and the type of brackets it has to check via <code>if..else if..else if..</code> or <code>switch(string[count])</code> or again using an array and replace my <code>if</code> with a loop that checks every type of bracket.</p>
",1
4669244,4669001,0,"<p>It is pretty straightforward with a c string.</p>

<pre><code>char s[] = ""{test}"";

size_t t = strlen(s) - 2;
memmove(s, s + 1, t);
s[t] = '\0';
</code></pre>
",1
4664951,4664926,4,"<p><a href=""http://en.wikipedia.org/wiki/Introduction_to_Algorithms"" rel=""nofollow"">Introduction to Algorithms</a> by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein is considered the standard reading on this subject. It's very thorough.</p>
",3
4665115,4664926,9,"<p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201314525"" rel=""noreferrer"" rel=""nofollow noreferrer"">Algorithms in C</a> (Sedgewick) is also good </p>

<p><a href=""http://www.algorist.com/"" rel=""noreferrer"">The Algorithm Design Manual</a> is very readable</p>
",5
4181163,4181152,2,"<p>If the character pointer (string) points to a valid C-string which stores a number in string format, like <code>""123""</code>, simply use the <code>%s</code> format specifier.</p>

<p><code>printf(""%s"", ptr);</code></p>

<p>The <code>%d</code> format specifier is used to print numbers stored as binary signed integers of type <code>int</code>.</p>
",0
4181173,4181152,0,"<p>No, it's generally wrong because a <code>char</code> is only 1 byte while an <code>int</code> is typically 4 bytes. The remaining bytes that you access may be invalid depending on what it points to, and this can undefined behaviour. The correct way to do it would be to get the <code>char</code> value first and then cast it to an <code>int</code>:</p>

<pre><code>(int)*ptr
</code></pre>

<p>Of course, in this case, an explicit cast may not be necessary at all, as the character value will implicitly get promoted to an integer.</p>
",0
4181184,4181152,0,"<p>It would be helpful to know what type the variable ptr has been declared to be.</p>

<p>If it was declared int *ptr; then only a de-reference would be required</p>

<p>ie. printf(""%d"", *ptr);</p>

<p>because ptr is of type int*, and *ptr is therefore of type int, which matches %d</p>

<p>However, I'm guessing ptr was declared void * ptr; in your example, in which case
if you know it actually points to an int, then casting from the generic pointer
type to int* is correct before then de-referencing.</p>

<p>ie. printf(""%d"", *(int * )ptr);</p>
",0
4182902,4182876,26,"<pre><code>#include &lt;stdio.h&gt;

void adx_store_data(const char *filepath, const char *data)
{
    FILE *fp = fopen(filepath, ""ab"");
    if (fp != NULL)
    {
        fputs(data, fp);
        fclose(fp);
    }
}
</code></pre>
",0
4182906,4182876,3,"<p>Something like this should do it:</p>

<pre><code>#include &lt;stdio.h&gt;
: : :
int adxStoreData (char *filepath, char *data) {
    int rc = 0;

    FILE *fOut = fopen (filepath, ""ab+"");
    if (fOut != NULL) {
        if (fputs (data, fOut) != EOF) {
            rc = 1;
        }
        fclose (fOut); // or for the paranoid: if (fclose (fOut) == EOF) rc = 0;
    }

    return rc;
}
</code></pre>

<p>It checks various error conditions such as file I/O problems and returns 1 (true) if okay, 0 (false) otherwise. This is probably something you <em>should</em> be doing, even in PHP.</p>
",3
5109676,5109512,5,"<p>Just try 
<code>scanf("" %c"", &amp;ch);</code>
This is because your scanf is treating the whitespace after the second number as the character to be inserted into ch.</p>
",0
5109546,5109512,1,"<p>If you're just reading in a single character, you could just use <code>getchar()</code> -</p>

<pre><code> c = getchar();
</code></pre>
",0
5109565,5109512,1,"<p>For a single character input, use <code>getchar()</code>.</p>
",0
5109567,5109512,4,"<p>It's getting the newline character from your previous data entry.  Look into using <code>fgets()</code> and <code>sscanf()</code> instead of using <code>scanf()</code> directly.</p>
",0
5109604,5109512,9,"<p>Unlike most conversions, <code>%c</code> does <em>not</em> skip whitespace before converting a character. After the user enters the two numbers, a carriage return/new-line is left in the input buffer waiting to be read -- so that's what the <code>%c</code> reads.</p>
",1
6374377,6374359,0,"<p>I couldn't see the point of doing this. It is not anymore efficient. In fact if it's not optimised out by the compiler it ends up generating more opcodes.</p>
",0
6374389,6374359,6,"<p>This is often how it's done at the hardware level (i.e. inside the ALU).</p>

<p>At the software level, it's generally useless, as it can never be more efficient than the straightfoward subtraction (unless you have a truly bizarre compiler/platform combination).</p>
",2
6374400,6374359,2,"<p>It should be obvious that that is how substraction <strong><em>is</em></strong> done internally, so I'm not sure what you mean by ""being used in the real world"". This is why two's complement was chosen in the first place, because subtraction is just overflowing negative addition.</p>
",2
6374427,6374359,1,"<p>I do not see any reason to do it in your C code. Doing it in software is no faster than subtracting using the minus operator - and is a lot more unclear.</p>

<p>However, that is the way processors execute subtraction. I bet you have seen this code as an example of what hardware does, since it is easier to see how <code>x + (~y + 1)</code> will become a logic circuit.</p>

<p>So... no, you will not use this <em>code</em> in real world, but this <em>operation</em> is executed a lot of times in your processor.</p>
",0
6374440,6374359,2,"<p>The two's complement implementation is done in hardware, so you do not need to implement them like that for builtin datatypes.</p>

<p>If you are making an  n-bit integer arithmetic library, then you need to emulate the integer addition, subtraction, multiplication and division etc operations, in which case such a technique might be implemented to add the n-bit length numbers, but using the carry flag to do so is a better implementation in my opinion.</p>
",7
6374471,6374359,0,"<p>Stuff like this was more common back before CPU's had billions of transistors to play with.  A particular CPU might not implement a specific subtract opcode, and so a compiler (or assembly program) targeting it would have to know that trick.</p>

<p>These manipulations can also help you understand the internal implementation of CPU's.  For example, CPU's division operations are sometimes accomplished by taking the reciprocal of the divisor and multiplying it by the dividend; the reciprocal is the only actual ""division"" being performed.</p>
",1
4917876,4917580,1,"<p>In <code>delete</code> you <code>free</code> the object because, once the pointer is replaced, there will be no way to access it. All good there.</p>

<p>In <code>replace</code> objects are only modified in place. Nothing is created or destroyed so <code>malloc</code> and <code>free</code> are not involved.</p>

<p>Note that these functions may cause a stack overflow error if the list is too long. Also, <code>replace</code> always returns its argument <code>p</code>, so there is no need for it to return anything. Leaving a tail call at the end of the function in place of <code>p-&gt;next = replace( ¡­</code> would (all but) eliminate the stack overflow risk. Recoding <code>delete</code> as a loop would likewise perhaps be somewhat safer.</p>
",1
4426389,4426374,3,"<p>This is actually kind of a weird way to initialize the dictionary.</p>

<p>It is a 2D array of <code>char*</code> (zero terminated (<code>\0</code>) strings).</p>

<p>The dimensions are [rows][columns].</p>

<p>So you have 1 row (determined by the initializer) and 40 columns of strings,</p>

<p>where 8 of them are initialized.</p>

<p>NOTE: Are you sure it isnt char <code>dic[][40]</code> (i.e., a list of strings of max-length 40) ?</p>
",0
4426437,4426374,1,"<p><code>dic</code> is a two-dimensional array of <code>char*</code>; its dimensions are 1 x 40.  </p>

<p>The 40 is given in the declarator and the 1 is implied by the fact that there is only one array in the initializer.  The full initializer would have another set of braces, e.g.,</p>

<pre><code>char *dic[][40] =
{
    {
        ""atlas"",     ""A volume of maps"",
        ""car"",       ""a vehicle"",
        ""telephone"", ""a communication device"",
         """",         """"
    }
};
</code></pre>

<p>With the extra braces, it is clearer that the implicit dimension is 1.</p>

<p>Each element in the two-dimensional array is a pointer of type <code>char*</code>.  The first eight pointers are initialized to point to the eight string literals given in the initializer.  </p>
",1
4426469,4426374,0,"<p>I think that there may be error in book, it seems that they wanted dictionary - 3D array:</p>

<pre><code>
 char *dic[][40]={
            {""atlas"", ""A volume of maps""},
            {""car"", ""a vehicle""},
            {""telephone"", ""a communication device""},
            {"""", """"}
        };
</code></pre>
",0
4426709,4426374,0,"<p>The 40 in your code means the maximum length of characters (or the total length of the string) is 40.</p>

<p>Think <code>char *dic[][40]</code> as an array of pointers. Wherein one pointer points to a maximum of 40 characters.</p>
",1
4541349,4541328,1,"<p><code>(int)pow(M,T)</code> is faster than using your function <code>ipow</code>, because if they are doing the same, then <code>ipow</code> is as fast but with the overhead of calling it (pushing arguments, etc.).</p>

<p>Also, yes, if you <code>#define</code> it in this way, <code>ipow</code> / <code>pow</code> / whatever is called every time; the preprocessor has no idea about what it is doing; it's basically string replacing. Therefore, your constant is simply being replaced by the <strong>text</strong> <code>ipow(M,T)</code> and so it is calculated everytime you need your constant.</p>

<p>Finally, for your case, a solution might be to use a global variable instead of a <code>#define</code> constant for your constant. This way, you can compute it once at the beginning of your program, and then use it later (without any more computations of it).</p>
",6
4541351,4541328,0,"<p>Yes, ipow is getting run every time the constant is mentioned. The C preprocessor is simply replacing all mentions of the constant with what you #define'd it as.</p>

<p>EDIT:</p>

<p>If you really want to compute these integers at compile time, you could try using <a href=""http://en.wikipedia.org/wiki/Template_metaprogramming"" rel=""nofollow"">Template Metaprogramming.</a> This requires C++, however.</p>
",0
4541388,4541328,0,"<p>I don't think this is possible with c pre-possessor , because it doesn't support recursion.</p>

<p>(you can use template meta-programming if you are using c++)</p>
",0
4541395,4541328,0,"<p>I suspect that <code>(int)pow(M,T)</code> is faster than using <code>(int)ipow(M,T)</code> because the compiler has special knowledge of the <code>pow()</code> function (as an intrinsic).  I wouldn't be surprised if given constant arguments that it elides the function call altogether when <code>pow()</code> is used.</p>

<p>However, since it has no special knowledge of <code>ipow()</code>, it doesn't do the same, and ends up actually calling the function.</p>

<p>You should be able to verify whether or not this is happening by looking at the assembly generated in a debugger or by having the compiler create an assembly listing. If that's what's happening, and your <code>ipow()</code> function is nothing more than a call to <code>pow()</code> (casting the result to an <code>int</code>),  you might be able to convince your compiler to perform the same optimization for <code>ipow()</code> by making it an inline function.</p>
",0
4541429,4541328,0,"<p>Your ipow isn't faster since its just a simple call to a function. 
Also I'm aware of compiler optimisation for standard C library routines and math functions.</p>

<p>Most possible the compiler is capable of determining the constexpr parameters and calculate the value of the <code>#define</code> at compile time.
Internally they will be replaced to some thing like this where the exponent is constant.</p>

<pre><code>#define pow2(x) ( (x) * (x) )
#define pow3(x) ( (x) * (x) * (x) )
#define pow4(x) ( pow2(x) * pow2(x) )
#define pow5(x) ( pow4(x) * (x) )
#define pow6(x) ( pow3(x) * pow3(x) )
...
</code></pre>

<p>The only work around is to use C++ metta programming to get better run time performance.</p>

<pre><code>template&lt;class T, T base, T exp&gt;
struct ipow
{
    static const T value = base * ipow&lt;T, base, exp - 1&gt;::value;
};

template&lt;class T, T base&gt;
struct ipow&lt;T, base, 0&gt;
{
    static const T value = 1;
};
</code></pre>

<p>you would use the above struct as follows:</p>

<pre><code>ipow&lt;size_t, M, T&gt;::value
</code></pre>
",0
4541617,4541328,0,"<p>The C preprocessor will not evaluate a function call to a C function such as ipow or pow at compile time, it merely does text replacement.</p>

<p>The preprocessor does have a concept of function-like macros, however these are not so much 'evaluated' as text replaced. It would be temping to think you could write a recursive function-like macro to self-multiply a constant to raise it to a power, but in fact you can't - due to the non-evaluation of macro bodies, you won't actually get continually recursive calculation when the macro refers to itself.</p>

<hr>

<p>For your shift operation, a #define involving constants and the shift operator will get text replaced by the preprocessor, but the constant expression will get evaluated during compilation, so this is efficient.  In fact it's very common in hardware interfaces, ie #define UART_RXD_READY ( 1 &lt;&lt; 11 ) or something like that</p>
",0
4541880,4541328,1,"<p>You don't need C++ to do metaprogramming. If you have a C99 compatible C compiler and preprocessor you can use <a href=""http://p99.gforge.inira.fr"" rel=""nofollow"">P99</a> with something like the following</p>

<pre><code>#include ""p99_for.h""
#define P00_POW(NAME, I, REC, Y) (NAME) * (REC)
#define IPOW(N, X) (P99_FOR(X, N, P00_POW, P00_NAM, P99_REP(N,)))
</code></pre>

<p>For example <code>IPOW(4, A)</code> is then expanded to <code>((A) * ((A) * ((A) * (A))))</code>. The only things that you should watch are</p>

<ul>
<li><code>N</code> must be (or expand to) a plain decimal constant with no suffix such as U or L</li>
<li><code>X</code> should not have side effects
since it is evaluated several times</li>
</ul>
",0
4367793,4367745,28,"<pre><code>if (a &gt; c)
   swap(a, c);

if (a &gt; b)
   swap(a, b);

//Now the smallest element is the 1st one. Just check the 2nd and 3rd

if (b &gt; c)
   swap(b, c);
</code></pre>

<blockquote>
  <p>Note: Swap changes the values of two
  variables.</p>
</blockquote>
",2
4367794,4367745,11,"<p>Call the three variables <code>x</code>, <code>y</code>, and <code>z</code>, then:</p>

<pre><code>if (x &gt; y) swap(x, y);
if (y &gt; z) swap(y, z)
if (x &gt; y) swap(x, y);
</code></pre>

<p>Writing the <code>swap</code> function is left as an exercise for the reader. Hint: you may have to use pointers.</p>
",0
4367805,4367745,1,"<p>Yes, there is a much better way, but you need to use loops and arrays.</p>

<p>Probably, for an introductory class, your answer is the answer they are looking for.  </p>

<p>There are ways to get looping with for/while (recursion, goto, etc).  And ways to get something like an array without indexing (<code>int *ptr = malloc (3 * sizeof(int))</code>, and then index with <code>*(ptr+index)</code>).  But, I find it hard to think that that's what they want.</p>
",1
4367812,4367745,4,"<p>Hint: if you have 3 numbers, a, b, and c, min(a, min(b, c)) is the smallest, max(a, max(b, c)) is the largest, and given the smallest and largest numbers, it should be easy to find the third one.</p>
",0
4370950,4367745,10,"<pre><code>#include &lt;stdio.h&gt;
#define min(a,b) ((a)&lt;(b)?(a):(b))
#define max(a,b) ((a)&gt;(b)?(a):(b))
int main(){
   int a, b, c;
   int hi;
   int lo;

   printf(""Enter No. 1: "");
   scanf(""%d"", &amp;a);
   printf(""Enter No. 2: "");
   scanf(""%d"", &amp;b);         
   printf(""Enter No. 3: "");
   scanf(""%d"", &amp;c);

   lo = min(min(a, b), c);
   hi = max(max(a, b), c);
   printf(""LOWEST %d\n"", lo);
   printf(""MIDDLE %d\n"", a+b+c-lo-hi);
   printf(""HIGHEST %d\n"", hi);  

   getchar(); 
}    
</code></pre>
",3
4331053,4331040,7,"<p>C does not have references. You need to compile as C++ for those.</p>
",1
4331221,4331040,1,"<p>You also might want to consider using SSE intrinsics instead of what it looks like you're doing.</p>
",0
4331061,4331040,4,"<p>C doesn't have references. You should use a pointer instead, or use C++.</p>

<pre><code>iVector4 SSEadd(iVector4 *v1, iVector4 *v2)
</code></pre>

<p>Now the next question - can you return objects in C? My C is rusty. If that's the not case, you'd need:</p>

<pre><code>void  SSEadd(iVector4 *v1, iVector4 *v2, iVector4 *vOut)
</code></pre>

<p>EDIT: As Justin pointed out, it is possible, so you don't need to go that route. You still could though - depending on the circumstances, it could be more performant.</p>
",3
4331066,4331040,1,"<p>I think your function definition should actually be:</p>

<p><code>iVector4 SSEadd(iVector4 *v1, iVector4 *v2);</code></p>
",0
6604144,6604121,3,"<p>It won't work, doesn't the compiler return an error if you do? ( or atleast a warning.. )</p>

<p>Just use ++i or i++</p>
",0
6604154,6604121,2,"<p>Using <code>i+</code> instead of <code>i++</code> should not work. As I think you know, <code>i++</code> increases the value of <code>i</code> by one. When the compiler sees <code>i+</code>, it is expecting something after the <code>+</code>, which causes it to not compile.</p>
",0
6604208,6604121,1,"<p>The line in question is not valid C</p>

<blockquote>
  <p>for(i = 0; i&lt;10; i+)</p>
</blockquote>

<p>Some valid, equivalent (between themselves) options are</p>

<pre><code>for(i = 0; i &lt; 10; i++)
for(i = 0; i &lt; 10; ++i)
for(i = 0; i &lt; 10; i += 1)
for(i = 0; i &lt; 10; ) { /*...*/ i++; }
</code></pre>
",0
5582115,5581729,1,"<p>If I understand correctly, you are wanting to create a C file that you can compile to write binary data to a file when it is executed. Here is some code to do that:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  FILE *fp1=fopen(""source.dll"", ""rb"");
  FILE *fp2=fopen(""dest.c"", ""w"");

  if ((fp1 == NULL) || (fp2 == NULL))
  {
    printf(""Unable to open file\n"");
    return 1;
  }

  fputs(""#include &lt;stdio.h&gt;\n"", fp2);
  fputs(""int main(void)\n"", fp2);
  fputs(""{\n"", fp2);
  fputs(""  unsigned char file_data[] = {\n    "", fp2);

  while(!feof(fp1))
  {
    int len;
    int i;
    unsigned char buf[4096];
    len = fread(buf, 1, 4096, fp1);
    if (len &lt;= 0)
    {
      break;
    }

    for (i = 0; i &lt; len; i++)
    {
      fprintf(fp2,   ""0x%02x, "", buf[i]);
    }
    fprintf(fp2, ""\n    "");
  }
  fclose(fp1);
  fputs(""  };\n"", fp2);
  fputs(""  FILE *fh = fopen(\""file.bin\"", \""wb\"");\n"", fp2);
  fputs(""  if (fh == NULL) { perror(\""fopen\""); return 1; }\n"", fp2);
  fputs(""  if (fwrite(file_data, 1, sizeof(file_data), fh) &lt; 1)\n"", fp2);
  fputs(""    { perror(\""fwrite\""); return 1; }\n"", fp2);
  fputs(""  if (fclose(fh) != 0) { perror(\""fclose\""); return 1; }\n"", fp2);
  fputs(""  return 0;\n"", fp2);
  fputs(""}\n"", fp2);
  fclose(fp2);
  return 0;
}
</code></pre>
",1
5581900,5581729,-1,"<p>Binary files are stored in a specific <em>format</em>. Only the intended program that loads binary files knows the format and <em>interprets</em> the file content accordingly.</p>

<p>For example, suppose you want to write two integers in a binary file. Each integer will take 4 bytes, so the binary file will be of 8 bytes in size. Let's say, the numbers are 16 and 32 and also assume that everything is little endian.</p>

<p>The file content will look like as follows in hexadecimal:</p>

<pre><code>1000000020000000
</code></pre>

<p>Now, how the file will look like if they are read in ASCII mode (like openning them in Notepad)? The data will look gibberish.</p>

<p>The intended program which is supposed to read the binary files knows that there are two integers there, each having 4 bytes long. So the program will read first 4 bytes from the file and interpret them as an integer. The program will do the same for next 4 bytes.</p>

<p>DLLs and EXEs are written in specific format as well and you need to know first what is the format. Then you can extract the data from them.</p>
",1
5581920,5581729,0,"<p>Something like this should work:</p>

<pre><code>FILE *fin=fopen(""source.dll"", ""r"");
FILE *fout=fopen(""source_dll.h"", ""w"");

int size=0;
fprintf(fout,""char *source_dll_bytes={"");

while(!feof(fin))
  fprintf(fout, ""%s%d"", size++==0?"""":"","", fgetc(fin));

fprintf(fout, ""};\nint source_dll_size=%d;"", size);

fclose(fout);
fclose(fin);
</code></pre>

<p>Then you just <code>#include ""source_dll.h""</code> and use <code>source_dll_bytes</code> and <code>source_dll_size</code> to print it out at runtime.</p>

<p>Edit: Just in case it wasn't clear, <code>fprintf</code> <strong>will not work</strong> to write binary data to a file on disk. Use <code>fwrite</code> instead.</p>
",0
4528324,4528317,6,"<p>Since its a member of the structure you have to qualify it:</p>

<pre><code>sum1 = var.fp( 2, 4 );
</code></pre>
",0
4528327,4528317,2,"<p>Have you tried changing:</p>

<blockquote>
  <p>sum1=fp(2,4);</p>
</blockquote>

<p>To:</p>

<blockquote>
  <p>sum1=var.fp(2,4);</p>
</blockquote>

<p>?</p>
",1
4528339,4528317,6,"<p>You meant to say <code>sum1 = var.fp(...)</code> or <code>sum1 = (*var.fp)(...)</code> but you typed <code>fp(...)</code>. C implicitly defined an external fp() for you to call. The compiler has to do this in order to compile legacy C code.</p>

<p>Use <code>cc -Wall ...</code> to generate errors for missing forward declarations.</p>
",0
4731070,4700407,1,"<p>Here is how ya do it 50x faster than grandpa mutex (we did tests on this sort of thing).  Use gcc atomic operations. You could also use linux atomic operations if your release included them.</p>

<pre><code>typedef union _foo {
  struct {
    unsigned int a:1,
                 b:6,
                 q:2;
  } Data;
  unsigned int n32;
} TFoo;

TFoo _GlobalFoo;

SomeFuncThatChangesFoo_A(int fNewA)
{
TFoo Old, New;

  while(1) {
    // get a copy of the current state
    Old.n32 = _GlobalFoo.n32;
    New.n32 = Old.n32;
    New.Data.a = fNewA;
    // compare and swap is the atomic operation.
    // if _GlobalFoo hasn't changed since we copied it to ""Old"", then change _GlobalFoo to ""New"".
    // __sync_bool_compare_and_swap works on basic types (8 bit, 16 bit, 32 bit, 64 bit, 128 bit
    // depending upon architecture), which is why there is a union overlaying the 32 bit n32 over 
    // the actual data that the program uses, Data.
    if (__sync_bool_compare_and_swap(_GlobalFoo.n32, Old.n32, New.n32))
      break; // successfully changed 
    // if we get here, the global was changed by another thread, so we just loop back, get the new value
    // and try again.
  } // concurrency loop
}
</code></pre>

<p>Astute threaders might think that the line ""Old.n32 = _GlobalFoo.n32;"" could copy garbage in a race if the compiler chose a non-atomic way to perform the copy.  However, __sync_bool_compare_and_swap would just fail because of the a bad copy of the current state, so there would be no harm done.</p>

<p>cheers.</p>
",0
5134789,5134779,8,"<p>You are answering the question yourself. The range of a <code>unsigned short</code> is 0-65535, so 70000 doesn't fit into it (2 bytes), use a datatype with 4 bytes instead (<code>unsigned int</code> should work, you can check the size with <code>sizeof</code>).</p>
",3
5134797,5134779,12,"<p>As <a href=""https://stackoverflow.com/questions/5134779/printing-unsigned-short-values/5134789#5134789"">schnaader said</a>, you may be running into an overflow problem.</p>

<p>But answering your <code>printf</code> question about outputting unsigned values, you want the <code>u</code> modifier (for ""unsigned""). In this case, as Jens points out below, you want <code>%hu</code>:</p>

<pre><code>printf(""a: %hu\n"", a);
</code></pre>

<p>...although just <code>%u</code> (<code>unsigned int</code>, rather than <code>unsigned short</code>) would probably work as well, because the <code>short</code> will get promoted to <code>int</code> when it gets pushed on the stack for <code>printf</code>.</p>

<p>But again, that's only if the value 70000 will fit in an <code>unsigned short</code> on your platform.</p>
",2
4518607,4517893,0,"<p>From what I understand the array should be immutable since you want to find the positions as well. So if I am correct you shouldn't sort the array, unless you use a new array of size 10, store the sorted array there, and compare and find between the two arrays etc.</p>

<p>If you want to find it without sorting you could do that :</p>

<p>Find the First biggest number and its position
Find the Second biggest number (which is smaller from the First biggest number) and its position
Find the third biggest number (which is smaller than the Second biggest number) ...</p>

<p>etc....</p>

<p>This can be done and it's not that hard.</p>
",0
4517943,4517893,6,"<p>Is the array guaranteed to have 10 elements? Are they guaranteed to be positive? If so, you can multiply each element by 10 and add the index to it, then sort the array, then take the 5 largest elements; divide by 10 (integer division) to get the original number, and take % 10 to get the original position.</p>

<p>For a more general solution, you could create a struct to hold the value and original index, then sort the array of structs based on value.</p>

<p>Use any basic sorting algorithm.</p>
",1
4518007,4517893,0,"<p>You just extend search algorithm for the largest number to search for n = 5 largest numbers.
If you use binary search, what should be done first with an array?  Well, if you answer this question, you'll probably won't need to binary search it at all ;)</p>
",0
5553536,5552976,1,"<p>Didn't have time to delve into your code too deeply but here are a few
things.</p>

<p>First thing you should do is replace that hardcoded <code>10</code> with a
<code>#define</code> constant.</p>

<p>It should not come as a surprise that you didn't set the value of <code>d</code>,
hence all the spaces. Also, why make <code>d</code> global?</p>

<p>Your print loop should traverse the entire list so the part in
brackets will always be the same size.</p>
",3
5553545,5552976,2,"<p>A couple things I notice:</p>

<ol>
<li>If level is going to be a modular variable instead of one passed in to the quick sort routine, it's unlikely to ever go down. Consider incorporating it into the signature of your quick sort function.</li>
<li>You start at <code>i = left</code> - this won't print your whole original underlying array. Consider always going over the array and printing them all, checking if you're in the current array or not.</li>
<li>You make a FORWARD declaration <code>void swap(int v[], int i, int j);</code> inside your quicksort routine. What's up with that? <strong>Note:</strong> apparently it's from K&amp;R. As a matter of personal taste, I'm not the biggest fan of the notation, but you could do worse than following K&amp;R, eh?</li>
</ol>
",5
4526105,4525778,0,"<p>I don't really know what you are trying to do but when running your program I am getting a <code>Floating Point Exception</code> and thats because of the <code>number[mul1_count] % prime_array[prime1_count]</code> when <code>prime_array[prime1_count]</code> is <code>0</code></p>

<p>Wrap your inner <code>for</code> loop with an <code>if(prime_array[prime1_count] != 0)</code></p>

<pre><code>for(prime1_count=0;prime1_count&lt;2339;prime1_count++)
{
       if(prime_array[prime1_count] != 0)
       {
           printf(""\nprime number used is:%d"",prime_array[prime1_count]);
           for(mul1_count=0;mul1_count&lt;7096;mul1_count++)
           {
              printf(""\n%d\t"",number[mul1_count] % prime_array[prime1_count]);
           }
       }
}
</code></pre>

<p>It would be good to also try to explain what you want to do, what you expect, what you get, etc...</p>

<p><strong>Edit :</strong> 
Also, as a sidenote. You should slightly change the loop which calculates the prime numbers. The reason is that you do not keep track of how many prime numbers you calculated. and then you
    <code>for(prime1_count=0;prime1_count&lt;2339;prime1_count++)</code>
iterate through the whole <code>prime_array[]</code>. </p>

<p>Imagine the situation where you only calculated 5 prime numbers, this means that the remaining array is left with whatever. No reason to do the extra calculation, leaving asside that the prime_array is not initialized to zero nowhere in the code which means it (afaik) contains garbage value, in the indeces where no prime number was allocated with your algorithm. This means that the 
<code>if(prime_array[prime1_count] != 0)</code> 
will probably fail if you think that garbage value exist there.</p>

<p>Either initialize the <code>prime_array[2339] = { 0 };</code> </p>

<p><strong>OR</strong></p>

<p>I would do that : </p>

<pre><code>int number_of_primes=0;
for(n=lim_low+1; n&lt;lim_up; n++)
{
    prime = 1;
    for(i=2; i&lt;n; i++)
        if(n%i == 0)
        {
            prime = 0;
            break;
        }
    if(prime)
    {
        if(number_of_primes &lt; 2338)
        {
            prime_array[number_of_primes]=n;
            number_of_primes++;
        }else
        {
            break;
        }
    }
}
</code></pre>

<p>....</p>

<pre><code>for(prime1_count=0 ; prime1_count &lt; number_of_primes+1 ; prime1_count++)
{
    printf(""\nprime number used is:%d"",prime_array[prime1_count]);
    for(mul1_count=0;mul1_count&lt;7096;mul1_count++)
    {
        printf(""\n%d\t"",number[mul1_count] % prime_array[prime1_count]);
    }
}
</code></pre>
",0
4544578,4544383,0,"<p>I would place the <code>free()</code> call in the module which did the corresponding <code>malloc()</code>/<code>calloc()</code> call.  In your case, ""A.c"" provided a function to allocate memory for a <code>Head</code> object.  There should be a corresponding function to delete the memory that was previously allocated also in ""A.c"".</p>

<p>It does not make sense to me to free the memory given to me from non-standard libraries (i.e., third party code) when I'm the consumer of that library.  There may be other memory allocated to that object that I don't necessarily have access to, especially for <a href=""http://en.wikipedia.org/wiki/Opaque_data_type"" rel=""nofollow"">opaque data types</a>.</p>

<p>e.g.,</p>

<p>MyType.c:</p>

<pre><code>typedef struct _MyType
{
    char *name; /* fields are ""private"" */
    ...
} *MyType; /* opaque type ""MyType"" */

MyType MyType_create(void)
{
    MyType ret = malloc(sizeof *ret);
    ret-&gt;name = malloc(...);
    return ret;
}

void MyType_delete(MyType obj)
{
    free(obj-&gt;name);
    free(obj);
}
</code></pre>

<p>Program.c:</p>

<pre><code>typedef void *MyType;

int main(void)
{
    MyType obj1 = MyType_create(); /* we have an ""instance"" of MyType */
    MyType_delete(obj1);           /* delete it */

    MyType obj2 = MyType_create(); /* we have an ""instance"" of MyType */
    free(obj2);  /* uh oh, what happened to the memory allocated for obj2-&gt;name? leak */
}
</code></pre>

<p>See also another <a href=""http://en.wikipedia.org/wiki/Opaque_pointer#C"" rel=""nofollow"">example</a>.</p>
",0
4544391,4544383,0,"<p><code>free</code> gets called when you no longer want or need the allocated memory, i.e. when you are done with the TreeHead and TreeNode. It would be silly to free the memory in <code>init()</code>, because you haven't done anything with it yet.</p>
",0
4544401,4544383,0,"<p>There's no hard and fast rule here except that you can call free() before init() returns because then the return pointer will be invalid.</p>

<p>This is a great example of how C++ is so much better for this kind of thing. If you have to use C, then you could call free() from either location, depending on what seems to make the best sense.</p>
",0
4544407,4544383,3,"<p>I would define a function in A.c:</p>

<pre><code>void freeHead(Head head){
   free(head-&gt;Root);
   free(head);
   return;
}
</code></pre>

<p>Then call it in appropriate places in B.c:</p>

<pre><code>freeHead(head);
</code></pre>
",1
6274617,5033027,0,"<p>I think <a href=""http://mathgl.sf.net"" rel=""nofollow"">MathGL</a> can help you. It is GPL plotting library which can create a window with yours plot without knowledge of any widgets library. Also it have nice graphics for matrices and 3-ranged data.</p>
",0
5189916,5189908,8,"<p>The output of this program could be anything because you overrun the buffer <code>str</code> and get undefined behavior.  In fact, the program might not output anything, it might crash, or it might do something far worse.</p>
",0
5189929,5189908,1,"<p>The snippet invokes undefined behaviour. The result can be anything, from crashing to unexpected output.</p>
",0
5189936,5189908,1,"<p>As other have mentioned, this is undefined behavior since it would depend on the contents of the memory located aftr wherever <code>str</code> is allocated. It will start with <code>ABCDE</code> but will run off into a random collection of bytes converted to chars or a crash.</p>
",0
5191509,5189908,0,"<p>The output is undefined. In linux, I am getting the output D because I think the data stored in stack from bottom to top. So, ch is stored at the bottom, and str is stored just above it. now you are overwriting str with two bytes extra, which is resulting in corrupting ch variable, which may result in displaying the D as output. Again, this depends upon compiler and operating system you are running. </p>
",0
4149799,4149338,1,"<p>You seem to have solved your immediate problem, but your program is crawling with more subtle problems.  I have taken the liberty of rewriting it for you.  There is a reason for every change I made, even the ones that seem trivial.  Please read it carefully and consider why I did what I did.  I am happy to answer <em>specific</em> questions about the changes.</p>

<pre><code>/* factor.c - produce the prime factorization of a number.
   Uses the Sieve of Eratosthenes.  */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

static unsigned char *
compute_sieve(unsigned long root)
{
    unsigned char *sieve = malloc(root + 1);
    unsigned long i, j;

    /* all numbers are prime till proven otherwise */
    memset(sieve, 1, root + 1);

    /* 0 and 1 are not prime */
    sieve[0] = 0;
    sieve[1] = 0;

    for (i = 2; i &lt;= root; i++) {
        if (!sieve[i])
            continue;
        for (j = 2; i*j &lt;= root; j++)
            sieve[i*j] = 0;
    }

    return sieve;
}

static unsigned long *
compute_factors(unsigned long number, const unsigned char *sieve,
                unsigned long root, int *isPrime)
{
    unsigned long i;
    unsigned long *factors = calloc(root + 1, sizeof(unsigned long));

    *isPrime = 1;

    /* trial division by each prime in turn, starting with 2.  */
    for (i = 2; i &lt;= root; i++) {
        if (!sieve[i])
            continue;
        while (number % i == 0) {
            *isPrime = 0;
            number /= i;
            factors[i]++;
        }
    }

    return factors;
}

static void
factor(unsigned long number)
{
    unsigned long root, i;
    unsigned char *sieve;
    unsigned long *factors;
    int isPrime;

    /* weed out base cases */
    if (number &lt;= 3) {
        printf("" %lu\n"", number);
        return;
    }

    /* sieve needs to go up to the square root of NUMBER */
    root = (unsigned long) floor(sqrt(number));
    sieve = compute_sieve(root);
    factors = compute_factors(number, sieve, root, &amp;isPrime);

    if (isPrime)
        printf("" %lu\n"", number);
    else {
        for (i = 2; i &lt;= root; i++) {
            while (factors[i]) {
                printf("" %lu"", i);
                number /= i;
                factors[i]--;
            }
        }
        if (number &gt; 1)
          printf("" %lu"", number);
        putchar('\n');
    }

    free(sieve);
    free(factors);
}

static void
usage(char **argv)
{
    fprintf(stderr, ""usage: %s NUMBER\n""
            ""NUMBER must be a non-negative integer\n"",
            argv[0]);
}

int
main(int argc, char **argv)
{
    unsigned long number;
    char *endptr;

    if (argc != 2) {
        usage(argv);
        return 1;
    }

    number = strtoul(argv[1], &amp;endptr, 10);
    if (endptr == argv[1] || *endptr != '\0') {
        usage(argv);
        return 1;
    }

    factor(number);
    return 0;
}
</code></pre>
",2
4149376,4149338,3,"<p>I can't tell which line is the correct line, but what that means is that you're using the indexing operator ""[]"" on something that isn't the correct type.</p>

<pre><code>blah[foo]
</code></pre>

<p>blah must be of type array, or pointer.</p>

<p>Edit: Your code:</p>

<pre><code>int z_array;
.....
      z_array[length_z_array]
.....
   printf(""%d\n"", z_array[j]);
</code></pre>

<p>z_array is declared as an int, int's can't be indexed</p>
",0
4149379,4149338,4,"<p><code>z_array</code> is declared to be type <code>int</code>. <code>int</code> is neither an array nor a pointer :)</p>

<p>I'm guessing you meant to make it an <code>int*</code>.</p>
",0
4149384,4149338,2,"<p><code>z_array</code> is just declared as an <code>int</code>, and you are trying to index it using square brackets like an array.</p>
",0
4149386,4149338,2,"<p>z_array is not an array of integers it is a single integer. You cannot subsript it like z_array[var]. To declare an array you can do int z_array[100] for example.</p>
",0
4149402,4149338,1,"<pre><code>int z_array;
z_array[length_z_array]=primes_fac[i];
printf(""%d\n"", z_array[j]);
</code></pre>

<p><code>z_array</code> is not an <code>int[]</code> or an <code>int*</code>, thus <code>z_array[i]</code> is nonsensical.</p>

<p>I suspect you may have intended to write</p>

<pre><code>int *z_array = malloc((length_primes_fac + 1) * sizeof(int));
...
free(z_array);
</code></pre>

<p>or something similar.  I haven't dug into the surrounding code to determine if that's realy the correct size or not.</p>
",0
5617834,5617699,2,"<p>The name of your structure is <code>struct blockPropStruct</code>.  Note that in C, you can't just remove the <code>struct</code> part, it's part of the type's name.  You can define a type for your structure so you have less typing, but I think it's better to remember to use your structures as <code>struct blockPropStruct</code>.</p>

<p>Based on the error messages you have added in your comments:</p>

<blockquote>
  <p>error C2036: 'blockPropStruct *' : unknown size<br>
  error C2027: use of undefined type 'blockPropStruct'</p>
</blockquote>

<p>You are attempting to get the size <code>sizeof(blockPropStruct)</code> in your <code>malloc()</code> call since <code>blockPropStruct</code> is not a valid identifier so you are attempting to get the size of an undefined type.</p>

<p>To define your type:</p>

<pre><code>typedef struct blockPropStruct blockPropStruct;
</code></pre>

<p>Now you can refer to your structure type as <code>blockPropStruct</code> or <code>struct blockPropStruct</code>.</p>
",5
5617836,5617699,2,"<p>It would appear that you have omitted the declaration of the struct type in the file which declares the extern variable.</p>
",9
5617898,5617699,0,"<p>You need to give a name with 'typedef' and point to it.</p>
",0
5617916,5617699,0,"<pre><code>newBlock = (blockPropStruct*)malloc(maxNum*sizeof(blockPropStruct));
</code></pre>

<p>To actually for the above statement to work, the current source file should see the size of structure. So, check whether you have included the corresponding header file.</p>

<hr>

<pre><code>extern struct blockPropStruct *newBlock;
</code></pre>

<p>And when you are doing -</p>

<pre><code>newBlock[i].left_up.x=mark1[i];
</code></pre>

<p>You should bring the definition of the <code>blockPropStruct</code> to the current compilation unit to be able to use it members. So, try -</p>

<pre><code>#include ""blockPropStruct.h""
extern struct blockPropStruct *newBlock;  // This says to use else where 
                                          // initialized newBlock
// ....
newBlock[i].left_up.x=mark1[i];           // And to do this, bring the definition
                                          // to this file scope
</code></pre>

<p>And there is no need to explicitly typecast <code>malloc</code>.</p>
",1
5546882,5546867,1,"<p>It's a variable which is a <em>pointer</em> to a function returning nothing, which takes two arguments of type ""pointer to char"". The function pointer is named ""a"".</p>
",0
5546883,5546867,2,"<p>This is declaration of a variable named <code>a</code>; it is a pointer to a function that takes two <code>char*</code> parameters and does not return anything.  You will need to assign an actual function to <code>a</code> before calling it.</p>
",1
5546884,5546867,3,"<p>It is a function pointer. Example:</p>

<pre><code>void someFunction(char* param1, char* param2) {
   // ...
}

int main(int argc, char* argv[]) {
   char arg1[] = ""Hello"";
   char arg2[] = ""World"";
   void (*a)(char*, char*) = &amp;someFunction;
   a(arg1, arg2);
   return 0;
}
</code></pre>
",0
5546888,5546867,7,"<p>This is a function <em>pointer</em> named <code>a</code>.  The function signature of <code>a</code> is a function that returns void and takes two <code>char *</code> arguments.</p>

<p>See <a href=""http://www.newty.de/fpt/fpt.html#defi"">Function Pointer Tutorials</a> for more information on function pointers.</p>
",0
5546893,5546867,3,"<p>It's a pointer to a function, which takes 2x char pointers &amp; returns void (see <a href=""http://cdecl.ridiculousfish.com/?q=void%20%20%28%2aa%29%28char%2a,%20char%2a%29;"" rel=""nofollow"">cdecl.org</a>)</p>
",0
5546895,5546867,1,"<p>No.</p>

<p>It is a pointer to a function that takes two strings and returns nothing.</p>
",0
5100228,5100201,6,"<p>One way is to used  <code>system()</code> call ...</p>

<pre><code>system(""cl generated_file.c -o gen_exe"") ;
system(""./gen.exe"");
</code></pre>

<p>or</p>

<pre><code>system(""gcc generated_file.c -o gen.exe"");
system(""./gen.exe"");
</code></pre>

<p>Or you use a simle batch or script or makefile to do this</p>
",2
5100230,5100201,1,"<p>You'd need to embed a compiler into your app(such as <a href=""http://bellard.org/tcc/"" rel=""nofollow"">libtcc</a> or <a href=""http://www.cs.virginia.edu/~lcc-win32/"" rel=""nofollow"">lcc</a>) or invoke one via a command line, but that requires detecting what the user has installed or at the very least including extra binaries with your app </p>
",0
5101855,5100201,2,"<p>I'll make two notes in one:</p>

<p>First, if you have one program that generates source code, why not use the normal build system to handle this for you? For a Make-based build system it could look something like this:</p>

<pre><code>second_program : second.c
    $(CC) $(CFLAGS) -o $@ $&lt;

second.c : first_program
    ./first_program $(GENERATION_OPTIONS) &gt; $@

first_program : $(LIST_OF_SOURCE_FILES)
    $(CC) $(CFLAGS) -o $@ $&lt;
</code></pre>

<p>This would be more in line with the Unix philosophy than having the first program run an external command, which is always nice.</p>

<p>Second, do you want the second program to be generated and executed dynamically? I.e. will the resulting code depend on some dynamic state of the first program, and could the output from the second program be relevant to the first? 
If so, perhaps you should take a look at what you can do with a library to run some script language like <a href=""http://www.lua.org"" rel=""nofollow"">LUA</a> or <a href=""http://www.mozilla.org/js/spidermonkey/"" rel=""nofollow"">ECMAScript</a>. 
(This is perhaps a bit too advanced for the case you are asking about, but it's always nice to know what options there are.)</p>
",0
4242900,4242865,1,"<p>Pseudo code for helping you precisely is not great
Also can you define a bit better your question ? you don't really say what is going wrong</p>

<p>but here is my guess</p>

<p>your test is i ==0 which means as soon as your user inputs the right word your exiting your loop...</p>

<p>I would guess your looking for something like </p>

<pre><code>exit_condition = 0;

while (exit_condition == 0)
{

   read keyboard entry

    if(condition to exit loop)
    {

        exit_condition = 1;
        printf(""correct"")
    }
    else
    {
        printf(""try again"")
    }

}
</code></pre>

<p>Concerning the tests I think you need to read up  bit on input and tests</p>

<p>try this</p>

<p><a href=""http://www.arachnoid.com/cpptutor/student1.html"" rel=""nofollow"">http://www.arachnoid.com/cpptutor/student1.html</a></p>
",3
4243075,4242865,2,"<p>you are using <code>scanf()</code> wrongly instead of <code>scanf(""%d"",string)</code> use <code>scanf(""%s"",string)</code> as %d is used for decimal input and %s is used for string input</p>
",0
4243127,4242865,1,"<ol>
<li>scanf is incorrect for getting input string. It should be scanf(""%s"", string) as pointed out by others</li>
<li>String comparison cannot be done by using == in 'C'. It will only compare the address of two strings which will fail. Use 'strncmp' function instead.</li>
</ol>
",0
5488084,5486675,0,"<p>Just re set match to 1 and count to zero at the start of the loop and allocate sufficient memory for tempStr* :</p>

<p>int endPos = strlen(string2)-1;
char* tempStr = (char*)malloc((size_t)(endPos+1));</p>

<p>while (endPos &lt;= strlength(string1)-1)
   {
      count=0;
      match=1; 
      ...</p>
",0
5487099,5486675,2,"<p>2 points:</p>

<ul>
<li>you need to reinitialie <code>count</code> to zero before the inner <code>while</code></li>
<li>you need to reinitialise <code>match</code> to 1 before the inner <code>while</code></li>
</ul>

<p>If you don't do this, then if the first iteration doesn't match, match will never be 1 again, and count will have you checking memory you don't know the content of.</p>

<p>This is in addition to the issue noted by paxdiablo.</p>
",3
5486728,5486675,5,"<p>I have only one point to raise.</p>

<p>How do you think that <code>tempStr</code> is getting set to anything useful?</p>

<p>The line <code>char *tempStr;</code> sets it to whatever happened to be on the stack at that time while C, with its lack of ""proper"" pass by reference, cannot change it with the call:</p>

<pre><code>strmid(string1, begPos, endPos, tempStr);
</code></pre>

<p>In order to change the pointer, you would have to pass in <code>&amp;tempStr</code> rather than <code>tempStr</code>.</p>

<p>So, it appears to me that your <code>tempStr</code> is not pointing to anything usable.</p>

<hr>

<p>And, based on your added <code>strmid</code> function, this program is definitely in the ""undefined behaviour"" class. A quick fix, though kludgy, would be to change:</p>

<pre><code>char *tempStr;
</code></pre>

<p>to:</p>

<pre><code>char tempStr[1000];
</code></pre>

<p>That might not fix <em>all</em> your problems (and it'll introduce a potential for buffer overflow) but it'll at least give you a well-defined program.</p>
",2
5486754,5486675,0,"<p>Look at this code:</p>

<pre><code>   if (tempStr[count] == string2[count]) {
       if (count &lt; strlength(string2)) count++;
      else break; }
   else match = 0;
</code></pre>

<p>Can you see how match will never get set to zero?</p>
",4
5486786,5486675,0,"<p>if ( match == 1 ) return begPos;
else { begPos++;
       endPos++; }</p>

<p>match will always be 1 for it to get here </p>
",1
7194449,7194404,3,"<p>On Win32 you can use GetPerformanceCounter.</p>

<p>I've used it to implement both hi-res timing and GUIDs on Windows.</p>

<p><a href=""http://msdn.microsoft.com/en-us/magazine/cc163996.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/magazine/cc163996.aspx</a></p>

<p>Combined with GetSystemTimeAsFileTime() you should have all you need.</p>
",3
7194453,7194404,0,"<p>See <a href=""http://msdn.microsoft.com/en-us/library/ms724408"" rel=""nofollow""><code>GetTickCount</code></a>.</p>
",2
3123851,3123484,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

/* Written by kaizer.se */
void randword(char *buf, size_t len)
{
  char alphabet[] = ""abcdefghijklmnopqrstuvxyz"";
  size_t i;

  for (i = 0; i &lt; len; i++) {
    size_t idx = ((float)rand()/RAND_MAX) * (sizeof(alphabet) -1);
    buf[i] = alphabet[idx];
  }
  buf[len] = '\0';
}

int main(void) {
  char buf[1024];

  srand(time(NULL));

  randword(buf, 7);
  printf(""Word: %s\n"", buf);
  return 0;
}
</code></pre>

<p>Test:</p>

<pre><code>$ ./rword 
Word: xoilfvv
</code></pre>
",0
3123863,3123484,5,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

main()
{
    srand(time(NULL));
    for (int i = 0; i &lt; 6; ++i)
    {
        putchar('a' + (rand() % 26));
    }
    putchar('\n');
    return EXIT_SUCCESS;
}
</code></pre>

<p>Salt to taste.</p>

<h2>Update0</h2>

<p>It would seem the OP does not know how to compile the above. If saved into a file called <code>so.c</code>, compile it with <code>make so CFLAGS=-std=c99</code> from the same folder.</p>
",3
7214879,7214835,2,"<p>Try to replace <code>char c</code> with <code>unsigned char c</code>. Basically char type supports values from -128 to 127. Your result is bigger than the supported range and overflows.</p>
",0
7215295,7214835,0,"<p>By default    <code>char</code>
 is     <code>signed char</code>
 in C. If you want     <code>255</code> to be printed then use      <code>unsigned char</code>
however i explain the output in context of     <code>signed char</code>
so that the concept becomes clear.
If you write     <code>j=127</code> then it will print      <code>127</code> as the bit representation is 01111111.
But if you write      <code>j=128</code>
 then it will print     <code>-128</code>
because the bit representation 01111111 has increased by 1 to become 10000000.
now if you write     <code>j=255</code>
then the bit representation is 11111111. so it will print      -1
If you write      <code>j=256</code> 
then it will print      <code>0</code>
because when bit representation 11111111 is increased by 1 it becomes 100000000. But only 1 byte is allocated for a characher variable so the left most bit is not stored and bit representation becomes 00000000. 
Further if you write      <code>j=257</code> 
then its also a case of overflow and the bit representation become 00000001 and      <code>1</code> will be printed.</p>
",0
7214856,7214835,16,"<p>In most implementations the <code>char</code> type is signed, so it ranges from <code>-128</code> to <code>127</code>.</p>

<p>This means, <code>11111111</code> (which is <code>255</code> written in binary) is equal to <code>-1</code>. (As it's represented as a value stored in <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two's complement</a>)</p>

<p>To get what you expect, you need to declare <code>c</code> as a <code>unsigned char</code>, like so:</p>



<pre><code>unsigned char c = 0;
int j = 255;
c = (c | j);
printf(""The value of c is %d"", (int)c);
</code></pre>
",5
7214864,7214835,5,"<p>It is probably printing -1. That is because </p>

<pre><code>c = (c | j);
</code></pre>

<p>will evaluate as</p>

<pre><code>c = (0 | 255) = (0 | 0xFF) = 0xFF
</code></pre>

<p>but, since <code>c</code> is signed, <code>0xFF</code> will be -1 and not 255 as you expected. If you change <code>c</code> to <code>unsigned char</code> it will print 255, as you imagined.</p>
",0
4542312,4542295,5,"<p>If you have a constant expression with no side effects inside an <code>if</code>, I would expect a reasonable compiler to generate code that doesn't bother with the calculation.  So I would expect no difference.  You can check your compiler's assembly output to confirm this.</p>

<p>The only situation I can think of in which it makes sense to use <code>#if</code> would be if a certain block of code doesn't make sense at all (or wouldn't compile) for a certain configuration.  I would agree that it looks weird for other things.  On the other hand, having an <code>if</code> statement that is either always-true or always-false is also a bit weird to me.  This is a subjective call, however.</p>
",0
4542317,4542295,0,"<p>If your compiler is any good at all, you will probably see no difference whatsover. Any decent optimizer will see that you are checking a constant and will not actually produce any code for that <code>if</code> check.</p>

<p>I am a bit worried that you have folks throwing (most likely BS) optimization requests at you. <a href=""http://c2.com/cgi/wiki?PrematureOptimization"" rel=""nofollow"">That way lies the road to Hell</a>. If you folks think performace in there is so critical that its worth investing large amounts of extra programmer time into improving, then <strong>the Right Way to do it is to profile the routine</strong>. Then any alleged optimization that makes the code harder to read should be reprofiled to prove that performance has improved enough to make it worth it.</p>

<p>Also, in C it can be difficult to avoid, but you should really try to avoid the preprocessor in general. Because its mechanisim of implementation is so much different than normal compiled code, it tends to make your sources way harder to understand. I know that doesn't shave 3 nannoseconds off of your iteration time, but it could save several weeks of maintenence programmer time. That ain't cheap either.</p>
",0
4542321,4542295,0,"<p>Well, it would eliminate the code that is not needed (as the preprocessor just cuts it out and it isn't compiled to binary), but that would only be beneficial if you are really on the edge about either binary size or cpu cycles (ie. on a microprocessor or embedded device). On a normal desktop application? It wouldn't hurt, but it wouldn't really make any difference either, as it is just one jump statement more in the code.</p>
",0
4542322,4542295,-1,"<p>The preprocessor will handle the #if directive, meaning that the output code will contain only the single necessary line.  This will result in a trivially longer compile time, but the best execution time.</p>

<p>Using the if keyword, on the other hand, puts branch instructions in the output machine code, which take longer to execute than zero branch instructions in assembly.</p>

<p>If you're executing this ""if"" multiple times, you will save many more cycles overall by having used the #if directive.</p>

<p>As previous answers have mentioned, however, it is very likely the compiler will optimize this for you.</p>
",2
5457804,5457609,5,"<p>Static variables in function scope go in data segment. Data segment is initialized at compile time. That means the initial value has to be known at compile time. In your case, the initial value (value of a) comes from a variable on stack which is available only at runtime. </p>
",0
5457628,5457609,0,"<p>You can not assign a variable to a static.</p>
",0
5457670,5457609,0,"<p>since you initialize the variable <code>i</code> not with a constant number (like <code>int a = 5;</code>) but with an expression (<code>a+5</code>) which is illegal.</p>
",0
5457681,5457609,0,"<p>The keyword <code>static</code> mean that there will be exactly one instance of the variable <code>i</code>, and that instance will live throughout the life of the program. This is useful, for example, if you want to store values between function calls.</p>

<p>As the variable is initialized when the application is started, the value must be constant.</p>

<p>In your case, there is no need to declare the ""static"", as it will get a new value every time the function is called.</p>
",0
5457710,5457609,1,"<p>In C Initializer should be some constant. however you can do something like this...</p>

<pre><code>int a = 5;
static int i;
i = a + 5;
printf(""%d"", i);
</code></pre>

<p>this will not generate any error...</p>
",2
4544966,4544372,19,"<p>A <code>sizeof</code> is always a multiple of largest alignment, as it is actually reports 'step' in chars in array of given type which include padding as between members so padding between array elements required to align them.</p>

<p>Memory layout of <code>struct data</code> will look like this:</p>

<pre><code> 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 ... &lt;--offset
|                                               |
|          struct data   (element [0])          |      (element [1])
|                                               |
|     a     |ch|::::::::|     s     |:::::::::::|     a     |ch|::::...
|                                               |
|&lt;----------- sizeof(struct data) -------------&gt;|

|::::| is padding
</code></pre>

<ul>
<li><code>a</code> is at offset 0 which is obviously a multiple of 8;</li>
<li><code>ch</code> is at offset 4 which is (also obviously) a multiple of 1;</li>
<li><code>s</code> is at offset 8 which is multiple of 4;</li>
<li><code>sizeof(struct data)</code> is equal to offset of <code>[1]</code> (16) which required to be multiple of <code>max(8,1,4) = 8</code></li>
</ul>
",0
4544393,4544372,14,"<p>The <code>aligned(N)</code> attribute aligns the <em>current</em> data item on an address which is a multiple of <code>N</code>, by inserting padding bytes <em>before</em> the data item. You appear to expect that it does something with packing, which is different.</p>

<p>Your structure appears to be laid out as follows:</p>

<pre><code>Address  Member
-------  -------
2280712  a        [address aligned on multiple of 8]
2280713  a
2280714  a
2280715  a
2280716  ch       [address aligned on multiple of 1]
2280717  (unused)
2280718  (unused)
2280719  (unused)
2280720  s        [address aligned on multiple of 4]
2280721  s
2280722  s
2280723  s
</code></pre>
",2
4544395,4544372,1,"<p>aligned(8) just means that the address of &amp;e.a will be aligned by 8. And it is (2280712). sizeof(int) is presumably 4, which is why your char ends up at 2280716 (it has an alignment requirement of 1, so there's no reason for it to be pushed to 2280720). Just add sizeof(int) to your debug output to verify it.</p>

<p>You will need to change your build target settings if you want to use 64-bit ints.</p>
",0
8213711,8213658,4,"<p>With your current definition of <code>struct sensors</code>, the compiler will insert additional padding because <code>int</code> has alignment requirements, usually on a <code>sizeof(int)</code> boundary. Moreover, <code>int</code> must be wider than <code>char</code>, hence it can accommodate more than 8 flags, which you're not gonna need.</p>

<p>If you declare it like this (use <code>unsigned char</code> instead), there should be no padding because <code>char</code> has the least strict alignment requirements:</p>

<pre><code>struct sensors {
    unsigned char Sensor0:1;
    unsigned char Sensor1:1;
    unsigned char Sensor2:1;
    unsigned char Sensor3:1;
    unsigned char Sensor4:1;
    unsigned char Sensor5:1;
    unsigned char Sensor6:1;
    unsigned char Sensor7:1;
}
</code></pre>

<p>This might not work only on a very strange platform where <code>CHAR_BIT != 8</code>.</p>
",1
8213723,8213658,0,"<p>If you want to be super-safe, you can AND with a character that has one bit set.  You probably would want to do this with an array, instead of a struct.  You can wrap it into a nice loop, and it's not much work at all.</p>

<p>However, any sane C compiler will put unsigned integers in contiguous memory, so it should be safe to do some kind of copy like that.  The compiler usually only puts in extra padding when there are types of different sizes.  Unfortunately I do not know if this will work easily for you because you have the command memcpy(buf, (char*)&amp;sensors, 1) will copy your byte of sensor data in the first integer - which is not what you want.</p>
",2
8213795,8213658,0,"<p>Instead of <code>memcpy()</code>, I would use a <code>union</code> to access the data as defined in <a href=""https://stackoverflow.com/questions/8213658/c-copy-char-to-struct/8213711#8213711"">Blagovest Buyukliev answer</a>:</p>

<pre><code>union combSensors {
    unsigned char all_fields;
    struct sensors field_by_field;
} 
</code></pre>
",1
8213891,8213658,2,"<p>To add to Blagovest's answer:</p>

<p>A bit-field approach seems sound. However, you'll have to instruct your compiler to not introduce a padding between the fields. For GCC, this is done by putting <code>__attribute__ ((packed))</code> after the definition of a structure, like this:</p>

<pre><code>struct sensors {
    unsigned char Sensor0:1;
    unsigned char Sensor1:1;
    unsigned char Sensor2:1;
    unsigned char Sensor3:1;
    unsigned char Sensor4:1;
    unsigned char Sensor5:1;
    unsigned char Sensor6:1;
    unsigned char Sensor7:1;
} __attribute__ ((packed)); 
</code></pre>

<p>Note that GCC before 4.4 used to introduce padding for <code>char</code> fields irrespective of this directive; see <a href=""http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wpacked_002dbitfield_002dcompat-476"" rel=""nofollow"">the documentation on warning option <code>-Wpacked-bitfield-compat</code></a> for more information.</p>
",0
4440036,4438860,0,"<p>in the code you've posted, you are trying to cast an integer (n) in something that seems to be a char (prime_array[k]), it can't work because 'n' and 'prime_array[k]' dont have the same type and also because you can't cast an integer in an array like that.</p>

<p>If you want to put an integer in an array, you can use the function sprintf from stdio.h.
Man of this function : <a href=""http://man.cx/sprintf%283%29"" rel=""nofollow"">http://man.cx/sprintf%283%29</a></p>

<p>Anhuin.</p>
",2
4440254,4438860,2,"<p>Assuming everything else is correct, you should consider the following: <code>printf</code> goes inside <code>if</code> block, but everything else doesn't. It probably should be:</p>

<pre><code>if(prime) {
  printf(""\n%d"", n);
  prime_array[k]=n;
  k++;
}
</code></pre>
",0
6278826,6278799,1,"<p>Are you sure you're passing an argument to the application's command line?</p>

<p><strong>EDIT</strong><br>
You must also check that <code>gethostbyname()</code> doesn't returns NULL.</p>
",1
6278859,6278799,9,"<p>You should check the return value (ptr) if it is NULL (gethostbyname returns NULL on error). When the function returns NULL you can check h_errno to see what exactly happened. See also: <a href=""http://www.manpagez.com/man/3/gethostbyname/"" rel=""noreferrer"">http://www.manpagez.com/man/3/gethostbyname/</a></p>

<p>You should also check the number of command line arguments befor you pass an argument to the gethostbyname function:</p>

<pre><code>if(c &lt; 2) {
    /* print an error */
    return 1;
}
</code></pre>
",0
4593300,4593231,10,"<p>A <code>register</code> variable is a type of local variable.<br>
It is a hint to store the value in a register for faster access.<br>
A register variable can not be global or static.<br>
It can be defined only in a block.<br>
Also please format the code you post</p>
",2
4593525,4593231,-4,"<p>Use of <code>register</code> is obsolete on most modern compilers. Don't use it.</p>

<p>It used to be the case that compilers were not smart enough to determine which variables would be accessed most often and therefore should be assigned a permanent place in a register. But modern compilers use techniques such as static single assignment and register allocation by colouring such that the compiler is far better than you at knowing when a variable should be in a register and when it should be ""spilled"" out to memory.</p>

<p>Furthermore, <code>register</code> places restrictions on its variable. You can't have a pointer to a <code>register</code> variable, because pointers point to memory locations, and the variable isn't in memory (at least conceptually). And a <code>register</code> variable must be an automatic variable -- commonly known as a ""stack"" variable. Therefore it must be a local variable within a function, and not qualified as <code>static</code> or <code>extern</code>.</p>

<p>In short, using <code>register</code> never provides performance gains in modern compilers, but it <em>does</em> provide programmer headaches. Premature optimization's biggest weapon -- wasting programmer time with false promises of execution time savings -- strikes again.</p>
",9
4594379,4593231,5,"<p>A <code>register</code> variable cannot be used as a ""global"" variable, because file scope variables have static storage, thus by definition they have an address. <code>register</code> variables are exactly the contrary, that are variables for which you, the programmer, promise to never take their address. So combining the two makes not much sense.</p>

<p>BTW, the error message that you get is not very helpful. It seems that your compiler is referring to an extension that allows to fix a <code>register</code> variable to a particular hardware register. If you post such an error message please also give an indication which compiler and/or platform you are using.</p>
",0
4914585,4914553,1,"<p>DO NOT NOT NOT declare that as an extern. Using a global variable in this context is very poor style. What you want to do is pass a pointer to the filename array as an argument to func2. When you call malloc, the OS allocates for you memory on the heap which is independent of your call stack. Therefore, even when func1 returns it is still there (until you call free). </p>

<p>for example</p>

<pre><code>void func1(void)
{
char * filename;
filename = (char*)malloc((SIZE)*sizeof(char));
//do stuff
func2(filename);
}

void func2(char * filename)
{
//do stuff to filename
}
</code></pre>
",3
4914605,4914553,0,"<p>If you allocate memory via <code>malloc</code> you can simply return the pointer from your function. The allocated memory won't be released automatically. You have to use <code>free</code> to do that.</p>
",3
4915012,4914553,0,"<p>You can only use one storage class at a time - so you cannot use both <code>static</code> and <code>extern</code> to qualify a single variable.</p>

<p>With dynamically allocated arrays, it is crucial to know which code will release the allocated space.  If you don't, you will have a memory leak.  In small-scale programs, it may not 'matter' in the sense that the program will run despite leaking memory.  However, in large programs, especially long-running programs (word processors, DBMS, etc), it matters crucially.</p>

<p>You can pass dynamically allocated arrays - or the pointer to the dynamically allocated array - to another function.  If you do not want the other function to modify it, you should write the other function so it takes <code>const SomeType *arg</code> as the argument.  The compiler will then ensure that your code does not modify the array.</p>

<p>Hence:</p>

<h3>header.h</h3>

<pre><code>extern void func2(const char *filename);
extern void func1(void);
</code></pre>

<h3>a.c</h3>

<pre><code>#include ""header.h""
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

extern const char *other_file_name; // Should be in a header!

void func1(void)
{
    char *filename;
    size_t N = strlen(other_file_name) + 1;
    filename = (char *)malloc(N);

    strcpy(filename, other_file_name); 
    file_name[N-1] = '\0'; 
    file_name[N-2] = 'x';

    func2(filename);
    free(filename);
} 
</code></pre>

<h3>b.c</h3>

<pre><code>#include ""header.h""

void func2(const char *filename)
{
    ...operations on filename...
}
</code></pre>

<h3>main.c</h3>

<pre><code>#include ""header.h""

int main(void)
{
    ...
    func1();
    ...
    func2(""/etc/passwd"");
    return 0;
}
</code></pre>

<p>Alternatively, but less desirably, you can make <code>filename</code> into a global variable.  In that case, you should declare it in <code>header.h</code>.  However, you cannot then have the compiler enforce the constraint that <code>func2()</code> should treat variable as a constant - one more reason not to use global variables.</p>

<p>See also <a href=""https://stackoverflow.com/questions/1433204/what-are-extern-variables-in-c"">SO 1433204</a> for a discussion of <code>extern</code> variables in C.</p>
",2
5099850,5099818,3,"<p>If you're looking to grab only one character, perhaps it would be better to use getchar() instead of scanf()?</p>
",1
5099853,5099818,1,"<p>You may print <code>area_code</code> after scanf, I guess it may be '\n' which is the last character of the <code>dest_code</code> line you entered.</p>
",2
5099873,5099818,0,"<p>You should empty the buffer before reading a character from <code>stdin</code>:</p>

<pre><code>int c = 0;
while (c != '\n' &amp;&amp; c != EOF)
{
    c = getchar();
}
</code></pre>

<p>then you can read your character using <code>scanf</code> or replace it with <code>getchar</code>.</p>
",0
5100028,5099818,1,"<p>Basically what's happening is this: you print the ""Please enter the number of trips"" message to the screen. The user types in 4 and then hits the enter key, which means the <code>stdin</code> buffer looks like this: ""4\n"". You then call <code>scanf</code> with the ""%d"" format string. <code>scanf</code> looks at the <code>stdin</code> buffer, and sees the 4. It looks at the next character, which is the newline, and sees it's not part of a number (as %d specifies), so it is done fulfilling the format string and leaves the file pointer at the newline. It converts the char '4' to an integer 4 and places it in <code>trip_num</code> and returns.</p>

<p>The next time you call <code>scanf</code>, it picks up where it left off at the newline. The format string this time is ""%c"", so it just grabs the next character from the buffer which is currently the newline (""\n""), places it in <code>dest_code</code>, and returns. If you want the <code>scanf</code> function to skip over the whitespace in this case, you have to explicitly tell it by adding a space before the ""%c"" format for the second <code>scanf</code> (destination code). Then <code>scanf</code> will skip over all whitespace (including that newline) until it encounters a non-whitespace character that it places in <code>dest_code</code>.</p>

<p>TL;DR: Change the second <code>scanf</code> call to <code>scanf("" %c"", &amp;dest_code)</code>. And fix the other errors others have pointed out so other bugs won't manifest.</p>
",1
5100037,5099818,0,"<p>This may or may not help, but previously stated you probably need to put the getchar() into the while loop. You may also need the fgets to grab the stdin from the keyboard.</p>

<p>while(1){</p>

<pre><code> printf(""Enter Message Type:"");
 fflush(stdout) ;

//    scan msg.hdr from received message.
 scanf(""%d"", &amp;(msg.m_hdr));
 while(getchar() != '\n'){}  

printf(""Enter your Message:"");
fflush(stdout);

// grab data from keyboard
fgets(msg.m_data, sizeof(msg.m_data), stdin);
</code></pre>
",0
7373704,7373653,0,"<p>Do you mean?</p>

<pre><code>for (int i = sizeof(uint32_t) - 1; i &gt;= 0; --i)
  *p++ = (number &gt;&gt; (i * 8)) &amp; 0xFF; 
</code></pre>

<p>Another option to might be to do</p>

<pre><code>// this would work on Big endian systems, e.g. sparc
struct unsignedMsg {
    unsigned char type;
    uint32_t value;
}

unsignedMsg msg;
msg.type = 7;
msg.value = number;
unsigned char *p = (unsigned char *) &amp;msg;
</code></pre>

<p>or</p>

<pre><code>unsigned char* p = 
p[0] = 7;
*((uint32_t *) &amp;(p[1])) = number;
</code></pre>
",3
7373710,7373653,3,"<p>You'll want to explicitly cast <code>type</code> to avoid a warning:</p>

<pre><code>*p++ = (unsigned char) type;
</code></pre>

<p>You want to encode the number with most significant byte first, but you're shifting in the wrong direction. The loop should be:</p>

<pre><code>for (int i = sizeof(uint32_t) - 1; i &gt;= 0; --i)
    *p++ = (unsigned char) ((number &gt;&gt; (i * 8)) &amp; 0xFF);
</code></pre>

<p>It looks good otherwise.</p>
",2
7373722,7373653,0,"<p>Your code is reasonable (although I'd use uint8_t, since you are not using the bytes as ¡°characters¡±, and Peter is of course right wrt the typo), and unlike the commonly found alternatives like</p>

<pre><code>uint32_t number = 8;
uint8_t* p = (uint8_t *) &amp;number;
</code></pre>

<p>or</p>

<pre><code>union {
  uint32_t number;
  uint8_t bytes[4];
} val;
val.number = 8;
// access val.bytes[0] .. val.bytes[3]
</code></pre>

<p>is even guaranteed to work. The first alternative will probably work in a debug build, but more and more compilers might break it when optimizing, while the second one tends to work in practice just about everywhere, but is explicitly marked as a bad thing? by the language standard.</p>
",0
7373830,7373653,0,"<p>I would drop the loop and use a ""caller allocates"" interface, like</p>

<pre><code>int convert_32 (unsigned char *target, size_t size, uint32_t val)
{
if (size &lt; 5) return -1;

target[0] = 7;
target[1] = (val &gt;&gt; 24) &amp; 0xff;
target[2] = (val &gt;&gt; 16) &amp; 0xff;
target[3] = (val &gt;&gt; 8) &amp; 0xff;
target[4] = (val) &amp; 0xff;

return 5;
}
</code></pre>

<p>This makes it easier for the caller to concatenate multiple fragments into one big binary packet and keep track of the used/needed buffer size.</p>
",1
5100340,5100274,0,"<p>The requested memory is allocated contiguously on the <a href=""http://en.wikipedia.org/wiki/Dynamic_memory_allocation"" rel=""nofollow"">heap</a> if enough space is available. Otherwise, those functions return NULL to indicate a failure.</p>
",0
5507737,5507715,3,"<p>The <code>register</code> keyword tells the compiler you want that variable stored in a CPU register as opposed to system RAM. In general this is a BAD idea, most compiler optimizers can do a much better job of handling variables, and many compilers ignore the keyword altogether.</p>

<p>Just remove it.</p>
",0
5507742,5507715,12,"<p>The <code>register</code> keyword was intended as an optimization hint to the compiler. The problem is, the compiler knows your code better than you do, and these days do not need such simplistic hints to generate better code.</p>

<p>So the only thing <code>register</code> does with modern compilers is prevent you from using <code>&amp;</code> to take the address of the variable. That's it.</p>
",4
5507743,5507715,1,"<p>It sounds like you shouldn't be using registers at all.</p>

<p>Registers are directions to compilers of where to put variables. They don't have types. The fact that your variable is a void pointer is unrelated.</p>

<p>I suggest looking up <a href=""https://stackoverflow.com/questions/578202/register-keyword-in-c"">register</a>.</p>
",0
5507747,5507715,2,"<p>As far as I remember, the <code>register</code> keyword tells the compiler to try to save the variable in a register of the CPU, for increasing the principle of locality. The programmer knows that the variable will be accessed many times so he wants to keep it in the fastest memory location that he can obtain.</p>

<p>I suspect that many compilers today are smarter than (the average) programmers when it comes to this kind of optimizations, so it could be not needed. I would not use it.</p>
",0
5507751,5507715,5,"<p>There's no ""special rule"" for <code>register</code> used in conjunction with <code>void *</code>, <code>register</code> will work on <code>void *</code> as with any variable, suggesting to the compiler that such variable will be heavily used and that it should be put into a CPU register.</p>

<p>Still, in general there's no reason to use <code>register</code> anywhere, since optimizers included in current compilers are much better than programmers at guessing what variables should be put into registers, and almost always will happily ignore the <code>register</code> keyword completely.</p>

<p>The C99 standard also provides some additional details about <code>register</code> (¡ì6.7.1 ?4):</p>

<blockquote>
  <p>A declaration of an identifier for an object with storage-class specifier <code>register</code>
     suggests that access to the object be as fast as possible. <strong><em>The extent to which such
    suggestions are effective is implementation-defined.</em></strong> 101)</p>
  
  <p>101) The implementation may treat any <code>register</code> declaration simply as an <code>auto</code> declaration. However, whether or not addressable storage is actually used, the address of any part of an object declared with storage-class specifier register cannot be computed, either explicitly (by use of the unary <code>&amp;</code> operator as discussed in 6.5.3.2) or implicitly (by converting an array name to a pointer as discussed in 6.3.2.1). Thus, the only operator that can be applied to an array declared with storage-class specifier <code>register</code> is <code>sizeof</code>.</p>
</blockquote>

<p>So using <code>register</code> you most probably get only the downsides of pretending having a variable in a register. :) Notice that the C++ standard relaxes these restrictions, but obviously if you try to take the address of a <code>register</code> variable it won't stay in a register anymore.</p>

<p>Long story short, <code>register</code> is there mostly as a relic of the past, avoiding it is the best use you can do of it. :)</p>
",0
5508246,5507715,0,"<p>register storage variable can't be applied to pointers. As register varible placed in machine register. </p>
",0
6385588,6385234,3,"<p>To calculate the sizes of user-defined types, the compiler takes into account any <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">alignment</a> space needed for complex user-defined data structures. This is why the size of a structure in C can be greater than the sum of the sizes of its members. For example, on many systems, the following code will print <strong>8</strong>:</p>

<pre><code>struct student{
  char grade; /* char is 1 byte long */
  int age; /* int is 4 bytes long */
};

printf(""%zu"", sizeof (struct student));
</code></pre>

<p>The reason for this is that most compilers, by default, align complex data-structures to a <a href=""http://en.wikipedia.org/wiki/Word_%28data_type%29"" rel=""nofollow"">word</a> alignment boundary. In addition, the individual members are also aligned to their respective alignment boundaries. By this logic, the structure student gets aligned on a word boundary and the variable age within the structure is aligned with the next word address. This is accomplished by way of the compiler inserting ""padding"" space between two members or to the end of the structure to satisfy alignment requirements. This padding is inserted to align age with a word boundary. (Most <a href=""http://en.wikipedia.org/wiki/Central_processing_unit"" rel=""nofollow"">processors</a> can fetch an <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">aligned word</a> faster than they can fetch a word value that straddles multiple words in memory, and some don't support the operation at all)</p>

<p>Referenced article: <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">data structure alignment</a> and <a href=""http://en.wikipedia.org/wiki/Sizeof#Structure_padding"" rel=""nofollow"">Structure padding</a></p>
",0
7813046,7812994,1,"<p>You are seeing garbage because for teacher, <code>second</code> and <code>third</code> aren't assigned, and for another, <code>first</code> and <code>last</code> aren't assigned?</p>

<p>Why do you have <code>second</code> and <code>third</code> fields? Remove them, use <code>first</code> and <code>last</code> for both, and remove the second line in <code>displayStats</code>, and it should work.</p>
",2
7813056,7812994,1,"<p>Each call to displayStats is printing two lines.  Calling it twice prints four lines.  Remove the second printf from displayStats and it should work.</p>
",3
7813093,7812994,1,"<p>You have unnecessary fields in your struct and you are calling <code>printf</code> twice in your display function. Remove these fields:</p>

<pre><code>struct person { /* ""person"" is name for structure type */
  char first[32]; /* first field of structure is array of char */
  char last[32]; /* second field is array of char */
  int year; /* third field is int */
  double ppg; /* fourth field is double */

  char second[31]; // &lt;- Remove
  char third[31]; // &lt;- Remove
  int year1; // &lt;- Remove
  double ppo; // &lt;- Remove
};
</code></pre>

<p>And change your display function to:</p>

<pre><code>void displayStats(struct person  Input) {
      printf(""%s, %s: %lf PPG in %d\n"", Input.last, Input.first, Input.ppg, Input.year);
}
</code></pre>
",0
6119380,6119340,1,"<p>The value swap in the inner-most loop of <code>sort()</code> is incomplete.  It never assigns <code>list[in]</code> to anything.</p>
",0
6119385,6119340,2,"<p>It's just code that is meant to sort the array elements but it's never going to work in its current form since:</p>

<pre><code>temp=list[in];
list[out]=temp;
</code></pre>

<p>will overwrite <code>list[out]</code> with <code>list[in]</code> <em>without ever preserving</em> the original contents of <code>list[out]</code>.</p>

<p>The best way to swap two variables is with something like:</p>

<pre><code>temp = array[index1];
array[index1] = array[index2];
array[index2] = temp;
</code></pre>

<p>And, please, for the love of whatever deity you believe in, don't do <a href=""https://stackoverflow.com/questions/804706/swap-two-variables-without-using-a-temp-variable"">this</a> :-)</p>

<p>So, if your question is how to sort the data, then the following pseudo-code should help. I'd provide C code but, on the off chance that this is homework, you should do some of the work yourself <sup>a</sup>.</p>

<pre><code>def sort (arr[], sz):
    swapped = true                       # Force loop entry.
    while swapped:                       # Loop until a pass had no swaps.
        swapped = false
        for idx goes from 1 to sz-1:     # For all but the first element.
            if arr[idx-1] &gt; arr[idx]:    # If order is wrong.
                swapped = true           # More passes will be needed.
                temp = arr[idx-1]        # Swap
                arr[idx-1] = arr[idx]    #   the
                arr[idx] = temp          #     elements.
</code></pre>

<p>This is a bubble sort variation which exits as soon as the list is sorted (well, after one pass with no swaps). Some naive variants will simply keep going for roughly <code>n<sup>2</sup></code> times regardless.</p>

<hr>

<p><sup>a</sup> If you'd like to indicate in a comment that it's <em>not</em> homework, I'd be happy to provide the C code. Just be aware (if you're planning to lie to me) that your educators will almost certainly be able to see that code and you will probably fail in that case (or be expelled for blatant plagiarism).</p>

<hr>

<p>And, since you've stated it's not homework, here's a complete C program illustrating it:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define FALSE (1==0)
#define TRUE  (1==1)

static void sort (int arr[], int sz) {
    int idx, temp, swapped;

    swapped = TRUE;                        // Force loop entry.
    while (swapped) {                      // Loop until a pass had no swaps.
        swapped = FALSE;
        for (idx  = 1; idx &lt; sz; idx++) {  // For all but the first element.
            if (arr[idx-1] &gt; arr[idx]) {   // If order is wrong.
                swapped = TRUE;            // More passes will be needed.
                temp = arr[idx-1];         // Swap
                arr[idx-1] = arr[idx];     //   the
                arr[idx] = temp;           //     elements.
            }
        }
    }
}
</code></pre>

<p>&nbsp;</p>

<pre><code>int main (int argc, char *argv[]) {
    int sz, i, *vals;

    sz = argc - 1;
    if (sz &lt; 1)
        return 0;
    if ((vals = malloc (sz * sizeof (int))) == NULL) {
        printf (""ERROR: Cannot allocate memory.\n"");
        return 1;
    }

    for (i = 0; i &lt; sz; i++)
        vals[i] = atoi (argv[i+1]);

    printf (""Numbers before:"");
    for (i = 0; i &lt; sz; i++)
        printf ("" %d"", vals[i]);
    printf (""\n"");

    sort (vals, sz);

    printf (""Numbers after :"");
    for (i = 0; i &lt; sz; i++)
        printf ("" %d"", vals[i]);
    printf (""\n"");

    free (vals);
    return 0;
}
</code></pre>

<p>Running this with:</p>

<pre><code>$ ./testprog 3 1 4 1 5 9 2 6 5 3 5 8 9
</code></pre>

<p>gives you the output:</p>

<pre><code>Numbers before: 3 1 4 1 5 9 2 6 5 3 5 8 9
Numbers after : 1 1 2 3 3 4 5 5 5 6 8 9 9
</code></pre>
",11
6119556,6119340,0,"<p>I believe the following is what you are trying to do. Essentially you are trying to find the minimum element at each inner loop iteration. 
For instance, if you start with the array [5,4,3,2,1], after the first inner loop iteration, the array would look like the following: </p>

<p>[5,4,3,2,1] : after in = 0</p>

<p>[4,5,3,2,1] : after in = 1</p>

<p>[3,5,4,2,1] : after in = 2</p>

<p>[2,5,4,3,1] : after in = 3</p>

<p>[1,5,4,3,2] : after in = 4</p>

<p>Now 1 is at the beginning. Eventually, the array would be sorted as [1,2,3,4,5].</p>

<pre><code>void sort(int list[], int size) {
    int out, in, temp;       
    for(out=0; out&lt;size; out++)  {        |
        for(in=out; in&lt;size; in++)                                           
            if(list[out] &gt; list[in])                                        
            {                                                               
                tmp = list[out]
                list[out]=list[in];
                list[in] = tmp                                                                                           
            }    
    }                                                           
} 
</code></pre>
",2
5556679,5556622,2,"<p>The first character you're reading in is the newline you typed to enter the <code>15</code>.  Use <code>fgets()</code> and <code>sscanf()</code> - you'll be much happier.</p>
",3
5559630,5556622,1,"<p>In the scanf function for getting the values of character use getche or getchar function. This will allow you to capture all the characters including new line. you can skip the first character and copy the rest.</p>
",0
5513465,5513432,1,"<p>If you are compiling with optimizations enabled, it is entirely possible that the jump instruction for the <code>if</code> is simply going straight to the <code>while</code>, rather than bothering with the <code>continue</code>, which would just be another simple jump instruction.</p>
",0
5513500,5513432,0,"<p>The continue would take you to while statement also. This is perhaps due to an optimization by the compiler. It detected that there are no statements following the continue and hence the resulting step would be same whether the if condition evaluated to true or not.</p>
",0
5513502,5513432,0,"<p>Your if is redundant. It's the last thing in the loop, and all it does is continues the loop. If you use any optimization whatsoever, it may be removed.</p>

<p>What is your code supposed to do?</p>
",0
5513527,5513432,0,"<p>The debugger executes statements.</p>

<p>The line in question does not have a full statement; the debugger never stops at the middle of a statement.</p>

<p>Imagine you have the multiple line statement like below. Where would the debugger stop?</p>

<pre><code>for (
    i = 0;
    i &lt; 100;
    i++)
            sum += a[i];
</code></pre>
",2
5537094,5536957,1,"<p>Given you cannot at runtime define new structures, something like the following (hack?) could work..</p>

<p>Firstly define a base structure which only has a type id</p>

<pre><code>typedef struct
{
  int type_id; /* this holds a number which identifies the following structure */
} TypeID;

/* now all structures should contain this */

typedef struct {
  TypeID type;
    char sname[STRLEN];
    int rating;
    float age;
} Sailor;

typedef struct {
  TypeID type;
  char sname[STRLEN];
  int sailors;
} Boat;
</code></pre>

<p>Now treat the data segment as a <em>container</em> of these structs, let's say for example that I will have two structs in data (i.e. joined the two above structs), my data segment would look like:</p>

<pre><code>----------
| Sailor |
+--------+
|  Boat  |
----------
</code></pre>

<p>When reading the data chunk, first cast it to <code>TypeID</code>, which gives you the type, then you can cast it to the real structure. Then if there is more data in the data segment, move the pointer by the sizeof the structure you've just read, and again do the same process. Basically this allows you to have a variable length segment which is a set of structures of different types - i.e. your <em>joined</em> data structure.</p>

<p>Oh, and you'll need to modify your <code>Element</code> structure to hold the size of the data segment as well.</p>
",2
8270773,8269832,2,"<p>You cannot do this in C. Even if you knew the length, the address of a function matters, because function calls and accesses to certain types of data will use <strong>program-counter-relative</strong> addressing. Thus, a copy of the function located at a different address will not do the same thing as the original. Of course there are many other issues too.</p>
",6
8270814,8269832,0,"<p>Here is a standards compliant way of achieving the result you want:</p>

<pre><code>int f(int magicNumber)
{
    return magicNumber;
}

int main(void)
{

    k = f(OTHERMAGICNUMBER);
    /* Prints the other magic number */
    printf(""Hello %d!\n"", k);
    return 0;
}
</code></pre>

<p>Now, you may have lots of uses of <code>f()</code> all over the place with no arguments and not want to go through your code changing every one, so you could do this instead</p>

<pre><code>int f()
{
    return newf(MAGICNUMBER);
}

int newf(int magicNumber)
{
    return magicNumber;
}


int main(void)
{

    k = newf(OTHERMAGICNUMBER);
    /* Prints the other magic number */
    printf(""Hello %d!\n"", k);
    return 0;
}
</code></pre>

<p>I'm not suggesting this is a direct answer to your problem but that what you are doing is so horrible, you need to rethink your design.</p>
",0
8269981,8269832,1,"<p>In the C standard, there is no notion of introspection or reflection, thus you'd need to devise a method yourself, as you have done, some other safer methods exists however.</p>

<p>There are two ways:</p>

<ol>
<li>Disassemble the function (at <em>runtime</em>) till you hit the <em>final</em> <code>RETN</code>/<code>JMP</code>/etc, while accounting for switch/jump tables. This of course requires some heavy analysis of the function you disassemble (using an engine like <a href=""http://www.beaengine.org/"" rel=""nofollow"">beaEngine</a>), this is of course the most reliable, but its slow and heavy.</li>
<li><p>Abuse compilation units, this is very risky, and not fool proof, but if you know you compiler generates functions sequentially in their compilation unit, you can do something along these lines:</p>

<pre><code>void MyFunc()
{
    //...
}

void MyFuncSentinel()
{
}

//somewhere in code
size_t z = (uintptr_t)MyFuncSentinel - (uintptr_t)MyFunc;
uint8_t* buf = (uint8_t*)malloc(z);
memcpy(buf,(char*)MyFunc,z);
</code></pre>

<p>this will have some extra padding, but it will be minimal (and unreachable). although highly risky, its a lot faster that the disassemble method.</p></li>
</ol>

<p>note: both methods will require that the target code has read permissions.</p>

<hr>

<p>@R.. raises a very good point, your code won't be relocatable unless its PIC or you reassasmble it in-place to adjust the addresses etc.</p>
",0
8271730,8269832,0,"<p>Well, you can obtain the length of a function at runtime using labels:</p>

<pre><code>int f()
{
    int length;
    start:
    length = &amp;&amp;end - &amp;&amp;start + 11; // 11 is the length of function prologue
                                   // and epilogue, got with gdb

    printf(""Magic number: %d\n"", MagicNumber);

    end:
    return length;
}
</code></pre>

<p>After executing this function we know its length, so we can <code>malloc</code> for the right length, copy and editing the code, then executing it.</p>

<pre><code>int main()
{
    int (*pointerToF)(), (*newFunc)(), length, i;
    char *buffer, *byte;

    length = f();

    buffer = malloc(length);
    if(!buffer) {
        printf(""can't malloc\n"");
        return 0;
    }

    pointerToF = f;
    newFunc = (void*)buffer;
    memcpy(newFunc, pointerToF, length);

    for (i=0; i &lt; length; i++) {
        byte = ((char*)newFunc)+i;
        if (*byte == MagicNumber) {
            *byte = CrackedNumber;
        }
    }

    newFunc();
}
</code></pre>

<p>Now there's another bigger problem though, the one @R. mentioned. Using this function once modified (correctly) results in segmentation fault when calling <code>printf</code> because the <code>call</code> instruction has to specify an <em>offset</em> which will be wrong. You can see this with <code>gdb</code>, using <code>disassemble f</code> to see the original code and <code>x/15i buffer</code> to see the edited one.<br>
By the way, both my code and yours compile without warnings but crash on my machine (<code>gcc 4.4.3</code>) when calling the edited function.</p>
",1
5603204,5602815,3,"<p>For the error occurred while dealing with .bss segment, check your definitions for global variables. In addition, make sure your code does not content non-ascii characters except in comments.</p>
",0
5128240,5128208,2,"<pre><code>#define PROD(x) (x*x)
</code></pre>

<p><code>PROD(3+1)</code> is changed by the preprocessor to <code>3+1*3+1</code></p>
",0
5128244,5128208,21,"<p>Macros are <em>expanded</em>, they don't have values <em>passed</em> to them. Have look what your macro expands to in the statement that assigns to <code>k</code>.</p>

<pre><code>k=(p+1*p+1);
</code></pre>

<p>Prefer functions to macros, if you have to use a macro the minimum you should do is to fully parenthesise the parameters. Note that even this has potential surprises if users use it with expressions that have side effects.</p>

<pre><code>#define PROD(x) ((x)*(x))
</code></pre>
",0
5128250,5128208,2,"<p>macro are not function . These are replaced by name</p>

<p>It will be <code>p+1*p+1</code></p>
",0
5128252,5128208,5,"<p>The problem here is that PROD is a macro and will not behave exactly like you intend it to. Hence, it will look like this:</p>

<pre><code>k = p+1*p+1
</code></pre>

<p>Which of course means you have:</p>

<pre><code>k = 3+1*3+1 = 7
</code></pre>
",0
5128254,5128208,5,"<p>The preprocessor expands PROD(p+1) as follows:</p>

<pre><code>k = (p+1*p+1);
</code></pre>

<p>With p=3, this gives: 3+1*3+1 = 7.</p>

<p>You should have written your #define as follows:</p>

<pre><code>#define PROD(x) ((x)*(x))
</code></pre>
",0
5128294,5128208,2,"<p>This is what compiler is going to see after preprocessors does its job: k= p+1*p+1. When p =  3, this is evaluated as k = 3+(1*3)+1. Hence 7. </p>
",0
5128412,5128208,1,"<p>This is exactly why you should use functions instead of macros. A function only evaluates each parameter once. Why not try  </p>

<p>int prod(int x)<br>
{ return x * x; }   </p>

<p>and see the difference!</p>
",0
5191115,5191050,4,"<p>If you want to print <code>n</code> lines in total: </p>

<ul>
<li>the first line consists of 1 char and <code>n-1</code> spaces in front of it</li>
<li>the second line consists of 3 chars and <code>n-2</code> spaces in front of them</li>
<li>the second line consists of 5 chars and <code>n-3</code> spaces in front of them</li>
<li>the <code>i</code>-th line consists of <code>___</code> chars and <code>___</code> spaces in front of them (please fill in missing fields</li>
</ul>

<p>How to determine what to print:</p>

<ul>
<li>the first line consists of numbers</li>
<li>the second line consists of alphabetical chars</li>
<li>the third line consists of numbers</li>
<li>the fourth line consists of alphabetical chars</li>
</ul>

<p>Please formulate a rule that determines which lines contain which signs:</p>

<pre><code>_______________________________________________________________________________

_______________________________________________________________________________  
</code></pre>

<p>You can print numbers with: <code>printf(""%d"", number)</code>. You can print chars with <code>printf(""%c"",char)</code>.</p>

<p>You can do addition on characters as well: <code>'A' + 2</code> yields <code>'C'</code>.</p>

<p>Now it should be no real problem to program the program you are looking for.</p>
",0
5191261,5191050,0,"<pre><code>char * pie = ""     1\n    A B\n   1 2 3\n  A B C D\n"";
for (i=0;i&lt;1;i++) printf(""%s"", pie);
</code></pre>
",0
5191314,5191050,-1,"<pre><code>f(int n)
{
  int i , j ;
  for( i = 1 ; i &lt;= n ; i ++ )
  { 
    j = 1 ;
    while( j &lt;= (n-i) ) { printf("" ""); j++ ;}
    j = 0 ;
    while( j &lt;= i )
    {
      if( i % 2 != 0 )
        printf(""%d "", j );
      else
        printf(""%c "", j + 'A' );
      printf(""\n""); 
      j ++ ;
    }
  }
}
</code></pre>

<p>Now if someone can do it in time &lt; O(n2) That is welcome :)</p>
",1
5469681,5469373,0,"<pre><code>strcmp(p,""IP_ADDR_ETH"")
</code></pre>

<p>will never match because at this time p points to ""NODE"". Once you fixed that, it should work.</p>
",0
7782753,7782747,1,"<p>same reason why 0x50 is not the same as 50 or 050</p>

<ul>
<li>50 - base 10</li>
<li>0x50 - base 16</li>
<li>050 - base 8 (never seen the need to use this, ever)</li>
</ul>
",1
7782754,7782747,8,"<p>Because <code>050</code> is considered octal and <code>50</code> is considered decimal.</p>

<p>So <code>x = 050</code> basically means <code>x = 40</code>.</p>

<blockquote>
  <p>6.4.4.1/3</p>
  
  <p>A <strong>decimal constant begins with a nonzero digit</strong> and consists of a
  sequence of decimal digits. <strong>An octal constant consists of the pre?x 0</strong>
  optionally followed by a sequence of the digits 0 through 7 only.</p>
</blockquote>
",0
7782755,7782747,1,"<p>Because <code>050</code> is an octal constant.</p>
",0
7782759,7782747,3,"<p>050 is interpreted as octal, with 8 instead of 10 as the number base.</p>
",2
7782762,7782747,1,"<p>050 is 40 in octal. The 0 turns the number into an octal literal.</p>
",0
6115646,6115615,3,"<p>What error?</p>

<p>Anyway your problem is here:</p>

<pre><code>printf(""Enter numbers of row for i"");
scanf (""%d"", a);
printf(""Enter numbers of column for j"");
scanf (""%d"", b);
</code></pre>

<p>It should be</p>

<pre><code>scanf (""%d"", &amp;a);
scanf (""%d"", &amp;b);
</code></pre>

<p>Also your num matrix is 0 by 0. Try making it bigger or allocating it after reading a,b.</p>
",1
6115661,6115615,2,"<p>You don't allocate enough (or any) memory for <code>num[]</code>. You're going to need to allocate some memory for it, e.g.</p>

<pre><code>int num[100][100];
</code></pre>

<p>Of course, you'll also have to make sure that i or j is not greater than 100 (in that case).</p>

<p>When using scanf, you need to pass pointers to the variables you want to scan in to, so it should be:</p>

<pre><code> scanf(""%d"", &amp;a);
</code></pre>

<p>and so on.</p>

<p>Also, you don't <code>#include &lt;stdlib.h&gt;</code>, so I don't believe the <code>system()</code> function should be available to you.</p>
",0
6115673,6115615,0,"<pre><code>int num[0][0];
</code></pre>

<p>here's the problem. How many rows and how many columns do you want your matrix to have? Put it in the  brackets</p>
",0
6115788,6115615,3,"<pre><code>scanf (""%d"", &amp;a);
scanf (""%d"", &amp;b);
</code></pre>

<p>And you need to malloc the 2D array if you want it to have variable size. Example:</p>

<pre><code>int **num;
num = malloc(a * sizeof(int *));
int i;
for(i = 0; i &lt; a; i++)
    num[i] = malloc(b * sizeof(int));
</code></pre>
",0
5462565,5462304,4,"<p>You've already done roughly what you seem to want, but I'd caution that what you seem to be trying to do doesn't make much sense.</p>

<p>In particular, earth, mars, and venus look a lot like they should be instances of a type. A union defines a type, so you probably want something like </p>

<pre><code>typedef union { 
    galaxy g; 
    star s; 
    planet p; 
    nebula n;
} celestial_object;
</code></pre>

<p>Individual galaxies, planets, stars, etc., would be instances of that union. You could then have (for example):</p>

<pre><code>#define max_objects 1000000

celestial_object universe[max_objects];

celestial_object earth;
earth.p.mass = 24;
earth.p.diameter = 12756;

celestial_object sun;
sun.s.mass = 30;
sun.s.diameter = 1400000;
</code></pre>

<p>...and so on.</p>
",1
5485335,5485324,5,"<p>The first <code>sizeof</code> reports the size of a pointer, the second the size of an array.</p>

<p>A parameter declared with array syntax (<code>void fun(char [])</code>) is actually a pointer parameter. The <code>[]</code> is just syntactic sugar.</p>
",0
5485342,5485324,5,"<p>It's because <code>arrays</code> when passed in functions get decayed into pointers in functions.</p>
<p><code>sizeof</code> in <code>fun()</code> returns the size of the pointer <code>a</code>. Read about <a href=""http://www.lysator.liu.se/c/c-faq/c-2.html/"" rel=""nofollow noreferrer"">Arrays and Pointers</a>.</p>
<p><code>a</code> in <code>fun()</code> is actually a pointer copied by value.</p>
<p>You should pass the size of the array with as a separate argument.</p>
<p>You should try it this way:</p>
<pre><code>#include &lt;stdio.h&gt;
void fun(char []);
void fun(char a[], int n)
{
//     printf(&quot;Size is %d\n&quot;,sizeof(arr));
       printf(&quot;Size is %d\n&quot;,n);
}
int main ()
{
  char arr[10] = { 0 };
  const int truesize = sizeof(arr)/sizeof(arr[0]); // try to understand this statement what it does -  sizeof returns size in bytes
  printf(&quot;Size is %d\n&quot;,truesize);
  fun(arr,truesize);  // This is how you should call fun
  return 0;
}
</code></pre>
",2
5485347,5485324,0,"<p>sizeof is an operator, it computes it value at compile time. sizeof(char[]) is the size of the pointer.</p>
",0
6655610,6655135,1,"<ul>
<li>Studying the Linux kernel, maybe in conjunction with one of the several books on the kernel or device drivers would provide a wealth of material.  Much of this is available free.</li>
<li>any or all of the books by <a href=""http://www.kohala.com/start/"" rel=""nofollow noreferrer"">W. Richard Stevens</a> that walk though the implementation (TCP/IP Illustrated) or use (UNIX Network Programming) of the networking stack or his Advanced Programming in the UNIX Environment book.</li>
</ul>

<p>If you have a leaning toward Windows there are several good books, even if they're quite old, including:</p>

<ul>
<li><a href=""https://rads.stackoverflow.com/amzn/click/com/0735607532"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Programming Server-Side Applications for Microsoft Windows 2000</a> by Richter and Clark</li>
<li><a href=""https://rads.stackoverflow.com/amzn/click/com/1572319968"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Programming Applications for Microsoft Windows</a> by Richter</li>
</ul>
",0
6655841,6655135,1,"<p>I would suggest the following sources might be interesting r.e. Operating Systems from a learning perspective. Be aware there have been many advancements actually present in modern kernels:</p>

<ul>
<li>The <a href=""http://www.kernel.org/pub/linux/kernel/Historic/"" rel=""nofollow"">original linux code</a>.</li>
<li><a href=""http://pdos.csail.mit.edu/6.828/xv6/"" rel=""nofollow"">xv6</a>. This is a simple unix OS that goes along with <a href=""http://ocw.mit.edu/index.htm"" rel=""nofollow"">MIT's excellent OpenCourseWare</a> course on <a href=""http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2006/"" rel=""nofollow"">Operating Systems</a>.</li>
</ul>

<p>Other ideas:</p>

<ul>
<li><a href=""http://bzr.savannah.gnu.org/lh/grub/trunk/grub/annotate/head:/grub-core/boot/i386/pc/boot.S"" rel=""nofollow"">The current grub stage 1 bootloader</a> isn't that complicated - it's pretty hard to be complicated with 512 bytes to play with.</li>
<li>The <a href=""http://tldp.org/LDP/lkmpg/2.6/html/"" rel=""nofollow"">Linux kernel module guide</a> gives you an introduction to building kernel modules. You could experiment with building custom, yet pointless, drivers that add say character devices to <code>/dev/</code> or proc devices to <code>/proc</code> and work towards implementing something interesting. People have implemented web servers in kernel space...</li>
<li>If you want to experiment with Windows kernels, have a go with <a href=""http://technet.microsoft.com/en-us/sysinternals/bb897447.aspx"" rel=""nofollow"">Native NT applications</a>. I'd start with printing a pointless boot message, then move up to drivers.</li>
</ul>

<p>Beyond that, it's hard to suggest where you might want to go. Systems level is a wide space.</p>

<p>In the context of low level programming, C and C++ are portable assembler. In many of the above spaces the standard library is either partially or totally missing and extra functionality may be implemented by existing parts of the system-level code you're modifying, so you have to be aware of the API functions available to you in any given space and what you need to implement yourself, as well as what your memory and processing requirements must be. For example, a bootloader written to the MBR has to use bios interrupts and starts in real (16-bit) mode. Those are the constraints of the hardware design. Likewise, functions like <code>fopen()</code> aren't available in kernel space since they wrap system calls - you'd need to use kernel specific constructs to achieve this if it really made sense to write a file from kernel space.</p>
",0
6656047,6655135,2,"<p>I would suggest you to study MINIX3 from Tanenbaum: <a href=""http://www.minix3.org/"" rel=""nofollow"">http://www.minix3.org/</a></p>

<p>Its a microkernel architecture, and with his book ( <a href=""http://vig.prenhall.com/catalog/academic/product/0,1144,0131429388,00.html"" rel=""nofollow"">http://vig.prenhall.com/catalog/academic/product/0,1144,0131429388,00.html</a> ) it is really enlightning.</p>

<p>As of my opinion, studying the linux kernel is a bit hardcore for a start ;), and out of a academical point of view the microkernel architecture is superior to the monolithic kernel.</p>

<p>Furthermore, with only a few thousands lines of code, unlike the Linux Kernel, its consumable in a realistic timetable.</p>

<p>And its a real serious project, the European Union sponsored some Millions towards it as far as i am aware of. I think i remind him saying that in one of his talks.</p>

<p>And you have a X-Server running there, a gcc-toolchain etcpp.</p>

<p>Have fun :)</p>

<p>EDIT: As i read the comments, someone mentions the Ruby interpreter. Its written in a mixture of C and Ruby, and as far as it was mentioned in one episode of se-radio.net, it is really nice sourcecode. Though i have to admit, i havent looked into it myself. Might be worth the dig into it if you have some interest in Ruby too.</p>
",1
6655412,6655135,1,"<p>I'd suggest looking at some (for you) interesting open source projects written in C. For example, there's <a href=""http://www.busybox.net/"" rel=""nofollow"">busybox</a>, a piece of software that runs on embedded devices and has lots of smaller programs to study. You could, for example, take the source for the <a href=""http://git.busybox.net/busybox/tree/networking/telnet.c"" rel=""nofollow"">telnet client</a> on one side and the <a href=""http://www.faqs.org/rfcs/rfc854.html"" rel=""nofollow"">corresponding RFC</a> on the other. Or, for a steeper learning curve, you could also try studying the open source OSes, like the <a href=""http://www.kernel.org/"" rel=""nofollow"">Linux kernel</a> (<a href=""http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=tree"" rel=""nofollow"">here's</a> the tree for browsing) or the BSDs. It's a lot more involved than busybox, but you can still find some parts that are fairly easy to understand if you're familiar with the context.</p>
",0
5490283,5490264,3,"<p><code>printf</code> writes the output under the control of a <code>format string</code> that specifies how subsequent arguments (or arguments accessed via the variable-length argument) are converted for output.</p>

<p>If the number of arguments provided in <code>printf</code> call are less than the number of conversion specifiers, then the behavior is undefined.</p>

<p>This is how the call should be made, <code>printf(""%s"",arr)</code>. </p>

<p>By the way, there is something even funnier you might want to try which is - <code>printf(arr,20,arr,20)</code> - replace it and see the fun, but make sure the input is still the same that you gave, i.e., <code>%d%s%u</code></p>
",1
5490299,5490264,0,"<p>This is not the way to use printf, you should do <code>printf(""%s"", arr);</code> to print a string from the place pointed by arr. The way you called it, it was actually called <code>printf(""%d%s%u"");</code> which gave you a garbage, depends on the calling convention, you will get different results. in case of <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl"" rel=""nofollow"">cdecl</a> it will print the next element on the stack as int, then the string pointed by the following element and then the next element as an unsigned int.</p>
",0
5490339,5490264,1,"<p><code>gets</code> is not safe. It doesn't check buffer overflows. Use fgets instead.</p>

<pre><code>fgets(arr,sizeof(arr),stdin) ;
</code></pre>

<p>And print -</p>

<pre><code>printf(""%s"", arr) ;
</code></pre>
",3
5490345,5490264,0,"<p>It seems you wanted to use the counterpart of <code>gets</code>, which is <code>puts</code>:</p>

<pre><code>puts(arr);
</code></pre>
",0
5490351,5490264,4,"<p>You probably haven't come across formatted output yet. <code>printf()</code> takes a string as its first parameter and then a variable number of extra parameters. Special strings found in the first parameters are replaced by the values provided in the extra parameters. For example:</p>

<pre><code>int i = 42;
printf(""%d"", i);
</code></pre>

<p>outputs 42.</p>

<p>Or you could write:</p>

<pre><code>char name[] = ""The Devil"";
int num = 666;
printf(""My name is %s and my favourite number is %d."", name, num);
</code></pre>

<p>Well, you can imagine what happens.</p>

<p>Now if you look back at your problem, it's easy to see what is happening.  You are effectively writing:</p>

<pre><code>printf(""%d%s%u"");
</code></pre>

<p>but since you don't provide any values for the 3 placeholders, the result is garbage - technically known as <em>undefined behaviour</em>.</p>
",2
8464039,8464030,4,"<p>Your program doesn't work fine; it won't be able to distinguish between <code>EOF</code> and <code>255</code>.</p>

<p>The reason it appears to work correctly is because <code>char</code> is probably <code>signed</code> on your platform, so it's still capable of representing <code>-1</code>.</p>
",5
8464094,8464030,8,"<p><code>getchar</code> result is the input character converted to <code>unsigned char</code> and then to <code>int</code> or <code>EOF</code> i.e. it will be in the -1 ¡ª 255 range that's 257 different values, you can't put that in an 8 bit <code>char</code> without merging two of them. Practically either you'll mistake <code>EOF</code> as a valid character (that will happen if <code>char</code> is unsigned) or will mistake another character as <code>EOF</code> (that will happen if <code>char</code> is signed).</p>

<p>Note: I'm assuming an 8 bit <code>char</code> type, I know this assumption isn't backed up by the standard, it is just by far the most common implementation choice.</p>
",2
6125112,6125068,85,"<p>It sets the <em>close-on-exec</em> flag for the file descriptor, which causes the file descriptor to be automatically (and atomically) closed when any of the <code>exec</code>-family functions succeed.</p>

<p>It also tests the return value to see if the operation failed, which is rather useless if the file descriptor is valid, since there is no condition under which this operation should fail on a valid file descriptor.</p>
",6
6125113,6125068,39,"<p>It marks the file descriptor so that it will be <code>close()</code>d automatically when the process or any children it <code>fork()</code>s calls one of the <code>exec*()</code> family of functions.  This is useful to keep from leaking your file descriptors to random programs run by e.g. <code>system()</code>.</p>
",3
4917791,4917753,0,"<p>There are a couple of issues with your <code>replace()</code> function.  (It looked fine to me in your last question).</p>

<ol>
<li><p>You call <code>insert()</code> when you find the node that has <code>i</code> but you do nothing with the new node (what <code>insert()</code> returns).  Basically the new node you are inserting is the new <code>p</code> so you should set <code>p</code> to it.</p></li>
<li><p>You free <code>p</code> and immediately attempt to set the <code>next</code> field of the <code>p</code> to a value.  The location <code>p</code> was pointing to is invalid so you shouldn't be doing that.  You should use a temporary variable to save the old <code>p</code> so you can free that later.  It should only be done if you are actually replacing it so it should be part of the previous condition.</p></li>
</ol>

<p>I think that should cover it.  Basically the changes are:</p>

<pre><code>/* if the current node contains the int I'm looking for... */
if(p-&gt;myInt == i)
{   /* ... the current node needs to be replaced */
    /* save the current node to delete later (2) */
    IntNodePtr oldNode = p;

    /* insert a new node making it the new current node (1) */
    p = insert(j, oldNode-&gt;next);

    /* free the old node (2) */
    free(oldNode);
}
/* and so on */
</code></pre>
",3
4917828,4917753,0,"<p>As Mark pointed out, your <code>free(p)</code> has undefined behavior. Hence, the next statement</p>

<pre><code>p-&gt;next = replace(i, j, p-&gt;next);
</code></pre>

<p>becomes invalid since you are trying to assign <code>p-&gt;next</code> to a pointer value, but <code>p-&gt;next</code> memory location itself is not defined. </p>

<p>But why have you made this replace function recursive? A simple while loop will be sufficient.</p>

<pre><code>IntNodePtr replace(int i, int j, IntNodePtr p) {
    if(p == NULL)
        return NULL;
    IntNodePtr prevPtr = NULL;
    while(p){
        if(p-&gt;myInt == i){
            IntNodePtr temp = insert(j, p-&gt;next);
            if(prevPtr)
                 prevPtr-&gt;next = temp;
            free(p);
            break;
        }
        prevPtr = p;
        p = p-&gt;next;
    }
}
</code></pre>

<p>And you are incorrectly using your insert function as well, since you are not connecting the previous node to the newly created node. </p>
",0
5523456,5523446,7,"<p>Try changing a and c to be type ""double"", rather than float.  That will give you better precision / accuracy.  (Floats have about 6 or so significant digits; doubles have more than twice that.)</p>
",0
5524123,5523446,9,"<p>Your compiler's <code>float</code> type is probably using the 32-bit IEEE 754 single-precision format.</p>

<p>67107842 is a 26-bit binary number:</p>

<pre><code>  11111111111111110000000010
</code></pre>

<p>The single-precision format represents most numbers as <code>1.x</code> multipled by some (positive or negative) power of two, where 23 bits are stored after the binary place, with the leading <code>1.</code> being implied (very small numbers are an exception).</p>

<p>But 67107842 would require 24 bits after the binary place (to be represented as <code>1.111111111111111000000001</code> multipled by 2<sup>25</sup>).  As there is only room to store 23 bits, the final <code>1</code> gets lost.  So it is the value in <code>a</code> that is wrong in this case, not the division - <code>a</code> actually contains 67107840 (<code>11111111111111110000000000</code>), which is exactly 131070 * 512.</p>

<p>You can see this if you print <code>a</code> as well:</p>

<pre><code>printf(""%lf %lf %lf\n"", a, b, c);
</code></pre>

<p>gives</p>

<pre><code>67107840.000000 512.000000 131070.000000
</code></pre>
",0
5525443,5523446,0,"<p>A <code>float</code> typically uses 32bit IEEE-754 single precision representation, and is good for only approximately 6 significant decimal figures.  A <code>double</code> is good for 15, and where supported an 80 bit <code>long double</code> gets to 20 significant figures.</p>

<p>Note that on some compilers there is no distinction between <code>double</code> and <code>long double</code>, or even no support for <code>long double</code> at all.</p>

<p>One solution is to use an arbitrary-precision numeric library, or to use a decimal-floating point library rather then the built-in binary floating point support.  Decimal floating point is not intrinsically more precise (though often such libraries support larger, more precise types), but will not show up the artefacts that occur when displaying a decimal representation of a binary floating point value.  Decimal floating point is also likely to be much slower, since it is not typically implemented in hardware.</p>
",0
8440993,8440973,26,"<p>It's when you do something like:</p>

<pre><code>int index;
int main (void) {
    int index;
    ....
    return 0;
}
</code></pre>

<p>What it's warning about is that the <code>index</code> inside <code>main()</code> is actually <em>hiding</em> the global one you've declared before <code>main()</code>.</p>

<p>It's warning you that you can't get at the global definition while the local one is ""active"". Now that's not <em>necessarily</em> a problem (hence why it's only a warning), it's perfectly valid C, but you need to be aware of the possible consequences.</p>

<blockquote>
  <p>As an aside, some C implementations (BSD-based) define an <code>index</code> <em>function</em> in <code>string.h</code> which may also cause a problem. Use of this function is deprecated and it doesn't appear in the C standard (use <code>strchr</code> instead) but it may be the cause of problems if you're running on (for example) Mac OS or OpenBSD (or even Linux under some combination of <code>#define</code> settings, I believe).</p>
</blockquote>

<p>There are a couple of ways to get around this (if you need to).</p>

<p>The first is probably the preferred one: don't <em>use</em> globals. Yes, that's right, get rid of them. They're very rarely needed so don't make me come over and slap you around :-)</p>

<p>A second way I've seen is to ensure they're ""packaged"". Assuming that you actually <em>need</em> globals (by no means a certainty, see previous paragraph), create a structure that holds them, such as in the following:</p>

<pre><code>myglobs.h:
    struct sMyGlobs {
        int index;
        // all other globals.
    };
    extern struct sMyGlobs myGlobs;

myglobs.c:
    #include ""myglobs.h""
    struct sMyGlobs myGlobs;

main.c:
    #include &lt;stdio.h&gt;
    #include ""myglobs.h""
    int main (void) {
        myGlobs.index = 42;
        return 0;
    }
</code></pre>

<p>This has the advantage in that it's obvious that you're referring to a global and that they're never hidden, unless you do something like define your own local variable called <code>myGlobs</code>.</p>
",2
8441403,8441368,24,"<p>String literals are not of type <code>unsigned char*</code>.</p>

<p>You probably meant to type <code>const char*</code> in your struct. If not, you probably do not want to assign a string literal to it without making it <code>const</code>, because it is illegal to modify the memory in which string literals reside.</p>
",0
8441419,8441368,2,"<p>Change unsigned char * type to const char*.</p>
",0
8441427,8441368,8,"<p>As @Seth Carnegie said, string literals are of type <code>char*</code>, not <code>unsigned char*</code>. So you can avoid this warning with an explicit type cast. i.e.</p>

<pre><code>#include&lt;stdio.h&gt;

struct s{
     unsigned char *p;
};

int main() {
    struct s a = {(unsigned char *)""?""""?/?""""?/????""}; // no warning
    printf(""%s"",a.p);
    return 0;
}
</code></pre>

<p>Edit: Changed string literal to remove the possible <a href=""http://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html#index-trigraphs-977"" rel=""noreferrer"">trigraph</a></p>
",7
5541840,5539932,0,"<p>Note that you would have gotten an error from passing the wrong type (<code>int</code> instead of <code>const char *</code>) as the first argument of <code>printf</code>, except that you forgot to <code>#include &lt;stdio.h&gt;</code> or prototype <code>printf</code> yourself. And since <code>printf</code> is a variadic function, this results in UB too.</p>
",0
5539951,5539932,8,"<p><code>'%u'</code> should be <code>""%u""</code> (double quotes). C is not SQL, and <code>'%u'</code> is considered a <a href=""https://stackoverflow.com/questions/3960954/c-multicharacter-literal"">multicharacter literal</a>.</p>

<p>And as Erik said, <code>%d</code> is better in your case.</p>
",1
5539961,5539932,3,"<p><code>printf(""%d"")</code> - printf takes a C string not a character. <code>%d</code> is the correct format specifier for an integer.</p>
",0
5539975,5539932,3,"<p>That '%u' ( a multi-character char constant) should be ""%u"" (a char array). The char constant is being misinterpreted as a pointer to random memory.</p>
",0
5562125,5562101,3,"<p>In your <code>display</code> function, you first need to test whether <code>root == null</code> before testing whether <code>root -&gt; word == null</code>. That should fix the seg fault.</p>

<p>Regarding the theory question: the answer is that yes, the tree will end up incredibly skewed. That's what <a href=""http://en.wikipedia.org/wiki/Balanced_binary_tree"" rel=""nofollow""><em>balanced</em> binary trees</a> are all about.</p>
",1
5562154,5562101,1,"<pre><code>if(root -&gt; word == NULL)
    printf(""Tree is empty."");
</code></pre>

<p>Your problem lies here. What happens if root itself is null? Double check that pointer before de-referencing it.</p>

<p>Yes, if you insert items in sorted order (or relatively sorted), you'll get a skewed tree. Look into algorithms on rotations for nodes in balanced binary trees.</p>
",1
5562192,5562101,0,"<p>Regarding your second question, others have already mentioned looking into balancing your binary tree.  However, as an alternative, if your input is already known to be sorted, then it is more appropriate instead to use a linear array with a binary search to find items of interest, rather than a binary tree.  A binary search of a sorted array has the same time complexity as a search in a balanced binary tree.</p>
",2
5564606,5564566,3,"<p>The problem with the second segfaulting line is operator precedence. </p>

<p><code>[]</code> has higher precedence than <code>*</code>, so <code>*str[strlen(*str)]</code> is interpreted as <code>*(str[strlen(*str)])</code> - that is, dereference the address pointed to by the memory at <code>str + strlen(*str)</code>. </p>

<p>You want <code>(*str)[strlen(*str)]</code> - that is, the character at the end of of <code>str</code>-dereferenced.</p>
",6
5566114,5564566,0,"<p>Segmentation faults occur when the memory being accessed by the program is invalid. It is very likely that the realloc call was not able to allocate the amount of memory being requested. It is a best practice to check whether the memory is properly allocated before proceeding to access it.</p>

<p>I tried this program and works well in my system.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

    void func(char **str)
    {
        *str = realloc(*str, sizeof(char) * 20);
        if( *str == NULL)
        {
            printf(""Memory allocation failed\n"");
            return;
        }

        *str[0] = '\0';
        strncat(*str, ""hello world"", 11);  
        //memcpy(*str, ""hello world"", 11); //memcpy also works fine
        //(*str) [strlen(*str)] = '\0';   
        printf(""String : %s\n"", *str);
     }
</code></pre>
",0
7781513,7781506,3,"<pre><code>int i = 7; /* i is 7 */
int j = (3 * (i--)) /* means 3 * 7 */ + 2; /* 3 * 7 + 2 = 23 */
/* i is now 6, because it was decreased by the postfix -- operator */
printf(""%d %d"", i /* 6 */, j /* 23 */);
</code></pre>
",0
7781514,7781506,2,"<p><code>i--</code> does have the side effect of decrementing <code>i</code> by 1 (setting it to 6), but the expression yields the <em>previous</em> value of <code>i</code>.  <code>--i</code> would decrement <code>i</code> and yield the <em>new</em> result.</p>
",0
7781518,7781506,1,"<p><code>--</code> binds to <code>i</code>, not to <code>3*i</code>. (You couldn't have <code>(3*i)--</code> in any case as <code>3*i</code> is not an lvalue which <code>--</code> requires.) The value of <code>i--</code> is the original value of <code>i</code> before it is decremented.</p>
",0
7781523,7781506,1,"<p>List of unary operators in C: <a href=""http://en.wikipedia.org/wiki/Unary_operation#C_family_of_languages"" rel=""nofollow"">http://en.wikipedia.org/wiki/Unary_operation#C_family_of_languages</a></p>

<p><code>--</code> is a unary operator and binds to <code>i</code>, so it's <code>i--</code>, not <code>(3 * i)--</code>.</p>

<p>Since it's post-decrement, the value of <code>i</code> BEFORE decrementing is used, so your equation is just:</p>

<p><code>3 * 7 + 2</code>, and <code>i</code> will be 6.</p>
",0
5616280,5616248,1,"<p>I'm not sure this is possible at all. You should use <code>for</code> or <code>while</code> loops.</p>

<p>You can use <code>memset</code> function if you want to fill memory with a single byte.</p>
",1
5616281,5616248,1,"<p>Multi-dimensional arrays can be built dynamically using
  pointers-to-pointers with malloc. In the example below, a single
  pointer-to-pointer-to-int is declared. Upon declaration, the
  pointer has no meaningful value. A call to mallac then requests
  that the pointer point to a block of nx valid memory units:</p>

<pre><code>x =  (int **) malloc(nx * sizeof(int *));
</code></pre>

<p>After this call, x now has a valid value; specifically, the
  beginning address of a block of memory which contains nx
  pointers-to-int. Eachof these pointers to int is just a regular
  pointer, as we have seen many times. They have yet to be
  initialized to anything meaningful, and the can each be accessed
  as either </p>

<pre><code>x[0], x[1] ... x[nx-1], OR *x, *(x+1), *(x+2),
  ... *(x+nx-1).
</code></pre>

<p>To give eachof these pointers a meaningful value,
  we can call malloc for each of them, such as is accomplished by
  this loop:</p>

<pre><code> for (i=0;i&lt;nx;++i){
    x[i] = ( int * ) malloc( ny * sizeof(int));
  }
</code></pre>

<p>Note that we could have also said:</p>

<pre><code>for (i=0;i&lt;nx;++i){
    *(x+i) = ( int * ) malloc( ny * sizeof(int));
  }
</code></pre>

<p>Now that each pointer in our array of pointers points to a
  meaningful block of memory (each of size ny ints), we can assign
  values. To understand how values are assigned, consider the
  schematic below. You will need to study this very carefully until
  it is very clear what is going on. This can be a little tricky but
  once you get the hang of it it's not so bad.</p>

<pre><code>  x[0] ---&gt;   | *x[0] | *x[0]+1 | *x[0] + 2 | ... | *x[0]+ny-1 |
  x[1] ---&gt;   | *x[1] | *x[1]+1 | *x[1] + 2 | ... | *x[1]+ny-1 |

  .
  .
  .
  x[nx-1] ---&gt; | *x[nx-1] | *x[nx-1]+1 | *x[nx-1] + 2 | ... | *x[nx-1]+ny-1 |
</code></pre>

<p>This is equivalent to:  </p>

<pre><code>  x[0] ---&gt;   | *(*(x+0)+0) | *(*(x+0)+1) | *(*(x+0)+2) | ... | *(*(x+0)+ny-1) |
  x[1] ---&gt;   | *(*(x+1)+0) | *(*(x+1)+1) | *(*(x+1)+2) | ... | *(*(x+1)+ny-1) |
  .
  .
  .
  x[nx-1] ---&gt;   | *(*(x+nx-1)+0) | *(*(x+nx-1)+1) | *(*(x+nx-1)+2) | ... | *(*(x+nx-1)+ny-1) |
</code></pre>

<p>And this is equivalent to:</p>

<pre><code>  x[0] ---&gt;   | x[0][0] | x[0][1] | x[0][2] | ... | x[0][ny-1] |
  x[1] ---&gt;   | x[1][0] | x[1][1] | x[1][2] | ... | x[1][ny-1] |
  .
  .
  .
  x[nx-1] ---&gt; | x[nx-1][0] | x[nx-1][1] | x[nx-1][2] | ... | x[nx-1][ny-1] |
</code></pre>

<p>... given the important relation:</p>

<pre><code> *( *(x + i) + j) = *( x[i] + j) = x[i][j]
</code></pre>
",0
5616759,5616248,1,"<p>You can do this:</p>

<pre><code>int ArrayName[5][5];

for(size_t i = 0; i &lt; 5; i++)
    for(size_t i2 = 0; i2 &lt; 5; i2++)
        ArrayName[i][i2] = 1;
</code></pre>

<p>Or to be more efficient:</p>

<pre><code>int ArrayName[5][5];

for(size_t i = 0, *ptr = ArrayName; i &lt; (5*5); ++i, ++ptr)
    *ptr = 1;
</code></pre>

<p>If you were crazy enough, you'd create a function for it:</p>

<pre><code>void init_arr(void* ptr, void* value, size_t size)
{
    for(size_t i = 0; i &lt; size; ++i, ++ptr)
        *ptr = *value;
}

int ArrayName[5][5];
int val = 1;
init_arr(ArrayName, val, 5 * 5);
</code></pre>

<p>If you were using C++, you might use templates:</p>

<pre><code>template &lt;class T&gt;
void init_arr(T *ptr, T value, size_t size)
{
    for(size_t i = 0; i &lt; size; ++i, ++ptr)
        *ptr = value;
}

int ArrayName[5][5];
init_arr(ArrayName, 1, 5 * 5);
</code></pre>

<p>If you <em>really</em> were using C++, you'd use vectors... Heck, there's probably a fancy boost way to do this. :)</p>
",0
5616831,5616248,7,"<p>There's no compact syntax in C language that would initialize all elements of an array to a single value, regardless of whether the array is multi-dimensional or single-dimensional. There's syntax that would set all elements to zero specifically (and it is <code>= { 0 }</code>), but for any other value it is impossible. </p>

<p>Of course, you can spell out individual initializers for all array elements, but that's probably not what you are looking for.</p>

<p>All you can do is to set all elements to a specific value manually, by using assignment.</p>
",0
7222940,7222818,2,"<p>I'm not sure exactly what you are asking here.  The <code>__interrupt</code> specifier you are using is not a part of the C language, but is instead an extension to the language. You will need to tell us what system you are compiling for in order to get a more specific answer for your use case.</p>

<p>That code does not appear to be a valid interrupt function.  Typically the arguments to the function will be <code>void</code> or the state of the registers when the interrupt occurred.  You can also typically change the value of the registers via the arguments (not always safe to do!).  Returning a value from an interrupt handler doesn't make a lot of sense either as it would not be called directly by user code.</p>

<p>Interrupts may be handled in many ways, but a simple mechanism would be to declare a function as an interrupt handler, a pointer to the function would be stored somewhere, and when an interrupt occurs on a specific CPU the registers functions would be called asynchronously (as the interrupt probably did not occur on your current thread).</p>

<p>I don't know that any of this generalist information will help you.  I can't really make out what you are asking here.  Perhaps if you narrowed things down a bit more we could offer more assistance.</p>
",0
7222894,7222859,9,"<p>From the C99 standard, section 6.3.1.8 (""Usual arithmetic conversions""):</p>

<blockquote>
  <p>if the operand that has unsigned integer type has rank greater or
  equal to the rank of the type of the other operand, then the operand
  with signed integer type is converted to the type of the operand with
  unsigned integer type.</p>
</blockquote>

<p>Basically, in the case of your example code, <code>unsigned int</code> and <code>int</code> have the same rank, so it's equivalent to:</p>

<pre><code>(a + (unsigned int)b &gt; 6)
</code></pre>

<p>To fix it, you need to explicitly cast in the other direction, i.e.:</p>

<pre><code>((int)a + b &gt; 6)
</code></pre>
",0
7222899,7222859,1,"<p>The answer is to be found in section ""6.3.1.8 Usual arithmetic conversions"" of the C99 standard, which favors the unsigned type when a signed type and an unsigned one are passed to a binary operator (the reality is much more subtle than that).</p>

<p>See <a href=""http://blog.frama-c.com/index.php?post/2011/04/11/Promotion-rules"" rel=""nofollow"">this blog post</a> for another example of working through the rules in 6.3.1.8.</p>
",0
7222935,7222859,1,"<p>You are mixing signed and unsigned integers in your code.  That is a <strong>bad thing</strong>.  Try the following snippet:</p>

<pre><code>int main()
{
    unsigned int a = 0;
    int b=-20;
    printf(""(a + b) = %f"", (a + b));
    return 0;
}
</code></pre>

<p>Don't mix signed and unsigned integers because the compiler will do a silent conversion just when you don't want it to.</p>
",0
8395432,8395418,3,"<p>When it's cast or treated as a <code>signed</code> type. You probably printed your <code>unsigned int</code> as an <code>int</code>, and the bit sequence of the <code>unsigned</code> would have corresponded to a negative <code>signed</code> value.</p>

<p>ie. Perhaps you did:</p>

<pre><code>unsigned int utc_time;
...
printf(""%d"", utc_time);
</code></pre>

<p>Where <code>%d</code> is for <code>signed</code> integers, compared to <code>%u</code> which is used for <code>unsigned</code>. Anyway if you show us the code we'll be able to tell you for certain.</p>

<p>There's no notion of positive or negative in an <code>unsigned</code> variable.</p>
",0
8395434,8395418,9,"<p>Unsigned integers, by their very nature, can <em>never</em> be negative.</p>

<p>You may end up with a negative value if you cast it to a signed integer, or simply assign the value to a signed integer, or even incorrectly treat it as signed, such as with:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {
    unsigned int u = 3333333333u;
    printf (""unsigned = %u, signed = %d\n"", u, u);
    return 0;
}
</code></pre>

<p>which outputs:</p>

<pre><code>unsigned = 3333333333, signed = -961633963
</code></pre>

<p>on my 32-bit integer system.</p>
",2
8395435,8395418,1,"<p>Negative numbers in most (all?) C programs are represented as a <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two's complement</a> of the unsigned number plus one.  It's possible that your debugger or a program listing the values doesn't show it as an unsigned type so you see it's two's complement.</p>
",1
8395444,8395418,3,"<p>Make sure you using </p>

<pre><code>printf(""%u"", utc_time);
</code></pre>

<p>to display it</p>

<hr>

<p>In response to the comment <code>%u</code> displays the varible as an unsigned int where as <code>%i</code> or <code>%d</code> will display the varible as a signed int.</p>
",2
5568170,5568137,2,"<p>A sentinel is just a dummy value.  For strings, you might use a NULL pointer since that's not a sensible thing to have in a list.  For integers, you might use a value unlikely to occur in your data set e.g. if you are dealing with a list ages, then you can use the age -1 to denote the list.</p>
",2
5568228,5568137,1,"<p>You can get an ""infinite value"" for floats, but it's not the best idea. For arrays, pass the size explicitly; for lists, use a null pointer sentinel.</p>
",0
5568318,5568137,1,"<p>in C, when sorting an array, you usually know the size so you could actually sort a range <code>[begin, end)</code> in which <code>end</code> is one past the end of the array. E.g. <code>int a[n]</code> could be sorted as <code>sort(a, a + n)</code>.</p>

<p>This allow you to do two things:</p>

<ul>
<li>call your sort recursively with the part of the array you haven't sorted yet (merge sort is a recursive algorithm)</li>
<li>use <code>end</code> as a sentinel.</li>
</ul>
",0
6138319,6138172,3,"<p><a href=""http://c-faq.com/stdio/stdinflush2.html"" rel=""nofollow"">http://c-faq.com/stdio/stdinflush2.html</a></p>
",2
6138362,6138172,2,"<p>use <code>consumetoendofline(stdin)</code> instead :)</p>

<pre><code>int consumetoendofline(FILE *where) {
    int ch;
    while (((ch = fgetc(where)) != '\n') &amp;&amp; (ch != EOF)) /* void */;
    return ch;
}
</code></pre>

<p>You can (<strong>and should</strong>) even test the return value to see if the stream has reached its end, or if there is probably more data waiting ...</p>
",0
5136190,5136165,3,"<p>Speak <a href=""https://www.rfc-editor.org/rfc/rfc2616"" rel=""nofollow noreferrer"">HTTP</a>, or at least fake it.</p>
",1
5136263,5136165,0,"<p>Once you have the connection, you simply have to check what file the browser is asking for and send it. For example, when you first connect to a web server your browser is asking something like <code>GET HTTP/1.1 index</code> so the server has to send the main page. It just opens it, reads from it and  <code>send()</code>s it back. Then the browser will look into that page and asks again if it finds images/videos or whatever, finally it shows you the page. Give a look <a href=""http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#getaddrinfo"" rel=""nofollow"">here</a>, it will surely help you. :)</p>
",0
5139761,5136165,1,"<p>When you get request from browser, this request may be</p>

<pre><code>GET /filename.ext HTTP/1.0
Host: ...
User-agent: ...
...
</code></pre>

<p>You should search for your filename.ext</p>

<p>If .ext is .htm or .html</p>

<p>Function sendMessage should send</p>

<pre><code>""HTTP/1.0 200 Ok\nConnection: close\nContent-type: text/html\nContent-length: 999999\n\n""
</code></pre>

<p>replace 999999 with the actual length of your file</p>

<p>send the content of your file</p>

<p>If .ext is .gif</p>

<p>Function sendMessage should send</p>

<pre><code>""HTTP/1.0 200 Ok\nConnection: close\nContent-type: image/gif\nContent-length: 999999\n\n""
</code></pre>

<p>replace 999999 with the actual length of your file</p>

<p>send the content of your file</p>

<p>And so on</p>
",0
5142027,5141980,6,"<p>To access, you need to <strong>dereference</strong> the pointer returned by the expression a->y to maniputlate the pointed at value. To do this, use the unary * operator:</p>

<p>You also need to allocate memory for y to make sure it points at something:</p>

<pre><code>a-&gt;y = malloc(sizeof(int));
...
*(a-&gt;y) = 12;
...
printf(""%d %d"", a-&gt;x,*(a-&gt;y));
</code></pre>

<p>And be sure to free malloc'd data in the reverse order it was  malloc'd</p>

<pre><code>free(a-&gt;y);
free(a);
</code></pre>
",0
8267046,8266956,6,"<p>Your structure contains a <code>char</code> data member and you probably have word-alignment on.  See if you can find a ""pack"" option in the compiler.</p>

<p>You can probably use a <code>#pragma pack(1)</code> or similar pragma (pragma's are implementation specific) to change the alignment for a particular set of classes.</p>

<p>Be careful though, the compiler word-aligns for performance reasons.  The memory bus typically works on word boundaries, so you could end up requiring two fetchs for each word that straddles the word boundary thereby slowing memory access down a bit.</p>

<p>You might want to stream the structure members out individually if you're concerned about the added bytes in the file.</p>
",2
3929983,3929884,3,"<p>I see the following problems:</p>

<ul>
<li><code>queue_free</code> does not free the memory for its <code>beforeFirst</code> object.</li>
<li><code>add_priority</code> won't free the element if the data allocation fails. This doesn't matter that much since you're exiting but it would be good form in case you ever decide to return an error (in other words, it will stop a memory leak).</li>
</ul>

<p>However, I've tested that code by inserting a new element, an element before that one then an element at the end, and it seems fine. What priority values are you inserting (in order)?</p>

<p>And you may want to post the code that's calling this code. It's quite possible it may be a memory corruption issue unrelated to this actual code.</p>

<hr>

<p>While I appreciate your attempt in introducing the <code>beforeFirst</code> stuff to keep your code nice, you really should just bite the bullet and get rid of it. Its removal will probably more than offset the minimal amount of extra code you're going to have to add for handling a truly empty list. This simpler code should handle all scenarios without the added processing required to keep extra pointers synchronised.</p>

<p>I haven't actually tested this other than in my wetware but it should (hopefully) work okay:</p>

<pre><code>typedef struct _e {
    void *data;
    size_t datalen;
    int priority;
    struct _e *next;
} ELEMENT;

typedef struct {
    ELEMENT *head;          //reference to first element 
    ELEMENT *tail;          //reference to last element
    int elements;
} PQUEUE;
</code></pre>

<p>&nbsp;</p>

<pre><code>PQUEUE *queue_new(void) {
    PQUEUE *pq = malloc(sizeof(PQUEUE));
    if (pq == NULL) {
        perror(""queue_new"");
        exit(EXIT_FAILURE);
    }
    pq-&gt;head = pq-&gt;tail = NULL;
    pq-&gt;elements = 0;
    return pq;
}

void queue_free(PQUEUE *pq) {
    ELEMENT *this, *save;
    this = pq-&gt;head;
    while(this!= NULL) {
        save = this;
        this = this-&gt;next;
        free(save-&gt;data);
        free(save);
    }
    free(pq);
}
</code></pre>

<p>&nbsp;</p>

<pre><code>void queue_add_priority(PQUEUE *pq, void *data, size_t datalen, int priority) {
    ELEMENT *newelement;
    newelement = calloc(1,sizeof(ELEMENT));
    if (newelement == NULL) {
        perror(""queue_add"");
        exit(EXIT_FAILURE);
    }
    newelement-&gt;data = malloc(datalen);
    if(newelement-&gt;data == NULL) {
        perror(""queue_add"");
        free (newelement);
        exit(EXIT_FAILURE);
    }
    memcpy(newelement-&gt;data,data,datalen);
    newelement-&gt;datalen = datalen;
    newelement-&gt;priority = priority;
    newelement-&gt;next = NULL;

    // Inserting into empty list.
    if (pq-&gt;elements == 0) {
        pq-&gt;head = pq-&gt;tail = newelement;
        pq-&gt;elements = 1;
        return;
    }

    // Inserting beyond tail.
    if (pq-&gt;tail-&gt;priority &lt;= priority) {
        pq-&gt;tail-&gt;next = newelement;
        pq-&gt;tail = newelement;
        pq-&gt;elements++;
        return;
    }

    // Inserting before head.
    if (pq-&gt;head-&gt;priority &gt; priority) {
        newelement-&gt;next = pq-&gt;head;
        pq-&gt;head = newelement;
        pq-&gt;elements++;
        return;
    }

    // Otherwise, we're inserting somewhere in the middle.
    ELEMENT *ptr = pq-&gt;head;
    while (ptr-&gt;next-&gt;priority &lt;= priority)
        ptr = ptr-&gt;next;
    newelement-&gt;next = ptr-&gt;next;
    ptr-&gt;next = newelement;
    pq-&gt;elements++;
}
</code></pre>

<p>&nbsp;</p>

<pre><code>void* queue_remove(PQUEUE *pq) {
    if (pq-&gt;elements == 0)        // added, just in case.
        return NULL;
    void* item = pq-&gt;head-&gt;data;
    pq-&gt;head = pq-&gt;head-&gt;next;
    pq-&gt;elements--;
    return item;
}

bool queue_has_next(PQUEUE *pq) {
    return (pq-&gt;elements &gt; 0);    // better, IMNSHO.
}
</code></pre>

<p>Keep in mind that <code>queue_add_priority</code> makes a copy of the memory so that you can pass it dynamically allocated memory or otherwise. That function doesn't accept responsibility for freeing any allocated memory that you pass to it. If it's dynamically allocated, you still have to free it yourself. It was done this way so you could pass in <em>any</em> sort of memory.</p>

<p>On the other hand, <code>queue_remove</code> just passes you back the allocated memory so you <em>are</em> responsible for freeing it when you're done. The memory you receive will have <em>always</em> been obtained via <code>malloc</code>.</p>

<p>You <em>could</em> optimise <code>queue_add_priority</code> so that you could specify that the memory being passed in is allocated via <code>malloc</code> and you are passing responsibility by changing the first part of the function from:</p>

<pre><code>void queue_add_priority(PQUEUE *pq, void *data, size_t datalen, int priority) {
    ELEMENT *newelement;
    newelement = calloc(1,sizeof(ELEMENT));
    if (newelement == NULL) {
        perror(""queue_add"");
        exit(EXIT_FAILURE);
    }
    newelement-&gt;data = malloc(datalen);
    if(newelement-&gt;data == NULL) {
        perror(""queue_add"");
        free (newelement);
        exit(EXIT_FAILURE);
    }
    memcpy(newelement-&gt;data,data,datalen);
</code></pre>

<p>to:</p>

<pre><code>void queue_add_priority(PQUEUE *pq, void *data, size_t datalen, int priority, int xfer) {
    ELEMENT *newelement;
    newelement = calloc(1,sizeof(ELEMENT));
    if (newelement == NULL) {
        perror(""queue_add"");
        exit(EXIT_FAILURE);
    }
    if (!xfer) {
        newelement-&gt;data = malloc(datalen);
        if(newelement-&gt;data == NULL) {
            perror(""queue_add"");
            free (newelement);
            exit(EXIT_FAILURE);
        }
        memcpy(newelement-&gt;data,data,datalen);
    } else {
        newelement-&gt;data = data;
    }
</code></pre>

<p>In other words, set the final parameter to true if the data was obtained via <code>malloc</code> and you agree to give up responsibility for it - that way, the function just takes your memory block as is.</p>

<p>Otherwise, use false and a copy will be made.</p>
",0
3930180,3929884,0,"<p>In addition to the problems that <a href=""https://stackoverflow.com/questions/3929884/problem-with-priorityqueue-in-c/3929983#3929983"">paxdiablo mentioned</a>, you're also forgetting to update <code>beforefirst-&gt;next</code> in the case where you remove the head of the queue.  Here's what's happening:</p>

<pre>
Before queue_remove:

  beforefirst             head                tail
       |                   |                   |
       V                   V                   V
+-------------+     +-------------+     +-------------+
| placeholder | --> |      x      | --> |      y      | --> NULL
+-------------+     +-------------+     +-------------+



After queue_remove:

  beforefirst                             head   tail
       |                                    |      |
       V                                    V      V
+-------------+     +-------------+     +-------------+
| placeholder | --> |      x      | --> |      y      | --> NULL
+-------------+     +-------------+     +-------------+
</pre>

<p>You need to fix <code>queue_remove</code> so that <code>beforefirst-&gt;next</code> points to <code>head-&gt;next</code> if <code>head</code> is non-NULL (NULL otherwise).</p>
",0
3930094,3929884,0,"<p>Here's an access pattern that causes a problem.</p>

<pre><code>PQUEUE *queue = queue_new();
int x0 = 0;
int x1 = 1;
queue_add_priority(queue, &amp;x0, sizeof(x0), x0); //add1
queue_add_priority(queue, &amp;x1, sizeof(x1), x1); //add2
queue_remove(queue);                            //remove
queue_add_priority(queue, &amp;x0, sizeof(x0), x0); //add3
while (queue_has_next(queue))
    printf(""%d\n"", *(int *)queue_remove(queue));
</code></pre>

<p>Should items with higher priority be appearing at the head?  This doesn't happen in your code if it should.</p>

<p>After the first two adds, the count is two and the lower priority item is at the head (<code>0 1</code>, count:<code>2</code>).  The following remove takes the head element decrementing the count.  What's left is the priority 1 item (<code>1</code>, count:<code>1</code>).  The problem is adding another 0 priority item, doesn't actually add anything to the queue and the count is still incremented (<code>1</code>, count:<code>2</code>).  Then since the queue has recorded that there are 2 items when there really is only 1, the remove in the end fails.</p>

<p>The problem lies in your traversal of the queue.  More specifically where you start (the <code>beforefirst</code> pointer) is not updated after a remove.  After a remove, it is still pointing to the ""removed"" node.  In effect, all proceeding adds will be adding to the end of the previously removed node leaving the actual queue in an inconsistent state.  This is one of the reasons why it is a good idea to consistently free memory when it is not needed and to set the pointer to <code>NULL</code> afterwards.</p>
",0
3930237,3929884,0,"<p>You have to fix queue_add to also change before_first if the element inserted is at the first position.</p>

<p>Generally, I would not use before_first. Just change your loops to check for ptr to current == null and change the start element to be the first.</p>

<p>Should eliminate all other issues as well.</p>

<p>hth</p>

<p>Mario</p>
",0
5108511,5108478,1,"<p>Just because you declared the prototype for <code>error_area</code> function does not mean that you are now free to omit return type and parameter types in the <em>definition</em>. When you <em>define</em> your <code>error_area</code> you are still supposed to specify all types explicitly</p>

<pre><code>char error_area(char area_code, char S, char M, char L, char N, char P, char K, char R, char C, char U, char W, char O, char T, char F)
{
  ...
</code></pre>

<p>Instead, you defined your <code>error_area</code> without the explicit type names. The definition was interpreted in accordance with the ""old"" rules, i.e. all missing types were assumed to be <code>int</code>, so what you defined is equivalent to</p>

<pre><code>int error_area(int area_code, int S, ... /* and so on */
{
  ...
</code></pre>

<p>This is totally different from what you said in the prototype. So the compiler is telling you that your declaration contradicts your definition.</p>
",6
5507421,5507310,0,"<p>Just do it with pencil and paper ...</p>

<pre>
                 | t | x | y | s | a |
-----------------+---+---+---+---+---+
before main      | 8 |#NA|#NA|#NA|#NA|
before x=dok(s)  | 8 | ? | ? | 6 |#NA|
inside dok       | 4 |#NA|#NA|#NA| 1 |
after dok        | 4 | 5 | ? | 6 |#NA|
before y=doky(s) | 4 | 5 | ? | 6 |#NA|
inside doky      | 5 |#NA|#NA|#NA| 1 |
after doky       | 5 | 5 | 6 | 6 |#NA|
</pre>
",0
5507346,5507310,1,"<p>first t increases by a and then sum of a and t is returned</p>

<p>so, t was 4. then operator t += a is executed and t becomes 5.
and a+t == 1+5 == 6 is returned</p>
",0
5507350,5507310,5,"<blockquote>
  <p>tell me how y comes as 6 ...</p>
</blockquote>

<p>Call to <code>dok</code> function modifies <code>t</code> to 4.</p>

<pre><code>int doky(int a)
{
    a=1;
    t+=a;    // Previously t is 4 because of t-=4 in earlier function call
             // t = 4+1 = 5
    return(a+t);   // 1+5 = 6 retured
}
</code></pre>
",1
5507375,5507310,1,"<p>The value of t is changed to 4 with the dok function, and the doky function increments that value by 1 (the value in a). Sum that (5 so far) to the value of a again (set to 1), and that's 4+1+1 = 6.</p>

<pre><code>//t is 4, the value of a is irrelevant since it changes on the next instruction.

a=1;
t+=a;    // t is now 5

return(a+t);   // 1+5 = 6
</code></pre>
",0
5507382,5507310,0,"<p>y = a + t = a + t + a = 1 + 4 + 1 = 6 :)</p>
",0
6384897,6384856,0,"<p>One way would be to calculate the address difference between two consecutive int variables. </p>
",6
6384966,6384856,10,"<p>Use an array[*]:</p>

<pre><code>int a[2];
int sizeof_int = (char*)(a+1) - (char*)(a);
</code></pre>

<p>Actually, due to a note in the section on pointer arithmetic, you don't even need an array, because for the purposes of pointer arithmetic an object behaves like an array of size 1, and an off-the-end pointer is legal for an array:</p>

<pre><code>int a;
int sizeof_int = (char*)((&amp;a)+1) - (char*)(&amp;a);
</code></pre>

<p>[*] By which I mean, ""a solution to the puzzle posed is to use an array"". Don't actually use an array, use <code>sizeof</code>!</p>
",4
6384970,6384856,0,"<p>I think of two ways. One is to print '-1' as a unsigned value and deduce the size basing on the number that is printed. Second is this:</p>

<pre><code>#include &lt;stdio.h&gt;

int size()
{
  int a = 1;
  int size = 1;
  while(a&lt;&lt;=1)
    size++;
  return size;
}

int main(int argc, char** argv)
{
  printf(""Size of int: %d\n"", size());
  return 0;  
} 
</code></pre>
",4
6384996,6384856,0,"<p>Declare int, init it to -1.  Repeatedly '&lt;&lt;1' it until it's 0. Number of shifts requried = size in bits.  '&lt;&lt;3' for size in bytes.</p>

<p>Rgds,
Martin</p>
",3
7459436,7459393,0,"<p>I'm not sure (because your compiler might behave differently) but perhaps it's caused by this:</p>

<p>You're using <code>5.0</code> and <code>9.0</code> which are <code>double</code> values as well as <code>32</code> which is an <code>int</code>.</p>

<p>Try changing them to <code>5.0f</code>, <code>9.0f</code> and <code>32.0f</code>.</p>
",1
7459477,7459393,0,"<p>It seems to be a compiler issue. My compiler (Emulated Turbo C++ 3.0) was not able to save my edits properly. So I went to C:\TC\Bin\ filename.c and opened the file in Notepad. Corrected the errors and compiled it again. </p>

<p>Now it works :)</p>
",0
7180746,7180293,16,"<p>Use <code>basename</code> (which has odd corner case semantics) or do it yourself by calling <code>strrchr(pathname, '/')</code> and treating the whole string as a basename if it does not contain a <code>'/'</code> character.</p>
",0
7180307,7180293,54,"<p>See <a href=""http://linux.die.net/man/3/basename""><code>char *basename(char *path)</code></a>.</p>

<p>Or run the command ""<code>man 3 basename</code>"" on your target UNIX/POSIX system.</p>
",0
6637941,6637895,2,"<p>This is using re-direction. Instead of the input to the program coming from the keyboard it comes from a file.</p>

<p>At the DOS prompt:-</p>

<p>C:>myexe &lt; filename</p>

<p>Get to the DOS prompt in Windows use the command shell. Or start Run.. and enter cmd</p>

<p>On a Mac this is called terminal (type ""terminal"" into Searchlight to get to it).</p>
",0
6637955,6637895,4,"<p>The program in chapter 1.6 reads input from stdin. To make it read from a file, you can (on most operating systems) redirect stdin to be a file by running your program like this:</p>

<pre><code>myprogram &lt; somefile
</code></pre>

<p>Or you can pipe the content of a file to it like so:</p>

<pre><code>cat somefile | myprogram
</code></pre>

<p>On windows, you'd use the <code>type</code> program instead of <code>cat</code>,</p>

<pre><code>type somefile | myprogram
</code></pre>
",2
6638000,6637895,2,"<p>By default, your program will take input from stdin, which is a buffer which is filled based on input from your keyboard (by default). However, you can also tell your program to fill stdin from a text file instead.</p>

<p><strong>Using a *nix based system</strong>, you can simply create a text file, and save it as whatever you'd like, ""test_input"" for instance. Fill it with the input that you'd like to pass to your program, save it, and then run your program like this:</p>

<pre><code>./a.out &lt; test_input
</code></pre>

<p>This is called redirection because you are ""redirecting"" (if you will) the input to come from a file, rather than the default (keyboard). It goes both ways, you can also redirect your output to a file, rather than stdout with the other angle bracket, '>'.</p>

<p><strong>Using Visual Studio</strong>, and not popping open a command prompt to do something like the command above, you can use a C++ ifstream, put the text file in the local directory, and then simply use the ifstream everywhere instead of stdin:</p>

<pre><code>ifstream sin(""test_input.txt"" , ifstream::in);
int value;
sin &gt;&gt; value;
</code></pre>

<p>You can output to a file using an ofstream. </p>

<p>Note that ifstreams and ofstreams are C++ objects, and can't be used in C. While you can write to files and read from files in C, it's a little trickier than simply replacing all instances of cout and cin. You actually have to think about what you are reading and writing :)</p>
",1
8287691,8287673,-1,"<p>You're starting the loop by setting d = -1, it should be d = 0. So for the first element you're reading random bits of memory.</p>

<p>If you fix that, then you can change your printf to be</p>

<pre><code>printf(""%d\n"",array[d]);
</code></pre>

<p>As you've also marked this as homework, I'd advise also take a look at your loop terminating condition.</p>
",2
8287703,8287673,5,"<p>The <code>sizeof</code> operator returns a value of type <code>size_t</code>, which is an <em>unsigned</em> value. In your <code>for</code> loop condition test:</p>

<pre><code>d &lt;= (TOTAL_ELEMENTS-2)
</code></pre>

<p>you are comparing a <em>signed</em> value (<code>d</code>) with an <em>unsigned</em> value (<code>TOTAL_ELEMENTS-2</code>). This is usually a warning condition, and you should turn up the warning level on your compiler so you'll properly get a warning message.</p>

<p>The compiler can only generate code for either a signed or an unsigned comparison, and in this case the comparison is unsigned. The integer value in <code>d</code> is converted to an unsigned value, which on a 2's complement architecture ends up being <code>0xFFFFFFFF</code> or similar. This is not less than your <code>TOTAL_ELEMENTS-2</code> value, so the comparison is false.</p>
",1
6120451,6120425,4,"<p>What you are trying to do is usually dangerous:</p>

<p>In <code>returnAddress()</code> you declare a local, non-static variable <code>i</code> on the stack. Then you return its address which will be <strong>invalid</strong> once the function returned.
Additionally you try to return a <code>char *</code> while you actually have an <code>int *</code>.</p>

<p>To get rid of the warning caused by returning a pointer to a local var, you could use this code:</p>

<pre><code>void *p = &amp;x;
return p;
</code></pre>

<p>Of course printing it is completely harmless but dereferencing (e.g. <code>int x = *ptr;</code>) it would likely crash your program.</p>

<p>However, what you are doing is a great way to break things - other people might not know that you return an invalid pointer that must never be dereferenced.</p>
",0
6120463,6120425,1,"<p>Because you can access the memory of the local variable, doesn't mean it is a correct thing to do. After the end of a function call, the stack pointer backtracks to its previous position in memory, so you could access the local variables of the function, as they are not erased. But there is no guaranty that such a thing won't fail (like a segmentation fault), or that you won't read garbages.</p>
",0
6120468,6120425,1,"<p>Which warning? I get a type error (you're returning an int* but the type says char*) and a warning about returning the address of a local variable. </p>

<p>The type error is because the type you've declared for the function is lies (or statistics?).</p>

<p>The second is because that is a crazy thing to do. That address is going to be smack in the middle (or rather, near the top) of the stack. If you use it you'll be stomping on data (or have your data stomped on by subsequent function calls).</p>
",2
6120470,6120425,3,"<p>Yes, the same address is printed both times. Except that, when the address is printed in <code>main()</code>, it no longer points to any valid memory address. (The variable <code>x</code> was created in the stack frame of <code>returnAddress()</code>, which was scrapped when the function returned.)</p>

<p>That's why the warning is generated: Because you now have an address that you must not use.</p>
",0
6120496,6120425,5,"<p>The behaviour is undefined.</p>

<p>Anything is allowed to happen when you invoke undefined behaviour - including behaving semi-sanely.</p>

<p>The address of a local variable is returned.  It remains an address; it might even be a valid address if you're lucky.  What you get if you access the data that it points to is anyone's guess - though you're best off not knowing.  If you call another function, the space pointed at could be overwritten by new data.</p>

<p>You should be getting warnings about the conversion between <code>int</code> pointer and <code>char</code> pointer - as well as warnings about returning the address of a local variable.</p>
",1
6120598,6120425,1,"<p>Its not strange. The local variables of a function is allocated in the stack of that function. Once the control goes out of the function, the local variables are invalid. You may have the reference to the address but the same space of memory can be replaced by some other values. This is why the behavior is undefined. If you want reference a memory throughout your program, allocate using malloc. This will allocate the memory in heap instead of stack. You can safely reference it until you free the memory explicitly.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
char * returnAddress();
main()
{
    char *ptr;
    ptr = returnAddress();
    printf(""%p\n"",ptr);
}

char * returnAddress()
{
    char *x = malloc(sizeof(char));
    printf(""%p\n"",x);
    return x;
}
</code></pre>
",2
6114187,6114142,1,"<p>(Carl posted the right answer.  I'm posting this as an answer instead of a comment only to retain formatting.)</p>

<pre><code>int i, nhashprime = nextprime(2 * hashprime);
</code></pre>

<p>is equivalent to:</p>

<pre><code>int i;
int nhashprime = nextprime(2 * hashprime);
</code></pre>
",0
6114218,6114142,3,"<p>This initializes <code>nhashprime</code> and not <code>i</code>. The <code>int</code> part applies to both <code>i</code> and <code>nhashprime</code>, but the assignment only applies to <code>nhashprime</code>. The code is equivalent to</p>

<pre><code>int i;
int nhashprime = nextprime(2 * hashprime);
</code></pre>

<p>It's generally not a good idea to combine multiple declarations into one, except in the simple case with simple types and no initialization:</p>

<pre><code>int i, j, k;
</code></pre>

<p>Note in particular that pointer markers do not distribute to multiple identifiers either:</p>

<pre><code>int *p, i;
</code></pre>

<p>should be avoided and is equivalent to</p>

<pre><code>int *p;
int i;
</code></pre>
",0
6114160,6114142,6,"<p>No.  Your code sets only <code>nhashprime</code>.  <code>i</code> will be uninitialized.</p>
",0
6114165,6114142,5,"<pre><code>int i, nhashprime = nextprime(2 * hashprime);
</code></pre>

<p>means</p>

<pre><code>int i;
int nhashprime = nextprime(2 * hashprime);
</code></pre>
",0
6114183,6114142,0,"<p>The first one just set the <code>nhashprime</code> while leaving <code>i</code> undefined. Of course if <code>hashprime</code> is undefined (I don't see any precedent initialization) then probably also <code>nhashprime</code> will be undefined.</p>
",0
5553112,5552957,0,"<p>This is a lot to sift through, and this kind of stuff isn't easy (on purpose!)</p>

<p>Something that jumps out at me is this</p>

<pre><code>if (p[0] == NULL)
    {
        if (pos == n || key &lt; key_arr[pos])
            return SearchFailure;
        /*Shift keys and pointers left*/
        for (i=pos+1; i &lt; n; i++)
        {
            key_arr[i-1] = key_arr[i];
            p[i] = p[i+1];
        }
        return --ptr-&gt;n &gt;= (ptr==root ? 1 : min) ? Success : LessKeys;
    }/*End of if */
</code></pre>

<p>What if p[1] is also null? All that will do is move p[1] into p[0]. Perhaps you need a function called ""node reduce"" or something that ""moves the nodes to the front of the node?""</p>
",0
5191016,5191009,9,"<p><code>""""</code> searches in current file's path.
<code>&lt;&gt;</code> searches in global include paths.</p>

<p>Edit: You asked for absolute path and relative path.</p>

<p>Assume you have a file structure as follows:</p>

<pre><code>folderX
 -fileX.a
 -fileX.b
 -folderX.Y
  -fileX.Y.a
  -fileX.Y.b
 -folderX.Z
  -fileX.Z.a
</code></pre>

<p>Then, the absolute path of <code>fileX.Z.a</code> would be <code>folderX/folderX.Z/fileX.Z.a</code>, assuming that <code>folderX</code> is the topmost directory available. The relative path of <code>fileX.Z.a</code> relative to e.g. <code>fileX.a</code> is just the part <code>folderX.Z/fileX.Z.a</code>, i.e. you start the path in the directory where <code>fileX.a</code> lies.</p>
",0
5191032,5191009,16,"<p>Use <code>&lt;whatever&gt;</code> for system headers, and <code>""whatever""</code> for your own headers.</p>

<p>The difference is that when it's enclosed in quotes, the compiler will look in the local directory, but with <code>&lt;&gt;</code>, it won't. If you want to get technical, the C standard doesn't guarantee that, but it's how essentially all compilers work.</p>
",0
5191067,5191009,5,"<pre><code>#include &lt;file&gt;
</code></pre>

<p>This variant is used for system header files. It searches for a file named file in a standard list of system directories. You can prepend directories to this list with the `-I' option.</p>

<pre><code>#include ""file""
</code></pre>

<p>This variant is used for header files of your own program. It searches for a file named file first in the directory containing the current file, then in the same directories used for .</p>

<p>The argument of <code>#include</code>, whether delimited with quote marks or angle brackets, behaves like a string constant in that comments are not recognized, and macro names are not expanded. Thus, #include  specifies inclusion of a system header file named `x/*y'.</p>

<p>However, if backslashes occur within filename, they are considered ordinary text characters, not escape characters. None of the character escape sequences appropriate to string constants in C are processed. </p>

<p><a href=""http://www.gnu-m68hc11.org/doc/cpp_2.html"" rel=""noreferrer"">Reference</a>:</p>
",0
5535336,5535292,5,"<p>gcc doesn't know that. It knows there is a function <code>printf</code> and it knows how to call it, but the object file it generates contains a call to an unresolved symbol.</p>

<p>The symbol is then resolved by the linker, which is given all your object files and libraries. The linker finds the symbol <code>printf</code> in a library, and after its combined all the relevant modules, it updates the unresolved calls.</p>
",8
6073732,6073685,7,"<p>That line is attempting to read 3 strings that do not contain a space separated by spaces into method, url, protocol and if it fails to read 3 it will then enter the if block.</p>
",3
6073788,6073685,0,"<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/sscanf/"" rel=""nofollow"">scanf</a> is a function that reads data from a string and returns the number of items successfully read.</p>

<p>So, <code>scanf</code> will parse <code>line</code> to to find 3 string containing a space and separated by a space and will put these 3 strings in the 3 variables that follows (<code>method</code>, <code>url</code>, <code>protocol</code>).</p>

<p>Then if it has parsed 3 arguments, it'll enter the <code>if</code> block.</p>
",0
6073842,6073685,3,"<p>the <code>[]</code> is the scanset. If you tell <code>%[abcd]</code> then an input string only with <em>a</em> or <em>b</em> or <em>c</em> or <em>d</em> will be considered. The string would terminate at the first occurance of some other character which is <em>not</em> any of the characters in the braces.</p>

<p>The <code>^</code> inside the <code>[]</code> is used to denote the compliment of the set inside the braces. Like with the format string <code>%[^abcd]</code> will only accept all characters <em>except</em> , <em>a</em> or <em>b</em> or <em>c</em> or <em>d</em>. </p>

<p>so in <code>%[^ ]</code> , the blankspace followed by the <code>^</code> tells that, the format string will accept <em>any</em> character combination in the string which <em>does not</em> have a blankspace.</p>

<p>The format string <code>""%[^ ] %[^ ] %[^ ]""</code> will match a string which has three components separated by blankspaces. Each of the component will contain a sequence of characters which have no space inside them. </p>

<p>The function returns the number of input items successfully matched and assigned, which can be fewer than provided for, or even zero in the event of an early matching failure.</p>

<p>So the above function will return <code>3</code> only if and only if all the three components are read, that is, the input line has three partitions and for each partition the three arrays <code>method</code>, <code>url</code> and <code>protocol</code> was populated.</p>
",0
5451310,5451288,2,"<p><code>strtok()</code> returns a pointer into the string buffer.  You need to <code>strdup()</code> that string and add the result to your tree instead.  Don't forget to <code>free()</code> it when you clean up the tree.</p>
",4
5588453,5588437,7,"<p>The standard output stream is line buffered by default. That means that output shorter than a whole line is not guaranteed to be seen before execution continues with other statements.</p>

<p>Either end your output with a <code>'\n'</code> or <code>fflush(stdout)</code>.</p>

<p>Example<br>
<em>EDITED: the previous example used <code>puts</code> which already ends the output with a <code>'\n'</code></em></p>

<pre><code>int set_phone_number(struct contacts* c) {
    printf(""\nWhat is your phone number?\n""); /* \n at end of output */
    scanf("" %d"", &amp;c-&gt;phone_number);
    return 0;
}
</code></pre>

<p>or</p>

<pre><code>int set_phone_number(struct contacts* c) {
    printf(""\nWhat is your phone number? "");
    fflush(stdout);                           /* force output */
    scanf("" %d"", &amp;c-&gt;phone_number);
    return 0;
}
</code></pre>
",4
5589013,5588437,0,"<p>Windows doesn't support line buffeting. By default, streams are unbuffered in the console window and on serial lines, and fully buffered elsewhere. As an alternative to flushing manually, buffering can be disabled with setvbuf().</p>
",0
7511032,7511008,20,"<p><code>value[8]</code> was never initialized, therefore its contents are undefined and can be anything.</p>

<p>Same applies to <code>value[1]</code>, <code>value[4]</code>, <code>value[6]</code>, and <code>value[7]</code>. But they just happened to be zero.</p>
",4
7511091,7511008,6,"<p>Objects with automatic storage duration declared without an initializer have indeterminate values until they are assigned to. Technically, it causes <em>undefined behavior</em> to use the value (e.g. printing int) of an object which has an indeterminate value.</p>

<p>If you want the array to be initialized to zero you need to provide an initializer. E.g.</p>

<pre><code>int value[10] = {0};
</code></pre>
",0
6882954,6882942,2,"<pre><code>int queue_full(struct queue_structure *qs){
  if((qs-&gt;queue_rear == 10) &amp;&amp; (qs-&gt;queue_front == 0)){
    return 1;
  }
  else{
    return 0;
  }
} &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
int queue_empty(struct queue_structure *qs){
...
</code></pre>
",0
6882959,6882942,2,"<p>The final curly brace is misplaced, it should be like this:</p>

<pre><code>int queue_full(struct queue_structure *qs){
  if((qs-&gt;queue_rear == 10) &amp;&amp; (qs-&gt;queue_front == 0)){
    return 1;
  }
  else{
    return 0;
  }
} /* added the }*/

int queue_empty(struct queue_structure *qs){
  if((qs-&gt;queue_rear &amp;&amp; qs-&gt;queue_front) == -1){
    return 1;
  }
  else{
    return 0;
  }
}
/* there was a } here that I've removed */
</code></pre>

<p>Otherwise <code>queue_empty</code> is defined within <code>queue_full</code>. This is not standard C, but it appears to be supported by <code>gcc</code> as an extension, hence no errors during compilation.</p>

<p>When your code is compiled with <code>-pedantic</code>, gcc does flag it up:</p>

<pre><code>aix@aix:~$ gcc -pedantic qq.c
qq.c: In function ¡®queue_full¡¯:
qq.c:78: warning: ISO C forbids nested functions
qq.c:78: warning: ISO C90 forbids mixed declarations and code
</code></pre>
",0
5191022,5190948,2,"<p>Make the enum a typedef enum and place it above the struct.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef enum { a,b,c,d } value;

struct test
{
  value z;
  int x;
};

int main()
{
  struct test come;
  come.z = 2;

  if (a == come.z)
    printf(""they match "");
  else
    printf(""dont match"");
}
</code></pre>

<p>Edit: fixed some minor typos.</p>
",5
5191972,5190948,0,"<ul>
<li>You don't need to <code>#include &lt;stdlib.h&gt;</code></li>
<li><code>value</code> is undefined</li>
<li><code>z</code> by itself does not exist. It exists only as a member of <code>struct test</code></li>
</ul>

<p>This works (I've added whitespace, removed stdlib, changed <code>value</code> to <code>int</code>, added return type and parameters info to main, changed the <code>z</code> inside the if, added '\n' to the prints, and added <code>return 0;</code>):</p>

<pre><code>#include &lt;stdio.h&gt;

struct test
{
    int z;
    int x;
};

int main(void)
{
    enum value {a, b, c, d};
    struct test come;
    come.z = 2;
    if (a == come.z) printf(""they match\n"");
    else printf(""don't match\n"");
    return 0;
}
</code></pre>

<p>The definition of <code>enum value</code> really should be outside any function.</p>
",0
6357649,6357387,0,"<p>Can you please elaborate on the redundancy part. The thing that you are trying to do is an insecure practice and highly inadvisable as you are going for a shortening conversion(converting 16 bits to 8 bits). </p>

<p>P.S
it is just enough if you write uint8_t int_val = (uint8_t) ((basic_units * 5U)/ 1000U);</p>
",1
6357454,6357387,0,"<p>I think <strong>(uint16_t)</strong> in </p>

<blockquote>
  <p>(uint8_t) (((uint16_t ) (basic_units *
  5U)) / 1000U)</p>
</blockquote>

<p>is redundant.; </p>

<p>Simply because </p>

<blockquote>
  <p>The Uint16_t is a synonym for
  ""unsigned short""</p>
</blockquote>

<p>and </p>

<blockquote>
  <p>uint8_t is just a typedef for unsigned
  char</p>
</blockquote>
",2
6357456,6357387,2,"<p>The <code>uint8_t</code> cast is redundant. The <code>uint16_t</code> cast may have the (un)intended consequence of truncating an intermediate value in the calculation if <code>basic_units * 5U</code> would overflow a normal <code>uint16_t</code> before being divided by 1000.</p>
",4
6636308,6636295,0,"<p>I don't immediately see any performance gain or penalty using static vars.</p>

<p>What you could do is to disassemble two identical functions and compare the code, or profile each.</p>
",0
6636312,6636295,3,"<p>Yes. In your example, it probably won't help (at least enough to care about). In fact, it might even hurt a bit, because it's likely to involve loading the data from memory where a local might just involve loading a value into a register. If the initialization is slow enough for the performance to matter, making the variable <code>static</code> can improve performance as long as only being initialized once is acceptable.</p>
",2
6636330,6636295,2,"<p>The answer is technically ""no"" because the C standard doesn't specify it. </p>

<p>Efficiency depends on many things like variable usage and hardware. If you wanted, you could write variant functions that are called many, many times to test the difference. In practice, there is probably a very small and insignificant difference.</p>
",0
6636369,6636295,8,"<p>To my opinion you might reduce performance. When you use static, the memory is located at the bss part for the program. When the function is called it a access two different locations, the function memory and the parameter memory. If it is local then you may gain performance due to localization, when all parameters are at the same cache line, that is when the cpu read memory it reads a full cache line (16 bytes is a common size of line), you read all the data in one memory access into the cache.</p>
",6
6636370,6636295,0,"<p>Why don't you do a simple</p>

<pre><code>#define MY_CONSTANT 20

/* ... */

return a*MY_CONSTANT + b;
</code></pre>

<p>Maybe the compiler knows a trick to multiply by 20 (which it won't be able to apply when you multiply by <code>iamstatic</code>).</p>
",0
6636389,6636295,1,"<p>This is the most readable and highest performing version of the function.</p>

<pre><code>int calcme(int a, int b)
{
    return a*20 + b;
}
</code></pre>

<p>If you put a constant in a <code>static</code> variable, maybe the compiler will figure out that it's never changed, and convert it to an immediate operand.  Maybe the compiler won't figure it out and it will load the static from memory.</p>

<p>If you put a constant in a global variable, the compiler WILL load the variable from memory.</p>

<p>You are trying to outsmart the optimizer, and this is almost always a bad idea.</p>

<p>Here is your original code, compiled:</p>

<pre><code>    leal    (%rdi,%rdi,4), %edi
    leal    (%rsi,%rdi,4), %eax
    ret
</code></pre>

<p>This is the same code generated by <code>return a*20 + b;</code>, but your code is more difficult to read.  Note that the static variable doesn't actually get stored anywhere, it gets converted to an immediate operand (and then strength reduction reduces it even further).  You'll get the same exact performance from the following code:</p>

<pre><code>int calcme(int a, int b)
{
    int local = 20; // ""initialized"" every time the function is called
                    // yet the assembly is the same
    return a*local + b;
}
</code></pre>
",1
6636436,6636295,0,"<p>If you compile with optimization, it depends on situation.
In your example, <code>iamstatic</code> is constant, I guess speed will not change.</p>

<p>You should try to measure execution time or look into assembly code.</p>
",0
6637013,6636295,0,"<p>The accepted answer is correct, but perhaps more importantly, you should never choose the storage duration of a variable based on trying to make it ""faster"", but instead based on the correct semantics for the code.</p>

<ol>
<li>If the variable is storing global state that needs to persist across calls to the function, it should have static storage duration. (Usually this is harmful but sometimes it's a necessary evil or at least makes things sufficiently easier that you're willing to commit the offense of writing bad code to save a lot of development time/cost.)</li>
<li>If a variable is storing data that's specific to the current invocation of the function, it should have automatic storage duration (the default).</li>
<li>If data belongs to the current execution context but needs to persist after the function returns, it should be stored in an object obtained by <code>malloc</code>.</li>
</ol>
",0
7763412,7763408,3,"<p>The line <code>p[i++] = c</code> stores the character and increments <code>i</code>. The next line prints <code>p[i]</code>but i <strong>has already been incremented</strong>. Try this:</p>

<pre><code>while(c!=EOF){    
    c=fgetc(myFile);
    p[i]=c;
    printf(""%c"",p[i]);

    i++;
}
</code></pre>

<p>As a side note, you could probably rewrite it</p>

<pre><code>while((c = fgetc(stdin)) != EOF)
    *p++ = c;
</code></pre>
",3
7763430,7763408,0,"<p>problem is,</p>

<pre><code>while(c!=EOF){    
              c=fgetc(myFile);
              p[i++]=c;
              printf(""%c"",p[i]);
             }
</code></pre>

<p>look at the p[i++]=c, it stores the value of c in p[i] than increments i by one,
so when you use p[i] to print the character you are referring to another memory location which possibly holds garbage.</p>
",0
7763440,7763408,0,"<p>You are incrementing <code>i</code> after you store the char, so you are printing the next position, which you haven't stored anything to yet.</p>

<p>change the lines to:</p>

<pre><code>p[i]=c;
printf(""%c"",p[i++]); 
</code></pre>
",0
7763037,7763025,4,"<p>Because <code>fgets</code> stops at newline.</p>

<pre><code>fgets(p,count,myFile); /* Stops when it reaches `count` OR at newline. */
</code></pre>

<h3>EDIT</h3>

<p>Use <code>fread</code> instead or use the first loop (the one with <code>fgetc</code>) to store the characters and expand <code>p</code> as you go.</p>
",1
7218076,7218066,9,"<p>This is a tradition which comes from early C compilers, when compiler needs all local variable definitions before the actual code of function starts (to generate right stack pointer calculation). This was the only way of declaring local variables in early C language, both pre-standard (K&amp;R) and first C standard, C90, published at 1989-1990 ( ANSI X3.159-1989,  ISO/IEC 9899:1990 ).</p>

<p>C99 - the 1999 year ISO standard (ISO/IEC 9899:1999) of C allows declaraions in the middle of function.</p>

<p>C++ allows this because it is newer language than C. C++ standards are ISO/IEC 14882:1998 and ISO/IEC 14882:2003, so they are from 1998 and 2003 years.</p>

<p>You can initialize variable (give it a value: <code>a=4;</code>) at the definition point or any time later.</p>
",0
7218078,7218066,2,"<p>You can do this in C so long as you use a C99 compiler. The restriction was lifted in C99. </p>

<p>Presumably the restriction was originally there because compilers were less capable, or perhaps simply because nobody thought of allowing such a convenience for the programmer.</p>

<p>When answering a question like this it is sometimes worth turning it around. Why would the original designers of C have done it the other way? They didn't have C++ to guide them!</p>
",2
7218085,7218066,7,"<p>That is a left-over from early C. C99 allows variables to be defined anywhere in the function, including in loop structures.</p>

<pre><code>for (int i = 0; i &lt; 10; ++i) { int j; }
</code></pre>

<p>The throwback is from when compilers needed to know the size of the stack for the function before they instantiated the function's code. As compilers became better the requirement just became annoying.</p>
",1
7218086,7218066,1,"<p>In C++ and C99, you <em>can</em> define variables in the middle of a function. What you cannot do is <em>refer</em> to a variable that has not yet been defined.</p>

<p>From the point of view of object-oriented programming, it wouldn't make much sense otherwise: By defining a variable you bring an object to life (by calling its constructor). Before that, there <em>is</em> no object, so there's nothing to interact with until you pass the point of object construction.</p>
",2
7218125,7218066,1,"<p>Try writing a compiler with the primitive power of the old times and you'd realize flexibility is something you'd rather kill to get the software to work.</p>

<p>Putting variables first, then other statements simply made their parser/compiler code simpler.</p>
",0
5525718,5525684,0,"<p>After the scanf(""%d"",&amp;choice); call, the input will still have a '\n' (the one of the return you pressed to enter the choice). So the file name will be empty. You can add a getchar() after reading the choice (to remove the '\n').</p>
",1
5598958,5598800,0,"<p>This may not be useful depending on your situation, but some linkers do not support having multiple object files with the same name in different directories.  So if you give them some_directory/func.o and some_other_directory/func.o, only one of them will be linked.  I know CodeWarrior does this.</p>

<p>In order to avoid this problem, I make sure that all of my object files have unique names.  The convention I use is to include an abbreviation of the module name, for example, func_module.o.  With that convention it is easy to identify the object file.  Or if you need to do so programatically, any file searching technique will suffice.</p>

<p>Some versions of Visual Studio put all object files into a single directory, regardless of the organization of the .c and/or .cpp files, and will automatically append numeric suffixes to avoid conflicts.  Figuring out which object file goes to which .c file requires reading the project file.</p>
",1
6894241,6894224,0,"<p><code>fgets</code> reads a line, i.e.: until the next <code>\n</code> (newline) in the text or end of file.</p>

<p>To read the whole file, you need to repeat the sequence until <code>feof</code> returns true.</p>
",1
6894244,6894224,3,"<p>There is documentation that you can use and look up easily on your favorite search engine which will tell you the answer. For example, <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fgets.html"" rel=""nofollow"">as described on this page for <code>fgets()</code></a>:</p>

<blockquote>
  <p>The <em>fgets()</em> function shall read bytes from stream into the array
  pointed to by <em>s</em>, until <em>n-1</em> bytes are read, or a  is read and
  transferred to <em>s</em>, or an end-of-file condition is encountered. The
  string is then terminated with a null byte.</p>
</blockquote>

<p>If you need to read in the entire file at once, use <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fread.html"" rel=""nofollow""><code>fread()</code></a> instead of <code>fgets()</code>. Unlike <code>fgets()</code>, <code>fread()</code> will not stop reading on occurrence of a newline.</p>

<p>If you want to process the file line-by-line, then call <code>fgets()</code> repeatedly until <a href=""http://pubs.opengroup.org/onlinepubs/000095399/functions/feof.html"" rel=""nofollow""><code>feof()</code></a> returns a non-zero value (indicating EOF) or <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/ferror.html"" rel=""nofollow""><code>ferror()</code></a> returns a non-zero value (indicating an error condition).</p>
",1
6895068,6894224,0,"<p>fgets documention says :</p>

<p>syntex : </p>

<p>char * fgets ( char * str, int num, FILE * stream );</p>

<p>Reads characters from stream and stores them as a C string into str until (num-1) characters have been read or either a newline or a the End-of-File is reached, whichever comes first.
A newline character makes fgets stop reading, but it is considered a valid character and therefore it is included in the string copied to str.
A null character is automatically appended in str after the characters read to signal the end of the C string.</p>

<p>so here fgets only read upto 1st line 
so i suggest u to use fread()</p>
",0
5589140,5589136,9,"<p><a href=""http://www.cplusplus.com/reference/clibrary/cstring/memcpy/"" rel=""noreferrer"">memcpy</a> can do this</p>

<p>Microsoft systems can use <a href=""http://msdn.microsoft.com/en-us/library/wes2t00f%28v=vs.80%29.aspx"" rel=""noreferrer"">memcpy_s</a> for an automated check on sizes</p>

<p>You also need to be aware of pointers inside <code>struct data</code>.</p>

<pre><code>struct data { 
    int num1;
    char* name;
}
</code></pre>

<p>the content of the memory pointed by <code>char* name</code> will not be copied by memcpy. You will need some kind of serialization which is a little more complicated.</p>

<p>Here is some valid code that does it. It copies the data to and from then displays the result</p>

<pre><code>struct data{
  int num1;
  int num2;
  int num3;
};

int main(int argc, char** argv)
{
   data my_data;
   my_data.num1 = 64;
   my_data.num2 = 65;
   my_data.num3 = 66;

   char buffer[20];
   memcpy(buffer, &amp;my_data, sizeof(data));

   data copy_data;
   memcpy(&amp;copy_data, buffer, sizeof(data));

   printf(""the numbers : %d - %d - %d \n"", copy_data.num1, copy_data.num2, copy_data.mum3);



   return 0;
}
</code></pre>
",6
5589369,5589136,1,"<p>First, you need a semicolon after the closing brace. Second you should use typedefs. Third, you should capitalize user types (some people recommend putting _t after your types, but that actually violates the C standard because such names are reserved). Fourth, you need a value of that type to copy. Considering all that:</p>

<pre><code>typedef struct{
 int num1;
 int num2;
 int num3;
 int num4;
} Data;

Data foo = { 1, 2, 3, 4};
char buffer[sizeof foo]; // at least

memcpy(buffer, &amp;foo, sizeof foo);
</code></pre>

<p>However, I would question why you actually want to copy a structure to a char buffer. You should state what you're actually trying to achieve, because there's a good chance that there's a better way to go about it.</p>
",2
5589450,5589136,1,"<p>Using memcpy will enable the entire structure to be copied into a buffer.
For eg., contents of 'ob1' are copied into 'buffer' in the following code:</p>

<pre><code> #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;      
 #include &lt;string.h&gt;

    struct data{
        int num1;
        int num2;
        int num3;
        int num4;
    };
    int main()
    {
        struct data ob1;
        struct data *buffer = (struct data *)malloc(sizeof(struct data));
        if(buffer == NULL)
            {
               printf(""Memory allocation failed\n"");
               return;
            }

        ob1.num1 = 1;
        ob1.num2 = 2;
        ob1.num3 = 3;
        ob1.num4 = 4;

        memcpy(buffer, &amp;ob1, sizeof(struct data));

    }
</code></pre>
",1
5590710,5589136,7,"<p>In your comment to <a href=""https://stackoverflow.com/questions/5589136/copy-struct-to-buffer/5589369#5589369"">this answer</a>, </p>

<blockquote>
  <p>I am trying to copy this struct to a flash [memory chip]. And the Flash read/write API passes a string. ¨C Punit 2 hours ago</p>
</blockquote>

<p>you reveal that you've got an <a href=""https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem"">XY Problem</a> - You're asking how to implement your idea of a solution, not how to solve your problem.  You don't really want to copy a struct to a buffer, you want to write data in your struct to Flash using an API that requires a <code>char *</code> argument.</p>

<p>Others have pointed out that <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/memcpy.html"" rel=""nofollow noreferrer""><code>memcpy</code></a> will do what you want.  But they all involve allocating memory for this buffer in RAM.  Using these approaches will work, but they'll waste time and memory. Assuming that your Flash API has a function to the effect of: </p>

<pre><code>int WriteBlock(int address, char *data, int length);
</code></pre>

<p>and you've stored your structure in a variable called <code>data_var</code>, you can use your API in an identical fashion to memcpy:</p>

<pre><code>int success = WriteBlock(my_address, (char *) &amp;data_var, sizeof(struct data)
</code></pre>

<p>To be clearer and avoid the cast, you may wish to wrap this in a union:</p>

<pre><code>union {
    struct data{
        int num1;
        int num2;
        int num3;
        int num4;
    };
    char data_arr[sizeof(struct data)];
};
</code></pre>

<p>This will allow you to call it with a more traditional syntax.</p>

<p>Note that both methods (and memcpy!) could fail if you've got a non-contiguous structure.  For instance, perhaps your structure looks like this: </p>

<pre><code>struct data{
 int   num1;
 char  num2;
 long  num3;
 short num4;
}
</code></pre>

<p>If you're on anything other than an 8-bit system, such a structure is likely (depending on your architecture) to contain gaps.
For example, assuming num1 is 0x12345678, num2 is 0x9A, num3 is 0xBCDEF0123456789A, and num4 is 0xBCDE, you might have any the following (assuming that your memory is zero-initialized, and big-endian for clarity):</p>

<pre>
    /* 8-bit */
    0x1234 5678 9ABC DEF0 1234 5678 9ABC DE00
    /* 16-bit */
    0x1234 5678 009A BCDE F012 3456 789A BCDE
    /* 32-bit */
    0x1234 5678 0000 0000 0000 009A BCDE F012 3456 789A 0000 0000 0000 BCDE
</pre>

<p>In this case, you'll have to use something more ugly, like the following function:</p>

<pre><code>int fillDataBuffer(struct data d, char *buffer, int len) 
{
  int i, j = 0;

  for (i = sizeof(d.num1) - 1; i &gt;= 0 &amp;&amp; j &lt; len; i--, j++) {
    buffer[j] = (char) (d.num1 &gt;&gt; i); 
  }
  for (i = sizeof(d.num2) - 1; i &gt;= 0 &amp;&amp; j &lt; len; i--, j++) {
    buffer[j] = (char) (d.num2 &gt;&gt; i); 
  }
  for (i = sizeof(d.num3) - 1; i &gt;= 0 &amp;&amp; j &lt; len; i--, j++) {
    buffer[j] = (char) (d.num3 &gt;&gt; i); 
  }
  for (i = sizeof(d.num4) - 1; i &gt;= 0 &amp;&amp; j &lt; len; i--, j++) {
    buffer[j] = (char) (d.num4 &gt;&gt; i); 
  }

  if (j &gt;= len) {
    /* Error!  The buffer wasn't big enough. */
    return 0;
  } else {
    return 1;
  }
}
</code></pre>

<p>or the <code>#pragma pack()</code> macro, but that could make computations using the struct slower, and you'd probably rather pack it when you're going to do the buffering.  </p>
",2
6129005,6128872,0,"<p>In main(), NAVIO*lstNavio; is a pointer but you never allocate memory for it, you pass this uninitialized pointer into listarnavios() and start writing into some random location in memory.</p>

<p>Change main() to this and add the ampersands as osgx suggested and it should work.</p>

<pre><code>main(){
    NAVIO lstNavio; // &lt;-- stack var instead of pointer
    FILE *lista;
    lista=fopen(""navios.txt"", ""r+"");
    if(lista==NULL){
            printf(""Error"");
            exit(1);
    }
    listarnavios(lista, &amp;lstNavio);  // &lt;-- pass address of stack var
}
</code></pre>

<p>... well this was before you edited in the contents you're trying to parse.  If you're trying to read in full strings, some of which are quote delimited, you'll need to redesign your struct and the scanf/printf formats.  The simple parsing capabilities of scanf aren't going to handle your input.</p>
",0
6129057,6128872,0,"<p>You have not allocated storage for lstNavio, thus it points to invalid memory. You need to allocate it using <code>malloc(3)</code> or as John said, use a stack variable. Also, %c is <em>one</em> character. %s matches <em>non-space</em> characters, thus your fscanf will not work with %s. You will need to use:</p>

<pre><code>fscanf(""\""[^\""]\"" %d \""[^\""]\"" %d %d \""[^\""]\"" \""[^\""]\"""", ...);
</code></pre>
",0
6128894,6128872,1,"<p>""Amazon Guardian"" is not a character, it is a string.  YOu specify it as %c and pass in a char.  Of course, that too is wrong since you should be passing in a pointer, not a char.  I'm surprised the compiler did not warn you.  Turn on -Wall.</p>
",4
6128898,6128872,2,"<p>Your file reading logic is wrong - whenever you see the use of feof() you can be almost certain of that. You need to test the return value of fscanf.</p>
",0
6128972,6128872,0,"<pre><code>main(){
    NAVIO*lstNavio;
    //... 
    listarnavios(lista, *lstNavio);
}
</code></pre>

<p>Seeing this I wonder - before using <code>*lstNavio</code>, where does it get its value?</p>
",2
6130058,6128872,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;stdlib.h&gt;


typedef struct{
        char nomenavio[20];
        int codigonavio;
        char tiponavio[20];
        int tonelagemnavio;
        int anonavio;
        char paisnavio[20];
        char armadornavio[20];
}NAVIO;


void listarnavios(FILE*lista, NAVIO*lstNavio){
        do
        {
                //printf(""Scanning...\n"");
                fscanf(lista,""\""\""%[^\""]\"" %d \""%[^\""]\"" %d %d \""%[^\""]\"" \""%[^\""]\""\""\n"", lstNavio-&gt;nomenavio, &amp;lstNavio-&gt;codigonavio, lstNavio-&gt;tiponavio, &amp;lstNavio-&gt;tonelagemnavio, &amp;lstNavio-&gt;anonavio,lstNavio-&gt;paisnavio, lstNavio-&gt;armadornavio);
                //printf(""Printing...\n"");
                printf(""%s %d %s %d %d %s %s\n"", lstNavio-&gt;nomenavio, lstNavio-&gt;codigonavio, lstNavio-&gt;tiponavio, lstNavio-&gt;tonelagemnavio, lstNavio-&gt;anonavio, lstNavio-&gt;paisnavio, lstNavio-&gt;armadornavio);       
        }while(!feof(lista));
        printf(""Done\n"");
}


int main(){
        NAVIO*lstNavio = malloc(sizeof(NAVIO));
        FILE *lista;
        lista=fopen(""navios.txt"", ""r+"");
        if(lista==NULL){
                printf(""Error"");
                exit(1);
        }
        listarnavios(lista, lstNavio);
        return 0;
}
</code></pre>

<p>This should work, as long as you provided the correct formatting of the file. There are some small corrections to the fscanf formatting suggested by Mel. Some other changes have also been done to make the code run.</p>

<p>I'm no c guru so feel free to correct horrible things I might have done. But it runs :)</p>

<p>edit: comment out debug printout</p>
",0
5608195,5608179,1,"<p>No, in this case you're pointing to a real (non-null) string with a length of 0. You can simply do the following to set it to actual null:</p>

<pre><code>char* str = NULL;
</code></pre>
",4
5608228,5608179,19,"<p>Your line <code>char *str = '\0';</code> actually <em>DOES</em> set str to (the equivalent of) NULL. This is because <code>'\0'</code> in C is an integer with value 0, which is a valid null pointer constant. It's extremely obfuscated though :-)</p>

<p>Making <code>str</code> (a pointer to) an empty string is done with <code>str = """";</code> (or with <code>str = ""\0"";</code>, which will make str point to an array of <em>two</em> zero bytes).</p>

<p>Note: do not confuse your declaration with the statement in line 3 here</p>

<pre><code>char *str;
/* ... allocate storage for str here ... */
*str = '\0'; /* Same as *str = 0; */
</code></pre>

<p>which does something entirely different: it sets the first character of the string that <code>str</code> points to to a zero byte, effectively making <code>str</code> point to the empty string.</p>

<p>Terminology nitpick: strings can't be set to NULL; a C string is an array of characters that has a NUL character somewhere. Without a NUL character, it's just an array of characters and must not be passed to functions expecting (pointers to) strings.
Pointers, however, are the only objects in C that can be NULL.
And don't confuse the NULL macro with the NUL character :-)</p>
",7
6104524,6104505,2,"<p>You say: </p>

<pre><code>printf(""%d ,%d, %d, is a %d"", year,month,day,total_num);
</code></pre>

<p>That's going to print</p>

<pre><code>L, M, N, is a P
</code></pre>

<p>where <code>L</code>, <code>M</code>, <code>N</code>, and <code>P</code> are numbers.</p>

<p>You need that <code>printf()</code> <strong>before</strong> the name-of-days <code>switch</code> and need to remove the final <code>%d</code> and the <code>total_num</code> from the <code>printf</code>.  Then that <code>printf</code> will print</p>

<pre><code>L, M, N, is a
</code></pre>

<p>and the <code>printf</code>s in the name-of-days <code>switch</code> will print out the name of the day on the same line, giving you</p>

<pre><code>L, M, N, is a XXXXXXXXXXX
</code></pre>

<hr>

<p><strong>Edited to address comment:</strong></p>

<p>Look at your program for output statements.</p>

<p>The first output statement encountered are the <code>printf</code> calls in the name-of-days switch that prints out the day names.  So when your program runs given the input you mention, the first thing that will be printed out is</p>

<pre><code>Saturday
</code></pre>

<p>Then after the name-of-days switch the next <code>printf</code> is</p>

<pre><code>printf(""%d ,%d, %d, is a %d"", year,month,day,total_num);
</code></pre>

<p>Since <code>year</code> is <code>1982</code>, <code>month</code> is <code>4</code>, <code>day</code> is <code>24</code>, and <code>total_num</code> is <code>6</code>, that <code>printf</code> will output</p>

<pre><code>1982, 4, 24, is a 6
</code></pre>

<p>on the same line as the previous <code>Saturday</code> output, which means the entire output is</p>

<pre><code>Saturday1982, 4, 24, is a 6
</code></pre>
",9
6104582,6104505,1,"<p>Looks like @QuantumMechanic found the root cause of the problem, but I'd like to suggest a few changes:</p>

<pre><code>    int century = year/100;

    /* making a century table for calculation*/

    switch(century)
    {
        case 19:
            century=0;
            break;
</code></pre>

<p>I'm <em>very</em> leery of using a single variable to represent two different things. Here, <code>century</code> represents both the user-input human-readable century <em>and</em> an offset to the first day of the week for the century. Two variables would give clearer code, and allow you to re-use the <code>century</code> information later, should the need arise.</p>

<p>Second, using a <code>case</code> statement to store offsets for the months feels a little ... overdone:</p>

<pre><code>    switch (month)
    {
        case 1:
            month=0;
            break;

        case 2:
            month=3;
            break;
        case 3:
            month=3;
            break;
</code></pre>

<p>This could instead be handled with an array lookup:</p>

<pre><code>int leap_month[] = [-1, 6, 2, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5];
int norm_month[] = [-1, 0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5];

if (leap_year)
    month_offset = leap_month[month];
else
    month_offset = norm_month[month];
</code></pre>

<p>The <code>-1</code> is just to allow referring to the table with human-friendly indexes (<code>Jan == 1</code>). Feel free to remove it and use <code>leap_month[month-1]</code> or similar if you find that easier.</p>
",1
6530768,6530725,2,"<p>In addTermCode you are changing the value of the infoTerm variable. That value is a pointer, but you are only changing the local value (C is pass-by-value only). To change the pointer outside of the function, you should pass a pointer to the pointer... Something like termination_code **infoTerm, and change *infoTerm = &amp;node.</p>

<p>And, to be clear, the segmentation fault is because you are accessing the outer pointer, which has not been changed and still points to the wrong address.</p>
",0
6530784,6530725,0,"<p>The problem is the way you are passing back the new object.  Assigning the new object to the pointer will not work the way you have it written.  You should return the object instead from your addTermCode() function.</p>

<p>Basically your list2 pointer is still null.  Return the newly created object from that function and assign it to list2.</p>

<p>If not, you'll need to adjust your code so that the pointer is properly assigned.</p>

<pre><code>int addTermCode(termination_code **infoTerm, int termCode, unsigned long timerInfo)
{
     ....
     *infoTerm = node;
}

int main ()
{
    termination_code *list2=NULL;
    //Add A single node and print it.
    if(addTermCode(&amp;list2, 12, time(0))==0)
       printf(""All OK node added\n"");
    printf(""Entered info :%d %ld\n"",list2-&gt;terminationCode,list2-&gt;time);
}
</code></pre>
",1
7472524,7472504,2,"<p>Because there needs to be only one <code>main</code> in the entire part of the executable which serves as a starting point of execution. There is no need for each translation unit to have linkage to <code>main</code>.</p>

<p>Quote from C++ standard ( I assume this would be same case for C too )-</p>

<p><strong>ISO/IEC 14882:2003(E) 3.6.1</strong></p>

<blockquote>
  <p>3 [...] The linkage (3.5) of main is
  implementation-defined. [...]</p>
</blockquote>
",0
7472527,7472504,5,"<p>For a start, functions are <code>extern</code> by default.</p>

<p>Furthermore, <code>main</code> is ""special""; the linker treats it differently.</p>
",0
7473014,7472504,7,"<p>You never need to write <code>extern</code> with function declarations. Functions have external linkage by default. There's a strange unexplainable habit observed in some older code: to add <code>extern</code> to all external function declarations. (This is probably what led to your question about <code>main</code>.) In reality, it is completely unnecessary, serves no purpose and only clutters the code.</p>

<p>You can surely declare <code>main</code> with <code>extern</code>, if you so desire. But it is totally redundant.</p>
",0
7755842,7755472,0,"<p>It's terminating because there are characters left in the input stream if the input is too large. For example, if you wish to take only <strong>5</strong> characters using <code>fgets</code> but have given the input as -</p>

<blockquote>
  <p>StackOverflow</p>
</blockquote>

<p><code>Overflow</code> are left in the input stream. They need to be removed from the stream for further input operations to succeed. So, remove those extra characters from the stream using -</p>

<pre><code>fgets(ps,100,stdin);
while (getchar() != '\n');
</code></pre>

<p>Since the input stream is struck with offending characters, the <code>scanf</code> statement that actually takes the user input is not working and jumping to subsequent operations.</p>

<p>Also initialize the <code>flag</code> variable to <strong>0</strong> other wise it has garbage values.</p>
",4
7755586,7755472,1,"<p>You should check for <code>fgets</code> failure, as recommended by the <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fgets/"" rel=""nofollow"">fgets spec</a>.</p>

<pre><code>if ( fgets(ps,100,stdin) == NULL ) {
    printf(""Input failed."");
    //check for 'feof' or 'ferror' here
    return -1;
}
printf(""You entered: %s of length %d"",ps,stringlength(ps));
</code></pre>

<p>I don't see why <code>fgets</code> would be failing, but you would get an uninitialized character buffer back, which would crash <code>printf</code>.</p>

<p><strong>EDIT:</strong> You should really pay attention to your compiler warnings, too. </p>

<pre><code>prog.c:49: warning: return type defaults to ¡®int¡¯
prog.c: In function ¡®main¡¯:
prog.c:59: warning: ignoring return value of ¡®fgets¡¯, declared with attribute warn_unused_result
prog.c:63: warning: ignoring return value of ¡®scanf¡¯, declared with attribute warn_unused_result
prog.c: In function ¡®palin¡¯:
prog.c:46: warning: control reaches end of non-void function
prog.c: In function ¡®main¡¯:
prog.c:52: warning: ¡®flag¡¯ may be used uninitialized in this function
</code></pre>

<p>You can see that even your compiler recommends checking <code>fgets</code> for null. Also, <code>flag</code> should be set to <code>0</code> in the default case, otherwise you will get undefined behavior if the user enters something other than <code>1</code> or <code>2</code>.</p>

<p><strong>EDIT 2:</strong> Oh for Christ's sake! your program works fine! You forgot to check <strong>""run program""</strong> in Ideone!!!</p>

<p><a href=""http://www.ideone.com/7ecZd"" rel=""nofollow"">http://www.ideone.com/7ecZd</a></p>
",0
7756188,7755472,0,"<p>You cannot break a string literal just like that</p>

<pre><code>printf(""%s\n"", ""string literal **WRONGLY**\n
broken right after the line break."");
</code></pre>

<p>What you can do is use the preprocessor feature of joining successive string literals to make just one</p>

<pre><code>printf(""%s\n"", ""string literal **CORRECTLY**\n""
""broken because the preprocessor joins these 2 parts."");
</code></pre>
",0
6268057,6267958,3,"<p>Your problem (or at least one of them) is here:</p>

<pre><code>sscanf(line_buffer, ""%s,%d,%d,%d,%d"", node-&gt;district, node-&gt;employees, 
                      node-&gt;students, node-&gt;retried, node-&gt;others);
</code></pre>

<p>all except the first of those parameters should be pointers:</p>

<pre><code>sscanf(line_buffer, ""%s,%d,%d,%d,%d"", node-&gt;district, &amp; node-&gt;employees, 
                      &amp; node-&gt;students, &amp; node-&gt;retried, &amp; node-&gt;others);
</code></pre>

<p>Also, this:</p>

<pre><code>filename = ""testData.txt"";
</code></pre>

<p>shouldn't be there at all - the name of the file to read is passed in as a parameter to the function.</p>

<p>And lastly, this:</p>

<pre><code> struct recordNode* node;
</code></pre>

<p>should be:</p>

<pre><code> struct recordNode node;
</code></pre>

<p>and you need to change things like <code>node-&gt;district</code> to <code>node.district</code>. This is tiring work - perhaps you could put a bit more effort into chasing these things down before posting here. You will learn much more that way.</p>
",3
5536569,5536561,3,"<p>Use <a href=""http://gcc.gnu.org/onlinedocs/gcc-3.1.1/cpp/"" rel=""nofollow""><code>cpp</code>, the GCC C preprocessor</a>.</p>

<p><code>gcc</code> is only a collection of tools: <code>cpp</code>, <code>cc</code> and <code>ld</code> for examples.</p>
",2
5536571,5536561,7,"<p>You want to see the preprocessed source code. Usually your C compiler has a switch to output the preprocessed output.</p>

<p>For gcc, it's <code>gcc -E [C-filename]</code>.</p>

<p>For msvc, it's <code>cl /EP</code> or <code>cl /P</code>. See <a href=""http://msdn.microsoft.com/en-us/library/8z9z0bx6%28v=VS.100%29.aspx"">MSVC /P (Preprocess to a File)</a></p>
",1
5540567,5536561,1,"<p>For GCC you can also use <a href=""http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html"" rel=""nofollow"">-save-temps</a> option. This will generate 3 intermediate files:</p>

<ul>
<li>*.i -> C preprocessed source</li>
<li>*.s -> assembly output (by default in AT&amp;T syntax, but can be switched to Intel also).</li>
<li>*.o -> object file.</li>
</ul>

<p>I prefer this option, because it gives more control over compilation process.</p>
",0
5551901,5551810,4,"<p>It's undefined behaviour. Section 7.19.6.1/9 of C99 states:</p>

<blockquote>
  <p>If a conversion specification is invalid, the behavior is undefined.</p>
</blockquote>

<p>and none of the preceding sections allow a conversion specifier of a space. They are limited to characters from the set <code>diouxXfFeEgGaAcsPn%</code>.</p>
",2
8455431,5256000,0,"<p>The size of an Integer Variable depends upon the type of compiler:</p>

<ul>
<li><p>if you have a 16 bit compiler:</p>

<pre><code>size of int is 2 bytes
char holds 1 byte
float occupies 4 bytes
</code></pre></li>
<li><p>if you have a 32 bit compiler:</p>

<p>size of each variable is just double of its size in a 16 bit compiler</p>

<pre><code>int hold 4 bytes
char holds 2 bytes
float holds 8 bytes 
</code></pre></li>
</ul>

<p>Same thing happens if you have a 64 bit compiler, and so on.    </p>
",0
5536611,5536564,4,"<p>No, it should <em>not</em> be 12. It should <em>not</em> be anything. The ISO standard has very little to say about how things are arranged on the stack. An implementation has a great deal of leeway in moving things around and inserting padding for efficiency.</p>

<p>If you pass it through your compiler with an option to generate he assembler code (such as with <code>gcc -S</code>), it will become evident as to what's happening here.</p>

<pre><code>fun:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $40, %esp            ;; this is quite large (see below).
    movl    8(%ebp), %edx
    leal    -12(%ebp), %eax
    movl    %edx, %ecx
    subl    %eax, %ecx
    movl    %ecx, %eax
    movl    %eax, 4(%esp)
    movl    $.LC2, (%esp)
    call    printf
    leal    -12(%ebp), %eax
    movl    %eax, 4(%esp)
    movl    $.LC3, (%esp)
    call    printf
    movl    $0, %eax
    leave
    ret
</code></pre>

<p>It appears that <code>gcc</code> is pre-generating the next stack frame (the one going down to <code>printf</code>) as part of the prolog for the <code>fun</code> function. That's in this case. Your compiler may be doing something totally different. But the bottom line is: the implementation can do what it likes as long as it doesn't violate the standard.</p>

<p>That's the code from optimisation level 0, by the way, and it gives a difference of 48. When I use gcc's insane optimisation level 3, I get a difference of 4. Again, perfectly acceptable, gcc usually does some pretty impressive optimisations at that level.</p>
",0
5536613,5536564,4,"<p>You're assuming that the compiler has packed everything (instead of putting things on specific alignment boundaries), and you're also assuming that the compiler hasn't inlined the function, or made any other optimisations or transformations.</p>

<p>In summary, you cannot make any assumptions about this sort of thing, or rely on any particular behaviour.</p>
",0
5574408,5574069,1,"<p>Try putting this snippet at the top of your file:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void push(void);
void pop(void);
void display(void);

struct node* top; // good catch by Borealid
</code></pre>
",1
5574101,5574069,1,"<p>First off, the <code>main</code> function is going to have to be below the functions it calls.  Secondly, you need to <code>#import &lt;stdio.h&gt;</code> to use <code>printf</code>.  Thirdly, <code>top</code> is not a global variable so you can't just use it inside the <code>display</code> function.</p>

<p>Work from there.</p>
",3
6383089,6383067,3,"<p>Why do you have these <em>two</em> lines?</p>

<pre><code>int a,b,d;
int a,b;
</code></pre>

<p>You only need to define the variables <em>once.</em> I'd suggest getting rid of the second line.</p>

<hr>

<p>Some other things you <em>may</em> want to consider in the interests of furthering your skills.</p>

<ul>
<li>Global variables are usually consider a bad thing. There are better ways to do it which encapsulate information much better, and will reduce the likelihood of problems down the track.</li>
<li>Use meaningful variable names. They only slow down the compiler the tiniest bit and will not affect your running speed, but they make your code so much easier to maintain.</li>
<li>I like to space out expressions to make them more readable as well, like <code>d += b - c;</code> instead of <code>d+=b-c;</code>.</li>
<li>Don't bother with the <code>register</code> keyword, it's a <em>suggestion</em> to the compiler and most modern compilers are far better than developers at figuring out how best to optimise code.</li>
<li>There are two canonical prototypes for main and <code>int main()</code> isn't one of them - use <code>int main (void)</code> if you don't care about program arguments.</li>
<li>On pre-C99 compilers, you should return 0 from <code>main</code> (C99 will return 0 for you if you reach the closing brace of <code>main</code>).</li>
</ul>
",8
6383090,6383067,4,"<p>You define a and b in the global scope here:</p>

<pre><code>int a,b,d;
</code></pre>

<p>and here</p>

<pre><code>int a,b;
</code></pre>

<p>You can not define variables twice.</p>
",2
6383108,6383067,0,"<p>Right after the definition of <code>Values2()</code>, there is the line <code>int a,b;</code> which will conflict with <code>int a,b,d;</code> before <code>Values1()</code>, so you can safely remove the line <code>int a,b;</code>.</p>

<p>Besides, to get good results, you may want to set tha values of <code>a</code>, <code>b</code> and <code>c</code> in the start of the main function to get consistent results.</p>
",0
6383550,6383067,3,"<p>Your compiler is badly configured. <strong>Your program is legal C</strong>.</p>

<p>The re-declarations of <code>a</code> and <code>b</code> fall into the category of <code>""tentative definition""</code>. A properly configured C compiler, cannot stop compilation because of that.</p>
",0
5559389,5559359,10,"<p>Quote from <a href=""http://software.cfht.hawaii.edu/cfitsio/node42.html"" rel=""nofollow noreferrer"">Advanced Interface Routines</a> (the emphasis is mine) <em>(click &quot;Up&quot; in the page you linked to)</em></p>
<blockquote>
<ol>
<li><p>Each routine has 2 names: a long descriptive name and a short concise name. Both names are listed on the first line of the following descriptions, separated by a slash (/) character.</p>
</li>
<li><p>A right arrow symbol (&gt;) is used to <strong>separate the input parameters from the output parameters</strong> in the definition of each routine. This symbol is not actually part of the C calling sequence. Note that the status parameter is both an input and an output parameter.</p>
</li>
</ol>
</blockquote>
",3
5587879,5587655,7,"<p>I think that strictly speaking, <a href=""https://stackoverflow.com/questions/5587655/pragma-not-working/5587695#5587695"">Lindydancer's solution</a> needs to be of the form:</p>

<pre><code>#define COVERAGE(x) PRAGMA(Coverage_tool x)
#define PRAGMA(x) _Pragma(#x)
</code></pre>

<p>This is the form the standard uses in an example, and it needs to be this way because <code>_Pragma</code> operator processing occurs in a translation phase before string literal concatenation. <code>_Pragma</code> is defined in such a way that it'll only deal with stripping off the leading and trailing quotes when manufacturing the corresponding <code>#pragma</code> - not any other ones that are from 'concatenated' literals.</p>

<p>However, your compiler might be tolerant of the other approach (GCC isn't).</p>

<p>Note: if the <code>#pragma Coverage_tool</code> pragma needs quotes around the <code>on</code>/<code>off</code> operand, then the <code>COVERAGE</code> macro needs to be:</p>

<pre><code>#define COVERAGE(x) PRAGMA(Coverage_tool #x)
</code></pre>

<p>Note #2:  If you're using Microsoft C, I think you want:</p>

<pre><code>#define COVERAGE(x) PRAGMA(Coverage_tool x)
#define PRAGMA(x) __pragma(x)
</code></pre>

<p>because Microsoft's directive is spelled slightly differently and, more annoyingly, <em>doesn't</em> want quotes surrounding the argument to the operator.</p>

<p>But <code>Coverage_tool</code> isn't a documented pragma supported by MSVC, so I think there's still some important information missing.</p>

<p>Since you have some code coverage tool outside of the compiler that's processing this pragma, I think you'll need to hide it from the compiler.  The tool will probably define some macro name that it recognizes when it's processing that won't be defined when the compiler is doing its work. For example, lint will define the macro <code>lint</code> when it's processing and Microsoft's resource compiler will define <code>RC_INVOKED</code>.</p>

<p>Let's assume that your code coverage tool defines <code>COVERAGE_TOOL</code> when it's running. You might make both tools happy with something like:</p>

<pre><code>#if COVERAGE_TOOL
#define COVERAGE(x) PRAGMA(Coverage_tool x)
#define PRAGMA(x) _Pragma(#x)
#else
#define COVERAGE(x)
#endif
</code></pre>

<p>But I'm just guessing.  I would expect that the docs for the coverage tool would be quite explicit about how these directives need to be integrated into your code if it supports MSVC - you should look there for details (or ask the vendor).</p>
",8
5587573,5587527,3,"<p>You must end a <code>struct</code> definition with a semicolon:</p>

<pre><code>struct agenda{
    char nombre [50];
    char telefono[25];
    char email[50];
}; // &lt;- HERE
</code></pre>

<p>Similarly for variable and function declarations:</p>

<pre><code>struct nodo *nuevonodo;
int colavacia(struct nodo *);
</code></pre>

<p>And <strong>the return value of <code>main</code> has type <code>int</code>.</strong></p>
",0
5587591,5587527,3,"<pre>5587527.c:2:19: fatal error: conio.h: No such file or directory</pre>

<p>I've commented out the offending <code>#include</code> and tried again</p>

<pre>
5587527.c:11:5: error: two or more data types in declaration specifiers
5587527.c:16:5: error: two or more data types in declaration specifiers
5587527.c:17:12: error: expected ¡®=¡¯, ¡®,¡¯, ¡®;¡¯, ¡®asm¡¯ or ¡®__attribute__¡¯ before ¡®int¡¯
cc1: warnings being treated as errors
5587527.c:22:10: error: function declaration isn¡¯t a prototype
5587527.c:22:10: error: return type of ¡®main¡¯ is not ¡®int¡¯
5587527.c: In function ¡®main¡¯:
5587527.c:22:10: error: old-style function definition
5587527.c:29:9: error: implicit declaration of function ¡®strcmpi¡¯
5587527.c:29:9: error: nested extern declaration of ¡®strcmpi¡¯
5587527.c:35:15: error: ¡®struct agenda¡¯ has no member named ¡®mail¡¯
5587527.c:36:9: error: implicit declaration of function ¡®creacola¡¯
5587527.c:36:9: error: nested extern declaration of ¡®creacola¡¯
5587527.c:36:12: error: assignment makes pointer from integer without a cast
5587527.c:41:5: error: implicit declaration of function ¡®colavacia¡¯
5587527.c:41:5: error: nested extern declaration of ¡®colavacia¡¯
5587527.c:43:5: error: implicit declaration of function ¡®getch¡¯
5587527.c:43:5: error: nested extern declaration of ¡®getch¡¯
5587527.c: At top level:
5587527.c:48:18: error: function declaration isn¡¯t a prototype
5587527.c: In function ¡®nuevonodo¡¯:
5587527.c:48:18: error: old-style function definition
5587527.c:51:40: error: ¡®struc¡¯ undeclared (first use in this function)
5587527.c:51:40: note: each undeclared identifier is reported only once for each function it appears in
5587527.c:51:46: error: expected ¡®)¡¯ before ¡®nodo¡¯
5587527.c: At top level:
5587527.c:61:18: error: conflicting types for ¡®creacola¡¯
5587527.c:36:13: note: previous implicit declaration of ¡®creacola¡¯ was here
5587527.c: In function ¡®creacola¡¯:
5587527.c:65:11: error: ¡®P¡¯ undeclared (first use in this function)
5587527.c: In function ¡®mostrar¡¯:
5587527.c:85:54: error: ¡®struct agenda¡¯ has no member named ¡®mail¡¯
</pre>

<p>I've added a <code>;</code> to lines 10, 14, 16, 17 and tried again</p>

<pre>
cc1: warnings being treated as errors
5587527.c:22:10: error: function declaration isn¡¯t a prototype
5587527.c:22:10: error: return type of ¡®main¡¯ is not ¡®int¡¯
5587527.c: In function ¡®main¡¯:
5587527.c:22:10: error: old-style function definition
5587527.c:29:9: error: implicit declaration of function ¡®strcmpi¡¯
5587527.c:29:9: error: nested extern declaration of ¡®strcmpi¡¯
5587527.c:35:15: error: ¡®struct agenda¡¯ has no member named ¡®mail¡¯
5587527.c:43:5: error: implicit declaration of function ¡®getch¡¯
5587527.c:43:5: error: nested extern declaration of ¡®getch¡¯
5587527.c: At top level:
5587527.c:48:18: error: function declaration isn¡¯t a prototype
5587527.c:48:18: error: ¡®nuevonodo¡¯ redeclared as different kind of symbol
5587527.c:16:18: note: previous declaration of ¡®nuevonodo¡¯ was here
5587527.c: In function ¡®nuevonodo¡¯:
5587527.c:48:18: error: old-style function definition
5587527.c:51:40: error: ¡®struc¡¯ undeclared (first use in this function)
5587527.c:51:40: note: each undeclared identifier is reported only once for each function it appears in
5587527.c:51:46: error: expected ¡®)¡¯ before ¡®nodo¡¯
5587527.c: In function ¡®creacola¡¯:
5587527.c:65:11: error: ¡®P¡¯ undeclared (first use in this function)
5587527.c: In function ¡®mostrar¡¯:
5587527.c:85:54: error: ¡®struct agenda¡¯ has no member named ¡®mail¡¯
</pre>

<p>Fix <code>main</code> in line 22 (to <code>int main(void)</code>)</p>

<pre>
5587527.c: In function ¡®main¡¯:
5587527.c:29:9: error: implicit declaration of function ¡®strcmpi¡¯
5587527.c:29:9: error: nested extern declaration of ¡®strcmpi¡¯
5587527.c:35:15: error: ¡®struct agenda¡¯ has no member named ¡®mail¡¯
5587527.c:43:5: error: implicit declaration of function ¡®getch¡¯
5587527.c:43:5: error: nested extern declaration of ¡®getch¡¯
5587527.c: At top level:
5587527.c:48:18: error: function declaration isn¡¯t a prototype
5587527.c:48:18: error: ¡®nuevonodo¡¯ redeclared as different kind of symbol
5587527.c:16:18: note: previous declaration of ¡®nuevonodo¡¯ was here
5587527.c: In function ¡®nuevonodo¡¯:
5587527.c:48:18: error: old-style function definition
5587527.c:51:40: error: ¡®struc¡¯ undeclared (first use in this function)
5587527.c:51:40: note: each undeclared identifier is reported only once for each function it appears in
5587527.c:51:46: error: expected ¡®)¡¯ before ¡®nodo¡¯
5587527.c: In function ¡®creacola¡¯:
5587527.c:65:11: error: ¡®P¡¯ undeclared (first use in this function)
5587527.c: In function ¡®mostrar¡¯:
5587527.c:85:54: error: ¡®struct agenda¡¯ has no member named ¡®mail¡¯
</pre>

<p>Changed <code>strcmpi</code> in line 29 to <code>strcmp</code></p>

<pre>
5587527.c: In function ¡®main¡¯:
5587527.c:35:15: error: ¡®struct agenda¡¯ has no member named ¡®mail¡¯
cc1: warnings being treated as errors
5587527.c:43:5: error: implicit declaration of function ¡®getch¡¯
5587527.c:43:5: error: nested extern declaration of ¡®getch¡¯
5587527.c: At top level:
5587527.c:48:18: error: function declaration isn¡¯t a prototype
5587527.c:48:18: error: ¡®nuevonodo¡¯ redeclared as different kind of symbol
5587527.c:16:18: note: previous declaration of ¡®nuevonodo¡¯ was here
5587527.c: In function ¡®nuevonodo¡¯:
5587527.c:48:18: error: old-style function definition
5587527.c:51:40: error: ¡®struc¡¯ undeclared (first use in this function)
5587527.c:51:40: note: each undeclared identifier is reported only once for each function it appears in
5587527.c:51:46: error: expected ¡®)¡¯ before ¡®nodo¡¯
5587527.c: In function ¡®creacola¡¯:
5587527.c:65:11: error: ¡®P¡¯ undeclared (first use in this function)
5587527.c: In function ¡®mostrar¡¯:
5587527.c:85:54: error: ¡®struct agenda¡¯ has no member named ¡®mail¡¯
</pre>

<p>...
I've done a few correct errors / recompile / get more errors for you. Now it's your turn.</p>
",0
5606262,5606252,5,"<p>The order of evaluation is unspecified.</p>

<p>Read <a href=""https://stackoverflow.com/questions/3457967/what-belongs-in-an-educational-tool-to-demonstrate-the-unwarranted-assumptions-pe/3458842#3458842"">this</a> answer.</p>

<hr>
",0
5571284,5570231,0,"<p><code>scanf</code> isn't a good tool for interactive input.  </p>

<p>Better to read your whole input line as text using <code>fgets</code>, then break it into tokens using <code>strtok</code> and convert each value using <code>strtol</code> or <code>strtoul</code>.  This will give you more control, and you don't have to worry about mistakenly accepting some bad input (for example, if someone enters ""10p"", <code>scanf</code> will successfully convert and assign the <code>10</code> and leave <code>p</code> in the input stream to foul up the next read; you'd probably want to reject the entire input outright).  </p>
",0
5570314,5570231,3,"<p>Well, <code>scanf</code> does return the number of items read successfully. You can compare that value after every read to the number of items you were expecting. </p>

<p>A very simple example</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int v;
    if ( scanf( ""%d"", &amp;v ) != 1 ) {
      /* we know something went wrong */
    }    
}
</code></pre>
",2
5570359,5570231,4,"<p>Using <code>scanf</code> is almost always a bad idea: it doesn't distinguish between newlines and other whitespace, which makes it very easy not to know where you are in whatever thing you're trying to parse. Probably bettter: read in lines using <code>fgets</code> and feed each line to <code>sscanf</code>, checking the return value to make sure you got what you were looking for. Alternatively, use an actual parser: make your own using a parser generator like <code>flex</code>, or use some sort of XML for your data format and use an XML parser, or something.</p>

<p>It would probably be wise to design your data format so that it's harder for parsing to get out of sync without noticing, and to make the structure of the data more apparent to human readers.</p>
",2
5570369,5570231,2,"<pre><code>int input ;
if (scanf(""%d"", (&amp;input)) == 0)
{
    while (getchar() != '\n');    // Removes the offending characters that causes 
                                    // scanf to struck at error occured on future 
                                    // operations.
    printf("" \n Invalid value.\n"") ;
}
</code></pre>

<p>So, if you wish to user to prompt again for input, keep it in a <code>while</code> and break it if the <code>scanf</code> returned value is not <strong>0</strong>. Hope this gives you an idea.</p>
",0
5574179,5574063,2,"<pre><code>     while ( !feof( readPtr ) )
     { 
         if ( client.acctNum != 0 )
         {
</code></pre>

<p>At this point in the code, you haven't <em>read</em> anything. Nothing. :)</p>

<p>You've opened the file, you've checked to see if you've reached the end of the file, but there's no code yet to read anything from the file, so your <code>if</code> condition is just checking against the initialized structure at the start.</p>

<p>Looping over input typically works best if the input is read at the <em>top</em> of the loop. (There are exceptions, but this doesn't look like one of them.)</p>

<p>Try this as a starting point for your loop:</p>

<pre><code>while(fread(&amp;client, sizeof(struct clientData), 1, filePtr)) {
    if (client.acctNum) {
        client.balance -= charge;
        fseek(filePtr, - sizeof(struct clientData), SEEK_CUR);
        if (1 != fwrite(&amp;client, sizeof(struct clientData), 1, filePtr))
            perror(""Error writing to file"");
    }
}
</code></pre>

<p>The error handling can probably be improved; maybe the whole edit should be aborted. (Mandatory record locking on the file could have <em>some</em> writes fail and some writes succeed, but that is pretty unlikely.)</p>

<p><strong>Update</strong></p>

<p>Your <code>fseek()</code> call is basing the new file position based on multiplying the account number by the size of the <code>struct clientData</code>. This works ONLY IF your records are sorted, no numbers are skipped, and it starts at <code>0</code> and works up. (Your example input file is not sorted; you even have a record with a <code>0</code> account number in the middle of 'valid' records.) So switch to <code>fseek(..., SEEK_CUR)</code> instead.</p>
",2
5574201,5574063,0,"<p>Apart from the logic errors in your code that @sarnold pointed out, you never <code>fflush()</code> your file stream or <code>fclose()</code> it. Any updates you make probably remain in the stream buffer and become lost as your program terminates.</p>
",1
5575203,5574063,0,"<p>This is the relevant part of the code currently on display:</p>

<pre><code> cfPtr = fopen(""credit.dat"", ""rb+"");
 fread(&amp;client, sizeof(struct clientData), 1, cfPtr);
 client.balance -= serviceCharge;
 fseek(cfPtr,(client.acctNum - 1) * sizeof(struct clientData), SEEK_CUR);
 fwrite(&amp;client, sizeof(struct clientData), 1, cfPtr);
</code></pre>

<p>I will assume that error checking on the function return values is 'not needed'; it should be there, but it will complicate things slightly.  However, I wouldn't trust myself to write a program without the error checking - too many things can go wrong for my tastes (and bitter experience).</p>

<ul>
<li>You read a record at offset 0 into the file.  You then update the balance, seek to a position based on the client account number relative to the current position, and then write the data back.</li>
</ul>

<p>At another time, we can discuss the wisdom of the binary data format you are using; it is sufficient for the time being.</p>

<p>Here's code that 'works':</p>

<pre><code>#include &lt;stdio.h&gt;

struct clientData 
{ 
    int acctNum;          
    char lastName[15];  
    char firstName[10]; 
    double balance;       
};

static void print_client(struct clientData *data)
{
    printf(""%04d %-15s %-15s %6.2f\n"", data-&gt;acctNum, data-&gt;lastName,
           data-&gt;firstName, data-&gt;balance);
}

int main(void)
{ 
    FILE *cfPtr;
    struct clientData client = {0, ""Me"", ""Mine"", 50.0};
    double serviceCharge = 5.0;

    /* Initialize */
    cfPtr = fopen(""credit.dat"", ""wb"");
    fwrite(&amp;client, sizeof(struct clientData), 1, cfPtr);
    fclose(cfPtr);

    /* Update */
    cfPtr = fopen(""credit.dat"", ""rb+"");
    fread(&amp;client, sizeof(struct clientData), 1, cfPtr);
    print_client(&amp;client);
    client.balance -= serviceCharge;
    fseek(cfPtr, 0, SEEK_SET);
    fwrite(&amp;client, sizeof(struct clientData), 1, cfPtr);
    fclose(cfPtr);

    /* Validate */
    cfPtr = fopen(""credit.dat"", ""rb"");
    fread(&amp;client, sizeof(struct clientData), 1, cfPtr);
    fclose(cfPtr);
    print_client(&amp;client);

    return 0;
}
</code></pre>

<hr>

<p>This works too...it doesn't skip 0 client IDs because it doesn't generate any.  But you can deal with that.</p>

<pre><code>#include &lt;stdio.h&gt;

struct clientData 
{ 
    int acctNum;          
    char lastName[15];  
    char firstName[10]; 
    double balance;       
};

static void print_client(const struct clientData *data)
{
    printf(""%04d %-15s %-15s %6.2f\n"", data-&gt;acctNum, data-&gt;lastName,
           data-&gt;firstName, data-&gt;balance);
}

/* Initialize file */
static void init_file(const char *filename)
{
    FILE *cfPtr = fopen(filename, ""wb"");
    int i;
    for (i = 1; i &lt;= 30; i++)
    {
        struct clientData client = { i, """", """", i * 50.0};
        sprintf(client.lastName, ""Me (%d)"", i);
        sprintf(client.firstName, ""Mine (%d)"", i);
        fwrite(&amp;client, sizeof(struct clientData), 1, cfPtr);
    }
    fclose(cfPtr);
}

static void print_file(const char *filename)
{
    struct clientData client;
    FILE *cfPtr = fopen(filename, ""rb"");
    while (fread(&amp;client, sizeof(struct clientData), 1, cfPtr) == 1)
        print_client(&amp;client);
    fclose(cfPtr);
}

int main(void)
{ 
    FILE *cfPtr;
    double serviceCharge = 5.0;
    const char *filename = ""credit.dat"";
    struct clientData client;

    init_file(filename);
    printf(""Post-initialization: %s\n"", filename);
    print_file(filename);

    /* Update */
    cfPtr = fopen(filename, ""rb+"");
    while (fread(&amp;client, sizeof(struct clientData), 1, cfPtr) == 1)
    {
        client.balance -= serviceCharge;
        fseek(cfPtr, -1 * (long)sizeof(struct clientData), SEEK_CUR);
        fwrite(&amp;client, sizeof(struct clientData), 1, cfPtr);
        fseek(cfPtr, 0, SEEK_CUR);
    }
    fclose(cfPtr);

    printf(""Post-update: %s\n"", filename);
    print_file(filename);

    return 0;
}
</code></pre>

<p>See also the comments...</p>
",2
6126878,6126842,2,"<p>You need to include either """" or &lt;> around the include files. You also need a # symbol.</p>

<p>For example:</p>

<pre><code>#include &lt;sys/socket.h&gt;    
#include &lt;netinet/in.h&gt;
</code></pre>
",2
6138953,6126842,0,"<p>Those header files are available on unixy operating systems like FreeBSD, Mac OSX, and linux. Since you are using windows right now, you will have to use winsock, which is Windows' own implementation of the BSD sockets API and has different headers and some slightly different function names.</p>

<p>This is detailed in one section of Beej's guide: <a href=""http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#windows"" rel=""nofollow"">http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#windows</a></p>

<p>He also mentions installing cygwin which would allow you to use the headers you are using right now, but I'm not sure if that would be an option for you.</p>
",0
7378571,7378555,5,"<blockquote>
  <p><code>&amp;a[1]</code> and <code>&amp;a+1</code>. Are they same or different?</p>
</blockquote>

<p>Different. <code>&amp;a[1]</code> is the same as <code>(a+1)</code>. In general, <code>x[y]</code> is by definition equivalent to <code>*(x+y)</code>.</p>

<blockquote>
  <p>I wanted to know how <code>*a[5]</code> is represented in memory. Does <code>*a</code> is a base
  pointer that points to <code>a[0],a[1],a[2],a[3],a[4]</code>.</p>
</blockquote>

<p>In your second example, <code>a</code> is an array of pointers. <code>*a[i]</code> is the value of the object, the address of which is stored as the i<sup>th</sup> element in your array. <code>*a</code> in this case is the same as <code>a[0]</code>, which is the first element in your array (which is a pointer). </p>

<blockquote>
  <p><code>a=v //why this gives error</code></p>
</blockquote>

<p>Because <code>a</code> (in your last example) is a pointer to an array. You want to assign to <code>a</code>, then you need to assign the address of the array <code>v</code> (or any other array with correct dimensions);</p>

<pre><code>a = &amp;v;
</code></pre>

<p>This is very good that you've commited to understanding things, but nothing will help you better than <a href=""https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list"">a good C book</a>.</p>

<p>Hope this helps.</p>
",0
7379559,7378555,-3,"<p>Stuff you are gonna need to know when dealing with pointers is that:</p>

<pre><code>int *a and int a[]
</code></pre>

<p>is a declaration of an Array, the only diffrence is that in a[] youre gonna have to declare its constant size, *a gives you flexability, it can point at an array size 1 to infinity</p>

<pre><code>int *a[] and int **a
</code></pre>

<p>is a declaration of an Array of Array,sometimes called Matrix, the only diffrence is that in *a[] youre gonna have to declare how many Arrays a[] gonna contain pointers of, **a gives you flexability, it can point at any Array of arrays that you want it to be assigned to.</p>

<p>IN GENERAL:
    When adding &amp; to a variable, your adding a * to its Type definition:</p>

<p>int a;</p>

<p>&amp;a -> &amp;(int)=int*</p>

<p>when adding * to a variable, you decrase a * from its Type definition</p>

<p>int *a;</p>

<p>*a -> * (int * )=int</p>

<pre><code>int *a;
&amp;a - the Address given to the pointer a by the system(pointer of pointer = **a)
&amp;a+1 - the Address to the beginning of the array + 1 byte
&amp;a[1] == &amp;(a+1) - the Address to the beginning of the array + 1 size of int

int **a;
*a == a[0] - the Address of the first Array in the array of arrays a
*a[0]==a[0][0] - the first int of first array

int *a, b[5];
*a=*b - ERROR because a points at garbage to begin with
a=b - a points at array b
</code></pre>

<p>ask me what else you want to know and ill edit this answer.</p>
",3
6367461,6367428,0,"<p>Its printing the character 0x10 (16).</p>

<p>If you want the output, change your print to output the values (in this case, character, hex value, decimal value):</p>

<p><code>printf(""%c - %x - %d\n"", a, a, a);</code></p>
",0
6367470,6367428,1,"<p>The characters from 0 to 31 are non-printing characters (in your case, you've chosen 0xF, which is 15 in decimal).  Many of the obscure ones were designed for <a href=""http://en.wikipedia.org/wiki/ASR-33_Teletype"" rel=""nofollow"">teletypes</a> and other ancient equipment.  Try a character from 32 to 126 instead.  See <a href=""http://www.asciitable.com"" rel=""nofollow"">http://www.asciitable.com</a> for details.</p>

<p>In response to your second question, the character stores the decimal value 90 (as characters are really 1-byte integers).  <code>'Z'</code> is just notation that <code>Z</code> is meant to be taken as a character and not a variable.</p>
",0
6367471,6367428,2,"<p>ASCII value for 16(0x0f + 1 = 0x10) is <code>DLE (data link escape)</code> which is non-printable character.
Just Print as integer like this.</p>

<pre><code>printf(""%d\n"",a);
</code></pre>
",2
6367497,6367428,1,"<p>You can modify your program like that:</p>

<pre><code>int main ()
{
  char a=0xf;
  a=a+1;
  printf(""Decimal:%u Hexa:%x Actual Char:|%c|\n"",a,a,a);
}
</code></pre>

<p>Printf can use different formatting for a character.</p>
",4
6367834,6367428,0,"<pre><code>#include&lt;stdio.h&gt;

int main ()    
{

    char a='z';                 \\\ascii value of z is stored in a i.e 122

    a=a+1;   \\\a now becomes 123

    printf(""%c"",a);   \\\ 123 corresponds to character '{' 

}
</code></pre>
",0
6359796,6359627,0,"<p>Your overflow on the assignment, combined with sign extension when you promote it to an int to view it in hex ... see <a href=""https://stackoverflow.com/q/6257807/759749"">What&#39;s happening in the background of a unsigned char to integer type cast?</a></p>
",0
6359798,6359627,0,"<p>Any type smaller that ""int"" gets converted to ""int"" when it's passed via ""..."". This means your negative char got converted to negative int, with FFFs showing up in hex printout.</p>
",0
6359938,6359627,2,"<p>As our starting point, 220 = DC in hex, and 11011100 in binary.</p>

<p>The first bit is the sign-bit, leaving us with 1011100. Per <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two's complement</a>, if we complement it (getting 0100011), and then add one, we get 0100100 -- this is 36.</p>

<p>When it converts the signed char to signed int, it doesn't say ""this would be 220 if it's unsigned"", it says ""this is -36, make it an int of -36"", for which the 32-bit two's complement representation is FFFFFFDC, because it must be the negative value for the full size of int (this is called <a href=""http://en.wikipedia.org/wiki/Sign_extension"" rel=""nofollow"">sign-extension</a>):</p>

<pre><code>+36 as a 32-bit value: 00000000000000000000000000100100
complement:            11111111111111111111111111011011
add one:               11111111111111111111111111011100
</code></pre>

<p>Or, in hex, <code>FFFFFFDC</code>.</p>

<p>This is why you must be careful with <code>printf(""%x"", ch);</code> (and relatives) -- if you intend to just get a two-digit value, and chars are signed, you may wind up with eight digits instead. Always specify ""unsigned char"" if you need it to be unsigned.</p>
",1
6359711,6359627,2,"<p>As you pointed out, the signed car can have a max value of 127. The reason for the negative number there, however, is due to how the char is stored in memory. All signed integer types save the final bit for sign, with 0/1 denoting positive/negative. The compiler, however, does not check overflow, so when you tried to assign num to 220, it overflowed the value into the sign bit since it could not fit it into the first 7 bits of the char (chars are 1 byte). As a result, when you try to read what is in memory, it sees the sign bit as thrown making the compiler think that instead of seeing a large positive number as you intended, it is instead seeing a small negative value. Hence, the output you see.</p>

<p><strong>Edit</strong>
Responding to your updated question. All that happens is that the compiler will copy or expand the char to have 4 bytes of memory, interpret the value of the char, and rewrite it in the new int's memory. In you're case, the program at run time would think that the char has a value of -36 instead of 220 because it's interpreting those bits as a signed char before the cast. Then, when it casts, it simply creates an int with value -36.</p>
",0
5616746,5616715,4,"<p>You need to bring the declaration right after struct. See you favourite C Book for examples. </p>

<pre><code>struct gps_position
{
    float lat_radians;          //latitude in radians
    float lon_radians;          //longtiude in radians
    float alt_radians;          //altiude in radians
    double ECEF_X;              // ECEF X in metres
    double ECEF_Y;              // ECEF Y in metres
    double ECEF_Z;              // ECEF Z in metres
} ;
</code></pre>

<p>or</p>

<pre><code>typedef struct 
{
      float lat_radians;          //latitude in radians
      float lon_radians;          //longtiude in radians
      float alt_radians;          //altiude in radians
      double ECEF_X;              // ECEF X in metres
      double ECEF_Y;              // ECEF Y in metres
      double ECEF_Z;              // ECEF Z in metres
} gps_position ;
</code></pre>
",0
5616768,5616715,0,"<p>This will eradicate your error:</p>

<p>This is the right way to pass structure as arguments into function</p>

<pre><code>     #include &lt;stdio.h&gt;
     typedef struct 
     {
        float lat_radians;          //latitude in radians
        float lon_radians;          //longtiude in radians
        float alt_radians;          //altiude in radians
        double ECEF_X;          // ECEF X in metres
        double ECEF_Y;                // ECEF Y in metres
        double ECEF_Z;                // ECEF Z in metres

      } gps_position;

    void main()
    {
        gps_position gps;
            LatLongAlt_to_ECEF_coordinates(gps);
    }
</code></pre>
",0
5616770,5616715,1,"<p>First off, that is not a valid way of declaring a struct try this:</p>

<pre><code>struct gps_position
{
    float lat_radians;          //latitude in radians
    float lon_radians;          //longtiude in radians
    float alt_radians;          //altiude in radians
    double ECEF_X;              // ECEF X in metres
    double ECEF_Y;              // ECEF Y in metres
    double ECEF_Z;              // ECEF Z in metres

};
</code></pre>

<p>Second, if you want to pass a struct to a function do:</p>

<pre><code>gps_position arg;

//Do assigning stuff before the function is called.

LatLongAlt_to_ECEF_coordinates(arg);
</code></pre>
",0
5616775,5616715,1,"<p>You want to start by giving a tag to your gps_position struct:</p>

<pre><code>struct gps_position
{
    float lat_radians;          //latitude in radians
    float lon_radians;          //longtiude in radians
    float alt_radians;          //altiude in radians
    double ECEF_X;          // ECEF X in metres
    double ECEF_Y;                // ECEF Y in metres
    double ECEF_Z;                // ECEF Z in metres

};
</code></pre>

<p>What you had before defined a variable named <code>gps_position</code>, but didn't give a name to the struct itself.</p>

<pre><code>void main()
</code></pre>

<p>Not that it's particularly relevant to the question at hand, but <code>main</code> should normally return an <code>int</code>.</p>

<pre><code>{
LatLongAlt_to_ECEF_coordinates(struct gps_position {float lon; float lat; float alt} arg);
}
</code></pre>

<p>If you want to call a function with a <code>gps_position</code>, you'd normally do something like this:</p>

<pre><code>struct gps_position pos;

LatLongAlt_to_ECEF_coordinates(pos);
</code></pre>

<p>Only in a typical case, you want to pass a pointer to the struct:</p>

<pre><code>LatLongAlt_to_ECEF_coordinates(&amp;pos); 
</code></pre>

<p>Personally, I think I'd separate the radian-based coordinates from the ECEF-based coordinates:</p>

<pre><code>struct radian_coords { 
   float latitude, longitude, altitude;
}

struct ECEF_coords { 
   double X, Y, Z;
}
</code></pre>

<p>Then when you convert from one to another, you'd pass an instance of each:</p>

<pre><code>struct radian_cords r_pos = { 12345.6, 23456.7, 123.4 };
struct ECEF_coords e_pos;

LatLongAlt_to_ECEF_coordinates(&amp;r_pos, &amp;e_pos);
</code></pre>

<p>Or, you could write the function to return the correct type:</p>

<pre><code>e_pos = LatLongAlt_to_ECEF_coordinates(&amp;r_pos);
</code></pre>

<p>In this case, your function header would look something like:</p>

<pre><code>struct e_pos LatLongAlt_to_ECEF_coordinates(struct r_pos const *input) { 
    struct e_pos ret;
    // compute and assign values to ret.X, ret.Y and ret.Z
    return ret;
}
</code></pre>
",0
6271514,6270827,0,"<pre><code>FTFY: still pretty ugly hack but should work

--- 2.c 2011-06-07 13:03:48.000000000 -0700
+++ 1.c 2011-06-07 13:49:18.000000000 -0700
@@ -7,7 +7,8 @@
     int num;
 } DblLinkList;

-struct _DblLinkList *head, *tail;
+struct _DblLinkList *head = NULL;
+struct _DblLinkList *tail = NULL;

 struct _DblLinkList *init(int nElements);
 void sort(struct _DblLinkList *listNode);
@@ -35,16 +36,16 @@
     for(i = 0; i &lt; nElements; i++) {
         listNode = (struct _DblLinkList *)malloc(sizeof(struct _DblLinkList));
         listNode-&gt;num = random();
+               listNode-&gt;flink = NULL;
+               listNode-&gt;blink = NULL;

         if(head == NULL) {
             head = listNode;
-            listNode-&gt;blink = NULL;
         } else {
             tail-&gt;flink = listNode;
             listNode-&gt;blink = tail;
         }
         tail = listNode;
-        listNode-&gt;flink = NULL;
     }
     return listNode;
 }
@@ -55,29 +56,33 @@
     }
 }

-void sort(struct _DblLinkList *listNode) {
+void sort(struct _DblLinkList *_listNode) {
     //Not working properly
-    struct _DblLinkList *listNode2;
-    struct _DblLinkList *minNode;
-    struct _DblLinkList *temp = (struct _DblLinkList *)malloc(sizeof(struct _DblLinkList));
+       struct _DblLinkList* listNode = head;
+    struct _DblLinkList *listNode2 = NULL;
+    struct _DblLinkList *minNode = head;
+    struct _DblLinkList *temp = NULL;

     //start from the head and traverse the list
-    for(listNode = head; listNode != NULL; listNode = listNode-&gt;flink) {
-        minNode = listNode;
+    for(; listNode != NULL; listNode = listNode-&gt;flink) {
         listNode2 = listNode-&gt;flink;
         for(;listNode2 != NULL;  listNode2 = listNode2-&gt;flink) {
             if (listNode2-&gt;num &lt; minNode-&gt;num) {
                 minNode = listNode2;
             }
-        }
-//Problem Lies here vvvvvvvvvvvv
-            temp-&gt;flink = listNode-&gt;flink;
-            temp-&gt;blink = listNode-&gt;blink;
-            listNode-&gt;blink = listNode2;
-            listNode-&gt;flink = listNode2-&gt;flink;
-            listNode2-&gt;flink = temp;
-            listNode2-&gt;blink = temp-&gt;blink;
+                       if (listNode-&gt;num &gt; listNode2-&gt;num) {
+                               temp = listNode;
+                               listNode = listNode2;
+                               temp-&gt;flink = listNode2-&gt;flink;
+                               listNode-&gt;flink = temp;
+                               listNode-&gt;blink = temp-&gt;blink;
+                               listNode2 = temp;
+                               listNode2-&gt;blink = listNode;
+                               if (head == listNode2)
+                                       head = listNode;
+                       }
         printf(""min: %d\n"", minNode-&gt;num);
         }
     }
+}
</code></pre>
",2
6270883,6270827,2,"<p>Looks like <code>listNode2</code> can be <code>NULL</code> after that <code>for</code> loop. You should check that before you try to access <code>listNode2-&gt;flink</code>.</p>
",1
6270898,6270827,3,"<pre><code>for(;listNode2 != NULL;  listNode2 = listNode2-&gt;flink)
</code></pre>

<p>This loop <strong>only exits when listNode2 is <code>NULL</code></strong>. So we've established that at this point <code>listNode2 == NULL</code>.</p>

<blockquote>
  <p>Thou shalt not follow the NULL
  pointer, for chaos and madness await
  thee at its end.</p>
</blockquote>

<p>And here is what you're doing, breaking the second commandment</p>

<pre><code>listNode2-&gt;flink = temp;
</code></pre>
",2
6270951,6270827,2,"<p>I can see a few problems in the code:</p>

<ol>
<li>You keep inserting the same chunk of memory, <code>temp</code> when you are moving nodes around.</li>
<li>When you are moving <code>listnode</code> away, <code>listnode-&gt;flink-&gt;blink</code> (before the move) still points to <code>listnode</code>.</li>
<li>Same as #2, but for <code>listnode-&gt;blink-&gt;flink</code></li>
<li>When you move listnode, you potentially skip all the nodes between old position and <code>listnode2</code>, as <code>linstnode-&gt;flink</code> is now <code>listnode2-&gt;flink</code>, which is not necessarily the old value. This won't cause a crash, but it will leave some nodes unsorted.</li>
<li>When moving nodes around, I didn't see any special handling of <code>head</code> an <code>tail</code>, so they will probably point to weird nodes when you are done. One trick to handle this seamlessly is to make them into concrete <code>_DblLinkList</code> structures, so that the code is not riddled with <code>if</code> statements.</li>
</ol>

<p>There may be other problems.</p>
",0
5453041,5452984,1,"<p>There's no portable way to do this for the simple reason that C by itself doesn't define the concept of a stack data structure. It's completely open to the implementation how it does automatic storage and returns from function calls.</p>

<p>That being said most implementations provide some kind of stack unwinding mechanism. For example GCC/glibc provides the runtime specific function <code>backtrace</code> </p>

<p><a href=""http://www.gnu.org/s/libc/manual/html_node/Backtraces.html"" rel=""nofollow"">http://www.gnu.org/s/libc/manual/html_node/Backtraces.html</a></p>

<p>There are similar stack unwinders for other plattforms. And of course you can implement your own backtracing mechanisms through a global, thread local storage array (it can be static and must provide only enough entries for how many function calls are supported by the stack size), where at each function call the calling module (using C preprocessor <code>__FILE__</code>), the line (C preprocessor <code>__LINE__</code>) and the called function (some additional preprocessor magic) are placed.</p>
",0
5599128,5599089,3,"<p>You're not making an array of characters: you're making an array of character <em>strings</em> -- i.e., an array of pointers to arrays of characters. I am not going to rewrite the whole program for you of course, but I'll start out with two alternative possible correct declarations for your main data structure:</p>

<pre><code>char letters[] = {'a','b','c','d, 0};

char * letters = ""abcd"";
</code></pre>

<p>Either of these declares an array of five characters: a, b, c, d followed by 0, the traditional ending for a character string in C.</p>
",3
5599281,5599089,2,"<p>Another thing: rather than making assumptions about the size of things, use the language to tell you. For instance:</p>

<pre><code>char   *my_array[]            = { ""foo"" , ""bar"" , ""baz"" , ""bat"" , } ;
// the size of an element of my_array
size_t  my_array_element_size = sizeof(my_array[0]) ;
size_t  alt_element_size      = size(*my_array) ; // arrays are pointers under the hood
// the number of elements in my_array
size_t  my_array_element_cnt  = sizeof(my_array) / sizeof(*myarray ;
// the size of a char
size_t  char_size             = sizeof(*(my_array[0])) ; // size of a char
</code></pre>

<p>Another thing: understand your data structures (as noted above). You talk about chars, but your data structures are talking about <em>strings</em>. Your declarations:</p>

<pre><code>char *letters[] = {""a"",""b"",""c"",""d""};
char *buffer[4];
</code></pre>

<p>get parsed as follows:</p>

<ul>
<li><code>letters</code> is an array of pointers to char (which happen to be nul-terminated C-style strings), and it's initialized with 4 elements.</li>
<li>Like <code>letters</code>, <code>buffer</code> is an array of 4 pointers to char, but uninitialized.</li>
</ul>

<p>You are not actually dealing individual chars anywhere, even in the <code>printf()</code> statements: the <code>%s</code> specifier says the argument is a nul-terminated string. Rather, you're dealing with strings (aka pointers to <code>char</code>) and arrays of the same.</p>

<p>An easier way:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{

  char   *letters[]  = { ""a"" , ""b"" , ""c"" , ""d"" , }    ;
  size_t  letter_cnt = size(letters)/sizeof(*letters) ;
  char   *buffer[sizeof(letters)/sizeof(*letters)]    ;

  for ( int i=0 , j=letter_cnt ; i &lt; letter_cnt ; ++i )
  {
    buffer[--j] = letters[i] ;
  }

  printf(""The alphabet: "");
  for( int i = 0 ; i &lt; letter_cnt ; ++i )
  {
    printf(""%s"",letters[i]);
  }
  printf(""\n"");

  printf(""The alphabet in reverse: "");
  for( int i=0 ; i &lt; letter_cnt ; i++ )
  {
    printf(""%s"",buffer[i]);
  }
  printf(""\n"");

}
</code></pre>

<p>BTW, is this homework?</p>
",2
5599325,5599089,0,"<p>This is a case of operator precedence. When you use <code>buffer[i] = *(char**)letters + add;</code>, the <code>*</code> before the cast is performed before the <code>+</code>, making this code equivalent to <code>(*(char**)letters) + add;</code>. The first part is equivalent to the address of the first element in your array, the string ""a"". Since using string constant automatically adds a null byte, this points to <code>'a\0'</code>. It happens that the compiler placed all four strings immediately after each other in memory, so if you go past the end of that string you flow into the next. When you add to the pointer, you are moving through this character array: <code>'a\0b\0c\0d\0'</code>. Notice that each character is 2 bytes after the last. Since this is only true because the compiler placed the 4 strings directly after each other, you should never depend on it (it won't even work if you tried to re-reverse your other string). Instead, you need to put in parentheses to make sure the addition happens before the dereference, and use the 4 byte pointer size. (Of course, as pointed out by Nicholas, you shouldn't assume the size of anything. Use sizeof to get the size of a pointer instead.)</p>

<pre><code>buffer[i] = *((char**)letters + add);
</code></pre>
",0
5599361,5599089,0,"<pre><code>char *letters[] = {""a"",""b"",""c"",""d""};
</code></pre>

<p>I think you didn't get the pointer arithmetic correctly. <code>letters</code> is an array of pointers and when incremented by 1 makes to go to next row.</p>

<pre><code>letters + 1 ; // Go to starting location of 2 row, i.e., &amp;""b""
</code></pre>

<hr>

<pre><code>char *letters[] = { ""abc"" , ""def"" } ;

(letters + 1) ; // Point to the second row's first element, i.e., &amp;""d""

*((*letters) + 1) ;  // Get the second element of the first row. i.e., ""b""
</code></pre>
",0
7195165,7195088,7,"<pre><code>int *ptr = (int *) 0x67a9;
*ptr = 0xaa55;  // MBR signature ?
</code></pre>

<p><strong>EDIT</strong></p>

<p>You <em>cannot</em> change the address of a variable, you can only point to some address with a pointer, which is shown above.</p>
",4
7195132,7195088,10,"<p>Try this:</p>

<p><code>*((int*)0x67a9) = 0xaa55;</code></p>
",0
7188587,7188484,2,"<pre><code>p = ptr;
++p; /* p now points to the second element of ptr ""s+2"" */
/* s+2 points to the third element of s ""pink"" */
/* **p+1 will point to the second character of ""pink"", thus ""ink""; essentially **(s+2)+1 */
</code></pre>
",0
7188609,7188484,4,"<p>so, p is a pointer to a pointer to a string, which basically is a pointer to a char.</p>

<p>p itself points to the first element of the ptr array; after <code>p++</code> it points to the second, which is s+2.</p>

<p>s+2 points to the third element in the s array, which is ""pink""</p>

<p>these are the two levels od dereferencing performed by <code>**p</code></p>

<p>now, <code>**p</code> points to the first character of ""pink"", thus <code>**p+1</code> points to the 'i'</p>

<p>now, printf takes the pointer to the i and prints everything until the next null byte, resulting in ""ink"" being printed to your console.</p>
",0
7188629,7188484,2,"<p>You have to understand pointers.</p>

<p><code>s[0]</code> is exactly the same as <code>*s</code>.</p>

<p>If you have <code>s[0]+1</code>, it points one char further than <code>s[0]</code>.</p>

<p><code>s[1]</code> is the same as <code>*(s+1)</code>, but it is completely different from <code>*s+1</code>, which is the same as <code>s[0]+1</code>.</p>

<p>You have to draw arrows on a blackboard.</p>
",0
7188639,7188484,2,"<p>I assume you have no problem with lines I haven't directly copied</p>

<pre><code>printf(""%s\n"",*s+1); //lack
</code></pre>

<p><code>*s+1</code> is the same as <code>(*s) + 1</code></p>

<pre><code>printf(""%s\n"",s[1]+6);//pink
</code></pre>

<p><code>s[1]+6</code> is the same as <code>(s[1]) + 6</code>. <code>s[1]</code> has type <code>char*</code>, so <code>s[1]+6</code> points 6 characters to the right. <strong>But it's illegal to do that</strong>: <code>s[1]</code> only points to 6 valid characters. You just had (bad) luck that your program didn't crash.</p>

<pre><code>printf(""%s\n"",**p+1); // how does this prints ink
</code></pre>

<p><em>approximately the same things go for <code>**p+1</code> :)</em></p>
",0
7678577,7678528,1,"<p>""C"" is</p>

<pre><code>char mystring[2];
mystring[0] = 'C';
mystring[1] = '\0';
</code></pre>

<p>While 'C' is</p>

<pre><code>int mychar;
mychar = 'C';
</code></pre>
",1
7678580,7678528,2,"<p>The '3' is converted to type int, which is 4 bytes.  However ""3"" is a string with two bytes.  The first byte is the char 3 and the second is the null terminator that gets appended to all strings.</p>
",1
7678586,7678528,4,"<p>In C</p>

<p><code>3</code>: integer literal, type <code>int</code><br>
<code>'3'</code>: char literal, type <code>int</code><br>
<code>""3""</code>: string literal: type <code>char[2]</code><br></p>

<p>In your second example, <code>x</code> denotes an object of type <code>char</code>.</p>
",1
7681164,7678528,0,"<p><code>'3'</code> is a character constant.  In C, character constants have type <code>int</code> (in C++, they have type <code>char</code>).  Thus, <code>sizeof '3'</code> == <code>sizeof (int)</code>.  </p>

<p><code>""3""</code> is a string literal.  It is a 2-element array of <code>char</code> (<code>const char</code> in C++) with the values <code>{'3', '\0'}</code>.  <code>sizeof (char)</code> == 1 by definition, thus, <code>sizeof ""3""</code> == 2.  </p>

<p><code>3</code> is an integer constant.  It has type <code>int</code>.  Thus, <code>sizeof 3</code> == <code>sizeof (int)</code>.  </p>

<p>The variable <code>x</code> is declared as <code>char</code>, thus <code>sizeof x</code> == 1.  </p>
",0
5451881,5451821,1,"<pre><code>int dataarray[][MAXDATACOL]=0;
</code></pre>

<p>You can't do this because:</p>

<ul>
<li>0 is a number while dataarray is an array (so a collection of numbers)</li>
<li>you are trying to modify an out of range value. Indexes go from 0 to MAXDATACOL - 1</li>
<li>you don't specify one of the dimensions of the array</li>
</ul>
",1
5451898,5451821,0,"<pre><code>for(;;)
{
    int i,j;
    printf(""enter the x and y values terminated by ctrl Z\n"");
    if(scanf(""%d%d"",&amp;dataarray[i],&amp;dataarray[j])==EOF)
    break;
}
</code></pre>

<p>Another problem: You need to initialize the values of i, j. Also, <code>dataarray</code> is a <strong>2D array</strong>.</p>
",0
5451923,5451821,0,"<p>As BlackBear noted C arrays need to be declared with a fixed size.  They can not change in run time.  Something like int a[] can be used in a function prototype because the <em>pointer</em> to the array is passed to the function.</p>

<pre><code>#define MAXDATAROW 1000
#define MAXDATACOL 2

int main(void)
{   
    int dataarray[MAXDATAROW][MAXDATACOL]={0};
}
</code></pre>

<p>Is one way of dealing with this.  Another way is using dynamic memory allocation (malloc, or realloc).  Yet another is to use C++ containers which can resize dynamically (they allocate memory undet the hood).</p>
",0
5451994,5451821,0,"<p>I can see that you are struggling a little with this.  If I were you I would declare a point struct to hold x,y pairs.  I would also declare a large fixed size buffer to hold the values as input by the user.  Something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAX_COUNT 1000

typedef struct {
    int x;
    int y;
} point;

void addPoint(point points[], int *count, point item)
{
    points[*count] = item;
    (*count)++;
}

int main(void)
{
    point points[MAX_COUNT];
    point item;
    int i;
    int count = 0;

    printf(""enter the x and y values terminated by ctrl Z\n"");
    for(;;)
    {
        if (scanf(""%d%d"",&amp;item.x,&amp;item.y)==EOF)
            break;
        addPoint(points, &amp;count, item);
        if (count==MAX_COUNT)
        {
            printf(""Input buffer full.\n"");
            break;
        }
    }

    for (i=0; i&lt;count; i++)
        printf(""x=%d, y=%d\n"", points[i].x, points[i].y);

    return 0;
}
</code></pre>
",0
5454457,5451821,-1,"<p>fugy - if you truly thought the code you posted above might actually have <em>worked</em> (once someone here sorted out your compiler error), I'm afraid you have much to learn.</p>

<p>You haven't specified the size of the first dimension of your dataarray. Even if you <em>had</em>, it would be meaningless to assign a value of 0 to the start address of a 2D array (it already <em>has</em> a fixed unchangeable address somewhere on the stack).</p>

<p>Your <strong>main()</strong> function contains no call to <strong>EnterValues()</strong>, so that code would never execute.</p>

<p>At your current level of coding ability there is no point in defining an <strong>EnterValues()</strong> function at all. It's only called once, and you've given the parameter the same name as the variable being passed, so you might as well have put the user input loop within <strong>main()</strong> to keep the code short while you're learning.</p>

<p>You don't set any values for your index subscripts <strong>i</strong> and <strong>j</strong>. Even if you <em>had</em>, they wouldn't do what you want because they would both refer to the <em>first</em> dimension. Obviously you want to read values into two consecutive elements in the <em>second</em> dimension.</p>

<p>You have made no provision for the maximum number of input pairs allowed before the user finally presses ^Z, and I suspect you don't even understand why this is a problem.</p>

<p>I suggest you work through a lot more <em>very</em> simple coding exercises before tackling multi-dimensional arrays and dynamic storage allocation for input of indeterminate size. These are relatively advanced techniques and it's unlikely you will understand any code corrections given here until you have a much firmer grasp of the basics.</p>
",0
7387318,7386657,4,"<p>1.bit fields may be no wider </p>

<p>Let's say you want a bitfield that is 200 bits long.</p>

<pre><code>struct my_struct {
  int my_field:200;  /* Illegal! No integer type has 200 bits --&gt; compile error!
} v;
</code></pre>

<p>2.no bit field should overlap the underlying variable boundaries</p>

<p>Let's say you want two 30 bit bitfields and that the compiler uses a 32 bit integer as the underlying variable.</p>

<pre><code>struct my_struct {
  unsigned int my_field1:30;  
  unsigned int my_field2:30; /* Without padding this field will overlap a 32-bit boundary */
} v;
</code></pre>

<p>Ususally, the compiler will add padding automatically, generating a struct with the following layout:</p>

<pre><code>struct my_struct {
  unsigned int my_field1:30;  
  :2  /* padding added by the compiler */
  unsigned int my_field2:30; /* Without padding this field will overlap a 32-bit boundary */
  :2  /* padding added by the compiler */
} v;
</code></pre>
",0
7462215,7461939,0,"<p>Although the nice hints provided by wildplasser, but the code works perfectly fine. </p>

<pre><code>int main(int argc, char *argv[])
{
    int incrItems=0;
    int j;

    header = NULL;

    for(j = 1; j &lt; argc; j++)
    {
        char ch=argv[j][0];

        switch(ch)
        {
        case 'A' :
            {
                char *newURI = argv[j+1];
                char *newIP = argv[j+2];
                incrItems++;
                printf("" Adding %s %s\n"", newURI, newIP);
                addData(newURI,newIP);
                j=j+2;
                break;
            }
        }
     }
printf("" J at end is %d\n"",j);

it = header;
if(it != NULL)
do {
        printf("" %s %s\n"",it-&gt;ip, it-&gt;uri);
        it = it-&gt;next;
}while(it != NULL);

    }
</code></pre>
",0
7462045,7461939,0,"<pre><code>for(j = 1; j &lt; argc; j++)
    {
    switch(argv[j][0]) { /* no need to copy */
    case 'A' :
            incrItems++;
            /* assert (j+2 &lt; argc); */
            addData(argv[j+1], argv[j+2]); /* no need to copy */
            j=j+2;
            break;
    case 'B' :
    default:
      ...
            break;
        }
     }
</code></pre>

<p>EDIT: Note: the above is not <strong>the solution</strong>, merely a hint.
Another hint:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void addData(char *addURI, char *addIP){

    struct str_pair *tmp, **hnd;

    tmp = malloc(sizeof *tmp);
    /* assert (tmp != NULL); */
    strncpy(tmp-&gt;uri, addURI, 49); tmp-&gt;uri[49] = 0;
    strncpy(tmp-&gt;ip, addIP, 49); tmp-&gt;ip[49] = 0;
    tmp-&gt;next = NULL;

    for (hnd = &amp;header; *hnd; hnd = &amp;(*hnd)-&gt;next) {;}
    *hnd = tmp;
}
</code></pre>
",1
7462056,7461939,0,"<p>If you're inside a for, why are you incrementing the j variable? Plus, try putting some printf inside the add function to know if the arguments are correct.</p>
",0
7173054,7172860,16,"<p>It's perfectly valid for a statement in C to be just a value that gets discarded. Most people don't realise that this is exactly what happens when they code up things like:</p>

<pre><code>x++;
printf (""Hello, world\n"");
</code></pre>

<p>The former is actually an expression which just happens to have the side effect of incrementing the variable after ""returning"" it.</p>

<p>The latter function call actually returns a value (the number of characters printed) which is also discarded.</p>

<p>From a certain viewpoint, that is no different from the statements:</p>

<pre><code>42;
3 * 12;
</code></pre>

<p>other than the fact that they have no side effects which make them useful.</p>

<p>In fact, even <code>x = 1</code> is an expression where the result is discarded. It is this that makes <code>x = y = z = 0</code> possible since this is effectively:</p>

<pre><code>(x = (y = (z = 1)));
</code></pre>

<p>All of this is detailed in C99, section <code>6.8.3 Expression and null statements</code> which says, in part:</p>

<blockquote>
  <p>The expression in an expression statement is evaluated as a void expression for its side
  effects, such as assignments, and function calls which have side effects.</p>
</blockquote>
",0
7172895,7172860,4,"<p>Why should it? The first three lines in you main don't do anything and return 0; is a valid expression.</p>

<p>If you use gcc to compile the program try to enable all warnings (with -Wall parameter). This would print <code>warning: statement with no effect [-Wunused-value]</code></p>
",3
7172904,7172860,2,"<p>Because it is valid. A string or a number is a valid expression and an expression followed by semi-colon is a statement (also informally known as instruction).</p>
",3
7172906,7172860,9,"<p>It is perfectly valid for a statement to consist of just an expression. Nothing is achieved by doing so in your examples, but it's perfectly valid all the same.</p>
",0
7172921,7172860,27,"<p>Each of those statements are expressions that evaluate to a value, which is then discarded.
Compare it to if you called a function that returned an int, a char or a float, without using the return value. That's also an expression that evaluates to a value.</p>

<p>It is not uncommon to have functions that return values that the caller may or may not be interested in, like for example where <code>printf(""%d"", 9001)</code> returns the number of characters printed. A caller can use the number returned, or they can just ignore it.</p>

<p>If the compiler complained whenever you ignored a return value, you'd have a very noisy build log. Some compilers however diagnose (if sufficient warning flags are enabled) such pointless side-effect-less uses of literals and variables.</p>
",3
7172923,7172860,5,"<p>Since in c it's a valid statement but when you use java it will give you compile time error.</p>
",3
5511187,5511007,0,"<p>As nearly everyone has already said, it's undefined behavior. The reason you are printing the correct value (5) is because your program hasn't reused that memory, <em>yet</em>. Wait until your program puts something else at that address, then you will see incorrect results.</p>
",0
5511057,5511007,3,"<p><code>x</code> is pointing to a local variable inside <code>f</code> which is no longer valid by the time <code>f</code> returns.</p>

<p>EDIT: Your post doesn't make it clear what you expect should happen, but as described much clearer in other answers, <code>*x</code> is pointing to memory which you do not own, and reading from <code>*x</code> is undefined behavior, so all bets are off. If you try to read from <code>*x</code> and it happens to be 5, it is probably because the value of 5 is still on the stack. Try to insert some calls to <code>printf</code> immediately after the call to <code>f</code>, and you will probably get another result.</p>
",0
5511072,5511007,1,"<p>This is a classic...</p>

<p>The variable <code>y</code> is only alive as long as the function <code>f</code> is executed. Once it returns, the memory space occupied by <code>y</code> on the stack can be used for anything else.</p>
",0
5511075,5511007,7,"<p>It is <strong><a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behaviour</a></strong> to access memory your program does not own.</p>

<p>The memory space occupied by <code>y</code> inside the function does not belong to your program once the function finishes, and yet you access it.</p>

<p>Anything could happen.</p>

<p><em>The worst thing to happen is for the program to behave as you expect.</em><br>
When this happens, you believe it is ok to do what you did. <strong>IT IS NOT OK</strong>. Undefined Behaviour is bad.</p>

<p>Also it's not guaranteed that the same undefined behaviour happens on different runs of the program either. It can work as you expect for a while and crash when you demo it to the client (or your boss).</p>

<p><sup><em>(Some good manifestations of <strong>UB</strong> are a crash, or lemon juice starting to ooze out of the USB port)</em></sup></p>

<p>Anything can happen.</p>
",1
5511078,5511007,2,"<p>The  <code>y</code> variable sits on the stack. so you pass an address on the stack to x, and it's a valid address, but with undefined content. if you add another function (like <code>printf</code>) between the call to <code>f</code> and the check of <code>*x == 5</code> you'll probably get a different result (since the stack was changed).</p>
",0
5511083,5511007,1,"<p><code>y</code> lives only within <code>f(int**val)</code>, since it is declared in that scope.<br>
Refering to its address outside of <code>f()</code> has no clear definition (or as we <em>love</em> to to say: Undefined Behaviour.</p>
",0
5511095,5511007,0,"<p>Because y might not be valid, but it's value is still in memory. 
It'll get nasty if you call some other function or do something else which will write on it.</p>
",0
6352259,6352222,4,"<p>Just keep a whitespace flag:</p>

<pre><code>int lastWasSpace = 0;
while((c = getchar()) != EOF) {
    if(c == '\t' || c == ' ') { // you could also use isspace()
        if(!lastWasSpace) {
            lastWasSpace = 1;
            putchar(c);
        }
    } else {
        lastWasSpace = 0;
    }
}
</code></pre>
",2
6352263,6352222,1,"<p>Record when you printed a space, and don't print them anymore until you find another letter.</p>

<p>Using your code as a base:</p>

<pre><code>unsigned char space = 0;

/* reads char by char until EOF */
while((c = getchar()) != EOF)
{
    if(c == '\t')
    {
        putchar(' ');
    }
    else if(c == ' ')
    {
        /* state specific action */
        if(space == 0) {
            putchar('d');
            space = 1; /* state transition */
        }
    }
    else
    {
        /* state transition */
        if(space == 1) {
            space = 0;
        }

        putchar(c);
    }
}
</code></pre>

<p>There you go. A very, very simple state machine. It's easy as that!</p>
",2
6352271,6352222,2,"<pre><code>jcomeau@intrepid:/tmp$ cat compress.c; echo 'this     is    a  test' | ./compress 
#include &lt;stdio.h&gt;
int main() {
 int c, lastchar = 'x';
 while ((c = getchar()) != EOF) {
  if (c == '\t' || c == ' ') {
   if (lastchar != ' ') {
    putchar(' ');
    lastchar = ' ';
   }
  } else {
   putchar(c);
   lastchar = c;
  }
 }
}
this is a test
</code></pre>
",1
6352272,6352222,2,"<p>First things first, how have you declared <code>c</code>?:</p>

<pre><code>while((c = getchar()) != EOF)
</code></pre>

<p>If <code>c</code> is a <code>char</code>, then it cannot hold all characters <em>and</em> an <code>EOF</code>. Be sure <code>c</code> is declared with a datatype larger than <code>char</code> (<code>int</code> is usual).</p>

<p>Next, you can handle compressing multiple spaces with a cheap trick:</p>

<pre><code>int space_seen = 0;

while((c = getchar()) != EOF)
{

    if(c == '\t')
    {
        putchar(' ');
    }
    else if(c == ' ')
    {
        if (!space_seen)
        {
            putchar('d');
            space_seen = 1;
        }
    }
    else
    {
        putchar(c);
        space_seen = 0;
    }
}
</code></pre>

<p>This trick is also good for keeping track of parsing strings, too.</p>
",0
6352299,6352222,3,"<p>One solution:</p>

<pre><code>/*reads char by char til EOF*/
int hasspace = 0;

while((c = getchar()) != EOF)
{
    if (isspace(c))
        hasspace = 1;
    }
    else
    {
        if (hasspace)
        {
            hasspace = 0;
            putchar(' ');
        }
        putchar(c);
    }     
}
</code></pre>
",2
6669284,6669204,3,"<p>You have a typo in this line -- the assignment of <code>c = '\t'</code> always evaluates to true</p>

<pre><code>if (c == ' ' || c == '\n' || c = '\t')
</code></pre>

<p>To fix, change = to ==</p>

<pre><code>if (c == ' ' || c == '\n' || c == '\t')
</code></pre>

<p>To answer your question <strong>why does it not print anything out</strong> -- I think that the compiler is either giving your an error or warning causing the program not being linked, and hence you are not actually compiling the source code as listed, but rather you are running an old version of whatever code you compiled before.</p>
",3
6669309,6669204,1,"<p>gcc gives a compile error on this line:</p>

<pre><code>if (c == ' ' || c == '\n' || c = '\t')
</code></pre>

<p>looking @ that line, it's easy to spot a typo: <code>c = '\t')</code></p>

<p>missing an equality test, no?
:)</p>
",0
6669321,6669204,1,"<p>It looks like you are reading your input from STDIN (the keyboard) and leave the loop only on ""End of file"", which will not happen. Do as the other answer suggests.</p>
",0
6387978,6387836,0,"<p>You are right, <code>char**</code> can be consider as  an array of pointers to strings/character array/fields. How did you <code>printf</code> the <code>csvfield(i)</code>? If you did it with format ""<code>...%s...</code>"" sure it will output the string value; if you want the pointer address, use the format ""<code>...%p...</code>"".</p>
",3
6380391,6380033,0,"<p>Sometimes files use \r\n instead of \n, So, you'll want to exclude \r.</p>
",1
8276793,8276783,1,"<p>The error is here:</p>

<pre><code>printf(""Output:"", msg);
</code></pre>

<p>You're not printing the string. Try this instead:</p>

<pre><code>printf(""Output: %s"", msg);
</code></pre>

<p>The <code>%s</code> is needed to tell <code>printf()</code> to print <code>msg</code> as a string.</p>

<hr>

<p>Note that due to buffering, you may also need to add a <code>\n</code>:</p>

<pre><code>printf(""Output: %s \n"", msg);
</code></pre>

<hr>

<p>Here's another minor error:</p>

<pre><code>message[++len] = '\0';
</code></pre>

<p>should be:</p>

<pre><code>message[len] = '\0';
</code></pre>
",14
8284609,8276783,0,"<pre><code>strcpy(message,buf);    //Modified code. This line fixed the code
message[++len] = '\0';
</code></pre>

<p>I'm not sure if it is guaranteed that after the allocation of the buffer buf it is nullified. Therefore buf[len] might not be '\0' after reading and if there is no '0\' in the read text then your strcpy might run outside its bounds. So either use strncpy or change the above two lines into</p>

<pre><code>buf[len++] = '\0\;
strcpy(message,buf);
</code></pre>

<p>Also the first version places the '\0' at len+1 which in my opinion is false. Imagine you've read 0 bytes then len=0 and message[1] is set to '\0' which leaves message[0] undefined.</p>

<p>Probably your code just ran fine because there is a create change the the allocated buffer buf is either filled with zeros or your compiler actively nullifies it. But as far as I know this is not mandatory for C compilers todo.</p>
",0
8220197,8219843,1,"<p>+1 for reading it. It's a brilliant, concise book, brilliantly written.</p>
",1
8272355,8272319,1,"<p>You need to do a few things</p>

<ul>
<li>Determine size of file (checkout fstat/stat)</li>
<li>You need to malloc enough memory to hold the file</li>
<li>You can then use fread to read the conents of the file into your array (dont forget to open the file in binary mode)</li>
<li>Return you pointer (and dont forget that it has to be freed after by the function caller)</li>
</ul>
",1
8272368,8272319,0,"<p>Bit more information is required to give a good answer as the contents and nature of the file is required. </p>

<p>But generally,</p>

<p>If it is a text file see the <code>stdio</code> library - you can get the length, create an array and fill it. Otherwise (binary files) parsing it would be a good idea and return a data structure - a lot more useful</p>
",0
8272381,8272319,2,"<ol>
<li>Get the file size (see <a href=""https://stackoverflow.com/questions/238603/how-can-i-get-a-files-size-in-c"">How can I get a file&#39;s size in C?</a>)</li>
<li>Allocate memory to store contents of the file (see <a href=""http://kernel.org/doc/man-pages/online/pages/man3/malloc.3.html"" rel=""nofollow noreferrer""><code>malloc</code></a>).</li>
<li>Read contents of the file into allocated memory (see <a href=""http://kernel.org/doc/man-pages/online/pages/man2/read.2.html"" rel=""nofollow noreferrer""><code>read</code></a>).</li>
<li>Return a pointer and a length of data in bytes to the user.</li>
</ol>

<p>Don't forget to check for errors in between those steps.</p>
",0
8295487,8295024,1,"<p>Do a "" man localtime() "" . Try to figure out the structure being passed to the function and the return values . Till u write yourself you wont learn . Dont copy paste from above and submit ur homework :) </p>
",0
8295044,8295024,3,"<p>from wikipedia: <a href=""http://en.wikipedia.org/wiki/C_date_and_time_functions"" rel=""nofollow"">C date and time functions</a></p>
",0
8295058,8295024,7,"<blockquote>
  <p>How to get local system time ?
  How to split local system time into hours , minutes and seconds ?</p>
</blockquote>

<p><a href=""http://www.cplusplus.com/reference/clibrary/ctime/"" rel=""noreferrer"">time.h</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main(void) {

    time_t rawtime;
    struct tm*  time_;

    time(&amp;rawtime);
    time_ = localtime(&amp;rawtime);

    printf(""%i:%i:%i %i %i %i\n"", time_-&gt;tm_hour, time_-&gt;tm_min, 
            time_-&gt;tm_sec, time_-&gt;tm_mday, time_-&gt;tm_mon+1,
            time_-&gt;tm_year+1900);

    return 0;
}
</code></pre>

<p>Why did I do <code>+1900</code> and <code>+1</code> you can read <a href=""http://www.cplusplus.com/reference/clibrary/ctime/tm/"" rel=""noreferrer"">here</a></p>
",1
5889920,5889880,16,"<p>snprintf would be the best and easiest to use option, though it may not be ""fast"".  You didn't state what your criteria was.  Simplicity is definitely this, though:</p>

<pre><code>snprintf(prefix, sizeof(prefix), ""%s: %s: %s"", argv[0], cmd_argv[0], cmd_argv[1]);
</code></pre>
",0
5889922,5889880,29,"<pre><code>sprintf(prefix,""%s: %s: %s"",argv[0],cmd_argv[0],cmd_argv[1]);
</code></pre>

<p>Or <code>snprintf</code> to prevent buffer overruns.</p>
",2
5889926,5889880,4,"<p>If you're trying to build a string from other strings (which your example suggests), then you can use snprintf.</p>

<pre><code>char prefix[100] = """";
snprintf( prefix, sizeof(prefix), ""%s: %s: %s"", argv[0], cmd_argv[0], cmd_argv[1]);
</code></pre>

<p>If you're trying to do concatenation of an existing string, where you can't use the format approach, then you're probably stuck with multiple calls to strcat, although I'd strongly suggest that you might want to consider using <strong><code>strncat</code></strong> instead and checking to ensure you don't have buffer overruns.</p>
",0
5889984,5889880,2,"<p>you can use <a href=""http://libslack.org/manpages/snprintf.3.html"" rel=""nofollow"">snprintf</a> function</p>

<pre><code>char prefix[100];
snprintf(prefix, 100, ""%s: %s: %s"", argv[0], cmd_argv[0], cmd_argv[1]);
</code></pre>
",1
5890464,5889880,6,"<p>I might take a rep hit for this, but what the heck. The worst thing that can happen is I'll learn something.</p>

<p>I don't really use C these days, and I don't typically use C-style strings in C++. But one idea I have is to write a modified strcpy() that returns the end of the string:</p>

<pre><code>char* my_strcpy(char*dest, const char* src)
{
    while ((*dest = *src++))
        ++dest;
    return dest;
}
</code></pre>

<p>Now Shlemiel can bring his bucket along with him:</p>

<pre><code>char prefix[100] = """";
char* bucket = my_strcpy(prefix, argv[0]);
bucket = my_strcpy(bucket, "": "");
bucket = my_strcpy(bucket, cmd_argv[0]);
bucket = my_strcpy(bucket, "": "");
bucket = my_strcpy(bucket, cmd_argv[1]);
perror(prefix);
</code></pre>

<p>I haven't tested this. Comments?</p>

<p>EDIT: Removed the unnecessary <code>my_strcat()</code> function. Also it turns out to be the same as <code>stpcpy()</code>, which is apparently part of POSIX as of 2008. See <a href=""http://www.manpagez.com/man/3/stpcpy/"" rel=""noreferrer"">http://www.manpagez.com/man/3/stpcpy/</a>.</p>
",4
6125065,6125042,8,"<p>In all likelihood, there isn't any performance difference since the compiler will figure out that <code>((1&lt;&lt;24) - 1)</code> is a constant expression, and will evaluate it at compile time.</p>

<p>We can only speculate about why the original author of the code chose to write it the way they did. Perhaps they thought it better expressed the intent (""mask out all but the 24 least significant bits of <code>b</code>"").</p>

<p>If that was their reasoning, I personally would tend to agree with them.</p>
",1
6125081,6125042,14,"<p>There is no difference in performance since the compiler will perform the calculation for you.</p>

<p>The first option may be used to explicitly clarify that you are using 24 set bits. This is harder to count in the second option.</p>
",0
6125082,6125042,1,"<p>No benefit in performance for doing <code>((1&lt;&lt;24) - 1)</code>. It might be slower since it has to perform some operations (<code>&lt;&lt;</code> and <code>-</code>), while <code>0xFFFFFF</code> is a constant. Best case the compiler will calculate the 1st at compile time and they'd be equivalent.</p>
",0
6125095,6125042,1,"<p>Generally, you should avoid using statements like the first.</p>

<p>The only scenario that i can think of that the first sentence would be preferable, is if the number 24 has a meaning. (Which should have been defined and named anyway.)</p>

<p>Like, if for some reason in this line of code it can be 24, and in a different place it might be 22.</p>
",0
6125114,6125042,2,"<p>I can't see any benefit from the performance point of view, as aix says.</p>

<p>To me, anyway, it appears clearer in the first version better communicates that the constant value is 2^24-1 than the latter form. Of course, I guess this is just an opinion.</p>
",0
6125306,6125042,2,"<p>If it isn't part of a larger block of code, I like your use of <code>0xFFFFFF</code> better.</p>

<p>But, it can conceivably be part of a group of similar statements. Then the shift version is (arguably) better.</p>

<pre><code>switch (binaryprefix) {
    default:       a = 0;                   break;
    case DECABIN:  a = b &amp; ((1 &lt;&lt;  1) - 1); break;
    case HECTOBIN: a = b &amp; ((1 &lt;&lt;  2) - 1); break;
    case KILOBIN:  a = b &amp; ((1 &lt;&lt;  3) - 1); break;
    case MEGABIN:  a = b &amp; ((1 &lt;&lt;  6) - 1); break;
    /* ... */
    case ZETTABIN: a = b &amp; ((1 &lt;&lt; 21) - 1); break;
    case YOTTABIN: a = b &amp; ((1 &lt;&lt; 24) - 1); break;
}
</code></pre>
",0
6125722,6125042,0,"<p>Strictly speaking, the expression</p>

<pre><code>(1&lt;&lt;24)
</code></pre>

<p>is non-portable and may be undefined behaviour, because 1 is treated as an int, and the standard guarantees only 16 bits for an int. If you still happen to code for such an implementation... If a and b are ints, then you can safely deduce that the target are more modern implementations only, having ints with 32 or more bits, of course.</p>
",1
6642361,6642350,6,"<p>The C standard does not mandate whether the implementation uses 2's complement, 1's complement, or something else.  So the representation of negative values is not mandated either.</p>

<p>However, in your particular case, <code>0x3</code> is a positive value, so sign-extension and zero-extension are the same thing!</p>
",3
6642451,6642350,0,"<p>As far as sign-extending, it depends if the values are signed or unsigned.</p>

<p>However, in your example, the high bit will not be set so it doesn't matter. The result would be zero extended.</p>
",0
6068498,5907790,0,"<p>You can try ollydbg with the <a href=""http://www.woodmann.com/collaborative/tools/index.php/OllyFlow_%28+_OllyGraph%29"" rel=""nofollow"">ollyflow</a> plugin, or have a look at IDA
 with its <a href=""http://www.hexblog.com/?p=99"" rel=""nofollow"">call graphing plugin</a> (there are other plugins along these lines as well).</p>
",0
6069063,5907790,3,"<p>I recommend <a href=""http://www.gnu.org/software/ddd/"" rel=""nofollow"">ddd</a> for fancy GUI debugging visualizations. It visualizes all the data structures and makes pretty graphs and gives you access to your regular debugger.</p>
",0
6068330,5907790,1,"<p>For C++, there are educational program visualizers that you might want to try:</p>

<ul>
<li><a href=""http://www.cs.tut.fi/~vip/en/"" rel=""nofollow"">VIP</a> (Visual InterPreter), you should be able to visualize your own code by editing one of the examples on the site. Supports only a C++ subset, though.</li>
<li><a href=""http://www.theteachingmachine.org/"" rel=""nofollow"">The Teaching Machine</a>, can be used as a Java program or an Eclipse plugin.</li>
</ul>

<p>EDIT: Updated the The Teaching Machine link.</p>
",1
6069168,5907790,2,"<p>Oracle Studio for Linux (former Sun Studio) Performance Analyzer has the timeline feature.
That is exactly an animated stack representation. </p>

<p>Like on this screenshot:</p>

<p><img src=""https://i.stack.imgur.com/u7Ace.gif"" alt=""enter image description here""></p>
",0
7504290,7504271,10,"<p>This is not OK:</p>

<pre><code>int
main(void)
{
    return 0;
{
^ ???
</code></pre>
",2
6616082,6616036,1,"<p>You didn't initialize <code>program_id_DB</code>, so it's free to contain anything it wants. Set it to zero before you start:</p>

<pre><code>memset(program_id_DB, 0, 10);
</code></pre>

<p>(You need to <code>#include &lt;string.h&gt;</code> for <code>memset</code>.)</p>

<p>In fact, what you're doing is terribly dangerous because there's no guarantee that the string you pass to <code>printf</code> is null-terminated! Always zero the array before use and copy at most 9 non-null characters into it.</p>
",0
6616083,6616036,0,"<p>You need to put a <code>\0</code> to mark the string's end.</p>

<p>A way to do it is: <code>memset(program_id_DB, 0, sizeof(program_id_DB));</code> before you <code>strncpy</code> to it.</p>
",0
6616091,6616036,0,"<p>You have to append a null-terminating character at the end of the <code>program_id_DB</code> string as <code>strncpy</code> does not do this automatically for you if you've already copied N characters (i.e., in your case you're copying a total of eight characters, so there will not be a null-terminating character copied into the buffer if you copy more than seven characters).  Either that, or zero-initialize your <code>program-id_DB</code> string using <code>memset</code> before using it with <code>strncpy</code>.</p>
",0
6616099,6616036,0,"<p><a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strncpy.html"" rel=""nofollow""><code>strncpy</code></a> is a bitch!</p>

<p>It doesn't terminate the string. You need to terminate the string yourself.</p>

<pre><code>if (pos) {
    strncpy(program_id_DB,data_DB, pos-data_DB);
    program_id_DB[pos - data_DB] = 0;
}
</code></pre>

<p>And if the string is too small, strncpy will set the remainder with zeros.</p>

<pre><code>strncpy(dst, src, 1000); /* always writes 1000 bytes, whether it needs to */
</code></pre>
",0
7205457,7205420,18,"<p>No, you can't do that. The names of variables do not even <em>exist</em> after your code is compiled and linked (unless you're keeping debugging information around), so you can't get at it at run time.</p>

<p>In C (in contrast to very dynamic languages such as JavaScript or classical Lisp), the <em>only</em> role of variable names is to tell the compiler/linker which declaration you're pointing at when you mention a variable in the source code. Once these connections have been made and represented in the compiler's internal data structures, there is no further use for the names (again, except for debugging and/or pretty-printing of error messages from the compiler).</p>
",1
7207171,7205420,1,"<p>Everything that Henning said before me is correct.  In addition, the target of a pointer might <em>not even have</em> a variable name.  For example, consider:</p>

<pre><code>char a;
char *ptr = &amp;a + 5;
</code></pre>

<p>Now ptr is pointing somewhere that doesn't have anything to do with a (and in fact might be pointing outside of the memory allocated for your program and doing anything with that pointer could cause a segmentation fault).</p>
",0
7216869,7205420,0,"<p>It is not possible to get the name of the variables <code>p</code> or <code>q</code> point to if you compile and execute the program traditionally, because one of the things the compiler does is forget the name of the variables, keeping only addresses. </p>

<p>Depending on what you are trying to do, you may execute the program in a non-traditional execution environment where the names are preserved. For instance,</p>

<pre>
~ $ cat t.c
main(){
 char name[20];
 char *p=name;
 int door_no;
 int *q= & door_no;
}
~ $ frama-c -val t.c
[kernel] preprocessing with ""gcc -C -E -I.  t.c""
...
[value] ====== VALUES COMPUTED ======
[value] Values for function main:
          p ¡Ê {{ &name ;}}
          q ¡Ê {{ &door_no ;}}
          __retres ¡Ê {0; }
</pre>
",0
5753521,5753516,5,"<p><s>You forgot to define <code>main</code>. Or you defined it, but forgot to link the object file containing it into the program.</s></p>

<p>You're compiling a library, not a program. First compile the library using the <code>Makefile</code> that comes with it, then write a program to the library's API, then compile that and link it to the library.</p>
",4
6635766,6635697,1,"<p>You should try to improve the program stepwise, and as it's written in C making it OOPSy is probably not the highest priority.  Eg start out by improving the selection logic by introducing a <code>switch()</code> statement:</p>

<pre><code>switch (dir[i]) {
    case 'l':
        ...
        break;
    case 'r':
        ...
        break;
    default:
        ....
        break;
}
</code></pre>

<p>You can also replace the inner if-chain with a switch, but that would get pretty messy. So, break that inner construction out in a function.</p>

<pre><code>char newa (char olda) {
    if(olda=='n') return 'w';
    if(olda=='w') return 's';
    if(olda=='s') return 'e';
    return 'n';
}
</code></pre>

<p>See?  Easier on the eye even with plain if's :-)
That way the inner block becomes</p>

<pre><code>a = newa(a);
</code></pre>

<p>Bonus points if you figure out how to fold the 3 very similar but not entirely identical inner blocks into 1 function!</p>

<p>And so on.  Just keep on improving step-wise, making your program more readable at every iteration.  </p>

<p>Ah yes, and while you're at it, put some useful comments here and there, especially comments that will help you figure out in 3 months what the &amp;!@%#&amp; you tried to achieve with a certain function :-)</p>

<p>Edit: according to <a href=""http://en.wikipedia.org/wiki/Indentation"" rel=""nofollow"">Wikipedia</a> indentation is</p>

<blockquote>
  <p>The placement of text farther to the
  right to separate it from surrounding
  text.</p>
</blockquote>

<p>And I'm incredibly puzzled that this concept seems foreign to you.</p>
",2
6636172,6635697,0,"<p>One that's small enough that it's often easy to miss is:</p>

<pre><code>for(i=0;i&lt;strlen(dir);i++)
</code></pre>

<p>The compiler doesn't (at least normally) have any way of knowing that <code>strlen</code> will return the same result from every call, so it'll end up being called on every iteration of the loop. To prevent that, you want to do something like:</p>

<pre><code>size_t len = strlen(dir);
for (i=0; i&lt;len; i++) /* ... */
</code></pre>

<p>You're currently doing the conversion of (apparently) directions using cascaded <code>if</code> statements. I'd probably build a small table, and just do a table lookup:</p>

<pre><code>char results[2]['z'-'a'];

results[0]['n'-'a'] = 'w';
results[0]['w'-'a'] = 's';
results[0]['s'-'a'] = 'e';
results[0]['e'-'a'] = 'n';
results[1]['n'-'a'] = 'e';
results[1]['e'-'a'] = 's';
results[1]['s'-'a'] = 'w';
results[1]['w'-'a'] = 'n';

a = results[dir[i]=='r'][a-'a'];
</code></pre>
",2
7510910,7510887,1,"<p>Let's assume we have this array of integers:</p>

<pre><code>#define CAPACITY 42
int foo[CAPACITY];
</code></pre>

<p>And these two functions that process it:</p>

<pre><code>void func1(int* begin, int* end) {
    // Loop over the array
    while(begin &lt; end) {
        int val = *begin++; // process element
    }
}

void func2(int* begin, int size) {
    // Loop over the array
    for(int i = 0; i &lt; size; ++i) {
        int val = begin[i]; // process element
    }
}
</code></pre>

<p>The first one would be called like <code>func1(foo, foo + CAPACITY)</code>: passing in a pointer to the start of the array, and a pointer to just beyond the last element.</p>

<p>The second would be called like <code>func2(foo, CAPACITY)</code>: passing in a pointer to the start of the array and the array size.</p>

<p>Due to how pointer arithmetic works, both versions are equivalent.</p>
",0
7510911,7510887,0,"<pre><code>void f(int* arr, int len) { ... }

void f(int* start, int* end) { ... }
</code></pre>
",0
7510936,7510887,1,"<p>Something like this:</p>

<pre><code>int accumulate( int *first, int *last )
{
  int result = 0;

  for( ; first != last; ++first ) {
    result += *first;
  }

  return result;
}

int main()
{
  int arr[] = {1,2,3,4,5};
  int sum = accumulate( arr, arr + 5 );

  return 0;
}
</code></pre>

<p>The code above sums all the elements in the range <code>[first, last)</code>; where <code>first</code> in included in the range and <code>last</code> is excluded. So you need to pass a pointer to the beginning of the range you want to sum and another to one location past the last element you want added to the sum.</p>
",1
7510940,7510887,0,"<p>If you only want to pass the array size you could do pass the following to the function :       </p>

<pre><code>function(sizeof(array)/sizeof(array[0]));
</code></pre>
",0
7510954,7510887,0,"<pre><code> int A[] = {1,2,3,4,5,6,7,8,9,0};
 printf(""Size of the Array %d \n"", sizeof(A)/sizeof(int));//size of the array


you can use this value to function 

void getSize(int A[], size_t size){
//do somthing
}

void function()
{
//from where you call this 
 int A[] = {1,2,3,4,5,6,7,8,9,0};
 getSize(A, sizeof(A)/sizeof(int));
}
</code></pre>
",0
7510978,7510887,8,"<p>The problem is that if you cannot pass an array to a function. When you do so, the name of the array ""decays"" to a pointer to its first element. That means you no longer know the size of that array, as you can only pass around a pointer to an element in that array. So you have to pass it a size, so the function receiving the ""array"" knows how long it is.</p>

<p>e.g.</p>

<pre><code>//the below declaration is even the same as e.g.
//void foo(unsigned char array[4], size_t length)
//the array notation doesn't really apply to a function argument list
//it'll mean a pointer anyhow.
void foo(unsigned char *array, size_t length)
{
    size_t i;
    for(i = 0; i &lt; length ; i++) {
       printf(""%02X "", array[i]);
    }
}
</code></pre>

<p>Or in the case where you pass in a pointer one element past the end of the array:</p>

<pre><code>void bar(unsigned char *array, unsigned char *end)
{
     while(array != end) {
       printf(""%02X "", *array);
       array++;
    }
}
</code></pre>

<p>And you call it like</p>

<pre><code>unsigned char data[] = {1,2,3,4};
foo(data,sizeof data); //same as foo(&amp;data[0], siseof data);
bar(data, data + 4); //same as bar(&amp;data[0], &amp;data[4]);
</code></pre>
",2
6652376,6652334,5,"<p>You need <code>char* arr[]</code> instead, since you can't assign an array to another array.</p>
<h3>But whyyyyy?</h3>
<p>Well, what would that mean? Should it copy over the elements? Use <code>strncpy</code> or <code>memcpy</code> for that. Or should it somehow &quot;redirect&quot; the previous array? That doesn't make sense, because an array is just a <em>block</em> of memory... what can you do with it, other than modify its contents? Not much! You can, however, have a <em>pointer</em> to the block, and change it to point somewhere else instead.</p>
<h3>But aren't arrays and pointers the same thing?</h3>
<p><strong>No!!</strong> Why would they have two different names, then? :P Arrays can <em>decay</em> to pointers implicitly (the address of their first elements), but they're <em>not</em> the same thing! Pointers are just <em>addresses</em>, whereas arrays <em>are</em> a block of data. They have no relation to each other, other than the implicit conversion. :)</p>
",1
6652457,6652334,1,"<p><code>arr[0]</code> is, itself, an array. C does not support assigning to arrays. If you mean to copy the contents of array <code>arr[1]</code> into the the array <code>arr[0]</code>, use <a href=""http://linux.die.net/man/3/memcpy"" rel=""nofollow"">memcpy</a>:</p>

<pre><code>memcpy(&amp;arr[0][0], &amp;arr[1][0], sizeof arr[0]);
</code></pre>
",0
6658956,6658936,2,"<p>UTF-8, except for the zero code point itself, will not have any zero bytes in it. The first byte of all multi-byte encodings (non-ASCII code points) will always start with the <code>11</code> bit pattern, with subsequent bytes always starting with the <code>10</code> bit pattern.</p>

<p>As you can see from the following table, <code>U+0000</code> is the only code point that can give you a zero byte in UTF-8.</p>

<pre><code>+----------------+----------+----------+----------+----------+
| Unicode        | Byte 1   | Byte 2   | Byte 3   | Byte 4   |
+----------------+----------+----------+----------+----------+
| U+0000-007F    | 0xxxxxxx |          |          |          |
| U+0080-07FF    | 110yyyxx | 10xxxxxx |          |          |
| U+0800-FFFF    | 1110yyyy | 10yyyyxx | 10xxxxxx |          |
| U+10000-10FFFF | 11110zzz | 10zzyyyy | 10yyyyxx | 10xxxxxx |
+----------------+----------+----------+----------+----------+
</code></pre>

<p>UTF-16 will intersperse zero bytes between your otherwise ASCII bytes but it's then a simple matter of throwing away every second byte. Whether that's <code>0, 2, 4, ...</code> or <code>1, 3, 5, ...</code> depends on whether your UTF-16 encoding is big-endian or little-endian.</p>

<hr>

<p>I see from your sample that your data stream <em>does</em> indicate UTF-8 (<code>43 4f 44 45 53 45 54 3d 55 54 46 38</code> translates to the text <code>CODESET=UTF8</code>) but I'll guarantee you it's lying :-)</p>

<p>The segment <code>72 00 65 00 61 00 74 00 68 00 69 00 6e 00 67 00</code> is UTF-16 for <code>reathing</code>, presumably a word segment since I'm not familiar with that word (in English, anyway).</p>

<p>I would suggest you clarify with whoever is generating that data since it's clearly erroneous. As to how you process the UTF-16, I've covered that above. Provided it's ASCII data in there (the alternate bytes are always zero), you can just throw away those alternates with something like:</p>

<pre><code>// Process a UTF16 buffer containing ASCII-only characters.
// buff is the buffer, count is the quantity of UTF-16 chars.
// Will change buffer.

void compressUtf16 (char *buff, size_t count) {
    int i;
    for (i = 0; i &lt; count; i++)
        buff[i] = buff[i*2];     // for xx 00 xx 00 xx 00 ...
}
</code></pre>

<p>And, if you're using the <em>other</em> endian UTF-16, simply change:</p>

<pre><code>buff[i] = buff[i*2];     // for xx 00 xx 00 xx 00 ...
</code></pre>

<p>into:</p>

<pre><code>buff[i] = buff[i*2+1];   // for 00 xx 00 xx 00 xx ...
</code></pre>
",7
7205765,7205764,1,"<p>No, it's not possible. Your pointer holds an address to a space in memory. The variable name is a name you have defined to mean that space in memory. So, you have somthing like this:</p>

<pre><code>name -&gt; mem space
q ------^
</code></pre>

<p>There is nothing linking q to name, and they don't go backwards. Both of them will get you to memory space, but you can't map back to them. Also, the program does not know that these happen to map to the same thing! The only reason you know is because you set it up to do so. </p>
",0
7205766,7205764,8,"<p>Short answer: No.</p>

<p>Long Answer:</p>

<p>In C variable names do not exist after compilation (everything is converted to either memory locations or register locations).</p>

<p>The compiler may potentially assign multiple variables to the same memory/register location if their lifespans of the two objects do not overlap. Thus the concept of variable names at runtime has no meaning (in the context of C)</p>
",1
7205894,7205764,0,"<p>This started as a comment, but then I realized it probably works better as an actual answer.</p>

<p>The short answer to the question as stated is, as others have already pointed out, <em>no</em>, you cannot map from a memory location to a variable name corresponding to that location.</p>

<p>Think about what would happen if it actually was possible to do something like what you want. Here is a thought experiment for you. I'm assuming C, but it should apply equally well in any language that supports pointers to arbitrary memory locations (including memory locations occupied by other variables).</p>

<p>Suppose that you start out with two pointers to an identical memory location:</p>

<pre><code>char p[] = DUMMY;
char *q = &amp;p;
</code></pre>

<p>Now, if you were to somehow de-dereference <code>&amp;q</code>, you'd get <code>p</code>. Okay, that kinda-sorta works, in the theoretical sense. Now, add this:</p>

<pre><code>char *r = &amp;q;
</code></pre>

<p>Now, you have double indirection. If you try to figure out what names point to the same memory location as the name <code>p</code>, what is the result? If I recall the pointer syntax correct, you get <code>*q</code> and <code>*(*r)</code>. How is the compiler going to tell you that, particularly at runtime?</p>

<p>Suppose that <code>p[]</code> is sufficiently large. For an arbitrary number <code>n</code>, replace the <code>*q</code> assignment by:</p>

<pre><code>char *q = &amp;p + n;
</code></pre>

<p>What is now the result of similarly de-dereferencing <code>q</code>? What would be the result in case <code>q</code> now points outside the bounds of <code>p[]</code>? (Okay, that latter could conceivably be just <code>q</code>, but then what's the point?)</p>

<p>Or, a practice which was quite common before the wide advent of GUIs. Try this (never mind the actual address).</p>

<pre><code>short *videomemory = 0xB8000;
/* and then, at some later point... */
videomemory += 4;
</code></pre>

<p>Then, try to find the address corresponding to the value of <code>videomemory</code> (0xB8004, given the above). What is the result? In principle, the ""array"" <code>videomemory[]</code> extends indefinitely, even wrapping around (let's ignore memory protection for the moment), and thus <em>anything</em> will map into the memory ""occupied"" by <code>videomemory[]</code>, only given a large enough array index.</p>
",0
7206174,7205764,1,"<p>It is possible, but only within the scope of the original object.</p>

<p>You gave these examples (I've modified the formatting slightly):</p>

<pre><code>char name[20];
char *p = name;
int door_no;
int *q = &amp;door_no;
</code></pre>

<p>You can do comparisons equivalent to your assignments, thus:</p>

<pre><code>if (p == name)
    printf(""p == name\n"");
if (q == &amp;door_no)
    printf(""q == &amp;door_no\n"");
</code></pre>
",0
7207984,7205764,0,"<p>It is not possible to get the name of the variables <code>p</code> or <code>q</code> point to if you compile and execute the program traditionally, because one of the things the compiler does is forget the name of the variables, keeping only addresses. </p>

<p>Depending on what you are trying to do, you may execute the program in a non-traditional execution environment where the names are preserved. For instance,</p>

<pre>
~ $ cat t.c
main(){
 char name[20];
 char *p=name;
 int door_no;
 int *q= & door_no;
}
~ $ frama-c -val t.c
[kernel] preprocessing with ""gcc -C -E -I.  t.c""
...
[value] ====== VALUES COMPUTED ======
[value] Values for function main:
          p ¡Ê {{ &name ;}}
          q ¡Ê {{ &door_no ;}}
          __retres ¡Ê {0; }
</pre>
",0
6666335,6666095,2,"<p>You should <code>bind(2)</code> your socket to a port of your choosing. See also
<code>man 7 ip</code> and <code>man 7 udp</code>.</p>
",1
6666336,6666095,7,"<p>Use <code>bind</code> to bind your socket to port 0, which will allow you to use <code>getsockname</code> to get the port. you can also bind your socket to a specific port, if you wish.</p>

<p>eg (assuming IPv4 socket, no error checking):</p>

<pre><code>struct sockaddr_in sin = {};
socklen_t slen;
int sock;
short unsigned int port;

sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = htonl(INADDR_ANY);
sin.sin_port = 0;

bind(sock, (struct sockaddr *)&amp;sin, sizeof(sin));
/* Now bound, get the address */
slen = sizeof(sin);
getsockname(sock, (struct sockaddr *)&amp;sin, &amp;slen);
port = ntohs(sin.sin_port);
</code></pre>

<p>Alternately, if you are communicating with a single server, you can use <code>connect</code> on your UDP socket (which also gives you the handy side effect of allowing you to use <code>send</code> instead of <code>sendto</code>, and making the UDP socket only accept datagrams from your ""connected"" peer), then use <code>getsockname</code> to obtain your local port/address. You may still choose to bind your socket prior to using <code>connect</code>.</p>

<p>eg:</p>

<pre><code>struct sockaddr_in sin = {};
socklen_t slen;
int sock;
short unsigned int port;

sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
/* set sin to your target host... */
...
connect(sock, (struct sockaddr *)&amp;sin, sizeof(sin));
/* now retrieve the address as before */
slen = sizeof(sin);
getsockname(sock, (struct sockaddr *)&amp;sin, &amp;slen);
port = ntohs(sin.sin_port);
</code></pre>
",1
7758514,7758361,2,"<p>a)Since you are saving to a file, why not declare the first line of the file as a single number i representing the number of donors so far, followed by i lines of donors?</p>

<p>b)you might want to lookup xml's</p>
",2
7758561,7758361,0,"<p>You can store these users in a data structure, such as a LinkedList and then iterate through the linked list to find all users whos name starts with ""s"" and you can count the items that way too.</p>
",0
6331537,6329515,0,"<p>You need to sum each value of the first array as you loop, so why not declare a variable to hold this value, and then assign it to the corresponding element of the second variable. This makes everything much simpler.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    double first[8], second[8], sum = 0.0;
    int i = 0;

    printf(""Enter 8 'doubles':"");
    while(i &lt; 8)
    {
        scanf(""%lf"", &amp;first[i]);
        sum += first[i];
        second[i] = sum;
        i++;
    }
    printf(""\nfirst -  "");
    for(i = 0; i &lt; 8; i++)
    {
        printf(""%7.2f "", first[i]);
    }
    printf(""\nsecond - "");
    for(i = 0; i &lt; 8; i++)
    {
        printf(""%7.2f "", second[i]);
    }

    return 0;
}
</code></pre>

<p>The other small mistake is using %lf for the <em>printf()</em> format string - printf() actually only uses %f for both doubles &amp; floats</p>
",2
7202118,7201462,3,"<p>No, it's not a standard format. I'll try to split your problem in a few key parts:</p>

<p>1) <strong>Data storage:</strong></p>

<p>Since the problem is limited to the days of the week, you could create an array of pairs of <a href=""http://www.cplusplus.com/reference/clibrary/ctime/tm/"" rel=""nofollow"">tm structs</a> for each day of the week:</p>

<pre><code>#include &lt;time.h&gt;

typedef tm interval[2];
typedef interval* daysofweek[7];

void main(void)
{
    int number_of_intervals = 2; //this must be calculated for each day but to exemplify how you could store your data I initialised it to 2
    interval *intervals;
    intervals = (interval*)malloc(number_of_intervals);
    daysofweek d;
    d[0] = intervals; //you must set the intervals for each day
}
</code></pre>

<p>2) <strong>Parsing</strong></p>

<p>You should define a set of rules based on the sintax of the strings. From the two strings you exemplified I would define the following rules:</p>

<ul>
<li>split and treat separately all strings based on the <code>;</code> character</li>
<li>split the resulted strings into a part with numerals (plus <code>-</code>, <code>:</code> and <code>,</code>) respectively a part with characters</li>
<li>parse the part with numerals and create the time intervals</li>
<li>parse the part with characters and populate the array for each day, keep track of all the days so that you can initialize the remaining days with 0 second intervals</li>
</ul>

<p>3) <strong>Comparison</strong></p>

<p>After you populated your data structure, you can parse it and deduce if you are in an interval or not by using the comparison functions found in <a href=""http://www.cplusplus.com/reference/clibrary/ctime/time/"" rel=""nofollow"">ctime</a>.</p>

<p>HTH,
JP.</p>

<p>P.S. if you would use C++ and STL instead of plain C, the task would be a bit easier.</p>
",0
7786927,7786921,8,"<p>Because, unless the variable has static storage space, it's initial value is indeterminate.  You cannot rely on it being anything as the standard does not define it.  Even statically allocated variables should be initialized though.  Just initialize your variables and avoid a potential headache in the future.  There is no good reason to not initialize a variable, plenty of good reasons to do the opposite.</p>

<p>On a side note, don't trust any book that claims to teach you X programming language in 21 days.  They are lying, get yourself a decent book.</p>
",7
7786932,7786921,1,"<p>In C the value of an uninitialized variable is indeterminate. This means you don't know its value and it can differ depending on platform and compiler. The same is also true for compounds such as <code>struct</code> and <code>union</code> types.</p>

<p><strong>Why?</strong> Sometimes you don't need to initialize a variable as you are going to pass it to a function that fills it and that doesn't care about what is in the variable. You don't want the overhead of initialization imposed upon you.</p>

<p><strong>How?</strong> Primitive types can be initialized from literals or function return values.</p>

<pre><code>int i = 0;
int j = foo();
</code></pre>

<p>Structures can be zero intialized with the aggregate intializer syntax:</p>

<pre><code>struct Foo { int i; int j; }

struct Foo f = {0};
</code></pre>
",0
7786980,7786921,2,"<p>You might end up using a variable declared outside the scope of your current method.  </p>

<p>Consider the following</p>

<pre><code>int count = 0;

while(count &lt; 500) 
{
   doFunction();
   count ++;
}

...


void doFunction() {

   count = sizeof(someString);
   print(count);

}
</code></pre>
",0
7786982,7786921,1,"<p>In C, using the values of uninitialized automatic variables (non-static locals and parameter variables) that satisfy the requirement for being a <code>register</code> variable is undefined behavior, because such variables values may have been fetched from a register and certain platforms may abort your program if you read such uninitialized values. This includes variables of type <code>unsigned char</code> (this was added to a later C spec, to accommodate these platforms).</p>

<p>Using values of uninitialized automatic variables that do not satisfy the requirement for being a <code>register</code> variable, like variables that have their addresses taken, is fine as long as the C implementation you use hasn't got trap representations for the variable type you use. For example if the variable type is <code>unsigned char</code>, the Standard requires all platforms not to have trap representations stored in such variables, and a read of an indeterminate value from it will always succeed and is not undefined behavior. Types like <code>int</code> or <code>short</code> don't have such guarantees, so your program may crash, depending on the C implementation you use. </p>

<p>Variables of static storage duration are always initialized if you don't do it explicitly, so you don't have to worry here. </p>

<p>For variables of allocated storage duration (<code>malloc</code> ...), the same applies as for automatic variables that don't satisfy the requirements for being a <code>register</code> variable, because in these cases the affected C implementations need to make your program read from memory, and won't run into the problems in which register reads may raise exceptions. </p>
",3
7787127,7786921,5,"<p>When a variable is declared, it will point to a piece of memory.</p>

<p>Accessing the value of the variable will give you the contents of that piece of memory.</p>

<p>However until the variable is initialised, that piece of memory could contain anything. This is why using it is unpredictable.</p>

<p>Other languages may assist you in this area by initialising variables automatically when you assign them, but as a C programmer you are working with a fairly low-level language that makes no assumptions about what you want to do with your program. You as the programmer must explicitly tell the program to do everything.</p>

<p>This means initialising variables, but it also means a lot more besides. For example, in C you need to be very careful that you de-allocate any resources that you allocate once you're finished with them. Other languages will automatically clean up after you when the program finished; but in C if you forget, you'll just end up with memory leaks.</p>

<p>C will let you get do a lot of things that would be difficult or impossible in other languages. But this power also means that you have to take responsibility for the housekeeping tasks that you take for granted in those other languages.</p>
",0
7787710,7786921,1,"<p>At the risk of being pedantic, the statement </p>

<blockquote>
  <p>DON'T use a variable that hasn't been initialized.</p>
</blockquote>

<p>is incorrect.  If would be better expressed:</p>

<blockquote>
  <p>Do not <em>use the value of</em> an uninitialised variable.</p>
</blockquote>

<p>The language distinguishes between <em>initialisation</em> and <em>assignment</em>, so the first warning is, in that sense over cautious - you need not provide an initialiser for every variable, but you should have either assigned <em>or</em> initialised a variable with a <em>useful and meaningful</em> value before you perform any operations that subsequently use its value.</p>

<p>So the following is fine:</p>

<pre><code>int i ;  // uninitialised variable

i = some_function() ;  // variable is ""used"" in left of assignment expression.
some_other_function( i ) ; // value of variable is used
</code></pre>

<p>even though when some_function() is called <code>i</code> is uninitialised.  If you are assigning a variable, you are definitely ""using"" it (to store the return value in this case); the fact that it is not initialised is irrelevant because you are not using its value.</p>

<p>Now if you adhere to</p>

<blockquote>
  <p>Do not <em>use the value of</em> an uninitialised variable.</p>
</blockquote>

<p>as I have suggested, the reason for this requirement becomes obvious - why would you take the value of a variable without knowing that it contained something meaningful?  A valid question might then be ""why does C not initialise <code>auto</code> variables with a known value.  And possible answers to that would be:</p>

<ul>
<li><p>Any arbitrary compiler supplied value need not be <em>meaningful</em> in the context of the application - or worse, it may have a meaning that is contrary to the actual state of the application.</p></li>
<li><p>C was deliberately designed to have no hidden overhead due to its roots as systems programming language - initialisation is only performed when explicitly coded, because it required additional machine instructions and CPU cycles to perform.</p></li>
</ul>

<p>Note that <code>static</code> variables are always initialised to zero. .NET languages, such as C# have the concept of an null value, or a variable that contains <em>nothing</em>, and that can be explicitly tested and even assigned. A variable in C cannot contain <em>nothing</em>, but what it contains can be indeterminate, and therefore code that uses its value will behave non-deterministically.</p>
",0
6351127,6351101,3,"<p>Assuming the <code>char*</code> is <code>NUL</code>-terminated, use <code>printf(""%s\n"",data);</code>.</p>

<p>If the data are not <code>NUL</code>-terminated, this may cause a segmentation fault.</p>

<p>If your data have some format other than ASCII characters, you're going to need to write some code to print it.</p>
",4
6655419,6655388,2,"<pre><code>record = (letter[rand()%2],num); 
</code></pre>

<p>This is not a legal opporation... try this:</p>

<pre><code>record[0] = letter[rand()%2];
record[1] = num;
</code></pre>
",3
6655435,6655388,3,"<p>For one obvious point, ""C10"" requires 4 characters, assuming you want it as a normal C string (3 in the string + 1 NUL terminator) but you've only made room for 2. </p>

<p>At least assuming you want your 1-10 as text characters, you'd typically want to do something like:</p>

<pre><code>sprintf(record, ""%c%d"", letter[rand()%2], num);
</code></pre>

<p>Not that it matters a lot, but you seem to be including a <em>lot</em> of unnecessary headers for what you're doing.</p>
",4
6655436,6655388,2,"<p>You want the characters '0'-'9' popping up, but you are assigning the character r a numerical value between 0 and 10. Check out the <a href=""http://www.asciitable.com/"" rel=""nofollow"">table of ASCII characters</a>.</p>

<p>I'd try it like this:</p>

<pre><code>char record[4];
for (unsigned r = 0; r &lt;= 10; ++r) {
   snprintf(record, sizeof(record), ""%c%d"", letter[rand() % 2], r);
}
</code></pre>
",1
4327406,4327334,2,"<p>You could use <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strchr/"" rel=""nofollow"">strchr</a> to scan the string for a space character after you you skipped leading spaces.</p>

<p>Assuming char buf[] holds the string to test</p>

<pre><code>int i=0;
while ( buf[i] == ' ' &amp;&amp; buf[i] != '\0' )
  i++;

return strchr( &amp;buf[i], ' ' ) != NULL;
</code></pre>

<hr>

<p>EDIT: The post has been retagged with homework.</p>

<p>Instead of using strchr you can also do another loop like the one to skip the leading spaces. To find out whether there are further spaces after the first non space char.</p>
",1
4327542,4327334,1,"<p>This might help, basically you need a simple state machine. </p>

<pre><code>int CheckEmbeddedStr(char *str)
{
    //0 - No Start str
    //1 - Start str seen
    //2 - embedded space seen
    //3 - trailing str seen
    int state=0; 
    int count=0;
    while(str &amp;&amp; str[count])
    {
        if(state == 0 &amp;&amp; isalpha(str[count]))
            state++;
        if(state == 1 &amp;&amp; str[count] = ' ')
            state++;
        if(state == 2 &amp;&amp; isalpha(str[count]))
        {
            state++;
            break;
        }
    }
    if(state==3)
        return 1;
    else
        return 0;
}
</code></pre>
",0
5879082,5879054,5,"<p>I find it hard to believe you could compile it on Solaris. The left-hand side of your assignment is a result of a cast. The results of casts in C language are always <em>rvalues</em>. You can't assign anything to an rvalue. It simple makes no sense. Rvalues are not objects. They are not stored in memory, which is why trying to assign anything to an rvalue makes no sense. This is a very fundamental fact of C, which is why I can't believe you could compile it with any C compiler.</p>

<p>For example, this code </p>

<pre><code>int i;
(int) i = 5; /* ERROR */
</code></pre>

<p>does not compile for the very same reason your code does not compile.</p>

<p>It is hard to ""point you in the right direction"" because it is totally not clear what you were trying to do. What is that assignment supposed to mean? Why do you want to have casts on both sides of the assignment?</p>
",3
5879105,5879054,0,"<p>The result of a cast is an rvalue, not an lvalue. IOW, the result is just the ""raw"" value, not the original object that was the source of the value.</p>

<p>It's not entirely apparent how to fix things in your case. In particular, without knowing what the ODATA(e) and DDATA(e) are/do, it's hard to guess how to proceed from there.</p>

<p>If you're trying to assign one struct to another, you can do something like:</p>

<pre><code>*(site_struct *)a = *(site_struct *)b;
</code></pre>

<p>Note that even though we have casts on both sides of the assignment, we're not trying to assign to the result of the cast -- rather, we're casting a pointer to the correct type, and then dereferencing that pointer, and assigning to the object that pointer refers to.</p>

<p>Edit: okay, after the macros are expanded, we end up with something like this:</p>

<pre><code>((site_struct *)((edge_struct *)((e)&amp;0xfffffffcu))-&gt;data[(e)&amp;3]) =
((site_struct *)((edge_struct *)((a)&amp;0xfffffffcu))-&gt;data[((a)+2)&amp;3]);
</code></pre>

<p>Based on the sheer ugliness of that, I think I'd try to back up at least a couple levels of abstraction and try to figure out the intent of all this. This is pretty close to write-only coding. Although you've provided the definitions of ODATA and DDATA as requested, it looks like figuring this out will take more than that -- you'll need to look closely at the definition of <code>edge_struct</code>, and possibly <code>site_struct</code> as well. You'll almost have to figure out the meaning of the subscripts into the <code>data</code> member of the <code>edge_struct</code>.</p>

<p>To make a long story short, this looks like a fairly serious case of reverse engineering, and it's almost impossible to predict how much code will need to be examined and understood before you can rewrite/update it to the point that you'll get the right result from a modern compiler.</p>
",1
8393501,8393486,1,"<p>Yes, just look at <code>man strftime</code>, or look <a href=""http://kernel.org/doc/man-pages/online/pages/man3/strftime.3.html#EXAMPLES"" rel=""nofollow"">here</a>.</p>
",1
8398854,8393486,1,"<p><code>system(""date &gt; out.txt"");</code></p>

<p>after read out.txt</p>

<p>or </p>

<p>popen()</p>
",0
5888093,5887058,1,"<p>Try this:</p>

<p>whatif.h:</p>

<pre><code>#ifndef H_WHATIF_INCLUDED
#define H_WHATIF_INCLUDED

struct whatif {
    char price[2];
};
int wi_process(struct whatif *);

#endif
</code></pre>

<p>p1.c</p>

<pre><code>#include ""whatif.h""

int main(void) {
    struct whatif whatif[100];
    whatif[0].price[0] = 0;
    whatif[0].price[1] = 1;
    whatif[1].price[0] = 42;
    whatif[1].price[1] = 74;
    whatif[99].price[0] = 99;
    whatif[99].price[1] = 100;
    wi_process(whatif);
    return 0;
}
</code></pre>

<p>p2.c</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""whatif.h""

int wi_process(struct whatif *arr) {
    printf(""%d =&gt; %d\n"", arr[0].price[0], arr[0].price[1]);
    printf(""%d =&gt; %d\n"", arr[1].price[0], arr[1].price[1]);
    printf(""%d =&gt; %d\n"", arr[99].price[0], arr[99].price[1]);
    return 3;
}
</code></pre>

<p>Then compile and link all of them together, for example with <code>gcc</code></p>

<pre>
gcc -ansi -pedantic -Wall p1.c p2.c
</pre>
",0
7811399,7811342,3,"<p><code>pthread_exit</code> exits the current thread, not others.  I believe <code>exit</code> should exit all threads. </p>
",0
7811407,7811342,1,"<p>One problem is the way that you're exiting the thread. </p>

<pre><code>pthread_exit((void *)55);
</code></pre>

<p>doesn't pass a pointer to the value 55, it passes a pointer referencing 55 in memory, which isn't likely to be a readable address. Try:</p>

<pre><code>int val = 55;
pthread_exit((void *)&amp;val);
</code></pre>
",0
7167255,7167193,1,"<p>In functions with ... you can use va_* macro</p>

<pre><code>void test(int a, ...) {
  va_list ap;
  va_start(ap, a);
  // Your code
  va_end(ap);    
}
</code></pre>
",0
7167715,7167193,2,"<p>As long as you know or can determine the number of arguments, you can use the macros from <code>&lt;stdarg.h&gt;</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void test1(int n, ...)
{
    va_list args;
    va_start(args, n);
    for (int i = 0; i &lt; n; i++)
    {
        int j = va_arg(args, int);
        printf(""%d: %d\n"", i, j);
    }
    va_end(args);
}

void test2(int a, ...)
{
    va_list args;
    int i = 0;
    printf(""%d: %d\n"", i++, a);
    va_start(args, a);
    int j;
    while ((j = va_arg(args, int)) &gt; 0)
        printf(""%d: %d\n"", i++, j);
    va_end(args);
}
</code></pre>

<p>The difference is in how these two functions are called:</p>

<pre><code>int main(void)
{
    test1(4, 1, 3, 7, 9);
    test2(1, 3, 7, 9, 0);
    return(0);
}
</code></pre>

<p>The <code>printf()</code> family uses an alternative but equivalent technique; those functions scan the format string and determine the type of each argument (as well as the number of arguments) from the information in the format string.  So, your main options are:</p>

<ul>
<li>count - <code>test1()</code></li>
<li>sentinel - <code>test2()</code></li>
<li>format string - <code>printf()</code></li>
</ul>
",6
6939562,6939505,1,"<p>An <a href=""http://en.wikipedia.org/wiki/Opaque_pointer"" rel=""nofollow"">opaque pointer</a> is the usual way to implement this.</p>

<p>If you don't want to pass a pointer at all for some reason, you could keep a global (""private"") array/hash of your structures, and give your users an index in that global container (could be a plain int). That's much more work (and much more failure-prone and potentially racy) than just handing out opaque pointers though.</p>
",0
6896659,6896626,3,"<p>Remove the ampersand in <code>mkvCopyWord(&amp;a,10)</code>:</p>

<pre><code>int mkvCopyWord(uint8_t *pBuffer, UINT8 temp):

main() 
{
  uint8_t a[10];
  mkvCopyWord(a,10); /* &lt;&lt;&lt; removed the ampersand */
}
</code></pre>

<p>There is quite a lot of information on the equivalence of pointers and arrays in the <a href=""http://c-faq.com/aryptr/index.html"" rel=""nofollow"">C FAQ</a>.</p>
",1
6896669,6896626,7,"<p>You don't need to take the address of the array as it implicitly converts to a pointer:</p>

<pre><code>int mkvCopyWord(uint8_t *pBuffer, UINT8 temp):

main() 
{
  uint8_t a[10];
  mkvCopyWord(a,10);
}
</code></pre>
",0
6896674,6896626,10,"<p>Your syntax for passing a pointer-to-array is fine. But you are trying to pass it to something that doesn't <strong>want</strong> a pointer-to-array. It just wants a pointer to the beginning element. The simplest way to get that is to allow the array name to decay to a pointer, thus <code>mkvCopyWord(a, 10)</code>. The function will assume that the pointer you give it is pointing to some sequence of <code>uint8_t</code>s somewhere - that is why you have to pass the array size as another parameter, because it does not know about the array, it only has some address in memory where the array is.</p>
",0
6896700,6896626,5,"<pre><code>int main(void) //main() without return type isn't a good practice  
{
   uint8_t a[10];
   mkvCopyWord(&amp;a,10);
   return 0; 
}
</code></pre>

<p>Here you pass a parameter of type ""pointer to array of 10 uint8_t"". Your function, however, is declared to take pointer to int. In order to make this syntax work, you'd have to change the declaration of your function to take a pointer to an array of 10 uint8_t's</p>

<pre><code>void mkvCopyWord(uint8_t (*parr)[10], int n)
</code></pre>

<p>This is all about syntax and type system. As for your actual problem, you need to pass a pointer to the first element of your array.</p>

<pre><code>mkvCopyWord(&amp;a[0],10);
</code></pre>

<p>However, an array is implicitly converted to that anyway, so you don't need to bother. You use the following:</p>

<pre><code>mkvCopyWord(a,10);  
</code></pre>

<p>HTH</p>
",2
8461220,8461170,5,"<p>Use two pointers. The first points at the next character to read, and the second points at the location to write.</p>

<p>If you read two spaces in a row, don't advance the write pointer.</p>

<hr>

<p>Another approach you may want to consider is to use <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strtok/"" rel=""nofollow""><code>strtok</code></a> with <code>"" ""</code> as a delimiter.</p>
",2
8461242,8461170,2,"<p>You could have two arrays and two counters.  Each iteration you always increase your first counter, but only increase your second when the character is not a space.  A table of it would look like this.</p>

<pre class=""lang-python prettyprint-override""><code>  Char   In-Pos  Out-Pos

   ' '      0      0
   ' '      1      0
   ' '      2      0
   ' '      3      0
   'T'      4      0
   'h'      5      1
   'i'      6      2
   's'      7      3
   ' '      8      4
   ' '      9      5
   ' '     10      5
   ' '     11      5
   'i'     12      5
   's'     13      6
   ' '     14      7
   'm'     15      8
   'y'     16      9
   ' '     17     10
   ' '     18     11
   ' '     19     11
   ' '     20     11
   ' '     21     11
   's'     22     11
   't'     23     12
   'r'     24     13
   'i'     25     14
   'n'     26     15
   'g'     27     16
   ' '     28     17
   ' '     29     18
   ' '     30     18
   ' '     31     18
</code></pre>
",3
8461373,8461170,1,"<p>You could use a string tokenizer in the first instance, and use as a delimiter a whitespace("" ""). For that purpose in C you use strtok.After that you parse the output of the strtok function, and for each element, if it contains more whitespaces character, you eliminate them. Also you put each corrected element in another array.
Then, all you have to do is parse the new array and add a whitespace after every element. If you fancy this idea, I can provide a code draft for you. </p>
",1
8464902,8461170,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char** split(const char *str, const char *delimiter, size_t *len){
    char *text, *p, *first, **array;
    int c;
    char** ret;

    *len = 0;
    text=strdup(str);//strdup not standard
    if(text==NULL) return NULL;
    for(c=0,p=text;NULL!=(p=strtok(p, delimiter));p=NULL, c++)//count item
        if(c==0) first=p; //first token top

    ret=(char**)malloc(sizeof(char*)*c+1);//+1 for NULL
    if(ret==NULL){
        free(text);
        return NULL;
    }
    //memmove?
    strcpy(text, str+(first-text));//skip until top token
    array=ret;
    for(p=text;NULL!=(p=strtok(p, delimiter));p=NULL){
        *array++=p;
    }
    *array=NULL;
    *len=c;
    return ret;
}

void free4split(char** sa){
    char **array=sa;

    if(sa!=NULL){
        free(array[0]);//for text
        free(sa);      //for array
    }
}

int main(void){
    char str[100] = ""    This    is my     string    "";
    char **words;
    size_t len=0;
    int i;

    words = split(str, "" \t"", &amp;len);
    *str = '\0';
    for(i = 0;i&lt;len-1;++i){
        strcat(str, words[i]);
        strcat(str, "" "");
    }
    strcat(str, words[i]);
    printf(""\""%s\""\n"", str);
    free4split(words);
    return 0;
}
</code></pre>
",1
8463664,8461170,2,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char* trim(char str[]){
    char *p=str;
    char *token;
    if(str == NULL) return NULL;
    if(*str == '\0') return str;

    token=strtok(str, "" \t"");
    if(token == NULL){
        *str = '\0';
        return str;
    }
    while(NULL!=token){
        int len;
        len = strlen(token);
        if(p != token){
            memmove(p, token, len);
        }
        p += len;
        *p++ =' ';
        token = strtok(NULL, "" \t"");
    }
    p[-1]='\0';

    return str;
}

int main(){
    char str[100] = ""    This    is my     string    "";
    printf(""\""%s\""\n"", trim(str));
    return 0;
}
</code></pre>
",1
6386971,6386948,6,"<p>It should be:</p>

<pre><code>  printf(""%d\n\n"",fn());
</code></pre>

<p><code>fn</code> corresponds to a ponter address of the function. That's why you get the garbage number.
In order to call a function you must use parentheses like this:</p>

<pre><code>foo();
foo(parameter1, ..., parameterN);
</code></pre>
",0
6386979,6386948,1,"<p>fn() not fn</p>

<pre><code>printf(""%d\n\n"",fn());
</code></pre>
",0
6386981,6386948,2,"<p>Forgot to call the function :)</p>

<p>change <code>fn</code> to <code>fn()</code></p>

<pre><code>printf(""%d\n\n"", fn());
</code></pre>

<p>Now this is what you get with ellipsis - no type checks...</p>
",0
6386991,6386948,3,"<p>You are printing the actual adress of fn code in memory, not calling it. Call it and your life will enlight !</p>

<pre><code>printf(""%d\n\n"", fn());
</code></pre>

<p>And please, put a space after comma, like always.</p>
",0
6387134,6386948,1,"<p>You aren't calling the function, when you type fn() THAT is when your'e calling the function and that should give you correct results.(SEE BELOW)</p>

<pre><code>int fn()
{
    return 10;
}

int main()
{
    printf(""%d\n\n"" , fn() );
    system(""pause"");
}
</code></pre>
",0
7485535,7484773,0,"<p>The problem here is when you do not define TRUE using #define TRUE, the compiler while executing the #else part encounters first the 'extern' declaration of variable 'a' and starts anticipating its declaration in an external scope somewhere. Remember the memory for extern is allocated when the program begins its execution. Consequently it finds another static definition after that and try to allocate memory at compile time but since its not sure of the extern declaration there is a conflict. So an error is generated as duplicate declaration.</p>

<p>But when the true is defined and executing the first condition, the 'a' is made static before the extern declaration and allocates the memory right at the compile time and hence further definitions doesn't conflict. I hope this helps. :) </p>

<p>Read this link <a href=""http://www.tenouk.com/ModuleZ.html"" rel=""nofollow"">http://www.tenouk.com/ModuleZ.html</a></p>
",0
7484877,7484773,3,"<p>I am not sure what you're trying to do here, but you are re-declaring <code>a</code> as both a static and external variable, in different order.</p>

<p>When applied to a variable, <code>static</code> allows global variables to only be visible within that file. <code>extern</code> declares an external variable, defined elsewhere. So for example you would declare <code>a</code> as extern if it was originally defined in a separate file, and declare it as <code>static</code> if it should only be visible within this file itself. </p>

<p>Here are the errors:</p>

<pre><code>test.c:8:12: error: static declaration of ¡®a¡¯ follows non-static declaration
test.c:7:12: note: previous declaration of ¡®a¡¯ was here
</code></pre>

<p>You declare <code>a</code> as an external variable (defined in a different file), but then re-declare it as static, only visible within this file.</p>

<p>In this case I would review what those <em>storage classes</em> (extern, static, etc) mean and then decide how your variable should be declared.</p>
",0
7484997,7484773,0,"<p>When you define <code>TRUE</code>, you are declaring <code>a</code> as extern, which means definition of <code>a</code> is in some other file, but compiler couldn't find it, so it can't compile your file.</p>

<p>Also, I think you wrote wrong in question, this file should be compiled when you <em>don't define</em> TRUE.</p>
",0
7485085,7484773,6,"<p>When <code>TRUE</code> is not defined, the first declaration (<code>extern</code>) says <code>a</code> has external linkage (ISO/IEC 9899:1999, 6.2.2, paragraph 4, no prior declaration). The second declaration (<code>static</code>) states <code>a</code> has internal linkage (paragraph 3). An identifier cannot have both internal and external linkage (paragraph 7). </p>

<p>In the <code>TRUE</code> defined case, the <code>extern</code> in the second declaration has no impact because there is a prior declaration declaring <code>a</code> with internal linkage (paragraph 4).</p>

<p>See <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""noreferrer"">draft of ISO/IEC 9899:1999</a>.</p>
",0
6268563,6268513,2,"<p>Certainly you should ditch Turbo C, if that is what you are using - get Code::Blocks from <a href=""http://forums.codeblocks.org"" rel=""nofollow"">http://forums.codeblocks.org</a>.</p>

<p>Your error is:</p>

<pre><code>for(i=1;i&lt;=5;i++)
{
for(j=1;j&lt;=3;j++)
{
</code></pre>

<p>should be:</p>

<pre><code>for(i=0;i&lt;5;i++)
{
for(j=0;j&lt;3;j++)
{
</code></pre>

<p>Arrays in C are indexed starting from zero. So an array:</p>

<pre><code>int a[5];
</code></pre>

<p>has 5 elements:</p>

<pre><code>a[0], a[1], a[2], a[3], a[4]
</code></pre>

<p>Note it does NOT have an element a[5]. Any attempt to access a[5] (or a[6] etc.) leads to what the C Standard calls ""undefined behaviour"" - your program is in an unknown state, from which it can never recover, and could do anything.</p>
",0
6268574,6268513,0,"<p>Code has errors. The array is <code>int sale[5][3];</code> . That means that the index ranges spans <code>0 to 4</code> in the first dimension and <code>0 to 2</code> in the second dimension. The index in C starts from <code>0</code>. so the loop should be:</p>

<pre><code>for(i=0;i&lt;5;i++)
{
  for(j=0;j&lt;3;j++)
  {
    sale[i][j]=0;
  }
}
</code></pre>

<p>Otherwise in your code you are accessing some memory location which you should not (beyond the array.</p>

<p>Although this should not make the compiler stop you from generating the executable.</p>
",0
6268883,6268513,0,"<p>Standards say using void main() is wrong. Some compilers will give errors if you try that.</p>
",0
7224375,7224356,1,"<p>As other people stated you can't really do this because arrays will degrade to pointers.  the standard way to do this is to return a struct</p>

<pre><code>struct array {
    void* ptrs[5];
}
</code></pre>

<p>then your procedure would be declared like</p>

<pre><code>struct array foo() {...}
</code></pre>
",3
7224389,7224356,1,"<p>Example:</p>

<pre><code>void **function(int c)
{
    void **arrayOfVoidStars = (void **)malloc(c*sizeof(void *));
    /* fill the array */
    return arrayOfVoidStars;
}
</code></pre>
",6
6883907,6883349,1,"<p>Piggybacking somewhat on the answer of unkulunkulu I think you could approach it as follows:</p>

<p>Take all the values in your matrix (2D) and put them in a simple array (1D). Then take this array and sort the values from lowest to highest.</p>

<p>Now what you need to do is fill the matrix again but in such a way that it conforms to the rules you have specified. If you have a look at a <a href=""http://en.wikipedia.org/wiki/Z-order_curve"" rel=""nofollow"">Z-order space filling curve in 2D</a>, you will find that if you fill you matrix in this order (with the sorted elements), that the resulting matrix has your desired properties.</p>

<p>Now actually coding this would be up to you.</p>
",0
6883963,6883349,1,"<p>The book numerical recipes chapter 21.8 <a href=""http://www.nrbook.com/nr3/"" rel=""nofollow noreferrer"">http://www.nrbook.com/nr3/</a> gives an analytic expression to calculate an index into the 2D array given the coordinates of a quadtree. </p>

<p><img src=""https://i.stack.imgur.com/j9Xnf.png"" alt=""enter image description here"">
<img src=""https://i.stack.imgur.com/1vTSo.png"" alt=""enter image description here""></p>

<p>Here is another straight forward approach that I tried, but I don't like it as much:</p>

<pre><code>(defun quad-pos (pos)
  ""POS is a list of letters that indicate the position in a 2x2 matrix [a,b; c,d].""
  (let ((x 0)
    (y 0)
    (s 1))
    (dolist (e pos)
      (setf s (/ s 2))
      (ecase e
    ('a )
    ('b (incf x s))
    ('c (incf y s))
    ('d (incf x s) (incf y s))))
    (values x y)))
#+nil
(quad-pos '(a)) ;=&gt; 0, 0
#+nil
(quad-pos '(a b c)) ;=&gt; 1/4, 1/8
#+nil
(quad-pos '(d d d d)) ;=&gt; 15/16, 15/16
</code></pre>
",0
6883531,6883349,1,"<p>You need to create a function which will convert an index between 0 and n*n-1 to coordinates in your array according to the ordering in question. Then you just run some usual 1D sorting algorithm, on an array of size n*n, <code>j</code>th element of which is substituted using that function. It solves the problem.</p>

<p>Update: the mapping function maps numbers in this matrix to their coordinates:</p>

<pre><code> 0  1  4  5
 2  3  6  7
 8  9 12 13
10 11 14 15
</code></pre>
",4
6943065,6943030,1,"<pre><code>while ( i &lt; 4)
        printf (""while: i=%d\n"",i++);
</code></pre>

<p>will do the trick. The <code>++</code> after the <code>i</code> is a post increment, so the <code>printf</code> statement prints <code>i</code>, then increments. </p>
",0
6943092,6943030,0,"<p>To change <code>while</code> loop to <code>for</code> loop:</p>

<pre><code>for (i = 1; i &lt; 5; ++i)
    printf (""while: i%d\n"",i);
</code></pre>

<p>To make <code>while</code> loop print numbers like the <code>for</code> loop:</p>

<pre><code>while ( i &lt; 4 )
    printf (""while: i%d\n"", i++);
</code></pre>

<p>Or alternatively:</p>

<pre><code>while ( i &lt; 4 )
{
    printf (""while: i%d\n"", i);
    ++i;
}
</code></pre>

<p>Read about pre-increment vs post-increment to get the idea. For example, <a href=""http://discuss.fogcreek.com/joelonsoftware/default.asp?cmd=show&amp;ixPost=171881"" rel=""nofollow"">here</a>.</p>
",0
6943113,6943030,0,"<p>The issue there is that the <code>while</code> checks for i=0, i=1, u=2, i=3 and i=4. When it fails, it breaks, but before it breaks, it updates i once more, and sets i to i++ (i=5)</p>

<p>So you get </p>

<pre><code>while: i0
while: i1
while: i2
while: i3
while: i4

after while  loop, i=5
</code></pre>

<p>But the <code>for</code> clause doesn't update i after the comparison fails, so you get</p>

<pre><code>first for: i=0
first for: i=1
first for: i=2
first for: i=3

after first loop, i=4
</code></pre>

<p>If you want to match both clauses, try incrementing i inside the <code>while</code>, not in the condition itself.</p>
",2
6937589,6937361,0,"<p>The error means that the linked modules are missing a definition of the named items <code>FastNew(unsigned int)</code>, etc.  That is, some code references the item, but there is no implementation of it.</p>

<p>This could have several classes of cause:</p>

<ul>
<li>a library is missing from the link</li>
<li>a module is compiled incorrectly:  mismatched options, #defines, or <code>C</code> vs. <code>C++</code></li>
<li>a module is mistakenly linked which should not have been</li>
</ul>

<p>From the types of modules referenced, I think the cause is likely the first one.  Look for a memory management library which should be included.</p>
",0
6277391,6277370,16,"<p>This is well explained in the <a href=""http://c-faq.com/stdio/scanfinterlace.html"" rel=""noreferrer"">C FAQ</a>. See also: <a href=""http://c-faq.com/stdio/gets_flush2.html"" rel=""noreferrer"">explanation</a>. The proposed solutions:</p>

<ul>
<li><strong>Quit using scanf. Use <code>fgets</code> and the <code>sscanf</code></strong></li>
<li><p>Use this to eat the newline</p>

<pre><code>while((c = getchar()) != '\n' &amp;&amp; c != EOF)
/* discard the character */;
</code></pre></li>
</ul>

<p>The fact that flushing stdin works on some implementations <strong><a href=""http://c-faq.com/stdio/stdinflush2.html"" rel=""noreferrer"">is wrong</a></strong>.</p>

<blockquote>
  <p>Some vendors do implement fflush so
  that fflush(stdin) discards unread
  characters, although portable programs
  cannot depend on this.</p>
</blockquote>
",0
6113395,6113218,0,"<p>I'll go out on a limb... Put a comma after the format string for case 3.</p>
",1
6113440,6113218,3,"<p>In the case for <code>%d</code>:</p>

<pre><code>sprintf(str,""%d"",val);
</code></pre>

<p>what does <code>str</code> point to? If there was a <code>%s</code> earlier, it points to one of the format arguments, otherwise it is uninitialized -- in both cases, it points to an invalid location for writing. You need another temporary buffer to write the value into. You were just lucky that cases 1 and 2 worked.</p>
",1
6113552,6113218,1,"<p>Take a look at this code:</p>

<pre><code>   if( fmt[i]=='i' || fmt[i]=='d' )
    {
      val=va_arg(ap,int);
      sprintf(str,""%d"",val);
      strcat(tempBuf, str);
    }
</code></pre>

<p>The sprintf() call there is trying to write something to <code>str</code>. What is str ? 
When you call it like <code>myPrintf(""%s %d"", ""Hi There"", 24)</code> , the <code>str</code> will be the 2. argument, the string ""Hi There"". You cannot change a string literal in C, this will likely fail and might cause a crash. </p>

<p>When you call it like <code>myPrintf(""%s %d"", tempbuf, 24)</code>, <code>str</code> will be <code>tmpbuf</code>, which is an array, which you can write to so that's fine. It only holds room for 9 bytes though, so it's easy to overflow that buffer.</p>

<p>You should rather just do something like </p>

<pre><code>      char tmp[32];
      sprintf(tmp,""%d"",val);
      strcat(tempBuf, tmp);
</code></pre>
",0
7686074,7686044,7,"<p>You have not initialized x to any value. Therefore, the initial value in <code>x</code> would be garbage and as it happens, this garbage increments itself every time because it is probably using the same memory location everytime.</p>

<p>Try changing your code to this:</p>

<pre><code>void print_it(void);
int main (int argc,  const char * argv[])
{
    print_it();
    print_it();
    print_it();
    exit(EXIT_SUCCESS);
}

void print_it(void)
{
    int x = 0;
    printf(""%d\n"", x++);
}
</code></pre>
",4
7686113,7686044,0,"<p>The initial value of uninitialized local variables is undefined.  In this case, the value is just sitting on the the stack and getting reused because you are calling the same function three times in a row.  If you call other functions that have local variables, the value will change because the other functions will use the same stack memory.</p>
",0
7686174,7686044,0,"<p>No man you are wrong. Variable is not keeping its value. you are not initializing int x so each time it has <strong>garbase value</strong> &amp; you are incrementing that &amp; printing that incremented garbase value. </p>

<p>You are getting same but standard says that it may not be same. </p>

<p><strong>in one million times you get same value still that it can not be accepted that local variable holds on its value.</strong>     </p>

<p>on differe system with different environment may your program has not same value..!  </p>

<p>Edit : 
in most of the case local variable has value 0. so its not retaining its previous value. </p>

<pre><code>void print_it(void);

int main (int argc,  const char * argv[])
{
    print_it();
    print_it();
    print_it();
    return 1;
}

void print_it(void)
{
    int x;
    printf(""starting %d\n"", x);
    x++;
    printf(""after increment %d\n"", x);
}
</code></pre>

<p>if variable keep its state then it output should be</p>

<pre><code>starting 0
after increment 1
starting 1
after increment 2
starting 2
after increment 3
</code></pre>

<p>but its real output is </p>

<pre><code>starting 0
after increment 1
starting 0
after increment 1
starting 0
after increment 1
</code></pre>

<p>so now get point..??</p>

<p><strong>local variable dont keep its state but if initialized local variable has always value 0.</strong></p>
",0
7686419,7686044,1,"<p>That's because all 3 stacks of function <code>print_it</code> occupy same address space.</p>

<pre><code>//    before print_it()                   1st print_it();             back to main()                 2nd print_it();            and so on...
//
//    ..................                ..................          ..................               .................. 
//    ... Stack data ...                ... Stack data ...          ... Stack data ...               ... Stack data ... 
//    ..................                ..................          ..................               ..................
//                       &lt;- stack_P     |call  print_it()|                            &lt;- stack_P     |call  print_it()| 
//                                              ||                                                           ||               
//                                              \/                                                           \/
//                                      ... some  data ...          ... some  data ...               ... some  data ...
//                                      | 4 bytes  of x  |          | X still  here  |               | Old  X  Bytes  |
//                                      ... some  data ...          ... some  data ...               ... some  data ...
//                                                        &lt;- stack_P                                                   &lt;- stack_P
//  
//                                       x got incremented                                         x got incremented again
</code></pre>

<p>Try this main:</p>

<pre><code>int main (int argc,  const char * argv[])
{
    print_it();
    int a;
    a += 1; 
    print_it();
    int b;
    b += 2
    print_it();
    exit(EXIT_SUCCESS);
}
</code></pre>
",0
7788805,7788795,5,"<p>5. Although the compiler could certainly optimize that to 1.</p>
",2
7788866,7788795,1,"<p>Suppose you modified your code slightly:</p>

<pre><code>for (i = 0; i &lt; 5; i++)
{
    int j = rand();
    printf(""%5d (%p)\n"", j, (void *)&amp;j);
}
</code></pre>

<p>You would see a different value for <code>j</code> in each iteration, making it clear that <code>j</code> is given a value each time through the loop, even if the address of <code>j</code> was the same in each loop.  This would demonstrate more clearly that <code>j</code> is initialized on each iteration (and is logically created and destroyed on each iteration).</p>
",0
7792423,7788795,0,"<p>Well, there are two things to mention here,</p>

<h2>Locality of a Variable:</h2>

<p>The locality of the variable <code>j</code> is the next '<code>}</code>'. When the program approaches the bracket, the variable <code>j</code> dies.</p>

<h2>Temporal Locality:</h2>

<p>There is a mechanism in computers that they tend to keep the extensively used variables and prevent them from dying because they might be needed again. So it is very much possible that the computer will in real not generate the variable <code>j</code> <code>5</code> times.</p>

<h2>Conclusion:</h2>

<p>As far as the answer to your question is concerned so you can say 5 as the person who wanted asked you this question wanted you to get an idea about locality of a variable.</p>
",0
6344074,6343977,6,"<p>This is not tested, but try to change your printf line, so you can see the difference:</p>

<pre><code>printf(""%s\n"",lineptr);
</code></pre>
",0
6344087,6343977,4,"<p>It's doing exactly what you think it is, it's just that the first string it prints is</p>

<pre><code>before giving tab !
</code></pre>

<p>with no new line, followed by <code>after tab has been given</code></p>

<p>change your print to </p>

<pre><code>printf(""%s\n"",lineptr);
</code></pre>
",0
6344108,6343977,1,"<p>It's working perfectly fine (and delimiting on '!' as you requested); the only problem is that you are printing out the individual strings exactly as they come in, in a while loop.</p>

<p>Remember: getdelim includes the delimiter in the string (it won't remove the '!' for you).</p>

<p>For the given test case, the first time around the loop will give the string <code>""before giving tab !""</code>, and the second time around the loop will give the string <code>""after tab has been given""</code>. You are printing them both out without any newlines or anything, so your output looks just the same as the input. I suggest you print a newline after each string, but that won't get rid of the '!'. So you may want to change your print code to:</p>

<pre><code>while((read=getdelim(&amp;lineptr,&amp;len,33,fp))!= -1)
{
    if (lineptr[strlen(lineptr)-1] == '!')
        lineptr[strlen(lineptr)-1] = '\0';
    printf(""%s\n"",lineptr);
}
</code></pre>
",1
6345344,6343977,0,"<pre><code>char before[256], after[256];

fscanf(fp, ""%255[^!]!%255[^\n]"", before, after);
printf(""%s\n%s"", before, after);
</code></pre>
",0
6622094,6621585,2,"<p>Clearly your struct is off by two bytes by the time you get to the IP addresses.  I've checked against the IPv4 protocol and that bit looks OK.  So I suspect the <code>struct mac</code> is wrong.  I presume <code>struct mac</code> is meant to be an ethernet frame.  If so, it's already a bit suspicious because an <a href=""http://en.wikipedia.org/wiki/Ethernet_frame"" rel=""nofollow"">Ethernet frame</a> is not of a fixed length.</p>

<p>Also, (assuming you are getting these from the Berkeley Packet Filter) make sure you calculate the start of the packet correctly from the bpf header (you can't rely on <code>sizeof(struct bpf_header)</code>).</p>
",0
6624865,6621585,0,"<p>Your IP packet starts at offset 16, and if you have copied <strong>struct mac</strong> from ethernet header it is 14 bytes long. Looks like there is some unexpected data in packet.</p>
",0
6350805,6350782,14,"<p>The variable name in C prototype function isn't mandatory.</p>
",2
6351422,6350782,2,"<p>Also sometimes you will see something like:</p>

<pre><code>void* foo(void);
</code></pre>

<p>In that case the function is explicitly declaring that it takes no parameters.  Why would you do that instead of just leaving out parameters?  Absence of parameters, for historical reasons, actually means one void* or int* parameter.</p>

<pre><code>void* foo();

// ... later
foo(x);
</code></pre>

<p>That will work and compile, but its unclear that that the variable passed in was not intended.   </p>
",0
6368319,6368301,2,"<p>Yep, it's known as Duff's device.</p>

<p>As far as I can remember it was written by someone doing special effects for a movie (Star Wars or something like that).  It was written this way to get maximum performance.</p>

<p>But, would I suggest to write code like this: NO.</p>

<p>Keep your code readable!</p>
",0
7786617,7786552,4,"<h3>After the edit to the question</h3>

<blockquote>
  <p>Basically I am trying to work on a problem where parent will pass the command line args (in <code>argv[]</code>) to the child for adding the numbers.  I am creating a child for every two numbers and passing them in <code>argv[]</code>. I want to append the result sum returned from the child again to parent's to create child process until the number reduces to one. </p>
</blockquote>

<p>This is not feasible; the memory of the child processes is completely separate from the parent process's memory.  The child cannot directly modify the parent's memory.  You will need to use some form of IPC (inter-process communication) to get information back from the child processes.</p>

<p>You can certainly pass the arguments to the children; that is (relatively) straight-forward.  However, you will need a mechanism such as a pipe for the parent to retrieve the answer from the child.</p>

<p>Note that this mechanism makes sense as a way to illustrate the issues involved in communicating between processes; it does not make sense as a way to add up numbers because the overhead of process startup and IPC is enormous compared to the cost of doing the work in a single program.</p>

<h3>Before the edit to the question</h3>

<blockquote>
  <p>How to append a value at the end of the (char* argv[]) array in C.</p>
</blockquote>

<p>Should you want to do so, you will have to:</p>

<ol>
<li>Allocate a new array big enough for the extra value.</li>
<li>Copy the existing values from the old array to the new one.</li>
<li>Add your new value.</li>
<li>Ensure that the rest of the code uses the new values of <code>argc</code> and <code>argv</code> when appropriate.</li>
<li>Ensure that you release the new <code>argv</code> when it is no longer needed (unless your program is exiting or execing at the point when it is done with the new value, in which case, you don't need to free it).</li>
</ol>

<p>In outline:</p>

<pre><code>char **newv = malloc((argc + 2) * sizeof(*newv));
// Error check omitted
memmove(newv, argv, sizeof(*newv) * argc);
newv[argc] = new_value;
newv[argc+1] = 0;
argc++;
argv = newv;

...

free(newv);
</code></pre>
",8
7786637,7786552,1,"<p>Changing the <code>argv</code> array in a child process does <em>not</em> change the array in the parent process. The OS makes a <em>copy</em> of the command line arguments in the child's address space. You will have to find another way to pass information from the child back to the parent. </p>
",2
7786651,7786552,1,"<p>Short Answer: You can't. The way C organizes memory does not allow it.</p>

<p><strong>Long Answer</strong> (please correct me if I'm wrong)</p>

<p>In your function <code>int main(int, char**)</code> you get two variables passed. The first is a integer and the second is a pointer to a pointer (<code>char **</code> is almost the same as <code>char*[]</code>). You only know two things about this pointer:</p>

<ol>
<li><p><code>argv</code> points to <code>argc</code> pointers of type <code>char *</code> and all of them are stored one after the    other in memory (<code>argv + 1</code> points to the next pointer in memory if <code>argc &gt; 1</code>).</p></li>
<li><p>Every pointer <code>argv + i</code> (<code>0 &lt; i &lt; argc</code> of course) consists of an unknown number of characters and a terminating <code>\0</code>.</p></li>
</ol>

<p>You don't know</p>

<ol>
<li>Where the memory is.</li>
<li>How to change it.</li>
</ol>

<p>See the answer of one faster than me to see how you could do it: <a href=""https://stackoverflow.com/questions/7786552/how-to-append-a-value-at-the-end-of-the-char-argv-array-in-c-language/7786617#7786617"">How to append a value at the end of the char* argv[] array in C language?</a></p>
",2
7786582,7786552,1,"<p>In general you can't/shouldn't.</p>

<p>It's not defined how the system allocates this memory - you might be unlucky and it works on one system, but it might not on the next!</p>
",0
8283496,8283491,5,"<p>No, it simply spits out more messages for you during the building process.</p>
",3
6602602,6602574,1,"<pre><code>if ((matrix[k][s] &lt; TOLERANCE) || (matrix[k][s] &lt; -TOLERANCE))
</code></pre>

<p>does not do what you want it to.  In particular, if <code>matrix[k][s]</code> is <code>-1.0</code>, this condition is true.  Instead, you want:</p>

<pre><code>if (fabs(matrix[k][s]) &lt; TOLERANCE)
</code></pre>
",0
6602603,6602574,6,"<p>My guess is that you wanted this condition:</p>

<pre><code>(matrix[k][s] &lt; TOLERANCE) || (matrix[k][s] &lt; -TOLERANCE)
</code></pre>

<p>to be this:</p>

<pre><code>(matrix[k][s] &lt; TOLERANCE) &amp;&amp; (matrix[k][s] &gt; -TOLERANCE)
</code></pre>

<p>In other words, when <code>abs(matrix[k][s]) &lt; TOLERANCE</code></p>
",2
6602625,6602574,2,"<p><code>||</code> should be <code>&amp;&amp;</code> ?</p>

<pre><code>if (fabs(matrix[k][s]) &lt; TOLERANCE)
</code></pre>

<p>Edit ref <a href=""https://stackoverflow.com/questions/6602574/a-1-0-1-0-operation-returns-a-0/6602603#6602603""><code>Jon's answer</code></a>; <code>abs(matrix[k][s]) &lt; TOLERANCE</code> is right solution..</p>
",0
6602659,6602574,0,"<p>I can see a few issues:</p>

<ol>
<li><p>Isn't that code going to set everything from -infinity <strong>..</strong> TOLERANCE to 0?  That can't really be what you want.</p></li>
<li><p>Shouldn't TOLERANCE be a very small number?</p></li>
<li><p>Is the comparison with 0.0 really necessary?  On modern processors, a division by 0 <em>should</em> produce an infinity and should <em>not</em> produce an exception.</p></li>
<li><p>You might want to write the division as <code>matrix[k][s] /= divisor;</code></p></li>
</ol>
",0
7193046,7193019,1,"<p>Really, the answer could be ""yes"" or ""no"", depending on your definition of ""function overloading"".</p>

<p>From the compiler's perspective, there is only one function instantiated.  From the user's persepctive, you <em>could</em> call this ""overloading"", but it's enforced by neither the language nor the compiler.</p>
",0
7193058,7193019,1,"<p>If you're referring to the implementation, no the compiler doesn't create overloads. Variable argument functions use va_start/va_arg/va_end to get their arguments.</p>
",0
7193073,7193019,2,"<p>Typically, function overloading has the implication that a different instance of a function/method is invoked depending on the given parameters.  With variable arguments in C, the same function is called regardless of the parameter list.  So based on that, the answer would be, ""No.""  The function itself could of course mimic the behavior of overloading (do A if 1 argument, do B if 2 arguments, etc.), but it probably would not normally be termed ""overloaded"".</p>
",0
7193078,7193019,0,"<p>The answer is a straight no since C doesnt implement function overloading as is. It may allow you to alter an argument or two but internally what takes place isnt the actual mechanism of function overloading.</p>

<blockquote>
  <p>When an overloaded function is called, the C++ compiler selects the
  proper function by examining the number, types and order of the
  arguments in the call. Function overloading is commonly used to create
  several functions of the same name that perform similar tasks but on
  different data types.</p>
</blockquote>

<p>I dont really understand your question but in general function overloading depends upon the difference in the arguments.</p>

<p>The arguments of the method.</p>

<p>public int add(int a, int b)</p>

<p>public float add(float a, float b)</p>

<p>This is function overloading. Atleast one of the arguments has to change for the function to be overloaded. This is not possible in early versions of c has they dont identify the functions by the types of parameters being passed.</p>
",2
7193249,7193019,0,"<p>No, this is not an example of function overloading.  </p>

<p>True overloading implies that you have several <em>different</em> functions with the same name, but distinguished by their argument lists.  Depending on the arguments you pass, a different function instance will be invoked.  </p>
",0
7193371,7193019,0,"<p><em><a href=""http://en.wikipedia.org/wiki/Function_overloading"" rel=""nofollow"">Overloading</a></em> means having several contracts tied to a same name.
For example:</p>

<pre><code>int a(int i1, int i2);
int a(char c);
int a();
</code></pre>

<p>This doesn't exist in C as a symbol has to be unique within a same scope, but this exists in C++.</p>

<p>So even if it can be called several ways, with different parameters types and numbers, the<br> function <code>int a(int i, ...);</code> cannot be seen as overloading in C as there is only one contract, which is ""<em>give me the arguments you wish and I'll find a way to handle them</em>"".</p>

<p>But this function can be seen as an overloading in C++ in such a case:</p>

<pre><code>int a(int i, ...);
int a();
</code></pre>
",0
7193651,7193019,1,"<p>No.</p>

<p>Overloading means that a different function will be called depending on the number and/or type(s) of the arguments (some languages can also use the return type).  But in this case, you're calling the <em>same</em> function regardless of the number of arguments.</p>

<p>It's no more overloading than <code>func(42)</code> vs. <code>func(43)</code>.</p>

<p>Note that C99 does have something that <em>behaves</em> much like a narrow form of overloading.  If you have <code>#include &lt;tgmath.h&gt;</code>, then <code>sqrt(x)</code> will call one of three different functions (<code>sqrtf()</code>, <code>sqrt()</code>, or <code>sqrtl</code>()), depending on the type of <code>x</code>.  But that's actually a ""type-generic <em>macro</em>"", not an overloaded function.  C11 adds the <code>_Generic</code> keyword, making this facility available to user-written code.  But that's not related to the OP's question.</p>
",0
7169761,7169755,2,"<p>You need to declare <code>int snc;</code>, and the format specifier in <code>printf</code> should be <code>%d</code>. In addition, the return type of <code>main</code> should be <code>int</code>, you should include <code>stdio.h</code> and you should have double quotes around your format string in <code>printf</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
int main() {
    int a, b, c;
    printf(""first number: "");
    scanf(""%d"", &amp;a);
    printf(""second number: "");
    scanf(""%d"", &amp;b);
    c = a + b;
    printf(""total: %d\n"", c);
    return 0;
}
</code></pre>
",4
7169775,7169755,0,"<p>Also, <code>printf(""\n Total= %d \n"" , snc );</code></p>
",0
7221403,7221293,0,"<p>Your scanf() format has all kinds of requirements that your input doesn't have... try getting rid of commas and square braces.</p>

<p>Regarding the braces... you seem to want to make the equals sign optional, but you cannot do that in a scanf. However, you could just scan in the entire line and then pass it through a regular expression matcher.</p>
",3
7221531,7221293,2,"<p>Simplify the <code>scanf</code> argument: </p>

<pre><code>while(scanf(""r%d = %x"", &amp;i, &amp;hex)==2)
</code></pre>

<p>And what do you want to happen if <code>i</code> is outside limits? Should <code>error()</code> be called and what then? Probably not calling <code>reg[i] = hex;</code>.</p>
",3
7221645,7221293,2,"<p>Your input does not have the commas that the format string requires.  You need to remove the first comma and replace the others with blanks.</p>

<p>Also, the <code>%[=]</code> conversion specifier generates a string, not a single character; you need to define <code>char eq[2];</code> and remove the ampersand when passing <code>eq</code> to <code>scanf()</code>.</p>

<p>And, when debugging such stuff, make sure you capture the return from <code>scanf()</code> so you can report how badly things went wrong.</p>

<p>Note that you will be allowing considerable flexibility in the inputs even so:</p>

<pre><code>if  ((n = scanf(""%c%d %[=] %x"", &amp;r, &amp;i, eq, &amp;hex)) == 4)
    printf(""Got: %c%d %s 0x%08X\n"", r, i, eq, hex);
else
    printf(""Got: n = %d\n"", n);
</code></pre>

<p>The format string allows all of these lines through as valid:</p>

<pre><code>r1 = 0c100009
r2  =  0c100009
r3=0c100009
r 4=0c100009
</code></pre>

<p>In particular, disallowing 'r 4' will be difficult with the <code>scanf()</code> family of functions.</p>
",2
7188349,7187830,3,"<p><a href=""http://groups.google.com/group/comp.std.c/msg/dfe1ef367547684b?pli=1"" rel=""nofollow"">Demons will fly from your nose!</a></p>

<p>Actually if they're reading from the same pipe, then they're <a href=""http://linux.die.net/man/2/clone"" rel=""nofollow"">holding file descriptors</a> pointing to the same <a href=""http://tldp.org/LDP/tlk/ds/ds.html"" rel=""nofollow""><code>struct file</code></a> in the kernel. This means the kernel will determine who gets the data. Only one process will read any given byte.</p>

<p>Most reads and writes to pipes have some guarantees regarding <a href=""http://manpages.courier-mta.org/htmlman7/pipe.7.html"" rel=""nofollow""><code>PIPE_BUF</code></a>, you might like to look into that.</p>
",0
6613136,6613036,0,"<p>Use <code>%d</code> when you do <code>scanf()</code> for <code>int</code> types.</p>

<p><a href=""http://en.wikipedia.org/wiki/Printf#Format_placeholders"" rel=""nofollow"">%d and %i are similar but different for scanf().</a></p>
",0
6613138,6613036,2,"<p>You can't do this in C (enter the name of variable from keyboard when <code>scanf</code> is running), this is not a scripting language. Basically, all variable's names are lost during the compile step (they still may be saved as debugging information, which is used by debugger, e.g. gdb, but program usually not uses this at the run time).</p>

<p>You should to input a string (char array with type <code>char*</code> or <code>char []</code>) via <code>scanf</code> with <code>%s</code> and then parse it by hand, e.g.</p>

<pre><code>char string[50];
scanf(""%s"", string);
if( strcmp(string, ""monday"") == 0 )
  day = 1;
else if ( strcmp(string, ""tuesday"") == 0 )
  day = 2;
</code></pre>

<p>and so on.</p>
",3
6613196,6613036,1,"<p>You will need to write a function, or set of functions presenting a single interface to the program using it, that will scan a string (not an integer) already read by the program, and translate that to the appropriate value.  You should probably make the code case-insensitive, and able to accept valid (unique) abbreviations (like Sa, Su, M, Tu, W, Th, F), etc.  You might or might not accept the day-of-week numbers as alternatives to the names.  If you have to worry about internationalization or I18N (S, D, L, J, Ma, Me, V for Samedi, Dimanche, Lundi, Mardi, Mercredi, Jeudi, Vendredi in French, etc) that adds to the complexity of these functions (but not to the complexity of the code using them).</p>

<p>C does not provide a direct way of doing this.  The nearest approach is POSIX <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html"" rel=""nofollow""><code>strptime()</code></a>, and I don't think it handles this in its fullness.</p>
",0
6613210,6613036,0,"<p>If you do a <code>scanf</code> that will accept a signed integer (<code>%i</code>) you can't expect nothing more that an integer. If user input a string (say sunday, so you want that day receive '0' value) you have to do it in a different way.</p>

<p>Maybe you can ask to user to insert the format BEFORE entering the data (<code>printf(""Enter the format of day ('n' for name, 'd' for number:\n""</code>); and then, according to user's choice, you can do a different scan f: if i choosen 'n' then you can go over and find the corrispective numeric value.</p>

<p>If i can suggest you an improvement of your code, you have to declare the different days or with an array or with a struct or enum.</p>
",1
6613234,6613036,2,"<p>For starters, something like that.</p>

<pre><code> int day, month, counter;
 char *dofw[] = { ""sunday"", ""monday"", ""tuesday"", ""wednesday"", ""thursday"", ""friday"", ""saturday"", NULL};
 char day_string[20];

 printf(""Enter how many days in the month:\n"");
 scanf(""%d"", &amp;month);

 printf(""Enter what day the month starts on:\n"");
 scanf(""%20s"", day_string);

 int i;
 day = -1;
 for(i=0; dofw[i]; i++) {
   if(strcmp(day_string, dofw[i]) == 0) {
     day = i;
     break;
   } 
 }
 if(day == -1)
   printf(""User Y U not give good day\n"");
</code></pre>
",0
6626529,6626487,3,"<pre><code>int c;
while ((c = getchar()) != EOF) {
    if (c == ',')
        putchar('\n');
    else if (isalnum(c))
        putchar(c);
}
</code></pre>

<p>does the same as your program, but without the array, translating <code>,</code> to newline and swallowing whitespace.</p>
",0
6626563,6626487,0,"<p>I'd do this in two passes. First, I'd use <code>strtok()</code> to separate the data on the commas (delimiter characters <code>','</code> and <code>' '</code>).</p>

<p>Once you've done that, you can simple separate each character of each token.</p>
",2
8283625,8283596,12,"<p>Arguments to macros are themselves macro-expanded, <em>except</em> where the macro argument name appears in the macro body with the stringifier # or the token-paster ##.</p>

<p>In the first case, the argument of STR is <em>not</em> macro-expanded, and so you just get the name of the LINE macro.</p>

<p>In the second case, the argument of STR <em>is</em> macro-expanded when it is substituted into the definition of VAL, and so it works -- you get the actual line number because the LINE macro is expanded.</p>
",0
6636664,6636642,1,"<p>Given your input, the <code>s</code> parameter to <code>strcmp</code> is</p>

<pre><code>""          regular""
</code></pre>

<p>not</p>

<pre><code>""regular"" 
</code></pre>

<p>Thus, no match, and, as a result, the code in the <code>if</code> block never runs and your <code>while</code> loop will never terminate.</p>
",0
6636871,6636642,0,"<p>Here's a function (and a complete program showing how to use it) that does what I think you want.  Given the input of ""i/p:          regular:ddf"" it prints:</p>

<blockquote>
  <p>Token found: ""i/p""
  Token found: ""regular""
  Regular!
  Token found: ""ddf""</p>
</blockquote>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void process(char * input)
{
    char * s = strtok(input, "": "");  // Get first token.  Colon AND space are delimiters.
    while(1)
    {
        if (s == NULL)
        {
            break;   // No more tokens.
        }

        printf(""Token found: \""%s\""\n"", s);
        if(strcmp(s,""regular"")==0)
        {
            printf(""Found \""regular\"" token.\n"");
        }

        s = strtok(NULL, "": "");  // Get next token.
    }
}

int main(int argc, char **argv)
{
    char str[] = ""i/p:          regular:ddf"";
    process(str); // Warning: process(str) will modify str
}
</code></pre>

<p>One big drawback to this approach, however, if that you can't call <code>strtok</code> anywhere else in the loop because this function relies on the internal state that is stored by <code>strtok</code> when it calls <code>strtok</code> with a NULL argument.</p>
",0
6654970,6654954,1,"<p>to print on stdout use <code>printf</code> function from <code>stdio.h</code></p>
",0
6655018,6654954,0,"<p>To watch the values of a particular variable in Turbo c (windows)<br>
Window-> watch -> enter your variable name. Then Press F7.<br>
You can able to keep track the value of the variable.</p>
",0
6334433,6334411,6,"<p>You can call it as follows:</p>

<pre><code>int h;
int n;
insert(&amp;h, &amp;n);
</code></pre>

<p>Where the <code>&amp;</code> means ""take the address of"".</p>

<p><strong>But be careful: Your function has NO error-handling for erroneous user-input.</strong></p>
",0
6334445,6334411,1,"<pre><code>insert(&amp;h, &amp;n)
</code></pre>

<p>The &amp; operator gets the address of the variables (a pointer to it), and then passes those pointers to the function.  Scanf then uses those points as places to write the values the user enters.</p>
",0
6334531,6334411,0,"<p>Here is what your what your code should look like:</p>

<pre><code>   #include &lt;stdio.h&gt;

   void insert(int*, int*)

   int main()
   {
      int n, h;
      insert(&amp;h, &amp;n);

      return 0;
   }
   void insert(int* h, int* n)
   {
       printf(""give numbers"");

       scanf(""%d %d"", h, n);
   }
</code></pre>

<p>However like @Oli your program would break if I input a, 3.5, or anything not an int.</p>
",1
6334558,6334411,2,"<p>You can call it in two ways:</p>

<pre><code>// Method 1
int h, n;
insert(&amp;h, &amp;n);

// Method 2 (if you need to return the pointers or anything else weird for some reason
// I think this is useful in some cases when you are using a library that requires you
// to pass in heap-allocated memory
int *h = malloc(sizeof(int));
int *n = malloc(sizeof(int));
if(h == NULL || n == NULL)
     exit(1);

insert(h, n);

// Stuff

free(h);
free(n);
h = n = NULL;
</code></pre>
",0
6334610,6334411,0,"<p>It's mostly correct, but that <code>printf()</code> isn't guaranteed to be shown. <code>stdout</code> may be line buffered, so you would need to issue a <code>fflush()</code>.</p>
",0
6641683,6641657,1,"<p>You probably mean <code>u16* pt = imgArray;</code> - if you're declaring new variables in C you must give the type.</p>
",0
7384865,7384828,5,"<p>You have missed one index in accessing the element. <code>a[j], a[j-1]</code> should be <code>a[i][j], a[i][j-1]</code> in all places. <code>a[i]</code> is the pointer to the first element of i-th row in a 2D array. <code>a[i][j]</code> is the element at index <code>i, j</code>. </p>

<p>Note: Though not specified in the question, I am almost sure that <code>i, j, k</code> are integers and <code>a</code> is a 2D integer array.</p>
",1
7386769,7384828,1,"<p>The warning is around unsafe conversion from pointer to integer in one of the assignment statements. It could be any of the statements in your code. You should provide the variable type declaration in order to detect where the warning comes from.</p>
",0
7495062,7495056,-1,"<p>You are using the wrong format specifier in printf.  try using <code>%u</code> instead of <code>%d</code></p>
",0
7495064,7495056,1,"<p>You mean that is printing index as it was a <code>(signed) short</code> here?</p>

<pre><code>short input;
...
printf(""Final Value: %d"", input);
</code></pre>

<p><strong>Update:</strong> Since the hint doesn't seem to be catching, I will be more direct: Your declaration of input should be <code>unsigned short input;</code>.</p>
",0
7495067,7495056,3,"<p>The return type for <code>str_2_dec()</code> is <code>unsigned short</code> but you are storing the value in a (signed) <code>short</code> variable.  You should declare your variables the appropriate type otherwise you will have problems as you have observed.</p>

<p>In this case, you converted <code>""65535""</code> to an <code>unsigned short</code> which has the bit pattern <code>FFFF</code><sub>Hex</sub>.  That bit pattern was reinterpreted as a (signed) <code>short</code> which is the decimal value <code>-1</code>.</p>

<p>You should change your <code>main()</code> to something like this:</p>

<pre><code>int main()
{
    unsigned short input; /* to match the type the function is returning */
    char input_string[6]= ""65535"";

    input = str_2_dec(input_string, 5);

    printf(""Final Value: %hf"", input);
    return 0;
}
</code></pre>
",10
7495069,7495056,-1,"<p>The problem isn't with the function but with how you are printing the return value.</p>

<pre><code>printf(""Final Value: %d"", input);
</code></pre>

<p>The <code>%d</code> is place-holder for <code>int</code> type, not short.</p>

<p>Use <code>%hu</code> instead.</p>
",0
7495152,7495056,2,"<p>The problem is that you are taking the <code>unsigned short</code> return value of the function and storing it in a (signed) <code>short</code> variable, <code>input</code>. Since the value is outside the range representable in <code>short</code>, and since <code>short</code> is signed, this results in either an implementation-defined result or an implementation-defined signal being raised.</p>

<p>Change the type of <code>input</code> to <code>unsigned short</code> and everything will be fine.</p>
",1
7495194,7495056,-2,"<p>You didn't use the correct format specifier for the</p>

<pre><code>short input;
printf(""final value=%d\n"",input);
</code></pre>

<p>This makes the difference of your out put.</p>
",2
7512336,7512254,0,"<p>Build a shared library (DLL or .so) from XYZ. Chances are that there is a shared library already available.
Link your code i.e. ABC with XYZ and you can start using the functions exposed by XYZ in your program.
All open source software come with very good readme and instructions which will help you use the software. Start checking from those guides.</p>
",0
7512342,7512254,2,"<p>You shouldn't. The static keyword makes the function local to it's translation unit (source file, more or less), which means it can not be called from other translation units.</p>

<p>Well of course you <em>can</em>, but it may not be a good idea.</p>

<p>There's two ways of making the function available:</p>

<ol>
<li>Export it from the module by removing the static keyword and adding it to the api header file. This will of course involve changing the original source.</li>
<li>#include the file into your own source file, thus effectively making it part of your own translation unit. Depending on what other dependencies this file may have, this may or may not be a viable option. I would be very wary of doing this, but it is an option.</li>
</ol>
",0
7512344,7512254,0,"<p>If the XYZ project is open source</p>

<ul>
<li>add the source files of the XYZ project to your own and compile all together</li>
<li>if you change something in the XYZ project, consider sending a message to the maintainers of the project with your changes: they might like what you did and incorporate into a future version</li>
</ul>

<p>If the project is proprietary, you don't have the source code. A function defined as <code>static ...</code> is not visible in other translation units, so you don't call it at all.</p>
",0
6394221,6393755,1,"<p>Besides the problem with <code>currentNode-&gt;next = nodToDelete-&gt;next;</code> and negative positions you are mixing your ui and your logic.  As much as possible you should separate the two.</p>

<p>Sending something to the ui is a way of reporting progress; whether the ui is a command line, a browser or a speaker. Within deleteNode, an empty list or a position that is out of bounds, is not progress. Sequentially both are the same as success - you are done.  If you want failure to be to be reported, that should be done where it can lead to a separate sequence...i.e the caller.  Also, by mixing in ui, you introduce an unnecessary dependency and failure (what if there's a bug in printf, YOUR function will crash when it doesn't doesn't have to).  If you're function returns a defined result, the caller can decide if/how to report that result, including success (your function currently doesn't do so, and the caller has no way telling the difference between sucess or failure).</p>
",0
6393786,6393755,1,"<p>Once you've found the node you want to take out of the list, you need to actually take it out. =)</p>

<p>...</p>

<pre><code>nodToDelete = currentNode-&gt;next;
currentNode-&gt;next = nodToDelete-&gt;next;
free(nodToDelete);
</code></pre>

<p>...</p>
",1
6393795,6393755,2,"<p>Here is something that might work -- 
Replace</p>

<pre><code>currentNode = nodToDelete-&gt;next;
</code></pre>

<p>with</p>

<pre><code>currentNode-&gt;next = nodToDelete-&gt;next;
</code></pre>

<p>You basically need the node before the nodetodelete to have its next to point to the node that nodetodelete used to point to</p>
",0
8305271,8305189,5,"<p>You have to set the signal handler somewhere.</p>

<pre><code>#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

volatile int loopFlag = 1;

void sigHandler(int sig)
{
    loopFlag = 0;
}

void cleanupCode()
{
     printf(""Graceful exit \n"");
}

int main ()
{
    signal(SIGINT, sigHandler);

     while(loopFlag)
       sleep(600);

     cleanupCode();
}
</code></pre>
",4
8305350,8305189,4,"<p>This works for me:</p>

<pre><code>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

typedef struct sigaction SigAction;
static volatile sig_atomic_t loopFlag = 1;

static void sigHandler(int signum __attribute__((unused)))
{
    loopFlag = 0; 
}

static void cleanupCode(void) 
{
    printf(""Graceful exit\n"");
} 

static void setSignals(void)
{
    SigAction action;
    sigfillset(&amp;action.sa_mask);
    action.sa_handler = sigHandler;
    action.sa_flags = 0;
    sigaction(SIGINT, &amp;action, 0);
}

int main(void)
{    
    setSignals();
    while (loopFlag)
        sleep(600);
    cleanupCode(); 
    return(0);
}
</code></pre>
",0
7798952,7798923,7,"<p>You can't get back the original C source code from the compiled binary - there are many ways in C of producing the same end result so there isn't a unique source.</p>

<p>The process is called <a href=""http://en.wikipedia.org/wiki/Decompiler"" rel=""nofollow noreferrer"">decompiling</a></p>

<p>If I have misunderstood your question and you want to know how to view the assembler that the compiler generates from your C code then that depends on the particular compiler but they can all do it. See <a href=""https://stackoverflow.com/questions/1354899/how-can-i-see-the-assembly-code-that-is-generated-by-a-gcc-any-flavor-compiler"">How can I see the assembly code that is generated by a gcc (any flavor) compiler for a C/C++ program?</a></p>
",0
7799017,7798923,1,"<p>so are you asking how to reverse it?
you should search up reverse engineering and go from there.
you will need to use a decompiler, know a bit of assembly and there
is still no guarantee of success, that you will be able to get all the  original code. 
it will also get harder if the program originally had more than one file or some sort of hiding technique to randomize the code (obfuscation). You will need to do alot of work to get even a bare-bones resemblance of the original code.
here is the Wikipedia link for the topic: <a href=""http://en.wikipedia.org/wiki/Reverse_engineering"" rel=""nofollow"">http://en.wikipedia.org/wiki/Reverse_engineering</a></p>

<p><em><strong>HOWEVER, IT MAY BE ILLEGAL IN YOUR AREA, Depending on what you do with it, please don't get in trouble!</em></strong> </p>

<p><em><strong>NOTE:</strong> if this post isn't allowed, someone please let me know and i'll take it down immediately.</em></p>

<p>EDIT: It can also be called decompiling as well i believe.</p>
",2
7799023,7798923,6,"<p>use ollydbg and find your code within the disassebly :)</p>

<p>for example compiled code</p>

<pre><code>int main()
{
  system(""PAUSE"");
  return 0;
}
</code></pre>

<p>would be hard to find in all the lines of the disassebly but if you pad it you can find it easier for example... compile this code</p>

<pre><code>int main()
{
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");

  //mycode
  system(""PAUSE"");

  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  asm(""nop"");
  return 0;
}
</code></pre>

<p>and now in the disassembly i will be able to see the rows of ""nops"" and in between them is my code in binary form</p>

<pre><code>CPU Disasm
Address   Hex dump          Command                                  Comments
004013F8  |.  90            NOP
004013F9  |.  90            NOP
004013FA  |.  90            NOP
004013FB  |.  90            NOP
004013FC  |.  90            NOP
004013FD  |.  90            NOP
004013FE  |.  90            NOP
004013FF  |.  90            NOP
00401400  |.  90            NOP
00401401  |.  90            NOP
00401402  |.  90            NOP
00401403  |.  90            NOP
00401404  |.  90            NOP
00401405  |.  90            NOP
00401406  |.  90            NOP
00401407  |.  90            NOP
00401408  |.  90            NOP
00401409  |.  90            NOP
0040140A  |.  90            NOP
0040140B  |.  90            NOP
0040140C  |.  C70424 004044 MOV DWORD PTR SS:[LOCAL.6],OFFSET 004440
00401413  |.  E8 D8500100   CALL &lt;JMP.&amp;msvcrt.system&gt;                
00401418  |.  90            NOP
00401419  |.  90            NOP
0040141A  |.  90            NOP
0040141B  |.  90            NOP
0040141C  |.  90            NOP
0040141D  |.  90            NOP
0040141E  |.  90            NOP
0040141F  |.  90            NOP
00401420  |.  90            NOP
00401421  |.  90            NOP
00401422  |.  90            NOP
00401423  |.  90            NOP
00401424  |.  90            NOP
00401425  |.  90            NOP
00401426  |.  90            NOP
00401427  |.  90            NOP
00401428  |.  90            NOP
00401429  |.  90            NOP
0040142A  |.  90            NOP
0040142B  |.  90            NOP
</code></pre>

<p>so you can see that my system call is compiled into </p>

<pre><code>C70424004044E8D8500100
</code></pre>

<p>i hope this is what you meant :)</p>

<p>This can be done with ollydbg or x32dbg or objdump -M intel -d  ;)</p>
",1
7799124,7798923,1,"<p>If you compile with debug information embedded in the object files ( binary output files generated by compiling the source files ), links to the original locations of the source files will be embedded in the object files. This allows a debugger ( e.g. gdb ) to jump to the line in the source file corresponding to a breakpoint when that breakpoint is encountered whilst debugging the program. You can compile with debug info added by specifying the -g switch if you're using gcc. For example:</p>

<pre><code>gcc -g -o myProgram myProgram.c
</code></pre>

<p>compiles myProgram.c into a executable myProgram which you can run or debug. To debug myProgram you can use gdb:</p>

<pre><code>gdb myProgram
</code></pre>
",0
7799756,7798923,8,"<p>This is commonly described as ""turning hamburger back into cows.""  </p>

<p>A decompiler will generate C source code that's <em>functionally equivalent</em> to the original code, but it won't have any of the original symbol names, and may not be structured the same.  It may not even be very ""readable"".</p>

<p>You cannot recover the <em>original</em> source from a compiled program.  </p>
",0
7484807,7484779,-3,"<p>The keyword is variadic arguments, and they are declared with ...</p>
",5
7484841,7484779,5,"<p>printf is a ""variadic"" function. This means that the argument list is declared with <code>...</code> on the end, and in the implementation of printf the <code>va_list</code>, <code>va_start</code>, <code>va_arg</code> etc macros are used to extract the arguments from the variable length list.</p>
",1
7484929,7484779,4,"<p>printf's signature looks something like this:</p>

<pre><code>int printf ( const char * format, ... );
</code></pre>

<p>If a function has a '...' as its last argument, it can receive any number of arguments. Within the function, you would use va_arg to access those arguments. Here is an example from <a href=""http://www.cplusplus.com/reference/clibrary/cstdarg/va_start/"" rel=""nofollow"">cplusplus.com</a>:</p>

<pre><code>/* va_start example */
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void PrintFloats ( int amount, ...)
{
  int i;
  double val;
  printf (""Floats passed: "");
  va_list vl;
  va_start(vl,amount);
  for (i=0;i&lt;amount;i++)
  {
    val=va_arg(vl,double);
    printf (""\t%.2f"",val);
  }
  va_end(vl);
  printf (""\n"");
}

int main ()
{
  PrintFloats (3,3.14159,2.71828,1.41421);
  return 0;
}
</code></pre>

<p>Notice that PrintFloats here requires that you pass in the number of additional arguments. printf doesn't need to do this, because it can infer how many arguments you are passing in by counting the tags in the format string.</p>
",0
8247120,8246749,1,"<p>My understanding is that a space character can be 2 bytes if its Unicode(0x0020).</p>

<p>However, most text in still in ASCII or something that is backwards compatible with ASCII, which would make whitespace a single character on Linux machines.  On Windows, you could get a <code>\r\n</code> combination as Jim Clay mentioned.</p>
",2
7468029,7467992,1,"<p>You can make it faster by using larger datatypes. So instead of testing if each <code>int</code> is <code>0xffffffff</code>, you can go with 64-bit integers and test against <code>0xffffffffffffffff</code>.</p>

<p>If you're willing to vectorize, you can do 128-bits (SSE) or 256-bits (AVX) at a time.</p>

<p>In all cases, watch your data alignment. If you don't align, it either won't work, or will make it slower.</p>

<p>To take it one final step, you can actually unroll the loop and test multiple words/vectors at a time. This will give you better IPC. Only when you find any zero do you go through the mess of narrowing down which bit it is.</p>

<p>EDIT:</p>

<p>To illustrate this last point, you can do this: (I've omitted the cleanup code in case <code>idx % 4 != 0</code>)</p>

<pre><code>for (idx =0; idx &lt; n; idx += 4) {
    unsigned int test = uIntArray[idx];
    test &amp;= uIntArray[idx + 1];
    test &amp;= uIntArray[idx + 2];
    test &amp;= uIntArray[idx + 3];

    if (test &lt; UINT_MAX){
        //  Find which bit it is.

    }
}
</code></pre>

<p>Except you can do it on larger datatypes. (like SSE/AVX vectors)</p>

<p>This will make finding the region of the first 0 much faster, but narrowing on the exact bit will be a bit more expensive. So this approach is better if your datasize is large.</p>
",3
7468093,7467992,1,"<p>To find the first element you can observe that if the number <em>didn't</em> have a <code>0</code> bit then it must be <code>0xff..ff</code> so instead of explicitly checking each bit, you can simply compare it to <code>0xff..ff</code>.</p>

<p>To find the least significant bit of that number I believe you will still have to check each bit.</p>
",2
7468141,7467992,2,"<p>The index of the least significant <code>0</code> in <code>x</code> is the index of the least significant <code>1</code> in <code>~x</code>. In order to find the latter you just need to count the trailing zeros in <code>~x</code>. There are quite a few ways to do it, see here <a href=""http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightLinear"" rel=""nofollow"">http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightLinear</a></p>

<p>Using the last method (based on DeBruijn sequence), the search would look as</p>

<pre><code>static const unsigned MultiplyDeBruijnBitPosition[32] = 
{
  0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
  31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
};

for (idx = 0; idx &lt; n; idx ++)
  if (uIntArray[idx] &lt; UINT_MAX)
    break;

if (idx &lt; n) {
  unsigned v = ~uIntArray[idx];
  int bit_idx = MultiplyDeBruijnBitPosition[((v &amp; -v) * 0x077CB531u) &gt;&gt; 27];
  fprintf(stderr, ""\nEleIdx[%d] BitIdx[%d]\n"", idx, bit_idx);
}
</code></pre>
",1
7474822,7467992,1,"<p>The following code seems to work nicely, using the <code>~x &amp; (x + 1)</code> test from another (now deleted) answer and extending it.  Not sure why the other answer was deleted.</p>

<pre><code>/* Return the position of the first clear bit in the array,
 * or -1 if none found.
 *  arr:  array of uint32_t to search
 *  sz:   number of elements in arr
 */
int findClearBit(uint32_t *arr, int sz)
{
  int i;
  for (i = 0; i &lt; sz; i++) {
    if (~arr[i]) {
      switch (~arr[i] &amp; (arr[i] + 1)) {
        case 1 &lt;&lt; 31:  return (i * 32) + 31;
        case 1 &lt;&lt; 30:  return (i * 32) + 30;
        case 1 &lt;&lt; 29:  return (i * 32) + 29;
        case 1 &lt;&lt; 28:  return (i * 32) + 28;
        case 1 &lt;&lt; 27:  return (i * 32) + 27;
        case 1 &lt;&lt; 26:  return (i * 32) + 26;
        case 1 &lt;&lt; 25:  return (i * 32) + 25;
        case 1 &lt;&lt; 24:  return (i * 32) + 24;
        case 1 &lt;&lt; 23:  return (i * 32) + 23;
        case 1 &lt;&lt; 22:  return (i * 32) + 22;
        case 1 &lt;&lt; 21:  return (i * 32) + 21;
        case 1 &lt;&lt; 20:  return (i * 32) + 20;
        case 1 &lt;&lt; 19:  return (i * 32) + 19;
        case 1 &lt;&lt; 18:  return (i * 32) + 18;
        case 1 &lt;&lt; 17:  return (i * 32) + 17;
        case 1 &lt;&lt; 16:  return (i * 32) + 16;
        case 1 &lt;&lt; 15:  return (i * 32) + 15;
        case 1 &lt;&lt; 14:  return (i * 32) + 14;
        case 1 &lt;&lt; 13:  return (i * 32) + 13;
        case 1 &lt;&lt; 12:  return (i * 32) + 12;
        case 1 &lt;&lt; 11:  return (i * 32) + 11;
        case 1 &lt;&lt; 10:  return (i * 32) + 10;
        case 1 &lt;&lt; 9:   return (i * 32) + 9;
        case 1 &lt;&lt; 8:   return (i * 32) + 8;
        case 1 &lt;&lt; 7:   return (i * 32) + 7;
        case 1 &lt;&lt; 6:   return (i * 32) + 6;
        case 1 &lt;&lt; 5:   return (i * 32) + 5;
        case 1 &lt;&lt; 4:   return (i * 32) + 4;
        case 1 &lt;&lt; 3:   return (i * 32) + 3;
        case 1 &lt;&lt; 2:   return (i * 32) + 2;
        case 1 &lt;&lt; 1:   return (i * 32) + 1;
        case 1:        return (i * 32);
        default:       return -1;
      }
    }
  }
  return -1;
}
</code></pre>
",1
7383592,7383550,8,"<p>Here is a hint. Think of the combinations as bit encodings. E.g.</p>

<p>empty = 000 = 0</p>

<p>C = 001 = 1</p>

<p>B = 010 = 2</p>

<p>BC = 011 = 3</p>

<p>A = 100 = 4</p>

<p>AC = 101 = 5</p>

<p>AB = 110 = 6</p>

<p>ABC = 111 = 7</p>
",1
7388603,7383550,0,"<p>Use recursion, the idea is this:</p>

<p>For each recursive call, the string input is reduced by 1 character, the resulting string is stored in tmp string array. for ex:</p>

<p>call 1: abc</p>

<p>call 2: ab, last char: c</p>

<p>call 3: a, last char: b</p>

<p>then take the last char, and insert it into the list of string in tmp in all possible position, ex:</p>

<p>tmp contains: a, last char: b</p>

<p>insert b to position 0 and 1, resulting ""ab"" and ""ba""</p>

<p>the result is push back to the output list, and the process continues.</p>

<p>pseudo-code is roughly like this:</p>

<pre><code>get_perm (input):
    string[] tmp, out
    if input lengh == 1     //base case
        add input to tmp
        return tmp;

    tmp = get_permu (input[0 to input.length -1])
    char last_char = input[input.length - 1]
    //loop thru the string in tmp
    for string str in tmp:
        string tmp_str = str    //create a tmp copy
        int len = tmp_str.lengh //get the len
        //insert last_char to all possible position
        for j=0 to len:
            new_str = (add last_char to tmp_str in j position)
            out.add(new_str)

    return out
</code></pre>
",0
7388659,7383550,0,"<p>What you're looking for is a backtracking algorithm. </p>

<p>As this is a homework, that's the place where you should start.
A general idea about it is to encode the letters as integers and generate all possible combinations of length 1 using the 3 letters, then all possible combinations of length 2, and then all combinations of length 3.</p>
",0
6653525,6653464,1,"<p>Try</p>

<pre><code>fingers = (enum colors) ( PINK + BROWN ) ;
</code></pre>

<p>I believe the cast operator binds more tightly than the addition operator.</p>
",3
6661855,6661819,0,"<p>EDIT:
Ok, ok my first answer was stupid...
(Answered without thinking enough)</p>

<p>Now I got it:</p>

<p>The problem is </p>

<pre><code>#define max 5
</code></pre>

<p>Later <code>max</code> (=5) is used as a parameter!</p>
",2
6661861,6661819,2,"<p>You seem to be missing the <code>for</code> keyword in the loop header in <code>reverse()</code>.</p>
",2
6661935,6661819,3,"<p><code>max</code> is defined as a macro. So after preprocessing it becomes</p>

<pre><code>void reverse(int num[],int 5)
</code></pre>

<p>Which is not valid and you are getting <code>' ) expected'</code>. If <code>max</code> is constant then there is no need to pass it as a parameter. And also you have a missing <code>for</code> in the function. </p>
",5
7223759,7223742,3,"<p>Sure there is. Use <a href=""http://en.wikipedia.org/wiki/Include_guard"" rel=""nofollow"">include guards</a>.</p>

<pre><code>file1.h

#ifndef FILE1_H
#define FILE1_H

/* Define everything here. */

#endif
</code></pre>

<p>This way you can include file1.h over and over. In particular, you should always use include guards if a header <em>defines</em> things.</p>

<p>As a side note, if you don't need the details of the struct (that is, it should be an opaque type), you can use an incomplete type and just say <code>struct yourstruct;</code> at the top.</p>
",0
7223764,7223742,1,"<p>I believe your header files are not guarded with include guards to prevent redefinitions. They should be</p>

<pre><code>//header.h
#ifndef SOME_LONG_UNIQUE_NAME
#define SOME_LONG_UNIQUE_NAME

//header contents here

#endif
</code></pre>

<p>As a side note, you don't need all the header and struct definition just to declare function arguments. A forward declaration is enough.</p>

<pre><code>struct C; //not including C.h
struct C* f(struct C* p);
</code></pre>

<p>This decreases code coupling and accelerated compilation</p>
",0
7223770,7223742,0,"<p>Header file 1:</p>

<pre><code>#ifndef HEADERFILE1_H
#define HEADERFILE1_H

//...
#endif
</code></pre>

<p>Header file 2:</p>

<pre><code>#ifndef HEADERFILE2_H
#define HEADERFILE2_H

#include ""headerfile1.h""

//...
#endif
</code></pre>
",2
8453127,8453046,3,"<p>You don't have to use an enormous buffer size, and the kernel is going to be doing the hard work for you, but yes, reading a buffer full from up the file and writing nearer the beginning is the way to do it if you can't afford to do the simpler job of create a new file, copy what you want into that file, and then copy the new (temporary) file over the old one.  I wouldn't rule out the possibility that the approach of copying what you want to a new file and then either moving the new file in place of the old or copying the new over the old will be faster than the shuffling process you describe.  If the number of bytes to be removed was a disk block size, rather than 7 bytes, the situation might be different, but probably not.  The only disadvantage is that the copying approach requires more intermediate disk space.</p>

<p>Your outline approach will require the use of <code>truncate()</code> or <code>ftruncate()</code> to shorten the file to the proper length, assuming you are on a POSIX system.  If you don't have <code>truncate()</code>, then you will need to do the copying.</p>

<p>Note that opening the file twice will work OK if you are careful not to clobber the file when opening for writing - using <code>""r+b""</code> mode with <code>fopen()</code>, or avoiding <code>O_TRUNC</code> with <code>open()</code>.</p>
",2
8453302,8453046,4,"<p>You could <a href=""http://en.wikipedia.org/wiki/mmap"" rel=""nofollow"">mmap</a> the file into memory and then memmove the contents. You would have to truncate the file separately.</p>
",4
8231301,8231241,1,"<p>By using <code>if (choice = 1)</code> you are saying ""If I change choice to 1"" which is virtually guaranteed to work, but it destroys the previous value choice held.</p>

<p>You want to start off with <code>if (choice == 1)</code> which means ""If I compare choice to 2, is this equal?`.</p>
",3
8231317,8231241,2,"<p>A single <code>=</code> does <em>assignment</em> in C. <code>if (a = 5) { /* always executed! */ }</code> sets <code>a</code> to 5 and then executes the if-branch because <code>a = 5</code> evaluates to 5 which is considered true.</p>

<p>You want <code>==</code> which <em>compares</em> values. Thus:</p>

<pre><code>if (choice = 1){
</code></pre>

<p>Should be</p>

<pre><code>if (choice == 1){
</code></pre>

<p>Another thing:</p>

<pre><code>while (choice = 1|2|3|4|cont){   
</code></pre>

<p>Does not do what you think it does. It's actually computing the bitwise or of 1, 2, 3, 4 and <code>cont</code>. (So just changing <code>=</code> to <code>==</code> wouldn't be sufficient.) You need to compare each value in turn: </p>

<pre><code>while (choice == 1 || choice == 2 || choice == 3 || choice == 4 || choice == cont){ 
</code></pre>

<p>Also notice the use of <code>||</code> (logical OR) instead of bitwise or.</p>

<p>EDIT: The reason your program prematurely exits is because of the following:</p>

<pre><code>   else
        printf(""Exiting"");
        break;
</code></pre>

<p>You're missing curly braces (<code>{</code> and <code>}</code>), so it actually means the following (despite misleading indention):</p>

<pre><code>   else
        printf(""Exiting"");
   break;
</code></pre>

<p>Your code probably has more errors.</p>
",1
8231334,8231241,2,"<p>For example, the following line:</p>

<pre><code>while (choice = 1|2|3|4|cont){   
</code></pre>

<p>belies a misunderstanding of some fundamental concepts.</p>

<p>First <code>=</code> is the <em>assignment</em> operator. The above code, among other things, changes the value of <code>choice</code>. Use <code>==</code> for equality comparison.</p>

<p>Second, the <code>|</code> operator is a <em>bitwise or</em>. The value of <code>1|2|3|4|5</code> is <code>7</code> (I'll leave it to you to figure out why sometime). Instead, use <code>||</code> like this:</p>

<pre><code>while (choice == 1 || choice == 2 || choice == 3 || choice == 4 || choice == cont) {
</code></pre>

<p>There are other similar errors throughout your code.</p>
",0
8231373,8231241,3,"<p>Your program ends because the <code>break;</code> isn't in the scope you think it is:</p>

<pre><code>else if (choice = 4){
    printf (""Phone number: "");    
    fgets(entry.phone, sizeof(entry.phone),stdin);
}
else
    printf(""Exiting"");
    break;
</code></pre>

<p>Even though you've indented the <code>break</code>, it doesn't belong to the else clause.  So no matter what happens in the if/else block, the <code>break</code> gets executed and your program breaks out of the loop and ends.</p>

<p>To fix it, add braces to enclose the break inside the scope of the <code>else</code>.:</p>

<pre><code>else if (choice = 4){
    printf (""Phone number: "");    
    fgets(entry.phone, sizeof(entry.phone),stdin);
}
else
{
    printf(""Exiting"");
    break;
}
</code></pre>

<p>And once you fix that, this line will cause your program to terminate because it always evaluates to <code>true</code> and returns from <code>main</code>:</p>

<pre><code>if (cont = 'n'|'N')
    return 0;
</code></pre>

<p>You want that line to say</p>

<pre><code>if (cont == 'n' || cont == 'N')
    return 0;
</code></pre>

<p>These fixes will at least stop your program from terminating, but as others have pointed out there are numerous logical errors elsewhere that will prevent it from doing what you want.</p>
",0
7088898,7088818,1,"<p>your <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strncpy/"" rel=""nofollow""><code>strncpy</code></a>'s are slightly off, you want this rather, so that you capture the correct amount of digits:</p>

<pre><code>strncpy(bjahr , &amp;bday[6], 4);
strncpy(btag  , &amp;bday[0], 2);
strncpy(bmonat, &amp;bday[3], 2);
</code></pre>

<p>also, your buffers should be a bit larger to accommodated the NULL terminator that atoi requires (I align then to multiples of four just for better matching with what the compiles stack allocator will do), which you can add in yourself, or get by pre-zeroing the buffers:</p>

<pre><code>char name[20] = {0}, bday[10] = {0}, bjahr[8] = {0}, bmonat[4] = {0}, btag[4] = {0};
</code></pre>

<p>however, you'd do better using something like <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/scanf/"" rel=""nofollow""><code>scanf</code></a> of <code>sscanf</code></p>
",0
7088916,7088818,2,"<p>Your variables are too short: for example, you expect two characters for the month, but you also need to account to for <code>\0</code> that terminates the string. Also, you're just copying one character per day and month and not null terminating it. So it should be:</p>

<pre><code>char name[20], bday[11], bjahr[5], bmonat[3], btag[3];

...

gets(bday);

strncpy(bjahr , &amp;bday[6], 4);
bjahr[4] = 0;
strncpy(btag  , &amp;bday[0], 2);
btag[2] = 0;
strncpy(bmonat, &amp;bday[3], 2);
bday[2] = 0;
</code></pre>

<p>But a way better solution would be to use <code>scanf</code> instead, you should read about it and get familiar with it. It can easily help you to correctly parse input like <code>1.2.2000</code>, for example.</p>

<p>Also, your current solution with fixed sized arrays can easily yield a buffer overflow (just enter <code>abcdefghijklmnopqrst</code>). You should do this instead:</p>

<pre><code>fgets(bday, sizeof(bday), stdin);
</code></pre>
",0
6606943,6606906,1,"<p>It is possible in C skill. Use <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fgets/"" rel=""nofollow"">fgets()</a> to read the file and use <strike>strcmp()</strike> <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strstr/"" rel=""nofollow"">strstr()</a> to find if the read data contains the pattern you're looking for.</p>
",11
6606944,6606906,3,"<p><a href=""http://pubs.opengroup.org/onlinepubs/009695399/"" rel=""nofollow"">POSIX</a> provides <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/regcomp.html"" rel=""nofollow"">regcomp</a>, <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/regexec.html"" rel=""nofollow"">regexec</a>, <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/regfree.html"" rel=""nofollow"">regfree</a>, and friends for regular expression matching. If you are using C++, then you can use the <a href=""http://code.google.com/p/re2/"" rel=""nofollow"">RE2</a> library for faster, safer regular expression matching. If all you need to do is find an exact match like ""hello"", you won't even need a regex library like these.</p>

<p>Yes, this is something you can do with C, but I won't do your homework for you.</p>
",5
6606949,6606906,-1,"<p>Yes it is possible, you can do pretty much anything in C. Open the file, read it character by character (byte by byte), check if it is the first letter in your search key ('h'), if it is, check if it is the next letter and so on.</p>

<p>EDIT: Pseudo code</p>

<pre><code>const char key[] = ""hello"";
bool found_key = false;

open file
handle errors if not open    

while not end of file
{
  i=0;
  do
  {
    ch = read 1 character;

    if(ch == key[i])
    {
      if(i==sizeof(key))
      {
        found_key = true;
        break;
      } 
      i++;
    }
  } while(ch == key[i]); 
}
</code></pre>

<p>I would regard any solution involving saving more than 1 char in RAM as quite suspicious.</p>
",17
6607037,6606906,3,"<p>code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[])
{
   FILE *f;
   char buffer[100];
   char *pattern = ""hello"";

   if (argc != 2) {
      // provide filename as first argument
      return 0;
   }

   if ((f = fopen(argv[1], ""r"")) == NULL) {
      // file not found
      return 0;
   }

   while (fgets(buffer, sizeof(buffer), f)) {
      if (strstr(buffer, pattern)) {
         return 1;
      }
   }

   return 0;
}
</code></pre>

<p>build:</p>

<pre><code>gcc demo.c
</code></pre>

<p>usage:</p>

<pre><code>./a.out 1.txt
echo $?
1

./a.out 2.txt
echo $?
0
</code></pre>
",9
7181027,7180290,2,"<p>A great article to read on this is:  </p>

<p><a href=""http://www.embedded.com/design/prototyping-and-development/4024941/Learn-a-new-trick-with-the-offsetof--macro"" rel=""nofollow"">Learn a new trick with the offsetof() macro</a></p>

<p>I use the offsetof macro frequently in my embedded code, together with the modified SIZEOF macro as discussed in the article.</p>
",0
7180364,7180290,1,"<p>Your <code>struct mystruct1</code> has 1 member named <code>u_line</code>. You can see the offset of that member</p>

<pre><code>offsetof(struct mystruct1, u_line); // should be 0
</code></pre>

<p>or of members down the line if you specify each ""level of parenthood""</p>

<pre><code>offsetof(struct mystruct1, u_line.line);
offsetof(struct mystruct1, u_line.line.buf);
offsetof(struct mystruct1, u_line.logo);
</code></pre>
",0
7180389,7180290,13,"<p>The <code>offsetof()</code> macro takes two arguments.  The C99 standard says (in ¡ì7.17 <code>&lt;stddef.h&gt;</code>):</p>

<blockquote>
<pre><code>offsetof(type, member-designator)
</code></pre>
  
  <p>which expands to an integer constant expression that has type <code>size_t</code>, the value of
  which is the offset in bytes, to the structure member (designated by member-designator),
  from the beginning of its structure (designated by type). The type and member designator
  shall be such that given</p>

<pre><code>static type t;
</code></pre>
  
  <p>then the expression <code>&amp;(t.member-designator)</code> evaluates to an address constant.</p>
</blockquote>

<p>So, you need to write:</p>

<pre><code>offsetof(struct mystruct1, u_line.line);
</code></pre>

<p>However, we can observe that the answer will be zero since <code>mystruct1</code> contains a <code>union</code> as the first member (and only), and the <code>line</code> part of it is one element of the union, so it will be at offset 0.</p>
",2
7180394,7180290,0,"<p>Firstly, AFAIK, <code>offsetof</code> is intended to be used with immediate members of the struct only (am I right on this?). </p>

<p>Secondly, knowing the internal details of popular <code>offsetof</code> implementations I can suggest trying</p>

<pre><code>offsetof(struct mystruct1, u_line.line) 
</code></pre>

<p>This should work. Whether it is standard-compliant is an open question for me.</p>

<p>P.S. Judging by @Jonathan Leffler's answer, this should actually work.</p>
",3
8454225,8454208,0,"<p>Referencing that location in memory after the function has returned is dangerous. Of course the location still exists (and it may still contain your value), but you no longer have any claim to that memory region and it will likely be overwritten with new data as the program continues and new local variables are allocated on the stack.</p>

<p><code>gcc</code> gives me the following warning:</p>

<pre><code>t.c: In function ¡®test¡¯:
t.c:3:2: warning: function returns address of local variable [enabled by default]
</code></pre>

<p>Consider this test program:</p>

<pre><code>int * test(int p) {
    int loc = p;
    return &amp;loc;
}

int main(void) {
    int *c = test(4);
    test(5);
    printf(""%d\n"", *c);
    return 0;
}
</code></pre>

<p>What do you think this prints?</p>
",2
8454234,8454208,3,"<p>The address can be returned, but the value stored at the address cannot reliably be read.  Indeed, it is not even clear that you can safely assign it, though the chances are that on most machines there wouldn't be a problem with that.</p>

<p>You can often read the address, but the behaviour is undefined (read '<em><strong>bad</strong>: to be avoided at all costs!</em>').  In particular, the address may be used for other variables in other functions, so if you access it after calling other functions, you are definitely unlikely to see the last value stored in the variable by the function that returned the pointer to  it.</p>

<hr>

<blockquote>
  <p>Why then is a function returning a pointer ever required?</p>
</blockquote>

<p>One reason is often 'dynamic memory'.  The <code>malloc()</code> family of functions return a pointer to new (non-stack) memory.</p>

<p>Another reason is 'found something at this location in a value passed to me'.  Consider <code>strchr()</code> or <code>strstr()</code>.</p>

<p>Another reason is 'returning pointer to a static object, either hidden in the function or in the file containing the source for the function'.  Consider <code>asctime()</code> et al (and worry about thread-safety).</p>

<p>There are probably a few others, but those are probably the most common.</p>

<p>Note that none of these return a pointer to a local (stack-based) variable.</p>
",1
8454241,8454208,0,"<p>The variable is gone, but the memory location still exists and might even still contain the value you set. It will however probably get overwritten pretty fast as more functions are called and the memory address gets reused for another function's local variables. You can learn more by reading about the <a href=""http://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow"">Call Stack</a>, which is where local variables of functions are stored.</p>
",2
7170252,7170150,0,"<p>The problem may be in the surrounding code that uses <code>basename()</code>.  The POSIX standard for <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/basename.html"" rel=""nofollow noreferrer""><code>basename()</code></a> says:</p>
<blockquote>
<p>DESCRIPTION</p>
<p>The <code>basename()</code> function shall take the pathname pointed to by path and return a pointer to the final component of the pathname, deleting any trailing <code>'/'</code> characters.</p>
<p>If the string pointed to by path consists entirely of the <code>'/'</code> character, <code>basename()</code> shall return a pointer to the string <code>&quot;/&quot;</code>. If the string pointed to by path is exactly <code>&quot;//&quot;</code>, it is implementation-defined whether <code>'/'</code> or <code>&quot;//&quot;</code> is returned.</p>
<p>If path is a null pointer or points to an empty string, <code>basename()</code> shall return a pointer to the string <code>&quot;.&quot;</code>.</p>
<p>The <code>basename()</code> function may modify the string pointed to by path, and may return a pointer to static storage that may then be overwritten by a subsequent call to <code>basename()</code>.</p>
<p>The <code>basename()</code> function need not be thread-safe.</p>
<p>RETURN VALUE</p>
<p>The <code>basename()</code> function shall return a pointer to the final component of path.</p>
</blockquote>
<p>There's a lot of wriggle room in that specification.</p>
<p>But it looks a bit as if you are trying to use the same space to store two values at the same time, unsuccessfully.</p>
",0
7188421,7188400,2,"<p>I would go with a hash table, hashing the actual name. Then you can search by name and retrieve the encrypted value.</p>

<p>Obviously if the problem is small (few names, few searches) you shouldn't bother and just use an array of structures.</p>
",6
7213713,7213692,8,"<p>When you write <code>char *str = ""abcde"";</code> you make a <code>char</code> pointer to a string literal, which you are not allowed to modify. </p>

<p>When you write <code>char str[] = ""abcde"";</code> you make a <code>char</code> array and copy a string literal into it. This is just a normal <code>char</code> array so you are free to modify it.</p>

<p>It is undefined behaviour to modify a string literal. This is a deliberate design decision that allows string literals to be placed in special read only sections of the output program. In practice many compliers and platforms do this (marking it read only means you need only one copy of the strings in memory, even if there is more than one instance of the program running). This leads to the behaviour you observed on your platform.</p>
",0
7213722,7213692,2,"<pre><code>char *str = ""abcde"";
</code></pre>

<p><code>str</code> is a pointer to char that points to a string literal. String literals are stored in read only memory. You can't modify them.</p>

<pre><code>char str[] = ""abcde"";
</code></pre>

<p>The string literal <code>""abcde""</code> is copied into the array <code>str</code>. So you can modify it.</p>
",1
7213731,7213692,1,"<p><code>char *</code> is pointer to char (string literal) and <code>char []</code> is an array of char. You can't modify string literal but you can modify char array.</p>
",0
7178040,7177956,4,"<p>The decimal and hexadecimal systems are just ways of expressing the value of the int. In a way ""it is already a hexadecimal"".</p>
",3
7178056,7177956,0,"<p>Of course it is possible. Just think about how <code>printf</code> itself was originally implemented...</p>

<p>I won't give you a full solution, only hints, based on which you can experiment with the implementation in code:</p>

<p>An 8-bit number can be expressed as 2 hex digits, which contain the higher and lower 4 bits, respectively. To get these bits, you can use the bit-shift (<code>&gt;&gt;</code>) and mask (<code>&amp;</code>) operators.</p>

<p>Once you have a 4-bit value, you can easily map it to the correct hex digit using a sequence of <code>if</code>s, or (as a more elegant solution) by indexing into a character array.</p>
",3
7178057,7177956,0,"<p>Hexdecival vs Decimal vs Binary..etc.. are only different bases that represent the same number. printf doesn't convert your number, it generates an hexdecimal string representation of your number. If you want to implement your own <a href=""http://en.wikipedia.org/wiki/Hexadecimal"" rel=""nofollow"">study</a> how to make a conversion between decimal and hexdecimal bases.</p>
",0
7178066,7177956,0,"<p><strong>Yes</strong>, it is definitely possible to convert an integer to a hexadecimal string without using the ""printf"" family of formatting functions.</p>

<p>You can write such a function by converting the number from base-10 (as we think about it) to base-16 (hexadecimal) and printing the digits in that representation (<code>0-9A-F</code>).  This will require you to think a lot about <a href=""http://en.wikipedia.org/wiki/Radix"" rel=""nofollow"">the bases we use to represent numbers</a>.</p>
",1
7178083,7177956,2,"<p>I think you can use itoa in <strong>stdlib.h</strong> :<br><br>
<code>char *  itoa ( int value, char * str, int base ); or sprintf(str,""%x"",value);</code> <br><br>
The documentation : <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/itoa/"" rel=""nofollow"">itoa documentation</a></p>
",6
7178113,7177956,0,"<p>If you are referring to displaying an int as a hexadecimal number in C, than you will have to write a function that does the same thing as printf.</p>

<p>If you are referring to casting or internal representation, it can't be done because hexadecimal is not a data type.</p>
",0
7178479,7177956,0,"<p>An <code>int</code> is stored in your computer as a binary number.  In fact, since hex can be interpreted as a shorthand for writing binary, you might even say that when you print out a decimal number using printf, it has to be converted <em>from</em> hex <em>to</em> decimal.</p>
",0
7178002,7177956,-3,"<pre><code>cout &lt;&lt; hex &lt;&lt; intvar &lt;&lt; endl;
</code></pre>

<p>But if you want an answer that gives you an A for your homework, you're not going to get lucky :)</p>
",1
6936282,6936254,2,"<p>Because,</p>

<pre><code>(1) function(char * p_array[])
</code></pre>

<p>is equivalent to <code>char **p_array</code>; i.e. a double pointer which is valid.</p>

<pre><code>(2) function(char (*p_array)[])
</code></pre>

<p>You are right, that <code>p_array</code> is pointer to <code>char</code> array. But that needs to be of fixed size in the case when it appears as function argument. You need to provide the size and that will also become valid.</p>
",9
6936285,6936254,16,"<p>Both are valid <strong>in C</strong> but <strong>not C++</strong>.  You would <em>ordinarily</em> be correct:</p>

<pre><code>char *x[]; // array of pointers to char
char (*y)[]; // pointer to array of char
</code></pre>

<p>However, the arrays decay to pointers if they appear as function parameters.  So they become:</p>

<pre><code>char **x; // Changes to pointer to array of pointer to char
char (*y)[]; // No decay, since it's NOT an array, it's a pointer to an array
</code></pre>

<p>In an array type in C, one of the sizes is permitted to be unspecified.  This must be the leftmost one (whoops, I said rightmost at first).  So,</p>

<pre><code>int valid_array[][5]; // Ok
int invalid_array[5][]; // Wrong
</code></pre>

<p>(You can chain them... but we seldom have reason to do so...)</p>

<pre><code>int (*convoluted_array[][5])[][10];
</code></pre>

<p><strong>There is a catch,</strong> and the catch is that an array type with <code>[]</code> in it is an <em>incomplete type.</em>  You can pass around a pointer to an incomplete type but certain operations will not work, as they need a complete type.  For example, this will not work:</p>

<pre><code>void func(int (*x)[])
{
    x[2][5] = 900; // Error
}
</code></pre>

<p>This is an error because in order to find the address of <code>x[2]</code>, the compiler needs to know how big <code>x[0]</code> and <code>x[1]</code> are.  But <code>x[0]</code> and <code>x[1]</code> have type <code>int []</code> -- an incomplete type with no information about how big it is.  This becomes clearer if you imagine what the ""un-decayed"" version of the type would be, which is <code>int x[][]</code> -- obviously invalid C.  If you want to pass a two-dimensional array around in C, you have a few options:</p>

<ul>
<li><p>Pass a one-dimensional array with a size parameter.</p>

<pre><code>void func(int n, int x[])
{
    x[2*n + 5] = 900;
}
</code></pre></li>
<li><p>Use an array of pointers to rows.  This is somewhat clunky if you have genuine 2D data.</p>

<pre><code>void func(int *x[])
{
    x[2][5] = 900;
}
</code></pre></li>
<li><p>Use a fixed size.</p>

<pre><code>void func(int x[][5])
{
    x[2][5] = 900;
}
</code></pre></li>
<li><p>Use a variable length array (C99 only, so it probably doesn't work with Microsoft compilers).</p>

<pre><code>// There's some funny syntax if you want 'x' before 'width'
void func(int n, int x[][n])
{
    x[2][5] = 900;
}
</code></pre></li>
</ul>

<p>This is a frequent problem area even for C veterans.  Many languages lack intrinsic ""out-of-the-box"" support for real, variable size, multidimensional arrays (C++, Java, Python) although a few languages do have it (Common Lisp, Haskell, Fortran).  You'll see a lot of code that uses arrays of arrays or that calculates array offsets manually.</p>
",7
6936287,6936254,2,"<p>NOTE:<br>
The below answer was added when the Q was tagged C++, and it answers from a C++ perspective. With tagged changed to only C, both the mentioned samples are valid in C.</p>

<p>Yes, Your reasoning is correct.<br>
If you try compiling the error given by compiler is:  </p>

<pre><code>parameter ¡®p_array¡¯ includes pointer to array of unknown bound ¡®char []¡¯
</code></pre>

<p>In C++ array sizes need to be fixed at compile time. C++ standard forbids Variable Lenght Array's(VLA) as well. Some compilers support that as an extension but that is non standard conforming.</p>
",0
6937038,6936254,3,"<p>Those two declarations are very different.  In a function parameter declaration, a declarator of <code>[]</code> directly applied to the parameter name is completely equivalent to a <code>*</code>, so your first declaration is exactly the same in all respects as this:</p>

<pre><code>function(char **p_array);
</code></pre>

<p>However, this does <em>not</em> apply recursively to parameter types.  Your second parameter has type <code>char (*)[]</code>, which is a pointer to an array of unknown size - it is a pointer to an incomplete type.  You can happily declare variables with this type - the following is a valid variable declaration:</p>

<pre><code>char (*p_array)[];
</code></pre>

<p>Just like a pointer to any other incomplete type, you cannot perform any pointer arithmetic on this variable (or your function parameter) - that's where you error arises.  Note that the <code>[]</code> operator is specified as <code>a[i]</code> being identical to <code>*(a+i)</code>, so that operator cannot be applied to your pointer.  You can, of course, happily use it as a pointer, so this is valid:</p>

<pre><code>void function(char (*p_array)[])
{
    printf(""p_array = %p\n"", (void *)p_array);
}
</code></pre>

<p>This type is also compatible with a pointer to any other fixed-size array of <code>char</code>, so you can also do this:</p>

<pre><code>void function(char (*p_array)[])
{
    char (*p_a_10)[10] = p_array;

    puts(*p_a_10);
}
</code></pre>

<p>...and even this:</p>

<pre><code>void function(char (*p_array)[])
{
    puts(*p_array);
}
</code></pre>

<p>(though there is precious little point in doing so: you might as well just declare the parameter with type <code>char *</code>).</p>

<p>Note that although <code>*p_array</code> is allowed, <code>p_array[0]</code> is not.</p>
",2
8237067,8236935,0,"<blockquote>
  <p>In this case, a will take the value of 34? because [34] is the first byte?</p>
</blockquote>

<p>Not exactly. If you look at the number in hex format it might look that way. But if you look at the number in decimal, 0x1234 = 4660 (in decimal). Like the sample program given by @user1061077 above, the value stored is <code>52</code> which is <code>4660 % 256</code> i.e the remainder of the number when divided by <code>256</code>. Why <code>256</code>? Because in a 8-bit memory you can store only values from 0 through <code>255</code> (total <code>256</code> numbers). When you assign a value larger than <code>256</code>, then the number rolls over and finally the remainder gets stored. So when you try to store <code>256</code> instead of <code>4660</code>, the resulting value will be <code>0</code>. So for larger numbers, the number of times the roll over happens will be exactly the quotient of the division: <code>number-to-be-stored / total-number-of-numbers</code>. In your case it is the quotient of <code>4660/256</code>.</p>
",3
8236982,8236935,3,"<blockquote>
  <p>jslagle@AR-E642-45QS3R1:~ $ cat test.c</p>
</blockquote>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

int main (int argc, char **argv) {
  uint8_t a = 0x1234;

  printf(""%d %x\n"",a,a);
  return 0;
}
</code></pre>

<hr>

<pre><code>jslagle@AR-E642-45QS3R1:~ $ gcc -o test test.c
test.c: In function ¡®main¡¯:
test.c:5:3: warning: large integer implicitly truncated to unsigned type [-Woverflow]

jslagle@AR-E642-45QS3R1:~ $ ./test
52 34
</code></pre>

<p>It does indeed behave like that.  GCC gives you a warning if you do it.</p>
",7
7458083,7458072,22,"<p>It's the other way around. <code>1 &lt;&lt; x</code> will give you '2 ^ x'.</p>
",0
7458160,7458072,2,"<p>This should do what you want. Call <code>pow(2, x)</code> to get 2<sup>x</sup>.</p>

<pre><code>int abs (int x) {
  if (x &lt; 0) return -x;
  return x;
}

int signum (int x) {
  if (x &lt; 0) return -1;
  if (x &gt; 0) return 1;
  return 0;
}

int add (int x, int y) {
  for (int i = 0; i &lt; abs(y); ++i) {
    if (y &gt; 0) ++x;
    else --x;
  }
  return x;
}

int mult (int x, int y) {
  int sign = signum(x) * signum(y);
  x = abs(x);
  y = abs(y);
  int res = 0;
  for (int i = 0; i &lt; y; ++i) {
    res = add(res, x);
  }
  return sign * res;
}

int pow (int x, int y) {
  if (y &lt; 0) return 0;
  int res = 1;
  for (int i = 0; i &lt; y; ++i) {
    res = mult(res, x);
  }
  return res;
}
</code></pre>
",0
7458220,7458072,2,"<p>Left shift is limited to the word size of your CPU, either 32 or 64 bits, which limits the maximum exponent which you can safely use, before the result is undefined (2^31 or 2^63).</p>

<p>The following works for larger exponents but uses floating point arithmetic. If you need exact results you should consider using a infinite precision maths library such as <a href=""http://gmplib.org/"" rel=""nofollow"">GMP</a></p>

<pre><code>#include &lt;math.h&gt;

int main() {
  double base = 2;
  double exponent = 4;

  double result = pow(base, exponent);

  return 0;
}
</code></pre>
",1
7758747,7758695,5,"<p>The identifier (the name) must come first. Try</p>

<pre><code>typedef float mat[MAT_ROW_SIZE][MAT_COL_SIZE];
</code></pre>
",0
7186430,7186388,6,"<p>Yes, <code>typedef</code> is used to declare a type. From now on</p>

<pre><code>u8 x;
/* Equivalent to. */
unsigned _CPU_8BIT_INT_ x;
</code></pre>

<p>Are you sure you're not better off using <strong><code>uint8_t</code> from <code>stdint.h</code></strong> ?</p>
",0
7501177,7500939,0,"<p>I will recommend Eclipse as the IDE. It has some issues on Windows, but it is great on Linux.</p>

<p>GCC/MinGW as compiler doesn't need much discussing.</p>
",0
7500973,7500939,1,"<p>I think gcc is your best option. On Windows the best port is probably <a href=""http://www.mingw.org/"" rel=""nofollow"">MinGW</a>.</p>

<hr>

<p>You edited your question to request an IDE too. Try <a href=""http://www.codeblocks.org/"" rel=""nofollow"">Code::Blocks</a>.</p>
",1
7198922,7198896,2,"<p>For info on size_t, see the Stack Overflow question: <a href=""https://stackoverflow.com/questions/2550774/what-is-size-t-in-c/2550799#2550799"" title=""What is size_t in C?"">What is size_t in C?</a></p>

<p>You're right for uint32 and uint64 that they're just being specific about the number of bits that they would like, and that the compiler should interpret them as unsigned.</p>
",1
7198933,7198896,1,"<p>There are many possible reasons for choosing an underlying type for an integer value. The most obvious one is the size of the maximum possible value that you can store -- uint32 will be able to store a number twice as large as int32, which might be desirable. int64 will be able to store a number much larger than int32 - up to 2^63 - 1 instead of 2^31 - 1. </p>

<p>There are other possible reasons as well. If you're directly reading binary data from some source (file, socket, etc), it is necessary to make sure it's interpreted correctly. If someone writes a uint32 and you interpret it as an int32, it's possible that you interpret a very large positive number as a negative number (overflow). </p>

<p>size_t is just a typedef for an unsigned int, usually 32-bit I believe.</p>
",0
7198943,7198896,1,"<p>For most day-to-day programming, the size of an integer doesn't really matter all that much.  But sometimes it is good to be specific.  This is especially useful in low-level or embedded programming.  Another place it is useful is scientific or computationally intensive tasks where it might be wasteful to use an int that is bigger than necessary.</p>

<p>The advantage of size_t is that it is unsigned.  On the one hand it nice to use size_t because it adds more information about what the argument should be (i.e not negitave).  On the other hand it is less tying vs. <code>unsigned int</code>.</p>
",1
7198944,7198896,19,"<p>These are for platform-independence.</p>

<p><code>size_t</code> is, by definition, the type returned by <code>sizeof</code>.  It is large enough to represent the largest object on the target system.</p>

<p>Not so many years ago, 32 bits would have been enough for any platform.  64 bits is enough today.  But who knows how many bits will be needed 5, 10, or 50 years from now?</p>

<p>By writing your code not to care -- i.e., always use <code>size_t</code> when you mean ""size of an object"" -- you can write code that will actually compile and run 5, 10, or 50 years from now.  Or at least have a fighting chance.</p>

<p>Use the types to say what you mean.  If for some reason you require a specific number of bits (probably only when dealing with an externally-defined format), use a size-specific type.  If you want something that is ""the natural word size of the machine"" -- i.e., fast -- use <code>int</code>.</p>

<p>If you are dealing with a programmatic interface like <code>sizeof</code> or <code>strlen</code>, use the data type appropriate for that interface, like <code>size_t</code>.</p>

<p>And never try to assign one type to another unless it is large enough to hold the value by definition.</p>
",2
7199034,7198896,3,"<p>The motivation to use them is because <strong>you can't rely on <code>int</code>, <code>short</code> or <code>long</code> to have any particular size</strong> - a mistake made by too many programmers far too many times in the past. If you look not too far back in history, there was a transition from 16 bit to 32 bit processors, which broke lots of code because people had wrongly relied on <code>int</code> being 16 bits. The same mistake was made thereafter when people relied on <code>int</code> to be 32 bits, and still do so even to this day.</p>

<p>Not to mention the terms <code>int</code>, <code>short</code> and <code>long</code> have been truly nuked by language designers who all decide to make them mean something different. A Java programmer reading some C will naively expect <code>long</code> to mean 64 bits. These terms are truly meaningless - they don't specify anything about a type, and I facepalm every time I see a new language released that still uses the terms.</p>

<p>The standard int types were a necessity so you can use the type you want to use. They should've deprecated <code>int</code>, <code>short</code> and <code>long</code> decades ago.</p>
",4
6887315,6887301,1,"<p>Yes. Reading from argv[2], one integer to g.number and one char to c.</p>

<p>For example argv[2] could be ""123 a""</p>
",5
6887928,6887301,1,"<p>What it is specifying is zero or more white space characters followed by a number followed by zero or more white space characters, then a character.  It puts the values of the number in g.number and the character in c.  I'm not sure why it scans for a number then a character, but if the input does not start with a number, then nothing will be assigned to either variables and the return value of sscanf will be zero, which is how many variables it scanned in.  If it fails then the value in g.number will be whatever is in the memory slot it occupies which could be anything, hence undefined.</p>
",0
8294753,8294695,5,"<p>Because there are ""the usual arithmetic conversions"" at work for the <code>if</code>.</p>

<p>The <code>sizeof</code> operator returns an unsigned type ... and <code>d</code> is converted to unsigned making it greater than the number of elements in <code>arr</code>.</p>

<p>Try</p>

<pre><code>#define TOT (int)(sizeof(arr)/sizeof(arr[0]))
</code></pre>

<p>or</p>

<pre><code> if(d&lt;= (int)TOT){
</code></pre>
",1
8294756,8294695,2,"<p>That's because <code>sizeof</code> returns an unsigned number, while <code>d</code> is signed. When <code>d</code> implicitly converted to a singed number, and then it is much much larger than <code>TOT</code>.</p>

<p>You should get a warning about comparison of signed-unsigned comparison from the compiler.</p>
",0
8294768,8294695,1,"<p>Your expression for <code>TOT</code> is an <em><code>unsigned</code></em> value because the <code>sizeof()</code> operator always returns unsigned (positive) values.</p>

<p>When you compare the <em><code>signed</code></em> variable <code>d</code> with it, <code>d</code> gets automatically converted to a very large <em><code>unsigned</code></em> value, and hence becomes <em>larger</em> than <code>TOT</code>.</p>
",0
8294925,8294695,0,"<p>return type of sizeof is unsigned integer ....that is why if is failing ...because ""d"" which is treated as signed by the compiler is greater than TOT</p>
",0
7468687,7467136,0,"<p>By the statement <code>h=(int **)a;</code> you have only allocated the memory address(the first) of the array <code>a</code> to <code>h</code>. You have also defined h as a <strong>pointer to a pointer</strong> which can also point to a two-dimensional array as you have done. Also, to be seen, you have <strong>not made <code>h</code> a two-dimensional array</strong>(using <code>malloc</code> recursively). By <code>printf(""%d"",*h);</code>, you are trying to access the value at the address stored in <code>h</code>.</p>

<p>Arrays store values in memory in two ways, either <strong>column-wise or row-wise</strong>. In either ways the memory locations are sequential, in your case also. So, <code>h</code> stores the memory address of the first element of the array <code>a</code>. Therefore, when you use <code>*h</code> it retrieves the value at the address stored in <code>h</code>, i.e., the first value in array <code>a</code>. And when you increment <code>*h</code> by <code>(*h)++</code>, it increments because <code>*h</code> is still a pointer, and as you know incrementing a pointer doesn't mean incrementing by <code>1</code>, it <strong>actually increments by <code>4</code></strong>.</p>

<p>Hence, you are getting the above-mentioned output of yours.</p>

<p>Further discussions are welcomed from you <strong>Ankit</strong>.</p>

<p>-<strong>Sandip</strong></p>
",0
7467250,7467136,4,"<p>What's happening is that <code>*h</code> is of type <code>int*</code> which is a pointer. </p>

<p>When you increment it will actually increment by 4 rather than 1. Therefore the number you print out in the end is <code>1 + 4 = 5</code>.</p>

<p>Here's your code with more prints:</p>

<pre><code>  int **h; 
  int a[2][2]={1,2,3,4}; 
  h=(int **)a; 

  cout &lt;&lt; h[0] &lt;&lt; endl;
  cout &lt;&lt; h[1] &lt;&lt; endl;
  cout &lt;&lt; h[2] &lt;&lt; endl;
  cout &lt;&lt; h[3] &lt;&lt; endl;

  int i,j; 
  printf(""%d"",*h); 
  (*h)++; 
  printf(""\n%d"",*h); 

  cout &lt;&lt; endl;
  cout &lt;&lt; h[0] &lt;&lt; endl;
  cout &lt;&lt; h[1] &lt;&lt; endl;
  cout &lt;&lt; h[2] &lt;&lt; endl;
  cout &lt;&lt; h[3] &lt;&lt; endl;
</code></pre>

<p>The output is:</p>

<pre><code>00000001
00000002
00000003
00000004
1
5
00000005
00000002
00000003
00000004
</code></pre>

<p>So you can see the first value, being incremented by 4. Because 4 is the size of the pointer when compiled for 32-bit.</p>
",4
7471960,7467136,0,"<p>Since the expression <code>*h</code> is a <em>pointer</em> type, pointer arithmetic comes into play.  Remember that pointer arithmetic takes the size of the base type into account; for any pointer of type <code>T *p</code>, the expression <code>p++</code> will advance the pointer <code>p</code> by <code>sizeof T</code> bytes.  </p>

<p>Since <code>*h</code> is a pointer initialized to the value 1, the expression <code>(*h)++</code> is read as ""add <code>sizeof (int *)</code> bytes to 1"", which in your case is obviously 4.  Hence the output of 5. </p>
",0
7162525,7162454,3,"<p>The idea here is to take the upper n bits (for an n bit shift) and <code>or</code> them in to the right of the shifted number.</p>

<p>That should give you a start.</p>
",5
7162837,7162454,1,"<pre><code>#define NUM_BITS_IN_INT ((sizeof(int) * 8)

int rotleft(int num, int shift)
{
    return (num &lt;&lt; shift) | (num &gt;&gt; (NUM_BITS_IN_INT - shift));
}

int rotright(int num, int shift)
{
    return (num &gt;&gt; shift) | (num &lt;&lt; (NUM_BITS_IN_INT - shift);
}
</code></pre>
",3
7499556,7499480,0,"<p>I have no idea why you have <code>**node</code> there.</p>

<p>You simply need <code>node *start</code>;</p>
",1
7500278,7499480,3,"<p>You can't declare a variable <code>node * start</code> after other code statements. All declarations have to be at the start of the block.</p>

<p>So your code should read:</p>

<pre><code>node * start;

if (alen == 0) 
    return;

start = malloc(sizeof(*start));
</code></pre>
",5
8220412,8220401,5,"<blockquote>
  <p>Do I have to use the static too in the function?</p>
</blockquote>

<p>Yes. The <code>const</code> is just a qualifier on the return value, signaling to callers of <code>returnStr</code> that they shouldn't modify the result of the function. It doesn't change <code>time</code>'s temporary character.</p>
",0
8220430,8220401,4,"<p>When the returnStr function terminates, its stack frame is deallocated - so whatever any local pointers point to is now random data. If you want to return a pointer, you have to allocate it on the heap, with malloc for example.</p>
",0
8221270,8220401,3,"<p>The <code>time</code> object will exists only until <code>returnStr</code> is running.  Once it returns to the function that called it, it is gone, and any pointer to it is invalid.  In short, in C you cannot return an array from a function, you can only return a pointer to one.  This is why standard library C functions do not allocate strings at all, you must pass in a string and specify how large it is and it will fill it or error out.</p>
",0
7779539,7779518,0,"<p>The user needs to print ""\n"" before scanf will return.</p>

<p>It's called ""<a href=""http://www.cplusplus.com/reference/clibrary/cstdio/"" rel=""nofollow"">buffered I/O</a>"".</p>

<p>The final ""getchar()"" just keeps the program from exiting before you've had a chance to see the results.  This would be important, for example, if your program is running from a Windows command prompt, and the command prompt disappears as soon as the program exits.</p>
",0
7779555,7779518,0,"<p><code>scanf</code> doesn't input the hole line. It only inputs until a space character is found (i.e. <code>'\n'</code> or <code>' '</code>). The input process begins after ENTER key is pressed. It continues input unitl it finds a white character. Take this example:</p>

<p>input:</p>

<pre><code>h s a e f o w 2 4 ; f e e
*Then ENTER-KEY was pressed)
</code></pre>

<p>Output:</p>

<pre><code>h s a e f o w 2 4 ; f e e
</code></pre>

<p>If we are inputing strings, it wont' get the hole line, but a word by word:</p>

<p><strong>input:</strong> (using <code>scanf(""%s"", &amp;str)</code>):</p>

<pre><code>Hello World C language!
(Then ENTER-KEY was pressed)
</code></pre>

<p><strong>Output:</strong> (using <code>printf(""%s\n"", str)</code>):</p>

<pre><code>Hello
World
C
Language!
</code></pre>
",1
7779602,7779518,2,"<p>It is not a good idea to check the value of <code>ch</code> (in <code>while</code> loop) before assigning it a value.</p>

<ul>
<li><p>First before entering loop, it checks whether <code>ch</code> equals <code>""\n""</code> which it does not (hopefully).</p>

<pre><code>while(ch!='/n')
</code></pre></li>
<li><p>It enters the loop. <code>scanf()</code> executes, waits for input. Suppose, you enter <code>""a""</code> and then press <kbd>ENTER</kbd>.</p>

<pre><code>scanf(""%c"",&amp;ch);
</code></pre></li>
<li><p>As a whitespace character is encountered, it continues to next line, which prints the character entered earlier.</p></li>
<li>Then you check again: this time <code>ch==a</code>, so it enters the loop again.</li>
<li><p>Now, <code>scanf()</code> is executed again, the input buffer already has <code>""\n""</code>, it is read.</p>

<pre><code>scanf(""%c"",&amp;ch); //This time INPUT BUFFER already has ""\n""
                 //so it wont ask for user input.
</code></pre></li>
<li><p><code>""\n""</code> read earlier, gets printed.</p></li>
<li>Now, <code>ch == ""\n""</code>, so the loop exits.</li>
</ul>

<p>The catch was that even though your read <code>""a""</code> from the input, the input buffer already had <code>""\n""</code> the second time the loop was executed. To avoid situations like that you should use </p>

<pre><code>scanf(""%c\n"", &amp;ch)
</code></pre>
",0
8373424,8370936,10,"<p>OK, so there's a lot wrong here, and plenty to explain. Let's start with the really obvious stuff that prevents this even running, and move on afterwards.
I'm going to use C89, so I'll do declare all my local variables at the start of each method. I'll be using <code>gcc 4.6.1</code>, and compiling with <code>-W -Wall -ansi -pedantic -g -lm</code>.
We will need the <code>-lm</code> shortly - it links to the math library.</p>

<h2>IsPrime()</h2>

<p>So, your <code>IsPrime(int n)</code> appears to be missing some pieces at the bottom. As such, I can't even say whether it will work or not.</p>

<p>Let's forward declare it by putting <code>int IsPrime(int n);</code> at the top of the file just below <code>#include stdio.h</code>. While we're at it, let's add some more includes, too:</p>

<pre><code>#include &lt;stdlib&gt;
#include &lt;math.h&gt; /* For sqrt() */
</code></pre>

<p>Now, let's replace the body of the method with something that should work (well, you don't have to, but I will because I can't see the rest of your method):</p>

<pre><code>int IsPrime (int n) {
  int i, sqrtN;

  if (n &lt; 2) { return 0; } /* 1, 0, and negatives are nonprime */
  if (n == 2) { return 2; }
  if ((n % 2) == 0) { return 0; } /* Check for even numbers */
  sqrtN = sqrt(n) + 1; /* We don't need to search all the way up to n */
  for (i = 3; i &lt; sqrtN; i += 2) {
    if (n % i == 0) { return 0; } /* Stop, because we found a factor! */
  }
  return n;
}
</code></pre>

<h2>main() and scanf()</h2>

<p>You aren't using arguments to <code>main()</code> so let's change it to <code>int main(void) {</code>.
When you call <code>scanf()</code>, you should check the result - it will return the number of things matched successfully, or <code>EOF</code>. You should also check the values it stored, since you require N to have a specific range and I to be positive.</p>

<p>So, let's try using this at the start of <code>main()</code>:</p>

<pre><code>int N, I;
int s;
int i, j, k;
int **arr; /* More on this later*/

printf(""Enter an odd integer n between 3 and 15: "");
s = scanf(""%d"", &amp;N);
if (s != 1) {
  printf(""No proper input provided; program will now exit"");
  return 0; /* Or we could use EXIT_SUCCESS, which is defined by stdlib */
} else if (N &lt; 3 || N &gt; 15) {
  /* I have assumed the range of 3 to 15 to be inclusive here */
  printf(""I must be positive; program will now exit"");
  return 0;
}

printf(""Enter an initial value I: "");
s = scanf(""%d"", &amp;I);
if (s != 1) {
  printf(""No proper input provided; program will now exit"");
  return 0;
} else if (I &lt;= 0) {
  printf(""I must be positive; program will now exit"");
  return 0;
}
</code></pre>

<h2>malloc()</h2>

<p>From the comments on your question, you appear to understand that <code>malloc</code> allocates memory but not necessarily the correct syntax to get it to do so in this instance.
That's where the <code>int **arr;</code> comes in. To allocate your two dimensional array of integers, now that we have a legal value for N, we can do <code>arr = malloc(N * sizeof arr[0]);</code>
Now, malloc can fail, so we need to check that <code>arr != NULL</code> after that call. And we aren't done yet! That's only one dimension of your array - we've just allocated enough memory for N pointers to one dimensional arrays, pointed to by <code>arr</code>.
So we have to loop through and allocate space for those pointers to point to.</p>

<p>So then we do this:</p>

<pre><code>for (s = 0; s &lt; N; ++s) {
  arr[s] = malloc(N * sizeof arr[0][0]); /* Enough space for N integers */
  if (NULL == arr[s]) {
    /* We'll just quit instead of handling this gracefully... */
    /* ...because this is only an example */
    printf(""Uh oh! Memory allocation failed! Let's run away!\n"");
    return 0;
  }
}
</code></pre>

<h2>free()</h2>

<p>Now, because you have allocated memory, you will also need to free it when you are done with it. At the end of your main method, you will need a loop to free each of the one dimensional arrays you allocated space for, and then you will need to free <code>arr</code> itself.
Like so:</p>

<pre><code>for (s = 0; s &lt; N; ++s) {
  free(arr[s]);      
  /* I am paranoid about setting pointers to NULL */
  arr[s] = NULL;
}

free(arr);
arr = NULL;
/* It can matter if you are going on to do other things instead of exiting. */

return 0;
</code></pre>

<h2>Logic</h2>

<p>So, now for the loop that's actually meant to do the moving around the array.
You are returning <code>i</code> from main instead of printing out. I'm pretty sure you intended to print it out instead, right? If you need to print out the whole grid, as a grid, you need to do it in a separate pass after testing all the values with <code>IsPrime()</code>. If you just need to print out whether or not the number is prime (well, the number or <em>*</em>) in a spiralling order starting from the centre, then you don't actually need <code>arr</code> at all.</p>

<p>Now, your loop to calculate the numbers is also incorrect (for starters, it runs out of the bounds of the array), but I'm reluctant to solve that for you, because that piece of logic is the point of your homework assignment, so try sorting out everything I've mentioned here first, and then comment if you're still stuck with the logic after that, I guess.</p>

<p>Just by the way, I've avoided changing your variable names, but you might want to consider not mixing <code>I</code> and <code>i</code> and in general naming things more descriptively.</p>

<h2>Spiral logic</h2>

<p>Disclaimer: There may be better approaches, this is just what came to mind. It does work, though.</p>

<p>The way I think about this is that there is an edge between the middle square and the one to the right of it, and another edge between that square and the one above it, and so on. This forms a spiral pattern. If you draw it, you'll also notice that after every second corner, the number of edges before the next corner increases by one (1,1,2,2,3,3). If we keep track of how long the current side is, when it needs to change, what direction we're going, and when to stop (we know there are N*N total squares, so just count the squares you've filled in so far), then this is relatively straightforward:</p>

<pre><code>totalSquares = N * N;
currentSquare = 0;
currentSideLength = 1; /* Number of edges/transitions per side before we turn */
currentPositionOnSide = 0; /* How far down a side we are*/
increaseSideLength = 0; /* This keeps track of when to increase currentSideLength */
i = j = N / 2; /* The middle */
direction = 0; /* Which way we're going - using an enum here would be better for clarity */

while (currentSquare &lt; totalSquares) {

arr[i][j] = IsPrime(I);
switch (direction) {
  case 0: /* Right */
    ++j;
    break;
  case 1: /* Up */
    --i;
    break;
  case 2: /* Left */
    --j;
    break;
  case 3: /* Down */
    ++i;
    break;
  default: /* So we can see if something silly goes wrong with the direction! */
    printf(""WTH?\n"");
    break;
  }

  ++currentSquare, ++I, ++currentPositionOnSide;

  if (currentPositionOnSide == currentSideLength) { /* We're at a corner! */
    ++increaseSideLength; /* Keep track of the number of turns */
    currentPositionOnSide = 0;
    direction = (direction + 1) % 4; /* Wrap around */
    if ((increaseSideLength % 2) == 0) { /* Increase every second corner */
      ++currentSideLength;
      increaseSideLength = 0;
    }
  }
}

/* Ultra crude formatting - you may want to do better than this */
for (i = 0; i &lt; N; ++i) {
    for (j = 0; j &lt; N; ++j) {
      if (arr[i][j] == 0) {
        printf("" *** |"");
      } else {
        printf(""%4d |"", arr[i][j]);
      }
    }
  printf(""\n"");
}
</code></pre>

<p>Now, I've checked that this works, but I haven't tested the #@! out of it - that's your responsibility. Also, you'll obviously need to add those variables or reuse some of the ones you already have (I'd really recommend using well named ones, though.)</p>

<p>Also, that code abuses <code>IsPrime()</code> by getting it to return n or 0 (0 is not a prime and you said I must be positive, so there's no need to use -1), thus avoiding all your <code>if IsPrime(I) ? I : -1;</code> checks.</p>
",9
7195677,7195621,-5,"<p>For file output, you should do strcat of <code>""\r\n""</code></p>
",11
7195733,7195621,6,"<p>This code works for me:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main ()
{
    char myTxt[100];

    myTxt[0] = 0;
    strcat(myTxt, ""data"");
    strcat(myTxt, ""\n"");
    strcat(myTxt, ""data1"");

    printf(""%s\n"", myTxt);
    return 0;
}
</code></pre>

<p>Did you initialize the buffer's first byte?
Edit: works also with a file as output:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main ()
{
    char myTxt[100];
    FILE *out = fopen(""out.txt"", ""wt"");

    myTxt[0] = 0;
    strcat(myTxt, ""data"");
    strcat(myTxt, ""\n"");
    strcat(myTxt, ""data1"");

    fprintf(out, ""%s\n"", myTxt);
    fclose(out);
    return 0;
}
</code></pre>
",2
8297545,8297525,5,"<p>Change:</p>

<pre><code>while (choice == 1 || 2 || 3 || 4){  
</code></pre>

<p>to:</p>

<pre><code>while (choice == 1 || choice == 2 || choice == 3 || choice == 4){  
</code></pre>

<p>or perhaps more succinctly:</p>

<pre><code>while (choice &gt;= 1 &amp;&amp; choice &lt;= 4){  
</code></pre>
",0
8297549,8297525,4,"<p>The expression <code>choice == 1 || 2 || 3 || 4</code> will always evaluate to true</p>

<p>choice == 1 evaluates to 1 if choice is 1 (true) otherwise to 0 (false)
2,3 and 4 evaluate to true if you do a logical or (||)
it will result in</p>

<pre><code>false || true || true || true -&gt; true
</code></pre>

<p>what you mean is probably</p>

<pre><code>choice &gt;= 1 &amp;&amp; choice &lt;= 4
</code></pre>
",0
8297564,8297525,1,"<p>You have syntax mistakes</p>

<pre><code>choice == 1 || 2 || 3 || 4
</code></pre>

<p>should be</p>

<pre><code>choice == 1 || choice ==  2 || choice ==  3 || choice == 4
</code></pre>
",0
8297582,8297525,1,"<pre><code>while (choice == 1 || 2 || 3 || 4)
</code></pre>

<p>Is the same as saying</p>

<pre><code>while (choice == 1 || TRUE == 2 || TRUE == 3 || TRUE == 4)
</code></pre>
",0
7780633,7780622,1,"<p>Your <code>scanf()</code> calls should pass a pointer to a place in memory where the input data will be stored. </p>

<p>For example:</p>

<pre><code>scanf(""%i"", &amp;d); // &amp;d is the location in memory of d
</code></pre>
",1
8385517,8385287,1,"<p>Yes,
In line1 bfrCnt is first incremented and then compared.
In line2 it is first compared and then incremented.
Your question is not having the quality when it is compared to the other questions in this site. That is why you are getting down votes.
So when ever you are posting a question, make sure it is having enough standard.</p>
",1
8385353,8385287,2,"<p>Correct.
In both case you increase bufCnt.
But without else if you increase bufCnt two times.</p>
",2
7814232,7814214,4,"<p>What is the type of <code>buffer</code>? </p>

<p>I guess that it is either <code>signed char</code> or implicitly-signed <code>char</code>. The range of a signed char in most implementations is (-128,+127). <code>0xDB</code> is outside that range, so that equality test might never be true.</p>

<p>Try changing the type of buffer to <code>unsigned char</code>, or replacing your test with:</p>

<pre><code> if((unsigned char)buffer[randomNumber] == 0xDB) 
</code></pre>

<p>or </p>

<pre><code> if(buffer[randomNumber] == (char)0xDB) 
</code></pre>
",0
7814296,7814214,0,"<p>If this were my code, I'd probably re-write it like this:</p>

<pre><code>count++;
if(buffer[randomNumber] != 0xDB) {
    buffer[randomNumber] = 0xDB;
    arrayChangeFlag++;
}
</code></pre>

<p>This makes it easier to see that <code>count</code> is incremented no matter what, and makes it more clear that <code>buffer[randomNumber]</code> will be set to <code>0xDB</code> on exit from this block.</p>

<p>It won't fix your underlying bug though; if you're using a plain <code>char</code>, perhaps your environment uses a <code>signed char</code> (as allowed by the standard), and the <em>integer</em> <code>0xDB</code> is going to be positive while the <code>signed char</code> value represented by the <em>byte</em> <code>0xDB</code> is going to be negative. Try changing to <code>unsigned char buffer[]</code>.</p>
",0
6938130,6938056,0,"<p>Is this embedded?  2k isn't that much memory by desktop standards.  You could always use a hash-table, but you probably wont get the performance you are getting now.  You can also just dynamically allocate the block if it makes you feel better.  </p>

<p>My C might be a little garbled, but if I remember it should look like this:</p>

<pre><code>unsigned char *ptr = (unsigned char *) malloc(2048 * sizeof (unsigned char));
//insert null pointer check here
</code></pre>

<p>Just remember to call <code>free</code> when you are done...</p>

<p>Seriously, 2k of static allocation is probably fine. </p>
",1
6938144,6938056,1,"<p>another way could be using a Set [Hash/Tree], which size will be dynamically chosen. every element is in the set if and only if this resource is allocated.</p>
<p>the problems with these solution are:
<br>1. it will be slower.
<br>2. when number of elements is high, it will take more memory then the static array.</p>
<p>for 2k, I'd stick with the static bitmap array.</p>
<p><strong>one more possibility:</strong></p>
<p>using the same trick Virtual Memory uses <a href=""http://en.wikipedia.org/wiki/Virtual_memory#Paged_virtual_memory"" rel=""nofollow noreferrer"">(pages)</a>.
<br>partition your 'array' into N parts, and create an extra table of size N.
<br>every element in the table will be mapped a part of the array it is relevant to.
<br>now, when you allocate resource k, you will have to allocate the part of the array which k is in, [and set all the other values to 0].
<br><br>it will still be slower then the chunk, and when all entrees are allocated, it will requires extra N*4 bytes.
<br><br>I'd use this solution only if the data is much larger then 2k.</p>
<p>more info: <a href=""http://tldp.org/LDP/tlk/mm/memory.html"" rel=""nofollow noreferrer"">http://tldp.org/LDP/tlk/mm/memory.html</a></p>
",0
7779445,7779415,0,"<p>(&amp;root)->left
&amp;root is NOT a BNODE*</p>
",0
7779474,7779415,0,"<pre><code>void insert(BNODE **root, int val){
BNODE *newnode;

newnode= malloc(sizeof *newnode);        
newnode-&gt;right=NULL;
newnode-&gt;left=NULL;
newnode-&gt;key=val;

while (*root){
   if (val &lt; (*root)-&gt;key) root = &amp;(*root)-&gt;left;
   else root = &amp;(*root)-&gt;right;     
   }
*root=newnode;

return;


}
</code></pre>
",0
8444579,8444429,0,"<p>Since you don't show all the code, I have to guess... And my guess is that it's because you only have one <code>ta1</code> in the <code>main</code> function. It is a pointer to some structure, and you send the pointer to the thread. But since there is only one pointer, that you send to both threads, then the variable <code>ta</code> in both threads point to the same structure. So when the second connection is made, the information for the first thread is overwritten with the information for the second.</p>

<p>To solve this, you need to make an array, like the <code>connected</code> array.</p>
",0
7488628,7488598,4,"<p>You don't seem to be specifying the actual type of the argument at <code>%</code>, if <code>mese</code> its a string it should be <code>%s</code>.</p>
",7
7495369,7488598,0,"<p><code>sprintf(query, ""SELECT IFNULL(SUM(%s),0) AS \'Totale acquisti mese\' from Acquisti WHERE mid(%s,6,2)=%s"",Netto_Acquisto,mese,Data_Acquisto);</code> you forgot to mention the escape sequences and format specifiers.</p>
",0
7495047,7488598,1,"<p>Here you missed the format specifier as you have written it like this <code>%</code> in the code.
Just look after it you'll get the answer.</p>
",0
7486247,7485891,1,"<p>The same:</p>

<pre><code>int a[10]; // array(10) of ints
int* pa = a; // pa points to first int
pa++; // pa points to second int

int b[10][20]; // array(10) of arrays(20) of ints
int (*pb)[20] = b; // pb points to first array(20) of ints
pb++; // pb points to second array(20) of ints
</code></pre>

<p>If you want to traverse 2-dimensionally, use manual indexing:</p>

<pre><code>int tab[W][H];
int* p = &amp;tab[x+y*W]; // element (x,y)
p += 1; // one element forward (x+1)
p += W; // one column forward (y+1)
</code></pre>
",0
7165508,7165486,2,"<p>Probably because the compiler optimizes the isdigit function call from the code.  That is it doesn't run it. </p>

<p>Also note that isdigit expects a character, not a number.  <a href=""http://www.cplusplus.com/reference/clibrary/cctype/isdigit/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cctype/isdigit/</a></p>
",1
7165522,7165486,1,"<p>This was probably optimized by the compiler. As neither the if or the else does something, it was removed and the <code>isdigit</code> ends up not called. Be sure to</p>

<pre><code>#include &lt;ctype.h&gt;
</code></pre>

<hr>

<p>The segmentation fault is coming probably from the fact that you're passing a (not so small) number, when a character was expected. When you remove the printf statements and the compiler optimizes it, the call won't happen thus not failing.</p>

<p>Note that the headers can be in fact omitted since the program will be linked with the standard C library by default, so it works. But it's not a good idea, and you should see a warning at least.</p>
",2
7165542,7165486,1,"<p>First of all, <a href=""http://linux.die.net/man/3/isdigit"" rel=""nofollow""><code>isdigit(3)</code></a> checks whether a <strong>character</strong> is a digit.</p>

<p>The segmentation fault probably (I'm positive) happens because you haven't included <code>stdio.h</code>.</p>

<p>Then you're calling <code>printf</code> which uses variable arguments without knowing its prototype (undefined behavior).</p>
",2
7166331,7165486,2,"<p>This is because isdigit can be defined as macro like this </p>

<pre><code>#define isdigit(c) ((map[c] &amp; FLAG_DIGIT)==FLAG_DIGIT)
</code></pre>

<p>You call isdigit with integer value, but map array size is 256 elements. In this case you try to read value outside of array bounds -> segmentation fault. This segmentation fault can occurs randomly. Depending on your program or data size.</p>
",0
8458438,8458419,9,"<p>The problem is that <code>~</code> only works in the shell. Replace with the full absolute path (e.g. <code>/home/user1031204/.local/...</code>) &amp; re-try.</p>
",2
8458450,8458419,4,"<p><code>~</code> is an handy shortcut available only in shell. You can achieve a similar behaviour by using <a href=""http://pubs.opengroup.org/onlinepubs/009604499/functions/getenv.html"" rel=""nofollow""><code>getenv(""HOME"")</code></a> and concatenate it with the target directory.</p>

<pre><code>snprintf(buffer, size_of_buffer, ""%s/.local/share/Trash/files/it_works.c"",
         getenv(""HOME""));
</code></pre>

<p>Remember to <code>#include &lt;stdlib.h&gt;</code> and have a buffer which is at least <code>PATH_MAX</code> bytes long (<code>limits.h</code>) to store the result.</p>
",1
8458560,8458419,4,"<p><a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/realpath.3.html"">realpath()</a> will be helpful here.  You may want to look at <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/glob.3.html"">glob()</a> and <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/wordexp.3.html"">wordexp()</a> as well.  </p>
",1
7459871,7459860,1,"<p>Read a char instead of an int (or better yet, a key press). Then if the so read char is between <code>'0'</code> and <code>'9'</code> turn it into an integer and use it as option; otherwise make your loop terminate, return from main, call exit or whatever way you prefer to end execution.</p>
",3
7803394,7803359,1,"<p>With <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/sscanf/"" rel=""nofollow"">sscanf</a>:</p>

<pre><code>int value;
sscanf (ptr1,""p%dh12"",&amp;value);
</code></pre>

<p><strong>Update</strong></p>

<pre><code>int i,j;
int values[MAX_VALUES];
int startIdx = -1;
char *ptr1 = ""p123hxxxxp124hxxxxp123145hxxxx"";
char buffer[16];
for(i=0,j=0; i&lt;strlen(ptr1);i++)
{
    if(startIdx&gt;=0 &amp;&amp; ptr[i] == 'h')
    {
        strncpy(buffer,ptr1+startIdx,i-startIdx+1);
        buffer[i-startIdx+1]='\0';
        sscanf (buffer,""p%dh"",&amp;(values[j++]));
        startIdx = -1;
    }
    else if(ptr[i] == 'p')
    {
        startIdx = i;
    }
}    
</code></pre>
",1
7803494,7803359,0,"<p>Here's a good possible starting point:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main (void) {
    char *p, *str = ""p123h12p97h62p32h"";
    int accum = 0;

    // Process every character.

    for (p = str; *p != '\0'; p++) {
        // 'p' resets the accumulator.
        // 'h' outputs the accumulator.
        // Any digit adjusts the accumulator.

        if (*p == 'p')       accum = 0;
        if (*p == 'h')       printf (""Processing %d\n"", accum);
        if (isdigit (*p))    accum = accum * 10 + *p - '0';
    }

    return 0;
}
</code></pre>

<p>This will work fine if your input string follows your specified format, outputting:</p>

<pre><code>Processing 123
Processing 97
Processing 32
</code></pre>

<p>If there's the possibility that your input string is not so well formed, you'll need to add some defensive coding.</p>
",0
7779423,7779411,8,"<p>This information such as the size of the allocation is kept within the memory allocator itself.</p>

<p>Internally, there's some data-structure that keeps a list of all the active memory allocations, their sizes, and their addresses. Exactly how it works is fairly complicated as there are lot of different memory allocation algorithms suited for different purposes and allocation sizes.</p>

<p>Often times, the size is stored as a fixed offset just below the address returned by <code>malloc()</code>, but that's just an implementation detail.</p>
",0
7779437,7779411,3,"<p>A fairly common way is for the allocation to increase the allocation by sizeof(size_t) and store the length at the start, before returning a pointer to the rest of the memory allocated. Freeing the memory then just involves looking at the length that was stashed away.</p>
",0
7462866,7462836,5,"<ol>
<li><strong>Don't do that ever</strong></li>
<li><strong>Throw away the tutorial if it teaches/preaches that.</strong></li>
</ol>

<p>As you pointed out it will read more bytes than that were actually allocated, so it reads off some garbage value from the memory not allocate by your variable.</p>

<p>In fact it is dangerous and it breaks the <strong><a href=""https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule"">Strict Aliasing Rule</a></strong><sup>[Detail below]</sup> and causes an <strong>Undefined Behavior</strong>.<br>
The compiler should give you a warning like this.  </p>

<pre><code>warning: dereferencing type-punned pointer will break strict-aliasing rules
</code></pre>

<p>And you should always listen to your compiler when it cries out that warning.</p>

<hr>

<p><sup>[Detail]</sup>  </p>

<p><strong>Strict aliasing</strong> is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias each other.)</p>

<p>The exception to the rule is a char*, which is allowed to point to any type.</p>
",0
7462870,7462836,1,"<p>This is dangerous and undefined behaviour, just as you said.</p>

<p>The reason why it doesn't crash on 32 (or 64) bit platforms is that most compilers allocate atleast 32 bits for each stack variable. This makes the access faster, but on e.g. 8 bit processor you would get garbage data in the upper bits instead.</p>
",0
7462874,7462836,1,"<p>No it's not going to crash your program, however it is going to be reading a portion of other variables (or possibly garbage) on the stack. I don't know what tutorial you got this from, but that kind of code is scary.</p>
",0
7462887,7462836,3,"<p>First of all, <strong>never do this</strong>.</p>

<p>As to why it doesn't crash: since <code>s</code> is a local, it's allocated on the stack. If <code>short</code> and <code>int</code> have different sizes in your architecture (which is not a given), then you will <em>probably</em> end up reading a few more bytes from memory that's on the same memory page as the stack; so and there will be no access violation (even though you will read garbage).</p>

<p><strong>Probably.</strong></p>
",0
7462901,7462836,1,"<p>First of all, all addresses are of the same size and if you're in a 64bit architecture, each char *, short * or int * will have 8 bytes.
When using a star before an ampersand it will cancel the effect, so *&amp;x is semantically equivalent to just x.</p>
",4
7463004,7462836,1,"<p>Basically you are right in the sense that since you are accessing an int * pointer, this will fetch 4 bytes instead of the only 2 reserved for 's' storage and the resulting content won't be a perfect reflection of what 's' really means.</p>

<p>However this most likely won't crash since 's' is located on the stack so depending on how your stack is laid out at this point, you will most likely read data pushed during the 'main' function prologue... </p>

<p>See for a program to crash due to invalid read memory access, you need to access a memory region that is not mapped which will trigger a 'segmentation fault' at the userworld level while a 'page fault' at the kernel level. By 'mapped' I mean you have a known mapping between a virtual memory region and a physical memory region (such mapping is handled by the operating system). That is why if you access a NULL pointer you will get such exception because there is no valid mapping at the userworld level. A valid mapping will usually be given to you by calling something like malloc() (note that malloc() is not a syscall but a smart wrapper around that manages your virtual memory blocks). Your stack is no exception since it is just memory like anything else but some pre-mapped area is already done for you so that when you create a local variable in a block you don't have to worry about its memory location since that's handled for you and in this case you are not accessing far enough to reach something non-mapped.</p>

<p>Now let's say you do something like that:</p>

<pre><code>short s = 10;
int *i = (int *)&amp;s;
*i = -1;
</code></pre>

<p>Then in this case your program is more likely to crash since in this case you start overwriting data. Depending on the data you are touching the effect of this might range from harmless program misbehavior to a program crash if for instance you overwrite the return address pushed in the stack... Data corruption is to me one of the hardest (if not the hardest) bugs category to deal with since its effect can affect your system randomly with non-deterministic pattern and might happen long after the original offending instructions were actually executed.</p>

<p>If you want to understand more about internal memory management, you probably want to look into <a href=""http://en.wikipedia.org/wiki/Virtual_memory"" rel=""nofollow"">Virtual Memory Management</a> in Operating System designs.</p>

<p>Hope it helps,</p>
",0
7680617,7680489,7,"<p>my gcc (version 4.6.1) optimizes it out</p>

<pre><code>$ cat 7680489.c
</code></pre>

<pre>
#include &lt;stdlib.h&gt;

#define SIZE 100

int main(void) {
  double *a;
  size_t i;

  a = calloc(SIZE, sizeof *a); /* initialize elements */
  for (i = 0; i &lt; SIZE; i++) a[i] = a[i];
  free(a);

  return 0;
}
</pre>

<pre><code>$ gcc -std=c89 -O3 -S 7680489.c
$ cat 7680489.s
</code></pre>

<pre>
        .file   ""7680489.c""
        .section        .text.startup,""ax"",@progbits
        .p2align 4,,15
        .globl  main
        .type   main, @function
main:
.LFB3:
        .cfi_startproc
        subq    $8, %rsp
        .cfi_def_cfa_offset 16
        movl    $8, %esi
        movl    $100, %edi
        call    calloc
        movq    %rax, %rdi
        call    free
        xorl    %eax, %eax
        addq    $8, %rsp
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE3:
        .size   main, .-main
        .ident  ""GCC: (Debian 4.6.1-4) 4.6.1""
        .section        .note.GNU-stack,"""",@progbits

</pre>

<p>No loop that I can see. The assembly output is very similar when using <code>malloc</code> rather than <code>calloc</code>. I switched to <code>calloc</code> to avoid having objects with indeterminate values about (thanks R..).</p>
",0
7680660,7680489,0,"<p>The problem here is that you are using pointers.  </p>

<p>It is hard for a compiler to optimise pointers since it can assume that pointer can read/write to any location in memory.  </p>

<p>Change to <code>[]</code> array operator instead and try again. You should see the optimization you expect</p>
",0
7680691,7680489,0,"<p>As a general big of info, two of the biggest things that compiler have trouble optimizing are loops and pointers, and your example deals with both. Compilers know that values change frequently in loops, and so they are very conservative when optimizing those. Also, A is a pointer, and compilers are aware that pointers can change due to diverse factors, and so they back off when changing those. That's why the compiler has trouble with your example.</p>
",2
7680757,7680489,0,"<p>This code has undefined behavior (using objects with indeterminate value) so why would you have any expectation for what it does?</p>
",3
7680804,7680489,2,"<p>To optimize away the loop the compiler had to recognize several things:</p>

<ul>
<li>The load/store does not cause a modification of the data (due, eg, to floating point NaN conversions)</li>
<li>The two array addresses are identical</li>
<li>The two array indexing expressions are identical</li>
<li>After taking into account the addresses and indexing, the load &amp; store are not overlapping but coincide exactly.</li>
<li>The store will not ""step"" on the results of other stores, or on a value that has not yet been loaded.</li>
<li>The load/store cannot result in a storage fault. This in turn requires that the compiler recognize that the storage came from malloc, and that the loop does not index beyond the end of the allocation.</li>
<li>The loop will terminate in a finite number of iterations</li>
<li>And probably several others I'm not thinking of</li>
</ul>

<p>Keep in mind that optimizations are oriented towards removing ""normal"" redundancies, not eliminating ""classroom examples"".</p>
",4
7680507,7680489,7,"<p>From a hardware perspective, loading and saving a double is not a no-op; its bitwise value can change if it is one of several trap representations of an IEEE double.</p>

<p>For example, if you load a NaN into a register, it will be written out as the canonical NaN value, which may not be the same bitwise value.</p>
",4
7680540,7680489,1,"<p>The compiler does not do any actual thinking.<br>
It can only optimize out stuff that matches a preconceived pattern.  </p>

<p>I.e. if the code does not match a known no-op pattern that has been pre-programmed into the compiler it does not get eliminated. </p>

<p>By putting in the <code>A[i] = A[i]</code> you changed the pattern  just enough to not match the <code>empty loop pattern</code></p>
",2
7813000,7812501,1,"<p><code>unescape</code> doesn't check the size of <code>dst</code>. You can easily overflow it and overwrite <code>vtable</code>. Change it to <code>person_debug_print</code> and you are done.</p>

<p>You can get the addres of <code>person_debug_vtable</code> with:</p>

<pre><code>$ nm a.out | grep  person_debug_vtable
0000000000400e90 r person_debug_vtable
</code></pre>

<p>And the exploit works like this:</p>

<pre><code>$ echo '________________________________%90%0e%40%00%00%00%00%00' | ./a.out root
current user information: root (The Mighty Administrator)
new full name? new account info will be: person object at 0x930010: login:root, password:@PROGRAM5_PASSWORD@, fullname:________________________________?@
failed to update account info (not implemented in this demo)
</code></pre>
",0
7812774,7812501,2,"<p>strings is a first program to look at. Its an easy way to see what string literals are stored in a program.</p>

<p>The basic usage is: strings executable_name</p>
",0
8407797,8407481,1,"<p>There is no need to implement this on the basis of <code>getc</code> and <code>strchr</code>.</p>

<p>if your data is organized in lines, then you should use <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow noreferrer""><code>fgets</code></a> to read the file line-wise.
if your data is separated by <code>';'</code>, then you should use <a href=""http://linux.die.net/man/3/sscanf"" rel=""nofollow noreferrer""><code>sscanf</code></a> to split the line buffer into substrings.</p>

<p>See <a href=""https://stackoverflow.com/a/3356418/1025391"">this post</a> for an example program that solves a similar problem.</p>
",0
8407503,8407481,3,"<p>Your variable <code>c</code> is a <em>single</em> character, not a char array.</p>
",2
8407541,8407481,0,"<p><code>strchr</code> is used to search for a specific character within a NULL terminated string. To compare two characters simply use <code>==</code></p>

<pre><code>if( c == ';' ) {
  // do something
}
</code></pre>
",1
8407557,8407481,0,"<p>this is crazy code!  No idea what the for loop is.... maybe you want something like...</p>

<pre><code>while(fgets(c2, 100, fp) != NULL)
{
    char* first = c2;
    char *second = c2;
            // look for a ;  or the end of the string...
    while(*second != ';' &amp;&amp; *second != 0) second++;
    if(*second == 0) continue;  // if there was no ; just carry on to the next line
    *second = 0; second++; // put a terminator where the ; was

            // first will now point to the first string :- 123456
            // second will now point to the second part :-  Lucas
    printf(""%s  %s\r\n"", first, second);        
            // you may want to trim the second part of \r\n chars.
}
</code></pre>
",2
8413854,8407481,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
    FILE *fp;
    char c;
    char c2[100];
    int i = 0;

    fp = fopen(""MyFile.csv"", ""r"");

    if (!fp) {
        printf(""Error!\n"");
        exit(-1);
    }

    while(NULL!=fgets(c2,100,fp)){//fgets read one line or 100 - 1 char 
        char *ptr = strchr(c2, ';');
        if(ptr) {
            int index = ptr - c2;
            printf(""index of %c is %d\n"", *ptr, index);
            *ptr = '\0';
            //12345;Lucas -&gt; first is ""12345"", second is ""Lucas""
            printf(""split string first is \""%s\"", second is \""%s\""\n"", c2, ptr + 1);
        }
    }
    fclose(fp);

    return 0;
}
</code></pre>
",0
7811519,7811449,2,"<p>The behaviour is at best 'implementation defined', and possibly 'undefined behaviour'.</p>
",3
7811575,7811449,0,"<p>Negative integers don't have a ""sign bit"". <code>-2</code> is stored as <code>0xFFFFFFFE</code>.</p>

<p>Also, <code>&lt;&lt;</code> doesn't do what you think. In C, it is an arithmetical (rather than a logical) shift. So <code>x &lt;&lt; y</code> is basically <code>x * 2 ^ y</code> for positive <code>x</code>, where <code>^</code> denotes exponentiation.</p>

<p>Lastly, you should <strong>never</strong> use shift operations for signed integers. It might generate unexpected results in a certain number of cases (negative <code>x</code> is one of them) and it's not worth to rule all of them out.</p>

<p>If you want to multiply <code>-2</code> by <code>4</code>, just do it...</p>
",2
8448356,8448332,8,"<p>The statement: </p>

<pre><code>char *p = ""GOOd"";
</code></pre>

<p>Defines a string literal ""GOOD"", pointed by an pointer <code>p</code>.</p>

<p>You are trying to modify this string literal through the <code>strrev</code> function which results in <strong>Undefined Behavior(UB)</strong> and the crash.</p>

<p>The problem with string literals is they are stored in a read-only(Implementation defined) memory location and user programs are not allowed to change that.If a program attempts to do so it causes an UB.     </p>

<p>So instead of using a string literal You should use an array.</p>

<p>You should be using:    </p>

<pre><code>char p[] = ""GOOd"";
</code></pre>
",4
8448366,8448332,5,"<p>One problem is that in the following:</p>

<pre><code>char *p = ""GOOd"";
</code></pre>

<p>the compiler is allowed to place the string literal in read-only memory.</p>

<p>Any attempt to modify the string pointed to by <code>p</code> results in undefined behaviour.</p>

<p>Try changing the above line to:</p>

<pre><code>char p[] = ""GOOd"";
</code></pre>

<p>I don't see anything wrong with the <code>strrev()</code> function itself.</p>
",2
8395989,8395978,1,"<p>For any kind of IPv6 address manipulation, you'll need to store it as an array of 4 unsigned ints (4bytes each). Most stacks store it somewhat like this, this is from the linux kernel:</p>

<pre><code> struct in6_addr {
         union {
                 __u8            u6_addr8[16];
                 __be16          u6_addr16[8];
                 __be32          u6_addr32[4];
         } in6_u;
 #define s6_addr                 in6_u.u6_addr8
 #define s6_addr16               in6_u.u6_addr16
 #define s6_addr32               in6_u.u6_addr32
 };
</code></pre>

<p>You'll need to convert your string to this packed format using <code>inet_pton()</code>.</p>
",1
7776568,7776514,1,"<p>You'll probably need to:</p>

<ul>
<li>Rewrite your full file (simpliest way), or:</li>
<li>Add blank to replace your deleted patient</li>
<li>If the new name is shorter, you can add blank between the end of the name and the next patient, or add blank to replace the patient and add the new name at the end of the file</li>
</ul>

<p>The simpliest way is clearly to rewrite all the file, if it's not too important. Or you can maybe use something more adapted, like an SQLite database¡­</p>
",0
7776582,7776514,0,"<p>If you are managing data that needs to remain consistent, you should use a database. As already mentioned, SQLite is an offline database. It is a very powerful and easy to use library that treats a single file as a fully fledged SQL data source.</p>
",0
8304272,8304246,2,"<p>So you want to use a loop then.</p>

<pre><code>do {
   // grab input, process...
} while( x != 0 );
</code></pre>

<p>Also...</p>

<pre><code>if(x = 0)
</code></pre>

<p>That is an assignment, i.e., x will <em>always</em> equal zero when that executes and the <code>if</code> block will never be entered.  If you want to check equality, use <code>==</code>.</p>

<pre><code>if(x == 0)
</code></pre>
",0
8304280,8304246,1,"<p>You need a loop. Something like this:</p>

<pre><code>while (x != 0)
{
  // ...

  x /= 10;
}
</code></pre>

<p>In the loop, check the current last digit (which is <code>x % 10</code>), and track the maximum.</p>
",0
8304291,8304246,0,"<p>You want something like:</p>

<pre><code>while(x&gt;0)
{
     i=x%10;
     x/=10;
     // here check to see if 'i' is the biggest so far
}
</code></pre>

<p>Also, don't use variables with single-letter names. It's easy to forget what they are. (In fact, I can't tell in your code which variable is supposed to track the largest digit found so far.)</p>
",2
8304302,8304246,5,"<p>Why does the input necessarily have to be treated as an integer? You may consider treating the input as a string instead. Then, each digit is a <code>char</code> in an array of ascii characters, making it very easy to loop through the digits.</p>

<p>By looking at an ascii table, you'll notice the numerical values of the ascii digits 0-9 are in ascending order, which means comparing them for which is the largest is quite easy.</p>
",0
8304320,8304246,3,"<p>I would do it in a different way:</p>

<pre><code>void extractLargestDigit() {

    printf(""Enter an integer : "");
    scanf(""%d"", &amp;x);
    int max  = -1; // so it will always be less than any first digit

        while (x &gt;0){
            int digit = X %10; //grab last digit
            x = x / 10;        //throw last digit away
            if (max &lt; digit)       //if this digit is grater than current max...
                max = digit;       //... update it!
    }

    return max;
}
</code></pre>

<p>This way, you loop through each digit in turn, and the greatest on will be in <code>max</code> varible.</p>
",2
8304333,8304246,0,"<p>Your code is a little bit hard to read as it is formatted now. Try this (your professor will thank you) as I think it will help you better understand what you have to do. I have given you a hint on what you might need to do next as well.</p>

<pre><code>void extractLargestDigit() {
   int i = 0; /* You can declare and initialise at the same time, by the way */
   int v = 0;
   int x = 0;

   printf(""Enter an integer : "");
</code></pre>

<p>You want to keep doing everything between this and the end of the function until the user enters a zero. You need a loop construct; C provides a few. Read up on <code>do...while</code>, <code>for</code> and <code>while</code> loops and you will find something that meets your needs.</p>

<pre><code>   scanf(""%d"", &amp;x);

   i = x % 10;
   x = x / 10 % 10;

   if(i &gt;= x) { 
       i = i; 
       x = x / 10 % 10;
   }
   if(x &gt;= i) {
       i = x; 
       x = x / 10 % 10;
   }
   if(x = 0) { /* Something's not right here */ 
       i = i;
   }
}
</code></pre>
",1
8213424,8213314,2,"<p>This, as Kerrek said, is a multi-byte character constant. It works because each character takes up 8 bits. 'adf' is 3 characters, which is 24 bits. An <code>int</code> is usually large enough to contain this. </p>

<p>But all of the above is platform dependent, and could be different from architecture to architecture. This kind of thing is still used in ancient Apple code, can't quite remember where, although file creator codes ring a bell.</p>

<p>Note the difference in syntax between <code>""</code> and <code>'</code>. </p>

<p><code>char *x = ""this is a string. The value assigned to x is a pointer to the string in memory""</code></p>

<p><code>char y = '!' // the value assigned to y is the numerical character value of the character '!'</code></p>

<p><code>char z = 'asd' // the value of z is the numerical value of the 'string' data, which can in theory be expressed as an int if it's short enough</code></p>
",4
8213592,8213314,0,"<p>It works just because ""adf"" is 3 ASCII characters and thus 3 bytes long and your platform is a 24 bit or larger system. It would fail on a 16bit system for instance.</p>

<p>Its also worth remembering that although sizeof(char) will always return 1, dependending on platform and compiler more than 1 byte of memory space could be assigned to a char hence for</p>

<pre><code>struct st 
{
int a;
char c;
};
</code></pre>

<p>when you:</p>

<p><code>sizeof(st)</code> a number of 32 bit systems will return <code>8</code>. This is because the system will pad out the single byte for <code>char c</code> to 4 bytes.</p>
",3
8395238,8395187,1,"<blockquote>
  <p>The pointer *dots should point to the first element of the array of
  pointers to squares (*neighbors[7])</p>
</blockquote>

<p>No it shouldn't ... the type of a pointer to the first element of neighbors is <code>struct _square **</code>, not <code>struct _square *</code>.</p>

<p>In your EDIT, you cast the result of <code>malloc</code> to <code>(node *)</code>, which is not a declared type, and then you attempt to assign it to <code>square_neighbors</code>, which is an array and cannot be assigned to. And it's an array of 8 <code>square*</code>, but there's no such type declared. And after assigning it to that local variable, you return without using the value, leaking memory. Also in your original code you have <code>typedef struct_plot</code> which is a typo.</p>

<p>Please, before posting a question to SO, run your code through the compiler and fix the typos and other errors and warnings that it reports. Once you have done that we can try to address your conceptual errors.</p>
",0
8395554,8395187,1,"<h2>Pointer Arrays</h2>

<p>This should clarify what it is you're trying to do.  In the code below we first allocate an array of 8 pointers to point objects (struct _squares).  We then allocate memory for each point object and initialize them as needed.</p>

<p>You can access this data structure as shown.  Note that this does not necessarily allocate memory contiguously (since multiple calls to malloc are made).</p>

<h2>Sample Program</h2>

<pre><code>#include &lt;stdio.h&gt;

typedef struct _square
{
    char figure;
    int num_neighbors;
    struct _square *neighbors[7];
} point;

typedef struct _plot
{
    int num_squares;
    struct _square *dots;
} plot;

int main(void)
{
    int i;
    point** residents = malloc(8 * sizeof(point*));
    for (i = 0; i &lt; 7; i++)
    {
        residents[i] = malloc(sizeof(point));
    }
    residents[0]-&gt;figure = 'A';
    residents[1]-&gt;figure = 'B';

    residents[0]-&gt;neighbors[0] = residents[1];
    printf(""First neighbor of %c is %c\n"",
        residents[0]-&gt;figure,
        residents[0]-&gt;neighbors[0]-&gt;figure);

    return 0;
}
</code></pre>

<h2>Output</h2>

<pre><code>First neighbor of A is B
</code></pre>
",3
8460924,8460874,3,"<p>I think you missed the correctness of the original answer, so I will elaborate here...</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;


struct record
{
    char * community_name;
    double data[10];
    double crimes_per_pop;
};

void allocate_struct_array(struct record ** array_pointer, int length);
/* the allocate_struct_array should take a POINTER to a POINTER */

int main()
{
    int num_lines = 10;
/* this is wrong:   struct record ** data_array; */
/* it should be: */ struct record *data_array; 

    allocate_struct_array(&amp;data_array, num_lines); /* NOW this will work */

    data_array[0]-&gt;community_name[0] = 'h'; /* THIS WILL STILL CRASH community_name is not allocated!!! */
    printf(""%c\n"", data_array[0]-&gt;community_name[0]);

    return 0;
}


void allocate_struct_array(struct record **array_pointer, int length)
{
    int i;
    struct record *array;
    array = malloc(length * sizeof(struct record *));

    if (!array)
    {
        fprintf(stderr, ""Could not allocate the array of struct record *\n"");
        exit(1);
    }

    for (i = 0; i &lt; length; i++)
    {
        array[i] = malloc( sizeof(struct record) );

        if (!array[i])
        {
            fprintf(stderr, ""Could not allocate array[%d]\n"", i);
            exit(1);
        }
    }
    *array_pointer = array; /* copied over. */
}
</code></pre>

<p>By the way i would like to show you a good C implementation of structure allocations record:</p>
",2
8460929,8460874,1,"<p>Your signatures are swapped. In your main function data_array should be declared as a  <code>struct record* array</code>,with only one <code>*</code>. Your allocate_struct_array function should instead take <code>struct record** array</code>, with two <code>*</code>'s. </p>

<p>Each <code>*</code> is another layer of indirection. You need to start off with only one layer of indirection in the main function(it is indirect because you are referring to multiple structs with one variable). </p>

<p>You then add another layer of indirection in your allocate_struct_array function, as you need to modify a variable from another function. You can see this adding of the indirection when you use the <code>&amp;</code> operator in your call of allocate_struct_array.</p>
",2
7799376,7799347,3,"<p>That's exactly what <code>malloc</code> is for. When you need a varying number of objects of a particular type and need to control where they are allocated, you use <code>malloc</code>. Why does it seem like a kludge?</p>
",1
8279538,8279511,3,"<p>Build an index. But that also takes at least linear time. But without any index and no sorting, how are you going to skip reading all data?</p>

<p>The best trick you can do is string matching algorithms such as Knuth-Morris-Pratt, but that only helps when your search string is long and there are many similar false matches. Doesn't save you any I/O either.</p>
",2
8303209,8303177,1,"<p>You must pass the address of the variable using <code>&amp;</code> to scanf:</p>

<pre><code>scanf(""%d"", &amp;option);
</code></pre>

<p>That's why it crashes when you run it.</p>
",1
8303231,8303177,0,"<p>You're using the assignment operator (<code>=</code>) as opposed to the comparison operator (<code>==</code>) in four of your <code>while</code> conditions:</p>

<p><code>while(option = 0)</code> should be <code>while(option == 0)</code></p>

<p>You also shouldn't have a <code>;</code> straight after the condition, otherwise if the condition is true it'll always be true and you'll have an infinite loop.</p>

<p><code>while(option == 0); { ... }</code> should be <code>while(option == 0) { ... }</code></p>

<p>Otherwise the body of the loops aren't actually the body of the loops, they're completely unrelated to the loop.</p>

<p><br/>
Also, <code>scanf(""%d"", option);</code> will treat the value of <code>option</code> (0) as an address and try to store the inputted integer into the wrong spot of memory, causing undefined behaviour (most likely a crash). If it doesn't crash, <code>option</code> will remain as 0.</p>

<p>You should also check the return value of <code>scanf</code> to ensure that the right amount of items were inputted. That may also involve getting rid of any junk input up until the next newline (or EOF).</p>

<p><br/>
I also don't understand why you have all of those <code>while</code> loops. If you're trying to create a menu that loops, have one single loop where the termination condition is the option that indicates exit (in your case it looks like that's 3). You could have a <code>switch</code> statement inside that single loop to call the right function based on the value of <code>option</code>.</p>

<p>And a <code>return;</code> isn't necessary at the end of a <code>void</code> function.</p>

<p><br/>
<strong>EDIT:</strong> About those two functions, the common way of splitting a number into it's digits is:</p>

<pre><code>WHILE num IS NOT 0:
   digit = num MOD base
   num = num DIV base
</code></pre>

<p>Since decimal is base 10, you'd compute the modulus (<code>%</code> in C) and division of <code>num</code> with 10. If you wanted binary digits, you'd use a base of 2. Then just do whatever you need to with each digit at every iteration. The digits will obviously be extracted starting from the end (least significant digit).</p>

<p>Lastly, turn up the warnings on your compiler so it'll tell you about the problems above, ie:</p>

<pre><code>gcc -Wall -o test test.c
test.c: In function ¡®displayProgramMenu¡¯:
test.c:44:2: warning: format ¡®%d¡¯ expects argument of type ¡®int *¡¯, but argument 2 has type ¡®int¡¯ [-Wformat]
test.c:46:2: warning: suggest parentheses around assignment used as truth value [-Wparentheses]
test.c:48:2: warning: suggest parentheses around assignment used as truth value [-Wparentheses]
test.c:49:2: warning: suggest parentheses around assignment used as truth value [-Wparentheses]
test.c:50:2: warning: suggest parentheses around assignment used as truth value [-Wparentheses]
</code></pre>

<p>And (lastly + 1) you can get rid of <code>conio.h</code> and replace <code>getch()</code> with <code>getchar()</code> or <code>getc(stdin)</code>.</p>
",0
8414950,8414643,3,"<p>Your left truncatable check is wrong. I did it differently, simpler.</p>

<pre><code>#include&lt;stdio.h&gt;
int isprime(int n) //Checks whether the number is prime or not
{
    int i;
    if(n==1)
        return(0);
    for(i=2;i&lt;n/2+1;i++)
    {

        if(n%i==0)
        {
            return(0);
            break;
        }   
    }
    return(1);      
}
int power(int a, int b){
    int r = 1;
    int i=0;
    for (i=0;i&lt;b;i++){
        r = r * a;
    }
    return r;
}

int main(void)
{
    int count=0,z=0;
    int i;
    int n;
    int z1=0;
    int p;
    int count1=0;
    int digits;
    int k=1000000;
    for(i=2;i&lt;k;i++)
    {
        if(isprime(i)==1)
        {
            z = 0;
            count = 0;
            n=i;
            p=i;
            while(n&gt;0) // This function removes the digits of the prime number from the right
            {
                n=n/10;
                if(isprime(n)==1)
                {
                    count++;
                }else{
                    count = -1;
                    break;
                }   
                z++;
            }

            if(z==count) 
            {   
                z1= 0;
                count1=0;
                n = i;
                p= i;
                while(p&gt;0) //Checks whether number is left truncatable 
                {   
                    digits=n%power(10,z1+1);
                    p = p /10;
                    if (isprime(digits)==1)
                    {
                        count1++; 
                    }else{
                        count1 =-1;
                        break;
                    }
                    z1++;
                }

                if(z1==count1)
                    printf(""%d\n "",i);

            }
        }                                                                                                                                                                                       
    }   

} 
</code></pre>
",0
8461523,8461512,2,"<p>I don't know what you are trying to do, but at least you have a programmatic error.</p>

<pre><code>allocate_struct_array( &amp;(**r) );
</code></pre>

<p>needs to be -</p>

<pre><code>allocate_struct_array(&amp;r);
</code></pre>
",0
8461525,8461512,1,"<p>In the function interface, you only need a double pointer <code>struct record **r</code> and not a triple pointer.</p>

<p>An array can be represented by a <code>struct record *array</code>; so a pointer to that is <code>struct record **ptr_to_array</code>.</p>

<p>You call the function with <code>&amp;array</code>.</p>

<pre><code>struct record
{
    char * community_name;
    double data[10];
    double crimes_per_pop;
};

void allocate_struct_array(struct record **r);

int main()
{
    struct record *r;
    allocate_struct_array(&amp;r);
}


void allocate_struct_array(struct record **r)
{
    *r = malloc(23 * sizeof(struct record));
    ...
}
</code></pre>
",0
8372180,8372142,1,"<p>The typical naive <code>new</code>/<code>delete</code> implementations in C++:</p>

<pre><code>void * operator new(std::size_t n) throw(std::bad_alloc)
{
    void * const p = std::malloc(n);

    if (!p) throw std::bad_alloc();

    return p;
}

void operator delete(void * p) throw()
{
    std::free(p);
}
</code></pre>

<p>In C++11, the exception specifications change to ¡°none¡± for <code>operator new()</code> and to <code>noexcept</code> for <code>operator delete()</code>.</p>

<p>The adult version of the <code>new</code> operator would first loop <code>set_new_handler()</code> before throwing.</p>

<p>Alignment guarantees follow those of <code>malloc()</code>.</p>
",0
8372195,8372142,0,"<pre><code>#include &lt;exception&gt;

void *operator new(unsigned int s)
{
    void *block = malloc(s);
    if(block == NULL)
       throw std::exception(""Not enough memory."");
    memset(block, 0, s);
    return block;
}
</code></pre>
",2
8372348,8372142,2,"<p>Are you sure you are wanting an implementation in C, not C++? The following is all under the assumption that you really want C.</p>

<p>To start with, C does not know the keyword <code>operator</code>, and you cannot give a function a name with two words. Therefore you will need to give your function a different name, like <code>operator_new</code>. Given that your function obviously only works for ints (there's no way in your interface to give information about the type, and your example implementation allocates space for <code>s</code> <code>int</code>s), I'd suggest <code>new_ints</code> instead (since C doesn't have constructors, the distinction between <code>new</code> and <code>operator new</code> is moot). Alternatively you might want to pass on arguments telling about the size of the type you want to allocate. You can even pass on a pointer to a function you want to be called as ""constructor"" for your objects (using a <code>void*</code> interface).</p>

<p>Also C has no exceptions. You may somewhat emulate them with <code>setjmp</code>/<code>longjmp</code>, however since C doesn't know destructors it will not do cleanup for you. Code aware of your hand-made exception handling may however implement cleanup explicitly through a chain of <code>setjmp</code> buffers. However, those setjmp buffers need to be passed on to your function, either using extra arguments, or using a global variable. All in all, the better option in C is to just return <code>NULL</code>, as <code>malloc</code> does. However, if you insist on the exception part, this is how you might do it (untested):</p>

<pre><code>#include &lt;setjmp.h&gt;
#include &lt;stdlib.h&gt;

void* operator_new(size_t s,     /* how many bytes to allocate */
                   jmp_buf env)  /* the ""exception"" information */
{
  void* block = malloc(s);
  if (!block)
    longjmp(env, 1); /* 1 is an ""error code"" */
  return block;
}
</code></pre>

<p>The function would then be called as follows:</p>

<pre><code>int main()
{
  volatile jmp_buf env; /* I'm actually not sure if this has to be volatile,
                           but longjmp may mess up some non-volatile variables */
  if (!setjmp(env)) /* try */
  {
    int* p = operator_new(10*sizeof int, env);
    /* use p */
    free(p)
  }
  else /* catch(...) */
  {
    /* handle the error */
  }
}
</code></pre>
",0
8425995,8425561,2,"<p>Here are few observations which you can use (This is more of a compilation of the comments above):<br>
1. Don't use <code>fflush(stdin)</code>. <a href=""https://stackoverflow.com/questions/2979209/using-fflushstdin""><code>fflush</code> is for output stream only</a>.<br>
2. Don't use <code>gets</code>.  <a href=""https://stackoverflow.com/questions/2843073/warninggets-function-is-dangerous"">Its not safe</a>. Use <code>fgets</code> as suggested.<br>
3. Add bound checks to your array. In <code>while ((tokens[i] = strtok (NULL, "" "")) != NULL)</code>, you should check for the value of <code>i</code> so that is does not exceed the allocated array size of <code>tokens</code><br>
4. In the statement <code>if (strcmp(tokens[6],metricLength[0])==0);</code>, the semicolon makes this condition result in empty body. I think adding the semicolon was not intended so get rid of it.<br>
5. As per your input requirement, you are checking the wrong token. If your input requires ""How many METRIC_UNIT are in VALUE ENGLISH_UNIT"", then you should compare the third token i.e. <code>tokens[2]</code>. If may be a good idea to validate the input as well.<br>
6. Crank up the warnings on your compiler to the max &amp; fix them all! Its a good practice.<br>
Hope this helps!</p>
",0
8377761,8377739,9,"<p>Your problem is that this statement : <code>(a &lt;&lt; 3)</code> converts the input to an <code>int</code> . So at this point you have <code>240 * 2 ^ 3 = 1920</code> </p>

<pre><code>00000000000000000000011110000000
</code></pre>

<p>Then you are dividing the previous result by <code>2 ^ 7 = 128</code> so you have : <code>15</code></p>

<pre><code>00000000000000000000000000001111
</code></pre>

<p>Which is exactly what you are getting as a result. </p>

<p>If you wanted to truncate bits you could have used : </p>

<pre><code>printf(""a: %u\n"",a &amp; 1); //get only last bit so you would have 1 as a result!
printf(""a: %u\n"",a &amp; 255); //get all 8 bits
</code></pre>

<p>Hope this helped!</p>
",1
8377770,8377739,3,"<p>The expressions are evaluated as (unsigned) ints. (default int promotion). Casting(truncation) to a narrower type only happens just prior to the final assignment.</p>
",0
8377775,8377739,3,"<p>When you shifted, it casted <code>a</code> into an integer type larger than 8 bits, so the top 4 bits were saved</p>

<pre><code>#include &lt;stdio.h&gt;
int main() {
    unsigned char a = 240;
    a = (a &lt;&lt; 3);
    a = (a &gt;&gt; 7);
    printf(""a: %u\n"",a);

    return 0;
}
</code></pre>

<p>prints 1</p>
",0
8377850,8377739,1,"<p>While shifting the types are automatically promoted to int which is wider than char (most often). So, it can store all your bits.</p>

<p>To get what you expect you would have to do</p>

<pre><code>a = a &lt;&lt; 3;
a = a &gt;&gt; 7;
</code></pre>

<p>or</p>

<pre><code>a = ((unsigned char)(a &lt;&lt; 3)) &gt;&gt; 7;
</code></pre>
",1
8437818,8437791,16,"<p>In exactly the same way but with some different arithmetic. You can think of what you are doing now as allocating an array with one element. Just multiply <code>sizeof(int)</code> by the number of elements you want your array to have:</p>

<pre><code>int f1(int ** b, int arrsize) {
  *b = malloc(sizeof(int) * arrsize);

  // then to assign items:
  (*b)[0] = 0;
  (*b)[1] = 1;
  // etc, or you can do it in a loop
}

int main() {
  int * a, i;
  int size = 20;

  f1(&amp;a, size); // array of 20 ints

  for (i = 0; i &lt; size; ++i)
      printf(""%d\n"", a[i]); // a[i] is the same as *(a + i)
                            // so a[0] is the same as *a

  // keep it clean : 
  free(a);

  return 0;
}
</code></pre>
",3
8437827,8437791,2,"<p>You are almost there <code>*b = malloc(sizeof(int));</code> allocates space for a single int ( a bit pointless since the pointer is at least as big as this)</p>

<p>The more normal usage is  <code>*b = malloc(number_of_ints*sizeof(int));</code> </p>

<p>Remember that the <code>[]</code> syntax just does the array maths for you   <code>(a+10)</code> and <code>a[10]</code> point to exactly  the same thing memory location, so you can allocate it using malloc, pass the poitner and refer to it as an array.</p>

<p>The only things about arrays and pointers that is complicated (apart from remembering when to use * and &amp;) is that malloc() works in bytes, so you need to tell it the sizeof an int. But the <code>int *</code> it returns knows about ints so to get to the next value you only need to do <code>a++</code> or <code>a+1</code> or <code>a[1]</code> even though it is really 4 or 8 bytes different in value.</p>
",3
8437832,8437791,0,"<p>Instead of <code>malloc()</code>ing a single int, <code>malloc</code> the array.</p>

<pre><code>int f1(int * b) {
  b = malloc(ARRAY_LENGTH * sizeof(int)); 
  *b = 5;
  b[1] = 6;
  *(b + 2) = 7;
}
</code></pre>
",1
8437835,8437791,0,"<p>You'll want to use a <code>calloc</code> call instead of <code>malloc</code> (See this: <a href=""http://www.manpagez.com/man/3/calloc/"" rel=""nofollow"">http://www.manpagez.com/man/3/calloc/</a>)</p>
",2
8437854,8437791,2,"<p><em>(untested, but I believe it'll work)</em></p>

<pre><code>int f1(int ** b) {
  *b = malloc(sizeof(int)*4); 

  (*b)[0] = 5;
  (*b)[1] = 6;
  (*b)[2] = 7;
  (*b)[3] = 8;
}

int main() {
  int * a;
  f1(&amp;a);
  printf(""%d %d %d %d\n"", a[0], a[1], a[2], a[3]); // should be ""5 6 7 8""
  // keep it clean : 
  free(a);
  return 0;
}
</code></pre>
",2
2266870,2266840,21,"<p>Typically, the string literal <code>""abc""</code> is stored in a read only part of the executable. The pointer <code>s</code> would be created on the stack(or placed in a register, or just optimized away) - and point to that string literal which lives ""elsewhere"".</p>
",4
2266893,2266840,6,"<pre><code>""abc""
</code></pre>

<p>String literals are stored in the <code>__TEXT,__cstring</code> (or <code>rodata</code> or whatever depends on the object format) section of your program, if string pooling is enabled. That means, it's neither on the stack, nor in the heap, but sticks in the read-only memory region near your code.</p>

<pre><code>char *s = ""abc"";
</code></pre>

<p>This statement will be assign the memory location of the string literal <code>""abc""</code> to <code>s</code>, i.e. <code>s</code> <em>points</em> to a read-only memory region.</p>
",0
2267060,2266840,3,"<p>""Stacks"" and ""heaps"" are implementation details and depend on the platform (all the world is <em>not</em> x86).  From the language POV, what matters is storage class and extent.</p>

<p>String literals have <em>static</em> extent; storage for them is allocated at program startup and held until the program terminates.  It is also assumed that string literals cannot be modified (attempting to do so invokes undefined behavior).  Contrast this with local, block-scope (auto) variables, whose storage is allocated on block entry and released on block exit.  Typically, this means that string literals are not stored in the same memory as block-scope variables.  </p>
",0
8448193,8448086,4,"<p>May be its preprocessor dependent. Since compiler does the optimization, the preprocessor may be only doing substitution.</p>

<p>My gcc version <code>i686-apple-darwin10-gcc-4.2.1</code> is showing it as option 1</p>

<pre><code>var = (5*10)
</code></pre>

<p>you can use <code>-E</code> flag option to check </p>

<p>like</p>

<pre><code>gcc -E test.c
</code></pre>
",0
8448452,8448086,0,"<p>it will be (5*10) after the macro expand, but after that, the compiler will optimize it with 50.</p>
",0
8448124,8448086,3,"<p>Macros are just textual replacement wherein the pre-compiler just replaces the macro with its defined value. So once the macro is replaced by its definition the compiler will evaluate those operations. Further compilers may optimize how they treat expressions such as <code>(5*10)</code> compilers follow the <strong>As-If</strong> rule of optimization wherein they might directly replace <code>(5*10)</code> by <code>50</code> since that does not change the observable behavior of your program.</p>
",0
8448125,8448086,5,"<p>Macro expansion is always just a textual transform of the input source code. You should be able to see the code after the pre-processor (the part of the compilation that does the macro expansion) is done; this text is what the compiler proper then works on.</p>

<p>But many compilers do ""constant folding"" optimization during compilation, that will optimize <code>5 * 10</code> to <code>50</code> so that it doesn't need to be calculated at runtime.</p>
",0
8448143,8448086,0,"<p>The macro is expanded to var=(5*10) by the precompiler</p>

<p>However the compiler almost certainly optimises this to be equivalent var=50 for any modern compiler.</p>

<p>You should be able to set the compiler to output the precompiled code so that you can see the macro expansions.</p>
",0
8448144,8448086,2,"<p>The output of the preprocessor will be <code>(5*10)</code>. It is the responsibility of the compiler to perform calculation, or in this case constant-fold, the expression.</p>
",0
8284375,8284309,11,"<p>This compiles because <strong>Standard C99 ¡ì6.2.1/7</strong> says: </p>

<blockquote>
  <p>Any identifier that is not a structure, union, or enumeration tag ""has scope that begins just after the completion of its declarator."" The declarator is followed by the initializer.</p>
</blockquote>

<p>However, value of <code>status</code> is <strong>Indeterminate</strong>. And you cannot rely on it being initialized to something meaningful.</p>

<p><strong>How does it work?</strong><br>
<code>int status</code> creates an space for the variable to exist on the stack(local storage) which is then further read to perform <code>status = status</code>, <code>status</code> might get initialized to any value that was present in the stack frame.</p>

<p><strong>How can you guard against such self Initialization?</strong><br>
gcc provides a specific setting to detect self Initializations and report them as errors:       </p>

<blockquote>
  <p>-Werror=uninitialized -Winit-self</p>
</blockquote>

<p><strong>Why is it used in this code?</strong><br>
The only reason I can think it is being used in the said code is to suppress the unused variable warning for ex: In <code>transport.c</code>, if the control never goes inside the <code>while</code> loop then in that control flow <code>cmp</code> will be unused and the compiler must be generating a warning for it. Same scenario seems to be with <code>status</code> variable in <code>wt-status.c</code> </p>
",2
8284423,8284309,0,"<p>I think <code>status = status</code> doesn't change the value of <code>status</code> (compared to <code>int status;</code>). I think it is used to suppress the <code>unused variable</code> warning.</p>
",0
8284341,8284309,1,"<p>For me the only reason of such self-assigning initialization is to avoid a warning.</p>

<p>In the case of your <code>transport.c</code>, I don't even understand why it is useful. I would have left  <code>cmp</code> uninitialized.</p>

<p>My own habit (at least in C) is to initialize all the variables, usually to 0. The compiler will optimize unneeded initialization, and having all variables initialized makes debugging easier.</p>

<p>There is a case when I want a variable to remain uninitialized, and I might self-assign it: random seeds:</p>

<pre><code> unsigned myseed = myseed;
 srand(myseed);
</code></pre>
",3
8284345,8284309,1,"<p>On MacOS X 10.7.2, I tried this example - with the result shown...</p>

<pre><code>$ cat x3.c
#include &lt;stdio.h&gt;

int status = -7;

int main()
{
    printf(""status = %d\n"", status);
    int status = status;
    printf(""status = %d\n"", status);
    return 0;
}
$ make x3
gcc -O -std=c99 -Wall -Wextra  x3.c -o x3  
$ ./x3
status = -7
status = 1787486824
$
</code></pre>

<p>The stack space where the local <code>status</code> in <code>main()</code> has been used by <code>printf()</code> so the self-initialization copies garbage around.</p>
",0
5149762,5149725,2,"<p>It's called isgraph, not isGraph (and char, not Char), and the POSIX Programmer's Manual says </p>

<blockquote>
  <p>The isgraph() function shall test
  whether c is a character of class
  graph in the program's current locale;
  see the Base Definitions volume of
  IEEE Std 1003.1-2001,
         Chapter 7, Locale.</p>
</blockquote>

<p>So yes, it looks it up in a table (or equivalent code). It can't check whether it can actually be displayed, since that would vary depending upon the output device, many of which can display chars in addition to those for which isgraph returns true.</p>
",2
5149777,5149725,0,"<p><code>isgraph</code> checks for ""printable"" characters, but the definition of ""printable"" can vary depending on your locale.  Your locale may use characters that aren't in the ASCII table.  Internally, it's most likely either a table lookup, a range-based test (<code>(x &gt;= 'a') &amp;&amp; (x &lt;= 'z')</code>, etc), or a combination of both.  Different implementations may do it slightly differently.</p>
",0
5149817,5149725,6,"<p>The code behind the <code>isgraph()</code> function varies by platform (or, more precisely, by implementation).  One common technique is to use an initialized array of bit-fields, one per character in the (single-byte) codeset plus EOF (which has to be accepted by the functions), and then selecting the relevant bit.  This allows for a simple implementation as a macro which is safe (only evaluates its argument once) and as a simple (possibly inline) function.</p>

<pre><code>#define isgraph(x) (__charmap[(x)+1]&amp;__PRINT)
</code></pre>

<p>where <code>__charmap</code> and <code>__PRINT</code> are names reserved for the implementation.  The <code>+1</code> part deals with the common situation where <code>EOF</code> is <code>-1</code>.</p>

<hr>

<p>According to the C standard (ISO/IEC 9899:1999):</p>

<blockquote>
  <h2>¡ì7.4.1.6 The isgraph function</h2>
  
  <h3>Synopsis</h3>

<pre><code>#include &lt;ctype.h&gt;
int isgraph(int c);
</code></pre>
  
  <h3>Description</h3>
  
  <p>The isgraph function tests for any printing character except space (' ').</p>
</blockquote>

<p>And:</p>

<blockquote>
  <h2>¡ì7.4 Character handling <code>&lt;ctype.h&gt;</code></h2>
  
  <p>?1 The header  declares several functions useful for classifying and mapping
  characters.<sup>166)</sup> In all cases the argument is an int, the value of which shall be
  representable as an unsigned char or shall equal the value of the macro EOF. If the
  argument has any other value, the behavior is undefined.</p>
  
  <p>?2 The behavior of these functions is affected by the current locale. Those functions that
  have locale-specific aspects only when not in the ""C"" locale are noted below.</p>
  
  <p>?3 The term printing character refers to a member of a locale-specific set of characters, each
  of which occupies one printing position on a display device; the term control character
  refers to a member of a locale-specific set of characters that are not printing
  characters.<sup>167)</sup> All letters and digits are printing characters.</p>
  
  <p><sup>166)</sup> See ¡®¡®future library directions¡¯¡¯ (7.26.2).</p>
  
  <p><sup>167)</sup> In an implementation that uses the seven-bit US ASCII character set, the printing characters are those
  whose values lie from 0x20 (space) through 0x7E (tilde); the control characters are those whose
  values lie from 0 (NUL) through 0x1F (US), and the character 0x7F (DEL).</p>
</blockquote>
",0
5535953,5535916,2,"<pre><code>printf(""\n%s"", vector[i]);
</code></pre>

<p>Simply</p>
",3
5622339,5622275,1,"<p>use <code>fgets</code> instead of <code>scanf</code>. <code>scanf</code> doesn't check if user enters a string longer than 40 chars in your example above so for your particular case <code>fgets</code> should be simpler(safer).</p>
",1
5622360,5622275,0,"<p><code>scanf</code> won't return until it sees something other than whitespace. It also doesn't distinguish between newlines and other whitespace. In practice, using <code>scanf</code> is almost always a mistake; I suggest that you call <code>fgets</code> instead and then (if you need to) use <code>sscanf</code> on the resulting data.</p>

<p>If you do that, you really ought to deal with the possibility that the user enters a line longer than the buffer you pass to <code>fgets</code>; you can tell when this has happened because your entire buffer gets filled and the last character isn't a newline. In that situation, you should reallocate a larger buffer and <code>fgets</code> again onto the end of it, and repeat until either you see a newline or the buffer gets unreasonably large.</p>

<p>You should really be similarly careful when calling <code>scanf</code> or <code>sscanf</code> -- what if the user enters a string 100 characters long? (You can tell <code>scanf</code> or <code>sscanf</code> to accept only a limited length of string.)</p>

<p>On the other hand, if this is just a toy program you can just make your buffer reasonably long and hope the user doesn't do anything nasty.</p>
",1
5622382,5622275,0,"<p><code>fgets</code> does what you need.  Avoid using <code>scanf</code> or <code>gets</code>.  If you can't use <code>fgets</code> try using <code>getchar</code></p>
",1
5622648,5622275,1,"<p>Can you use a while loop and getch, then test for the <code>&lt;Enter&gt;</code> key on each keystroke?</p>
",0
5623006,5622275,1,"<p>Use</p>

<pre><code>char enter[1];
int chk = scanf(""%39[^\n]%c"", string_input, enter);
</code></pre>

<p>but <code>string_input</code> will not have a <code>'\n'</code> inside. Your test</p>

<pre><code>   if (string_input[0] == '\n') {
       printf(""ERROR - no data\n"");
   }
</code></pre>

<p>will have to be changed to, for example</p>

<pre><code>   if (chk != 2) {
       printf(""ERROR - bad data\n"");
   }
</code></pre>
",0
5623154,5622275,0,"<p>The problem is that <code>""%s""</code> attempts to skip white-space, and then read a string -- and according to <code>scanf</code>, a new-line is ""whitespace"".</p>

<p>The obvious alternative would be to use <code>""%c""</code> instead of <code>""%s""</code>. The difference between the two is that <code>""%c""</code> does <em>not</em> attempt to skip leading whitespace.</p>

<p>A somewhat less obvious (or less known, anyway) alternative would be to use <code>""%[^\n]%*[\n]""</code>. This reads data until it encounters a new-line, then reads the new-line and doesn't assign it to anything.</p>

<p>Regardless of which conversion you use, you <em>want</em> (need, really) to limit the amount of input entered so it doesn't overflow the buffer you've provided, so you'd want to use <code>""%39c""</code> or <code>""%39[^\n]""</code>. Note that when you're specifying the length for <code>scanf</code>, you need to subtract one to leave space for the NUL terminator (in contrast to <code>fgets</code>, for which you specify the full buffer size).</p>
",0
5131667,5131663,2,"<p>The end-of-file condition only affects <code>stdin</code>, not <code>stdout</code>.  Note that there are no uses of <code>stdin</code> after the <code>EOF</code> is found, just printouts to <code>stdout</code>.</p>
",1
5131670,5131663,0,"<p>I think you're getting two different things mixed up. EOF is with regard to input. printf is an output function.</p>
",1
5131672,5131663,0,"<p>getchar() reads from stdin. printf() writes to stdout. They are different streams that usually map to the same physical device (console or terminal).</p>
",1
6085141,5131663,0,"<p>You should not count on a Ctrl-Z or any terminator
If you were counting on that and were running on traditional *nix shells you would suspend your process rather than terminate the input (read up on JOB CONTROL, in <code>man bash</code>, for example)</p>

<p>(I know this answer comes a bit late but I see you keep mentioning Ctrl-Z in you responses to other answers)</p>

<p>If you are on a *nix system you can use Ctrl-D, but dont expect that to end up in your input stream (its just used as a signaling mechanism).m   You can also test this with a file input which should give you more consistent results than typing, i.e. </p>

<pre><code>a.out &lt; prog.c
</code></pre>

<p>to count the lines in your c program </p>
",0
4540850,4540429,1,"<p>I'd go with 'wasting' an array entry to detect the queue full condition, especially if you're dealing with different threads/tasks being producers and consumers. Having another flag keep track of that situation increases the locking necessary to keep things consistent and increases the likelihood of some sort of bug that introduces a race condition. This is even more true in the case where you can't use a critical section (as you mention in a comment) to ensure that things are in-sync.</p>

<p>You'll need at least a bit somewhere to keep track of that condition, and that probably means at least a byte.  Assuming that your queue contains <code>ints</code> you're only saving 3 bytes of RAM and you're going to chew up several more bytes of program image (which might not be as precious, so that might not matter). If you keep a flag bit inside a byte used to store other flag bits, then you have to additionally deal with setting/testing/clearing that flag bit in a thread safe manner to ensure that the other bits don't get corrupted.</p>

<p>If you're queuing bytes, then you probably save nothing - you can consider the sentinel element to be the flag that you'd have to put somewhere else. But now you have to have <em>no</em> extra code to deal with the flag.</p>

<p>Consider carefully if you really need that extra queue item, and keep in mind that if you're queuing bytes, then the extra queue item probably isn't really extra space</p>
",1
4540868,4540429,1,"<p>Instead of a read and write index, you could use a read index and a queue count. From the queue count, you can easily tell if the queue is empty of full. And the write index can be computed as (read index + queue count) mod array_size.</p>
",2
4540504,4540429,0,"<p>What's wrong with a queue count?  It sounds like you're going for maximum efficiency and minimal logic, and while I would do the same, I think I'd still use a queue count variable.  Otherwise, one other potential solution would be to use a linked list.  Low memory usage, and removing first element would be easy, just make sure that you have pointers to the head and tail of the list.</p>
",1
4540557,4540429,0,"<p>Basically you only need a single additional bit somewhere to signal that the queue is currently empty. You can probably stash that away somewhere, e.g., in the most significant bit of one of your indices (and than AND-ing the lower bits creatively in places where you need to work only on the actual index into your array).</p>

<p>But honestly, I'd go with a queue count first and only cut that if I really need that space, instead of putting up with bit fiddling.</p>
",3
5556910,5556125,0,"<p>Here is an example of what you are looking for with an awesome console output. It dynamically allocates the array to hold any number errors (duplicate characters in your case) that may occur.</p>

<pre><code>//Only free errors if result is &gt; 0
int find_errors(char* word, char** errors)
{
    int num_errors = 0;
    int word_length = strlen(word);
    int ARRAY_SIZE = MIN(8, word_length);
    char existing[word_length];
    int existing_index = 0;

    *errors = NULL;

    for(int i = 0; i &lt; word_length; i++)
    {
        char character = word[i];

        //Search array
        for (int n = 0; n &lt; word_length; ++n ) {
            if(n &gt;= existing_index)
            {
                existing[n] = character;
                existing_index++;
                break;
            }
            if (existing[n] == character) {
                num_errors++;

                if(!*errors)
                    *errors = (char*)malloc(ARRAY_SIZE * sizeof(char));

                //Check if we need to resize array
                if(num_errors &gt;= ARRAY_SIZE)
                {
                    ARRAY_SIZE *= 2;
                    ARRAY_SIZE = MIN(ARRAY_SIZE, word_length);

                    char *tmp = (char*)malloc(ARRAY_SIZE * sizeof(char));
                    memcpy(tmp, *errors, (unsigned long)ARRAY_SIZE);
                    free(*errors);
                    *errors = tmp;
                }
                //Set the error character
                (*errors)[num_errors - 1] = character;
                break;
            } 
        } 
    }

    return num_errors;
}
int find_word(char* word)
{
    char* errors;
    int errCount = find_errors (word, &amp;errors);
    if(errCount &gt; 0)
    {
        printf(""Invalid Characters: "");
        for(int i =0; i &lt; errCount; i++)
        {
            printf(""%c "", errors[i]);
        }
        printf(""\n"");

        free(errors);
    }

    return 0;
}

int main(int argc, char *argv[])
{
    find_word(""YWPEIT"");
    find_word(""Hello World"");
    find_word(""XxxxXXxXXoooooooOOOOOOOOOOOOOOOooooooooOOOOOOOOOOOOooooooOOO"");
}
</code></pre>
",0
5556201,5556125,5,"<p>There are at least three possible approaches:</p>

<ol>
<li>Use a global variable</li>
<li>pass a parameter between them</li>
<li>return a pointer from the function</li>
</ol>
",3
5556225,5556125,0,"<p>You need to declare the <code>error</code> array globally and use it just like you did.</p>

<p>EDIT: using global variables isn't the best practice in most of the cases, like this one.</p>
",1
5556236,5556125,0,"<p>Your question relates to ""call-by-reference"" and ""call-by-value"".</p>

<pre><code>char* getNewValsToSet(void)
{
  char* new_vals = (char*) malloc(sizeof(char[5]));
  new_vals[4] = '\0';
  return new_vals;
}

void setValuesEven(char* vals_to_set)
{
  vals_to_set[0] = 'A';
  vals_to_set[2] = 'C';
}

void setValuesOdd(char* vals_to_set)
{
  vals_to_set[1] = 'B';
  vals_to_set[3] = 'D';
}

int main(void)
{
  char* some_vals_to_set = getNewValsToSet();
  setValsEven(some_vals_to_set);
  setValsOdd(some_vals_to_set);

  // ... now has vals ""ABCD""

  free(some_vals_to_set);  //cleanup

  return 0;
}
</code></pre>

<p>If you have ""doubts"" about learning C, IMHO it's one of the best things you can do (no matter the language in which you work) because it will explain <em>exactly how</em> things work ""under-the-hood"" (which all high-level languages try to hide to some degree).</p>
",0
5556271,5556125,2,"<p>There are multiple ways to do this.</p>

<p>1) Create a dynamic array and return a pointer to the array.  This will require you to manually free the memory for the array at a later time.</p>

<pre><code>#define NUM_ELEMS 50

// In find_error():
char* error = malloc(NUM_ELEMS * sizeof(char));
return error;

// In find_word():
char *error = find_errors();
// do stuff
free(error);
</code></pre>

<p>2) Pass a pointer to find_errors that it can use as the error array. This will not require you to manually free the memory.</p>

<pre><code>// In find_word():
char error[NUM_ELEMS];
find_error(error);
</code></pre>

<p>3) Use a global array. May make it more difficult for other people to understand your code. Has other potential problems as well.</p>

<pre><code>// In global scope:
char error[NUM_ELEMS];
</code></pre>
",2
3698340,3698332,1,"<p>You should use:</p>

<pre><code>fread(dataStr, 1, sizeof dataStr, dFd);
</code></pre>

<p>to indicate that you want to read the number of bytes equal to the size of your array buffer.</p>

<p>The reason why your code doesn't work is that <code>strlen()</code> finds the length of a <em>NULL-terminated string, not the size of the buffer</em>. In your case, you run it on an uninitialized buffer and simply get lucky, your first byte in the buffer is NULL, so <code>strlen(dataStr)</code> returns 0, but is just as likely to crash or return some random number greater than your buffer size.</p>

<p>Also note that <code>fread()</code> returns the number of <em>items</em> read, not the number of characters (I swapped the second and the third arguments so that each character is equivalent to one item).</p>
",0
3698346,3698332,3,"<p><code>strlen</code> counts the number of characters until it hits \0.<br>
In this case you probably hit \0 on the very first character hence <code>strlen</code> returns 0 as the length and nothing is read.</p>

<p>You sould use <code>sizeof</code> instead of <code>strlen</code>.</p>
",0
3698348,3698332,2,"<p>You can't do that, obviously.</p>

<p>You can read until a known delimiter, often line feed, using <code>fgets()</code> to read a line. Or you can read a known-in-advance byte count, using that argument.</p>

<p>Of course, if there's an upper bound on the amount of data, you can read that always, and then somehow inspect the data to see what you got.</p>

<p>Also, in your example you're using <code>strlen()</code> on the argument that is going to be overwritten, that implies that it already contains a proper string of the exact same size as the data that is going to be read. This seems unlikely, you probably mean <code>sizeof dataStr</code> there.</p>
",0
3698367,3698332,-2,"<p>fread returns the number of successfully readed numblocks.
You can:</p>

<pre><code>if( 1==fread(dataStr, 256, 1, dFd) )
  puts(""OK"");
</code></pre>

<p>It reads ever the full length of your defined data; fread can't break on '\0'. </p>
",1
5566897,5566080,16,"<p><code>pthread_cond_broadcast()</code> should be used when multiple threads may be waiting on the condition variable, but some of those threads may not be ready to proceed.  <code>pthread_cond_signal()</code> might wake up one of those threads; <code>pthread_cond_broadcast()</code> wakes them all, so that if any can proceed, one will.</p>

<p>For example, we might have a mutex protecting two variables <code>x</code> and <code>y</code>.  Some threads wait on this condition:</p>

<pre><code>pthread_mutex_lock(&amp;mutex);
while (x &lt; 10)
    pthread_cond_wait(&amp;cond, &amp;mutex);
</code></pre>

<p>whereas others wait on this condition:</p>

<pre><code>pthread_mutex_lock(&amp;mutex);
while (x &lt; 10 || y &lt; 5)
    pthread_cond_wait(&amp;cond, &amp;mutex);
</code></pre>

<p>If a thread increases <code>x</code> above 10 but leaves <code>y</code> less than 5, then it should use <code>pthread_cond_broadcast(&amp;cond)</code>, because any threads waiting on the second condition aren't ready to run yet, so we have to ensure that at least one thread from the first condition is woken (if there are any waiting on that condition).</p>

<p>The other situation in which <code>pthread_cond_broadcast()</code> can be used is when <em>all</em> waiting threads can proceed (eg. when a group of threads should stop waiting and exit).</p>

<p>One thing to keep in mind for correct code is that <code>pthread_cond_signal()</code> is an optimisation, nothing more - if your code is correct, then it should also work if every <code>pthread_cond_signal()</code> were replaced by <code>pthread_cond_broadcast()</code> (but perhaps not as efficiently).</p>
",0
6352045,6352034,1,"<p><strike>In <code>char* foo(void)</code> you return an invalid pointer, because <code>b</code> ceases to exist when you exit the function.</strike></p>

<p>Both allocations have the same performance <strike>, it's just the way you use them is incorrect</strike>.</p>

<p><code>b</code> is allocated on the stack when the function <code>foo</code> is being called (the performance is of simply changing the value of the stack pointer). It's deallocated when <code>foo</code> is done (by changing the stack pointer, again).</p>

<p><code>a</code> is allocated somewhere (global, I'm guessing, or on stack in some other context), and there's no performance hit there as well.</p>

<p>If you need to allocate memory within your function that should be given to the caller (as in your <code>foo</code>) - then the allocation should be <em>dynamic</em> - using <code>malloc</code> (or <code>new</code> if C++). Then there's indeed a performance hit, depending on the relevant memory manager performance.</p>
",3
6353022,6352034,0,"<p>The answer is ""it depends"". There is no difference in memory allocation cost of a &amp;b. Both have same cache locality properties for the memcpy. </p>

<p>However, You do have a trade-off between using stack space vs using data section.</p>

<p>Cost of allocating space on stack is really same, whether it is one local variable or a 1000 byte array. You just decrement stack pointer by larger number when you set up its stackframe.
b is part of program image and allocated at program load time.</p>

<p>If foo gets called repeatedly you might run into stack size limitation. On the otherhand since a is global, you can use an additional flag and copy into it only once and reuse a.</p>
",1
5496960,5496913,2,"<p>Not really.  C is effectively call-by-value.  If you want different behaviour, you'll have to emulate it manually.</p>
",0
5497047,5496913,4,"<blockquote>
  <p><strong>call-by-value-result definition</strong> </p>
  
  <p>An argument passing convention where
  the actual argument is a variable V
  whose value is copied to a local
  variable L inside the called function
  or procedure. If the procedure
  modifies L, these changes will not
  affect V, which may also be in scope
  inside the procedure, until the
  procedure returns when the final value
  of L is copied to V. Under
  call-by-reference changes to L would
  affect V immediately. Used, for
  example, by BBC BASIC V on the Acorn
  Archimedes.</p>
</blockquote>

<p>Source: <a href=""http://dictionary.reference.com/browse/call-by-value-result"" rel=""nofollow"">http://dictionary.reference.com/browse/call-by-value-result</a></p>

<p>As Oli said, C incorporates call-by-value behaviour.</p>
",0
5617341,5617309,1,"<p>You are leaking memory for first 99 times, as your free call is outside of loop. Only the last allocated memory is freed. </p>
",0
5617343,5617309,0,"<p>You should have as many calls to <code>malloc</code> as to <code>free</code>. Here you call <code>malloc</code> in a loop, which mean that you will have many more calls to it than to <code>free</code>.</p>
",0
5617349,5617309,1,"<p>Each time through the loop you allocation some memory and set <code>pointer</code> to point to it.  When you do that <code>pointer</code> is no longer pointing to the last piece of memory, but it's still allocated to your program.  When you call <code>free(pointer)</code> you're only freeing the last block of memory you allocated.</p>
",0
6645306,6645161,0,"<p>I should make a correction: the address of the array is not passed - it's the address of the array's first element. The simplest way of putting it is:</p>

<p>In C, the value of an array is a pointer to its first element.</p>

<p>If you work with arrays of arrays, you need to supply information about the sizes of arrays after the first dereference:</p>

<pre><code>// either the following or: void foo(char param[][30][20])
void foo(char (*param)[30][20])
{
    // ...
}


int main(void)
{
    // bar is an array of 10 arrays of 30 arrays of 20 chars.
    // its value's TYPE is 'pointer to an array of 30 arrays of 20 chars,
    // which is what foo above requires.
    char bar[10][30][20];

    foo(bar);

}
</code></pre>
",0
6645171,6645161,0,"<p>It is valid syntax, and yes, when passing an array the memory address of the first element is copied, but when you dereference the address, you are modifying the original array.</p>
",0
6645182,6645161,0,"<p>This is the same as the following:</p>

<pre><code>// The array ""char b[2]"" ""decays"" to a pointer ""char *b""
void foo(char *b)
{
    // b[0] == a[0]
    // also, b == a (two addresses, both the same)
}
</code></pre>

<p>You can read up on how arrays and pointers in C behave very similarly (but not <em>exactly</em> the same).  Arrays decay to pointers if they're function arguments (but not anywhere else).  The real gotcha here is that on a 64-bit system, <code>sizeof(b) == 8</code> and <code>sizeof(a) == 2</code>, which is somewhat surprising unless you know about arrays decaying into pointers.</p>
",0
6645186,6645161,0,"<ol>
<li><p>When you declare an array as a function parameter, it is treated as if it were a pointer.  Your <code>foo</code> is completely identical to</p>

<pre><code>void foo(char *b)
{
    ...
}
</code></pre></li>
<li><p>Arrays decay to pointers.  In other words, in some uses (e.g. <code>sizeof(a)</code>) <code>a</code> is an array, but in others where a pointer is expected, the name <code>a</code> <em>means</em> the address of <code>a[0]</code>.</p></li>
</ol>
",0
6645188,6645161,0,"<p><code>b[0] = &amp;a[0]</code> if you do <code>foo(a)</code> as the argument.</p>

<p>If you pass <code>foo((a+1))</code> then <code>b[0] = &amp;a[1]</code> (you shouldn't do that though since <code>b[1]</code> would be undefined) and so on.</p>
",0
6645206,6645161,6,"<p>When you pass an array as a parameter to a function it decays into a pointer, this is defined in the C standard in <code>6.7.1</code>:</p>

<blockquote>
  <p>On  entry   to  the  function    the  value  of  each  argument   expression   shall   be   converted    to  the  type 
  of   its   corresponding     parameter,    as  if   by   assignment    to   the   parameter.     <em>Array    expressions</em>    and 
  function    designators    as  arguments   are  <em>converted    to  pointers</em>    before   the  call.     A   declaration    of   a 
  parameter    as  <strong>¡°array     of   type¡±     shall   be  adjusted    to   ¡°pointer      to   type,</strong>¡±  </p>
</blockquote>

<p>This essentially means that in your function declaration it's equivalent to use</p>

<p><code>void foo(char b[2]);</code> or
<code>void foo(char b[]);</code> or
<code>void foo(char *b)</code></p>

<p>`</p>
",3
6621228,6621219,3,"<p>You can't do that. You could allocate your object on the heap and return a <code>void *</code> to it. Or perhaps you could use a union.</p>
",0
6621243,6621219,2,"<p>You can do this with a macro but only if the type can be determined at compile time. Otherwise you're out of luck.</p>

<p>Since you are trying to declare a variable it follows that <code>foo</code> must be known at compile time.</p>
",0
6622075,6621219,0,"<p>This is fundamentally impossible: types in C need to be known at the time the code is written (that's why you have to write them at all in the first place), and the function cannot 'return' until it runs, which happens after the program has been compiled.</p>

<p>What are you really trying to do? Why do you need <code>variable</code> to be either a <code>char</code> or an <code>int</code> depending on something that happens at runtime? What Bad Thing(TM) happens if we just make it an <code>int</code> and then we never end up assigning it a value that wouldn't fit in a <code>char</code>? We waste 3 bytes on the stack? Oh dear.</p>
",0
6620096,6579592,0,"<p>yes you can copy the value of the type_a into type_b by trying something like </p>

<p>type_b sample_b =*((type_b*)&amp;sample);</p>

<p>or </p>

<p>memcpy(&amp;sample_b,&amp;sample,sizeof(type_a));</p>

<p>Typecasting is nothing but converting an expression of one type to another one. But you seem to be trying to convert the type itself, which is fixed at compile time(variable declaration)</p>

<p>Its not clear the idea behind trying something like this. If you can make it more clear,  people would be able to give more insights</p>
",0
8269547,8269526,8,"<p>I would store it as an integer and only convert to the formatted version with leading zeros on demand when you need to produce output, for example with <code>printf</code>, <code>sprintf</code> etc.</p>

<p>It's far easier that way than storing a string and trying to perform arithmetic on strings. Not least because you have extra formatting requirements about your strings.</p>

<p>If for some reason it is awkward to store an integer as your master data do it like this.</p>

<ol>
<li>Store the string as your master data.</li>
<li>Whenever you need to perform arithmetic, convert from string to integer.</li>
<li>When the arithmetic is complete, convert back to string and store.</li>
</ol>
",2
8269558,8269526,1,"<p>You could store it in a integer variable (provided there's an integer type that's wide enough for your needs). When printing, simply format the number to have the correct number of leading zeros.</p>
",0
8269563,8269526,7,"<p>You should simply store the number using an appropriate type (say, <code>unsigned int</code>), so that doing operations like 'increment by one' are easy - only bother worrying about leading zeros when displaying the number.</p>

<p><code>sprintf</code> can actually do this for you:</p>

<pre><code>unsigned int i = 1;
char buffer[64];
sprintf( buf, ""%014u"", i );
</code></pre>

<p>This prints '00000000000001'.</p>
",8
8269716,8269526,0,"<pre><code>#include &lt;stdlib.h&gt; // for itoa() call
#include &lt;stdio.h&gt;  // for printf() call

int main() {
    int num = 123;
    char buf[5];

    // convert 123 to string [buf]
    itoa(num, buf, 10);

    // print our string
    printf(""%s\n"", buf);

    return 0;
}
</code></pre>
",3
2525954,2525136,1,"<p>Have the caller pass in a pointer to a memory area (an a maximum length) to the function.  That way the caller will be responsible for allocating (and deallocating) the memory, and the function will only provide output constrained to the buffer passed into the function.</p>

<p>Sure the person using the function could still mess things up (by specifying a length that doesn't have anything to do with actual buffer size, but then you can correctly argue it's the caller's fault, not this functions fault.</p>
",0
2525147,2525136,0,"<p>Aside from C++ solutions like using <code>std::string</code>, you could always allocate an array of a set size, and pass the size in as a parameter, and the array as a parameter by reference or as a pointer?</p>

<p>This way the data is allocated in the same scope and there is no memory leakage.</p>

<p>Then again you can always free the memory after calling. It means that the code responsible for creating it and the code responsible for destroying the data are not the same, which can be a precursor to mistakes and errors.</p>
",0
2525156,2525136,0,"<p><b>Allocation and deletion outside the function:</b></p>

<p>Allocate it from stack with char trimmed[SIZE] and pass it to the function or from heap with calloc and pass it to the function.</p>

<p><b>Allocation inside the function and deletion outside:</b></p>

<p>You allocate it inside the function with calloc, but the the caller must free it using free.</p>
",0
2525159,2525136,15,"<p>To address (3) - You can <code>free</code> the newly allocated string from your calling code, once you are finished with it:</p>

<pre><code>char* tmp = trim(myline);

if (tmp != NULL) {
    ....
    free( tmp );
}
</code></pre>

<p>But this places a burden on the caller to remember to free the memory. So instead you might consider passing an allocated buffer and a buffer size to <code>trim()</code>, for example:</p>

<pre><code>void trim(char* line, char *trimmed_buf, int trimmed_buf_len){ ... }
</code></pre>

<p>Neil did an excellent job addressing your other questions. Basically an array declaration <code>char trimmed[len];</code> will declare a local variable on the <b>stack</b>, so while it is syntactically correct to return a <code>char *</code> to this memory, the memory location that it points to will no longer be valid.</p>
",5
2525189,2525136,6,"<p>To answer your specific questions, the syntax:</p>

<pre><code>char trimmed[len];
</code></pre>

<p>where <code>len</code> is a variable, is only allowed in C99, not in C89 or in C++. The return type would indeed be a <code>char *</code>, but returning the local variable <code>trimmed</code> would result in undefined behaviour, so don't do it. And if you allocate an array dynamically in a function via <code>calloc</code> and return it, it is up to the caller of the function to free it, using the pointer that the function returns.</p>
",0
2525200,2525136,0,"<p>Hm, well, answers to your questions:</p>

<ol>
<li>yes, the array would be allocated on the stack, not the heap and would be freed when the function returns.</li>
<li>yes, char[] is mostly equivalent to char*. It is best to keep those separate, as there is a semantic difference.</li>
<li>Using any pointer to the memory, you can use free. In your case, you would free the return the function. That is considered pretty bad form and bug-prone. You usually want the allocat'er to be the free()er.  You could, perhaps, pass in a buffer for the new space, or the caller of the function could agree to have the <code>char * line</code> contents written on top of the existing contents. This works as trim() would always only remove stuff. I think the passed in buffer would work more often and is a good thing to get into the habit of.</li>
</ol>

<p>As for your function, consider using memcpy() or its cousins to copy bytes into and out of a char buffer.</p>
",0
2525213,2525136,1,"<p>Regarding dynamic sizing an array declaration like <code>char trimmed[len];</code> the newest version of the C standard (<a href=""http://en.wikipedia.org/wiki/C_%28programming_language%29#C99"" rel=""nofollow noreferrer"">ISO/IEC 9899:1999</a>) allows this, but for this function it would not help at all. The <code>trimmed</code> variable has its scope within the <code>trim</code> function and it is allocated on the stack. So if you put <code>return trimmed;</code> in your code you return a pointer to a variable on the stack, and the portion of the stack where this variable lives will be released at the point where the function returns, so that will not work out so well...</p>
",0
3726089,3725427,0,"<p>get the source for the ""find"" command from the (i think) gnu package (or a linux source distribution), and copy the appropriate passages for you platform.</p>
",0
4248722,4248709,2,"<p>Probably nonstandard Unsigned Integer 64-bit, or a fixed point 0.64 format.</p>
",0
4248728,4248709,4,"<p>That's an unsigned 64-bit 1.</p>
",0
4248739,4248709,7,"<p>It's not a <strong>type</strong>, it's a 64-bit <strong>constant</strong> integer of value 1.</p>
",0
4249778,4248709,5,"<p>In Microsoft C/C++ The <code>I64</code> part of the expression is a suffix for integer constants that indicates the constant should be a 64-bit type:</p>

<ul>
<li><a href=""http://msdn.microsoft.com/en-us/library/2k2xf226.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/2k2xf226.aspx</a></li>
</ul>

<p>This is a Microsoft extension, even though the docs don't call that out.</p>

<p>A somewhat more portable way to specify such a constant might be to include <code>&lt;stdint.h&gt;</code> and use <code>UINT64_C(1)</code> - MSVC has <code>stdint.h</code> as of VS2010.  </p>

<p>For versions prior to that you might consider the options provided in this SO question: <a href=""https://stackoverflow.com/questions/126279/c99-stdint-h-header-and-ms-visual-studio"">C99 stdint.h header and MS Visual Studio</a></p>
",2
3753173,3752979,3,"<p>I say <code>C89</code> (<code>ANSI C89</code> or <code>ISO C90</code>).</p>

<p>It isn't pre-standard (K&amp;R) C: function definition has type information for parameters inside the declaration.</p>

<p>It follows all rules of the C89 standard and all rules of the C99 standard (*). However, the C99 standard says that <code>main</code> returns 0 if it reaches the closing <code>}</code> without a return statement. So, the guy who wrote this <strong>had to</strong> add the <code>return 0;</code> statement ... or the question doesn't make much sense.</p>

<p>(*) <em>the first 2 printf shoud really have a '\n' (or call <code>fflush(stdout);</code> afterwards) to flush the output</em></p>
",1
3753100,3752979,4,"<p>If you happen to use <code>gcc</code>, with the <code>-std=...</code>, <code>-Wall</code> and <code>-pedantic</code> options you may change the standard that it expects and get warning / errors if the code doesn't comply.</p>
",2
3753106,3752979,2,"<p>K&amp;R C does not include arguments in function declarations.</p>

<p>See, for instance, <a href=""http://en.wikipedia.org/wiki/C_%28programming_language%29#History"" rel=""nofollow noreferrer"">the Wikipedia text on C's history</a>.</p>
",0
3753111,3752979,7,"<p>It's not K&amp;R.  K&amp;R function declarations define arguments outside the parentheses like this:</p>

<pre><code>int mult (a, b)
    int a;
    int b;
</code></pre>

<p>and <code>void</code> was ntroduced with the first ANSI standard.</p>

<p>To me it looks likeit is compliant with both ANSI C89 and C99.</p>
",0
3754719,3752979,0,"<pre><code>#if __STDC_VERSION__ &gt;= 199901L
puts(""C99"");
#else
puts(""C89 or pre C89"");
#endif
</code></pre>

<p>will work for ANSI C compilers.</p>
",0
6357840,6357788,1,"<p>If you write this string from C source code, and you want the output to be <code>\c</code>, then you have to escape the escape character <code>\</code> in your source code.</p>

<pre><code>printf(""\\c"");    // Will print \c in the output
</code></pre>
",0
6357862,6357788,1,"<p>\c means you are escaping the ""c"" character, allowing you to print c
\c means you are escaping the ""\"" character, which allows you to print \c</p>

<p>Escaping a character means that you are making the compiler ignore the character, if it is used for any functions or is reserved within a string.</p>

<p>Ex:</p>

<pre><code>string = ""bla bla \c bla \\c""; 
</code></pre>

<p>printing string will turn out like this:</p>

<pre><code>""bla bla c bla \c""
</code></pre>
",0
5603666,479099,0,"<p>The reason this happens is as follows:
fgets reads up to and <strong>only</strong> up to on less than the value specified in the second parameter. In your case, you ask it to read into an array that can hold than 6 values, so it reads 5 values into this array. Anything left over is then left in the buffer to be read later on - which you then read on line 10.</p>

<p>In terms of discarding values, there's no real way that you can ""flush"" an input buffer, or just clear its contents.
Try the following, to clear the input buffer:</p>

<pre><code>while (getc(stdin) != EOF);
clearerr(stdin);
</code></pre>

<p>Hope this helps.</p>
",0
4231743,4231735,9,"<p>When you have the "","", the expression evaluates to the last expression in the list.</p>

<p>So: 1,3 == 3.</p>

<p>This can also be interpreted as this:</p>

<pre><code>lcn = (ULONG)GetLCN(index);
if (lcn) { .... }
</code></pre>

<p>Why they did this, I can't say.</p>
",2
4231744,4231735,2,"<p><code>a, b</code> evaluates first <code>a</code>, then <code>b</code> and the whole expression has the value of <code>b</code>. So e.g. <code>(false, true)</code> evaluates to true.</p>

<p>The expression you give as an example has the value of <code>lcn</code> after the assignment has been performed. The same thing could be, and more typically is, written <code>if ((var = func()))</code> (the extra parentheses suppress compiler warnings guarding against accidental use of <code>=</code> instead of <code>==</code>).</p>
",0
4231748,4231735,2,"<p>You're seeing C's <a href=""http://msdn.microsoft.com/en-us/library/zs06xbxh.aspx"" rel=""nofollow"">comma operator</a> in action.</p>

<p>Basically, all expressions but the last are evaluated but their results are discarded; then the last is evaluated and returned into the rest of the expression.</p>

<p>So in your case, <code>lcn</code> is being set and then checked (in the <code>if</code> statement).</p>
",0
4231749,4231735,5,"<p>What you're seeing is the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a> in action. When you have</p>

<pre><code>if(expr1, expr2)...
</code></pre>

<p><code>expr1</code> is evaluated and discarded and <code>expr2</code>'s value is used in if statement.</p>
",0
4236674,4236647,1,"<p>Assuming c99:</p>

<pre><code>#include &lt;string.h&gt;
int main(int argc, void **argv)
{
    bool bDrw = false;
    if (argc &gt; 1  &amp;&amp; strcmp(argv[1], ""bDrw"") == 0)
        bDrw = true;
    /* take it from here.... */
    return 0;
}
</code></pre>
",1
4236676,4236647,1,"<p>Try this, assuming you run the program by typing its name followed by <code>Drw</code>:</p>

<pre><code>int main(int argc, char *argv[])
{
...
  if(argc &gt; 1 &amp;&amp; strncmp(""Drw"",argv[1],4) == 0)
  {
     ...  // bDrw is true
  }
...
}
</code></pre>
",0
4236686,4236647,0,"<p>Take a look at this tutorial:</p>

<ul>
<li><a href=""http://wwwx.cs.unc.edu/~sparkst/howto/cpp_main.php"" rel=""nofollow"">http://wwwx.cs.unc.edu/~sparkst/howto/cpp_main.php</a></li>
</ul>
",2
4236690,4236647,0,"<p>For complex argument parsing, you should consider the <a href=""http://www.gnu.org/s/libc/manual/html_node/Getopt.html"" rel=""nofollow""><strong><code>getopt</code></strong></a> library.</p>

<p>However, in this case:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main( int argc, char** argv ) {
    unsigned short int bDrw = 0;

    if ( argc == 2 &amp;&amp; strcmp( argv[1], ""Drw"" ) == 0 ) {
        bDrw = 1;
    }

    printf( ""bDrw = %d\n"", bDrw );

    return 0;
}
</code></pre>
",0
4238188,4238179,36,"<p>Yes, C allows you to call your main function (while C++ <a href=""https://stackoverflow.com/questions/2532912/call-main-itself-in-c"">does not</a> )</p>
",5
4238382,4238179,7,"<p>Yes, we can call the main() within the main() function.</p>

<p>The process of calling a function by the function itself is known as Recursion.</p>

<p>Well,you can call a main() within the main() function ,but you should have a condition that does not call the main() function to terminate the program.</p>

<p>Otherwise,the program will never return and run infinitely.</p>
",2
4243145,4243113,4,"<p>The fact that ch[1234] are characters is not relevant: they are just numeric values.</p>

<p>Just think it's something like this:</p>

<pre><code>ch1 = 0x10;
ch2 = 0x20;
ch3 = 0x30;
ch4 = 0x40;
</code></pre>

<p>your output value will be hex value 0x10203040.</p>
",0
4243151,4243113,-1,"<p>Break it down by steps:</p>

<ol>
<li>It reads 4 8 bit bytes from the file pointed to by <code>hTTF</code> or returns EOF;</li>
<li>If it can read those 4 bytes, it creates a 4 byte value by bit or'ing the 4 bytes together after rotating each it turn. </li>
</ol>
",0
4243179,4243113,2,"<p>What is output is a single int that has four chars inside of it.  You can think of it like this:</p>

<p>My four chars are: <code>0x00, 0x02, 0x53, 0xEF</code></p>

<p>ch1 &lt;&lt; 24 = 0x <strong>00</strong> 000000</p>

<p>ch2 &lt;&lt; 16 = 0x00 <strong>02</strong> 0000</p>

<p>ch3 &lt;&lt; 8 = 0x0000 <strong>53</strong> 00</p>

<p>ch4 = 0x000000 <strong>EF</strong></p>

<p>Next with bitwise ors.</p>

<pre><code>x | 0 = x
1 | x = 1
</code></pre>

<p>So:</p>

<pre><code>0x00000000
0x00020000
0x00005300
0x000000EF
----------
0x000253EF
</code></pre>
",0
4243184,4243113,2,"<p>The return will be a 32 bit value where the most significant 8 bits is ch1, next 8 bits is ch2 and so on. The <code>&lt;&lt;</code> operator is a shift left operator, so if (in binary)</p>

<pre><code>ch1 = 10101010
</code></pre>

<p>then (dots added for readability)</p>

<pre><code>ch1 &lt;&lt; 24 = 10101010.00000000.00000000.00000000 
</code></pre>

<p>and so on. The <code>|</code> operator is an bitwise <strong>OR</strong> operator, so it just combines the variously shifted <code>ch</code> values.</p>
",0
3709234,3709140,3,"<p>Did you verify your code using the sample input and sample output:</p>

<pre><code>Sample Input

1 10
100 200
201 210
900 1000

Sample Output

1 10 20
100 200 125
201 210 89
900 1000 174
</code></pre>

<p>?</p>

<p>The only minor problems I see are:</p>

<pre><code>while (scanf(""%lld %lld"",&amp;p,&amp;q) !=EOF)
</code></pre>

<p>should probably be:</p>

<pre><code>while (scanf(""%lld %lld"", &amp;p, &amp;q) == 2)
</code></pre>

<p>and:</p>

<pre><code>printf(""%lld %lld %lld \r\n"",p,q,max_cycle_length);
</code></pre>

<p>should probably be:</p>

<pre><code>printf(""%lld %lld %lld\n"", p, q, max_cycle_length);
</code></pre>
",1
3709241,3709140,2,"<p>Do the online judges accept <code>C99</code>?</p>

<p><code>long long</code> (and their <code>printf</code> conversion specification) is a <code>C99</code> type. It wasn't defined by the <code>C89</code> standard.</p>
",0
3709336,3709140,0,"<p><code>stdout</code> is opened in text mode by the library even before <code>main</code> starts. That means that the library is responsible for managing the differences in line breaks between your program and the Operating System.</p>

<p>Drop the <code>\r</code> (and extra spaces) from your <code>printf()</code> calls</p>

<pre><code>printf(""%lld %lld %lld\n"", p, q, max_cycle_length);
</code></pre>
",1
2031822,2018706,1,"<p>CMake can help you keep your build portable across several toolchains. However, you still have to deal with the incompatibilities between those at the language and library level.</p>

<p>Which is why I recommend using GCC, the autotools, etc on all platforms. On windows, the GNU toolchain is called MinGW/MSys. Look at MSysGit for an example.</p>
",0
2031978,2018706,2,"<p>For simple console applications (and even more complex ones, like the Qt framework) you can build on Windows using <a href=""http://www.mingw.org"" rel=""nofollow noreferrer"">MinGW</a>. Building with MinGW is pretty similar to building on Linux, and it isn't unlikely that you can use the same <code>Makefile</code> with no or only minor modifications. This has the major advantage that you don't need to maintain two sets of Makefiles / project files.</p>

<p>You can also use <a href=""http://www.cygwin.org/cygwin"" rel=""nofollow noreferrer"">Cygwin</a>, which basically is an emulation layer of the Linux API for the substantial functionality. Using Cygwin however has the disadvantage that it links to its own library <code>cygwin1.dll</code>. This might not be an issue for you as you can simply ship this DLL with your program. You can also suppress using this by using the option <code>-mno-cygwin</code> as compiler option for <code>gcc</code> / <code>g++</code>. However, for some functionality the <code>cygwin1.dll</code> functionality is required.</p>

<p>I can recommend MinGW for building programs on Windows that have originally been written for Linux. I'm using this for various command line programs, and for GUI applications I'm using the <a href=""http://www.trolltech.com"" rel=""nofollow noreferrer"">Qt framework</a> with the MinGW compiler. If you want to build GUI applications you should definitely use a platform independent GUI framework as it makes things much easier.</p>
",0
2037513,2018706,1,"<p>You may be able to use MinGW to cross-compile Windows binaries directly from Linux.  Most of the popular Linux distros now have MinGW packages available that make this very straightforward.</p>

<p>Then you can build all your Windows and Linux binaries in one go, on one machine, from one Makefile.  No need to mess around trying to get GNU Make to work properly in Windows, let alone worry about Visual Studio.</p>
",0
2071715,2071021,3,"<p>The C99 standard is ""better"" in the sense that it is more up-to-date, and offers useful features not found in C89 (VLAs, compound literals, restrict keyword, improved math library,  etc.).  It is not as widely supported as C89, because C89 is ""good enough"" for most jobs, and there isn't the overwhelming demand to move to the new standard like there was when C89 came out (the improvements C99 offers over C89 are fairly incremental, whereas the improvements of C89 over K&amp;R C were significant).  </p>
",0
2082957,2077860,1,"<p>If you're not actually trying to directly map a binary format ""from the wire"", then you probably don't really need a fixed-width type at all.</p>

<p>By way of example, if you're using <code>int32_t</code> just because you need an integer than can store all values in the range <code>-2147483647</code> to <code>2147483647</code>, then a simple <code>long</code> is perfectly portable for that application - it is guaranteed to be at least that wide.</p>

<p>People seem to be inordinately keen on exact-width types.</p>
",0
5591261,5591189,1,"<p>One Problem in the code it that <code>get_raw_c_object( co, &amp;ptrOut);</code> allocates memory with malloc (returned by <code>ptrOut</code>) yet you never free that memory!</p>

<p>I don't exactly know what you are trying to achive but take a look at the following <em>pseudo C/C++</em> code. Maybe it can help you:</p>

<pre><code>typedef struct Variadic {
    enum DataType type;
    union {
        char charData;
        short shortData;
        int intData;
        unsigned int uintData;
        char *charPtrData;
        [...]
    } data;
};

// functions for allocation and destruction
Variadic* new_variadic();
void      delete_variadic(Variadic*);

// using the variadic
Variadic *a = new_variadic;
a-&gt;type = TYPE_INT;
a-&gt;data.intData = 10;
</code></pre>

<p>In case of a <code>char*</code> string <code>delete_variadic</code> would also delete the contained string.</p>
",3
5591334,5591189,0,"<p>You do really much copying with your objects. So I hope that all the types you want to store support being copied. One counter-example that comes to mind is a node of a doubly linked list, because there are some pointers outside that point to that exact address.</p>

<p>But as long as your data is not referenced from the outside, this works. You also need to make sure that your program has enough memory available, otherwise you run into <em>undefined behavior</em> as soon as malloc returns NULL.</p>

<p>In the <code>delete_c_object</code> function you don't need to zero out <code>inObject</code>. That statement has no effect at all.</p>

<p>The section for the integer pointer is missing one level of pointers. It looks just like the integer section.</p>
",2
5496285,5496211,0,"<p>Your example array holds items of type (void*). It holds pointers.  You seem to be wanting it to hold arbitrary types. In this case and int.  Do you want to store copies of inserted data or to simply store pointers given to you by the caller?</p>

<p>A while ago I wanted simple array like behavour for a game I was writing and came up with <a href=""https://github.com/inorton/xrlist"" rel=""nofollow"">xrlist</a>. A while later I wanted to store them and randomly access them so came up with <a href=""https://github.com/inorton/xrhash"" rel=""nofollow"">xrhash</a>.</p>

<p>xrlist and xrhash store user supplied pointers and expect all elements to be of the same type (xrhash has a hashcode and comparison callback function )</p>
",0
5496290,5496211,0,"<p>You might be better served allocating a small chunk of memory (perhaps to hold unions) in the beginning, and pushing back elements until you fill it up.  Then either realloc, or allocate an array twice the size and copy everything over.  </p>
",0
5496293,5496211,2,"<p>It is possible, if you provide a version of push_back_c_array() that will copy the value provided. For this you'll need an extra argument, that specifies the size of the value:</p>

<pre><code>push_back_c_array(c_array* arr, void* val, unsigned int size);
</code></pre>

<p>You allocate memory in heap for the new value and then do memcpy. But after that you'll need to deallocate it back. So, you'll need to remember, which values are allocated by you, and which ones - by the caller. Rather nasty... So, if you do that - do that always, and describe this convention in the documenation to your function.</p>
",7
5496496,5496211,0,"<p>you example whit a=5 should work as long as you will use integers or any other type that has same size as int. User of generic array will want to push structs, just like your. But, big elements can not/should not should not be passed by value, but its pointer should be passed.</p>

<p>using generic and no being bounded on sizeof(int) bring some extra effort from user. I think that best solution is that you pass allocated pointer (void*) in function and whoever wants to take this element out, should free() this struct.</p>
",1
2922782,2922703,2,"<p>Hmm...as a first approximation, to read a single number, consider using <code>fscanf(""%d"", &amp;number);</code>. To store the numbers you read, you'll probably want to create an array of numbers (e.g., <code>int numbers[100];</code>). To read more than one number, use a loop to read the numbers into the array.</p>

<p>Sidenote: <code>fscanf</code> isn't particularly forgiving of errors in the input (among other things) so for production code, you probably want to read a string, and parse numbers out of that, but for now, it looks like you probably just need to get something that works for correct input, not worry about handling incorrect input gracefully.</p>
",0
2922922,2922703,2,"<p>Your (first) problem is here:</p>

<pre><code>d[count1]='/0';
strcpy(&amp;array[count],d);
</code></pre>

<p>You have written <code>'/0'</code>, which isn't what you think it is.  Assuming you meant <code>'\0'</code> (a null <code>char</code> literal), then you appear to be trying to manually terminate the string <code>d</code> before calling <code>strcpy()</code>.  The problem is that what actually gets written to <code>d</code> is not a null byte, and so <code>d</code> is not null-terminated, and then <code>strcpy()</code> goes off and starts reading random memory after it, and copying that memory into <code>array</code>, until either the reading or the writing ends up outside of memory you're allowed to access, and you get a segmentation fault.</p>

<p>You also have some confusion about that <code>array</code> is.  It's declared as an array of 100 <code>char</code>s, but you're treating it like it's an array of strings.  Perhaps you meant to declare it as <code>char *array[100]</code> ?</p>
",0
2922965,2922703,0,"<p>Is this actually how the code is written?</p>

<p>In <code>d[count1]='/0';</code> I think you mean <code>d[count1]='\0';</code> (already mentioned by Daniel Pryden).</p>

<p>There is also a semicolon missing at the end of <code>memset(d,'\0',100)</code> </p>
",0
2922857,2922840,5,"<p>There's no such thing as a string data type in C.  But to your question, you can use <strong>int atoi ( const char * str )</strong> and remember to include <strong>&lt;stdlib.h></strong></p>
",1
2922944,2922840,1,"<p>You can't cast a char array/const char * into an integer in C, at least not in a way that gives you a sensible integer result[1]. The only exception is if you use it to convert a single char into an integer, which is basically just widening it if you look at the bit representation.</p>

<p>The only way you can do the proper conversion functions like <code>atoi</code> or <code>sscanf</code>.</p>

<p>[1] Yes, I know you can convert a pointer (const char *) into an integer, but that converts the value of the pointer and not the value of the data it points to.</p>
",1
2925545,2922840,2,"<p>C doesn't have strings but it does have char arrays (which we often call strings), such as:</p>

<pre><code>char someChars[] = ""12345"";
</code></pre>

<p>You can convert (not the same as type cast) the contents of the character array to an int like this:</p>

<pre><code>int result;
sscanf(someChars, ""%d"", &amp;result);
</code></pre>

<p>Or using atoi:</p>

<pre><code>int result = atoi( someChars );
</code></pre>

<p>Type casting is like taking a bottle of Coke and putting a Pepsi label on the bottle.
<br>Type conversion is like pouring a bottle of Coke into an Pepsi can.  Maybe it will fit.</p>
",0
5602097,5602072,2,"<p><code>stdin</code> <em>is</em> a variable of type <code>FILE *</code>, it's defined in <a href=""http://en.wikipedia.org/wiki/Stdio.h"" rel=""nofollow""><code>&lt;stdio.h&gt;</code></a>.
It's used to read data from <a href=""http://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29"" rel=""nofollow"">standard input</a>.</p>
",0
2029564,2029428,0,"<p>Have you tried going through the compiler errors and understanding what they mean?</p>

<p>From a cursory glance, here's where I think the problem is. The compiler error is:</p>

<blockquote>
  <p>error LNK2019: unresolved external symbol _<strong>artLength</strong> referenced in function _<strong>spellCheck</strong></p>
</blockquote>

<p>Which basically means the compiler is looking for a function called artLength, called from function spellCheck. However, it's not finding it.</p>

<p>It seems like you have a function called <code>articleLength</code>, which may be what you meant to write?</p>

<p>I would definitely advise you, however, to go over all the other output from your compiler and try to understand what it means. A lot of it is basically telling you that the compiler can't find certain functions, which is because you're calling them before you actually write them.</p>
",0
2029448,2029428,0,"<p>Not much information to go on - in future you need to post the actual error messages you are getting. However, you definitely need to move your function declarations so they appear in the code before the main() function.</p>
",0
2029782,2029428,1,"<p>You have made a forward declaration:</p>

<pre><code>int artLength( char article[]); 
</code></pre>

<p>but your actual implementation is:</p>

<pre><code>int articleLength( char article[]); 
</code></pre>

<p>Make them identical (change either one of them) and your project will compile.</p>
",0
2040077,2039953,0,"<p>Hint: Read about <a href=""http://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow noreferrer"">buffer overflow</a> exploits.</p>
",0
2040078,2039953,2,"<p>What you want to do is <strong>overflow the input</strong> such that the program will return into a set of instructions you have overwritten at the return address. </p>

<p>The problem lies here:</p>

<pre><code>  int x[2]; // array to hold input values
</code></pre>

<p>By passing more than 3 values in, you can overwrite memory that you shouldn't. Explaining the sample example:</p>

<ol>
<li>First input -559,038,737 puts xDEADBEEF in memory</li>
<li>Second input -559,038,737, why not.</li>
<li>Third number -559,038,737 can't hurt</li>
<li>Fourth number 8992 is the address we want the function to return into.</li>
</ol>

<p>When the function call returns, it will return to the address overwrote the return address on the stack with (8992). </p>

<p>Here are some handy resources, and an excerpt:</p>

<p>The actual buffer-overflow hack work slike this:</p>

<ol>
<li><p>Find code with overflow potential.</p></li>
<li><p>Put the code to be executed in the
buffer, i.e., on the stack. </p></li>
<li>Point the return address to the same code
you have just put on the stack.</li>
</ol>

<p>Also a good book on the topic is ""<a href=""http://nostarch.com/hacking2.htm"" rel=""nofollow noreferrer"">Hacking: The art of exploitation</a>"" if you like messing around with stacks and calling procedures.</p>

<p>In your case, it seems they are looking for you to encode your instructions in integers passed to the input. </p>

<p><a href=""http://www.linuxjournal.com/article/2902"" rel=""nofollow noreferrer"">An article on buffer overflowing</a></p>
",1
3012145,3012113,0,"<p>Usually that's ordinary process virtual memory with write protection set.</p>

<p>That's implementation-dependent, but processors usually use special metadata blocks for controlling access to memory regions and the operating system can set those accordingly. So the string literals and all other unchangeable stuff is loaded into a region that is set protection on. So when the program tries to modify that memory a special unit inside the processor checks whther that write is allowed and if it is not wllowed issues a hardware interrupt that is handled by the operating system.</p>
",0
3012146,3012113,3,"<p>It is usually done with hardware assistance.</p>

<p>The virtual memory subsystem of the hardware can be told to mark a page as read-only.  When an application tries to write a read-only page, the hardware generates a fault that the OS catches.  The OS can tell that the app tried to write a read-only page and end your program.</p>

<p>So the OS/loader makes sure the pages the string literals are in are marked as read-only.</p>

<p>The heap and read-only memory are orthogonal issues.</p>
",0
3012451,3012113,0,"<p>From an hw point of view RAM is RAM and it can be R/W. The ""read-only"" memory is an attribute put by software; on some architecture (almost all we're used to) there is hardware support to make a portion of memory not writable (in the sense that when you try to access an address inside that memory, an ""exception"" occurs).</p>
",0
3012642,3012113,1,"<p>It's OS and hardware dependent. The spec says they <em>can</em> be placed in read-only memory, rather than they have to be. If you're writing C for a simple embedded device, then the strings get blown into the rom and runtime memory is allocated from the RAM; these are physically separate (<a href=""http://en.wikipedia.org/wiki/Harvard_architecture"" rel=""nofollow noreferrer"">Harvard</a>). If it's a typical unix-like computer, then there is virtual memory subsystem which converts logical addresses to physical addresses in pages and can mark some pages read-only and some executable, but the memory itself can be either data or instructions (<a href=""http://en.wikipedia.org/wiki/Von_Neumann_architecture#Non-von_Neumann_processors"" rel=""nofollow noreferrer"">Von Neumann</a>).  </p>
",0
5145362,5144845,1,"<p>Concepts at work here: <strong>modifiable lvalue</strong> and <strong>compound literals vs. initializers</strong>.</p>

<p>An array is not considered a <strong>modifiable lvalue</strong>, and so the following will never work:</p>

<pre><code>int i[];
int j[];
i = j;</code></pre>

<p>This includes the case where the right-hand side of the assignment is a <strong>compound literal</strong> like you are using.</p>

<p><strong>Compound literals</strong> look a lot like <strong>initializers</strong> but they are two different concepts with similar syntax.  Initializers appear with definitions, whereas compound literals can appear in arbitrary expressions.</p>

<p>Since a pointer is a <strong>modifiable lvalue</strong>, you can assign a <strong>compound literal</strong> to it:</p>

<pre><code>char** array;
array = (char* []) {""zero"", ""one"", ""two""};</code></pre>
",2
5144902,5144845,3,"<p>No -- the initialization syntax <em>only</em> works for initialization, not assignment, so it <em>must</em> be part of the array definition, not afterwards. Afterwards, what you'd have would be assigning an array instead of truly initializing it, and C does not support array assignment.</p>
",0
5144964,5144845,2,"<p>As @Jerry says, you cannot do this for an array. Your question mentions structures, and you can do it for a structure. e.g.</p>

<pre><code>struct mystruct {
   int a;
   int b;
};

struct mystruct mystruct;

mystruct = (struct mystruct){1, 2};
</code></pre>

<p>will assign mystruct.a to 1 and mystruct.b to 2</p>
",2
5144982,5144845,2,"<p>Short answer: no, you can't.</p>

<p>When initialising a non-static array like this, the compiler has to generate code to copy the initial state of the array out of storage and into the new array. (Because it's a <em>new</em> array every time you call the function.) It's not actually much slower to write code to do this yourself.</p>

<p>Long answer: if you're willing to be evil, you can sort of do it, in C99, by wrapping the array in a struct and using structure assignment...</p>

<pre><code>struct arrayWrapper
{
  char* array[4];
};

{
  struct arrayWrapper d;
  ...
  d = (struct arrayWrapper){{1, 2, 3, 4}};
}
</code></pre>

<p>(syntax may not be quite right.)</p>

<p>But that's evil, and only works in C99, so don't do it, mmm'kay?</p>
",6
5144991,5144845,0,"<p>The answer for Array as Jerry has given is correct it it not for a structure.</p>

<pre><code>    #include &lt;stdio.h&gt;

struct foo {
  int v1;
  int v2;
};


int main(void){
  struct foo v1, v2;

  v1.v1 = 1;
  v1.v2 = 2;
  v2 = v1;

  printf(""v2.v1 = %d, v2.v2 = %d\n"", v2.v1, v2.v1);
  return 0;
}
</code></pre>
",0
6103936,6103623,1,"<p>If I understand your question, you're curious about which kinds of variables get placed into which kinds of <a href=""http://en.wikipedia.org/wiki/Data_segment"" rel=""nofollow"">data segments</a>.</p>

<p>Uninitialized global variables and function-level <code>static</code> variables go into the <code>bss</code> section, which is really just a number in the object file telling the linker/loader how much space to set aside for the section when loading the program or library:</p>

<pre><code>$ readelf --sections /bin/sh
There are 28 section headers, starting at offset 0x195e8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
...
  [26] .bss              NOBITS           0000000000619500  00019500
       0000000000002bd0  0000000000000000  WA       0     0     32
</code></pre>

<p>That's 0x2bd0 == 11216 bytes to be set aside at runtime for uninitialized variables.</p>

<p>Global variables that are initialized are stored into the <code>data</code> or <code>rodata</code> section:</p>

<pre><code>$ readelf --sections /bin/sh
There are 28 section headers, starting at offset 0x195e8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
...
  [16] .rodata           PROGBITS         0000000000412de0  00012de0
       0000000000003482  0000000000000000   A       0     0     32
...
  [25] .data             PROGBITS         0000000000619300  00019300
       0000000000000200  0000000000000000  WA       0     0     32
</code></pre>

<p>Sorry, I've forgotten the exact rules the compiler / linker use to decide which variables go into the read only section and which variables go into the read / write section. But suffice to say that the linker will set the page protections to <em>read only</em> for the <code>rodata</code> section, and attempts to write to this section will generate a page fault and probably terminate the program.</p>

<pre><code>char *string = ""hello world""; /* ""hello world\0"" goes into rodata
                                 char *string goes into data */
</code></pre>

<p>I would expect any computation based solely on literal integers, floating point, and <code>sizeof()</code> operations to be computed at compile-time.</p>

<p>A very small example:</p>

<pre><code>$ cat test.c
int i;
int main(int argc, char *argv[]) {
    return 0;
}
$ gcc -o test test.c
$ size test
   text    data     bss     dec     hex filename
   1044     496      24    1564     61c test
</code></pre>

<p>The C library brings along a <em>lot</em> of extra baggage. But notice what happens when we initialize <code>i</code>, the <code>bss</code> size goes down, the <code>data</code> size goes up:</p>

<pre><code>$ cat test.c
int i=1+2;
int main(int argc, char *argv[]) {
    return 0;
}
$ gcc -o test test.c
$ size test
   text    data     bss     dec     hex filename
   1044     500      16    1560     618 test
$ 
</code></pre>

<p>I assume the <code>bss</code> is constrained to a multiple of <code>8</code> on my system, because it is an AMD64-compliant CPU. Other systems might require a multiple of <code>4</code>.</p>

<pre><code>$ cat test.c
int i=sizeof(int);
int main(int argc, char *argv[]) {
    return 0;
}
$ gcc -o test test.c
$ size test
   text    data     bss     dec     hex filename
   1044     500      16    1560     618 test
$ 
</code></pre>

<p>Note that switching to <code>sizeof(int)</code> didn't increase the <code>text</code> (executable code) size, and didn't change the <code>data</code> size either.</p>
",0
6103656,6103623,3,"<p><em>Some basic principles of optimization:</em></p>

<ul>
<li>only optimize measured (profiled) bottlenecks, don't waste time optimizing imaginary or hypothetical issues, unless you are a subject-matter expert who is reimplementing a known compute-time issue</li>
<li>don't optimize anything unless it's in a loop</li>
</ul>

<p>But to answer your question...</p>

<p><em>Always at compile time:</em></p>

<ul>
<li>static initialization</li>
<li><code>#if</code> and other preprocessor macro expressions</li>
</ul>

<p><em>Usually at compile time:</em></p>

<ul>
<li>Any expression involving only constants</li>
</ul>
",12
3986307,3986295,4,"<p>Yes, this is a no-op function.</p>

<p>The casting is a common trick to prevent the compiler complaining about unused parameters.</p>
",0
3986319,3986295,14,"<p>That's indeed a no-op. The casts to <code>(void)</code> are here to avoid getting ""parameter never used"" warnings with some compilers (the casts are optimized away, but the parameters are still considered as ""used"").</p>

<p>You can pass <code>NULL</code> since the parameters are ignored anyway.</p>
",0
3986321,3986295,0,"<p>That is not no-op. Like that you tell the compiler to ignore those two arguments.</p>
",0
3990234,3986295,3,"<p>Yes, this is a no-op function and <code>void</code> casted lines are placed to avoid the ""unused parameter"" warning. For gcc, search for ""unused"" in the page: <a href=""http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html</a></p>

<p>However, <strong>if it were C++ instead of C</strong>, I would probably write it little differently as</p>

<pre><code>static void llist_dtor( void * /* user */, void * /* element */ )
{
  /* Do nothing */
}
</code></pre>

<p>Note that the variable names are commented out.</p>
",2
3700292,3700198,0,"<p>For 3 floats at a time that's all nice and good.</p>

<p>If you think your program is running slow, make sure the copying is responsible for the slowness before trying to ""make it better"".</p>
",0
3700416,3700198,2,"<p>If you always calloc exactly <code>1</code> array, you can only index the array pointer with <code>0</code> anyway. What's the reason for not taking <code>float*</code> then and omitting the one index step?</p>

<pre><code>typedef float *el_i;
el_i data_i[NTIMES];
for (i = 0; i &lt; ntimes; i++) data_i[i] = (el_i)calloc(1, sizeof(float[3]));

for (i = 0; i &lt; ntimes; i++){
  data_i[i][0]=data[i][0];
  data_i[i][1]=data[i][1];
  data_i[i][2]=data[i][2];
}
</code></pre>

<p>I don't really see the whole purpose of this. </p>
",1
3074028,3074026,9,"<p>If we call the malloc'ed variable <code>x</code>, then your program does this:</p>

<pre><code>                                      n     x
int *n = malloc(sizeof(int));        &amp;x     ?
*n = 10;                             &amp;x    10
n++;                                &amp;x+1   10
</code></pre>

<p>You want to do this:</p>

<pre><code>                                      n     x
int *n = malloc(sizeof(int));        &amp;x     ?
*n = 10;                             &amp;x    10
(*n)++;                              &amp;x    11
</code></pre>
",5
3074029,3074026,25,"<p><code>n++</code> increments the pointer <code>n</code>, not the integer pointed to by <code>n</code>.  To increment the integer, you need to dereference the pointer and then increment the result of that:</p>

<pre><code>(*n)++;
</code></pre>
",2
3074114,3074026,2,"<p>You set n[0] to 10, and then you print n[1].  malloc() does not initialize the memory that it gives you, so what gets printed is unpredictable - it's whatever garbage happened to be in n[1].</p>
",2
3074131,3074026,2,"<p>You can get 11 as your output with this code:</p>

<pre><code>void foo {
    int *n = malloc(sizeof(int)); 
    *n = 10; 
    (*n)++; 
    printf(""%d"", *n)
}
</code></pre>
",0
3074135,3074026,1,"<p>n++ moves the pointer sizeof(int) bytes forward.</p>
",0
1999886,1999856,2,"<p>You must read <a href=""https://rads.stackoverflow.com/amzn/click/com/0131774298"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Expert C Programming </a> by Peter van der Linden.<br><br>
<img src=""https://3.bp.blogspot.com/_zQuhcRo8NtU/SEjSyjiKAYI/AAAAAAAAAAs/pBvzzgOQzOI/s320/New%2BPicture.bmp"" alt=""alt text""></p>
",5
1999915,1999856,3,"<p>The same principles for OOP apply to C, with the exception you don't have classes. However, an idea which is applicable to C, of which OOP is an implementation, is the concept of Abstract Data Structures - ADT. </p>

<p>The book ""Data Structures and Algorithms"" is a classic and should be read.</p>

<p><a href=""http://www.amazon.ca/Data-Structures-Algorithms-Alfred-Aho/dp/0201000237"" rel=""nofollow noreferrer"">http://www.amazon.ca/Data-Structures-Algorithms-Alfred-Aho/dp/0201000237</a></p>

<p>In general, the same principles that apply to OOP, can be applied to ADT. Read design books for principles, not details.</p>
",2
1999958,1999856,7,"<p>If you want a more C specific book then you could look at <strong>The Practice of Programming</strong> by Kernighan and Pike.</p>

<p>NB: I've always thought of OOP as a way of looking at design; the fact that some languages provide explicit support for it is nice but not esssential.</p>
",1
1999965,1999856,1,"<p>Here is a PDF on object oriented C.  This article is fairly old, but worth a read.</p>

<p><a href=""http://www.planetpdf.com/codecuts/pdfs/ooc.pdf"" rel=""nofollow noreferrer"">http://www.planetpdf.com/codecuts/pdfs/ooc.pdf</a></p>
",0
1999978,1999856,4,"<p><a href=""https://rads.stackoverflow.com/amzn/click/com/1556155514"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Writing solid code</a></p>
",1
1999984,1999856,8,"<p>G'day,</p>

<p>While heavily focused on C++, John Lakos's excellent book ""<a href=""https://rads.stackoverflow.com/amzn/click/com/0201633620"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Large-Scale C++ Software Design</a>"" has a lot of information that is very relevant to the design of software written in C.</p>

<p><strong>Edit:</strong> Oooh. After seeing @Jackson's suggestion for the excellent ""The Practice of Programming"" I'd also highly recommend Eric Raymond's excellent book ""<a href=""https://rads.stackoverflow.com/amzn/click/com/0131429019"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">The Art of UNIX Programming.</a>"". Thanks for the reminder @Jackson.</p>

<p>HTH</p>

<p>cheers,</p>
",2
2000019,1999856,5,"<ol>
<li><a href=""http://c-faq.com/index.html"" rel=""noreferrer"">C FAQ</a></li>
<li><a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""noreferrer"" rel=""nofollow noreferrer"">K &amp; R</a></li>
<li>Linux kernel source code</li>
</ol>
",4
2000179,1999856,4,"<p>I know sometimes it can't be avoided, and that is probably your situation, but you <strong>shouldn't</strong> be using C for large projects if you can at all help it.</p>

<p>I know this is the kind of statement that leads to knee-jerk responses from fans, but for everybody else, including the language's own authors, it is an obvious fact. For instance, here's an excerpt from the history the the DoD's <a href=""http://archive.adaic.com/pol-hist/history/holwg-93/2.htm"" rel=""nofollow noreferrer"">search for a language</a> to support way back in the late 70's (the <a href=""http://archive.adaic.com/pol-hist/history/holwg-93/2.htm"" rel=""nofollow noreferrer"">High Order Language Working Group</a>):</p>

<blockquote>
  <p>Other languages were considered for formal evaluation, but were not included because preliminary examination led one to believe that they would not meet the requirements so were not viable candidates for the purposes of the DoD. One such language was C. At that time DARPA was working with Western Electric/Bell Labs on UNIX, contractually supporting some DARPA contractors and other government facilities using UNIX. It was the evaluation policy to have the owners provide assessments of their own languages, in addition to the contracted evaluations, so HOLWG took advantage of this connection between DARPA and Bell Labs to request their cooperation. <strong>When Bell Labs were invited to evaluate C against the DoD requirements, they said that there was no chance of C meeting the requirements of readability, safety, etc., for which we were striving, and that it should not even be on the list of evaluated languages.</strong> We recognized the truth in their observation and honored their request. </p>
</blockquote>
",0
2003607,1999856,6,"<p>Dave Hanson's book <a href=""http://www.cs.princeton.edu/software/cii"" rel=""noreferrer"">C Interfaces and Implementations</a> is a wonderful example of how to do large-scale programming in C: by dividing your system into interfaces and implementations.  At one go, the book provides good examples and also useful building blocks.   For people who have been around, this is very much a rebadging of object-oriented design as practiced by Barbara Liskov (who recently won the Turing Award for it).  Think of it as OO programming but without inheritance.</p>

<p>A terrific book for anybody who has to write C.</p>
",1
2048692,1999856,1,"<p>The Cheshire Cat idiom is a useful way of reducing coupling in C and is very helpful when designing large projects. </p>

<p><a href=""http://en.wikipedia.org/wiki/Cheshire_Cat_Idiom_(programming_technique)#C"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Cheshire_Cat_Idiom_(programming_technique)#C</a></p>
",0
2268678,2268149,1,"<p>Will it work: Yes.</p>

<p>Is it conformant: No.</p>

<p>According to the C Standard:  </p>

<blockquote>
  <p><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow noreferrer"">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf</a>  </p>
</blockquote>

<p>All names in the standard library are reserved (including malloc).</p>

<pre><code>7.1.3 Reserved identifiers
Specifically:  
    &lt;quote&gt;Each macro name in any of the following subclauses&lt;/quote&gt;
    &lt;quote&gt;All identifiers with external linkage in any of the
    following subclauses&lt;/quote&gt;
</code></pre>

<p>Also a strictly conforming program will can not define names that are reserved for the implementation (i.e. This includes reserved names and idnetifiers, those for current libraries and those reserved for future use).</p>

<pre><code>7.1.3 (note 2)
Specifically:
    &lt;quote&gt;If the program declares or defines an identifier in a context in which
    it is reserved or defines a reserved identifier as a macro name,
    the behavior is undefined.&lt;/quote&gt;
</code></pre>

<p>Thus by definition: defining malloc() is non conformant because it is undefined behavior (Illegal).</p>
",1
2268778,2268149,0,"<p>Macro identifiers are proper names, and all library identifiers of any kind are forbidden from aliasing to a macro regardless of the linguistic status of macros.</p>

<p>¡ì6.10.3/7</p>

<blockquote>
  <p>The identifier immediately following
  the define is called the macro name.
  There is one name space for macro
  names.</p>
</blockquote>

<p>¡ì7.1.3/1</p>

<blockquote>
  <p>Each identifier with file scope listed
  in any of the following subclauses
  (including the future library
  directions) is reserved for use as a
  macro name and as an identifier with
  file scope in the same name space if
  any of its associated headers is
  included.</p>
</blockquote>

<p>¡ì7.1.3/2</p>

<blockquote>
  <p>If the program declares or defines an
  identifier in a context in which it is
  reserved (other than as allowed by
  7.1.4), or defines a reserved identifier as a macro name, the
  behavior is undefined.</p>
</blockquote>
",5
2268173,2268149,3,"<p>You will want to change <code>journalling_malloc(...)</code> from <code>void</code> to <code>void *</code>, change the comments to // (because they are commenting out your undef) and add a <code>#endif</code> near the top,  but otherwise it looks fine. </p>
",2
2268965,2268149,11,"<p>Let's look at what the C99 standard has to say about it:</p>

<p>See 7.1.3, ¡ì1, clause 5:</p>

<blockquote>
  <p>Each identifier with file scope listed in any of the following subclauses [...] is <strong>reserved for use as a macro name</strong> and as an identifier with file scope in the same name space <strong>if any of its associated headers is included</strong>.</p>
</blockquote>

<p>As you include <code>stdlib.h</code>, the name <code>malloc</code> is reserved for use as a macro name.</p>

<p>But 7.1.4, ¡ì1 allows using <code>#undef</code> on reserved names:</p>

<blockquote>
  <p>The use of <code>#undef</code> to remove any macro definition will also ensure that an
  actual function is referred to.</p>
</blockquote>

<p>This makes it possible to re-<code>#define</code> <code>malloc</code>, which results in undefined behaviour according to  7.1.3, ¡ì2:</p>

<blockquote>
  <p>If the program [...] defines a reserved identifier as a macro name, <strong>the behavior is undefined</strong>.</p>
</blockquote>

<p>Why does the standard make this restriction? Because other functions of the standard library may be implemented as function-like macros in terms of the original function, so hiding the declaration might break these other functions.</p>

<p>In practice, you should be fine as long as your definition of <code>malloc</code> satisfies all provisions the standard provides for the library function, which can be achieved by wrapping an actual call to <code>malloc()</code>.</p>
",3
2029175,2029156,13,"<p>The same reason <code>1;</code> would compile,  <code>getchar</code> is just an address to a function.  The result is evaluated, then discarded.  In the language specification, it's called an ""expression statement"";</p>
",0
2029176,2029156,28,"<p>Because function names are aliases to function pointers to those functions, which are themselves values much like integers..  This is semantically very similar to </p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    42;
}
</code></pre>

<p>It is valid but pointless.</p>
",9
8393898,8393886,3,"<p>That's the meaning of ""Formatted"". You used qualifier <code>%d</code> which means ""format the given value as its <strike>ASCII</strike> numeric representation <em>in the execution character set</em>, assuming the value is a signed integer"".</p>

<p>If you want to write binary data into a file - <strong>don't</strong> use formatted output. Use <a href=""http://linux.die.net/man/3/fwrite"" rel=""nofollow""><code>fwrite</code></a> instead to write raw binary data.</p>
",4
8393906,8393886,5,"<p>Use <code>fwrite</code>:</p>

<pre><code>uint32_t n = 578;
fwrite(&amp;n, sizeof n, 1, fp);
</code></pre>

<p><code>fprintf</code> is for <em>formatted</em> output, whence the trailing <code>f</code>.</p>
",3
8393908,8393886,1,"<p>You'll want to look at <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fwrite/"" rel=""nofollow"">fwrite</a>. </p>

<pre><code>int myNum = 578;
fwrite( &amp;myNum, sizeof(int), 1, fp);
</code></pre>
",5
8393951,8393886,1,"<p>If you want to write raw data to a file using the standard IO facilities, you're looking for <code>fwrite(3)</code>:</p>

<pre><code>$ cat numbers.c
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {
    int i = 578;
    long l = 578;
    float f = 5.78;
    double d = .578;
    long marker = 0xFFFFFFFFFFFFFFFF;


    FILE *fp = fopen(""data"", ""w"");
    fwrite(&amp;i, sizeof i, 1, fp);
    fwrite(&amp;marker, sizeof marker, 1, fp);
    fwrite(&amp;l, sizeof l, 1, fp);
    fwrite(&amp;marker, sizeof marker, 1, fp);
    fwrite(&amp;f, sizeof f, 1, fp);
    fwrite(&amp;marker, sizeof marker, 1, fp);
    fwrite(&amp;d, sizeof d, 1, fp);
    fclose(fp);
    return 0;
}
$ make numbers
cc     numbers.c   -o numbers
$ ./numbers 
$ xxd data
0000000: 4202 0000 ffff ffff ffff ffff 4202 0000  B...........B...
0000010: 0000 0000 ffff ffff ffff ffff c3f5 b840  ...............@
0000020: ffff ffff ffff ffff e5d0 22db f97e e23f  ..........""..~.?
$ xxd -b data
0000000: 01000010 00000010 00000000 00000000 11111111 11111111  B.....
0000006: 11111111 11111111 11111111 11111111 11111111 11111111  ......
000000c: 01000010 00000010 00000000 00000000 00000000 00000000  B.....
0000012: 00000000 00000000 11111111 11111111 11111111 11111111  ......
0000018: 11111111 11111111 11111111 11111111 11000011 11110101  ......
000001e: 10111000 01000000 11111111 11111111 11111111 11111111  .@....
0000024: 11111111 11111111 11111111 11111111 11100101 11010000  ......
000002a: 00100010 11011011 11111001 01111110 11100010 00111111  ""..~.?
$ 
</code></pre>
",0
8394161,8394127,1,"<p><code>-g</code> (for <code>gcc</code>) stores debugging information in the output files so that debuggers can pick it up and present more useful information during the debugging process. Exactly <em>what</em> gets stored can depend a great deal on the environment you're running in.</p>

<p>One way to look at what this consists of is to use <code>objdump</code> with the <code>--debugging</code> option (or its equivalent short form <code>-g</code> which matches <code>gcc</code>).</p>
",1
8394188,8394127,1,"<p>The <code>-g</code> command line option asks the compiler to emit additional debugging information; on Linux, the format is <a href=""http://dwarfstd.org/"" rel=""nofollow"">DWARF 2</a>, but other platforms may have different defaults -- <a href=""http://en.wikipedia.org/wiki/Stabs"" rel=""nofollow"">stabs</a> was more common, once upon a time.</p>

<p><code>readelf --debug-dump</code> can be used to dump the debugging information itself if you're curious in what it adds -- you can see the entire program source in the <code>.debug_info</code> section, for example.</p>
",0
4251351,4251335,0,"<p>You're looking at 8-bit values. I bet that pktNum and invPktNum are 32-bit values, so you're comparing 0x000000fe to 0xfffffffe.</p>
",4
4251390,4251335,-1,"<p>Assuming the following:</p>

<pre><code>invPktNum = ~pktNum
</code></pre>

<p>then your comparison is equivalent to:</p>

<pre><code>if (pktNum != ~(~pktNum)) {
</code></pre>

<p>or</p>

<pre><code>if (pktNum != pktNum) {
</code></pre>

<p>which is always false. Unless invPktNum has a different definition in your code which is not shown.</p>
",2
4251399,4251335,10,"<p>In C, values in most expressions that are of a type narrower than <code>int</code> are promoted to a wider type before the calculation takes place.  If <code>int</code> is wide enough to hold all the values of the narrower type, then it is promoted to <code>int</code>; otherwise it is promoted to <code>unsigned int</code>.</p>

<p>In this case, <code>int</code> is wide enough to hold all the values of your <code>unsigned char</code>, so your values are promoted to <code>int</code>.</p>

<p><code>pktNum</code> (and thus, the promoted <code>pktNum</code>) can have a value between 0 and 255 inclusive.  This is the value that will be used on the left hand side of the <code>!=</code> operator.</p>

<p><code>invPktNum</code> can likewise have a value between 0 and 255 inclusive.  This value will be promoted to <code>int</code>, and then bitwise-negated.  The result of this bitwise negation will always be a <em>negative</em> number, since the sign bit will be negated.  This is the value that will be used on the right hand side of the <code>!=</code> operator.</p>

<p>No negative number can ever be equal to the promoted <code>pktNum</code>, so the condition is always true.</p>

<p>To perform the calculation that you actually want to, you need to mask out the lower eight bits after the negation:</p>

<pre><code>if (pktNum != (~invPktNum &amp; 0xff)) {
    return 1;
}
</code></pre>

<p>Or alternatively, you can just negate the bits you're interested in:</p>

<pre><code>if (pktNum != (invPktNum ^ 0xff)) {
    return 1;
}
</code></pre>
",2
4251521,4251335,0,"<p>Perhaps the simple type independent test is:</p>

<pre><code>if (0 == (pktNum &amp; pkNum)) {
</code></pre>

<p>Which is equal to:</p>

<pre><code>if (0 == (0xfe &amp; 0x01)) {
</code></pre>

<p>Quickly tested with <a href=""http://codepad.org/nziOGYJG"" rel=""nofollow"">http://codepad.org/nziOGYJG</a> seems to work with multiple signed and unsigned long / int types.</p>

<p>Out of interest anybody have any comments?</p>
",2
2614904,2614894,4,"<p>Lvalue is something which can be assigned to, or taken a pointer of.<br>
It's something that has an address.</p>

<p>Example:</p>

<pre><code>int f()
{
    return 5;
}
f() = 8; // doesn't compile, f() is not an lvalue

int* g()
{
    int* pv = malloc(sizeof(int));
    *pv = 5;
    return pv;
}
*g() = 8; // compiles, as *g() is a lvalue
</code></pre>

<p>If you post your code, we will be able to tell you why are you getting the error message about the missing lvalue.</p>
",3
2614920,2614894,3,"<p>An <em>lvalue</em> is a term given to an expression that refers to an object, i.e. something with an address.</p>

<p>Historically it comes from the the fact that it's something that's valid to appear on the left of an assignment. In contrast, something that can appear on the right of an assignment is known was an <em>rvalue</em>, however <em>rvalue</em> actually refers to any expression that isn't an <em>lvalue</em>.</p>

<p>Typically you can convert <em>lvalues</em> to <em>rvalues</em> (objects have a value), but not the other way around.</p>

<p>Usually the error that you are getting means that you are trying to do something to an <em>rvalue</em> that is only valid for <em>lvalues</em>.</p>

<p>That might be, assigning to the result of a function, or taking the address of a literal.</p>

<pre><code>f() = 5;

int *p = &amp;5;
</code></pre>
",0
3844274,3844246,4,"<p>If I invoke your program passing it <code>/tmp</code> as the argument.</p>

<pre><code>files = get_all_files(argv[1]);
</code></pre>

<p>will return all the files in <code>/tmp</code> but when you do:</p>

<pre><code>for (i = 0; files[i]; ++i) { 
  FILE *fp;
  if((fp = fopen(files[i],""r""))==NULL)
</code></pre>

<p>you are trying to open those files from the present working directory. But they are present in the directory you passed as argument making your <code>fopen</code>s fail.</p>

<p>To fix this </p>

<ul>
<li>you prefix the dir name to the file
to be opened. or</li>
<li>You can change your pwd using <a href=""http://www.delorie.com/gnu/docs/glibc/libc_268.html"" rel=""nofollow"">chdir</a> and then do the <code>fopen</code>s.</li>
</ul>
",3
3844291,3844246,1,"<p>A couple problems, I think:</p>

<ol>
<li><code>readdir()</code> returns subdirectories in the path, even entries like ""."" and "".."".</li>
<li>you try to open the files returned, but in whatever the current directory might be - you need to concatenate the path to the filename you're opening.</li>
</ol>
",0
2124632,2124621,1,"<p>Your code is not the problem, except the typo on the last line. The error you get, indicates that there is a problem when linking, specifically that the <code>sqlite3_*</code> symbols can't be resolved by the linker.</p>

<p>You probably need to specify the location of the sqlite library. If you expand your question with the commands you use for compiling, I can expand my answer =)</p>
",0
2124635,2124621,13,"<p>You have to pass the library you wish to link your code with, in this situation it's sqlite3.</p>

<p>If you are using gcc try adding the:</p>

<pre><code>-lsqlite3 
</code></pre>

<p>To your arguments you pass to gcc in your makefile/build command.</p>
",0
2124638,2124621,2,"<p>It looks like the compiler can't find the sqlite library. Be sure to pass the <code>-lsqlite3</code> flag when compiling (for gcc at least).</p>
",0
8423644,8423284,2,"<p>Yes: a pointer to an array decays into a pointer to the first element; so <code>&amp;buff[0] == &amp;buff</code>. In your case there is another thing: when used as a function argument (such as memcpy (buff, ...) ) an array <em>name</em> decays into a pointer.</p>

<p>For <code>sizeof buff</code>, the buff <em>does not</em> decay into a pointer. (hint: use short, or long long to test that, or a platform where sizeof (void*) != sizeof (int). )</p>
",1
8423675,8423284,3,"<p>It will always return 1.</p>

<p>An array is a contiguously allocated non-empty set of objects with the element type - arrays are not allowed to have padding before or between elements.  It follows that a pointer to an array points at the same location as a pointer to the first element, although it has a different type.</p>

<p><code>&amp;buff</code> <em>is</em> the address of the variable <code>buff</code>.  The variable <code>buff</code> in this case is an array, so <code>&amp;buff</code> is the address of an array - and just like the address of a <code>struct</code> variable is the same location as the address of its first member (although a different type), the address of an array variable is the same location as the address of its first member.</p>

<p>¡ì6.5.9 tells us:</p>

<blockquote>
  <p>6 Two pointers compare equal if and only if both are null pointers,
  both are pointers to the same object (including a pointer to an object
  and a subobject at its beginning)...</p>
</blockquote>

<p>In this case the <em>""pointer to an object""</em> is the pointer to the array, and the <em>""pointer to the subobject at its beginning""</em> is the pointer to the first element of the array.</p>

<p>In other words, it returns 1 for much the same reason that this code does:</p>

<pre><code>int foo()
{
    struct { int a; int b; } s;

    return (void*)&amp;s == (void*)&amp;s.a;
}
</code></pre>
",0
8423678,8423284,6,"<blockquote>
  <p>Are they [<code>buff</code> and <code>&amp;buff</code>] guaranteed to have the same value or is that something that just happens with gcc and clang? I ask because I don't think &amp;buff is ""the address of the start of the array,"" but the address of the variable buff.</p>
</blockquote>

<p>They <em>are</em> guaranteed to be the same value. In C arrays can be considered ""special"" in the sense that they're not pointers and the only time they're treated as such is when they're passed to a function and they <em>decay</em> to pointers.</p>

<p>For that reason:</p>

<pre><code>buff == &amp;buff &amp;&amp; buff == &amp;buff[0]
</code></pre>

<p>However <code>buff</code> and <code>&amp;buff</code> are of two different types, where <code>&amp;buff</code> is a pointer to the array (they still refer to the same spot!). You can use <code>sizeof</code> on the two to see this difference for yourself.</p>

<p>That is <strong>not</strong> the same for a pointer, which as you say will return the address of that actual pointer variable. An array also isn't a pointer to itself since in order for a pointer to point to itself, the address of that pointer would need to be stored in that pointer variable.</p>

<p>An array name is simply a label used by the compiler that corresponds to a contiguous block of memory. It has special properties, the above being one of them.</p>
",0
6944771,6944730,8,"<p>You could use it in a case statement, I guess, but I wouldn't recommend it.</p>

<p><code>'yes'</code> is a multicharacter constant.  Its type is <code>int</code>, and its value is implementation dependent. So like you already stated, it's up to the compiler.</p>

<p>so <code>int foo = 'yes';</code></p>

<p><em>ARM, section 2.5.2, page 9:</em></p>

<blockquote>
  <p>""A character constant is one or more characters enclosed in single
  quotes, as in 'x'.""</p>
</blockquote>

<p>Later on the same page:</p>

<blockquote>
  <p>""Multicharacter constants have type int.  The value of a
  multicharacter constant is implementation dependent.  For example, the
  value of 'AB' could reasonably be expected to be 'A' 'B' and
  ('A'&lt;&lt;8)+'B' on three different implementations.  Multicharacter
  constants are usually best avoided.""</p>
</blockquote>

<p>and</p>

<p>Quoting from the ANSI C specification (to which C++ makes some attempt to be compatible):</p>

<blockquote>
  <p>3.1.3.4  Character Constants Semantics</p>
  
  <p>An integer charcter constant has type int [note that it has type char
  in C++]...The value of an integer character constant containing more
  than one character...is implementation-defined.</p>
</blockquote>
",0
6945217,6944730,15,"<p>As Code Monkey cited, it is implementation defined and implementation varies -- it isn't just a BigEndian/LittleEndian and charset difference.  I've tested four implementations (all using ASCII) with the program</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    unsigned value = 'ABCD';
    char* ptr = (char*)&amp;value;

    printf(""'ABCD' = %02x%02x%02x%02x = %08x\n"", ptr[0], ptr[1], ptr[2], ptr[3], value);
    value = 'ABC';
    printf(""'ABC'  = %02x%02x%02x%02x = %08x\n"", ptr[0], ptr[1], ptr[2], ptr[3], value);
    return 0;
}
</code></pre>

<p>and I got four different results</p>

<p>Big endian (AIX, POWER, IBM compiler)</p>

<pre><code>'ABCD' = 41424344 = 41424344
'ABC'  = 00414243 = 00414243
</code></pre>

<p>Big endian (Solaris, Sparc, SUN compiler)</p>

<pre><code>'ABCD' = 44434241 = 44434241
'ABC'  = 00434241 = 00434241
</code></pre>

<p>Little endian (Linux, x86_64, gcc)</p>

<pre><code>'ABCD' = 44434241 = 41424344
'ABC'  = 43424100 = 00414243
</code></pre>

<p>Little endian (Solaris, x86_64, Sun compiler)</p>

<pre><code>'ABCD' = 41424344 = 44434241
'ABC'  = 41424300 = 00434241
</code></pre>
",0
6947066,6944730,6,"<p>Multi-character constants are <em>allowed</em> in all contexts where single-character constants are allowed.</p>

<p>As for where they'd actually be used, I've seen code that uses multi-character constants to create legible unique values.  For example, assuming that int is 4 bytes, 'ABCD' and 'EFGH' are likely to be distinct.  (This isn't guaranteed by the language; the implementation must document the mapping, but it needn't be reasonable.)  And assuming a reasonable mapping, you'll likely see ""ABCD"" or ""EFGH"" in the object code.  Not the best idea in the world, but it can work if you don't care much about portability.</p>

<p>Incidentally, <em>all</em> conforming C compilers support multi-character constants (by definition; a compiler that doesn't support them is non-conforming).</p>
",0
3439395,3439385,2,"<p>You missed &amp;.</p>

<p>retry with</p>

<pre><code>int main()
 {
char TurHare;   

    while(1)
    {
    scanf(""%c"",&amp;TurHare);
    printf(""\nCharacter :%c"", TurHare);
    }

return 0;
} 
</code></pre>

<p>I recommend getch,getche,getchar to use in case of character ,scanf will lead you to some buffering problem</p>
",3
3439489,3439385,1,"<p>Ok so Its because of return key which you enter after entering w. so once it reads w and other time it read the end of line character.  </p>
",0
3439507,3439385,0,"<p>Your program does what you tell it to do, it outputs the characters you type.</p>

<p>Now when you input <code>w</code> , look at what you're doing. You're hitting 2 keys. the <code>w</code> key , and <code>Enter</code> . That's the output you get, w and a newline(from the enter key). If you don't want that, do e.g.</p>

<pre><code>char TurHare; 

while(1)
{
    if(scanf(""%c"",&amp;TurHare) != 1) { //always check for errors
       break; //or some other error handling
    }

    if(c != '\n') { //or perhaps if(!isspace(c)) from &lt;ctype.h&gt;
      printf(""\nCharacter :%c"", TurHare);
      fflush(stdout);
    }
 }
</code></pre>
",0
3439641,3439385,1,"<p>There is an buffering-problem with scanf(""%c""). Many people use fflush(stdin) to solve, but isnt ANSI.</p>

<pre><code>void fflushstdin()
{
    int c;
    while( (c=getchar())=='\n' );
    if( c!=EOF )
        ungetc(c,stdin);
}

main()
{
    int TurHare;
    while( fflushstdin(), !feof(stdin)&amp;&amp;1==scanf(""%c"",&amp;TurHare) )
    {
        printf(""\nCharacter :%c"", TurHare);
    }
    return 0;
}
</code></pre>

<p>Break the loop with ^Z on Windows and ^D with Unix/Linux.</p>
",0
2287874,2287688,1,"<p>If I were to guess, you want to have a <code>char</code> array, or a <code>char</code> pointer with enough memory, and then put your query string in it:</p>

<pre><code>char query[BIG_ENOUGH];
sprintf(query, ""EXEC SQL VAR %s is STRING;"", d-&gt;x);
</code></pre>

<p>The above assumes that your have a string in <code>d-&gt;x</code>, and that you want the string value in your SQL query.  I don't know if your SQL query is well-formed though.</p>

<p>If this is not what you want, you need to post more information.</p>
",1
6372284,6372233,0,"<p>Open the file with append flag ""a"" and then use fputs() function.</p>
",0
6372297,6372233,1,"<p>You should use <code>""\n""</code> instead of <code>""/n""</code> with the file opened in ""appending mode"" (letter 'a' as fopen parameter</p>
",0
6372384,6372233,4,"<p>a very simple way, no error checking:</p>

<pre><code>FILE * file = fopen(fname, ""a"");
fwrite(""\n"", strlen(""\n""), 1, file);
fclose(file);
</code></pre>
",1
6372439,6372233,0,"<p>The strings <code>""\n""</code> and <code>""/n""</code> are very different. The first has 1 character (plus a null terminator); the second has 2 characters (plus a null terminator).</p>

<p>The character used for line termination is <code>'\n'</code>. <code>puts()</code> appends one such character automatically.</p>

<p>The following statements do the same thing (they may return a different value, but that isn't used in the example below):</p>

<pre><code>printf(""full line\n"");
fputs(""full line\n"", stdout);
puts(""full line"");
</code></pre>
",0
4358261,4358207,2,"<p>The prototype for <code>generate</code> should read</p>

<pre><code>void generate(int nwords, int random_num[], FILE* oufile);
</code></pre>

<p>in both the declaration and the definition. <code>int[] foo</code> is not valid C syntax.</p>

<p>The other error is because you forgot to declare <code>estrdup</code>. Without a declaration, C assumes that its prototype its return value is <code>int</code>, hence the error</p>

<pre><code>a.c:136: note: expected ¡®char *¡¯ but argument is of type ¡®int¡¯
</code></pre>

<p>Good to see someone is reading <em>The Practice of Programming</em>, it's one of my favorites :)</p>
",10
2200403,2200363,6,"<p>You are passing ptr into you function and then changing it using realloc.  You need to pass a pointer to a pointer in order to make this work properly.</p>

<p>I suggest you print out the address that the pointer is pointing to before and after the call to include and before and after the call to realloc.  This should show you what is happening or look at the code below:</p>

<pre><code>#include &lt;stdio.h&gt;

void a( int **ptrptr)
{
    printf(""ptrptr = %p,  ptr = %p\n"",ptrptr,*ptrptr) ;
    *ptrptr = (int*)realloc(*ptrptr, 10*sizeof(int)) ;
    printf(""ptrptr = %p,  ptr = %p\n"",ptrptr,*ptrptr) ;
}


int main(int argc, char **argv)
{
    int *ptr = malloc(5*sizeof(int)) ;
    printf(""ptr = %p\n"",ptr) ;
    a(&amp;ptr) ;
    printf(""ptr = %p\n"",ptr) ;
    free(ptr) ;
    return 0;
}
</code></pre>
",0
2200701,2200363,1,"<p>The <code>realloc()</code> call in <code>include()</code> may move the block. That's why <code>realloc()</code> returns a pointer, to tell you where it finally put the data. Your code temporarily uses that value (you store it in the local variable <code>p</code> and use it) but fails to propagate it back to the caller. The <code>main()</code> function keeps in its <code>ptr</code> local variable a pointer to the original block, and it never changes.</p>

<p>Remember that when you pass an argument to a function, the function gets its own copy. Here, you pass the contents of <code>ptr</code> as an argument, and <code>include()</code> sees that value as a variable named <code>p</code>, but this <code>p</code> is only a copy of <code>ptr</code>. Modifications to <code>p</code> are not seen by <code>ptr</code>.</p>

<p>You could modify <code>include()</code> so that it returns the new pointer; something like:</p>

<pre><code>int *include(int d,int* p,int n,int k,int flag)
{
    ...
    return p;
}
</code></pre>

<p>and then call it with:</p>

<pre><code>ptr = include(digit, ptr, i, koef, 1);
</code></pre>

<p>which is a way to propagate back the new pointer value to the caller.</p>

<p>Side notes:</p>

<ul>
<li><code>main()</code> should return an <code>int</code>, not <code>void</code>.</li>
<li>You do not have to cast the return value of <code>malloc()</code> or <code>realloc()</code>. These functions return a <code>void *</code> which the C compiler happily converts to any kind of pointer without an explicit cast. An explicit cast is a way to tell the compiler: ""shut up, I know what I am doing"". Since in that situation the compiler would not have talked anyway, the cast is just a waste of source code space. Also, the cast could be harmful in some situations where the compiler <em>would</em> have warned loudly: if <code>malloc()</code> was mispelled, the compiler would assume that it returns an <code>int</code>, and would warn about using an <code>int</code> as a pointer; but the cast would prevent that warning.</li>
<li>Your code does not compile, there is an extra closing brace.</li>
</ul>
",0
2202564,2200363,0,"<p>Thanks a lot!
Your remarks were realy helpful.
The problem was in the logic of function include() calling. I corrected it and at the moment the program is working fine. My function is now returning pointer to the allocated memory block.</p>
",0
2240492,2240475,2,"<p>Include other includes in the header file if the contents of the header file uses types defined by such includes. (Sorry, that was a mouthful.)</p>

<p>In your case, <code>math.h</code> should definitely include <code>struct.h</code>, although, I argue that neither are good names for user-defined header files (the former because there is already a system-provided <code>math.h</code>; the latter because <code>struct</code> is a keyword). :-P</p>

<p>If your header file uses <code>bool</code>, then yes, it should include <code>stdbool.h</code>.</p>
",0
2240496,2240475,4,"<p>The general rule is to include as little as possible in your header files.</p>

<p>Use forward declarations instead of definitions where possible, then you can move the definitions to the .c file. This can reduce the number of files you need to include in your header files.</p>

<p>In your specific example you could remove the include of <code>struct.h</code> from <code>math.h</code> and forward declare box instead. Not that it makes a huge difference in this specific case.</p>
",3
2240507,2240475,3,"<blockquote>
  <p>would ""math.h"" need to include
  ""struct.h"" as well?</p>
</blockquote>

<p>No, because in math.h (not  a great name, BTW) you are only dealing with pointers to a type. The definition is only needed if you are dealing with instances of a type. However, it would be good practice to include it, as the user who <em>is</em> going to traffic with actual instances will otherwise have to include it separately themselves.</p>
",1
2287837,2287784,1,"<p>Invoke gdb as:</p>

<pre><code>gdb /devl/aaa/BINARY/pfm.sql_Kavitha
</code></pre>

<p>and then run the program from within gdb as:</p>

<pre><code>(gdb) r /devl/aaa/BINARY/pfm.sql_Kavitha /devl/aaa/AVP/OCT_TEST /devl/aaa/ASAPDATA/READONLY /devl/aaa/ASAPDATA/READONLY 17 kk12345
</code></pre>

<p><code>(gdb)</code> above is the prompt.</p>

<p>If you want to be able to specify the program to execute from within gdb, use <code>file</code> command, as the error message says:</p>

<pre><code>(gdb) file /devl/aaa/BINARY/pfm.sql_Kavitha
</code></pre>

<p>followed by the <code>r</code> command as above.</p>
",0
2287844,2287784,0,"<p>There is some problem with the file you are trying to run from gdb -- either it is a corrupted file or the path is wrong. Try ""gdb {filename}"". </p>
",0
5509006,2287784,0,"<p>Instead of a single command, you will need two. One to <em>specify</em> the binary file and another to <em>run</em> the binary. In your case the commands are:</p>

<pre><code>file /devl/aaa/BINARY/pfm.sql_Kavitha
run /devl/aaa/AVP/OCT_TEST /devl/aaa/ASAPDATA/READONLY /devl/aaa/ASAPDATA/READONLY 17 kk12345
</code></pre>

<p>Alternatively, instead of using the <code>file</code> command, you can give the binary name to gdb as an argument when you start gdb. Also notice the syntax of the <code>run</code> command. The binary name is not repeated!</p>
",0
7480171,7480164,8,"<p>You do know that ""Hello world is good"" is more than 10 bytes? The behavior in this case is <strong>undefined</strong>. Anything can happen, anything at all, from working as you <em>wanted</em> to total crash of your system with reformatting the hard-drive and burning junk over your ROM.</p>

<p>You must allocate enough space for <code>gets</code> to put the string in, and in this case you don't. That's the main reason why <code>gets</code> should be avoided, use <code>fgets</code> instead.</p>
",0
7480179,7480164,2,"<p>Well, you allocate only 10 characters (<code>char ch[10]</code>) which fits ""hello worl"". Afterwards there's only junk in memory you're trying to print.</p>
",4
7480199,7480164,5,"<p>Your character array <code>ch</code> only has space for 10 chars. You typed something longer than 10 chars and tried to store it in that array, effectively writing beyond the end of the array into space that's not reserved for anything (or at least isn't reserved for your characters). You got lucky in this case and didn't write over anything important (your program didn't crash), but subsequent code comes along (the <code>printf()</code>, your <code>int i</code>, etc.) and changes that memory (it's the stack, after all, so it gets used in FIFO order).</p>

<p>Change your <code>char ch[10]</code> to <code>char ch[2048]</code> to give yourself a larger buffer to type into. You might also use <code>fgets()</code> instead of <code>gets()</code> so that you can limit the size of the input to your buffer size. If you use <code>gets()</code>, heed the warning on the man page:</p>

<blockquote>
  <p>It is the caller's responsibility to ensure that the input line, if
  any, is sufficiently short to fit in the string.</p>
</blockquote>
",0
7480326,7480312,20,"<p>You are hard-sizing your arrays so that they are too short for the strings (they don't include an additional character for the null terminator).  As a result, strcmp is running past the end of the strings when doing the comparison, producing essentially unpredictable results.  You're lucky to not be getting a seg fault.</p>
",3
7480329,7480312,9,"<p>Forgive me if this is off track, since I haven't done C in ages!</p>

<pre><code>main()
{
    char name[] = ""sara"";
    char vname[] = ""sara"";

    if(strcmp(name, vname) == 0)
    {
        printf(""\nOK"");
    }
    else
    {
        printf(""\nError"");
    }
}
</code></pre>

<p>You've specified hard lengths for your char arrays, but in C, strings are null terminated, so ""sara"" actually needs len 5, not 4. </p>
",0
7480332,7480312,8,"<p>Because <code>name</code> and <code>vname</code> don't contain strings.  By specifying a size of 4 for each of them, with a 4-character string as the initializer, you've told the compiler to store just those 4 characters <em>without</em> the <code>'\0'</code> null character that marks the end of the string.</p>

<p>The behavior is undefined; you're (un)lucky that it didn't just crash.</p>

<p>Remove the <code>4</code> (or change it to <code>5</code>):</p>

<pre><code>char name[] = ""sara"";
char vname[] = ""sara"";
</code></pre>

<p><strong>EDIT</strong>: Here's a modified version of your program that fixes several other issues (see comments).  Other that omitting the <code>4</code> on the declarations of <code>name</code> and <code>vname</code>, most of the changes are not directly relevant to your question.</p>

<pre><code>#include &lt;stdio.h&gt;  /* needed for printf */
#include &lt;string.h&gt; /* needed for strcmp */

int main(void) /* correct declaration of ""main"" */
{

    char name[] = ""sara"";   /* omit 4 */
    char vname[] = ""sara"";  /* omit 4 */

    if (strcmp(name, vname) == 0)
    {
        printf(""OK\n"");     /* \n is at the *end* of the line */
    }
    else
    {
        printf(""Error\n"");  /* as above */
    }

    return 0; /* not absolutely required, but good style */
}
</code></pre>
",0
7480350,7480312,1,"<p>It's because you're not allocating enough space for your strings (4 bytes can store the characters of ""sara"", but not the nul character at the end of the string.</p>

<p><code>strcmp</code> walks through the string until it reaches a nul character, or a difference in the strings and then, if it reached a nul for both strings they are equal. Since you don't allocate arrays large enough for a nul character you'll end up with your two strings being unequal. In fact in most systems you'll probably get name being something like ""sarasara"" and vname being just ""sara"", since vname comes right after name, there is a good chance it will be stored their in memory and overwrite names nul char.</p>
",0
6670308,6670257,3,"<p>No structure. The calling code just puts the arguments on the stack, it's the vararg function's responsibity to decode them properly.</p>

<p>For example in case of printf, the first argument is fixed, a c string, and the rest is decoded based on what's in the string. C just gives you tools to access these elements so you don't have to do stack pointer arithmetic based on size of the fields (which is architecture dependent..)</p>
",1
6670716,6670257,1,"<p>The compiler actually doesn't do anything special. During compilation, when a function is invoked, the compiler will as usual generate code to push the entire list of the arguments onto the stack consecutively (often in reverse order, depends on the calling convention).</p>

<p>It is then the responsibility of the callee to detect and reference these arguments from the stack. To do this the callee must know the number of arguments as well as the stack memory address of the first argument (this is always a known offset form the stack frame pointer). To determine the number of arguments, this information must be communicated. This is often achieved in the following ways:</p>

<ol>
<li>The first argument is an integer which explicitly indicates the number of arguments
to come.</li>
<li>The information is encoded inside the first argument such as the case for <code>printf</code>.</li>
</ol>

<p>Often C macros are used to automate this and encapsulate some of these details. See: <a href=""http://en.wikipedia.org/wiki/Stdarg.h"" rel=""nofollow"">stdarg.h Macros</a></p>
",0
7497695,7497658,15,"<p>Oh boy, where to start? You really need a good book. Sigh. Let's start at the top of <code>main()</code>: </p>

<hr>

<p>This</p>

<pre><code>struct Player *player;
</code></pre>

<p>defines a pointer to a <code>struct Player</code>, but it doesn't initialize it. It has thus a more or less random value, pointing somewhere into memory. This</p>

<pre><code>player-&gt;name = malloc(sizeof(player-&gt;name)*256);
</code></pre>

<p>now writes into parts of that random location the address of a piece of memory obtained by <code>malloc()</code>. Writing to memory through an uninitialized pointer invokes <em>Undefined Behavior</em>. After that, all bets are off. No need to look further down your program. You are unlucky that, by accident, you write to a piece of memory that is owned by your process, so it doesn't crash immediately, making you aware of the problem.</p>

<p>There's two ways for you to improve that. Either stick to the pointer and have it point to a piece of memory allocated for a <code>Player</code> object. You could obtain it by calling <code>malloc(sizeof(Player)</code>.<br>
Or just use a local, automatic (aka stack-based) object: </p>

<pre><code>struct Player player;
</code></pre>

<p>The compiler will generate the code to allocate memory on the stack for it and will release it automatically. This is the easiest, and should certainly be your default. </p>

<hr>

<p>However, your code has more problems than that. </p>

<p>This</p>

<pre><code>player-&gt;name = malloc(sizeof(player-&gt;name)*256);
</code></pre>

<p>allocates consecutive memory on the heap to store 256 <em>pointers to characters</em>, and assigns the address of the first pointer (the address of a <code>char*</code>, thus a <code>char**</code>) to <code>player-&gt;name</code> (a <code>char*</code>). Frankly, I'm surprised that even compiles, but then I'm more used to C++' stricter type enforcement. Anyway, what you probably want instead instead is to allocate memory for 256 characters: </p>

<pre><code>player-&gt;name = malloc(sizeof(char)*256);
</code></pre>

<p>(Since <code>sizeof(char)</code> is, by definition, <code>1</code>, you will often see this as <code>malloc(256)</code>.)<br>
However, there more to this: Why 256? What if I pass a string 1000 chars long? No, simply allocating space for a longer string is not the way to deal with this, because I could pass it a string longer still. So either <em>1)</em> fix the maximum string length (just declare <code>Player::name</code> to be a <code>char</code> array of that length, instead of a <code>char*</code>) and enforce this limit in your code, or <em>2)</em> find out the length needed dynamically, at run-time, and allocate exactly the memory needed (string length plus 1, for the terminating <code>'\0'</code> char). </p>

<p>But it gets worse. This</p>

<pre><code>player-&gt;name = ""John"";
</code></pre>

<p>then assigns the address of a string literal to <code>player-&gt;name</code>, overriding the address of the memory allocated by <code>malloc()</code> in the only variable you store it in, making you lose and leak the memory.<br>
But strings are no first-class citizens in C, so you cannot assign them. They are arrays of characters, by convention terminated with a <code>'\0'</code>. To copy them, you have to copy them character by character, either in a loop or, preferably, by calling <code>strcpy()</code>. </p>

<p>To add insult to injury, you later attempt to free the memory a string literal lives in</p>

<pre><code>free(player);
</code></pre>

<p>thereby very likely seriously scrambling the heap manager's data structures. Again, you seem to be unlucky for that to not causing an immediate crash, but the code seemingly working as intended is one of the worst possibilities of <em>Undefined Behavior</em> to manifest itself. If it weren't for all bets being off before, they now thoroughly would be. </p>

<hr>

<p>I'm sorry if this sounds condemning, it really wasn't meant that way, but you certainly and seriously fucked up this one. To wrap this up: </p>

<ol>
<li><p>You need a good C++ book. Right now. <a href=""https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list"">Here</a> is a list of good books assembled by C programmers on Stack Overflow. (I'm a C++ programmer by heart, so I won't comment on their judgment, but K&amp;R is certainly a good choice.) </p></li>
<li><p>You should initialize all pointers immediately, either with the address of an existing valid object, or with the address of a piece of memory allocated to hold an object of the right type, or with <code>NULL</code> (which you can easily check for later). In particular, you must not attempt to read from or write to a piece of memory that has not been allocated (dynamically on the heap or automatically on the stack) to you. </p></li>
<li><p>You need to <code>free()</code> all memory that was obtained by calling <code>malloc()</code> <em>exactly once</em>. </p></li>
<li><p>You must not attempt to <code>free()</code> any other memory. </p></li>
</ol>

<hr>

<p>I'm sure there is more to that code, but I'll stop here. <em>And did I mention you need a good C book?</em> Because you do. </p>
",1
7497719,7497658,0,"<p><code>player</code> doesn't need to be freed because it was never <code>malloc</code>'d, it's simply a local stack variable. <code>player-&gt;name</code> does need to be freed since it was allocated dynamically.</p>

<pre><code>int main()
{
    // Declares local variable which is a pointer to a Player struct
    // but doesn't actually point to a Player because it wasn't initialised
    struct Player *player;

    // Allocates space for name (in an odd way...)
    player-&gt;name = malloc(sizeof(player-&gt;name)*256);

    // At this point, player-&gt;name is a pointer to a dynamically allocated array of size 256*4

    // Replaces the name field of player with a string literal
    player-&gt;name = ""John"";


    // At this point, the pointer returned by malloc is essentially lost...
    printf(player-&gt;name);

    // ?!?!
    free(player);

    printf(""\n\n\n"");
    system(""PAUSE"");
    return 0;
}
</code></pre>

<p>I guess you wanted to do something like this:</p>

<pre><code>int main() {
  struct Player player;
  player.name = malloc( 256 );
  // Populate the allocated memory somehow...

  printf(""%s"", player.name);
  free(player.name);
}
</code></pre>
",1
7497741,7497658,0,"<p>You have to <code>free()</code> everything that you <code>malloc()</code> and you must <code>malloc()</code> everything that is not allocated at compile time.</p>

<p>So:</p>

<p>You must malloc <code>player</code> and you must free <code>player-&gt;name</code></p>
",0
7497747,7497658,0,"<p>Ok, so your variable player is a pointer, which you have not initialized, and therefore points to a random memory location.</p>

<p>You first need to allocate the memory for <code>player</code> the way you have done for <code>player-&gt;name</code>, and then alocate for player->name.</p>

<p>Any memory allocated with <code>malloc()</code> needs to be freed with <code>free()</code>. </p>

<p>Take a look at <a href=""http://computer.howstuffworks.com/c29.htm"" rel=""nofollow"">this</a> and <a href=""http://www.codingunit.com/c-tutorial-the-functions-malloc-and-free"" rel=""nofollow"">this</a>.</p>
",0
7497794,7497658,0,"<p>This is awful code. Why? Firstly you allocate memory for player->name. malloc returns pointer to allocated memory. In next step you lose this pointer value because reassign player->name to point to static ""John"" string. Maybe you want to use strdup or sprintf functions?</p>

<p>Also the big mistake is to use uninitialized pointer to player struct. Try to imagine that it can point to random memory location. So it is good idea allocate memory for your structure with help of malloc. Or don't use pointer to structure and use real structure variable.</p>
",0
2422800,2422774,2,"<p>They're still headers, but they're not directly in the default search paths. This is often done for headers from third-party libraries, to keep them separate from the stock libc headers.</p>
",0
2422811,2422774,2,"<p>It has to do with how your preprocessor works.  If your preprocessor looks in <code>/usr/include/</code> then you need <code>sys/sysinfo.h</code>.  If your preprocessor looks in <code>/usr/include/sys/</code> then you only need <code>sysinfo.h</code></p>

<p>Try playing around with gcc with the <code>-I</code> and <code>-l</code> options</p>

<p>edit: those should be capital i and lowercase L</p>
",1
2422814,2422774,8,"<p>It is a convenient way of providing some 'namespace structure' to header files.  In the Unix world, the main division is between headers like <code>&lt;stdio.h&gt;</code> which are often fairly general and primarily for use by user programs and not primarily for use by the operating system kernel.  By contrast, the headers like <code>&lt;sys/sysinfo.h&gt;</code> or <code>&lt;sys/types.h&gt;</code> were intended for use when compiling the kernel - they were more system-y.</p>

<p>Nowadays, it provides a way to separate your project's headers from another project's headers.  For example, <code>&lt;openssl/ssl.h&gt;</code> identifies the header as belonging to the OpenSSL code base.</p>

<p>I don't know that there is a particular name for this style of specifying headers.</p>

<p>Note that if the OpenSSL headers are stored in the directory <code>/usr/local/include/openssl</code>, then you specify <code>-I /usr/local/include</code> on the compiler command line.  What actually happens is that the header is looked for by prefixing the name in the angle brackets by one of a number of standard directories, of which the default one is <code>/usr/include</code> on Unix.  Therefore, <code>&lt;stdio.h&gt;</code> is found in <code>/usr/include/stdio.h</code> and <code>&lt;sys/sysinfo.h&gt;</code> is found in <code>/usr/include/sys/sysinfo.h</code>, etc.</p>
",2
2574097,2574089,4,"<p>No it isn't good to have a declaration with unspecified arguments. In C (but not in C++) it is allowed to declare a function as <code>f()</code> without specifying the argument, but using that functionality should be avoided. If the function does not accept any arguments use <code>f(void)</code> to explicitly mark that. If the function accepts argument, always include the arguments' types in the declaration.</p>
",1
2574100,2574089,7,"<blockquote>
  <p>If defining the function prototype at
  the top in the program as void f() a
  good practice? Or is it better to put
  it as void f(long double y[], long
  double A) as in the function
  declaration?</p>
</blockquote>

<p>Definitely the latter -- the former doesn't give the compiler any type info for compile-time checks. <code>void f()</code> tells the compiler that <code>f</code> takes an unspecified argument list. I.e. anything goes.</p>

<blockquote>
  <p>The called function f is changing
  elements in the array y. Is void the
  right return type? The program is
  working fine as such with the void as
  described.</p>
</blockquote>

<p>The return type has nothing to do with the parameter being modified. You can have a non-<code>void</code> return type if you want to indicate a success code though.</p>
",1
2574125,2574089,10,"<p>Your question suffers from a terminological mix-up. </p>

<pre><code>void f();
</code></pre>

<p>is <em>not</em> a function prototype in C. This is a <em>function declaration</em> that does not introduce a prototype. Meanwhile</p>

<pre><code>void f(long double y[], long double A);
</code></pre>

<p>is also a function declaration, and this one is a prototype (i.e. it does introduce a prototype for <code>f</code>).</p>

<p>To answer your questions, yes, it is always a good practice to declare functions with prototypes (i.e. it is better to declare them with prototypes than without prototypes). Normally, you should declare prototypes for all your external functions (and <code>void f()</code> is not a prototype).</p>

<p>As for the return types, it is all a matter of your intent. I don't see how the fact that you are changing the elements of the array should make it better to return <code>long double</code> instead of <code>void</code>.</p>
",1
2849396,2849344,1,"<p>By using the double pointer, <code>**table</code>, once memory is allocated you can reference an array of elements, eg: <code>table[2]</code>. You then could access a hash table element directly, without having to traverse a linked list.</p>

<p>Alternatively, if you use only a single pointer, <code>*table</code>, you will only be able to reference a single element. So basically you would then need to use a data structure such as a linked list (ick) to store your hash table elements - just like how you have set up your <code>list</code> data structure.</p>

<p>I do not recommend using a single pointer, since you will have to do a linear list traversal in order to perform any operations on your hash table. In other words, to add an element you will have to traverse the linked list to find element <code>n</code> instead of just directly accessing it. Since operations on a hashtable are expected to be O(1) fast, this implementation eliminates the advantage of using a hashtable. You might as well just use a linked list at that point.</p>
",3
2849399,2849344,3,"<p>Well, that depends. If you look at table[i], how will you know if it is empty or not? If you use list**, then table[i] is type list*, and so you can easily tell if it is empty based on if it is null. If you use type list*, then table[i] is a list, and so unless you use a null, empty, or some other value for the key as a sentinel value indicating that the list is empty, then it will not work. So, yes, you could use list*, but then you need to add an additional sentinel condition, which might also limit which types of keys you allow. Alternatively, you could just ignore the first element of list[i], however, that would be wasteful. I should also point out that using list* instead of list** makes inserting an element at the front of table[i] harder; if you use a list** type, then you simply need to set the new entry's next pointer to the current value of table[i], and then assign to table[i] the address of the newly allocated entry. If you use type list*, you will need to insert the item between table[i] and table[i]->next, which makes the logic for insertion unnecessarily complicated.</p>

<p>Also, I should add that your hash table definition is flawed. A hash table is supposed to map one set of items to another. Your list structure has a single value. It needs both a key and a value. A better declaration for a hash table would be the following:</p>

<pre><code>typedef struct HashTableEntry
{
    char* key;
    void* value;
    struct HashTableEntry* next;
} HashTableEntry;

typedef struct HashTable
{
     HashTableEntry** entries;
     int capacity; // size of entries
     int length; // number of key/value pairs currently in map
} HashTable;
</code></pre>
",2
5127802,5127779,-1,"<p>found this code that is similar enough that should be able to help you get done what you need.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* Sample data lines
5 0 Wednesday Sunny
6 2 Thursday Wet
*/

int main() {
/* Define a daydata structure */
        typedef struct {
                int n_adults; int n_kids;
                char day[10]; char weather[10];
                } daydata ;
        daydata record[30];
        FILE * filehandle;
        char lyne[121];

        char *item;
        int reccount = 0;
        int k;

        /* Here comes the actions! */
        /* open file */

        filehandle = fopen(""newstuff.txt"",""r"");

        /* Read file line by line */

        while (fgets(lyne,120,filehandle)) {
                printf(""%s"",lyne);

                item = strtok(lyne,"" "");
                record[reccount].n_adults = atoi(item);

                item = strtok(NULL,"" "");
                record[reccount].n_kids = atoi(item);

                item = strtok(NULL,"" "");
                strcpy(record[reccount].day,item);

                item = strtok(NULL,""\n"");
                strcpy(record[reccount].weather,item);

                printf(""%s\n"",record[reccount].day);
                reccount++;
                }

        /* Close file */

        fclose(filehandle);

        /* Loop through and report on data */

        printf(""Weather Record\n"");
        for (k=0; k&lt;reccount; k++) {
                printf(""It is %s\n"",record[k].weather);
                }

        }
</code></pre>

<p><a href=""http://www.wellho.net/resources/ex.php4?item=c209/lunches.c"" rel=""nofollow"">http://www.wellho.net/resources/ex.php4?item=c209/lunches.c</a></p>

<p>Give a holler with code you tried if you have problems changing it to fit your needs.</p>
",0
5127812,5127779,1,"<p>First, define the structure. The structure describes what a <em>record</em> is; what data it contains. Here you have a student's name and his or her mark.</p>

<p>Second you need to prepare the array to write the objects of the structure into. You already know from the problem description that no more than 7 students are allowed, so you can define the length of the array to that number.</p>

<p>Next, open the text file.</p>

<p>Lastly write a loop that takes as input from the file a string for the student's name and an integer (or a floating-point point number if you so choose) for their mark. In the loop create a structure for each record and insert the structure into the array.</p>

<p>And of course, don't forget to close the file when you're done.</p>

<p>That's all there is to it. If you have any syntax or logic questions then ask in the comments, and we'll gladly help.</p>
",0
5127817,5127779,0,"<p>Read the man page for fopen: <a href=""http://linux.die.net/man/3/fopen"" rel=""nofollow"">http://linux.die.net/man/3/fopen</a></p>

<p>This should give you somewhere to start.</p>

<p>Also, the man page for fread and fgets could be helpful. There are many ways to read from a file and the path you choose will depend on numerous things, such as the structure of the file and the amount of security you want in your application.</p>
",0
2644827,2635601,0,"<p>if I add -fPIC to gcc while compile the static, then it works well.</p>
",0
5561343,3613268,0,"<p>In C single quotes describe a single character i.e. 'a'
while in double quotes ""a"" it makes up the null teminated string</p>

<p>So this</p>

<pre><code>int main(void)
{
    char s[2]=""a"";

    // s='a'; leads to error incompatible types.........
    printf(""%s"",s);

    return 0;
}
</code></pre>

<p>will work fine</p>
",0
7502499,7502332,2,"<p>do the memchr and assign the return value then do the if.  like this:</p>

<pre><code>ptr = memchr(str1, '4', sizeof(str1));
if (ptr)
{
  // do stuff using ptr;
}</code></pre>
",1
7503061,7502332,3,"<p>The assignment operator returns the value being assigned, which (along with right associativity) is why <code>a=b=c;</code> works. So your first example will work just fine.</p>
",0
2849739,2849716,3,"<pre><code>  ++c;
  if(ch==32)
  {
      ++w;
      ++c;
  }
</code></pre>

<p>You have double-counted the space character. Remove the 2nd <code>++c</code>.</p>
",0
2849741,2849716,4,"<p>You're double-counting spaces:</p>

<pre><code>++c;
if(ch==32)
{
    ++w;
    ++c;
}
</code></pre>

<p>You already incremented <code>c</code>; you don't need to do it again. You're also counting the newline as a character, and your word count is a count of the number of spaces, which is going to be short one (""foo bar"" has two words, but one space). Depending on what exactly you want to check, standard functions like <a href=""http://www.cplusplus.com/reference/clibrary/cctype/isspace/"" rel=""nofollow noreferrer"">isspace</a> might be easier (but it returns true for things besides ' ')</p>
",1
2849742,2849716,7,"<p>You're incrementing <code>c</code> <em>twice</em> for the space character.</p>

<p>Your <code>if</code> statement should be just:</p>

<pre><code>if(ch==32)
    ++w;
</code></pre>

<p>You have another subtle bug as well inasmuch as the string <kbd>h</kbd><kbd>e</kbd><kbd>l</kbd><kbd>l</kbd><kbd>o</kbd><kbd>spc</kbd><kbd>spc</kbd><kbd>t</kbd><kbd>h</kbd><kbd>e</kbd><kbd>r</kbd><kbd>e</kbd> (with two spaces) will register as three words in your code.</p>

<p>This is how <em>I</em> would have written it to avoid those problems. Note the use of <code>lastch</code> to avoid counting space sequences as multiple words.</p>

<pre><code>int main(void) {
    int ch = ' ', lastch, w = 0, c = 0;

    do {
        lastch = ch;
        ch = getchar();
        ++c;
        if (ch == ' ') {
            if (lastch != ' ') {
                ++w;
            }
        }
    } while (ch != '\n');

    if (lastch != ' ') {
        ++w;
    }

    printf(""num of characters is  %d\n"",c);
    printf(""num of words is  %d\n"",w);

    return 0;
}
</code></pre>
",5
2849743,2849716,2,"<p>You're counting spaces twice.</p>

<p>Also it's easier to read if you use character literals like <code>ch==' '</code> instead of <code>ch==32</code></p>
",0
2849745,2849716,1,"<p>Each space is counted twice</p>
",0
2849747,2849716,3,"<p>Each space is counted twice...</p>

<pre><code>  ++c;
  if(ch==32)
  {
      ++w;
      ++c; // char is counted again
  }
</code></pre>

<p>Change code to:</p>

<pre><code>  ++c;
  if(ch==32)
  {
      ++w;     
  }
</code></pre>
",0
2849749,2849716,2,"<p>You're incrementing <code>c</code> twice, if the character read is 32.</p>
",0
2849754,2849716,3,"<p>You are adding to <code>c</code> twice when <code>ch==32</code>.  Also, you are adding to <code>c</code> when <code>ch==13</code>.</p>
",0
2849936,2849716,0,"<pre><code>void main(void)
{
    int ch,w=0,c=0,lastch=32;
    while((ch = getche()) != 13) //get input and check if it's ENTER key
    {
        ++c;
        if(ch == 32 &amp;&amp; lastch != ch) //make sure two continuous spaces are not counted as a word as pointed out by paxdiablo
            ++w;
        lastch = ch;
    }
    if(lastch != 32) //for a word with no space
        ++w;
    printf(""\nnum of characters is  %d"",c);
    printf(""\nnum of words is  %d"",w);
    getch();
}
</code></pre>

<p>You can consider using char instead of int.</p>
",0
6082110,6082083,3,"<p>You are reading and writing to the same file</p>

<pre><code> read(fd, buffer, SIZE)
</code></pre>

<p>Is wrong.  You want to read from stdin.</p>
",1
6082181,6082083,3,"<pre><code>if (fd = open(""log.txt"", O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO) &lt; 0)
</code></pre>

<p>should be</p>

<pre><code>if ((fd = open(""log.txt"", O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO)) &lt; 0)
</code></pre>

<p>otherwise it will be parsed as</p>

<pre><code>if (fd = (open(""log.txt"", O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO) &lt; 0))
</code></pre>

<p>(because <code>&lt;</code> has a higher operator precedence than <code>=</code>); if the <code>open()</code> succeeds, it will return a value that is >= 0, so the expression <code>open(...) &lt; 0</code> will be false, so <code>fd</code> will be set to 0.</p>

<p>File descriptor 0 represents the standard input for your process.  Unless you've redirected it, this will be a terminal device, for which seeking is illegal.</p>
",1
6082246,6082083,1,"<p>Not only are you reading the same file, read() reads SIZE bytes. 
Unless your input is fixed length records of SIZE bytes you will read multiple lines, completely missing the STOP which is now in the middle of the buffer.</p>

<p>while ( fgets( buffer, sizeof(buffer), stdin) &amp;&amp; (strncmp(buffer, ""STOP"", 4) != 0))</p>

<p>Reads a line at a time.</p>
",0
3053046,3052885,5,"<p>The following is going to loop for ever.</p>

<pre><code>while(c!= ' ' || c != '\t' || c != '\n' || c != '&gt;'){
    c = getchar(); //Get a new char
    test[i] = c;
    i++;
}
</code></pre>

<p>c can only be equal to one of them, so the condition will always be true.</p>
",1
3052907,3052885,8,"<p>You are specifying that it should write to tweets.rss instead of read from it.  Since your program reads from STDIN as the first thing it does and you don't supply any input, why would you expect any output?</p>

<p>Try:</p>

<pre><code>./parse &lt; tweets.rss
</code></pre>
",2
3053318,3053287,0,"<p>There is no need for put it into <code>s</code>. Just use <code>argv[1]</code>.</p>

<p>Having said this, is you <strong>are putting it into s anyway</strong> (which is not that bad) make sure you change your code to:</p>

<pre><code>char s[20];
strcpy(s, argv[1]);
</code></pre>

<p>Using <code>strcpy</code> with a constant char array is not a good idea.</p>
",0
3053320,3053287,0,"<p>You can simply pass it as <code>argv[1]</code>, no need to copy it. Should you want to copy it, you need to ensure that <code>s</code> can actually hold the full string contained in <code>argv[1]</code>, and allocate a bigger array if not... so it is messier.</p>
",2
3053364,3053287,0,"<p>I personally would do it this way:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
  const char defaultStr[]=""3.1415e-4"";
  const char *arg = NULL;
  if(argc &lt;= 1)
  {
     arg = defaultStr;
  }
  else
  {
     arg = argv[1];
  }

  printf(""%e\n"", atof(arg));

  return 0;
}
</code></pre>
",0
3186156,3186140,2,"<p>You are first allocating memory, then throwing that memory away by re-assigning the pointer using a string literal. Your arguments to <code>calloc()</code> also look very wrong.</p>

<p>Also, <code>memcpy()</code> is not a string copying function, it doesn't include the terminator. You should use <code>strcpy()</code>.</p>

<p>The best way to print only DATA would seem to be</p>

<pre><code>puts(""DATA"");
</code></pre>

<p>You need to be more clear on what you want to do, to get help with the pointers/allocations/copying.</p>
",0
3186158,3186140,6,"<p>Strings in C are terminated by a zero character value (nul). </p>

<p>strlen returns the number of characters before the zero.</p>

<p>So you are not copying the zero.</p>

<p>printf keeps going, printing whatever is in the memory after s until it hits a zero.</p>

<p>You also are only creating a buffer of size 1, so you are writing data over whatever is after s, and you leak the memory calloc'd to a before you set a to be a literal.</p>

<p>Allocate the memory for s after finding the length of the string, allocating one more byte to include the nul terminator, then copy a into s. You don't need to allocate anything for a as the C runtime looks after storing the literal ""DATA"".</p>
",0
3186160,3186140,1,"<p>You are reserving space for 1 character so you are actually using the memory of some other variable when you are writing ""DATA"" (which is 4 characters + the trailing <code>\0</code> to mark the end of the string).</p>

<pre><code>a=(char *)calloc(1,(sizeof(char)));
</code></pre>

<p>For this example you would need 5 characters or more:</p>

<pre><code>a=(char *)calloc(5, (sizeof(char)));
</code></pre>
",0
3186165,3186140,1,"<p>You need to store a terminating <code>\0</code> after that <code>DATA</code> string so <code>printf()</code> will know to stop printing.</p>

<p>You could replace <code>memcpy</code> with <code>strcat</code>:</p>

<pre><code>strcat(s, a);
</code></pre>

<p>should do it.</p>

<p>Note, however, that there's a bug earlier on:</p>

<pre><code>calloc(1,sizeof(char)) 
</code></pre>

<p>will only allocate a single byte! That's certainly not enough! Depending on the implementation, your program may or may not crash.</p>
",0
3186172,3186140,2,"<p>strlen does only count the chars without the terminator '\0'.
Without this terminator printf does not know the end od the string.</p>

<p>Solution:
memcpy(s,a,(strlen(a)+1));</p>
",0
3186861,3186140,2,"<p>Your</p>

<pre><code>a=""DATA"";
</code></pre>

<p>trashes the pointer to the allocated memory. It does not copy ""DATA"" into the memory. Which however would be not enough to store it, since</p>

<pre><code>a=(char *)calloc(1,(sizeof(char))); 
</code></pre>

<p>allocates a single char. While</p>

<pre><code>memcpy(s,a,(strlen(a)));
</code></pre>

<p>copies what is pointed now by a (string literal ""DATA"") to the memory which is pointed by s. But again, <code>s</code> points to a single char allocated, and copying more than 1 char will overwrite something and results in a bug.</p>

<p><code>strlen(a)</code> gives you 4 (the length of ""DATA"") and memcpy copies exactly 4 char. But to know where a string ends, C uses the convention to put a final ""null"" char ('\0') to its end. So indeed ""DATA"" is, in memory, 'D' 'A' 'T' 'A' '\0'.</p>

<p>All string related function expect the null byte, and they don't stop printing until they find it.</p>

<p>To copy strings, use instead <code>strcpy</code> (or <code>strncpy</code>), it copies the string with its final null byte too. (<code>strcpy</code> is less ""secure"" since you can overflow the destination buffer).</p>

<p>But the biggest problem I can see here is that you reserve a single char only for a (and you trash it then) and s, so DATA\0 won't fit anywhere.</p>
",0
4911409,4911401,2,"<p>In C, any non-zero value is considered ""true"", so <code>while (*ptr)</code> will loop as long as <code>*ptr</code> is non-zero.</p>
",0
4911414,4911401,0,"<p>In C anything zero is considered false and anything else is considered true.  That code is essentially saying ""while ptr isn't null"", which given null terminated string is a common way to walk though a string.</p>
",2
4911415,4911401,0,"<p>C expects the condition of a <code>while()</code> clause to be an integer.  If the integer is zero, the while loop exits, otherwise it executes it's body and evaluates the condition again.  A wide variety of things count in C as integers, including characters.  the character <code>'\0'</code> (the null character) is equal to the integer <code>0</code></p>
",0
4911416,4911401,0,"<p>In C, any non-zero value is considered true.</p>
",0
4911445,4911401,0,"<p>This is an idiom used to iterate through a C-string since C-strings are defined to be NUL terminated.  This works because the NUL character <code>\0</code> has a value of zero and as you may know, a value of zero will cause the <code>while()</code> loop to terminate.</p>
",0
4911456,4911401,0,"<p>Since in C the most common string type is the null terminated string it makes sense to loop like so sometimes</p>

<pre><code>while(*ptr)
{
    printf(""%c"", *ptr);
    ptr++;
}
</code></pre>

<p>Which essentially moves from character to character in a character array until the null character is encountered. Of course this is bad form since <code>'\0'</code>, <code>null</code> and <code>0</code> need not be the same on a given system, but works on 99% of environments.</p>
",1
4911464,4911401,1,"<p>Let's expand on this a little.</p>

<p>The while syntax in C means ""if the conditional is true, do the body; then if it's still true, do the body again.""</p>

<p>As casablanca notes, any value of 0 in C is ""false""; any non-zero value is ""true"".  (It's worth considering why they chose that; you can get a good hint if you look at the PDP-11 instruction set.)  So you can expand that out to</p>

<pre><code> while /* the expression *ptr is nonzero*/)
     /* do this */
</code></pre>

<p>The expression <code>*prt</code> means simply <code>whatever is at the address stored in ptr</code>.  </p>

<p>The usual sort of code where this pattern is used is in string processing.  Say we have</p>

<pre><code> char myString[] = ""Hello, world!"" ; // remember char myString[] is equivalent
                                     // to char * myString in C

 char * ptr = myString;              // note ptr points to myString[0]

 while(*ptr){
   putc(*ptr);
   ptr ++;
 }
</code></pre>

<p>Now as long as ptr points to a character in the string, it's non-zero, and the loop continued.  but by convention in C, all strings end with a NUL, ie, a byte-wide 0.  So
when the loop reaches that last NUL, *ptr is 0, and the loop ends.</p>

<p>You could write it more tersely by</p>

<pre><code> char * ptr = myString;
 while(*ptr) putc(ptr++);
</code></pre>

<p>Puzzle: Can you write this more tersely still?</p>
",1
3316581,3316539,1,"<p>Your virtual address space should be 2^32 bytes on a 32-bit platform without PAE enabled. Seems like your platform is allowing you to allocate about half of that before putting its foot down.</p>
",0
3316554,3316539,1,"<p>Hard to say - it depends on how the underlying OS gives you memory.</p>

<p>Its not necessarily physical memory, it could reside in swap space, or it may not allocate anything at all, choosing instead to do the allocation when you <em>use</em> the memory, rather than when you ask to allocate it.</p>
",0
3316557,3316539,0,"<p>The basic notion here is that <code>malloc</code> is assigning free memory blocks from <em>virtual memory</em>.</p>

<p>So do not expect to have only <code>128M</code> of free memory, but more than that, depending on where your operating system is allocating memory from.</p>
",0
3316558,3316539,4,"<p>Because your program is allocating <a href=""http://en.wikipedia.org/wiki/Virtual_memory"" rel=""nofollow noreferrer"">virtual memory</a>. In a 32-bit process (on Windows - other operating systems are slightly different), you typically get 2GB of <em>virtual address space</em> in which to allocate memory. The operating system them maps that memory between a ""swap file"" and physical memory (in your case, since you only have 128MB of physical memory, the majority of the memory you allocate will be in the swap file only).</p>

<p>So 100MB * 20 = ""around"" 2GB, and that explains why you can run through 20 loops.</p>
",3
3316572,3316539,2,"<p>Since you don't actually do anything with the memory, you can probably get the kernel to over-commit (i.e. give you more memory than it could actually provide) by using virtual memory.</p>

<p>And 20 times 100M is pretty near 2GB, so it looks like you're using a 32 bit OS that reserves 2GB for OS use, leaving a 2GB address space for user-space processes. So 2GB is the absolute maximum amount of memory you could possibly address in such a process, no matter how much memory your computer actually has.</p>
",1
5599398,5599380,2,"<p>Example:</p>

<pre><code> while (!kbhit())
     ;
</code></pre>

<p>Should be self-explanatory.</p>
",0
5599399,5599380,16,"<p>After a label at the end of a function (or more precisely, at the end of any block), e.g.</p>

<pre><code>void foo(void)
{
    // ...

exit:
    ;
}
</code></pre>
",5
5599405,5599380,18,"

<pre><code>while (*(dst++) = *(src++))
    ;
</code></pre>
",0
5599413,5599380,5,"<pre><code>while (somethingWithSideEffects()) ;
</code></pre>
",0
5599420,5599380,24,"<p>It's typically the side-effect of a code block that was stripped by the preprocessor, like</p>

<pre><code>#if DEBUG
    #define ASSERT(_x) Assert(_x)
#else
    #define ASSERT(_x)
#endif


ASSERT(test);    // Results in null statement in non-debug builds
</code></pre>

<p>That, or in loops where your condition already contains whatever needs to be done in each iteration.</p>
",2
5599437,5599380,1,"<p>The only uses I can think of are:</p>

<p>1- At the end of a loop, where the operations are already encoded within the loop statements. e.g. <code>while(a[i--]);</code></p>

<p>2- At the end of a label, where no operation is needed to be done. e.g. <code>Label: ;</code></p>
",0
5599461,5599380,1,"<p>Unit tests for a compliant compiler.</p>
",0
5599465,5599380,2,"<p>I can think of <code>scanf</code> validation. <code>scanf</code> gets stuck when user didn't give the correct input. So, to prevent <code>scanf</code> from being stuck, characters until end of line must be removed.</p>

<pre><code>if( scanf(""%d"",&amp;integer) == 0 )
{
    while( getchar() != '\n' ) ;
    // ....
}
</code></pre>
",0
5599505,5599380,4,"<p>I have used it, albeit rarely, in a possibly unusual situation (and one that some/many people would find wrong).  I have had to sometimes write a very complex <code>if</code> condition without an <code>else</code> clause where the if condition has to be negated.  Obviously it can be something like this:</p>

<pre><code>if ( !( overly complex condition ) )
  {
  do stuff
  }
</code></pre>

<p>It sometimes makes more sense (to me at least) to think of it in terms of positive logic.  In other words, if the <code>overly complex condition</code> holds true, I don't want the code to run.  So I have instead written it as:</p>

<pre><code>if ( overly complex condition )
  ;  // do nothing
else
  {
  do stuff
  }  
</code></pre>
",1
5599555,5599380,0,"<p>It's more of a null expression rather than a null statement, but it's often found in for loops.</p>

<pre><code>for (;;)                 // Loop ""forever""

for (int i=10; i--; )    // 9..0
</code></pre>

<p>etc</p>
",2
4185860,4185750,2,"<p>As far as I can see, you want to put the split strings into <code>param</code> as an array of pointers (presumably making the caller responsible for freeing them). In the first branch of the if statement in your loop, you do so by assigning the current <code>temp</code> buffer to that place. However, once you start a new string (when <code>comnmand == 0</code>, you free that space, rendering the previous <code>param</code> entry pointer invalid. </p>

<p>Only free each pointer once. I wouldn't rule out other leaks in this code: I think you can simplify your state machine (and probably find other bugs as a result). </p>
",0
4185919,4185750,0,"<p>It's hard to understand your code. I suggest you use sscanf instead.</p>

<p>You can use a format string like this:</p>

<pre><code>""\""%[^\""]\""%n""
</code></pre>

<p>Read up on what it does.</p>

<p>I wrote an example:</p>

<pre><code>if( sscanf( string, ""\""%[^\""]\""%n"", matchedstring, &amp;bytesread ) )
{
    handlestring( matchedstring );
    string += bytesread;
}
else if( sscanf( string, ""%s%n"", matchedstring, &amp;bytesread ) )
{
    handlestring( matchedstring );
    string += bytesread;
}
else
{
    handleexception();
}
</code></pre>

<p>Untested. :)</p>
",1
4185807,4185750,0,"<p>Maybe you're not removing the right free()'s? The actual problem might be in the code that calls split_string. Can you show it?</p>
",1
4186025,4185750,0,"<p>Thanks to all the comments i found the answer.
The problem was that the first malloc before the for loop is superfluous as there will be another one before it starts to put temp into param and therefore there were no pointers to the first malloc so it was simply lost.</p>
",0
4185834,4185750,1,"<p>When you free the temp buffer you also free the param[] buffer, where your tokens are stored. On the other hand, if you don't call <code>free(temp)</code>, which you shouldn't, it will be the responsibility of the caller of your function to call <code>free(param[n])</code>, when the tokens aren't needed.</p>
",1
3317606,3317537,21,"<p>Does it matter what it costs? Really?</p>

<p>The true answer is ""it depends"".</p>

<p>It depends on loads of things</p>

<ul>
<li>What else the OS is doing at the time</li>
<li>How fragmented memory has become</li>
<li>speed of the memory and processor on the client PC</li>
<li>etc</li>
</ul>

<p>If this code is massively performance critical, them <strong>time everything</strong> you can and work out the best pattern for your usage case. </p>

<p>If it is isn't the most performance critical bit of code, just do whatever is the <strong>clearest and simplest to implement and maintain</strong>.</p>

<p><em>""We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil"", Donald Knuth</em></p>
",11
3317621,3317537,4,"<blockquote>
  <p>Is it really worth it?</p>
</blockquote>

<p>You will have to measure in order to know, period. </p>
",6
3317624,3317537,1,"<p>In addition to what @rikh highlighted, if you want ultra fast memory allocation, one technique is to pre-allocate blocks that are the size you need (lots of them).</p>

<p>I've written custom memory managers that have pre-allocated lists of blocks of different sizes.</p>

<p>In addition, you can also incorporate a memory bounds checking scheme into the blocks you are managing.</p>
",1
3317643,3317537,5,"<p>malloc() does not have a fixed cost in terms of latency because of the numerous possible states the memory manager has to deal with to fulfill your request.</p>

<p>Since your node sizes are relatively small, you should consider always doing an allocation of some larger size, perhaps 10 or more node sizes per allocation and stuffing the extra ones into your unused pool.  That way you'll incur allocation uncertainly less frequently.  But more importantly, you'll reduce the amount of memory fragmentation caused by so many tiny allocations.</p>

<p>Incidentally, I don't consider this sort of design consideration ""Premature Optimization"" since you aren't looking for an excuse to inject obtuse design characteristics without good reason.  Data structures which can grow to arbitrary size and persist for arbitrary durations do need a little bit of forethought.</p>

<p>Particularly since data structures tend to find their way into unplanned usages later and often by other developers, it is important to strike a reasonable balance in terms of clarity and anticipated behavior.</p>

<p>Write your structure proper with your own allocation and deallocation functions.  Implement those separately.  Initially have them just malloc and free a single node to make debugging easier.  Later you can redesign them with fancier algorithms as your needs dictate.</p>
",0
3317765,3317537,0,"<p>It's worth finding out what the minimum allocatable block is in your target OS. You may be better off malloc()ing in 4K blocks and using that as your unused pool.</p>
",0
3317791,3317537,1,"<p>You might want to look into pooled allocators; AT&amp;T's <a href=""http://www2.research.att.com/~gsf/download/ref/vmalloc/vmalloc.html"" rel=""nofollow noreferrer""><code>vmalloc</code></a> package provides pooled allocator for example.</p>
",0
3907220,3907151,2,"<p>Let's start with the inside of the onion:</p>

<pre><code>struct error
{
    int warning, error, exception;
};
</code></pre>

<p>That defines a struct called <code>error</code> with 3 elements: <code>warning</code>, <code>error</code>, and <code>exception</code>.</p>

<p>To use it, you could have replaced the <code>error g1;</code> line in your <code>main</code> function with <code>struct error g1;</code>. Then you wrap that struct definition in a typedef, which essentially tells the compiler that there's a type <code>error</code> that's equivalent to <code>struct error</code>. The names are all in independent spaces: types, a struct, and elements in that struct. So they don't clash. That said, it's a bit cleaner to write</p>

<pre><code>typedef struct
{
    int warning, error, exception;
} error;
</code></pre>

<p>since it doesn't give the struct 2 names. The first version I gave is also valid; some people prefer to be explicit about their usage of structs.</p>
",0
3907224,3907151,2,"<p>What is it that you don't understand in this code? <code>error</code> is not a reserved word in C, so you are free to use it as a (variable/struct) name.</p>

<p>You defined a <code>struct</code> containing 3 <code>int</code> fields, instantiated it as a local variable <code>g1</code>, assigned 1 to one of its fields, then printed that field on the standard output. If you have any more specific questions, please clarify.</p>
",0
3907247,3907151,1,"<p>You defined a struct <code>error</code> that has an <code>int</code> member named <code>error</code>. You defined a typedef (in other words, an alias) for <code>struct error</code>, named <code>error</code>. You then created an instance of <code>struct error</code>, named <code>g1</code>, using the typedef name. Then, you assigned the value <code>1</code> to the <code>error</code> member of the <code>error</code> instance <code>g1</code>. Finally, you printed the value of <code>g1.error</code>.</p>

<p>Struct names and typedef names occupy separate namespaces &mdash; they can be the same. In C, you <em>must</em> put the keyword <code>struct</code> before structs' names:</p>

<pre><code>struct S{ /*...*/ };

struct S instance1;
</code></pre>

<p>But not before typedef names:</p>

<pre><code>struct S{ /*...*/ };
typedef struct S S;

S instance2;
</code></pre>

<p>You can also typedef unions and enums. You can combine a struct definition with a typedef definition:</p>

<pre><code>typedef struct S { /* ... */ } S;
</code></pre>

<p>And you can omit the struct name:</p>

<pre><code>typedef struct { /* ... */ } S;
</code></pre>

<p>In this case, the struct type can only be referred to via the typedef.</p>
",0
3907256,3907151,1,"<p>This is a pretty basic use of a typedef struct in c.  I'd recommend you visit <a href=""http://en.wikipedia.org/wiki/Struct_%28C_programming_language%29"" rel=""nofollow"">the wikipedia page on structs</a> for a general overview, but in short:</p>

<p>The first line creates a new structure type <code>struct error</code> which contains 3 integers: <code>warning</code>, <code>error</code>, and <code>exception</code>.  The typedef acts as an alias renaming the <code>struct error</code> to just <code>error</code> so you can refer to items of this type by just the short name.</p>

<p>The code inside main then creates a new <code>error</code> on the stack, sets its <code>error</code> property to 1, and then prints it out.</p>
",0
6380891,6380869,8,"<p>Try u_char (well <code>unsigned char</code>, R is right) test;</p>

<p>char is signed for you and is being converted to an int.  If the high bit 0x80 is set, it is becoming a negative number.</p>
",1
6380907,6380869,3,"<p>Since test is a <em>signed</em> char, and 0x85 and 0x95 (actually anything between 0x80 and 0xFF) has the high-order bit set, the result will set signed-extended with 1's when it's promoted from char to int.</p>

<p>Try declaring test as unsigned char.</p>
",0
6380911,6380869,2,"<p>As a small extension to Seth's answer, You are printing an int-wide hexadecimal number. (That's what your format string is saying to do).</p>

<p>If you wanted to print a char sized hex number, you could use:</p>

<pre><code>printf(""test hex: %2hhx\n"", test);
</code></pre>
",0
5559732,5559701,9,"<p>A segmentation fault couldn't possibly occur when you compile. Unless, well, the compiler violates memory safety, which is unlikely. I'll take it that it happens when you run the program :D.</p>

<p>The problem is here:</p>

<pre><code>*filename = argv[1];
</code></pre>

<p>It should be:</p>

<pre><code>filename = argv[1];
</code></pre>

<p>Why? You declared a pointer to <code>char</code>, unitialized, poiting nowhere in particular. Then, you <strong>dereferenced</strong> that pointer and assigned data to that memory position. Which is, well, who knows where!</p>

<p>Edit: you also dereference <code>filename</code> in the <code>printf()</code> call. Remove that <code>*</code> :).</p>

<p>Also, didnt' the compiler shoot a warning when you assigned *filename? Making integer from pointer without a cast, would be my guess? <strong>Pay attention to the warnings</strong>, they provide useful information!</p>

<p>Cheers.</p>
",3
5559746,5559701,3,"<p>In the statement <code>*filename = argv[1];</code>, the expression <code>*filename</code> attempts to dereference (find the value pointed to) the <code>filename</code> pointer, which is not yet pointing anywhere meaningful.</p>

<p>Change the assignment to <code>filename = argv[1]</code>.  </p>
",0
5559762,5559701,4,"<p>You're not making <code>filename</code> point to the same place as <code>argv[1]</code>. To do that you need</p>

<pre><code>filename = argv[1];
</code></pre>

<p>With your version (<code>*filename = argv[1];</code>) you're trying to make whatever filename points to have the value that is in argv[1]. There's lots of stuff wrong with this: a) filename is not initialized and can point anywhere, even invalid locations; b) <code>argv[1]</code> is of type <code>char*</code> and you're trying to put it into a location of type <code>char</code>!</p>
",0
5559778,5559701,1,"<p>You're dereferencing the char* when you try to assign it, so you're trying to stuff a pointer into a char. And since filename is uninitialized, you're trying to hit some random address (or perhaps address 0x00000000. And your print statement, if you got that far, wouldn't work either: you're again dereferencing the char* (to get a char) and then telling printf to interpret that as a pointer to a nul-terminated string.</p>

<p>Try this:</p>

<pre><code>char *filename ;
filename = argv[1] ;
printf( ""The filename is: %s"" , filename ) ;
</code></pre>
",0
3723125,3723120,9,"<pre><code>char mystring[] = ""1234567"";
</code></pre>

<p>Each digit is going to be <code>mystring[n] - '0'</code>.</p>
",0
3723139,3723120,3,"<p>What Delan said. Also, it's probably bad practice for maintainability to use a ASCII dependent trickery. Try using this one from the standard library:</p>

<pre><code>int atoi ( const char * str );
</code></pre>

<p>EDIT: Much better idea (the one above has been pointed out to me as being a slow way to do it) Put a function like this in:</p>

<pre><code>int ASCIIdigitToInt(char c){
    return (int) c - '0';
}
</code></pre>

<p>and iterate this along your string.</p>
",7
3723140,3723120,2,"<p>Don't forget that a string in C is actually an array of type 'char'. You could walk through the array, and grab each individual character by array index and subtract from that character's ascii value the ascii value of '0' (which can be represented by '0').</p>
",0
8253559,8253489,1,"<p>There are a few ways:</p>

<ol>
<li>Return value using the return statement (as you already know)</li>
<li>Return via references.</li>
<li>Return values via the heap.</li>
<li>Return values via global variables.</li>
</ol>
",2
8253585,8253489,27,"<p>The tricky problem is that the interviewer has some solution they are particularly happy with in mind and they are likely grading you by whether you have the same clever trick as them or not.</p>

<p>You could just name a few ways such as you did, and still not fall upon their secret trick.  And if you knew their secret trick, you could well not be impressed with it.</p>

<p>So in these situations, its to turn it from interview into conversation.  Once you detect you're not moving towards their ego, you can avoid heading towards the intimidating ""I don't know"" ""I give up"" and instead try out the ""so do you have any clever solution?  Is there an in-house recipe for this at Xyz Inc?"" etc.</p>

<p>Any glimpse at their obviously self-impressed solution and you are back on firm ground where you can talk about it and ask them if they have thought about various factors that come to mind and basically interview them.</p>

<p>Everyone loves a good listener, and getting them to talk about their tricks is a good way to get them to leave the interview throughly impressed with you! ;)</p>
",2
8253632,8253489,0,"<p>Return a pointer to a structure, or pack several small datatypes into one large datatype, or use global variables.<br>
The first is probably the cleanest way to do it, the other two might have their uses in certain situations.</p>

<p>If we pass the address instead of the true value of the parameters.<br>
Then whenever we refer those parameters we do it with the address.</p>
",0
8255254,8253489,1,"<p>That depends on what you consider <em>a value</em>. If a value is a piece of information for you, <em>more values</em> could be a struct of values. More values could be also passed via pointers or arrays, even a <code>char*</code> containing a list of (non-zero alphanumerical) <em>values</em>. If you consider a value to be a bit of information a single returned <code>uint32_t</code> may hold 32 <em>values</em>. You could even mess around with signals or sockets or pipes or files.</p>

<p>But for you do not even know the use case and the requirements it imposes on the solution, it's indeed a rather hard task to come up with <em>the</em> right solution (and you actually <em>did</em> come up with some proper solutions ...).</p>
",0
3743472,3743444,3,"<p>A few issues:</p>

<p>1.&nbsp;You should be using '9' and '0', since you want the ASCII values for digit '9' (0x39) and '0' (0x30), not 0x9 and 0x0.</p>

<pre><code>if ( (c&gt;'9') || (c&lt;'0') ) { 
</code></pre>

<p>2.&nbsp;!= has higher precedence than =, so you need parens.  Learn <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence"" rel=""nofollow noreferrer"">operator precedence</a>, and if you're in doubt, use parens:</p>

<p>3.&nbsp;<code>getchar</code> is a function not a variable.</p>

<pre><code>while ((c = getchar()) != '\n') { 
</code></pre>

<p>4.&nbsp;  You use the wrong conversion.  <code>num</code> is a double, so you would need <code>%f</code>.  Or, you could make <code>num</code> a <code>int</code>.</p>

<pre><code>printf(""Please input number %f: "", num);
</code></pre>

<p>5.&nbsp;You never actually use c in any way (except error checking).  You always return 0 or <code>num</code> (see your else clause), which makes no sense.  The else body of the original is correct.</p>
",2
3743480,3743444,1,"<p>You got the floating point parsing all wrong and shouldn't be doing it yourself. There's an easier way:</p>

<pre><code>double get_number(double num) { 
  double value = 0.0;
  printf(""Please input number %lf: "", num);
  scanf(""%lf"", &amp;value);
  return(value);
}
</code></pre>
",2
3744008,3743444,1,"<p>Here's how I'd go about correcting the code ...</p>

<ol>
<li><a href=""http://ideone.com/a0UMm"" rel=""nofollow noreferrer"">http://ideone.com/a0UMm</a> -- compilation errors</li>
<li><a href=""http://ideone.com/ljUg1"" rel=""nofollow noreferrer"">http://ideone.com/ljUg1</a> -- warnings, but it works now</li>
<li><a href=""http://ideone.com/Qd0gp"" rel=""nofollow noreferrer"">http://ideone.com/Qd0gp</a> -- no errors, no warnings, test run ok</li>
</ol>

<p>For 1. I used the ""original code"" as posted by you.</p>

<p>For 2. I used <code>int main(void)</code>, declared the function <code>get_number</code> before defining <code>main</code>, added parenthesis in line 20, and added <code>#include &lt;stdlib.h&gt;</code></p>

<p>For 3. I added <code>return 0;</code> before the final <code>}</code> of <code>main</code>. I also removed the extra output that messed up the ideone interface (it looks better on an interactive interface)</p>

<hr>

<p><strong>Edit</strong> more tests needed to complete the task of correcting the original code</p>
",1
3743521,3743444,1,"<p>The issues with the <strong>original</strong> program are:</p>

<ol>
<li>getchar() returns an ASCII code, and the condition was wrong. When checking for boundaries, use <code>((c&lt;'0') || (c&gt;'9'))</code>. </li>
<li>For the <code>exit</code> function you need to include ""stdlib.h"".</li>
<li>For the <code>main</code> function to understand what is <code>get_number</code>, you need to either move the function to be before the <code>main</code> function, or you can use a forward declaration.</li>
<li>The assignment operator (<code>=</code>) has lower precedence than the inequality operator (<code>!=</code>), so you need to use parenthesis, like: <code>((c = getchar()) != '\n')</code></li>
</ol>

<p>You have actually created several more issues, so I wouldn't rely on your code. </p>

<p>In any case, in general - it is advised you study how to use a debugger. Once your code is compiling (and for that you'll need to get accustomed to the compilation error messages), you need to start debugging your code. I suggest you take some time to learn how to set breakpoints, set watches, and go step by step into your code. That skill is absolutely essential for a good developer. </p>
",1
4435895,4435875,5,"<p>That's not a valid expression. <code>...</code> simply means the caller can pass in more arguments than the number of parameters the function formally specifies.</p>
",0
3831944,3831858,1,"<p>myPointer is an array of (20) pointers to characters. myFriend[0] is an array of (150) characters. The types do not match. </p>

<p>Essentially, myFriend[0] is the address of the first character of a sequence of characters. This is the address of the letter 'T' in ""The car was finally discovered...."".</p>

<p>myPointer is an array of 20 pointers to characters. See the difference? Also, you cannot perform the assignment even if types matched, because myPointer (the address of the array of 20 pointers to characters) is a constant value. I believe the C standard specifically states this is undefined behavior.</p>

<p>Refer to the right-left walk method: <a href=""http://www.cs.uml.edu/~canning/101/RLWM.pdf"" rel=""nofollow"">www.cs.uml.edu/~canning/101/RLWM.pdf</a></p>
",0
3831948,3831858,4,"<p>You've defined <code>myPointer</code> to be an array of character pointers:</p>

<pre><code>char *myPointer[20];
</code></pre>

<p>But you're assigning to it an array of characters:</p>

<pre><code>myPointer = myFiend[0];
</code></pre>

<p>Which is equivilent to:</p>

<pre><code>myPointer = ""... stuff ..."";
</code></pre>

<p>Possibly you mean either to make <code>myPointer</code> simply a pointer to a string:</p>

<pre><code>char *myPointer;
myPointer = myFriend[0];
</code></pre>

<p>or you mean to make the first string pointed to by <code>myPointer</code> the <code>myFriend[0]</code> string:</p>

<pre><code>myPointer[0] = myFriend[0];
</code></pre>
",0
3831961,3831858,0,"<pre><code>char* myPointer[20];
char myFriend[][150];
/* ... */
myPointer = myFriend[0]; /* error! */
</code></pre>

<p><code>myFriend[0]</code> is an array of 150 chars.  It can be automatically converted to a <code>char*</code> pointer pointing at the first element.  But <code>myPointer</code> is an array of pointers.  You can't assign anything to that.  The assignment would be valid if the type of myPointer were (for example) <code>char* myPointer;</code></p>
",0
3845691,3845590,2,"<p>The only thing wrong (<em>half wrong</em>) with your program is <code>main</code> signature.</p>

<p>To be 100% portable it should be <code>int main(void)</code> or <code>int main(int argc, char **argv)</code> or equivalent: <code>int main()</code> is not equivalent.</p>

<hr>

<p>And I'd print a <code>'\n'</code> too, or flush the output buffer rather than relying on the runtime flushing all buffers for me automatically, but your program should sound the bell as it is. If it doesn't the problem is elsewhere, not with <code>C</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf(""\a\n"");
    return 0;
}
</code></pre>
",7
3845750,3845590,1,"<p>I agree with @Steve Jessop.  People will go to great lengths to keep their computers quiet.</p>

<p>In Windows: As an alternative to ""\a"", you could use WinAPI's Beep command.  If you are using Windows 7, this may not work as expected.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms679277%28VS.85%29.aspx"" rel=""nofollow"">Beep Function (Windows)</a></p>
",0
3852112,3852050,0,"<p>in addiction to dmckee post, you must think of how you build your structure:
if it's something like a b-tree, a list. an array of pointer to other dinamically allocated structure, well, in this case you must FIRST free childrens (for example, child node of a b-tree) and than go back to the root (maybe recursively, depending on the structure).
It's a very common mistake and it can cause lot of memory leak</p>
",0
3911896,3911875,3,"<p>The first call to <code>fun1</code> here  <code>ret = fun1(color[offset]);</code> returns <code>3</code> as <code>color[0][3]</code> and <code>color[0][4]</code> are both <code>|</code>.</p>

<p>Then you add <code>ret</code> to <code>offset</code> making it <code>3</code>.</p>

<p>In the next call to <code>fun1</code> you pass it <code>color[offset]</code> which is <code>color[3]</code> which is <code>""\0""</code>, note that this is <strong>not</strong> <code>NULL</code> its a string literal containing only the <code>nul</code> character.</p>

<p>To clarify:</p>

<pre><code>char *str = NULL;  // str is null pointer.
char *str = 0;     // same as above.

char *str = ""\0"";  // str is pointer to an empty string literal.
char *str = """";    // same as above.
</code></pre>
",0
3911900,3911875,0,"<p>When you add to offset, it is going to advance by the number equal to ret. So, it advances 3 places, which brings it to an offset of 3, so <code>color[offset] = color[3] = ""\0""</code>. When you then call fun1, it will loop forever because there are no <code>|</code> characters. This continues until something terrible and undefined happens.</p>
",0
3922511,3922500,2,"<p>This is generally not possible - see <a href=""http://c-faq.com/misc/symtab.html"" rel=""nofollow"">http://c-faq.com/misc/symtab.html</a>.</p>
",5
3922529,3922500,0,"<p>I'm afraid that without using debug info api (which depends on the platform your in) or using some kind clever trickery with register the pointer in a lookup table it is just not possible.</p>
",0
3922715,3922500,0,"<p>As Ofir <a href=""https://stackoverflow.com/questions/3922500/print-the-name-of-function-assigned-to-a-function-pointer/3922511#3922511"">says in his answer</a>, you basically cannot do that. The names of the functions only exist before linking is done (they may endure afterwards in debugging data). After link it's only pointers.</p>

<p>If you're willing to store the function addresses somewhere and compare to them, you can do somewhat like this:</p>

<p>$ cat 3922500.c</p>

<pre><code>#include &lt;stdio.h&gt;

char *fxname(void *fx) {
  if (fx == fprintf) return ""fprintf"";
  if (fx == gets) return ""gets"";
  if (fx == scanf) return ""scanf"";
  return ""(unknown)"";
}

int main(void) {
  void (*fx)(void);
  fx = gets; printf(""name: %s\n"", fxname(fx));
  fx = putchar; printf(""name: %s\n"", fxname(fx));
  return 0;
}
</code></pre>

<p>$ gcc 3922500.c</p>

<pre>
3922500.c: In function 'main':
3922500.c:12: warning: assignment from incompatible pointer type
3922500.c:13: warning: assignment from incompatible pointer type
/tmp/ccvg8QvD.o: In function `fxname':
3922500.c:(.text+0x1d): warning: the `gets' function is dangerous and should not be used.
</pre>

<p>$ ./a.out</p>

<pre>
name: gets
name: (unknown)
</pre>
",0
3922580,3922500,0,"<p>Depending on your compiler, you might be able to use a pre-defined macro.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/b0084kay(VS.71).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/b0084kay(VS.71).aspx</a></p>
",0
5132666,5132649,0,"<p>They are some macro defined somewere in your library. Do a text search in all the files and you probably finfd what they exactly defines. By using some paranormal diagnosys strategy I guess that TIDY export is some decoration to export the function from the library ( ie declspec(dllexport) in MS compilers, and TIDY_CALL specify the calling convention ( ie stdcall, pascal, and so on ) </p>
",1
5132672,5132649,2,"<p>TIDY_EXPORT and TIDY_CALL are macros. They are defined in <a href=""http://tidy.sourceforge.net/docs/api/platform_8h-source.html"" rel=""nofollow"">platform.h</a>.</p>
",1
5132674,5132649,3,"<p><code>TIDY_EXPORT int TIDY_CALL</code> are just modifiers to your function.</p>

<p>The function name is <code>tidyDetectedHtmlVersion</code>, it takes one parameter (<code>tdoc</code>) of type <code>TidyDoc</code> and returns an <code>int</code>.</p>

<p><code>TIDY_EXPORT</code> is a macro defined in the <a href=""http://tidy.sourceforge.net/docs/api/platform_8h-source.html"" rel=""nofollow noreferrer""><code>platform.h</code></a> file which defined as</p>

<pre><code>00492 #if defined(_WIN32)
00493 
00494 #if (defined(_USRDLL) || defined(_WINDLL)) &amp;&amp; !defined(TIDY_EXPORT)
00495 #define TIDY_EXPORT __declspec( dllexport ) 
00496 #endif
</code></pre>

<p>which allows you to export the function when compiling the file as a library (e.g. dll)</p>

<p>As for <code>TIDY_CALL</code>, it's defined in the same file as:</p>

<pre><code>00498 #ifndef TIDY_CALL
00499 #ifdef _WIN64
00500 #  define TIDY_CALL __fastcall
00501 #else
00502 #  define TIDY_CALL __stdcall
00503 #endif
00504 #endif
</code></pre>

<p>See this question for an explanation <a href=""https://stackoverflow.com/questions/297654/what-is-stdcall"">What is __stdcall?</a></p>
",1
5132675,5132649,0,"<p>TIDY_CALL and so on are (It's my guess, but it's very probably) macros.
<a href=""http://www.google.pl/search?sourceid=chrome&amp;ie=UTF-8&amp;q=macros+C%2B%2B#sclient=psy&amp;hl=pl&amp;source=hp&amp;q=macros+C&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;pbx=1&amp;fp=58c095358c87453c"" rel=""nofollow"">http://www.google.pl/search?sourceid=chrome&amp;ie=UTF-8&amp;q=macros+C%2B%2B#sclient=psy&amp;hl=pl&amp;source=hp&amp;q=macros+C&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;pbx=1&amp;fp=58c095358c87453c</a></p>
",0
5132681,5132649,0,"<p>They are macros, you can find them in the source code somewhere. TIDY_CALL for example is in platform.h</p>

<pre><code> #ifndef TIDY_CALL
 #ifdef _WIN64
 #  define TIDY_CALL __fastcall
 #else
 #  define TIDY_CALL __stdcall
 #endif
 #endif
</code></pre>
",0
5132684,5132649,2,"<p>In platform.h you have </p>

<pre><code>#if (defined(_USRDLL) || defined(_WINDLL)) &amp;&amp; !defined(TIDY_EXPORT)
#define TIDY_EXPORT __declspec( dllexport )
#endif

#ifndef TIDY_CALL
#ifdef _WIN64
#define TIDY_CALL __fastcall
#else
# define TIDY_CALL __stdcall
#endif
#endif 
</code></pre>
",0
5132695,5132649,2,"<p>C is straightforward ... until macros get involved! Anything in ALL CAPS is probably a macro, which is a symbol which gets replaced with other text before compilation. That text can be defined to be anything, including an empty string. Luckily Doxygen has been used, so you can view the documentation <a href=""http://tidy.sourceforge.net/docs/api/tidy_8h.html"" rel=""nofollow"">http://tidy.sourceforge.net/docs/api/tidy_8h.html</a>.</p>

<p>The file that is included:</p>

<pre><code>#include ""platform.h""
</code></pre>

<p><a href=""http://tidy.sourceforge.net/docs/api/platform_8h-source.html"" rel=""nofollow"">which you can read here</a>, defines the macro. </p>

<p>For more info on macros in all their glory, <a href=""http://gcc.gnu.org/onlinedocs/cpp/Macros.html"" rel=""nofollow"">read this</a>.</p>
",0
5132703,5132649,1,"<p><code>TIDY_EXPORT</code> is #defined as <a href=""http://msdn.microsoft.com/en-us/library/3y1sfaz2%28v=vs.80%29.aspx"" rel=""nofollow"">__declspec(dllexport)</a> on Windows, to allow the function to be exported when Tidy is compiled as a DLL.</p>

<p><code>TIDY_CALL</code> is a macro that expands to a platform-specific <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions"" rel=""nofollow"">calling convention</a>.</p>

<p>Both of these features are nonstandard extensions to the C language (which is why they are abstracted behind conditionally-compiled macros).</p>
",0
7825943,7825903,0,"<blockquote>
  <p>It was also working correctly when the struct A had B apples[8],
  rather than B* apples[8]. However, using this solution does not
  maintain the changes made in functions outside of where they were
  made.</p>
</blockquote>

<p>Pass a pointer to the object to such functions and your changes will persist outside of them. The reason they didn't is because you were passing the object by value.</p>
",0
7825952,7825903,1,"<p><code>A</code> and <code>B</code> are not types, but instances of <code>struct a</code> and <code>struct b</code>. Perhaps you want to use the classic C idiom but you are missing a <code>typedef</code>:</p>

<pre><code>typedef struct a {
    ...
} A;
</code></pre>

<p>Now <code>struct a</code> and <code>A</code> are the same thing.</p>

<p>In your last code snippet, <code>(*b_list)[6].color</code> should actually be <code>(*b_list[6]).color</code> or better yet <code>b_list[6]-&gt;color</code>.</p>
",2
4667118,4667094,4,"<p>It's a declaration.  It says there is an integer <code>i</code> that will be defined elsewhere.</p>
",0
4667122,4667094,2,"<p>The extern keyword introduces a variable declaration, not a definition.  It says that somewhere in some source file there will be a variable defined with the given declaration, which allows the source file to reference the variable without hassle, but doesn't actually define the variable.  This allows one variable defined in one file to be shared and accessed across multiple source files without each file having its own independent copy.</p>
",0
4667137,4667094,1,"<p>B states that the variable <code>i</code> is defined elsewhere, typically in a different translation unit.  The <a href=""http://en.wikipedia.org/wiki/External_variable"" rel=""nofollow"">Wikipedia article</a> would not be a bad place to continue your research.</p>
",0
4667274,4667094,0,"<p>A) As well as declaring the variable i, it is actually implicit definition of i.</p>

<p>B) A declaration of i. You will need the variable i to be defined <a href=""http://en.wikipedia.org/wiki/External_variable#Example_.28C_programming_language.29"" rel=""nofollow"">some where</a>.</p>
",0
4667430,4667094,2,"<p>Case A) is a 'tentative defintion' with external linkage. You can have multiple of these in a single translation unit, and all will refer to the same variable. The definition  is called tentative because it will only zero-initialize the variable if there is no other definition with explicit initializer in the translation unit.</p>

<p>Case B) is a declaration but not a definition (tentative or otherwise), because there is no initializer present and no storage will be reserved. There must be a valid definition of the variable elsewhere in this or another translation unit. If there's a previous declaration of the variable with internal linkage in scope, the variable will have internal linkage, otherwise external, ie</p>

<pre><code>static int foo;
extern int foo;
</code></pre>

<p>results in a valid tentative definition with internal linkage, whereas</p>

<pre><code>extern int foo;
static int foo;    
</code></pre>

<p>is invalid as you have a declaration with external linkage followed by a (tentative) definition with internal linkage.</p>

<p>See C99 sections 6.2.2 and 6.9.2 for details.</p>
",0
5451679,5450908,1,"<p>Perhaps you have forgottent to convert tn C this line:
""divide each entry in row i by A[i,j]""
Something like:     </p>

<pre><code> for (k = j; k &lt;= num+1; ++k) {
        A[i][k] /= A[i][j];
    }
</code></pre>
",0
5450997,5450908,0,"<p>Looks like you're swapping the cell <code>A[maxi][j]</code> with <code>A[i][j]</code> but the algorithm calls for swapping the whole row maxi with i:</p>

<pre><code>swap rows i and maxi, but do not change the value of i
Now A[i,j] will contain the old value of A[maxi,j].
</code></pre>

<p>So you'll need an additional for loop, from [0, num+1) that does that swap:</p>

<pre><code>int x
for(x = 0; x &lt; num+1; x++) {
    p=A[maxi][x];
    A[maxi][x]=A[i][x];
    A[i][x]=p;
}
</code></pre>
",1
4337878,4337841,2,"<p><a href=""http://en.wikipedia.org/wiki/Static_variable"" rel=""nofollow"">http://en.wikipedia.org/wiki/Static_variable</a></p>

<p>In C a variable declared outside of functions as static will not be accessible from outside that file (can't use extern in another file..)</p>

<p>For a local variable in a function, static will make the lifetime of the variable last throughout execution of the program, not just a variable allocated on the stack.</p>

<p>When using static variables, it can really raise issues with multithreading because only one instance of the variable exists - so that needs to be kept in mind.</p>
",0
4337857,4337841,2,"<p>In C <code>static</code> means two different things, actually:</p>

<p>1) inside a function it means that the <code>static</code> variable will remain in existence after the function has exited</p>

<p>2) otherwise it means that the <code>static</code> variable or function is local to that compilation unit (¡°file¡±), i.e. not externally visible</p>
",1
4338283,4337841,8,"<p>There are 2 distinct uses of the <code>static</code> keyword in C:</p>

<ul>
<li>Static declarations in a function's scope</li>
<li>Static declarations outside of a function's scope</li>
</ul>

<hr>

<h2>(MOSTLY) EVIL: Static Variables in a function</h2>

<p>A static variable in a function is used as a ""memory"" state.</p>

<p>Basically, your variable is initialized to your default value only the first time you call it, and then retains its previous value in all the future calls.</p>

<p>It is potentially useful if you need to remember such state, but the use of such statics is usually <strong>frowned upon</strong> because they are pretty much <strong>global variables in disguise</strong>: they will consume your memory until the termination of your process once.</p>

<p>So, <em>in general</em>, making localized functions is <strong>EVIL</strong> / <strong>BAD</strong>.</p>

<p><strong>Example:</strong></p>

<pre><code>#include &lt;stdio.h&gt;


void  ping() {
  static int counter = 0;

  return (++counter);
}

int   main(int ac, char **av) {
  print(""%d\n"", ping()); // outputs 1
  print(""%d\n"", ping()); // outputs 2
  return (0);
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>1
2
</code></pre>

<hr>

<h2>(MOSTLY) GOOD: Static Variables outside of a function's scope</h2>

<p>You can use static outside of a function on a variable or function (which, after all, is sort of a variable as well and points to a memory address).</p>

<p>What it does is limit the use of that variable to the file containing it. You cannot call it from somewhere else. While it still means that that function/var is ""global"" in the sense that it consumes your memory until your program's termination, at least it has the decency to not pollute your ""namespace"".</p>

<p>This is interesting because that way you can have small utility functions with identical names in different files of your project. </p>

<p>So, <em>in general</em>, making localized functions is <strong>GOOD</strong>.</p>

<p><strong>Example:</strong></p>

<p><em>example.h</em></p>

<pre><code>#ifndef __EXAMPLE_H__
# define __EXAMPLE_H__

void  function_in_other_file(void);

#endif
</code></pre>

<p><em>file1.c</em></p>

<pre><code>#include &lt;stdio.h&gt;

#include ""example.h""

static void  test(void);


void test(void) {
  printf(""file1.c: test()\n"");
}

int   main(int ac, char **av) {
  test();  // calls the test function declared above (prints ""file1.c: test()"")
  function_in_other_file();
  return (0);
}
</code></pre>

<p><em>file2.c</em></p>

<pre><code>#include &lt;stdio.h&gt;

#include ""example.h""

static void  test(void); // that's a different test!!


void test(void) {
  printf(""file2.c: test()\n"");
}

void   function_in_other_file(void) {
  test();  // prints file2.c: test()
  return (0);
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>file1.c: test()
file2.c: test()
</code></pre>

<p><strong><em>PS</strong>: Don't start throwing stones at me if you're a purist: I know static vars are not evil, they're not exactly globals either, functions are not exactly variables, and there's no actual ""namespace"" (don't get started on symbols) in C. But that's for the sake of the explanation here.</em></p>

<h2>Resources</h2>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/Static_variable"" rel=""nofollow noreferrer"">Static Variables</a></li>
<li><a href=""https://stackoverflow.com/questions/1703980/is-static-variable-in-c-re-allocated-everytime-calling-a-function"">Is a Static Variable in C Reallocated Every Time I Call a function?</a></li>
<li><a href=""http://www.scribd.com/doc/16306895/Draft-ANSI-C-Rationale"" rel=""nofollow noreferrer"">A Draft of the ANSI C standard (C89)</a></li>
</ul>
",7
4366525,4366457,4,"<p>This is because the newline (return key) after feeding float is counted as a character.</p>

<p>This is not a bug but it is due to fact that ""\n"" is considered a character in C and if you have to ignore it, you need to do that manually. </p>

<p>The simplest solution for your case is to eat up the newline as follows:</p>

<pre><code>scanf(""%f"", &amp;number1);
getchar();
</code></pre>

<p>This <a href=""https://stackoverflow.com/questions/2187474/i-am-not-able-to-flush-stdin"">Link</a> will help.</p>
",2
4366544,4366457,3,"<p><code>scanf</code> reads the whitespace that is left in the buffer from the previous line. To skip the whitespace, add a space to the scanf:</p>

<pre><code>scanf("" %c"", &amp;letter);
</code></pre>

<p>The space means ""skip whitespace"" and the the %c means ""read the following character.</p>
",3
4339826,4339697,2,"<p>If you need to define something in a header file, make sure that anything that uses it includes that header. That includes other headers.</p>
",0
4339945,4339697,4,"<p>I would recommend putting defines that modify headers like that in the makefile instead of in the code. Otherwise you can't be sure which compilation units have one definition or the other, as you've experienced.</p>

<p>Sometimes modifying headers with macros is the intended behavior (e.g. using headers as templates) and sometimes it isn't (like in your case), so it is hard to produce meaningful warnings from a tool, I think. </p>
",0
4364795,4364772,3,"<p>Because the behaviour is undefined. The compiler is allowed to evaluate <code>a</code>, <code>a++</code> and <code>++a</code> in any order before passing them to <code>call()</code>. (Technically, because we've invoked undefined behaviour, it actually doesn't have to do anything in particular at this point; it may write whatever code it pleases.) Depending on what order they're evaluated in, the results differ.</p>
",12
4513406,4513316,1,"<p><code>malloc(0)</code> may (optionally) return <code>NULL</code>, depending on the implementation.  Do you realize why you may be calling <code>malloc(0)</code>?  Or more precisely, do you see where you are reading and writing beyond the size of your arrays?</p>
",2
4513437,4513316,103,"<p><a href=""http://www.cplusplus.com/reference/clibrary/cstring/strtok/"" rel=""noreferrer"">http://www.cplusplus.com/reference/clibrary/cstring/strtok/</a></p>

<p>Take a look at this, and use whitespace characters as the delimiter.  If you need more hints let me know.</p>

<p>From the website:</p>

<pre><code>char * strtok ( char * str, const char * delimiters );
</code></pre>

<blockquote>
  <p>On a first call, the function expects a C string as argument for str, whose first character is used as the starting location to scan for tokens. In subsequent calls, the function expects a null pointer and uses the position right after the end of last token as the new starting location for scanning.</p>
  
  <p>Once the terminating null character of str is found in a call to strtok, all subsequent calls to this function (with a null pointer as the first argument) return a null pointer.</p>
  
  <h1>Parameters</h1>
  
  <ul>
  <li>str
  
  <ul>
  <li>C string to truncate.</li>
  <li>Notice that this string is modified by being broken into smaller strings (tokens).
  Alternativelly [sic], a null pointer may be specified, in which case the function continues scanning where a previous successful call to the function ended.</li>
  </ul></li>
  <li>delimiters
  
  <ul>
  <li>C string containing the delimiter characters.</li>
  <li>These may vary from one call to another.</li>
  </ul></li>
  </ul>
  
  <h1>Return Value</h1>
  
  <p>A pointer to the last token found in string.
  A null pointer is returned if there are no tokens left to retrieve.</p>
  
  <h1>Example</h1>
</blockquote>

<pre><code>/* strtok example */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
{
  char str[] =""- This, a sample string."";
  char * pch;
  printf (""Splitting string \""%s\"" into tokens:\n"",str);
  pch = strtok (str,"" ,.-"");
  while (pch != NULL)
  {
    printf (""%s\n"",pch);
    pch = strtok (NULL, "" ,.-"");
  }
  return 0;
}
</code></pre>
",5
4513449,4513316,0,"<p>Something going wrong is <code>get_words()</code> always returning one less than the actual word count, so eventually you attempt to:</p>

<pre><code>char *newbuff[words]; /* Words is one less than the actual number,
so this is declared to be too small. */

newbuff[count2] = (char *)malloc(strlen(buffer))
</code></pre>

<p><code>count2</code>, eventually, is always one more than the number of elements you've declared for <code>newbuff[]</code>. Why <code>malloc()</code> isn't returning a valid ptr, though, I don't know.</p>
",2
4513510,4513316,4,"<p>For the fun of it here's an implementation based on the callback approach:</p>

<pre><code>const char* find(const char* s,
                 const char* e,
                 int (*pred)(char))
{
    while( s != e &amp;&amp; !pred(*s) ) ++s;
    return s;
}

void split_on_ws(const char* s,
                 const char* e,
                 void (*callback)(const char*, const char*))
{
    const char* p = s;
    while( s != e ) {
        s = find(s, e, isspace);
        callback(p, s);
        p = s = find(s, e, isnotspace);
    }
}

void handle_word(const char* s, const char* e)
{
    // handle the word that starts at s and ends at e
}

int main()
{
    split_on_ws(some_str, some_str + strlen(some_str), handle_word);
}
</code></pre>
",0
4513558,4513316,0,"<p>You should be malloc'ing strlen(ptr), not strlen(buf). Also, your count2 should be limited to the number of words. When you get to the end of your string, you continue going over the zeros in your buffer and adding zero size strings to your array.</p>
",0
4513611,4513316,0,"<p>Just as an idea of a different style of string manipulation in C, here's an example which does not modify the source string, and does not use <code>malloc</code>.  To find spaces I use the libc function <code>strpbrk</code>.</p>

<pre><code>int print_words(const char *string, FILE *f)
{
   static const char space_characters[] = "" \t"";
   const char *next_space;

   // Find the next space in the string
   //
   while ((next_space = strpbrk(string, space_characters)))
   {
      const char *p;

      // If there are non-space characters between what we found
      // and what we started from, print them.
      //
      if (next_space != string)
      {
         for (p=string; p&lt;next_space; p++)
         {
            if(fputc(*p, f) == EOF)
            {
               return -1;
            }
         }

         // Print a newline
         //
         if (fputc('\n', f) == EOF)
         {
            return -1;
         }
      }

      // Advance next_space until we hit a non-space character
      //
      while (*next_space &amp;&amp; strchr(space_characters, *next_space))
      {
         next_space++;
      }

      // Advance the string
      //
      string = next_space;
   }

   // Handle the case where there are no spaces left in the string
   //
   if (*string)
   {
      if (fprintf(f, ""%s\n"", string) &lt; 0)
      {
         return -1;
      }
   }

   return 0;
}
</code></pre>
",0
4513665,4513316,1,"<p>Consider using <code>strtok_r</code>, as others have suggested, or something like:</p>

<pre><code>void printWords(const char *string) {
    // Make a local copy of the string that we can manipulate.
    char * const copy = strdup(string);
    char *space = copy;
    // Find the next space in the string, and replace it with a newline.
    while (space = strchr(space,' ')) *space = '\n';
    // There are no more spaces in the string; print out our modified copy.
    printf(""%s\n"", copy);
    // Free our local copy
    free(copy);
}
</code></pre>
",0
4620737,4620696,1,"<p>Assuming the compiler doesn't optimize here, there is a small penalty paid in allocating the float on every loop. It would probably be better to declare the float outside of the loop.</p>

<p>It depends on the code though. Sometimes it's cleaner to declare the variable like that. The price you pay in performance is probably pretty small.</p>
",0
4620738,4620696,0,"<p>You don't initialize <code>b</code>, so you're invoking undefined behavior by using it.</p>

<p>If you're worried about performance issues, the compiler might just optimize the allocation away.</p>
",0
4620748,4620696,5,"<p>This is perfectly ok, and in fact I don't think it matters one bit in any decent compiler, if you only use the <code>float</code> inside the loop.</p>

<p>It does make sense for code clarity to put it in the loop, but it's a matter of taste mostly.</p>

<p>But beware for situations like</p>

<pre><code>int i,j;
for ( i=0;i&lt;count;i++ )
{
    int j;
    // stuff
}
</code></pre>

<p>I've seen similar situations not generate compiler warnings, which makes for hard to trace bugs.</p>

<p><strong>edit</strong> just tested, <code>gcc</code> does compile differently, but with <code>-O3</code> the generated assembly is identical. Test with <code>gcc -S file.c</code>. Update: <code>-O1</code> is enough, and it actually depends on the order you declare variables. If the <code>float</code> was declared below <code>int i;</code> in your example, the compiled assembly will still be identical.</p>
",2
4620814,4620696,-2,"<p>If you define a variable in a block (stuff enclosed by braces) it just restricts its scope, you can't use it outside. It just makes the program cleaner.</p>

<p>The program <em>may</em> allocate your variables on stack at the opening bracet and dropping at the closing bracet, but a good compiler should do it on the point of entering and leaving the subroutine (method).</p>

<p>Also, it's a C++ feature, and really a step forth to well-structured programming (and also it makes the C++ programming a bit like using script languages, where you don't need to declare variables, but don't tell this to serious C or Java programmers).</p>
",4
4621810,4620696,3,"<p>On pre-<a href=""http://en.wikipedia.org/wiki/C99"" rel=""nofollow"">C99</a> compilers, the same stack space would often be used for each iteration, so there actually was no performance impact for declaring a variable in a loop, since it was not necessary to allocate more stack space during successive iterations. I imagine that C99 compilers do something similar, but I don't know for sure.</p>

<p>Most compilers will just optimize this away. The worst case is that you're creating a new float on the stack, which is an extremely inexpensive operation on most architectures. There may be cases where it is even be faster to declare the variable immediately before use. Though, if your program is that performance sensitive, you should probably be using assembly language to begin with.</p>

<p>C99 and later specify that variables are scoped to the loop that they are created in, while earlier versions of C are ambiguous. Different compilers implement it differently. This is important to be aware of because you may run into naming conflicts on pre C99 compilers if a variable of the same name exists in the scope of the function containing the loop (since they will treat the variable as being scoped to the function).</p>

<p>Personally, I declare variables in loops all the time. It performs well and clearly indicates that the variables exist to be used in that loop. It's a matter of structuring your code in a way that clearly indicates the intentions of that code.</p>
",0
5153706,5153677,4,"<p>This should work, it will read a whole line (it's not quite clear what you mean by ""string""):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int read_line(FILE *in, char *buffer, size_t max)
{
  return fgets(buffer, max, in) == buffer;
}

int main(void)
{
  FILE *in;
  if((in = fopen(""foo.txt"", ""rt"")) != NULL)
  {
    char line[256];

    if(read_line(in, line, sizeof line))
      printf(""read '%s' OK"", line);
    else
      printf(""read error\n"");
    fclose(in);
  }
  return EXIT_SUCCESS;
}
</code></pre>

<p>The return value is 1 if all went well, 0 on error.</p>

<p>Since this uses a plain fgets(), it will retain the '\n' line feed at the end of the line (if present).</p>
",2
5153713,5153677,20,"<p>Use <code>fgets</code> to read string from files in <strong>C</strong>.</p>

<p>Something like:</p>

<pre><code>#include &lt;stdio.h&gt;

#define BUZZ_SIZE 1024

int main(int argc, char **argv)
{
    char buff[BUZZ_SIZE];
    FILE *f = fopen(""f.txt"", ""r"");
    fgets(buff, BUZZ_SIZE, f);
    printf(""String read: %s\n"", buff);
    fclose(f);
    return 0;
}
</code></pre>

<p>Security checks avoided for simplicity.</p>
",0
5153757,5153677,5,"<pre><code>void read_file(char string[60])
{
  FILE *fp;
  char filename[20];
  printf(""File to open: \n"", &amp;filename );
  gets(filename);
  fp = fopen(filename, ""r"");  /* open file for input */

  if (fp)  /* If no error occurred while opening file */
  {           /* input the data from the file. */
    fgets(string, 60, fp); /* read the name from the file */
    string[strlen(string)] = '\0';
    printf(""The name read from the file is %s.\n"", string );
  }
  else          /* If error occurred, display message. */
  {
    printf(""An error occurred while opening the file.\n"");
  }
  fclose(fp);  /* close the input file */
}
</code></pre>
",1
5611726,5611250,1,"<p>As all people saids in c to comparing strings use <code>strncmp</code> or use <code>pointers</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main ()
{
  FILE * pFile;

  char tag [6];
  char code[20]=""bill"";
  pFile = fopen (""example.asm"",""r+"");
  if (pFile==NULL)
  {
    perror(""Error"");  
  }
  else
  {

  while(!feof(pFile))
  {
    fgets(tag,5,pFile);

    if((strncmp(tag, ""&lt;bp&gt;"") == 0) &amp;&amp; (!feof(pFile)))
    {

        fputs(code,pFile);  

    }

  }

  }
fclose(pFile);
 return 0;
}
</code></pre>
",0
5611266,5611250,0,"<p>For one thing, <code>if (tag == ""&lt;bp&gt;"")</code> is not right for C. Try <code>strcmp</code> <a href=""http://www.elook.org/programming/c/strcmp.html"" rel=""nofollow"">http://www.elook.org/programming/c/strcmp.html</a></p>
",0
5611268,5611250,0,"<p>Well at the least you need to change this</p>

<pre><code>tag==""&lt;bp&gt;""
</code></pre>

<p>to this</p>

<pre><code>strncmp(tag,""&lt;bp&gt;"",4) == 0
</code></pre>
",2
5611269,5611250,3,"<p>You can't compare strings using the <code>==</code> operator since it will compare between two pointers, not the strings they point to, you should use <code>strcmp(tag,""&lt;bp&gt;"")</code>.</p>
",0
4623142,4623127,5,"<p>That's a common C idiom for ""number of elements in an array"".</p>

<p>Since an array <a href=""http://www.lysator.liu.se/c/c-faq/c-2.html#2-3"" rel=""nofollow"">decays to a pointer</a> at the slightest provocation, <code>*data</code> is the first element of the array, and therefore it's dividing the total size of the array by the size of its first element, giving a count of elements.</p>

<p>There are any number of possible objections to this technique, whether on style grounds, the fact that it only works on variables declared as arrays (not those passed as pointer to the first element -- it relies on the decay-to-pointer not having happened yet), or possible breakage scenarios in C++ code; that said, it remains common in older C code.</p>
",6
4623146,4623127,2,"<p>It divides the total size of the array by the size of the type of each element.
It returns the number of elements in the array</p>
",0
4623164,4623127,0,"<p>It gives you the number of elements in the array. Because it's a compile-time value and not a run-time value, it doesn't actually evaluate anything inside the <code>sizeof()</code>, which is nice because it works even if any pointers are null or out of bounds.</p>

<p>(Fun facts: i the Windows C runtime, there's already a <code>_countof()</code> macro that does exactly that, and in the Windows SDK, there's the <code>ARRAYSIZE()</code> macro that also does the same thing.)</p>
",0
4623171,4623127,0,"<p>It's simply computing the number of elements in an array -- I.e., the size of the whole array divided by the size of the first element in the array gives the number of elements (all elements in an array are the same size).</p>
",0
5151357,5151332,2,"<p>Obviously, the files aren't found in the include path.</p>

<p>To get rid of that, locate <code>sys/netmgr.h</code> on your system. The parent path of <code>sys</code> must be in the include paths passed to the compiler when building <code>timer_ex1.c</code></p>
",3
5485114,5485082,8,"<p>Try putting this inside the <code>if</code> block:</p>

<pre><code>perror(NULL);
</code></pre>

<p>That should give a descriptive error message, so you know what went wrong.</p>
",0
7215240,7215213,8,"<p>As you learnt from <a href=""https://stackoverflow.com/questions/7214835/or-operator-in-c-not-working/"">your previous question</a>, <code>char</code> is signed on your platform.  Therefore, at the beginning of your <code>while</code> loop, <code>c</code> has a negative value.</p>

<p>Right-shifting a negative value is implementation-defined.  On your platform, I imagine it is doing an <a href=""http://en.wikipedia.org/wiki/Arithmetic_shift"" rel=""nofollow noreferrer"">arithmetic shift</a>.</p>
",4
7215250,7215213,0,"<p>Try using an <code>unsigned char</code>. The standard C <code>char</code> can be signed (and quite often is on PC).</p>
",1
7215422,7215213,3,"<p>This code has undefined behavior on the very first statement. <code>c</code> is uninitialized and has an indeterminate value, and using an object with indeterminate value, even to bitwise-and or multiply it by zero, results in undefined behavior.</p>
",1
5500704,5500673,6,"<p>I think I've done that very exercise!</p>

<p>Anyway, it's likely that the * operator on the command line is turning into ""all the files in the directory"" which won't work.  So you need to quote it when you call the program:</p>

<pre><code># rpmprog 2 3 '*'
</code></pre>

<p>or you can use back-quotes for most shells:</p>

<pre><code># rpmprog 2 3 \*
</code></pre>
",0
5500712,5500673,2,"<p>Your operating system uses ""*"" for a wildcard on the command line; no changes you make to your program will affect this. You may be able to ""escape"" the symbol on the command line -- i.e.,</p>

<pre><code>calculator 2 2 \*
</code></pre>
",0
5500723,5500673,3,"<p>On Linux/UNIX shells, you should enclose the <code>*</code> between single quotes <code>'*'</code> if you don't want it to be expanded by your shell.</p>
",0
5139079,5139072,4,"<p>You can return only one thing from a function. Either you make a struct which contains all the  things you want to return, or you pass some function parameters by reference.</p>
",0
5139082,5139072,8,"<p>You can't return two values. However, you can return a single value that is a struct that contains two values.</p>
",0
5139084,5139072,1,"<p>To return two values, you'll have to define some sort of struct to hold both values, and return an instance of that struct. Alternatively, you can pass an address or two to the function, and have it write the value(s) there.</p>
",0
5139087,5139072,0,"<p>Like this:</p>

<pre><code>typedef ret {
    int val1;
    int *val2;
} ret_t ;

// make sure to remember to free the struct when you're done with it
ret_t *myFunc( void ) {
    ret_t *r = malloc( sizeof(ret_t) );
    r-&gt;val1 = 1;
    r-&gt;val2 = &amp;r.val1;

    return r;
}

// You can also return a copy of the struct on the stack
ret_t myFunc( void ) {
    ret_t r;
    r.val1 = 1;
    r.val2 = &amp;r.val1;

    return r;
}
</code></pre>
",4
5139119,5139072,1,"<p>No, you can not have two returns in a function, the first return will exit the function you will need to create an object.  Note: I have not coded in C in a long time, so the syntax here is probably off.</p>

<pre><code>public class link{
  private int&amp; ptr;
  private int Duplicate;

  public constructor link() {}

  public setPtr(int&amp; ptr) {
     this-&gt;&amp;ptr = ptr;
  }

  //set duplicate function

  //get ptr function

  //get duplicate function

}
</code></pre>

<p>and in the function you snippet you posted before create a link object set the values desired, and then return(link object);</p>
",2
5139177,5139072,2,"<p>Robert's code is correct.  However, you /can/ also use a struct without malloc, like so:</p>

<pre><code>struct retstruct {
    int a;
    int b;
};
struct retstruct myfunc(void) {
    struct retstruct r;
    r.a = 1;
    r.b = 2;
    return r;
}

int main()
{
    struct retstruct r;
    r = myfunc();
    printf(""a=%d  b=%d\n"", r.a, r.b);
}
</code></pre>

<p>This is typically shunned because it's generally a bit more costly (performance-wise) to be passing around structs like this, but if you only need a couple values like this, it can be sufficient.</p>
",0
5139549,5139072,1,"<p>In C/C++, a function cannot return two values. However, most often, this limitation actually makes sense: in any complex function, you want to update some data (a bunch of variables, an array, etc.), and return the status of the function, i.e., whether it was successful or not. As a result, a good practice is to return the status of the function, and use references (in C++) or pointers (in C) to modify your arguments, just like in this example in C:</p>

<pre><code>int swap(int* a, int* b)
{
   int tmp = *a;
   *a = *b;
   *b = tmp;
   return 0;
}
</code></pre>

<p>Of  course, this function is too simple to fail (sort of), but you get the idea :P</p>

<p>And then, if you <strong>really</strong> want your function to return 2 values, then you can use all the tricks proposed by the other answerers.</p>
",0
5111584,5111562,1,"<p>No, you should write -</p>

<pre><code>if ( (code == 'S') ||(code == 'M') ||(code == 'L') /*....*/)
</code></pre>
",0
5111589,5111562,3,"<p>No, that is not valid. Firstly, each one would have to be in single quotes, and secondly, you must explicitly compare with each character- that is, <code>if(code == 'S' || code == 'M' ...)</code>.</p>

<p>If you're checking this many conditions, it's time to get an array and use a loop.</p>
",0
5111597,5111562,9,"<p>You would need to write:</p>

<pre><code>code == 'S' || code == 'M' || code == 'L', etc.
</code></pre>

<p>But you could also do:</p>

<pre><code>if(strchr(""SMLNPKJRCUWO"", code) != NULL) (or != 0, if you don't have NULL defined)
{}
</code></pre>

<p><code>strchr</code> says ""Is a char in a string?  If so, give me a pointer to where it is.  If not, then return NULL"" (which is just a fancy way of saying zero).</p>

<p>To use strchr, you will probably need to have <code>#include &lt;string.h&gt;</code> at the top of your source file.</p>
",0
5111606,5111562,0,"<p>No you do not. <code>||</code> is the logical or operation, and the C-compiler will interpret it like this:</p>

<pre><code>if ( (code == 'S' || 'M' != 0 || 'L' != 0 || 'N' != 0 || 'P' != 0 || 'K' != 0 || 'R' != 0 || 'C' != 0 || 'U' != 0 || 'W' != 0 || 'O' != 0) )
</code></pre>

<p>which I would expect to be the case anyway. I am sure you wanted something less casual-languuage like, but mathematically correct:</p>

<pre><code>if ( (code == 'S' || code == 'M' || code == 'L' || code == 'N' || code == 'P' || code == 'K' || code == 'R' || code == 'C' || code == 'U' || code == 'W' || code == 'O') )
</code></pre>

<p>Maybe you want to consider a <code>switch</code>, which would look nicer and clearer.</p>

<pre><code>switch(code) {
case 'S':
case 'M':
case 'L':
case 'N':
case 'P':
case 'K':
case 'R':
case 'C':
case 'U':
case 'W':
case 'O':
    return 'T';
}
</code></pre>
",0
5111674,5111562,0,"<p>No. First off, I'm assuming that <code>code</code> is of type char and contains a single character.</p>

<p>If you want to use an if statement, you'd need to write ...</p>

<pre><code>if ( (code == 'S' || code == 'M' || code == 'L' || ...)
{
   return 'T';
}
</code></pre>

<p>However, I recommend that you use a switch/case for this.</p>

<pre><code>switch(code){
case 'S':
case 'M':
case 'L':
case 'N':
case 'P':
case 'K':
case 'R':
case 'C':
case 'U':
case 'W':
case 'O':
    return 'T';
    break;
case 'V':
    /* Do something else if code == 'V' */
    break;
default:
    /* It's any other value... */
}
</code></pre>

<p>Normally when using switch/case, you're told to use break after each option, because the options will ""fall through"". But you can also use this to your advantage if you have multiple options.</p>
",0
6103668,6103653,4,"<p><code>json_result</code> is a pointer, probably a parameter from outside. Using <code>*</code> dereferences it and changes the value it <strong>points to</strong>.</p>

<p>That is a pretty standard way of providing results from functions. The caller passes a pointer to its variable, and the callee does exactly what this code does: dereferences the passed pointer and changes the value it points to, thus changing the caller's variable.</p>
",2
6103704,6103653,0,"<p>I can't be sure, since you didn't include the function signature in your code snippet, but if <code>json_result</code> is a pointer that is passed in as a function parameter, then it will be useful to the caller of the function. In C, when you want to be able to return more than one value from a function, you typically pass in pointers to variables which will hold the return values. That is probably what is being done here.</p>

<p>The standard library function <a href=""http://cplusplus.com/reference/clibrary/cstdio/scanf/"" rel=""nofollow"">scanf</a> does this, for example. You specify a format string to use in reading values from standard input, and then give it pointers to variables that it will use to store the values in.</p>

<pre><code>int x;
char c;
float f;

scanf(""%d %c %f"", &amp;x, &amp;c, &amp;f);
</code></pre>
",0
5131993,5131928,2,"<p>There are many ways to solve this.</p>

<ol>
<li><p>Convert every token (space delimited string) into a number and when the tokens run out return the last value converted.</p></li>
<li><p>Scan the line for tokens until you get to the end and then convert the last token into a number.</p></li>
<li><p>Start at the end of the line. Skip spaces and store digits until the first space is encountered and then convert the result to a number.</p></li>
<li><p>Split the string into an array of strings and convert the last one into a number.</p></li>
</ol>

<p>I could go on and on but you get the idea I hope.</p>
",0
5131995,5131928,3,"<blockquote>
  <p><em>i have copied these value from the file onto char array.now i want the last number in integer variable</em></p>
</blockquote>

<p>When you were copying,add a counter of # of characters copied. Then do this</p>

<pre><code>int count = 0;
char c;
while(c = readCharFromFile()) {
  array[count++] = c;
}

int last = array[count - 1];
</code></pre>
",0
5132038,5131928,1,"<pre><code>int getLastInt(char *data)
{
    size_t i = strlen(data);
    if(!i--) return -1; // failure
    for(;i;--i)
    {
        if(data[i] == ' ')
        {
            return atoi(&amp;data[i+1]);
        }
    }
    return -1; // failure
}
</code></pre>

<p>Should work as long as the data has a space + actual text.
You could also skip the strlen and just loop forward, which could be faster depending on your system's strlen.</p>
",3
5132259,5131928,0,"<p>If there is no trailing whitespace on the line:</p>

<pre><code>int last_int(const char *s)
{
    const char *ptr = strrchr(s, ' ');
    if (ptr == NULL) {
        ptr = s;
    } else {
        ptr++;
    }

    return atoi(ptr);
}
</code></pre>

<p>If there can be trailing whitespace, then you'll need to do something like what ProdigySim suggested, but with more states, to walk backwards past the trailing whitespace (if any), then past the number, then call atoi().  No matter what you do, you'll need to watch out for boundary conditions and edge cases and decide how you want to handle them.</p>
",0
5132282,5131928,0,"<p>I guess you want to use a combination of strtok_r and atoi</p>
",0
6640991,6640975,4,"<p>You've declared <code>writeSpace()</code> to return a <code>char*</code>, but you haven't returned anything from it.</p>
",0
6641015,6640975,4,"<p>Well, you're <code>fput</code>ting all those spaces to the console, so you get them first.</p>

<p>Then you're outputting everything else, so you get that next.</p>

<p>Perhaps you meant for <code>writeSpace</code> to <em>return</em> a C-style string, rather than print it to the console.</p>

<p>But be sure that you allocate space for it! Since ownership of memory buffers gets a bit hinky, it's best to allocate space <em>outside</em> of the function.</p>

<pre><code>void writeSpace(char* buf, int i) {
   fputs(""                              "" + (30-i), buf);
}

char spaceBuf1[30];
writeSpace(spaceBuf1, 10);

char spaceBuf2[30];
writeSpace(spaceBuf2, 8);

printf(""#%i key: %s%svalue: %s%s value2: %s"",
   id, key, spaceBuf1, value, spaceBuf2, value2);
</code></pre>

<p>And consider using <em>actual</em> C++ features like iostreams and <code>std::string</code>. It'll be much easier:</p>

<pre><code>std::cout &lt;&lt; ""#"" &lt;&lt; id &lt;&lt; "" ""
          &lt;&lt; "" key: "" &lt;&lt; std::setw(30) &lt;&lt; key
          &lt;&lt; "" value: "" &lt;&lt; std::setw(30) &lt;&lt; value
          &lt;&lt; "" value2: "" &lt;&lt; value2;
</code></pre>

<p>I recommend <a href=""http://jcatki.no-ip.org/fncpp/Resources"" rel=""nofollow"">these resources</a> for learning idiomatic C++.</p>
",0
6641107,6640975,0,"<p>Your <code>writeSpace</code> function is not returning a new string (even though you've declared it that way) but is writing to the terminal directly. Since you call it as an argument in your <code>printf</code> call, <code>writeSpace</code> gets called first, prints its stuff, and then <code>printf</code> prints its stuff. You should do it like this:</p>

<pre><code>char* writeSpace(int i)
{
    char *ret = NULL;
    asprintf(ret, ""                              "" + (30-i));
    return ret;
}
</code></pre>

<p>Of course, this requires you to <code>free</code> the memory (otherwise you'd have a memory leak). You could do it like this:</p>

<pre><code>char *spaces = writeSpace(10);
printf(""%s%i"", spaces, 42);
free(spaces);
</code></pre>

<p>An alternative is to use a static variable that the function itself cleans up on the next call:</p>

<pre><code>char* writeSpace(int i)
{
    static char *ret = NULL;
    if (ret != NULL) free(ret);
    asprintf(ret, ""                              "" + (30-i));
    return ret;
}
</code></pre>

<p>But this has the disadvantage that you can only use one call to <code>writeSpace</code> in your <code>printf</code> arguments, as the second one will clean up the memory of the previous call. Still might be what you want.</p>

<p>BTW, The <code>+ (30-i)</code> part is evil. What you probably want is this instead:</p>

<pre><code>asprintf(ret, ""%*s"", i, """"); // Prints i spaces
</code></pre>
",0
6641115,6640975,0,"<p>If you want to format variable ws' and you absolutely have to use plain C you might use such format strings (%*c, where * is the count of ws and c represents the char to set (' ' in this case of course)):</p>

<p><code>
sprintf(buffer, ""%*cafterspace"", 30, ' '); // Will print 30 ws and then ""afterspace"".<br>
sprintf(buffer, ""%*cafterspace"", 15, ' '); // Will print 15 ws and then ""afterspace"".
</code></p>

<p>But you still have to prepare a buffer as Tomalak explained!</p>
",0
6641134,6640975,0,"<p>The other Answers provided have the correct answer you are looking for. However, I would like to try and add a little explanation of the symptoms you were seeing so as to help you avoid them in the future.</p>

<p>when your printf statement is executed:</p>

<pre><code> printf(""#%i key: %s%svalue: %s%s value2: %s"", id, key, writeSpace(10), value, writeSpace(8), value2);
</code></pre>

<p>The two writeSpace() method calls are executed before the printf itself does anything. The reason for this is that the return value of these methods are used as arguments for the printf method. So the sequence of execution for the above line of code is:</p>

<ul>
<li>writeSpace(10) which prints some white spaces to standard out and returns a null pointer.</li>
<li>writeSpace(8)  which prints some more white spaces to standard out and also returns a null pointer.</li>
<li>finally printf is called with the following arguments: printf(""#%i key: %s%svalue: %s%s value2: %s"", id, key, <strong>null</strong>, value, <strong>null</strong>, value2);</li>
</ul>

<p>This is why you see the white spaces printed at the beginning, but also why you are seeing the ""(null)"" appear in your output.</p>

<p>So the lesson learn here is that during a program execution the arguments for a method are resolved before the method itself is called.</p>
",0
5590160,5590150,40,"<p>There is <strong>no difference</strong>.</p>

<p>It's a matter of <em>notation</em>, not <em>semantics</em>. The second is <strong>less misleading</strong>, because</p>

<pre><code>int *a, b;
</code></pre>

<p>is clearly declaring an <code>int*</code> and an <code>int</code>, whereas</p>

<pre><code>int* a, b;
</code></pre>

<p>looks as if it's declaring two pointers, when it's really doing the same thing as above.</p>
",0
5590374,5590150,21,"<ul>
<li><p><code>int* p</code></p>
<ul>
<li>widely used by C++ programmers</li>
<li><code>int* p, q</code> wrongly implies that both <code>p</code> and <code>q</code> are pointers (leading to a preference for declaring this on two lines, which also improves readability when there are assignments, and makes it easier to quickly cut/paste or comment specific lines/variables)</li>
<li><code>int* p</code> visually separates the type from the identifier</li>
<li><code>*p</code> then unambiguously indicates a dereference (assuming you put spaces around your binary <code>operator*</code> ala <code>2 * 3</code>)</li>
<li>in C++ <code>...&amp;x</code> is clearly taking an address while <code>...&amp; x</code> must be declaring a reference variable, and <code>... &amp; ...</code> is the bitwise-AND operator</li>
</ul>
</li>
<li><p><code>int *p</code></p>
<ul>
<li>widely used by C programmers</li>
<li><code>int *p, q</code> clearly reflects <code>p</code> being a pointer and <code>q</code> not being.</li>
<li><code>int *p</code> visually confuses the type with the identifier</li>
<li>visually indistinguishable from a pointer dereference (for better or worse)</li>
</ul>
</li>
</ul>
<p>Similarly for types appearing in function declarations...</p>
<pre><code>int* f(), g();  // declares int g();
int *h(), (*i)();  // i is pointer to function returning int
int *const*m(), n(); // m returns pointer to (const-pointer to int)
                     // n returns int
</code></pre>
<p>...but at least function arguments can't get so hairy - the type specification starts afresh after each comma separators.</p>
<p><em>Summarily, <code>int *p</code> is better if your coding style / code-base utilises multiple declarations on a single line of source code, otherwise <code>int* p</code> offers a clearer separation of type and the following identifier.</em></p>
<p>For all that, people's preferences are largely based on what they're used to.</p>
",0
5472838,5472808,5,"<p>The current directory is by default not a part of PATH in unix-derived OS'es. This is a security measure, which you <em>can but should not</em> change by modifying PATH in your <code>.bash_profile</code> or <code>.bashrc</code></p>

<p>The reason not to include the current directory in path: Assume that you are root, and you have a malicious user. This user creates e.g. a <code>ls</code> executable in his home directory, which does something not nice. If you're looking at what this user is up to, and type <code>ls</code> while in his home directory, <em>his</em> ls will be executed.</p>

<p>If you want to just change it, add <code>PATH=""${PATH}:.""</code> to your <code>.bashrc</code> and <code>.bash_profile</code></p>
",4
7489237,7489093,39,"<p>First off, you probably don't want <code>0</code> for the <code>has_arg</code> field - it must be one of <code>no_argument</code>, <code>required_arguemnt</code>, or <code>optional_argument</code>.  In your case, all of them are going to be <code>required_argument</code>.  Besides that, you're not using the <code>flag</code> field correctly - it has to be an integer pointer.  If the corresponding flag is set, <code>getopt_long()</code> will fill it in with the integer you passed in via the <code>val</code> field.  I don't think you need this feature at all.  Here's a better (shortened) example for your case:</p>

<pre><code>static struct option long_options[] =
{
    {""title"", required_argument, NULL, 't'},
    {""artist"", required_argument, NULL, 'a'},
    {NULL, 0, NULL, 0}
};
</code></pre>

<p>Then later, you can use it appropriately (straight from the manpage, I added some comments):</p>

<pre><code>// loop over all of the options
while ((ch = getopt_long(argc, argv, ""t:a:"", long_options, NULL)) != -1)
{
    // check to see if a single character or long option came through
    switch (ch)
    {
         // short option 't'
         case 't':
             field.title = optarg; // or copy it if you want to
             break;
         // short option 'a'
         case 'a':
             field.artist = optarg; // or copy it if you want to
             break;
    }
}
</code></pre>

<p>You can extend for your other fields as necessary (and add some error handling, please!).  Note - if you want to use <code>-title</code> and <code>-artist</code> like you have in your example, you'll need to use <code>getopt_long_only()</code>, which doesn't have short options.</p>

<p>As to your <code>filename</code> option, you'll get that out as a <code>'?'</code> from the <code>getopt_long()</code> call, so you could handle it at that time.  Your other options are to require that it is either the first or the last option and handle it by itself separately.</p>
",8
6609338,6609258,1,"<p><a href=""http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">The Standard</a> says:</p>

<blockquote>
  <p>7.23.1</p>
  
  <p>The types declared are [...] time_t [...] which  are  arithmetic  types capable of representing times</p>
</blockquote>

<p>You just need to retain that it is an arithmetic type: you can perform arithmetic with values of <code>time_t</code> type.</p>
",0
5447439,5447419,2,"<p>Standard C (on its own) doesn't define anything named <code>getline</code>. To read a line from a file you normally use <code>fgets</code>.</p>

<p>The error you describe <em>sounds</em> like you don't have a prototype for <code>strtok</code> in scope, so the compiler is treating it as if it returned the default type (int). You'd normally eliminate that by adding <code>#include &lt;string.h&gt;</code> somewhere close to the top of the file.</p>
",3
5447441,5447419,1,"<p>I don't think you want <code>&amp;buffer</code> in your <code>strtok()</code> call.  Also, you're not including <code>string.h</code>, which is why you're getting the warning ""assignment makes pointer from integer without a cast"".  Without a correct prototype for <code>strtok()</code> available, the compiler is assuming that it returns <code>int</code>.  The conversion of that <code>int</code> to <code>char *</code> to make the assignment to <code>token</code> is the assignment it's complaining about.</p>

<p>Edit - thanks to @dmckee for the signature of <code>getline()</code>.</p>
",2
5447447,5447419,0,"<p>one more error is using &amp;buffer instead of buffer.</p>

<p>&amp;buffer is pointer to pointer to char, but you need pointer to char.</p>
",0
5449859,5449794,2,"<p>If the descending sort is working, then all you need is an extra condition in the <code>if</code> statement to handle the other direction:</p>

<pre><code> for(r=0;r&lt;i-1;r++) {
    for(k=r+1;k&lt;i;k++) {
      if((sort==0 &amp;&amp; strcmp(NAMES[k],NAMES[r])&gt;0)||
         (sort==1 &amp;&amp; strcmp(NAMES[k],NAMES[r])&lt;0)) {
         strcpy(swapNAME,NAMES[r]);
         strcpy(NAMES[r],NAMES[k]);
         strcpy(NAMES[k],swapNAME);
      }
    }
  }
</code></pre>
",0
5450078,5449794,0,"<p>First, your sorting is off.  To fix that problem, just replace your bubble sort with a call to qsort, and that immediately leads to a good way to do your reverse sorting.  In particular, try:</p>

<pre>

int
rstrcmp( const char *s1, const char *s2 )
{
    return -strcmp( s1, s2 );
}


int main( int argc, char **argv ) {
    ...
    int (*compare)(const char *s1, const char *s2 );
    /* Based on user input, set 
    compare = rstrcmp;
    -- or --
    compare = strcmp;
    */
    ...
    qsort( NAMES, i, 20, compare );
    ...
</pre>

<p>As a recommendation, do not prompt for the sort direction but let the user pass it as a flag in argv.</p>
",0
5513728,5513702,1,"<p>Yes, you have to allocate memory for what e is pointing first. Something like:</p>

<pre><code>e = (emp_t*) malloc(sizeof(emp_t));
</code></pre>

<p>Also, as some other noted above (and just for completeness), you should be using <code>e-&gt;name</code> instead of <code>&amp;e-&gt;name</code>), as a name of an array (<code>name</code>) is implicitly the address of its first byte.</p>
",2
5513729,5513702,3,"<p>Yes, you must allocate the storage before you can access it. Otherwise you'll just be pointing at some random location in memory.</p>

<p>Try this:</p>

<pre><code>typedef struct employee
{
    int age;
    char name[30];
} emp_t;

emp_t * e;

int main( )
{
    e = malloc(sizeof(emp_t));
    printf(""\nName : "");
    scanf(""%s"", e-&gt;name);
    return 0;
}
</code></pre>
",1
5513731,5513702,2,"<p>you should use</p>

<pre><code>scanf(""%s"",e-&gt;name)  // name is itself an array, so need not to use &amp;
</code></pre>
",0
5522532,5522504,3,"<p>If you have this:</p>

<pre><code>void something(type *p) {
  p = somethingelse;
}

int main() {
  type *a = ...;
  something(a);
}
</code></pre>

<p>The assignment in function <code>something</code> will not change the value of <code>a</code> in the caller (<code>main</code> here). The pointer is passed <em>by value</em>, meaning that a copy of the pointer's value is given to function <code>something</code>.</p>

<p>If you want to be able to change what <code>a</code> points to in the caller, you need to pass a pointer to pointer.</p>

<pre><code>void something(type **p) {
 *p = somethingelse;
}

int main() {
 type *a;
 something(&amp;a);
}
</code></pre>

<hr>

<p>You're not changing <code>first_TR</code> anywhere in that code. So it's keeping it's null value all along.</p>

<p>Either you don't need first_TR and your code should be something like:</p>

<pre><code>if(!first)  
{
 first = malloc(sizeof(TBST));
 ...
}
</code></pre>

<p>Or you do need it, and you could do:</p>

<pre><code>if(!first_TR)  
{
 first = malloc(sizeof(TBST));
 ...
 first_TR = first;
}
</code></pre>

<p>(You don't need to cast the result of <code>malloc</code> in <code>C</code>.)</p>
",1
5557501,5557241,2,"<p>Unless I misunderstand the code, it looks like when you <code>push</code>, because you use the pre-increment, the <code>.last</code> field actually holds the index of the last thing, not a count of how many have been pushed.  However, when you loop through to <code>free</code> them, you're looping while <em>less</em> than last, not less than or equal.  </p>
",3
5557581,5557241,2,"<ul>
<li><p>You are not initializing the allocated memory in the code you show.  In general, you get non-zero garbage allocated by <code>malloc()</code>.  If you need zeroed memory, use <code>calloc()</code>.</p></li>
<li><p>There's also the problem identified by <a href=""https://stackoverflow.com/users/666402/jcooper"">JCooper</a>'s answer.</p></li>
<li><p>There's also the problem identified by <a href=""https://stackoverflow.com/users/418748/muggen"">Muggen</a>'s comment.</p></li>
<li><p>You are freeing the items on the stack, but not the stacks as a whole.  That should be done inside the '<code>for (i2 = 0; ...)</code>' loop but after the '<code>for (k2 = 0; ...)</code>' loop.</p></li>
</ul>

<p>Collectively, these add up to a minor catastrophe.</p>

<hr>

<p>After the code edit...</p>

<ul>
<li>The type VPPTR is not defined, but is presumably meant to be '<code>typedef VPTYPE *VPPTR;</code>.</li>
<li>In the struct VPLIST, you have a pointer to a VPPTR - one more reason to distrust such pointer typedefs.  You almost certainly intended to have a simple VPPTR there.  However, the other code does assume you need an array of pointers to pointers, so it is self-consistent (up to a point).</li>
<li>This problem propagates into the memory allocation code.</li>
<li><p>In your free memory loop, in the call to <code>free()</code>, you have reversed the roles of <code>i</code> and <code>i2</code>:</p>

<pre><code>free(v1v2[i2].list[i]);  // Yours
free(v1v2[i].list[i2]);  // Mine
</code></pre></li>
<li>Your assignments in the allocation loop (<code>v1v2[i]-&gt;v1=1;v1v2[i]-&gt;v2=2;</code>) are bogus.</li>
</ul>

<hr>

<p>The following code compiles clean and runs clean:</p>

<pre><code>$ cc -Wall -Wextra -g -O3 -std=c99 x.c -o x
$ valgrind ./x
==16593== Memcheck, a memory error detector.
==16593== Copyright (C) 2002-2006, and GNU GPL'd, by Julian Seward et al.
==16593== Using LibVEX rev 1658, a library for dynamic binary translation.
==16593== Copyright (C) 2004-2006, and GNU GPL'd, by OpenWorks LLP.
==16593== Using valgrind-3.2.1, a dynamic binary instrumentation framework.
==16593== Copyright (C) 2000-2006, and GNU GPL'd, by Julian Seward et al.
==16593== For more details, rerun with: -v
==16593== 
==16593== 
==16593== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 5 from 1)
==16593== malloc/free: in use at exit: 0 bytes in 0 blocks.
==16593== malloc/free: 2,201 allocs, 2,201 frees, 40,032 bytes allocated.
==16593== For counts of detected errors, rerun with: -v
==16593== All heap blocks were freed -- no leaks are possible.
$
</code></pre>

<h3>Working Code</h3>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define push(s, ele) ((s).list[((s).last)++] = (ele))

typedef struct vp
{
    short v1;
    short v2;
} VPTYPE;

typedef struct VPLIST
{
    int     last;
    VPTYPE **list;
} VPLISTTYPE;

enum { nof = 2 };

int main(void)
{
    VPLISTTYPE *v1v2 = (VPLISTTYPE *)malloc(sizeof(*v1v2) * nof);

    for (int i = 0; i &lt; nof; i++)
        v1v2[i].last = 0;

    for (int a = 0; a &lt; 100; a++)
    {
        //allocation part
        for (int i = 0; i &lt; nof; i++)
        {
            v1v2[i].list = (VPTYPE **)malloc(20 * sizeof(*v1v2[i].list));

            for (int i2 = 0; i2 &lt; 10; i2++)
            {
                VPTYPE *v = (VPTYPE *)malloc(sizeof(*v));
                v-&gt;v1 = 1;
                v-&gt;v2 = 2;
                push(v1v2[i], v);
            }
        }

        // free memory part
        for (int i = 0; i &lt; nof; i++)
        {
            for (int i2 = 0; i2 &lt; (v1v2[i].last); i2++)
            {
                free(v1v2[i].list[i2]);
            }
            free(v1v2[i].list);
            v1v2[i].list = 0;
            v1v2[i].last = 0;
        }
    }
    free(v1v2);
    return 0;
}
</code></pre>

<h3>Simpler Working Code</h3>

<p>This code uses one less level of indirection - and one less level of memory allocation, therefore - and compiles and runs equally cleanly.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define push(s, ele) ((s).list[((s).last)++] = (ele))

typedef struct vp
{
    short v1;
    short v2;
} VPTYPE;

typedef struct VPLIST
{
    int     last;
    VPTYPE *list;
} VPLISTTYPE;

enum { nof = 2 };

int main(void)
{
    VPLISTTYPE *v1v2 = (VPLISTTYPE *)malloc(sizeof(*v1v2) * nof);

    for (int i = 0; i &lt; nof; i++)
        v1v2[i].last = 0;

    for (int a = 0; a &lt; 100; a++)
    {
        //allocation part
        for (int i = 0; i &lt; nof; i++)
        {
            v1v2[i].list = (VPTYPE *)malloc(20 * sizeof(*v1v2[i].list));

            for (int i2 = 0; i2 &lt; 10; i2++)
            {
                VPTYPE v;
                v.v1 = 1;
                v.v2 = 2;
                push(v1v2[i], v);
            }
        }

        // free memory part
        for (int i = 0; i &lt; nof; i++)
        {
            free(v1v2[i].list);
            v1v2[i].list = 0;
            v1v2[i].last = 0;
        }
    }
    free(v1v2);
    return 0;
}
</code></pre>
",4
5607158,5607054,0,"<p>Should be:</p>

<pre><code>int main() {    
    Employee array[SIZE]; //Employee is a typedef struct --includes char *name, DATE *dateOfBirth, DATE is also a typedef struct, has 3 int fields month, day, year,`  

fillArray(&amp;array, &amp;count, fpin1, fpin2);

freeMemory(&amp;array, int count);

}  
</code></pre>

<p>You aren't allocating your <code>Employee</code> objects anywhere, so array[0] points to some random address.</p>
",4
5607183,5607054,0,"<pre><code>Employee* array[SIZE];
</code></pre>

<p>This is an array that stores pointers to <code>Employee</code> structs.</p>

<p>I think you mean </p>

<pre><code>fillArray(Employee* array[], int* count,  FILE *fpin1, FILE *fpin2)
{
    char buffer[MAX], buffer2[MAX];
    int i = 0;
    while ( fgets(buffer, MAX, fpin1) != NULL &amp;&amp; 
            fgets(buffer2, MAX, fpin2) != NULL )
    {
        // the array does not hold any valid memory address.
        array[i] = malloc( sizeof(Employee) );
        assert( array[i] != NULL );

        // now on the new employee add some char memory
        (array[i])-&gt;name = malloc( sizeof(char) * 25 );
        assert(array[i]-&gt;name != NULL);

        strncpy(array[i]-&gt;name, buffer, 15);
        strncpy(buffer2, temp, 2);

        array[i]-&gt;dateOfBirth-&gt;day = atoi(temp)

        ++i;
        (*count)++; 
    }  
}
</code></pre>

<p>doing <code>array[*count]</code> besides looking weird, always modifies the same index. You never modified <code>*count</code> anywhere.</p>

<p>This code does not check that you do not exceed the bounds of the <code>array</code> passed.</p>

<p>Also : for the <code>freeMemory()</code></p>

<pre><code>freeMemory(Employee* array[], int count)
{
    int i = 0;
    while( i &lt; count )
    {
        free(array[i]);
        array[i] = NULL;
        ++i;
    }  
}
</code></pre>
",2
5607207,5607099,1,"<p>It seems that you have two tasks here.</p>
<ol>
<li>To count the number of occurrences of each index in <code>z</code> and allocate a data structure of the right size and configuration.</li>
<li>To iterate over the data and copy it to the correct places.</li>
</ol>
<p>At the moment you appear to have solved (1) naively by allocating a big, two dimensional array <code>iz</code>. That works fine if you know in advance the limits on how big it could be (and your machine will have enough memory), no need to fix this until later.</p>
<p>It is not clear to me exactly how (2) should be approached. Is the data currently going into <code>iz</code> guaranteed to consist of [0, 1, ... n ]?</p>
<hr />
<p>If you <em>don't</em> know the limits of the size of <code>iz</code> in advance, then you will have to allocate a dynamic structure. I'd suggest a ragged array though this means two (or even three) passes over <code>z</code>.</p>
<p>What do I mean by a ragged array? A object like the <code>argv</code> argument to <code>main</code>, but in this case of type <code>int **</code>. In memory it looks like this:</p>
<pre><code>+----+     +---+     +---+---+---+--
| iz |----&gt;|   |----&gt;|   |   |   ...
+----+     +---+     +---+---+---+--
           |   |--
           +---+  \    +---+---+---+--
           | . |   ---&gt;|   |   |   ...
             .         +---+---+---+--
             .
</code></pre>
<p>A ragged array can be accessed with <code>iz[][]</code> just like it was a two-dimensional array (but it is a different type of object), which is nice for your purposes because you can tune your algorithm with the code you have now, and then slap one of these in place.</p>
<hr />
<p>How to set it up.</p>
<ol>
<li><p>Iterate of <code>z</code> to find the largest number, <code>maxZ</code>, present.</p>
</li>
<li><p>Allocate an array of <code>int*</code> of size <code>maxZ+1</code>: <code>iz=callac(maxZ+1,sizeof(int*));</code>.</p>
<p>I chose <code>calloc</code> because it zeros the memory, which makes all those pointers <code>NULL</code>, but you could use <code>malloc</code> and NULL them yourself. Making the array one too big gives us a NULL termination, which may be useful later.</p>
</li>
<li><p>Allocate an array of counters of size <code>maxZ</code>: <code>int *cz = calloc(maxZ,sizeof(int));</code></p>
</li>
<li><p>iterate over <code>z</code>, filling <code>cz</code> with the number of entries needed in each row.</p>
</li>
<li><p>For each row, allocate an array of ints: <code>for(i=0; i&lt;maxZ; ++i){ iz[i] = malloc(sizeof(int)*cz[i]; }</code></p>
</li>
<li><p>Iterate over <code>z</code> one last time, sticking the figures into <code>iz</code> as you already do. You <em>could</em> re-use <code>cz</code> at this point to keep track of how many figure have already been put into each row, but you might want to allocate a separate array for that purpose because so that you have a record of how big each allocated array was.</p>
</li>
</ol>
<p><strong>NB:</strong> Every call to <code>malloc</code> or <code>calloc</code> ought to be accompanied by a check to insure that the allocation worked. I've left that as an exercise for the student.</p>
<hr />
<p>This repeated passes over <code>z</code> business can be avoided entirely by using dynamic arrays, but I suspect you don't need that and don't want the added complexity.</p>
",1
6078648,5688980,0,"<p>It looks like you're trying to do something like a Fisher exact test or a permutation test. If so, you might try using a statistics package like R, which is designed to do this kind of stuff, and is likely to have the most efficient algorithms built in already.</p>

<p>That aside, as I understand it, you are stratifying the sample into n subgroups (y), and then each of those subgroups into k sub-subgroups. You want to find the minimum element of each sub-subgroup.</p>

<p>One reasonably efficient solution is: create n*k unique identifiers, and a map that indicates which sub-subgroup each of them corresponds to. Then, randomly allocate these numbers, (using the same distribution) to your sample observations (like you were before). Use an efficient in-place sort (like quicksort with a properly selected pivot) to sort the sample by identifier, so that all elements with the same identifier are stored in a contiguous block of memory. This takes log-linear time, so it should be very quick.</p>

<p>Then you just need to walk through the array in order, and find the minimum element for each unique identifier. This should take linear time and n*k extra space.</p>

<p>Hope that helps. </p>
",0
5753609,5753140,1,"<p>As Cosmin Prund already stated in his comment: ""Rename your image file to a .txt"". Now, of course you don't have to do that, what he meant is: the Huffman encoding algorithm is agnostic to what kind of input it gets, it doesn't care.</p>

<p>So instead of reading in a .txt file, just read the image file and hand it to the Huffman algorithm. For the algorithm it's all just bits, doesn't matter it it's English or Klingon or a BMP or ...</p>

<p>Of course, using Huffman encoding on an image file to compress it, isn't probably the best idea. There's a reason there's file formats such as JPG around. They make use of the fact that the human eye is insensitive to certain lossy transformations on the image and use this to remove that information so they have to encode less data. The Huffman encoding can't do that, since it's generic and lossless.</p>

<p><em>[Edit]</em> I haven't gone through the code you posted, but I did notice an error on first glance: <code>fgetc</code> returns an <code>int</code>, not a <code>char</code> as its name might lead you to believe. So better change the definition of <code>ch</code>.</p>
",2
7775531,7775365,2,"<p>LOL i helped my friend working on this yesterday. COMP1917 assignment hmm?</p>

<p>you are supposed to pass in the filename you read from the stdin rather than the filename in the struct in this assignment</p>

<p>Back to C, defining a structure doesn't mean that you have that structure and have those members inside the structure. You still declare and create a structure instance by doing this:</p>

<pre><code>struct imgnode node;
</code></pre>

<p>then you can access the member by doing this:</p>

<pre><code>node.filename
</code></pre>

<p>or more commonly:</p>

<pre><code>struct imgnode* nodePtr;
nodePtr-&gt;filename
</code></pre>
",2
7775411,7775365,0,"<p>What you usually do is something like this</p>

<p>So you have a function defined in foo.c as</p>

<pre><code>void foo()
{
    /* do nothing */
}
</code></pre>

<p>You put this line in a header file - guarded by include guards</p>

<pre><code>void foo();
</code></pre>

<p>Now you include that header file in your other c file and the function should be able to resolve at compile time</p>
",1
7775453,7775365,1,"<pre><code>image = getImage(filename,&amp;dim);
              // ^^^^^^^^ Check where this variable declared.
              // If declared check whether it is accessible from this scope.
</code></pre>

<p>Compiler don't know what the variable <code>filename</code> being passed an argument in the current translation unit. <code>filename</code> should be some where declared and should be accessible at the point of the function call. Check it.</p>

<p>If you are trying to access the struct members then you should have instance to access them.</p>

<pre><code> image = getImage(strucInstance.filename,&amp;(strucInstance.dim) );
</code></pre>
",0
7486297,7486251,2,"<p>Because in basic arithmetic <code>10/2=5</code>.</p>
",2
7486315,7486251,3,"<p>Dividing by zero is undefined behavior, so any result is permitted - it may crash or the compiler might refuse to compile that code (Visual C++ 10 does so). Dividing 10 by 5 yields 2 as you would normally expect.</p>
",1
7486337,7486251,4,"<blockquote>
  <p>10/0 prints 10</p>
</blockquote>

<p>Division by zero is <a href=""http://c2.com/cgi/wiki?UndefinedBehavior"" rel=""nofollow"">Undefined Behaviour</a> (*). Anything can happen. If you're lucky, the computer will print some very unexpected thing forcing you to correct the programming error; if you're unlucky the error goes unnoticed for a long time.</p>

<blockquote>
  <p>10/2 prints 5</p>
</blockquote>

<p>This is correct. <code>10</code> divided by <code>2</code> is <code>5</code>.</p>

<p>(*) The <a href=""http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">C99 Standard</a> says:</p>

<blockquote>
  <p>6.5.5/5<br>
  ...<br>
  ... if the value of the second operand is zero, the behavior is undefined.</p>
</blockquote>
",0
6029685,6029597,1,"<p>You need to pass the reference of <code>a</code> to <code>cont()</code> - </p>

<pre><code>void cont(int* a)
{ 
    printf(""If you do not want to enter a value press q""); 
    scanf(""%c"", a);
}
</code></pre>

<p>and call it like that:</p>

<pre><code>cont(&amp;a);
</code></pre>

<p>otherwise, only the the copy of <code>a</code> (that is passed to the function) is changed, not <code>a</code> itself.</p>

<p>If you want to change the value of <code>a</code> in the function, then you need to store the return value somewhere, but you ignored it (e.g. <code>a = cont(a);</code>).<br/>
Or, give a reference (e.g. address of) a to the function, so it will be able to change the value of <code>a</code>.</p>
",8
6110193,6110148,0,"<p>Yes, the string terminator has a value of 0. The 64-bit representation would indeed be 64 zeros.</p>
",0
6110345,6110148,0,"<p>C string termination character is <code>\0</code> (all bits set to zero). The remaining bits won't necessary always be zeroes: if the string is emptied via setting its first char to <code>\0</code>, the other chars won't change. A sequence of 64 bits set to zero is <em>one</em> representation of an empty C string. </p>
",0
6111119,6110148,2,"<p>What a ""C-string"" is, is an array of characters with a zero-element; which decays to a pointer to its first element in most contexts. Also, the converse is usually accepted: a pointer to char is (often) assumed to be a pointer to (a part of) an array of characters which has a (subsequent) zero-element.</p>

<p>If you interpret ""empty string"" as array of 0 elements, there really is no concept of that in the C language.<br>
If you interpret ""empty string"" as array of N elements of which the first element is a 0, the bit representation of that 1st element is <code>CHAR_BIT</code>binary 0's (usually 8).<br>
If you interpret ""empty string"" as pointer to NULL, the bit representation of that pointer is implementation defined, but comparing it to <code>0</code> must yield ""true"".</p>

<pre><code>/* ERRATA: where it says ""is a string"" please read ""can be interpreted as a string"" */
char arr_string[10]; /* if any element is 0, this is a string */
char *ptr_string; /* if it points to a valid object accessible as `char`
                  ** and a subsequent valid char is 0, this is a string */

strcpy(arr_string, ""foobar""); /* arr_string[6] == 0 */
ptr_string = arr_string;

test_string_empty(arr_string);      /* not empty */
test_string_empty(ptr_string + 6);  /* empty */
test_string_empty(NULL);            /* unknown */
</code></pre>
",0
6113122,6110148,0,"<p>The first char would be '\0', which would be a null terminator. In the memory the previous char from what the was before it was set to NULL would still be there. So lets string = Hello World, then string = \0. The memory would look like '\0', 'e', 'l', 'l', 'o', '', 'W', 'o', 'r', 'l', 'd', '!'.
So if you initialize string to null. It would first be a char of \0 and the rest would be bits set to zero. </p>
",0
7502705,7502333,0,"<p><code>execl()</code> is a variadic function, so this should compile.</p>

<p>However, it won't work.  <code>execl</code> expects each of its arguments to be a <code>const char *</code>, i.e. a pointer to a string.  A <code>va_list</code> is not such a thing.</p>
",0
7502987,7502333,4,"<p>Since you don't know how many arguments you'll be receiving, you'll need/want to use <code>execv</code> instead of <code>execl</code>. You'll need to walk through the arguments, retrieve a pointer to the beginning of each string, and put them into an array. You'll then pass the address of that array to <code>execv</code>.</p>
",0
7775348,7775317,0,"<p>There is no open() function defined in the C language standard. Although open() by POSIX</p>

<pre><code>   int open(const char *pathname, int flags);
   int open(const char *pathname, int flags, mode_t mode);
</code></pre>

<p>As Etienne asked - ""What are you trying to do""</p>
",0
7775352,7775317,-2,"<p>EDIT: wow, holy downvotes folks.  As the OP's post has now been entirely rewritten to clarify what his question was, I suggest another SO post which has a good discussion: <a href=""https://stackoverflow.com/questions/205529/c-c-passing-variable-number-of-arguments-around"">Passing variable number of arguments around</a></p>
",2
7775433,7775317,6,"<p>To wrap a variadic function in the general case, it needs to have a variant that takes the <code>va_list</code> as an argument (this is what the <code>vprintf</code> family of functions are for, for instance).</p>

<p>However, <code>open</code> only ever has two or three arguments, so it can be wrapped by conditionally reading the third argument, but <em>unconditionally</em> passing three arguments to the real <code>open</code>:</p>

<pre><code>#ifndef O_TMPFILE
# define O_TMPFILE 0
#endif
int my_open(const char *pathname, int flags, ...)
{
    mode_t mode = 0;
    if (flags &amp; (O_CREAT|O_TMPFILE))
    {
        va_list ap;
        va_start(ap, flags);
        mode = va_arg(ap, mode_t);
        va_end(ap);
    }
    // ... do what you need to do here ...
    return open(pathname, flags, mode);
}
</code></pre>

<p>This works because extra arguments to a variadic function are harmless; they'll just get ignored.  However, you will need to update the <code>if</code> condition every time the operating systems you care about add new flags that require the third parameter.  The original version of this answer didn't account for <code>O_TMPFILE</code>, for instance.  (It's <em>not</em> safe to read the third parameter unconditionally; if the compiler ever managed to notice that you were reading a parameter that wasn't passed, it would be nasal demons time.)</p>
",0
7775436,7775317,0,"<p>Early versions of the <code>open()</code> function were described with an optional argument, but modern POSIX defines it as a variadic function with <code>, ...</code> in its prototype.</p>

<p>Wrapping a variadic function with another is generally difficult, which is why the standard has <code>vfprintf()</code> and friends.  But since the valid variations for <code>open()</code> are quite simple, with the presence or absence of the third argument determined by the value of the second, you can use a simpler approach.</p>

<p>Write your own <code>my_open()</code> function that uses <code>&lt;stdarg.h&gt;</code> to access the optional third argument.  Depending the value of <code>oflag</code>, do either</p>

<pre><code>return open(path, oflag);
</code></pre>

<p>or</p>

<pre><code>return open(path, oflag, third_arg);
</code></pre>
",0
7775461,7775317,-1,"<p>you can't wrap open() without using inline assembly or SWIG (a library for calling C)</p>

<p>see 
<a href=""http://www.swig.org/Doc1.3/Varargs.html"" rel=""nofollow"">http://www.swig.org/Doc1.3/Varargs.html</a></p>
",0
6653142,6653087,3,"<p>You will have to allocate global memory (memory on the heap), assign the rttype there and then return a pointer to the allocted memory. Of course, doing this you'll have to deal with freeing the memory later on too.</p>

<p>However, by doing this you are modifying the semantics and design of the function and you should bear this in mind and make other changes responsibly to respect this.</p>
",0
6653145,6653087,4,"<p>Generally speaking, you don't. Going the other direction might be reasonable at times, but the minute you return a pointer you introduce questions of lifetime and ownership. In particular, what are you returning a pointer to, and whose responsibility (if anybody's) is it to free the memory it points at?</p>

<p>These questions typically affect the overall design, so they're not something you can reasonably address in a simple wrapper.</p>
",0
6887920,6887890,6,"<p>Order of evaluation of function arguments is <em>unspecified</em>. The compiler can compute the arguments in any order it pleases, but it must do it in some particular order (so there's no <em>undefined</em> behaviour here). The output can be either 32 or 64.</p>

<p>UPD: this is wrong, there's UB here, see <a href=""https://stackoverflow.com/questions/6887890/undefined-behaviour-in-c/6888025#6888025"">here</a>.</p>
",3
6887942,6887890,0,"<p>And what does your power function contain? I just checked C math libraries pow function. I had to cast it to &lt;int&gt; like this;</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

int main () {
    int n=5;
    printf(""%d %d\n"", ++n, (int)pow(2.0, n));
    return 0;
}
</code></pre>

<p>Output: 6 64</p>

<p>I used Microsoft Compiler(used by Visual Studio). Hope it helps.</p>
",1
6888025,6887890,1,"<p>Contrary to what other answers say, the code may indeed exhibit undefined behavior.</p>

<p>As has been stated, the order of evaluation of function arguments is unspecified in C.  In your program, you have an expression composed of several subexpressions:</p>

<pre><code>ex0(ex1, ex2, ex3(ex4, ex5));
</code></pre>

<p>There is only a partial ordering between these subexpressions:  <code>ex4</code> and <code>ex5</code> must obviously be evaluated before <code>ex3</code> can be evaluated, and <code>ex1</code>, <code>ex2</code>, and <code>ex3</code> must be evaluated before <code>ex0</code> can be evaluated.  Other than that, the order of evaluation of the subexpressions is unspecified, and it is up to your compiler to decide the order in which to evaluate the subexpressions.</p>

<p>There are certain, valid orders of evaluations that yield undefined behavior.  For example, if <code>++n</code> is evaluated before <code>power(2, n)</code>, the results are undefined:  there is a sequence point after the evaluation of all of the arguments to a function but not before or between, and the C Language Standard very clearly states (C99 ¡ì6.5/2; emphasis mine):</p>

<blockquote>
  <p>Between the previous and next sequence point an object shall have its stored value modi?ed at most once by the evaluation of an expression. Furthermore, <strong>the prior value shall be read only to determine the value to be stored.</strong></p>
</blockquote>

<p>If <code>++n</code> is evaluated first, this rule is violated because <code>n</code> is modified by <code>++n</code> and <code>n</code> is read for the call to <code>power(2, n)</code> without a sequence point between those two steps.</p>

<p>A program that exhibits undefined behavior may produce any result:  it may crash, it may print an unexpected answer, or it may appear to work as you expect it to work.  Since your program potentially exhibits undefined behavior, it's difficult to discuss with certainty the actual behavior that you see.  It is best to avoid writing programs that potentially (or worse, actually) exhibit undefined behavior.</p>
",0
6366581,6366046,2,"<p>This should do it, very very fast.</p>

<pre><code>char const* find_body_closing_tag( char const* const src, size_t const data_len )
{
    static char table[256];
    static bool inited;
    if (!inited) {
         table['&lt;'] = 1;
         table['/'] = 2;
         table['b'] = table['B'] = 3;
         table['o'] = table['O'] = 4;
         table['d'] = table['D'] = 5;
         table['y'] = table['Y'] = 6;
         table['&gt;'] = 7;
         inited = true;
    }

    for( char const* p = src + data_len - 7; p &gt;= src; p -= 7 ) {
        if (char offset = table[*p]) {
            if (0 == strnicmp(p - (offset-1), ""&lt;/body&gt;"", 7)) return p - (offset-1);
        }
    }
    return 0;
}
</code></pre>

<p>Another very fast approach would be using SIMD to test 16 consecutive characters against <code>'&gt;'</code> at once (and this is what <code>strrchr</code> or <code>memrchr</code> ought to be doing).</p>
",1
8227969,8225555,0,"<p>If you want to affect every load and store, the only way to do this (that I know of) without generating new code is by instrumenting your binary with a tool like <a href=""http://www.pintool.org/"" rel=""nofollow"">Pin</a>.  You will, of course, incur great amounts of overhead by instrumenting every assembly instruction.</p>

<p>Edit: See <a href=""http://www.pintool.org/docs/43611/Pin/html/"" rel=""nofollow"">here</a> for a (possibly relevant) memory trace example.</p>
",1
8228079,8225555,0,"<p>It's not an easy task, but you can use <a href=""http://clang.llvm.org"" rel=""nofollow"">clang</a> as a library for static code analysis to introduce a stage in the compilation after pre-processing and before compilation. Your static code analysis compiler 'middleware' tool should detect calls to <code>malloc</code>, then change the types of p1 and s1, to <code>char **</code> and all places where p1 and s1 are references to *s1 and *p1, before passing the code to the compilation stage. Another option is to leverage on <a href=""http://gcc-melt.org"" rel=""nofollow"">GCC MELT</a> for the same purpose (I'm assuming you depend on gcc and not on another compiler, though).</p>
",1
6609157,6609133,7,"<p><strong>You are storing the result of <code>getc</code> in a <code>char</code></strong>. It should be an <code>int</code>. There's also a <a href=""http://c-faq.com/stdio/getcharc.html"" rel=""nofollow"">C FAQ</a> on it. Also you should check the return value of the <code>fopen</code>.</p>

<pre><code>P=fopen(""mola.txt"",""r"");
if (NULL == P) {
    perror(""fopen""):
}
</code></pre>

<p>Also the <code>while</code> looks fishy. Try indenting ?</p>

<pre><code>while((a=getc(P)) != EOF)
    printf(""%c"",a);
</code></pre>
",2
6609174,6609133,0,"<p>It means the loop will fell into Infinite loop not allowing the program to exit when at <code>a=getc(p)</code>.</p>
",0
6609273,6609133,1,"<p>It means just what it says</p>

<blockquote>
  <p>comparison is always true due to limited range of data type.</p>
</blockquote>

<p>The range of the data type in question (the <code>a</code>, which is <code>unsigned char</code>) is from 0 to 255 (really <code>UCHAR_MAX</code>);</p>

<p>The <code>EOF</code> value is -1</p>

<p>You are comparing <code>a</code> (from 0 to 255) with <code>-1</code></p>

<pre><code>(a != -1)
</code></pre>

<p><strong>the condition will always be true</strong></p>
",0
6609468,6609133,1,"<p>Try:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
int a;
FILE *P;
P=fopen(""tryit2.c"",""r"");
while(EOF != (a = fgetc(P))) {
        printf(""%c"",a);
    }
}
</code></pre>

<p>You had two problems ""getc()"" returns an integer not a character. And the while statement had some weird side effects in the original order.</p>
",2
6614690,6614621,0,"<p>Windows terminate lines with <code>\r\n</code>. May be this could help:</p>

<pre><code>$ echo test | unix2dos &gt; /tmp/test
$ hexdump -c /tmp/test
0000000   t   e   s   t  \r  \n                                        
0000006
</code></pre>

<p>Stangely <code>\r</code> value is 13, so I dont know wath is going wrong. </p>
",1
6614945,6614621,0,"<p>try this:</p>

<pre><code>while((c = getc(pFile)) != EOF)
{
    if(c != '\n' &amp;&amp; index)
    {
         input[index] = (char)c;
         index++;
    } 
    else
    {
         if (!index)
              continue; // dumps repeated '\n'

         input[index] = '\0';
         index = 0;
    }
}
</code></pre>
",4
6614676,6614621,1,"<p>Is the file physically the same, i.e. bit-by-bit, on the two platforms? That's asking for trouble, since the encoding for line ending differs.</p>
",1
6620679,6620600,3,"<p>Your problem is that you don't set <code>index</code> back to zero after the <code>linecount == 16</code> code. Amongst other things, that means you have a horrendous buffer overflow.</p>

<p>In the trailing data processing, you should first print out enough blanks for the missing characters that the printable characters are aligned with the other sets.  I mentioned in a comment using <code>""%03o""</code> in place of <code>""%02o""</code> to give consistent alignment.  Also, using <code>isprint()</code> from <code>&lt;ctype.h&gt;</code> would improve things.</p>

<hr>

<p>This works reasonably well for me - tested on its own source code:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

enum { LINESIZE = 16 };

void octaldump(FILE * fp)
{
    int c;
    size_t linecount = 0, index = 0, i;
    unsigned long address = 0;
    char temp [LINESIZE];

    while ((c = fgetc(fp)) != EOF)
    {
        if (linecount == 0)
        {
            printf(""%07lo "", address);
            address += 16;
        }
        temp[index] = c;
        index++;

        printf(""%03o "", c);
        linecount++;

        if (linecount == 16)
        {
            printf("" | "");
            for (i = 0; i &lt; linecount; i++)
                printf(""%c"", isprint(temp[i]) ? temp[i] : '.');
            printf(""\n"");
            linecount = 0;
            index = 0;
        }
    }

    if (linecount &lt; 16)
    {
        for (int j = linecount; j &lt; 16; j++)
            printf(""    "");
        printf("" | "");

        for (i = 0; i &lt; linecount; i++)
            printf(""%c"", isprint(temp[i]) ? temp[i] : '.');
        printf(""\n"");
    }

    printf(""%07lo\n"", address);
}

int main(void)
{
    octaldump(stdin);
    return 0;
}
</code></pre>
",1
7179600,7179572,2,"<p>Yes, <code>#define</code> macro's can have more than one parameter.</p>

<p>Specifically, C99 specifies that a compliant implementation has to be able to deal with at least 127 parameters for a macro (it used to be 31 in C89).</p>
",3
7181868,7179572,0,"<p>If you're trying to determine how many arguments were passed to a function, you can use this:</p>

<pre><code>#include &lt;stdarg.h&gt;

#define __VA_NARGS__(...) __VA_NARGS__N(__VA_ARGS__,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0)
#define __VA_NARGS__N(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,N,...) N

#define sum(...) _sum (__VA_NARGS__(__VA_ARGS__), __VA_ARGS__)
int _sum (numargs, ...) {
    int total = 0;
    va_list args;

    va_start (args, numargs);
    for (; numargs &gt; 0; numargs--) {
        total += va_arg (args, int);
    }
    va_end (args);

    return (total);
}
</code></pre>
",0
6891573,6891521,3,"<p>I'm surprised that compiled</p>

<pre><code>char stack[30];
</code></pre>

<p>should be replaced by</p>

<pre><code>struct node* stack[30];
</code></pre>

<p>There might be other problems.</p>

<p>You wrote a nice recursive routine to build the tree, why not write a recursive routine to do a pre-order traversal. It would be much easier to understand.</p>
",1
6891658,6891521,1,"<p>Simply calling something ""stack"" won't make it behave as one. When you push something onto a stack, the existing values get pushed down, and the reverse is true for popping.</p>

<p>I'd start with a working stack implementation, preferably with own functions for pushing and popping stuff.</p>
",1
8395259,8394155,0,"<p>Maybe you should post all your code (however, try to reduce it to minimum). This works for me:</p>

<p>File input.txt</p>

<pre>
530 A
531 B
532 C
</pre>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

#define MAX_LINES 50

int main()
{
    FILE* file;
    int NumOfField = 2;
    int index = 0;
    char roomLetter[ MAX_LINES ];
    int  quote     [ MAX_LINES ];

    file = fopen(""input.txt"",""r"");

    while ( NumOfField == 2 ) {
        NumOfField = fscanf(file,""%d %c\n"", &amp;quote[index], &amp;roomLetter[index]);
        index++;
    }
    fclose(file);
    index--;

    for(; index &gt;=0; index-- )
        printf( ""%d %c\n"", quote[index], roomLetter[index] );

    getch();

    return 0;
}
</code></pre>
",0
8407655,8394155,0,"<p>Ok here is the answer to my question:</p>

<p>the EOF was the trick</p>

<pre><code>for (FuncIndex = index; FuncIndex != EOF; FuncIndex--)
</code></pre>

<p>Basically, in here you are saying that whatever the number of index is (Number of Lines) put it in the FuncIndex and then one by one (from the highest number) check each line until its not the end of line anymore.</p>
",7
7463001,7462396,0,"<p>If you error condition is always that simple (print error message and return) you can rewrite to save lines.</p>

<pre><code>int errmsg(const char *msg, int retval) {
    fprintf(stderr, ""%s\n"", msg);
    return retval;
}
</code></pre>

<hr>

<pre><code>if ((ptr = malloc(size)) == NULL) return errmsg(""failed to allocate memory."", -1);
/* ... */
free(ptr);
</code></pre>
",0
7463078,7462396,3,"<p>You could use macros. This is cheaper than grouping this code into a function because Macros don't have the overhead a function call incurs. Macros are expanded by the preprocessor stage of compilation and can be verified by the '-E' option in gcc.
Now say we have func1(), func2(), func3()</p>

<pre><code>#define MY_MALLOC(_ptr,_count, _lbl) \
do { \
 if (NULL == (ptr = malloc(sizeof(char) * _count))) { \
    fprintf(stderr, ""Failed to allocate memory.\n""); \
    goto _lbl; \
 } \
} while(0)

func1() {  
 char *ptr;
 MY_MALLOC(ptr,10,Error);
 ....
 ...
 return (0);
Error:
 return (1);
}


func2() {  
 char *ptr;
 MY_MALLOC(ptr,10,Error);
 ....
 ...
 return (0);
Error:
 return (1);
}


func3() {  
 char *ptr;
 MY_MALLOC(ptr,10,Error);
 ....
 ...
 return (0);
Error:
 return (1);
}

#undef MY_MALLOC
</code></pre>
",0
7462441,7462396,3,"<p>Sorry, but there's nothing you can do about that in C. Except... <em>gasp... wrap it all in a macro</em> which will automate the <code>if</code> check and allow you to write custom error-handling code each time. There, I said it.</p>

<p>Seriously, C isn't meant to provide conveniences like this. If you don't mind exiting the program on the spot, you can wrap it in a function of course that does <code>exit</code> when the allocation fails -- but that's no general solution.</p>
",2
7462448,7462396,1,"<p>When you have no real error handling (except printing something and exiting), the simple and established solution is to define a function safe_malloc which incorporates the check. (Edit: Or, of course, a macro. Whatever rocks your boat.)</p>
",0
7462498,7462396,5,"<p>There isn't usually much point in trying to stumble on when all memory is consumed.  Might as well call it quits:</p>

<pre><code>char* allocCharBuffer(size_t numberOfChars) 
{
    char *ptr = (char *)malloc(sizeof(char) * numberOfChars);
    if (ptr == NULL) {
        fprintf(stderr, ""failed to allocate memory.\n"");
        exit(-1);
    }
    return ptr;
}
</code></pre>
",2
7090514,7089294,2,"<p>comma is used as separator as well as an operator.
the three cases are dealt as below:
first: i=1,2; assignment has higher precedence to comma(,) so i=1 is evaluated i.e. i is given value 1 and then 2 is just put there without any use.
second: j=(1,2) parentheses has highest precedence so contents inside it will be evaluated first (1,2) will result to 2 and hence j is assigned value 2.
third: k=(1,2),(3,4); here (1,2) and (3,4) are evaluated to 2,4
and then it is like the first expression i.e. k=2,4 so k will be assigned value 2.</p>

<p>hope this helps :D</p>
",1
7172715,7172696,1,"<p>Use <code>snprintf</code> to make the string you need.</p>
",0
7172718,7172696,3,"<p>You are looking for the <code>snprintf()</code> function:</p>

<p><a href=""http://libslack.org/manpages/snprintf.3.html"" rel=""nofollow"">http://libslack.org/manpages/snprintf.3.html</a></p>
",0
7172733,7172696,0,"<p>You could use sprintf to do that:</p>

<pre><code>sprintf(buffer, ""%d"", 123);
</code></pre>

<p>Note that you need to mage sure that your buffer has enough space allocated</p>
",0
7172737,7172696,0,"<p>try this:</p>

<pre><code>int number = 10;
char mystring[20];
snprintf(mystring, sizeof(mystring), ""%d"", number);
</code></pre>

<p>alternatively you can use <code>itoa</code> but this is considered unsafe.</p>
",1
7172746,7172696,0,"<p>use <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/itoa/"" rel=""nofollow""><code>itoa</code></a>, or <code>sprintf</code> as suggested in the link, because of portability reasons.</p>

<p><code>snprintf</code> or <code>asprintf</code> for security reasons..</p>
",0
7172797,7172696,0,"<p>i guess this will work</p>

<pre><code>#include &lt;stdlib.h&gt; // for itoa() call
#include &lt;stdio.h&gt;  // for printf() call

int main() {
    int num = 123;
    char buf[5];

    // convert 123 to string [buf]
    itoa(num, buf, 10);

    // print our string
    printf(""%s\n"", buf);

    return 0;
}
</code></pre>

<p>also u can use--</p>

<pre><code>#include &lt;stdio.h&gt;

   int main(void)
   {
      const char base[] = ""filename"";
      char filename [ FILENAME_MAX ];
      int number = 42;
      sprintf(filename, ""%s%d"", base, number);
      printf(""filename = \""%s\""\n"", filename);
      return 0;
   }
</code></pre>

<p>Though remember sprintf() does not calculate for buffer overflow. sprintf() doesn't flush any file buffer, in fact it doesn't have any buffer associated with it. sprintf() operates on a character buffer (not quite the same thing). If you overflow that buffer you can crash the system.</p>

<p>A safer version of sprintf() is snprintf() which unfortunately isn't very standard yet. It appears in various forms from many compiler vendors and was finally standardized in C99 and will hopefully make it as part of standard C++ in the next standard of C++. Until then you just have to dig up the unstandard version of it if you have one.</p>
",0
8372428,8372402,5,"<p>If it's not <code>static</code> it's on the stack. Since the function is returning a <code>char *</code> pointer to it, that's kind of important and it needs to be done that way.</p>

<p>If it's not <code>static</code>, outside of the function you have a pointer to a stack variable that is no longer valid. Your ""test"" isn't showing this because the memory hasn't yet been reused. Make no mistake - it will be at some point.</p>

<p><strong>Edit:</strong> Jim brings up a good point in the comments below that I didn't think about initially. Since these are string literals, they are already in read-only memory. I <em>think</em> that using <code>static</code> here simply keeps from re-initializing the <code>char *name[]</code> array each time.  The initial answer above does apply to other data types, but in this case I don't think it does. </p>
",5
8372463,8372402,1,"<p>The point of it being static is exactly what you stated. It means the array is initialised <em>once and once only.</em></p>

<p>An ""internal"" static (as you put it) has visibility of the current function and duration for the entire program execution. Another way of doing this would be to use a global (file-level) variable but that has the disadvantage of being visible outside the function.</p>

<p>And, yes, your test is flawed. Even <em>if</em> the address of the array on the stack changed (and it probably doesn't since you're calling <code>month_name</code> from the same stack level each time), the actual <em>characters themselves</em> are not usually on the stack (assuming your implementation even <em>has</em> a stack). They're string literals and will probably be stored in the code section at a specific location.</p>

<p>By adding more string literals, you may cause their address to change but that's by no means guaranteed.</p>
",0
8372468,8372402,3,"<p>This is just an invalid test.
You are not printing the address of <code>name</code> array, but the address of the string literal which is always ""January"".</p>

<p>Note that <code>name</code> is not an array of characters where you return the address to the portion inside it, but it is an array of pointers to string literals.</p>

<p>Therefore, what is initialized each time you enter a function is <code>name</code> array, not the literals which are constant by their nature. </p>

<p>EDIT: another thing is that the compiler is quite an intelligent beast. Thus, even if you print out the value of <code>name</code> array, you will get the same address (thanks to inlining, most probably), however GCC compiler at Mac seems to get fooled with an indirect call (<code>gcc -O0</code> call). Test the following code:</p>

<pre><code>char *month_name(int n)
{
  static char *name[] = {
    ""Illegal month"",
    ""January"", ""February"", ""March"",
    ""April"", ""May"", ""June"",
    ""July"", ""August"", ""September"",
    ""October"", ""November"", ""December""
  };
  printf(""names addr = %p\n"", name);
  return (n &lt; 1 || n &gt; 12) ? name[0] : name[n];
}

void indirect_call_function(char* (*fptr)(int n))
{
  fptr(1);
}

int main(void)
{
  printf(""%s\n"", month_name(1)); // print string

  indirect_call_function(month_name);

  char dummy[] = ""dummy"";

  printf(""%s\n"", month_name(1)); // print string
}
</code></pre>

<p>Compare to the code with static <code>name</code>.</p>
",3
8372542,8372402,1,"<p>Even if the array was being re-initalized, the address of the strings would be the same each time; The address of a string literal is usually the same, because it resides in the (read-only) .data section; although technically, <code>""a"" == ""a""</code> is undefined behavior. What static prevents, is the recreation of the array, such that this:</p>

<pre><code>char* month_static(int n){
   static char * months[] = {  /*month names*/ };
   printf(""static: %p\n"", months);
   return months[n];
}
char* month_nonstatic(int n){ 
   char * months[] = {  /*month names*/ };
   printf(""nonstatic: %p\n"", months);
   return months[n];
}
void large_ar(char*(*fn)(int), int n){
   int ints[50000];
   fn(n);
}
int main(){
   month_static(3);
   month_nonstatic(3);
   large_ar(month_static, 3);
   large_ar(month_nonstatic, 3);
}
</code></pre>

<p>outputs:</p>

<pre><code>static: 0x80497f0
nonstatic: 0xbfd11a10
static: 0x80497f0
nonstatic: 0xbfce0cb0
</code></pre>

<p>You'll notice that the static calls print the same address, while the nonstatic ones change.</p>
",4
7221968,7220988,1,"<p>C doesn't have classes.  C just has structures and ordinary functions.  Access is straightforward using one of the structure member access operators <code>.</code> or <code>-&gt;</code> (depending on whether or not you have a pointer) and the array subscripting operator <code>[]</code>:</p>

<pre><code>typedef struct HillStruct
{
    CGPoint hillKeyPoints[kMaxHillKeyPoints];
} HillStruct;

void SomeFunction(HillStruct *hillStruct)
{
    // Read first member of the array in the structure
    CGPoint firstPoint = hillStruct-&gt;hillKeyPoints[0];
    // etc.
}
</code></pre>
",0
7452390,7452164,0,"<p>since you know the elements in each of the array(i.e 4),you can easily construct the bigger array having 16 elements....
arr1,arr2,arr3,arr4   and arr5(all the 4 arrays will be stored in it)
you can traverse the bigger array,and fill in the contents for smaller arrays</p>

<p>arr5-->[4 elements]arr1----------[4 elements]arr2--------[4 elements]arr3-------[4 elements]arr4==========[16 elements]</p>

<p>for(i=0;i&lt;16;i++)//traversing the bigger array)
{</p>

<p>//for first array ,fill up the contents and increment the i,this would fill up the bigger array 
for(j=0;j&lt;4;j++,i++)
arr5[i]=arr1[j];
similarly for other arrays as well</p>

<p>}</p>
",0
7452172,7452164,3,"<p>Check this out: <a href=""http://c-faq.com/~scs/cclass/int/sx9.html"" rel=""nofollow"">Multidimensional arrays in C</a> and <a href=""http://en.wikipedia.org/wiki/C_syntax#Multidimensional_arrays"" rel=""nofollow"">this Wikipedia page</a> for the general information on multidimensional arrays in C.</p>

<p>Your code should work with this:</p>

<pre><code>int* big[] = {ar1, ar2, ar3, ar4};
</code></pre>
",0
7452175,7452164,0,"<p>Sure, and you're pretty close to having it.  In C, what you do is construct (always) a bunch of adresses, and either you or the compiler does the necessary arithmetic to treat is as however many dimensions you want.</p>

<p>So, let's say we make a one-dimensional array, a vector:</p>

<pre><code>int vec[] = {0, 1, 2, 3 };
</code></pre>

<p>In memory, that becomes a location with a name <code>vec</code></p>

<pre><code>vec:
     DS  0
     DS  1
     DS  2
     DS  3
</code></pre>

<p>where <code>DS</code> is just saying ""define storage and initialize with"".</p>

<p>When you write a <code>for</code> loop to iterate through it:</p>

<pre><code>int ix;
for(ix=0; ix &lt; 4; ix++){
   printf(""%d\n"", vec[ix]);
}
</code></pre>

<p>it becomes a loop somewhat like</p>

<pre><code>ix:    DS 0
loop:  CMP ix, 4
       JGE end     ; jump if comparison is &gt;=
       PUSH vec+ix ; address arithmetic
       JSR PRINTF  ; call the printf routing using value on the stack
       INC ix      ; ix := ix+1
       JUMP loop   ; goto top
end:  
</code></pre>

<p>(That's in no particular assembler, just a pseudocode.)</p>

<p>Now, let's make a 2d array</p>

<pre><code>int ary2[][] = {{0,1,2,3},{4,5,6,7});
int ix, jx;
for(ix=0; ix&lt;4;ix++){
   for(jx=0; jx&lt;4; jx++){
      printf(""%d\n"", ary2[ix][jx]);
   }
}
</code></pre>

<p>In memory, that just becomes</p>

<pre><code>ary2:
     DS 0
     DS 1
     DS 2
     DS 3
     DS 4
     DS 5
     DS 6
     DS 7
</code></pre>

<p>in other words, just another blob of memory.  Our loop becomes</p>

<pre><code>ix:   DS  0
jx:   DS  0
;; Now, the compiler helps us a little bit: it ""remembers"" that
;; the inner array is 4 long.  We'll keep that around as 'len'
len:  DS  4
ofst: DS  0   ; and we'll keep a convenient variable for the ""offset""
;; here's out loop
loop1:
      CMP ix, 4
      JGE end1
loop2:
      CMP  jx, 4
      JGE  end2
;; I'm going to cheat here.  ASSUME I've got a little
;; routine that multiplies ix*len and puts it in offset
      MLTOFFSET  ix,len
      ADD  jx, ofst
;; so what this all did was make ofst == (ix*len)+jx
      PUSH ary2+ofst
      INC  jx
      JUMP loop2
end2:
      INC ix
      JUMP loop1
end1:
</code></pre>

<p>If you walk through that, what you find is that <code>ary2[ix][jx]</code> turns into
<code>ary2+0</code>,<code>ary2+1</code>,<code>ary2+2</code>,...<code>ary2+6</code>,<code>ary2+7</code> -- and those are exactly the values you need to make that one piece of memory <em>act</em> like a 2 dimensional array.</p>

<p>The same trick, of course, can be carried on for as many dimensions as you want; the compiler just has to ""remember"" how big the steps will be.</p>
",0
7452306,7452164,1,"<p>A C 2-dimensional array is nothing more or less than an array of arrays.  Such a 2-d array cannot be ""ragged"", i.e., each row must have the same number of elements.  For your particular case, you could declare it as:</p>

<pre><code>int big[4][4] =
    { { 1, 2, 3, 4 },
      { 10, 12, 13, 14 },
      { 8, 9, 15, 16 },
      { 17, 18, 19, 20 } };
</code></pre>

<p>You can omit the first dimension: <code>int big[][4] = ...</code> and the length will be determined by the initializer, but you can't omit the second one.</p>

<p>One advantage of this approach is that it's a single object, and you can use <code>sizeof</code> to determine how many elements it has:</p>

<pre><code>sizeof big == 16 * sizeof (int)
sizeof big[0] == sizeof *big == 4 * sizeof (int)
sizeof big[0][0] == sizeof (int)
</code></pre>

<p>But the disadvantage is that the dimensions are fixed.</p>

<p>Another approach is to use an array of pointers, where each pointer points to the first element of an array:</p>

<pre><code>int row0[] = { 1, 2, 3, 4 };
int row1[] = { 10, 12, 13, 14 };
int row2[] = { 8, 9, 15, 16 };
int row3[] = { 17, 18, 19, 20 };

int *big[4] = { row0, row1, row2, row3 };
</code></pre>

<p>(In the initializer, <code>row0</code> is an array name, but it decays to a pointer to the first element; likewise for <code>row1</code>, <code>row2</code>, and <code>row3</code>).  This is more flexible, but you have to keep track of the number of elements in each row; <code>sizeof big[0]</code> will give you the size of a pointer, not of the row itself.</p>

<p>Yet another approach is make <code>big</code> a pointer-to-pointer:</p>

<pre><code>int row0[] = { 1, 2, 3, 4 };
int row1[] = { 10, 12, 13, 14 };
int row2[] = { 8, 9, 15, 16 };
int row3[] = { 17, 18, 19, 20 };

int *rows[] = { row0, row1, row2, row3 };

int **big = rows;
</code></pre>

<p>This is even more flexible (and in practice you'd probably allocate everything with <code>malloc()</code>.</p>

<p>A fourth approach, probably not terribly useful, would be to make <code>big</code> an array of pointers to arrays; I won't go into the details of that.</p>

<p>Due to the array-to-pointer decay rules, even though <code>big</code> is of 4 different types in the 4 different cases, you can use the same syntax to refer to the <code>int</code> elements: <code>big[x][y]</code>.</p>

<p>Recommended reading, as always: section 6 of the <a href=""http://c-faq.com/"" rel=""nofollow"">comp.lang.c FAQ</a>.</p>
",0
7514569,7514546,6,"<p>Try the function <a href=""http://en.cppreference.com/w/c/string/byte/strtoul"" rel=""nofollow noreferrer""><code>strtoull</code></a> which returns <code>unsigned long long</code>.</p>
<p>On Visual Studio <code>strtoull</code> is not available, but <a href=""http://msdn.microsoft.com/en-us/library/85zk715d.aspx"" rel=""nofollow noreferrer""><code>_strtoui64</code></a> can probably be used.</p>
<h3>EDIT</h3>
<p>As <a href=""https://stackoverflow.com/users/379897/r"">R..</a> mentions in the comments you should probably use <code>sscanf(hex, &quot;%p&quot;, ..)</code> or <code>strtoumax</code> which has the same prototype as <code>strtoull</code> but returns an <code>uintmax_t</code>.</p>
",5
7516156,7514546,1,"<pre><code>void *ptr;
sscanf(hex, ""%p"", &amp;ptr);
</code></pre>
",1
7457382,7455963,3,"<p>This answer assumes a Unix-like system, such as Linux, Mac OS X, or BSD.</p>

<p>First of all, you don't need threads to do asynchronous I/O in C.  The <a href=""http://linux.die.net/man/2/select"" rel=""nofollow""><code>select</code></a> system call can be used to wait for activity on one or more file descriptors.</p>

<p><a href=""http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf"" rel=""nofollow"">Threads are Evil</a> (at least in C).  They cause everything to be shared by default, which violates the principle of least privilege.  On the other hand, threads keep you from having to ""turn your code inside-out"".  I recommend not using threads in C, but the choice is yours.  The example below does not use threads.</p>

<p>If you're writing a TCP server, a good place to start is <a href=""http://linux.die.net/man/7/tcp"" rel=""nofollow""><code>man 7 tcp</code></a>.  It tells you what arguments to give to the <a href=""http://linux.die.net/man/2/socket"" rel=""nofollow""><code>socket</code></a> function, as well as what steps you need to take to start listening for connections.</p>

<p>The code that follows is a ""parrot server"", a program that accepts connections from clients and echos what they send.  You can connect to it by running <code>telnet localhost 1337</code> in the command line.  I hope it will help you get started:</p>

<pre><code>#include &lt;arpa/inet.h&gt;
#include &lt;err.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/tcp.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define PORT        1337
#define CLIENT_MAX  3

/* Utility macro: return the maximum of two numbers. */
#define max(a, b) ((a) &gt; (b) ? (a) : (b))

/* Utility function: send a NUL-terminated string on a socket. */
static ssize_t send_string(int sockfd, const char *str, int flags)
{
    return send(sockfd, str, strlen(str), flags);
}

/*
 * Filter out negative values in an array of ints.
 * Return the new array count.
 */
static int filter_out_negatives(int *fds, int count)
{
    int i;
    int new_count;

    for (i = 0, new_count = 0; i &lt; count; i++) {
        if (fds[i] &gt;= 0)
            fds[new_count++] = fds[i];
    }

    return new_count;
}

int main(void)
{
    /* Server socket */
    int server;

    /* Client socket array */
    int clients[CLIENT_MAX];
    int client_count = 0;

    /* Other useful variables */
    int i;
    int rc;

    /* See man 7 tcp. */
    server = socket(AF_INET, SOCK_STREAM, 0);
    if (server &lt; 0) {
        /* Simple error handling: print an error message and exit. */
        err(1, ""socket"");
    }

    {
        /* This structure is described in man 7 ip. */
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(PORT); /* port in *network byte order*, hence the htons */
        addr.sin_addr.s_addr = INADDR_ANY;

        rc = bind(server, (const struct sockaddr *) &amp;addr, sizeof(addr));
        if (rc &lt; 0)
            err(1, ""bind"");
    }

    rc = listen(server, 20);
    if (rc &lt; 0)
        err(1, ""listen"");

    for (;;) {
        int nfds;
        fd_set readfds;
        FD_ZERO(&amp;readfds);

        /*
         * Listen for activity on the server socket.  It will be readable
         * when a client attempts to connect.
         *
         * The nfds argument to select is pesky.  It needs to be the
         * highest-numbered file descriptor we supply, plus one.
         */
        FD_SET(server, &amp;readfds);
        nfds = server + 1;

        /* Listen for activity on any client sockets. */
        for (i = 0; i &lt; client_count; i++) {
            FD_SET(clients[i], &amp;readfds);
            nfds = max(nfds, clients[i] + 1);
        }

        /* Wait for activity from one or more of the sockets specified above. */
        rc = select(nfds, &amp;readfds, NULL, NULL, NULL);
        if (rc &lt; 0) {
            warn(""select"");
            continue;
        }

        /* Check for activity on client sockets. */
        for (i = 0; i &lt; client_count; i++) {
            if (FD_ISSET(clients[i], &amp;readfds)) {
                /*
                 * The parrot only has so much breath.  If the client sends us
                 * a long message, it's not a big deal the parrot has to squawk
                 * again.
                 */
                char buffer[100];
                ssize_t readlen;

                readlen = recv(clients[i], buffer, sizeof(buffer), 0);
                if (readlen &lt; 0) {
                    warn(""recv"");
                } else if (readlen == 0) {
                    /* Client closed the connection. */
                    if (close(clients[i]) &lt; 0)
                        err(1, ""close (1)"");

                    /*
                     * Set client socket to -1.  We'll remove it
                     * at the end of this loop.
                     */
                    clients[i] = -1;
                } else {
                    if (send_string(clients[i], ""Squawk!  "", 0) &lt; 0)
                        warn(""send (2)"");
                    if (send(clients[i], buffer, readlen, 0) &lt; 0)
                        warn(""send (3)"");
                }
            }
        }

        /* Filter out closed clients. */
        client_count = filter_out_negatives(clients, client_count);

        /*
         * If there is activity on the server socket, it means someone
         * is trying to connect to us.
         */
        if (FD_ISSET(server, &amp;readfds)) {
            int client;

            client = accept(server, NULL, NULL);
            if (client &lt; 0)
                err(1, ""accept"");

            if (client_count &lt; CLIENT_MAX) {
                clients[client_count++] = client;

                if (send_string(client, ""Squawk!  Welcome to the Parrot Server!\n"", 0) &lt; 0)
                    err(1, ""send (4)"");
            } else {
                if (send_string(client, ""Squawk!  I'm busy, can you come back later?\n"", 0) &lt; 0)
                    err(1, ""send (5)"");
                if (close(client) &lt; 0)
                    err(1, ""close (2)"");
            }
        }
    }
}
</code></pre>

<p>The most important thing is to learn through play.  Don't worry about all the little nuances up front (e.g. what will happen if <a href=""http://linux.die.net/man/2/send"" rel=""nofollow""><code>send</code></a> blocks or produces <code>SIGPIPE</code>).  Get something working, and play around with it.  When you encounter a problem, <em>then</em> go back to the manual to see how to deal with it.  If something you read in the manual solves a problem you are actually observing, you will surely remember it.</p>

<p>On the other hand, do worry about checking the return value of every system call you make.  If you don't, your program will start acting weird, and you won't know why.  Even if all you do is print an error message, at least you'll know that a system call failed.</p>
",1
7497473,7497420,8,"<p>C does not define <code>string</code>: it only has ""perfectly ordinary arrays of characters"" and pointers to those arrays;</p>

<p>C++ defines it, as a class type, with several properties and methods.</p>
",4
7497494,7497420,0,"<p>in C++ String objects are a special type of container, specifically designed to operate with sequences of characters.string class defined in string</p>

<p>or in C string is a character sequence terminated with a null character ('\0'), all functions related to strings defined in string.h</p>
",0
7497507,7497420,4,"<p>In C there is no such thing/type as ""string"". It is represented as NULL terminated array of characters like <code>char str[256];</code>. C++ has <code>string</code> class in standard library that internally maintains it as array of characters and has many methods and properties to manipulate it. </p>
",0
7497715,7497420,3,"<p>I fully agree with @pmg answer. But one need to mention some things. In C programmer must be very careful when he works with C-strings because a) every C-string must be ended with zero code character; b) it is very easy to make buffer overrun if buffer size for string is too small. Also in C all work with strings goes through functions. It may be programmers nightmare. In C++ things are much simpler. Firstly, you don't need to care about memory management. String class allocate additional memory when internal buffer becomes small. Secondly, you don't need to care about zero terminating character. You work with container. Thirdly, there are simple methods for working with string class. For example, overloaded operator + for string concatenation. No more awful strcat() calls. Let the work with strings to be simple!</p>
",0
8285234,8285228,12,"<p>Your guess is correct; it's an infinite loop.<sup>*</sup>  This is a common C idiom, although many people (including me) believe the following to be less cryptic:</p>

<pre><code>while (1) { whatever statements; }
</code></pre>

<p><hr>
<sub>* It's infinite assuming there are no <code>break</code>/<code>return</code>/etc. statements inside the loop body.</sub></p>
",3
8285246,8285228,0,"<p>This statement is basically equal to: </p>

<pre><code>while(1) {}
</code></pre>

<p>There is no start, no condition and no step statement.</p>
",0
8285251,8285228,1,"<p>Yes, the expressions in the for loop are just optional. if you omit them, you will get an infinite loop. The way to get out is break or exit or so.</p>
",0
8285253,8285228,2,"<p>It's an un-terminated loop. It is sometimes written with a <code>while</code>:</p>

<pre><code>while (1)
</code></pre>

<p>or even better:</p>

<pre><code>while (true)
</code></pre>

<p>I would expect to see a <code>break</code> or <code>return</code> inside any such loop, no matter whether it is written with <code>for</code> or <code>while</code>. There has to be some abnormal control flow or it really will be an infinite loop.</p>
",1
8285287,8285228,2,"<p>Yes, that's the <code>for</code> C syntax with blank fields for initialization expression, loop condition and increment expression.</p>

<p>The <code>for</code> statement can also use more than one value, like this sample : </p>

<pre><code>for (i=0, j=100, k=1000; j &lt; 500 || i&lt;50 || k==5000; i++, j+=2, k*=6) {}; 
</code></pre>

<p>Maybe one step beyond in <code>for</code> understanding ? =)</p>
",0
7785791,7785764,0,"<p><strike>Use ¡±%f¡±, not ¡±%lf"".</strike>  And for future reference, please tell us <em>how</em> it doesn't work.</p>
",2
7785826,7785764,1,"<p>This should Work :</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;math.h&gt;

#define PI 3.14159265

void main()
{
double x;

clrscr();
printf(""Enter angle:"");
scanf(""%lf"",&amp;x);
printf(""Sine %lf = %lf"",x,sin (x*PI/180));
getch();
}
</code></pre>
",1
7785892,7785764,2,"<p>Maybe there is 3 issues with the code:</p>

<ol>
<li>You should convert <code>x</code> to radian angle :<code>sin(x*3.14159265/180.0)</code>.</li>
<li>You should add <code>\n</code> : <code>printf(""Sine %lf = %lf\n"",x,sin(x*PI 3.14159265/180.0));</code> Because it flushes output to <code>stdout</code>.</li>
<li>Maybe you have a compile error with <code>clrscr()</code> which is not supportet with currently compilers.</li>
</ol>

<p>So try this:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main()
{
  double x;
  printf(""Enter angle:"");
  scanf(""%lf"",&amp;x);
  printf(""Sine %lf = %lf\n"",x,sin(x*3.14159265/180.0));
  getch();
  return 0;
}
</code></pre>

<p><strong>EDIT:</strong>
<em>Accuracy of 3.14 is not well</em></p>
",6
7787077,7785764,0,"<p>Here's a more portable version of the program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(void)
{
    double x;

    printf(""Enter angle (in radians): "");
    fflush(stdout);
    scanf(""%lf"", &amp;x);

    printf(""sin %lf = %lf\n"", x, sin(x));

    return 0;
}
</code></pre>

<p>The changes I've made are:</p>

<ol>
<li><p>Drop <code>#include &lt;conio.h&gt;</code> and the calls to <code>clrscr()</code> and <code>getch();</code>.  These are Windows- (or MS-DOS-) specific.  That's not necesarily to say that you shouldn't use them (they exist for a reason), but you should at least be aware that they make your program less portable than it could be.  (And why do you want to clear the screen anyway?  I might have information there.)</p></li>
<li><p>Change <code>void main()</code> to <code>int main(void)</code>.  Compilers are allowed to accept <code>void main()</code>, but it's non-portable, and there is <em>no</em> good reason to use it rather than the completely portable <code>int main(void)</code>.  (Unless you're writing code for an embedded system that doesn't like <code>int main(void)</code>, but that's not the case here.)</p></li>
<li><p>Add <code>fflush(stdout);</code> after the prompt.  This may not be necessary, but it's possible that the prompt won't appear without it.  Portability again.</p></li>
<li><p>Add <code>return 0;</code> to the end of the program.  In the 1990 version of the C standard, falling off the end of the <code>main</code> function without a return statement returns an undefined status to the environment; in C99, there's an implied <code>return 0;</code>, but it doesn't hurt to make it explicit.</p></li>
</ol>

<p>As for the behavior of both your original program and this modified one, <code>sin(3.14)</code> <em>is</em> approximately 0.001593.  But even if you had entered a more precise value of pi, <code>sin(x)</code> <em>still</em> wouldn't give you exactly 0.0, because floating-point cannot represent the value of pi exactly.  If you show the result with more precision, you'll see that <code>sin(3.14159265358979323846264)</code> comes out to something like <code>0.00000000000000012246063538223772</code>.</p>

<p>Finally, the purpose of your <code>getch()</code> call is to make the program wait for you to press a key before it terminates (and, presumably, the window in which the output appears vanishes).  That's typically needed for Windows-style IDE environments, but if you run the program from a command prompt it's unnecessary.  Again, I'm not telling you not to call <code>getch()</code>, just that you don't necessarily need it.</p>
",0
7775238,7775225,5,"<p>You miss address-of operator here </p>

<pre><code>         //read in the day, start time, and end time.
        fscanf(ifp, ""%d"", day);
        fscanf(ifp, ""%d"", start);
        fscanf(ifp, ""%d"", end);
</code></pre>

<p>correct should be</p>

<pre><code>         //read in the day, start time, and end time.
        fscanf(ifp, ""%d"", &amp;day);
        fscanf(ifp, ""%d"", &amp;start);
        fscanf(ifp, ""%d"", &amp;end);
</code></pre>

<p>it's strange it's correct above! Time to go to sleep, for me at least!</p>
",0
7775259,7775225,0,"<p>Because this reads a lot like homework, I'm going to be giving <em>hints</em> about the problems, rather than anything approaching <em>fixes</em> -- a huge part of learning is fighting the fight, but there's nothing fun about being stuck for hours at a time.</p>

<pre><code>int Schedule;
int booked;
/* ... */
            else if (Hours_week[k] == 1)
                Schedule = booked;
/* ... */
    if (Schedule == booked)
        printf(""I'm sorry, schedule %d has a conflict in it.\n"", i);
</code></pre>

<p>You have used <code>booked</code> without initializing it first. (Any reasonable compiler should have <em>warned</em> about this -- please do not disregard your compiler warnings. Not all warnings need to be silenced, but the authors of your compiler are <em>very</em> good programmers and will warn you when things don't look right.)</p>

<pre><code>        //read in the day, start time, and end time.
        fscanf(ifp, ""%d"", day);
        fscanf(ifp, ""%d"", start);
        fscanf(ifp, ""%d"", end);
</code></pre>

<p>You've passed the (probably uninitialized) values of <code>day</code>, <code>start</code>, and <code>end</code> as <em>addresses</em> to <code>fscanf(3)</code>. Again, this is a case that your compiler should have warned you about. Don't ignore the warnings. :)</p>

<pre><code>    j = 0;
    while (j &lt; Num_items){
        j++;
</code></pre>

<p>This code is ripe for replacement with a <code>for</code> loop. Don't just use a different loop type for variety. <code>while</code> loops are <em>fine</em>, and if you were doing anything remotely interesting with <code>j</code> inside the loop, this might be fine. But you're simply incrementing it. Stick to the boring old idioms where you can, it'll make reading code far easier. (It comes with practice.) There's nothing <em>wrong</em> with this, it is just that I wondered why you chose a different loop construct here than all the other loops when it looked fundamentally identical.</p>
",0
8427914,8427740,1,"<p>Well, reading and writing the input and output should be a no brainer (you open the file, read/write and then close it when you're done with it).</p>

<p>The trick is to get those pesky strings sorted. 
The way I look at strnig sorting is an array of arrays sorting. The first array-level is an iteration over all the structs while the second is an iteration over all the letters of a name (note that some names are longer then others)<br>
1. First you sort the first column - all the first letters<br>
2. Then all the sub-columns - within each first letter group you sort the second letter<br>
3. Repeat 1&amp;2 until you run out of letters to sort.</p>

<p>The sorting of an array of letters is the same as sorting an array of byte (AKA chars), and if you're working with an algorithm like bubble sort, working on a sub array is seamless.</p>

<p>Hope this idea helps</p>
",0
8428093,8427740,0,"<p>You can use <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strcmp/"" rel=""nofollow"">strcmp</a> from string.h library, which compares two strings and returns the result. 
You should read every string from input file and keep in memory. You will probably use a list for that, for example linked list. While adding you can organize them in alphabetical order. Here is an example:</p>

<ol>
<li>Take the an element in list.</li>
<li>Compare it with new string.</li>
<li>Where should it be placed? if it should be before the current element, place it before the current element. If it should be after current element, do the same for next element.</li>
</ol>

<p>This is a simple algorithm for your problem.</p>
",0
8428402,8427740,0,"<p>The tricky part is to implement the comparation of two strings. the strcmp function only tells you whether the strings are identical. You can loop through the char array to do it.</p>

<p>Once this is done, the remaining sorting is simple.</p>
",1
8237614,8237583,0,"<p>(Assuming you're using TCP/IP, or UDP).  </p>

<p>A socket endpoint is the IP address and port number combined.  So, on your host you would have your various servers listen on different port numbers.  For example a web server may listen on port 80, ssh on a different port etc.</p>
",0
8237685,8237583,1,"<p>When you create a socket, first you establish a connection between a server and a client (using <code>connect</code> system call on the client side, and <code>bind</code>, <code>listen</code>, and <code>accept</code> system calls on the server side). You can have many such connections, from a server to different clients. The server can send data on any of these established connections.</p>

<p>The <a href=""http://www.linuxhowtos.org/C_C++/socket.htm"" rel=""nofollow"">Sockets Tutorial</a> can assist you in this case.</p>

<hr>

<p>If you want multiple reads/writes by the server to happen <em>at the same time</em>, you have to use <a href=""http://www.scottklement.com/rpg/socktut/nonblocking.html"" rel=""nofollow"">non-blocking</a> sockets or multiple threads.</p>
",1
8263897,8263822,3,"<p>You open the file three separate times (in three separate modes) over the course of 6 lines of code (not counting blank lines) in <code>ProcesoHijo2</code>:</p>

<pre><code>descrFichero = open(""salida.txt"", O_CREAT|O_TRUNC, 0600);  /* One */
descrFichero = open(""salida.txt"", O_RDWR | O_TRUNC, 0600); /* Two */

FILE*fp = fdopen(descrTub2[0], ""r"");

while(1) { 

    fgets(bufferLectura,255,fp); 
    descrFichero = open(""salida.txt"",O_APPEND|O_WRONLY, 0600); /* Three */
    write(descrFichero, bufferLectura, strlen(bufferLectura));
}
</code></pre>

<p>The first truncates it, the second truncates it. The third time opens the file over and over again (each time through the while loop), even though you've already opened it twice previously using the same file descriptor <code>descrFichero</code>.</p>

<p>Replace the first one with something like this, and delete the other two calls to <code>open</code>:</p>

<pre><code>descrFichero = open(""salida.txt"", O_APPEND | O_TRUNC | O_RDWR, 0600);
</code></pre>
",2
8443606,8443482,1,"<p>Use preprocessor directives to remove the tracing statements:</p>

<pre><code>#ifdef TRACING_IS_ENABLED
    /* Perform tracing operations. */
#endif
</code></pre>

<p>Ensure there are no unintended side effects from the tracing statements.</p>

<p>If you want to re-enable the tracing operations define the macro <code>TRACING_IS_ENABLED</code>.</p>
",0
8443626,8443482,2,"<p>Usually trace is performed in a way similar to this (oversimplified here):</p>

<pre><code>#ifdef DISPLAY_TRACES
#define TRACE(x) printf(x)
#else
#define TRACE(x)
#endif
</code></pre>

<p>Then compile with or without <code>-DDISPLAY_TRACES</code> depending on whether you want traces.</p>
",1
8443681,8443482,2,"<p>You can put the tracing in pre-processor macros, and use the pre-processor conditions to select which macros should be used:</p>

<pre><code>#ifdef TRACING_ENABLED
# define TRACE(x) printf(""TRACE: %s:%d %s\n"", __FILE__, __LINE__, x)
#else
# define TRACE(x)
#endif

void foo()
{
    TRACE(""In foo()"");
}
</code></pre>

<p>If <code>TRACING_ENABLED</code> is defined, the <code>TRACE</code> macro is replaced by a <code>printf</code> statement. If <code>TRACING_EMABLED</code> is <em>not</em> defined, <code>TRACE</code> is replaced by an empty line.</p>
",5
8460487,8459467,0,"<p>As Oli has commented, you're sacrificing type-safety. You're also forcing people to muck around with memory buffers passed by pointer, which quickly gets awkward. Just make a single getter per public data member. That's an ABI breaker in terms of backward compatibility with older versions of the library, but it retains forward compatibility if you never remove a getter.</p>
",0
4526853,4526826,2,"<p>You are missing a <code>#include &lt;ctype.h&gt;</code> for <code>toupper</code>.</p>

<p>For the rest, I don't really know where to start... </p>

<ul>
<li>You're compiling <code>C++</code>, not <code>C</code></li>
<li>All your functions are missing a return type (but <code>void</code> should be appropriate for all of them)</li>
</ul>
",0
6369980,6289169,0,"<p>In this particular case, yes both a and b would be reported to be same, since the array in question is 1D. FYI - this does not hold true had it been a 2D or higher dimensional array in question? Read more about pointer to arrays,in that case. Good to know concept, though better avoided for maintaining good code readability.</p>
",0
2611051,2610939,5,"<p>In a typical case, a structure with a member that's declared as an array of one item will have that member as the <em>last</em> item in the struct. The intent is that the struct will be allocated dynamically. When it is allocated, the code will allocate space for as many items as you really want/need in that array:</p>

<pre><code>struct X {
    time_t birthday;
    char name[1];
};

struct X *x = malloc(sizeof(*x) + 35);
x-&gt;birthday = mktime(&amp;t);
strcpy(x-&gt;name, ""no more than 35 characters"");
</code></pre>

<p>This works particularly well for strings -- the character you've allocated in the struct gives you space for the NUL terminator, so when you do the allocation, the number of characters you allocate is exactly the <code>strlen()</code> of the string you're going to put there. For most other kinds of items, you normally want to subtract one from the allocation size (or just live with the allocated space being one item larger than is strictly necessary).</p>

<p>You can do (sort of) the same thing with a pointer, but it results in allocating the body of the struct separately from the item you refer to via the pointer. The good point is that (unlike the method above) more than one item can be allocated dynamically, where the method above only works for the last member of the struct.</p>
",1
2611172,2610939,0,"<p>So I think it's been stated that the main difference between pointers and arrays is that you have to allocate memory for pointers.</p>

<p>The tricky part about your question is that even as you allocate space for your struct, if your struct contains a pointer you have to allocate a SECOND time for the pointer, but the pointer itself would be allocated as part of the struct's allocaiton.</p>

<p>If your struct contained an array of 1 you would not have to allocate any additional memory, it would be stored in the struct (which you still have to allocate).</p>
",0
2610949,2610939,0,"<p>These are different things.</p>

<p>Such member's name is an address of allocated memory, allocated inside the struct instance itself.</p>
",2
2610974,2610939,2,"<p>What you describe are two different things entirely.  If you have a pointer as a member:</p>

<pre><code>a_struct_t* a_member;
</code></pre>

<p>then it is simply a pointer.  There is no memory allocated inside of the struct to hold an <code>a_struct_t</code>.  If, on the other hand, you have an array of size 1:</p>

<pre><code>a_struct_t a_member[1];
</code></pre>

<p>then your struct actually has an object of type <code>a_struct_t</code> inside of it.  From a memory standpoint, it isn't much different from just putting an object of that type inside the struct:</p>

<pre><code>a_struct_t a_member;
</code></pre>

<p>From a usage standpoint, an array requires indirection to access the one element (i.e., you need to use <code>*a_member</code> instead of <code>a_member</code>).</p>
",2
2610987,2610939,2,"<p>""Array of size 1 instead of a pointer""? Sorry, but I don't see how this quiestion can possibly make sense. I would understand if you asked about ""array of size 1 instead of an ordinary member (non-array)"". But ""instead of a pointer""? What does pointer have to do with this? How is it interchangeable with an array, to justify the question?</p>

<p>If what you really wanted to ask is why it is declared as an array of size 1 instead of non-array as in</p>

<pre><code>struct { 
  a_struct_t a_member; 
} b_struct; 
</code></pre>

<p>then one possible explanation is the well-known idiom called ""struct hack"". You might see a declaration like</p>

<pre><code>struct { 
  ...
  a_struct_t a_member[1]; 
} b_struct; 
</code></pre>

<p>used to implement an array of flexible size as the <em>last</em> member of the struct object. The actual struct object is later created within a memory block that is large enough to accomodate as many array elements as necessary. But in this case the array has to be the <em>last</em> member of the struct, not the first one as in your example.</p>

<p>P.S. From time to time you might see ""struct hack"" implemented through an array of size 0, which is actually a constraint violation in C (i.e. a compile error).</p>
",2
5479670,5479630,1,"<pre><code>while(isdigit(s[++i] = c))
    c = getch();
</code></pre>

<p>and</p>

<pre><code>while(isdigit(s[++i] = c = getch()))
    ;
</code></pre>

<p>have different behavior. The latter reads once before entering the loop and checks if the value read is a digit, while the former checks if the previously read value was a digit.</p>
",1
5619228,5619110,1,"<p>Aside from the lack of newlines, that seems to run fine on my machine - the output is <code>10 1210 14100 200</code>, which when appropriately newlined, gives </p>

<pre><code>10 12
10 14
100 200
</code></pre>

<p>.</p>

<p>Also, <code>getch()</code> is a strange choice, given that you've just called <code>fclose()</code> on <code>stdin</code></p>
",0
5619259,5619110,2,"<p>Your code needs to check the return values from <code>freopen()</code> and <code>scanf()</code>.</p>

<p>An unexpected return value from either of those functions will give you clues as to what is going wrong.</p>

<p><code>freopen()</code> returns <code>NULL</code> to indicate an error.</p>

<p><code>scanf()</code> returns the number of items converted, or <code>EOF</code>.</p>

<p>In either case your code can examine the value of <code>errno</code> to find out what caused the error. You will probably want to print it using <code>perror()</code>.</p>
",2
5619274,5619110,2,"<p>You need to run your code through a debugger.  I think then it'll probably be blindingly obvious what the issue is. </p>

<p>Having said that, you do <strong>no</strong> error checking on any of your library calls.  If any of them fail, you'll just have garbage values in your variables.</p>
",0
7089588,7089511,2,"<p>the signature of <code>pow</code> is:</p>

<pre><code>double pow(double X, double Y);
</code></pre>

<p>for calculating 2^multiplier use:</p>

<pre><code>1 &lt;&lt; multiplier;
</code></pre>

<p>Just to quickly mention:</p>

<ul>
<li>You have an infinite loop</li>
<li>If you parse the string from the other direction you can multiply the sum by two so you don't need the <code>multiplier</code> variable.</li>
<li>After that many problems I'm not even sure that <code>int binaryChar[]</code> is right. Char in the name suggests a different type (and code)..</li>
</ul>

<p>.</p>
",1
7089621,7089511,1,"<p>pow takes doubles and returns a double.  An ugly fix is just to use a cast</p>

<pre><code>(int)pow(x, y)
</code></pre>

<p>But in this simple program, why not just do the power expansion yourself instead of calling pow?</p>
",0
7089624,7089511,5,"<p>Why are you using <code>pow</code> to calculate a power of 2? It's too slow. Use <code>1 &lt;&lt; p</code> to get the p-th power of two. E.g., <code>1 &lt;&lt; 0</code> will give 1, <code>1 &lt;&lt; 1</code> will give 2, <code>1 &lt;&lt; 2</code> will give 4. This is due to the nature of the bit shift operation: shifting one bit to the left is equivalent of multiplying by 2. </p>

<p>Also, it looks like you have an endless cycle in your program: </p>

<pre><code>for(i=length;i&gt;=0;i++)
</code></pre>

<p>If <code>length</code> is >= 0, the loop will never terminate.</p>

<p>This should fix it:</p>

<pre><code>for(i = length - 1; i&gt;=0; i--) sum += (binaryChar[i]*(1 &lt;&lt; multiplier++));
</code></pre>
",1
7089680,7089511,1,"<p>The problem is that the precision of the data type int is smaller as the precision of double (the function <a href=""http://www.cplusplus.com/reference/clibrary/cmath/pow/"" rel=""nofollow"">pow</a> returns double) therefore the value of binaryChar[i] will be implizit converted to double and so on... problematic line implicit looks like this:</p>

<pre><code>sum = (double) sum + ((double) binaryChar[i] * pow((double)2, (double) multiplier))
</code></pre>

<p>in order to get rid of the warning you have to do an explicit conversion (
see <a href=""http://en.wikipedia.org/wiki/Type_conversion"" rel=""nofollow"">Type Conversion</a>), e.g.:</p>

<pre><code>sum = sum + (binaryChar[i] * ((int) pow(2, multiplier));
</code></pre>
",0
5462157,5460286,1,"<p>What you try to implement are so called <strong>coroutines</strong>. While C doesn't directly support them, there are ways to exploit some ingenious hacks like <em>Duff's Device</em> to implement them.</p>

<p>Simon Tatham wrote an excellent article about <strong>Coroutines in C</strong>: <a href=""http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html"" rel=""nofollow"">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a></p>
",0
5460335,5460286,0,"<p>I think you should use setjmp() and longjmp(). The man is available <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/setjmp.html"" rel=""nofollow"">here</a>.</p>

<p>The following example shows you how to use it (from <a href=""http://en.wikipedia.org/wiki/Setjmp.h#Example_usage"" rel=""nofollow"">http://en.wikipedia.org/wiki/Setjmp.h#Example_usage</a> ):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;setjmp.h&gt;

static jmp_buf buf;

void second(void) {
    printf(""second\n"");         // prints
    longjmp(buf,1);             // jumps back to where setjmp was called - making setjmp now return 1
}

void first(void) {
    second();
    printf(""first\n"");          // does not print
}

int main() {   
    if ( ! setjmp(buf) ) {
        first();                // when executed, setjmp returns 0
    } else {                    // when longjmp jumps back, setjmp returns 1
        printf(""main\n"");       // prints
    }

    return 0;
}
</code></pre>

<p>Output :</p>

<pre><code>second
main
</code></pre>
",0
5460336,5460286,5,"<p>Well, the typical way of doing this would be:</p>

<pre><code>int fn3() {
  return 1;
}

void fn2() {
  if (fn3())
    return;
  ...
}
</code></pre>

<p>Not sure if you're looking for something more esoteric, such as setjmp/longjmp</p>
",1
5460337,5460286,2,"<p>You can use <a href=""http://pubs.opengroup.org/onlinepubs/007908799/xsh/longjmp.html"" rel=""nofollow"">longjmp</a> as a ""long range goto"" if you <em>absolutely must</em> do this.</p>
",2
5460361,5460286,1,"<pre><code>int fn1(void) {
    printf(""in fn1 before calling fn2\n"");
    fn2();
    printf(""in fn1 after calling fn2\n"");
    return 0;
}
int fn2(void) {
    printf(""in fn2 before calling fn3\n"");
    if (1) {
      return fn3();
    }
    printf(""in fn2 after calling fn3\n"");
    return 0;
}
int fn3(void) {
    printf(""in fn3\n"");
    return 0;
}
</code></pre>
",0
5460479,5460286,1,"<p>You <em>can</em> use <code>setjmp</code> and <code>longjmp</code> to do this -- but it's almost certainly a really <em>bad</em> idea to actually do so. Former Fortran programmers (among others) still sometimes have nightmares about the kind of mess you seem intent on creating. Given a time when a mainframe that served 300+ simultaneous users ran at 20 MHz or so, there was some excuse at the time, even if keeping track of things was a mess. Given current computers, I question not only the utility but the very sanity of having a function call that doesn't return (especially since CPUs are now optimized for that case, so what you're asking for will be slower than normal returns).</p>
",0
5494280,3268292,0,"<p>Try doing a search for ""c programming puzzles"" and you'll find lots of resources on the tricky subtleties of the language itself (and there are many). Eg. <a href=""http://www.gowrikumar.com/c/"" rel=""nofollow"">here</a></p>
",0
5104643,4884972,0,"<p>I was trying to write the shortest code possible in c, so i tried removing the header files from source code.To my surprise even a program with printf compiled with just a warning and ran successfully.How does that happen??</p>

<p>main()
{
   printf(""Hello World\n"");
}</p>
",0
5096814,5096790,1,"<p>An array dimension with only one element in the row is a trifle pointless.  You normally only use dimensions with more than one element in each row.</p>

<p>Additionally, you are never assigning to the <code>travelint</code> array - only reading from it.  So, since it is initialized to all zeroes, all you will ever see when you print it are zeroes.</p>

<p>You probably simply need to change this:</p>

<pre><code>  if ( (cont_num &lt;= 7) &amp;&amp; (cont_num &gt; 0) &amp;&amp;  (type_num &lt;= 5) &amp;&amp; (type_num &gt;=0) )
      dest_code = travelint[i][0];  
</code></pre>

<p>to:</p>

<pre><code>  if ( (cont_num &lt;= 7) &amp;&amp; (cont_num &gt; 0) &amp;&amp;  (type_num &lt;= 5) &amp;&amp; (type_num &gt;=0) )
      travelint[i][0] = dest_code; 
</code></pre>

<p>This assigns to <code>travelint</code>. </p>

<p>To print out a full 2D array, you would normally use:</p>

<pre><code>for (int j = 0; j &lt; TRIP; j++)
{
    for (int k = 0; k &lt; DEST; k++)
        printf(""Trip[%d][%d] = %d\n"", j, k, travelint[j][k]);
}
</code></pre>

<p>Given that the inner loop will be executed just once per iteration of the outer loop (in your example, where DEST is 1), you could simplify that to:</p>

<pre><code>for (int j = 0; j &lt; TRIP; j++)
{
    printf(""Trip[%d][%d] = %d\n"", j, 0, travelint[j][0]);
}
</code></pre>

<p>You should validate the <code>trip_num</code> after the user enters it.  You should check that <code>scanf()</code> actually converted a value; if the user types 'A', then your program will go into a rapid loop printing out ""Invalid code"" every time.  Always check that inputs succeed.  In theory, you should also check that outputs succeed, but that rule is more often ignored than honoured.  Also, if the user is nasty and types 200, then your program is not going to be happy after the user enters the sixth trip destination.  It should be between 0 and TRIP (inclusive), of course.  You should handle the degenerate (0) case properly, of course.  And the printing loop becomes:</p>

<pre><code>for (int j = 0; j &lt; trip_num; j++)
{
    printf(""Trip[%d][%d] = %d\n"", j, 0, travelint[j][0]);
}
</code></pre>
",5
5113641,5113545,17,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

static void pSigHandler(int signo){
    switch (signo) {
            case SIGTSTP:
            printf(""TSTP"");
            fflush(stdout);
            break;
    }
}

int main(void)
{
    struct sigaction psa;
    psa.sa_handler = pSigHandler;
    sigaction(SIGTSTP, &amp;psa, NULL);
    for(;;) {}
    return 0;
}
</code></pre>

<p>Because you need to fflush(stdout)</p>

<p>try with C-z</p>

<p>I'm not even sure if it's safe to use stdio in a signal handler though.</p>

<p>Update: <a href=""http://bytes.com/topic/c/answers/440109-signal-handler-sigsegv"">http://bytes.com/topic/c/answers/440109-signal-handler-sigsegv</a></p>

<p>According to that link, you should not do this.</p>
",7
3921998,3921984,1,"<p>newjob->filename is a wild pointer(not set to anything), you have to allocate memory before you can store things at it.</p>
",0
3922004,3921984,1,"<p>Change:</p>

<pre><code>typedef struct{
    char* filename;
    int time;
} JOB;
</code></pre>

<p>to:</p>

<pre><code>#include &lt;limits.h&gt;

typedef struct{
    char filename[PATH_MAX];
    int time;
} JOB;
</code></pre>
",0
3922037,3921984,0,"<p>Additional suggestions for improvement of your code:</p>

<ul>
<li><p>You do never <code>free()</code> the malloced pointers.</p></li>
<li><p>What is there are more than 3 Jobs?
Your code doesn't handle this. You
could use a <strong><em>linked list</em></strong> instead of an
array.</p></li>
<li><p>You do not call <code>fclose()</code> on your file handle.</p></li>
</ul>
",1
3922119,3921984,1,"<p>I'd like to add a few suggestions</p>

<pre><code>nJobs = 0;
</code></pre>

<p>Globals are initialised with 0, you don't need to do it manually.</p>

<pre><code>while (fgets(filename,sizeof(jobfilename),fp)!=NULL) {
</code></pre>

<p>jobfilename is not declared in your code. I guess you mean filename.</p>

<pre><code>for (int i = strlen(line); i &gt;=0; i--) {
    if (line[i] == '\n' || line[i] == '\r') line[i] = '\0';
}
</code></pre>

<p>You start with the ending \0 which you could skip.</p>

<p>You declare new variables everywhere you like, it's good practice (and C89 standard) that increases readability to declare variables at the start of a code block.</p>
",0
3923062,3921984,0,"<p>Trasvi, don't forget that your jobQueue is malloc'ed to hold only 3 instances of the JOB struct. However, your ""while loop"" goes around as many times as the user inputs.</p>

<p>But to answer your original question, simply add this to your code before the strcpy.</p>

<pre><code>newjob-&gt;filename = malloc ( strlen( filename) +1 );
//You only need to malloc the amount of characters in the filename + 1,
//which is for the null-terminated char, and you don't need to worry about 
//multiplying by 'sizeof' because a char is one byte on any compiler.
</code></pre>
",0
8255887,8255854,6,"<p>There should be millions of pages explaining the use of <code>malloc</code>, I doubt you did much searching. But here is how you call it:</p>

<pre><code>char *var = malloc(sizeof(char) * 1000);
</code></pre>

<p>For other types, just change it:</p>

<pre><code>int *int_var = malloc(sizeof(int) * 1000);
</code></pre>

<p><strong>Edit</strong> Remember that you have to free the allocated memory after use! Or you will have a memory leak.</p>

<pre><code>free(var);
free(int_var);
</code></pre>
",2
8255889,8255854,0,"<p><a href=""http://www.manpagez.com/man/3/malloc/"" rel=""nofollow"">http://www.manpagez.com/man/3/malloc/</a></p>

<pre><code>char *pVar = malloc(1000);
.... use pVar ....
free(pVar);
// DONT use pVar anymore
</code></pre>
",0
8255898,8255854,0,"<p>If you have declared your variable as <code>char var[1000];</code> you already have statically allocated that much memory. You don't need to call <code>malloc</code> for this.</p>

<p>If you want to use dynamic allocation and your variable is declared like this: <code>char *var;</code> you can allocate the memory as follows:</p>

<pre><code>var = malloc(1000);
</code></pre>

<p>also don't forget to free your allocated memory when you're done with it:</p>

<pre><code>free(var);
</code></pre>
",2
8255904,8255854,2,"<p>You do not want to use malloc for this variable, because it's already allocated, but you may achieve similar results by using</p>

<pre><code>char *var = malloc(sizeof(char[1000]));
// do stuff
free(var);
</code></pre>
",0
8255914,8255854,0,"<p>If you have <code>char var[1000]</code> you do not need malloc this definition allocates <code>1000*sizeof(char)</code> for your <code>var</code> so you can do something like var[999] = 'x';</p>
",0
5166294,5166221,1,"<p>You don't need atoi, just add <code>buffer[i]</code>.  atoi is interpreting a string as a number, something not wanted in this case, and you use it in a wrong way if it was wanted.</p>
",0
5166390,5166221,1,"<p>Your sum is not initialised.</p>

<p>You are deferencing an undefined pointer (ptr).</p>

<p>You don't need the atoi.</p>

<p>You are only using the bottom 6 bits.</p>

<p>Two's complement is just a negation (although your binary not and adding 1 should work).</p>

<p>Try:</p>

<pre><code>int getcheckdigit(char *buffer) {

    int i;
    int sum = 0;

    for (i=0;i&lt;=16;i++) {
        sum += buffer[i];
    }

    sum = -(sum % 128);

    return sum;
}
</code></pre>
",1
5194665,5194648,3,"<p>compare <code>*test</code> to <code>'\0'</code>, return 0 if inequal, return 1 if equal.</p>
",1
5194680,5194648,1,"<p>It fails to compile because ""test"" is not the same as ""text"", and because there is no such type <code>Int</code> in C.</p>

<p>If the typos were fixed, it'd see whether the first letter of the buffer pointed to by <code>text</code> is the NULL character -- i.e. it returns <code>1</code> if the buffer is empty, and <code>0</code> otherwise.</p>
",0
5194689,5194648,2,"<p>The <code>*test</code> part reads the first character for the C string (a C string is merely a bunch of characters starting at a given address, and the <code>*foo</code> operator looks at that address which happens to contain the first character). By definition, a C string ends with a null byte (<code>'\0'</code> or simply <code>0</code>).</p>

<p>So this tests whether the first character is the end-of-string character. Or in other words: it tests whether the string is empty. That comparison result (1 if empty, 0 if non-empty) is returned.</p>
",0
5194700,5194648,0,"<p>It checks if the character pointed by <code>text</code> pointer equals <code>'\0'</code> character (string-terminating character).</p>
",0
5194703,5194648,0,"<p><code>*test</code> means the contents of the <code>test</code> pointer, which is a <code>char</code>.</p>

<p><code>*test == '\0'</code> just compares that character to the null character.</p>

<p><code>return *test == '\0'</code> means return the result of that comparison.</p>

<p>So basically, if <code>test</code> points to a null-character then <code>matchhere()</code> will return true, otherwise false.</p>
",0
5468630,5468580,0,"<p>how about... 
int *x;
int *y;
instead of int *x,*y;</p>
",0
5468645,5468580,0,"<p>Hi you increment your pointer address not value use <code>(*x)++ (*y)++</code></p>
",0
5468649,5468580,0,"<p>In your code you are accessing a pointer and incrementing a pointer. What you might wanted to do is this:</p>

<pre><code>void main() {
  int *x,*y;
  int a=23,b=56;
  x=&amp;a;
  y=&amp;b;
  printf(""%d\t%d"",*x,*y);
  (*x)++;
  (*y)++;
  printf(""\n%d\t%d"",*x,*y);
  return 0;
}
</code></pre>

<p>Notice the (*x)++ and (*y)++ to access the <em>value</em> of the pointer, because it is this, you want to increment. If you write x++ or y++ you increment the pointer itself, meaning you push the address on where it is pointing at forward. This leads in your case to undefined values.</p>
",2
5468657,5468580,11,"<p>There is <em>no</em> guarantee that your pointers are the same size as your integers so you realy shouldn't be using <code>%d</code> as the format specifier.</p>

<p>I've seen problems similar to this when people pass <code>long</code> variables to <code>printf</code> with a specifier for an <code>int</code>. Because the long was wider than the <code>int</code>, it confused <code>printf</code> regarding where things were on the stack.</p>

<p>You should be using <code>%p</code> for pointers. There are also numerous other problems with that code, standards-wise. Try the following as a starting point:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {
    int *x, *y;
    int a = 23, b = 56;

    x=&amp;a; y=&amp;b;
    printf (""%p  %p\n"", x, y);

    x++; y++;
    printf (""%p  %p\n"", x, y);

    return 0;
}
</code></pre>

<hr>

<p>Here's one <em>possible</em> explanation (thanks to the comment from Michael Burr):</p>

<p>Let's say your pointer are 32 bits and your integers are 16 bits and that you are on a little-endian architecture (like Intel).</p>

<p>Further, assume the address of <code>a</code> is <code>0x12345678</code> and the address of <code>b</code> is <code>0x1234567a</code>.</p>

<p>When you pass them to <code>printf</code>, you push two 32-bit values on the stack but <code>printf</code> only reads two 16-bit values since it's been told that with the <code>%d %d</code> format specifiers:</p>

<pre><code>       himem
      --------
    / | 0x12 |
push  | 0x34 |
   |  | 0x56 |
    \ | 0x78 |
      --------
    / | 0x12 | \ printf reads 0x1234
push  | 0x34 | /
   |  | 0x56 | \ printf reads 0x567a
    \ | 0x7a | /
      --------
       lomem
</code></pre>

<p>Then, when you increment both pointers and call <code>printf</code> again, you get:</p>

<pre><code>       himem
      --------
    / | 0x12 |
push  | 0x34 |
   |  | 0x56 |
    \ | 0x7a |
      --------
    / | 0x12 | \ printf reads 0x1234
push  | 0x34 | /
   |  | 0x56 | \ printf reads 0x567c
    \ | 0x7c | /
      --------
       lomem
</code></pre>

<p>So you can see in that scenario why it might look as if only one pointer had been incremented but the real problem is that you're not <em>printing</em> the pointers, rather you're printing the most significant half of one of them (which probably won't change) and the least significant half of that same one (which will change).</p>
",4
5468667,5468580,0,"<p>you're incrementing the <em>pointers</em>, not the values if that's any help.</p>

<p>I can't tell you more, since that source doesn't actually compile and gives you roughly the same warning I did :)</p>

<pre><code>#include&lt;stdio.h&gt;
int main(int argc, char *argv[]) {
        int *x,*y;
        int a=23,b=56;
        x=&amp;a;
        y=&amp;b;
        printf(""%d\t\t%d"",*x,*y);
        x++;
        y++;
        printf(""\n%d\t\t%d"",*x,*y);
        return 0;
}
</code></pre>

<p>that will compile, and shows the contents - on my compiler that results in the following output:</p>

<pre><code>23      56
1606415920      23
</code></pre>

<p>(I put the two '\t' per line to guarantee separation of values, this doesn't affect the rest of the code)</p>

<p>since I <em>assume</em> you want the code to increment <code>a</code> and <code>b</code> the code would be as follows:</p>

<pre><code>#include&lt;stdio.h&gt;
int main(int argc, char *argv[]) {
        int *x,*y;
        int a=23,b=56;
        x=&amp;a;
        y=&amp;b;
        printf(""%d\t\t%d"",*x,*y);
        (*x)++;
        (*y)++;
        printf(""\n%d\t\t%d"",*x,*y);
        return 0;
}
</code></pre>

<p>which prints:</p>

<pre><code>23      56
24      57
</code></pre>
",0
5468728,5468580,0,"<p>Please the program :</p>

<pre><code>#include&lt;stdio.h&gt;
void main() {
    int *x= NULL;
    int *y = NULL;
    int a=23,b=56;
    x=&amp;a;
    y=&amp;b;
    printf(""%x\t%x"",x,y);
    x++;
    y++;
    printf(""\n%x\t%x"",x,y);
}
</code></pre>

<p>I beleive it should be fine then.Only the values are intialized properly.</p>
",1
8260307,8259817,0,"<p>you could try something like this... i'd strongly recommend to use this only for debugging purpose!</p>

<pre><code>#define MAXMEMBLOCKS 10000

typedef struct {
    int size;
    void* ptr;
} memblock;

typedef struct {
    int totalSize;
    int current;
    memblock memblocks[MAXMEMBLOCKS];
} currentMemory;

currentMemory mem;

void *MyMalloc(int size) {
    if (mem.current &lt; MAXMEMBLOCKS) {
        mem.current += size;
        mem.memblocks[mem.current].size = size;
        mem.memblocks[mem.current].ptr = malloc(size);
        return mem.memblocks[mem.current++].ptr;
    } else {
        // you needed more memblocks than estimated
        return NULL;
    }
};

int MyFree(void *pointer) {
    int i;
    for (i = 0; i &lt; mem.current; i++) {
        if (mem.memblocks[i].ptr == pointer) {
            mem.totalSize -= mem.memblocks[i].size;
            free(mem.memblocks[i].ptr);
            mem.current--;
            return 0;
        }
    }
    // you tried to free a block wich hasn't been allocated through MyMalloc()
    return -1;
}
</code></pre>
",0
8259943,8259817,2,"<p>In C++, you could keep a global <code>std::map&lt;void*, std::size_t&gt;</code> around to track the size of each allocated block; your own allocator function would register the size when allocating, and the deallocation function would remove the entry. (Update: Or do as the linked question suggests and allocate a bit more memory and save the size there.)</p>

<p>The more fundamental problem is that this will probably only be of very limited use in a typical C++ program: Allocations there are done predominantly in two ways: 1) through explicit <code>new</code> expressions, which call <code>::operator new()</code>, which in turn (usually) calls <code>malloc()</code>, and 2) through <code>std::allocator&lt;T&gt;::allocate()</code>, which on many platforms is implemented in terms of <code>::operator new()</code>.</p>

<p>The problem is that you don't have control over the specifics of your platform. You can replace the global operator-new to use your own <code>MyMalloc()</code>, but the default <code>std::allocator</code> might use <code>malloc()</code> directly and thus not be affected by that.</p>

<p>A cleaner approach for debugging purposes is to use an external tool like <code>valgrind</code> to track heap usage. For permanent internal use, tracking the allocation sizes is going to cause a significant performance hit, too.</p>
",0
8259969,8259817,9,"<p>You could allocate few <em>extra</em> bytes more than asked, and store the size in the extra bytes, so that you could know the size later on, in <code>MyFree</code> function, with little calculation as:</p>

<pre><code>unsigned long int usedMemory = 0;

void *MyMalloc(int size)
{
  char *buffer = (char *) malloc(size + sizeof(int)); //allocate sizeof(int) extra bytes 
  if ( buffer == NULL) 
      return NULL; // no memory! 

  usedMemory += size ;      
  int *sizeBox = (int*)buffer;
  *sizeBox = size; //store the size in first sizeof(int) bytes!
  return buffer + sizeof(int); //return buffer after sizeof(int) bytes!
}

void MyFree(void *pointer)
{
   if (pointer == NULL)
       return; //no free

   char *buffer = (char*)pointer - sizeof(int); //get the start of the buffer
   int *sizeBox = (int*)buffer;
   usedMemory -= *sizeBox;
   free(buffer);
}
</code></pre>
",6
8259983,8259817,2,"<p>You could allocate memory and store its size in the allocated block (error checking omitted for brevity):</p>

<pre><code>unsigned int totalAlloc = 0;

void *MyAlloc(unsigned int size)
{
    void *p;
    totalAlloc += size;

    p = malloc(size + sizeof(int));
    *(int *) p = size;
    return (void *)(((int *) p) + 1)
}

void MyFree(void *ptr)
{
    ptr = (void *)(((int *) ptr) -1 );
    totalAlloc -= * (int *) ptr;
    free(ptr);
}
</code></pre>

<p>This code actually reserves more memory than requested in order to store the block's size in the (usually) first four bytes. This information can then be retrieved later on when you free the memory.</p>
",4
8260058,8259817,0,"<p>You need to manage a list of all malloc() you have done with pointer + size. Then you can search for the size in that list, and decrement it in free().</p>

<p>Check for example in that example how they are doing:
<a href=""http://developers.sun.com/solaris/articles/lib_interposers_code.html#malloc_interposer.c"" rel=""nofollow"">http://developers.sun.com/solaris/articles/lib_interposers_code.html#malloc_interposer.c</a></p>

<p>You might have other possibilities to track memory, like:</p>

<ul>
<li><a href=""http://valgrind.org/docs/manual/ms-manual.html"" rel=""nofollow"">Valgrind with massif tool</a> for tracking memory usage over time. You can even generate <a href=""http://wingolog.org/archives/2008/05/05/catching-memory-leaks-with-valgrinds-massif"" rel=""nofollow"">png output graphics</a></li>
<li>Interposed libraries. You can found some libraries that you can use by <code>LD_PRELOAD=thelib.so ./yourprogram</code>, and they will output some statistics like <a href=""http://www.canonware.com/jemalloc/"" rel=""nofollow"">jemalloc</a></li>
</ul>

<p>(A side note, please accept some answers to your question !)</p>
",0
7784790,7784758,29,"<p>Yes, C/C++ stores a multi-dimensional (rectangular) array as a contiguous memory area. But, your syntax is incorrect. To modify element <code>foo[0][1]</code>, the following code will work:</p>

<pre><code>*((int *)foo+1)=5;
</code></pre>

<p>The explicit cast is necessary, because <code>foo+1</code>, is the same as <code>&amp;foo[1]</code> which is not at all the same thing as <code>foo[0][1]</code>. <code>*(foo+1)</code> is a pointer to the fifth element in the flat memory area. In other words, <code>*(foo+1)</code> is basically <code>foo[1]</code> and <code>**(foo+1)</code> is <code>foo[1][0]</code>. Here is how the memory is laid out for some of your two dimensional array:</p>

<p><img src=""https://i.stack.imgur.com/73BTu.png"" alt=""enter image description here""></p>
",9
7785116,7784758,30,"<p>A two-dimensional array:</p>

<pre><code>int foo[5][4];
</code></pre>

<p>is nothing more or less than an array of arrays:</p>

<pre><code>typedef int row[4];   /* type ""row"" is an array of 4 ints */
row foo[5];           /* the object ""foo"" is an array of 5 rows */
</code></pre>

<p><em>There are no pointer objects here, either explicit or implicit.</em></p>

<p>Arrays are not pointers.  Pointers are not arrays.</p>

<p>What often causes confusion is that an array <em>expression</em> is, in most contexts, implicitly converted to a pointer to its first element.  (And a separate rule says that what looks like an array parameter declaration is really a pointer declaration, but that doesn't apply in this example.)  An array <em>object</em> is an array object; declaring such an object does not create any pointer objects.  Referring to an array object can create a pointer <em>value</em> (the address of the array's first element), but there is no pointer object stored in memory.</p>

<p>The array object <code>foo</code> is stored in memory as 5 contiguous elements, where each element is itself an array of 4 contiguous <code>int</code> elements; the whole thing is therefore stored as 20 contiguous <code>int</code> objects.</p>

<p>The indexing operator is defined in terms of pointer arithmetic; <code>x[y]</code> is equivalent to <code>*(x + y)</code>.  Typically the left operand is going to be either a pointer expression <em>or</em> an array expression; if it's an array expression, the array is implicitly converted to a pointer.</p>

<p>So <code>foo[x][y]</code> is equivalent to <code>*(foo[x] + y)</code>, which in turn is equivalent to <code>*(*(foo + x) + y)</code>.  (Note that no casts are necessary.)  Fortunately, you don't have to write it that way, and <code>foo[x][y]</code> is a lot easier to understand.</p>

<p>Note that you <em>can</em> create a data structure that can be accessed with the same <code>foo[x][y]</code> syntax, but where <code>foo</code> really is a pointer to pointer to int.  (In that case, the prefix of each <code>[]</code> operator is already a pointer expression, and doesn't need to be converted.)  But to do that, you'd have to declare <code>foo</code> as a pointer-to-pointer-to-int:</p>

<pre><code>int **foo;
</code></pre>

<p>and then allocate and initialize all the necessary memory.  This is more flexible than <code>int foo[5][4]</code>, since you can determine the number of rows and the size (or even existence) of each row dynamically.</p>

<p>Section 6 of the <a href=""http://c-faq.com/"" rel=""noreferrer"">comp.lang.c FAQ</a> explains this very well.</p>

<p><strong>EDIT:</strong></p>

<p>In response to Arrakis's comment, it's important to keep in mind the distinction between <em>type</em> and <em>representation</em>.</p>

<p>For example, these two types:</p>

<pre><code>struct pair { int x; int y;};
typedef int arr2[2];
</code></pre>

<p>very likely have the same representation in memory (two consecutive <code>int</code> objects), but the syntax to access the elements is quite different.</p>

<p>Similarly, the types <code>int[5][4]</code> and <code>int[20]</code> have the same memory layout (20 consecutive <code>int</code> objects), but the syntax to access the elements is different.</p>

<p>You <em>can</em> access <code>foo[2][2]</code> as <code>((int*)foo)[10]</code> (treating the 2-dimensional array as if it were a 1-dimensional array).  And sometimes it's useful to do so, but strictly speaking the behavior is undefined.  You can likely get away with it because most C implementations don't do array bounds-checking. On the other hand, optimizing compilers can <em>assume</em> that your code's behavior is defined, and generate arbitrary code if it isn't.</p>
",10
7787436,7784758,7,"<p>C arrays - even multi-dimensional ones - are contiguous, ie an array of type <code>int [4][5]</code> is structurally equivalent to an array of type <code>int [20]</code>.</p>

<p>However, these types are still incompatible according to C language semantics. In particular, the following code is in violation of the C standard:</p>

<pre><code>int foo[4][5] = { { 0 } };
int *p = &amp;foo[0][0];
int x = p[12]; // undefined behaviour - can't treat foo as int [20]
</code></pre>

<p>The reason for this is that the C standard is (probably intentionally) worded in a way which makes bounds-checking implementations possible: As <code>p</code> is derived from <code>foo[0]</code>, which has type <code>int [5]</code>, valid indices must be in range <code>0..5</code> (resp. <code>0..4</code> if you actually access the element).</p>

<p>Many other programming languages (Java, Perl, Python, JavaScript, ...) use jagged arrays to implement multi-dimensional arrays. This is also possible in C by using an array of pointers:</p>

<pre><code>int *bar[4] = { NULL };
bar[0] = (int [3]){ 0 };
bar[1] = (int [5]){ 1, 2, 3, 4 };
int y = bar[1][2]; // y == 3
</code></pre>

<p>However, jagged arrays are not contiguous, and the pointed-to arrays need not be of uniform size.</p>

<p>Because of implicit conversion of array expressions into pointer expressions, indexing jagged and non-jagged arrays looks identical, but the actual address calculations will be quite different:</p>

<pre><code>&amp;foo[1]    == (int (*)[5])((char *)&amp;foo + 1 * sizeof (int [5]))

&amp;bar[1]    == (int **)((char *)&amp;bar + 1 * sizeof (int *))

&amp;foo[1][2] == (int *)((char *)&amp;foo[1] + 2 * sizeof (int))
           == (int *)((char *)&amp;foo + 1 * sizeof (int [5]) + 2 * sizeof (int))

&amp;bar[1][2] == (int *)((char *)bar[1] + 2 * sizeof (int)) // no &amp; before bar!
           == (int *)((char *)*(int **)((char *)&amp;bar + 1 * sizeof (int *))
                      + 2 * sizeof (int))
</code></pre>
",0
5490930,5490909,5,"<p>""Segementation fault"" means that your program tried to access memory that it wasn't allowed to.  Your program has several pointer and initialization errors.</p>

<p>I think you want your array to be <code>char ch[10]</code>, not <code>char *ch[10]</code>.  You also need to change the <code>scanf()</code> call to match:  <code>scanf(""%s"", obj-&gt;ch);</code>.</p>

<p>The same goes for your <code>a</code> field.  It should probably not be a pointer, and you should pass a pointer to <code>scanf()</code>:</p>

<pre><code>scanf(""%d"", &amp;obj-&gt;a);
</code></pre>
",3
5490944,5490909,2,"<blockquote>
  <p>i get an SEGMENTATION FAULT (CORE DUMPED??) //What does it mean??</p>
</blockquote>

<p>A variable doing a memory access violation results segmentation fault.</p>

<pre><code>scanf(""%d"",obj-&gt;a);
</code></pre>

<p><code>int *a;</code> - struct member <code>a</code> is an uninitialized pointer but trying to take input on to the location it is pointing to. Causing you segmentation fault.</p>

<pre><code> obj-&gt;a = malloc(sizeof(int)) ;
</code></pre>

<p>Now you can take input for <code>a</code> pointing location.</p>

<pre><code> scanf(""%d"", &amp;(obj-&gt;a) );
</code></pre>

<hr>

<p>With the kind of input operations you perform, the struct definition need not need raw pointers -</p>

<pre><code>struct abc{
    int *a;         // Change this to int a; or make a point to a valid memory location
    char *ch[10];   // Change this to char ch[10]; or initialize it with pointers pointing to a valid memory locations
                    // and then take input on to pointer pointing location.
};
</code></pre>

<p>Note the difference between the two -</p>

<pre><code>int a  ;  // Can take input directly to ""a""
int *a ;  // First ""a"" must point to a valid memory location that can hold an int
          // Then, can take input to ""a"" pointing location
</code></pre>
",1
5490960,5490909,1,"<p>Expanding on Carl's answer: <code>char *ch[10]</code> creates an array of 10 pointers to a character. What you want is an array to 10 characters.</p>
",0
5490979,5490909,0,"<p>Your code invokes undefined behaviour.</p>

<p>You should have <code>char ch[10];</code> and use scanf with a preset width to avoid overflows</p>

<pre><code>scanf(""9%s"",&amp;obj-&gt;ch); 
</code></pre>

<p>More : <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/scanf/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstdio/scanf/</a></p>

<p>The struct is defined to have a pointer-to-int, which you never initialize, hence pointing to random location, hence writing to a memory place you do not own, hence <code>UB</code>. Either switch that to a local variable <code>int a</code> or <code>malloc()</code> an integer.</p>
",0
5500926,5500898,2,"<pre><code>int main()
{
    char str[10];
    int i=0;
    scanf(""%s"", str);
    while (str[i] != 0)
    {
        str[i] += -32;
            i++;
    }
    printf(""%s"", str);
    return 0;
}
</code></pre>

<p>and of course, you must check overflow of str...</p>
",0
5500942,5500898,5,"<ol>
<li><p>If you enter a string longer than 9 characters, <code>scanf()</code> will try to write past the end of your string buffer.</p></li>
<li><p>Your while-loop never terminates as you never change <code>i</code>.</p></li>
<li><p>You should use <code>""%c""</code> as format string in your <code>printf()</code> call, since you are wrting characters, not null-terminated strings.</p></li>
</ol>
",3
5500958,5500898,0,"<p>You better use <a href=""http://www.cplusplus.com/reference/clibrary/cctype/toupper/"" rel=""nofollow"">toupper</a></p>

<pre><code>/* toupper example */
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
int main ()
{
  int i=0;
  char str[]=""Test String.\n"";
  char c;
  while (str[i])
  {
    c=str[i];
    putchar (toupper(c));
    i++;
  }
  return 0;
}
</code></pre>
",0
5501094,5500898,1,"<p>There are few mistakes here:</p>

<ol>
<li><code>scanf(""%s"", &amp;str);</code> - since str is a pointer to char, you don't need to give its address, but <code>scanf(""%s"", str);</code>. (and as sven said, it's unsafe)</li>
<li><code>while (str[i] !=0)</code> this is an endless loop, you should increment <code>i</code> at the end of the while block.</li>
<li><p><code>str[i] += -32;</code> will modify any char you're at, you should check if this is a lower case any time, for example:</p>

<p>if (str[i] >= 'a' &amp;&amp; str[i] &lt;= 'z'){ 
         str[i] -=32;
    } //couldn't format this line for some reason....</p></li>
<li><p><code>printf(""%s"", str[i])</code> is again wrong way to use printf,  since <code>%s</code> expects to <code>char*</code>, and <code>str[i]</code> is a <code>char</code>. instead, use <code>printf(""%c"", str[i])</code> which expects a char</p></li>
</ol>
",0
5501239,5500898,2,"<p>As cprogrammer said</p>

<blockquote>
  <p>You better use toupper</p>

<pre><code>/* toupper example */
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
int main ()
{
  int i=0;
  char str[]=""Test String.\n"";
  char c;
  while (str[i])
  {
    c=str[i];
    putchar (toupper(c));
    i++;
  }
  return 0;
}
</code></pre>
</blockquote>

<p>But if not, and you want to do it your way</p>

<pre><code>int main()
{
    char str[10];
    int i=0;
    scanf(""%s"", &amp;str);
    while (str[i]!='\0' &amp;&amp; i&lt;10)  
    {// You forgot this: '\0' instead of 0 and also i&lt;10
        str[i] += -32;
        printf(""%c"", str[i]);//char, not string
        i++; //And this
    }
    return 0;
}
</code></pre>
",0
5502600,5501501,0,"<p>This code is fast and works fine.. hopes this helps for ur case.. Copy and paste into a file and test it.. </p>

<pre><code>#include &lt;stdio.h&gt;
main()
{
    char str[100];
    int len = 0;
    gets(str);
    len = strlen(str);
    int i = 0;
    while(str[i]!='\0')
    {
        if(str[i] == ' ')
        {
            memcpy(&amp;str[i], &amp;str[i+1], len - i);
            len--;
        }
        i++;
    }
    str[len] = '\0';
    printf(""O/P : %s\n"",str);
}
</code></pre>

<p>This works fine.. </p>
",0
5501597,5501501,1,"<p>you can use 2 pointers. I'm not familiar with C, so I suppose checking  str[i] ==0 means the end of a string.</p>

<pre><code>int main()
{
    char str[15];
    int i=0;
    int j=0;
    gets(str);
    while(str[i] !=0 &amp;&amp; str[j] !=0){
        while(str[j] == 32)
        {
            j++;
        }
        if ( str[j] ==0){
            break;
        }
        str[i] = str[j];
        i++;
    }
    str[strlen(i)] = '\0';
    printf(""%s"", str);
    return 0;
}
</code></pre>
",1
5501698,5501501,3,"<p>Well since you are using C trim is not an option.
First of all, what are your thoughts on the line:
str[i] = str[i++];
?
This is basically the same as
i++;</p>

<p>Now to the code:</p>

<pre><code> char *mystring, *read, *write;
 // mystring gehts filled with a null terminated string here
 read = mystring;
 write = mystring;
 while(*read != '\0') {
      if(*read == ' ') 
           read++;
      else 
           *write++ = *read++;
 }
 *write = '\0';
</code></pre>

<p>If you like to write to another String, just make write point to the location where you want it to be. Do not forget to check that you have enough room there ;)</p>
",0
5501727,5501501,0,"<p>What do you intend to happen in this conditional?</p>

<pre><code>  if(str[i] == 32)
        {
            str[i++] = str[i];
            str[i] = str[i++];
        }
</code></pre>

<p>What does actually happen? (hint: reread the section on i++)</p>

<p>-- pete</p>
",0
5502283,5501501,1,"<p>Several problems:</p>

<ol>
<li><p><strong>NEVER NEVER NEVER NEVER NEVER NEVER</strong> use <code>gets</code>. First of all, it's deprecated as of C99, and will be gone from the next revision of the standard.  Secondly, it <em>will</em> introduce a point of failure in your code (not <em>may</em> introduce, <strong>will</strong> introduce).  Instead of <code>gets(str)</code>, use <code>fgets(str, sizeof str, stdin)</code> instead.</p></li>
<li><p>Use character constants instead of numeric values, because all the world is not ASCII:<pre>
<code>if (str[i] == ' ') // not str[i] == 32</code>
</pre></p></li>
<li><p>Whitespace includes tabs, form feeds, returns, etc., not just spaces; instead of checking against individual values, use the <code>isspace()</code> library function.</p></li>
<li><p>The following lines are a problem: <pre>
<code>
str[i++] = str[i];
str[i] = str[i++];
</code>
</pre>  First of all, this should invoke undefined behavior; you're attempting to read and update an object more than once between sequence points.  Second, I'm not sure of the logic.  It looks like you're trying to swap elements, instead of just skipping over one.  </p></li>
<li><p>You're passing an integer value to <code>strlen</code>: that's not going to work.  It's going to interpret that integer value as an address (you should at least be getting a warning), with potentially bad results.  </p></li>
</ol>

<p>You can do this in a single loop with two array indices:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(void)
{
  char str[15];

  if (fgets(str, sizeof str, stdin) != NULL)
  {
    size_t r, w;

    printf(""Original: \""%s\""\n"", str);

    /**
     * str[r] is the element that we are reading; str[w]
     * is the element that we are writing
     */
    for (r = 0, w = 0; str[r] != 0; r++)
    {
      if (!isspace(str[r]))   // if str[r] is not a whitespace character
        str[w++] = str[r];    // write it to str[w]; note that we only
                              // advance w for non-whitespace chars
    }
    str[w] = 0; // add the 0 terminator at the end

    printf(""Stripped: \""%s\""\n"", str);
  }
  return 0;
}
</code></pre>

<p>Obviously, this alters the original string.  If you need to preserve the original input for some reason, you'll have to declare a second buffer to hold the modified string. </p>
",0
5533942,5533926,9,"<p>For <code>scanf()</code> you always read from standard input and for <code>fscanf()</code> you specify the file input stream.</p>

<p>Compare:</p>

<pre><code>int  scanf ( const char * format, ... );
int fscanf ( FILE * stream, const char * format, ... );
</code></pre>
",0
5533949,5533926,2,"<p>Just google it (emphasis mine):</p>
<blockquote>
<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/scanf/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/clibrary/cstdio/scanf/</a></p>
<pre><code>int  scanf ( const char * format, ... );
</code></pre>
<p>Read formatted data from <strong><em>stdin</em></strong></p>
</blockquote>
<p>And</p>
<blockquote>
<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fscanf/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/clibrary/cstdio/fscanf/</a></p>
<pre><code>int fscanf ( FILE * stream, const char * format, ... );
</code></pre>
<p>Read formatted data from <strong><em>stream</em></strong></p>
</blockquote>
",2
5533952,5533926,11,"<p><code>scanf()</code> is exactly identical to <code>fscanf()</code> with <code>stdin</code> as the first argument.</p>
",0
5533953,5533926,0,"<p>From the third paragraph of <code>fscanf(3)</code> manpage:</p>

<pre><code>   The scanf() function reads input from the standard input stream
   stdin, fscanf() reads input from the stream pointer stream, and
   sscanf() reads its input from the character string pointed to by
   str.
</code></pre>

<p>You might have been able to guess that from the <code>SYNOPSIS</code>:</p>

<pre><code>   int scanf(const char *format, ...);
   int fscanf(FILE *stream, const char *format, ...);
</code></pre>

<p>:)</p>
",0
5550126,5550036,0,"<p>You probably have some heap corruption going on. Without seeing code it's impossible to say.</p>
",2
5550247,5550036,5,"<p>This is the oldest error in the book, kind of.</p>

<p>You can't use a variable of type <code>char</code> to read characters (!), since the <code>EOF</code> constant doesn't fit.</p>

<p>You need:</p>

<pre><code>int C;
</code></pre>

<p>Also, the <code>while</code> condition looks scary, you are incrementing <code>X</code> in the loop, then checking the (new) position, is that properly initialized? You don't show how <code>Copy.Array</code> is set up before starting the loop.</p>

<p>I would suggest removing that altogether, it's very strange code.</p>

<p>In fact, I don't understand why you loop reading single characters at all, why not just use <code>fread()</code> to read as much as you need?</p>
",2
5550454,5550036,1,"<p>Firstly, unwind's answer is a valid point although I'm not sure whether it explains the issues you are seeing. </p>

<p>Secondly,</p>

<pre><code>printf(""%d %c\n"",C,C); //Remove/add this as necessary
</code></pre>

<p>might be a problem.  The <code>%d</code> and <code>%c</code> format specifiers expect an int to be the parameter, you are only passing a char.  Depending on your compiler, this might mean that they are too small.</p>

<hr>

<p>This is what I think the problem is:</p>

<p>How are you allocating Copy.Array?  Are you making sure all its elements are zeroed before you start?  If you malloc it (malloc just leaves whatever garbage was in the memory it returns) and an element just happens to contain <code>0xFF</code>, your loop will exit prematurely because your while condition tests Copy.Array[X] before you have placed a character in that location.</p>

<p>This is one of the few cases where I allow myself to put an assignment in a condition because the pattern</p>

<pre><code>int c;
while ((c = fgetc(fileStream)) != EOF)
{
    doSomethingWithC(c);
}
</code></pre>

<p>is really common</p>

<hr>

<p><strong>Edit</strong></p>

<p>Just read your ""Additionally"" comment.  I think it is highly likely you are overrunning your output buffer.  I think you should change your code to something like:</p>

<pre><code>    int X = 0; int C = 0; int I = 0;
    while(X &lt; arraySize &amp;&amp; (C = fgetc(Read)) != EOF)
    {
        Copy.Array[X] = C;
        printf(""%d %c\n"", (int)C, (int)C);
        X++;
    }
    printf(""\n"");
</code></pre>

<p>Note that I am assuming that you have a variable called <code>arraySize</code> that is set to the number of characters you can write to the array without overrunning it.  Note also, I am not writing the EOF to your array.</p>
",4
5550465,5550036,0,"<p>Not sure if this is your error but this code:</p>

<pre><code>C = fgetc(Read);
Copy.Array[X] = C;
if(C == EOF){break;}
</code></pre>

<p>Means you are adding the <code>EOF</code> value into your array - I'm pretty sure you don't want to do that, especially as your array is presumably <code>char</code> and <code>EOF</code> is <code>int</code>, so you'll actually end up with some other value in there (which could mess up later loops etc).</p>

<p>Instead I suggest you change the order so <code>C</code> is only put in the array once you know it is not <code>EOF</code>:</p>

<pre><code>C = fgetc(Read);
if(C == EOF){break;}
Copy.Array[X] = C;
</code></pre>
",2
5557151,5550036,0,"<p>Whilst this isn't what I'd call a 'complete' answer (as the bug remains), this does solve the 'observer effect' element: I found, for some reason, printf was somehow 'fixing' the code, and using std::cout seemed to (well, I can't say 'fix' the problem) prevent the observer effect happening. That is to say, use std::cout instead of printf (as printf is the origin of the observer effect).</p>

<p>It seems to me that printf does something in memory on a lower level that seems to partially correct what does indeed seem to be a memory allocation error.</p>
",0
5557153,5557076,1,"<p>If I get your question, please try this:</p>

<pre><code>system(""cls"");
</code></pre>

<p>and print a new text on the console.</p>

<p><strong>EDIT</strong>:</p>

<p>Also, to answer your second question, have a while loop and:</p>

<pre><code>use getch() found in conio.h
</code></pre>

<p>So that you need not wait for the enter key to be pressed as in the scanf.</p>
",2
5557171,5557076,3,"<p>Doing those console manipulations is dependent on the platform that you are using.  You will probably need a library to accomplish what you are trying to do.  See something like <a href=""http://pdcurses.sourceforge.net/"" rel=""nofollow"">this</a> which is cross platform, or the old conio library for DOS if you're on Windows.</p>
",2
5557190,5557076,4,"<p>Use the <code>\b</code> (backspace) character.</p>

<pre><code>printf(""Quick brown fox"");
int i;
for(i=0; i &lt; 9; i++)
{
    printf(""\b"");
}
printf(""green fox\n"");
</code></pre>

<p>I noticed that putting a <code>\n</code> on the first <code>printf()</code> messed up the output.</p>
",4
6284441,6283907,0,"<p>Try printing backspaces <code>""\b""</code></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt; /* sleep */

int main(void) {
  int k;

  printf(""Percentage completed: "");

  for (k = 0; k &lt; 100; k++) {
    printf(""%3d%%"", k);
    fflush(stdout);

    {  /* work */
      sleep(1);
    }

    printf(""\b\b\b\b"");
    fflush(stdout);
  }

  printf(""100%%\n"");
  return 0;
}
</code></pre>
",1
6283960,6283907,4,"<p>You can use the carriage return (<code>\r</code>) instead of the line feed (<code>\n</code>) to go back to the beginning of the current line... the next <code>printf()</code> will overwrite the previous one.</p>
",0
6283961,6283907,7,"<p>You can acheive a rough aproximation of this on the command line by using carriage return ( Assuming your command line handles those properly ).</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int spin (void) {
    int i = 0;
    for ( ; i &lt; 1000; i++ ) {
        printf(""%d\r"", i);
        sleep( 1 );
    }
    return 0;
}
</code></pre>
",1
6280417,6280335,2,"<p>Did not answer exactly what you asked,but ...
Tring to solve some Euler problems is a good way to familiar with the language features.</p>

<p><a href=""http://projecteuler.net/"" rel=""nofollow"">http://projecteuler.net/</a></p>
",1
6280494,6280335,0,"<p>There are multiple websites with numerous tutorials:</p>

<p><a href=""http://www.cprogramming.com/"" rel=""nofollow"">C programming</a></p>

<p><a href=""http://www.freeprogrammingresources.com/ctutor.html"" rel=""nofollow"">C tutor</a></p>

<p>Also, be sure to look into pointers:</p>

<p><a href=""http://pw1.netcom.com/~tjensen/ptr/pointers.htm"" rel=""nofollow"">something on pointers</a></p>

<p>Hope this helps</p>
",1
6280949,6280335,1,"<p>If you want examples of existing C projects, browse github/sourceforge.</p>

<p>I wonder though - why do you want to learn C? Seeing as you're new to C, I'm assuming you might actually mean C++.</p>

<p>What background are you coming from and what do you want to achieve? If you want to try some algorithms, pierr's answer is a good one to get used to any language. Also, if you're interested in learning the language detail/algorithms, avoid shiny UI temptation and stick with the command line.</p>

<p>If you're starting programming for the first time, glenn's answer is a good start.</p>

<p>If you're just interested in Windows application development, <a href=""http://msdn.microsoft.com/en-us/library/ff708696.aspx"" rel=""nofollow"">this</a> MS tutorial looks like a good start.</p>

<p>If you are moving from another language, look for a specific guide (e.g. <a href=""http://www.horstmann.com/ccj2/ccjapp3.html"" rel=""nofollow"">Java to C++</a>) to fill you in on the details quickly.</p>
",4
6118257,6118243,5,"<p>You have to send the <code>EOF</code> signal/character to the program. If you are running it from inside a terminal window, press <kbd>Ctrl</kbd>+<kbd>D</kbd>.</p>

<p>If you are piping from a file, like so:</p>

<pre><code>./my_program &lt; input_file_name
</code></pre>

<p>then it will work automagically.</p>
",1
6118259,6118243,1,"<p>Since it is checking for <code>EOF</code>, hit <code>Ctrl-D</code> in the terminal.</p>
",0
6118273,6118243,0,"<p>As others have mentioned, you have to press <kbd>control</kbd>-<kbd>d</kbd> (aka <code>^d</code>) but that only works <em>after you hit return</em>.  In other words you cannot type ""foo<kbd>control</kbd>-<kbd>d</kbd>"" and expect it to work.  ""foo<kbd>return</kbd><kbd>control</kbd>-<kbd>d</kbd>"" would work, though.</p>

<p>Also please note that K&amp;R is a fine fine book, but was written decades ago.  The counting algorithm presented only work on ASCII-ish input.  Wide characters (UTF-8, etc) would not be counted correctly.</p>

<p>Also also note, the example you quoted is using a floating point number for this counting.  There is little strictly wrong with this, but for speed and efficiency, most people would use unsigned ints, longs, or some other intergral datatype.  You are not likely to be reading ?th of a character!</p>
",0
6336603,6336576,2,"<p>You are comparing wether ptr1 points to the same address as ptr2 does (and reciprocally). That means, your option 2.</p>
",0
6336606,6336576,5,"<p>That compares the pointer values, which are addresses.</p>

<p>So <code>ptr1==ptr2</code> tests whether the two pointers point to the same address -- your #2.</p>

<p>You could express #1 -- comparing the addresses of the pointers themselves -- with <code>&amp;ptr1 == &amp;ptr2</code>, but here you know that that will be false.</p>
",0
6336611,6336576,0,"<p>You compare the actual pointers.</p>

<p>I am not sure from your phrasing what you actually want to do, but it is probably one of:</p>

<pre><code>if (*ptr1 == *ptr2) ...
</code></pre>

<p>or </p>

<pre><code>if (&amp;ptr1 == &amp;ptr2) ...
</code></pre>
",3
6336613,6336576,0,"<p>To compare what the pointers actually point towards, use:</p>

<pre><code>if(*ptr1 == *ptr2)...
</code></pre>
",0
6336621,6336576,0,"<p>When you declare</p>

<pre><code>  int *ptr1;
</code></pre>

<p>you're defining a variable (that has an address) that points to an integer.  You can get the address of that variable by taking the address (&amp;) of that variable, that is,</p>

<pre><code>&amp;ptr1
</code></pre>

<p>fundamentally, ptr1 will contain the address of a memory location (where an integer may be stored, if it point to a location where space has been allocated for such a thing).</p>

<p>Comparing the values of the ptr1 and ptr2 variables will tell you if they point at the same variable; comparing the dereferenced values of the ptr1 and ptr2 variables will tell you if the values they point at are the same.</p>
",0
6336631,6336576,0,"<p>2) the values of the pointers and therefore the addresses they point to.</p>
",0
6336633,6336576,0,"<p>To compare the values pointed to by the pointers:</p>

<ol>
<li>check if any of the pointers are NULL</li>
<li>Figure out what both pointers being NULL means in context</li>
<li>compare with <code>if (*ptr1 == *ptr2)</code></li>
</ol>

<p>To compare the addresses where the pointers are stored use:</p>

<pre><code>if ( &amp;ptr1 == &amp;ptr2 ) since these are the addresses of the pointers.
</code></pre>
",0
6339006,6336576,0,"<p>Any time you use have something in the form ""a==b"" you are comparing the contents of variable a to the contents of variable b.  In the case that a and b are pointers, their contents are the addresses of some data so a==b will return true if they point to the same location and false otherwise.</p>

<p>To compare the addresses of two variables you need to do &amp;a==&amp;b.</p>
",0
6280271,6280224,5,"<p><code>struct data *d</code> merely declares a pointer. You have not allocated this struct anywhere. You need to either <code>malloc</code> it or declare it just as <code>struct data d</code> on the stack or globally.</p>

<p>The former can be done like this:</p>

<pre><code>d = malloc(sizeof(struct data));
</code></pre>

<p>If you choose the latter, accessing <code>b</code> has to be written as <code>d.b</code>.</p>
",0
6280275,6280224,3,"<p>You are not allocating any memory for <code>d</code>. It likely points to an invalid memory area and so - segmentation fault.</p>

<p>You can solve this like so:</p>

<pre><code>struct data *d = malloc(sizeof(*d));
</code></pre>
",0
6280315,6280224,2,"<p>The problem is that you didn't allocate memory for a d pointer: <code>struct data *d;</code>. This lines only creates a pointer, it doesn't alloc memory for it. Please try the following code:</p>

<pre><code>int main()
{
    struct data *d = (struct data*)malloc(sizeof(struct data));
    int *ptr;
    int key=10000;
    d-&gt;b=&amp;key;
    ptr=(int *)d-&gt;b;
    printf(""%d\n"",*ptr);
    free(d);
}
</code></pre>
",1
6281235,6280224,3,"<p>You are getting segmentation fault at the line <code>d-&gt;b=&amp;key;</code> Note that you have <em>not</em> allocated any memory location to the structure variable <code>d</code>. So <code>d</code> contains some garbage value, and <code>d-&gt;b</code> it trying to use that garbage address to dereference the pointer and get the component <code>b</code>. Here is where you get the segfault. Either statically allocate the struct variable, or use <code>malloc</code> to dynamically allocate it.</p>

<pre><code>int main()
{
    struct data *d;
    int *ptr;

    /* Here you are allocating memory to the
     * pointer variable, which will be used to
     * point to the structure type data
     */
    d = malloc (sizeof (struct data)); 
    int key=10000;

    /* Now you can dereference the pointer 
     * and get any of the components of the
     * structure, because 'd' contains a valid
     * address.
     */ 
    d-&gt;b=&amp;key;

    ptr=(int *)d-&gt;b;
    printf(""%d\n"",*ptr);

    /* Good practice to free the memory location
     * you have allocated. Not freeing will lead to
     * memory leak in larger applications. After you 
     * free the memory location denoted by the address
     * stored in 'd', you will not be anymore access 
     * the contents of it.
     */
    free (d);

    /* d-&gt;b; or d-&gt;a; is no more possible at this point
     * as we have freed the memory pointed by 'd'
     */
}
</code></pre>

<p>Or you can use:</p>

<pre><code>int main()
{
    /* Not a pointer, statically allocated */
    struct data d;
    int *ptr;

    int key=10000;
    d.b=&amp;key;

    ptr=(int *)d.b;
    printf(""%d\n"",*ptr);
}
</code></pre>

<p>So, it is not the typecasting of <code>void *</code> to <code>int *</code> that causes the segfault. Its the illegal memory reference of the pointer variable which you have used but not allocated/initialized.</p>
",0
6370089,6370055,0,"<p>Handle everything as a string, then, see if you can convert them if you absolutely have to (like you may have to convert string to int for math operations).</p>

<p>Now, to find out if you can convert a string to an integer, you can use <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/"" rel=""nofollow"">atoi</a> which returns a zero upon failure.</p>
",2
6372515,6370055,0,"<p>I'll assume that the possible different data types are known (otherwise how can the server possibly handle them). Then you could use a union, e.g. something like:</p>

<pre><code>union dataU{
    struct datatype1S datatype1;
    struct datatype2S datatype2;
    ...
}
struct messageS {
    int typeId;
    union dataU data;
}
</code></pre>

<p>Then use the typeId to determine what member of the union to look at.</p>
",0
6371375,6370055,0,"<p>I'd suggest encoding the data.  <a href=""http://www.json.org/"" rel=""nofollow"">JSON</a> is generally suitable for this.  What are you using for your message queue - if you haven't already take a look at <a href=""http://www.zeromq.org/"" rel=""nofollow"">ZMQ</a>.</p>
",0
6333273,6333240,0,"<p>You can either return a <code>struct</code> that encapsulates the two values, or use two pointer parameters in which the function will store the values.</p>

<pre><code>typedef struct
{
    double height;
    int hits;
} BallParameters;


BallParameters insert()
{
    BallParameters ret;
    printf (""Give a value for height and number of hits"");
    scanf (""%f %d"",&amp;ret.height,&amp;ret.hits);
    return ret;
}

/* ~~~ or ~~~ */

void insert(double *height, int *hits)
{
    printf (""Give a value for height and number of hits"");
    scanf (""%f %d"",height,hits);
}
</code></pre>
",4
6333290,6333240,1,"<p>As an aside, the function you give returns nothing which is an error.</p>

<p>A function can have only a single return value.  If you want to return multiple values you can:</p>

<ol>
<li>Return a struct containing the values.</li>
<li>Pass the return values as parameters using pointers.</li>
</ol>

<p>An example of the option 2:</p>

<pre><code>void divmod(int a, int b, int *div, int *mod)
{
    *div = a/b;
    *mod = a%b;
}
</code></pre>

<p>Call the function like this:</p>

<pre><code>int div;
int mod;
divmod(666, 42, &amp;div, &amp;mod);
</code></pre>

<p>I intentionally chose a different example because I couldn't work out what you want to do with your <code>float</code> return value.</p>
",2
6333325,6333240,0,"<p>For a homework assignment, they'll probably be happy with you passing in the parameters to fill in.</p>

<pre><code>void insert(int* h, int* n)
{
   ...
   scanf(""%d %d"", h, n);
}

// called like:
// int height, number;
// insert(&amp;height, &amp;number);
</code></pre>

<p>But you can always get tricky and return a struct</p>

<pre><code>typedef struct
{
  int h;
  int n;
} S;

S insert()
{
  S s;
  ...
  scanf (""%d %d"" , &amp;s.h, &amp;s.n);
  return s;
}
</code></pre>
",6
7684219,7684204,5,"<p>This is an initialization of a static array of <code>struct option</code> elements. This structure will have four elements (<code>char*</code>, other, a pointer, and a character), and these are the values. Note the array is ended with a NULL value to prevent searchs throug it to pass beyond end, and note also how some constants relevant for the struct are used.</p>
",0
7684234,7684204,1,"<p>It defines a static (that is, invisible in other .c modules) constant array, named <code>long_options</code>, of structures of type <code>option</code>. Individual lines like <code>{""all"", no_argument, NULL, 'a'}</code> are elements of type <code>struct option</code>. I see no problem here.</p>
",0
7684246,7684204,1,"<p>This code is creating an array of struct option. Each row contains the value of an item in that array.</p>

<p>From the code I assume struct option something like this </p>

<pre><code>struct option
{
    const char * option_name;
    enum argument_type  argument;
    void * pointer; //not enough context
    char short_option;
};
</code></pre>
",0
7677339,7677185,1,"<p>If you want your code to sleep for 4 seconds then you can use sleep(4) to do that and it will almost certainly not consume CPU like your wait() function does.  Note that sleep(4) will block execution of the remainder of your single-threaded program and if you do not want that then you will need something more sophisticated, but I suspect sleep(4) will suffice here.</p>

<p>Also, your code will eventually exhaust the stack because printwow() calls timer_func() which calls printwow() which calls timer_func() etc. etc. ad infinitum in a recursive loop.  You need to fix this, probably by using a for/while loop rather than recursion.</p>
",1
7677208,7677185,4,"<p>Yes, it's your tight loop in <code>Wait()</code>. You probably have a dual-core machine, so you're using 100% of one core. Use <code>sleep()</code> instead.</p>
",0
7677219,7677185,21,"<p>Your loop:</p>

<pre><code>while (clock() &lt; endwait) {}
</code></pre>

<p>is <a href=""http://en.wikipedia.org/wiki/Busy_waiting"" rel=""noreferrer"">busy-waiting</a>. You are basically having the following conversation with the CPU.</p>

<p>""Are we there yet?""  ""No.""</p>

<p>""Are we there yet?""  ""No.""</p>

<p>""Are we there yet?""  ""No.""</p>

<p>(repeat several gazillion times)</p>

<p>""Are we there yet?""  ""Yes.""</p>

<p>You are better off using a function like <code>sleep()</code> which tells the CPU to tell you when it's ready.</p>
",4
7677223,7677185,1,"<p>because the loop</p>

<pre><code>while (clock() &lt; endwait) {}
</code></pre>

<p>cpu has to check the value of clock() all the time, use sleep() instead of your own code.</p>
",0
7677228,7677185,2,"<p><code>timer_func()</code> and <code>printwow()</code> call each other forever. You'll eventually get a stack overflow.</p>
",1
7677230,7677185,3,"<p>Use some built-in sleep function, that does not use processor cycles to ""wait"", like <code>sleep</code> from <code>unistd.h</code>.</p>
",0
6623949,6623910,2,"<p>Two things:</p>

<ul>
<li>You can't put spaces inside the angle brackets when including a system header (e.g. <code>#include &lt;stdio.h&gt;</code></li>
<li>You need a prototype for <code>call()</code></li>
</ul>
",1
7800215,7800188,2,"<p>Change</p>

<pre><code>dbg = fopen(dbg, ""w+"");
</code></pre>

<p>to</p>

<pre><code>dbg = fopen(name, ""w+"");
</code></pre>

<p>Also, if you want to read the file, change it then write it, you shouldn't open it with <code>""w+""</code>. You should first open the file with <code>""r""</code>, read from it, do whatever change you want, then <code>fclose</code> it, then again open it but this time with <code>""w""</code> so that you write over it. After you have opened it in <code>""w""</code>rite mode, you can write the modified buffer back into the file.</p>
",0
7800275,7800188,2,"<p>You opened a file for writing and then you try to read from it.</p>

<p>Check the return value of <code>fread</code> and all the other calls.</p>
",0
6935865,6935824,5,"<p>No -- all three arguments are pointers. There is no way to reliably distinguish between them.</p>
",0
7163500,7163396,2,"<p>First, you should fill up <code>used</code> with 0 characters to ensure it is always properly terminated:</p>

<pre><code>memset(used, 0, 14);
</code></pre>

<p>Then, add a new character to it like this:</p>

<pre><code>used[i] = input;
</code></pre>

<p>Also, as @Fred noted, you should use the proper format specifier <code>%s</code> in the <code>printf</code> call.</p>
",0
7163512,7163396,1,"<p>As already said here you should fill used with zeros, something like <code>used[14] = {0};</code></p>

<p>Then I think the line <code>printf(""\n\n The following characters are allready used: %c "", used);</code> should be <code>printf(""\n\n The following characters are allready used: %s "", used);</code>, notice the ""%s"" you're printing a string.</p>
",1
7163596,7163396,0,"<p>If you know the maximum size, you can create a buffer with that maximum size, and then append to it. In this case you do know the maximum size, as there are only 26 letters in the alphabet. So the maximum length of the string is the length of whatever text you put at the beginning, plus 26 times the number of characters you'll use for each letter. I count 18 in the initial string. Remember to add one for the null byte terminator at the end. For each letter you have the letter, a comma, and a space, so the max length is 18 + 26*3 + 1 = 97 if I did the arithmetic right.</p>

<p>So you could write something like:</p>

<pre><code>char used[96];
strcpy(used,""You already used: "");
int first=TRUE;
... whatever other work ...
... let's say we get the character in variable ""c"" ...
// Add comma after previous entry, but only if not first
if (!first)
{
  first=FALSE;
  strcat(used,"", "");
}
// turn character into a string
char usedchar[2];
usedchar[0]=c;
usedchar[1]='\0';
// Append to working string
strcat(used,usedchar);
</code></pre>
",1
8372276,8371968,2,"<p>The char[] has been explained, but I think the most important thing to remember in the int example is that:</p>

<pre><code>int x;  // memory space created for an int
int *ip;  // pointer
ip = &amp;x;  // assigning a pointer
x = 5; // assigning a value to the memory space referenced by x
</code></pre>

<p>Whereas</p>

<pre><code>int *ip; // this is a pointer - no space in memory has been allocated for an int
*ip = 5;  // hence why you can't assign a value here - there's nowhere to put it!
</code></pre>
",2
8372879,8371968,1,"<p>the compiler does not allocate memory for a string neither for an integer if you declare <code>char*</code> or <code>int*</code>. </p>

<p>the memory is allocated only if you specify it : <code>char* p1 = ""string"";</code> for a const string or <code>char* p2 = (char*)malloc(5*sizeof(char));</code> for a normal dynamically allocated array of char which can be modified or <code>char p3[10];</code> for array of char which can be use as a string.  </p>

<p>then you can fill p2 and p3 with the string you want : <code>strcpy (p2 , ""Hi"");</code> </p>

<p>you cannot not do the same with p1 : <code>strcpy(p1 , ""Hi"");</code> will certainly crash the program.</p>

<p>then when you write <code>int* ip;</code>,<code>int x;</code>, <code>p=&amp;x;</code> :  you allocate the memory for the int with the line <code>int x;</code>.</p>

<p>yo can allocate the memory also with <code>int *ip2 = (int*)malloc(sizeof(int))</code> then you have not to associate the pointer with a variable. the int can be changed with <code>*ip2 = 3;</code>.</p>
",0
7453820,7451165,3,"<p>The solution is a somewhat strange version of the Sieve of Eratosthenes.  It looks like the writer was trying to prematurely optimise by doing some sneaky tricks with the loop counter, <code>i</code>.</p>

<p>I suggest that you work through the first few iterations of the loop on paper to get a feel for what the code is doing.</p>
",0
7371689,7371678,3,"<p>You have declared i to be defined in a separate file, but haven't linked to an external file.</p>

<p>If you remove the extern keyword, this will work as you expect.</p>
",0
7371695,7371678,1,"<blockquote>
  <p>The extern keyword declares a variable or function and specifies that
  it has external linkage (its name is visible from files other than the
  one in which it's defined). When modifying a variable, extern
  specifies that the variable has static duration (it is allocated when
  the program begins and deallocated when the program ends). The
  variable or function may be defined in another source file, or later
  in the same file. Declarations of variables and functions at file
  scope are external by default.</p>
</blockquote>

<p>Where is <code>i</code> defined?</p>

<p>Try this.</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
  int i;
  i = 20;
  printf(""%d\n"", sizeof(i));
  return 0;
}
</code></pre>
",1
7371702,7371678,0,"<p>The ""extern"" keyword is you telling the compiler ""This variable is define somewhere else, just use it and trust me that it will be available at linking time.""</p>
",0
8455320,8455310,5,"<p>I assure you that your code is running in order. Probably, <code>printf</code> prints to a buffer which is not cleared by your program so the output from <code>dir</code> goes straight to the terminal while the output from <code>printf</code> waits until the output buffer is cleared which occurs when your program exits. The buffer is also cleared when you print a newline <code>\n</code> which is why printing <code>""%s\n""</code> appears to work but just <code>""%s""</code> appears to fail.</p>
",0
8455324,8455310,3,"<p><code>\n</code> signals that the buffer can be printed on some systems (like Solaris). That's a feature, not a bug.</p>
",0
8455329,8455310,1,"<p>You should write</p>

<pre><code>printf(""%s\n"", ""asdf"");
fflush (NULL); // or at least fflush(stdout)
system (""dir"");
</code></pre>

<p>but that is still very ugly and non portable code. To traverse a directory, did you consider <a href=""http://linux.die.net/man/3/readdir"" rel=""nofollow"">readdir</a> &amp; friends?</p>
",2
8455352,8455310,1,"<p>For sure, the order is always correct. I suppose you think execution order is incorrect as the console shows the text lines generated by ""dir"" before the printf output. But that doesn't mean that one is done before the other. I don't know how the printing buffer works in your system, but for sure there are a buffer of text that each process send to any output pipe.</p>

<p>My guess is that text buffers to output streams are flushed immediately when a CR char appears. So, if you don't write the '\n' char, the process that runs ""dir"" (a os system process your are invoking) flushes its output before your process does.</p>
",0
8455378,8455310,2,"<p>The reason it <em>looks</em> like <code>dir</code> is being executed before the <code>printf</code> is because <code>printf</code> prints to <code>stdout</code> and <code>stdout</code> buffers its output - your program <em>is</em> being executed in the correct order. <code>stdout</code>'s buffer is <em>usually</em> flushed when (as I mentioned in <a href=""https://stackoverflow.com/questions/8061019/why-doesnt-this-c-programme-print-the-first-printf-statement/8061104"">this answer</a>):</p>

<ul>
<li>A newline (<code>'\n'</code>) is to be printed</li>
<li>You read in from <code>stdin</code></li>
<li><code>fflush()</code> is called on it</li>
</ul>

<p>That is why adding a newline (<code>'\n'</code>) the string being printed causes <code>""asdf""</code> to be printed before the output of <code>dir</code>.</p>

<p>Other alternatives to flushing the buffer include printing to <code>stderr</code>, which isn't buffered, or using <code>setbuf(stdout, NULL);</code> to disable buffering altogether for <code>stdout</code>. Neither of these two approaches seem necessary for your situation, however.</p>
",0
7774782,7774770,6,"<p><code>char p[] = ""house"";</code></p>

<p><code>""house""</code> is a string literal stored in a read only location, but, p is an array of chars placed on stack in which <code>""house""</code> is copied.</p>

<p>However, in <code>char *p = ""house"";</code>, <code>p</code> actually points to the read-only location which contains the string literal ""house"", thus modifying it is UB.</p>

<p>A note from the standard <code>6.7.8 Initialization</code></p>

<blockquote>
  <p>14 An array of character type may be initialized by a character string
  literal, optionally enclosed in braces. Successive characters of the
  character string literal (including the terminating null character if
  there is room or if the array is of unknown size) initialize the
  elements of the array.</p>
</blockquote>

<p>So you basically have an array of characters. It should not be so difficult or puzzle you in understanding how this array gets modified if you have used arrays of <code>ints</code>, <code>floats</code> etc.</p>
",0
7774788,7774770,0,"<pre><code>char *p = ""house"";  // const char* p = ""house"";
</code></pre>

<p>String literal <code>""house""</code> resides in read only location and cannot be modified. Now what you are doing is -</p>

<pre><code>*p = 'm' ; // trying to modify read-only location; Missed the dereferencing part
</code></pre>

<p>Now,</p>

<pre><code>char p[] = ""house""; 
</code></pre>

<p><code>""house""</code> is copied to the array p. So, it's contents are modifiable. So, this actually works.</p>

<pre><code>p[0] = 'm'; // assigning `m` at 0th index.
</code></pre>
",3
7774794,7774770,0,"<p>When you use char *p=""house"" - the compiler collects all the ""house"" strings and puts them in one read only space.</p>

<p>When you use char p[]=""house"" the compiler creates space for the string as an array in the local scope.</p>

<p>Basic difference is that 1000's of pointer could share the first one (which is why you cannot modify) and the second is local to the scope - so as long as it stays the same size it is modifiable.</p>
",1
8400527,8400412,5,"<p>Try unsigned long long. It should work.</p>
",3
8214743,8214698,2,"<p><code>void *v[]</code> is an <em>array</em> of pointers. So <code>v[i] = v[j];</code> assigns an element at index <code>j</code> to the position <code>i</code> which does not involve dereferencing the pointer but merely copying the pointer(address).</p>
",3
8214744,8214698,0,"<p>You need to typecast the pointer into desired type. For instance, void* x; (int*)x - suddenly it's a pointer to int.</p>
",0
8230444,8230356,9,"<p>Eliminate the type-punning, and replace it with something that isn't fragile in the face of aliasing:</p>

<pre><code>#include &lt;string.h&gt;

inline float __HTON_F32(float x) {
    int i;
    memcpy(&amp;i, &amp;x, sizeof x);
    i = HTON_I32(i);
    memcpy(&amp;x, &amp;i, sizeof x);
    return x;
}
</code></pre>

<p>Reasonable optimizing compilers will lower the <code>memcpy</code> calls, and generate equivalent (sometimes better) code to what you get from type-punning.</p>

<p>Another common solution you will see involves unions.  All of these solutions assume that <code>sizeof(int) == sizeof(float)</code>.  You may want to add an assert to that effect.</p>
",0
8231118,8230356,1,"<p>You can use unions for type-punning, which takes care of possible alignment and aliasing issues (C99:TC3 explicitly mentions that this is indeed legal):</p>

<pre><code>#include &lt;stdint.h&gt;

inline float __HTON_F32(float x) {
    union { float as_float; int32_t as_int; } value = { x };
    value.as_int = HTON_I32(value.as_int);
    return value.as_float;
}
</code></pre>
",9
8455066,8455045,5,"<p>This is the <strong><a href=""http://en.wikipedia.org/wiki/Indent_style#K.26R_style"" rel=""nofollow"">K &amp; R style</a></strong> of function definition. It is non standard compliant and hence the compiler error in gcc(which is used by Ideone).</p>

<p>It works for you in visual studio because visual studio allows you to change the default coding style.</p>
",0
8455133,8455045,8,"<p>The function is written in K&amp;R style, and your prototype for it is incorrect.  In fact, there are other problems too...</p>

<pre><code>#include &lt;stdio.h&gt;
void main() {
    extern int fun(float);
    int a=fun(3.5);
    printf(""%d"",a);
}

int fun(aa)
float aa;
{
    return ((int)aa);
}
</code></pre>

<p>The return type of <code>main()</code> is <code>int</code>, at least in Standard C.  Your print statement should include a newline.</p>

<p>Your prototype would be OK if the function <code>fun()</code> were written with a prototype:</p>

<pre><code>int fun(float aa) { ... }
</code></pre>

<p>However, the function is written in K&amp;R style, and therefore the function expects to be passed a <code>double</code> which it will convert to <code>float</code>:</p>

<pre><code>int fun(double aa_arg) { float aa = aa_arg; ... }
</code></pre>

<p>In K&amp;R C, all <code>float</code> values were passed as <code>double</code>.  This is why you are getting garbage; you are lying (probably unwittingly) to your compiler, and it is getting its own back by doing GIGO on you.</p>

<p>FWIW: GCC 4.6.1 refuses to compile your code (even without any warning settings).  It complains:</p>

<pre><code>f1.c: In function ¡®main¡¯:
f1.c:2: warning: return type of ¡®main¡¯ is not ¡®int¡¯
f1.c: At top level:
f1.c:9: error: conflicting types for ¡®fun¡¯
f1.c:3: error: previous declaration of ¡®fun¡¯ was here
</code></pre>

<p>You can fix this in a number of different ways:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    extern int fun(float);
    int a = fun(3.5);
    printf(""%d\n"", a);
    return(0);
}

int fun(float aa)
{
    return ((int)aa);
}
</code></pre>

<p>Or:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    extern int fun(double);
    int a = fun(3.5);
    printf(""%d\n"", a);
    return(0);
}

int fun(double aa)
{
    return ((int)aa);
}
</code></pre>

<p>Or:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    extern int fun(double);
    int a = fun(3.5);
    printf(""%d\n"", a);
    return(0);
}

int fun(aa)
double aa;
{
    return ((int)aa);
}
</code></pre>

<p>Or:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    extern int fun(double);
    int a = fun(3.5);
    printf(""%d\n"", a);
    return(0);
}

int fun(aa)
float aa;
{
    return ((int)aa);
}
</code></pre>

<p>Or:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    extern int fun();
    int a = fun(3.5);
    printf(""%d\n"", a);
    return(0);
}

int fun(aa)
float aa;
{
    return ((int)aa);
}
</code></pre>

<p>I believe these are all correct and they all should compile without warnings (unless you ask the compiler to complain about old style (K&amp;R) function definitions, etc).  </p>

<p>With GCC set to rather fussy, I get the warnings:</p>

<pre><code>/usr/bin/gcc -g -std=c99 -Wall -Wextra -Wmissing-prototypes -Wstrict-prototypes -Wold-style-definition f2.c -o f2  
f2.c:12: warning: no previous prototype for ¡®fun¡¯
/usr/bin/gcc -g -std=c99 -Wall -Wextra -Wmissing-prototypes -Wstrict-prototypes -Wold-style-definition f3.c -o f3  
f3.c:12: warning: no previous prototype for ¡®fun¡¯
/usr/bin/gcc -g -std=c99 -Wall -Wextra -Wmissing-prototypes -Wstrict-prototypes -Wold-style-definition f4.c -o f4  
f4.c:12: warning: function declaration isn¡¯t a prototype
f4.c: In function ¡®fun¡¯:
f4.c:13: warning: old-style function definition
/usr/bin/gcc -g -std=c99 -Wall -Wextra -Wmissing-prototypes -Wstrict-prototypes -Wold-style-definition f5.c -o f5  
f5.c:12: warning: function declaration isn¡¯t a prototype
f5.c: In function ¡®fun¡¯:
f5.c:13: warning: old-style function definition
/usr/bin/gcc -g -std=c99 -Wall -Wextra -Wmissing-prototypes -Wstrict-prototypes -Wold-style-definition f6.c -o f6  
f6.c: In function ¡®main¡¯:
f6.c:5: warning: function declaration isn¡¯t a prototype
f6.c: At top level:
f6.c:12: warning: function declaration isn¡¯t a prototype
f6.c: In function ¡®fun¡¯:
f6.c:13: warning: old-style function definition
</code></pre>
",1
8298120,8298098,6,"<ul>
<li>Create the file.</li>
<li>Write bytes to it, until you've written the size you want.</li>
<li>Close file.</li>
</ul>

<p>The loop should be all of about 2 lines of code.<br>
What difficulties are you encountering?</p>
",4
8298168,8298098,0,"<ul>
<li>create the file</li>
<li>seek to the desired size</li>
<li>write 0 bytes</li>
<li>close the file.</li>
</ul>
",0
8465197,8465172,2,"<p>You will need to check every character of the input to determine if they are digits or not:</p>

<pre><code>for(int i = 0; i &lt; strlen(hours); i++)
{
   if(!isDigit(hours[i])) { printf(""invalid time\n""); break; }
}
</code></pre>
",2
8465204,8465172,2,"<p><code>isdigit</code> is only checking a single character; I suspect that you're looking at strings (although this isn't clear in your question).  I'm not sure whether there is library function that would do it for you, but you could use a function like:</p>

<pre><code>int isnumeric(char *p)
{
   while (*p)
   {
       if ( ! isdigit(p))
           return 0;
       p++;
   }
   return 1;
}
</code></pre>
",0
8465211,8465172,0,"<p>isdigit(X) return true if ( 0 &lt;= X &lt;= 9 ) in other words X is a digit not only a number.</p>

<p>what you want is reading the input into a string, and check if this string is a number and then convert it to a number using atoi(string).</p>

<p>Good Luck (:</p>
",0
8387124,8387087,9,"<p>String literals are static, i.e. the memory used to hold the characters <code>Lorem</code> is not used to hold anything else for the duration of the program. Thus, returning an address to such a string is safe.</p>

<p>This is the same as doing</p>

<pre><code>const char* myfunction(void)
{
  return ""Lorem"";
}
</code></pre>

<p>which is perfectly fine and a common thing to do, for instance when mapping <code>enum</code> values to symbolic strings:</p>

<pre><code>typedef enum { Error_FileNotFound, Error_OutOfMemory, Error_PrinterOnFire } ErrorCode;

const char * error_code_to_string(ErrorCode error)
{
  switch(errorCode)
  {
  case Error_FileNotFound:
    return ""Error_FileNotFound"";
  case Error_OutOfMemory:
    return ""Error_OutOfMemory"";
  case Error_PrinterOnFire:
    return ""Error_PrinterOnFire"";
  return ""Unknown error"";
  }
}
</code></pre>

<p>Code like this is often (in practice) made way harder to read by making it more DRY, using macros to implement the <code>case</code> statements.</p>
",1
8387214,8387087,2,"<p>""Lorem"" is static. as you can see, you never defined him in the code.</p>

<p>If you would have done:</p>

<pre><code>char[6] d;
</code></pre>

<p>and you would copy there the value and try to return it you would have a problem</p>
",0
8455125,8455099,3,"<p>Since you are passing the address of array to the function <code>allocate_struct_array</code></p>

<p>You need:</p>

<pre><code>*array = malloc(length * sizeof(struct record *));
</code></pre>

<p>And in the calling function you need to declare <code>data_array</code> as:</p>

<pre><code>struct record * data_array;
</code></pre>

<p>and pass its address as:</p>

<pre><code>allocate_struct_array(&amp;data_array, num_lines);
</code></pre>
",4
4250606,4250250,2,"<p>My suggestion would be to allocate a buffer of sufficient size:</p>

<pre><code>char name_buffer [ 80 ];
</code></pre>

<p>Generally, most names (at least common English names) will be less than 80 characters in size. If you feel that you may need more space than that, by all means allocate more.</p>

<p>Keep a counter variable to know how many characters you have already read into your buffer:</p>

<pre><code>int chars_read = 0; /* most compilers will init to 0 for you, but always good to be explicit */
</code></pre>

<p>At this point, read character by character with <code>fgetc()</code> until you either hit the end of file marker or read 80 characters (79 really, since you need room for the null terminator). Store each character you've read into your buffer, incrementing your counter variable.</p>

<pre><code>while ( ( chars_read &lt; 80 ) &amp;&amp; ( !feof( stdin ) ) ) {
  name_buffer [ chars_read ] = fgetc ( stdin );
  chars_read++;
}
if ( chars_read &lt; 80 )
  name_buffer [ chars_read ] = '\0'; /* terminating null character */
</code></pre>

<p>I am assuming here that you are reading from <code>stdin</code>. A more complete example would also check for errors, verify that the character you read from the stream is valid for a person's name (no numbers, for example), etc. If you try to read more data than for which you allocated space, print an error message to the console.</p>

<p>I understand wanting to maintain as small a buffer as possible and only allocate what you need, but part of learning how to program is understanding the trade-offs in code/data size, efficiency, and code readability. You can <code>malloc</code> and <code>realloc</code>, but it makes the code much more complex than necessary, and it introduces places where errors may come in - NULL pointers, array index out-of-bounds errors, etc. For most practical cases, allocate what should suffice for your data requirements plus a small amount of breathing room. If you find that you are encountering a lot of cases where the data exceeds the size of your buffer, adjust your buffer to accommodate it - that is what debugging and test cases are for.</p>
",0
4250331,4250250,2,"<p>You could read the string character by character until you find the end, then rewind to the beginning, allocate a buffer of the right size, and re-read it into that, but unless you are on a tiny embedded system this is probably silly.  For one thing, the fgetc, fread, etc functions create buffers in the O/S anyway.</p>

<p>You could allocate a temporary buffer that's large enough, use a length limited read (for safety) into that, and then allocate a buffer of the precise size to copy it into.  You probably want to allocate the temporary buffer on the stack rather than via malloc, unless you think it might exceed your available stack space.</p>

<p>If you are writing single threaded code for a tiny system you can allocate a scratch buffer on startup or statically, and re-use it for many purposes - but be really carefully your usage can't overlap!</p>

<p>Given the implementation complexity of most systems, unless you really research how things work it's entirely possible to write memory optimized code that actually takes more memory than doing things the easy way.  Variable initializations can be another surprisingly wasteful one.</p>
",0
4250338,4250250,5,"<p><strong>Don't</strong> worry about wasting 100 or 1000 bytes which is likely to be long enough for all names.
I'd probably just put the buffer that you're reading into on the stack.</p>

<p><strong>Do</strong> worry about writing over the end of the buffer.  i.e. buffer overrun.  Program to prevent that!</p>

<p>When you come to store the name into your structure you can malloc a buffer to store the name the exact length you need (don't forget to add an extra byte for the null terminator).</p>

<p>But if you really must store names of any length at all then you could do it with realloc.
i.e. Allocate a buffer with malloc of some size say 50 bytes.</p>

<p>Then when you need more space, use realloc to increase it's length.  Increase the length in blocks of say 50 bytes and keep track with an int on how big it is so that you know when you need to grow it again.  At some point, you will have to decide how long that buffer is going to be, because it can't grow indefinitely.</p>
",1
2207247,2207214,12,"<p>It'd have to be the minimum value of an integer, i.e. 0x80000000 if it's 32-bits, because that's the only number other than zero that remains the same when negated.</p>

<pre><code>#include &lt;stdio.h&gt;

main()
{
 int data = 0x80000000;
 if(data!=0 &amp;&amp; data==-data)
 {
  printf(""AMAZING"");
 }
}
</code></pre>

<p>Result:</p>

<pre><code>AMAZING
</code></pre>

<p>As Richard Pennington correctly pointed out, this works because of the <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""noreferrer"">two's complement</a> representation of negative numbers. The largest representable positive number is one smaller in absolute value than the largest negative number, so if you try to negate the largest negative number it overflows an int and wraps around, giving back the same number.</p>

<p>For computers that use <a href=""http://en.wikipedia.org/wiki/Signed_number_representations#Ones.27_complement"" rel=""noreferrer"">one's complement</a>, every representable number's negative value can also be represented without overflow so this puzzle doesn't have a solution.</p>
",8
2207252,2207214,7,"<p>It depends on the size of an integer and how integers are implemented, but on a two's complement machine with 2 byte integers, the answer is -32768.</p>
",1
5619527,5619462,-1,"<p>Once you add 1 to INT_MAX, you end up getting INT_MIN (i.e. overflow).<br>
In C, there's no reliable way to test for overflow, because all 32 bytes are used to represent the integer (and not a state flag). You can only test to see if the number you get will be within a valid range, as in your link.</p>

<p>You'll get answers suggesting that you can test <code>if (c &lt; a)</code>, however note that you could overflow the value of a and/or b to the point where their addition forms a number greater than a (but still overflown)</p>
",0
5619756,5619462,4,"<p>If you're adding unsigned numbers then you can do this</p>

<pre><code>c = a+b;
if (c&lt;a) {
  // you'll get here if and only if overflow has occurred
}
</code></pre>

<p>and you may even find that your compiler is clever enough to implement it by checking the overflow or carry flag instead of doing an extra comparison. For instance, I just fed this to <code>gcc -O3 -S</code>:</p>

<pre><code>unsigned int foo() {
  unsigned int x=g(), y=h();
  unsigned int z = x+y;
  return z&lt;0 ? 0 : z;
}
</code></pre>

<p>and got this for the key bit of the code:</p>

<pre><code>movl  $0,   %edx
addl  %ebx, %eax
cmovb %edx, %eax
</code></pre>

<p>where you'll notice there's no extra comparison instruction.</p>
",4
5619820,5619462,0,"<p>You can base a solution on a particular feature of the C language. According to the specification, when you add two <strong>unsigned</strong> ints, ""the result value is congruent to the modulo 2^n of the true result"" (""C - A reference manual"" by Harbison and Steele). This means you can use some simple arithmetic checks to detect overflow:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    unsigned int a, b, c;
    char *overflow;

    a = (unsigned int)-1;
    for (b = 0; b &lt; 3; b++) {
        c = a + b;
        overflow = (a &lt; b) ? ""yes"" : ""no"";
        printf(""%u + %u = %u, %s overflow\n"", a, b, c, overflow);
    }

    return 0;
}
</code></pre>
",0
5620046,5619462,1,"<p>If you are working with unisigned numbers, then if <code>a &lt;= UINT_MAX</code>, <code>b &lt;= UINT_MAX</code>, and <code>a + b &gt;= UINT_MAX</code>,  then <code>c = (a + b) % UINT_MAX</code> will always be smaller than <code>a</code> and <code>b</code>. And this is the only case where this can happen.</p>

<p>So you can detect overflow this way.</p>

<pre><code>int add_return_overflow(unsigned int a, unsigned int b, unsigned int* c) {
    *c = a + b;
    return *c &lt; a &amp;&amp; *c &lt; b;
}
</code></pre>
",0
5620270,5619462,0,"<p>Just xor MSB of both operands and result. Result of this operation is overflow flag.</p>

<p>But that will not show you if result is correct or not. (it might be correct result even whit overflow) for instance 3 + (-1) is 2 whit overflow.</p>

<p>In order to figure that using signed arithmetic you need to check if both operdas were same sign (xor of MSB).</p>
",0
5620357,5619462,4,"<p>Contrary to popular belief, an <code>int</code> overflow results in undefined behavior. This means that once <code>a + b</code> overflows, it doesn't make sense to use this value (or do anything else, for that matter). The wrap-around is just what most machines happen to do in case of overflow, but they might as well explode.</p>

<p>To check whether an <code>int</code> overflow will occur when adding two non-negative integers <code>a</code> and <code>b</code>, you can do the following:</p>

<pre><code>if (INT_MAX - b &lt; a) {
        /* int overflow when evaluating a+b */
}
</code></pre>

<p>This is due to the fact that if <code>a + b &gt; INT_MAX</code>, then <code>INT_MAX - b &lt; a</code>, but <code>INT_MAX - b</code> can not overflow.</p>

<p>You will have to pay special attention to the case where <code>b</code> is negative, which is left as an exercise for the reader  ;)</p>

<p><br />
Regarding your actual goal: 1024-bit numbers suffer from exactly the same overall issues as 32-bit numbers. It might be more promising to choose a completely different approach, e.g. representing numbers as, say, linked lists of digits, using a very large base B. Usually, B is chosen such that <code>B = sqrt(INT_MAX)</code>, so multiplication of digits doesn't overflow the machine's <code>int</code> type.</p>

<p>This way, you can represent arbitrarily large numbers, where ""arbitrary"" means ""only limited by the amount of main memory available"".</p>
",0
5620974,5619462,1,"<p>Information which maybe useful in this subject :</p>

<ol>
<li><a href=""http://www.informit.com/content/images/0321335724/samplechapter/seacord_ch05.pdf"" rel=""nofollow"">Secure Coding in C and C++</a></li>
<li><a href=""http://blogs.msdn.com/b/michael_howard/archive/2006/02/02/523392.aspx"" rel=""nofollow"">IntSafe library</a></li>
</ol>
",0
